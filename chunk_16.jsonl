{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _delete_version(self, symbol, version_num, do_cleanup=True):\n        version = self._versions.find_one({'symbol': symbol, 'version': version_num})\n        if not version:\n            logger.error(\"Can't delete %s:%s as not found in DB\" % (symbol, version_num))\n            return\n        # If the version is pointed to by a snapshot, then can't delete\n        if version.get('parent', None):\n            for parent in version['parent']:\n                snap_name = self._snapshots.find_one({'_id': parent})\n                if snap_name:\n                    snap_name = snap_name['name']\n                logger.error(\"Can't delete: %s:%s as pointed to by snapshot: %s\" % (symbol, version['version'],\n                                                                                    snap_name))\n                return\n        self._versions.delete_one({'_id': version['_id']})\n        # TODO: for FW pointers, if the above statement fails, they we have no way to delete the orphaned segments.\n        #       This would be possible only via FSCK, or by moving the above statement at the end of this method,\n        #       but with the risk of failing to delelte the version catastrophically, and ending up with a corrupted v.\n        if do_cleanup:\n            cleanup(self._arctic_lib, symbol, [version['_id']], self._versions,\n                    shas_to_delete=tuple(bson.binary.Binary(s) for s in version.get(FW_POINTERS_REFS_KEY, [])),\n                    pointers_cfgs=(get_fwptr_config(version), ))", "response": "Delete the version of a particular symbol from the historical collection."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef delete(self, symbol):\n        logger.info(\"Deleting data item: %r from %r\" % (symbol, self._arctic_lib.get_name()))\n        # None is the magic sentinel value that indicates an item has been deleted.\n        sentinel = self.write(symbol, None, prune_previous_version=False, metadata={'deleted': True})\n        self._prune_previous_versions(symbol, 0)\n\n        # If there aren't any other versions, then we don't need the sentinel empty value\n        # so delete the sentinel version altogether\n        snapped_version = self._versions.find_one({'symbol': symbol,\n                                                   'metadata.deleted': {'$ne': True}})\n        if not snapped_version:\n            self._delete_version(symbol, sentinel.version)\n        assert not self.has_symbol(symbol)", "response": "Delete all versions of the item from the current library which aren t currently part of some snapshot."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate an audit entry for the current version of the entry.", "response": "def _write_audit(self, user, message, changed_version):\n        \"\"\"\n        Creates an audit entry, which is much like a snapshot in that\n        it references versions and provides some history of the changes made.\n        \"\"\"\n        audit = {'_id': bson.ObjectId(),\n                 'user': user,\n                 'message': message,\n                 'symbol': changed_version.symbol\n                 }\n        orig_version = changed_version.orig_version.version\n        new_version = changed_version.new_version.version\n        audit['orig_v'] = orig_version\n        audit['new_v'] = new_version\n        # Update the versions to contain the audit\n        mongo_retry(self._versions.update_many)({'symbol': changed_version.symbol,\n                                                 'version': {'$in': [orig_version, new_version]}\n                                                 },\n                                                {'$addToSet': {'parent': audit['_id']}})\n        # Create the audit entry\n        mongo_retry(self._audit.insert_one)(audit)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef snapshot(self, snap_name, metadata=None, skip_symbols=None, versions=None):\n        # Ensure the user doesn't insert duplicates\n        snapshot = self._snapshots.find_one({'name': snap_name})\n        if snapshot:\n            raise DuplicateSnapshotException(\"Snapshot '%s' already exists.\" % snap_name)\n\n        # Create a snapshot version document\n        snapshot = {'_id': bson.ObjectId()}\n        snapshot['name'] = snap_name\n        snapshot['metadata'] = metadata\n\n        skip_symbols = set() if skip_symbols is None else set(skip_symbols)\n\n        if versions is None:\n            versions = {sym: None for sym in set(self.list_symbols()) - skip_symbols}\n\n        # Loop over, and snapshot all versions except those we've been asked to skip\n        for sym in versions:\n            try:\n                sym = self._read_metadata(sym, read_preference=ReadPreference.PRIMARY, as_of=versions[sym])\n                # Update the parents field of the version document\n                mongo_retry(self._versions.update_one)({'_id': sym['_id']},\n                                                       {'$addToSet': {'parent': snapshot['_id']}})\n            except NoDataFoundException:\n                # Version has been deleted, not included in the snapshot\n                pass\n\n        mongo_retry(self._snapshots.insert_one)(snapshot)", "response": "Creates a snapshot of the specified version of the specified symbol."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndelete a named snapshot", "response": "def delete_snapshot(self, snap_name):\n        \"\"\"\n        Delete a named snapshot\n\n        Parameters\n        ----------\n        symbol : `str`\n            The snapshot name to delete\n        \"\"\"\n        snapshot = self._snapshots.find_one({'name': snap_name})\n        if not snapshot:\n            raise NoDataFoundException(\"Snapshot %s not found!\" % snap_name)\n\n        # Remove the snapshot Id as a parent of versions\n        self._versions.update_many({'parent': snapshot['_id']},\n                                   {'$pull': {'parent': snapshot['_id']}})\n\n        self._snapshots.delete_one({'name': snap_name})"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nruns a consistency check on this VersionStore library.", "response": "def _fsck(self, dry_run):\n        \"\"\"\n        Run a consistency check on this VersionStore library.\n        \"\"\"\n        # Cleanup Orphaned Chunks\n        self._cleanup_orphaned_chunks(dry_run)\n        # Cleanup unreachable SHAs (forward pointers)\n        self._cleanup_unreachable_shas(dry_run)\n        # Cleanup Orphaned Snapshots\n        self._cleanup_orphaned_versions(dry_run)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nremoves any chunks who have parent pointers to missing versions.", "response": "def _cleanup_orphaned_chunks(self, dry_run):\n        \"\"\"\n        Fixes any chunks who have parent pointers to missing versions.\n        Removes the broken parent pointer and, if there are no other parent pointers for the chunk,\n        removes the chunk.\n        \"\"\"\n        lib = self\n        chunks_coll = lib._collection\n        versions_coll = chunks_coll.versions\n\n        logger.info(\"ORPHANED CHUNK CHECK: %s\" % self._arctic_lib.get_name())\n        for symbol in chunks_coll.distinct('symbol'):\n            logger.debug('Checking %s' % symbol)\n            # Be liberal with the generation time.\n            gen_time = dt.now() - timedelta(days=1)\n            parent_id_constraint = {'$lt': bson.ObjectId.from_datetime(gen_time)}\n\n            # For each symbol, grab all 'real' versions\n            versions = set(versions_coll.find({'symbol': symbol,\n                                               '_id': parent_id_constraint}).distinct('_id'))\n            # Using aggregate so we can unwind, and pull out 'parent', where 'parent' is older than a day.\n            parents = chunks_coll.aggregate([{'$match': {'symbol': symbol}},\n                                             {'$project': {'parent': True}},\n                                             {'$unwind': '$parent'},\n                                             {'$match': {'parent': parent_id_constraint}},\n                                             {'$group': {'_id': '$parent'}},\n                                             ])\n            parent_ids = set([x['_id'] for x in parents])\n\n            leaked_versions = sorted(parent_ids - versions)\n            if len(leaked_versions):\n                logger.info(\"%s leaked %d versions\" % (symbol, len(leaked_versions)))\n            for x in leaked_versions:\n                chunk_count = mongo_count(chunks_coll, filter={'symbol': symbol, 'parent': x})\n                logger.info(\"%s: Missing Version %s (%s) ; %s chunks ref'd\" % (symbol,\n                                                                               x.generation_time,\n                                                                               x,\n                                                                               chunk_count\n                                                                               ))\n                if versions_coll.find_one({'symbol': symbol, '_id': x}) is not None:\n                    raise Exception(\"Error: version (%s) is found for (%s), but shouldn't be!\" %\n                                    (x, symbol))\n            # Now cleanup the leaked versions\n            if not dry_run:\n                # This is now able to handle safely symbols which have both forward and legacy/parent pointers\n                cleanup(lib._arctic_lib, symbol, leaked_versions, versions_coll)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _cleanup_orphaned_versions(self, dry_run):\n        lib = self\n        versions_coll = lib._collection.versions\n        snapshots_coll = lib._collection.snapshots\n\n        logger.info(\"ORPHANED SNAPSHOT CHECK: %s\" % self._arctic_lib.get_name())\n\n        # Be liberal with the generation time.\n        gen_time = dt.now() - timedelta(days=1)\n        parent_id_constraint = {'$lt': bson.ObjectId.from_datetime(gen_time)}\n\n        # For each symbol, grab all 'real' snapshots and audit entries\n        snapshots = set(snapshots_coll.distinct('_id'))\n        snapshots |= set(lib._audit.distinct('_id'))\n        # Using aggregate so we can unwind, and pull out 'parent', where 'parent' is older than a day.\n        parents = versions_coll.aggregate([{'$project': {'parent': True}},\n                                           {'$unwind': '$parent'},\n                                           {'$match': {'parent': parent_id_constraint}},\n                                           {'$group': {'_id': '$parent'}},\n                                           ])\n        parent_ids = set([x['_id'] for x in parents])\n\n        leaked_snaps = sorted(parent_ids - snapshots)\n        if len(leaked_snaps):\n            logger.info(\"leaked %d snapshots\" % (len(leaked_snaps)))\n        for x in leaked_snaps:\n            ver_count = mongo_count(versions_coll, filter={'parent': x})\n            logger.info(\"Missing Snapshot %s (%s) ; %s versions ref'd\" % (x.generation_time,\n                                                                          x,\n                                                                          ver_count\n                                                                          ))\n            if snapshots_coll.find_one({'_id': x}) is not None:\n                raise Exception(\"Error: snapshot (%s) is found, but shouldn't be!\" %\n                                (x))\n            # Now cleanup the leaked snapshots\n            if not dry_run:\n                versions_coll.update_many({'parent': x},\n                                          {'$pull': {'parent': x}})", "response": "Remove any versions who have parent pointers to missing snapshots."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef enable_parallel_lz4(mode):\n    global ENABLE_PARALLEL\n    ENABLE_PARALLEL = bool(mode)\n    logger.info(\"Setting parallelisation mode to {}\".format(\"multi-threaded\" if mode else \"single-threaded\"))", "response": "Enables or disables parallel LZ4 compression."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting the size of the compression workers thread pool.", "response": "def set_compression_pool_size(pool_size):\n    \"\"\"\n    Set the size of the compression workers thread pool.\n    If the pool is already created, it waits until all jobs are finished, and then proceeds with setting the new size.\n\n    Parameters\n    ----------\n        pool_size : `int`\n            The size of the pool (must be a positive integer)\n\n    Returns\n    -------\n    `None`\n    \"\"\"\n    pool_size = int(pool_size)\n    if pool_size < 1:\n        raise ValueError(\"The compression thread pool size cannot be of size {}\".format(pool_size))\n\n    global _compress_thread_pool\n    if _compress_thread_pool is not None:\n        _compress_thread_pool.close()\n        _compress_thread_pool.join()\n    _compress_thread_pool = ThreadPool(pool_size)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncompress an array of strings by using a thread pool.", "response": "def compress_array(str_list, withHC=LZ4_HIGH_COMPRESSION):\n    \"\"\"\n    Compress an array of strings\n\n    Parameters\n    ----------\n        str_list: `list[str]`\n            The input list of strings which need to be compressed.\n        withHC: `bool`\n            This flag controls whether lz4HC will be used.\n\n    Returns\n    -------\n    `list[str`\n    The list of the compressed strings.\n    \"\"\"\n    global _compress_thread_pool\n\n    if not str_list:\n        return str_list\n\n    do_compress = lz4_compressHC if withHC else lz4_compress\n\n    def can_parallelize_strlist(strlist):\n        return len(strlist) > LZ4_N_PARALLEL and len(strlist[0]) > LZ4_MINSZ_PARALLEL\n\n    use_parallel = (ENABLE_PARALLEL and withHC) or can_parallelize_strlist(str_list)\n\n    if BENCHMARK_MODE or use_parallel:\n        if _compress_thread_pool is None:\n            _compress_thread_pool = ThreadPool(LZ4_WORKERS)\n        return _compress_thread_pool.map(do_compress, str_list)\n\n    return [do_compress(s) for s in str_list]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef decompress_array(str_list):\n    global _compress_thread_pool\n\n    if not str_list:\n        return str_list\n\n    if not ENABLE_PARALLEL or len(str_list) <= LZ4_N_PARALLEL:\n        return [lz4_decompress(chunk) for chunk in str_list]\n\n    if _compress_thread_pool is None:\n        _compress_thread_pool = ThreadPool(LZ4_WORKERS)\n    return _compress_thread_pool.map(lz4_decompress, str_list)", "response": "Decompress a list of strings\n   "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _split_arrs(array_2d, slices):\n    if len(array_2d) == 0:\n        return np.empty(0, dtype=np.object)\n\n    rtn = np.empty(len(slices) + 1, dtype=np.object)\n    start = 0\n    for i, s in enumerate(slices):\n        rtn[i] = array_2d[start:s]\n        start = s\n    rtn[-1] = array_2d[start:]\n    return rtn", "response": "Split array_2d into lists of arrays."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef checksum(symbol, doc):\n    sha = hashlib.sha1()\n    sha.update(symbol.encode('ascii'))\n    for k in sorted(iter(doc.keys()), reverse=True):\n        v = doc[k]\n        if isinstance(v, six.binary_type):\n            sha.update(doc[k])\n        else:\n            sha.update(str(doc[k]).encode('ascii'))\n    return Binary(sha.digest())", "response": "Checksum the passed in dictionary"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef cleanup(arctic_lib, symbol, version_ids, versions_coll, shas_to_delete=None, pointers_cfgs=None):\n    pointers_cfgs = set(pointers_cfgs) if pointers_cfgs else set()\n    collection = arctic_lib.get_top_level_collection()\n    version_ids = list(version_ids)\n\n    # Iterate versions to check if they are created only with fw pointers, parent pointers (old), or mixed\n    # Keep in mind that the version is not yet inserted.\n    all_symbol_pointers_cfgs = _get_symbol_pointer_cfgs(symbol, versions_coll)\n    all_symbol_pointers_cfgs.update(pointers_cfgs)\n\n    # All the versions of the symbol have been created with old arctic or with disabled forward pointers.\n    # Preserves backwards compatibility and regression for old pointers implementation.\n    if all_symbol_pointers_cfgs == {FwPointersCfg.DISABLED} or not all_symbol_pointers_cfgs:\n        _cleanup_parent_pointers(collection, symbol, version_ids)\n        return\n\n    # All the versions of the symbol we wish to delete have been created with forward pointers\n    if FwPointersCfg.DISABLED not in all_symbol_pointers_cfgs:\n        _cleanup_fw_pointers(collection, symbol, version_ids, versions_coll,\n                             shas_to_delete=shas_to_delete, do_clean=True)\n        return\n\n    # Reaching here means the symbol has versions with mixed forward pointers and legacy/parent pointer configurations\n    _cleanup_mixed(symbol, collection, version_ids, versions_coll)", "response": "This method cleans up chunks from a version store and returns the version store that was created."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _define_compat_pickle_load():\n    if pd.__version__.startswith(\"0.14\"):\n        return pickle.load\n    return functools.partial(pickle_compat.load, compat=True)", "response": "Factory function to initialise the correct Pickle load function based on the Pandas version."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nanalyzing the versions of a given symbol in a version store.", "response": "def analyze_symbol(l, sym, from_ver, to_ver, do_reads=False):\n    \"\"\"\n    This is a utility function to produce text output with details about the versions of a given symbol.\n    It is useful for debugging corruption issues and to mark corrupted versions.\n    Parameters\n    ----------\n    l : `arctic.store.version_store.VersionStore`\n        The VersionStore instance against which the analysis will be run.\n    sym : `str`\n        The symbol to analyze\n    from_ver : `int` or `None`\n        The lower bound for the version number we wish to analyze. If None then start from the earliest version.\n    to_ver : `int` or `None`\n        The upper bound for the version number we wish to analyze. If None then stop at the latest version.\n    do_reads : `bool`\n        If this flag is set to true, then the corruption check will actually try to read the symbol (slower).\n    \"\"\"\n    logging.info('Analyzing symbol {}. Versions range is [v{}, v{}]'.format(sym, from_ver, to_ver))\n    prev_rows = 0\n    prev_n = 0\n    prev_v = None\n\n    logging.info('\\nVersions for {}:'.format(sym))\n    for v in l._versions.find({'symbol': sym, 'version': {'$gte': from_ver, '$lte': to_ver}},\n                              sort=[('version', pymongo.ASCENDING)]):\n        n = v.get('version')\n\n        is_deleted = v.get('metadata').get('deleted', False) if v.get('metadata') else False\n\n        if is_deleted:\n            matching = 0\n        else:\n            spec = {'symbol': sym, 'parent': v.get('base_version_id', v['_id']), 'segment': {'$lt': v.get('up_to', 0)}}\n            matching = mongo_count(l._collection, filter=spec) if not is_deleted else 0\n\n        base_id = v.get('base_version_id')\n        snaps = ['/'.join((str(x), str(x.generation_time))) for x in v.get('parent')] if v.get('parent') else None\n\n        added_rows = v.get('up_to', 0) - prev_rows\n\n        meta_match_with_prev = v.get('metadata') == prev_v.get('metadata') if prev_v else False\n\n        delta_snap_creation = (min([x.generation_time for x in v.get('parent')]) - v['_id'].generation_time).total_seconds() / 60.0 if v.get('parent') else 0.0\n\n        prev_v_diff = 0 if not prev_v else v['version'] - prev_v['version']\n\n        corrupted = not is_deleted and (is_corrupted(l, sym, v) if do_reads else fast_is_corrupted(l, sym, v))\n\n        logging.info(\n            \"v{: <6} \"\n            \"{: <6} \"\n            \"{: <5} \"\n            \"({: <20}):   \"\n            \"expected={: <6} \"\n            \"found={: <6} \"\n            \"last_row={: <10} \"\n            \"new_rows={: <10} \"\n            \"append count={: <10} \"\n            \"append_size={: <10} \"\n            \"type={: <14} {: <14} \"\n            \"base={: <24}/{: <28} \"\n            \"snap={: <30}[{:.1f} mins delayed] \"\n            \"{: <20} \"\n            \"{: <20}\".format(\n                n,\n                prev_v_diff,\n                'DEL' if is_deleted else 'ALIVE',\n                str(v['_id'].generation_time),\n                v.get('segment_count', 0),\n                matching,\n                v.get('up_to', 0),\n                added_rows,\n                v.get('append_count'),\n                v.get('append_size'),\n                v.get('type'),\n                'meta-same' if meta_match_with_prev else 'meta-changed',\n                str(base_id),\n                str(base_id.generation_time) if base_id else '',\n                str(snaps),\n                delta_snap_creation,\n                'PREV_MISSING' if prev_n < n - 1 else '',\n                'CORRUPTED VERSION' if corrupted else '')\n        )\n        prev_rows = v.get('up_to', 0)\n        prev_n = n\n        prev_v = v\n\n    logging.info('\\nSegments for {}:'.format(sym))\n    for seg in l._collection.find({'symbol': sym}, sort=[('_id', pymongo.ASCENDING)]):\n        logging.info(\"{: <32}  {: <7}  {: <10} {: <30}\".format(\n            hashlib.sha1(seg['sha']).hexdigest(),\n            seg.get('segment'),\n            'compressed' if seg.get('compressed', False) else 'raw',\n            str([str(p) for p in seg.get('parent', [])])\n        ))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef is_safe_to_append(l, sym, input_v):\n    input_v = l._versions.find_one({'symbol': sym, 'version': input_v}) if isinstance(input_v, int) else input_v\n    return not _fast_check_corruption(l._collection, sym, input_v,\n                                      check_count=True, check_last_segment=True, check_append_safe=True)", "response": "Tests whether the symbol is safe to append to a version store."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef is_corrupted(l, sym, input_v):\n    # If version is just a number, read the version document\n    input_v = l._versions.find_one({'symbol': sym, 'version': input_v}) if isinstance(input_v, int) else input_v\n    if not _fast_check_corruption(l._collection, sym, input_v,\n                                  check_count=True, check_last_segment=True, check_append_safe=False):\n        try:\n            # Done with the fast checks, proceed to a full read if instructed\n            l.read(sym, as_of=input_v['version'])\n            return False\n        except Exception:\n            pass\n    return True", "response": "Checks if a version of a given symbol is corrupted."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconvert object arrays of strings to numpy string arrays", "response": "def _convert_types(self, a):\n        \"\"\"\n        Converts object arrays of strings to numpy string arrays\n        \"\"\"\n        # No conversion for scalar type\n        if a.dtype != 'object':\n            return a, None\n\n        # We can't infer the type of an empty array, so just\n        # assume strings\n        if len(a) == 0:\n            return a.astype('U1'), None\n\n        # Compute a mask of missing values. Replace NaNs and Nones with\n        # empty strings so that type inference has a chance.\n        mask = pd.isnull(a)\n        if mask.sum() > 0:\n            a = a.copy()\n            np.putmask(a, mask, '')\n        else:\n            mask = None\n\n        if infer_dtype(a, skipna=False) == 'mixed':\n            # assume its a string, otherwise raise an error\n            try:\n                a = np.array([s.encode('ascii') for s in a])\n                a = a.astype('O')\n            except:\n                raise ValueError(\"Column of type 'mixed' cannot be converted to string\")\n\n        type_ = infer_dtype(a, skipna=False)\n        if type_ in ['unicode', 'string']:\n            max_len = max_len_string_array(a)\n            return a.astype('U{:d}'.format(max_len)), mask\n        else:\n            raise ValueError('Cannot store arrays with {} dtype'.format(type_))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef docify(self, df):\n        dtypes = {}\n        masks = {}\n        lengths = {}\n        columns = []\n        data = Binary(b'')\n        start = 0\n\n        arrays = []\n        for c in df:\n            try:\n                columns.append(str(c))\n                arr, mask = self._convert_types(df[c].values)\n                dtypes[str(c)] = arr.dtype.str\n                if mask is not None:\n                    masks[str(c)] = Binary(compress(mask.tostring()))\n                arrays.append(arr.tostring())\n            except Exception as e:\n                typ = infer_dtype(df[c], skipna=False)\n                msg = \"Column '{}' type is {}\".format(str(c), typ)\n                logging.info(msg)\n                raise e\n\n        arrays = compress_array(arrays)\n        for index, c in enumerate(df):\n            d = Binary(arrays[index])\n            lengths[str(c)] = (start, start + len(d) - 1)\n            start += len(d)\n            data += d\n\n        doc = SON({DATA: data, METADATA: {}})\n        doc[METADATA] = {COLUMNS: columns,\n                         MASK: masks,\n                         LENGTHS: lengths,\n                         DTYPE: dtypes\n                         }\n\n        return doc", "response": "Convert a Pandas DataFrame to SON."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndecoding a Pymongo SON object into a Pandas DataFrame", "response": "def objify(self, doc, columns=None):\n        \"\"\"\n        Decode a Pymongo SON object into an Pandas DataFrame\n        \"\"\"\n        cols = columns or doc[METADATA][COLUMNS]\n        data = {}\n\n        for col in cols:\n            # if there is missing data in a chunk, we can default to NaN\n            # and pandas will autofill the missing values to the correct length\n            if col not in doc[METADATA][LENGTHS]:\n                d = [np.nan]\n            else:\n                d = decompress(doc[DATA][doc[METADATA][LENGTHS][col][0]: doc[METADATA][LENGTHS][col][1] + 1])\n                # d is ready-only but that's not an issue since DataFrame will copy the data anyway.\n                d = np.frombuffer(d, doc[METADATA][DTYPE][col])\n\n                if MASK in doc[METADATA] and col in doc[METADATA][MASK]:\n                    mask_data = decompress(doc[METADATA][MASK][col])\n                    mask = np.frombuffer(mask_data, 'bool')\n                    d = ma.masked_array(d, mask)\n            data[col] = d\n\n        # Copy into\n        return pd.DataFrame(data, columns=cols, copy=True)[cols]"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _create_key_manager(self, get_match_fuzzy, set_match_fuzzy,\n                            get_enable_vi_bindings, set_enable_vi_bindings,\n                            get_show_completion_columns,\n                            set_show_completion_columns,\n                            get_show_help, set_show_help,\n                            stop_input_and_refresh_cli):\n        \"\"\"Create and initialize the keybinding manager.\n\n        :type get_fuzzy_match: callable\n        :param get_fuzzy_match: Gets the fuzzy matching config.\n\n        :type set_fuzzy_match: callable\n        :param set_fuzzy_match: Sets the fuzzy matching config.\n\n        :type get_enable_vi_bindings: callable\n        :param get_enable_vi_bindings: Gets the vi (or emacs) key bindings\n            config.\n\n        :type set_enable_vi_bindings: callable\n        :param set_enable_vi_bindings: Sets the vi (or emacs) key bindings\n            config.\n\n        :type get_show_completion_columns: callable\n        :param get_show_completion_columns: Gets the show completions in\n            multiple or single columns config.\n\n        type set_show_completion_columns: callable\n        :param set_show_completion_columns: Sets the show completions in\n            multiple or single columns config.\n\n        :type get_show_help: callable\n        :param get_show_help: Gets the show help pane config.\n\n        :type set_show_help: callable\n        :param set_show_help: Sets the show help pane config.\n\n        :type stop_input_and_refresh_cli: callable\n        param stop_input_and_refresh_cli: Stops input by raising an\n            `InputInterrupt`, forces a cli refresh to ensure certain\n            options take effect within the current session.\n\n        :rtype: :class:`prompt_toolkit.KeyBindingManager`\n        :return: A custom `KeyBindingManager`.\n\n        \"\"\"\n        assert callable(get_match_fuzzy)\n        assert callable(set_match_fuzzy)\n        assert callable(get_enable_vi_bindings)\n        assert callable(set_enable_vi_bindings)\n        assert callable(get_show_completion_columns)\n        assert callable(set_show_completion_columns)\n        assert callable(get_show_help)\n        assert callable(set_show_help)\n        assert callable(stop_input_and_refresh_cli)\n        self.manager = KeyBindingManager(\n            enable_search=True,\n            enable_abort_and_exit_bindings=True,\n            enable_system_bindings=True,\n            enable_auto_suggest_bindings=True,\n            enable_open_in_editor=False)\n\n        @self.manager.registry.add_binding(Keys.F2)\n        def handle_f2(_):\n            \"\"\"Toggle fuzzy matching.\n\n            :type _: :class:`prompt_toolkit.Event`\n            :param _: (Unused)\n\n            \"\"\"\n            set_match_fuzzy(not get_match_fuzzy())\n\n        @self.manager.registry.add_binding(Keys.F3)\n        def handle_f3(_):\n            \"\"\"Toggle Vi mode keybindings matching.\n\n            Disabling Vi keybindings will enable Emacs keybindings.\n\n            :type _: :class:`prompt_toolkit.Event`\n            :param _: (Unused)\n\n            \"\"\"\n            set_enable_vi_bindings(not get_enable_vi_bindings())\n            stop_input_and_refresh_cli()\n\n        @self.manager.registry.add_binding(Keys.F4)\n        def handle_f4(_):\n            \"\"\"Toggle multiple column completions.\n\n            :type _: :class:`prompt_toolkit.Event`\n            :param _: (Unused)\n\n            \"\"\"\n            set_show_completion_columns(not get_show_completion_columns())\n            stop_input_and_refresh_cli()\n\n        @self.manager.registry.add_binding(Keys.F5)\n        def handle_f5(_):\n            \"\"\"Toggle the help container.\n\n            :type _: :class:`prompt_toolkit.Event`\n            :param _: (Unused)\n\n            \"\"\"\n            set_show_help(not get_show_help())\n            stop_input_and_refresh_cli()\n\n        @self.manager.registry.add_binding(Keys.F9)\n        def handle_f9(event):\n            \"\"\"Switch between the default and docs buffers.\n\n            :type event: :class:`prompt_toolkit.Event`\n            :param event: Contains info about the event, namely the cli\n                which is used to changing which buffer is focused.\n\n            \"\"\"\n            if event.cli.current_buffer_name == u'clidocs':\n                event.cli.focus(u'DEFAULT_BUFFER')\n            else:\n                event.cli.focus(u'clidocs')\n\n        @self.manager.registry.add_binding(Keys.F10)\n        def handle_f10(event):\n            \"\"\"Quit when the `F10` key is pressed.\n\n            :type event: :class:`prompt_toolkit.Event`\n            :param event: Contains info about the event, namely the cli\n                which is used for exiting the app.\n\n            \"\"\"\n            event.cli.set_exit()", "response": "Create and initialize a keybinding manager."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef describe_autocomplete(self, service, operation, param):\n        service_index = self._index[service]\n        LOG.debug(service_index)\n        if param not in service_index.get('operations', {}).get(operation, {}):\n            LOG.debug(\"param not in index: %s\", param)\n            return None\n        p = service_index['operations'][operation][param]\n        resource_name = p['resourceName']\n        resource_identifier = p['resourceIdentifier']\n\n        resource_index = service_index['resources'][resource_name]\n        completion_operation = resource_index['operation']\n        path = resource_index['resourceIdentifier'][resource_identifier]\n        return ServerCompletion(service=service, operation=completion_operation,\n                                params={}, path=path)", "response": "Describe the operation and args needed for server side completion."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef create_completer_query(self, service_name):\n        if service_name not in self._describer_cache:\n            query = self._create_completer_query(service_name)\n            self._describer_cache[service_name] = query\n        return self._describer_cache[service_name]", "response": "Create a CompleterDescriber object for a service."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nretrieving the candidate values for the given service and operation.", "response": "def retrieve_candidate_values(self, service, operation, param):\n        \"\"\"Retrieve server side completions.\n\n        :type service: str\n        :param service: The service name, e.g. 'ec2', 'iam'.\n\n        :type operation: str\n        :param operation: The operation name, in the casing\n            used by the CLI (words separated by hyphens), e.g.\n            'describe-instances', 'delete-user'.\n\n        :type param: str\n        :param param: The param name, as specified in the service\n            model, e.g. 'InstanceIds', 'UserName'.\n\n        :rtype: list\n        :return: A list of possible completions for the\n            service/operation/param combination.  If no\n            completions were found an empty list is returned.\n\n        \"\"\"\n        # Example call:\n        # service='ec2',\n        # operation='terminate-instances',\n        # param='InstanceIds'.\n        if service not in self._describer_creator.services_with_completions():\n            return []\n        try:\n            client = self._client_creator.create_client(service)\n        except BotoCoreError as e:\n            # create_client() could raise an exception if the session\n            # isn't fully configured (say it's missing a region).\n            # However, we don't want to turn off all server side\n            # completions because it's still possible to create\n            # clients for some services without a region, e.g. IAM.\n            LOG.debug(\"Error when trying to create a client for %s\",\n                      service, exc_info=True)\n            return []\n        api_operation_name = client.meta.method_to_api_mapping.get(\n            operation.replace('-', '_'))\n        if api_operation_name is None:\n            return []\n        # Now we need to convert the param name to the\n        # casing used by the API.\n        completer = self._describer_creator.create_completer_query(service)\n        result = completer.describe_autocomplete(\n            service, api_operation_name, param)\n        if result is None:\n            return\n        try:\n            response = getattr(client, xform_name(result.operation, '_'))()\n        except Exception as e:\n            LOG.debug(\"Error when calling %s.%s: %s\", service,\n                      result.operation, e, exc_info=True)\n            return\n        results = jmespath.search(result.path, response)\n        return results"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef convert_rst_to_basic_text(contents):\n    # The report_level override is so that we don't print anything\n    # to stdout/stderr on rendering issues.\n    converted = publish_string(\n        contents, writer=BasicTextWriter(),\n        settings_overrides={'report_level': 5})\n    return converted.decode('utf-8')", "response": "Convert RST to basic text output."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nread the user config file if it exists else read the default config.", "response": "def load(self, config_template, config_file=None):\n        \"\"\"Read the config file if it exists, else read the default config.\n\n        Creates the user config file if it doesn't exist using the template.\n\n        :type config_template: str\n        :param config_template: The config template file name.\n\n        :type config_file: str\n        :param config_file: (Optional) The config file name.\n            If None, the config_file name will be set to the config_template.\n\n        :rtype: :class:`configobj.ConfigObj`\n        :return: The config information for reading and writing.\n        \"\"\"\n        if config_file is None:\n            config_file = config_template\n        config_path = build_config_file_path(config_file)\n        template_path = os.path.join(os.path.dirname(__file__),\n                                     config_template)\n        self._copy_template_to_config(template_path, config_path)\n        return self._load_template_or_config(template_path, config_path)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nloads the config file if it exists else read the default config.", "response": "def _load_template_or_config(self, template_path, config_path):\n        \"\"\"Load the config file if it exists, else read the default config.\n\n        :type template_path: str\n        :param template_path: The template config file path.\n\n        :type config_path: str\n        :param config_path: The user's config file path.\n\n        :rtype: :class:`configobj.ConfigObj`\n        :return: The config information for reading and writing.\n        \"\"\"\n        expanded_config_path = os.path.expanduser(config_path)\n        cfg = ConfigObj()\n        cfg.filename = expanded_config_path\n        cfg.merge(ConfigObj(template_path, interpolation=False))\n        cfg.merge(ConfigObj(expanded_config_path, interpolation=False))\n        return cfg"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncopying the template to the user s config file.", "response": "def _copy_template_to_config(self, template_path,\n                                 config_path, overwrite=False):\n        \"\"\"Write the default config from a template.\n\n        :type template_path: str\n        :param template_path: The template config file path.\n\n        :type config_path: str\n        :param config_path: The user's config file path.\n\n        :type overwrite: bool\n        :param overwrite: (Optional) Determines whether to overwrite the\n            existing config file, if it exists.\n\n        :raises: :class:`OSError <exceptions.OSError>`\n        \"\"\"\n        config_path = os.path.expanduser(config_path)\n        if not overwrite and os.path.isfile(config_path):\n            return\n        else:\n            try:\n                config_path_dir_name = os.path.dirname(config_path)\n                os.makedirs(config_path_dir_name)\n            except OSError:\n                if not os.path.isdir(config_path_dir_name):\n                    raise\n            shutil.copyfile(template_path, config_path)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a pygments style object for the specified pygments style name.", "response": "def style_factory(self, style_name):\n        \"\"\"Retrieve the specified pygments style.\n\n        If the specified style is not found, the vim style is returned.\n\n        :type style_name: str\n        :param style_name: The pygments style name.\n\n        :rtype: :class:`pygments.style.StyleMeta`\n        :return: Pygments style info.\n        \"\"\"\n        try:\n            style = get_style_by_name(style_name)\n        except ClassNotFound:\n            style = get_style_by_name('vim')\n\n        # Create a style dictionary.\n        styles = {}\n        styles.update(style.styles)\n        styles.update(default_style_extensions)\n        t = Token\n        styles.update({\n            t.Menu.Completions.Completion.Current: 'bg:#00aaaa #000000',\n            t.Menu.Completions.Completion: 'bg:#008888 #ffffff',\n            t.Menu.Completions.Meta.Current: 'bg:#00aaaa #000000',\n            t.Menu.Completions.Meta: 'bg:#00aaaa #ffffff',\n            t.Scrollbar.Button: 'bg:#003333',\n            t.Scrollbar: 'bg:#00aaaa',\n            t.Toolbar: 'bg:#222222 #cccccc',\n            t.Toolbar.Off: 'bg:#222222 #696969',\n            t.Toolbar.On: 'bg:#222222 #ffffff',\n            t.Toolbar.Search: 'noinherit bold',\n            t.Toolbar.Search.Text: 'nobold',\n            t.Toolbar.System: 'noinherit bold',\n            t.Toolbar.Arg: 'noinherit bold',\n            t.Toolbar.Arg.Text: 'nobold'\n        })\n\n        return style_from_dict(styles)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef change_profile(self, profile_name):\n        self._server_side_completer = self._create_server_side_completer(\n            session=botocore.session.Session(profile=profile_name))", "response": "Change the profile used for server side completions."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef autocomplete(self, line):\n        current_length = len(line)\n        self._current_line = line\n        if current_length == 1 and self._last_position > 1:\n            # Reset state.  This is likely from a user completing\n            # a previous command.\n            self.reset()\n        elif current_length < self._last_position:\n            # The user has hit backspace.  We'll need to check\n            # the current words.\n            return self._handle_backspace()\n        elif not line:\n            return []\n        elif current_length != self._last_position + 1:\n            return self._complete_from_full_parse()\n\n        # This position is important.  We only update the _last_position\n        # after we've checked the special cases above where that value\n        # matters.\n        self._last_position = len(line)\n        if line and not line.strip():\n            # Special case, the user hits a space on a new line so\n            # we autocomplete all the top level commands.\n            return self._current['commands']\n\n        last_word = line.split()[-1]\n        if last_word in self.arg_metadata or last_word in self._global_options:\n            # The last thing we completed was an argument, record\n            # this as self.last_arg\n            self.last_option = last_word\n        if line[-1] == ' ':\n            # At this point the user has autocompleted a command\n            # or an argument and has hit space.  If they've\n            # just completed a command, we need to change the\n            # current context and traverse into the subcommand.\n            # \"ec2 \"\n            #      ^--here, need to traverse into \"ec2\"\n            #\n            # Otherwise:\n            # \"ec2 --no-validate-ssl \"\n            #                        ^-- here, stay on \"ec2\" context.\n            if not last_word.startswith('-'):\n                next_command = self._current['children'].get(last_word)\n                if next_command is not None:\n                    self._current = next_command\n                    self._current_name = last_word\n                    self.cmd_path.append(self._current_name)\n            elif last_word in self.arg_metadata and \\\n                    self.arg_metadata[last_word]['example']:\n                # Then this is an arg with a shorthand example so we'll\n                # suggest that example.\n                return [self.arg_metadata[last_word]['example']]\n            # Even if we don't change context, we still want to\n            # autocomplete all the commands for the current context\n            # in either of the above two cases.\n            return self._current['commands'][:]\n        elif last_word.startswith('-'):\n            # TODO: cache this for the duration of the current context.\n            # We don't need to recompute this until the args are\n            # different.\n            all_args = self._get_all_args()\n            if self.match_fuzzy:\n                return fuzzy_search(last_word, all_args)\n            else:\n                return substring_search(last_word, all_args)\n        if self.match_fuzzy:\n            return fuzzy_search(last_word, self._current['commands'])\n        else:\n            return substring_search(last_word, self._current['commands'])", "response": "Given a line return a list of suggestions."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef run(self, command, application):\n        with temporary_file('w') as f:\n            all_commands = self._generate_edit_history(application)\n            f.write(all_commands)\n            f.flush()\n            editor = self._get_editor_command()\n            try:\n                p = self._popen_cls([editor, f.name])\n                p.communicate()\n            except OSError:\n                self._err.write(\"Unable to launch editor: %s\\n\"\n                                \"You can configure which editor to use by \"\n                                \"exporting the EDITOR environment variable.\\n\"\n                                % editor)", "response": "Open the application s history buffer in an editor."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef run(self, command, application):\n        if len(command) == 1:\n            profile = application.profile\n            if profile is None:\n                self._output.write(\n                    \"Current shell profile: no profile configured\\n\"\n                    \"You can change profiles using: .profile profile-name\\n\")\n            else:\n                self._output.write(\"Current shell profile: %s\\n\" % profile)\n        elif len(command) == 2:\n            new_profile_name = command[1]\n            application.profile = new_profile_name\n            self._output.write(\"Current shell profile changed to: %s\\n\" %\n                               new_profile_name)\n        else:\n            self._err.write(\"Usage:\\n%s\\n\" % self.USAGE)", "response": "Get or set the profile for the application."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nhandling running a given dot command from a user.", "response": "def handle_cmd(self, command, application):\n        \"\"\"Handle running a given dot command from a user.\n\n        :type command: str\n        :param command: The full dot command string, e.g. ``.edit``,\n            of ``.profile prod``.\n\n        :type application: AWSShell\n        :param application: The application object.\n\n        \"\"\"\n        parts = command.split()\n        cmd_name = parts[0][1:]\n        if cmd_name not in self.HANDLER_CLASSES:\n            self._unknown_cmd(parts, application)\n        else:\n            # Note we expect the class to support no-arg\n            # instantiation.\n            return self.HANDLER_CLASSES[cmd_name]().run(parts, application)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef load_config(self):\n        config = Config()\n        self.config_obj = config.load('awsshellrc')\n        self.config_section = self.config_obj['aws-shell']\n        self.model_completer.match_fuzzy = self.config_section.as_bool(\n            'match_fuzzy')\n        self.enable_vi_bindings = self.config_section.as_bool(\n            'enable_vi_bindings')\n        self.show_completion_columns = self.config_section.as_bool(\n            'show_completion_columns')\n        self.show_help = self.config_section.as_bool('show_help')\n        self.theme = self.config_section['theme']", "response": "Load the config from the config file or template."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef save_config(self):\n        self.config_section['match_fuzzy'] = self.model_completer.match_fuzzy\n        self.config_section['enable_vi_bindings'] = self.enable_vi_bindings\n        self.config_section['show_completion_columns'] = \\\n            self.show_completion_columns\n        self.config_section['show_help'] = self.show_help\n        self.config_section['theme'] = self.theme\n        self.config_obj.write()", "response": "Save the config to the config file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate a KeyManager instance for the given locale.", "response": "def create_key_manager(self):\n        \"\"\"Create the :class:`KeyManager`.\n\n        The inputs to KeyManager are expected to be callable, so we can't\n        use the standard @property and @attrib.setter for these attributes.\n        Lambdas cannot contain assignments so we're forced to define setters.\n\n        :rtype: :class:`KeyManager`\n        :return: A KeyManager with callables to set the toolbar options.  Also\n            includes the method stop_input_and_refresh_cli to ensure certain\n            options take effect within the current session.\n\n        \"\"\"\n        def set_match_fuzzy(match_fuzzy):\n            \"\"\"Setter for fuzzy matching mode.\n\n            :type match_fuzzy: bool\n            :param match_fuzzy: The match fuzzy flag.\n\n            \"\"\"\n            self.model_completer.match_fuzzy = match_fuzzy\n\n        def set_enable_vi_bindings(enable_vi_bindings):\n            \"\"\"Setter for vi mode keybindings.\n\n            If vi mode is off, emacs mode is enabled by default by\n            `prompt_toolkit`.\n\n            :type enable_vi_bindings: bool\n            :param enable_vi_bindings: The enable Vi bindings flag.\n\n            \"\"\"\n            self.enable_vi_bindings = enable_vi_bindings\n\n        def set_show_completion_columns(show_completion_columns):\n            \"\"\"Setter for showing the completions in columns flag.\n\n            :type show_completion_columns: bool\n            :param show_completion_columns: The show completions in\n                multiple columns flag.\n\n            \"\"\"\n            self.show_completion_columns = show_completion_columns\n\n        def set_show_help(show_help):\n            \"\"\"Setter for showing the help container flag.\n\n            :type show_help: bool\n            :param show_help: The show help flag.\n\n            \"\"\"\n            self.show_help = show_help\n\n        return KeyManager(\n            lambda: self.model_completer.match_fuzzy, set_match_fuzzy,\n            lambda: self.enable_vi_bindings, set_enable_vi_bindings,\n            lambda: self.show_completion_columns, set_show_completion_columns,\n            lambda: self.show_help, set_show_help,\n            self.stop_input_and_refresh_cli)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncalculates how well the search string matches the word.", "response": "def calculate_score(search_string, word):\n    \"\"\"Calculate how well the search string matches the word.\"\"\"\n    # See the module docstring for a high level description\n    # of what we're trying to do.\n    # * If the search string is larger than the word, we know\n    #   immediately that this can't be a match.\n    if len(search_string) > len(word):\n        return 0\n    original_word = word\n    score = 1\n    search_index = 0\n    while True:\n        scale = 1.0\n        search_char = search_string[search_index]\n        i = word.find(search_char)\n        if i < 0:\n            return 0\n        if i > 0 and word[i - 1] == '-':\n            scale = 0.95\n        else:\n            scale = 1 - (i / float(len(word)))\n        score *= scale\n        word = word[i + 1:]\n        search_index += 1\n        if search_index >= len(search_string):\n            break\n    # The more characters that matched the word, the better\n    # so prefer more complete matches.\n    completion_scale = 1 - (len(word) / float(len(original_word)))\n    score *= completion_scale\n    return score"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef substring_search(word, collection):\n    return [item for item in sorted(collection) if item.startswith(word)]", "response": "Find all matches in the collection for the specified word."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating the toolbar handler.", "response": "def _create_toolbar_handler(self, get_match_fuzzy, get_enable_vi_bindings,\n                                get_show_completion_columns, get_show_help):\n        \"\"\"Create the toolbar handler.\n\n        :type get_fuzzy_match: callable\n        :param fuzzy_match: Gets the fuzzy matching config.\n\n        :type get_enable_vi_bindings: callable\n        :param get_enable_vi_bindings: Gets the vi (or emacs) key bindings\n            config.\n\n        :type get_show_completion_columns: callable\n        :param get_show_completion_columns: Gets the show completions in\n            multiple or single columns config.\n\n        :type get_show_help: callable\n        :param get_show_help: Gets the show help pane config.\n\n        :rtype: callable\n        :returns: get_toolbar_items.\n\n        \"\"\"\n        assert callable(get_match_fuzzy)\n        assert callable(get_enable_vi_bindings)\n        assert callable(get_show_completion_columns)\n        assert callable(get_show_help)\n\n        def get_toolbar_items(cli):\n            \"\"\"Return the toolbar items.\n\n            :type cli: :class:`prompt_toolkit.Cli`\n            :param cli: The command line interface from prompt_toolkit\n\n            :rtype: list\n            :return: A list of (pygments.Token.Toolbar, str).\n            \"\"\"\n            if get_match_fuzzy():\n                match_fuzzy_token = Token.Toolbar.On\n                match_fuzzy_cfg = 'ON'\n            else:\n                match_fuzzy_token = Token.Toolbar.Off\n                match_fuzzy_cfg = 'OFF'\n            if get_enable_vi_bindings():\n                enable_vi_bindings_token = Token.Toolbar.On\n                enable_vi_bindings_cfg = 'Vi'\n            else:\n                enable_vi_bindings_token = Token.Toolbar.On\n                enable_vi_bindings_cfg = 'Emacs'\n            if get_show_completion_columns():\n                show_columns_token = Token.Toolbar.On\n                show_columns_cfg = 'Multi'\n            else:\n                show_columns_token = Token.Toolbar.On\n                show_columns_cfg = 'Single'\n            if get_show_help():\n                show_help_token = Token.Toolbar.On\n                show_help_cfg = 'ON'\n            else:\n                show_help_token = Token.Toolbar.Off\n                show_help_cfg = 'OFF'\n            if cli.current_buffer_name == 'DEFAULT_BUFFER':\n                show_buffer_name = 'cli'\n            else:\n                show_buffer_name = 'doc'\n            return [\n                (match_fuzzy_token,\n                 ' [F2] Fuzzy: {0} '.format(match_fuzzy_cfg)),\n                (enable_vi_bindings_token,\n                 ' [F3] Keys: {0} '.format(enable_vi_bindings_cfg)),\n                (show_columns_token,\n                 ' [F4] {0} Column '.format(show_columns_cfg)),\n                (show_help_token,\n                 ' [F5] Help: {0} '.format(show_help_cfg)),\n                (Token.Toolbar,\n                 ' [F9] Focus: {0} '.format(show_buffer_name)),\n                (Token.Toolbar,\n                 ' [F10] Exit ')\n            ]\n\n        return get_toolbar_items"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef create_default_layout(app, message='',\n                          lexer=None, is_password=False,\n                          reserve_space_for_menu=False,\n                          get_prompt_tokens=None,\n                          get_bottom_toolbar_tokens=None,\n                          display_completions_in_columns=False,\n                          extra_input_processors=None, multiline=False):\n    \"\"\"\n    Generate default layout.\n\n    Returns a ``Layout`` instance.\n\n    :param message: Text to be used as prompt.\n    :param lexer: Lexer to be used for the highlighting.\n    :param is_password: `bool` or `CLIFilter`. When True, display input as '*'.\n    :param reserve_space_for_menu: When True, make sure that a minimal height\n        is allocated in the terminal, in order to display the completion menu.\n    :param get_prompt_tokens: An optional callable that returns the tokens to\n        be shown in the menu. (To be used instead of a `message`.)\n    :param get_bottom_toolbar_tokens: An optional callable that returns the\n        tokens for a toolbar at the bottom.\n    :param display_completions_in_columns: `bool` or `CLIFilter`. Display the\n        completions in multiple columns.\n    :param multiline: `bool` or `CLIFilter`. When True, prefer a layout that is\n        more adapted for multiline input. Text after newlines is automatically\n        indented, and search/arg input is shown below the input, instead of\n        replacing the prompt.\n    \"\"\"\n    assert isinstance(message, text_type)\n    assert (get_bottom_toolbar_tokens is None or\n            callable(get_bottom_toolbar_tokens))\n    assert get_prompt_tokens is None or callable(get_prompt_tokens)\n    assert not (message and get_prompt_tokens)\n\n    display_completions_in_columns = to_cli_filter(\n        display_completions_in_columns)\n    multiline = to_cli_filter(multiline)\n\n    if get_prompt_tokens is None:\n        get_prompt_tokens = lambda _: [(Token.Prompt, message)]\n\n    get_prompt_tokens_1, get_prompt_tokens_2 = _split_multiline_prompt(\n        get_prompt_tokens)\n\n    # `lexer` is supposed to be a `Lexer` instance. But if a Pygments lexer\n    # class is given, turn it into a PygmentsLexer. (Important for\n    # backwards-compatibility.)\n    try:\n        if issubclass(lexer, Lexer):\n            lexer = PygmentsLexer(lexer)\n    except TypeError:\n        # Happens when lexer is `None` or an instance of something else.\n        pass\n\n    # Create processors list.\n    # (DefaultPrompt should always be at the end.)\n    input_processors = [\n        ConditionalProcessor(\n            # By default, only highlight search when the search\n            # input has the focus. (Note that this doesn't mean\n            # there is no search: the Vi 'n' binding for instance\n            # still allows to jump to the next match in\n            # navigation mode.)\n            HighlightSearchProcessor(preview_search=Always()),\n            HasFocus(SEARCH_BUFFER)),\n        HighlightSelectionProcessor(),\n        ConditionalProcessor(\n            AppendAutoSuggestion(), HasFocus(DEFAULT_BUFFER) & ~IsDone()),\n        ConditionalProcessor(PasswordProcessor(), is_password)\n    ]\n\n    if extra_input_processors:\n        input_processors.extend(extra_input_processors)\n\n    # Show the prompt before the input (using the DefaultPrompt processor.\n    # This also replaces it with reverse-i-search and 'arg' when required.\n    # (Only for single line mode.)\n    input_processors.append(ConditionalProcessor(\n        DefaultPrompt(get_prompt_tokens), ~multiline))\n\n    # Create bottom toolbar.\n    if get_bottom_toolbar_tokens:\n        toolbars = [ConditionalContainer(\n            Window(TokenListControl(get_bottom_toolbar_tokens,\n                                    default_char=Char(' ', Token.Toolbar)),\n                   height=LayoutDimension.exact(1)),\n            filter=~IsDone() & RendererHeightIsKnown())]\n    else:\n        toolbars = []\n\n    def get_height(cli):\n        # If there is an autocompletion menu to be shown, make sure that our\n        # layout has at least a minimal height in order to display it.\n        if reserve_space_for_menu and not cli.is_done:\n            return LayoutDimension(min=8)\n        else:\n            return LayoutDimension()\n\n    def separator():\n        return ConditionalContainer(\n            content=Window(height=LayoutDimension.exact(1),\n                           content=FillControl(u'\\u2500',\n                                               token=Token.Separator)),\n            filter=HasDocumentation(app) & ~IsDone())\n\n    # Create and return Layout instance.\n    return HSplit([\n        ConditionalContainer(\n            Window(\n                TokenListControl(get_prompt_tokens_1),\n                dont_extend_height=True),\n            filter=multiline,\n        ),\n        VSplit([\n            # In multiline mode, the prompt is displayed in a left pane.\n            ConditionalContainer(\n                Window(\n                    TokenListControl(get_prompt_tokens_2),\n                    dont_extend_width=True,\n                ),\n                filter=multiline,\n            ),\n            # The main input, with completion menus floating on top of it.\n            FloatContainer(\n                Window(\n                    BufferControl(\n                        input_processors=input_processors,\n                        lexer=lexer,\n                        # Enable preview_search, we want to have immediate\n                        # feedback in reverse-i-search mode.\n                        preview_search=Always(),\n                        focus_on_click=True,\n                    ),\n                    get_height=get_height,\n                ),\n                [\n                    Float(xcursor=True,\n                          ycursor=True,\n                          content=CompletionsMenu(\n                              max_height=16,\n                              scroll_offset=1,\n                              extra_filter=(HasFocus(DEFAULT_BUFFER) &\n                                            ~display_completions_in_columns))),\n                    Float(xcursor=True,\n                          ycursor=True,\n                          content=MultiColumnCompletionsMenu(\n                              extra_filter=(HasFocus(DEFAULT_BUFFER) &\n                                            display_completions_in_columns),\n                              show_meta=Always()))\n                ]\n            ),\n        ]),\n        separator(),\n        ConditionalContainer(\n            content=Window(\n                BufferControl(\n                    focus_on_click=True,\n                    buffer_name=u'clidocs',\n                ),\n                height=LayoutDimension(max=15)),\n            filter=HasDocumentation(app) & ~IsDone(),\n        ),\n        separator(),\n        ValidationToolbar(),\n        SystemToolbar(),\n\n        # In multiline mode, we use two toolbars for 'arg' and 'search'.\n        ConditionalContainer(ArgToolbar(), multiline),\n        ConditionalContainer(SearchToolbar(), multiline),\n    ] + toolbars)", "response": "Create a default layout for the given application."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef temporary_file(mode):\n    tempdir = tempfile.gettempdir()\n    basename = 'tmpfile-%s' % (uuid.uuid4())\n    full_filename = os.path.join(tempdir, basename)\n    if 'w' not in mode:\n        # We need to create the file before we can open\n        # it in 'r' mode.\n        open(full_filename, 'w').close()\n    try:\n        with open(full_filename, mode) as f:\n            yield f\n    finally:\n        os.remove(f.name)", "response": "Cross platform temporary file creation."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef file_contents(self, filename, binary=False):\n        if binary:\n            mode = 'rb'\n        else:\n            mode = 'r'\n        try:\n            with open(filename, mode) as f:\n                return f.read()\n        except (OSError, IOError) as e:\n            raise FileReadError(str(e))", "response": "Return the contents of a given file."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nloading the completion index for a given CLI version.", "response": "def load_index(self, version_string):\n        \"\"\"Load the completion index for a given CLI version.\n\n        :type version_string: str\n        :param version_string: The AWS CLI version, e.g \"1.9.2\".\n\n        :raises: :class:`IndexLoadError <exceptions.IndexLoadError>`\n        \"\"\"\n        filename = self._filename_for_version(version_string)\n        try:\n            contents = self._fslayer.file_contents(filename)\n        except FileReadError as e:\n            raise IndexLoadError(str(e))\n        return contents"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef load_completions(self):\n        try:\n            index_str = self.load_index(utils.AWSCLI_VERSION)\n        except IndexLoadError:\n            return\n        index_str = self.load_index(utils.AWSCLI_VERSION)\n        index_data = json.loads(index_str)\n        index_root = index_data['aws']\n        # ec2, s3, elb...\n        self.commands = index_root['commands']\n        # --profile, --region, --output...\n        self.global_opts = index_root['arguments']\n        for command in self.commands:\n            # ec2: start-instances, stop-instances, terminate-instances...\n            subcommands_current = index_root['children'] \\\n                .get(command)['commands']\n            self.subcommands.extend(subcommands_current)\n            for subcommand_current in subcommands_current:\n                # start-instances: --instance-ids, --dry-run...\n                args_opts_current = index_root['children'] \\\n                    .get(command)['children'] \\\n                    .get(subcommand_current)['arguments']\n                self.args_opts.update(args_opts_current)", "response": "Load completions from the completion index."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nincrements the counter (overflow rolls back to 0).", "response": "def increment(self):\n        '''Increment the counter (overflow rolls back to 0).'''\n\n        for i in xrange(len(self._counter) - 1, -1, -1):\n            self._counter[i] += 1\n\n            if self._counter[i] < 256: break\n\n            # Carry the one\n            self._counter[i] = 0\n\n        # Overflow\n        else:\n            self._counter = [ 0 ] * len(self._counter)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndumping raw efuse data registers", "response": "def dump(esp, _efuses, args):\n    \"\"\" Dump raw efuse data registers \"\"\"\n    for block in range(len(EFUSE_BLOCK_OFFS)):\n        print(\"EFUSE block %d:\" % block)\n        offsets = [x + EFUSE_BLOCK_OFFS[block] for x in range(EFUSE_BLOCK_LEN[block])]\n        print(\" \".join([\"%08x\" % esp.read_efuse(offs) for offs in offsets]))"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nprint a human - readable summary of efuse contents.", "response": "def summary(esp, efuses, args):\n    \"\"\" Print a human-readable summary of efuse contents \"\"\"\n    ROW_FORMAT = \"%-22s %-50s%s= %s %s %s\"\n    print(ROW_FORMAT.replace(\"-50\", \"-12\") % (\"EFUSE_NAME\", \"Description\", \"\", \"[Meaningful Value]\", \"[Readable/Writeable]\", \"(Hex Value)\"))\n    print(\"-\" * 88)\n    for category in set(e.category for e in efuses):\n        print(\"%s fuses:\" % category.title())\n        for e in (e for e in efuses if e.category == category):\n            raw = e.get_raw()\n            try:\n                raw = \"(0x%x)\" % raw\n            except TypeError:\n                raw = \"\"\n            (readable, writeable) = (e.is_readable(), e.is_writeable())\n            if readable and writeable:\n                perms = \"R/W\"\n            elif readable:\n                perms = \"R/-\"\n            elif writeable:\n                perms = \"-/W\"\n            else:\n                perms = \"-/-\"\n            value = str(e.get())\n            if not readable:\n                value = value.replace(\"0\", \"?\")\n            print(ROW_FORMAT % (e.register_name, e.description, \"\\n  \" if len(value) > 20 else \"\", value, perms, raw))\n        print(\"\")\n    sdio_force = efuses[\"XPD_SDIO_FORCE\"]\n    sdio_tieh = efuses[\"XPD_SDIO_TIEH\"]\n    sdio_reg = efuses[\"XPD_SDIO_REG\"]\n    if sdio_force.get() == 0:\n        print(\"Flash voltage (VDD_SDIO) determined by GPIO12 on reset (High for 1.8V, Low/NC for 3.3V).\")\n    elif sdio_reg.get() == 0:\n        print(\"Flash voltage (VDD_SDIO) internal regulator disabled by efuse.\")\n    elif sdio_tieh.get() == 0:\n        print(\"Flash voltage (VDD_SDIO) set to 1.8V by efuse.\")\n    else:\n        print(\"Flash voltage (VDD_SDIO) set to 3.3V by efuse.\")\n    warnings = efuses.get_coding_scheme_warnings()\n    if warnings:\n        print(\"WARNING: Coding scheme has encoding bit error warnings (0x%x)\" % warnings)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nwrite the values in the efuse write registers to the hardware and refresh the efuse read registers to obtain the new efuse hardware.", "response": "def write_efuses(self):\n        \"\"\" Write the values in the efuse write registers to\n        the efuse hardware, then refresh the efuse read registers.\n        \"\"\"\n\n        # Configure clock\n        apb_freq = self._esp.get_crystal_freq()\n        clk_sel0, clk_sel1, dac_clk_div = EFUSE_CLK_SETTINGS[apb_freq]\n\n        self.update_reg(EFUSE_DAC_CONF_REG, EFUSE_DAC_CLK_DIV_MASK, dac_clk_div)\n        self.update_reg(EFUSE_CLK_REG, EFUSE_CLK_SEL0_MASK, clk_sel0)\n        self.update_reg(EFUSE_CLK_REG, EFUSE_CLK_SEL1_MASK, clk_sel1)\n\n        self.write_reg(EFUSE_REG_CONF, EFUSE_CONF_WRITE)\n        self.write_reg(EFUSE_REG_CMD, EFUSE_CMD_WRITE)\n\n        def wait_idle():\n            deadline = time.time() + EFUSE_BURN_TIMEOUT\n            while time.time() < deadline:\n                if self._esp.read_reg(EFUSE_REG_CMD) == 0:\n                    return\n            raise esptool.FatalError(\"Timed out waiting for Efuse controller command to complete\")\n        wait_idle()\n        self.write_reg(EFUSE_REG_CONF, EFUSE_CONF_READ)\n        self.write_reg(EFUSE_REG_CMD, EFUSE_CMD_READ)\n        wait_idle()"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the raw integer value of the efuse bits", "response": "def get_raw(self):\n        \"\"\" Return the raw (unformatted) numeric value of the efuse bits\n\n        Returns a simple integer or (for some subclasses) a bitstring.\n        \"\"\"\n        value = self.parent.read_efuse(self.data_reg_offs)\n        return (value & self.mask) >> self.shift"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning true if the efuse is readable by software", "response": "def is_readable(self):\n        \"\"\" Return true if the efuse is readable by software \"\"\"\n        if self.read_disable_bit is None:\n            return True  # read cannot be disabled\n        value = (self.parent.read_efuse(0) >> 16) & 0xF  # RD_DIS values\n        return (value & (1 << self.read_disable_bit)) == 0"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncalculate the CRC of a raw MAC address.", "response": "def calc_crc(raw_mac):\n        \"\"\"\n        This algorithm is the equivalent of esp_crc8() in ESP32 ROM code\n\n        This is CRC-8 w/ inverted polynomial value 0x8C & initial value 0x00.\n        \"\"\"\n        result = 0x00\n        for b in struct.unpack(\"B\" * 6, raw_mac):\n            result ^= b\n            for _ in range(8):\n                lsb = result & 1\n                result >>= 1\n                if lsb != 0:\n                    result ^= 0x8c\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\napply 34 encoding to the given 24 byte sequence to be represented in 3 / 4 encoding and returns 8 words suitable for writing to an efuse block.", "response": "def apply_34_encoding(self, inbits):\n        \"\"\" Takes 24 byte sequence to be represented in 3/4 encoding,\n            returns 8 words suitable for writing \"encoded\" to an efuse block\n        \"\"\"\n        def popcnt(b):\n            \"\"\" Return number of \"1\" bits set in 'b' \"\"\"\n            return len([x for x in bin(b) if x == \"1\"])\n\n        outbits = b\"\"\n        while len(inbits) > 0:  # process in chunks of 6 bytes\n            bits = inbits[0:6]\n            inbits = inbits[6:]\n            xor_res = 0\n            mul_res = 0\n            index = 1\n            for b in struct.unpack(\"B\" * 6, bits):\n                xor_res ^= b\n                mul_res += index * popcnt(b)\n                index += 1\n            outbits += bits\n            outbits += struct.pack(\"BB\", xor_res, mul_res)\n        return struct.unpack(\"<\" + \"I\" * (len(outbits) // 4), outbits)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nbeing the point x y on this curve?", "response": "def contains_point( self, x, y ):\n    \"\"\"Is the point (x,y) on this curve?\"\"\"\n    return ( y * y - ( x * x * x + self.__a * x + self.__b ) ) % self.__p == 0"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef double( self ):\n\n    if self == INFINITY:\n      return INFINITY\n\n    # X9.62 B.3:\n\n    p = self.__curve.p()\n    a = self.__curve.a()\n\n    l = ( ( 3 * self.__x * self.__x + a ) * \\\n          numbertheory.inverse_mod( 2 * self.__y, p ) ) % p\n\n    x3 = ( l * l - 2 * self.__x ) % p\n    y3 = ( l * ( self.__x - x3 ) - self.__y ) % p\n\n    return Point( self.__curve, x3, y3 )", "response": "Return a new point that is twice the old."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nscale timeouts which are size - specific", "response": "def timeout_per_mb(seconds_per_mb, size_bytes):\n    \"\"\" Scales timeouts which are size-specific \"\"\"\n    result = seconds_per_mb * (size_bytes / 1e6)\n    if result < DEFAULT_TIMEOUT:\n        return DEFAULT_TIMEOUT\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nload a firmware image from a file.", "response": "def LoadFirmwareImage(chip, filename):\n    \"\"\" Load a firmware image. Can be for ESP8266 or ESP32. ESP8266 images will be examined to determine if they are\n        original ROM firmware images (ESP8266ROMFirmwareImage) or \"v2\" OTA bootloader images.\n\n        Returns a BaseFirmwareImage subclass, either ESP8266ROMFirmwareImage (v1) or ESP8266V2FirmwareImage (v2).\n    \"\"\"\n    with open(filename, 'rb') as f:\n        if chip.lower() == 'esp32':\n            return ESP32FirmwareImage(f)\n        else:  # Otherwise, ESP8266 so look at magic to determine the image type\n            magic = ord(f.read(1))\n            f.seek(0)\n            if magic == ESPLoader.ESP_IMAGE_MAGIC:\n                return ESP8266ROMFirmwareImage(f)\n            elif magic == ESPBOOTLOADER.IMAGE_V2_MAGIC:\n                return ESP8266V2FirmwareImage(f)\n            else:\n                raise FatalError(\"Invalid image magic number: %d\" % magic)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\naligns the file position to the next block of specified size", "response": "def align_file_position(f, size):\n    \"\"\" Align the position in the file to the next block of specified size \"\"\"\n    align = (size - 1) - (f.tell() % size)\n    f.seek(align, 1)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef flash_size_bytes(size):\n    if \"MB\" in size:\n        return int(size[:size.index(\"MB\")]) * 1024 * 1024\n    elif \"KB\" in size:\n        return int(size[:size.index(\"KB\")]) * 1024\n    else:\n        raise FatalError(\"Unknown size %s\" % size)", "response": "Given a flash size of the type passed in args. flash_size_bytes return the size in bytes."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef pad_to(data, alignment, pad_character=b'\\xFF'):\n    pad_mod = len(data) % alignment\n    if pad_mod != 0:\n        data += pad_character * (alignment - pad_mod)\n    return data", "response": "Pad the data to the next alignment boundary."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _update_image_flash_params(esp, address, args, image):\n    if len(image) < 8:\n        return image  # not long enough to be a bootloader image\n\n    # unpack the (potential) image header\n    magic, _, flash_mode, flash_size_freq = struct.unpack(\"BBBB\", image[:4])\n    if address != esp.BOOTLOADER_FLASH_OFFSET or magic != esp.ESP_IMAGE_MAGIC:\n        return image  # not flashing a bootloader, so don't modify this\n\n    if args.flash_mode != 'keep':\n        flash_mode = {'qio':0, 'qout':1, 'dio':2, 'dout': 3}[args.flash_mode]\n\n    flash_freq = flash_size_freq & 0x0F\n    if args.flash_freq != 'keep':\n        flash_freq = {'40m':0, '26m':1, '20m':2, '80m': 0xf}[args.flash_freq]\n\n    flash_size = flash_size_freq & 0xF0\n    if args.flash_size != 'keep':\n        flash_size = esp.parse_flash_size_arg(args.flash_size)\n\n    flash_params = struct.pack(b'BB', flash_mode, flash_size + flash_freq)\n    if flash_params != image[2:4]:\n        print('Flash params set to 0x%04x' % struct.unpack(\">H\", flash_params))\n        image = image[0:2] + flash_params + image[4:]\n    return image", "response": "Modify the flash mode & size bytes if this looks like an executable bootloader image"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef main(custom_commandline=None):\n    parser = argparse.ArgumentParser(description='esptool.py v%s - ESP8266 ROM Bootloader Utility' % __version__, prog='esptool')\n\n    parser.add_argument('--chip', '-c',\n                        help='Target chip type',\n                        choices=['auto', 'esp8266', 'esp32'],\n                        default=os.environ.get('ESPTOOL_CHIP', 'auto'))\n\n    parser.add_argument(\n        '--port', '-p',\n        help='Serial port device',\n        default=os.environ.get('ESPTOOL_PORT', None))\n\n    parser.add_argument(\n        '--baud', '-b',\n        help='Serial port baud rate used when flashing/reading',\n        type=arg_auto_int,\n        default=os.environ.get('ESPTOOL_BAUD', ESPLoader.ESP_ROM_BAUD))\n\n    parser.add_argument(\n        '--before',\n        help='What to do before connecting to the chip',\n        choices=['default_reset', 'no_reset', 'no_reset_no_sync'],\n        default=os.environ.get('ESPTOOL_BEFORE', 'default_reset'))\n\n    parser.add_argument(\n        '--after', '-a',\n        help='What to do after esptool.py is finished',\n        choices=['hard_reset', 'soft_reset', 'no_reset'],\n        default=os.environ.get('ESPTOOL_AFTER', 'hard_reset'))\n\n    parser.add_argument(\n        '--no-stub',\n        help=\"Disable launching the flasher stub, only talk to ROM bootloader. Some features will not be available.\",\n        action='store_true')\n\n    parser.add_argument(\n        '--trace', '-t',\n        help=\"Enable trace-level output of esptool.py interactions.\",\n        action='store_true')\n\n    parser.add_argument(\n        '--override-vddsdio',\n        help=\"Override ESP32 VDDSDIO internal voltage regulator (use with care)\",\n        choices=ESP32ROM.OVERRIDE_VDDSDIO_CHOICES,\n        nargs='?')\n\n    subparsers = parser.add_subparsers(\n        dest='operation',\n        help='Run esptool {command} -h for additional help')\n\n    def add_spi_connection_arg(parent):\n        parent.add_argument('--spi-connection', '-sc', help='ESP32-only argument. Override default SPI Flash connection. ' +\n                            'Value can be SPI, HSPI or a comma-separated list of 5 I/O numbers to use for SPI flash (CLK,Q,D,HD,CS).',\n                            action=SpiConnectionAction)\n\n    parser_load_ram = subparsers.add_parser(\n        'load_ram',\n        help='Download an image to RAM and execute')\n    parser_load_ram.add_argument('filename', help='Firmware image')\n\n    parser_dump_mem = subparsers.add_parser(\n        'dump_mem',\n        help='Dump arbitrary memory to disk')\n    parser_dump_mem.add_argument('address', help='Base address', type=arg_auto_int)\n    parser_dump_mem.add_argument('size', help='Size of region to dump', type=arg_auto_int)\n    parser_dump_mem.add_argument('filename', help='Name of binary dump')\n\n    parser_read_mem = subparsers.add_parser(\n        'read_mem',\n        help='Read arbitrary memory location')\n    parser_read_mem.add_argument('address', help='Address to read', type=arg_auto_int)\n\n    parser_write_mem = subparsers.add_parser(\n        'write_mem',\n        help='Read-modify-write to arbitrary memory location')\n    parser_write_mem.add_argument('address', help='Address to write', type=arg_auto_int)\n    parser_write_mem.add_argument('value', help='Value', type=arg_auto_int)\n    parser_write_mem.add_argument('mask', help='Mask of bits to write', type=arg_auto_int)\n\n    def add_spi_flash_subparsers(parent, is_elf2image):\n        \"\"\" Add common parser arguments for SPI flash properties \"\"\"\n        extra_keep_args = [] if is_elf2image else ['keep']\n        auto_detect = not is_elf2image\n\n        if auto_detect:\n            extra_fs_message = \", detect, or keep\"\n        else:\n            extra_fs_message = \"\"\n\n        parent.add_argument('--flash_freq', '-ff', help='SPI Flash frequency',\n                            choices=extra_keep_args + ['40m', '26m', '20m', '80m'],\n                            default=os.environ.get('ESPTOOL_FF', '40m' if is_elf2image else 'keep'))\n        parent.add_argument('--flash_mode', '-fm', help='SPI Flash mode',\n                            choices=extra_keep_args + ['qio', 'qout', 'dio', 'dout'],\n                            default=os.environ.get('ESPTOOL_FM', 'qio' if is_elf2image else 'keep'))\n        parent.add_argument('--flash_size', '-fs', help='SPI Flash size in MegaBytes (1MB, 2MB, 4MB, 8MB, 16M)'\n                            ' plus ESP8266-only (256KB, 512KB, 2MB-c1, 4MB-c1)' + extra_fs_message,\n                            action=FlashSizeAction, auto_detect=auto_detect,\n                            default=os.environ.get('ESPTOOL_FS', 'detect' if auto_detect else '1MB'))\n        add_spi_connection_arg(parent)\n\n    parser_write_flash = subparsers.add_parser(\n        'write_flash',\n        help='Write a binary blob to flash')\n\n    parser_write_flash.add_argument('addr_filename', metavar='<address> <filename>', help='Address followed by binary filename, separated by space',\n                                    action=AddrFilenamePairAction)\n    parser_write_flash.add_argument('--erase-all', '-e',\n                                    help='Erase all regions of flash (not just write areas) before programming',\n                                    action=\"store_true\")\n\n    add_spi_flash_subparsers(parser_write_flash, is_elf2image=False)\n    parser_write_flash.add_argument('--no-progress', '-p', help='Suppress progress output', action=\"store_true\")\n    parser_write_flash.add_argument('--verify', help='Verify just-written data on flash ' +\n                                    '(mostly superfluous, data is read back during flashing)', action='store_true')\n    parser_write_flash.add_argument('--encrypt', help='Encrypt before write ',\n                                    action='store_true')\n    parser_write_flash.add_argument('--ignore-flash-encryption-efuse-setting', help='Ignore flash encryption efuse settings ',\n                                    action='store_true')\n\n    compress_args = parser_write_flash.add_mutually_exclusive_group(required=False)\n    compress_args.add_argument('--compress', '-z', help='Compress data in transfer (default unless --no-stub is specified)',action=\"store_true\", default=None)\n    compress_args.add_argument('--no-compress', '-u', help='Disable data compression during transfer (default if --no-stub is specified)',action=\"store_true\")\n\n    subparsers.add_parser(\n        'run',\n        help='Run application code in flash')\n\n    parser_image_info = subparsers.add_parser(\n        'image_info',\n        help='Dump headers from an application image')\n    parser_image_info.add_argument('filename', help='Image file to parse')\n\n    parser_make_image = subparsers.add_parser(\n        'make_image',\n        help='Create an application image from binary files')\n    parser_make_image.add_argument('output', help='Output image file')\n    parser_make_image.add_argument('--segfile', '-f', action='append', help='Segment input file')\n    parser_make_image.add_argument('--segaddr', '-a', action='append', help='Segment base address', type=arg_auto_int)\n    parser_make_image.add_argument('--entrypoint', '-e', help='Address of entry point', type=arg_auto_int, default=0)\n\n    parser_elf2image = subparsers.add_parser(\n        'elf2image',\n        help='Create an application image from ELF file')\n    parser_elf2image.add_argument('input', help='Input ELF file')\n    parser_elf2image.add_argument('--output', '-o', help='Output filename prefix (for version 1 image), or filename (for version 2 single image)', type=str)\n    parser_elf2image.add_argument('--version', '-e', help='Output image version', choices=['1','2'], default='1')\n    parser_elf2image.add_argument('--secure-pad', action='store_true', help='Pad image so once signed it will end on a 64KB boundary. For ESP32 images only.')\n    parser_elf2image.add_argument('--elf-sha256-offset', help='If set, insert SHA256 hash (32 bytes) of the input ELF file at specified offset in the binary.',\n                                  type=arg_auto_int, default=None)\n\n    add_spi_flash_subparsers(parser_elf2image, is_elf2image=True)\n\n    subparsers.add_parser(\n        'read_mac',\n        help='Read MAC address from OTP ROM')\n\n    subparsers.add_parser(\n        'chip_id',\n        help='Read Chip ID from OTP ROM')\n\n    parser_flash_id = subparsers.add_parser(\n        'flash_id',\n        help='Read SPI flash manufacturer and device ID')\n    add_spi_connection_arg(parser_flash_id)\n\n    parser_read_status = subparsers.add_parser(\n        'read_flash_status',\n        help='Read SPI flash status register')\n\n    add_spi_connection_arg(parser_read_status)\n    parser_read_status.add_argument('--bytes', help='Number of bytes to read (1-3)', type=int, choices=[1,2,3], default=2)\n\n    parser_write_status = subparsers.add_parser(\n        'write_flash_status',\n        help='Write SPI flash status register')\n\n    add_spi_connection_arg(parser_write_status)\n    parser_write_status.add_argument('--non-volatile', help='Write non-volatile bits (use with caution)', action='store_true')\n    parser_write_status.add_argument('--bytes', help='Number of status bytes to write (1-3)', type=int, choices=[1,2,3], default=2)\n    parser_write_status.add_argument('value', help='New value', type=arg_auto_int)\n\n    parser_read_flash = subparsers.add_parser(\n        'read_flash',\n        help='Read SPI flash content')\n    add_spi_connection_arg(parser_read_flash)\n    parser_read_flash.add_argument('address', help='Start address', type=arg_auto_int)\n    parser_read_flash.add_argument('size', help='Size of region to dump', type=arg_auto_int)\n    parser_read_flash.add_argument('filename', help='Name of binary dump')\n    parser_read_flash.add_argument('--no-progress', '-p', help='Suppress progress output', action=\"store_true\")\n\n    parser_verify_flash = subparsers.add_parser(\n        'verify_flash',\n        help='Verify a binary blob against flash')\n    parser_verify_flash.add_argument('addr_filename', help='Address and binary file to verify there, separated by space',\n                                     action=AddrFilenamePairAction)\n    parser_verify_flash.add_argument('--diff', '-d', help='Show differences',\n                                     choices=['no', 'yes'], default='no')\n    add_spi_flash_subparsers(parser_verify_flash, is_elf2image=False)\n\n    parser_erase_flash = subparsers.add_parser(\n        'erase_flash',\n        help='Perform Chip Erase on SPI flash')\n    add_spi_connection_arg(parser_erase_flash)\n\n    parser_erase_region = subparsers.add_parser(\n        'erase_region',\n        help='Erase a region of the flash')\n    add_spi_connection_arg(parser_erase_region)\n    parser_erase_region.add_argument('address', help='Start address (must be multiple of 4096)', type=arg_auto_int)\n    parser_erase_region.add_argument('size', help='Size of region to erase (must be multiple of 4096)', type=arg_auto_int)\n\n    subparsers.add_parser(\n        'version', help='Print esptool version')\n\n    # internal sanity check - every operation matches a module function of the same name\n    for operation in subparsers.choices.keys():\n        assert operation in globals(), \"%s should be a module function\" % operation\n\n    expand_file_arguments()\n\n    args = parser.parse_args(custom_commandline)\n\n    print('esptool.py v%s' % __version__)\n\n    # operation function can take 1 arg (args), 2 args (esp, arg)\n    # or be a member function of the ESPLoader class.\n\n    if args.operation is None:\n        parser.print_help()\n        sys.exit(1)\n\n    operation_func = globals()[args.operation]\n\n    if PYTHON2:\n        # This function is depreciated in Python3\n        operation_args = inspect.getargspec(operation_func).args\n    else:\n        operation_args = inspect.getfullargspec(operation_func).args\n\n    if operation_args[0] == 'esp':  # operation function takes an ESPLoader connection object\n        if args.before != \"no_reset_no_sync\":\n            initial_baud = min(ESPLoader.ESP_ROM_BAUD, args.baud)  # don't sync faster than the default baud rate\n        else:\n            initial_baud = args.baud\n\n        if args.port is None:\n            ser_list = sorted(ports.device for ports in list_ports.comports())\n            print(\"Found %d serial ports\" % len(ser_list))\n        else:\n            ser_list = [args.port]\n        esp = None\n        for each_port in reversed(ser_list):\n            print(\"Serial port %s\" % each_port)\n            try:\n                if args.chip == 'auto':\n                    esp = ESPLoader.detect_chip(each_port, initial_baud, args.before, args.trace)\n                else:\n                    chip_class = {\n                        'esp8266': ESP8266ROM,\n                        'esp32': ESP32ROM,\n                    }[args.chip]\n                    esp = chip_class(each_port, initial_baud, args.trace)\n                    esp.connect(args.before)\n                break\n            except (FatalError, OSError) as err:\n                if args.port is not None:\n                    raise\n                print(\"%s failed to connect: %s\" % (each_port, err))\n                esp = None\n        if esp is None:\n            raise FatalError(\"Could not connect to an Espressif device on any of the %d available serial ports.\" % len(ser_list))\n\n        print(\"Chip is %s\" % (esp.get_chip_description()))\n\n        print(\"Features: %s\" % \", \".join(esp.get_chip_features()))\n\n        print(\"Crystal is %dMHz\" % esp.get_crystal_freq())\n\n        read_mac(esp, args)\n\n        if not args.no_stub:\n            esp = esp.run_stub()\n\n        if args.override_vddsdio:\n            esp.override_vddsdio(args.override_vddsdio)\n\n        if args.baud > initial_baud:\n            try:\n                esp.change_baud(args.baud)\n            except NotImplementedInROMError:\n                print(\"WARNING: ROM doesn't support changing baud rate. Keeping initial baud rate %d\" % initial_baud)\n\n        # override common SPI flash parameter stuff if configured to do so\n        if hasattr(args, \"spi_connection\") and args.spi_connection is not None:\n            if esp.CHIP_NAME != \"ESP32\":\n                raise FatalError(\"Chip %s does not support --spi-connection option.\" % esp.CHIP_NAME)\n            print(\"Configuring SPI flash mode...\")\n            esp.flash_spi_attach(args.spi_connection)\n        elif args.no_stub:\n            print(\"Enabling default SPI flash mode...\")\n            # ROM loader doesn't enable flash unless we explicitly do it\n            esp.flash_spi_attach(0)\n\n        if hasattr(args, \"flash_size\"):\n            print(\"Configuring flash size...\")\n            detect_flash_size(esp, args)\n            if args.flash_size != 'keep':  # TODO: should set this even with 'keep'\n                esp.flash_set_parameters(flash_size_bytes(args.flash_size))\n\n        try:\n            operation_func(esp, args)\n        finally:\n            try:  # Clean up AddrFilenamePairAction files\n                for address, argfile in args.addr_filename:\n                    argfile.close()\n            except AttributeError:\n                pass\n\n        # Handle post-operation behaviour (reset or other)\n        if operation_func == load_ram:\n            # the ESP is now running the loaded image, so let it run\n            print('Exiting immediately.')\n        elif args.after == 'hard_reset':\n            print('Hard resetting via RTS pin...')\n            esp.hard_reset()\n        elif args.after == 'soft_reset':\n            print('Soft resetting...')\n            # flash_finish will trigger a soft reset\n            esp.soft_reset(False)\n        else:\n            print('Staying in bootloader.')\n            if esp.IS_STUB:\n                esp.soft_reset(True)  # exit stub back to ROM loader\n\n        esp._port.close()\n\n    else:\n        operation_func(args)", "response": "Entry point for esptool. py"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef expand_file_arguments():\n    new_args = []\n    expanded = False\n    for arg in sys.argv:\n        if arg.startswith(\"@\"):\n            expanded = True\n            with open(arg[1:],\"r\") as f:\n                for line in f.readlines():\n                    new_args += shlex.split(line)\n        else:\n            new_args.append(arg)\n    if expanded:\n        print(\"esptool.py %s\" % (\" \".join(new_args[1:])))\n        sys.argv = new_args", "response": "Expand sys. argv to include all values read from a text file."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef detect_chip(port=DEFAULT_PORT, baud=ESP_ROM_BAUD, connect_mode='default_reset', trace_enabled=False):\n        detect_port = ESPLoader(port, baud, trace_enabled=trace_enabled)\n        detect_port.connect(connect_mode)\n        try:\n            print('Detecting chip type...', end='')\n            sys.stdout.flush()\n            date_reg = detect_port.read_reg(ESPLoader.UART_DATA_REG_ADDR)\n\n            for cls in [ESP8266ROM, ESP32ROM]:\n                if date_reg == cls.DATE_REG_VALUE:\n                    # don't connect a second time\n                    inst = cls(detect_port._port, baud, trace_enabled=trace_enabled)\n                    print(' %s' % inst.CHIP_NAME, end='')\n                    return inst\n        finally:\n            print('')  # end line\n        raise FatalError(\"Unexpected UART datecode value 0x%08x. Failed to autodetect chip type.\" % date_reg)", "response": "Detect the chip type."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef check_command(self, op_description, op=None, data=b'', chk=0, timeout=DEFAULT_TIMEOUT):\n        val, data = self.command(op, data, chk, timeout=timeout)\n\n        # things are a bit weird here, bear with us\n\n        # the status bytes are the last 2/4 bytes in the data (depending on chip)\n        if len(data) < self.STATUS_BYTES_LENGTH:\n            raise FatalError(\"Failed to %s. Only got %d byte status response.\" % (op_description, len(data)))\n        status_bytes = data[-self.STATUS_BYTES_LENGTH:]\n        # we only care if the first one is non-zero. If it is, the second byte is a reason.\n        if byte(status_bytes, 0) != 0:\n            raise FatalError.WithResult('Failed to %s' % op_description, status_bytes)\n\n        # if we had more data than just the status bytes, return it as the result\n        # (this is used by the md5sum command, maybe other commands?)\n        if len(data) > self.STATUS_BYTES_LENGTH:\n            return data[:-self.STATUS_BYTES_LENGTH]\n        else:  # otherwise, just return the 'val' field which comes from the reply header (this is used by read_reg)\n            return val", "response": "Execute a command with command and return the result."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef connect(self, mode='default_reset'):\n        print('Connecting...', end='')\n        sys.stdout.flush()\n        last_error = None\n\n        try:\n            for _ in range(7):\n                last_error = self._connect_attempt(mode=mode, esp32r0_delay=False)\n                if last_error is None:\n                    return\n                last_error = self._connect_attempt(mode=mode, esp32r0_delay=True)\n                if last_error is None:\n                    return\n        finally:\n            print('')  # end 'Connecting...' line\n        raise FatalError('Failed to connect to %s: %s' % (self.CHIP_NAME, last_error))", "response": "Try to connect to the current instance of the class."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nread memory from target", "response": "def read_reg(self, addr):\n        \"\"\" Read memory address in target \"\"\"\n        # we don't call check_command here because read_reg() function is called\n        # when detecting chip type, and the way we check for success (STATUS_BYTES_LENGTH) is different\n        # for different chip types (!)\n        val, data = self.command(self.ESP_READ_REG, struct.pack('<I', addr))\n        if byte(data, 0) != 0:\n            raise FatalError.WithResult(\"Failed to read register address %08x\" % addr, data)\n        return val"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef write_reg(self, addr, value, mask=0xFFFFFFFF, delay_us=0):\n        return self.check_command(\"write target memory\", self.ESP_WRITE_REG,\n                                  struct.pack('<IIII', addr, value, mask, delay_us))", "response": "Write to memory address in target"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nupdate the bits in the specified register at addr with the new value.", "response": "def update_reg(self, addr, mask, new_val):\n        \"\"\" Update register at 'addr', replace the bits masked out by 'mask'\n        with new_val. new_val is shifted left to match the LSB of 'mask'\n\n        Returns just-written value of register.\n        \"\"\"\n        shift = _mask_to_shift(mask)\n        val = self.read_reg(addr)\n        val &= ~mask\n        val |= (new_val << shift) & mask\n        self.write_reg(addr, val)\n\n        return val"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef flash_defl_begin(self, size, compsize, offset):\n        num_blocks = (compsize + self.FLASH_WRITE_SIZE - 1) // self.FLASH_WRITE_SIZE\n        erase_blocks = (size + self.FLASH_WRITE_SIZE - 1) // self.FLASH_WRITE_SIZE\n\n        t = time.time()\n        if self.IS_STUB:\n            write_size = size  # stub expects number of bytes here, manages erasing internally\n            timeout = DEFAULT_TIMEOUT\n        else:\n            write_size = erase_blocks * self.FLASH_WRITE_SIZE  # ROM expects rounded up to erase block size\n            timeout = timeout_per_mb(ERASE_REGION_TIMEOUT_PER_MB, write_size)  # ROM performs the erase up front\n        print(\"Compressed %d bytes to %d...\" % (size, compsize))\n        self.check_command(\"enter compressed flash mode\", self.ESP_FLASH_DEFL_BEGIN,\n                           struct.pack('<IIII', write_size, num_blocks, self.FLASH_WRITE_SIZE, offset),\n                           timeout=timeout)\n        if size != 0 and not self.IS_STUB:\n            # (stub erases as it writes, but ROM loaders erase on begin)\n            print(\"Took %.2fs to erase flash block\" % (time.time() - t))\n        return num_blocks", "response": "Start downloading compressed data to Flash"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef flash_spi_attach(self, hspi_arg):\n        # last 3 bytes in ESP_SPI_ATTACH argument are reserved values\n        arg = struct.pack('<I', hspi_arg)\n        if not self.IS_STUB:\n            # ESP32 ROM loader takes additional 'is legacy' arg, which is not\n            # currently supported in the stub loader or esptool.py (as it's not usually needed.)\n            is_legacy = 0\n            arg += struct.pack('BBBB', is_legacy, 0, 0, 0)\n        self.check_command(\"configure SPI flash pins\", ESP32ROM.ESP_SPI_ATTACH, arg)", "response": "Send SPI attach command to enable the SPI flash pins"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ntell the ESP bootloader the parameters of the ESP bootloader that the chip has in RAM and size.", "response": "def flash_set_parameters(self, size):\n        \"\"\"Tell the ESP bootloader the parameters of the chip\n\n        Corresponds to the \"flashchip\" data structure that the ROM\n        has in RAM.\n\n        'size' is in bytes.\n\n        All other flash parameters are currently hardcoded (on ESP8266\n        these are mostly ignored by ROM code, on ESP32 I'm not sure.)\n        \"\"\"\n        fl_id = 0\n        total_size = size\n        block_size = 64 * 1024\n        sector_size = 4 * 1024\n        page_size = 256\n        status_mask = 0xffff\n        self.check_command(\"set SPI params\", ESP32ROM.ESP_SPI_SET_PARAMS,\n                           struct.pack('<IIIIII', fl_id, total_size, block_size, sector_size, page_size, status_mask))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef run_spiflash_command(self, spiflash_command, data=b\"\", read_bits=0):\n\n        # SPI_USR register flags\n        SPI_USR_COMMAND = (1 << 31)\n        SPI_USR_MISO    = (1 << 28)\n        SPI_USR_MOSI    = (1 << 27)\n\n        # SPI registers, base address differs ESP32 vs 8266\n        base = self.SPI_REG_BASE\n        SPI_CMD_REG       = base + 0x00\n        SPI_USR_REG       = base + 0x1C\n        SPI_USR1_REG      = base + 0x20\n        SPI_USR2_REG      = base + 0x24\n        SPI_W0_REG        = base + self.SPI_W0_OFFS\n\n        # following two registers are ESP32 only\n        if self.SPI_HAS_MOSI_DLEN_REG:\n            # ESP32 has a more sophisticated wayto set up \"user\" commands\n            def set_data_lengths(mosi_bits, miso_bits):\n                SPI_MOSI_DLEN_REG = base + 0x28\n                SPI_MISO_DLEN_REG = base + 0x2C\n                if mosi_bits > 0:\n                    self.write_reg(SPI_MOSI_DLEN_REG, mosi_bits - 1)\n                if miso_bits > 0:\n                    self.write_reg(SPI_MISO_DLEN_REG, miso_bits - 1)\n        else:\n\n            def set_data_lengths(mosi_bits, miso_bits):\n                SPI_DATA_LEN_REG = SPI_USR1_REG\n                SPI_MOSI_BITLEN_S = 17\n                SPI_MISO_BITLEN_S = 8\n                mosi_mask = 0 if (mosi_bits == 0) else (mosi_bits - 1)\n                miso_mask = 0 if (miso_bits == 0) else (miso_bits - 1)\n                self.write_reg(SPI_DATA_LEN_REG,\n                               (miso_mask << SPI_MISO_BITLEN_S) | (\n                                   mosi_mask << SPI_MOSI_BITLEN_S))\n\n        # SPI peripheral \"command\" bitmasks for SPI_CMD_REG\n        SPI_CMD_USR  = (1 << 18)\n\n        # shift values\n        SPI_USR2_DLEN_SHIFT = 28\n\n        if read_bits > 32:\n            raise FatalError(\"Reading more than 32 bits back from a SPI flash operation is unsupported\")\n        if len(data) > 64:\n            raise FatalError(\"Writing more than 64 bytes of data with one SPI command is unsupported\")\n\n        data_bits = len(data) * 8\n        old_spi_usr = self.read_reg(SPI_USR_REG)\n        old_spi_usr2 = self.read_reg(SPI_USR2_REG)\n        flags = SPI_USR_COMMAND\n        if read_bits > 0:\n            flags |= SPI_USR_MISO\n        if data_bits > 0:\n            flags |= SPI_USR_MOSI\n        set_data_lengths(data_bits, read_bits)\n        self.write_reg(SPI_USR_REG, flags)\n        self.write_reg(SPI_USR2_REG,\n                       (7 << SPI_USR2_DLEN_SHIFT) | spiflash_command)\n        if data_bits == 0:\n            self.write_reg(SPI_W0_REG, 0)  # clear data register before we read it\n        else:\n            data = pad_to(data, 4, b'\\00')  # pad to 32-bit multiple\n            words = struct.unpack(\"I\" * (len(data) // 4), data)\n            next_reg = SPI_W0_REG\n            for word in words:\n                self.write_reg(next_reg, word)\n                next_reg += 4\n        self.write_reg(SPI_CMD_REG, SPI_CMD_USR)\n\n        def wait_done():\n            for _ in range(10):\n                if (self.read_reg(SPI_CMD_REG) & SPI_CMD_USR) == 0:\n                    return\n            raise FatalError(\"SPI command did not complete in time\")\n        wait_done()\n\n        status = self.read_reg(SPI_W0_REG)\n        # restore some SPI controller registers\n        self.write_reg(SPI_USR_REG, old_spi_usr)\n        self.write_reg(SPI_USR2_REG, old_spi_usr2)\n        return status", "response": "This function runs an arbitrary SPI flash command."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef read_status(self, num_bytes=2):\n        SPIFLASH_RDSR  = 0x05\n        SPIFLASH_RDSR2 = 0x35\n        SPIFLASH_RDSR3 = 0x15\n\n        status = 0\n        shift = 0\n        for cmd in [SPIFLASH_RDSR, SPIFLASH_RDSR2, SPIFLASH_RDSR3][0:num_bytes]:\n            status += self.run_spiflash_command(cmd, read_bits=8) << shift\n            shift += 8\n        return status", "response": "Read up to num_bytes of SPI flash status register contents."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nwrite up to 24 bits of new status register.", "response": "def write_status(self, new_status, num_bytes=2, set_non_volatile=False):\n        \"\"\"Write up to 24 bits (num_bytes) of new status register\n\n        num_bytes can be 1, 2 or 3.\n\n        Not all flash supports the additional commands to write the\n        second and third byte of the status register. When writing 2\n        bytes, esptool also sends a 16-byte WRSR command (as some\n        flash types use this instead of WRSR2.)\n\n        If the set_non_volatile flag is set, non-volatile bits will\n        be set as well as volatile ones (WREN used instead of WEVSR).\n\n        \"\"\"\n        SPIFLASH_WRSR = 0x01\n        SPIFLASH_WRSR2 = 0x31\n        SPIFLASH_WRSR3 = 0x11\n        SPIFLASH_WEVSR = 0x50\n        SPIFLASH_WREN = 0x06\n        SPIFLASH_WRDI = 0x04\n\n        enable_cmd = SPIFLASH_WREN if set_non_volatile else SPIFLASH_WEVSR\n\n        # try using a 16-bit WRSR (not supported by all chips)\n        # this may be redundant, but shouldn't hurt\n        if num_bytes == 2:\n            self.run_spiflash_command(enable_cmd)\n            self.run_spiflash_command(SPIFLASH_WRSR, struct.pack(\"<H\", new_status))\n\n        # also try using individual commands (also not supported by all chips for num_bytes 2 & 3)\n        for cmd in [SPIFLASH_WRSR, SPIFLASH_WRSR2, SPIFLASH_WRSR3][0:num_bytes]:\n            self.run_spiflash_command(enable_cmd)\n            self.run_spiflash_command(cmd, struct.pack(\"B\", new_status & 0xFF))\n            new_status >>= 8\n\n        self.run_spiflash_command(SPIFLASH_WRDI)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef chip_id(self):\n        id0 = self.read_reg(self.ESP_OTP_MAC0)\n        id1 = self.read_reg(self.ESP_OTP_MAC1)\n        return (id0 >> 24) | ((id1 & MAX_UINT24) << 8)", "response": "Read the chip ID from efuse"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef read_mac(self):\n        mac0 = self.read_reg(self.ESP_OTP_MAC0)\n        mac1 = self.read_reg(self.ESP_OTP_MAC1)\n        mac3 = self.read_reg(self.ESP_OTP_MAC3)\n        if (mac3 != 0):\n            oui = ((mac3 >> 16) & 0xff, (mac3 >> 8) & 0xff, mac3 & 0xff)\n        elif ((mac1 >> 16) & 0xff) == 0:\n            oui = (0x18, 0xfe, 0x34)\n        elif ((mac1 >> 16) & 0xff) == 1:\n            oui = (0xac, 0xd0, 0x74)\n        else:\n            raise FatalError(\"Unknown OUI\")\n        return oui + ((mac1 >> 8) & 0xff, mac1 & 0xff, (mac0 >> 24) & 0xff)", "response": "Read MAC from OTP ROM"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_erase_size(self, offset, size):\n\n        sectors_per_block = 16\n        sector_size = self.FLASH_SECTOR_SIZE\n        num_sectors = (size + sector_size - 1) // sector_size\n        start_sector = offset // sector_size\n\n        head_sectors = sectors_per_block - (start_sector % sectors_per_block)\n        if num_sectors < head_sectors:\n            head_sectors = num_sectors\n\n        if num_sectors < 2 * head_sectors:\n            return (num_sectors + 1) // 2 * sector_size\n        else:\n            return (num_sectors - head_sectors) * sector_size", "response": "Calculate an erase size given a specific offset and size in bytes."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns True if the flash encryption key is valid.", "response": "def is_flash_encryption_key_valid(self):\n\n        \"\"\" Bit 0 of efuse_rd_disable[3:0] is mapped to BLOCK1\n        this bit is at position 16 in EFUSE_BLK0_RDATA0_REG \"\"\"\n        word0 = self.read_efuse(0)\n        rd_disable = (word0 >> 16) & 0x1\n\n        # reading of BLOCK1 is NOT ALLOWED so we assume valid key is programmed\n        if rd_disable:\n            return True\n        else:\n            \"\"\" reading of BLOCK1 is ALLOWED so we will read and verify for non-zero.\n            When ESP32 has not generated AES/encryption key in BLOCK1, the contents will be readable and 0.\n            If the flash encryption is enabled it is expected to have a valid non-zero key. We break out on\n            first occurance of non-zero value \"\"\"\n            key_word = [0] * 7\n            for i in range(len(key_word)):\n                key_word[i] = self.read_efuse(14 + i)\n                # key is non-zero so break & return\n                if key_word[i] != 0:\n                    return True\n            return False"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_flash_crypt_config(self):\n        word0 = self.read_efuse(0)\n        rd_disable = (word0 >> 19) & 0x1\n\n        if rd_disable == 0:\n            \"\"\" we can read the flash_crypt_config efuse value\n            so go & read it (EFUSE_BLK0_RDATA5_REG[31:28]) \"\"\"\n            word5 = self.read_efuse(5)\n            word5 = (word5 >> 28) & 0xF\n            return word5\n        else:\n            # if read of the efuse is disabled we assume it is set correctly\n            return 0xF", "response": "get the flash_crypt_config efuse value"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef read_mac(self):\n        words = [self.read_efuse(2), self.read_efuse(1)]\n        bitstring = struct.pack(\">II\", *words)\n        bitstring = bitstring[2:8]  # trim the 2 byte CRC\n        try:\n            return tuple(ord(b) for b in bitstring)\n        except TypeError:  # Python 3, bitstring elements are already bytes\n            return tuple(bitstring)", "response": "Read the MAC from the EFUSE region"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a new ImageSegment which splits the image from the beginning of the data.", "response": "def split_image(self, split_len):\n        \"\"\" Return a new ImageSegment which splits \"split_len\" bytes\n        from the beginning of the data. Remaining bytes are kept in\n        this segment object (and the start address is adjusted to match.) \"\"\"\n        result = copy.copy(self)\n        result.data = self.data[:split_len]\n        self.data = self.data[split_len:]\n        self.addr += split_len\n        self.file_offs = None\n        result.file_offs = None\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nloading the next segment from the image file", "response": "def load_segment(self, f, is_irom_segment=False):\n        \"\"\" Load the next segment from the image file \"\"\"\n        file_offs = f.tell()\n        (offset, size) = struct.unpack('<II', f.read(8))\n        self.warn_if_unusual_segment(offset, size, is_irom_segment)\n        segment_data = f.read(size)\n        if len(segment_data) < size:\n            raise FatalError('End of file reading segment 0x%x, length %d (actual length %d)' % (offset, size, len(segment_data)))\n        segment = ImageSegment(offset, segment_data, file_offs)\n        self.segments.append(segment)\n        return segment"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef maybe_patch_segment_data(self, f, segment_data):\n        segment_len = len(segment_data)\n        file_pos = f.tell()  # file_pos is position in the .bin file\n        if self.elf_sha256_offset >= file_pos and self.elf_sha256_offset < file_pos + segment_len:\n            # SHA256 digest needs to be patched into this binary segment,\n            # calculate offset of the digest inside the binary segment.\n            patch_offset = self.elf_sha256_offset - file_pos\n            # Sanity checks\n            if patch_offset < self.SEG_HEADER_LEN or patch_offset + self.SHA256_DIGEST_LEN > segment_len:\n                raise FatalError('Cannot place SHA256 digest on segment boundary' +\n                                 '(elf_sha256_offset=%d, file_pos=%d, segment_size=%d)' %\n                                 (self.elf_sha256_offset, file_pos, segment_len))\n            if segment_data[patch_offset:patch_offset + self.SHA256_DIGEST_LEN] != b'\\x00' * self.SHA256_DIGEST_LEN:\n                raise FatalError('Contents of segment at SHA256 digest offset 0x%x are not all zero. Refusing to overwrite.' %\n                                 self.elf_sha256_offset)\n            assert(len(self.elf_sha256) == self.SHA256_DIGEST_LEN)\n            # offset relative to the data part\n            patch_offset -= self.SEG_HEADER_LEN\n            segment_data = segment_data[0:patch_offset] + self.elf_sha256 + \\\n                segment_data[patch_offset + self.SHA256_DIGEST_LEN:]\n        return segment_data", "response": "If the SHA256 digest of the ELF file needs to be inserted into this segment do so. Returns segment data."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsaving the next segment to the image file return the checksum value if provided", "response": "def save_segment(self, f, segment, checksum=None):\n        \"\"\" Save the next segment to the image file, return next checksum value if provided \"\"\"\n        segment_data = self.maybe_patch_segment_data(f, segment.data)\n        f.write(struct.pack('<II', segment.addr, len(segment_data)))\n        f.write(segment_data)\n        if checksum is not None:\n            return ESPLoader.checksum(segment_data, checksum)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef calculate_checksum(self):\n        checksum = ESPLoader.ESP_CHECKSUM_MAGIC\n        for seg in self.segments:\n            if seg.include_in_checksum:\n                checksum = ESPLoader.checksum(seg.data, checksum)\n        return checksum", "response": "Calculate checksum of loaded image based on segments in the segment array."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nappends checksum to the just - written image", "response": "def append_checksum(self, f, checksum):\n        \"\"\" Append ESPLoader checksum to the just-written image \"\"\"\n        align_file_position(f, 16)\n        f.write(struct.pack(b'B', checksum))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsaving a set of V1 images for flashing. Parameter is a base filename.", "response": "def save(self, basename):\n        \"\"\" Save a set of V1 images for flashing. Parameter is a base filename. \"\"\"\n        # IROM data goes in its own plain binary file\n        irom_segment = self.get_irom_segment()\n        if irom_segment is not None:\n            with open(\"%s0x%05x.bin\" % (basename, irom_segment.addr - ESP8266ROM.IROM_MAP_START), \"wb\") as f:\n                f.write(irom_segment.data)\n\n        # everything but IROM goes at 0x00000 in an image file\n        normal_segments = self.get_non_irom_segments()\n        with open(\"%s0x00000.bin\" % basename, 'wb') as f:\n            self.write_common_header(f, normal_segments)\n            checksum = ESPLoader.ESP_CHECKSUM_MAGIC\n            for segment in normal_segments:\n                checksum = self.save_segment(f, segment, checksum)\n            self.append_checksum(f, checksum)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nderiving a default output name from the ELF name.", "response": "def default_output_name(self, input_file):\n        \"\"\" Derive a default output name from the ELF name. \"\"\"\n        irom_segment = self.get_irom_segment()\n        if irom_segment is not None:\n            irom_offs = irom_segment.addr - ESP8266ROM.IROM_MAP_START\n        else:\n            irom_offs = 0\n        return \"%s-0x%05x.bin\" % (os.path.splitext(input_file)[0],\n                                  irom_offs & ~(ESPLoader.FLASH_SECTOR_SIZE - 1))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef save_flash_segment(self, f, segment, checksum=None):\n        segment_end_pos = f.tell() + len(segment.data) + self.SEG_HEADER_LEN\n        segment_len_remainder = segment_end_pos % self.IROM_ALIGN\n        if segment_len_remainder < 0x24:\n            # Work around a bug in ESP-IDF 2nd stage bootloader, that it didn't map the\n            # last MMU page, if an IROM/DROM segment was < 0x24 bytes over the page boundary.\n            segment.data += b'\\x00' * (0x24 - segment_len_remainder)\n        return self.save_segment(f, segment, checksum)", "response": "Save the next segment to the image file return the checksum value if provided"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsigns a digest using a deterministic algorithm.", "response": "def sign_digest_deterministic(self, digest, hashfunc=None, sigencode=sigencode_string):\n        \"\"\"\n        Calculates 'k' from data itself, removing the need for strong\n        random generator and producing deterministic (reproducible) signatures.\n        See RFC 6979 for more details.\n        \"\"\"\n        secexp = self.privkey.secret_multiplier\n        k = rfc6979.generate_k(\n            self.curve.generator.order(), secexp, hashfunc, digest)\n\n        return self.sign_digest(digest, sigencode=sigencode, k=k)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsign data with the key k.", "response": "def sign(self, data, entropy=None, hashfunc=None, sigencode=sigencode_string, k=None):\n        \"\"\"\n        hashfunc= should behave like hashlib.sha1 . The output length of the\n        hash (in bytes) must not be longer than the length of the curve order\n        (rounded up to the nearest byte), so using SHA256 with nist256p is\n        ok, but SHA256 with nist192p is not. (In the 2**-96ish unlikely event\n        of a hash output larger than the curve order, the hash will\n        effectively be wrapped mod n).\n\n        Use hashfunc=hashlib.sha1 to match openssl's -ecdsa-with-SHA1 mode,\n        or hashfunc=hashlib.sha256 for openssl-1.0.0's -ecdsa-with-SHA256.\n        \"\"\"\n\n        hashfunc = hashfunc or self.default_hashfunc\n        h = hashfunc(data).digest()\n        return self.sign_digest(h, entropy, sigencode, k)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nwrapping an ELF file into a stub dict", "response": "def wrap_stub(elf_file):\n    \"\"\" Wrap an ELF file into a stub 'dict' \"\"\"\n    print('Wrapping ELF file %s...' % elf_file)\n    e = esptool.ELFFile(elf_file)\n\n    text_section = e.get_section('.text')\n    try:\n        data_section = e.get_section('.data')\n    except ValueError:\n        data_section = None\n    stub = {\n         'text': text_section.data,\n         'text_start': text_section.addr,\n         'entry': e.entrypoint,\n        }\n    if data_section is not None:\n        stub['data'] = data_section.data\n        stub['data_start'] = data_section.addr\n\n    # Pad text with NOPs to mod 4.\n    if len(stub['text']) % 4 != 0:\n        stub['text'] += (4 - (len(stub['text']) % 4)) * '\\0'\n\n    print('Stub text: %d @ 0x%08x, data: %d @ 0x%08x, entry @ 0x%x' % (\n        len(stub['text']), stub['text_start'],\n        len(stub.get('data', '')), stub.get('data_start', 0),\n        stub['entry']), file=sys.stderr)\n    return stub"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngenerating the key for the private key of the DSA.", "response": "def generate_k(order, secexp, hash_func, data):\n    '''\n        order - order of the DSA generator used in the signature\n        secexp - secure exponent (private key) in numeric form\n        hash_func - reference to the same hash function used for generating hash\n        data - hash in binary form of the signing data\n    '''\n\n    qlen = bit_length(order)\n    holen = hash_func().digest_size\n    rolen = (qlen + 7) / 8\n    bx = number_to_string(secexp, order) + bits2octets(data, order)\n\n    # Step B\n    v = b('\\x01') * holen\n\n    # Step C\n    k = b('\\x00') * holen\n\n    # Step D\n\n    k = hmac.new(k, v+b('\\x00')+bx, hash_func).digest()\n\n    # Step E\n    v = hmac.new(k, v, hash_func).digest()\n\n    # Step F\n    k = hmac.new(k, v+b('\\x01')+bx, hash_func).digest()\n\n    # Step G\n    v = hmac.new(k, v, hash_func).digest()\n\n    # Step H\n    while True:\n        # Step H1\n        t = b('')\n\n        # Step H2\n        while len(t) < rolen:\n            v = hmac.new(k, v, hash_func).digest()\n            t += v\n\n        # Step H3\n        secret = bits2int(t, qlen)\n\n        if secret >= 1 and secret < order:\n            return secret\n\n        k = hmac.new(k, v+b('\\x00'), hash_func).digest()\n        v = hmac.new(k, v, hash_func).digest()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_chunks(source, chunk_len):\n    return (source[i: i + chunk_len] for i in range(0, len(source), chunk_len))", "response": "Returns an iterator over chunk_len chunks of source"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef endian_swap_words(source):\n    assert len(source) % 4 == 0\n    words = \"I\" * (len(source) // 4)\n    return struct.pack(\"<\" + words, *struct.unpack(\">\" + words, source))", "response": "Endian - swap each word in source bitstring"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nswapping the order of the words in source bitstring", "response": "def swap_word_order(source):\n    \"\"\" Swap the order of the words in 'source' bitstring \"\"\"\n    assert len(source) % 4 == 0\n    words = \"I\" * (len(source) // 4)\n    return struct.pack(words, *reversed(struct.unpack(words, source)))"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nloads a 256 - bit key from a file.", "response": "def _load_hardware_key(keyfile):\n    \"\"\" Load a 256-bit key, similar to stored in efuse, from a file\n\n    192-bit keys will be extended to 256-bit using the same algorithm used\n    by hardware if 3/4 Coding Scheme is set.\n    \"\"\"\n    key = keyfile.read()\n    if len(key) not in [24, 32]:\n        raise esptool.FatalError(\"Key file contains wrong length (%d bytes), 24 or 32 expected.\" % len(key))\n    if len(key) == 24:\n        key = key + key[8:16]\n        print(\"Using 192-bit key (extended)\")\n    else:\n        print(\"Using 256-bit key\")\n\n    assert len(key) == 32\n    return key"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncalculate the digest of a secure bootloader image.", "response": "def digest_secure_bootloader(args):\n    \"\"\" Calculate the digest of a bootloader image, in the same way the hardware\n    secure boot engine would do so. Can be used with a pre-loaded key to update a\n    secure bootloader. \"\"\"\n    if args.iv is not None:\n        print(\"WARNING: --iv argument is for TESTING PURPOSES ONLY\")\n        iv = args.iv.read(128)\n    else:\n        iv = os.urandom(128)\n    plaintext_image = args.image.read()\n    args.image.seek(0)\n\n    # secure boot engine reads in 128 byte blocks (ie SHA512 block\n    # size), but also doesn't look for any appended SHA-256 digest\n    fw_image = esptool.ESP32FirmwareImage(args.image)\n    if fw_image.append_digest:\n        if len(plaintext_image) % 128 <= 32:\n            # ROM bootloader will read to the end of the 128 byte block, but not\n            # to the end of the SHA-256 digest at the end\n            new_len = len(plaintext_image) - (len(plaintext_image) % 128)\n            plaintext_image = plaintext_image[:new_len]\n\n    # if image isn't 128 byte multiple then pad with 0xFF (ie unwritten flash)\n    # as this is what the secure boot engine will see\n    if len(plaintext_image) % 128 != 0:\n        plaintext_image += b\"\\xFF\" * (128 - (len(plaintext_image) % 128))\n\n    plaintext = iv + plaintext_image\n\n    # Secure Boot digest algorithm in hardware uses AES256 ECB to\n    # produce a ciphertext, then feeds output through SHA-512 to\n    # produce the digest. Each block in/out of ECB is reordered\n    # (due to hardware quirks not for security.)\n\n    key = _load_hardware_key(args.keyfile)\n    aes = pyaes.AESModeOfOperationECB(key)\n    digest = hashlib.sha512()\n\n    for block in get_chunks(plaintext, 16):\n        block = block[::-1]  # reverse each input block\n\n        cipher_block = aes.encrypt(block)\n        # reverse and then byte swap each word in the output block\n        cipher_block = cipher_block[::-1]\n        for block in get_chunks(cipher_block, 4):\n            # Python hashlib can build each SHA block internally\n            digest.update(block[::-1])\n\n    if args.output is None:\n        args.output = os.path.splitext(args.image.name)[0] + \"-digest-0x0000.bin\"\n    with open(args.output, \"wb\") as f:\n        f.write(iv)\n        digest = digest.digest()\n        for word in get_chunks(digest, 4):\n            f.write(word[::-1])  # swap word order in the result\n        f.write(b'\\xFF' * (0x1000 - f.tell()))  # pad to 0x1000\n        f.write(plaintext_image)\n    print(\"digest+image written to %s\" % args.output)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngenerates an ECDSA signing key for signing secure boot images", "response": "def generate_signing_key(args):\n    \"\"\" Generate an ECDSA signing key for signing secure boot images (post-bootloader) \"\"\"\n    if os.path.exists(args.keyfile):\n        raise esptool.FatalError(\"ERROR: Key file %s already exists\" % args.keyfile)\n    sk = ecdsa.SigningKey.generate(curve=ecdsa.NIST256p)\n    with open(args.keyfile, \"wb\") as f:\n        f.write(sk.to_pem())\n    print(\"ECDSA NIST256p private key in PEM format written to %s\" % args.keyfile)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef sign_data(args):\n    sk = _load_ecdsa_signing_key(args)\n\n    # calculate signature of binary data\n    binary_content = args.datafile.read()\n    signature = sk.sign_deterministic(binary_content, hashlib.sha256)\n\n    # back-verify signature\n    vk = sk.get_verifying_key()\n    vk.verify(signature, binary_content, hashlib.sha256)  # throws exception on failure\n\n    if args.output is None or os.path.abspath(args.output) == os.path.abspath(args.datafile.name):  # append signature to input file\n        args.datafile.close()\n        outfile = open(args.datafile.name, \"ab\")\n    else:  # write file & signature to new file\n        outfile = open(args.output, \"wb\")\n        outfile.write(binary_content)\n    outfile.write(struct.pack(\"I\", 0))  # Version indicator, allow for different curves/formats later\n    outfile.write(signature)\n    outfile.close()\n    print(\"Signed %d bytes of data from %s with key %s\" % (len(binary_content), args.datafile.name, args.keyfile.name))", "response": "Sign a data file with a ECDSA private key and append binary signature to file contents"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nverifies a previously signed binary image using the ECDSA public key", "response": "def verify_signature(args):\n    \"\"\" Verify a previously signed binary image, using the ECDSA public key \"\"\"\n    key_data = args.keyfile.read()\n    if b\"-BEGIN EC PRIVATE KEY\" in key_data:\n        sk = ecdsa.SigningKey.from_pem(key_data)\n        vk = sk.get_verifying_key()\n    elif b\"-BEGIN PUBLIC KEY\" in key_data:\n        vk = ecdsa.VerifyingKey.from_pem(key_data)\n    elif len(key_data) == 64:\n        vk = ecdsa.VerifyingKey.from_string(key_data,\n                                            curve=ecdsa.NIST256p)\n    else:\n        raise esptool.FatalError(\"Verification key does not appear to be an EC key in PEM format or binary EC public key data. Unsupported\")\n\n    if vk.curve != ecdsa.NIST256p:\n        raise esptool.FatalError(\"Public key uses incorrect curve. ESP32 Secure Boot only supports NIST256p (openssl calls this curve 'prime256v1\")\n\n    binary_content = args.datafile.read()\n    data = binary_content[0:-68]\n    sig_version, signature = struct.unpack(\"I64s\", binary_content[-68:])\n    if sig_version != 0:\n        raise esptool.FatalError(\"Signature block has version %d. This version  of espsecure only supports version 0.\" % sig_version)\n    print(\"Verifying %d bytes of data\" % len(data))\n    try:\n        if vk.verify(signature, data, hashlib.sha256):\n            print(\"Signature is valid\")\n        else:\n            raise esptool.FatalError(\"Signature is not valid\")\n    except ecdsa.keys.BadSignatureError:\n        raise esptool.FatalError(\"Signature is not valid\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nloads an ECDSA private key and extract the embedded public key as raw binary data.", "response": "def extract_public_key(args):\n    \"\"\" Load an ECDSA private key and extract the embedded public key as raw binary data. \"\"\"\n    sk = _load_ecdsa_signing_key(args)\n    vk = sk.get_verifying_key()\n    args.public_keyfile.write(vk.to_string())\n    print(\"%s public key extracted to %s\" % (args.keyfile.name, args.public_keyfile.name))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _flash_encryption_tweak_range(flash_crypt_config=0xF):\n    tweak_range = []\n    if (flash_crypt_config & 1) != 0:\n        tweak_range += range(67)\n    if (flash_crypt_config & 2) != 0:\n        tweak_range += range(67, 132)\n    if (flash_crypt_config & 4) != 0:\n        tweak_range += range(132, 195)\n    if (flash_crypt_config & 8) != 0:\n        tweak_range += range(195, 256)\n    return tweak_range", "response": "Return a list of the bit indexes that the key tweak applies to the flash encryption."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _flash_encryption_tweak_key(key, offset, tweak_range):\n    if esptool.PYTHON2:\n        key = [ord(k) for k in key]\n    else:\n        key = list(key)\n    assert len(key) == 32\n\n    offset_bits = [(offset & (1 << x)) != 0 for x in range(24)]\n\n    for bit in tweak_range:\n        if offset_bits[_FLASH_ENCRYPTION_TWEAK_PATTERN[bit]]:\n            # note that each byte has a backwards bit order, compared\n            # to how it is looked up in the tweak pattern table\n            key[bit // 8] ^= 1 << (7 - (bit % 8))\n\n    if esptool.PYTHON2:\n        return b\"\".join(chr(k) for k in key)\n    else:\n        return bytes(key)", "response": "Apply XOR tweak values to the key derived from flash offset\n    offset."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nconverting integer x into a string of bytes.", "response": "def int_to_string( x ):\n  \"\"\"Convert integer x into a string of bytes, as per X9.62.\"\"\"\n  assert x >= 0\n  if x == 0: return b('\\0')\n  result = []\n  while x:\n    ordinal = x & 0xFF\n    result.append(int2byte(ordinal))\n    x >>= 8\n\n  result.reverse()\n  return b('').join(result)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconverts a string of bytes into an integer as per X9. 62.", "response": "def string_to_int( s ):\n  \"\"\"Convert a string of bytes into an integer, as per X9.62.\"\"\"\n  result = 0\n  for c in s:\n    if not isinstance(c, int): c = ord( c )\n    result = 256 * result + c\n  return result"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef point_is_valid( generator, x, y ):\n\n  # These are the tests specified in X9.62.\n\n  n = generator.order()\n  curve = generator.curve()\n  if x < 0 or n <= x or y < 0 or n <= y:\n    return False\n  if not curve.contains_point( x, y ):\n    return False\n  if not n*ellipticcurve.Point( curve, x, y ) == \\\n     ellipticcurve.INFINITY:\n    return False\n  return True", "response": "Is the point x y a valid public key based on the specified generator?"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef verifies( self, hash, signature ):\n\n    # From X9.62 J.3.1.\n\n    G = self.generator\n    n = G.order()\n    r = signature.r\n    s = signature.s\n    if r < 1 or r > n-1: return False\n    if s < 1 or s > n-1: return False\n    c = numbertheory.inverse_mod( s, n )\n    u1 = ( hash * c ) % n\n    u2 = ( r * c ) % n\n    xy = u1 * G + u2 * self.point\n    v = xy.x() % n\n    return v == r", "response": "Verify that signature is a valid signature of hash Return True if the signature is valid."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef sign( self, hash, random_k ):\n\n    G = self.public_key.generator\n    n = G.order()\n    k = random_k % n\n    p1 = k * G\n    r = p1.x()\n    if r == 0: raise RuntimeError(\"amazingly unlucky random number r\")\n    s = ( numbertheory.inverse_mod( k, n ) * \\\n          ( hash + ( self.secret_multiplier * r ) % n ) ) % n\n    if s == 0: raise RuntimeError(\"amazingly unlucky random number s\")\n    return Signature( r, s )", "response": "Return a signature for the provided hash using the provided random nonce."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nraise base to exponent reducing by modulus", "response": "def modular_exp( base, exponent, modulus ):\n  \"Raise base to exponent, reducing by modulus\"\n  if exponent < 0:\n    raise NegativeExponentError( \"Negative exponents (%d) not allowed\" \\\n                                 % exponent )\n  return pow( base, exponent, modulus )"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef polynomial_reduce_mod( poly, polymod, p ):\n\n  # This module has been tested only by extensive use\n  # in calculating modular square roots.\n\n  # Just to make this easy, require a monic polynomial:\n  assert polymod[-1] == 1\n\n  assert len( polymod ) > 1\n\n  while len( poly ) >= len( polymod ):\n    if poly[-1] != 0:\n      for i in range( 2, len( polymod ) + 1 ):\n        poly[-i] = ( poly[-i] - poly[-1] * polymod[-i] ) % p\n    poly = poly[0:-1]\n\n  return poly", "response": "Reduce polynomial by polymod integer arithmetic modulo p."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef polynomial_multiply_mod( m1, m2, polymod, p ):\n\n  # This is just a seat-of-the-pants implementation.\n\n  # This module has been tested only by extensive use\n  # in calculating modular square roots.\n\n  # Initialize the product to zero:\n\n  prod = ( len( m1 ) + len( m2 ) - 1 ) * [0]\n\n  # Add together all the cross-terms:\n\n  for i in range( len( m1 ) ):\n    for j in range( len( m2 ) ):\n      prod[i+j] = ( prod[i+j] + m1[i] * m2[j] ) % p\n\n  return polynomial_reduce_mod( prod, polymod, p )", "response": "Polynomial multiplication modulo a polynomial over ints mod p."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef jacobi( a, n ):\n\n  # Based on the Handbook of Applied Cryptography (HAC), algorithm 2.149.\n\n  # This function has been tested by comparison with a small\n  # table printed in HAC, and by extensive use in calculating\n  # modular square roots.\n\n  assert n >= 3\n  assert n%2 == 1\n  a = a % n\n  if a == 0: return 0\n  if a == 1: return 1\n  a1, e = a, 0\n  while a1%2 == 0:\n    a1, e = a1//2, e+1\n  if e%2 == 0 or n%8 == 1 or n%8 == 7: s = 1\n  else: s = -1\n  if a1 == 1: return s\n  if n%4 == 3 and a1%4 == 3: s = -s\n  return s * jacobi( n % a1, a1 )", "response": "Jacobi symbol n is the number of elements in a small or big - endian tree."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ninversing of a mod m.", "response": "def inverse_mod( a, m ):\n  \"\"\"Inverse of a mod m.\"\"\"\n\n  if a < 0 or m <= a: a = a % m\n\n  # From Ferguson and Schneier, roughly:\n\n  c, d = a, m\n  uc, vc, ud, vd = 1, 0, 0, 1\n  while c != 0:\n    q, c, d = divmod( d, c ) + ( c, )\n    uc, vc, ud, vd = ud - q*uc, vd - q*vc, uc, vc\n\n  # At this point, d is the GCD, and ud*a+vd*m = d.\n  # If d == 1, this means that ud is a inverse.\n\n  assert d == 1\n  if ud > 0: return ud\n  else: return ud + m"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef gcd2(a, b):\n  while a:\n    a, b = b%a, a\n  return b", "response": "Greatest common divisor using Euclid s algorithm."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndecomposing n into a list of prime and exponent pairs.", "response": "def factorization( n ):\n  \"\"\"Decompose n into a list of (prime,exponent) pairs.\"\"\"\n\n  assert isinstance( n, integer_types )\n\n  if n < 2: return []\n\n  result = []\n  d = 2\n\n  # Test the small primes:\n\n  for d in smallprimes:\n    if d > n: break\n    q, r = divmod( n, d )\n    if r == 0:\n      count = 1\n      while d <= n:\n        n = q\n        q, r = divmod( n, d )\n        if r != 0: break\n        count = count + 1\n      result.append( ( d, count ) )\n\n  # If n is still greater than the last of our small primes,\n  # it may require further work:\n\n  if n > smallprimes[-1]:\n    if is_prime( n ):   # If what's left is prime, it's easy:\n      result.append( ( n, 1 ) )\n    else:               # Ugh. Search stupidly for a divisor:\n      d = smallprimes[-1]\n      while 1:\n        d = d + 2               # Try the next divisor.\n        q, r = divmod( n, d )\n        if q < d: break         # n < d*d means we're done, n = 1 or prime.\n        if r == 0:              # d divides n. How many times?\n          count = 1\n          n = q\n          while d <= n:                 # As long as d might still divide n,\n            q, r = divmod( n, d )       # see if it does.\n            if r != 0: break\n            n = q                       # It does. Reduce n, increase count.\n            count = count + 1\n          result.append( ( d, count ) )\n      if n > 1: result.append( ( n, 1 ) )\n\n  return result"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef phi( n ):\n\n  assert isinstance( n, integer_types )\n\n  if n < 3: return 1\n\n  result = 1\n  ff = factorization( n )\n  for f in ff:\n    e = f[1]\n    if e > 1:\n      result = result * f[0] ** (e-1) * ( f[0] - 1 )\n    else:\n      result = result * ( f[0] - 1 )\n  return result", "response": "Return the Euler totient function of n."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the Carmichael function of a number that is represented as a list of ( prime exponent ) pairs.", "response": "def carmichael_of_factorized( f_list ):\n  \"\"\"Return the Carmichael function of a number that is\n  represented as a list of (prime,exponent) pairs.\n  \"\"\"\n\n  if len( f_list ) < 1: return 1\n\n  result = carmichael_of_ppower( f_list[0] )\n  for i in range( 1, len( f_list ) ):\n    result = lcm( result, carmichael_of_ppower( f_list[i] ) )\n\n  return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the order of x in the multiplicative group mod m.", "response": "def order_mod( x, m ):\n  \"\"\"Return the order of x in the multiplicative group mod m.\n  \"\"\"\n\n  # Warning: this implementation is not very clever, and will\n  # take a long time if m is very large.\n\n  if m <= 1: return 0\n\n  assert gcd( x, m ) == 1\n\n  z = x\n  result = 1\n  while z != 1:\n    z = ( z * x ) % m\n    result = result + 1\n  return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef largest_factor_relatively_prime( a, b ):\n\n  while 1:\n    d = gcd( a, b )\n    if d <= 1: break\n    b = d\n    while 1:\n      q, r = divmod( a, d )\n      if r > 0:\n        break\n      a = q\n  return a", "response": "Return the largest factor of a relatively prime to b."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning True if x is prime False otherwise.", "response": "def is_prime( n ):\n  \"\"\"Return True if x is prime, False otherwise.\n\n  We use the Miller-Rabin test, as given in Menezes et al. p. 138.\n  This test is not exact: there are composite values n for which\n  it returns True.\n\n  In testing the odd numbers from 10000001 to 19999999,\n  about 66 composites got past the first test,\n  5 got past the second test, and none got past the third.\n  Since factors of 2, 3, 5, 7, and 11 were detected during\n  preliminary screening, the number of numbers tested by\n  Miller-Rabin was (19999999 - 10000001)*(2/3)*(4/5)*(6/7)\n  = 4.57 million.\n  \"\"\"\n\n  # (This is used to study the risk of false positives:)\n  global miller_rabin_test_count\n\n  miller_rabin_test_count = 0\n\n  if n <= smallprimes[-1]:\n    if n in smallprimes: return True\n    else: return False\n\n  if gcd( n, 2*3*5*7*11 ) != 1: return False\n\n  # Choose a number of iterations sufficient to reduce the\n  # probability of accepting a composite below 2**-80\n  # (from Menezes et al. Table 4.4):\n\n  t = 40\n  n_bits = 1 + int( math.log( n, 2 ) )\n  for k, tt in ( ( 100, 27 ),\n                 ( 150, 18 ),\n                 ( 200, 15 ),\n                 ( 250, 12 ),\n                 ( 300,  9 ),\n                 ( 350,  8 ),\n                 ( 400,  7 ),\n                 ( 450,  6 ),\n                 ( 550,  5 ),\n                 ( 650,  4 ),\n                 ( 850,  3 ),\n                 ( 1300, 2 ),\n                 ):\n    if n_bits < k: break\n    t = tt\n\n  # Run the test t times:\n\n  s = 0\n  r = n - 1\n  while ( r % 2 ) == 0:\n    s = s + 1\n    r = r // 2\n  for i in range( t ):\n    a = smallprimes[ i ]\n    y = modular_exp( a, r, n )\n    if y != 1 and y != n-1:\n      j = 1\n      while j <= s - 1 and y != n - 1:\n        y = modular_exp( y, 2, n )\n        if y == 1:\n          miller_rabin_test_count = i + 1\n          return False\n        j = j + 1\n      if y != n-1:\n        miller_rabin_test_count = i + 1\n        return False\n  return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef next_prime( starting_value ):\n  \"Return the smallest prime larger than the starting value.\"\n\n  if starting_value < 2: return 2\n  result = ( starting_value + 1 ) | 1\n  while not is_prime( result ): result = result + 2\n  return result", "response": "Return the smallest prime larger than the starting value."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nuse feeder to read and convert from in_stream and write to out_stream.", "response": "def _feed_stream(feeder, in_stream, out_stream, block_size = BLOCK_SIZE):\n    'Uses feeder to read and convert from in_stream and write to out_stream.'\n\n    while True:\n        chunk = in_stream.read(block_size)\n        if not chunk:\n            break\n        converted = feeder.feed(chunk)\n        out_stream.write(converted)\n    converted = feeder.feed()\n    out_stream.write(converted)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef encrypt_stream(mode, in_stream, out_stream, block_size = BLOCK_SIZE, padding = PADDING_DEFAULT):\n    'Encrypts a stream of bytes from in_stream to out_stream using mode.'\n\n    encrypter = Encrypter(mode, padding = padding)\n    _feed_stream(encrypter, in_stream, out_stream, block_size)", "response": "Encrypts a stream of bytes from in_stream to out_stream using mode."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef feed(self, data = None):\n        '''Provide bytes to encrypt (or decrypt), returning any bytes\n           possible from this or any previous calls to feed.\n\n           Call with None or an empty string to flush the mode of\n           operation and return any final bytes; no further calls to\n           feed may be made.'''\n\n        if self._buffer is None:\n            raise ValueError('already finished feeder')\n\n        # Finalize; process the spare bytes we were keeping\n        if not data:\n            result = self._final(self._buffer, self._padding)\n            self._buffer = None\n            return result\n\n        self._buffer += to_bufferable(data)\n\n        # We keep 16 bytes around so we can determine padding\n        result = to_bufferable('')\n        while len(self._buffer) > 16:\n            can_consume = self._mode._can_consume(len(self._buffer) - 16)\n            if can_consume == 0: break\n            result += self._feed(self._buffer[:can_consume])\n            self._buffer = self._buffer[can_consume:]\n\n        return result", "response": "Feed the data into a new object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a random integer k such that 1 <= k < order uniformly distributed across that range.", "response": "def randrange(order, entropy=None):\n    \"\"\"Return a random integer k such that 1 <= k < order, uniformly\n    distributed across that range. For simplicity, this only behaves well if\n    'order' is fairly close (but below) a power of 256. The try-try-again\n    algorithm we use takes longer and longer time (on average) to complete as\n    'order' falls, rising to a maximum of avg=512 loops for the worst-case\n    (256**k)+1 . All of the standard curves behave well. There is a cutoff at\n    10k loops (which raises RuntimeError) to prevent an infinite loop when\n    something is really broken like the entropy function not working.\n\n    Note that this function is not declared to be forwards-compatible: we may\n    change the behavior in future releases. The entropy= argument (which\n    should get a callable that behaves like os.urandom) can be used to\n    achieve stability within a given release (for repeatable unit tests), but\n    should not be used as a long-term-compatible key generation algorithm.\n    \"\"\"\n    # we could handle arbitrary orders (even 256**k+1) better if we created\n    # candidates bit-wise instead of byte-wise, which would reduce the\n    # worst-case behavior to avg=2 loops, but that would be more complex. The\n    # change would be to round the order up to a power of 256, subtract one\n    # (to get 0xffff..), use that to get a byte-long mask for the top byte,\n    # generate the len-1 entropy bytes, generate one extra byte and mask off\n    # the top bits, then combine it with the rest. Requires jumping back and\n    # forth between strings and integers a lot.\n\n    if entropy is None:\n        entropy = os.urandom\n    assert order > 1\n    bytes = orderlen(order)\n    dont_try_forever = 10000 # gives about 2**-60 failures for worst case\n    while dont_try_forever > 0:\n        dont_try_forever -= 1\n        candidate = string_to_number(entropy(bytes)) + 1\n        if 1 <= candidate < order:\n            return candidate\n        continue\n    raise RuntimeError(\"randrange() tried hard but gave up, either something\"\n                       \" is very wrong or you got realllly unlucky. Order was\"\n                       \" %x\" % order)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates AUTHORS file using git commits.", "response": "def generate_authors(git_dir):\n    \"\"\"Create AUTHORS file using git commits.\"\"\"\n    authors = []\n    emails = []\n    git_log_cmd = ['git', 'log', '--format=%aN|%aE']\n    tmp_authors = _run_shell_command(git_log_cmd, git_dir).split('\\n')\n    for author_str in tmp_authors:\n        author, email = author_str.split('|')\n        author = author.strip()\n        email = email.strip()\n        if author.lower() not in [x.lower() for x in authors]:\n            if email.lower() not in [x.lower() for x in emails]:\n                authors.append(author)\n                emails.append(email)\n    co_authors_raw = _run_shell_command(['git', 'log'], git_dir)\n    co_authors = re.findall('Co-authored-by:.+', co_authors_raw,\n                            re.MULTILINE)\n    co_authors = [signed.split(\":\", 1)[1].strip().split('<')\n                  for signed in co_authors if signed]\n    for author_str in co_authors:\n        author, email = author_str.split('<')\n        author = author.strip()\n        email = email[:-1].strip()\n        if author.lower() not in [x.lower() for x in authors]:\n            if email.lower() not in [x.lower() for x in emails]:\n                authors.append(author)\n                emails.append(email)\n    authors = sorted(set(authors))\n    return authors"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _initalize_tree(self, position, momentum, slice_var, stepsize):\n\n        position_bar, momentum_bar, _ = self.simulate_dynamics(self.model, position, momentum, stepsize,\n                                                               self.grad_log_pdf).get_proposed_values()\n\n        _, logp_bar = self.grad_log_pdf(position_bar, self.model).get_gradient_log_pdf()\n\n        hamiltonian = logp_bar - 0.5 * np.dot(momentum_bar, momentum_bar)\n\n        candidate_set_size = slice_var < np.exp(hamiltonian)\n        accept_set_bool = hamiltonian > np.log(slice_var) - 10000  # delta_max = 10000\n\n        return position_bar, momentum_bar, candidate_set_size, accept_set_bool", "response": "Initializes the tree based on the given parameters."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _sample(self, position, stepsize):\n\n        # Re-sampling momentum\n        momentum = np.random.normal(0, 1, len(position))\n\n        # Initializations\n        depth = 0\n        position_backward, position_forward = position, position\n        momentum_backward, momentum_forward = momentum, momentum\n        candidate_set_size = accept_set_bool = 1\n        _, log_pdf = self.grad_log_pdf(position, self.model).get_gradient_log_pdf()\n\n        # Resample slice variable `u`\n        slice_var = np.random.uniform(0, np.exp(log_pdf - 0.5 * np.dot(momentum, momentum)))\n\n        while accept_set_bool == 1:\n            direction = np.random.choice([-1, 1], p=[0.5, 0.5])\n            if direction == -1:\n                # Build a tree in backward direction\n                (position_backward, momentum_backward, _, _, position_bar,\n                 candidate_set_size2, accept_set_bool2) = self._build_tree(position_backward, momentum_backward,\n                                                                           slice_var, direction, depth, stepsize)\n            else:\n                # Build tree in forward direction\n                (_, _, position_forward, momentum_forward, position_bar,\n                 candidate_set_size2, accept_set_bool2) = self._build_tree(position_forward, momentum_forward,\n                                                                           slice_var, direction, depth, stepsize)\n            if accept_set_bool2 == 1:\n                if np.random.rand() < candidate_set_size2 / candidate_set_size:\n                    position = position_bar.copy()\n\n            accept_set_bool, candidate_set_size = self._update_acceptance_criteria(position_forward, position_backward,\n                                                                                   momentum_forward, momentum_backward,\n                                                                                   accept_set_bool2, candidate_set_size,\n                                                                                   candidate_set_size2)\n            depth += 1\n\n        return position", "response": "Sample a set of elements from the position using a single iteration of NUTS."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef sample(self, initial_pos, num_samples, stepsize=None, return_type='dataframe'):\n        initial_pos = _check_1d_array_object(initial_pos, 'initial_pos')\n        _check_length_equal(initial_pos, self.model.variables, 'initial_pos', 'model.variables')\n\n        if stepsize is None:\n            stepsize = self._find_reasonable_stepsize(initial_pos)\n\n        types = [(var_name, 'float') for var_name in self.model.variables]\n        samples = np.zeros(num_samples, dtype=types).view(np.recarray)\n\n        samples[0] = tuple(initial_pos)\n        position_m = initial_pos\n\n        for i in range(1, num_samples):\n            # Genrating sample\n            position_m = self._sample(position_m, stepsize)\n            samples[i] = tuple(position_m)\n\n        return _return_samples(return_type, samples)", "response": "Method to return samples from a markov chain using No U Turn Sampler"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef generate_sample(self, initial_pos, num_samples, stepsize=None):\n        initial_pos = _check_1d_array_object(initial_pos, 'initial_pos')\n        _check_length_equal(initial_pos, self.model.variables, 'initial_pos', 'model.variables')\n\n        if stepsize is None:\n            stepsize = self._find_reasonable_stepsize(initial_pos)\n\n        position_m = initial_pos\n\n        for _ in range(0, num_samples):\n\n            position_m = self._sample(position_m, stepsize)\n\n            yield position_m", "response": "Generates a sample of the markov state for a given set of parameters."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsamples a set of nouurn sine values from the markov chain.", "response": "def sample(self, initial_pos, num_adapt, num_samples, stepsize=None, return_type='dataframe'):\n        \"\"\"\n        Returns samples using No U Turn Sampler with dual averaging\n\n        Parameters\n        ----------\n        initial_pos: A 1d array like object\n            Vector representing values of parameter position, the starting\n            state in markov chain.\n\n        num_adapt: int\n            The number of interations to run the adaptation of stepsize\n\n        num_samples: int\n            Number of samples to be generated\n\n        stepsize: float , defaults to None\n            The stepsize for proposing new values of position and momentum in simulate_dynamics\n            If None, then will be choosen suitably\n\n        return_type: string (dataframe | recarray)\n            Return type for samples, either of 'dataframe' or 'recarray'.\n            Defaults to 'dataframe'\n\n        Returns\n        -------\n        sampled: A pandas.DataFrame or a numpy.recarray object depending upon return_type argument\n\n\n        Examples\n        ---------\n        >>> from pgmpy.sampling import NoUTurnSamplerDA as NUTSda, GradLogPDFGaussian, LeapFrog\n        >>> from pgmpy.factors.continuous import GaussianDistribution as JGD\n        >>> import numpy as np\n        >>> mean = np.array([10, -13])\n        >>> covariance = np.array([[16, -3], [-3, 13]])\n        >>> model = JGD(['x', 'y'], mean, covariance)\n        >>> sampler = NUTSda(model=model, grad_log_pdf=GradLogPDFGaussian, simulate_dynamics=LeapFrog)\n        >>> samples = sampler.sample(initial_pos=np.array([12, -4]), num_adapt=10, num_samples=10,\n        ...                          stepsize=0.1, return_type='dataframe')\n        >>> samples\n                   x          y\n        0  12.000000  -4.000000\n        1  11.864821  -3.696109\n        2  10.546986  -4.892169\n        3   8.526596 -21.555793\n        4   8.526596 -21.555793\n        5  11.343194  -6.353789\n        6  -1.583269 -12.802931\n        7  12.411957 -11.704859\n        8  13.253336 -20.169492\n        9  11.295901  -7.665058\n        \"\"\"\n        initial_pos = _check_1d_array_object(initial_pos, 'initial_pos')\n        _check_length_equal(initial_pos, self.model.variables, 'initial_pos', 'model.variables')\n\n        if stepsize is None:\n            stepsize = self._find_reasonable_stepsize(initial_pos)\n\n        if num_adapt <= 1:\n            return NoUTurnSampler(self.model, self.grad_log_pdf,\n                                  self.simulate_dynamics).sample(initial_pos, num_samples, stepsize)\n\n        mu = np.log(10.0 * stepsize)\n        stepsize_bar = 1.0\n        h_bar = 0.0\n\n        types = [(var_name, 'float') for var_name in self.model.variables]\n        samples = np.zeros(num_samples, dtype=types).view(np.recarray)\n        samples[0] = tuple(initial_pos)\n        position_m = initial_pos\n\n        for i in range(1, num_samples):\n\n            position_m, alpha, n_alpha = self._sample(position_m, stepsize)\n            samples[i] = tuple(position_m)\n\n            if i <= num_adapt:\n                stepsize, stepsize_bar, h_bar = self._adapt_params(stepsize, stepsize_bar, h_bar, mu,\n                                                                   i, alpha, n_alpha)\n            else:\n                stepsize = stepsize_bar\n\n        return _return_samples(return_type, samples)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngenerates a sample of the current state of the markov chain.", "response": "def generate_sample(self, initial_pos, num_adapt, num_samples, stepsize=None):\n        \"\"\"\n        Returns a generator type object whose each iteration yields a sample\n\n        Parameters\n        ----------\n        initial_pos: A 1d array like object\n            Vector representing values of parameter position, the starting\n            state in markov chain.\n\n        num_adapt: int\n            The number of interations to run the adaptation of stepsize\n\n        num_samples: int\n            Number of samples to be generated\n\n        stepsize: float , defaults to None\n            The stepsize for proposing new values of position and momentum in simulate_dynamics\n            If None, then will be choosen suitably\n\n        Returns\n        -------\n        genrator: yielding a numpy.array type object for a sample\n\n        Examples\n        --------\n        >>> from pgmpy.sampling import NoUTurnSamplerDA as NUTSda, GradLogPDFGaussian\n        >>> from pgmpy.factors.continuous import GaussianDistribution as JGD\n        >>> import numpy as np\n        >>> mean = np.array([1, -100])\n        >>> covariance = np.array([[-12, 45], [45, -10]])\n        >>> model = JGD(['a', 'b'], mean, covariance)\n        >>> sampler = NUTSda(model=model, grad_log_pdf=GradLogPDFGaussian, simulate_dynamics=LeapFrog)\n        >>> samples = sampler.generate_sample(initial_pos=np.array([12, -4]), num_adapt=10,\n        ...                                   num_samples=10, stepsize=0.1)\n        >>> samples\n        <generator object NoUTurnSamplerDA.generate_sample at 0x7f4fed46a4c0>\n        >>> samples_array = np.array([sample for sample in samples])\n        >>> samples_array\n        array([[ 11.89963386,  -4.06572636],\n               [ 10.3453755 ,  -7.5700289 ],\n               [-26.56899659, -15.3920684 ],\n               [-29.97143077, -12.0801625 ],\n               [-29.97143077, -12.0801625 ],\n               [-33.07960829,  -8.90440347],\n               [-55.28263496, -17.31718524],\n               [-55.28263496, -17.31718524],\n               [-56.63440044, -16.03309364],\n               [-63.880094  , -19.19981944]])\n        \"\"\"\n        initial_pos = _check_1d_array_object(initial_pos, 'initial_pos')\n        _check_length_equal(initial_pos, self.model.variables, 'initial_pos', 'model.variables')\n\n        if stepsize is None:\n            stepsize = self._find_reasonable_stepsize(initial_pos)\n\n        if num_adapt <= 1:  # return sample generated using Simple HMC algorithm\n            for sample in NoUTurnSampler(self.model, self.grad_log_pdf,\n                                         self.simulate_dynamics).generate_sample(initial_pos, num_samples, stepsize):\n                yield sample\n            return\n        mu = np.log(10.0 * stepsize)\n\n        stepsize_bar = 1.0\n        h_bar = 0.0\n\n        position_m = initial_pos.copy()\n        num_adapt += 1\n\n        for i in range(1, num_samples + 1):\n\n            position_m, alpha, n_alpha = self._sample(position_m, stepsize)\n\n            if i <= num_adapt:\n                stepsize, stepsize_bar, h_bar = self._adapt_params(stepsize, stepsize_bar, h_bar, mu,\n                                                                   i, alpha, n_alpha)\n            else:\n                stepsize = stepsize_bar\n\n            yield position_m"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef discretize(self, method, *args, **kwargs):\n        return method(self, *args, **kwargs).get_discrete_values()", "response": "Discretizes the continuous distribution into discrete\n        probability masses using various methods."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreducing the factor to the context of the given variable values.", "response": "def reduce(self, values, inplace=True):\n        \"\"\"\n        Reduces the factor to the context of the given variable values.\n\n        Parameters\n        ----------\n        values: list, array-like\n            A list of tuples of the form (variable_name, variable_value).\n\n        inplace: boolean\n            If inplace=True it will modify the factor itself, else would return\n            a new ContinuosFactor object.\n\n        Returns\n        -------\n        ContinuousFactor or None: if inplace=True (default) returns None\n                                  if inplace=False returns a new ContinuousFactor instance.\n\n        Examples\n        --------\n        >>> import numpy as np\n        >>> from scipy.special import beta\n        >>> from pgmpy.factors.continuous import ContinuousFactor\n        >>> def custom_pdf(x, y, z):\n        ...     return z*(np.power(x, 1) * np.power(y, 2)) / beta(x, y)\n        >>> custom_factor = ContinuousFactor(['x', 'y', 'z'], custom_pdf)\n        >>> custom_factor.variables\n        ['x', 'y', 'z']\n        >>> custom_factor.assignment(1, 2, 3)\n        24.0\n\n        >>> custom_factor.reduce([('y', 2)])\n        >>> custom_factor.variables\n        ['x', 'z']\n        >>> custom_factor.assignment(1, 3)\n        24.0\n        \"\"\"\n        phi = self if inplace else self.copy()\n\n        phi.distribution = phi.distribution.reduce(values, inplace=False)\n        if not inplace:\n            return phi"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef marginalize(self, variables, inplace=True):\n        phi = self if inplace else self.copy()\n        phi.distribution = phi.distribution.marginalize(variables, inplace=False)\n\n        if not inplace:\n            return phi", "response": "Marginalizes the factor with respect to the given variables."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nnormalizes the pdf of the continuous factor so that it integrates to 1 over all the variables.", "response": "def normalize(self, inplace=True):\n        \"\"\"\n        Normalizes the pdf of the continuous factor so that it integrates to\n        1 over all the variables.\n\n        Parameters\n        ----------\n        inplace: boolean\n            If inplace=True it will modify the factor itself, else would return\n            a new factor.\n\n        Returns\n        -------\n        ContinuousFactor or None:\n             if inplace=True (default) returns None\n             if inplace=False returns a new ContinuousFactor instance.\n\n        Examples\n        --------\n        >>> from pgmpy.factors.continuous import ContinuousFactor\n        >>> from scipy.stats import multivariate_normal\n        >>> std_normal_pdf = lambda x: 2 * multivariate_normal.pdf(x, [0, 0], [[1, 0], [0, 1]])\n        >>> std_normal = ContinuousFactor(['x1', 'x2'], std_normal_pdf)\n        >>> std_normal.assignment(1, 1)\n        0.117099663049\n        >>> std_normal.normalize()\n        >>> std_normal.assignment(1, 1)\n        0.0585498315243\n\n        \"\"\"\n        phi = self if inplace else self.copy()\n        phi.distriution = phi.distribution.normalize(inplace=False)\n\n        if not inplace:\n            return phi"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a new ContinuousFactor instance with the multiplication of the two ContinuousFactors.", "response": "def _operate(self, other, operation, inplace=True):\n        \"\"\"\n        Gives the ContinuousFactor operation (product or divide) with\n        the other factor.\n\n        Parameters\n        ----------\n        other: ContinuousFactor\n            The ContinuousFactor to be multiplied.\n\n        operation: String\n            'product' for multiplication operation and 'divide' for\n            division operation.\n\n        inplace: boolean\n            If inplace=True it will modify the factor itself, else would return\n            a new factor.\n\n        Returns\n        -------\n        ContinuousFactor or None:\n                        if inplace=True (default) returns None\n                        if inplace=False returns a new `DiscreteFactor` instance.\n\n        \"\"\"\n        if not isinstance(other, ContinuousFactor):\n            raise TypeError(\"ContinuousFactor objects can only be multiplied \",\n                            \"or divided with another ContinuousFactor object. \",\n                            \"Got {other_type}, expected: ContinuousFactor.\".format(\n                                other_type=type(other)))\n\n        phi = self if inplace else self.copy()\n        phi.distribution = phi.distribution._operate(\n            other=other.distribution, operation=operation, inplace=False)\n\n        if not inplace:\n            return phi"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a ContinuousFactor instance with the divide of this ContinuousFactor and the other factor.", "response": "def divide(self, other, inplace=True):\n        \"\"\"\n        Gives the ContinuousFactor divide with the other factor.\n\n        Parameters\n        ----------\n        other: ContinuousFactor\n            The ContinuousFactor to be divided.\n\n        Returns\n        -------\n        ContinuousFactor or None:\n                        if inplace=True (default) returns None\n                        if inplace=False returns a new `ContinuousFactor` instance.\n\n        Example\n        -------\n        >>> from pgmpy.factors.continuous import ContinuousFactor\n        >>> from scipy.stats import multivariate_normal\n        >>> sn_pdf1 = lambda x: multivariate_normal.pdf([x], [0], [[1]])\n        >>> sn_pdf2 = lambda x1,x2: multivariate_normal.pdf([x1, x2], [0, 0], [[1, 0], [0, 1]])\n        >>> sn1 = ContinuousFactor(['x2'], sn_pdf1)\n        >>> sn2 = ContinuousFactor(['x1', 'x2'], sn_pdf2)\n\n        >>> sn4 = sn2.divide(sn1, inplace=False)\n        >>> sn4.assignment(0, 0)\n        0.3989422804014327\n\n        >>> sn4 = sn2 / sn1\n        >>> sn4.assignment(0, 0)\n        0.3989422804014327\n        \"\"\"\n        if set(other.scope()) - set(self.scope()):\n            raise ValueError(\"Scope of divisor should be a subset of dividend\")\n\n        return self._operate(other, 'divide', inplace)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a new base factor that is factor product over all the arguments.", "response": "def factor_product(*args):\n    \"\"\"\n    Returns factor product over `args`.\n\n    Parameters\n    ----------\n    args: `BaseFactor` instances.\n        factors to be multiplied\n\n    Returns\n    -------\n    BaseFactor: `BaseFactor` representing factor product over all the `BaseFactor` instances in args.\n\n    Examples\n    --------\n    >>> from pgmpy.factors.discrete import DiscreteFactor\n    >>> from pgmpy.factors import factor_product\n    >>> phi1 = DiscreteFactor(['x1', 'x2', 'x3'], [2, 3, 2], range(12))\n    >>> phi2 = DiscreteFactor(['x3', 'x4', 'x1'], [2, 2, 2], range(8))\n    >>> phi = factor_product(phi1, phi2)\n    >>> phi.variables\n    ['x1', 'x2', 'x3', 'x4']\n    >>> phi.cardinality\n    array([2, 3, 2, 2])\n    >>> phi.values\n    array([[[[ 0,  0],\n             [ 4,  6]],\n\n            [[ 0,  4],\n             [12, 18]],\n\n            [[ 0,  8],\n             [20, 30]]],\n\n\n           [[[ 6, 18],\n             [35, 49]],\n\n            [[ 8, 24],\n             [45, 63]],\n\n            [[10, 30],\n             [55, 77]]]])\n    \"\"\"\n    if not all(isinstance(phi, BaseFactor) for phi in args):\n        raise TypeError(\"Arguments must be factors\")\n    # Check if all of the arguments are of the same type\n    elif len(set(map(type, args))) != 1:\n            raise NotImplementedError(\"All the args are expected to \",\n                                      \"be instances of the same factor class.\")\n\n    return reduce(lambda phi1, phi2: phi1 * phi2, args)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a new DiscreteFactor representing the factor division of two factores.", "response": "def factor_divide(phi1, phi2):\n    \"\"\"\n    Returns `DiscreteFactor` representing `phi1 / phi2`.\n\n    Parameters\n    ----------\n    phi1: Factor\n        The Dividend.\n\n    phi2: Factor\n        The Divisor.\n\n    Returns\n    -------\n    DiscreteFactor: `DiscreteFactor` representing factor division `phi1 / phi2`.\n\n    Examples\n    --------\n    >>> from pgmpy.factors.discrete import DiscreteFactor\n    >>> from pgmpy.factors import factor_product\n    >>> phi1 = DiscreteFactor(['x1', 'x2', 'x3'], [2, 3, 2], range(12))\n    >>> phi2 = DiscreteFactor(['x3', 'x1'], [2, 2], range(1, 5))\n    >>> phi = factor_divide(phi1, phi2)\n    >>> phi.variables\n    ['x1', 'x2', 'x3']\n    >>> phi.cardinality\n    array([2, 3, 2])\n    >>> phi.values\n    array([[[ 0.        ,  0.33333333],\n            [ 2.        ,  1.        ],\n            [ 4.        ,  1.66666667]],\n\n           [[ 3.        ,  1.75      ],\n            [ 4.        ,  2.25      ],\n            [ 5.        ,  2.75      ]]])\n    \"\"\"\n    if not isinstance(phi1, BaseFactor) or not isinstance(phi2, BaseFactor):\n        raise TypeError(\"phi1 and phi2 should be factors instances\")\n\n    # Check if all of the arguments are of the same type\n    elif type(phi1) != type(phi2):\n        raise NotImplementedError(\"All the args are expected to be instances\",\n                                  \"of the same factor class.\")\n\n    return phi1.divide(phi2, inplace=False)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nestimate the CPD for a given variable.", "response": "def estimate_cpd(self, node, prior_type='BDeu', pseudo_counts=[], equivalent_sample_size=5):\n        \"\"\"\n        Method to estimate the CPD for a given variable.\n\n        Parameters\n        ----------\n        node: int, string (any hashable python object)\n            The name of the variable for which the CPD is to be estimated.\n\n        prior_type: 'dirichlet', 'BDeu', 'K2',\n            string indicting which type of prior to use for the model parameters.\n            - If 'prior_type' is 'dirichlet', the following must be provided:\n                'pseudo_counts' = dirichlet hyperparameters; 2-D array of shape\n                 (node_card, product of parents_card) with a \"virtual\" count for \n                 each variable state in the CPD.\n                 The virtual counts are added to the actual state counts found in the data.\n                 (if a list is provided, a lexicographic ordering of states is assumed)\n            - If 'prior_type' is 'BDeu', then an 'equivalent_sample_size'\n                must be specified instead of 'pseudo_counts'. This is equivalent to\n                'prior_type=dirichlet' and using uniform 'pseudo_counts' of\n                `equivalent_sample_size/(node_cardinality*np.prod(parents_cardinalities))`.\n            - A prior_type of 'K2' is a shorthand for 'dirichlet' + setting every pseudo_count to 1,\n                regardless of the cardinality of the variable.\n\n        Returns\n        -------\n        CPD: TabularCPD\n\n        Examples\n        --------\n        >>> import pandas as pd\n        >>> from pgmpy.models import BayesianModel\n        >>> from pgmpy.estimators import BayesianEstimator\n        >>> data = pd.DataFrame(data={'A': [0, 0, 1], 'B': [0, 1, 0], 'C': [1, 1, 0]})\n        >>> model = BayesianModel([('A', 'C'), ('B', 'C')])\n        >>> estimator = BayesianEstimator(model, data)\n        >>> cpd_C = estimator.estimate_cpd('C', prior_type=\"dirichlet\", pseudo_counts=[1, 2])\n        >>> print(cpd_C)\n        \u2552\u2550\u2550\u2550\u2550\u2550\u2550\u2564\u2550\u2550\u2550\u2550\u2550\u2550\u2564\u2550\u2550\u2550\u2550\u2550\u2550\u2564\u2550\u2550\u2550\u2550\u2550\u2550\u2564\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2555\n        \u2502 A    \u2502 A(0) \u2502 A(0) \u2502 A(1) \u2502 A(1)               \u2502\n        \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        \u2502 B    \u2502 B(0) \u2502 B(1) \u2502 B(0) \u2502 B(1)               \u2502\n        \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        \u2502 C(0) \u2502 0.25 \u2502 0.25 \u2502 0.5  \u2502 0.3333333333333333 \u2502\n        \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        \u2502 C(1) \u2502 0.75 \u2502 0.75 \u2502 0.5  \u2502 0.6666666666666666 \u2502\n        \u2558\u2550\u2550\u2550\u2550\u2550\u2550\u2567\u2550\u2550\u2550\u2550\u2550\u2550\u2567\u2550\u2550\u2550\u2550\u2550\u2550\u2567\u2550\u2550\u2550\u2550\u2550\u2550\u2567\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255b\n        \"\"\"\n\n        node_cardinality = len(self.state_names[node])\n        parents = sorted(self.model.get_parents(node))\n        parents_cardinalities = [len(self.state_names[parent]) for parent in parents]\n        cpd_shape = (node_cardinality, np.prod(parents_cardinalities, dtype=int))\n\n        if prior_type == 'K2':\n            pseudo_counts = np.ones(cpd_shape, dtype=int)\n        elif prior_type == 'BDeu':\n            alpha = float(equivalent_sample_size) / (node_cardinality * np.prod(parents_cardinalities))\n            pseudo_counts = np.ones(cpd_shape, dtype=float) * alpha\n        elif prior_type == 'dirichlet':\n            pseudo_counts = np.array(pseudo_counts)\n            if pseudo_counts.shape != cpd_shape:\n                raise ValueError(\"The shape of pseudo_counts must be: {shape}\".format(\n                   shape=str(cpd_shape)))\n        else:\n            raise ValueError(\"'prior_type' not specified\")\n\n        state_counts = self.state_counts(node)\n        bayesian_counts = state_counts + pseudo_counts\n\n        cpd = TabularCPD(node, node_cardinality, np.array(bayesian_counts),\n                         evidence=parents,\n                         evidence_card=parents_cardinalities,\n                         state_names=self.state_names)\n        cpd.normalize()\n        return cpd"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef forward_sample(self, size=1, return_type='dataframe'):\n        types = [(var_name, 'int') for var_name in self.topological_order]\n        sampled = np.zeros(size, dtype=types).view(np.recarray)\n\n        for node in self.topological_order:\n            cpd = self.model.get_cpds(node)\n            states = range(self.cardinality[node])\n            evidence = cpd.variables[:0:-1]\n            if evidence:\n                cached_values = self.pre_compute_reduce(variable=node)\n                evidence = np.vstack([sampled[i] for i in evidence])\n                weights = list(map(lambda t: cached_values[tuple(t)], evidence.T))\n            else:\n                weights = cpd.values\n            sampled[node] = sample_discrete(states, weights, size)\n\n        return _return_samples(return_type, sampled)", "response": "Generate a sample from the joint distribution of the bayesian network."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef rejection_sample(self, evidence=None, size=1, return_type=\"dataframe\"):\n        if evidence is None:\n            return self.forward_sample(size)\n        types = [(var_name, 'int') for var_name in self.topological_order]\n        sampled = np.zeros(0, dtype=types).view(np.recarray)\n        prob = 1\n        i = 0\n        while i < size:\n            _size = int(((size - i) / prob) * 1.5)\n            _sampled = self.forward_sample(_size, 'recarray')\n\n            for evid in evidence:\n                _sampled = _sampled[_sampled[evid[0]] == evid[1]]\n\n            prob = max(len(_sampled) / _size, 0.01)\n            sampled = np.append(sampled, _sampled)[:size]\n\n            i += len(_sampled)\n\n        return _return_samples(return_type, sampled)", "response": "Generates a sample of the bayesian network from the given evidence and returns a pandas. DataFrame or numpy. recarray object."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef likelihood_weighted_sample(self, evidence=None, size=1, return_type=\"dataframe\"):\n        types = [(var_name, 'int') for var_name in self.topological_order]\n        types.append(('_weight', 'float'))\n        sampled = np.zeros(size, dtype=types).view(np.recarray)\n        sampled['_weight'] = np.ones(size)\n        evidence_dict = {var: st for var, st in evidence}\n\n        for node in self.topological_order:\n            cpd = self.model.get_cpds(node)\n            states = range(self.cardinality[node])\n            evidence = cpd.get_evidence()\n\n            if evidence:\n                evidence_values = np.vstack([sampled[i] for i in evidence])\n                cached_values = self.pre_compute_reduce(node)\n                weights = list(map(lambda t: cached_values[tuple(t)], evidence_values.T))\n                if node in evidence_dict:\n                    sampled[node] = evidence_dict[node]\n                    for i in range(size):\n                        sampled['_weight'][i] *= weights[i][evidence_dict[node]]\n                else:\n                    sampled[node] = sample_discrete(states, weights)\n            else:\n                if node in evidence_dict:\n                    sampled[node] = evidence_dict[node]\n                    for i in range(size):\n                        sampled['_weight'][i] *= cpd.values[evidence_dict[node]]\n                else:\n                    sampled[node] = sample_discrete(states, cpd.values, size)\n\n        return _return_samples(return_type, sampled)", "response": "Returns a dataframe of weighted samples from the joint distribution of the bayesian network that comply with the given evidence."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _get_kernel_from_bayesian_model(self, model):\n        self.variables = np.array(model.nodes())\n        self.cardinalities = {var: model.get_cpds(var).variable_card for var in self.variables}\n\n        for var in self.variables:\n            other_vars = [v for v in self.variables if var != v]\n            other_cards = [self.cardinalities[v] for v in other_vars]\n            cpds = [cpd for cpd in model.cpds if var in cpd.scope()]\n            prod_cpd = factor_product(*cpds)\n            kernel = {}\n            scope = set(prod_cpd.scope())\n            for tup in itertools.product(*[range(card) for card in other_cards]):\n                states = [State(v, s) for v, s in zip(other_vars, tup) if v in scope]\n                prod_cpd_reduced = prod_cpd.reduce(states, inplace=False)\n                kernel[tup] = prod_cpd_reduced.values / sum(prod_cpd_reduced.values)\n            self.transition_models[var] = kernel", "response": "Computes the transition models from a Bayesian Network."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncomputes the Gibbs transition models from a Markov model.", "response": "def _get_kernel_from_markov_model(self, model):\n        \"\"\"\n        Computes the Gibbs transition models from a Markov Network.\n        'Probabilistic Graphical Model Principles and Techniques', Koller and\n        Friedman, Section 12.3.3 pp 512-513.\n\n        Parameters:\n        -----------\n        model: MarkovModel\n            The model from which probabilities will be computed.\n        \"\"\"\n        self.variables = np.array(model.nodes())\n        factors_dict = {var: [] for var in self.variables}\n        for factor in model.get_factors():\n            for var in factor.scope():\n                factors_dict[var].append(factor)\n\n        # Take factor product\n        factors_dict = {var: factor_product(*factors) if len(factors) > 1 else factors[0]\n                        for var, factors in factors_dict.items()}\n        self.cardinalities = {var: factors_dict[var].get_cardinality([var])[var] for var in self.variables}\n\n        for var in self.variables:\n            other_vars = [v for v in self.variables if var != v]\n            other_cards = [self.cardinalities[v] for v in other_vars]\n            kernel = {}\n            factor = factors_dict[var]\n            scope = set(factor.scope())\n            for tup in itertools.product(*[range(card) for card in other_cards]):\n                states = [State(first_var, s) for first_var, s in zip(other_vars, tup) if first_var in scope]\n                reduced_factor = factor.reduce(states, inplace=False)\n                kernel[tup] = reduced_factor.values / sum(reduced_factor.values)\n            self.transition_models[var] = kernel"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nsample from the Markov Chain.", "response": "def sample(self, start_state=None, size=1, return_type=\"dataframe\"):\n        \"\"\"\n        Sample from the Markov Chain.\n\n        Parameters:\n        -----------\n        start_state: dict or array-like iterable\n            Representing the starting states of the variables. If None is passed, a random start_state is chosen.\n        size: int\n            Number of samples to be generated.\n        return_type: string (dataframe | recarray)\n            Return type for samples, either of 'dataframe' or 'recarray'.\n            Defaults to 'dataframe'\n\n        Returns\n        -------\n        sampled: A pandas.DataFrame or a numpy.recarray object depending upon return_type argument\n            the generated samples\n\n        Examples:\n        ---------\n        >>> from pgmpy.factors import DiscreteFactor\n        >>> from pgmpy.sampling import GibbsSampling\n        >>> from pgmpy.models import MarkovModel\n        >>> model = MarkovModel([('A', 'B'), ('C', 'B')])\n        >>> factor_ab = DiscreteFactor(['A', 'B'], [2, 2], [1, 2, 3, 4])\n        >>> factor_cb = DiscreteFactor(['C', 'B'], [2, 2], [5, 6, 7, 8])\n        >>> model.add_factors(factor_ab, factor_cb)\n        >>> gibbs = GibbsSampling(model)\n        >>> gibbs.sample(size=4, return_tupe='dataframe')\n           A  B  C\n        0  0  1  1\n        1  1  0  0\n        2  1  1  0\n        3  1  1  1\n        \"\"\"\n        if start_state is None and self.state is None:\n            self.state = self.random_state()\n        elif start_state is not None:\n            self.set_start_state(start_state)\n\n        types = [(var_name, 'int') for var_name in self.variables]\n        sampled = np.zeros(size, dtype=types).view(np.recarray)\n        sampled[0] = tuple([st for var, st in self.state])\n        for i in range(size - 1):\n            for j, (var, st) in enumerate(self.state):\n                other_st = tuple(st for v, st in self.state if var != v)\n                next_st = sample_discrete(list(range(self.cardinalities[var])),\n                                          self.transition_models[var][other_st])[0]\n                self.state[j] = State(var, next_st)\n            sampled[i + 1] = tuple([st for var, st in self.state])\n\n        return _return_samples(return_type, sampled)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _collect_state_names(self, variable):\n        \"Return a list of states that the variable takes in the data\"\n        states = sorted(list(self.data.ix[:, variable].dropna().unique()))\n        return states", "response": "Return a list of states that the variable takes in the data"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef state_counts(self, variable, parents=[], complete_samples_only=None):\n        parents = list(parents)\n\n        # default for how to deal with missing data can be set in class constructor\n        if complete_samples_only is None:\n            complete_samples_only = self.complete_samples_only\n        # ignores either any row containing NaN, or only those where the variable or its parents is NaN\n        data = self.data.dropna() if complete_samples_only else self.data.dropna(subset=[variable] + parents)\n\n        if not parents:\n            # count how often each state of 'variable' occured\n            state_count_data = data.ix[:, variable].value_counts()\n            state_counts = state_count_data.reindex(self.state_names[variable]).fillna(0).to_frame()\n\n        else:\n            parents_states = [self.state_names[parent] for parent in parents]\n            # count how often each state of 'variable' occured, conditional on parents' states\n            state_count_data = data.groupby([variable] + parents).size().unstack(parents)\n            if not isinstance(state_count_data.columns, pd.MultiIndex):\n                state_count_data.columns = pd.MultiIndex.from_arrays([state_count_data.columns])\n\n            # reindex rows & columns to sort them and to add missing ones\n            # missing row    = some state of 'variable' did not occur in data\n            # missing column = some state configuration of current 'variable's parents\n            #                  did not occur in data\n            row_index = self.state_names[variable]\n            column_index = pd.MultiIndex.from_product(parents_states, names=parents)\n            state_counts = state_count_data.reindex(index=row_index, columns=column_index).fillna(0)\n\n        return state_counts", "response": "Return a pandas. DataFrame containing the number of times each state of variable occured in the data."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the state counts for the given variable.", "response": "def state_counts(self, variable, **kwargs):\n        \"\"\"\n        Return counts how often each state of 'variable' occured in the data.\n        If the variable has parents, counting is done conditionally\n        for each state configuration of the parents.\n\n        Parameters\n        ----------\n        variable: string\n            Name of the variable for which the state count is to be done.\n\n        complete_samples_only: bool\n            Specifies how to deal with missing data, if present. If set to `True` all rows\n            that contain `np.NaN` somewhere are ignored. If `False` then\n            every row where neither the variable nor its parents are `np.NaN` is used.\n            Desired default behavior can be passed to the class constructor.\n\n        Returns\n        -------\n        state_counts: pandas.DataFrame\n            Table with state counts for 'variable'\n\n        Examples\n        --------\n        >>> import pandas as pd\n        >>> from pgmpy.models import BayesianModel\n        >>> from pgmpy.estimators import ParameterEstimator\n        >>> model = BayesianModel([('A', 'C'), ('B', 'C')])\n        >>> data = pd.DataFrame(data={'A': ['a1', 'a1', 'a2'],\n                                      'B': ['b1', 'b2', 'b1'],\n                                      'C': ['c1', 'c1', 'c2']})\n        >>> estimator = ParameterEstimator(model, data)\n        >>> estimator.state_counts('A')\n            A\n        a1  2\n        a2  1\n        >>> estimator.state_counts('C')\n        A  a1      a2\n        B  b1  b2  b1  b2\n        C\n        c1  1   1   0   0\n        c2  0   0   1   0\n        \"\"\"\n\n        parents = sorted(self.model.get_parents(variable))\n        return super(ParameterEstimator, self).state_counts(variable, parents=parents, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add_node(self, node, **kwargs):\n        if not isinstance(node, (list, set, tuple)):\n            raise TypeError('Node can only be a list, set or tuple of nodes forming a clique')\n\n        node = tuple(node)\n        super(ClusterGraph, self).add_node(node, **kwargs)", "response": "Add a single node to the cluster graph."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add_nodes_from(self, nodes, **kwargs):\n        for node in nodes:\n            self.add_node(node, **kwargs)", "response": "Add multiple nodes to the cluster graph."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd an edge between two nodes.", "response": "def add_edge(self, u, v, **kwargs):\n        \"\"\"\n        Add an edge between two clique nodes.\n\n        Parameters\n        ----------\n        u, v: nodes\n            Nodes can be any list or set or tuple of nodes forming a clique.\n\n        Examples\n        --------\n        >>> from pgmpy.models import ClusterGraph\n        >>> G = ClusterGraph()\n        >>> G.add_nodes_from([('a', 'b', 'c'), ('a', 'b'), ('a', 'c')])\n        >>> G.add_edges_from([(('a', 'b', 'c'), ('a', 'b')),\n        ...                   (('a', 'b', 'c'), ('a', 'c'))])\n        \"\"\"\n        set_u = set(u)\n        set_v = set(v)\n        if set_u.isdisjoint(set_v):\n            raise ValueError('No sepset found between these two edges.')\n\n        super(ClusterGraph, self).add_edge(u, v)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nassociates a factor with the cluster graph.", "response": "def add_factors(self, *factors):\n        \"\"\"\n        Associate a factor to the graph.\n        See factors class for the order of potential values\n\n        Parameters\n        ----------\n        *factor: pgmpy.factors.factors object\n            A factor object on any subset of the variables of the model which\n            is to be associated with the model.\n\n        Returns\n        -------\n        None\n\n        Examples\n        --------\n        >>> from pgmpy.models import ClusterGraph\n        >>> from pgmpy.factors.discrete import DiscreteFactor\n        >>> student = ClusterGraph()\n        >>> student.add_node(('Alice', 'Bob'))\n        >>> factor = DiscreteFactor(['Alice', 'Bob'], cardinality=[3, 2],\n        ...                 values=np.random.rand(6))\n        >>> student.add_factors(factor)\n        \"\"\"\n        for factor in factors:\n            factor_scope = set(factor.scope())\n            nodes = [set(node) for node in self.nodes()]\n            if factor_scope not in nodes:\n                raise ValueError('Factors defined on clusters of variable not'\n                                 'present in model')\n\n            self.factors.append(factor)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_factors(self, node=None):\n        if node is None:\n            return self.factors\n        else:\n            nodes = [set(n) for n in self.nodes()]\n\n            if set(node) not in nodes:\n                raise ValueError('Node not present in Cluster Graph')\n\n            factors = filter(lambda x: set(x.scope()) == set(node), self.factors)\n            return next(factors)", "response": "Returns the factors that have been added till now to the graph."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_cardinality(self, node=None):\n        if node:\n            for factor in self.factors:\n                for variable, cardinality in zip(factor.scope(), factor.cardinality):\n                    if node == variable:\n                        return cardinality\n\n        else:\n            cardinalities = defaultdict(int)\n            for factor in self.factors:\n                for variable, cardinality in zip(factor.scope(), factor.cardinality):\n                    cardinalities[variable] = cardinality\n            return cardinalities", "response": "Returns the cardinality of the node."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef check_model(self):\n        for clique in self.nodes():\n            factors = filter(lambda x: set(x.scope()) == set(clique), self.factors)\n            if not any(factors):\n                raise ValueError('Factors for all the cliques or clusters not defined.')\n\n        cardinalities = self.get_cardinality()\n        if len(set((x for clique in self.nodes() for x in clique))) != len(cardinalities):\n            raise ValueError('Factors for all the variables not defined.')\n\n        for factor in self.factors:\n            for variable, cardinality in zip(factor.scope(), factor.cardinality):\n                if (cardinalities[variable] != cardinality):\n                    raise ValueError(\n                        'Cardinality of variable {var} not matching among factors'.format(var=variable))\n\n        return True", "response": "Checks the model for various errors."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef copy(self):\n        copy = ClusterGraph(self.edges())\n        if self.factors:\n            factors_copy = [factor.copy() for factor in self.factors]\n            copy.add_factors(*factors_copy)\n        return copy", "response": "Returns a copy of ClusterGraph."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nfind the index of the maximum values for all the single node dual objectives. Reference: code presented by Sontag in 2012 here: http://cs.nyu.edu/~dsontag/code/README_v2.html", "response": "def _local_decode(self):\n        \"\"\"\n        Finds the index of the maximum values for all the single node dual objectives.\n\n        Reference:\n        code presented by Sontag in 2012 here: http://cs.nyu.edu/~dsontag/code/README_v2.html\n        \"\"\"\n        # The current assignment of the single node factors is stored in the form of a dictionary\n        decoded_result_assignment = {node: np.argmax(self.objective[node].values)\n                                     for node in self.objective if len(node) == 1}\n        # Use the original cluster_potentials of each factor to find the primal integral value.\n        # 1. For single node factors\n        integer_value = sum([self.factors[variable][0].values[decoded_result_assignment[frozenset([variable])]]\n                             for variable in self.variables])\n        # 2. For clusters\n        for cluster_key in self.cluster_set:\n            cluster = self.cluster_set[cluster_key]\n            index = [tuple([variable, decoded_result_assignment[frozenset([variable])]])\n                     for variable in cluster.cluster_variables]\n            integer_value += cluster.cluster_potential.reduce(index, inplace=False).values\n\n        # Check if this is the best assignment till now\n        if self.best_int_objective < integer_value:\n            self.best_int_objective = integer_value\n            self.best_assignment = decoded_result_assignment"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nfind all the triangles present in the given model.", "response": "def find_triangles(self):\n        \"\"\"\n        Finds all the triangles present in the given model\n\n        Examples\n        --------\n        >>> from pgmpy.models import MarkovModel\n        >>> from pgmpy.factors.discrete import DiscreteFactor\n        >>> from pgmpy.inference import Mplp\n        >>> mm = MarkovModel()\n        >>> mm.add_nodes_from(['x1', 'x2', 'x3', 'x4', 'x5', 'x6', 'x7'])\n        >>> mm.add_edges_from([('x1', 'x3'), ('x1', 'x4'), ('x2', 'x4'),\n        ...                    ('x2', 'x5'), ('x3', 'x6'), ('x4', 'x6'),\n        ...                    ('x4', 'x7'), ('x5', 'x7')])\n        >>> phi = [DiscreteFactor(edge, [2, 2], np.random.rand(4)) for edge in mm.edges()]\n        >>> mm.add_factors(*phi)\n        >>> mplp = Mplp(mm)\n        >>> mplp.find_triangles()\n        \"\"\"\n        return list(filter(lambda x: len(x) == 3, nx.find_cliques(self.model)))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nupdating the cluster set and objective for each of the given list of triangles.", "response": "def _update_triangles(self, triangles_list):\n        \"\"\"\n        From a set of variables forming a triangle in the model, we form the corresponding Clusters.\n        These clusters are then appended to the code.\n\n        Parameters\n        ----------\n        triangle_list : list\n                        The list of variables forming the triangles to be updated. It is of the form of\n                        [['var_5', 'var_8', 'var_7'], ['var_4', 'var_5', 'var_7']]\n\n        \"\"\"\n        new_intersection_set = []\n        for triangle_vars in triangles_list:\n            cardinalities = [self.cardinality[variable] for variable in triangle_vars]\n            current_intersection_set = [frozenset(intersect) for intersect in it.combinations(triangle_vars, 2)]\n            current_factor = DiscreteFactor(triangle_vars, cardinalities, np.zeros(np.prod(cardinalities)))\n            self.cluster_set[frozenset(triangle_vars)] = self.Cluster(current_intersection_set, current_factor)\n            # add new factors\n            self.model.factors.append(current_factor)\n            # add new intersection sets\n            new_intersection_set.extend(current_intersection_set)\n            # add new factors in objective\n            self.objective[frozenset(triangle_vars)] = current_factor"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the scores of each of the triplets found in the current model.", "response": "def _get_triplet_scores(self, triangles_list):\n        \"\"\"\n        Returns the score of each of the triplets found in the current model\n\n        Parameters\n        ---------\n        triangles_list: list\n                        The list of variables forming the triangles to be updated. It is of the form of\n                        [['var_5', 'var_8', 'var_7'], ['var_4', 'var_5', 'var_7']]\n\n        Return: {frozenset({'var_8', 'var_5', 'var_7'}): 5.024, frozenset({'var_5', 'var_4', 'var_7'}): 10.23}\n        \"\"\"\n        triplet_scores = {}\n        for triplet in triangles_list:\n\n            # Find the intersection sets of the current triplet\n            triplet_intersections = [intersect for intersect in it.combinations(triplet, 2)]\n\n            # Independent maximization\n            ind_max = sum([np.amax(self.objective[frozenset(intersect)].values) for intersect in triplet_intersections])\n\n            # Joint maximization\n            joint_max = self.objective[frozenset(triplet_intersections[0])]\n            for intersect in triplet_intersections[1:]:\n                joint_max += self.objective[frozenset(intersect)]\n            joint_max = np.amax(joint_max.values)\n            # score = Independent maximization solution - Joint maximization solution\n            score = ind_max - joint_max\n            triplet_scores[frozenset(triplet)] = score\n\n        return triplet_scores"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nrun MPLP on the cluster set.", "response": "def _run_mplp(self, no_iterations):\n        \"\"\"\n        Updates messages until either Mplp converges or if doesn't converges; halts after no_iterations.\n\n        Parameters\n        --------\n        no_iterations:  integer\n                        Number of maximum iterations that we want MPLP to run.\n        \"\"\"\n        for niter in range(no_iterations):\n            # We take the clusters in the order they were added in the model and update messages for all factors whose\n            # scope is greater than 1\n            for factor in self.model.get_factors():\n                if len(factor.scope()) > 1:\n                    self._update_message(self.cluster_set[frozenset(factor.scope())])\n            # Find an integral solution by locally maximizing the single node beliefs\n            self._local_decode()\n            # If mplp converges to a global/local optima, we break.\n            if self._is_converged(self.dual_threshold, self.integrality_gap_threshold) and niter >= 16:\n                break"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nmaps query method using Max Product LP method. This returns the best assignment of the nodes in the form of a dictionary. Parameters ---------- init_iter: integer Number of maximum iterations that we want MPLP to run for the first time. later_iter: integer Number of maximum iterations that we want MPLP to run for later iterations dual_threshold: double This sets the minimum width between the dual objective decrements. If the decrement is lesser than the threshold, then that means we have stuck on a local minima. integrality_gap_threshold: double This sets the threshold for the integrality gap below which we say that the solution is satisfactory. tighten_triplet: bool set whether to use triplets as clusters or not. max_triplets: integer Set the maximum number of triplets that can be added at once. max_iterations: integer Maximum number of times we tighten the relaxation. Used only when tighten_triplet is set True. prolong: bool If set False: The moment we exhaust of all the triplets the tightening stops. If set True: The tightening will be performed max_iterations number of times irrespective of the triplets. Reference: Section 3.3: The Dual Algorithm; Tightening LP Relaxation for MAP using Message Passing (2008) By Sontag Et al. Examples -------- >>> from pgmpy.models import MarkovModel >>> from pgmpy.factors.discrete import DiscreteFactor >>> from pgmpy.inference import Mplp >>> import numpy as np >>> student = MarkovModel() >>> student.add_edges_from([('A', 'B'), ('B', 'C'), ('C', 'D'), ('E', 'F')]) >>> factor_a = DiscreteFactor(['A'], cardinality=[2], values=np.array([0.54577, 1.8323])) >>> factor_b = DiscreteFactor(['B'], cardinality=[2], values=np.array([0.93894, 1.065])) >>> factor_c = DiscreteFactor(['C'], cardinality=[2], values=np.array([0.89205, 1.121])) >>> factor_d = DiscreteFactor(['D'], cardinality=[2], values=np.array([0.56292, 1.7765])) >>> factor_e = DiscreteFactor(['E'], cardinality=[2], values=np.array([0.47117, 2.1224])) >>> factor_f = DiscreteFactor(['F'], cardinality=[2], values=np.array([1.5093, 0.66257])) >>> factor_a_b = DiscreteFactor(['A', 'B'], cardinality=[2, 2], ... values=np.array([1.3207, 0.75717, 0.75717, 1.3207])) >>> factor_b_c = DiscreteFactor(['B', 'C'], cardinality=[2, 2], ... values=np.array([0.00024189, 4134.2, 4134.2, 0.0002418])) >>> factor_c_d = DiscreteFactor(['C', 'D'], cardinality=[2, 2], ... values=np.array([0.0043227, 231.34, 231.34, 0.0043227])) >>> factor_d_e = DiscreteFactor(['E', 'F'], cardinality=[2, 2], ... values=np.array([31.228, 0.032023, 0.032023, 31.228])) >>> student.add_factors(factor_a, factor_b, factor_c, factor_d, factor_e, factor_f, ... factor_a_b, factor_b_c, factor_c_d, factor_d_e) >>> mplp = Mplp(student) >>> result = mplp.map_query() >>> result {'B': 0.93894, 'C': 1.121, 'A': 1.8323, 'F': 1.5093, 'D': 1.7765, 'E': 2.12239}", "response": "def map_query(self, init_iter=1000, later_iter=20, dual_threshold=0.0002, integrality_gap_threshold=0.0002,\n                  tighten_triplet=True, max_triplets=5, max_iterations=100, prolong=False):\n        \"\"\"\n        MAP query method using Max Product LP method.\n        This returns the best assignment of the nodes in the form of a dictionary.\n\n        Parameters\n        ----------\n        init_iter: integer\n                   Number of maximum iterations that we want MPLP to run for the first time.\n\n        later_iter: integer\n                    Number of maximum iterations that we want MPLP to run for later iterations\n\n        dual_threshold: double\n                        This sets the minimum width between the dual objective decrements. If the decrement is lesser\n                        than the threshold, then that means we have stuck on a local minima.\n\n        integrality_gap_threshold: double\n                                   This sets the threshold for the integrality gap below which we say that the solution\n                                   is satisfactory.\n\n        tighten_triplet: bool\n                         set whether to use triplets as clusters or not.\n\n        max_triplets: integer\n                      Set the maximum number of triplets that can be added at once.\n\n        max_iterations: integer\n                        Maximum number of times we tighten the relaxation. Used only when tighten_triplet is set True.\n\n        prolong: bool\n                 If set False: The moment we exhaust of all the triplets the tightening stops.\n                 If set True: The tightening will be performed max_iterations number of times irrespective of the\n                              triplets.\n\n        Reference:\n        Section 3.3: The Dual Algorithm; Tightening LP Relaxation for MAP using Message Passing (2008)\n        By Sontag Et al.\n\n        Examples\n        --------\n        >>> from pgmpy.models import MarkovModel\n        >>> from pgmpy.factors.discrete import DiscreteFactor\n        >>> from pgmpy.inference import Mplp\n        >>> import numpy as np\n        >>> student = MarkovModel()\n        >>> student.add_edges_from([('A', 'B'), ('B', 'C'), ('C', 'D'), ('E', 'F')])\n        >>> factor_a = DiscreteFactor(['A'], cardinality=[2], values=np.array([0.54577, 1.8323]))\n        >>> factor_b = DiscreteFactor(['B'], cardinality=[2], values=np.array([0.93894, 1.065]))\n        >>> factor_c = DiscreteFactor(['C'], cardinality=[2], values=np.array([0.89205, 1.121]))\n        >>> factor_d = DiscreteFactor(['D'], cardinality=[2], values=np.array([0.56292, 1.7765]))\n        >>> factor_e = DiscreteFactor(['E'], cardinality=[2], values=np.array([0.47117, 2.1224]))\n        >>> factor_f = DiscreteFactor(['F'], cardinality=[2], values=np.array([1.5093, 0.66257]))\n        >>> factor_a_b = DiscreteFactor(['A', 'B'], cardinality=[2, 2],\n        ...                             values=np.array([1.3207, 0.75717, 0.75717, 1.3207]))\n        >>> factor_b_c = DiscreteFactor(['B', 'C'], cardinality=[2, 2],\n        ...                             values=np.array([0.00024189, 4134.2, 4134.2, 0.0002418]))\n        >>> factor_c_d = DiscreteFactor(['C', 'D'], cardinality=[2, 2],\n        ...                             values=np.array([0.0043227, 231.34, 231.34, 0.0043227]))\n        >>> factor_d_e = DiscreteFactor(['E', 'F'], cardinality=[2, 2],\n        ...                             values=np.array([31.228, 0.032023, 0.032023, 31.228]))\n        >>> student.add_factors(factor_a, factor_b, factor_c, factor_d, factor_e, factor_f,\n        ...                     factor_a_b, factor_b_c, factor_c_d, factor_d_e)\n        >>> mplp = Mplp(student)\n        >>> result = mplp.map_query()\n        >>> result\n        {'B': 0.93894, 'C': 1.121, 'A': 1.8323, 'F': 1.5093, 'D': 1.7765, 'E': 2.12239}\n        \"\"\"\n\n        self.dual_threshold = dual_threshold\n        self.integrality_gap_threshold = integrality_gap_threshold\n        # Run MPLP initially for a maximum of init_iter times.\n        self._run_mplp(init_iter)\n        # If triplets are to be used for the tightening, we proceed as follows\n        if tighten_triplet:\n            self._tighten_triplet(max_iterations, later_iter, max_triplets, prolong)\n        # Get the best result from the best assignment\n        self.best_decoded_result = {factor.scope()[0]: factor.values[self.best_assignment[frozenset(factor.scope())]]\n                                    for factor in self.model.factors if len(factor.scope()) == 1}\n        return self.best_decoded_result"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding an edge between u and v.", "response": "def add_edge(self, u, v, **kwargs):\n        \"\"\"\n        Add an edge between u and v.\n\n        The nodes u and v will be automatically added if they are\n        not already in the graph\n\n        Parameters\n        ----------\n        u,v : nodes\n            Nodes can be any hashable Python object.\n\n        Examples\n        --------\n        >>> from pgmpy.models import MarkovModel\n        >>> G = MarkovModel()\n        >>> G.add_nodes_from(['Alice', 'Bob', 'Charles'])\n        >>> G.add_edge('Alice', 'Bob')\n        \"\"\"\n        # check that there is no self loop.\n        if u != v:\n            super(MarkovModel, self).add_edge(u, v, **kwargs)\n        else:\n            raise ValueError('Self loops are not allowed')"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nassociating a factor with the model.", "response": "def add_factors(self, *factors):\n        \"\"\"\n        Associate a factor to the graph.\n        See factors class for the order of potential values\n\n        Parameters\n        ----------\n        *factor: pgmpy.factors.factors object\n            A factor object on any subset of the variables of the model which\n            is to be associated with the model.\n\n        Returns\n        -------\n        None\n\n        Examples\n        --------\n        >>> from pgmpy.models import MarkovModel\n        >>> from pgmpy.factors.discrete import DiscreteFactor\n        >>> student = MarkovModel([('Alice', 'Bob'), ('Bob', 'Charles'),\n        ...                        ('Charles', 'Debbie'), ('Debbie', 'Alice')])\n        >>> factor = DiscreteFactor(['Alice', 'Bob'], cardinality=[3, 2],\n        ...                 values=np.random.rand(6))\n        >>> student.add_factors(factor)\n        \"\"\"\n        for factor in factors:\n            if set(factor.variables) - set(factor.variables).intersection(\n                    set(self.nodes())):\n                raise ValueError(\"Factors defined on variable not in the model\",\n                                 factor)\n\n            self.factors.append(factor)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_factors(self, node=None):\n        if node:\n            if node not in self.nodes():\n                raise ValueError('Node not present in the Undirected Graph')\n            node_factors = []\n            for factor in self.factors:\n                if node in factor.scope():\n                    node_factors.append(factor)\n            return node_factors\n        else:\n            return self.factors", "response": "Returns all the factors that are present in the Undirected Graph."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncheck the model for various errors.", "response": "def check_model(self):\n        \"\"\"\n        Check the model for various errors. This method checks for the following\n        errors -\n\n        * Checks if the cardinalities of all the variables are consistent across all the factors.\n        * Factors are defined for all the random variables.\n\n        Returns\n        -------\n        check: boolean\n            True if all the checks are passed\n        \"\"\"\n        cardinalities = self.get_cardinality()\n        for factor in self.factors:\n            for variable, cardinality in zip(factor.scope(), factor.cardinality):\n                if cardinalities[variable] != cardinality:\n                    raise ValueError(\n                        'Cardinality of variable {var} not matching among factors'.format(var=variable))\n                if len(self.nodes()) != len(cardinalities):\n                    raise ValueError('Factors for all the variables not defined')\n            for var1, var2 in itertools.combinations(factor.variables, 2):\n                if var2 not in self.neighbors(var1):\n                    raise ValueError(\"DiscreteFactor inconsistent with the model.\")\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef to_factor_graph(self):\n        from pgmpy.models import FactorGraph\n        factor_graph = FactorGraph()\n\n        if not self.factors:\n            raise ValueError('Factors not associated with the random variables.')\n\n        factor_graph.add_nodes_from(self.nodes())\n        for factor in self.factors:\n            scope = factor.scope()\n            factor_node = 'phi_' + '_'.join(scope)\n            factor_graph.add_edges_from(itertools.product(scope, [factor_node]))\n            factor_graph.add_factors(factor)\n\n        return factor_graph", "response": "Converts the current object into a factor graph."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef triangulate(self, heuristic='H6', order=None, inplace=False):\n        self.check_model()\n\n        if self.is_triangulated():\n            if inplace:\n                return\n            else:\n                return self\n\n        graph_copy = nx.Graph(self.edges())\n        edge_set = set()\n\n        def _find_common_cliques(cliques_list):\n            \"\"\"\n            Finds the common cliques among the given set of cliques for\n            corresponding node.\n            \"\"\"\n            common = set([tuple(x) for x in cliques_list[0]])\n            for i in range(1, len(cliques_list)):\n                common = common & set([tuple(x) for x in cliques_list[i]])\n            return list(common)\n\n        def _find_size_of_clique(clique, cardinalities):\n            \"\"\"\n            Computes the size of a clique.\n\n            Size of a clique is defined as product of cardinalities of all the\n            nodes present in the clique.\n            \"\"\"\n            return list(map(lambda x: np.prod([cardinalities[node] for node in x]),\n                            clique))\n\n        def _get_cliques_dict(node):\n            \"\"\"\n            Returns a dictionary in the form of {node: cliques_formed} of the\n            node along with its neighboring nodes.\n\n            clique_dict_removed would be containing the cliques created\n            after deletion of the node\n            clique_dict_node would be containing the cliques created before\n            deletion of the node\n            \"\"\"\n            graph_working_copy = nx.Graph(graph_copy.edges())\n            neighbors = list(graph_working_copy.neighbors(node))\n            graph_working_copy.add_edges_from(itertools.combinations(neighbors, 2))\n            clique_dict = nx.cliques_containing_node(graph_working_copy,\n                                                     nodes=([node] + neighbors))\n            graph_working_copy.remove_node(node)\n            clique_dict_removed = nx.cliques_containing_node(graph_working_copy,\n                                                             nodes=neighbors)\n            return clique_dict, clique_dict_removed\n\n        if not order:\n            order = []\n\n            cardinalities = self.get_cardinality()\n            for index in range(self.number_of_nodes()):\n                # S represents the size of clique created by deleting the\n                # node from the graph\n                S = {}\n                # M represents the size of maximum size of cliques given by\n                # the node and its adjacent node\n                M = {}\n                # C represents the sum of size of the cliques created by the\n                # node and its adjacent node\n                C = {}\n                for node in set(graph_copy.nodes()) - set(order):\n                    clique_dict, clique_dict_removed = _get_cliques_dict(node)\n                    S[node] = _find_size_of_clique(\n                        _find_common_cliques(list(clique_dict_removed.values())),\n                        cardinalities\n                    )[0]\n                    common_clique_size = _find_size_of_clique(\n                        _find_common_cliques(list(clique_dict.values())),\n                        cardinalities\n                    )\n                    M[node] = np.max(common_clique_size)\n                    C[node] = np.sum(common_clique_size)\n\n                if heuristic == 'H1':\n                    node_to_delete = min(S, key=S.get)\n\n                elif heuristic == 'H2':\n                    S_by_E = {key: S[key] / cardinalities[key] for key in S}\n                    node_to_delete = min(S_by_E, key=S_by_E.get)\n\n                elif heuristic == 'H3':\n                    S_minus_M = {key: S[key] - M[key] for key in S}\n                    node_to_delete = min(S_minus_M, key=S_minus_M.get)\n\n                elif heuristic == 'H4':\n                    S_minus_C = {key: S[key] - C[key] for key in S}\n                    node_to_delete = min(S_minus_C, key=S_minus_C.get)\n\n                elif heuristic == 'H5':\n                    S_by_M = {key: S[key] / M[key] for key in S}\n                    node_to_delete = min(S_by_M, key=S_by_M.get)\n\n                else:\n                    S_by_C = {key: S[key] / C[key] for key in S}\n                    node_to_delete = min(S_by_C, key=S_by_C.get)\n\n                order.append(node_to_delete)\n\n        graph_copy = nx.Graph(self.edges())\n        for node in order:\n            for edge in itertools.combinations(graph_copy.neighbors(node), 2):\n                graph_copy.add_edge(edge[0], edge[1])\n                edge_set.add(edge)\n            graph_copy.remove_node(node)\n\n        if inplace:\n            for edge in edge_set:\n                self.add_edge(edge[0], edge[1])\n            return self\n\n        else:\n            graph_copy = MarkovModel(self.edges())\n            for edge in edge_set:\n                graph_copy.add_edge(edge[0], edge[1])\n            return graph_copy", "response": "Triangulate the graph.\n\n        If order of deletion is given heuristic algorithm will not be used.\n\n        Parameters\n        ----------\n        heuristic: H1 | H2 | H3 | H4 | H5 | H6\n            The heuristic algorithm to use to decide the deletion order of\n            the variables to compute the triangulated graph.\n            Let X be the set of variables and X(i) denotes the i-th variable.\n\n            * S(i) - The size of the clique created by deleting the variable.\n            * E(i) - Cardinality of variable X(i).\n            * M(i) - Maximum size of cliques given by X(i) and its adjacent nodes.\n            * C(i) - Sum of size of cliques given by X(i) and its adjacent nodes.\n\n            The heuristic algorithm decide the deletion order if this way:\n\n            * H1 - Delete the variable with minimal S(i).\n            * H2 - Delete the variable with minimal S(i)/E(i).\n            * H3 - Delete the variable with minimal S(i) - M(i).\n            * H4 - Delete the variable with minimal S(i) - C(i).\n            * H5 - Delete the variable with minimal S(i)/M(i).\n            * H6 - Delete the variable with minimal S(i)/C(i).\n\n        order: list, tuple (array-like)\n            The order of deletion of the variables to compute the triagulated\n            graph. If order is given heuristic algorithm will not be used.\n\n        inplace: True | False\n            if inplace is true then adds the edges to the object from\n            which it is called else returns a new object.\n\n        Reference\n        ---------\n        http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.56.3607\n\n        Examples\n        --------\n        >>> from pgmpy.models import MarkovModel\n        >>> from pgmpy.factors.discrete import DiscreteFactor\n        >>> G = MarkovModel()\n        >>> G.add_nodes_from(['x1', 'x2', 'x3', 'x4', 'x5', 'x6', 'x7'])\n        >>> G.add_edges_from([('x1', 'x3'), ('x1', 'x4'), ('x2', 'x4'),\n        ...                   ('x2', 'x5'), ('x3', 'x6'), ('x4', 'x6'),\n        ...                   ('x4', 'x7'), ('x5', 'x7')])\n        >>> phi = [DiscreteFactor(edge, [2, 2], np.random.rand(4)) for edge in G.edges()]\n        >>> G.add_factors(*phi)\n        >>> G_chordal = G.triangulate()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef to_junction_tree(self):\n        from pgmpy.models import JunctionTree\n\n        # Check whether the model is valid or not\n        self.check_model()\n\n        # Triangulate the graph to make it chordal\n        triangulated_graph = self.triangulate()\n\n        # Find maximal cliques in the chordal graph\n        cliques = list(map(tuple, nx.find_cliques(triangulated_graph)))\n\n        # If there is only 1 clique, then the junction tree formed is just a\n        # clique tree with that single clique as the node\n        if len(cliques) == 1:\n            clique_trees = JunctionTree()\n            clique_trees.add_node(cliques[0])\n\n        # Else if the number of cliques is more than 1 then create a complete\n        # graph with all the cliques as nodes and weight of the edges being\n        # the length of sepset between two cliques\n        elif len(cliques) >= 2:\n            complete_graph = UndirectedGraph()\n            edges = list(itertools.combinations(cliques, 2))\n            weights = list(map(lambda x: len(set(x[0]).intersection(set(x[1]))),\n                           edges))\n            for edge, weight in zip(edges, weights):\n                complete_graph.add_edge(*edge, weight=-weight)\n\n            # Create clique trees by minimum (or maximum) spanning tree method\n            clique_trees = JunctionTree(nx.minimum_spanning_tree(complete_graph).edges())\n\n        # Check whether the factors are defined for all the random variables or not\n        all_vars = itertools.chain(*[factor.scope() for factor in self.factors])\n        if set(all_vars) != set(self.nodes()):\n            ValueError('DiscreteFactor for all the random variables not specified')\n\n        # Dictionary stating whether the factor is used to create clique\n        # potential or not\n        # If false, then it is not used to create any clique potential\n        is_used = {factor: False for factor in self.factors}\n\n        for node in clique_trees.nodes():\n            clique_factors = []\n            for factor in self.factors:\n                # If the factor is not used in creating any clique potential as\n                # well as has any variable of the given clique in its scope,\n                # then use it in creating clique potential\n                if not is_used[factor] and set(factor.scope()).issubset(node):\n                    clique_factors.append(factor)\n                    is_used[factor] = True\n\n            # To compute clique potential, initially set it as unity factor\n            var_card = [self.get_cardinality()[x] for x in node]\n            clique_potential = DiscreteFactor(node, var_card, np.ones(np.product(var_card)))\n            # multiply it with the factors associated with the variables present\n            # in the clique (or node)\n            # Checking if there's clique_factors, to handle the case when clique_factors\n            # is empty, otherwise factor_product with throw an error [ref #889]\n            if clique_factors:\n                clique_potential *= factor_product(*clique_factors)\n            clique_trees.add_factors(clique_potential)\n\n        if not all(is_used.values()):\n            raise ValueError('All the factors were not used to create Junction Tree.'\n                             'Extra factors are defined.')\n\n        return clique_trees", "response": "Creates a junction tree for a given markov model."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn all the local independencies present in the markov model.", "response": "def get_local_independencies(self, latex=False):\n        \"\"\"\n        Returns all the local independencies present in the markov model.\n\n        Local independencies are the independence assertion in the form of\n        .. math:: {X \\perp W - {X} - MB(X) | MB(X)}\n        where MB is the markov blanket of all the random variables in X\n\n        Parameters\n        ----------\n        latex: boolean\n            If latex=True then latex string of the indepedence assertion would\n            be created\n\n        Examples\n        --------\n        >>> from pgmpy.models import MarkovModel\n        >>> mm = MarkovModel()\n        >>> mm.add_nodes_from(['x1', 'x2', 'x3', 'x4', 'x5', 'x6', 'x7'])\n        >>> mm.add_edges_from([('x1', 'x3'), ('x1', 'x4'), ('x2', 'x4'),\n        ...                    ('x2', 'x5'), ('x3', 'x6'), ('x4', 'x6'),\n        ...                    ('x4', 'x7'), ('x5', 'x7')])\n        >>> mm.get_local_independecies()\n        \"\"\"\n        local_independencies = Independencies()\n\n        all_vars = set(self.nodes())\n        for node in self.nodes():\n            markov_blanket = set(self.markov_blanket(node))\n            rest = all_vars - set([node]) - markov_blanket\n            try:\n                local_independencies.add_assertions([node, list(rest), list(markov_blanket)])\n            except ValueError:\n                pass\n\n        local_independencies.reduce()\n\n        if latex:\n            return local_independencies.latex_string()\n        else:\n            return local_independencies"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef to_bayesian_model(self):\n        from pgmpy.models import BayesianModel\n\n        bm = BayesianModel()\n        var_clique_dict = defaultdict(tuple)\n        var_order = []\n\n        # Create a junction tree from the markov model.\n        # Creation of clique tree involves triangulation, finding maximal cliques\n        # and creating a tree from these cliques\n        junction_tree = self.to_junction_tree()\n\n        # create an ordering of the nodes based on the ordering of the clique\n        # in which it appeared first\n        root_node = next(iter(junction_tree.nodes()))\n        bfs_edges = nx.bfs_edges(junction_tree, root_node)\n        for node in root_node:\n            var_clique_dict[node] = root_node\n            var_order.append(node)\n        for edge in bfs_edges:\n            clique_node = edge[1]\n            for node in clique_node:\n                if not var_clique_dict[node]:\n                    var_clique_dict[node] = clique_node\n                    var_order.append(node)\n\n        # create a bayesian model by adding edges from parent of node to node as\n        # par(x_i) = (var(c_k) - x_i) \\cap {x_1, ..., x_{i-1}}\n        for node_index in range(len(var_order)):\n            node = var_order[node_index]\n            node_parents = (set(var_clique_dict[node]) - set([node])).intersection(\n                set(var_order[:node_index]))\n            bm.add_edges_from([(parent, node) for parent in node_parents])\n            # TODO : Convert factor into CPDs\n        return bm", "response": "Creates a Bayesian Model which is a minimum I - Map for this markov model."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_partition_function(self):\n        self.check_model()\n\n        factor = self.factors[0]\n        factor = factor_product(factor, *[self.factors[i] for i in\n                                          range(1, len(self.factors))])\n        if set(factor.scope()) != set(self.nodes()):\n            raise ValueError('DiscreteFactor for all the random variables not defined.')\n\n        return np.sum(factor.values)", "response": "Returns the partition function for a given undirected graph."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a copy of this Markov Model.", "response": "def copy(self):\n        \"\"\"\n        Returns a copy of this Markov Model.\n\n        Returns\n        -------\n        MarkovModel: Copy of this Markov model.\n\n        Examples\n        -------\n        >>> from pgmpy.factors.discrete import DiscreteFactor\n        >>> from pgmpy.models import MarkovModel\n        >>> G = MarkovModel()\n        >>> G.add_nodes_from([('a', 'b'), ('b', 'c')])\n        >>> G.add_edge(('a', 'b'), ('b', 'c'))\n        >>> G_copy = G.copy()\n        >>> G_copy.edges()\n        [(('a', 'b'), ('b', 'c'))]\n        >>> G_copy.nodes()\n        [('a', 'b'), ('b', 'c')]\n        >>> factor = DiscreteFactor([('a', 'b')], cardinality=[3],\n        ...                 values=np.random.rand(3))\n        >>> G.add_factors(factor)\n        >>> G.get_factors()\n        [<DiscreteFactor representing phi(('a', 'b'):3) at 0x...>]\n        >>> G_copy.get_factors()\n        []\n        \"\"\"\n        clone_graph = MarkovModel(self.edges())\n        clone_graph.add_nodes_from(self.nodes())\n\n        if self.factors:\n            factors_copy = [factor.copy() for factor in self.factors]\n            clone_graph.add_factors(*factors_copy)\n\n        return clone_graph"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef pdf(self):\n        return lambda *args: multivariate_normal.pdf(\n            args, self.mean.reshape(1, len(self.variables))[0], self.covariance)", "response": "PDF function for the log - likelihood of a set of variables."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the precision matrix of the distribution.", "response": "def precision_matrix(self):\n        \"\"\"\n        Returns the precision matrix of the distribution.\n\n        Precision is defined as the inverse of the variance. This method returns\n        the inverse matrix of the covariance.\n\n        Examples\n        --------\n        >>> import numpy as np\n        >>> from pgmpy.factors.distributions import GaussianDistribution as GD\n        >>> dis = GD(variables=['x1', 'x2', 'x3'],\n        ...          mean=[1, -3, 4],\n        ...          cov=[[4, 2, -2],\n        ...               [2, 5, -5],\n        ...               [-2, -5, 8]]))\n        >>> dis.precision_matrix\n        array([[ 0.3125    , -0.125     ,  0.        ],\n               [-0.125     ,  0.58333333,  0.33333333],\n               [ 0.        ,  0.33333333,  0.33333333]])\n        \"\"\"\n        if self._precision_matrix is None:\n            self._precision_matrix = np.linalg.inv(self.covariance)\n        return self._precision_matrix"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef marginalize(self, variables, inplace=True):\n        if not isinstance(variables, list):\n            raise TypeError(\"variables: Expected type list or array-like,\"\n                            \"got type {var_type}\".format(\n                                var_type=type(variables)))\n\n        phi = self if inplace else self.copy()\n\n        index_to_keep = [self.variables.index(var) for var in self.variables\n                         if var not in variables]\n\n        phi.variables = [phi.variables[index] for index in index_to_keep]\n        phi.mean = phi.mean[index_to_keep]\n        phi.covariance = phi.covariance[np.ix_(index_to_keep, index_to_keep)]\n        phi._precision_matrix = None\n\n        if not inplace:\n            return phi", "response": "Returns a new GaussianDistribution instance with marginalized values."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreduces the distribution to the context of the given variable values.", "response": "def reduce(self, values, inplace=True):\n        \"\"\"\n        Reduces the distribution to the context of the given variable values.\n\n        The formula for the obtained conditional distribution is given by -\n\n        For,\n        .. math:: N(X_j | X_i = x_i) ~ N(mu_{j.i} ; sig_{j.i})\n\n        where,\n        .. math:: mu_{j.i} = mu_j + sig_{j, i} * {sig_{i, i}^{-1}} * (x_i - mu_i)\n        .. math:: sig_{j.i} = sig_{j, j} - sig_{j, i} * {sig_{i, i}^{-1}} * sig_{i, j}\n\n        Parameters\n        ----------\n        values: list, array-like\n            A list of tuples of the form (variable_name, variable_value).\n\n        inplace: boolean\n            If inplace=True it will modify the factor itself, else would return\n            a new ContinuosFactor object.\n\n        Returns\n        -------\n        GaussianDistribution or None:\n                if inplace=True (default) returns None\n                if inplace=False returns a new GaussianDistribution instance.\n\n        Examples\n        --------\n        >>> import numpy as np\n        >>> from pgmpy.factors.distributions import GaussianDistribution as GD\n        >>> dis = GD(variables=['x1', 'x2', 'x3'],\n        ...             mean=[1, -3, 4],\n        ...             cov=[[4, 2, -2],\n        ...                  [2, 5, -5],\n        ...                  [-2, -5, 8]])\n        >>> dis.variables\n        ['x1', 'x2', 'x3']\n        >>> dis.mean\n        array([[ 1.],\n               [-3.],\n               [ 4.]])\n        >>> dis.covariance\n        array([[ 4.,  2., -2.],\n               [ 2.,  5., -5.],\n               [-2., -5.,  8.]])\n\n        >>> dis.reduce([('x1', 7)])\n        >>> dis.variables\n        ['x2', 'x3']\n        >>> dis.mean\n        array([[ 0.],\n               [ 1.]])\n        >>> dis.covariance\n        array([[ 4., -4.],\n               [-4.,  7.]])\n\n        \"\"\"\n        if not isinstance(values, list):\n            raise TypeError(\"values: Expected type list or array-like, \",\n                            \"got type {var_type}\".format(\n                                var_type=type(values)))\n\n        phi = self if inplace else self.copy()\n\n        var_to_reduce = [var for var, value in values]\n\n        # index_to_keep -> j vector\n        index_to_keep = [self.variables.index(var) for var in self.variables\n                         if var not in var_to_reduce]\n        # index_to_reduce -> i vector\n        index_to_reduce = [self.variables.index(var) for var in var_to_reduce]\n\n        mu_j = self.mean[index_to_keep]\n        mu_i = self.mean[index_to_reduce]\n        x_i = np.array([value for var, value in values]).reshape(len(index_to_reduce), 1)\n\n        sig_i_j = self.covariance[np.ix_(index_to_reduce, index_to_keep)]\n        sig_j_i = self.covariance[np.ix_(index_to_keep, index_to_reduce)]\n        sig_i_i_inv = np.linalg.inv(self.covariance[np.ix_(index_to_reduce, index_to_reduce)])\n        sig_j_j = self.covariance[np.ix_(index_to_keep, index_to_keep)]\n\n        phi.variables = [self.variables[index] for index in index_to_keep]\n        phi.mean = mu_j + np.dot(np.dot(sig_j_i, sig_i_i_inv), x_i - mu_i)\n        phi.covariance = sig_j_j - np.dot(np.dot(sig_j_i, sig_i_i_inv), sig_i_j)\n        phi._precision_matrix = None\n\n        if not inplace:\n            return phi"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef normalize(self, inplace=True):\n        phi = self if inplace else self.copy()\n\n        # The pdf of a Joint Gaussian distrinution is always\n        # normalized. Hence, no changes.\n        if not inplace:\n            return phi", "response": "Normalizes the distribution. In case of a Gaussian Distribution the\n        distribution is always normalized, therefore this method doesn't do\n        anything and has been implemented only for a consistent API across\n        distributions."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef copy(self):\n        copy_distribution = GaussianDistribution(variables=self.variables,\n                                                 mean=self.mean.copy(),\n                                                 cov=self.covariance.copy())\n        if self._precision_matrix is not None:\n            copy_distribution._precision_matrix = self._precision_matrix.copy()\n\n        return copy_distribution", "response": "Returns a copy of the distribution."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef to_canonical_factor(self):\n        from pgmpy.factors.continuous import CanonicalDistribution\n\n        mu = self.mean\n        sigma = self.covariance\n\n        K = self.precision_matrix\n\n        h = np.dot(K, mu)\n\n        g = -(0.5) * np.dot(mu.T, h)[0, 0] - np.log(\n            np.power(2 * np.pi, len(self.variables)/2) *\n            np.power(abs(np.linalg.det(sigma)), 0.5))\n\n        return CanonicalDistribution(self.variables, K, h, g)", "response": "u Returns a canonical factor object for the given log - likelihood."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the product or divide of this factor and the other factor.", "response": "def _operate(self, other, operation, inplace=True):\n        \"\"\"\n        Gives the CanonicalDistribution operation (product or divide) with\n        the other factor.\n\n        Parameters\n        ----------\n        other: CanonicalDistribution\n            The CanonicalDistribution to be multiplied.\n\n        operation: String\n            'product' for multiplication operation and\n            'divide' for division operation.\n\n        Returns\n        -------\n        CanonicalDistribution or None:\n                        if inplace=True (default) returns None\n                        if inplace=False returns a new CanonicalDistribution instance.\n\n        Examples\n        --------\n        >>> import numpy as np\n        >>> from pgmpy.factors.distributions import GaussianDistribution as GD\n        >>> dis1 = GD(['x1', 'x2', 'x3'], np.array([[1], [-3], [4]]),\n        ...             np.array([[4, 2, -2], [2, 5, -5], [-2, -5, 8]]))\n        >>> dis2 = GD(['x3', 'x4'], [1, 2], [[2, 3], [5, 6]])\n        >>> dis3 = dis1 * dis2\n        >>> dis3.covariance\n        array([[ 3.6,  1. , -0.4, -0.6],\n               [ 1. ,  2.5, -1. , -1.5],\n               [-0.4, -1. ,  1.6,  2.4],\n               [-1. , -2.5,  4. ,  4.5]])\n        >>> dis3.mean\n        array([[ 1.6],\n               [-1.5],\n               [ 1.6],\n               [ 3.5]])\n        \"\"\"\n        phi = self.to_canonical_factor()._operate(\n            other.to_canonical_factor(), operation, inplace=False).to_joint_gaussian()\n\n        if not inplace:\n            return phi"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the product of two GaussianDistribution objects.", "response": "def product(self, other, inplace=True):\n        \"\"\"\n        TODO: Make it work when using `*` instead of product.\n\n        Returns the product of two gaussian distributions.\n\n        Parameters\n        ----------\n        other: GaussianDistribution\n            The GaussianDistribution to be multiplied.\n\n        inplace: boolean\n            If True, modifies the distribution itself, otherwise returns a new\n            GaussianDistribution object.\n\n        Returns\n        -------\n        CanonicalDistribution or None:\n                    if inplace=True (default) returns None.\n                    if inplace=False returns a new CanonicalDistribution instance.\n\n        Examples\n        --------\n        >>> import numpy as np\n        >>> from pgmpy.factors.distributions import GaussianDistribution as GD\n        >>> dis1 = GD(['x1', 'x2', 'x3'], np.array([[1], [-3], [4]]),\n        ...            np.array([[4, 2, -2], [2, 5, -5], [-2, -5, 8]]))\n        >>> dis2 = GD(['x3', 'x4'], [1, 2], [[2, 3], [5, 6]])\n        >>> dis3 = dis1.product(dis2, inplace=False)\n        >>> dis3.covariance\n        array([[ 3.6,  1. , -0.4, -0.6],\n               [ 1. ,  2.5, -1. , -1.5],\n               [-0.4, -1. ,  1.6,  2.4],\n               [-1. , -2.5,  4. ,  4.5]])\n        >>> dis3.mean\n        array([[ 1.6],\n               [-1.5],\n               [ 1.6],\n               [ 3.5]])\n        \"\"\"\n        return self._operate(other, operation='product', inplace=inplace)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the division of two GaussianDistribution objects.", "response": "def divide(self, other, inplace=True):\n        \"\"\"\n        Returns the division of two gaussian distributions.\n\n        Parameters\n        ----------\n        other: GaussianDistribution\n            The GaussianDistribution to be divided.\n\n        inplace: boolean\n            If True, modifies the distribution itself, otherwise returns a new\n            GaussianDistribution object.\n\n        Returns\n        -------\n        CanonicalDistribution or None:\n                    if inplace=True (default) returns None.\n                    if inplace=False returns a new CanonicalDistribution instance.\n\n        Examples\n        --------\n        >>> import numpy as np\n        >>> from pgmpy.factors.distributions import GaussianDistribution as GD\n        >>> dis1 = GD(['x1', 'x2', 'x3'], np.array([[1], [-3], [4]]),\n        ...            np.array([[4, 2, -2], [2, 5, -5], [-2, -5, 8]]))\n        >>> dis2 = GD(['x3', 'x4'], [1, 2], [[2, 3], [5, 6]])\n        >>> dis3 = dis1.divide(dis2, inplace=False)\n        >>> dis3.covariance\n        array([[ 3.6,  1. , -0.4, -0.6],\n               [ 1. ,  2.5, -1. , -1.5],\n               [-0.4, -1. ,  1.6,  2.4],\n               [-1. , -2.5,  4. ,  4.5]])\n        >>> dis3.mean\n        array([[ 1.6],\n               [-1.5],\n               [ 1.6],\n               [ 3.5]])\n        \"\"\"\n        return self._operate(other, operation='divide', inplace=inplace)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef discretize(self, method, *args, **kwargs):\n        super(CustomDistribution, self).discretize(method, *args, **kwargs)", "response": "Discretizes the continuous distribution into discrete\n            probability masses using specified method."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef reduce(self, values, inplace=True):\n        if not isinstance(values, (list, tuple, np.ndarray)):\n            raise TypeError(\"variables: Expected type: iterable, \"\n                            \"got: {var_type}\".format(var_type=type(values)))\n\n        for var, value in values:\n            if var not in self.variables:\n                raise ValueError(\"{var} not in scope.\".format(var=var))\n\n        phi = self if inplace else self.copy()\n\n        var_to_remove = [var for var, value in values]\n        var_to_keep = [var for var in self.variables if var not in var_to_remove]\n\n        reduced_var_index = [(self.variables.index(var), value) for var, value in values]\n        pdf = self.pdf\n\n        def reduced_pdf(*args, **kwargs):\n            reduced_args = list(args)\n            reduced_kwargs = kwargs.copy()\n\n            if reduced_args:\n                for index, val in reduced_var_index:\n                    reduced_args.insert(index, val)\n            if reduced_kwargs:\n                for variable, val in values:\n                    reduced_kwargs[variable] = val\n            if reduced_args and reduced_kwargs:\n                reduced_args = [arg for arg in reduced_args if arg not in\n                                reduced_kwargs.values()]\n\n            return pdf(*reduced_args, **reduced_kwargs)\n\n        phi.variables = var_to_keep\n        phi._pdf = reduced_pdf\n\n        if not inplace:\n            return phi", "response": "Reduces the factor to the context of the given variable values."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef normalize(self, inplace=True):\n        phi = self if inplace else self.copy()\n        pdf = self.pdf\n\n        pdf_mod = integrate.nquad(pdf, [[-np.inf, np.inf] for var in self.variables])[0]\n\n        phi._pdf = lambda *args: pdf(*args) / pdf_mod\n\n        if not inplace:\n            return phi", "response": "Normalizes the pdf of the distribution so that it integrates to 1 over all the variables."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a new instance of the same type with the same number of elements multiplied with the other.", "response": "def _operate(self, other, operation, inplace=True):\n        \"\"\"\n        Gives the CustomDistribution operation (product or divide) with\n        the other distribution.\n\n        Parameters\n        ----------\n        other: CustomDistribution\n            The CustomDistribution to be multiplied.\n\n        operation: str\n            'product' for multiplication operation and 'divide' for\n            division operation.\n\n        inplace: boolean\n            If inplace=True it will modify the factor itself, else would return\n            a new distribution.\n\n        Returns\n        -------\n        CustomDistribution or None:\n                        if inplace=True (default) returns None\n                        if inplace=False returns a new `CustomDistribution` instance.\n\n        \"\"\"\n        if not isinstance(other, CustomDistribution):\n            raise TypeError(\"CustomDistribution objects can only be multiplied \"\n                            \"or divided with another CustomDistribution  \"\n                            \"object. Got {other_type}, expected: \"\n                            \"CustomDistribution.\".format(other_type=type(other)))\n\n        phi = self if inplace else self.copy()\n        pdf = self.pdf\n        self_var = [var for var in self.variables]\n\n        modified_pdf_var = self_var + [var for var in other.variables if var not in self_var]\n\n        def modified_pdf(*args):\n            self_pdf_args = list(args[:len(self_var)])\n            other_pdf_args = [args[modified_pdf_var.index(var)] for var in other.variables]\n\n            if operation == 'product':\n                return pdf(*self_pdf_args) * other._pdf(*other_pdf_args)\n            if operation == 'divide':\n                return pdf(*self_pdf_args) / other._pdf(*other_pdf_args)\n\n        phi.variables = modified_pdf_var\n        phi._pdf = modified_pdf\n\n        if not inplace:\n            return phi"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef query(self, variables, evidence=None, elimination_order=None, joint=True):\n        return self._variable_elimination(variables, 'marginalize',\n                                          evidence=evidence, elimination_order=elimination_order,\n                                          joint=joint)", "response": "Query the probability distribution of a set of variables."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef max_marginal(self, variables=None, evidence=None, elimination_order=None):\n        if not variables:\n            variables = []\n        final_distribution = self._variable_elimination(variables, 'maximize',\n                                                        evidence=evidence,\n                                                        elimination_order=elimination_order)\n\n        return np.max(final_distribution.values)", "response": "Computes the max - marginal over the variables given the evidence."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef map_query(self, variables=None, evidence=None, elimination_order=None):\n        # TODO:Check the note in docstring. Change that behavior to return the joint MAP\n        final_distribution = self._variable_elimination(variables, 'marginalize',\n                                                        evidence=evidence,\n                                                        elimination_order=elimination_order)\n        argmax = np.argmax(final_distribution.values)\n        assignment = final_distribution.assignment([argmax])[0]\n\n        map_query_results = {}\n        for var_assignment in assignment:\n            var, value = var_assignment\n            map_query_results[var] = value\n\n        if not variables:\n            return map_query_results\n        else:\n            return_dict = {}\n            for var in variables:\n                return_dict[var] = map_query_results[var]\n            return return_dict", "response": "This function computes the MAP Query over the variables given the evidence and returns the max - marginalized version of the MAP query."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the induced graph formed by running Variable Elimination on the network.", "response": "def induced_graph(self, elimination_order):\n        \"\"\"\n        Returns the induced graph formed by running Variable Elimination on the network.\n\n        Parameters\n        ----------\n        elimination_order: list, array like\n            List of variables in the order in which they are to be eliminated.\n\n        Examples\n        --------\n        >>> import numpy as np\n        >>> import pandas as pd\n        >>> from pgmpy.models import BayesianModel\n        >>> from pgmpy.inference import VariableElimination\n        >>> values = pd.DataFrame(np.random.randint(low=0, high=2, size=(1000, 5)),\n        ...                       columns=['A', 'B', 'C', 'D', 'E'])\n        >>> model = BayesianModel([('A', 'B'), ('C', 'B'), ('C', 'D'), ('B', 'E')])\n        >>> model.fit(values)\n        >>> inference = VariableElimination(model)\n        >>> inference.induced_graph(['C', 'D', 'A', 'B', 'E'])\n        <networkx.classes.graph.Graph at 0x7f34ac8c5160>\n        \"\"\"\n        # If the elimination order does not contain the same variables as the model\n        if set(elimination_order) != set(self.variables):\n            raise ValueError(\"Set of variables in elimination order\"\n                             \" different from variables in model\")\n\n        eliminated_variables = set()\n        working_factors = {node: [factor.scope() for factor in self.factors[node]]\n                           for node in self.factors}\n\n        # The set of cliques that should be in the induced graph\n        cliques = set()\n        for factors in working_factors.values():\n            for factor in factors:\n                cliques.add(tuple(factor))\n\n        # Removing all the factors containing the variables which are\n        # eliminated (as all the factors should be considered only once)\n        for var in elimination_order:\n            factors = [factor for factor in working_factors[var]\n                       if not set(factor).intersection(eliminated_variables)]\n            phi = set(itertools.chain(*factors)).difference({var})\n            cliques.add(tuple(phi))\n            del working_factors[var]\n            for variable in phi:\n                working_factors[variable].append(list(phi))\n            eliminated_variables.add(var)\n\n        edges_comb = [itertools.combinations(c, 2)\n                      for c in filter(lambda x: len(x) > 1, cliques)]\n        return nx.Graph(itertools.chain(*edges_comb))"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the width of the induced graph formed by running Variable Elimination on the network.", "response": "def induced_width(self, elimination_order):\n        \"\"\"\n        Returns the width (integer) of the induced graph formed by running Variable Elimination on the network.\n        The width is the defined as the number of nodes in the largest clique in the graph minus 1.\n\n        Parameters\n        ----------\n        elimination_order: list, array like\n            List of variables in the order in which they are to be eliminated.\n\n        Examples\n        --------\n        >>> import numpy as np\n        >>> import pandas as pd\n        >>> from pgmpy.models import BayesianModel\n        >>> from pgmpy.inference import VariableElimination\n        >>> values = pd.DataFrame(np.random.randint(low=0, high=2, size=(1000, 5)),\n        ...                       columns=['A', 'B', 'C', 'D', 'E'])\n        >>> model = BayesianModel([('A', 'B'), ('C', 'B'), ('C', 'D'), ('B', 'E')])\n        >>> model.fit(values)\n        >>> inference = VariableElimination(model)\n        >>> inference.induced_width(['C', 'D', 'A', 'B', 'E'])\n        3\n        \"\"\"\n        induced_graph = self.induced_graph(elimination_order)\n        return nx.graph_clique_number(induced_graph) - 1"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nchecks whether the calibration has converged or not.", "response": "def _is_converged(self, operation):\n        \"\"\"\n        Checks whether the calibration has converged or not. At convergence\n        the sepset belief would be precisely the sepset marginal.\n\n        Parameters\n        ----------\n        operation: str ('marginalize' | 'maximize')\n            The operation to do for passing messages between nodes.\n            if operation == marginalize, it checks whether the junction tree is calibrated or not\n            else if operation == maximize, it checks whether the juction tree is max calibrated or not\n\n        Formally, at convergence or at calibration this condition would be satisified for\n\n        .. math:: \\sum_{C_i - S_{i, j}} \\beta_i = \\sum_{C_j - S_{i, j}} \\beta_j = \\mu_{i, j}\n\n        and at max calibration this condition would be satisfied\n\n        .. math:: \\max_{C_i - S_{i, j}} \\beta_i = \\max_{C_j - S_{i, j}} \\beta_j = \\mu_{i, j}\n        \"\"\"\n        # If no clique belief, then the clique tree is not calibrated\n        if not self.clique_beliefs:\n            return False\n\n        for edge in self.junction_tree.edges():\n            sepset = frozenset(edge[0]).intersection(frozenset(edge[1]))\n            sepset_key = frozenset(edge)\n            if (edge[0] not in self.clique_beliefs or edge[1] not in self.clique_beliefs or\n                    sepset_key not in self.sepset_beliefs):\n                return False\n\n            marginal_1 = getattr(self.clique_beliefs[edge[0]], operation)(list(frozenset(edge[0]) - sepset),\n                                                                          inplace=False)\n            marginal_2 = getattr(self.clique_beliefs[edge[1]], operation)(list(frozenset(edge[1]) - sepset),\n                                                                          inplace=False)\n            if marginal_1 != marginal_2 or marginal_1 != self.sepset_beliefs[sepset_key]:\n                return False\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _calibrate_junction_tree(self, operation):\n        # Initialize clique beliefs as well as sepset beliefs\n        self.clique_beliefs = {clique: self.junction_tree.get_factors(clique)\n                               for clique in self.junction_tree.nodes()}\n        self.sepset_beliefs = {frozenset(edge): None for edge in self.junction_tree.edges()}\n\n        for clique in self.junction_tree.nodes():\n            if not self._is_converged(operation=operation):\n                neighbors = self.junction_tree.neighbors(clique)\n                # update root's belief using nieighbor clique's beliefs\n                # upward pass\n                for neighbor_clique in neighbors:\n                    self._update_beliefs(neighbor_clique, clique, operation=operation)\n                bfs_edges = nx.algorithms.breadth_first_search.bfs_edges(self.junction_tree, clique)\n                # update the beliefs of all the nodes starting from the root to leaves using root's belief\n                # downward pass\n                for edge in bfs_edges:\n                    self._update_beliefs(edge[0], edge[1], operation=operation)\n            else:\n                break", "response": "This method calibrates the junction tree using belief propagation."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _query(self, variables, operation, evidence=None, joint=True):\n\n        is_calibrated = self._is_converged(operation=operation)\n        # Calibrate the junction tree if not calibrated\n        if not is_calibrated:\n            self.calibrate()\n\n        if not isinstance(variables, (list, tuple, set)):\n            query_variables = [variables]\n        else:\n            query_variables = list(variables)\n        query_variables.extend(evidence.keys() if evidence else [])\n\n        # Find a tree T' such that query_variables are a subset of scope(T')\n        nodes_with_query_variables = set()\n        for var in query_variables:\n            nodes_with_query_variables.update(filter(lambda x: var in x, self.junction_tree.nodes()))\n        subtree_nodes = nodes_with_query_variables\n\n        # Conversion of set to tuple just for indexing\n        nodes_with_query_variables = tuple(nodes_with_query_variables)\n        # As junction tree is a tree, that means that there would be only path between any two nodes in the tree\n        # thus we can just take the path between any two nodes; no matter there order is\n        for i in range(len(nodes_with_query_variables) - 1):\n            subtree_nodes.update(nx.shortest_path(self.junction_tree, nodes_with_query_variables[i],\n                                                  nodes_with_query_variables[i + 1]))\n        subtree_undirected_graph = self.junction_tree.subgraph(subtree_nodes)\n        # Converting subtree into a junction tree\n        if len(subtree_nodes) == 1:\n            subtree = JunctionTree()\n            subtree.add_node(subtree_nodes.pop())\n        else:\n            subtree = JunctionTree(subtree_undirected_graph.edges())\n\n        # Selecting a node is root node. Root node would be having only one neighbor\n        if len(subtree.nodes()) == 1:\n            root_node = list(subtree.nodes())[0]\n        else:\n            root_node = tuple(filter(lambda x: len(list(subtree.neighbors(x))) == 1, subtree.nodes()))[0]\n        clique_potential_list = [self.clique_beliefs[root_node]]\n\n        # For other nodes in the subtree compute the clique potentials as follows\n        # As all the nodes are nothing but tuples so simple set(root_node) won't work at it would update the set with'\n        # all the elements of the tuple; instead use set([root_node]) as it would include only the tuple not the\n        # internal elements within it.\n        parent_nodes = set([root_node])\n        nodes_traversed = set()\n        while parent_nodes:\n            parent_node = parent_nodes.pop()\n            for child_node in set(subtree.neighbors(parent_node)) - nodes_traversed:\n                clique_potential_list.append(self.clique_beliefs[child_node] /\n                                             self.sepset_beliefs[frozenset([parent_node, child_node])])\n                parent_nodes.update([child_node])\n            nodes_traversed.update([parent_node])\n\n        # Add factors to the corresponding junction tree\n        subtree.add_factors(*clique_potential_list)\n\n        # Sum product variable elimination on the subtree\n        variable_elimination = VariableElimination(subtree)\n        if operation == 'marginalize':\n            return variable_elimination.query(variables=variables, evidence=evidence, joint=joint)\n        elif operation == 'maximize':\n            return variable_elimination.map_query(variables=variables, evidence=evidence)", "response": "This method is used to compute the probability of a given set of variables for a given set of variables."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef query(self, variables, evidence=None, joint=True):\n        return self._query(variables=variables, operation='marginalize', evidence=evidence, joint=joint)", "response": "This method returns a dict of distributions over the given set of variables."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef map_query(self, variables=None, evidence=None):\n        # TODO:Check the note in docstring. Change that behavior to return the joint MAP\n        if not variables:\n            variables = set(self.variables)\n\n        final_distribution = self._query(variables=variables, operation='marginalize', evidence=evidence)\n\n        # To handle the case when no argument is passed then\n        # _variable_elimination returns a dict.\n        argmax = np.argmax(final_distribution.values)\n        assignment = final_distribution.assignment([argmax])[0]\n\n        map_query_results = {}\n        for var_assignment in assignment:\n            var, value = var_assignment\n            map_query_results[var] = value\n\n        if not variables:\n            return map_query_results\n        else:\n            return_dict = {}\n            for var in variables:\n                return_dict[var] = map_query_results[var]\n            return return_dict", "response": "This method returns the map_query method for the given set of variables and evidence."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef maximum_likelihood_estimator(self, data, states):\n        x_df = pd.DataFrame(data, columns=states)\n        x_len = len(self.evidence)\n\n        sym_coefs = []\n        for i in range(0, x_len):\n            sym_coefs.append('b' + str(i + 1) + '_coef')\n\n        sum_x = x_df.sum()\n        x = [sum_x['(Y|X)']]\n        coef_matrix = pd.DataFrame(columns=sym_coefs)\n\n        # First we compute just the coefficients of beta_1 to beta_N.\n        # Later we compute beta_0 and append it.\n        for i in range(0, x_len):\n            x.append(self.sum_of_product(x_df['(Y|X)'], x_df[self.evidence[i]]))\n            for j in range(0, x_len):\n                coef_matrix.loc[i, sym_coefs[j]] = self.sum_of_product(\n                    x_df[self.evidence[i]], x_df[self.evidence[j]])\n\n        coef_matrix.insert(0, 'b0_coef', sum_x[self.evidence].values)\n        row_1 = np.append([len(x_df)], sum_x[self.evidence].values)\n        coef_matrix.loc[-1] = row_1\n        coef_matrix.index = coef_matrix.index + 1  # shifting index\n        coef_matrix.sort_index(inplace=True)\n\n        beta_coef_matrix = np.matrix(coef_matrix.values, dtype='float')\n        coef_inv = np.linalg.inv(beta_coef_matrix)\n        beta_est = np.array(np.matmul(coef_inv, np.transpose(x)))\n        self.beta = beta_est[0]\n\n        sigma_est = 0\n        x_len_df = len(x_df)\n        for i in range(0, x_len):\n            for j in range(0, x_len):\n                sigma_est += self.beta[i + 1] * self.beta[j + 1] * (self.sum_of_product(\n                    x_df[self.evidence[i]], x_df[self.evidence[j]]) / x_len_df - np.mean(x_df[self.evidence[i]]) * np.mean(x_df[self.evidence[j]]))\n\n        sigma_est = np.sqrt(\n            self.sum_of_product(\n                x_df['(Y|X)'],\n                x_df['(Y|X)']) /\n            x_len_df -\n            np.mean(\n                x_df['(Y|X)']) *\n            np.mean(\n                x_df['(Y|X)']) -\n            sigma_est)\n        self.sigma_yx = sigma_est\n        return self.beta, self.sigma_yx", "response": "Fit using MLE method."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef fit(\n            self,\n            data,\n            states,\n            estimator=None,\n            complete_samples_only=True,\n            **kwargs):\n        \"\"\"\n        Determine \u03b2s from data\n\n        Parameters\n        ----------\n        data: pandas.DataFrame\n            Dataframe containing samples from the conditional distribution, p(Y|X)\n            estimator: 'MLE' or 'MAP'\n\n        completely_samples_only: boolean (True or False)\n            Are they downsampled or complete? Defaults to True\n\n        \"\"\"\n        if estimator == 'MLE':\n            mean, variance = self.maximum_likelihood_estimator(data, states)\n        elif estimator == 'MAP':\n            raise NotImplementedError(\n                \"fit method has not been implemented using Maximum A-Priori (MAP)\")\n\n        return mean, variance", "response": "Fits the likelihood estimator to the data and returns the mean and variance of the current state."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef copy(self):\n        copy_cpd = LinearGaussianCPD(self.variable, self.beta, self.variance,\n                                     list(self.evidence))\n\n        return copy_cpd", "response": "Returns a copy of the distribution."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _pipe_segment_with_colons(align, colwidth):\n    w = colwidth\n    if align in [\"right\", \"decimal\"]:\n        return ('-' * (w - 1)) + \":\"\n    elif align == \"center\":\n        return \":\" + ('-' * (w - 2)) + \":\"\n    elif align == \"left\":\n        return \":\" + ('-' * (w - 1))\n    else:\n        return '-' * w", "response": "Return a segment of a horizontal line with optional colons which\n    indicate column s alignment."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a horizontal line with optional colons to indicate column s alignment.", "response": "def _pipe_line_with_colons(colwidths, colaligns):\n    \"\"\"Return a horizontal line with optional colons to indicate column's\n    alignment (as in `pipe` output format).\"\"\"\n    segments = [_pipe_segment_with_colons(a, w) for a, w in zip(colaligns, colwidths)]\n    return \"|\" + \"|\".join(segments) + \"|\""}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef simple_separated_format(separator):\n    return TableFormat(None, None, None, None,\n                       headerrow=DataRow('', separator, ''),\n                       datarow=DataRow('', separator, ''),\n                       padding=0, with_header_hide=None)", "response": "Construct a simple TableFormat with columns separated by a separator."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _isint(string):\n    return type(string) is int or \\\n           (isinstance(string, _binary_type) or isinstance(string, _text_type)) and \\\n           _isconvertible(int, string)", "response": "Check if a string is an integer."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the number of symbols after a decimal point.", "response": "def _afterpoint(string):\n    \"\"\"Symbols after a decimal point, -1 if the string lacks the decimal point.\n\n    >>> _afterpoint(\"123.45\")\n    2\n    >>> _afterpoint(\"1001\")\n    -1\n    >>> _afterpoint(\"eggs\")\n    -1\n    >>> _afterpoint(\"123e45\")\n    2\n\n    \"\"\"\n    if _isnumber(string):\n        if _isint(string):\n            return -1\n        else:\n            pos = string.rfind(\".\")\n            pos = string.lower().rfind(\"e\") if pos < 0 else pos\n            if pos >= 0:\n                return len(string) - pos - 1\n            else:\n                return -1  # no point\n    else:\n        return -1"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\npad a string to the left with the given width.", "response": "def _padleft(width, s, has_invisible=True):\n    \"\"\"Flush right.\n\n    >>> _padleft(6, '\\u044f\\u0439\\u0446\\u0430') == '  \\u044f\\u0439\\u0446\\u0430'\n    True\n\n    \"\"\"\n    iwidth = width + len(s) - len(_strip_invisible(s)) if has_invisible else width\n    fmt = \"{0:>%ds}\" % iwidth\n    return fmt.format(s)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _strip_invisible(s):\n    \"Remove invisible ANSI color codes.\"\n    if isinstance(s, _text_type):\n        return re.sub(_invisible_codes, \"\", s)\n    else:  # a bytestring\n        return re.sub(_invisible_codes_bytes, \"\", s)", "response": "Remove invisible ANSI color codes."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nformats row according to DataRow format without padding.", "response": "def _build_simple_row(padded_cells, rowfmt):\n    \"Format row according to DataRow format without padding.\"\n    begin, sep, end = rowfmt\n    return (begin + sep.join(padded_cells) + end).rstrip()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a string which represents a row of data cells.", "response": "def _build_row(padded_cells, colwidths, colaligns, rowfmt):\n    \"Return a string which represents a row of data cells.\"\n    if not rowfmt:\n        return None\n    if hasattr(rowfmt, \"__call__\"):\n        return rowfmt(padded_cells, colwidths, colaligns)\n    else:\n        return _build_simple_row(padded_cells, rowfmt)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a string which represents a horizontal line.", "response": "def _build_line(colwidths, colaligns, linefmt):\n    \"Return a string which represents a horizontal line.\"\n    if not linefmt:\n        return None\n    if hasattr(linefmt, \"__call__\"):\n        return linefmt(colwidths, colaligns)\n    else:\n        begin, fill, sep,  end = linefmt\n        cells = [fill*w for w in colwidths]\n        return _build_simple_row(cells, (begin, sep, end))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _format_table(fmt, headers, rows, colwidths, colaligns):\n    lines = []\n    hidden = fmt.with_header_hide if (headers and fmt.with_header_hide) else []\n    pad = fmt.padding\n    headerrow = fmt.headerrow\n\n    padded_widths = [(w + 2*pad) for w in colwidths]\n    padded_headers = _pad_row(headers, pad)\n    padded_rows = [_pad_row(row, pad) for row in rows]\n\n    if fmt.lineabove and \"lineabove\" not in hidden:\n        lines.append(_build_line(padded_widths, colaligns, fmt.lineabove))\n\n    if padded_headers:\n        lines.append(_build_row(padded_headers, padded_widths, colaligns, headerrow))\n        if fmt.linebelowheader and \"linebelowheader\" not in hidden:\n            lines.append(_build_line(padded_widths, colaligns, fmt.linebelowheader))\n\n    if padded_rows and fmt.linebetweenrows and \"linebetweenrows\" not in hidden:\n        # initial rows with a line below\n        for row in padded_rows[:-1]:\n            lines.append(_build_row(row, padded_widths, colaligns, fmt.datarow))\n            lines.append(_build_line(padded_widths, colaligns, fmt.linebetweenrows))\n        # the last row without a line below\n        lines.append(_build_row(padded_rows[-1], padded_widths, colaligns, fmt.datarow))\n    else:\n        for row in padded_rows:\n            lines.append(_build_row(row, padded_widths, colaligns, fmt.datarow))\n\n    if fmt.linebelow and \"linebelow\" not in hidden:\n        lines.append(_build_line(padded_widths, colaligns, fmt.linebelow))\n\n    return \"\\n\".join(lines)", "response": "Produce a plain - text representation of the table."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_labels(self):\n        step = (self.high - self.low) / self.cardinality\n        labels = ['x={i}'.format(i=str(i)) for i in np.round(\n            np.arange(self.low, self.high, step), 3)]\n        return labels", "response": "Returns a list of strings representing the values about the current set of masses."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _lim_moment(self, u, order=1):\n        def fun(x):\n            return np.power(x, order) * self.factor.pdf(x)\n        return (integrate.quad(fun, -np.inf, u)[0] +\n                np.power(u, order)*(1 - self.factor.cdf(u)))", "response": "This method calculates the kth order limiting moment of a specific distribution."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef estimate_cpd(self, node):\n\n        state_counts = self.state_counts(node)\n\n        # if a column contains only `0`s (no states observed for some configuration\n        # of parents' states) fill that column uniformly instead\n        state_counts.ix[:, (state_counts == 0).all()] = 1\n\n        parents = sorted(self.model.get_parents(node))\n        parents_cardinalities = [len(self.state_names[parent]) for parent in parents]\n        node_cardinality = len(self.state_names[node])\n\n        cpd = TabularCPD(node, node_cardinality, np.array(state_counts),\n                         evidence=parents,\n                         evidence_card=parents_cardinalities,\n                         state_names=self.state_names)\n        cpd.normalize()\n        return cpd", "response": "Method to estimate the CPD for a given variable."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nestimate a DAG for the data set, using the PC constraint-based structure learning algorithm. Independencies are identified from the data set using a chi-squared statistic with the acceptance threshold of `significance_level`. PC identifies a partially directed acyclic graph (PDAG), given that the tested independencies admit a faithful Bayesian network representation. This method returns a DAG that is a completion of this PDAG. Parameters ---------- significance_level: float, default: 0.01 The significance level to use for conditional independence tests in the data set. `significance_level` is the desired Type 1 error probability of falsely rejecting the null hypothesis that variables are independent, given that they are. The lower `significance_level`, the less likely we are to accept dependencies, resulting in a sparser graph. Returns ------- model: DAG()-instance An estimate for the DAG for the data set (not yet parametrized). Reference --------- Neapolitan, Learning Bayesian Networks, Section 10.1.2, Algorithm 10.2 (page 550) http://www.cs.technion.ac.il/~dang/books/Learning%20Bayesian%20Networks(Neapolitan,%20Richard).pdf Examples -------- >>> import pandas as pd >>> import numpy as np >>> from pgmpy.estimators import ConstraintBasedEstimator >>> data = pd.DataFrame(np.random.randint(0, 5, size=(2500, 3)), columns=list('XYZ')) >>> data['sum'] = data.sum(axis=1) >>> print(data) X Y Z sum 0 3 0 1 4 1 1 4 3 8 2 0 0 3 3 3 0 2 3 5 4 2 1 1 4 ... .. .. .. ... 2495 2 3 0 5 2496 1 1 2 4 2497 0 4 2 6 2498 0 0 0 0 2499 2 4 0 6 [2500 rows x 4 columns] >>> c = ConstraintBasedEstimator(data) >>> model = c.estimate() >>> print(model.edges()) [('Z', 'sum'), ('X', 'sum'), ('Y', 'sum')]", "response": "def estimate(self, significance_level=0.01):\n        \"\"\"\n        Estimates a DAG for the data set, using the PC constraint-based\n        structure learning algorithm. Independencies are identified from the\n        data set using a chi-squared statistic with the acceptance threshold of\n        `significance_level`. PC identifies a partially directed acyclic graph (PDAG), given\n        that the tested independencies admit a faithful Bayesian network representation.\n        This method returns a DAG that is a completion of this PDAG.\n\n        Parameters\n        ----------\n        significance_level: float, default: 0.01\n            The significance level to use for conditional independence tests in the data set.\n\n            `significance_level` is the desired Type 1 error probability of\n            falsely rejecting the null hypothesis that variables are independent,\n            given that they are. The lower `significance_level`, the less likely\n            we are to accept dependencies, resulting in a sparser graph.\n\n        Returns\n        -------\n        model: DAG()-instance\n            An estimate for the DAG for the data set (not yet parametrized).\n\n        Reference\n        ---------\n        Neapolitan, Learning Bayesian Networks, Section 10.1.2, Algorithm 10.2 (page 550)\n        http://www.cs.technion.ac.il/~dang/books/Learning%20Bayesian%20Networks(Neapolitan,%20Richard).pdf\n\n        Examples\n        --------\n        >>> import pandas as pd\n        >>> import numpy as np\n        >>> from pgmpy.estimators import ConstraintBasedEstimator\n        >>> data = pd.DataFrame(np.random.randint(0, 5, size=(2500, 3)), columns=list('XYZ'))\n        >>> data['sum'] = data.sum(axis=1)\n        >>> print(data)\n              X  Y  Z  sum\n        0     3  0  1    4\n        1     1  4  3    8\n        2     0  0  3    3\n        3     0  2  3    5\n        4     2  1  1    4\n        ...  .. .. ..  ...\n        2495  2  3  0    5\n        2496  1  1  2    4\n        2497  0  4  2    6\n        2498  0  0  0    0\n        2499  2  4  0    6\n\n        [2500 rows x 4 columns]\n        >>> c = ConstraintBasedEstimator(data)\n        >>> model = c.estimate()\n        >>> print(model.edges())\n        [('Z', 'sum'), ('X', 'sum'), ('Y', 'sum')]\n        \"\"\"\n\n        skel, separating_sets = self.estimate_skeleton(significance_level)\n        pdag = self.skeleton_to_pdag(skel, separating_sets)\n        model = self.pdag_to_dag(pdag)\n        return model"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef estimate_skeleton(self, significance_level=0.01):\n\n        nodes = self.state_names.keys()\n\n        def is_independent(X, Y, Zs):\n            \"\"\"Returns result of hypothesis test for the null hypothesis that\n            X _|_ Y | Zs, using a chi2 statistic and threshold `significance_level`.\n            \"\"\"\n            chi2, p_value, sufficient_data = self.test_conditional_independence(X, Y, Zs)\n            return p_value >= significance_level\n\n        return self.build_skeleton(nodes, is_independent)", "response": "Estimates a undirected graph skeleton for the given data set."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef estimate_from_independencies(nodes, independencies):\n\n        skel, separating_sets = ConstraintBasedEstimator.build_skeleton(nodes, independencies)\n        pdag = ConstraintBasedEstimator.skeleton_to_pdag(skel, separating_sets)\n        dag = ConstraintBasedEstimator.pdag_to_dag(pdag)\n\n        return dag", "response": "Estimates a DAG from an Independencies - object or a decision function for conditional independencies."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef pdag_to_dag(pdag):\n\n        pdag = pdag.copy()\n        dag = DAG()\n        dag.add_nodes_from(pdag.nodes())\n\n        # add already directed edges of pdag to dag\n        for X, Y in pdag.edges():\n            if not pdag.has_edge(Y, X):\n                dag.add_edge(X, Y)\n\n        while pdag.number_of_nodes() > 0:\n            # find node with (1) no directed outgoing edges and\n            #                (2) the set of undirected neighbors is either empty or\n            #                    undirected neighbors + parents of X are a clique\n            found = False\n            for X in pdag.nodes():\n                directed_outgoing_edges = set(pdag.successors(X)) - set(pdag.predecessors(X))\n                undirected_neighbors = set(pdag.successors(X)) & set(pdag.predecessors(X))\n                neighbors_are_clique = all((pdag.has_edge(Y, Z)\n                                            for Z in pdag.predecessors(X)\n                                            for Y in undirected_neighbors if not Y == Z))\n\n                if not directed_outgoing_edges and \\\n                        (not undirected_neighbors or neighbors_are_clique):\n                    found = True\n                    # add all edges of X as outgoing edges to dag\n                    for Y in pdag.predecessors(X):\n                        dag.add_edge(Y, X)\n\n                    pdag.remove_node(X)\n                    break\n\n            if not found:\n                warn(\"PDAG has no faithful extension (= no oriented DAG with the \" +\n                     \"same v-structures as PDAG). Remaining undirected PDAG edges \" +\n                     \"oriented arbitrarily.\")\n                for X, Y in pdag.edges():\n                    if not dag.has_edge(Y, X):\n                        try:\n                            dag.add_edge(X, Y)\n                        except ValueError:\n                            pass\n                break\n\n        return dag", "response": "Completes a PDAG to a DAG."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef model_to_pdag(model):\n\n        if not isinstance(model, DAG):\n            raise TypeError(\"model: Expected DAG instance, \" +\n                            \"got type {model_type}\".format(model_type=type(model)))\n\n        skel, separating_sets = ConstraintBasedEstimator.build_skeleton(\n                                    model.nodes(),\n                                    model.get_independencies())\n        pdag = ConstraintBasedEstimator.skeleton_to_pdag(skel, separating_sets)\n\n        return pdag", "response": "Construct the DAG pattern for a given model."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\norient the edges of a graph skeleton based on information from `separating_sets` to form a DAG pattern (DAG). Parameters ---------- skel: UndirectedGraph An undirected graph skeleton as e.g. produced by the estimate_skeleton method. separating_sets: dict A dict containing for each pair of not directly connected nodes a separating set (\"witnessing set\") of variables that makes then conditionally independent. (needed for edge orientation) Returns ------- pdag: DAG An estimate for the DAG pattern of the BN underlying the data. The graph might contain some nodes with both-way edges (X->Y and Y->X). Any completion by (removing one of the both-way edges for each such pair) results in a I-equivalent Bayesian network DAG. Reference --------- Neapolitan, Learning Bayesian Networks, Section 10.1.2, Algorithm 10.2 (page 550) http://www.cs.technion.ac.il/~dang/books/Learning%20Bayesian%20Networks(Neapolitan,%20Richard).pdf Examples -------- >>> import pandas as pd >>> import numpy as np >>> from pgmpy.estimators import ConstraintBasedEstimator >>> data = pd.DataFrame(np.random.randint(0, 4, size=(5000, 3)), columns=list('ABD')) >>> data['C'] = data['A'] - data['B'] >>> data['D'] += data['A'] >>> c = ConstraintBasedEstimator(data) >>> pdag = c.skeleton_to_pdag(*c.estimate_skeleton()) >>> pdag.edges() # edges: A->C, B->C, A--D (not directed) [('B', 'C'), ('A', 'C'), ('A', 'D'), ('D', 'A')]", "response": "def skeleton_to_pdag(skel, separating_sets):\n        \"\"\"Orients the edges of a graph skeleton based on information from\n        `separating_sets` to form a DAG pattern (DAG).\n\n        Parameters\n        ----------\n        skel: UndirectedGraph\n            An undirected graph skeleton as e.g. produced by the\n            estimate_skeleton method.\n\n        separating_sets: dict\n            A dict containing for each pair of not directly connected nodes a\n            separating set (\"witnessing set\") of variables that makes then\n            conditionally independent. (needed for edge orientation)\n\n        Returns\n        -------\n        pdag: DAG\n            An estimate for the DAG pattern of the BN underlying the data. The\n            graph might contain some nodes with both-way edges (X->Y and Y->X).\n            Any completion by (removing one of the both-way edges for each such\n            pair) results in a I-equivalent Bayesian network DAG.\n\n        Reference\n        ---------\n        Neapolitan, Learning Bayesian Networks, Section 10.1.2, Algorithm 10.2 (page 550)\n        http://www.cs.technion.ac.il/~dang/books/Learning%20Bayesian%20Networks(Neapolitan,%20Richard).pdf\n\n\n        Examples\n        --------\n        >>> import pandas as pd\n        >>> import numpy as np\n        >>> from pgmpy.estimators import ConstraintBasedEstimator\n        >>> data = pd.DataFrame(np.random.randint(0, 4, size=(5000, 3)), columns=list('ABD'))\n        >>> data['C'] = data['A'] - data['B']\n        >>> data['D'] += data['A']\n        >>> c = ConstraintBasedEstimator(data)\n        >>> pdag = c.skeleton_to_pdag(*c.estimate_skeleton())\n        >>> pdag.edges() # edges: A->C, B->C, A--D (not directed)\n        [('B', 'C'), ('A', 'C'), ('A', 'D'), ('D', 'A')]\n        \"\"\"\n\n        pdag = skel.to_directed()\n        node_pairs = combinations(pdag.nodes(), 2)\n\n        # 1) for each X-Z-Y, if Z not in the separating set of X,Y, then orient edges as X->Z<-Y\n        # (Algorithm 3.4 in Koller & Friedman PGM, page 86)\n        for X, Y in node_pairs:\n            if not skel.has_edge(X, Y):\n                for Z in set(skel.neighbors(X)) & set(skel.neighbors(Y)):\n                    if Z not in separating_sets[frozenset((X, Y))]:\n                        pdag.remove_edges_from([(Z, X), (Z, Y)])\n\n        progress = True\n        while progress:  # as long as edges can be oriented (removed)\n            num_edges = pdag.number_of_edges()\n\n            # 2) for each X->Z-Y, orient edges to Z->Y\n            for X, Y in node_pairs:\n                for Z in ((set(pdag.successors(X)) - set(pdag.predecessors(X))) &\n                          (set(pdag.successors(Y)) & set(pdag.predecessors(Y)))):\n                    pdag.remove(Y, Z)\n\n            # 3) for each X-Y with a directed path from X to Y, orient edges to X->Y\n            for X, Y in node_pairs:\n                for path in nx.all_simple_paths(pdag, X, Y):\n                    is_directed = True\n                    for src, dst in path:\n                        if pdag.has_edge(dst, src):\n                            is_directed = False\n                    if is_directed:\n                        pdag.remove(Y, X)\n                        break\n\n            # 4) for each X-Z-Y with X->W, Y->W, and Z-W, orient edges to Z->W\n            for X, Y in node_pairs:\n                for Z in (set(pdag.successors(X)) & set(pdag.predecessors(X)) &\n                          set(pdag.successors(Y)) & set(pdag.predecessors(Y))):\n                    for W in ((set(pdag.successors(X)) - set(pdag.predecessors(X))) &\n                              (set(pdag.successors(Y)) - set(pdag.predecessors(Y))) &\n                              (set(pdag.successors(Z)) & set(pdag.predecessors(Z)))):\n                        pdag.remove(W, Z)\n\n            progress = num_edges > pdag.number_of_edges()\n\n        return pdag"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef build_skeleton(nodes, independencies):\n\n        nodes = list(nodes)\n\n        if isinstance(independencies, Independencies):\n            def is_independent(X, Y, Zs):\n                return IndependenceAssertion(X, Y, Zs) in independencies\n        elif callable(independencies):\n            is_independent = independencies\n        else:\n            raise ValueError(\"'independencies' must be either Independencies-instance \" +\n                             \"or a ternary function that decides independencies.\")\n\n        graph = UndirectedGraph(combinations(nodes, 2))\n        lim_neighbors = 0\n        separating_sets = dict()\n        while not all([len(list(graph.neighbors(node))) < lim_neighbors for node in nodes]):\n            for node in nodes:\n                for neighbor in list(graph.neighbors(node)):\n                    # search if there is a set of neighbors (of size lim_neighbors)\n                    # that makes X and Y independent:\n                    for separating_set in combinations(set(graph.neighbors(node)) - set([neighbor]), lim_neighbors):\n                        if is_independent(node, neighbor, separating_set):\n                            separating_sets[frozenset((node, neighbor))] = separating_set\n                            graph.remove_edge(node, neighbor)\n                            break\n            lim_neighbors += 1\n\n        return graph, separating_sets", "response": "Estimates a graph skeleton from a set of nodes and independencies."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_probability_grammar(self):\n        # Creating valid word expression for probability, it is of the format\n        # wor1 | var2 , var3 or var1 var2 var3 or simply var\n        word_expr = Word(alphanums + '-' + '_') + Suppress(Optional(\"|\")) + Suppress(Optional(\",\"))\n        word_expr2 = Word(initChars=printables, excludeChars=[',', ')', ' ', '(']) + Suppress(Optional(\",\"))\n        # creating an expression for valid numbers, of the format\n        # 1.00 or 1 or 1.00. 0.00 or 9.8e-5 etc\n        num_expr = Word(nums + '-' + '+' + 'e' + 'E' + '.') + Suppress(Optional(\",\"))\n        probability_expr = Suppress('probability') + Suppress('(') + OneOrMore(word_expr) + Suppress(')')\n        optional_expr = Suppress('(') + OneOrMore(word_expr2) + Suppress(')')\n        probab_attributes = optional_expr | Suppress('table')\n        cpd_expr = probab_attributes + OneOrMore(num_expr)\n\n        return probability_expr, cpd_expr", "response": "A method that returns probability grammar for the current log entry."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_network_name(self):\n        start = self.network.find('network')\n        end = self.network.find('}\\n', start)\n        # Creating a network attribute\n        network_attribute = Suppress('network') + Word(alphanums + '_' + '-') + '{'\n        network_name = network_attribute.searchString(self.network[start:end])[0][0]\n\n        return network_name", "response": "Retruns the name of the network"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_variables(self):\n        variable_names = []\n        for block in self.variable_block():\n            name = self.name_expr.searchString(block)[0][0]\n            variable_names.append(name)\n\n        return variable_names", "response": "Returns list of variables of the network"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_states(self):\n        variable_states = {}\n        for block in self.variable_block():\n            name = self.name_expr.searchString(block)[0][0]\n            variable_states[name] = list(self.state_expr.searchString(block)[0][0])\n\n        return variable_states", "response": "Returns the states of variables present in the network"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_property(self):\n        variable_properties = {}\n        for block in self.variable_block():\n            name = self.name_expr.searchString(block)[0][0]\n            properties = self.property_expr.searchString(block)\n            variable_properties[name] = [y.strip() for x in properties for y in x]\n        return variable_properties", "response": "Returns the property of the variable with the keys name and properties."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_parents(self):\n        variable_parents = {}\n        for block in self.probability_block():\n            names = self.probability_expr.searchString(block.split('\\n')[0])[0]\n            variable_parents[names[0]] = names[1:]\n        return variable_parents", "response": "Returns the parents of the variables present in the network"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_values(self):\n        variable_cpds = {}\n        for block in self.probability_block():\n            names = self.probability_expr.searchString(block)\n            var_name, parents = names[0][0], names[0][1:]\n            cpds = self.cpd_expr.searchString(block)\n            if 'table' in block:\n                arr = np.array([float(j) for i in cpds for j in i])\n                arr = arr.reshape((len(self.variable_states[var_name]),\n                                   arr.size // len(self.variable_states[var_name])))\n            else:\n                arr_length = np.prod([len(self.variable_states[var]) for var in parents])\n                arr = np.zeros((len(self.variable_states[var_name]), arr_length))\n                values_dict = {}\n                for prob_line in cpds:\n                    states = prob_line[:len(parents)]\n                    vals = [float(i) for i in prob_line[len(parents):]]\n                    values_dict[tuple(states)] = vals\n                for index, combination in enumerate(product(*[self.variable_states[var] for var in parents])):\n                    arr[:, index] = values_dict[combination]\n            variable_cpds[var_name] = arr\n\n        return variable_cpds", "response": "Returns the values of the variables present in the network"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_edges(self):\n        edges = [[value, key] for key in self.variable_parents.keys()\n                 for value in self.variable_parents[key]]\n        return edges", "response": "Returns the edges of the network"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the fitted bayesian model object at 0x7f20af154320", "response": "def get_model(self):\n        \"\"\"\n        Returns the fitted bayesian model\n\n        Example\n        ----------\n        >>> from pgmpy.readwrite import BIFReader\n        >>> reader = BIFReader(\"bif_test.bif\")\n        >>> reader.get_model()\n        <pgmpy.models.BayesianModel.BayesianModel object at 0x7f20af154320>\n        \"\"\"\n        try:\n            model = BayesianModel()\n            model.add_nodes_from(self.variable_names)\n            model.add_edges_from(self.variable_edges)\n            model.name = self.network_name\n\n            tabular_cpds = []\n            for var in sorted(self.variable_cpds.keys()):\n                values = self.variable_cpds[var]\n                cpd = TabularCPD(var, len(self.variable_states[var]), values,\n                                 evidence=self.variable_parents[var],\n                                 evidence_card=[len(self.variable_states[evidence_var])\n                                                for evidence_var in self.variable_parents[var]])\n                tabular_cpds.append(cpd)\n\n            model.add_cpds(*tabular_cpds)\n            for node, properties in self.variable_properties.items():\n                for prop in properties:\n                    prop_name, prop_value = map(lambda t: t.strip(), prop.split('='))\n                    model.node[node][prop_name] = prop_value\n\n            return model\n\n        except AttributeError:\n            raise AttributeError('First get states of variables, edges, parents and network name')"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating template for writing in BIF format", "response": "def BIF_templates(self):\n        \"\"\"\n        Create template for writing in BIF format\n        \"\"\"\n        network_template = Template('network $name {\\n}\\n')\n        # property tag may or may not be present in model,and since no of properties\n        # can be more than one , will replace them accoriding to format otherwise null\n        variable_template = Template(\"\"\"variable $name {\n    type discrete [ $no_of_states ] { $states };\n$properties}\\n\"\"\")\n        property_template = Template('    property $prop ;\\n')\n        # $variable_ here is name of variable, used underscore for clarity\n        probability_template = Template(\"\"\"probability ( $variable_$seprator_$parents ) {\n    table $values ;\n}\\n\"\"\")\n        return network_template, variable_template, property_template, probability_template"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_states(self):\n        variable_states = {}\n        cpds = self.model.get_cpds()\n        for cpd in cpds:\n            variable = cpd.variable\n            variable_states[variable] = []\n            for state in range(cpd.get_cardinality([variable])[variable]):\n                variable_states[variable].append(str(variable) + '_' + str(state))\n        return variable_states", "response": "Get the states of the variable of BIF\n       "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting properties of the current node in the BIF file", "response": "def get_properties(self):\n        \"\"\"\n        Add property to variables in BIF\n\n        Returns\n        -------\n        dict: dict of type {variable: list of properties }\n\n        Example\n        -------\n        >>> from pgmpy.readwrite import BIFReader, BIFWriter\n        >>> model = BIFReader('dog-problem.bif').get_model()\n        >>> writer = BIFWriter(model)\n        >>> writer.get_properties()\n        {'bowel-problem': ['position = (335, 99)'],\n         'dog-out': ['position = (300, 195)'],\n         'family-out': ['position = (257, 99)'],\n         'hear-bark': ['position = (296, 268)'],\n         'light-on': ['position = (218, 195)']}\n        \"\"\"\n        variables = self.model.nodes()\n        property_tag = {}\n        for variable in sorted(variables):\n            properties = self.model.node[variable]\n            properties = collections.OrderedDict(sorted(properties.items()))\n            property_tag[variable] = []\n            for prop, val in properties.items():\n                property_tag[variable].append(str(prop) + \" = \" + str(val))\n        return property_tag"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the parents of the current BIF", "response": "def get_parents(self):\n        \"\"\"\n        Add the parents to BIF\n\n        Returns\n        -------\n        dict: dict of type {variable: a list of parents}\n\n        Example\n        -------\n        >>> from pgmpy.readwrite import BIFReader, BIFWriter\n        >>> model = BIFReader('dog-problem.bif').get_model()\n        >>> writer = BIFWriter(model)\n        >>> writer.get_parents()\n        {'bowel-problem': [],\n         'dog-out': ['bowel-problem', 'family-out'],\n         'family-out': [],\n         'hear-bark': ['dog-out'],\n         'light-on': ['family-out']}\n        \"\"\"\n        cpds = self.model.get_cpds()\n        cpds.sort(key=lambda x: x.variable)\n        variable_parents = {}\n        for cpd in cpds:\n            variable_parents[cpd.variable] = []\n            for parent in sorted(cpd.variables[:0:-1]):\n                variable_parents[cpd.variable].append(parent)\n        return variable_parents"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a dict of all the CPDs in the current model.", "response": "def get_cpds(self):\n        \"\"\"\n        Adds tables to BIF\n\n        Returns\n        -------\n        dict: dict of type {variable: array}\n\n        Example\n        -------\n        >>> from pgmpy.readwrite import BIFReader, BIFWriter\n        >>> model = BIFReader('dog-problem.bif').get_model()\n        >>> writer = BIFWriter(model)\n        >>> writer.get_cpds()\n        {'bowel-problem': array([ 0.01,  0.99]),\n         'dog-out': array([ 0.99,  0.97,  0.9 ,  0.3 ,  0.01,  0.03,  0.1 ,  0.7 ]),\n         'family-out': array([ 0.15,  0.85]),\n         'hear-bark': array([ 0.7 ,  0.01,  0.3 ,  0.99]),\n         'light-on': array([ 0.6 ,  0.05,  0.4 ,  0.95])}\n        \"\"\"\n        cpds = self.model.get_cpds()\n        tables = {}\n        for cpd in cpds:\n            tables[cpd.variable] = cpd.values.ravel()\n        return tables"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nwrite the BIF data into a file.", "response": "def write_bif(self, filename):\n        \"\"\"\n        Writes the BIF data into a file\n\n        Parameters\n        ----------\n        filename : Name of the file\n\n        Example\n        -------\n        >>> from pgmpy.readwrite import BIFReader, BIFWriter\n        >>> model = BIFReader('dog-problem.bif').get_model()\n        >>> writer = BIFWriter(model)\n        >>> writer.write_bif(filname='test_file.bif')\n        \"\"\"\n        writer = self.__str__()\n        with open(filename, 'w') as fout:\n            fout.write(writer)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nmake a copy of the factor.", "response": "def copy(self):\n        \"\"\"\n        Makes a copy of the factor.\n\n        Returns\n        -------\n        CanonicalDistribution object: Copy of the factor\n\n        Examples\n        --------\n        >>> from pgmpy.factors.continuous import CanonicalDistribution\n        >>> phi = CanonicalDistribution(['X', 'Y'], np.array([[1, -1], [-1, 1]]),\n                                  np.array([[1], [-1]]), -3)\n        >>> phi.variables\n        ['X', 'Y']\n\n        >>> phi.K\n        array([[1, -1],\n               [-1, 1]])\n\n        >>> phi.h\n        array([[1],\n               [-1]])\n\n        >>> phi.g\n        -3\n\n        >>> phi2 = phi.copy()\n\n        >>> phi2.variables\n        ['X', 'Y']\n\n        >>> phi2.K\n        array([[1, -1],\n               [-1, 1]])\n\n        >>> phi2.h\n        array([[1],\n               [-1]])\n\n        >>> phi2.g\n        -3\n\n        \"\"\"\n        copy_factor = CanonicalDistribution(self.variables, self.K.copy(),\n                                            self.h.copy(), self.g)\n\n        return copy_factor"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns an equivalent Joint Gaussian Distribution.", "response": "def to_joint_gaussian(self):\n        \"\"\"\n        Return an equivalent Joint Gaussian Distribution.\n\n        Examples\n        --------\n\n        >>> import numpy as np\n        >>> from pgmpy.factors.continuous import CanonicalDistribution\n        >>> phi = CanonicalDistribution(['x1', 'x2'], np.array([[3, -2], [-2, 4]]),\n                                  np.array([[5], [-1]]), 1)\n        >>> jgd = phi.to_joint_gaussian()\n        >>> jgd.variables\n        ['x1', 'x2']\n        >>> jgd.covariance\n        array([[ 0.5  ,  0.25 ],\n               [ 0.25 ,  0.375]])\n        >>> jgd.mean\n        array([[ 2.25 ],\n               [ 0.875]])\n\n        \"\"\"\n        covariance = np.linalg.inv(self.K)\n        mean = np.dot(covariance, self.h)\n\n        return GaussianDistribution(self.variables, mean, covariance)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreduces the distribution to the context of the given variable values.", "response": "def reduce(self, values, inplace=True):\n        \"\"\"\n        Reduces the distribution to the context of the given variable values.\n\n        Let C(X,Y \u037e K, h, g) be some canonical form over X,Y where,\n\n        k = [[K_XX, K_XY],        ;       h = [[h_X],\n             [K_YX, K_YY]]                     [h_Y]]\n\n        The formula for the obtained conditional distribution for setting\n        Y = y is given by,\n\n        .. math:: K' = K_{XX}\n        .. math:: h' = h_X - K_{XY} * y\n        .. math:: g' = g + {h^T}_Y * y - 0.5 * y^T * K_{YY} * y\n\n\n        Parameters\n        ----------\n        values: list, array-like\n            A list of tuples of the form (variable name, variable value).\n\n        inplace: boolean\n            If inplace=True it will modify the factor itself, else would return\n            a new CaninicalFactor object.\n\n        Returns\n        -------\n        CanonicalDistribution or None:\n                if inplace=True (default) returns None\n                if inplace=False returns a new CanonicalDistribution instance.\n\n        Examples\n        --------\n        >>> import numpy as np\n        >>> from pgmpy.factors.continuous import CanonicalDistribution\n        >>> phi = CanonicalDistribution(['X1', 'X2', 'X3'],\n        ...                       np.array([[1, -1, 0], [-1, 4, -2], [0, -2, 4]]),\n        ...                       np.array([[1], [4], [-1]]), -2)\n        >>> phi.variables\n        ['X1', 'X2', 'X3']\n\n        >>> phi.K\n        array([[ 1., -1.],\n               [-1.,  3.]])\n\n        >>> phi.h\n        array([[ 1. ],\n               [ 3.5]])\n\n        >>> phi.g\n        -2\n\n        >>> phi.reduce([('X3', 0.25)])\n\n        >>> phi.variables\n        ['X1', 'X2']\n\n        >>> phi.K\n        array([[ 1, -1],\n               [-1,  4]])\n\n        >>> phi.h\n        array([[ 1. ],\n               [ 4.5]])\n\n        >>> phi.g\n        -2.375\n        \"\"\"\n        if not isinstance(values, (list, tuple, np.ndarray)):\n            raise TypeError(\"variables: Expected type list or array-like, \"\n                            \"got type {var_type}\".format(var_type=type(values)))\n\n        if not all([var in self.variables for var, value in values]):\n            raise ValueError(\"Variable not in scope.\")\n\n        phi = self if inplace else self.copy()\n\n        var_to_reduce = [var for var, value in values]\n\n        # index_to_keep -> j vector\n        index_to_keep = [self.variables.index(var) for var in self.variables\n                         if var not in var_to_reduce]\n        # index_to_reduce -> i vector\n        index_to_reduce = [self.variables.index(var) for var in var_to_reduce]\n\n        K_i_i = self.K[np.ix_(index_to_keep, index_to_keep)]\n        K_i_j = self.K[np.ix_(index_to_keep, index_to_reduce)]\n        K_j_j = self.K[np.ix_(index_to_reduce, index_to_reduce)]\n        h_i = self.h[index_to_keep]\n        h_j = self.h[index_to_reduce]\n\n        # The values for the reduced variables.\n        y = np.array([value for var, value in values]).reshape(len(index_to_reduce), 1)\n\n        phi.variables = [self.variables[index] for index in index_to_keep]\n        phi.K = K_i_i\n        phi.h = h_i - np.dot(K_i_j, y)\n        phi.g = self.g + (np.dot(h_j.T, y) - (0.5 * np.dot(np.dot(y.T, K_j_j), y)))[0][0]\n\n        if not inplace:\n            return phi"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef marginalize(self, variables, inplace=True):\n        if not isinstance(variables, (list, tuple, np.ndarray)):\n            raise TypeError(\"variables: Expected type list or array-like, \"\n                            \"got type {var_type}\".format(var_type=type(variables)))\n\n        if not all([var in self.variables for var in variables]):\n            raise ValueError(\"Variable not in scope.\")\n\n        phi = self if inplace else self.copy()\n\n        # index_to_keep -> i vector\n        index_to_keep = [self.variables.index(var) for var in self.variables\n                         if var not in variables]\n        # index_to_marginalize -> j vector\n        index_to_marginalize = [self.variables.index(var) for var in variables]\n\n        K_i_i = self.K[np.ix_(index_to_keep, index_to_keep)]\n        K_i_j = self.K[np.ix_(index_to_keep, index_to_marginalize)]\n        K_j_i = self.K[np.ix_(index_to_marginalize, index_to_keep)]\n        K_j_j = self.K[np.ix_(index_to_marginalize, index_to_marginalize)]\n        K_j_j_inv = np.linalg.inv(K_j_j)\n        h_i = self.h[index_to_keep]\n        h_j = self.h[index_to_marginalize]\n\n        phi.variables = [self.variables[index] for index in index_to_keep]\n\n        phi.K = K_i_i - np.dot(np.dot(K_i_j, K_j_j_inv), K_j_i)\n        phi.h = h_i - np.dot(np.dot(K_i_j, K_j_j_inv), h_j)\n        phi.g = self.g + 0.5 * (len(variables) * np.log(2 * np.pi) -\n                                np.log(abs(np.linalg.det(K_j_j))) + np.dot(np.dot(h_j.T, K_j_j), h_j))[0][0]\n\n        if not inplace:\n            return phi", "response": "u Marginalizes the factor with marginalized values."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngiving the CanonicalDistribution operation (product or divide) with the other factor. The product of two canonical factors over the same scope X is simply: C(K1, h1, g1) * C(K2, h2, g2) = C(K1+K2, h1+h2, g1+g2) The division of canonical forms is defined analogously: C(K1, h1, g1) / C(K2, h2, g2) = C(K1-K2, h1-h2, g1- g2) When we have two canonical factors over different scopes X and Y, we simply extend the scope of both to make their scopes match and then perform the operation of the above equation. The extension of the scope is performed by simply adding zero entries to both the K matrices and the h vectors. Parameters ---------- other: CanonicalFactor The CanonicalDistribution to be multiplied. operation: String 'product' for multiplication operation and 'divide' for division operation. Returns ------- CanonicalDistribution or None: if inplace=True (default) returns None if inplace=False returns a new CanonicalDistribution instance. Example ------- >>> import numpy as np >>> from pgmpy.factors.continuous import CanonicalDistribution >>> phi1 = CanonicalDistribution(['x1', 'x2', 'x3'], np.array([[1, -1, 0], [-1, 4, -2], [0, -2, 4]]), np.array([[1], [4], [-1]]), -2) >>> phi2 = CanonicalDistribution(['x1', 'x2'], np.array([[3, -2], [-2, 4]]), np.array([[5], [-1]]), 1) >>> phi3 = phi1 * phi2 >>> phi3.K array([[ 4., -3., 0.], [-3., 8., -2.], [ 0., -2., 4.]]) >>> phi3.h array([ 6., 3., -1.]) >>> phi3.g -1 >>> phi4 = phi1 / phi2 >>> phi4.K array([[-2., 1., 0.], [ 1., 0., -2.], [ 0., -2., 4.]]) >>> phi4.h array([-4., 5., -1.]) >>> phi4.g -3", "response": "def _operate(self, other, operation, inplace=True):\n        \"\"\"\n        Gives the CanonicalDistribution operation (product or divide) with\n        the other factor.\n\n        The product of two canonical factors over the same scope\n        X is simply:\n\n        C(K1, h1, g1) * C(K2, h2, g2) = C(K1+K2, h1+h2, g1+g2)\n\n        The division of canonical forms is defined analogously:\n\n        C(K1, h1, g1) / C(K2, h2, g2) = C(K1-K2, h1-h2, g1- g2)\n\n        When we have two canonical factors over different scopes X and Y,\n        we simply extend the scope of both to make their scopes match and\n        then perform the operation of the above equation. The extension of\n        the scope is performed by simply adding zero entries to both the K\n        matrices and the h vectors.\n\n        Parameters\n        ----------\n        other: CanonicalFactor\n            The CanonicalDistribution to be multiplied.\n\n        operation: String\n            'product' for multiplication operation and\n            'divide' for division operation.\n\n        Returns\n        -------\n        CanonicalDistribution or None:\n                        if inplace=True (default) returns None\n                        if inplace=False returns a new CanonicalDistribution instance.\n\n        Example\n        -------\n        >>> import numpy as np\n        >>> from pgmpy.factors.continuous import CanonicalDistribution\n        >>> phi1 = CanonicalDistribution(['x1', 'x2', 'x3'],\n                                   np.array([[1, -1, 0], [-1, 4, -2], [0, -2, 4]]),\n                                   np.array([[1], [4], [-1]]), -2)\n        >>> phi2 = CanonicalDistribution(['x1', 'x2'], np.array([[3, -2], [-2, 4]]),\n                                   np.array([[5], [-1]]), 1)\n\n        >>> phi3 = phi1 * phi2\n        >>> phi3.K\n        array([[ 4., -3.,  0.],\n               [-3.,  8., -2.],\n               [ 0., -2.,  4.]])\n        >>> phi3.h\n        array([ 6.,  3., -1.])\n        >>> phi3.g\n        -1\n\n        >>> phi4 = phi1 / phi2\n        >>> phi4.K\n        array([[-2.,  1.,  0.],\n               [ 1.,  0., -2.],\n               [ 0., -2.,  4.]])\n        >>> phi4.h\n        array([-4.,  5., -1.])\n        >>> phi4.g\n        -3\n\n        \"\"\"\n        if not isinstance(other, CanonicalDistribution):\n            raise TypeError(\n                \"CanonicalDistribution object can only be multiplied or divided \"\n                \"with an another CanonicalDistribution object. Got {other_type}, \"\n                \"expected CanonicalDistribution.\".format(other_type=type(other)))\n\n        phi = self if inplace else self.copy()\n\n        all_vars = self.variables + [var for var in other.variables if var not in self.variables]\n        no_of_var = len(all_vars)\n\n        self_var_index = [all_vars.index(var) for var in self.variables]\n        other_var_index = [all_vars.index(var) for var in other.variables]\n\n        def _extend_K_scope(K, index):\n            ext_K = np.zeros([no_of_var, no_of_var])\n            ext_K[np.ix_(index, index)] = K\n            return ext_K\n\n        def _extend_h_scope(h, index):\n            ext_h = np.zeros(no_of_var).reshape(no_of_var, 1)\n            ext_h[index] = h\n            return ext_h\n\n        phi.variables = all_vars\n\n        if operation == 'product':\n            phi.K = _extend_K_scope(self.K, self_var_index) + _extend_K_scope(other.K, other_var_index)\n            phi.h = _extend_h_scope(self.h, self_var_index) + _extend_h_scope(other.h, other_var_index)\n            phi.g = self.g + other.g\n\n        else:\n            phi.K = _extend_K_scope(self.K, self_var_index) - _extend_K_scope(other.K, other_var_index)\n            phi.h = _extend_h_scope(self.h, self_var_index) - _extend_h_scope(other.h, other_var_index)\n            phi.g = self.g - other.g\n\n        if not inplace:\n            return phi"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_variables(self):\n        self.variables = defaultdict(list)\n        for variable in self.network.findall('Variable'):\n            _variables = defaultdict(list)\n            for var in variable.findall('StateVar'):\n                state_variables = defaultdict(list)\n                state_variables['vnamePrev'] = var.get('vnamePrev')\n                state_variables['vnameCurr'] = var.get('vnameCurr')\n                if var.get('fullyObs'):\n                    state_variables['fullyObs'] = True\n                else:\n                    state_variables['fullyObs'] = False\n                state_variables['ValueEnum'] = []\n                if var.find('NumValues') is not None:\n                    for i in range(0, int(var.find('NumValues').text)):\n                        state_variables['ValueEnum'].append('s' + str(i))\n                if var.find('ValueEnum') is not None:\n                    state_variables['ValueEnum'] = \\\n                        var.find('ValueEnum').text.split()\n                _variables['StateVar'].append(state_variables)\n\n            for var in variable.findall('ObsVar'):\n                obs_variables = defaultdict(list)\n                obs_variables['vname'] = var.get('vname')\n                obs_variables['ValueEnum'] = \\\n                    var.find('ValueEnum').text.split()\n                _variables['ObsVar'].append(obs_variables)\n\n            for var in variable.findall('ActionVar'):\n                action_variables = defaultdict(list)\n                action_variables['vname'] = var.get('vname')\n                action_variables['ValueEnum'] = \\\n                    var.find('ValueEnum').text.split()\n                _variables['ActionVar'].append(action_variables)\n\n            for var in variable.findall('RewardVar'):\n                reward_variables = defaultdict(list)\n                reward_variables['vname'] = var.get('vname')\n                _variables['RewardVar'].append(reward_variables)\n\n            self.variables.update(_variables)\n\n        return self.variables", "response": "Returns list of variables of the current resource."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_state_transition_function(self):\n        state_transition_function = []\n        for variable in self.network.findall('StateTransitionFunction'):\n            for var in variable.findall('CondProb'):\n                cond_prob = defaultdict(list)\n                cond_prob['Var'] = var.find('Var').text\n                cond_prob['Parent'] = var.find('Parent').text.split()\n                if not var.find('Parameter').get('type'):\n                    cond_prob['Type'] = 'TBL'\n                else:\n                    cond_prob['Type'] = var.find('Parameter').get('type')\n                cond_prob['Parameter'] = self.get_parameter(var)\n                state_transition_function.append(cond_prob)\n\n        return state_transition_function", "response": "Returns the transition of the state variables as nested dict in the case of table type parameter and nested structure in case of decision diagram parameter."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_obs_function(self):\n        obs_function = []\n        for variable in self.network.findall('ObsFunction'):\n            for var in variable.findall('CondProb'):\n                cond_prob = defaultdict(list)\n                cond_prob['Var'] = var.find('Var').text\n                cond_prob['Parent'] = var.find('Parent').text.split()\n                if not var.find('Parameter').get('type'):\n                    cond_prob['Type'] = 'TBL'\n                else:\n                    cond_prob['Type'] = var.find('Parameter').get('type')\n                cond_prob['Parameter'] = self.get_parameter(var)\n                obs_function.append(cond_prob)\n\n        return obs_function", "response": "Returns the observation function as nested dict in the case of table -\n        type parameter and a nested structure in case of decision diagram parameter -\n        type parameter -\n        decision diagram parameter -\n        decision diagram parameter -\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the reward function as nested dict in the case of table - type parameter and nested structure in case of decision diagram parameter - type parameter - decision diagram parameter - parameter - tuples of all tables -", "response": "def get_reward_function(self):\n        \"\"\"\n        Returns the reward function as nested dict in the case of table-\n        type parameter and a nested structure in case of\n        decision diagram parameter\n\n        Example\n        --------\n        >>> reader = PomdpXReader('Test_PomdpX.xml')\n        >>> reader.get_reward_function()\n        [{'Var': 'reward_rover',\n              'Parent': ['action_rover', 'rover_0', 'rock_0'],\n              'Type': 'TBL',\n              'Parameter': [{'Instance': ['ame', 's1', '*'],\n                             'ValueTable': ['10']},\n                         ...\n                        ]\n        }]\n        \"\"\"\n        reward_function = []\n        for variable in self.network.findall('RewardFunction'):\n            for var in variable.findall('Func'):\n                func = defaultdict(list)\n                func['Var'] = var.find('Var').text\n                func['Parent'] = var.find('Parent').text.split()\n                if not var.find('Parameter').get('type'):\n                    func['Type'] = 'TBL'\n                else:\n                    func['Type'] = var.find('Parameter').get('type')\n                func['Parameter'] = self.get_parameter(var)\n                reward_function.append(func)\n\n        return reward_function"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_parameter(self, var):\n        parameter = []\n\n        for parameter_tag in var.findall('Parameter'):\n            parameter_type = 'TBL'\n            if parameter_tag.get('type') is not None:\n                parameter_type = parameter_tag.get('type')\n            if parameter_type == 'TBL':\n                parameter = self.get_parameter_tbl(parameter_tag)\n            elif parameter_type == 'DD':\n                parameter = defaultdict(list)\n                parameter = self.get_parameter_dd(parameter_tag)\n\n        return parameter", "response": "This method returns the parameter of the functional tags in the function."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd the value enum to the xml", "response": "def _add_value_enum(self, var, tag):\n        \"\"\"\n        supports adding variables to the xml\n\n        Parameters\n        ---------------\n        var: The SubElement variable\n        tag: The SubElement tag to which enum value is to be added\n\n        Return\n        ---------------\n        None\n        \"\"\"\n        if var['ValueEnum'][0] == 's0':\n                numvalues_tag = etree.SubElement(tag, 'NumValues')\n                numvalues_tag.text = str(int(var['ValueEnum'][-1][-1]) + 1)\n        else:\n            valueenum_tag = etree.SubElement(tag, 'ValueEnum')\n            valueenum_tag.text = ''\n            for value in var['ValueEnum']:\n                valueenum_tag.text += value + ' '\n            valueenum_tag.text = valueenum_tag.text[:-1]"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the PomdpX xml containing variables tag", "response": "def get_variables(self):\n        \"\"\"\n        Add variables to PomdpX\n\n        Return\n        ---------------\n        xml containing variables tag\n        \"\"\"\n        state_variables = self.model['variables']['StateVar']\n        for var in state_variables:\n            state_var_tag = etree.SubElement(self.variable, 'StateVar', attrib={'vnamePrev': var['vnamePrev'],\n                                                                                'vnameCurr': var['vnameCurr'],\n                                                                                'fullyObs': 'true' if var['fullyObs']\n                                                                                else 'false'})\n            self._add_value_enum(var, state_var_tag)\n\n        obs_variables = self.model['variables']['ObsVar']\n        for var in obs_variables:\n            obs_var_tag = etree.SubElement(self.variable, 'ObsVar', attrib={'vname': var['vname']})\n            self._add_value_enum(var, obs_var_tag)\n\n        action_variables = self.model['variables']['ActionVar']\n        for var in action_variables:\n            action_var_tag = etree.SubElement(self.variable, 'ActionVar', attrib={'vname': var['vname']})\n            self._add_value_enum(var, action_var_tag)\n\n        reward_var = self.model['variables']['RewardVar']\n        for var in reward_var:\n            etree.SubElement(self.variable, 'RewardVar', attrib={'vname': var['vname']})\n\n        return self.__str__(self.variable)[:-1]"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add_conditions(self, condition, condprob):\n        var_tag = etree.SubElement(condprob, 'Var')\n        var_tag.text = condition['Var']\n        parent_tag = etree.SubElement(condprob, 'Parent')\n        parent_tag.text = ''\n        for parent in condition['Parent']:\n            parent_tag.text += parent + ' '\n        parent_tag.text = parent_tag.text[:-1]\n        parameter_tag = etree.SubElement(condprob, 'Parameter', attrib={'type': condition['Type']\n                                                                        if condition['Type'] is not None\n                                                                        else 'TBL'})\n        if condition['Type'] == 'DD':\n            dag_tag = etree.SubElement(parameter_tag, 'DAG')\n            parameter_dict = condition['Parameter']\n            if 'SubDAGTemplate' in parameter_dict:\n                subdag_tag = etree.SubElement(parameter_tag, 'SubDAGTemplate', attrib={'id': parameter_dict['id']})\n                self.add_parameter_dd(subdag_tag, parameter_dict['SubDAGTemplate'])\n                del parameter_dict['SubDAGTemplate']\n                del parameter_dict['id']\n                self.add_parameter_dd(dag_tag, parameter_dict)\n            else:\n                self.add_parameter_dd(dag_tag, parameter_dict)\n        else:\n            for parameter in condition['Parameter']:\n                entry = etree.SubElement(parameter_tag, 'Entry')\n                instance = etree.SubElement(entry, 'Instance')\n                instance.text = ''\n                for instance_var in parameter['Instance']:\n                    instance.text += instance_var + ' '\n                length_instance = len(parameter['Instance'])\n                if len(parameter['Instance'][length_instance - 1]) > 1:\n                        instance.text = instance.text[:-1]\n                if len(parameter['Instance']) == 1:\n                    instance.text = ' ' + instance.text\n                if condprob.tag == 'Func':\n                    table = 'ValueTable'\n                else:\n                    table = 'ProbTable'\n                prob_table = parameter[table]\n                prob_table_tag = etree.SubElement(entry, table)\n                prob_table_tag.text = ''\n                for probability in prob_table:\n                    prob_table_tag.text += probability + ' '\n                prob_table_tag.text = prob_table_tag.text[:-1]", "response": "helper function for adding probability conditions for model \\"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding initial belief tag to pomdpx model", "response": "def add_initial_belief(self):\n        \"\"\"\n        add initial belief tag to pomdpx model\n\n        Return\n        ---------------\n        string containing the xml for initial belief tag\n        \"\"\"\n        initial_belief = self.model['initial_state_belief']\n        for condition in initial_belief:\n            condprob = etree.SubElement(self.initial_belief, 'CondProb')\n            self.add_conditions(condition, condprob)\n        return self.__str__(self.initial_belief)[:-1]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add_state_transition_function(self):\n        state_transition_function = self.model['state_transition_function']\n        for condition in state_transition_function:\n            condprob = etree.SubElement(self.transition_function, 'CondProb')\n            self.add_conditions(condition, condprob)\n        return self.__str__(self.transition_function)[:-1]", "response": "add state transition function tag to pomdpx model"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add_obs_function(self):\n        obs_function = self.model['obs_function']\n        for condition in obs_function:\n            condprob = etree.SubElement(self.observation_function, 'CondProb')\n            self.add_conditions(condition, condprob)\n        return self.__str__(self.observation_function)[:-1]", "response": "add observation function tag to pomdpx model"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add_reward_function(self):\n        reward_function = self.model['reward_function']\n        for condition in reward_function:\n            condprob = etree.SubElement(self.reward_function, 'Func')\n            self.add_conditions(condition, condprob)\n        return self.__str__(self.reward_function)[:-1]", "response": "add reward function tag to pomdpx model"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the grammar of the UAI file.", "response": "def get_grammar(self):\n        \"\"\"\n        Returns the grammar of the UAI file.\n        \"\"\"\n        network_name = Word(alphas).setResultsName('network_name')\n        no_variables = Word(nums).setResultsName('no_variables')\n        grammar = network_name + no_variables\n        self.no_variables = int(grammar.parseString(self.network)['no_variables'])\n        domain_variables = (Word(nums)*self.no_variables).setResultsName('domain_variables')\n        grammar += domain_variables\n        no_functions = Word(nums).setResultsName('no_functions')\n        grammar += no_functions\n        self.no_functions = int(grammar.parseString(self.network)['no_functions'])\n        integer = Word(nums).setParseAction(lambda t: int(t[0]))\n        for function in range(0, self.no_functions):\n            scope_grammar = Word(nums).setResultsName('fun_scope_' + str(function))\n            grammar += scope_grammar\n            function_scope = grammar.parseString(self.network)['fun_scope_' + str(function)]\n            function_grammar = ((integer)*int(function_scope)).setResultsName('fun_' + str(function))\n            grammar += function_grammar\n\n        floatnumber = Combine(Word(nums) + Optional(Literal(\".\") + Optional(Word(nums))))\n        for function in range(0, self.no_functions):\n            no_values_grammar = Word(nums).setResultsName('fun_no_values_' + str(function))\n            grammar += no_values_grammar\n            no_values = grammar.parseString(self.network)['fun_no_values_' + str(function)]\n            values_grammar = ((floatnumber)*int(no_values)).setResultsName('fun_values_' + str(function))\n            grammar += values_grammar\n        return grammar"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_variables(self):\n        variables = []\n        for var in range(0, self.no_variables):\n            var_name = \"var_\" + str(var)\n            variables.append(var_name)\n        return variables", "response": "Returns a list of variables."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the domain of the variables in the UAI file.", "response": "def get_domain(self):\n        \"\"\"\n        Returns the dictionary of variables with keys as variable name\n        and values as domain of the variables.\n\n        Returns\n        -------\n        dict: dictionary containing variables and their domains\n\n        Example\n        -------\n        >>> reader = UAIReader('TestUAI.uai')\n        >>> reader.get_domain()\n        {'var_0': '2', 'var_1': '2', 'var_2': '3'}\n        \"\"\"\n        domain = {}\n        var_domain = self.grammar.parseString(self.network)['domain_variables']\n        for var in range(0, len(var_domain)):\n            domain[\"var_\" + str(var)] = var_domain[var]\n        return domain"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_edges(self):\n        edges = []\n        for function in range(0, self.no_functions):\n            function_variables = self.grammar.parseString(self.network)['fun_' + str(function)]\n            if isinstance(function_variables, int):\n                function_variables = [function_variables]\n            if self.network_type == 'BAYES':\n                child_var = \"var_\" + str(function_variables[-1])\n                function_variables = function_variables[:-1]\n                for var in function_variables:\n                    edges.append((child_var, \"var_\" + str(var)))\n            elif self.network_type == \"MARKOV\":\n                function_variables = [\"var_\" + str(var) for var in function_variables]\n                edges.extend(list(combinations(function_variables, 2)))\n        return set(edges)", "response": "Returns the edges of the UAI network."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning list of tuples of child variable and CPD in case of Bayesian and list of tuple of scope of variables and values in case of Markov.", "response": "def get_tables(self):\n        \"\"\"\n        Returns list of tuple of child variable and CPD in case of Bayesian\n        and list of tuple of scope of variables and values in case of Markov.\n\n        Returns\n        -------\n        list : list of tuples of child variable and values in Bayesian\n            list of tuples of scope of variables and values in case of Markov.\n\n        Example\n        -------\n        >>> reader = UAIReader('TestUAI.uai')\n        >>> reader.get_tables()\n        [(['var_0', 'var_1'], ['4.000', '2.400', '1.000', '0.000']),\n         (['var_0', 'var_1', 'var_2'],\n          ['2.2500', '3.2500', '3.7500', '0.0000', '0.0000', '10.0000',\n           '1.8750', '4.0000', '3.3330', '2.0000', '2.0000', '3.4000'])]\n        \"\"\"\n        tables = []\n        for function in range(0, self.no_functions):\n            function_variables = self.grammar.parseString(self.network)['fun_' + str(function)]\n            if isinstance(function_variables, int):\n                function_variables = [function_variables]\n            if self.network_type == 'BAYES':\n                child_var = \"var_\" + str(function_variables[-1])\n                values = self.grammar.parseString(self.network)['fun_values_' + str(function)]\n                tables.append((child_var, list(values)))\n            elif self.network_type == \"MARKOV\":\n                function_variables = [\"var_\" + str(var) for var in function_variables]\n                values = self.grammar.parseString(self.network)['fun_values_' + str(function)]\n                tables.append((function_variables, list(values)))\n        return tables"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_model(self):\n        if self.network_type == 'BAYES':\n            model = BayesianModel()\n            model.add_nodes_from(self.variables)\n            model.add_edges_from(self.edges)\n\n            tabular_cpds = []\n            for cpd in self.tables:\n                child_var = cpd[0]\n                states = int(self.domain[child_var])\n                arr = list(map(float, cpd[1]))\n                values = np.array(arr)\n                values = values.reshape(states, values.size // states)\n                tabular_cpds.append(TabularCPD(child_var, states, values))\n\n            model.add_cpds(*tabular_cpds)\n            return model\n\n        elif self.network_type == 'MARKOV':\n            model = MarkovModel(self.edges)\n\n            factors = []\n            for table in self.tables:\n                variables = table[0]\n                cardinality = [int(self.domain[var]) for var in variables]\n                value = list(map(float, table[1]))\n                factor = DiscreteFactor(variables=variables, cardinality=cardinality, values=value)\n                factors.append(factor)\n\n            model.add_factors(*factors)\n            return model", "response": "Returns an instance of Bayesian Model or Markov Model."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_domain(self):\n        if isinstance(self.model, BayesianModel):\n            cpds = self.model.get_cpds()\n            cpds.sort(key=lambda x: x.variable)\n            domain = {}\n            for cpd in cpds:\n                domain[cpd.variable] = str(cpd.variable_card)\n            return domain\n        elif isinstance(self.model, MarkovModel):\n            factors = self.model.get_factors()\n            domain = {}\n            for factor in factors:\n                variables = factor.variables\n                for var in variables:\n                    if var not in domain:\n                        domain[var] = str(factor.get_cardinality([var])[var])\n            return domain\n        else:\n            raise TypeError(\"Model must be an instance of Markov or Bayesian model.\")", "response": "Returns a dictionary of domain of each variable in the network."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding functions to the network.", "response": "def get_functions(self):\n        \"\"\"\n        Adds functions to the network.\n\n        Example\n        -------\n        >>> writer = UAIWriter(model)\n        >>> writer.get_functions()\n        \"\"\"\n        if isinstance(self.model, BayesianModel):\n            cpds = self.model.get_cpds()\n            cpds.sort(key=lambda x: x.variable)\n            variables = sorted(self.domain.items(), key=lambda x: (x[1], x[0]))\n            functions = []\n            for cpd in cpds:\n                child_var = cpd.variable\n                evidence = cpd.variables[:0:-1]\n                function = [str(variables.index((var, self.domain[var]))) for var in evidence]\n                function.append(str(variables.index((child_var, self.domain[child_var]))))\n                functions.append(function)\n            return functions\n        elif isinstance(self.model, MarkovModel):\n            factors = self.model.get_factors()\n            functions = []\n            variables = sorted(self.domain.items(), key=lambda x: (x[1], x[0]))\n            for factor in factors:\n                scope = factor.scope()\n                function = [str(variables.index((var, self.domain[var]))) for var in scope]\n                functions.append(function)\n            return functions\n        else:\n            raise TypeError(\"Model must be an instance of Markov or Bayesian model.\")"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_tables(self):\n        if isinstance(self.model, BayesianModel):\n            cpds = self.model.get_cpds()\n            cpds.sort(key=lambda x: x.variable)\n            tables = []\n            for cpd in cpds:\n                values = list(map(str, cpd.values.ravel()))\n                tables.append(values)\n            return tables\n        elif isinstance(self.model, MarkovModel):\n            factors = self.model.get_factors()\n            tables = []\n            for factor in factors:\n                values = list(map(str, factor.values.ravel()))\n                tables.append(values)\n            return tables\n        else:\n            raise TypeError(\"Model must be an instance of Markov or Bayesian model.\")", "response": "Adds tables to the network."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nwrites the xml data into the file.", "response": "def write_uai(self, filename):\n        \"\"\"\n        Write the xml data into the file.\n\n        Parameters\n        ----------\n        filename: Name of the file.\n\n        Examples\n        -------\n        >>> writer = UAIWriter(model)\n        >>> writer.write_xmlbif(test_file)\n        \"\"\"\n        writer = self.__str__()\n        with open(filename, 'w') as fout:\n            fout.write(writer)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef local_score(self, variable, parents):\n        \"Computes a score that measures how much a \\\n        given variable is \\\"influenced\\\" by a given list of potential parents.\"\n\n        var_states = self.state_names[variable]\n        var_cardinality = len(var_states)\n        state_counts = self.state_counts(variable, parents)\n\n        score = 0\n        for parents_state in state_counts:  # iterate over df columns (only 1 if no parents)\n            conditional_sample_size = sum(state_counts[parents_state])\n\n            score += lgamma(var_cardinality) - lgamma(conditional_sample_size + var_cardinality)\n\n            for state in var_states:\n                if state_counts[parents_state][state] > 0:\n                    score += lgamma(state_counts[parents_state][state] + 1)\n        return score", "response": "Computes a score that measures how much a \\\n given variable is influenced by a given list of potential parents."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nrunning the command to download target.", "response": "def _clean_check(cmd, target):\n    \"\"\"\n    Run the command to download target. If the command fails, clean up before\n    re-raising the error.\n    \"\"\"\n    try:\n        subprocess.check_call(cmd)\n    except subprocess.CalledProcessError:\n        if os.access(target, os.F_OK):\n            os.unlink(target)\n        raise"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndownloading the file at url to target using Powershell.", "response": "def download_file_powershell(url, target):\n    \"\"\"\n    Download the file at url to target using Powershell (which will validate\n    trust). Raise an exception if the command cannot complete.\n    \"\"\"\n    target = os.path.abspath(target)\n    cmd = [\n        'powershell',\n        '-Command',\n        \"(new-object System.Net.WebClient).DownloadFile(%(url)r, %(target)r)\" % vars(),\n    ]\n    _clean_check(cmd, target)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndownloading setuptools from a specified location and return its filename.", "response": "def download_setuptools(version=DEFAULT_VERSION, download_base=DEFAULT_URL,\n                        to_dir=os.curdir, delay=15,\n                        downloader_factory=get_best_downloader):\n    \"\"\"Download setuptools from a specified location and return its filename\n\n    `version` should be a valid setuptools version number that is available\n    as an egg for download under the `download_base` URL (which should end\n    with a '/'). `to_dir` is the directory where the egg will be downloaded.\n    `delay` is the number of seconds to pause before an actual download\n    attempt.\n\n    ``downloader_factory`` should be a function taking no arguments and\n    returning a function for downloading a URL to a target.\n    \"\"\"\n    # making sure we use the absolute path\n    to_dir = os.path.abspath(to_dir)\n    tgz_name = \"setuptools-%s.tar.gz\" % version\n    url = download_base + tgz_name\n    saveto = os.path.join(to_dir, tgz_name)\n    if not os.path.exists(saveto):  # Avoid repeated downloads\n        log.warn(\"Downloading %s\", url)\n        downloader = downloader_factory()\n        downloader(url, saveto)\n    return os.path.realpath(saveto)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _parse_args():\n    parser = optparse.OptionParser()\n    parser.add_option(\n        '--user', dest='user_install', action='store_true', default=False,\n        help='install in user site package (requires Python 2.6 or later)')\n    parser.add_option(\n        '--download-base', dest='download_base', metavar=\"URL\",\n        default=DEFAULT_URL,\n        help='alternative URL from where to download the setuptools package')\n    parser.add_option(\n        '--insecure', dest='downloader_factory', action='store_const',\n        const=lambda: download_file_insecure, default=get_best_downloader,\n        help='Use internal, non-validating downloader'\n    )\n    options, args = parser.parse_args()\n    # positional arguments are ignored\n    return options", "response": "Parse the command line for options\n   "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add_edge(self, u, v, **kwargs):\n        if u == v:\n            raise ValueError('Self loops are not allowed.')\n        if u in self.nodes() and v in self.nodes() and nx.has_path(self, v, u):\n            raise ValueError(\n                'Loops are not allowed. Adding the edge from (%s->%s) forms a loop.' % (u, v))\n        else:\n            super(BayesianModel, self).add_edge(u, v, **kwargs)", "response": "Add an edge between u and v."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef remove_node(self, node):\n        affected_nodes = [v for u, v in self.edges() if u == node]\n\n        for affected_node in affected_nodes:\n            node_cpd = self.get_cpds(node=affected_node)\n            if node_cpd:\n                node_cpd.marginalize([node], inplace=True)\n\n        if self.get_cpds(node=node):\n            self.remove_cpds(node)\n        super(BayesianModel, self).remove_node(node)", "response": "Remove a node from the model."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add_cpds(self, *cpds):\n        for cpd in cpds:\n            if not isinstance(cpd, (TabularCPD, ContinuousFactor)):\n                raise ValueError('Only TabularCPD or ContinuousFactor can be added.')\n\n            if set(cpd.scope()) - set(cpd.scope()).intersection(\n                    set(self.nodes())):\n                raise ValueError('CPD defined on variable not in the model', cpd)\n\n            for prev_cpd_index in range(len(self.cpds)):\n                if self.cpds[prev_cpd_index].variable == cpd.variable:\n                    logging.warning(\"Replacing existing CPD for {var}\".format(var=cpd.variable))\n                    self.cpds[prev_cpd_index] = cpd\n                    break\n            else:\n                self.cpds.append(cpd)", "response": "Adds a set of CPDs to the current model."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the CPDs that have been added till now to the graph.", "response": "def get_cpds(self, node=None):\n        \"\"\"\n        Returns the cpd of the node. If node is not specified returns all the CPDs\n        that have been added till now to the graph\n\n        Parameter\n        ---------\n        node: any hashable python object (optional)\n            The node whose CPD we want. If node not specified returns all the\n            CPDs added to the model.\n\n        Returns\n        -------\n        A list of TabularCPDs.\n\n        Examples\n        --------\n        >>> from pgmpy.models import BayesianModel\n        >>> from pgmpy.factors.discrete import TabularCPD\n        >>> student = BayesianModel([('diff', 'grade'), ('intel', 'grade')])\n        >>> cpd = TabularCPD('grade', 2, [[0.1, 0.9, 0.2, 0.7],\n        ...                               [0.9, 0.1, 0.8, 0.3]],\n        ...                  ['intel', 'diff'], [2, 2])\n        >>> student.add_cpds(cpd)\n        >>> student.get_cpds()\n        \"\"\"\n        if node is not None:\n            if node not in self.nodes():\n                raise ValueError('Node not present in the Directed Graph')\n            for cpd in self.cpds:\n                if cpd.variable == node:\n                    return cpd\n            else:\n                return None\n        else:\n            return self.cpds"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nremoving the cpds that are provided in the argument. Parameters ---------- *cpds: TabularCPD object A CPD object on any subset of the variables of the model which is to be associated with the model. Examples -------- >>> from pgmpy.models import BayesianModel >>> from pgmpy.factors.discrete import TabularCPD >>> student = BayesianModel([('diff', 'grade'), ('intel', 'grade')]) >>> cpd = TabularCPD('grade', 2, [[0.1, 0.9, 0.2, 0.7], ... [0.9, 0.1, 0.8, 0.3]], ... ['intel', 'diff'], [2, 2]) >>> student.add_cpds(cpd) >>> student.remove_cpds(cpd)", "response": "def remove_cpds(self, *cpds):\n        \"\"\"\n        Removes the cpds that are provided in the argument.\n\n        Parameters\n        ----------\n        *cpds: TabularCPD object\n            A CPD object on any subset of the variables of the model which\n            is to be associated with the model.\n\n        Examples\n        --------\n        >>> from pgmpy.models import BayesianModel\n        >>> from pgmpy.factors.discrete import TabularCPD\n        >>> student = BayesianModel([('diff', 'grade'), ('intel', 'grade')])\n        >>> cpd = TabularCPD('grade', 2, [[0.1, 0.9, 0.2, 0.7],\n        ...                               [0.9, 0.1, 0.8, 0.3]],\n        ...                  ['intel', 'diff'], [2, 2])\n        >>> student.add_cpds(cpd)\n        >>> student.remove_cpds(cpd)\n        \"\"\"\n        for cpd in cpds:\n            if isinstance(cpd, six.string_types):\n                cpd = self.get_cpds(cpd)\n            self.cpds.remove(cpd)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the cardinality of the node.", "response": "def get_cardinality(self, node=None):\n        \"\"\"\n        Returns the cardinality of the node. Throws an error if the CPD for the\n        queried node hasn't been added to the network.\n\n        Parameters\n        ----------\n        node: Any hashable python object(optional).\n              The node whose cardinality we want. If node is not specified returns a\n              dictionary with the given variable as keys and their respective cardinality\n              as values.\n\n        Returns\n        -------\n        int or dict : If node is specified returns the cardinality of the node.\n                      If node is not specified returns a dictionary with the given\n                      variable as keys and their respective cardinality as values.\n\n        Examples\n        --------\n        >>> from pgmpy.models import BayesianModel\n        >>> from pgmpy.factors.discrete import TabularCPD\n        >>> student = BayesianModel([('diff', 'grade'), ('intel', 'grade')])\n        >>> cpd_diff = TabularCPD('diff',2,[[0.6,0.4]]);\n        >>> cpd_intel = TabularCPD('intel',2,[[0.7,0.3]]);\n        >>> cpd_grade = TabularCPD('grade', 2, [[0.1, 0.9, 0.2, 0.7],\n        ...                                     [0.9, 0.1, 0.8, 0.3]],\n        ...                                 ['intel', 'diff'], [2, 2])\n        >>> student.add_cpds(cpd_diff,cpd_intel,cpd_grade)\n        >>> student.get_cardinality()\n        defaultdict(int, {'diff': 2, 'grade': 2, 'intel': 2})\n\n        >>> student.get_cardinality('intel')\n        2\n        \"\"\"\n\n        if node:\n            return self.get_cpds(node).cardinality[0]\n        else:\n            cardinalities = defaultdict(int)\n            for cpd in self.cpds:\n                cardinalities[cpd.variable] = cpd.cardinality[0]\n            return cardinalities"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nchecks the model for various errors.", "response": "def check_model(self):\n        \"\"\"\n        Check the model for various errors. This method checks for the following\n        errors.\n\n        * Checks if the sum of the probabilities for each state is equal to 1 (tol=0.01).\n        * Checks if the CPDs associated with nodes are consistent with their parents.\n\n        Returns\n        -------\n        check: boolean\n            True if all the checks are passed\n        \"\"\"\n        for node in self.nodes():\n            cpd = self.get_cpds(node=node)\n\n            if cpd is None:\n                raise ValueError('No CPD associated with {}'.format(node))\n            elif isinstance(cpd, (TabularCPD, ContinuousFactor)):\n                evidence = cpd.get_evidence()\n                parents = self.get_parents(node)\n                if set(evidence if evidence else []) != set(parents if parents else []):\n                    raise ValueError(\"CPD associated with {node} doesn't have \"\n                                     \"proper parents associated with it.\".format(node=node))\n                if not cpd.is_valid_cpd():\n                    raise ValueError(\"Sum or integral of conditional probabilites for node {node}\"\n                                     \" is not equal to 1.\".format(node=node))\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef to_markov_model(self):\n        moral_graph = self.moralize()\n        mm = MarkovModel(moral_graph.edges())\n        mm.add_factors(*[cpd.to_factor() for cpd in self.cpds])\n\n        return mm", "response": "Converts the bayesian model to markov model."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef fit(self, data, estimator=None, state_names=[], complete_samples_only=True, **kwargs):\n\n        from pgmpy.estimators import MaximumLikelihoodEstimator, BayesianEstimator, BaseEstimator\n\n        if estimator is None:\n            estimator = MaximumLikelihoodEstimator\n        else:\n            if not issubclass(estimator, BaseEstimator):\n                raise TypeError(\"Estimator object should be a valid pgmpy estimator.\")\n\n        _estimator = estimator(self, data, state_names=state_names,\n                               complete_samples_only=complete_samples_only)\n        cpds_list = _estimator.get_parameters(**kwargs)\n        self.add_cpds(*cpds_list)", "response": "Fits the CPD model to the data set."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef predict(self, data):\n        from pgmpy.inference import VariableElimination\n\n        if set(data.columns) == set(self.nodes()):\n            raise ValueError(\"No variable missing in data. Nothing to predict\")\n\n        elif set(data.columns) - set(self.nodes()):\n            raise ValueError(\"Data has variables which are not in the model\")\n\n        missing_variables = set(self.nodes()) - set(data.columns)\n        pred_values = defaultdict(list)\n\n        # Send state_names dict from one of the estimated CPDs to the inference class.\n        model_inference = VariableElimination(self, state_names=self.get_cpds()[0].state_names)\n        for index, data_point in data.iterrows():\n            states_dict = model_inference.map_query(variables=missing_variables, evidence=data_point.to_dict())\n            for k, v in states_dict.items():\n                pred_values[k].append(v)\n        return pd.DataFrame(pred_values, index=data.index)", "response": "Predict states of all the missing variables in the data."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\npredict probabilities of all states of the missing variables.", "response": "def predict_probability(self, data):\n        \"\"\"\n        Predicts probabilities of all states of the missing variables.\n\n        Parameters\n        ----------\n        data : pandas DataFrame object\n            A DataFrame object with column names same as the variables in the model.\n\n        Examples\n        --------\n        >>> import numpy as np\n        >>> import pandas as pd\n        >>> from pgmpy.models import BayesianModel\n        >>> values = pd.DataFrame(np.random.randint(low=0, high=2, size=(100, 5)),\n        ...                       columns=['A', 'B', 'C', 'D', 'E'])\n        >>> train_data = values[:80]\n        >>> predict_data = values[80:]\n        >>> model = BayesianModel([('A', 'B'), ('C', 'B'), ('C', 'D'), ('B', 'E')])\n        >>> model.fit(values)\n        >>> predict_data = predict_data.copy()\n        >>> predict_data.drop('B', axis=1, inplace=True)\n        >>> y_prob = model.predict_probability(predict_data)\n        >>> y_prob\n            B_0         B_1\n        80  0.439178    0.560822\n        81  0.581970    0.418030\n        82  0.488275    0.511725\n        83  0.581970    0.418030\n        84  0.510794    0.489206\n        85  0.439178    0.560822\n        86  0.439178    0.560822\n        87  0.417124    0.582876\n        88  0.407978    0.592022\n        89  0.429905    0.570095\n        90  0.581970    0.418030\n        91  0.407978    0.592022\n        92  0.429905    0.570095\n        93  0.429905    0.570095\n        94  0.439178    0.560822\n        95  0.407978    0.592022\n        96  0.559904    0.440096\n        97  0.417124    0.582876\n        98  0.488275    0.511725\n        99  0.407978    0.592022\n        \"\"\"\n        from pgmpy.inference import VariableElimination\n\n        if set(data.columns) == set(self.nodes()):\n            raise ValueError(\"No variable missing in data. Nothing to predict\")\n\n        elif set(data.columns) - set(self.nodes()):\n            raise ValueError(\"Data has variables which are not in the model\")\n\n        missing_variables = set(self.nodes()) - set(data.columns)\n        pred_values = defaultdict(list)\n\n        model_inference = VariableElimination(self)\n        for index, data_point in data.iterrows():\n            full_distribution = model_inference.query(variables=missing_variables, evidence=data_point.to_dict())\n            states_dict = {}\n            for var in missing_variables:\n                states_dict[var] = full_distribution.marginalize(missing_variables - {var}, inplace=False)\n            for k, v in states_dict.items():\n                for l in range(len(v.values)):\n                    state = self.get_cpds(k).state_names[k][l]\n                    pred_values[k + '_' + str(state)].append(v.values[l])\n        return pd.DataFrame(pred_values, index=data.index)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncheck whether the bayesian model is Imap for given Joint Probability Distribution and returns a boolean indicating if the bayesian model is Imap for given Joint Probability Distribution.", "response": "def is_imap(self, JPD):\n        \"\"\"\n        Checks whether the bayesian model is Imap of given JointProbabilityDistribution\n\n        Parameters\n        -----------\n        JPD : An instance of JointProbabilityDistribution Class, for which you want to\n            check the Imap\n\n        Returns\n        --------\n        boolean : True if bayesian model is Imap for given Joint Probability Distribution\n                False otherwise\n        Examples\n        --------\n        >>> from pgmpy.models import BayesianModel\n        >>> from pgmpy.factors.discrete import TabularCPD\n        >>> from pgmpy.factors.discrete import JointProbabilityDistribution\n        >>> G = BayesianModel([('diff', 'grade'), ('intel', 'grade')])\n        >>> diff_cpd = TabularCPD('diff', 2, [[0.2], [0.8]])\n        >>> intel_cpd = TabularCPD('intel', 3, [[0.5], [0.3], [0.2]])\n        >>> grade_cpd = TabularCPD('grade', 3,\n        ...                        [[0.1,0.1,0.1,0.1,0.1,0.1],\n        ...                         [0.1,0.1,0.1,0.1,0.1,0.1],\n        ...                         [0.8,0.8,0.8,0.8,0.8,0.8]],\n        ...                        evidence=['diff', 'intel'],\n        ...                        evidence_card=[2, 3])\n        >>> G.add_cpds(diff_cpd, intel_cpd, grade_cpd)\n        >>> val = [0.01, 0.01, 0.08, 0.006, 0.006, 0.048, 0.004, 0.004, 0.032,\n                   0.04, 0.04, 0.32, 0.024, 0.024, 0.192, 0.016, 0.016, 0.128]\n        >>> JPD = JointProbabilityDistribution(['diff', 'intel', 'grade'], [2, 3, 3], val)\n        >>> G.is_imap(JPD)\n        True\n        \"\"\"\n        if not isinstance(JPD, JointProbabilityDistribution):\n            raise TypeError(\"JPD must be an instance of JointProbabilityDistribution\")\n        factors = [cpd.to_factor() for cpd in self.get_cpds()]\n        factor_prod = reduce(mul, factors)\n        JPD_fact = DiscreteFactor(JPD.variables, JPD.cardinality, JPD.values)\n        if JPD_fact == factor_prod:\n            return True\n        else:\n            return False"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a copy of the model.", "response": "def copy(self):\n        \"\"\"\n        Returns a copy of the model.\n\n        Returns\n        -------\n        BayesianModel: Copy of the model on which the method was called.\n\n        Examples\n        --------\n        >>> from pgmpy.models import BayesianModel\n        >>> from pgmpy.factors.discrete import TabularCPD\n        >>> model = BayesianModel([('A', 'B'), ('B', 'C')])\n        >>> cpd_a = TabularCPD('A', 2, [[0.2], [0.8]])\n        >>> cpd_b = TabularCPD('B', 2, [[0.3, 0.7], [0.7, 0.3]],\n                               evidence=['A'],\n                               evidence_card=[2])\n        >>> cpd_c = TabularCPD('C', 2, [[0.1, 0.9], [0.9, 0.1]],\n                               evidence=['B'],\n                               evidence_card=[2])\n        >>> model.add_cpds(cpd_a, cpd_b, cpd_c)\n        >>> copy_model = model.copy()\n        >>> copy_model.nodes()\n        ['C', 'A', 'B']\n        >>> copy_model.edges()\n        [('A', 'B'), ('B', 'C')]\n        >>> copy_model.get_cpds()\n        [<TabularCPD representing P(A:2) at 0x7f2824930a58>,\n         <TabularCPD representing P(B:2 | A:2) at 0x7f2824930a90>,\n         <TabularCPD representing P(C:2 | B:2) at 0x7f2824944240>]\n        \"\"\"\n        model_copy = BayesianModel()\n        model_copy.add_nodes_from(self.nodes())\n        model_copy.add_edges_from(self.edges())\n        if self.cpds:\n            model_copy.add_cpds(*[cpd.copy() for cpd in self.cpds])\n        return model_copy"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_values(self):\n        if self.variable in self.variables:\n            return self.values.reshape(self.cardinality[0], np.prod(self.cardinality[1:]))\n        else:\n            return self.values.reshape(1, np.prod(self.cardinality))", "response": "Returns the values of the current set of items."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a copy of the TabularCPD object.", "response": "def copy(self):\n        \"\"\"\n        Returns a copy of the TabularCPD object.\n\n        Examples\n        --------\n        >>> from pgmpy.factors.discrete import TabularCPD\n        >>> cpd = TabularCPD('grade', 2,\n        ...                  [[0.7, 0.6, 0.6, 0.2],[0.3, 0.4, 0.4, 0.8]],\n        ...                  ['intel', 'diff'], [2, 2])\n        >>> copy = cpd.copy()\n        >>> copy.variable\n        'grade'\n        >>> copy.variable_card\n        2\n        >>> copy.evidence\n        ['intel', 'diff']\n        >>> copy.values\n        array([[[ 0.7,  0.6],\n                [ 0.6,  0.2]],\n\n               [[ 0.3,  0.4],\n                [ 0.4,  0.8]]])\n        \"\"\"\n        evidence = self.variables[1:] if len(self.variables) > 1 else None\n        evidence_card = self.cardinality[1:] if len(self.variables) > 1 else None\n        return TabularCPD(self.variable, self.variable_card, self.get_values(),\n                          evidence, evidence_card, state_names=self.state_names)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef normalize(self, inplace=True):\n        tabular_cpd = self if inplace else self.copy()\n        cpd = tabular_cpd.get_values()\n        tabular_cpd.values = (cpd / cpd.sum(axis=0)).reshape(tabular_cpd.cardinality)\n        if not inplace:\n            return tabular_cpd", "response": "Normalizes the cpd table.\n\n        Parameters\n        ----------\n        inplace: boolean\n            If inplace=True it will modify the CPD itself, else would return\n            a new CPD\n\n        Examples\n        --------\n        >>> from pgmpy.factors.discrete import TabularCPD\n        >>> cpd_table = TabularCPD('grade', 2,\n        ...                        [[0.7, 0.2, 0.6, 0.2],[0.4, 0.4, 0.4, 0.8]],\n        ...                        ['intel', 'diff'], [2, 2])\n        >>> cpd_table.normalize()\n        >>> cpd_table.get_values()\n        array([[ 0.63636364,  0.33333333,  0.6       ,  0.2       ],\n               [ 0.36363636,  0.66666667,  0.4       ,  0.8       ]])"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nmodifies the cpd table with marginalized values. Parameters ---------- variables: list, array-like list of variable to be marginalized inplace: boolean If inplace=True it will modify the CPD itself, else would return a new CPD Examples -------- >>> from pgmpy.factors.discrete import TabularCPD >>> cpd_table = TabularCPD('grade', 2, ... [[0.7, 0.6, 0.6, 0.2],[0.3, 0.4, 0.4, 0.8]], ... ['intel', 'diff'], [2, 2]) >>> cpd_table.marginalize(['diff']) >>> cpd_table.get_values() array([[ 0.65, 0.4 ], [ 0.35, 0.6 ]])", "response": "def marginalize(self, variables, inplace=True):\n        \"\"\"\n        Modifies the cpd table with marginalized values.\n\n        Parameters\n        ----------\n        variables: list, array-like\n            list of variable to be marginalized\n\n        inplace: boolean\n            If inplace=True it will modify the CPD itself, else would return\n            a new CPD\n\n        Examples\n        --------\n        >>> from pgmpy.factors.discrete import TabularCPD\n        >>> cpd_table = TabularCPD('grade', 2,\n        ...                        [[0.7, 0.6, 0.6, 0.2],[0.3, 0.4, 0.4, 0.8]],\n        ...                        ['intel', 'diff'], [2, 2])\n        >>> cpd_table.marginalize(['diff'])\n        >>> cpd_table.get_values()\n        array([[ 0.65,  0.4 ],\n                [ 0.35,  0.6 ]])\n        \"\"\"\n        if self.variable in variables:\n            raise ValueError(\"Marginalization not allowed on the variable on which CPD is defined\")\n\n        tabular_cpd = self if inplace else self.copy()\n\n        super(TabularCPD, tabular_cpd).marginalize(variables)\n        tabular_cpd.normalize()\n\n        if not inplace:\n            return tabular_cpd"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreduce the cpd table to the context of given variable values.", "response": "def reduce(self, values, inplace=True):\n        \"\"\"\n        Reduces the cpd table to the context of given variable values.\n\n        Parameters\n        ----------\n        values: list, array-like\n            A list of tuples of the form (variable_name, variable_state).\n\n        inplace: boolean\n            If inplace=True it will modify the factor itself, else would return\n            a new factor.\n\n        Examples\n        --------\n        >>> from pgmpy.factors.discrete import TabularCPD\n        >>> cpd_table = TabularCPD('grade', 2,\n        ...                        [[0.7, 0.6, 0.6, 0.2],[0.3, 0.4, 0.4, 0.8]],\n        ...                        ['intel', 'diff'], [2, 2])\n        >>> cpd_table.reduce([('diff', 0)])\n        >>> cpd_table.get_values()\n        array([[ 0.7,  0.6],\n               [ 0.3,  0.4]])\n        \"\"\"\n        if self.variable in (value[0] for value in values):\n            raise ValueError(\"Reduce not allowed on the variable on which CPD is defined\")\n\n        tabular_cpd = self if inplace else self.copy()\n\n        super(TabularCPD, tabular_cpd).reduce(values)\n        tabular_cpd.normalize()\n\n        if not inplace:\n            return tabular_cpd"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef reorder_parents(self, new_order, inplace=True):\n        if (len(self.variables) <= 1 or (set(new_order) - set(self.variables)) or\n                (set(self.variables[1:]) - set(new_order))):\n            raise ValueError(\"New order either has missing or extra arguments\")\n        else:\n            if new_order != self.variables[1:]:\n                evidence = self.variables[1:]\n                evidence_card = self.cardinality[1:]\n                card_map = dict(zip(evidence, evidence_card))\n                old_pos_map = dict(zip(evidence, range(len(evidence))))\n                trans_ord = [0] + [(old_pos_map[letter] + 1) for letter in new_order]\n                new_values = np.transpose(self.values, trans_ord)\n\n                if inplace:\n                    variables = [self.variables[0]] + new_order\n                    cardinality = [self.variable_card] + [card_map[var] for var in new_order]\n                    super(TabularCPD, self).__init__(variables, cardinality, new_values.flatten('C'))\n                    return self.get_values()\n                else:\n                    return new_values.reshape(self.cardinality[0], np.prod([card_map[var] for var in new_order]))\n            else:\n                warn(\"Same ordering provided as current\")\n                return self.get_values()", "response": "Returns a new CPD with the same attributes as the current one."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd a list of LinearGaussianCPDs to the Bayesian Model.", "response": "def add_cpds(self, *cpds):\n        \"\"\"\n        Add linear Gaussian CPD (Conditional Probability Distribution)\n        to the Bayesian Model.\n\n        Parameters\n        ----------\n        cpds  :  instances of LinearGaussianCPD\n            List of LinearGaussianCPDs which will be associated with the model\n\n        Examples\n        --------\n        >>> from pgmpy.models import LinearGaussianBayesianNetwork\n        >>> from pgmpy.factors.continuous import LinearGaussianCPD\n        >>> model = LinearGaussianBayesianNetwork([('x1', 'x2'), ('x2', 'x3')])\n        >>> cpd1 = LinearGaussianCPD('x1', [1], 4)\n        >>> cpd2 = LinearGaussianCPD('x2', [-5, 0.5], 4, ['x1'])\n        >>> cpd3 = LinearGaussianCPD('x3', [4, -1], 3, ['x2'])\n        >>> model.add_cpds(cpd1, cpd2, cpd3)\n        >>> for cpd in model.cpds:\n                print(cpd)\n\n        P(x1) = N(1; 4)\n        P(x2| x1) = N(0.5*x1_mu); -5)\n        P(x3| x2) = N(-1*x2_mu); 4)\n\n        \"\"\"\n        for cpd in cpds:\n            if not isinstance(cpd, LinearGaussianCPD):\n                raise ValueError('Only LinearGaussianCPD can be added.')\n\n            if set(cpd.variables) - set(cpd.variables).intersection(\n                    set(self.nodes())):\n                raise ValueError('CPD defined on variable not in the model', cpd)\n\n            for prev_cpd_index in range(len(self.cpds)):\n                if self.cpds[prev_cpd_index].variable == cpd.variable:\n                    logging.warning(\"Replacing existing CPD for {var}\".format(var=cpd.variable))\n                    self.cpds[prev_cpd_index] = cpd\n                    break\n            else:\n                self.cpds.append(cpd)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef to_joint_gaussian(self):\n        variables = nx.topological_sort(self)\n        mean = np.zeros(len(variables))\n        covariance = np.zeros((len(variables), len(variables)))\n\n        for node_idx in range(len(variables)):\n            cpd = self.get_cpds(variables[node_idx])\n            mean[node_idx] = sum([coeff * mean[variables.index(parent)] for\n                                  coeff, parent in zip(cpd.beta_vector, cpd.evidence)]) + cpd.beta_0\n            covariance[node_idx, node_idx] = sum(\n                [coeff * coeff * covariance[variables.index(parent), variables.index(parent)]\n                 for coeff, parent in zip(cpd.beta_vector, cpd.evidence)]) + cpd.variance\n\n        for node_i_idx in range(len(variables)):\n            for node_j_idx in range(len(variables)):\n                if covariance[node_j_idx, node_i_idx] != 0:\n                    covariance[node_i_idx, node_j_idx] = covariance[node_j_idx, node_i_idx]\n                else:\n                    cpd_j = self.get_cpds(variables[node_j_idx])\n                    covariance[node_i_idx, node_j_idx] = sum(\n                        [coeff * covariance[node_i_idx, variables.index(parent)]\n                         for coeff, parent in zip(cpd_j.beta_vector, cpd_j.evidence)])\n\n        return GaussianDistribution(variables, mean, covariance)", "response": "This method converts the linear Gaussian Bayesian Network into a joint Gaussian distribution."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef check_model(self):\n        for node in self.nodes():\n            cpd = self.get_cpds(node=node)\n\n            if isinstance(cpd, LinearGaussianCPD):\n                if set(cpd.evidence) != set(self.get_parents(node)):\n                    raise ValueError(\"CPD associated with %s doesn't have \"\n                                     \"proper parents associated with it.\" % node)\n        return True", "response": "Checks the model for various errors."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef factorset_product(*factorsets_list):\n    if not all(isinstance(factorset, FactorSet) for factorset in factorsets_list):\n        raise TypeError(\"Input parameters must be FactorSet instances\")\n    return reduce(lambda x, y: x.product(y, inplace=False), factorsets_list)", "response": "r Base method used for product of two factor sets."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef factorset_divide(factorset1, factorset2):\n    if not isinstance(factorset1, FactorSet) or not isinstance(factorset2, FactorSet):\n        raise TypeError(\"factorset1 and factorset2 must be FactorSet instances\")\n    return factorset1.divide(factorset2, inplace=False)", "response": "r Base method for division of two factor sets."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef divide(self, factorset, inplace=True):\n        factor_set = self if inplace else self.copy()\n        factor_set1 = factorset.copy()\n\n        factor_set.add_factors(*[phi.identity_factor() / phi for phi in factor_set1.factors])\n\n        if not inplace:\n            return factor_set", "response": "r Divides two factor sets and returns a new FactorSet instance after division by the factor set."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add_node(self, node, **attr):\n        super(DynamicBayesianNetwork, self).add_node((node, 0), **attr)", "response": "Adds a single node to the Network\n           "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _nodes(self):\n        return list(set([node for node, timeslice in\n                         super(DynamicBayesianNetwork, self).nodes()]))", "response": "Returns the list of nodes present in the network."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding an edge between two nodes.", "response": "def add_edge(self, start, end, **kwargs):\n        \"\"\"\n        Add an edge between two nodes.\n\n        The nodes will be automatically added if they are not present in the network.\n\n        Parameters\n        ----------\n        start: tuple\n               Both the start and end nodes should specify the time slice as\n               (node_name, time_slice). Here, node_name can be any hashable\n               python object while the time_slice is an integer value,\n               which denotes the time slice that the node belongs to.\n\n        end: tuple\n               Both the start and end nodes should specify the time slice as\n               (node_name, time_slice). Here, node_name can be any hashable\n               python object while the time_slice is an integer value,\n               which denotes the time slice that the node belongs to.\n\n        Examples\n        --------\n        >>> from pgmpy.models import DynamicBayesianNetwork as DBN\n        >>> model = DBN()\n        >>> model.add_nodes_from(['D', 'I'])\n        >>> model.add_edge(('D',0), ('I',0))\n        >>> sorted(model.edges())\n        [(('D', 0), ('I', 0)), (('D', 1), ('I', 1))]\n        \"\"\"\n        try:\n            if len(start) != 2 or len(end) != 2:\n                raise ValueError('Nodes must be of type (node, time_slice).')\n            elif not isinstance(start[1], int) or not isinstance(end[1], int):\n                raise ValueError('Nodes must be of type (node, time_slice).')\n            elif start[1] == end[1]:\n                start = (start[0], 0)\n                end = (end[0], 0)\n            elif start[1] == end[1] - 1:\n                start = (start[0], 0)\n                end = (end[0], 1)\n            elif start[1] > end[1]:\n                raise NotImplementedError('Edges in backward direction are not allowed.')\n            elif start[1] != end[1]:\n                raise ValueError(\"Edges over multiple time slices is not currently supported\")\n        except TypeError:\n            raise ValueError('Nodes must be of type (node, time_slice).')\n\n        if start == end:\n            raise ValueError('Self Loops are not allowed')\n        elif start in super(DynamicBayesianNetwork, self).nodes() and end \\\n                in super(DynamicBayesianNetwork, self).nodes() and \\\n                nx.has_path(self, end, start):\n            raise ValueError('Loops are not allowed. Adding the edge from ({start} --> {end}) forms a loop.'.format(\n                start=str(start), end=str(end)))\n\n        super(DynamicBayesianNetwork, self).add_edge(start, end, **kwargs)\n\n        if start[1] == end[1]:\n            super(DynamicBayesianNetwork, self).add_edge((start[0], 1 - start[1]), (end[0], 1 - end[1]))\n        else:\n            super(DynamicBayesianNetwork, self).add_node((end[0], 1 - end[1]))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add_edges_from(self, ebunch, **kwargs):\n        for edge in ebunch:\n            self.add_edge(edge[0], edge[1])", "response": "Add all the edges from the given ebunch to the current node."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the intra slice edges present in the 2 - TBN.", "response": "def get_intra_edges(self, time_slice=0):\n        \"\"\"\n        Returns the intra slice edges present in the 2-TBN.\n\n        Parameter\n        ---------\n        time_slice: int (whole number)\n                The time slice for which to get intra edges. The timeslice\n                should be a positive value or zero.\n\n        Examples\n        --------\n        >>> from pgmpy.models import DynamicBayesianNetwork as DBN\n        >>> dbn = DBN()\n        >>> dbn.add_nodes_from(['D', 'G', 'I', 'S', 'L'])\n        >>> dbn.add_edges_from([(('D', 0), ('G', 0)), (('I', 0), ('G', 0)),\n        ...                     (('G', 0), ('L', 0)), (('D', 0), ('D', 1)),\n        ...                     (('I', 0), ('I', 1)), (('G', 0), ('G', 1)),\n        ...                     (('G', 0), ('L', 1)), (('L', 0), ('L', 1))])\n        >>> dbn.get_intra_edges()\n        [(('D', 0), ('G', 0)), (('G', 0), ('L', 0)), (('I', 0), ('G', 0))\n        \"\"\"\n        if not isinstance(time_slice, int) or time_slice < 0:\n            raise ValueError(\"The timeslice should be a positive value greater than or equal to zero\")\n\n        return [tuple((x[0], time_slice) for x in edge) for edge in self.edges() if edge[0][1] == edge[1][1] == 0]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_interface_nodes(self, time_slice=0):\n        if not isinstance(time_slice, int) or time_slice < 0:\n            raise ValueError(\"The timeslice should be a positive value greater than or equal to zero\")\n\n        return [(edge[0][0], time_slice) for edge in self.get_inter_edges()]", "response": "Returns the nodes in the first timeslice whose children are present in the first timeslice."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_slice_nodes(self, time_slice=0):\n        if not isinstance(time_slice, int) or time_slice < 0:\n            raise ValueError(\"The timeslice should be a positive value greater than or equal to zero\")\n\n        return [(node, time_slice) for node in self._nodes()]", "response": "Returns the nodes present in a particular timeslice."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the CPDs that have been associated with the network.", "response": "def get_cpds(self, node=None, time_slice=0):\n        \"\"\"\n        Returns the CPDs that have been associated with the network.\n\n        Parameters\n        ----------\n        node: tuple (node_name, time_slice)\n            The node should be in the following form (node_name, time_slice).\n            Here, node_name is the node that is inserted while the time_slice is\n            an integer value, which denotes the index of the time_slice that the\n            node belongs to.\n\n        time_slice: int\n            The time_slice should be a positive integer greater than or equal to zero.\n\n        Examples\n        --------\n        >>> from pgmpy.models import DynamicBayesianNetwork as DBN\n        >>> from pgmpy.factors.discrete import TabularCPD\n        >>> dbn = DBN()\n        >>> dbn.add_edges_from([(('D',0),('G',0)),(('I',0),('G',0)),(('D',0),('D',1)),(('I',0),('I',1))])\n        >>> grade_cpd =  TabularCPD(('G',0), 3, [[0.3,0.05,0.9,0.5],\n        ...                                      [0.4,0.25,0.8,0.03],\n        ...                                      [0.3,0.7,0.02,0.2]], [('I', 0),('D', 0)],[2,2])\n        >>> dbn.add_cpds(grade_cpd)\n        >>> dbn.get_cpds()\n        \"\"\"\n        # TODO: fix bugs in this\n        if node:\n            if node not in super(DynamicBayesianNetwork, self).nodes():\n                raise ValueError('Node not present in the model.')\n            else:\n                for cpd in self.cpds:\n                    if cpd.variable == node:\n                        return cpd\n        else:\n            return [cpd for cpd in self.cpds if set(list(cpd.variables)).issubset(self.get_slice_nodes(time_slice))]"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef remove_cpds(self, *cpds):\n        for cpd in cpds:\n            if isinstance(cpd, (tuple, list)):\n                cpd = self.get_cpds(cpd)\n            self.cpds.remove(cpd)", "response": "This method removes the cpds that are provided in the argument."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncheck the model for various errors.", "response": "def check_model(self):\n        \"\"\"\n        Check the model for various errors. This method checks for the following\n        errors.\n\n        * Checks if the sum of the probabilities in each associated CPD for each\n            state is equal to 1 (tol=0.01).\n        * Checks if the CPDs associated with nodes are consistent with their parents.\n\n        Returns\n        -------\n        boolean: True if everything seems to be order. Otherwise raises error\n            according to the problem.\n        \"\"\"\n        for node in super(DynamicBayesianNetwork, self).nodes():\n            cpd = self.get_cpds(node=node)\n            if isinstance(cpd, TabularCPD):\n                evidence = cpd.variables[:0:-1]\n                evidence_card = cpd.cardinality[:0:-1]\n                parents = self.get_parents(node)\n                if set(evidence) != set(parents if parents else []):\n                    raise ValueError(\"CPD associated with {node} doesn't have \"\n                                     \"proper parents associated with it.\".format(node=node))\n                if not np.allclose(cpd.to_factor().marginalize([node], inplace=False).values.flatten('C'),\n                                   np.ones(np.product(evidence_card)),\n                                   atol=0.01):\n                    raise ValueError('Sum of probabilities of states for node {node}'\n                                     ' is not equal to 1'.format(node=node))\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates a graph of all the immoralities in the DynamicBayesian Network and returns it.", "response": "def moralize(self):\n        \"\"\"\n        Removes all the immoralities in the Network and creates a moral\n        graph (UndirectedGraph).\n\n        A v-structure X->Z<-Y is an immorality if there is no directed edge\n        between X and Y.\n\n        Examples\n        --------\n        >>> from pgmpy.models import DynamicBayesianNetwork as DBN\n        >>> dbn = DBN([(('D',0), ('G',0)), (('I',0), ('G',0))])\n        >>> moral_graph = dbn.moralize()\n        >>> moral_graph.edges()\n        [(('G', 0), ('I', 0)),\n        (('G', 0), ('D', 0)),\n        (('D', 1), ('I', 1)),\n        (('D', 1), ('G', 1)),\n        (('I', 0), ('D', 0)),\n        (('G', 1), ('I', 1))]\n        \"\"\"\n        moral_graph = self.to_undirected()\n\n        for node in super(DynamicBayesianNetwork, self).nodes():\n            moral_graph.add_edges_from(combinations(\n                self.get_parents(node), 2))\n\n        return moral_graph"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef copy(self):\n        dbn = DynamicBayesianNetwork()\n        dbn.add_nodes_from(self._nodes())\n        dbn.add_edges_from(self.edges())\n        cpd_copy = [cpd.copy() for cpd in self.get_cpds()]\n        dbn.add_cpds(*cpd_copy)\n        return dbn", "response": "Returns a copy of the dynamic bayesian network."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ngenerate a list of legal operations for a given model.", "response": "def _legal_operations(self, model, tabu_list=[], max_indegree=None):\n        \"\"\"Generates a list of legal (= not in tabu_list) graph modifications\n        for a given model, together with their score changes. Possible graph modifications:\n        (1) add, (2) remove, or (3) flip a single edge. For details on scoring\n        see Koller & Fridman, Probabilistic Graphical Models, Section 18.4.3.3 (page 818).\n        If a number `max_indegree` is provided, only modifications that keep the number\n        of parents for each node below `max_indegree` are considered.\"\"\"\n\n        local_score = self.scoring_method.local_score\n        nodes = self.state_names.keys()\n        potential_new_edges = (set(permutations(nodes, 2)) -\n                               set(model.edges()) -\n                               set([(Y, X) for (X, Y) in model.edges()]))\n\n        for (X, Y) in potential_new_edges:  # (1) add single edge\n            if nx.is_directed_acyclic_graph(nx.DiGraph(list(model.edges()) + [(X, Y)])):\n                operation = ('+', (X, Y))\n                if operation not in tabu_list:\n                    old_parents = model.get_parents(Y)\n                    new_parents = old_parents + [X]\n                    if max_indegree is None or len(new_parents) <= max_indegree:\n                        score_delta = local_score(Y, new_parents) - local_score(Y, old_parents)\n                        yield(operation, score_delta)\n\n        for (X, Y) in model.edges():  # (2) remove single edge\n            operation = ('-', (X, Y))\n            if operation not in tabu_list:\n                old_parents = model.get_parents(Y)\n                new_parents = old_parents[:]\n                new_parents.remove(X)\n                score_delta = local_score(Y, new_parents) - local_score(Y, old_parents)\n                yield(operation, score_delta)\n\n        for (X, Y) in model.edges():  # (3) flip single edge\n            new_edges = list(model.edges()) + [(Y, X)]\n            new_edges.remove((X, Y))\n            if nx.is_directed_acyclic_graph(nx.DiGraph(new_edges)):\n                operation = ('flip', (X, Y))\n                if operation not in tabu_list and ('flip', (Y, X)) not in tabu_list:\n                    old_X_parents = model.get_parents(X)\n                    old_Y_parents = model.get_parents(Y)\n                    new_X_parents = old_X_parents + [Y]\n                    new_Y_parents = old_Y_parents[:]\n                    new_Y_parents.remove(X)\n                    if max_indegree is None or len(new_X_parents) <= max_indegree:\n                        score_delta = (local_score(X, new_X_parents) +\n                                       local_score(Y, new_Y_parents) -\n                                       local_score(X, old_X_parents) -\n                                       local_score(Y, old_Y_parents))\n                        yield(operation, score_delta)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef estimate(self, start=None, tabu_length=0, max_indegree=None):\n        epsilon = 1e-8\n        nodes = self.state_names.keys()\n        if start is None:\n            start = DAG()\n            start.add_nodes_from(nodes)\n        elif not isinstance(start, DAG) or not set(start.nodes()) == set(nodes):\n            raise ValueError(\"'start' should be a DAG with the same variables as the data set, or 'None'.\")\n\n        tabu_list = []\n        current_model = start\n\n        while True:\n            best_score_delta = 0\n            best_operation = None\n\n            for operation, score_delta in self._legal_operations(current_model, tabu_list, max_indegree):\n                if score_delta > best_score_delta:\n                    best_operation = operation\n                    best_score_delta = score_delta\n\n            if best_operation is None or best_score_delta < epsilon:\n                break\n            elif best_operation[0] == '+':\n                current_model.add_edge(*best_operation[1])\n                tabu_list = ([('-', best_operation[1])] + tabu_list)[:tabu_length]\n            elif best_operation[0] == '-':\n                current_model.remove_edge(*best_operation[1])\n                tabu_list = ([('+', best_operation[1])] + tabu_list)[:tabu_length]\n            elif best_operation[0] == 'flip':\n                X, Y = best_operation[1]\n                current_model.remove_edge(X, Y)\n                current_model.add_edge(Y, X)\n                tabu_list = ([best_operation] + tabu_list)[:tabu_length]\n\n        return current_model", "response": "This method calculates the local hill climbing model for the structure containing the current state of the current state of the structure."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_elimination_order(self, nodes=None):\n        if not nodes:\n            nodes = self.bayesian_model.nodes()\n        nodes = set(nodes)\n\n        ordering = []\n        while nodes:\n            scores = {node: self.cost(node) for node in nodes}\n            min_score_node = min(scores, key=scores.get)\n            ordering.append(min_score_node)\n            nodes.remove(min_score_node)\n        return ordering", "response": "Returns the optimal elimination order based on the cost function."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncost function for WeightedMinFill.", "response": "def cost(self, node):\n        \"\"\"\n        Cost function for WeightedMinFill.\n        The cost of eliminating a node is the sum of weights of the edges that need to\n        be added to the graph due to its elimination, where a weight of an edge is the\n        product of the weights, domain cardinality, of its constituent vertices.\n        \"\"\"\n        edges = combinations(self.moralized_model.neighbors(node), 2)\n        return sum([self.bayesian_model.get_cardinality(edge[0]) *\n                    self.bayesian_model.get_cardinality(edge[1]) for edge in edges])"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the cost of eliminating a node.", "response": "def cost(self, node):\n        \"\"\"\n        The cost of a eliminating a node is the product of weights, domain cardinality,\n        of its neighbors.\n        \"\"\"\n        return np.prod([self.bayesian_model.get_cardinality(neig_node) for neig_node in\n                        self.moralized_model.neighbors(node)])"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a dictionary of STATICPROPERTIES", "response": "def get_static_properties(self):\n        \"\"\"\n        Returns a dictionary of STATICPROPERTIES\n\n        Examples\n        --------\n        >>> reader = XBNReader('xbn_test.xml')\n        >>> reader.get_static_properties()\n        {'FORMAT': 'MSR DTAS XML', 'VERSION': '0.2', 'CREATOR': 'Microsoft Research DTAS'}\n        \"\"\"\n        return {tags.tag: tags.get('VALUE') for tags in self.bnmodel.find('STATICPROPERTIES')}"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a list of variables.", "response": "def get_variables(self):\n        \"\"\"\n        Returns a list of variables.\n\n        Examples\n        --------\n        >>> reader = XBNReader('xbn_test.xml')\n        >>> reader.get_variables()\n        {'a': {'TYPE': 'discrete', 'XPOS': '13495',\n               'YPOS': '10465', 'DESCRIPTION': '(a) Metastatic Cancer',\n               'STATES': ['Present', 'Absent']}\n        'b': {'TYPE': 'discrete', 'XPOS': '11290',\n               'YPOS': '11965', 'DESCRIPTION': '(b) Serum Calcium Increase',\n               'STATES': ['Present', 'Absent']},\n        'c': {....},\n        'd': {....},\n        'e': {....}\n        }\n        \"\"\"\n        variables = {}\n        for variable in self.bnmodel.find('VARIABLES'):\n            variables[variable.get('NAME')] = {'TYPE': variable.get('TYPE'),\n                                               'XPOS': variable.get('XPOS'),\n                                               'YPOS': variable.get('YPOS'),\n                                               'DESCRIPTION': variable.find('DESCRIPTION').text,\n                                               'STATES': [state.text for state in variable.findall('STATENAME')]}\n        return variables"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a list of tuples containing two elements parent and child for each edge.", "response": "def get_edges(self):\n        \"\"\"\n        Returns a list of tuples. Each tuple contains two elements (parent, child) for each edge.\n\n        Examples\n        --------\n        >>> reader = XBNReader('xbn_test.xml')\n        >>> reader.get_edges()\n        [('a', 'b'), ('a', 'c'), ('b', 'd'), ('c', 'd'), ('c', 'e')]\n        \"\"\"\n        return [(arc.get('PARENT'), arc.get('CHILD')) for arc in self.bnmodel.find('STRUCTURE')]"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a dictionary of name and its distribution.", "response": "def get_distributions(self):\n        \"\"\"\n        Returns a dictionary of name and its distribution. Distribution is a ndarray.\n\n        The ndarray is stored in the standard way such that the rightmost variable changes most often.\n        Consider a CPD of variable 'd' which has parents 'b' and 'c' (distribution['CONDSET'] = ['b', 'c'])\n\n                  |  d_0     d_1\n        ---------------------------\n        b_0, c_0  |  0.8     0.2\n        b_0, c_1  |  0.9     0.1\n        b_1, c_0  |  0.7     0.3\n        b_1, c_1  |  0.05    0.95\n\n        The value of distribution['d']['DPIS'] for the above example will be:\n        array([[ 0.8 ,  0.2 ], [ 0.9 ,  0.1 ], [ 0.7 ,  0.3 ], [ 0.05,  0.95]])\n\n        Examples\n        --------\n        >>> reader = XBNReader('xbn_test.xml')\n        >>> reader.get_distributions()\n        {'a': {'TYPE': 'discrete', 'DPIS': array([[ 0.2,  0.8]])},\n         'e': {'TYPE': 'discrete', 'DPIS': array([[ 0.8,  0.2],\n                 [ 0.6,  0.4]]), 'CONDSET': ['c'], 'CARDINALITY': [2]},\n         'b': {'TYPE': 'discrete', 'DPIS': array([[ 0.8,  0.2],\n                 [ 0.2,  0.8]]), 'CONDSET': ['a'], 'CARDINALITY': [2]},\n         'c': {'TYPE': 'discrete', 'DPIS': array([[ 0.2 ,  0.8 ],\n                 [ 0.05,  0.95]]), 'CONDSET': ['a'], 'CARDINALITY': [2]},\n         'd': {'TYPE': 'discrete', 'DPIS': array([[ 0.8 ,  0.2 ],\n                 [ 0.9 ,  0.1 ],\n                 [ 0.7 ,  0.3 ],\n                 [ 0.05,  0.95]]), 'CONDSET': ['b', 'c']}, 'CARDINALITY': [2, 2]}\n        \"\"\"\n        distribution = {}\n        for dist in self.bnmodel.find('DISTRIBUTIONS'):\n            variable_name = dist.find('PRIVATE').get('NAME')\n            distribution[variable_name] = {'TYPE': dist.get('TYPE')}\n            if dist.find('CONDSET') is not None:\n                distribution[variable_name]['CONDSET'] = [var.get('NAME') for\n                                                          var in dist.find('CONDSET').findall('CONDELEM')]\n                distribution[variable_name]['CARDINALITY'] = np.array(\n                    [len(set(np.array([list(map(int, dpi.get('INDEXES').split()))\n                                       for dpi in dist.find('DPIS')])[:, i]))\n                     for i in range(len(distribution[variable_name]['CONDSET']))])\n            distribution[variable_name]['DPIS'] = np.array(\n                [list(map(float, dpi.text.split())) for dpi in dist.find('DPIS')])\n\n        return distribution"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn an instance of Bayesian Model.", "response": "def get_model(self):\n        \"\"\"\n        Returns an instance of Bayesian Model.\n        \"\"\"\n        model = BayesianModel()\n        model.add_nodes_from(self.variables)\n        model.add_edges_from(self.edges)\n        model.name = self.model_name\n\n        tabular_cpds = []\n        for var, values in self.variable_CPD.items():\n            evidence = values['CONDSET'] if 'CONDSET' in values else []\n            cpd = values['DPIS']\n            evidence_card = values['CARDINALITY'] if 'CARDINALITY' in values else []\n            states = self.variables[var]['STATES']\n            cpd = TabularCPD(var, len(states), cpd,\n                             evidence=evidence,\n                             evidence_card=evidence_card)\n            tabular_cpds.append(cpd)\n\n        model.add_cpds(*tabular_cpds)\n\n        if nx.__version__.startswith('1'):\n            for var, properties in self.variables.items():\n                model.node[var] = properties\n        else:\n            for var, properties in self.variables.items():\n                model._node[var] = properties\n\n        return model"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_analysisnotebook(self, **data):\n        for key, value in data.items():\n            self.network.set(str(key), str(value))", "response": "Set the attributes for ANALYSISNOTEBOOK tag\n       "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset the STATICPROPERTIES tag for the network.", "response": "def set_static_properties(self, **data):\n        \"\"\"\n        Set STATICPROPERTIES tag for the network\n\n        Parameters\n        ----------\n        **data: dict\n            {name: value} for name and value of the property.\n\n        Examples\n        --------\n        >>> from pgmpy.readwrite.XMLBeliefNetwork import XBNWriter\n        >>> writer = XBNWriter()\n        >>> writer.set_static_properties(FORMAT=\"MSR DTAS XML\", VERSION=\"0.2\", CREATOR=\"Microsoft Research DTAS\")\n        \"\"\"\n        static_prop = etree.SubElement(self.bnmodel, 'STATICPROPERTIES')\n        for key, value in data.items():\n            etree.SubElement(static_prop, key, attrib={'VALUE': value})"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting variables for the current object.", "response": "def set_variables(self, data):\n        \"\"\"\n        Set variables for the network.\n\n        Parameters\n        ----------\n        data: dict\n            dict for variable in the form of example as shown.\n\n        Examples\n        --------\n        >>> from pgmpy.readwrite.XMLBeliefNetwork import XBNWriter\n        >>> writer = XBNWriter()\n        >>> writer.set_variables({'a': {'TYPE': 'discrete', 'XPOS': '13495',\n        ...                             'YPOS': '10465', 'DESCRIPTION': '(a) Metastatic Cancer',\n        ...                             'STATES': ['Present', 'Absent']}\n        ...                       'b': {'TYPE': 'discrete', 'XPOS': '11290',\n        ...                             'YPOS': '11965', 'DESCRIPTION': '(b) Serum Calcium Increase',\n        ...                             'STATES': ['Present', 'Absent']}})\n        \"\"\"\n        variables = etree.SubElement(self.bnmodel, \"VARIABLES\")\n        for var in sorted(data):\n            variable = etree.SubElement(variables, 'VAR', attrib={'NAME': var, 'TYPE': data[var]['TYPE'],\n                                                                  'XPOS': data[var]['XPOS'], 'YPOS': data[var]['YPOS']})\n            etree.SubElement(variable, 'DESCRIPTION', attrib={'DESCRIPTION': data[var]['DESCRIPTION']})\n            for state in data[var]['STATES']:\n                etree.SubElement(variable, 'STATENAME').text = state"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_edges(self, edge_list):\n        structure = etree.SubElement(self.bnmodel, 'STRUCTURE')\n        for edge in edge_list:\n            etree.SubElement(structure, 'ARC', attrib={'PARENT': edge[0], 'CHILD': edge[1]})", "response": "Set edges in the network."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_distributions(self):\n        distributions = etree.SubElement(self.bnmodel, 'DISTRIBUTIONS')\n\n        cpds = self.model.get_cpds()\n        cpds.sort(key=lambda x: x.variable)\n        for cpd in cpds:\n            cpd_values = cpd.values.ravel()\n            var = cpd.variable\n            dist = etree.SubElement(distributions, 'DIST', attrib={'TYPE': self.model.node[var]['TYPE']})\n            etree.SubElement(dist, 'PRIVATE', attrib={'NAME': var})\n            dpis = etree.SubElement(dist, 'DPIS')\n            evidence = cpd.variables[:0:-1]\n            if evidence:\n                condset = etree.SubElement(dist, 'CONDSET')\n                for condelem in sorted(evidence):\n                    etree.SubElement(condset, 'CONDELEM', attrib={'NAME': condelem})\n                # TODO: Get Index value.\n                for val in range(0, len(cpd_values), 2):\n                    etree.SubElement(dpis, \"DPI\", attrib={'INDEXES': ' '}).text = \\\n                        \" \" + str(cpd_values[val]) + \" \" + str(cpd_values[val+1]) + \" \"\n            else:\n                etree.SubElement(dpis, \"DPI\").text = ' ' + ' '.join(map(str, cpd_values))", "response": "Set distributions in the network."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_edge(self, u, v, **kwargs):\n        if u != v:\n            super(FactorGraph, self).add_edge(u, v, **kwargs)\n        else:\n            raise ValueError('Self loops are not allowed')", "response": "Add an edge between variable_node and factor_node."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nchecking the model for various errors.", "response": "def check_model(self):\n        \"\"\"\n        Check the model for various errors. This method checks for the following\n        errors. In the same time it also updates the cardinalities of all the\n        random variables.\n\n        * Check whether bipartite property of factor graph is still maintained\n          or not.\n        * Check whether factors are associated for all the random variables or not.\n        * Check if factors are defined for each factor node or not.\n        * Check if cardinality information for all the variables is availble or not.\n        * Check if cardinality of random variable remains same across all the\n          factors.\n        \"\"\"\n        variable_nodes = set([x for factor in self.factors for x in factor.scope()])\n        factor_nodes = set(self.nodes()) - variable_nodes\n\n        if not all(isinstance(factor_node, DiscreteFactor) for factor_node in factor_nodes):\n            raise ValueError('Factors not associated for all the random variables')\n\n        if (not (bipartite.is_bipartite(self)) or\n            not (bipartite.is_bipartite_node_set(self, variable_nodes) or\n                 bipartite.is_bipartite_node_set(self, variable_nodes))):\n            raise ValueError('Edges can only be between variables and factors')\n\n        if len(factor_nodes) != len(self.factors):\n            raise ValueError('Factors not associated with all the factor nodes.')\n\n        cardinalities = self.get_cardinality()\n        if len(variable_nodes) != len(cardinalities):\n            raise ValueError('Factors for all the variables not defined')\n\n        for factor in self.factors:\n            for variable, cardinality in zip(factor.scope(), factor.cardinality):\n                if (cardinalities[variable] != cardinality):\n                    raise ValueError('Cardinality of variable {var} not matching among factors'.format(var=variable))\n\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_variable_nodes(self):\n        self.check_model()\n\n        variable_nodes = set([x for factor in self.factors for x in factor.scope()])\n        return list(variable_nodes)", "response": "Returns a list of variable nodes present in the graph."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_factor_nodes(self):\n        self.check_model()\n\n        variable_nodes = self.get_variable_nodes()\n        factor_nodes = set(self.nodes()) - set(variable_nodes)\n        return list(factor_nodes)", "response": "Returns a list of all the factors nodes present in the graph."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef to_markov_model(self):\n        mm = MarkovModel()\n\n        variable_nodes = self.get_variable_nodes()\n\n        if len(set(self.nodes()) - set(variable_nodes)) != len(self.factors):\n            raise ValueError('Factors not associated with all the factor nodes.')\n\n        mm.add_nodes_from(variable_nodes)\n        for factor in self.factors:\n            scope = factor.scope()\n            mm.add_edges_from(itertools.combinations(scope, 2))\n            mm.add_factors(factor)\n\n        return mm", "response": "Converts the factor graph into a markov model."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the factors that have been added till now to the graph.", "response": "def get_factors(self, node=None):\n        \"\"\"\n        Returns the factors that have been added till now to the graph.\n\n        If node is not None, it would return the factor corresponding to the\n        given node.\n\n        Examples\n        --------\n        >>> from pgmpy.models import FactorGraph\n        >>> from pgmpy.factors.discrete import DiscreteFactor\n        >>> G = FactorGraph()\n        >>> G.add_nodes_from(['a', 'b', 'c'])\n        >>> phi1 = DiscreteFactor(['a', 'b'], [2, 2], np.random.rand(4))\n        >>> phi2 = DiscreteFactor(['b', 'c'], [2, 2], np.random.rand(4))\n        >>> G.add_factors(phi1, phi2)\n        >>> G.add_nodes_from([phi1, phi2])\n        >>> G.add_edges_from([('a', phi1), ('b', phi1),\n        ...                   ('b', phi2), ('c', phi2)])\n        >>> G.get_factors()\n        >>> G.get_factors(node=phi1)\n        \"\"\"\n        if node is None:\n            return self.factors\n        else:\n            factor_nodes = self.get_factor_nodes()\n            if node not in factor_nodes:\n                raise ValueError('Factors are not associated with the '\n                                 'corresponding node.')\n            factors = list(filter(lambda x: set(x.scope()) == set(self.neighbors(node)),\n                                  self.factors))\n            return factors[0]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef local_score(self, variable, parents):\n        \"Computes a score that measures how much a \\\n        given variable is \\\"influenced\\\" by a given list of potential parents.\"\n\n        var_states = self.state_names[variable]\n        var_cardinality = len(var_states)\n        state_counts = self.state_counts(variable, parents)\n        num_parents_states = float(len(state_counts.columns))\n\n        score = 0\n        for parents_state in state_counts:  # iterate over df columns (only 1 if no parents)\n            conditional_sample_size = sum(state_counts[parents_state])\n\n            score += (lgamma(self.equivalent_sample_size / num_parents_states) -\n                      lgamma(conditional_sample_size + self.equivalent_sample_size / num_parents_states))\n\n            for state in var_states:\n                if state_counts[parents_state][state] > 0:\n                    score += (lgamma(state_counts[parents_state][state] +\n                                     self.equivalent_sample_size / (num_parents_states * var_cardinality)) -\n                              lgamma(self.equivalent_sample_size / (num_parents_states * var_cardinality)))\n        return score", "response": "Computes a score that measures how much a \\\n given variable is influenced by a given list of potential parents."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the cliques in the junction tree which are a subset of the given nodes.", "response": "def _get_clique(self, junction_tree, nodes):\n        \"\"\"\n        Extracting the cliques from the junction tree which are a subset of\n        the given nodes.\n\n        Parameters:\n        ----------\n        junction_tree: Junction tree\n            from which the nodes are to be extracted.\n\n        nodes: iterable container\n            A container of nodes (list, dict, set, etc.).\n        \"\"\"\n\n        return [clique for clique in junction_tree.nodes() if set(nodes).issubset(clique)][0]"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the evidence dict for a particular time slice and shift.", "response": "def _get_evidence(self, evidence_dict, time_slice, shift):\n        \"\"\"\n        Getting the evidence belonging to a particular timeslice.\n\n        Parameters:\n        ----------\n        evidence: dict\n            a dict key, value pair as {var: state_of_var_observed}\n            None if no evidence\n\n        time: int\n            the evidence corresponding to the time slice\n\n        shift: int\n            shifting the evidence corresponding to the given time slice.\n        \"\"\"\n        if evidence_dict:\n            return {(node[0], shift): evidence_dict[node] for node in evidence_dict if node[1] == time_slice}"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _marginalize_factor(self, nodes, factor):\n        marginalizing_nodes = list(set(factor.scope()).difference(nodes))\n        return factor.marginalize(marginalizing_nodes, inplace=False)", "response": "Marginalizes the factor selectively for a set of variables."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the required factor for the given belief prop and evidence.", "response": "def _get_factor(self, belief_prop, evidence):\n        \"\"\"\n        Extracts the required factor from the junction tree.\n\n        Parameters:\n        ----------\n        belief_prop: Belief Propagation\n            Belief Propagation which needs to be updated.\n\n        evidence: dict\n            a dict key, value pair as {var: state_of_var_observed}\n        \"\"\"\n        final_factor = factor_product(*belief_prop.junction_tree.get_factors())\n        if evidence:\n            for var in evidence:\n                if var in final_factor.scope():\n                    final_factor.reduce([(var, evidence[var])])\n        return final_factor"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _shift_factor(self, factor, shift):\n        new_scope = self._shift_nodes(factor.scope(), shift)\n        return DiscreteFactor(new_scope, factor.cardinality, factor.values)", "response": "Shifts a factor to a certain required time slice."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef forward_inference(self, variables, evidence=None, args=None):\n        variable_dict = defaultdict(list)\n        for var in variables:\n            variable_dict[var[1]].append(var)\n\n        time_range = max(variable_dict)\n        if evidence:\n            evid_time_range = max([time_slice for var, time_slice in evidence.keys()])\n            time_range = max(time_range, evid_time_range)\n\n        start_bp = BeliefPropagation(self.start_junction_tree)\n        mid_bp = BeliefPropagation(self.one_and_half_junction_tree)\n        evidence_0 = self._get_evidence(evidence, 0, 0)\n        interface_nodes_dict = {}\n        potential_dict = {}\n\n        if evidence:\n            interface_nodes_dict = {k: v for k, v in evidence_0.items() if k in self.interface_nodes_0}\n        initial_factor = self._get_factor(start_bp, evidence_0)\n        marginalized_factor = self._marginalize_factor(self.interface_nodes_0, initial_factor)\n        potential_dict[0] = marginalized_factor\n        self._update_belief(mid_bp, self.in_clique, marginalized_factor)\n\n        if variable_dict[0]:\n            factor_values = start_bp.query(variable_dict[0], evidence=evidence_0, joint=False)\n        else:\n            factor_values = {}\n\n        for time_slice in range(1, time_range + 1):\n            evidence_time = self._get_evidence(evidence, time_slice, 1)\n            if interface_nodes_dict:\n                evidence_time.update(interface_nodes_dict)\n\n            if variable_dict[time_slice]:\n                variable_time = self._shift_nodes(variable_dict[time_slice], 1)\n                new_values = mid_bp.query(variable_time, evidence=evidence_time, joint=False)\n                changed_values = {}\n                for key in new_values.keys():\n                    new_key = (key[0], time_slice)\n                    new_factor = DiscreteFactor([new_key], new_values[key].cardinality, new_values[key].values)\n                    changed_values[new_key] = new_factor\n                factor_values.update(changed_values)\n\n            clique_phi = self._get_factor(mid_bp, evidence_time)\n            out_clique_phi = self._marginalize_factor(self.interface_nodes_1, clique_phi)\n            new_factor = self._shift_factor(out_clique_phi, 0)\n            potential_dict[time_slice] = new_factor\n            mid_bp = BeliefPropagation(self.one_and_half_junction_tree)\n            self._update_belief(mid_bp, self.in_clique, new_factor)\n\n            if evidence_time:\n                interface_nodes_dict = {(k[0], 0): v for k, v in evidence_time.items() if k in self.interface_nodes_1}\n            else:\n                interface_nodes_dict = {}\n\n        if args == 'potential':\n            return potential_dict\n\n        return factor_values", "response": "Forward inference method using belief propagation."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef backward_inference(self, variables, evidence=None):\n        variable_dict = defaultdict(list)\n        for var in variables:\n            variable_dict[var[1]].append(var)\n        time_range = max(variable_dict)\n        interface_nodes_dict = {}\n        if evidence:\n            evid_time_range = max([time_slice for var, time_slice in evidence.keys()])\n            time_range = max(time_range, evid_time_range)\n        end_bp = BeliefPropagation(self.start_junction_tree)\n        potential_dict = self.forward_inference(variables, evidence, 'potential')\n        update_factor = self._shift_factor(potential_dict[time_range], 1)\n        factor_values = {}\n\n        for time_slice in range(time_range, 0, -1):\n            evidence_time = self._get_evidence(evidence, time_slice, 1)\n            evidence_prev_time = self._get_evidence(evidence, time_slice - 1, 0)\n            if evidence_prev_time:\n                interface_nodes_dict = {k: v for k, v in evidence_prev_time.items() if k in self.interface_nodes_0}\n            if evidence_time:\n                evidence_time.update(interface_nodes_dict)\n            mid_bp = BeliefPropagation(self.one_and_half_junction_tree)\n            self._update_belief(mid_bp, self.in_clique, potential_dict[time_slice - 1])\n            forward_factor = self._shift_factor(potential_dict[time_slice], 1)\n            self._update_belief(mid_bp, self.out_clique, forward_factor, update_factor)\n\n            if variable_dict[time_slice]:\n                variable_time = self._shift_nodes(variable_dict[time_slice], 1)\n                new_values = mid_bp.query(variable_time, evidence=evidence_time, joint=False)\n                changed_values = {}\n                for key in new_values.keys():\n                    new_key = (key[0], time_slice)\n                    new_factor = DiscreteFactor([new_key], new_values[key].cardinality, new_values[key].values)\n                    changed_values[new_key] = new_factor\n                factor_values.update(changed_values)\n\n            clique_phi = self._get_factor(mid_bp, evidence_time)\n            in_clique_phi = self._marginalize_factor(self.interface_nodes_0, clique_phi)\n            update_factor = self._shift_factor(in_clique_phi, 1)\n\n        out_clique_phi = self._shift_factor(update_factor, 0)\n        self._update_belief(end_bp, self.start_interface_clique, potential_dict[0], out_clique_phi)\n        evidence_0 = self._get_evidence(evidence, 0, 0)\n        if variable_dict[0]:\n            factor_values.update(end_bp.query(variable_dict[0], evidence_0, joint=False))\n        return factor_values", "response": "This method uses the backward inference method using belief propagation."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef query(self, variables, evidence=None, args='exact'):\n        if args == 'exact':\n            return self.backward_inference(variables, evidence)", "response": "Query Dynamic Bayesian Network using Interface Algorithm."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef add_node(self, node, weight=None):\n\n        # Check for networkx 2.0 syntax\n        if isinstance(node, tuple) and len(node) == 2 and isinstance(node[1], dict):\n            node, attrs = node\n            if attrs.get('weight', None) is not None:\n                attrs['weight'] = weight\n        else:\n            attrs = {'weight': weight}\n\n        super(DAG, self).add_node(node, weight=weight)", "response": "Add a node to the DAG."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds multiple nodes to the Graph.", "response": "def add_nodes_from(self, nodes, weights=None):\n        \"\"\"\n        Add multiple nodes to the Graph.\n\n        **The behviour of adding weights is different than in networkx.\n\n        Parameters\n        ----------\n        nodes: iterable container\n            A container of nodes (list, dict, set, or any hashable python\n            object).\n\n        weights: list, tuple (default=None)\n            A container of weights (int, float). The weight value at index i\n            is associated with the variable at index i.\n\n        Examples\n        --------\n        >>> from pgmpy.base import DAG\n        >>> G = DAG()\n        >>> G.add_nodes_from(nodes=['A', 'B', 'C'])\n        >>> sorted(G.nodes())\n        ['A', 'B', 'C']\n\n        Adding nodes with weights:\n        >>> G.add_nodes_from(nodes=['D', 'E'], weights=[0.3, 0.6])\n        >>> G.node['D']\n        {'weight': 0.3}\n        >>> G.node['E']\n        {'weight': 0.6}\n        >>> G.node['A']\n        {'weight': None}\n        \"\"\"\n        nodes = list(nodes)\n\n        if weights:\n            if len(nodes) != len(weights):\n                raise ValueError(\"The number of elements in nodes and weights\"\n                                 \"should be equal.\")\n            for index in range(len(nodes)):\n                self.add_node(node=nodes[index], weight=weights[index])\n        else:\n            for node in nodes:\n                self.add_node(node=node)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add_edge(self, u, v, weight=None):\n        super(DAG, self).add_edge(u, v, weight=weight)", "response": "Add an edge between u and v."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_edges_from(self, ebunch, weights=None):\n        ebunch = list(ebunch)\n\n        if weights:\n            if len(ebunch) != len(weights):\n                raise ValueError(\"The number of elements in ebunch and weights\"\n                                 \"should be equal\")\n            for index in range(len(ebunch)):\n                self.add_edge(ebunch[index][0], ebunch[index][1],\n                              weight=weights[index])\n        else:\n            for edge in ebunch:\n                self.add_edge(edge[0], edge[1])", "response": "Add all the edges from the given edge containers to the graph."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating a MoralGraph that contains all the immoralities in the DAG and all the parents of the node.", "response": "def moralize(self):\n        \"\"\"\n        Removes all the immoralities in the DAG and creates a moral\n        graph (UndirectedGraph).\n\n        A v-structure X->Z<-Y is an immorality if there is no directed edge\n        between X and Y.\n\n        Examples\n        --------\n        >>> from pgmpy.base import DAG\n        >>> G = DAG(ebunch=[('diff', 'grade'), ('intel', 'grade')])\n        >>> moral_graph = G.moralize()\n        >>> moral_graph.edges()\n        [('intel', 'grade'), ('intel', 'diff'), ('grade', 'diff')]\n        \"\"\"\n        moral_graph = UndirectedGraph(self.to_undirected().edges())\n\n        for node in self.nodes():\n            moral_graph.add_edges_from(\n                itertools.combinations(self.get_parents(node), 2))\n\n        return moral_graph"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a list of roots of the graph.", "response": "def get_roots(self):\n        \"\"\"\n        Returns a list of roots of the graph.\n\n        Examples\n        --------\n        >>> from pgmpy.base import DAG\n        >>> graph = DAG([('A', 'B'), ('B', 'C'), ('B', 'D'), ('E', 'B')])\n        >>> graph.get_roots()\n        ['A', 'E']\n        \"\"\"\n        return [node for node, in_degree in dict(self.in_degree()).items() if in_degree == 0]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_independencies(self, latex=False):\n        independencies = Independencies()\n        for start in (self.nodes()):\n            rest = set(self.nodes()) - {start}\n            for r in range(len(rest)):\n                for observed in itertools.combinations(rest, r):\n                    d_seperated_variables = rest - set(observed) - set(\n                        self.active_trail_nodes(start, observed=observed)[start])\n                    if d_seperated_variables:\n                        independencies.add_assertions([start, d_seperated_variables, observed])\n\n        independencies.reduce()\n\n        if not latex:\n            return independencies\n        else:\n            return independencies.latex_string()", "response": "Computes the independencies of the current node."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef local_independencies(self, variables):\n        def dfs(node):\n            \"\"\"\n            Returns the descendents of node.\n\n            This is a very simple dfs\n            which does not remember which nodes it has visited.\n            \"\"\"\n            descendents = []\n            visit = [node]\n            while visit:\n                n = visit.pop()\n                neighbors = list(self.neighbors(n))\n                visit.extend(neighbors)\n                descendents.extend(neighbors)\n            return descendents\n\n        independencies = Independencies()\n        for variable in variables if isinstance(variables, (list, tuple)) else [variables]:\n            non_descendents = set(self.nodes()) - {variable} - set(dfs(variable))\n            parents = set(self.get_parents(variable))\n            if non_descendents - parents:\n                independencies.add_assertions([variable, non_descendents - parents, parents])\n        return independencies", "response": "Returns an Independencies containing the local independencies of each of the variables."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nchecking whether the given model is I - equivalent.", "response": "def is_iequivalent(self, model):\n        \"\"\"\n        Checks whether the given model is I-equivalent\n\n        Two graphs G1 and G2 are said to be I-equivalent if they have same skeleton\n        and have same set of immoralities.\n\n        Note: For same skeleton different names of nodes can work but for immoralities\n        names of nodes must be same\n\n        Parameters\n        ----------\n        model : A DAG object, for which you want to check I-equivalence\n\n        Returns\n        --------\n        boolean : True if both are I-equivalent, False otherwise\n\n        Examples\n        --------\n        >>> from pgmpy.base import DAG\n        >>> G = DAG()\n        >>> G.add_edges_from([('V', 'W'), ('W', 'X'),\n        ...                   ('X', 'Y'), ('Z', 'Y')])\n        >>> G1 = DAG()\n        >>> G1.add_edges_from([('W', 'V'), ('X', 'W'),\n        ...                    ('X', 'Y'), ('Z', 'Y')])\n        >>> G.is_iequivalent(G1)\n        True\n\n        \"\"\"\n        if not isinstance(model, DAG):\n            raise TypeError('model must be an instance of DAG')\n        skeleton = nx.algorithms.isomorphism.GraphMatcher(self.to_undirected(), model.to_undirected())\n        if skeleton.is_isomorphic() and self.get_immoralities() == model.get_immoralities():\n            return True\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a set of all the immoralities in the model.", "response": "def get_immoralities(self):\n        \"\"\"\n        Finds all the immoralities in the model\n        A v-structure X -> Z <- Y is an immorality if there is no direct edge between X and Y .\n\n        Returns\n        -------\n        set: A set of all the immoralities in the model\n\n        Examples\n        ---------\n        >>> from pgmpy.base import DAG\n        >>> student = DAG()\n        >>> student.add_edges_from([('diff', 'grade'), ('intel', 'grade'),\n        ...                         ('intel', 'SAT'), ('grade', 'letter')])\n        >>> student.get_immoralities()\n        {('diff','intel')}\n        \"\"\"\n        immoralities = set()\n        for node in self.nodes():\n            for parents in itertools.combinations(self.predecessors(node), 2):\n                if not self.has_edge(parents[0], parents[1]) and not self.has_edge(parents[1], parents[0]):\n                    immoralities.add(tuple(sorted(parents)))\n        return immoralities"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn True if there is any active trail between start and end node.", "response": "def is_active_trail(self, start, end, observed=None):\n        \"\"\"\n        Returns True if there is any active trail between start and end node\n        Parameters\n        ----------\n        start : Graph Node\n        end : Graph Node\n        observed : List of nodes (optional)\n            If given the active trail would be computed assuming these nodes to be observed.\n        additional_observed : List of nodes (optional)\n            If given the active trail would be computed assuming these nodes to be observed along with\n            the nodes marked as observed in the model.\n        Examples\n        --------\n        >>> from pgmpy.base import DAG\n        >>> student = DAG()\n        >>> student.add_nodes_from(['diff', 'intel', 'grades', 'letter', 'sat'])\n        >>> student.add_edges_from([('diff', 'grades'), ('intel', 'grades'), ('grades', 'letter'),\n        ...                         ('intel', 'sat')])\n        >>> student.is_active_trail('diff', 'intel')\n        False\n        >>> student.is_active_trail('grades', 'sat')\n        True\n        \"\"\"\n        if end in self.active_trail_nodes(start, observed)[start]:\n            return True\n        else:\n            return False"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_markov_blanket(self, node):\n        children = self.get_children(node)\n        parents = self.get_parents(node)\n        blanket_nodes = children + parents\n        for child_node in children:\n            blanket_nodes.extend(self.get_parents(child_node))\n        blanket_nodes = set(blanket_nodes)\n        blanket_nodes.remove(node)\n        return list(blanket_nodes)", "response": "Returns a markov blanket for a random variable."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a dictionary with the given variables as keys and all the nodes reachable from that respective variable as values and all the nodes reachable from that respective variable as values.", "response": "def active_trail_nodes(self, variables, observed=None):\n        \"\"\"\n        Returns a dictionary with the given variables as keys and all the nodes reachable\n        from that respective variable as values.\n        Parameters\n        ----------\n        variables: str or array like\n            variables whose active trails are to be found.\n        observed : List of nodes (optional)\n            If given the active trails would be computed assuming these nodes to be observed.\n        Examples\n        --------\n        >>> from pgmpy.base import DAG\n        >>> student = DAG()\n        >>> student.add_nodes_from(['diff', 'intel', 'grades'])\n        >>> student.add_edges_from([('diff', 'grades'), ('intel', 'grades')])\n        >>> student.active_trail_nodes('diff')\n        {'diff': {'diff', 'grades'}}\n        >>> student.active_trail_nodes(['diff', 'intel'], observed='grades')\n        {'diff': {'diff', 'intel'}, 'intel': {'diff', 'intel'}}\n        References\n        ----------\n        Details of the algorithm can be found in 'Probabilistic Graphical Model\n        Principles and Techniques' - Koller and Friedman\n        Page 75 Algorithm 3.1\n        \"\"\"\n        if observed:\n            observed_list = observed if isinstance(observed, (list, tuple)) else [observed]\n        else:\n            observed_list = []\n        ancestors_list = self._get_ancestors_of(observed_list)\n\n        # Direction of flow of information\n        # up ->  from parent to child\n        # down -> from child to parent\n\n        active_trails = {}\n        for start in variables if isinstance(variables, (list, tuple)) else [variables]:\n            visit_list = set()\n            visit_list.add((start, 'up'))\n            traversed_list = set()\n            active_nodes = set()\n            while visit_list:\n                node, direction = visit_list.pop()\n                if (node, direction) not in traversed_list:\n                    if node not in observed_list:\n                        active_nodes.add(node)\n                    traversed_list.add((node, direction))\n                    if direction == 'up' and node not in observed_list:\n                        for parent in self.predecessors(node):\n                            visit_list.add((parent, 'up'))\n                        for child in self.successors(node):\n                            visit_list.add((child, 'down'))\n                    elif direction == 'down':\n                        if node not in observed_list:\n                            for child in self.successors(node):\n                                visit_list.add((child, 'down'))\n                        if node in ancestors_list:\n                            for parent in self.predecessors(node):\n                                visit_list.add((parent, 'up'))\n            active_trails[start] = active_nodes\n        return active_trails"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a dictionary of all the observed nodes and their ancestors including the node itself.", "response": "def _get_ancestors_of(self, obs_nodes_list):\n        \"\"\"\n        Returns a dictionary of all ancestors of all the observed nodes including the\n        node itself.\n        Parameters\n        ----------\n        obs_nodes_list: string, list-type\n            name of all the observed nodes\n        Examples\n        --------\n        >>> from pgmpy.base import DAG\n        >>> model = DAG([('D', 'G'), ('I', 'G'), ('G', 'L'),\n        ...                        ('I', 'L')])\n        >>> model._get_ancestors_of('G')\n        {'D', 'G', 'I'}\n        >>> model._get_ancestors_of(['G', 'I'])\n        {'D', 'G', 'I'}\n        \"\"\"\n        if not isinstance(obs_nodes_list, (list, tuple)):\n            obs_nodes_list = [obs_nodes_list]\n\n        for node in obs_nodes_list:\n            if node not in self.nodes():\n                raise ValueError('Node {s} not in not in graph'.format(s=node))\n\n        ancestors_list = set()\n        nodes_list = set(obs_nodes_list)\n        while nodes_list:\n            node = nodes_list.pop()\n            if node not in ancestors_list:\n                nodes_list.update(self.predecessors(node))\n            ancestors_list.add(node)\n        return ancestors_list"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding an edge between two clique nodes.", "response": "def add_edge(self, u, v, **kwargs):\n        \"\"\"\n        Add an edge between two clique nodes.\n\n        Parameters\n        ----------\n        u, v: nodes\n            Nodes can be any list or set or tuple of nodes forming a clique.\n\n        Examples\n        --------\n        >>> from pgmpy.models import JunctionTree\n        >>> G = JunctionTree()\n        >>> G.add_nodes_from([('a', 'b', 'c'), ('a', 'b'), ('a', 'c')])\n        >>> G.add_edges_from([(('a', 'b', 'c'), ('a', 'b')),\n        ...                   (('a', 'b', 'c'), ('a', 'c'))])\n        \"\"\"\n        if u in self.nodes() and v in self.nodes() and nx.has_path(self, u, v):\n            raise ValueError('Addition of edge between {u} and {v} forms a cycle breaking the '\n                             'properties of Junction Tree'.format(u=str(u), v=str(v)))\n\n        super(JunctionTree, self).add_edge(u, v, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef check_model(self):\n        if not nx.is_connected(self):\n            raise ValueError('The Junction Tree defined is not fully connected.')\n\n        return super(JunctionTree, self).check_model()", "response": "Check the model for various errors."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a copy of JunctionTree.", "response": "def copy(self):\n        \"\"\"\n        Returns a copy of JunctionTree.\n\n        Returns\n        -------\n        JunctionTree : copy of JunctionTree\n\n        Examples\n        --------\n        >>> import numpy as np\n        >>> from pgmpy.factors.discrete import DiscreteFactor\n        >>> from pgmpy.models import JunctionTree\n        >>> G = JunctionTree()\n        >>> G.add_edges_from([(('a', 'b', 'c'), ('a', 'b')), (('a', 'b', 'c'), ('a', 'c'))])\n        >>> phi1 = DiscreteFactor(['a', 'b'], [1, 2], np.random.rand(2))\n        >>> phi2 = DiscreteFactor(['a', 'c'], [1, 2], np.random.rand(2))\n        >>> G.add_factors(phi1,phi2)\n        >>> modelCopy = G.copy()\n        >>> modelCopy.edges()\n        [(('a', 'b'), ('a', 'b', 'c')), (('a', 'c'), ('a', 'b', 'c'))]\n        >>> G.factors\n        [<DiscreteFactor representing phi(a:1, b:2) at 0xb720ee4c>,\n         <DiscreteFactor representing phi(a:1, c:2) at 0xb4e1e06c>]\n        >>> modelCopy.factors\n        [<DiscreteFactor representing phi(a:1, b:2) at 0xb4bd11ec>,\n         <DiscreteFactor representing phi(a:1, c:2) at 0xb4bd138c>]\n\n        \"\"\"\n        copy = JunctionTree(self.edges())\n        copy.add_nodes_from(self.nodes())\n        if self.factors:\n            factors_copy = [factor.copy() for factor in self.factors]\n            copy.add_factors(*factors_copy)\n        return copy"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngenerating ProbModelXML lines for a given model.", "response": "def generate_probmodelxml(model, encoding='utf-8', prettyprint=True):\n    \"\"\"\n    Generate ProbModelXML lines for model.\n\n    Parameters\n    ----------\n    model : Graph\n        The Bayesian or Markov Model\n    encoding : string (optional)\n        Encoding for text data\n    prettyprint: bool (optional)\n        If True uses line breaks and indenting in output XML.\n\n    Examples\n    --------\n    >>> G = nx.path_graph(5)\n    >>> s = pgmpy.readwrite.generate_ProbModelXML(G) # doctest: +SKIP\n    >>> for line in pgmpy.readwrite.generate_ProbModelXML(G):  #doctest: +SKIP\n    ...     print(line)\n    \"\"\"\n    writer = ProbModelXMLWriter(G, encoding=encoding, prettyprint=prettyprint)\n    for line in str(writer).splitlines():\n        yield line"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nwriting a ProbModelXML model to path.", "response": "def write_probmodelxml(model, path, encoding='utf-8', prettyprint=True):\n    \"\"\"\n    Write model in ProbModelXML format to path.\n\n    Parameters\n    ----------\n    model : A NetworkX graph\n            Bayesian network or Markov network\n    path : file or string\n            File or filename to write.\n            Filenames ending in .gz or .bz2 will be compressed.\n    encoding : string (optional)\n            Encoding for text data.\n    prettyprint : bool (optional)\n            If True use line breaks and indenting in output XML.\n\n    Examples\n    --------\n    >>> G = nx.path_graph(4)\n    >>> pgmpy.readwrite.write_probmodelxml(G, \"test.probmodelxml\")\n    \"\"\"\n    writer = ProbModelXMLWriter(model, path, encoding=encoding,\n                                prettyprint=prettyprint)\n    writer.dump(path)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_probmodel_data(model):\n    if not isinstance(model, BayesianModel):\n        raise TypeError(\"Model must an instance of BayesianModel.\")\n    model_data = {'probnet': {'type': 'BayesianNetwork', 'Variables': {}}}\n\n    variables = model.nodes()\n    for var in variables:\n        model_data['probnet']['Variables'][var] = model.node[var]\n\n    model_data['probnet']['edges'] = {}\n    edges = model.edges()\n    for edge in edges:\n        model_data['probnet']['edges'][str(edge)] = model.adj[edge[0]][edge[1]]\n\n    model_data['probnet']['Potentials'] = []\n    cpds = model.get_cpds()\n    for cpd in cpds:\n        potential_dict = {}\n        potential_dict['Variables'] = {}\n        evidence = cpd.variables[:0:-1]\n        if evidence:\n            potential_dict['Variables'][cpd.variable] = evidence\n        else:\n            potential_dict['Variables'][cpd.variable] = []\n        potential_dict['type'] = \"Table\"\n        potential_dict['role'] = \"conditionalProbability\"\n        potential_dict['Values'] = \" \".join([str(val) for val in cpd.values.ravel().astype(float)]) + \" \"\n        model_data['probnet']['Potentials'].append(potential_dict)\n\n    return model_data", "response": "Returns the model_data dictionary containing model data for the given Bayesian model."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _add_additional_properties(position, properties_dict):\n        add_prop = etree.SubElement(position, 'AdditionalProperties')\n        for key, value in properties_dict.items():\n            etree.SubElement(add_prop, 'Property', attrib={'name': key, 'value': value})", "response": "Adds AdditionalProperties to the ProbModelXML."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding a node to the ProbModelXML.", "response": "def _add_variable(self, variable):\n        \"\"\"\n        Adds a node to the ProbModelXML.\n        \"\"\"\n        # TODO: Add feature for accepting additional properties of states.\n        variable_data = self.data['probnet']['Variables'][variable]\n        variable_element = etree.SubElement(self.variables, 'Variable', attrib={'name': variable,\n                                                                                'type': variable_data['type'],\n                                                                                'role': variable_data['role']})\n\n        try:\n            etree.SubElement(variable_element, 'Comment').text = variable_data['Comment']\n        except KeyError:\n            pass\n        try:\n            etree.SubElement(variable_element, 'Coordinates', variable_data['Coordinates'])\n        except KeyError:\n            pass\n\n        try:\n            for key, value in sorted(variable_data['AdditionalProperties'].items()):\n                etree.SubElement(variable_element, 'Property', attrib={'name': key, 'value': value})\n        except KeyError:\n            etree.SubElement(variable_element, 'AdditionalProperties')\n        states = etree.SubElement(variable_element, 'States')\n        for s in sorted(variable_data['States']):\n            state = etree.SubElement(states, 'State', attrib={'name': s})\n            try:\n                self._add_additional_properties(state, variable_data['States'][s]['AdditionalProperties'])\n            except KeyError:\n                etree.SubElement(state, 'AdditionalProperties')"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _add_link(self, edge):\n        edge_data = self.data['probnet']['edges'][edge]\n        if isinstance(edge, six.string_types):\n            edge = eval(edge)\n        link = etree.SubElement(self.links, 'Link', attrib={'var1': edge[0], 'var2': edge[1],\n                                                            'directed': edge_data['directed']})\n        try:\n            etree.SubElement(link, 'Comment').text = edge_data['Comment']\n        except KeyError:\n            pass\n        try:\n            etree.SubElement(link, 'Label').text = edge_data['Label']\n        except KeyError:\n            pass\n        try:\n            self._add_additional_properties(link, edge_data['AdditionalProperties'])\n        except KeyError:\n            etree.SubElement(link, 'AdditionalProperties')", "response": "Adds an edge to the ProbModelXML."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _add_constraint(self, constraint):\n        constraint_data = self.data['probnet']['AdditionalConstraints'][constraint]\n        constraint_element = etree.SubElement(\n            self.additional_constraints, 'Constraint', attrib={'name': constraint})\n        for argument in sorted(constraint_data):\n            name = argument\n            value = constraint_data[name]\n            etree.SubElement(constraint_element, 'Argument', attrib={'name': name, 'value': value})", "response": "Adds constraint to the ProbModelXML."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _add_decision_criteria(self, criteria_dict):\n        decision_tag = etree.SubElement(self.xml, 'DecisionCriteria', attrib={})\n        for criteria in sorted(criteria_dict):\n            criteria_tag = etree.SubElement(decision_tag, 'Criterion', attrib={'name': criteria})\n            self._add_additional_properties(criteria_tag, criteria_dict[criteria])", "response": "Adds Decision Criteria to the ProbModelXML."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd Potentials to the ProbModelXML.", "response": "def _add_potential(self, potential, parent_tag):\n        \"\"\"\n        Adds Potentials to the ProbModelXML.\n\n        Parameters\n        ----------\n        potential: dict\n            Dictionary containing Potential data.\n            For example: {'role': 'Utility',\n                          'Variables': ['D0', 'D1', 'C0', 'C1'],\n                          'type': 'Tree/ADD',\n                          'UtilityVaribale': 'U1'}\n        parent_tag: etree Element\n            etree element which would contain potential tag\n            For example: <Element Potentials at 0x7f315fc44b08>\n                         <Element Branch at 0x7f315fc44c88>\n                         <Element Branch at 0x7f315fc44d88>\n                         <Element Subpotentials at 0x7f315fc44e48>\n\n        Examples\n        --------\n        >>> writer = ProbModelXMLWriter(model)\n        >>> writer._add_potential(potential, parent_tag)\n        \"\"\"\n        potential_type = potential['type']\n        try:\n            potential_tag = etree.SubElement(parent_tag, 'Potential', attrib={\n                'type': potential['type'], 'role': potential['role']})\n        except KeyError:\n            potential_tag = etree.SubElement(parent_tag, 'Potential', attrib={\n                'type': potential['type']})\n        self._add_element(potential, 'Comment', potential_tag)\n        if 'AdditionalProperties' in potential:\n            self._add_additional_properties(potential_tag, potential['AdditionalProperties'])\n        if potential_type == \"delta\":\n            etree.SubElement(potential_tag, 'Variable', attrib={'name': potential['Variable']})\n            self._add_element(potential, 'State', potential_tag)\n            self._add_element(potential, 'StateIndex', potential_tag)\n            self._add_element(potential, 'NumericValue', potential_tag)\n        else:\n            if 'UtilityVariable' in potential:\n                etree.SubElement(potential_tag, 'UtilityVariable', attrib={\n                    'name': potential['UtilityVariable']})\n            if 'Variables' in potential:\n                variable_tag = etree.SubElement(potential_tag, 'Variables')\n                for var in sorted(potential['Variables']):\n                    etree.SubElement(variable_tag, 'Variable', attrib={'name': var})\n                    for child in sorted(potential['Variables'][var]):\n                        etree.SubElement(variable_tag, 'Variable', attrib={'name': child})\n            self._add_element(potential, 'Values', potential_tag)\n            if 'UncertainValues' in potential:\n                value_tag = etree.SubElement(potential_tag, 'UncertainValues', attrib={})\n                for value in sorted(potential['UncertainValues']):\n                    try:\n                        etree.SubElement(value_tag, 'Value', attrib={\n                            'distribution': value['distribution'],\n                            'name': value['name']}).text = value['value']\n                    except KeyError:\n                        etree.SubElement(value_tag, 'Value', attrib={\n                            'distribution': value['distribution']}).text = value['value']\n            if 'TopVariable' in potential:\n                etree.SubElement(potential_tag, 'TopVariable', attrib={'name': potential['TopVariable']})\n            if 'Branches' in potential:\n                branches_tag = etree.SubElement(potential_tag, 'Branches')\n                for branch in potential['Branches']:\n                    branch_tag = etree.SubElement(branches_tag, 'Branch')\n                    if 'States' in branch:\n                        states_tag = etree.SubElement(branch_tag, 'States')\n                        for state in sorted(branch['States']):\n                            etree.SubElement(states_tag, 'State', attrib={'name': state['name']})\n                    if 'Potential' in branch:\n                        self._add_potential(branch['Potential'], branch_tag)\n                    self._add_element(potential, 'Label', potential_tag)\n                    self._add_element(potential, 'Reference', potential_tag)\n                    if 'Thresholds' in branch:\n                        thresholds_tag = etree.SubElement(branch_tag, 'Thresholds')\n                        for threshold in branch['Thresholds']:\n                            try:\n                                etree.SubElement(thresholds_tag, 'Threshold', attrib={\n                                    'value': threshold['value'], 'belongsTo': threshold['belongsTo']})\n                            except KeyError:\n                                etree.SubElement(thresholds_tag, 'Threshold', attrib={\n                                    'value': threshold['value']})\n            self._add_element(potential, 'Model', potential_tag)\n            self._add_element(potential, 'Coefficients', potential_tag)\n            self._add_element(potential, 'CovarianceMatrix', potential_tag)\n            if 'Subpotentials' in potential:\n                subpotentials = etree.SubElement(potential_tag, 'Subpotentials')\n                for subpotential in potential['Subpotentials']:\n                    self._add_potential(subpotential, subpotentials)\n            if 'Potential' in potential:\n                self._add_potential(potential['Potential'], potential_tag)\n            if 'NumericVariables' in potential:\n                numvar_tag = etree.SubElement(potential_tag, 'NumericVariables')\n                for var in sorted(potential['NumericVariables']):\n                    etree.SubElement(numvar_tag, 'Variable', attrib={'name': var})"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef dump(self, stream):\n        if self.prettyprint:\n            self.indent(self.xml)\n        document = etree.ElementTree(self.xml)\n        header = '<?xml version=\"1.0\" encoding=\"%s\"?>' % self.encoding\n        stream.write(header.encode(self.encoding))\n        document.write(stream, encoding=self.encoding)", "response": "Dumps the data to stream after appending header."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nwrite the xml data into the file.", "response": "def write_file(self, filename):\n        \"\"\"\n        Write the xml data into the file.\n\n        Parameters\n        ----------\n        filename: Name of the file.\n\n        Examples\n        -------\n        >>> writer = ProbModelXMLWriter(model)\n        >>> writer.write_file(test_file)\n        \"\"\"\n        writer = self.__str__()[:-1].decode('utf-8')\n        with open(filename, 'w') as fout:\n            fout.write(writer)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating a BayesianModel object based on the type of ProbNetXML passed to ProbModelXMLReader class.", "response": "def create_probnet(self):\n        \"\"\"\n        Returns a BayesianModel or MarkovModel object depending on the\n        type of ProbModelXML passed to ProbModelXMLReader class.\n        \"\"\"\n        self.probnet = {}\n        # Add general properties\n        probnet_elem = self.xml.find('ProbNet')\n        self.probnet['type'] = probnet_elem.attrib['type']\n        if probnet_elem.find('Comment') is not None:\n            self.add_comment(probnet_elem.find('Comment').text)\n        if probnet_elem.find('Language') is not None:\n            self.add_language(probnet_elem.find('Language').text)\n        if probnet_elem.find('AdditionalProperties') is not None:\n            self.probnet['AdditionalProperties'] = {}\n            for prop in probnet_elem.find('AdditionalProperties'):\n                self.add_additional_property(self.probnet['AdditionalProperties'], prop)\n\n        # Add additional Constraints\n        self.probnet['AdditionalConstraints'] = {}\n        for constraint in probnet_elem.findall('AdditionalConstraints/Constraint'):\n            self.add_probnet_additionalconstraints(constraint)\n\n        # Add Decision Criterion\n        self.probnet['DecisionCriteria'] = {}\n        for criterion in probnet_elem.findall('DecisionCriteria/Criterion'):\n            self.add_criterion(criterion)\n\n        # Add nodes\n        self.probnet['Variables'] = {}\n        for variable in probnet_elem.find('Variables'):\n            self.add_node(variable)\n\n        # Add edges\n        self.probnet['edges'] = {}\n        for edge in probnet_elem.findall('Links/Link'):\n            self.add_edge(edge)\n\n        # Add CPD\n        self.probnet['Potentials'] = []\n        for potential in probnet_elem.findall('Potentials/Potential'):\n            probnet_dict = {}\n            self.add_potential(potential, probnet_dict)\n            self.probnet['Potentials'].append(probnet_dict)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nadd Additional Constraints to the ProbModel XML file.", "response": "def add_probnet_additionalconstraints(self, constraint):\n        \"\"\"\n        Adds Additional Constraints to the probnet dict.\n\n        Parameters\n        ----------\n        criterion: <Element Constraint at AdditionalConstraints Node in XML>\n            etree Element consisting Constraint tag.\n\n        Examples\n        -------\n        >>> reader = ProbModelXMLReader()\n        >>> reader.add_additionalconstraints(constraint)\n        \"\"\"\n        constraint_name = constraint.attrib['name']\n        self.probnet['AdditionalConstraints'][constraint_name] = {}\n        for argument in constraint.findall('Argument'):\n            argument_name = argument.attrib['name']\n            argument_value = argument.attrib['value']\n            self.probnet['AdditionalConstraints'][constraint_name][argument_name] = argument_value"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef add_criterion(self, criterion):\n        criterion_name = criterion.attrib['name']\n        self.probnet['DecisionCriteria'][criterion_name] = {}\n        if criterion.find('AdditionalProperties/Property') is not None:\n            for prop in criterion.findall('AdditionalProperties/Property'):\n                prop_name = prop.attrib['name']\n                prop_value = prop.attrib['value']\n                self.probnet['DecisionCriteria'][criterion_name]['AdditionalProperties'][prop_name] = prop_value", "response": "Adds Decision Criteria to the probnet dict."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add_node(self, variable):\n        # TODO: Do some checks with variable type and roles. Right now I don't know when they are to be used.\n        variable_name = variable.attrib['name']\n        self.probnet['Variables'][variable_name] = {}\n        self.probnet['Variables'][variable_name]['type'] = variable.attrib['type']\n        self.probnet['Variables'][variable_name]['role'] = variable.attrib['role']\n        if variable.find('Comment') is not None:\n            self.probnet['Variables'][variable_name]['Comment'] = variable.find('Comment').text\n        if variable.find('Coordinates') is not None:\n            self.probnet['Variables'][variable_name]['Coordinates'] = variable.find('Coordinates').attrib\n        if variable.find('AdditionalProperties/Property') is not None:\n            self.probnet['Variables'][variable_name]['AdditionalProperties'] = {}\n            for prop in variable.findall('AdditionalProperties/Property'):\n                self.probnet['Variables'][variable_name]['AdditionalProperties'][prop.attrib['name']] = \\\n                    prop.attrib['value']\n        if variable.find('States/State') is None:\n            warnings.warn(\"States not available for node: \" + variable_name)\n        else:\n            self.probnet['Variables'][variable_name]['States'] = {state.attrib['name']: {\n                prop.attrib['name']: prop.attrib['value'] for\n                prop in state.findall('AdditionalProperties/Property')} for state in variable.findall(\n                'States/State')}", "response": "Adds a variable to the ProbModel XML file."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds Edges to the ProbModel XML file.", "response": "def add_edge(self, edge):\n        \"\"\"\n        Adds Edges to the probnet dict.\n\n        Parameters\n        ----------\n        edge: <Element Link at Links Node in XML>\n            etree Element consisting Variable tag.\n\n        Examples\n        -------\n        >>> reader = ProbModelXMLReader()\n        >>> reader.add_edge(edge)\n        \"\"\"\n        var1 = edge.findall('Variable')[0].attrib['name']\n        var2 = edge.findall('Variable')[1].attrib['name']\n        self.probnet['edges'][(var1, var2)] = {}\n        self.probnet['edges'][(var1, var2)]['directed'] = edge.attrib['directed']\n        # TODO: check for the case of undirected graphs if we need to add to both elements of the dic for a single edge.\n        if edge.find('Comment') is not None:\n            self.probnet['edges'][(var1, var2)]['Comment'] = edge.find('Comment').text\n        if edge.find('Label') is not None:\n            self.probnet['edges'][(var1, var2)]['Label'] = edge.find('Label').text\n        if edge.find('AdditionalProperties/Property') is not None:\n            self.probnet['edges'][(var1, var2)]['AdditionalProperties'] = {}\n            for prop in edge.findall('AdditionalProperties/Property'):\n                self.probnet['edges'][(var1, var2)]['AdditionalProperties'][prop.attrib['name']] = prop.attrib['value']"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add_potential(self, potential, potential_dict):\n        potential_type = potential.attrib['type']\n        potential_dict['type'] = potential_type\n        try:\n            potential_dict['role'] = potential.attrib['role']\n        except KeyError:\n            pass\n        if potential.find('Comment') is not None:\n            potential_dict['Comment'] = potential.find('Comment').text\n        for prop in potential.findall('AdditionalProperties/Property'):\n            potential_dict['AdditionalProperties'][prop.attrib['name']] = prop.attrib['value']\n        if potential_type == \"delta\":\n            potential_dict['Variable'] = potential.find('Variable').attrib['name']\n            if potential.find('State') is not None:\n                potential_dict['State'] = potential.find('State').text\n            if potential.find('StateIndex') is not None:\n                potential_dict['StateIndex'] = potential.find('StateIndex').text\n            if potential.find('NumericValue') is not None:\n                potential_dict['NumericValue'] = potential.find('NumericValue').text\n        else:\n            if potential.find('UtilityVariable') is not None:\n                potential_dict['UtilityVaribale'] = potential.find('UtilityVariable').attrib['name']\n            if len(potential.findall('Variables/Variable')):\n                potential_dict['Variables'] = {}\n                var_list = []\n                for var in potential.findall('Variables/Variable'):\n                    var_list.append(var.attrib['name'])\n                potential_dict['Variables'][var_list[0]] = var_list[1:]\n            if potential.find('Values') is not None:\n                potential_dict['Values'] = potential.find('Values').text\n            if len(potential.findall('UncertainValues/Value')):\n                potential_dict['UncertainValues'] = []\n                for value in potential.findall('UncertainValues/Value'):\n                    try:\n                        potential_dict['UncertainValues'].append(\n                            {'distribution': value.attrib['distribution'], 'name': value.attrib['name'],\n                             'value': value.text})\n                    except KeyError:\n                        potential_dict['UncertainValues'].append(\n                            {'distribution': value.attrib['distribution'], 'value': value.text})\n            if potential.find('TopVariable') is not None:\n                potential_dict['TopVariable'] = potential.find('TopVariable').attrib['name']\n\n            if len(potential.findall('Branches/Branch')):\n                potential_dict['Branches'] = []\n                for branch in potential.findall('Branches/Branch'):\n                    branch_dict = {}\n                    if len(branch.findall('States/State')):\n                        states = []\n                        for state in branch.findall('States/State'):\n                            states.append({'name': state.attrib['name']})\n                        branch_dict['States'] = states\n                    if branch.find('Potential') is not None:\n                        branch_potential = {}\n                        self.add_potential(branch.find('Potential'), branch_potential)\n                        branch_dict['Potential'] = branch_potential\n                    if branch.find('Label') is not None:\n                        label = branch.find('Label').text\n                        branch_dict['Label'] = label\n                    if branch.find('Reference') is not None:\n                        reference = branch.find('Reference').text\n                        branch_dict['Reference'] = reference\n                    if len(branch.findall('Thresholds/Threshold')):\n                        thresholds = []\n                        for threshold in branch.findall('Thresholds/Threshold'):\n                            try:\n                                thresholds.append({\n                                    'value': threshold.attrib['value'], 'belongsTo': threshold.attrib['belongsTo']})\n                            except KeyError:\n                                thresholds.append({'value': threshold.attrib['value']})\n                        branch_dict['Thresholds'] = thresholds\n                    potential_dict['Branches'].append(branch_dict)\n\n            if potential.find('Model') is not None:\n                potential_dict['Model'] = potential.find('Model').text\n            if len(potential.findall('Subpotentials/Potential')):\n                potential_dict['Subpotentials'] = []\n                for subpotential in potential.findall('Subpotentials/Potential'):\n                    subpotential_dict = {}\n                    self.add_potential(subpotential, subpotential_dict)\n                    potential_dict['Subpotentials'].append(subpotential_dict)\n            if potential.find('Coefficients') is not None:\n                potential_dict['Coefficients'] = potential.find('Coefficients').text\n            if potential.find('CovarianceMatrix') is not None:\n                potential_dict['CovarianceMatrix'] = potential.find('CovarianceMatrix').text\n            if potential.find('Potential') is not None:\n                potential_dict['Potential'] = {}\n                self.add_potential(potential.find('Potential'), potential_dict['Potential'])\n            if len(potential.findall('NumericVariables/Variable')):\n                potential_dict['NumericVariables'] = []\n                for variable in potential.findall('NumericVariables/Variable'):\n                    potential_dict['NumericVariables'].append(variable.attrib['name'])", "response": "Adds Potential to the dict."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_model(self):\n        if self.probnet.get('type') == \"BayesianNetwork\":\n            model = BayesianModel()\n            model.add_nodes_from(self.probnet['Variables'].keys())\n            model.add_edges_from(self.probnet['edges'].keys())\n\n            tabular_cpds = []\n            cpds = self.probnet['Potentials']\n            for cpd in cpds:\n                var = list(cpd['Variables'].keys())[0]\n                states = self.probnet['Variables'][var]['States']\n                evidence = cpd['Variables'][var]\n                evidence_card = [len(self.probnet['Variables'][evidence_var]['States'])\n                                 for evidence_var in evidence]\n                arr = list(map(float, cpd['Values'].split()))\n                values = np.array(arr)\n                values = values.reshape((len(states), values.size//len(states)))\n                tabular_cpds.append(TabularCPD(var, len(states), values, evidence, evidence_card))\n\n            model.add_cpds(*tabular_cpds)\n\n            variables = model.nodes()\n            for var in variables:\n                for prop_name, prop_value in self.probnet['Variables'][var].items():\n                    model.node[var][prop_name] = prop_value\n            edges = model.edges()\n\n            if nx.__version__.startswith('1'):\n                for edge in edges:\n                    for prop_name, prop_value in self.probnet['edges'][edge].items():\n                        model.edge[edge[0]][edge[1]][prop_name] = prop_value\n            else:\n                for edge in edges:\n                    for prop_name, prop_value in self.probnet['edges'][edge].items():\n                        model.adj[edge[0]][edge[1]][prop_name] = prop_value\n            return model\n        else:\n            raise ValueError(\"Please specify only Bayesian Network.\")", "response": "Returns the model instance of the ProbModel."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a generator that yields all possible directed acyclic graphs with a given set of nodes.", "response": "def all_dags(self, nodes=None):\n        \"\"\"\n        Computes all possible directed acyclic graphs with a given set of nodes,\n        sparse ones first. `2**(n*(n-1))` graphs need to be searched, given `n` nodes,\n        so this is likely not feasible for n>6. This is a generator.\n\n        Parameters\n        ----------\n        nodes: list of nodes for the DAGs (optional)\n            A list of the node names that the generated DAGs should have.\n            If not provided, nodes are taken from data.\n\n        Returns\n        -------\n        dags: Generator object for nx.DiGraphs\n            Generator that yields all acyclic nx.DiGraphs, ordered by number of edges. Empty DAG first.\n\n        Examples\n        --------\n        >>> import pandas as pd\n        >>> from pgmpy.estimators import ExhaustiveSearch\n        >>> s = ExhaustiveSearch(pd.DataFrame(data={'Temperature': [23, 19],\n                                                    'Weather': ['sunny', 'cloudy'],\n                                                    'Humidity': [65, 75]}))\n        >>> list(s.all_dags())\n        [<networkx.classes.digraph.DiGraph object at 0x7f6955216438>,\n         <networkx.classes.digraph.DiGraph object at 0x7f6955216518>,\n        ....\n        >>> [dag.edges() for dag in s.all_dags()]\n        [[], [('Humidity', 'Temperature')], [('Humidity', 'Weather')],\n        [('Temperature', 'Weather')], [('Temperature', 'Humidity')],\n        ....\n        [('Weather', 'Humidity'), ('Weather', 'Temperature'), ('Temperature', 'Humidity')]]\n\n        \"\"\"\n        if nodes is None:\n            nodes = sorted(self.state_names.keys())\n        if len(nodes) > 6:\n            warn(\"Generating all DAGs of n nodes likely not feasible for n>6!\")\n            warn(\"Attempting to search through {0} graphs\".format(2**(len(nodes)*(len(nodes)-1))))\n\n        edges = list(combinations(nodes, 2))  # n*(n-1) possible directed edges\n        edges.extend([(y, x) for x, y in edges])\n        all_graphs = powerset(edges)  # 2^(n*(n-1)) graphs\n\n        for graph_edges in all_graphs:\n            graph = nx.DiGraph()\n            graph.add_nodes_from(nodes)\n            graph.add_edges_from(graph_edges)\n            if nx.is_directed_acyclic_graph(graph):\n                yield graph"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncomputing a list of DAGs and their structure scores ordered by score.", "response": "def all_scores(self):\n        \"\"\"\n        Computes a list of DAGs and their structure scores, ordered by score.\n\n        Returns\n        -------\n        list: a list of (score, dag) pairs\n            A list of (score, dag)-tuples, where score is a float and model a acyclic nx.DiGraph.\n            The list is ordered by score values.\n\n        Examples\n        --------\n        >>> import pandas as pd\n        >>> import numpy as np\n        >>> from pgmpy.estimators import ExhaustiveSearch, K2Score\n        >>> # create random data sample with 3 variables, where B and C are identical:\n        >>> data = pd.DataFrame(np.random.randint(0, 5, size=(5000, 2)), columns=list('AB'))\n        >>> data['C'] = data['B']\n        >>> searcher = ExhaustiveSearch(data, scoring_method=K2Score(data))\n        >>> for score, model in searcher.all_scores():\n        ...   print(\"{0}\\t{1}\".format(score, model.edges()))\n        -24234.44977974726      [('A', 'B'), ('A', 'C')]\n        -24234.449760691063     [('A', 'B'), ('C', 'A')]\n        -24234.449760691063     [('A', 'C'), ('B', 'A')]\n        -24203.700955937973     [('A', 'B')]\n        -24203.700955937973     [('A', 'C')]\n        -24203.700936881774     [('B', 'A')]\n        -24203.700936881774     [('C', 'A')]\n        -24203.700936881774     [('B', 'A'), ('C', 'A')]\n        -24172.952132128685     []\n        -16597.30920265254      [('A', 'B'), ('A', 'C'), ('B', 'C')]\n        -16597.30920265254      [('A', 'B'), ('A', 'C'), ('C', 'B')]\n        -16597.309183596342     [('A', 'B'), ('C', 'A'), ('C', 'B')]\n        -16597.309183596342     [('A', 'C'), ('B', 'A'), ('B', 'C')]\n        -16566.560378843253     [('A', 'B'), ('C', 'B')]\n        -16566.560378843253     [('A', 'C'), ('B', 'C')]\n        -16268.324549347722     [('A', 'B'), ('B', 'C')]\n        -16268.324549347722     [('A', 'C'), ('C', 'B')]\n        -16268.324530291524     [('B', 'A'), ('B', 'C')]\n        -16268.324530291524     [('B', 'C'), ('C', 'A')]\n        -16268.324530291524     [('B', 'A'), ('C', 'B')]\n        -16268.324530291524     [('C', 'A'), ('C', 'B')]\n        -16268.324530291524     [('B', 'A'), ('B', 'C'), ('C', 'A')]\n        -16268.324530291524     [('B', 'A'), ('C', 'A'), ('C', 'B')]\n        -16237.575725538434     [('B', 'C')]\n        -16237.575725538434     [('C', 'B')]\n        \"\"\"\n\n        scored_dags = sorted([(self.scoring_method.score(dag), dag) for dag in self.all_dags()],\n                             key=lambda x: x[0])\n        return scored_dags"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nestimate the DAG structure that fits best to the given data set.", "response": "def estimate(self):\n        \"\"\"\n        Estimates the `DAG` structure that fits best to the given data set,\n        according to the scoring method supplied in the constructor.\n        Exhaustively searches through all models. Only estimates network structure, no parametrization.\n\n        Returns\n        -------\n        model: `DAG` instance\n            A `DAG` with maximal score.\n\n        Examples\n        --------\n        >>> import pandas as pd\n        >>> import numpy as np\n        >>> from pgmpy.estimators import ExhaustiveSearch\n        >>> # create random data sample with 3 variables, where B and C are identical:\n        >>> data = pd.DataFrame(np.random.randint(0, 5, size=(5000, 2)), columns=list('AB'))\n        >>> data['C'] = data['B']\n        >>> est = ExhaustiveSearch(data)\n        >>> best_model = est.estimate()\n        >>> best_model\n        <pgmpy.base.DAG.DAG object at 0x7f695c535470>\n        >>> best_model.edges()\n        [('B', 'C')]\n        \"\"\"\n\n        best_dag = max(self.all_dags(), key=self.scoring_method.score)\n\n        best_model = DAG()\n        best_model.add_nodes_from(sorted(best_dag.nodes()))\n        best_model.add_edges_from(sorted(best_dag.edges()))\n        return best_model"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding variables to the NoisyOrModel.", "response": "def add_variables(self, variables, cardinality, inhibitor_probability):\n        \"\"\"\n        Adds variables to the NoisyOrModel.\n\n        Parameters\n        ----------\n        variables: list, tuple, dict (array like)\n            array containing names of the variables that are to be added.\n\n        cardinality: list, tuple, dict (array like)\n            array containing integers representing the cardinality\n            of the variables.\n\n        inhibitor_probability: list, tuple, dict (array_like)\n            array containing the inhibitor probabilities corresponding to each variable.\n\n        Examples\n        --------\n        >>> from pgmpy.models import NoisyOrModel\n        >>> model = NoisyOrModel(['x1', 'x2', 'x3'], [2, 3, 2], [[0.6, 0.4],\n        ...                                                      [0.2, 0.4, 0.7],\n        ...                                                      [0.1, 0. 4]])\n        >>> model.add_variables(['x4'], [3], [0.1, 0.4, 0.2])\n        \"\"\"\n        if len(variables) == 1:\n            if not isinstance(inhibitor_probability[0], (list, tuple)):\n                inhibitor_probability = [inhibitor_probability]\n\n        if len(variables) != len(cardinality):\n            raise ValueError(\"Size of variables and cardinality should be same\")\n        elif any(cardinal != len(prob_array) for prob_array, cardinal in zip(inhibitor_probability, cardinality)) or \\\n                len(cardinality) != len(inhibitor_probability):\n            raise ValueError(\"Size of variables and inhibitor_probability should be same\")\n        elif not all(0 <= item <= 1 for item in chain.from_iterable(inhibitor_probability)):\n            raise ValueError(\"Probability values should be between 0 and 1(both inclusive).\")\n        else:\n            self.variables = np.concatenate((self.variables, variables))\n            self.cardinality = np.concatenate((self.cardinality, cardinality))\n            self.inhibitor_probability.extend(inhibitor_probability)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndelete variables from the NoisyOrModel.", "response": "def del_variables(self, variables):\n        \"\"\"\n        Deletes variables from the NoisyOrModel.\n\n        Parameters\n        ----------\n        variables: list, tuple, dict (array like)\n            list of variables to be deleted.\n\n        Examples\n        --------\n        >>> from pgmpy.models import NoisyOrModel\n        >>> model = NoisyOrModel(['x1', 'x2', 'x3'], [2, 3, 2], [[0.6, 0.4],\n        ...                                                      [0.2, 0.4, 0.7],\n        ...                                                      [0.1, 0. 4]])\n        >>> model.del_variables(['x1'])\n        \"\"\"\n        variables = [variables] if isinstance(variables, six.string_types) else set(variables)\n        indices = [index for index, variable in enumerate(self.variables) if variable in variables]\n        self.variables = np.delete(self.variables, indices, 0)\n        self.cardinality = np.delete(self.cardinality, indices, 0)\n        self.inhibitor_probability = [prob_array for index, prob_array in enumerate(self.inhibitor_probability)\n                                      if index not in indices]"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the samples according to the return_type", "response": "def _return_samples(return_type, samples):\n    \"\"\"\n        A utility function to return samples according to type\n    \"\"\"\n    if return_type.lower() == \"dataframe\":\n        if HAS_PANDAS:\n            return pandas.DataFrame.from_records(samples)\n        else:\n            warn(\"Pandas installation not found. Returning numpy.recarray object\")\n            return samples\n    else:\n        return samples"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the cardinality of a given variable in the current context.", "response": "def get_cardinality(self, variables):\n        \"\"\"\n        Returns cardinality of a given variable\n\n        Parameters\n        ----------\n        variables: list, array-like\n                A list of variable names.\n\n        Returns\n        -------\n        dict: Dictionary of the form {variable: variable_cardinality}\n\n        Examples\n        --------\n        >>> from pgmpy.factors.discrete import DiscreteFactor\n        >>> phi = DiscreteFactor(['x1', 'x2', 'x3'], [2, 3, 2], range(12))\n        >>> phi.get_cardinality(['x1'])\n        {'x1': 2}\n        >>> phi.get_cardinality(['x1', 'x2'])\n        {'x1': 2, 'x2': 3}\n        \"\"\"\n        if isinstance(variables, six.string_types):\n            raise TypeError(\"variables: Expected type list or array-like, got type str\")\n\n        if not all([var in self.variables for var in variables]):\n            raise ValueError(\"Variable not in scope\")\n\n        return {var: self.cardinality[self.variables.index(var)] for var in variables}"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a list of assignments for the corresponding index.", "response": "def assignment(self, index):\n        \"\"\"\n        Returns a list of assignments for the corresponding index.\n\n        Parameters\n        ----------\n        index: list, array-like\n            List of indices whose assignment is to be computed\n\n        Returns\n        -------\n        list: Returns a list of full assignments of all the variables of the factor.\n\n        Examples\n        --------\n        >>> import numpy as np\n        >>> from pgmpy.factors.discrete import DiscreteFactor\n        >>> phi = DiscreteFactor(['diff', 'intel'], [2, 2], np.ones(4))\n        >>> phi.assignment([1, 2])\n        [[('diff', 0), ('intel', 1)], [('diff', 1), ('intel', 0)]]\n        \"\"\"\n        index = np.array(index)\n\n        max_possible_index = np.prod(self.cardinality) - 1\n        if not all(i <= max_possible_index for i in index):\n            raise IndexError(\"Index greater than max possible index\")\n\n        assignments = np.zeros((len(index), len(self.scope())), dtype=np.int)\n        rev_card = self.cardinality[::-1]\n        for i, card in enumerate(rev_card):\n            assignments[:, i] = index % card\n            index = index // card\n\n        assignments = assignments[:, ::-1]\n\n        return [[(key, val) for key, val in zip(self.variables, values)] for values in assignments]"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the identity factor of the current factor.", "response": "def identity_factor(self):\n        \"\"\"\n        Returns the identity factor.\n\n        Def: The identity factor of a factor has the same scope and cardinality as the original factor,\n             but the values for all the assignments is 1. When the identity factor is multiplied with\n             the factor it returns the factor itself.\n\n        Returns\n        -------\n        DiscreteFactor: The identity factor.\n\n        Examples\n        --------\n        >>> from pgmpy.factors.discrete import DiscreteFactor\n        >>> phi = DiscreteFactor(['x1', 'x2', 'x3'], [2, 3, 2], range(12))\n        >>> phi_identity = phi.identity_factor()\n        >>> phi_identity.variables\n        ['x1', 'x2', 'x3']\n        >>> phi_identity.values\n        array([[[ 1.,  1.],\n                [ 1.,  1.],\n                [ 1.,  1.]],\n\n               [[ 1.,  1.],\n                [ 1.,  1.],\n                [ 1.,  1.]]])\n        \"\"\"\n        return DiscreteFactor(self.variables, self.cardinality, np.ones(self.values.size))"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nmodifies the factor with marginalized values. Parameters ---------- variables: list, array-like List of variables over which to marginalize. inplace: boolean If inplace=True it will modify the factor itself, else would return a new factor. Returns ------- DiscreteFactor or None: if inplace=True (default) returns None if inplace=False returns a new `DiscreteFactor` instance. Examples -------- >>> from pgmpy.factors.discrete import DiscreteFactor >>> phi = DiscreteFactor(['x1', 'x2', 'x3'], [2, 3, 2], range(12)) >>> phi.marginalize(['x1', 'x3']) >>> phi.values array([ 14., 22., 30.]) >>> phi.variables ['x2']", "response": "def marginalize(self, variables, inplace=True):\n        \"\"\"\n        Modifies the factor with marginalized values.\n\n        Parameters\n        ----------\n        variables: list, array-like\n            List of variables over which to marginalize.\n\n        inplace: boolean\n            If inplace=True it will modify the factor itself, else would return\n            a new factor.\n\n        Returns\n        -------\n        DiscreteFactor or None: if inplace=True (default) returns None\n                        if inplace=False returns a new `DiscreteFactor` instance.\n\n        Examples\n        --------\n        >>> from pgmpy.factors.discrete import DiscreteFactor\n        >>> phi = DiscreteFactor(['x1', 'x2', 'x3'], [2, 3, 2], range(12))\n        >>> phi.marginalize(['x1', 'x3'])\n        >>> phi.values\n        array([ 14.,  22.,  30.])\n        >>> phi.variables\n        ['x2']\n        \"\"\"\n\n        if isinstance(variables, six.string_types):\n            raise TypeError(\"variables: Expected type list or array-like, got type str\")\n\n        phi = self if inplace else self.copy()\n\n        for var in variables:\n            if var not in phi.variables:\n                raise ValueError(\"{var} not in scope.\".format(var=var))\n\n        var_indexes = [phi.variables.index(var) for var in variables]\n\n        index_to_keep = sorted(set(range(len(self.variables))) - set(var_indexes))\n        phi.variables = [phi.variables[index] for index in index_to_keep]\n        phi.cardinality = phi.cardinality[index_to_keep]\n\n        phi.values = np.sum(phi.values, axis=tuple(var_indexes))\n\n        if not inplace:\n            return phi"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nnormalizing the values of factor so that they sum to 1.", "response": "def normalize(self, inplace=True):\n        \"\"\"\n        Normalizes the values of factor so that they sum to 1.\n\n        Parameters\n        ----------\n        inplace: boolean\n            If inplace=True it will modify the factor itself, else would return\n            a new factor\n\n        Returns\n        -------\n        DiscreteFactor or None: if inplace=True (default) returns None\n                        if inplace=False returns a new `DiscreteFactor` instance.\n\n        Examples\n        --------\n        >>> from pgmpy.factors.discrete import DiscreteFactor\n        >>> phi = DiscreteFactor(['x1', 'x2', 'x3'], [2, 3, 2], range(12))\n        >>> phi.values\n        array([[[ 0,  1],\n                [ 2,  3],\n                [ 4,  5]],\n\n               [[ 6,  7],\n                [ 8,  9],\n                [10, 11]]])\n        >>> phi.normalize()\n        >>> phi.variables\n        ['x1', 'x2', 'x3']\n        >>> phi.cardinality\n        array([2, 3, 2])\n        >>> phi.values\n        array([[[ 0.        ,  0.01515152],\n                [ 0.03030303,  0.04545455],\n                [ 0.06060606,  0.07575758]],\n\n               [[ 0.09090909,  0.10606061],\n                [ 0.12121212,  0.13636364],\n                [ 0.15151515,  0.16666667]]])\n\n        \"\"\"\n        phi = self if inplace else self.copy()\n\n        phi.values = phi.values / phi.values.sum()\n\n        if not inplace:\n            return phi"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreduce the factor to the context of given variable values.", "response": "def reduce(self, values, inplace=True):\n        \"\"\"\n        Reduces the factor to the context of given variable values.\n\n        Parameters\n        ----------\n        values: list, array-like\n            A list of tuples of the form (variable_name, variable_state).\n\n        inplace: boolean\n            If inplace=True it will modify the factor itself, else would return\n            a new factor.\n\n        Returns\n        -------\n        DiscreteFactor or None: if inplace=True (default) returns None\n                        if inplace=False returns a new `DiscreteFactor` instance.\n\n        Examples\n        --------\n        >>> from pgmpy.factors.discrete import DiscreteFactor\n        >>> phi = DiscreteFactor(['x1', 'x2', 'x3'], [2, 3, 2], range(12))\n        >>> phi.reduce([('x1', 0), ('x2', 0)])\n        >>> phi.variables\n        ['x3']\n        >>> phi.cardinality\n        array([2])\n        >>> phi.values\n        array([0., 1.])\n        \"\"\"\n        if isinstance(values, six.string_types):\n            raise TypeError(\"values: Expected type list or array-like, got type str\")\n\n        if (any(isinstance(value, six.string_types) for value in values) or\n                not all(isinstance(state, (int, np.integer)) for var, state in values)):\n            raise TypeError(\"values: must contain tuples or array-like elements of the form \"\n                            \"(hashable object, type int)\")\n\n        phi = self if inplace else self.copy()\n\n        var_index_to_del = []\n        slice_ = [slice(None)] * len(self.variables)\n        for var, state in values:\n            var_index = phi.variables.index(var)\n            slice_[var_index] = state\n            var_index_to_del.append(var_index)\n\n        var_index_to_keep = sorted(set(range(len(phi.variables))) - set(var_index_to_del))\n        # set difference is not gaurenteed to maintain ordering\n        phi.variables = [phi.variables[index] for index in var_index_to_keep]\n        phi.cardinality = phi.cardinality[var_index_to_keep]\n        phi.values = phi.values[tuple(slice_)]\n\n        if not inplace:\n            return phi"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a new DiscreteFactor instance with the sum of the two values.", "response": "def sum(self, phi1, inplace=True):\n        \"\"\"\n        DiscreteFactor sum with `phi1`.\n\n        Parameters\n        ----------\n        phi1: `DiscreteFactor` instance.\n            DiscreteFactor to be added.\n\n        inplace: boolean\n            If inplace=True it will modify the factor itself, else would return\n            a new factor.\n\n        Returns\n        -------\n        DiscreteFactor or None: if inplace=True (default) returns None\n                        if inplace=False returns a new `DiscreteFactor` instance.\n\n        Example\n        -------\n        >>> from pgmpy.factors.discrete import DiscreteFactor\n        >>> phi1 = DiscreteFactor(['x1', 'x2', 'x3'], [2, 3, 2], range(12))\n        >>> phi2 = DiscreteFactor(['x3', 'x4', 'x1'], [2, 2, 2], range(8))\n        >>> phi1.sum(phi2, inplace=True)\n        >>> phi1.variables\n        ['x1', 'x2', 'x3', 'x4']\n        >>> phi1.cardinality\n        array([2, 3, 2, 2])\n        >>> phi1.values\n        array([[[[ 0,  0],\n                 [ 4,  6]],\n\n                [[ 0,  4],\n                 [12, 18]],\n\n                [[ 0,  8],\n                 [20, 30]]],\n\n\n               [[[ 6, 18],\n                 [35, 49]],\n\n                [[ 8, 24],\n                 [45, 63]],\n\n                [[10, 30],\n                 [55, 77]]]])\n        \"\"\"\n        phi = self if inplace else self.copy()\n        if isinstance(phi1, (int, float)):\n            phi.values += phi1\n        else:\n            phi1 = phi1.copy()\n\n            # modifying phi to add new variables\n            extra_vars = set(phi1.variables) - set(phi.variables)\n            if extra_vars:\n                slice_ = [slice(None)] * len(phi.variables)\n                slice_.extend([np.newaxis] * len(extra_vars))\n                phi.values = phi.values[tuple(slice_)]\n\n                phi.variables.extend(extra_vars)\n\n                new_var_card = phi1.get_cardinality(extra_vars)\n                phi.cardinality = np.append(phi.cardinality, [new_var_card[var] for var in extra_vars])\n\n            # modifying phi1 to add new variables\n            extra_vars = set(phi.variables) - set(phi1.variables)\n            if extra_vars:\n                slice_ = [slice(None)] * len(phi1.variables)\n                slice_.extend([np.newaxis] * len(extra_vars))\n                phi1.values = phi1.values[tuple(slice_)]\n\n                phi1.variables.extend(extra_vars)\n                # No need to modify cardinality as we don't need it.\n\n            # rearranging the axes of phi1 to match phi\n            for axis in range(phi.values.ndim):\n                exchange_index = phi1.variables.index(phi.variables[axis])\n                phi1.variables[axis], phi1.variables[exchange_index] = phi1.variables[exchange_index], \\\n                    phi1.variables[axis]\n                phi1.values = phi1.values.swapaxes(axis, exchange_index)\n\n            phi.values = phi.values + phi1.values\n\n        if not inplace:\n            return phi"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef divide(self, phi1, inplace=True):\n        phi = self if inplace else self.copy()\n        phi1 = phi1.copy()\n\n        if set(phi1.variables) - set(phi.variables):\n            raise ValueError(\"Scope of divisor should be a subset of dividend\")\n\n        # Adding extra variables in phi1.\n        extra_vars = set(phi.variables) - set(phi1.variables)\n        if extra_vars:\n            slice_ = [slice(None)] * len(phi1.variables)\n            slice_.extend([np.newaxis] * len(extra_vars))\n            phi1.values = phi1.values[tuple(slice_)]\n\n            phi1.variables.extend(extra_vars)\n\n        # Rearranging the axes of phi1 to match phi\n        for axis in range(phi.values.ndim):\n            exchange_index = phi1.variables.index(phi.variables[axis])\n            phi1.variables[axis], phi1.variables[exchange_index] = phi1.variables[exchange_index], phi1.variables[axis]\n            phi1.values = phi1.values.swapaxes(axis, exchange_index)\n\n        phi.values = phi.values / phi1.values\n\n        # If factor division 0/0 = 0 but is undefined for x/0. In pgmpy we are using\n        # np.inf to represent x/0 cases.\n        phi.values[np.isnan(phi.values)] = 0\n\n        if not inplace:\n            return phi", "response": "Returns a new DiscreteFactor instance with the denominator of division by phi1."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef copy(self):\n        # not creating a new copy of self.values and self.cardinality\n        # because __init__ methods does that.\n        return DiscreteFactor(self.scope(), self.cardinality, self.values, state_names=self.state_names)", "response": "Returns a copy of the factor."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _str(self, phi_or_p=\"phi\", tablefmt=\"grid\", print_state_names=True):\n        string_header = list(map(lambda x: six.text_type(x), self.scope()))\n        string_header.append('{phi_or_p}({variables})'.format(phi_or_p=phi_or_p,\n                                                              variables=','.join(string_header)))\n\n        value_index = 0\n        factor_table = []\n        for prob in product(*[range(card) for card in self.cardinality]):\n            if self.state_names and print_state_names:\n                prob_list = [\"{var}({state})\".format(\n                    var=list(self.variables)[i], state=self.state_names[list(\n                        self.variables)[i]][prob[i]])\n                             for i in range(len(self.variables))]\n            else:\n                prob_list = [\"{s}_{d}\".format(s=list(self.variables)[i], d=prob[i])\n                             for i in range(len(self.variables))]\n\n            prob_list.append(self.values.ravel()[value_index])\n            factor_table.append(prob_list)\n            value_index += 1\n\n        return tabulate(factor_table, headers=string_header, tablefmt=tablefmt, floatfmt=\".4f\")", "response": "Generate the string from the __str__ method."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncheck whether given parameter is a 1d array like object and returns a numpy array object", "response": "def _check_1d_array_object(parameter, name_param):\n    \"\"\"\n    Checks whether given parameter is a 1d array like object, and returns a numpy array object\n    \"\"\"\n    if isinstance(parameter, (np.ndarray, list, tuple, np.matrix)):\n        parameter = np.array(parameter)\n        if parameter.ndim != 1:\n            raise TypeError(\"{} should be a 1d array type object\".format(name_param))\n    else:\n        raise TypeError(\"{} should be a 1d array type object\".format(name_param))\n\n    return parameter"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _check_length_equal(param_1, param_2, name_param_1, name_param_2):\n    if len(param_1) != len(param_2):\n        raise ValueError(\"Length of {} must be same as Length of {}\".format(name_param_1, name_param_2))", "response": "Checks that the length of two arguments is equal to the length of the base class."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_variables(self):\n        variables = [variable.find('NAME').text for variable in self.network.findall('VARIABLE')]\n        return variables", "response": "Returns list of variables of the network"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the edges of the network", "response": "def get_edges(self):\n        \"\"\"\n        Returns the edges of the network\n\n        Examples\n        --------\n        >>> reader = XMLBIF.XMLBIFReader(\"xmlbif_test.xml\")\n        >>> reader.get_edges()\n        [['family-out', 'light-on'],\n         ['family-out', 'dog-out'],\n         ['bowel-problem', 'dog-out'],\n         ['dog-out', 'hear-bark']]\n        \"\"\"\n        edge_list = [[value, key] for key in self.variable_parents\n                     for value in self.variable_parents[key]]\n        return edge_list"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the states of variables present in the network", "response": "def get_states(self):\n        \"\"\"\n        Returns the states of variables present in the network\n\n        Examples\n        --------\n        >>> reader = XMLBIF.XMLBIFReader(\"xmlbif_test.xml\")\n        >>> reader.get_states()\n        {'bowel-problem': ['true', 'false'],\n         'dog-out': ['true', 'false'],\n         'family-out': ['true', 'false'],\n         'hear-bark': ['true', 'false'],\n         'light-on': ['true', 'false']}\n        \"\"\"\n        variable_states = {variable.find('NAME').text: [outcome.text for outcome in variable.findall('OUTCOME')]\n                           for variable in self.network.findall('VARIABLE')}\n        return variable_states"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the parents of the variables present in the network", "response": "def get_parents(self):\n        \"\"\"\n        Returns the parents of the variables present in the network\n\n        Examples\n        --------\n        >>> reader = XMLBIF.XMLBIFReader(\"xmlbif_test.xml\")\n        >>> reader.get_parents()\n        {'bowel-problem': [],\n         'dog-out': ['family-out', 'bowel-problem'],\n         'family-out': [],\n         'hear-bark': ['dog-out'],\n         'light-on': ['family-out']}\n        \"\"\"\n        variable_parents = {definition.find('FOR').text: [edge.text for edge in definition.findall('GIVEN')]\n                            for definition in self.network.findall('DEFINITION')}\n        return variable_parents"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_values(self):\n        variable_CPD = {definition.find('FOR').text: list(map(float, table.text.split()))\n                        for definition in self.network.findall('DEFINITION')\n                        for table in definition.findall('TABLE')}\n        for variable in variable_CPD:\n            arr = np.array(variable_CPD[variable])\n            arr = arr.reshape((len(self.variable_states[variable]),\n                               arr.size // len(self.variable_states[variable])), order='F')\n            variable_CPD[variable] = arr\n        return variable_CPD", "response": "Returns the CPD of the variables present in the network"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the property of the variable", "response": "def get_property(self):\n        \"\"\"\n        Returns the property of the variable\n\n        Examples\n        --------\n        >>> reader = XMLBIF.XMLBIFReader(\"xmlbif_test.xml\")\n        >>> reader.get_property()\n        {'bowel-problem': ['position = (190, 69)'],\n         'dog-out': ['position = (155, 165)'],\n         'family-out': ['position = (112, 69)'],\n         'hear-bark': ['position = (154, 241)'],\n         'light-on': ['position = (73, 165)']}\n        \"\"\"\n        variable_property = {variable.find('NAME').text: [property.text for property in variable.findall('PROPERTY')]\n                             for variable in self.network.findall('VARIABLE')}\n        return variable_property"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_variables(self):\n        variables = self.model.nodes()\n        variable_tag = {}\n        for var in sorted(variables):\n            variable_tag[var] = etree.SubElement(self.network, \"VARIABLE\", attrib={'TYPE': 'nature'})\n            etree.SubElement(variable_tag[var], \"NAME\").text = var\n        return variable_tag", "response": "Add variables to XMLBIF object"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the states of the XMLBIF.", "response": "def get_states(self):\n        \"\"\"\n        Add outcome to variables of XMLBIF\n\n        Return\n        ------\n        dict: dict of type {variable: outcome tags}\n\n        Examples\n        --------\n        >>> writer = XMLBIFWriter(model)\n        >>> writer.get_states()\n        {'dog-out': [<Element OUTCOME at 0x7ffbabfcdec8>, <Element OUTCOME at 0x7ffbabfcdf08>],\n         'family-out': [<Element OUTCOME at 0x7ffbabfd4108>, <Element OUTCOME at 0x7ffbabfd4148>],\n         'bowel-problem': [<Element OUTCOME at 0x7ffbabfd4088>, <Element OUTCOME at 0x7ffbabfd40c8>],\n         'hear-bark': [<Element OUTCOME at 0x7ffbabfcdf48>, <Element OUTCOME at 0x7ffbabfcdf88>],\n         'light-on': [<Element OUTCOME at 0x7ffbabfcdfc8>, <Element OUTCOME at 0x7ffbabfd4048>]}\n        \"\"\"\n        outcome_tag = {}\n        cpds = self.model.get_cpds()\n        for cpd in cpds:\n            var = cpd.variable\n            outcome_tag[var] = []\n            if cpd.state_names is None or cpd.state_names.get(var) is None:\n                states = range(cpd.get_cardinality([var])[var])\n            else:\n                states = cpd.state_names[var]\n\n            for state in states:\n                state_tag = etree.SubElement(self.variables[var], \"OUTCOME\")\n                state_tag.text = self._make_valid_state_name(state)\n                outcome_tag[var].append(state_tag)\n        return outcome_tag"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _make_valid_state_name(self, state_name):\n        s = str(state_name)\n        s_fixed = pp.CharsNotIn(pp.alphanums + \"_\").setParseAction(pp.replaceWith(\"_\")).transformString(s)\n        if not s_fixed[0].isalpha():\n            s_fixed = \"state\" + s_fixed\n        return s_fixed", "response": "Transform the input state_name into a valid state in XMLBIF."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget properties of the current object.", "response": "def get_properties(self):\n        \"\"\"\n        Add property to variables in XMLBIF\n\n        Return\n        ------\n        dict: dict of type {variable: property tag}\n\n        Examples\n        --------\n        >>> writer = XMLBIFWriter(model)\n        >>> writer.get_property()\n        {'light-on': <Element PROPERTY at 0x7f7a2ffac1c8>,\n         'family-out': <Element PROPERTY at 0x7f7a2ffac148>,\n         'hear-bark': <Element PROPERTY at 0x7f7a2ffac188>,\n         'bowel-problem': <Element PROPERTY at 0x7f7a2ffac0c8>,\n         'dog-out': <Element PROPERTY at 0x7f7a2ffac108>}\n        \"\"\"\n        variables = self.model.nodes()\n        property_tag = {}\n        for var in sorted(variables):\n            properties = self.model.node[var]\n            property_tag[var] = etree.SubElement(self.variables[var], \"PROPERTY\")\n            for prop, val in properties.items():\n                property_tag[var].text = str(prop) + \" = \" + str(val)\n        return property_tag"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_definition(self):\n        cpds = self.model.get_cpds()\n        cpds.sort(key=lambda x: x.variable)\n        definition_tag = {}\n        for cpd in cpds:\n            definition_tag[cpd.variable] = etree.SubElement(self.network, \"DEFINITION\")\n            etree.SubElement(definition_tag[cpd.variable], \"FOR\").text = cpd.variable\n            for child in sorted(cpd.variables[:0:-1]):\n                etree.SubElement(definition_tag[cpd.variable], \"GIVEN\").text = child\n\n        return definition_tag", "response": "Add Definition to XMLBIF"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_values(self):\n        cpds = self.model.get_cpds()\n        definition_tag = self.definition\n        table_tag = {}\n        for cpd in cpds:\n            table_tag[cpd.variable] = etree.SubElement(definition_tag[cpd.variable], \"TABLE\")\n            table_tag[cpd.variable].text = ''\n            for val in cpd.get_values().ravel(order=\"F\"):\n                table_tag[cpd.variable].text += str(val) + ' '\n\n        return table_tag", "response": "Get the values of the CO - COVER and other related variables."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef write_xmlbif(self, filename):\n        with open(filename, 'w') as fout:\n            fout.write(self.__str__())", "response": "Write the xml data into the file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the marginal distribution over variables.", "response": "def marginal_distribution(self, variables, inplace=True):\n        \"\"\"\n        Returns the marginal distribution over variables.\n\n        Parameters\n        ----------\n        variables: string, list, tuple, set, dict\n                Variable or list of variables over which marginal distribution needs\n                to be calculated\n        inplace: Boolean (default True)\n                If False return a new instance of JointProbabilityDistribution\n\n        Examples\n        --------\n        >>> import numpy as np\n        >>> from pgmpy.factors.discrete import JointProbabilityDistribution\n        >>> values = np.random.rand(12)\n        >>> prob = JointProbabilityDistribution(['x1', 'x2', 'x3'], [2, 3, 2], values/np.sum(values))\n        >>> prob.marginal_distribution(['x1', 'x2'])\n        >>> print(prob)\n        x1    x2      P(x1,x2)\n        ----  ----  ----------\n        x1_0  x2_0      0.1502\n        x1_0  x2_1      0.1626\n        x1_0  x2_2      0.1197\n        x1_1  x2_0      0.2339\n        x1_1  x2_1      0.1996\n        x1_1  x2_2      0.1340\n        \"\"\"\n        return self.marginalize(list(set(list(self.variables)) -\n                                     set(variables if isinstance(\n                                         variables, (list, set, dict, tuple)) else [variables])),\n                                inplace=inplace)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef check_independence(self, event1, event2, event3=None, condition_random_variable=False):\n        JPD = self.copy()\n        if isinstance(event1, six.string_types):\n            raise TypeError('Event 1 should be a list or array-like structure')\n\n        if isinstance(event2, six.string_types):\n            raise TypeError('Event 2 should be a list or array-like structure')\n\n        if event3:\n            if isinstance(event3, six.string_types):\n                raise TypeError('Event 3 cannot of type string')\n\n            elif condition_random_variable:\n                if not all(isinstance(var, six.string_types) for var in event3):\n                    raise TypeError('Event3 should be a 1d list of strings')\n                event3 = list(event3)\n                # Using the definition of conditional independence\n                # If P(X,Y|Z) = P(X|Z)*P(Y|Z)\n                # This can be expanded to P(X,Y,Z)*P(Z) == P(X,Z)*P(Y,Z)\n                phi_z = JPD.marginal_distribution(event3, inplace=False).to_factor()\n                for variable_pair in itertools.product(event1, event2):\n                    phi_xyz = JPD.marginal_distribution(event3 + list(variable_pair), inplace=False).to_factor()\n                    phi_xz = JPD.marginal_distribution(event3 + [variable_pair[0]], inplace=False).to_factor()\n                    phi_yz = JPD.marginal_distribution(event3 + [variable_pair[1]], inplace=False).to_factor()\n                    if phi_xyz * phi_z != phi_xz * phi_yz:\n                        return False\n                return True\n            else:\n                JPD.conditional_distribution(event3)\n\n        for variable_pair in itertools.product(event1, event2):\n            if (JPD.marginal_distribution(variable_pair, inplace=False) !=\n                    JPD.marginal_distribution(variable_pair[0], inplace=False) *\n                    JPD.marginal_distribution(variable_pair[1], inplace=False)):\n                return False\n        return True", "response": "Checks if the Joint Probability Distribution satisfies the given independence condition."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the independent variables in the joint probability distribution.", "response": "def get_independencies(self, condition=None):\n        \"\"\"\n        Returns the independent variables in the joint probability distribution.\n        Returns marginally independent variables if condition=None.\n        Returns conditionally independent variables if condition!=None\n\n        Parameter\n        ---------\n        condition: array_like\n                Random Variable on which to condition the Joint Probability Distribution.\n\n        Examples\n        --------\n        >>> import numpy as np\n        >>> from pgmpy.factors.discrete import JointProbabilityDistribution\n        >>> prob = JointProbabilityDistribution(['x1', 'x2', 'x3'], [2, 3, 2], np.ones(12)/12)\n        >>> prob.get_independencies()\n        (x1 _|_ x2)\n        (x1 _|_ x3)\n        (x2 _|_ x3)\n        \"\"\"\n        JPD = self.copy()\n        if condition:\n            JPD.conditional_distribution(condition)\n        independencies = Independencies()\n        for variable_pair in itertools.combinations(list(JPD.variables), 2):\n            if (JPD.marginal_distribution(variable_pair, inplace=False) ==\n                    JPD.marginal_distribution(variable_pair[0], inplace=False) *\n                    JPD.marginal_distribution(variable_pair[1], inplace=False)):\n                independencies.add_assertions(variable_pair)\n        return independencies"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef conditional_distribution(self, values, inplace=True):\n        JPD = self if inplace else self.copy()\n        JPD.reduce(values)\n        JPD.normalize()\n        if not inplace:\n            return JPD", "response": "Returns a new JointProbabilityDistribution object with conditional distribution of the given set of values."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a Bayesian Model which is minimal IMap of the Joint Probability Distribution considering the order of the random variables.", "response": "def minimal_imap(self, order):\n        \"\"\"\n        Returns a Bayesian Model which is minimal IMap of the Joint Probability Distribution\n        considering the order of the variables.\n\n        Parameters\n        ----------\n        order: array-like\n            The order of the random variables.\n\n        Examples\n        --------\n        >>> import numpy as np\n        >>> from pgmpy.factors.discrete import JointProbabilityDistribution\n        >>> prob = JointProbabilityDistribution(['x1', 'x2', 'x3'], [2, 3, 2], np.ones(12)/12)\n        >>> bayesian_model = prob.minimal_imap(order=['x2', 'x1', 'x3'])\n        >>> bayesian_model\n        <pgmpy.models.models.models at 0x7fd7440a9320>\n        >>> bayesian_model.edges()\n        [('x1', 'x3'), ('x2', 'x3')]\n        \"\"\"\n        from pgmpy.models import BayesianModel\n\n        def get_subsets(u):\n            for r in range(len(u) + 1):\n                for i in itertools.combinations(u, r):\n                    yield i\n\n        G = BayesianModel()\n        for variable_index in range(len(order)):\n            u = order[:variable_index]\n            for subset in get_subsets(u):\n                if (len(subset) < len(u) and\n                        self.check_independence([order[variable_index]], set(u) - set(subset), subset, True)):\n                    G.add_edges_from([(variable, order[variable_index]) for variable in subset])\n        return G"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef is_imap(self, model):\n        from pgmpy.models import BayesianModel\n        if not isinstance(model, BayesianModel):\n            raise TypeError(\"model must be an instance of BayesianModel\")\n        factors = [cpd.to_factor() for cpd in model.get_cpds()]\n        factor_prod = six.moves.reduce(mul, factors)\n        JPD_fact = DiscreteFactor(self.variables, self.cardinality, self.values)\n        if JPD_fact == factor_prod:\n            return True\n        else:\n            return False", "response": "Checks whether the given bayesian model is Imap for Joint Probability Distribution\n       "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _acceptance_prob(self, position, position_bar, momentum, momentum_bar):\n\n        # Parameters to help in evaluating Joint distribution P(position, momentum)\n        _, logp = self.grad_log_pdf(position, self.model).get_gradient_log_pdf()\n        _, logp_bar = self.grad_log_pdf(position_bar, self.model).get_gradient_log_pdf()\n\n        # acceptance_prob = P(position_bar, momentum_bar)/ P(position, momentum)\n        potential_change = logp_bar - logp  # Negative change\n        kinetic_change = 0.5 * np.float(np.dot(momentum_bar.T, momentum_bar) - np.dot(momentum.T, momentum))\n\n        # acceptance probability\n        return np.exp(potential_change - kinetic_change)", "response": "Returns the acceptance probability for given new position and momentum"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns True if the condition is met for the given acceptance probability.", "response": "def _get_condition(self, acceptance_prob, a):\n        \"\"\"\n        Temporary method to fix issue in numpy 0.12 #852\n        \"\"\"\n        if a == 1:\n            return (acceptance_prob ** a) > (1/(2**a))\n        else:\n            return (1/(acceptance_prob ** a)) > (2**(-a))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nfinding a reasonable stepsize for a given position.", "response": "def _find_reasonable_stepsize(self, position, stepsize_app=1):\n        \"\"\"\n        Method for choosing initial value of stepsize\n\n        References\n        -----------\n        Matthew D. Hoffman, Andrew Gelman, The No-U-Turn Sampler: Adaptively\n        Setting Path Lengths in Hamiltonian Monte Carlo. Journal of\n        Machine Learning Research 15 (2014) 1351-1381\n        Algorithm 4 : Heuristic for choosing an initial value of epsilon\n        \"\"\"\n        # momentum = N(0, I)\n        momentum = np.reshape(np.random.normal(0, 1, len(position)), position.shape)\n\n        # Take a single step in time\n        position_bar, momentum_bar, _ =\\\n            self.simulate_dynamics(self.model, position, momentum,\n                                   stepsize_app, self.grad_log_pdf).get_proposed_values()\n\n        acceptance_prob = self._acceptance_prob(position, position_bar, momentum, momentum_bar)\n\n        # a = 2I[acceptance_prob] -1\n        a = 2 * (acceptance_prob > 0.5) - 1\n\n        condition = self._get_condition(acceptance_prob, a)\n\n        while condition:\n            stepsize_app = (2 ** a) * stepsize_app\n\n            position_bar, momentum_bar, _ =\\\n                self.simulate_dynamics(self.model, position, momentum,\n                                       stepsize_app, self.grad_log_pdf).get_proposed_values()\n\n            acceptance_prob = self._acceptance_prob(position, position_bar, momentum, momentum_bar)\n\n            condition = self._get_condition(acceptance_prob, a)\n\n        return stepsize_app"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _sample(self, position, trajectory_length, stepsize, lsteps=None):\n        # Resampling momentum\n        momentum = np.reshape(np.random.normal(0, 1, len(position)), position.shape)\n\n        # position_m here will be the previous sampled value of position\n        position_bar, momentum_bar = position.copy(), momentum\n\n        # Number of steps L to simulate dynamics\n        if lsteps is None:\n            lsteps = int(max(1, round(trajectory_length / stepsize, 0)))\n\n        grad_bar, _ = self.grad_log_pdf(position_bar, self.model).get_gradient_log_pdf()\n\n        for _ in range(lsteps):\n            position_bar, momentum_bar, grad_bar =\\\n                self.simulate_dynamics(self.model, position_bar, momentum_bar,\n                                       stepsize, self.grad_log_pdf, grad_bar).get_proposed_values()\n\n        acceptance_prob = self._acceptance_prob(position, position_bar, momentum, momentum_bar)\n\n        # Metropolis acceptance probability\n        alpha = min(1, acceptance_prob)\n\n        # Accept or reject the new proposed value of position, i.e position_bar\n        if np.random.rand() < alpha:\n            position = position_bar.copy()\n            self.accepted_proposals += 1.0\n\n        return position, alpha", "response": "Runs a single sampling iteration to return a sample of dynamics and the acceptance probability of the dynamics."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadapt the parameters for the stepsize stepsize_bar h_bar and mu for better proposals of position", "response": "def _adapt_params(self, stepsize, stepsize_bar, h_bar, mu, index_i, alpha, n_alpha=1):\n        \"\"\"\n        Run tha adaptation for stepsize for better proposals of position\n        \"\"\"\n        gamma = 0.05  # free parameter that controls the amount of shrinkage towards mu\n        t0 = 10.0  # free parameter that stabilizes the initial iterations of the algorithm\n        kappa = 0.75\n        # See equation (6) section 3.2.1 for details\n\n        estimate = 1.0 / (index_i + t0)\n        h_bar = (1 - estimate) * h_bar + estimate * (self.delta - alpha / n_alpha)\n\n        stepsize = np.exp(mu - sqrt(index_i) / gamma * h_bar)\n        i_kappa = index_i ** (-kappa)\n        stepsize_bar = np.exp(i_kappa * np.log(stepsize) + (1 - i_kappa) * np.log(stepsize_bar))\n\n        return stepsize, stepsize_bar, h_bar"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn True if arg is a list of states example - [ x1 x2 x1 hard ]", "response": "def is_list_of_states(self, arg):\n        \"\"\"\n        A list of states example -\n        [('x1', 'easy'), ('x2', 'hard')]\n\n        Returns\n        -------\n        True, if arg is a list of states else False.\n\n        \"\"\"\n        return isinstance(arg, list) and all(isinstance(i, tuple) for i in arg)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nadd an edge between u and v.", "response": "def add_edge(self, u, v, weight=None):\n        \"\"\"\n        Add an edge between u and v.\n\n        The nodes u and v will be automatically added if they are\n        not already in the graph.\n\n        Parameters\n        ----------\n        u, v : nodes\n            Nodes can be any hashable Python object.\n\n        weight: int, float (default=None)\n            The weight of the edge.\n\n        Examples\n        --------\n        >>> from pgmpy.base import UndirectedGraph\n        >>> G = UndirectedGraph()\n        >>> G.add_nodes_from(nodes=['Alice', 'Bob', 'Charles'])\n        >>> G.add_edge(u='Alice', v='Bob')\n        >>> G.nodes()\n        ['Alice', 'Bob', 'Charles']\n        >>> G.edges()\n        [('Alice', 'Bob')]\n\n        When the node is not already present in the graph:\n        >>> G.add_edge(u='Alice', v='Ankur')\n        >>> G.nodes()\n        ['Alice', 'Ankur', 'Bob', 'Charles']\n        >>> G.edges()\n        [('Alice', 'Bob'), ('Alice', 'Ankur')]\n\n        Adding edges with weight:\n        >>> G.add_edge('Ankur', 'Maria', weight=0.1)\n        >>> G.edge['Ankur']['Maria']\n        {'weight': 0.1}\n        \"\"\"\n        super(UndirectedGraph, self).add_edge(u, v, weight=weight)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncheck if the given nodes form a clique.", "response": "def is_clique(self, nodes):\n        \"\"\"\n        Check if the given nodes form a clique.\n\n        Parameters\n        ----------\n        nodes: list, array-like\n            List of nodes to check if they are a part of any clique.\n\n        Examples\n        --------\n        >>> from pgmpy.base import UndirectedGraph\n        >>> G = UndirectedGraph(ebunch=[('A', 'B'), ('C', 'B'), ('B', 'D'),\n                                        ('B', 'E'), ('D', 'E'), ('E', 'F'),\n                                        ('D', 'F'), ('B', 'F')])\n        >>> G.is_clique(nodes=['A', 'B', 'C', 'D'])\n        False\n        >>> G.is_clique(nodes=['B', 'D', 'E', 'F'])\n        True\n\n        Since B, D, E and F are clique, any subset of these should also\n        be clique.\n        >>> G.is_clique(nodes=['D', 'E', 'B'])\n        True\n        \"\"\"\n        for node1, node2 in itertools.combinations(nodes, 2):\n            if not self.has_edge(node1, node2):\n                return False\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_start_state(self, start_state):\n        if start_state is not None:\n            if not hasattr(start_state, '__iter__') or isinstance(start_state, six.string_types):\n                raise ValueError('start_state must be a non-string iterable.')\n            # Must be an array-like iterable. Reorder according to self.variables.\n            state_dict = {var: st for var, st in start_state}\n            start_state = [State(var, state_dict[var]) for var in self.variables]\n        if start_state is None or self._check_state(start_state):\n            self.state = start_state", "response": "Set the start state of the object in the Markov Chain."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _check_state(self, state):\n        if not hasattr(state, '__iter__') or isinstance(state, six.string_types):\n            raise ValueError('Start state must be a non-string iterable object.')\n        state_vars = {s.var for s in state}\n        if not state_vars == set(self.variables):\n            raise ValueError('Start state must represent a complete assignment to all variables.'\n                             'Expected variables in state: {svar}, Got: {mvar}.'.format(svar=state_vars,\n                                                                                        mvar=set(self.variables)))\n        for var, val in state:\n            if val >= self.cardinalities[var]:\n                raise ValueError('Assignment {val} to {var} invalid.'.format(val=val, var=var))\n        return True", "response": "Checks if a list representing the state of the variables is valid."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef add_variable(self, variable, card=0):\n        if variable not in self.variables:\n            self.variables.append(variable)\n        else:\n            warn('Variable {var} already exists.'.format(var=variable))\n        self.cardinalities[variable] = card\n        self.transition_models[variable] = {}", "response": "Add a variable to the model."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add_variables_from(self, variables, cards):\n        for var, card in zip(variables, cards):\n            self.add_variable(var, card)", "response": "Add several variables to the model at once."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add_transition_model(self, variable, transition_model):\n        if isinstance(transition_model, list):\n            transition_model = np.array(transition_model)\n\n        # check if the transition model is valid\n        if not isinstance(transition_model, dict):\n            if not isinstance(transition_model, np.ndarray):\n                raise ValueError('Transition model must be a dict or numpy array')\n            elif len(transition_model.shape) != 2:\n                raise ValueError('Transition model must be 2d array.given {t}'.format(t=transition_model.shape))\n            elif transition_model.shape[0] != transition_model.shape[1]:\n                raise ValueError('Dimension mismatch {d1}!={d2}'.format(d1=transition_model.shape[0],\n                                 d2=transition_model.shape[1]))\n            else:\n                # convert the matrix to dict\n                size = transition_model.shape[0]\n                transition_model = dict((i, dict((j, float(transition_model[i][j]))\n                                         for j in range(0, size))) for i in range(0, size))\n\n        exp_states = set(range(self.cardinalities[variable]))\n        tm_states = set(transition_model.keys())\n        if not exp_states == tm_states:\n            raise ValueError('Transitions must be defined for all states of variable {v}. '\n                             'Expected states: {es}, Got: {ts}.'.format(v=variable, es=exp_states, ts=tm_states))\n\n        for _, transition in transition_model.items():\n            if not isinstance(transition, dict):\n                raise ValueError('Each transition must be a dict.')\n            prob_sum = 0\n\n            for _, prob in transition.items():\n                if prob < 0 or prob > 1:\n                    raise ValueError('Transitions must represent valid probability weights.')\n                prob_sum += prob\n\n            if not np.allclose(prob_sum, 1):\n                raise ValueError('Transition probabilities must sum to 1.')\n\n        self.transition_models[variable] = transition_model", "response": "Adds a transition model for a particular variable."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef sample(self, start_state=None, size=1):\n        if start_state is None:\n            if self.state is None:\n                self.state = self.random_state()\n            # else use previously-set state\n        else:\n            self.set_start_state(start_state)\n\n        sampled = DataFrame(index=range(size), columns=self.variables)\n        sampled.loc[0] = [st for var, st in self.state]\n\n        var_states = defaultdict(dict)\n        var_values = defaultdict(dict)\n        samples = defaultdict(dict)\n        for var in self.transition_models.keys():\n            for st in self.transition_models[var]:\n                var_states[var][st] = list(self.transition_models[var][st].keys())\n                var_values[var][st] = list(self.transition_models[var][st].values())\n                samples[var][st] = sample_discrete(var_states[var][st], var_values[var][st], size=size)\n\n        for i in range(size - 1):\n            for j, (var, st) in enumerate(self.state):\n                next_st = samples[var][st][i]\n                self.state[j] = State(var, next_st)\n            sampled.loc[i + 1] = [st for var, st in self.state]\n\n        return sampled", "response": "Sample from the Markov Chain."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef prob_from_sample(self, state, sample=None, window_size=None):\n        if sample is None:\n            # generate sample of size 10000\n            sample = self.sample(self.random_state(), size=10000)\n        if window_size is None:\n            window_size = len(sample) // 100  # default window size is 100\n        windows = len(sample) // window_size\n        probabilities = np.zeros(windows)\n\n        for i in range(windows):\n            for j in range(window_size):\n                ind = i * window_size + j\n                state_eq = [sample.loc[ind, v] == s for v, s in state]\n                if all(state_eq):\n                    probabilities[i] += 1\n\n        return probabilities / window_size", "response": "Given a state and a sample compute the probability of observing it over multiple windows in a given sample."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef is_stationarity(self, tolerance=0.2, sample=None):\n        keys = self.transition_models.keys()\n        return_val = True\n        for k in keys:\n            # convert dict to numpy matrix\n            transition_mat = np.array([np.array(list(self.transition_models[k][i].values()))\n                                       for i in self.transition_models[k].keys()], dtype=np.float)\n            S, U = eig(transition_mat.T)\n            stationary = np.array(U[:, np.where(np.abs(S - 1.) < 1e-8)[0][0]].flat)\n            stationary = (stationary / np.sum(stationary)).real\n\n            probabilites = []\n            window_size = 10000 if sample is None else len(sample)\n            for i in range(0, transition_mat.shape[0]):\n                probabilites.extend(self.prob_from_sample([State(k, i)], window_size=window_size))\n            if any(np.abs(i) > tolerance for i in np.subtract(probabilites, stationary)):\n                return_val = return_val and False\n            else:\n                return_val = return_val and True\n\n        return return_val", "response": "Checks if the given markov chain is stationary and checks the steady state distribution within the given tolerance."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngenerating a random state of the Markov Chain.", "response": "def random_state(self):\n        \"\"\"\n        Generates a random state of the Markov Chain.\n\n        Return Type:\n        ------------\n        List of namedtuples, representing a random assignment to all variables of the model.\n\n        Examples:\n        ---------\n        >>> from pgmpy.models import MarkovChain as MC\n        >>> model = MC(['intel', 'diff'], [2, 3])\n        >>> model.random_state()\n        [State('diff', 2), State('intel', 1)]\n        \"\"\"\n        return [State(var, np.random.randint(self.cardinalities[var])) for var in self.variables]"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a copy of the Markov Chain Model.", "response": "def copy(self):\n        \"\"\"\n        Returns a copy of Markov Chain Model.\n\n        Return Type:\n        ------------\n        MarkovChain : Copy of MarkovChain.\n\n        Examples:\n        ---------\n        >>> from pgmpy.models import MarkovChain\n        >>> from pgmpy.factors.discrete import State\n        >>> model = MarkovChain()\n        >>> model.add_variables_from(['intel', 'diff'], [3, 2])\n        >>> intel_tm = {0: {0: 0.2, 1: 0.4, 2:0.4}, 1: {0: 0, 1: 0.5, 2: 0.5}, 2: {0: 0.3, 1: 0.3, 2: 0.4}}\n        >>> model.add_transition_model('intel', intel_tm)\n        >>> diff_tm = {0: {0: 0.5, 1: 0.5}, 1: {0: 0.25, 1:0.75}}\n        >>> model.add_transition_model('diff', diff_tm)\n        >>> model.set_start_state([State('intel', 0), State('diff', 2)])\n        >>> model_copy = model.copy()\n        >>> model_copy.transition_models\n        >>> {'diff': {0: {0: 0.1, 1: 0.5, 2: 0.4}, 1: {0: 0.2, 1: 0.2, 2: 0.6}, 2: {0: 0.7, 1: 0.15, 2: 0.15}},\n             'intel': {0: {0: 0.25, 1: 0.75}, 1: {0: 0.5, 1: 0.5}}}\n        \"\"\"\n        markovchain_copy = MarkovChain(variables=list(self.cardinalities.keys()),\n                                       card=list(self.cardinalities.values()), start_state=self.state)\n        if self.transition_models:\n            markovchain_copy.transition_models = self.transition_models.copy()\n\n        return markovchain_copy"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef contains(self, assertion):\n        if not isinstance(assertion, IndependenceAssertion):\n            raise TypeError(\"' in <Independencies()>' requires IndependenceAssertion\" +\n                            \" as left operand, not {0}\".format(type(assertion)))\n\n        return assertion in self.get_assertions()", "response": "Returns True if assertion is contained in this Independencies - object otherwise False."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add_assertions(self, *assertions):\n        for assertion in assertions:\n            if isinstance(assertion, IndependenceAssertion):\n                self.independencies.append(assertion)\n            else:\n                try:\n                    self.independencies.append(IndependenceAssertion(assertion[0], assertion[1], assertion[2]))\n                except IndexError:\n                    self.independencies.append(IndependenceAssertion(assertion[0], assertion[1]))", "response": "Adds assertions to independencies."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef closure(self):\n\n        def single_var(var):\n            \"Checks if var represents a single variable\"\n            if not hasattr(var, '__iter__'):\n                return True\n            else:\n                return len(var) == 1\n\n        def sg0(ind):\n            \"Symmetry rule: 'X \u27c2 Y | Z' -> 'Y \u27c2 X | Z'\"\n            return IndependenceAssertion(ind.event2, ind.event1, ind.event3)\n\n        # since X\u27c2Y|Z == Y\u27c2X|Z in pgmpy, sg0 (symmetry) is not used as an axiom/rule.\n        # instead we use a decorator for the other axioms to apply them on both sides\n        def apply_left_and_right(func):\n            def symmetric_func(*args):\n                if len(args) == 1:\n                    return func(args[0]) + func(sg0(args[0]))\n                if len(args) == 2:\n                    return (func(*args) + func(args[0], sg0(args[1])) +\n                            func(sg0(args[0]), args[1]) + func(sg0(args[0]), sg0(args[1])))\n            return symmetric_func\n\n        @apply_left_and_right\n        def sg1(ind):\n            \"Decomposition rule: 'X \u27c2 Y,W | Z' -> 'X \u27c2 Y | Z', 'X \u27c2 W | Z'\"\n            if single_var(ind.event2):\n                return []\n            else:\n                return [IndependenceAssertion(ind.event1, ind.event2 - {elem}, ind.event3)\n                        for elem in ind.event2]\n\n        @apply_left_and_right\n        def sg2(ind):\n            \"Weak Union rule: 'X \u27c2 Y,W | Z' -> 'X \u27c2 Y | W,Z', 'X \u27c2 W | Y,Z' \"\n            if single_var(ind.event2):\n                return []\n            else:\n                return [IndependenceAssertion(ind.event1, ind.event2 - {elem}, {elem} | ind.event3)\n                        for elem in ind.event2]\n\n        @apply_left_and_right\n        def sg3(ind1, ind2):\n            \"Contraction rule: 'X \u27c2 W | Y,Z' & 'X \u27c2 Y | Z' -> 'X \u27c2 W,Y | Z'\"\n            if ind1.event1 != ind2.event1:\n                return []\n\n            Y = ind2.event2\n            Z = ind2.event3\n            Y_Z = ind1.event3\n            if Y < Y_Z and Z < Y_Z and Y.isdisjoint(Z):\n                return [IndependenceAssertion(ind1.event1, ind1.event2 | Y, Z)]\n            else:\n                return []\n\n        # apply semi-graphoid axioms as long as new independencies are found.\n        all_independencies = set()\n        new_inds = set(self.independencies)\n\n        while new_inds:\n            new_pairs = (set(itertools.permutations(new_inds, 2)) |\n                         set(itertools.product(new_inds, all_independencies)) |\n                         set(itertools.product(all_independencies, new_inds)))\n\n            all_independencies |= new_inds\n            new_inds = set(sum([sg1(ind) for ind in new_inds] +\n                               [sg2(ind) for ind in new_inds] +\n                               [sg3(*inds) for inds in new_pairs], []))\n            new_inds -= all_independencies\n\n        return Independencies(*list(all_independencies))", "response": "Returns a new Independencies - object that contains those IndependenceAssertions that are implied by the current independencies."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef entails(self, entailed_independencies):\n        if not isinstance(entailed_independencies, Independencies):\n            return False\n\n        implications = self.closure().get_assertions()\n        return all(ind in implications for ind in entailed_independencies.get_assertions())", "response": "Returns True if the entailed_independencies are implied by this Independencies - object otherwise False."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding an edge between u and v.", "response": "def add_edge(self, u, v, *kwargs):\n        \"\"\"\n        Add an edge between u and v.\n\n        The nodes u and v will be automatically added if they are\n        not already in the graph\n\n        Parameters\n        ----------\n        u,v : nodes\n              Nodes can be any hashable python object.\n\n        Examples\n        --------\n        >>> from pgmpy.models import NaiveBayes\n        >>> G = NaiveBayes()\n        >>> G.add_nodes_from(['a', 'b', 'c'])\n        >>> G.add_edge('a', 'b')\n        >>> G.add_edge('a', 'c')\n        >>> G.edges()\n        [('a', 'c'), ('a', 'b')]\n        \"\"\"\n\n        if self.parent_node and u != self.parent_node:\n            raise ValueError(\"Model can have only one parent node.\")\n        self.parent_node = u\n        self.children_nodes.add(v)\n        super(NaiveBayes, self).add_edge(u, v, *kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _get_ancestors_of(self, obs_nodes_list):\n        if not obs_nodes_list:\n            return set()\n        return set(obs_nodes_list) | set(self.parent_node)", "response": "Returns a list of all the ancestors of all the observed nodes."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning all the nodes reachable from start via an active trail.", "response": "def active_trail_nodes(self, start, observed=None):\n        \"\"\"\n        Returns all the nodes reachable from start via an active trail.\n\n        Parameters\n        ----------\n        start: Graph node\n\n        observed : List of nodes (optional)\n            If given the active trail would be computed assuming these nodes to be observed.\n\n        Examples\n        --------\n        >>> from pgmpy.models import NaiveBayes\n        >>> model = NaiveBayes()\n        >>> model.add_nodes_from(['a', 'b', 'c', 'd'])\n        >>> model.add_edges_from([('a', 'b'), ('a', 'c'), ('a', 'd')])\n        >>> model.active_trail_nodes('a')\n        {'a', 'b', 'c', 'd'}\n        >>> model.active_trail_nodes('a', ['b', 'c'])\n        {'a', 'd'}\n        >>> model.active_trail_nodes('b', ['a'])\n        {'b'}\n        \"\"\"\n\n        if observed and self.parent_node in observed:\n            return set(start)\n        else:\n            return set(self.nodes()) - set(observed if observed else [])"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn an Independencies containing the local independencies of each of the variables.", "response": "def local_independencies(self, variables):\n        \"\"\"\n        Returns an instance of Independencies containing the local independencies\n        of each of the variables.\n\n\n        Parameters\n        ----------\n        variables: str or array like\n            variables whose local independencies are to found.\n\n        Examples\n        --------\n        >>> from pgmpy.models import NaiveBayes\n        >>> model = NaiveBayes()\n        >>> model.add_edges_from([('a', 'b'), ('a', 'c'), ('a', 'd')])\n        >>> ind = model.local_independencies('b')\n        >>> ind\n        (b _|_ d, c | a)\n        \"\"\"\n        independencies = Independencies()\n        for variable in [variables] if isinstance(variables, str) else variables:\n            if variable != self.parent_node:\n                independencies.add_assertions(\n                    [variable, list(\n                        set(self.children_nodes) - set(variable)), self.parent_node])\n        return independencies"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nfits the model to a given data.", "response": "def fit(self, data, parent_node=None, estimator=None):\n        \"\"\"\n        Computes the CPD for each node from a given data in the form of a pandas dataframe.\n        If a variable from the data is not present in the model, it adds that node into the model.\n\n        Parameters\n        ----------\n        data : pandas DataFrame object\n            A DataFrame object with column names same as the variable names of network\n\n        parent_node: any hashable python object (optional)\n            Parent node of the model, if not specified it looks for a previously specified\n            parent node.\n\n        estimator: Estimator class\n            Any pgmpy estimator. If nothing is specified, the default ``MaximumLikelihoodEstimator``\n            would be used.\n\n        Examples\n        --------\n        >>> import numpy as np\n        >>> import pandas as pd\n        >>> from pgmpy.models import NaiveBayes\n        >>> model = NaiveBayes()\n        >>> values = pd.DataFrame(np.random.randint(low=0, high=2, size=(1000, 5)),\n        ...                       columns=['A', 'B', 'C', 'D', 'E'])\n        >>> model.fit(values, 'A')\n        >>> model.get_cpds()\n        [<TabularCPD representing P(D:2 | A:2) at 0x4b72870>,\n         <TabularCPD representing P(E:2 | A:2) at 0x4bb2150>,\n         <TabularCPD representing P(A:2) at 0x4bb23d0>,\n         <TabularCPD representing P(B:2 | A:2) at 0x4bb24b0>,\n         <TabularCPD representing P(C:2 | A:2) at 0x4bb2750>]\n        >>> model.edges()\n        [('A', 'D'), ('A', 'E'), ('A', 'B'), ('A', 'C')]\n        \"\"\"\n        if not parent_node:\n            if not self.parent_node:\n                raise ValueError(\"parent node must be specified for the model\")\n            else:\n                parent_node = self.parent_node\n        if parent_node not in data.columns:\n            raise ValueError(\"parent node: {node} is not present in the given data\".format(node=parent_node))\n        for child_node in data.columns:\n            if child_node != parent_node:\n                self.add_edge(parent_node, child_node)\n        super(NaiveBayes, self).fit(data, estimator)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncomputing a score to measure how well the given BayesianModel fits to the data set.", "response": "def score(self, model):\n        \"\"\"\n        Computes a score to measure how well the given `BayesianModel` fits to the data set.\n        (This method relies on the `local_score`-method that is implemented in each subclass.)\n\n        Parameters\n        ----------\n        model: `BayesianModel` instance\n            The Bayesian network that is to be scored. Nodes of the BayesianModel need to coincide\n            with column names of data set.\n\n        Returns\n        -------\n        score: float\n            A number indicating the degree of fit between data and model\n\n        Examples\n        -------\n        >>> import pandas as pd\n        >>> import numpy as np\n        >>> from pgmpy.estimators import K2Score\n        >>> # create random data sample with 3 variables, where B and C are identical:\n        >>> data = pd.DataFrame(np.random.randint(0, 5, size=(5000, 2)), columns=list('AB'))\n        >>> data['C'] = data['B']\n        >>> K2Score(data).score(BayesianModel([['A','B'], ['A','C']]))\n        -24242.367348745247\n        >>> K2Score(data).score(BayesianModel([['A','B'], ['B','C']]))\n        -16273.793897051042\n        \"\"\"\n\n        score = 0\n        for node in model.nodes():\n            score += self.local_score(node, model.predecessors(node))\n        score += self.structure_prior(model)\n        return score"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef local_score(self, variable, parents):\n        \"Computes a score that measures how much a \\\n        given variable is \\\"influenced\\\" by a given list of potential parents.\"\n\n        var_states = self.state_names[variable]\n        var_cardinality = len(var_states)\n        state_counts = self.state_counts(variable, parents)\n        sample_size = len(self.data)\n        num_parents_states = float(len(state_counts.columns))\n\n        score = 0\n        for parents_state in state_counts:  # iterate over df columns (only 1 if no parents)\n            conditional_sample_size = sum(state_counts[parents_state])\n\n            for state in var_states:\n                if state_counts[parents_state][state] > 0:\n                    score += state_counts[parents_state][state] * (log(state_counts[parents_state][state]) -\n                                                                   log(conditional_sample_size))\n\n        score -= 0.5 * log(sample_size) * num_parents_states * (var_cardinality - 1)\n\n        return score", "response": "Computes a score that measures how much a \\\n given variable is influenced by a given list of potential parents."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngenerates a cartesian product of the input arrays.", "response": "def cartesian(arrays, out=None):\n    \"\"\"Generate a cartesian product of input arrays.\n\n    Parameters\n    ----------\n    arrays : list of array-like\n        1-D arrays to form the cartesian product of.\n    out : ndarray\n        Array to place the cartesian product in.\n\n    Returns\n    -------\n    out : ndarray\n        2-D array of shape (M, len(arrays)) containing cartesian products\n        formed of input arrays.\n\n    Examples\n    --------\n    >>> cartesian(([1, 2, 3], [4, 5], [6, 7]))\n    array([[1, 4, 6],\n           [1, 4, 7],\n           [1, 5, 6],\n           [1, 5, 7],\n           [2, 4, 6],\n           [2, 4, 7],\n           [2, 5, 6],\n           [2, 5, 7],\n           [3, 4, 6],\n           [3, 4, 7],\n           [3, 5, 6],\n           [3, 5, 7]])\n\n    \"\"\"\n    arrays = [np.asarray(x) for x in arrays]\n    shape = (len(x) for x in arrays)\n    dtype = arrays[0].dtype\n\n    ix = np.indices(shape)\n    ix = ix.reshape(len(arrays), -1).T\n\n    if out is None:\n        out = np.empty_like(ix, dtype=dtype)\n\n    for n, arr in enumerate(arrays):\n        out[:, n] = arrays[n][ix[:, n]]\n\n    return out"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef sample_discrete(values, weights, size=1):\n    weights = np.array(weights)\n    if weights.ndim == 1:\n        return np.random.choice(values, size=size, p=weights)\n    else:\n        return np.fromiter(map(lambda t: np.random.choice(values, p=t), weights), dtype='int')", "response": "Generates a random variable from a given PMF."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ngenerate all subsets of list l.", "response": "def powerset(l):\n    \"\"\"\n    Generates all subsets of list `l` (as tuples).\n\n    Example\n    -------\n    >>> from pgmpy.utils.mathext import powerset\n    >>> list(powerset([1,2,3]))\n    [(), (1,), (2,), (3,), (1,2), (1,3), (2,3), (1,2,3)]\n    \"\"\"\n    return chain.from_iterable(combinations(l, r) for r in range(len(l)+1))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef clean_draft_pages_from_space(confluence, space_key, count, date_now):\n    pages = confluence.get_all_draft_pages_from_space(space=space_key, start=0, limit=500)\n    for page in pages:\n        page_id = page['id']\n        draft_page = confluence.get_draft_page_by_id(page_id=page_id)\n        last_date_string = draft_page['version']['when']\n        last_date = datetime.datetime.strptime(last_date_string.replace(\".000\", \"\")[:-6], \"%Y-%m-%dT%H:%M:%S\")\n        if (date_now - last_date) > datetime.timedelta(days=DRAFT_DAYS):\n            count += 1\n            print(\"Removing page with page id: \" + page_id)\n            confluence.remove_page_as_draft(page_id=page_id)\n            print(\"Removed page with date \" + last_date_string)\n    return count", "response": "Remove draft pages from the given space using datetime. now\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef clean_all_draft_pages_from_all_spaces(confluence, days=30):\n    date_now = datetime.datetime.now()\n    count = 0\n    limit = 50\n    flag = True\n    i = 0\n    while flag:\n        space_lists = confluence.get_all_spaces(start=i * limit, limit=limit)\n        if space_lists and len(space_lists) != 0:\n            i += 1\n            for space_list in space_lists:\n                print(\"Start review the space {}\".format(space_list['key']))\n                count = clean_draft_pages_from_space(confluence=confluence, space_key=space_list['key'], count=count,\n                                                     date_now=date_now)\n        else:\n            flag = False\n    print(\"Script has removed {count} draft pages older than {days} days\".format(count=count, days=days))", "response": "Remove all draft pages for all spaces older than DRAFT_DAYS\n   "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_page_child_by_type(self, page_id, type='page', start=None, limit=None):\n        params = {}\n        if start is not None:\n            params['start'] = int(start)\n        if limit is not None:\n            params['limit'] = int(limit)\n\n        url = 'rest/api/content/{page_id}/child/{type}'.format(page_id=page_id, type=type)\n        log.info(url)\n        try:\n            return (self.get(url, params=params) or {}).get('results')\n        except IndexError as e:\n            log.error(e)\n            return None", "response": "Get content by type."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_page_by_title(self, space, title, start=None, limit=None):\n        url = 'rest/api/content'\n        params = {}\n        if start is not None:\n            params['start'] = int(start)\n        if limit is not None:\n            params['limit'] = int(limit)\n        if space is not None:\n            params['spaceKey'] = str(space)\n        if space is not None:\n            params['title'] = str(title)\n        try:\n            return (self.get(url, params=params) or {}).get('results')[0]\n        except IndexError as e:\n            log.error(e)\n            return None", "response": "Returns the list of labels on a piece of Content."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_page_by_id(self, page_id, expand=None):\n        url = 'rest/api/content/{page_id}?expand={expand}'.format(page_id=page_id, expand=expand)\n        return self.get(url)", "response": "Get a specific content by ID"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_page_labels(self, page_id, prefix=None, start=None, limit=None):\n        url = 'rest/api/content/{id}/label'.format(id=page_id)\n        params = {}\n        if prefix:\n            params['prefix'] = prefix\n        if start is not None:\n            params['start'] = int(start)\n        if limit is not None:\n            params['limit'] = int(limit)\n        return self.get(url, params=params)", "response": "Returns the list of labels on a piece of Content."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets a draft page by id", "response": "def get_draft_page_by_id(self, page_id, status='draft'):\n        \"\"\"\n        Provide content by id with status = draft\n        :param page_id:\n        :param status:\n        :return:\n        \"\"\"\n        url = 'rest/api/content/{page_id}?status={status}'.format(page_id=page_id, status=status)\n        return self.get(url)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_all_pages_by_label(self, label, start=0, limit=50):\n        url = 'rest/api/content/search'\n        params = {}\n        if label:\n            params['cql'] = 'type={type}%20AND%20label={label}'.format(type='page',\n                                                                       label=label)\n        if start:\n            params['start'] = start\n        if limit:\n            params['limit'] = limit\n        return (self.get(url, params=params) or {}).get('results')", "response": "Get all pages by label"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget all pages from a given space.", "response": "def get_all_pages_from_space(self, space, start=0, limit=500, status=None):\n        \"\"\"\n        Get all pages from space\n        :param space:\n        :param start: OPTIONAL: The start point of the collection to return. Default: None (0).\n        :param limit: OPTIONAL: The limit of the number of pages to return, this may be restricted by\n                            fixed system limits. Default: 50\n        :param status: OPTIONAL\n        :return:\n        \"\"\"\n        url = 'rest/api/content'\n        params = {}\n        if space:\n            params['spaceKey'] = space\n        if start:\n            params['start'] = start\n        if limit:\n            params['limit'] = limit\n        if status:\n            params['status'] = status\n        return (self.get(url, params=params) or {}).get('results')"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets list of pages from trash.", "response": "def get_all_pages_from_space_trash(self, space, start=0, limit=500, status='trashed'):\n        \"\"\"\n        Get list of pages from trash\n        :param space:\n        :param start: OPTIONAL: The start point of the collection to return. Default: None (0).\n        :param limit: OPTIONAL: The limit of the number of pages to return, this may be restricted by\n                            fixed system limits. Default: 500\n        :param status:\n        :return:\n        \"\"\"\n        return self.get_all_pages_from_space(space, start, limit, status)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting all draft pages from a given space", "response": "def get_all_draft_pages_from_space(self, space, start=0, limit=500, status='draft'):\n        \"\"\"\n        Get list of draft pages from space\n        Use case is cleanup old drafts from Confluence\n        :param space:\n        :param start: OPTIONAL: The start point of the collection to return. Default: None (0).\n        :param limit: OPTIONAL: The limit of the number of pages to return, this may be restricted by\n                            fixed system limits. Default: 500\n        :param status:\n        :return:\n        \"\"\"\n        return self.get_all_pages_from_space(space, start, limit, status)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_all_draft_pages_from_space_through_cql(self, space, start=0, limit=500, status='draft'):\n        url = 'rest/api/content?cql=space=spaceKey={space} and status={status}'.format(space=space,\n                                                                                       status=status)\n        params = {}\n        if limit:\n            params['limit'] = limit\n        if start:\n            params['start'] = start\n        return (self.get(url, params=params) or {}).get('results')", "response": "Search list of draft pages from a given space key."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates page from scratch", "response": "def create_page(self, space, title, body, parent_id=None, type='page'):\n        \"\"\"\n        Create page from scratch\n        :param space:\n        :param title:\n        :param body:\n        :param parent_id:\n        :param type:\n        :return:\n        \"\"\"\n        log.info('Creating {type} \"{space}\" -> \"{title}\"'.format(space=space, title=title, type=type))\n        url = 'rest/api/content/'\n        data = {\n            'type': type,\n            'title': title,\n            'space': {'key': space},\n            'body': {'storage': {\n                'value': body,\n                'representation': 'storage'}}}\n        if parent_id:\n            data['ancestors'] = [{'type': type, 'id': parent_id}]\n        return self.post(url, data=data)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets all spaces with provided limit", "response": "def get_all_spaces(self, start=0, limit=500):\n        \"\"\"\n        Get all spaces with provided limit\n        :param start: OPTIONAL: The start point of the collection to return. Default: None (0).\n        :param limit: OPTIONAL: The limit of the number of pages to return, this may be restricted by\n                            fixed system limits. Default: 500\n        \"\"\"\n        url = 'rest/api/space'\n        params = {}\n        if limit:\n            params['limit'] = limit\n        if start:\n            params['start'] = start\n        return (self.get(url, params=params) or {}).get('results')"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nadd comment into page", "response": "def add_comment(self, page_id, text):\n        \"\"\"\n        Add comment into page\n        :param page_id\n        :param text\n        \"\"\"\n        data = {'type': 'comment',\n                'container': {'id': page_id, 'type': 'page', 'status': 'current'},\n                'body': {'storage': {'value': text, 'representation': 'storage'}}}\n        return self.post('rest/api/content/', data=data)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef attach_file(self, filename, page_id=None, title=None, space=None, comment=None):\n        page_id = self.get_page_id(space=space, title=title) if page_id is None else page_id\n        type = 'attachment'\n        if page_id is not None:\n            extension = os.path.splitext(filename)[-1]\n            content_type = self.content_types.get(extension, \"application/binary\")\n            comment = comment if comment else \"Uploaded {filename}.\".format(filename=filename)\n            data = {\n                'type': type,\n                \"fileName\": filename,\n                \"contentType\": content_type,\n                \"comment\": comment,\n                \"minorEdit\": \"true\"}\n            headers = {\n                'X-Atlassian-Token': 'nocheck',\n                'Accept': 'application/json'}\n            path = 'rest/api/content/{page_id}/child/attachment'.format(page_id=page_id)\n            # get base name of the file to get the attachment from confluence.\n            file_base_name = os.path.basename(filename)\n            # Check if there is already a file with the same name\n            attachments = self.get(path=path, headers=headers, params={'filename': file_base_name})\n            if attachments['size']:\n                path = path + '/' + attachments['results'][0]['id'] + '/data'\n            with open(filename, 'rb') as infile:\n                return self.post(path=path, data=data, headers=headers,\n                                 files={'file': (filename, infile, content_type)})\n        else:\n            log.warning(\"No 'page_id' found, not uploading attachments\")\n            return None", "response": "Attach a file to a page"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets a label on the page_id", "response": "def set_page_label(self, page_id, label):\n        \"\"\"\n        Set a label on the page\n        :param page_id: content_id format\n        :param label: label to add\n        :return:\n        \"\"\"\n        url = 'rest/api/content/{page_id}/label'.format(page_id=page_id)\n        data = {'prefix': 'global',\n                'name': label}\n        return self.post(path=url, data=data)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nremove content history. It works as experimental method :param page_id: :param version_number: version number :return:", "response": "def remove_content_history(self, page_id, version_number):\n        \"\"\"\n        Remove content history. It works as experimental method\n        :param page_id:\n        :param version_number: version number\n        :return:\n        \"\"\"\n        url = 'rest/experimental/content/{id}/version/{versionNumber}'.format(id=page_id, versionNumber=version_number)\n        self.delete(url)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nremove content history in CLOUD. It works in CLOUD", "response": "def remove_content_history_in_cloud(self, page_id, version_id):\n        \"\"\"\n        Remove content history. It works in CLOUD\n        :param page_id:\n        :param version_id:\n        :return:\n        \"\"\"\n        url = 'rest/api/content/{id}/version/{versionId}'.format(id=page_id, versionId=version_id)\n        self.delete(url)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nchecks if unknown attachment error on page_id", "response": "def has_unknown_attachment_error(self, page_id):\n        \"\"\"\n        Check has unknown attachment error on page\n        :param page_id:\n        :return:\n        \"\"\"\n        unknown_attachment_identifier = 'plugins/servlet/confluence/placeholder/unknown-attachment'\n        result = self.get_page_by_id(page_id, expand='body.view')\n        if len(result) == 0:\n            return \"\"\n        body = (((result.get('body') or {}).get('view') or {}).get('value') or {})\n        if unknown_attachment_identifier in body:\n            return result.get('_links').get('base') + result.get('_links').get('tinyui')\n        return \"\""}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncomparing content and check is already updated or not", "response": "def is_page_content_is_already_updated(self, page_id, body):\n        \"\"\"\n        Compare content and check is already updated or not\n        :param page_id: Content ID for retrieve storage value\n        :param body: Body for compare it\n        :return: True if the same\n        \"\"\"\n        confluence_content = (self.get_page_by_id(page_id, expand='body.storage').get('body') or {}).get('storage').get(\n            'value')\n        confluence_content = confluence_content.replace('&oacute;', u'\u00f3')\n\n        log.debug('Old Content: \"\"\"{body}\"\"\"'.format(body=confluence_content))\n        log.debug('New Content: \"\"\"{body}\"\"\"'.format(body=body))\n\n        if confluence_content == body:\n            log.warning('Content of {page_id} is exactly the same'.format(page_id=page_id))\n            return True\n        else:\n            log.info('Content of {page_id} differs'.format(page_id=page_id))\n            return False"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef update_page(self, parent_id, page_id, title, body, type='page',\n                    minor_edit=False):\n        \"\"\"\n        Update page if already exist\n        :param parent_id:\n        :param page_id:\n        :param title:\n        :param body:\n        :param type:\n        :param minor_edit: Indicates whether to notify watchers about changes.\n            If False then notifications will be sent.\n        :return:\n        \"\"\"\n        log.info('Updating {type} \"{title}\"'.format(title=title, type=type))\n\n        if self.is_page_content_is_already_updated(page_id, body):\n            return self.get_page_by_id(page_id)\n        else:\n            version = self.history(page_id)['lastUpdated']['number'] + 1\n\n            data = {\n                'id': page_id,\n                'type': type,\n                'title': title,\n                'body': {'storage': {\n                    'value': body,\n                    'representation': 'storage'}},\n                'version': {'number': version,\n                            'minorEdit': minor_edit}\n            }\n\n            if parent_id:\n                data['ancestors'] = [{'type': 'page', 'id': parent_id}]\n\n            return self.put('rest/api/content/{0}'.format(page_id), data=data)", "response": "Update page if already exist\n        :param parent_id:\n        :param page_id:\n        :param title:\n        :param body:\n        :param type:\n        :param minor_edit: Indicates whether to notify watchers about changes.\n            If False then notifications will be sent.\n        :return:"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nupdating or create a page if it does not exist.", "response": "def update_or_create(self, parent_id, title, body):\n        \"\"\"\n        Update page or create a page if it is not exists\n        :param parent_id:\n        :param title:\n        :param body:\n        :return:\n        \"\"\"\n        space = self.get_page_space(parent_id)\n\n        if self.page_exists(space, title):\n            page_id = self.get_page_id(space, title)\n            result = self.update_page(parent_id=parent_id, page_id=page_id, title=title, body=body)\n        else:\n            result = self.create_page(space=space, parent_id=parent_id, title=title, body=body)\n\n        log.info('You may access your page at: {host}{url}'.format(host=self.url,\n                                                                   url=result['_links']['tinyui']))\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the page property e. g. add hash parameters", "response": "def set_page_property(self, page_id, data):\n        \"\"\"\n        Set the page (content) property e.g. add hash parameters\n        :param page_id: content_id format\n        :param data: data should be as json data\n        :return:\n        \"\"\"\n        url = 'rest/api/content/{page_id}/property'.format(page_id=page_id)\n        json_data = data\n        return self.post(path=url, data=json_data)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef delete_page_property(self, page_id, page_property):\n        url = 'rest/api/content/{page_id}/property/{page_property}'.format(page_id=page_id,\n                                                                           page_property=str(page_property))\n        return self.delete(path=url)", "response": "Delete the page ( content ) property e. g. delete key of hash\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the page ( content ) property e. g. get key of hash", "response": "def get_page_property(self, page_id, page_property_key):\n        \"\"\"\n        Get the page (content) property e.g. get key of hash\n        :param page_id: content_id format\n        :param page_property_key: key of property\n        :return:\n        \"\"\"\n        url = 'rest/api/content/{page_id}/property/{key}'.format(page_id=page_id,\n                                                                 key=str(page_property_key))\n        return self.get(path=url)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_page_properties(self, page_id):\n        url = 'rest/api/content/{page_id}/property'.format(page_id=page_id)\n        return self.get(path=url)", "response": "Get the page properties"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_page_ancestors(self, page_id):\n        url = 'rest/api/content/{page_id}?expand=ancestors'.format(page_id=page_id)\n        return (self.get(path=url) or {}).get('ancestors')", "response": "Get the ancestors of the page"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nclean caches from cache management e. g. com. gliffy. cache. gon", "response": "def clean_package_cache(self, cache_name='com.gliffy.cache.gon'):\n        \"\"\" Clean caches from cache management\n            e.g.\n            com.gliffy.cache.gon\n            org.hibernate.cache.internal.StandardQueryCache_v5\n        \"\"\"\n        headers = self.form_token_headers\n        data = {'cacheName': cache_name}\n        return self.delete('rest/cacheManagement/1.0/cacheEntries', data=data, headers=headers)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_all_groups(self, start=0, limit=1000):\n        url = 'rest/api/group?limit={limit}&start={start}'.format(limit=limit,\n                                                                  start=start)\n\n        return (self.get(url) or {}).get('results')", "response": "Get all groups from Confluence User management"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_group_members(self, group_name='confluence-users', start=0, limit=1000):\n        url = 'rest/api/group/{group_name}/member?limit={limit}&start={start}'.format(group_name=group_name,\n                                                                                      limit=limit,\n                                                                                      start=start)\n        return (self.get(url) or {}).get('results')", "response": "Get a paginated collection of users in a given group."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_space(self, space_key, expand='description.plain,homepage'):\n        url = 'rest/api/space/{space_key}?expand={expand}'.format(space_key=space_key,\n                                                                  expand=expand)\n        return self.get(url)", "response": "Get information about a unique space key"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets information about a user through username", "response": "def get_user_details_by_username(self, username, expand=None):\n        \"\"\"\n        Get information about a user through username\n        :param username: The user name\n        :param expand: OPTIONAL expand for get status of user.\n                Possible param is \"status\". Results are \"Active, Deactivated\"\n        :return: Returns the user details\n        \"\"\"\n        if expand:\n            url = 'rest/api/user?username={username}&expand={expand}'.format(username=username,\n                                                                             expand=expand)\n        else:\n            url = 'rest/api/user?username={username}'.format(username=username)\n\n        return self.get(url)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_user_details_by_userkey(self, userkey, expand=None):\n        if expand:\n            url = 'rest/api/user?key={userkey}&expand={expand}'.format(userkey=userkey,\n                                                                       expand=expand)\n        else:\n            url = 'rest/api/user?key={userkey}'.format(userkey=userkey)\n        return self.get(url)", "response": "Get user details by user key"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef cql(self, cql, start=0, limit=None, expand=None, include_archived_spaces=None, excerpt=None):\n        params = {}\n        if start is not None:\n            params['start'] = int(start)\n        if limit is not None:\n            params['limit'] = int(limit)\n        if cql is not None:\n            params['cql'] = cql\n        if expand is not None:\n            params['expand'] = expand\n        if include_archived_spaces is not None:\n            params['includeArchivedSpaces'] = include_archived_spaces\n        if excerpt is not None:\n            params['excerpt'] = excerpt\n\n        return self.get('rest/api/search', params=params)", "response": "Search for entities in a Confluence using the CQL query."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_page_as_pdf(self, page_id):\n        headers = self.form_token_headers\n        url = 'spaces/flyingpdf/pdfpageexport.action?pageId={pageId}'.format(pageId=page_id)\n        return self.get(url, headers=headers, not_json_response=True)", "response": "Get page as standard pdf exporter\n       "}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nprovides space, parent_id and title of the descendant page, it will return the descendant page_id :param space: str :param parent_id: int :param title: str :return: page_id of the page whose title is passed in argument", "response": "def get_descendant_page_id(self, space, parent_id, title):\n        \"\"\"\n        Provide  space, parent_id and title of the descendant page, it will return the descendant page_id\n        :param space: str\n        :param parent_id: int\n        :param title: str\n        :return: page_id of the page whose title is passed in argument\n        \"\"\"\n        page_id = \"\"\n\n        url = 'rest/api/content/search?cql=parent={}%20AND%20space=\"{}\"'.format(\n            parent_id, space\n        )\n        response = self.get(url, {})\n\n        for each_page in response.get(\"results\", []):\n            if each_page.get(\"title\") == title:\n                page_id = each_page.get(\"id\")\n                break\n        return page_id"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef health_check(self):\n        # check as Troubleshooting & Support Tools Plugin\n        response = self.get('rest/troubleshooting/1.0/check/')\n        if not response:\n            # check as support tools\n            response = self.get('rest/supportHealthCheck/1.0/check/')\n        return response", "response": "Get health status of a specific resource."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef reindex(self, comments=True, change_history=True, worklogs=True):\n        params = {}\n        if not comments:\n            params['indexComments'] = comments\n        if not change_history:\n            params['indexChangeHistory'] = change_history\n        if not worklogs:\n            params['indexWorklogs'] = worklogs\n        return self.post('rest/api/2/reindex', params=params)", "response": "Reindex the Jira instance with comments change history and worklogs."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets issues from jql search result with all related fields", "response": "def jql(self, jql, fields='*all', start=0, limit=None):\n        \"\"\"\n        Get issues from jql search result with all related fields\n        :param jql:\n        :param fields: list of fields, for example: ['priority', 'summary', 'customfield_10007']\n        :param start: OPTIONAL: The start point of the collection to return. Default: 0.\n        :param limit: OPTIONAL: The limit of the number of issues to return, this may be restricted by\n                fixed system limits. Default by built-in method: 50\n        :return:\n        \"\"\"\n        params = {}\n        if start is not None:\n            params['startAt'] = int(start)\n        if limit is not None:\n            params['maxResults'] = int(limit)\n        if fields is not None:\n            if isinstance(fields, (list, tuple, set)):\n                fields = ','.join(fields)\n            params['fields'] = fields\n        if jql is not None:\n            params['jql'] = jql\n        return self.get('rest/api/2/search', params=params)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef csv(self, jql, limit=1000):\n        url = 'sr/jira.issueviews:searchrequest-csv-all-fields/temp/SearchRequest.csv?tempMax={limit}&jqlQuery={jql}'.format(\n            limit=limit, jql=jql)\n        return self.get(url, not_json_response=True, headers={'Accept': 'application/csv'})", "response": "Get issues from jql search result with all related fields"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nupdate user attributes based on json", "response": "def user_update(self, username, data):\n        \"\"\"\n        Update user attributes based on json\n        :param username:\n        :param data:\n        :return:\n        \"\"\"\n        url = 'rest/api/2/user?username={0}'.format(username)\n        return self.put(url, data=data)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nupdating user email for new domain changes", "response": "def user_update_email(self, username, email):\n        \"\"\"\n        Update user email for new domain changes\n        :param username:\n        :param email:\n        :return:\n        \"\"\"\n        data = {'name': username, 'emailAddress': email}\n        return self.user_update(username, data=data)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef user_deactivate(self, username):\n        url = 'secure/admin/user/EditUser.jspa'\n        headers = self.form_token_headers\n        user = self.user(username)\n        user_update_info = {\n            'inline': 'true',\n            'decorator': 'dialog',\n            'username': user['name'],\n            'fullName': user['displayName'],\n            'email': user['emailAddress'],\n            'editName': user['name']\n        }\n        return self.post(data=user_update_info, path=url, headers=headers)", "response": "Disable user by username"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef user_disable_throw_rest_endpoint(self, username, url='rest/scriptrunner/latest/custom/disableUser',\n                                         param='userName'):\n        \"\"\"The disable method throw own rest enpoint\"\"\"\n        url = \"{}?{}={}\".format(url, param, username)\n        return self.get(path=url)", "response": "The disable method throw own rest enpoint"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget web sudo cookies using normal http request", "response": "def user_get_websudo(self):\n        \"\"\" Get web sudo cookies using normal http request\"\"\"\n        url = 'secure/admin/WebSudoAuthenticate.jspa'\n        headers = self.form_token_headers\n        data = {\n            'webSudoPassword': self.password,\n        }\n        return self.post(path=url, data=data, headers=headers)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef user_find_by_user_string(self, username, start=0, limit=50, include_inactive_users=False, include_active_users=True):\n        url = 'rest/api/2/user/search'\n        url += \"?username={username}&includeActive={include_active}&includeInactive={include_inactive}&startAt={start}&maxResults={limit}\".format(\n            username=username, include_inactive=include_inactive_users, include_active=include_active_users, start=start, limit=limit)\n        return self.get(url)", "response": "Fuzzy search using username and display name"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a full representation of a the specified project s versions.", "response": "def get_project_versions(self, key, expand=None):\n        \"\"\"\n        Contains a full representation of a the specified project's versions.\n        :param key:\n        :param expand: the parameters to expand\n        :return:\n        \"\"\"\n        params = {}\n        if expand is not None:\n            params['expand'] = expand\n        return self.get('rest/api/2/project/{}/versions'.format(key), params=params)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning all versions for the specified project.", "response": "def get_project_versions_paginated(self, key, start=None, limit=None, order_by=None, expand=None):\n        \"\"\"\n        Returns all versions for the specified project. Results are paginated.\n        Results can be ordered by the following fields:\n            sequence\n            name\n            startDate\n            releaseDate\n        :param key: the project key or id\n        :param start: the page offset, if not specified then defaults to 0\n        :param limit: how many results on the page should be included. Defaults to 50.\n        :param order_by: ordering of the results.\n        :param expand: the parameters to expand\n        :return:\n        \"\"\"\n        params = {}\n        if start is not None:\n            params['startAt'] = int(start)\n        if limit is not None:\n            params['maxResults'] = int(limit)\n        if order_by is not None:\n            params['orderBy'] = order_by\n        if expand is not None:\n            params['expand'] = expand\n        return self.get('rest/api/2/project/{}/version'.format(key), params)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the details for a given project role in a project.", "response": "def get_project_actors_for_role_project(self, project_key, role_id):\n        \"\"\"\n        Returns the details for a given project role in a project.\n        :param project_key:\n        :param role_id:\n        :return:\n        \"\"\"\n        url = 'rest/api/2/project/{projectIdOrKey}/role/{id}'.format(projectIdOrKey=project_key,\n                                                                     id=role_id)\n        return (self.get(url) or {}).get('actors')"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndeletes actors from a project role.", "response": "def delete_project_actors(self, project_key, role_id, actor, actor_type=None):\n        \"\"\"\n        Deletes actors (users or groups) from a project role.\n        Delete a user from the role: /rest/api/2/project/{projectIdOrKey}/role/{roleId}?user={username}\n        Delete a group from the role: /rest/api/2/project/{projectIdOrKey}/role/{roleId}?group={groupname}\n        :param project_key:\n        :param role_id:\n        :param actor:\n        :param actor_type: str : group or user string\n        :return:\n        \"\"\"\n        url = 'rest/api/2/project/{projectIdOrKey}/role/{roleId}'.format(projectIdOrKey=project_key,\n                                                                         roleId=role_id)\n        params = {}\n        if actor_type is not None and actor_type in ['group', 'user']:\n            params[actor_type] = actor\n        return self.delete(url, params=params)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef update_project(self, project_key, data, expand=None):\n        if expand:\n            url = '/rest/api/2/project/{projectIdOrKey}?expand={expand}'.format(projectIdOrKey=project_key, expand=expand)\n        else:\n            url = '/rest/api/2/project/{projectIdOrKey}'.format(projectIdOrKey=project_key)\n        return self.put(url, data)", "response": "Updates a project.\n        Update project: /rest/api/2/project/{projectIdOrKey}\n\n        :param project_key: project key of project that needs to be updated\n        :param data: dictionary containing the data to be updated\n        :param expand: the parameters to expand"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget custom fields. Evaluated on 7. 12.", "response": "def get_custom_fields(self, search=None, start=1, limit=50):\n        \"\"\"\n        Get custom fields. Evaluated on 7.12\n        :param search: str\n        :param start: long Default: 1\n        :param limit: int Default: 50\n        :return:\n        \"\"\"\n        url = 'rest/api/2/customFields'\n        params = {}\n        if search:\n            params['search'] = search\n        if start:\n            params['startAt'] = start\n        if limit:\n            params['maxResults'] = limit\n        return self.get(url, params=params)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_issue_labels(self, issue_key):\n        url = 'rest/api/2/issue/{issue_key}?fields=labels'.format(issue_key=issue_key)\n        return (self.get(url) or {}).get('fields').get('labels')", "response": "Get issue labels.\n        :param issue_key:\n        :return:"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nprovide assignable users for project :param project_key: :param start: OPTIONAL: The start point of the collection to return. Default: 0. :param limit: OPTIONAL: The limit of the number of users to return, this may be restricted by fixed system limits. Default by built-in method: 50 :return:", "response": "def get_all_assignable_users_for_project(self, project_key, start=0, limit=50):\n        \"\"\"\n        Provide assignable users for project\n        :param project_key:\n        :param start: OPTIONAL: The start point of the collection to return. Default: 0.\n        :param limit: OPTIONAL: The limit of the number of users to return, this may be restricted by\n                fixed system limits. Default by built-in method: 50\n        :return:\n        \"\"\"\n        url = 'rest/api/2/user/assignable/search?project={project_key}&startAt={start}&maxResults={limit}'.format(\n            project_key=project_key,\n            start=start,\n            limit=limit)\n        return self.get(url)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_groups(self, query=None, exclude=None, limit=20):\n        url = 'rest/api/2/groups/picker'\n        params = {}\n        if query:\n            params['query'] = query\n        else:\n            params['query'] = ''\n        if exclude:\n            params['exclude'] = exclude\n        if limit:\n            params['maxResults'] = limit\n        return self.get(url, params=params)", "response": "This endpoint returns a list of groups with substrings matching a given query."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate a group by given name", "response": "def create_group(self, name):\n        \"\"\"\n        Create a group by given group parameter\n\n        :param name: str\n        :return: New group params\n        \"\"\"\n        url = 'rest/api/2/group'\n        data = {'name': name}\n\n        return self.post(url, data=data)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef remove_group(self, name, swap_group=None):\n        log.warning('Removing group...')\n        url = 'rest/api/2/group'\n        if swap_group is not None:\n            params = {'groupname': name, 'swapGroup': swap_group}\n        else:\n            params = {'groupname': name}\n\n        return self.delete(url, params=params)", "response": "Removes a group by given name."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_all_users_from_group(self, group, include_inactive_users=False, start=0, limit=50):\n        url = 'rest/api/2/group/member'\n        params = {}\n        if group:\n            params['groupname'] = group\n        params['includeInactiveUsers'] = include_inactive_users\n        params['startAt'] = start\n        params['maxResults'] = limit\n        return self.get(url, params=params)", "response": "This method returns all users from a group."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef add_user_to_group(self, username, group_name):\n        url = 'rest/api/2/group/user'\n        params = {'groupname': group_name}\n        data = {'name': username}\n\n        return self.post(url, params=params, data=data)", "response": "Add given user to a group"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nremoving given user from a group", "response": "def remove_user_from_group(self, username, group_name):\n        \"\"\"\n        Remove given user from a group\n\n        :param username: str\n        :param group_name: str\n        :return:\n        \"\"\"\n        log.warning('Removing user from a group...')\n        url = 'rest/api/2/group/user'\n        params = {'groupname': group_name, 'username': username}\n\n        return self.delete(url, params=params)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef issue_add_comment(self, issue_key, comment, visibility=None):\n        url = 'rest/api/2/issue/{issueIdOrKey}/comment'.format(issueIdOrKey=issue_key)\n        data = {'body': comment}\n        if visibility:\n            data['visibility'] = visibility\n        return self.post(url, data=data)", "response": "Add comment into Jira issue\n           "}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nadds an attachment to an issue", "response": "def add_attachment(self, issue_key, filename):\n        \"\"\"\n        Add attachment to Issue\n\n        :param issue_key: str\n        :param filename: str, name, if file in current directory or full path to file\n        \"\"\"\n        log.warning('Adding attachment...')\n        headers = {'X-Atlassian-Token': 'no-check'}\n        with open(filename, 'rb') as file:\n            files = {'file': file}\n            url = 'rest/api/2/issue/{}/attachments'.format(issue_key)\n\n            return self.post(url, headers=headers, files=files)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_issue_remotelinks(self, issue_key, global_id=None, internal_id=None):\n        return self.get_issue_remote_links(issue_key, global_id, internal_id)", "response": "Get all the remote links for a given issue."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting all Remote Links on an issue", "response": "def get_issue_remote_links(self, issue_key, global_id=None, internal_id=None):\n        \"\"\"\n        Finding all Remote Links on an issue, also with filtering by Global ID and internal ID\n        :param issue_key:\n        :param global_id: str\n        :param internal_id: str\n        :return:\n        \"\"\"\n        url = 'rest/api/2/issue/{issue_key}/remotelink'.format(issue_key=issue_key)\n        params = {}\n        if global_id:\n            params['globalId'] = global_id\n        if internal_id:\n            url += '/' + internal_id\n        return self.get(url, params=params)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef create_or_update_issue_remote_links(self, issue_key, link_url, title, global_id=None, relationship=None):\n        url = 'rest/api/2/issue/{issue_key}/remotelink'.format(issue_key=issue_key)\n        data = {'object': {'url': link_url, 'title': title}}\n        if global_id:\n            data['globalId'] = global_id\n        if relationship:\n            data['relationship'] = relationship\n        return self.post(url, data=data)", "response": "Create or update Remote Link for an issue"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef update_issue_remote_link_by_id(self, issue_key, link_id, url, title, global_id=None, relationship=None):\n        data = {'object': {'url': url, 'title': title}}\n        if global_id:\n            data['globalId'] = global_id\n        if relationship:\n            data['relationship'] = relationship\n        url = 'rest/api/2/issue/{issue_key}/remotelink/{link_id}'.format(issue_key=issue_key, link_id=link_id)\n        return self.put(url, data=data)", "response": "Update Remote Link on Issue by ID"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef delete_issue_remote_link_by_id(self, issue_key, link_id):\n        url = 'rest/api/2/issue/{issue_key}/remotelink/{link_id}'.format(issue_key=issue_key, link_id=link_id)\n        return self.delete(url)", "response": "Delete Remote Link on Issue"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef create_issue_link_type(self, link_type_name, inward, outward):\n        if link_type_name.lower() in [x.lower() for x in self.get_issue_link_types_names()]:\n            log.error(\"Link type name already exists\")\n            return \"Link type name already exists\"\n        data = {\n            'name': link_type_name,\n            'inward': inward,\n            'outward': outward\n        }\n        return self.create_issue_link_type_by_json(data=data)", "response": "Create a new issue link type."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_issue_link_type(self, issue_link_type_id):\n        url = 'rest/api/2/issueLinkType/{issueLinkTypeId}'.format(issueLinkTypeId=issue_link_type_id)\n        return self.get(url)", "response": "Returns for a given issue link type id all information about this issue link type."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ndeletes the specified issue link type.", "response": "def delete_issue_link_type(self, issue_link_type_id):\n        \"\"\"Delete the specified issue link type.\"\"\"\n        url = 'rest/api/2/issueLinkType/{issueLinkTypeId}'.format(issueLinkTypeId=issue_link_type_id)\n        return self.delete(url)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef update_issue_link_type(self, issue_link_type_id, data):\n        url = 'rest/api/2/issueLinkType/{issueLinkTypeId}'.format(issueLinkTypeId=issue_link_type_id)\n        return self.put(url, data=data)", "response": "Update the issue link type."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the counts of issues related to this component.", "response": "def get_component_related_issues(self, component_id):\n        \"\"\"\n        Returns counts of issues related to this component.\n        :param component_id:\n        :return:\n        \"\"\"\n        url = 'rest/api/2/component/{component_id}/relatedIssueCounts'.format(component_id=component_id)\n        return self.get(url)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nuploads a plugin into Jira e. g. useful for auto deploy .", "response": "def upload_plugin(self, plugin_path):\n        \"\"\"\n        Provide plugin path for upload into Jira e.g. useful for auto deploy\n        :param plugin_path:\n        :return:\n        \"\"\"\n        files = {\n            'plugin': open(plugin_path, 'rb')\n        }\n        headers = {\n            'X-Atlassian-Token': 'nocheck'\n        }\n        upm_token = self.request(method='GET', path='rest/plugins/1.0/', headers=headers, trailing=True).headers[\n            'upm-token']\n        url = 'rest/plugins/1.0/?token={upm_token}'.format(upm_token=upm_token)\n        return self.post(url, files=files, headers=headers)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a list of all permissions schemes.", "response": "def get_all_permissionschemes(self, expand=None):\n        \"\"\"\n        Returns a list of all permission schemes.\n        By default only shortened beans are returned.\n        If you want to include permissions of all the schemes,\n        then specify the permissions expand parameter.\n        Permissions will be included also if you specify any other expand parameter.\n        :param expand : permissions,user,group,projectRole,field,all\n        :return:\n        \"\"\"\n        url = 'rest/api/2/permissionscheme'\n        params = {}\n        if expand:\n            params['expand'] = expand\n        return (self.get(url, params=params) or {}).get('permissionSchemes')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_permissionscheme(self, permission_id, expand=None):\n        url = 'rest/api/2/permissionscheme/{schemeID}'.format(schemeID=permission_id)\n        params = {}\n        if expand:\n            params['expand'] = expand\n        return self.get(url, params=params)", "response": "Get all permissions of a specific permission scheme."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating a permission grant in a permission scheme.", "response": "def set_permissionscheme_grant(self, permission_id, new_permission):\n        \"\"\"\n        Creates a permission grant in a permission scheme.\n        Example:\n\n        {\n            \"holder\": {\n                \"type\": \"group\",\n                \"parameter\": \"jira-developers\"\n            },\n            \"permission\": \"ADMINISTER_PROJECTS\"\n        }\n\n        :param permission_id\n        :param new_permission\n        :return:\n        \"\"\"\n        url = 'rest/api/2/permissionscheme/{schemeID}/permission'.format(schemeID=permission_id)\n\n        return self.post(url, data=new_permission)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef tempo_account_get_accounts(self, skip_archived=None, expand=None):\n        params = {}\n        if skip_archived is not None:\n            params['skipArchived'] = skip_archived\n        if expand is not None:\n            params['expand'] = expand\n        url = 'rest/tempo-accounts/1/account'\n        return self.get(url, params=params)", "response": "Get all Accounts that the logged in user has permission to browse."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef tempo_account_associate_with_jira_project(self, account_id, project_id,\n                                                  default_account=False,\n                                                  link_type='MANUAL'):\n        \"\"\"\n        The AccountLinkBean for associate Account with project\n        Adds a link to an Account.\n        {\n            scopeType:PROJECT\n            defaultAccount:boolean\n            linkType:IMPORTED | MANUAL\n            name:string\n            key:string\n            accountId:number\n            scope:number\n            id:number\n        }\n        :param project_id:\n        :param account_id\n        :param default_account\n        :param link_type\n        :return:\n        \"\"\"\n        data = {}\n        if account_id:\n            data['accountId'] = account_id\n        if default_account:\n            data['defaultAccount'] = default_account\n        if link_type:\n            data['linkType'] = link_type\n        if project_id:\n            data['scope'] = project_id\n        data['scopeType'] = 'PROJECT'\n\n        url = 'rest/tempo-accounts/1/link/'\n        return self.post(url, data=data)", "response": "This method associates a link to an Account in a JIRA Project with a tempo account."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating Account and adds new Account", "response": "def tempo_account_add_account(self, data=None):\n        \"\"\"\n        Creates Account, adding new Account requires the Manage Accounts Permission.\n        :param data: String then it will convert to json\n        :return:\n        \"\"\"\n        url = 'rest/tempo-accounts/1/account/'\n        if data is None:\n            return \"\"\"Please, provide data e.g.\n                       {name: \"12312312321\",\n                       key: \"1231231232\",\n                       lead: {name: \"myusername\"},\n                       }\n                       detail info: http://developer.tempo.io/doc/accounts/api/rest/latest/#-700314780\n                   \"\"\"\n        return self.post(url, data=data)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef tempo_account_delete_account_by_id(self, account_id):\n        url = 'rest/tempo-accounts/1/account/{id}/'.format(id=account_id)\n        return self.delete(url)", "response": "Delete an Account by id."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting un - archived Accounts by customer.", "response": "def tempo_account_get_all_account_by_customer_id(self, customer_id):\n        \"\"\"\n        Get un-archived Accounts by customer. The Caller must have the Browse Account permission for the Account.\n        :param customer_id: the Customer id.\n        :return:\n        \"\"\"\n        url = 'rest/tempo-accounts/1/account/customer/{customerId}/'.format(customerId=customer_id)\n        return self.get(url)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets all or some Attribute whose key or name contain a specific substring. Attributes can be a Category or Customer. :param query: OPTIONAL: query for search :param count_accounts: bool OPTIONAL: provide how many associated Accounts with Customer :return: list of customers", "response": "def tempo_account_get_customers(self, query=None, count_accounts=None):\n        \"\"\"\n        Gets all or some Attribute whose key or name contain a specific substring.\n        Attributes can be a Category or Customer.\n        :param query: OPTIONAL: query for search\n        :param count_accounts: bool OPTIONAL: provide how many associated Accounts with Customer\n        :return: list of customers\n        \"\"\"\n        params = {}\n        if query is not None:\n            params['query'] = query\n        if count_accounts is not None:\n            params['countAccounts'] = count_accounts\n        url = 'rest/tempo-accounts/1/customer'\n        return self.get(url, params=params)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef tempo_account_add_customer(self, data=None):\n        if data is None:\n            return \"\"\"Please, set the data as { isNew:boolean\n                                                name:string\n                                                key:string\n                                                id:number } or you can put only name and key parameters\"\"\"\n        url = 'rest/tempo-accounts/1/customer'\n        return self.post(url, data=data)", "response": "Add a customer to tempo account"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef tempo_account_get_customer_by_id(self, customer_id=1):\n        url = 'rest/tempo-accounts/1/customer/{id}'.format(id=customer_id)\n        return self.get(url)", "response": "Get Customer by id"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nupdating a customer by id", "response": "def tempo_account_update_customer_by_id(self, customer_id=1, data=None):\n        \"\"\"\n        Updates an Attribute. Caller must have Manage Account Permission. Attribute can be a Category or Customer.\n        :param customer_id: id of Customer record\n        :param data: format is\n                    {\n                        isNew:boolean\n                        name:string\n                        key:string\n                        id:number\n                    }\n        :return: json with parameters name, key and id.\n        \"\"\"\n        if data is None:\n            return \"\"\"Please, set the data as { isNew:boolean\n                                                name:string\n                                                key:string\n                                                id:number }\"\"\"\n        url = 'rest/tempo-accounts/1/customer/{id}'.format(id=customer_id)\n        return self.put(url, data=data)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef tempo_account_delete_customer_by_id(self, customer_id=1):\n        url = 'rest/tempo-accounts/1/customer/{id}'.format(id=customer_id)\n        return self.delete(url)", "response": "Delete an attribute from the customer table. Caller must have Manage Account Permission."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef tempo_account_export_accounts(self):\n        headers = self.form_token_headers\n        url = 'rest/tempo-accounts/1/export'\n        return self.get(url, headers=headers, not_json_response=True)", "response": "Get csv export file of Accounts from Tempo\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_all_agile_boards(self, board_name=None, project_key=None, board_type=None, start=0, limit=50):\n        url = 'rest/agile/1.0/board'\n        params = {}\n        if board_name:\n            params['name'] = board_name\n        if project_key:\n            params['projectKeyOrId'] = project_key\n        if board_type:\n            params['type'] = board_type\n        if start:\n            params['startAt'] = int(start)\n        if limit:\n            params['maxResults'] = int(limit)\n\n        return self.get(url, params=params)", "response": "Get all agile boards."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget agile board info by id", "response": "def get_agile_board(self, board_id):\n        \"\"\"\n        Get agile board info by id\n        :param board_id:\n        :return:\n        \"\"\"\n        url = 'rest/agile/1.0/board/{}'.format(str(board_id))\n        return self.get(url)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_agile_board_configuration(self, board_id):\n        url = 'rest/agile/1.0/board/{}/configuration'.format(str(board_id))\n        return self.get(url)", "response": "Get the agile board configuration."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef delete_agile_board(self, board_id):\n        url = 'rest/agile/1.0/board/{}'.format(str(board_id))\n        return self.delete(url)", "response": "Delete agile board by id"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating customer user :param full_name: str :param email: str :return: New customer", "response": "def create_customer(self, full_name, email):\n        \"\"\"\n        Creating customer user\n\n        :param full_name: str\n        :param email: str\n        :return: New customer\n        \"\"\"\n        log.warning('Creating customer...')\n        data = {'fullName': full_name, 'email': email}\n\n        return self.post('rest/servicedeskapi/customer', headers=self.experimental_headers, data=data)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates a customer request.", "response": "def create_customer_request(self, service_desk_id, request_type_id, values_dict, raise_on_behalf_of=None):\n        \"\"\"\n        Creating customer request\n\n        :param service_desk_id: str\n        :param request_type_id: str\n        :param values_dict: str\n        :param raise_on_behalf_of: str\n        :return: New request\n        \"\"\"\n        log.warning('Creating request...')\n        data = {\n            \"serviceDeskId\": service_desk_id,\n            \"requestTypeId\": request_type_id,\n            \"requestFieldValues\": values_dict\n        }\n\n        if raise_on_behalf_of:\n            data[\"raiseOnBehalfOf\"] = raise_on_behalf_of\n\n        return self.post('rest/servicedeskapi/request', data=data)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget customer request status name", "response": "def get_customer_request_status(self, issue_id_or_key):\n        \"\"\"\n        Get customer request status name\n\n        :param issue_id_or_key: str\n        :return: Status name\n        \"\"\"\n        request = self.get('rest/servicedeskapi/request/{}/status'.format(issue_id_or_key)).get('values')\n        status = request[0].get('status')\n\n        return status"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_customer_transitions(self, issue_id_or_key):\n        url = 'rest/servicedeskapi/request/{}/transition'.format(issue_id_or_key)\n\n        return self.get(url, headers=self.experimental_headers)", "response": "Returns a list of all the customer transitions that customers can perform on the request\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_request_participants(self, issue_id_or_key, start=0, limit=50):\n        url = 'rest/servicedeskapi/request/{}/participant'.format(issue_id_or_key)\n        params = {}\n        if start is not None:\n            params['start'] = int(start)\n        if limit is not None:\n            params['limit'] = int(limit)\n\n        return self.get(url, params=params).get('values')", "response": "Get request participants\n\n        :param issue_id_or_key: str\n        :param start: OPTIONAL: int\n        :param limit: OPTIONAL: int\n        :return: Request participants"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add_request_participants(self, issue_id_or_key, users_list):\n        url = 'rest/servicedeskapi/request/{}/participant'.format(issue_id_or_key)\n        data = {'usernames': users_list}\n\n        return self.post(url, data=data)", "response": "Add users as participants to an existing customer request"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef remove_request_participants(self, issue_id_or_key, users_list):\n        url = 'rest/servicedeskapi/request/{}/participant'.format(issue_id_or_key)\n        data = {'usernames': users_list}\n\n        return self.delete(url, data=data)", "response": "This method is used to remove participants from an existing customer request."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nperforms a customer transition for a given request and transition ID.", "response": "def perform_transition(self, issue_id_or_key, transition_id, comment=None):\n        \"\"\"\n        Perform a customer transition for a given request and transition ID.\n        An optional comment can be included to provide a reason for the transition.\n\n        :param issue_id_or_key: str\n        :param transition_id: str\n        :param comment: OPTIONAL: str\n        :return: None\n        \"\"\"\n        log.warning('Performing transition...')\n        data = {'id': transition_id, 'additionalComment': {'body': comment}}\n        url = 'rest/servicedeskapi/request/{}/transition'.format(issue_id_or_key)\n\n        return self.post(url, headers=self.experimental_headers, data=data)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a comment for a request.", "response": "def create_request_comment(self, issue_id_or_key, body, public=True):\n        \"\"\"\n        Creating request comment\n\n        :param issue_id_or_key: str\n        :param body: str\n        :param public: OPTIONAL: bool (default is True)\n        :return: New comment\n        \"\"\"\n        log.warning('Creating comment...')\n        data = {\"body\": body, \"public\": public}\n\n        return self.post('rest/servicedeskapi/request/{}/comment'.format(issue_id_or_key), data=data)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting organizations in the Jira instance.", "response": "def get_organisations(self, service_desk_id=None, start=0, limit=50):\n        \"\"\"\n        Returns a list of organizations in the Jira instance. If the user is not an agent,\n        the resource returns a list of organizations the user is a member of.\n\n        :param service_desk_id: OPTIONAL: str Get organizations from single Service Desk\n        :param start: OPTIONAL: int The starting index of the returned objects.\n                     Base index: 0. See the Pagination section for more details.\n        :param limit: OPTIONAL: int The maximum number of users to return per page.\n                     Default: 50. See the Pagination section for more details.\n        :return:\n        \"\"\"\n        url_without_sd_id = 'rest/servicedeskapi/organization'\n        url_with_sd_id = 'rest/servicedeskapi/servicedesk/{}/organization'.format(service_desk_id)\n        params = {}\n        if start is not None:\n            params['start'] = int(start)\n        if limit is not None:\n            params['limit'] = int(limit)\n\n        if service_desk_id is None:\n            return self.get(url_without_sd_id, headers=self.experimental_headers, params=params)\n        else:\n            return self.get(url_with_sd_id, headers=self.experimental_headers, params=params)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget an organization for a given organization ID", "response": "def get_organization(self, organization_id):\n        \"\"\"\n        Get an organization for a given organization ID\n\n        :param organization_id: str\n        :return: Organization\n        \"\"\"\n        url = 'rest/servicedeskapi/organization/{}'.format(organization_id)\n\n        return self.get(url, headers=self.experimental_headers)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_users_in_organization(self, organization_id, start=0, limit=50):\n        url = 'rest/servicedeskapi/organization/{}/user'.format(organization_id)\n        params = {}\n        if start is not None:\n            params['start'] = int(start)\n        if limit is not None:\n            params['limit'] = int(limit)\n\n        return self.get(url, headers=self.experimental_headers, params=params)", "response": "Get all the users in an organization."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create_organization(self, name):\n        log.warning('Creating organization...')\n        url = 'rest/servicedeskapi/organization'\n        data = {'name': name}\n\n        return self.post(url, headers=self.experimental_headers, data=data)", "response": "To create an organization Jira administrator global permission or agent permission is required\n        depending on the settings\n\n        :param name: str\n        :return: Organization data"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds an organization to a given servicedesk ID and organization ID", "response": "def add_organization(self, service_desk_id, organization_id):\n        \"\"\"\n        Adds an organization to a servicedesk for a given servicedesk ID and organization ID\n\n        :param service_desk_id: str\n        :param organization_id: int\n        :return:\n        \"\"\"\n        log.warning('Adding organization...')\n        url = 'rest/servicedeskapi/servicedesk/{}/organization'.format(service_desk_id)\n        data = {'organizationId': organization_id}\n\n        return self.post(url, headers=self.experimental_headers, data=data)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef remove_organization(self, service_desk_id, organization_id):\n        log.warning('Removing organization...')\n        url = 'rest/servicedeskapi/servicedesk/{}/organization'.format(service_desk_id)\n        data = {'organizationId': organization_id}\n\n        return self.delete(url, headers=self.experimental_headers, data=data)", "response": "Removes an organization from a servicedesk for a given servicedesk ID and organization ID"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef delete_organization(self, organization_id):\n        log.warning('Deleting organization...')\n        url = 'rest/servicedeskapi/organization/{}'.format(organization_id)\n\n        return self.delete(url, headers=self.experimental_headers)", "response": "Delete an organization for a given organization ID"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd users to an organization", "response": "def add_users_to_organization(self, organization_id, users_list):\n        \"\"\"\n        Adds users to an organization\n        users_list is a list of strings\n\n        :param organization_id: str\n        :param users_list: list\n        :return:\n        \"\"\"\n        log.warning('Adding users...')\n        url = 'rest/servicedeskapi/organization/{}/user'.format(organization_id)\n        data = {'usernames': users_list}\n\n        return self.post(url, headers=self.experimental_headers, data=data)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef remove_users_from_organization(self, organization_id, users_list):\n        log.warning('Removing users...')\n        url = 'rest/servicedeskapi/organization/{}/user'.format(organization_id)\n        data = {'usernames': users_list}\n\n        return self.delete(url, headers=self.experimental_headers, data=data)", "response": "Removes users from an organization"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef create_attachment(self, service_desk_id, issue_id_or_key, filename, public=True, comment=None):\n        log.warning('Creating attachment...')\n\n        # Create temporary attachment\n        temp_attachment_id = self.attach_temporary_file(service_desk_id, filename)\n\n        # Add attachments\n        return self.add_attachment(issue_id_or_key, temp_attachment_id, public, comment)", "response": "Create a temporary attachment and add it to the cache."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef attach_temporary_file(self, service_desk_id, filename):\n        headers = {'X-Atlassian-Token': 'no-check', 'X-ExperimentalApi': 'opt-in'}\n        url = 'rest/servicedeskapi/servicedesk/{}/attachTemporaryFile'.format(service_desk_id)\n\n        with open(filename, 'rb') as file:\n            result = self.post(url, headers=headers, files={'file': file}).get('temporaryAttachments')\n            temp_attachment_id = result[0].get('temporaryAttachmentId')\n\n            return temp_attachment_id", "response": "Create temporary attachment which can later be converted into permanent attachment"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef add_attachment(self, issue_id_or_key, temp_attachment_id, public=True, comment=None):\n        log.warning('Adding attachment')\n        data = {\n            'temporaryAttachmentIds': [temp_attachment_id],\n            'public': public,\n            'additionalComment': {'body': comment}\n        }\n        url = 'rest/servicedeskapi/request/{}/attachment'.format(issue_id_or_key)\n\n        return self.post(url, headers=self.experimental_headers, data=data)", "response": "Adds temporary attachment to customer request"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the SLA information for a given request ID or key and SLA metric ID", "response": "def get_sla_by_id(self, issue_id_or_key, sla_id):\n        \"\"\"\n        Get the SLA information for a customer request for a given request ID or key and SLA metric ID\n        IMPORTANT: The calling user must be an agent\n\n        :param issue_id_or_key: str\n        :param sla_id: str\n        :return: SLA information\n        \"\"\"\n        url = 'rest/servicedeskapi/request/{0}/sla/{1}'.format(issue_id_or_key, sla_id)\n\n        return self.get(url)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_approvals(self, issue_id_or_key, start=0, limit=50):\n        url = 'rest/servicedeskapi/request/{}/approval'.format(issue_id_or_key)\n        params = {}\n        if start is not None:\n            params['start'] = int(start)\n        if limit is not None:\n            params['limit'] = int(limit)\n\n        return self.get(url, headers=self.experimental_headers, params=params).get('values')", "response": "Get all approvals on a given request ID or Key."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_approval_by_id(self, issue_id_or_key, approval_id):\n        url = 'rest/servicedeskapi/request/{0}/approval/{1}'.format(issue_id_or_key, approval_id)\n\n        return self.get(url, headers=self.experimental_headers)", "response": "Get an approval for a given approval ID"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef answer_approval(self, issue_id_or_key, approval_id, decision):\n        url = 'rest/servicedeskapi/request/{0}/approval/{1}'.format(issue_id_or_key, approval_id)\n        data = {'decision': decision}\n\n        return self.post(url, headers=self.experimental_headers, data=data)", "response": "Answer a pending approval"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets queue settings on project", "response": "def get_queue_settings(self, project_key):\n        \"\"\"\n        Get queue settings on project\n\n        :param project_key: str\n        :return:\n        \"\"\"\n        url = 'rest/servicedeskapi/queues/{}'.format(project_key)\n\n        return self.get(url, headers=self.experimental_headers)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadd one or more customers to the given service desk.", "response": "def add_customers(self, service_desk_id, list_of_usernames):\n        \"\"\"\n        Adds one or more existing customers to the given service desk.\n        If you need to create a customer, see Create customer method.\n\n        Administer project permission is required, or agents if public signups\n        and invites are enabled for the Service Desk project.\n\n        :param service_desk_id: str\n        :param list_of_usernames: list\n        :return: the customers added to the service desk\n        \"\"\"\n        url = 'rest/servicedeskapi/servicedesk/{}/customer'.format(service_desk_id)\n        data = {'usernames': list_of_usernames}\n\n        return self.post(url, headers=self.experimental_headers, data=data)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the queues defined inside a service desk.", "response": "def get_queues(self, service_desk_id, include_count=False, start=0, limit=50):\n        \"\"\"\n        Returns a page of queues defined inside a service desk, for a given service desk ID.\n        The returned queues will include an issue count for each queue (represented in issueCount field)\n        if the query param includeCount is set to true (defaults to false).\n\n        Permissions: The calling user must be an agent of the given service desk.\n\n        :param service_desk_id: str\n        :param include_count: bool\n        :param start: int\n        :param limit: int\n        :return: a page of queues\n        \"\"\"\n        url = 'rest/servicedeskapi/servicedesk/{}/queue'.format(service_desk_id)\n        params = {}\n\n        if include_count is not None:\n            params['includeCount'] = bool(include_count)\n        if start is not None:\n            params['start'] = int(start)\n        if limit is not None:\n            params['limit'] = int(limit)\n\n        return self.get(url, headers=self.experimental_headers, params=params)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_issues_in_queue(self, service_desk_id, queue_id, start=0, limit=50):\n        url = 'rest/servicedeskapi/servicedesk/{0}/queue/{1}/issue'.format(service_desk_id, queue_id)\n        params = {}\n\n        if start is not None:\n            params['start'] = int(start)\n        if limit is not None:\n            params['limit'] = int(limit)\n\n        return self.get(url, headers=self.experimental_headers, params=params)", "response": "Get a page of issues inside a queue for a given service desk ID and queue ID."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef project_plans(self, project_key):\n        resource = 'project/{}'.format(project_key, max_results=25)\n        return self.base_list_call(resource, expand='plans', favourite=False, clover_enabled=False, max_results=25,\n                                   elements_key='plans', element_key='plan')", "response": "Returns a generator with the plans in a given project"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef results(self, project_key=None, plan_key=None, job_key=None, build_number=None, expand=None, favourite=False,\n                clover_enabled=False, issue_key=None, start_index=0, max_results=25):\n        \"\"\"\n        Get results as generic method\n        :param project_key:\n        :param plan_key:\n        :param job_key:\n        :param build_number:\n        :param expand:\n        :param favourite:\n        :param clover_enabled:\n        :param issue_key:\n        :param start_index:\n        :param max_results:\n        :return:\n        \"\"\"\n        resource = \"result\"\n        if project_key and plan_key and job_key and build_number:\n            resource += \"/{}-{}-{}/{}\".format(project_key, plan_key, job_key, build_number)\n        elif project_key and plan_key and build_number:\n            resource += \"/{}-{}/{}\".format(project_key, plan_key, build_number)\n        elif project_key and plan_key:\n            resource += \"/{}-{}\".format(project_key, plan_key)\n        elif project_key:\n            resource += '/' + project_key\n\n        params = {}\n        if issue_key:\n            params['issueKey'] = issue_key\n        return self.base_list_call(resource, expand=expand, favourite=favourite, clover_enabled=clover_enabled,\n                                   start_index=start_index, max_results=max_results,\n                                   elements_key='results', element_key='result', **params)", "response": "Get results as generic method"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the results for a specific plan.", "response": "def plan_results(self, project_key, plan_key, expand=None, favourite=False, clover_enabled=False, label=None,\n                     issue_key=None, start_index=0, max_results=25):\n        \"\"\"\n        Get Plan results\n        :param project_key:\n        :param plan_key:\n        :param expand:\n        :param favourite:\n        :param clover_enabled:\n        :param label:\n        :param issue_key:\n        :param start_index:\n        :param max_results:\n        :return:\n        \"\"\"\n        return self.results(project_key, plan_key, expand=expand, favourite=favourite, clover_enabled=clover_enabled,\n                            label=label, issue_key=issue_key, start_index=start_index, max_results=max_results)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning details of a specific build result", "response": "def build_result(self, build_key, expand=None):\n        \"\"\"\n        Returns details of a specific build result\n        :param expand: expands build result details on request. Possible values are: artifacts, comments, labels,\n        Jira Issues, stages. stages expand is available only for top level plans. It allows to drill down to job results\n        using stages.stage.results.result. All expand parameters should contain results.result prefix.\n        :param build_key: Should be in the form XX-YY[-ZZ]-99, that is, the last token should be an integer representing\n        the build number\n        \"\"\"\n        try:\n            int(build_key.split('-')[-1])\n            resource = \"result/{}\".format(build_key)\n            return self.base_list_call(resource, expand, favourite=False, clover_enabled=False,\n                                       start_index=0, max_results=25)\n        except ValueError:\n            raise ValueError('The key \"{}\" does not correspond to a build result'.format(build_key))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef deployment_dashboard(self, project_id=None):\n        resource = 'deploy/dashboard/{}'.format(project_id) if project_id else 'deploy/dashboard'\n        return self.get(self.resource_url(resource))", "response": "Returns the current status of each deployment environment."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef plan_branches(self, plan_key, expand=None, favourite=False, clover_enabled=False, max_results=25):\n        resource = 'plan/{}/branch'.format(plan_key)\n        return self.base_list_call(resource, expand, favourite, clover_enabled, max_results,\n                                   elements_key='branches', element_key='branch')", "response": "Get branch information for a given plan."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef is_email(string):\n    email_regex = r'^[A-Za-z0-9\\.\\+_-]+@[A-Za-z0-9\\._-]+\\.[a-zA-Z]*$'\n\n    if isinstance(string, str) and not re.match(email_regex, string):\n        return False\n    else:\n        return True", "response": "Check if a string is an email address."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a list of html elements for the given data.", "response": "def html_list(data):\n    \"\"\"\n    >>> html_list(['example.com', 'admin1@example.com', 'admin2@example.com'])\n    '<ul>\n        <li>example.com</li>\n        <li><a href=\"mailto:admin1@example.com\">admin1@example.com</a></li>\n        <li><a href=\"mailto:admin2@example.com\">admin2@example.com</a></li>\n    </ul>'\n    \"\"\"\n    html = '<ul>'\n\n    for item in data:\n\n        if isinstance(item, dict):\n            if item.get('email'):\n                item = html_email(item.get('email'), item.get('name', None))\n            elif item.get('name'):\n                item = item.get('name')\n\n        if is_email(item):\n            item = html_email(item, item)\n\n        html += '<li>{}</li>'.format(item)\n\n    return html + '</ul>'"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef html_table_header_row(data):\n    html = '\\n\\t<tr>'\n\n    for th in data:\n        title = th.replace('_', ' ').title()\n        html += '<th>{}</th>'.format(title)\n\n    return html + '</tr>'", "response": "Return a table header row."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef html_row_with_ordered_headers(data, headers):\n    html = '\\n\\t<tr>'\n\n    for header in headers:\n        element = data[header]\n\n        if isinstance(element, list):\n            element = html_list(element)\n\n        if is_email(element):\n            element = html_email(element)\n\n        html += '<td>{}</td>'.format(element)\n\n    return html + '</tr>'", "response": "Returns an HTML row with ordered headers."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef html_table_from_dict(data, ordering):\n    html = '<table><tbody>'\n    html += html_table_header_row(ordering)\n\n    for row in data:\n        html += html_row_with_ordered_headers(row, ordering)\n\n    return html + '\\n</tbody></table>'", "response": "This function will convert the dictionary into an HTML table."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_plugins_info(self, limit=10, offset=10):\n        params = {}\n        if offset:\n            params['offset'] = offset\n        if limit:\n            params['limit'] = limit\n        url = 'rest/1.0/plugins'\n        return (self.get(url, params=params) or {}).get('plugins')", "response": "Get the plugins info for a specific user."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_vendors_info(self, limit=10, offset=10):\n        params = {}\n        if offset:\n            params['offset'] = offset\n        if limit:\n            params['limit'] = limit\n        url = 'rest/1.0/vendors'\n        return (self.get(url, params=params) or {}).get('vendors')", "response": "Get vendors info for a specific user."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_application_info(self, limit=10, offset=10):\n        params = {}\n        if offset:\n            params['offset'] = offset\n        if limit:\n            params['limit'] = limit\n        url = 'rest/2/applications'\n        return self.get(url, params=params)", "response": "Get information about applications."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nproviding the project list", "response": "def project_list(self, limit=None):\n        \"\"\"\n        Provide the project list\n        :param limit: OPTIONAL 25 is default\n        :return:\n        \"\"\"\n        params = {}\n        if limit:\n            params['limit'] = limit\n        return (self.get('rest/api/1.0/projects', params=params) or {}).get('values')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the project info for a given key", "response": "def project(self, key):\n        \"\"\"\n        Provide project info\n        :param key:\n        :return:\n        \"\"\"\n        url = 'rest/api/1.0/projects/{0}'.format(key)\n        return (self.get(url) or {}).get('values')"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef create_project(self, key, name, description=\"\"):\n        url = 'rest/api/1.0/projects'\n        data = {\"key\": key,\n                \"name\": name,\n                \"description\": description\n                }\n        return self.post(url, data=data)", "response": "Create a new project in the nacore store"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets project administrators for project key", "response": "def project_users_with_administrator_permissions(self, key):\n        \"\"\"\n        Get project administrators for project\n        :param key: project key\n        :return: project administrators\n        \"\"\"\n        project_administrators = [user['user'] for user in self.project_users(key)\n                                  if user['permission'] == 'PROJECT_ADMIN']\n        for group in self.project_groups_with_administrator_permissions(key):\n            for user in self.group_members(group):\n                project_administrators.append(user)\n        return project_administrators"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef project_groups(self, key, limit=99999, filter_str=None):\n        url = 'rest/api/1.0/projects/{key}/permissions/groups'.format(key=key)\n        params = {}\n        if limit:\n            params['limit'] = limit\n        if filter_str:\n            params['filter'] = filter_str\n        return (self.get(url, params=params) or {}).get('values')", "response": "Get Project Groups\n        :param key:\n        :param limit: OPTIONAL: The limit of the number of groups to return, this may be restricted by\n                            fixed system limits. Default by built-in method: 99999\n        :param filter_str: OPTIONAL: group filter string\n        :return:"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef repo_groups(self, project_key, repo_key, limit=99999, filter_str=None):\n        url = 'rest/api/1.0/projects/{project_key}/repos/{repo_key}/permissions/groups'.format(\n            project_key=project_key,\n            repo_key=repo_key)\n        params = {}\n        if limit:\n            params['limit'] = limit\n        if filter_str:\n            params['filter'] = filter_str\n        return (self.get(url, params=params) or {}).get('values')", "response": "Get repository Groups\n        :param project_key:\n        :param repo_key:\n        :param limit: OPTIONAL: The limit of the number of groups to return, this may be restricted by\n                            fixed system limits. Default by built-in method: 99999\n        :param filter_str: OPTIONAL: group filter string\n        :return:"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the members of a group.", "response": "def group_members(self, group, limit=99999):\n        \"\"\"\n        Get group of members\n        :param group:\n        :param limit: OPTIONAL: The limit of the number of users to return, this may be restricted by\n                        fixed system limits. Default by built-in method: 99999\n        :return:\n        \"\"\"\n        url = 'rest/api/1.0/admin/groups/more-members'\n        params = {}\n        if limit:\n            params['limit'] = limit\n        if group:\n            params['context'] = group\n        return (self.get(url, params=params) or {}).get('values')"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef all_project_administrators(self):\n        for project in self.project_list():\n            log.info('Processing project: {0} - {1}'.format(project.get('key'), project.get('name')))\n            yield {\n                'project_key': project.get('key'),\n                'project_name': project.get('name'),\n                'project_administrators': [{'email': x['emailAddress'], 'name': x['displayName']}\n                                           for x in self.project_users_with_administrator_permissions(project['key'])]}", "response": "Get the list of project administrators that are in the system."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting repositories list from project", "response": "def repo_list(self, project_key, start=None, limit=25):\n        \"\"\"\n        Get repositories list from project\n        :param project_key:\n        :param start: OPTIONAL: The start of the\n        :param limit: OPTIONAL: The limit of the number of repositories to return, this may be restricted by\n                        fixed system limits. Default by built-in method: 25\n        :return:\n        \"\"\"\n        url = 'rest/api/1.0/projects/{projectKey}/repos'.format(projectKey=project_key)\n        params = {}\n        if limit:\n            params['limit'] = limit\n        if start:\n            params['start'] = start\n        response = self.get(url, params=params)\n        if response.get('isLastPage'):\n            log.info('This is a last page of the result')\n        else:\n            log.info('Next page start at {}'.format(response.get('nextPageStart')))\n        return (response or {}).get('values')"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates a new repository.", "response": "def create_repo(self, project_key, repository, forkable=False, is_private=True):\n        \"\"\"Create a new repository.\n\n        Requires an existing project in which this repository will be created. The only parameters which will be used\n        are name and scmId.\n\n        The authenticated user must have PROJECT_ADMIN permission for the context project to call this resource.\n\n        :param project_key: The project matching the projectKey supplied in the resource path as shown in URL.\n        :type project_key: str\n        :param repository: Name of repository to create (i.e. \"My repo\").\n        :type repository: str\n        :param forkable: Set the repository to be forkable or not.\n        :type forkable: bool\n        :param is_private: Set the repository to be private or not.\n        :type is_private: bool\n        :return:\n            201 - application/json (repository)\n            400 - application/json (errors)\n            401 - application/json (errors)\n            409 - application/json (errors)\n        :rtype: requests.Response\n        \"\"\"\n\n        url = 'rest/api/1.0/projects/{projectKey}/repos'.format(projectKey=project_key)\n        data = {\n            \"name\": repository,\n            \"scmId\": \"git\",\n            \"forkable\": forkable,\n            \"is_private\": is_private\n        }\n        return self.post(url, data=data)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef repo_all_list(self, project_key):\n        url = 'rest/api/1.0/projects/{projectKey}/repos'.format(projectKey=project_key)\n        params = {}\n        start = 0\n        params['start'] = start\n        response = self.get(url, params=params)\n        if 'values' not in response:\n            return []\n        repo_list = (response or {}).get('values')\n        while not response.get('isLastPage'):\n            start = response.get('nextPageStart')\n            params['start'] = start\n            response = self.get(url, params=params)\n            repo_list += (response or {}).get('values')\n        return repo_list", "response": "Get all repositories list from project\n           "}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_branches(self, project, repository, base=None, filter=None, start=0, limit=99999, details=True,\n                     order_by='MODIFICATION'):\n        \"\"\"\n        Retrieve the branches matching the supplied filterText param.\n        The authenticated user must have REPO_READ permission for the specified repository to call this resource.\n        :param start:\n        :param project:\n        :param repository:\n        :param base: base branch/tag to compare each branch to (for the metadata providers that uses that information)\n        :param filter:\n        :param limit: OPTIONAL: The limit of the number of branches to return, this may be restricted by\n                    fixed system limits. Default by built-in method: 99999\n        :param details: whether to retrieve plugin-provided metadata about each branch\n        :param order_by: OPTIONAL: ordering of refs either ALPHABETICAL (by name) or MODIFICATION (last updated)\n        :return:\n        \"\"\"\n        url = 'rest/api/1.0/projects/{project}/repos/{repository}/branches'.format(project=project,\n                                                                                   repository=repository)\n        params = {}\n        if start:\n            params['start'] = start\n        if limit:\n            params['limit'] = limit\n        if filter:\n            params['filterText'] = filter\n        if base:\n            params['base'] = base\n        if order_by:\n            params['orderBy'] = order_by\n        params['details'] = details\n\n        return (self.get(url, params=params) or {}).get('values')", "response": "Retrieve the branches for the specified filterText param."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef create_branch(self, project_key, repository, name, start_point, message=\"\"):\n\n        url = 'rest/api/1.0/projects/{projectKey}/repos/{repository}/branches'.format(projectKey=project_key,\n                                                                                      repository=repository)\n        data = {\n            \"name\": name,\n            \"startPoint\": start_point,\n            \"message\": message\n        }\n        return self.post(url, data=data)", "response": "Creates a branch using the information provided in the request."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef delete_branch(self, project, repository, name, end_point):\n\n        url = 'rest/branch-utils/1.0/projects/{project}/repos/{repository}/branches'.format(project=project,\n                                                                                            repository=repository)\n\n        data = {\"name\": str(name), \"endPoint\": str(end_point)}\n        return self.delete(url, data=data)", "response": "Delete branch from related repo\n       "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting pull requests in a repository.", "response": "def get_pull_requests(self, project, repository, state='OPEN', order='newest', limit=100, start=0):\n        \"\"\"\n        Get pull requests\n        :param project:\n        :param repository:\n        :param state:\n        :param order: OPTIONAL: defaults to NEWEST) the order to return pull requests in, either OLDEST\n                                (as in: \"oldest first\") or NEWEST.\n        :param limit:\n        :param start:\n        :return:\n        \"\"\"\n        url = 'rest/api/1.0/projects/{project}/repos/{repository}/pull-requests'.format(project=project,\n                                                                                        repository=repository)\n        params = {}\n        if state:\n            params['state'] = state\n        if limit:\n            params['limit'] = limit\n        if start:\n            params['start'] = start\n        if order:\n            params['order'] = order\n        response = self.get(url, params=params)\n        if 'values' not in response:\n            return []\n        pr_list = (response or {}).get('values')\n        while not response.get('isLastPage'):\n            start = response.get('nextPageStart')\n            params['start'] = start\n            response = self.get(url, params=params)\n            pr_list += (response or {}).get('values')\n        return pr_list"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_pull_requests_activities(self, project, repository, pull_request_id):\n        url = 'rest/api/1.0/projects/{project}/repos/{repository}/pull-requests/{pullRequestId}/activities'.format(\n            project=project,\n            repository=repository,\n            pullRequestId=pull_request_id)\n        params = {'start': 0}\n        response = self.get(url, params=params)\n        if 'values' not in response:\n            return []\n        activities_list = (response or {}).get('values')\n        while not response.get('isLastPage'):\n            params['start'] = response.get('nextPageStart')\n            response = self.get(url, params=params)\n            activities_list += (response or {}).get('values')\n        return activities_list", "response": "Get the list of pull requests activities within a pull request."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_pull_requests_changes(self, project, repository, pull_request_id):\n        url = 'rest/api/1.0/projects/{project}/repos/{repository}/pull-requests/{pullRequestId}/changes'.format(\n            project=project,\n            repository=repository,\n            pullRequestId=pull_request_id)\n        params = {'start': 0}\n        response = self.get(url, params=params)\n        if 'values' not in response:\n            return []\n        changes_list = (response or {}).get('values')\n        while not response.get('isLastPage'):\n            params['start'] = response.get('nextPageStart')\n            if params['start'] is None:\n                log.warning('Too many changes in pull request. Changes list is incomplete.')\n                break\n            response = self.get(url, params=params)\n            changes_list += (response or {}).get('values')\n        return changes_list", "response": "Get the list of all changes in a pull request."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_pull_requests_commits(self, project, repository, pull_request_id):\n        url = 'rest/api/1.0/projects/{project}/repos/{repository}/pull-requests/{pullRequestId}/commits'.format(\n            project=project,\n            repository=repository,\n            pullRequestId=pull_request_id)\n        params = {'start': 0}\n        response = self.get(url, params=params)\n        if 'values' not in response:\n            return []\n        commits_list = (response or {}).get('values')\n        while not response.get('isLastPage'):\n            params['start'] = response.get('nextPageStart')\n            response = self.get(url, params=params)\n            commits_list += (response or {}).get('values')\n        return commits_list", "response": "Get the commits for a pull request."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds a comment into a pull request", "response": "def add_pull_request_comment(self, project, repository, pull_request_id, text):\n        \"\"\"\n        Add comment into pull request\n        :param project:\n        :param repository:\n        :param pull_request_id: the ID of the pull request within the repository\n        :param text comment text\n        :return:\n        \"\"\"\n        url = 'rest/api/1.0/projects/{project}/repos/{repository}/pull-requests/{pullRequestId}/comments'.format(\n            project=project,\n            repository=repository,\n            pullRequestId=pull_request_id)\n        body = {'text': text}\n        return self.post(url, data=body)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget a pull request.", "response": "def get_pullrequest(self, project, repository, pull_request_id):\n        \"\"\"\n        Retrieve a pull request.\n        The authenticated user must have REPO_READ permission\n        for the repository that this pull request targets to call this resource.\n        :param project:\n        :param repository:\n        :param pull_request_id: the ID of the pull request within the repository\n        :return:\n        \"\"\"\n        url = 'rest/api/1.0/projects/{project}/repos/{repository}/pull-requests/{pullRequestId}'.format(project=project,\n                                                                                                        repository=repository,\n                                                                                                        pullRequestId=pull_request_id)\n        return self.get(url)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_tags(self, project, repository, filter='', limit=1000, order_by=None, start=0):\n        url = 'rest/api/1.0/projects/{project}/repos/{repository}/tags'.format(project=project,\n                                                                               repository=repository)\n        params = {}\n        if start:\n            params['start'] = start\n        if limit:\n            params['limit'] = limit\n        if filter:\n            params['filter'] = filter\n        if order_by:\n            params['orderBy'] = order_by\n        result = self.get(url, params=params)\n        if result.get('isLastPage'):\n            log.info('This is a last page of the result')\n        else:\n            log.info('Next page start at {}'.format(result.get('nextPageStart')))\n        return (result or {}).get('values')", "response": "Retrieve the tags for a given context repository."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_project_tags(self, project, repository, tag_name):\n        url = 'rest/api/1.0/projects/{project}/repos/{repository}/tags/{tag}'.format(project=project,\n                                                                                     repository=repository,\n                                                                                     tag=tag_name)\n        return self.get(url)", "response": "Get a specific tag in the specified repository."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting the tag name and revision of the current context.", "response": "def set_tag(self, project, repository, tag_name, commit_revision, description=None):\n        \"\"\"\n        Creates a tag using the information provided in the {@link RestCreateTagRequest request}\n        The authenticated user must have REPO_WRITE permission for the context repository to call this resource.\n        :param project:\n        :param repository:\n        :param tag_name:\n        :param commit_revision: commit hash\n        :param description: OPTIONAL:\n        :return:\n        \"\"\"\n        url = 'rest/api/1.0/projects/{project}/repos/{repository}/tags'.format(project=project,\n                                                                               repository=repository)\n        body = {}\n        if tag_name is not None:\n            body['name'] = tag_name\n        if tag_name is not None:\n            body['startPoint'] = commit_revision\n        if tag_name is not None:\n            body['message'] = description\n        return self.post(url, data=body)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef delete_tag(self, project, repository, tag_name):\n        url = 'rest/git/1.0/projects/{project}/repos/{repository}/tags/{tag}'.format(project=project,\n                                                                                     repository=repository,\n                                                                                     tag=tag_name)\n        return self.delete(url)", "response": "Delete a tag from a context repository"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_commits(self, project, repository, hash_oldest, hash_newest, limit=99999):\n        url = 'rest/api/1.0/projects/{project}/repos/{repository}/commits'.format(project=project,\n                                                                                  repository=repository)\n        params = {}\n        if hash_oldest:\n            params['since'] = hash_oldest\n        if hash_newest:\n            params['until'] = hash_newest\n        if limit:\n            params['limit'] = limit\n        return (self.get(url, params=params) or {}).get('values')", "response": "Get the list of commits from a repository."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_commit_info(self, project, repository, commit, path=None):\n        url = 'rest/api/1.0/projects/{project}/repos/{repository}/commits/{commitId}'.format(project=project,\n                                                                                             repository=repository,\n                                                                                             commitId=commit)\n        params = {}\n        if path:\n            params['path'] = path\n        return self.get(url, params=params)", "response": "Retrieve a single commit identified by its ID."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_changelog(self, project, repository, ref_from, ref_to, limit=99999):\n        url = 'rest/api/1.0/projects/{project}/repos/{repository}/compare/commits'.format(project=project,\n                                                                                          repository=repository)\n        params = {}\n        if ref_from:\n            params['from'] = ref_from\n        if ref_to:\n            params['to'] = ref_to\n        if limit:\n            params['limit'] = limit\n        return (self.get(url, params=params) or {}).get('values')", "response": "Get the change log between two refs."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nretrieving a page of files from particular directory of a repository.", "response": "def get_file_list(self, project, repository, query, limit=100000):\n        \"\"\"\n        Retrieve a page of files from particular directory of a repository.\n        The search is done recursively, so all files from any sub-directory of the specified directory will be returned.\n        The authenticated user must have REPO_READ permission for the specified repository to call this resource.\n        :param project:\n        :param repository:\n        :param query: the commit ID or ref (e.g. a branch or tag) to list the files at.\n                      If not specified the default branch will be used instead.\n        :param limit: OPTIONAL\n        :return:\n        \"\"\"\n        url = 'rest/api/1.0/projects/{project}/repos/{repository}/files'.format(project=project,\n                                                                                repository=repository)\n        params = {}\n        if query:\n            params['at'] = query\n        if limit:\n            params['limit'] = limit\n        return (self.get(url, params=params) or {}).get('values')"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_content_of_file(self, project, repository, filename, at=None, markup=None):\n        headers = self.form_token_headers\n        url = 'projects/{project}/repos/{repository}/raw/{filename}/'.format(project=project,\n                                                                             repository=repository,\n                                                                             filename=filename)\n        params = {}\n        if at is not None:\n            params['at'] = at\n        if markup is not None:\n            params['markup'] = markup\n        return self.get(url, params=params, not_json_response=True, headers=headers)", "response": "Retrieve the raw content of a file at a specified revision."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_branches_permissions(self, project, repository, limit=25):\n        url = 'rest/branch-permissions/2.0/projects/{project}/repos/{repository}/restrictions'.format(project=project,\n                                                                                                      repository=repository)\n        params = {}\n        if limit:\n            params['limit'] = limit\n        return self.get(url, params=params)", "response": "Get branches permissions from a given repository"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef reindex_repo_dev_panel(self, project, repository):\n        url = 'rest/jira-dev/1.0/projects/{projectKey}/repos/{repositorySlug}/reindex'.format(projectKey=project,\n                                                                                              repositorySlug=repository)\n        return self.post(url)", "response": "Reindex all of the Jira issues related to this repository."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nforking a repository within the same project.", "response": "def fork_repository(self, project, repository, new_repository):\n        \"\"\"\n        Forks a repository within the same project.\n        :param project:\n        :param repository:\n        :param new_repository:\n        :return:\n        \"\"\"\n        url = 'rest/api/1.0/projects/{project}/repos/{repository}'.format(project=project,\n                                                                          repository=repository)\n        body = {}\n        if new_repository is not None:\n            body['name'] = new_repository\n        if new_repository is not None:\n            body['project'] = {'key': project}\n        return self.post(url, data=body)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_branching_model(self, project, repository):\n        url = 'rest/branch-utils/1.0/projects/{project}/repos/{repository}/branchmodel/configuration'.format(\n            project=project,\n            repository=repository)\n        return self.get(url)", "response": "Get branching model\n        :param project:\n        :param repository:\n        :return:"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_branching_model(self, project, repository, data):\n        url = 'rest/branch-utils/1.0/projects/{project}/repos/{repository}/branchmodel/configuration'.format(\n            project=project,\n            repository=repository)\n        return self.put(url, data=data)", "response": "Set branching model for a specific resource."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef enable_branching_model(self, project, repository):\n        default_model_data = {'development': {'refId': None, 'useDefault': True},\n                              'types': [{'displayName': 'Bugfix',\n                                         'enabled': True,\n                                         'id': 'BUGFIX',\n                                         'prefix': 'bugfix/'},\n                                        {'displayName': 'Feature',\n                                         'enabled': True,\n                                         'id': 'FEATURE',\n                                         'prefix': 'feature/'},\n                                        {'displayName': 'Hotfix',\n                                         'enabled': True,\n                                         'id': 'HOTFIX',\n                                         'prefix': 'hotfix/'},\n                                        {'displayName': 'Release',\n                                         'enabled': True,\n                                         'id': 'RELEASE',\n                                         'prefix': 'release/'}]}\n        return self.set_branching_model(project,\n                                        repository,\n                                        default_model_data)", "response": "Enable branching model by setting it with default configuration\n       "}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndisable branching model for a specific language.", "response": "def disable_branching_model(self, project, repository):\n        \"\"\"\n        Disable branching model\n        :param project:\n        :param repository:\n        :return:\n        \"\"\"\n        url = 'rest/branch-utils/1.0/projects/{project}/repos/{repository}/branchmodel/configuration'.format(\n            project=project,\n            repository=repository)\n        return self.delete(url)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the content of a resource from the server", "response": "def get(self, path, data=None, flags=None, params=None, headers=None, not_json_response=None):\n        \"\"\"\n        Get request based on the python-requests module. You can override headers, and also, get not json response\n        :param path:\n        :param data:\n        :param flags:\n        :param params:\n        :param headers:\n        :param not_json_response: OPTIONAL: For get content from raw requests packet\n        :return:\n        \"\"\"\n        answer = self.request('GET', path=path, flags=flags, params=params, data=data, headers=headers)\n        if not_json_response:\n            return answer.content\n        else:\n            try:\n                return answer.json()\n            except Exception as e:\n                log.error(e)\n                return"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndeleting resources at given paths. :rtype: dict :return: Empty dictionary to have consistent interface. Some of Atlassian REST resources don't return any content.", "response": "def delete(self, path, data=None, headers=None, params=None):\n        \"\"\"\n        Deletes resources at given paths.\n        :rtype: dict\n        :return: Empty dictionary to have consistent interface.\n        Some of Atlassian REST resources don't return any content.\n        \"\"\"\n        self.request('DELETE', path=path, data=data, headers=headers, params=params)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndetect errors in a given space.", "response": "def check_unknown_attachment_in_space(confluence, space_key):\r\n    \"\"\"\r\n    Detect errors in space\r\n    :param confluence:\r\n    :param space_key:\r\n    :return:\r\n    \"\"\"\r\n    page_ids = get_all_pages_ids(confluence, space_key)\r\n    print(\"Start review pages {} in {}\".format(len(page_ids), space_key))\r\n    for page_id in page_ids:\r\n        link = confluence.has_unknown_attachment_error(page_id)\r\n        if len(link) > 0:\r\n            print(link)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef search_word(confluence, word):\r\n    cql = \"siteSearch ~ {} order by created\".format(word)\r\n    answers = confluence.cql(cql)\r\n    for answer in answers.get('results'):\r\n        print(answer)", "response": "Search for all pages with the given word"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef search_word_in_space(confluence, space, word):\r\n    cql = \"space.key={} and (text ~ {})\".format(space, word)\r\n    answers = confluence.cql(cql, expand='space,body.view')\r\n    for answer in answers.get('results'):\r\n        print(answer)", "response": "Search for a word in a given space"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nremoving all pages from trash for related space", "response": "def clean_pages_from_space(confluence, space_key, limit=500):\n    \"\"\"\n    Remove all pages from trash for related space\n    :param limit:\n    :param confluence:\n    :param space_key:\n    :return:\n    \"\"\"\n    flag = True\n    while flag:\n        values = confluence.get_all_pages_from_space_trash(space=space_key, start=0, limit=limit)\n        if len(values) == 0:\n            flag = False\n            print(\"For space {} trash is empty\".format(space_key))\n        else:\n            print(\"Found in space {} pages as trashed {}\".format(space_key, len(values)))\n            for value in values:\n                print(\"Removing page with title: \" + value['title'])\n                confluence.remove_page_from_trash(value['id'])"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef clean_all_trash_pages_from_all_spaces(confluence):\n    limit = 50\n    flag = True\n    i = 0\n    while flag:\n        space_lists = confluence.get_all_spaces(start=i * limit, limit=limit)\n        if space_lists and len(space_lists) != 0:\n            i += 1\n            for space_list in space_lists:\n                print(\"Start review the space with key = \" + space_list['key'])\n                clean_pages_from_space(confluence=confluence, space_key=space_list['key'])\n        else:\n            flag = False\n    return 0", "response": "This function will retrieve all space keys and provide space for cleaner\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets all page ids from a given space.", "response": "def get_all_page_ids_from_space(confluence, space_key):\n    \"\"\"\n    :param confluence:\n    :param space_key:\n    :return:\n    \"\"\"\n    limit = 500\n    flag = True\n    step = 0\n    page_ids = []\n\n    while flag:\n        values = confluence.get_all_pages_from_space(space=space_key, start=limit * step, limit=limit)\n        step += 1\n        if len(values) == 0:\n            flag = False\n            print(\"Did not find any pages, please, check permissions\")\n        else:\n            for value in values:\n                print(\"Retrieve page with title: \" + value['title'])\n                page_ids.append((value['id']))\n    print(\"Found in space {} pages {}\".format(space_key, len(page_ids)))\n    return page_ids"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the threshold of the content.", "response": "def threshold(self, value):\n        \"\"\"Threshold used to determine if your content qualifies as spam.\n        On a scale from 1 to 10, with 10 being most strict, or most likely to\n        be considered as spam.\n\n        :param value: Threshold used to determine if your content qualifies as\n                      spam.\n                      On a scale from 1 to 10, with 10 being most strict, or\n                      most likely to be considered as spam.\n        :type value: int\n        \"\"\"\n        if isinstance(value, SpamThreshold):\n            self._threshold = value\n        else:\n            self._threshold = SpamThreshold(value)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting the post_to_url of the Inbound Parse URL.", "response": "def post_to_url(self, value):\n        \"\"\"An Inbound Parse URL to send a copy of your email.\n        If defined, a copy of your email and its spam report will be sent here.\n\n        :param value: An Inbound Parse URL to send a copy of your email.\n        If defined, a copy of your email and its spam report will be sent here.\n        :type value: string\n        \"\"\"\n        if isinstance(value, SpamUrl):\n            self._post_to_url = value\n        else:\n            self._post_to_url = SpamUrl(value)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets a JSON - ready representation of this SpamCheck.", "response": "def get(self):\n        \"\"\"\n        Get a JSON-ready representation of this SpamCheck.\n\n        :returns: This SpamCheck, ready for use in a request body.\n        :rtype: dict\n        \"\"\"\n        spam_check = {}\n        if self.enable is not None:\n            spam_check[\"enable\"] = self.enable\n\n        if self.threshold is not None:\n            spam_check[\"threshold\"] = self.threshold.get()\n\n        if self.post_to_url is not None:\n            spam_check[\"post_to_url\"] = self.post_to_url.get()\n        return spam_check"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get(self):\n        content = {}\n        if self.mime_type is not None:\n            content[\"type\"] = self.mime_type\n\n        if self.content is not None:\n            content[\"value\"] = self.content\n        return content", "response": "Returns a JSON - ready representation of this HtmlContent."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting a JSON - ready representation of this BCCSettings.", "response": "def get(self):\n        \"\"\"\n        Get a JSON-ready representation of this BCCSettings.\n\n        :returns: This BCCSettings, ready for use in a request body.\n        :rtype: dict\n        \"\"\"\n        bcc_settings = {}\n        if self.enable is not None:\n            bcc_settings[\"enable\"] = self.enable\n\n        if self.email is not None:\n            bcc_settings[\"email\"] = self.email.get()\n        return bcc_settings"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _default_headers(self):\r\n        headers = {\r\n            \"Authorization\": 'Bearer {}'.format(self.api_key),\r\n            \"User-agent\": self.useragent,\r\n            \"Accept\": 'application/json'\r\n        }\r\n        if self.impersonate_subuser:\r\n            headers['On-Behalf-Of'] = self.impersonate_subuser\r\n\r\n        return headers", "response": "Set the default header for a Twilio SendGrid v3 API call"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef send(self, message):\r\n        if isinstance(message, dict):\r\n            response = self.client.mail.send.post(request_body=message)\r\n        else:\r\n            response = self.client.mail.send.post(request_body=message.get())\r\n        return response", "response": "Make a Twilio SendGrid v3 API request with the request body generated by the Mail object\r\n           the Mail object\r\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nensures an item is appended to a list or create a new empty list", "response": "def _ensure_append(self, new_items, append_to, index=0):\n        \"\"\"Ensure an item is appended to a list or create a new empty list\n\n        :param new_items: the item(s) to append\n        :type new_items: list(obj)\n        :param append_to: the list on which to append the items\n        :type append_to: list()\n        :param index: index of the list on which to append the items\n        :type index: int\n        \"\"\"\n        append_to = append_to or []\n        append_to.insert(index, new_items)\n        return append_to"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _ensure_insert(self, new_items, insert_to):\n        insert_to = insert_to or []\n        insert_to.insert(0, new_items)\n        return insert_to", "response": "Ensure an item is inserted to a list or create a new empty list"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _flatten_dicts(self, dicts):\n        d = dict()\n        list_of_dicts = [d.get() for d in dicts or []]\n        return {k: v for d in list_of_dicts for k, v in d.items()}", "response": "Flatten a list of dicts into a single dict."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding emails to the Personalization object.", "response": "def _set_emails(\n            self, emails, global_substitutions=None, is_multiple=False, p=0):\n        \"\"\"Adds emails to the Personalization object\n\n        :param emails: An Email or list of Email objects\n        :type emails: Email, list(Email)\n        :param global_substitutions: A dict of substitutions for all recipients\n        :type global_substitutions: dict\n        :param is_multiple: Create a new personilization for each recipient\n        :type is_multiple: bool\n        :param p: p is the Personalization object or Personalization object\n                  index\n        :type p: Personalization, integer, optional\n        \"\"\"\n        # Send multiple emails to multiple recipients\n        if is_multiple is True:\n            if isinstance(emails, list):\n                for email in emails:\n                    personalization = Personalization()\n                    personalization.add_email(email)\n                    self.add_personalization(personalization)\n            else:\n                personalization = Personalization()\n                personalization.add_email(emails)\n                self.add_personalization(personalization)\n            if global_substitutions is not None:\n                if isinstance(global_substitutions, list):\n                    for substitution in global_substitutions:\n                        for p in self.personalizations:\n                            p.add_substitution(substitution)\n                else:\n                    for p in self.personalizations:\n                        p.add_substitution(global_substitutions)\n        else:\n            try:\n                personalization = self._personalizations[p]\n                has_internal_personalization = True\n            except IndexError:\n                personalization = Personalization()\n                has_internal_personalization = False\n\n            if isinstance(emails, list):\n                for email in emails:\n                    personalization.add_email(email)\n            else:\n                personalization.add_email(emails)\n\n            if global_substitutions is not None:\n                if isinstance(global_substitutions, list):\n                    for substitution in global_substitutions:\n                        personalization.add_substitution(substitution)\n                else:\n                    personalization.add_substitution(global_substitutions)\n\n            if not has_internal_personalization:\n                self.add_personalization(personalization, index=p)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadds a Personaliztion object to the internal list of personalizations.", "response": "def add_personalization(self, personalization, index=0):\n        \"\"\"Add a Personaliztion object\n\n        :param personalizations: Add a Personalization object\n        :type personalizations: Personalization\n        :param index: The index where to add the Personalization\n        :type index: int\n        \"\"\"\n        self._personalizations = self._ensure_append(\n            personalization, self._personalizations, index)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef to(self, to_emails, global_substitutions=None, is_multiple=False, p=0):\n        if isinstance(to_emails, list):\n            for email in to_emails:\n                if isinstance(email, str):\n                    email = To(email, None)\n                if isinstance(email, tuple):\n                    email = To(email[0], email[1])\n                self.add_to(email, global_substitutions, is_multiple, p)\n        else:\n            if isinstance(to_emails, str):\n                to_emails = To(to_emails, None)\n            if isinstance(to_emails, tuple):\n                to_emails = To(to_emails[0], to_emails[1])\n            self.add_to(to_emails, global_substitutions, is_multiple, p)", "response": "Adds To objects to the Personalization object."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add_to(\n            self, to_email, global_substitutions=None, is_multiple=False, p=0):\n        \"\"\"Adds a To object to the Personalization object\n\n        :param to_emails: A To object\n        :type to_emails: To, str, tuple\n        :param global_substitutions: A dict of substitutions for all recipients\n        :type global_substitutions: dict\n        :param is_multiple: Create a new personilization for each recipient\n        :type is_multiple: bool\n        :param p: p is the Personalization object or Personalization object\n                  index\n        :type p: Personalization, integer, optional\n        \"\"\"\n\n        if isinstance(to_email, list):\n            for email in to_email:\n                if isinstance(email, str):\n                    email = To(email, None)\n                if isinstance(email, tuple):\n                    email = To(email[0], email[1])\n                self._set_emails(email, global_substitutions, is_multiple, p)\n        else:\n            if isinstance(to_email, str):\n                to_email = To(to_email, None)\n            if isinstance(to_email, tuple):\n                to_email = To(to_email[0], to_email[1])\n            if isinstance(to_email, Email):\n                p = to_email.personalization\n            self._set_emails(to_email, global_substitutions, is_multiple, p)", "response": "Adds a To object to the Personalization object."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef cc(self, cc_emails, global_substitutions=None, is_multiple=False, p=0):\n        if isinstance(cc_emails, list):\n            for email in cc_emails:\n                if isinstance(email, str):\n                    email = Cc(email, None)\n                if isinstance(email, tuple):\n                    email = Cc(email[0], email[1])\n                self.add_cc(email, global_substitutions, is_multiple, p)\n        else:\n            if isinstance(cc_emails, str):\n                cc_emails = Cc(cc_emails, None)\n            if isinstance(cc_emails, tuple):\n                cc_emails = To(cc_emails[0], cc_emails[1])\n            self.add_cc(cc_emails, global_substitutions, is_multiple, p)", "response": "Adds Cc objects to the Personalization object."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add_cc(\n            self, cc_email, global_substitutions=None, is_multiple=False, p=0):\n        \"\"\"Adds a Cc object to the Personalization object\n\n        :param to_emails: An Cc object\n        :type to_emails: Cc\n        :param global_substitutions: A dict of substitutions for all recipients\n        :type global_substitutions: dict\n        :param is_multiple: Create a new personilization for each recipient\n        :type is_multiple: bool\n        :param p: p is the Personalization object or Personalization object\n                  index\n        :type p: Personalization, integer, optional\n        \"\"\"\n        if isinstance(cc_email, str):\n            cc_email = Cc(cc_email, None)\n        if isinstance(cc_email, tuple):\n            cc_email = Cc(cc_email[0], cc_email[1])\n        if isinstance(cc_email, Email):\n            p = cc_email.personalization\n        self._set_emails(\n            cc_email, global_substitutions, is_multiple=is_multiple, p=p)", "response": "Adds a Cc object to the Personalization object."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding Bcc objects to the Personalization object.", "response": "def bcc(\n            self,\n            bcc_emails,\n            global_substitutions=None,\n            is_multiple=False,\n            p=0):\n        \"\"\"Adds Bcc objects to the Personalization object\n\n        :param bcc_emails: An Bcc or list of Bcc objects\n        :type bcc_emails: Bcc, list(Bcc), tuple\n        :param global_substitutions: A dict of substitutions for all recipients\n        :type global_substitutions: dict\n        :param is_multiple: Create a new personilization for each recipient\n        :type is_multiple: bool\n        :param p: p is the Personalization object or Personalization object\n                  index\n        :type p: Personalization, integer, optional\n        \"\"\"\n        if isinstance(bcc_emails, list):\n            for email in bcc_emails:\n                if isinstance(email, str):\n                    email = Bcc(email, None)\n                if isinstance(email, tuple):\n                    email = Bcc(email[0], email[1])\n                self.add_bcc(email, global_substitutions, is_multiple, p)\n        else:\n            if isinstance(bcc_emails, str):\n                bcc_emails = Bcc(bcc_emails, None)\n            if isinstance(bcc_emails, tuple):\n                bcc_emails = Bcc(bcc_emails[0], bcc_emails[1])\n            self.add_bcc(bcc_emails, global_substitutions, is_multiple, p)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadd a Bcc object to the Personalization object.", "response": "def add_bcc(\n            self,\n            bcc_email,\n            global_substitutions=None,\n            is_multiple=False,\n            p=0):\n        \"\"\"Adds a Bcc object to the Personalization object\n\n        :param to_emails: An Bcc object\n        :type to_emails: Bcc\n        :param global_substitutions: A dict of substitutions for all recipients\n        :type global_substitutions: dict\n        :param is_multiple: Create a new personilization for each recipient\n        :type is_multiple: bool\n        :param p: p is the Personalization object or Personalization object\n                  index\n        :type p: Personalization, integer, optional\n        \"\"\"\n        if isinstance(bcc_email, str):\n            bcc_email = Bcc(bcc_email, None)\n        if isinstance(bcc_email, tuple):\n            bcc_email = Bcc(bcc_email[0], bcc_email[1])\n        if isinstance(bcc_email, Email):\n            p = bcc_email.personalization\n        self._set_emails(\n            bcc_email,\n            global_substitutions,\n            is_multiple=is_multiple,\n            p=p)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef subject(self, value):\n        if isinstance(value, Subject):\n            if value.personalization is not None:\n                try:\n                    personalization = \\\n                        self._personalizations[value.personalization]\n                    has_internal_personalization = True\n                except IndexError:\n                    personalization = Personalization()\n                    has_internal_personalization = False\n                personalization.subject = value.subject\n\n                if not has_internal_personalization:\n                    self.add_personalization(\n                        personalization,\n                        index=value.personalization)\n            else:\n                self._subject = value\n        else:\n            self._subject = Subject(value)", "response": "Sets the subject of the message."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef header(self, headers):\n        if isinstance(headers, list):\n            for h in headers:\n                self.add_header(h)\n        else:\n            self.add_header(headers)", "response": "Add headers to the email\n\n       "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add_header(self, header):\n        if header.personalization is not None:\n            try:\n                personalization = \\\n                    self._personalizations[header.personalization]\n                has_internal_personalization = True\n            except IndexError:\n                personalization = Personalization()\n                has_internal_personalization = False\n            if isinstance(header, dict):\n                (k, v) = list(header.items())[0]\n                personalization.add_header(Header(k, v))\n            else:\n                personalization.add_header(header)\n\n            if not has_internal_personalization:\n                self.add_personalization(\n                    personalization,\n                    index=header.personalization)\n        else:\n            if isinstance(header, dict):\n                (k, v) = list(header.items())[0]\n                self._headers = self._ensure_append(\n                                    Header(k, v), self._headers)\n            else:\n                self._headers = self._ensure_append(header, self._headers)", "response": "Add headers to the email globaly or to a specific Personalization"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef substitution(self, substitution):\n        if isinstance(substitution, list):\n            for s in substitution:\n                self.add_substitution(s)\n        else:\n            self.add_substitution(substitution)", "response": "Add substitutions to the email\nTaxonomy"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd a substitution to the email.", "response": "def add_substitution(self, substitution):\n        \"\"\"Add a substitution to the email\n\n        :param value: Add a substitution to the email\n        :type value: Substitution\n        \"\"\"\n        if substitution.personalization:\n            try:\n                personalization = \\\n                    self._personalizations[substitution.personalization]\n                has_internal_personalization = True\n            except IndexError:\n                personalization = Personalization()\n                has_internal_personalization = False\n            personalization.add_substitution(substitution)\n\n            if not has_internal_personalization:\n                self.add_personalization(\n                    personalization, index=substitution.personalization)\n        else:\n            if isinstance(substitution, list):\n                for s in substitution:\n                    for p in self.personalizations:\n                        p.add_substitution(s)\n            else:\n                for p in self.personalizations:\n                    p.add_substitution(substitution)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds custom args to the email key - value pairs.", "response": "def custom_arg(self, custom_arg):\n        \"\"\"Add custom args to the email\n\n        :param value: A list of CustomArg objects or a dict of custom arg\n                      key/values\n        :type value: CustomArg, list(CustomArg), dict\n        \"\"\"\n        if isinstance(custom_arg, list):\n            for c in custom_arg:\n                self.add_custom_arg(c)\n        else:\n            self.add_custom_arg(custom_arg)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add_custom_arg(self, custom_arg):\n        if custom_arg.personalization is not None:\n            try:\n                personalization = \\\n                    self._personalizations[custom_arg.personalization]\n                has_internal_personalization = True\n            except IndexError:\n                personalization = Personalization()\n                has_internal_personalization = False\n            if isinstance(custom_arg, dict):\n                (k, v) = list(custom_arg.items())[0]\n                personalization.add_custom_arg(CustomArg(k, v))\n            else:\n                personalization.add_custom_arg(custom_arg)\n\n            if not has_internal_personalization:\n                self.add_personalization(\n                    personalization, index=custom_arg.personalization)\n        else:\n            if isinstance(custom_arg, dict):\n                (k, v) = list(custom_arg.items())[0]\n                self._custom_args = self._ensure_append(\n                    CustomArg(k, v), self._custom_args)\n            else:\n                self._custom_args = self._ensure_append(\n                    custom_arg, self._custom_args)", "response": "Adds custom args to the email globaly or to a specific Personalization"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef send_at(self, value):\n        if isinstance(value, SendAt):\n            if value.personalization is not None:\n                try:\n                    personalization = \\\n                        self._personalizations[value.personalization]\n                    has_internal_personalization = True\n                except IndexError:\n                    personalization = Personalization()\n                    has_internal_personalization = False\n                personalization.send_at = value.send_at\n\n                if not has_internal_personalization:\n                    self.add_personalization(\n                        personalization, index=value.personalization)\n            else:\n                self._send_at = value\n        else:\n            self._send_at = SendAt(value)", "response": "Set the send_at of the related object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the dynamic template data for a transactional template.", "response": "def dynamic_template_data(self, value):\n        \"\"\"Data for a transactional template\n\n        :param value: Data for a transactional template\n        :type value: DynamicTemplateData, a JSON-serializeable structure\n        \"\"\"\n        if not isinstance(value, DynamicTemplateData):\n            value = DynamicTemplateData(value)\n        try:\n            personalization = self._personalizations[value.personalization]\n            has_internal_personalization = True\n        except IndexError:\n            personalization = Personalization()\n            has_internal_personalization = False\n        personalization.dynamic_template_data = value.dynamic_template_data\n\n        if not has_internal_personalization:\n            self.add_personalization(\n                personalization, index=value.personalization)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets the From field of the object", "response": "def from_email(self, value):\n        \"\"\"The email address of the sender\n\n        :param value: The email address of the sender\n        :type value: From, str, tuple\n        \"\"\"\n        if isinstance(value, str):\n            value = From(value, None)\n        if isinstance(value, tuple):\n            value = From(value[0], value[1])\n        self._from_email = value"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef reply_to(self, value):\n        if isinstance(value, str):\n            value = ReplyTo(value, None)\n        if isinstance(value, tuple):\n            value = ReplyTo(value[0], value[1])\n        self._reply_to = value", "response": "Sets the ReplyTo value"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef content(self, contents):\n        if isinstance(contents, list):\n            for c in contents:\n                self.add_content(c)\n        else:\n            self.add_content(contents)", "response": "The content of the email\n        is a list of Content objects."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add_content(self, content, mime_type=None):\n        if isinstance(content, str):\n            content = Content(mime_type, content)\n        # Content of mime type text/plain must always come first\n        if content.mime_type == \"text/plain\":\n            self._contents = self._ensure_insert(content, self._contents)\n        else:\n            if self._contents:\n                index = len(self._contents)\n            else:\n                index = 0\n            self._contents = self._ensure_append(\n                content, self._contents, index=index)", "response": "Add a content to the email."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef attachment(self, attachment):\n        if isinstance(attachment, list):\n            for a in attachment:\n                self.add_attachment(a)\n        else:\n            self.add_attachment(attachment)", "response": "Adds an attachment to this email."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef add_attachment(self, attachment):\n        self._attachments = self._ensure_append(attachment, self._attachments)", "response": "Add an attachment to this email\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef template_id(self, value):\n        if isinstance(value, TemplateId):\n            self._template_id = value\n        else:\n            self._template_id = TemplateId(value)", "response": "Sets the transactional template id for this email."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding a section to the set of block sections of code to be used as substitutions", "response": "def section(self, section):\n        \"\"\"The block sections of code to be used as substitutions\n\n        :rtype: Section, list(Section)\n        \"\"\"\n        if isinstance(section, list):\n            for h in section:\n                self.add_section(h)\n        else:\n            self.add_section(section)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds a section to the set of section names to be used as substitutions .", "response": "def add_section(self, section):\n        \"\"\"A block section of code to be used as substitutions\n\n        :param section: A block section of code to be used as substitutions\n        :type section: Section\n        \"\"\"\n        self._sections = self._ensure_append(section, self._sections)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nadd categories assigned to this message.", "response": "def category(self, categories):\n        \"\"\"Add categories assigned to this message\n\n        :rtype: list(Category)\n        \"\"\"\n        if isinstance(categories, list):\n            for c in categories:\n                self.add_category(c)\n        else:\n            self.add_category(categories)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_category(self, category):\n        self._categories = self._ensure_append(category, self._categories)", "response": "Add a category assigned to this message\n       "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get(self):\n        mail = {\n            'from': self._get_or_none(self.from_email),\n            'subject': self._get_or_none(self.subject),\n            'personalizations': [p.get() for p in self.personalizations or []],\n            'content': [c.get() for c in self.contents or []],\n            'attachments': [a.get() for a in self.attachments or []],\n            'template_id': self._get_or_none(self.template_id),\n            'sections': self._flatten_dicts(self.sections),\n            'headers': self._flatten_dicts(self.headers),\n            'categories': [c.get() for c in self.categories or []],\n            'custom_args': self._flatten_dicts(self.custom_args),\n            'send_at':  self._get_or_none(self.send_at),\n            'batch_id': self._get_or_none(self.batch_id),\n            'asm': self._get_or_none(self.asm),\n            'ip_pool_name': self._get_or_none(self.ip_pool_name),\n            'mail_settings': self._get_or_none(self.mail_settings),\n            'tracking_settings': self._get_or_none(self.tracking_settings),\n            'reply_to': self._get_or_none(self.reply_to),\n        }\n\n        return {key: value for key, value in mail.items()\n                if value is not None and value != [] and value != {}}", "response": "Get a JSON - ready representation of this Mail object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef from_EmailMessage(cls, message):\n        mail = cls(\n            from_email=Email(message.get('From')),\n            subject=message.get('Subject'),\n            to_emails=Email(message.get('To')),\n        )\n        try:\n            body = message.get_content()\n        except AttributeError:\n            # Python2\n            body = message.get_payload()\n        mail.add_content(Content(\n            message.get_content_type(),\n            body.strip()\n        ))\n        for k, v in message.items():\n            mail.add_header(Header(k, v))\n        return mail", "response": "Create an instance of Mail from an email. message. EmailMessage object."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets a JSON - ready representation of this Ganalytics.", "response": "def get(self):\n        \"\"\"\n        Get a JSON-ready representation of this Ganalytics.\n\n        :returns: This Ganalytics, ready for use in a request body.\n        :rtype: dict\n        \"\"\"\n        keys = [\"enable\", \"utm_source\", \"utm_medium\", \"utm_term\",\n                \"utm_content\", \"utm_campaign\"]\n\n        ganalytics = {}\n\n        for key in keys:\n            value = getattr(self, key, None)\n            if value is not None:\n                if isinstance(value, bool):\n                    ganalytics[key] = value\n                else:\n                    ganalytics[key] = value.get()\n\n        return ganalytics"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget a JSON - ready representation of this FooterSettings.", "response": "def get(self):\n        \"\"\"\n        Get a JSON-ready representation of this FooterSettings.\n\n        :returns: This FooterSettings, ready for use in a request body.\n        :rtype: dict\n        \"\"\"\n        footer_settings = {}\n        if self.enable is not None:\n            footer_settings[\"enable\"] = self.enable\n\n        if self.text is not None:\n            footer_settings[\"text\"] = self.text.get()\n\n        if self.html is not None:\n            footer_settings[\"html\"] = self.html.get()\n        return footer_settings"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets the name associated with this email.", "response": "def name(self, value):\n        \"\"\"Name associated with this email.\n\n        :param value: Name associated with this email.\n        :type value: string\n        \"\"\"\n        if not (value is None or isinstance(value, str)):\n            raise TypeError('name must be of type string.')\n\n        # Escape common CSV delimiters as workaround for\n        # https://github.com/sendgrid/sendgrid-python/issues/578\n        if value is not None and (',' in value or ';' in value):\n            value = html_entity_decode(value)\n            value = '\"' + value + '\"'\n        self._name = value"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nparsing an email address and returns the name and email.", "response": "def parse_email(self, email_info):\n        \"\"\"Allows passing emails as \"Example Name <example@example.com>\"\n\n        :param email_info: Allows passing emails as\n                           \"Example Name <example@example.com>\"\n        :type email_info: string\n        \"\"\"\n        name, email = rfc822.parseaddr(email_info)\n\n        # more than likely a string was passed here instead of an email address\n        if \"@\" not in email:\n            name = email\n            email = None\n\n        if not name:\n            name = None\n\n        if not email:\n            email = None\n\n        self.name = name\n        self.email = email\n        return name, email"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a JSON - ready representation of this Email.", "response": "def get(self):\n        \"\"\"\n        Get a JSON-ready representation of this Email.\n\n        :returns: This Email, ready for use in a request body.\n        :rtype: dict\n        \"\"\"\n        email = {}\n        if self.name is not None:\n            email[\"name\"] = self.name\n\n        if self.email is not None:\n            email[\"email\"] = self.email\n        return email"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef groups_to_display(self, value):\n        if value is not None and len(value) > 25:\n            raise ValueError(\"New groups_to_display exceeds max length of 25.\")\n        self._groups_to_display = value", "response": "Sets the value for the groups_to_display property."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef group_id(self, value):\n        if isinstance(value, GroupId):\n            self._group_id = value\n        else:\n            self._group_id = GroupId(value)", "response": "The group ID of an unsubscribe group."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef groups_to_display(self, value):\n        if isinstance(value, GroupsToDisplay):\n            self._groups_to_display = value\n        else:\n            self._groups_to_display = GroupsToDisplay(value)", "response": "Set the array containing the unsubscribe groups that you would like to display on the preferences page. Max of 25 groups."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get(self):\n        asm = {}\n        if self.group_id is not None:\n            asm[\"group_id\"] = self.group_id.get()\n\n        if self.groups_to_display is not None:\n            asm[\"groups_to_display\"] = self.groups_to_display.get()\n        return asm", "response": "Get a JSON - ready representation of this ASM object."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nvalidates the JSON dict that will be sent to SendGrid s API.", "response": "def validate_message_dict(self, request_body):\n        \"\"\"With the JSON dict that will be sent to SendGrid's API,\n            check the content for SendGrid API keys - throw exception if found.\n\n           :param request_body: The JSON dict that will be sent to SendGrid's\n                                API.\n           :type request_body: JSON serializable structure\n           :raise ApiKeyIncludedException: If any content in request_body\n                                           matches regex\n        \"\"\"\n\n        # Handle string in edge-case\n        if isinstance(request_body, str):\n            self.validate_message_text(request_body)\n\n        # Default param\n        elif isinstance(request_body, dict):\n\n            contents = request_body.get(\"content\", list())\n\n            for content in contents:\n                if content is not None:\n                    if (content.get(\"type\") == \"text/html\" or\n                            isinstance(content.get(\"value\"), str)):\n                        message_text = content.get(\"value\", \"\")\n                        self.validate_message_text(message_text)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nvalidate that a message string contains a SendGrid API KeyAcquire.", "response": "def validate_message_text(self, message_string):\n        \"\"\"With a message string, check to see if it contains a SendGrid API Key\n            If a key is found, throw an exception\n\n           :param message_string: message that will be sent\n           :type message_string: string\n           :raises ApiKeyIncludedException: If message_string matches a regex\n                                            string\n        \"\"\"\n        if isinstance(message_string, str):\n            for regex in self.regexes:\n                if regex.match(message_string) is not None:\n                    raise ApiKeyIncludedException()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_mock_personalization_dict():\n    mock_pers = dict()\n\n    mock_pers['to_list'] = [To(\"test1@example.com\",\n                                  \"Example User\"),\n                            To(\"test2@example.com\",\n                                  \"Example User\")]\n\n    mock_pers['cc_list'] = [To(\"test3@example.com\",\n                                  \"Example User\"),\n                            To(\"test4@example.com\",\n                                  \"Example User\")]\n\n    mock_pers['bcc_list'] = [To(\"test5@example.com\"),\n                             To(\"test6@example.com\")]\n\n    mock_pers['subject'] = (\"Hello World from the Personalized \"\n                            \"SendGrid Python Library\")\n\n    mock_pers['headers'] = [Header(\"X-Test\", \"test\"),\n                            Header(\"X-Mock\", \"true\")]\n\n    mock_pers['substitutions'] = [Substitution(\"%name%\", \"Example User\"),\n                                  Substitution(\"%city%\", \"Denver\")]\n\n    mock_pers['custom_args'] = [CustomArg(\"user_id\", \"343\"),\n                                CustomArg(\"type\", \"marketing\")]\n\n    mock_pers['send_at'] = 1443636843\n    return mock_pers", "response": "Get a dict of personalization mock."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef build_attachment1():\n    attachment = Attachment()\n    attachment.content = (\"TG9yZW0gaXBzdW0gZG9sb3Igc2l0IGFtZXQsIGNvbnNl\"\n                          \"Y3RldHVyIGFkaXBpc2NpbmcgZWxpdC4gQ3JhcyBwdW12\")\n    attachment.type = \"application/pdf\"\n    attachment.filename = \"balance_001.pdf\"\n    attachment.disposition = \"attachment\"\n    attachment.content_id = \"Balance Sheet\"\n    return attachment", "response": "Build attachment mock. Make sure your content is base64 encoded before passing into attachment.content.\n    Another example: https://github.com/sendgrid/sendgrid-python/blob/master/use_cases/attachment.md"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef build_kitchen_sink():\n    from sendgrid.helpers.mail import (\n        Mail, From, To, Cc, Bcc, Subject, PlainTextContent, \n        HtmlContent, SendGridException, Substitution, \n        Header, CustomArg, SendAt, Content, MimeType, Attachment,\n        FileName, FileContent, FileType, Disposition, ContentId,\n        TemplateId, Section, ReplyTo, Category, BatchId, Asm,\n        GroupId, GroupsToDisplay, IpPoolName, MailSettings,\n        BccSettings, BccSettingsEmail, BypassListManagement,\n        FooterSettings, FooterText, FooterHtml, SandBoxMode,\n        SpamCheck, SpamThreshold, SpamUrl, TrackingSettings,\n        ClickTracking, SubscriptionTracking, SubscriptionText,\n        SubscriptionHtml, SubscriptionSubstitutionTag,\n        OpenTracking, OpenTrackingSubstitutionTag, Ganalytics,\n        UtmSource, UtmMedium, UtmTerm, UtmContent, UtmCampaign)\n    import time\n    import datetime\n\n    message = Mail()\n\n    # Define Personalizations \n\n    message.to = To('test1@sendgrid.com', 'Example User1', p=0)\n    message.to = [ \n        To('test2@sendgrid.com', 'Example User2', p=0),\n        To('test3@sendgrid.com', 'Example User3', p=0)\n    ]\n\n    message.cc = Cc('test4@example.com', 'Example User4', p=0)\n    message.cc = [ \n        Cc('test5@example.com', 'Example User5', p=0),\n        Cc('test6@example.com', 'Example User6', p=0)\n    ]\n\n    message.bcc = Bcc('test7@example.com', 'Example User7', p=0)\n    message.bcc = [ \n        Bcc('test8@example.com', 'Example User8', p=0),\n        Bcc('test9@example.com', 'Example User9', p=0)\n    ]\n\n    message.subject = Subject('Sending with SendGrid is Fun 0', p=0)\n\n    message.header = Header('X-Test1', 'Test1', p=0)\n    message.header = Header('X-Test2', 'Test2', p=0)\n    message.header = [\n        Header('X-Test3', 'Test3', p=0),\n        Header('X-Test4', 'Test4', p=0)\n    ]\n\n    message.substitution = Substitution('%name1%', 'Example Name 1', p=0)\n    message.substitution = Substitution('%city1%', 'Example City 1', p=0)\n    message.substitution = [\n        Substitution('%name2%', 'Example Name 2', p=0),\n        Substitution('%city2%', 'Example City 2', p=0)\n    ]\n\n    message.custom_arg = CustomArg('marketing1', 'true', p=0)\n    message.custom_arg = CustomArg('transactional1', 'false', p=0)\n    message.custom_arg = [\n        CustomArg('marketing2', 'false', p=0),\n        CustomArg('transactional2', 'true', p=0)\n    ]\n\n    message.send_at = SendAt(1461775051, p=0)\n\n    message.to = To('test10@example.com', 'Example User10', p=1)\n    message.to = [ \n        To('test11@example.com', 'Example User11', p=1),\n        To('test12@example.com', 'Example User12', p=1)\n    ]\n\n    message.cc = Cc('test13@example.com', 'Example User13', p=1)\n    message.cc = [ \n        Cc('test14@example.com', 'Example User14', p=1),\n        Cc('test15@example.com', 'Example User15', p=1)\n    ]\n\n    message.bcc = Bcc('test16@example.com', 'Example User16', p=1)\n    message.bcc = [ \n        Bcc('test17@example.com', 'Example User17', p=1),\n        Bcc('test18@example.com', 'Example User18', p=1)\n    ]\n\n    message.header = Header('X-Test5', 'Test5', p=1)\n    message.header = Header('X-Test6', 'Test6', p=1)\n    message.header = [\n        Header('X-Test7', 'Test7', p=1),\n        Header('X-Test8', 'Test8', p=1)\n    ]\n\n    message.substitution = Substitution('%name3%', 'Example Name 3', p=1)\n    message.substitution = Substitution('%city3%', 'Example City 3', p=1)\n    message.substitution = [\n        Substitution('%name4%', 'Example Name 4', p=1),\n        Substitution('%city4%', 'Example City 4', p=1)\n    ]\n\n    message.custom_arg = CustomArg('marketing3', 'true', p=1)\n    message.custom_arg = CustomArg('transactional3', 'false', p=1)\n    message.custom_arg = [\n        CustomArg('marketing4', 'false', p=1),\n        CustomArg('transactional4', 'true', p=1)\n    ]\n\n    message.send_at = SendAt(1461775052, p=1)\n\n    message.subject = Subject('Sending with SendGrid is Fun 1', p=1)\n\n    # The values below this comment are global to entire message\n\n    message.from_email = From('dx@sendgrid.com', 'DX')\n\n    message.reply_to = ReplyTo('dx_reply@sendgrid.com', 'DX Reply')\n\n    message.subject = Subject('Sending with SendGrid is Fun 2')\n\n    message.content = Content(MimeType.text, 'and easy to do anywhere, even with Python')\n    message.content = Content(MimeType.html, '<strong>and easy to do anywhere, even with Python</strong>')\n    message.content = [\n        Content('text/calendar', 'Party Time!!'),\n        Content('text/custom', 'Party Time 2!!')\n    ]\n\n    message.attachment = Attachment(FileContent('base64 encoded content 1'),\n                                    FileType('application/pdf'),\n                                    FileName('balance_001.pdf'),\n                                    Disposition('attachment'),\n                                    ContentId('Content ID 1'))\n    message.attachment = [\n        Attachment(FileContent('base64 encoded content 2'),\n                FileType('image/png'),\n                FileName('banner.png'),\n                Disposition('inline'),\n                ContentId('Content ID 2')),\n        Attachment(FileContent('base64 encoded content 3'),\n                FileType('image/png'),\n                FileName('banner2.png'),\n                Disposition('inline'),\n                ContentId('Content ID 3'))\n    ]\n\n    message.template_id = TemplateId('13b8f94f-bcae-4ec6-b752-70d6cb59f932')\n\n    message.section = Section('%section1%', 'Substitution for Section 1 Tag')\n    message.section = [\n        Section('%section2%', 'Substitution for Section 2 Tag'),\n        Section('%section3%', 'Substitution for Section 3 Tag')    \n    ]\n\n    message.header = Header('X-Test9', 'Test9')\n    message.header = Header('X-Test10', 'Test10')\n    message.header = [\n        Header('X-Test11', 'Test11'),\n        Header('X-Test12', 'Test12')\n    ]\n\n    message.category = Category('Category 1')\n    message.category = Category('Category 2')\n    message.category = [\n        Category('Category 1'),\n        Category('Category 2')\n    ]\n\n    message.custom_arg = CustomArg('marketing5', 'false')\n    message.custom_arg = CustomArg('transactional5', 'true')\n    message.custom_arg = [\n        CustomArg('marketing6', 'true'),\n        CustomArg('transactional6', 'false')\n    ]\n\n    message.send_at = SendAt(1461775053)\n\n    message.batch_id = BatchId(\"HkJ5yLYULb7Rj8GKSx7u025ouWVlMgAi\")\n\n    message.asm = Asm(GroupId(1), GroupsToDisplay([1,2,3,4]))\n\n    message.ip_pool_name = IpPoolName(\"IP Pool Name\")\n\n    mail_settings = MailSettings()\n    mail_settings.bcc_settings = BccSettings(False, BccSettingsTo(\"bcc@twilio.com\"))\n    mail_settings.bypass_list_management = BypassListManagement(False)\n    mail_settings.footer_settings = FooterSettings(True, FooterText(\"w00t\"), FooterHtml(\"<string>w00t!<strong>\"))\n    mail_settings.sandbox_mode = SandBoxMode(True)\n    mail_settings.spam_check = SpamCheck(True, SpamThreshold(5), SpamUrl(\"https://example.com\"))\n    message.mail_settings = mail_settings\n\n    tracking_settings = TrackingSettings()\n    tracking_settings.click_tracking = ClickTracking(True, False)\n    tracking_settings.open_tracking = OpenTracking(True, OpenTrackingSubstitutionTag(\"open_tracking\"))\n    tracking_settings.subscription_tracking = SubscriptionTracking(\n        True, \n        SubscriptionText(\"Goodbye\"),\n        SubscriptionHtml(\"<strong>Goodbye!</strong>\"),\n        SubscriptionSubstitutionTag(\"unsubscribe\"))\n    tracking_settings.ganalytics = Ganalytics(\n        True,\n        UtmSource(\"utm_source\"),\n        UtmMedium(\"utm_medium\"),\n        UtmTerm(\"utm_term\"),\n        UtmContent(\"utm_content\"),\n        UtmCampaign(\"utm_campaign\"))\n    message.tracking_settings = tracking_settings\n\n    return message.get()", "response": "Build a Kitchen Sink"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ninitializing the environment variables for the current object.", "response": "def init_environment():\n        \"\"\"Allow variables assigned in .env available using\n           os.environ.get('VAR_NAME')\"\"\"\n        base_path = os.path.abspath(os.path.dirname(__file__))\n        env_path = '{0}/.env'.format(base_path)\n        if os.path.exists(env_path):\n            with open(env_path) as f:\n                lines = f.readlines()\n                for line in lines:\n                    var = line.strip().split('=')\n                    if len(var) == 2:\n                        os.environ[var[0]] = var[1]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget a JSON - ready representation of this MailSettings.", "response": "def get(self):\n        \"\"\"\n        Get a JSON-ready representation of this MailSettings.\n\n        :returns: This MailSettings, ready for use in a request body.\n        :rtype: dict\n        \"\"\"\n        mail_settings = {}\n        if self.bcc_settings is not None:\n            mail_settings[\"bcc\"] = self.bcc_settings.get()\n\n        if self.bypass_list_management is not None:\n            mail_settings[\n                \"bypass_list_management\"] = self.bypass_list_management.get()\n\n        if self.footer_settings is not None:\n            mail_settings[\"footer\"] = self.footer_settings.get()\n\n        if self.sandbox_mode is not None:\n            mail_settings[\"sandbox_mode\"] = self.sandbox_mode.get()\n\n        if self.spam_check is not None:\n            mail_settings[\"spam_check\"] = self.spam_check.get()\n        return mail_settings"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get(self):\n        substitution = {}\n        if self.key is not None and self.value is not None:\n            substitution[self.key] = self.value\n        return substitution", "response": "Returns a JSON - ready representation of this Substitution."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a JSON - ready representation of this Header.", "response": "def get(self):\n        \"\"\"\n        Get a JSON-ready representation of this Header.\n\n        :returns: This Header, ready for use in a request body.\n        :rtype: dict\n        \"\"\"\n        header = {}\n        if self.key is not None and self.value is not None:\n            header[self.key] = self.value\n        return header"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a dictionary of key - value pairs in the payload received from the webhook", "response": "def key_values(self):\n        \"\"\"\n        Return a dictionary of key/values in the payload received from\n        the webhook\n        \"\"\"\n        key_values = {}\n        for key in self.keys:\n            if key in self.payload:\n                key_values[key] = self.payload[key]\n        return key_values"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_raw_email(self):\n        if 'email' in self.payload:\n            raw_email = email.message_from_string(self.payload['email'])\n            return raw_email\n        else:\n            return None", "response": "Returns the raw email for the current classroom."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn an object with the name of the file content type file_name contents of the file contents", "response": "def attachments(self):\n        \"\"\"Returns an object with:\n        type = file content type\n        file_name = the name of the file\n        contents = base64 encoded file contents\"\"\"\n        attachments = None\n        if 'attachment-info' in self.payload:\n            attachments = self._get_attachments(self.request)\n        # Check if we have a raw message\n        raw_email = self.get_raw_email()\n        if raw_email is not None:\n            attachments = self._get_attachments_raw(raw_email)\n        return attachments"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef unassigned(data, as_json=False):\n\n    no_subusers = set()\n\n    if not isinstance(data, list):\n        return format_ret(no_subusers, as_json=as_json)\n\n    for current in data:\n        num_subusers = len(current[\"subusers\"])\n        if num_subusers == 0:\n            current_ip = current[\"ip\"]\n            no_subusers.add(current_ip)\n\n    ret_val = format_ret(no_subusers, as_json=as_json)\n    return ret_val", "response": "The unassigned API endpoint returns information about the IP addresses and usernames assigned to an IP - level object."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add_to(self, email):\n        if email.substitutions:\n            if isinstance(email.substitutions, list):\n                for substitution in email.substitutions:\n                    self.add_substitution(substitution)\n            else:\n                self.add_substitution(email.substitutions)\n        if email.subject:\n            if isinstance(email.subject, str):\n                self.subject = email.subject\n            else:\n                self.subject = email.subject.get()\n        self._tos.append(email.get())", "response": "Adds a single recipient to this Personalization."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add_substitution(self, substitution):\n        if isinstance(substitution, dict):\n            self._substitutions.append(substitution)\n        else:\n            self._substitutions.append(substitution.get())", "response": "Add a new Substitution to this Personalization."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get(self):\n        personalization = {}\n\n        for key in ['tos', 'ccs', 'bccs']:\n            value = getattr(self, key)\n            if value:\n                personalization[key[:-1]] = value\n\n        for key in ['subject', 'send_at', 'dynamic_template_data']:\n            value = getattr(self, key)\n            if value:\n                personalization[key] = value\n\n        for prop_name in ['headers', 'substitutions', 'custom_args']:\n            prop = getattr(self, prop_name)\n            if prop:\n                obj = {}\n                for key in prop:\n                    obj.update(key)\n                    personalization[prop_name] = obj\n\n        return personalization", "response": "Returns a JSON - ready representation of this Personalization."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a JSON - ready representation of this CustomArg.", "response": "def get(self):\n        \"\"\"\n        Get a JSON-ready representation of this CustomArg.\n\n        :returns: This CustomArg, ready for use in a request body.\n        :rtype: dict\n        \"\"\"\n        custom_arg = {}\n        if self.key is not None and self.value is not None:\n            custom_arg[self.key] = self.value\n        return custom_arg"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a JSON - ready representation of this Section.", "response": "def get(self):\n        \"\"\"\n        Get a JSON-ready representation of this Section.\n\n        :returns: This Section, ready for use in a request body.\n        :rtype: dict\n        \"\"\"\n        section = {}\n        if self.key is not None and self.value is not None:\n            section[self.key] = self.value\n        return section"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a JSON - ready representation of this ClickTracking.", "response": "def get(self):\n        \"\"\"\n        Get a JSON-ready representation of this ClickTracking.\n\n        :returns: This ClickTracking, ready for use in a request body.\n        :rtype: dict\n        \"\"\"\n        click_tracking = {}\n        if self.enable is not None:\n            click_tracking[\"enable\"] = self.enable\n\n        if self.enable_text is not None:\n            click_tracking[\"enable_text\"] = self.enable_text\n        return click_tracking"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget a JSON - ready representation of this SubscriptionTracking.", "response": "def get(self):\n        \"\"\"\n        Get a JSON-ready representation of this SubscriptionTracking.\n\n        :returns: This SubscriptionTracking, ready for use in a request body.\n        :rtype: dict\n        \"\"\"\n        subscription_tracking = {}\n        if self.enable is not None:\n            subscription_tracking[\"enable\"] = self.enable\n\n        if self.text is not None:\n            subscription_tracking[\"text\"] = self.text.get()\n\n        if self.html is not None:\n            subscription_tracking[\"html\"] = self.html.get()\n\n        if self.substitution_tag is not None:\n            subscription_tracking[\"substitution_tag\"] = \\\n                self.substitution_tag.get()\n        return subscription_tracking"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget a JSON - ready representation of this TrackingSettings.", "response": "def get(self):\n        \"\"\"\n        Get a JSON-ready representation of this TrackingSettings.\n\n        :returns: This TrackingSettings, ready for use in a request body.\n        :rtype: dict\n        \"\"\"\n        tracking_settings = {}\n        if self.click_tracking is not None:\n            tracking_settings[\"click_tracking\"] = self.click_tracking.get()\n        if self.open_tracking is not None:\n            tracking_settings[\"open_tracking\"] = self.open_tracking.get()\n        if self.subscription_tracking is not None:\n            tracking_settings[\n                \"subscription_tracking\"] = self.subscription_tracking.get()\n        if self.ganalytics is not None:\n            tracking_settings[\"ganalytics\"] = self.ganalytics.get()\n        return tracking_settings"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets a JSON - ready representation of this OpenTracking.", "response": "def get(self):\n        \"\"\"\n        Get a JSON-ready representation of this OpenTracking.\n\n        :returns: This OpenTracking, ready for use in a request body.\n        :rtype: dict\n        \"\"\"\n        open_tracking = {}\n        if self.enable is not None:\n            open_tracking[\"enable\"] = self.enable\n\n        if self.substitution_tag is not None:\n            open_tracking[\"substitution_tag\"] = self.substitution_tag.get()\n        return open_tracking"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get(self):\n        stats = {}\n        if self.start_date is not None:\n            stats[\"start_date\"] = self.start_date\n        if self.end_date is not None:\n            stats[\"end_date\"] = self.end_date\n        if self.aggregated_by is not None:\n            stats[\"aggregated_by\"] = self.aggregated_by\n        if self.sort_by_metric is not None:\n            stats[\"sort_by_metric\"] = self.sort_by_metric\n        if self.sort_by_direction is not None:\n            stats[\"sort_by_direction\"] = self.sort_by_direction\n        if self.limit is not None:\n            stats[\"limit\"] = self.limit\n        if self.offset is not None:\n            stats[\"offset\"] = self.offset\n        if self.categories is not None:\n            stats['categories'] = [category.get() for category in\n                                   self.categories]\n        return stats", "response": "Get the response stats dict from the object."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef file_content(self, value):\n        if isinstance(value, FileContent):\n            self._file_content = value\n        else:\n            self._file_content = FileContent(value)", "response": "Sets the file_content attribute of the object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset the file type of the content you are attaching.", "response": "def file_type(self, value):\n        \"\"\"The MIME type of the content you are attaching\n\n        :param file_type: The MIME type of the content you are attaching\n        :type file_type FileType, string, optional\n        \"\"\"\n        if isinstance(value, FileType):\n            self._file_type = value\n        else:\n            self._file_type = FileType(value)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets the content - disposition of the attachment.", "response": "def disposition(self, value):\n        \"\"\"The content-disposition of the attachment, specifying display style.\n\n        Specifies how you would like the attachment to be displayed.\n         - \"inline\" results in the attached file being displayed automatically\n            within the message.\n         - \"attachment\" results in the attached file requiring some action to\n            display (e.g. opening or downloading the file).\n        If unspecified, \"attachment\" is used. Must be one of the two choices.\n\n        :param disposition: The content-disposition of the attachment,\n                            specifying display style. Specifies how you would\n                            like the attachment to be displayed.\n                            - \"inline\" results in the attached file being\n                              displayed automatically within the message.\n                            - \"attachment\" results in the attached file\n                              requiring some action to display (e.g. opening\n                              or downloading the file).\n                            If unspecified, \"attachment\" is used. Must be one\n                            of the two choices.\n        :type disposition: Disposition, string, optional\n        \"\"\"\n        if isinstance(value, Disposition):\n            self._disposition = value\n        else:\n            self._disposition = Disposition(value)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the content id for the attachment.", "response": "def content_id(self, value):\n        \"\"\"The content id for the attachment.\n\n        This is used when the disposition is set to \"inline\" and the attachment\n        is an image, allowing the file to be displayed within the email body.\n\n        :param content_id: The content id for the attachment.\n                           This is used when the Disposition is set to \"inline\"\n                           and the attachment is an image, allowing the file to\n                           be displayed within the email body.\n        :type content_id: ContentId, string, optional\n        \"\"\"\n        if isinstance(value, ContentId):\n            self._content_id = value\n        else:\n            self._content_id = ContentId(value)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets a JSON - ready representation of this Attachment.", "response": "def get(self):\n        \"\"\"\n        Get a JSON-ready representation of this Attachment.\n\n        :returns: This Attachment, ready for use in a request body.\n        :rtype: dict\n        \"\"\"\n        attachment = {}\n        if self.file_content is not None:\n            attachment[\"content\"] = self.file_content.get()\n\n        if self.file_type is not None:\n            attachment[\"type\"] = self.file_type.get()\n\n        if self.file_name is not None:\n            attachment[\"filename\"] = self.file_name.get()\n\n        if self.disposition is not None:\n            attachment[\"disposition\"] = self.disposition.get()\n\n        if self.content_id is not None:\n            attachment[\"content_id\"] = self.content_id.get()\n        return attachment"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nexecutes computation of blobs on input eopatch", "response": "def execute(self, eopatch):\n        \"\"\" Execute computation of blobs on input eopatch\n\n        :param eopatch: Input eopatch\n        :type eopatch: eolearn.core.EOPatch\n        :return: EOPatch instance with new key holding the blob image.\n        :rtype: eolearn.core.EOPatch\n        \"\"\"\n        for feature_type, feature_name, new_feature_name in self.feature:\n            eopatch[feature_type][new_feature_name] = self._compute_blob(\n                eopatch[feature_type][feature_name].astype(np.float64)).astype(np.float32)\n\n        return eopatch"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _check_classifier(classifier):\r\n        predict = getattr(classifier, \"predict\", None)\r\n        if not callable(predict):\r\n            raise ValueError('Classifier does not have predict method!')\r\n\r\n        predict_proba = getattr(classifier, \"predict_proba\", None)\r\n        if not callable(predict_proba):\r\n            raise ValueError('Classifier does not have predict_proba method!')", "response": "Check if the classifier implements predict and predict_proba methods."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _check_image(self, X):\r\n\r\n        if (len(X.shape) < 3) or (len(X.shape) > 4):\r\n            raise ValueError('Input has to have shape [n_samples, n_pixels_y, n_pixels_x] '\r\n                             'or [n_samples, n_pixels_y, n_pixels_x, n_bands].')\r\n\r\n        self._samples = X.shape[0]\r\n        self._image_size = X.shape[1:3]\r\n\r\n        if (self._image_size[0] % self.receptive_field[0]) or (self._image_size[0] % self.receptive_field[0]):\r\n            raise ValueError('Image (%d,%d) and receptive fields (%d,%d) mismatch.\\n'\r\n                             'Resize your image to be divisible with receptive field.'\r\n                             % (self._image_size[0], self._image_size[0], self.receptive_field[0],\r\n                                self.receptive_field[1]))", "response": "Check the size of the image and check that it is compatible with the classifier s receptive field."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef image_predict(self, X):\r\n        self._check_image(X)\r\n\r\n        new_shape = (X.shape[0] * X.shape[1] * X.shape[2],)\r\n\r\n        if len(X.shape) == 4:\r\n            new_shape += (X.shape[3],)\r\n\r\n        pixels = X.reshape(new_shape)\r\n\r\n        predictions = self.classifier.predict(self._transform_input(pixels))\r\n\r\n        return predictions.reshape(X.shape[0], X.shape[1], X.shape[2])", "response": "Predicts class label for the entire image."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\npredict class probabilities for the entire image.", "response": "def image_predict_proba(self, X):\r\n        \"\"\"\r\n        Predicts class probabilities for the entire image.\r\n\r\n        Parameters:\r\n        -----------\r\n\r\n        X: array, shape = [n_samples, n_pixels_x, n_pixels_y, n_bands]\r\n            Array of training images\r\n\r\n        y: array, shape = [n_samples] or [n_samples, n_pixels_x, n_pixels_y, n_classes]\r\n            Target probabilities\r\n        \"\"\"\r\n        self._check_image(X)\r\n\r\n        new_shape = (X.shape[0] * X.shape[1] * X.shape[2],)\r\n\r\n        if len(X.shape) == 4:\r\n            new_shape += (X.shape[3],)\r\n\r\n        pixels = X.reshape(new_shape)\r\n\r\n        probabilities = self.classifier.predict_proba(self._transform_input(pixels))\r\n\r\n        return probabilities.reshape(X.shape[0], X.shape[1], X.shape[2],\r\n                                     probabilities.shape[1])"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _to_patches(self, X):\r\n\r\n        window = self.receptive_field\r\n        asteps = self.receptive_field\r\n\r\n        if len(X.shape) == 4:\r\n            window += (0,)\r\n            asteps += (1,)\r\n\r\n        image_view = rolling_window(X, window, asteps)\r\n\r\n        new_shape = image_view.shape\r\n\r\n        # this makes a copy of the array? can we do without reshaping?\r\n        image_view = image_view.reshape((new_shape[0] * new_shape[1] * new_shape[2],) + new_shape[3:])\r\n\r\n        if len(X.shape) == 4:\r\n            image_view = np.moveaxis(image_view, 1, -1)\r\n\r\n        return image_view, new_shape", "response": "Reshapes input to patches of the size of the classifier s receptive field. For example :\r\n\r\n           "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef image_predict(self, X):\r\n        self._check_image(X)\r\n\r\n        patches, patches_shape = self._to_patches(X)\r\n\r\n        predictions = self.classifier.predict(self._transform_input(patches))\r\n\r\n        image_predictions = predictions.reshape(patches_shape[0:3])\r\n\r\n        image_results = np.zeros((self._samples,) + self._image_size)\r\n\r\n        nx, ny = self.receptive_field\r\n        row_steps = self._image_size[0] // nx\r\n        col_steps = self._image_size[1] // ny\r\n\r\n        # how can this be optimised?\r\n        for i, j, k in itertools.product(range(row_steps), range(col_steps), range(self._samples)):\r\n            image_results[k, nx * i:nx * (i + 1), ny * j:ny * (j + 1)] = image_predictions[k, i, j]\r\n\r\n        return image_results", "response": "Predicts class label for the entire image."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef image_predict_proba(self, X):\r\n        self._check_image(X)\r\n\r\n        patches, patches_shape = self._to_patches(X)\r\n\r\n        probabilities = self.classifier.predict_proba(self._transform_input(patches))\r\n\r\n        image_probabilities = probabilities.reshape(patches_shape[0:3] + (probabilities.shape[1],))\r\n\r\n        image_results = np.zeros((self._samples,) + self._image_size + (probabilities.shape[1],))\r\n\r\n        nx, ny = self.receptive_field\r\n        row_steps = self._image_size[0] // nx\r\n        col_steps = self._image_size[1] // ny\r\n\r\n        # how can this be optimised?\r\n        for i, j, k in itertools.product(range(row_steps), range(col_steps), range(self._samples)):\r\n            image_results[k, nx * i:nx * (i + 1), ny * j:ny * (j + 1), :] = image_probabilities[k, i, j, :]\r\n\r\n        return image_results", "response": "Predicts class probabilities for the entire image."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _to_patches(self, X):\r\n\r\n        window = self.patch_size\r\n        asteps = self.patch_size\r\n\r\n        if len(X.shape) == 4:\r\n            window += (0,)\r\n            asteps += (1,)\r\n\r\n        image_view = rolling_window(X, window, asteps)\r\n\r\n        new_shape = image_view.shape\r\n\r\n        return image_view, new_shape", "response": "Reshapes input to patches of the size of the classifier s receptive field."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef image_predict(self, X):\r\n        self._check_image(X)\r\n\r\n        if self.mode == 'majority_class':\r\n            predictions = self.pixel_classifier.image_predict(X)\r\n\r\n        elif self.mode == 'mean_prob':\r\n            probabilities = self.image_predict_proba(X)\r\n            predictions = (probabilities[..., self.target] > self.target_threshold).astype(np.int)\r\n\r\n        patches, _ = self._to_patches(predictions)\r\n\r\n        row_steps = self._image_size[0] // self.patch_size[0]\r\n        col_steps = self._image_size[1] // self.patch_size[1]\r\n\r\n        # how can this be optimised?\r\n        for i, j, k in itertools.product(range(row_steps), range(col_steps), range(self._samples)):\r\n            patches[k, i, j] = self._target(patches[k, i, j])\r\n\r\n        return predictions", "response": "Predicts class label for the entire image."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef image_predict_proba(self, X):\r\n        self._check_image(X)\r\n\r\n        probabilities = self.pixel_classifier.image_predict_proba(X)\r\n\r\n        patches, _ = self._to_patches(probabilities)\r\n\r\n        row_steps = self._image_size[0] // self.patch_size[0]\r\n        col_steps = self._image_size[1] // self.patch_size[1]\r\n\r\n        ps = self.patch_size[0] * self.patch_size[1]\r\n\r\n        # how can this be optimised?\r\n        for i, j, k in itertools.product(range(row_steps), range(col_steps), range(self._samples)):\r\n            patches[k, i, j, 0] = np.sum(patches[k, i, j, 0]) / ps\r\n            patches[k, i, j, 1] = np.sum(patches[k, i, j, 1]) / ps\r\n\r\n        return probabilities", "response": "Predicts class probabilities for the entire image."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ntaking an eopatch and applies the classification mask to the eopatch.", "response": "def execute(self, eopatch):\r\n        \"\"\" Transforms [n, w, h, d] eopatch into a [n, w, h, 1] eopatch, adding it the classification mask.\r\n\r\n            :param eopatch: An input EOPatch\r\n            :type eopatch: EOPatch\r\n            :return: Outputs EOPatch with n classification masks appended to out_feature_type with out_feature_name key\r\n            :rtype: EOPatch\r\n        \"\"\"\r\n        in_type, in_name = next(self.input_feature(eopatch))\r\n        out_type, out_name = next(self.input_feature())\r\n\r\n        eopatch[out_type][out_name] = self.classifier.image_predict(eopatch[in_type][in_name])\r\n\r\n        return eopatch"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nparse the execution arguments provided by user and returns a list of EOWorkflow objects.", "response": "def _parse_execution_args(execution_args):\n        \"\"\" Parses execution arguments provided by user and raises an error if something is wrong\n        \"\"\"\n        if not isinstance(execution_args, (list, tuple)):\n            raise ValueError(\"Parameter 'execution_args' should be a list\")\n\n        return [EOWorkflow.parse_input_args(input_args) for input_args in execution_args]"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nrunning the executor with n workers.", "response": "def run(self, workers=1):\n        \"\"\" Runs the executor with n workers.\n\n        :param workers: Number of parallel processes used in the execution. Default is a single process. If set to\n            `None` the number of workers will be the number of processors of the system.\n        :type workers: int or None\n        \"\"\"\n        self.report_folder = self._get_report_folder()\n        if self.save_logs and not os.path.isdir(self.report_folder):\n            os.mkdir(self.report_folder)\n\n        execution_num = len(self.execution_args)\n        log_paths = [self._get_log_filename(idx) if self.save_logs else None\n                     for idx in range(execution_num)]\n\n        processing_args = [(self.workflow, init_args, log_path) for init_args, log_path in zip(self.execution_args,\n                                                                                               log_paths)]\n\n        with concurrent.futures.ProcessPoolExecutor(max_workers=workers) as executor:\n            self.execution_stats = list(tqdm(executor.map(self._execute_workflow, processing_args),\n                                             total=len(processing_args)))\n\n        self.execution_logs = [None] * execution_num\n        if self.save_logs:\n            for idx, log_path in enumerate(log_paths):\n                with open(log_path) as fin:\n                    self.execution_logs[idx] = fin.read()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _execute_workflow(cls, process_args):\n        workflow, input_args, log_path = process_args\n\n        if log_path:\n            logger = logging.getLogger()\n            logger.setLevel(logging.DEBUG)\n            handler = cls._get_log_handler(log_path)\n            logger.addHandler(handler)\n\n        stats = {'start_time': dt.datetime.now()}\n        try:\n            _ = workflow.execute(input_args, monitor=True)\n        except BaseException:\n            stats['error'] = traceback.format_exc()\n        stats['end_time'] = dt.datetime.now()\n\n        if log_path:\n            handler.close()\n            logger.removeHandler(handler)\n\n        return stats", "response": "Handles a single execution of a workflow\n           "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef make_report(self):\n        if self.execution_stats is None:\n            raise RuntimeError('Cannot produce a report without running the executor first, check EOExecutor.run '\n                               'method')\n\n        if os.environ.get('DISPLAY', '') == '':\n            LOGGER.info('No display found, using non-interactive Agg backend')\n            plt.switch_backend('Agg')\n\n        dependency_graph = self._create_dependency_graph()\n        task_descriptions = self._get_task_descriptions()\n\n        formatter = HtmlFormatter(linenos=True)\n        task_source = self._render_task_source(formatter)\n        execution_stats = self._render_execution_errors(formatter)\n\n        template = self._get_template()\n\n        html = template.render(dependency_graph=dependency_graph,\n                               task_descriptions=task_descriptions,\n                               task_source=task_source,\n                               execution_stats=execution_stats,\n                               execution_logs=self.execution_logs,\n                               code_css=formatter.get_style_defs())\n\n        if not os.path.isdir(self.report_folder):\n            os.mkdir(self.report_folder)\n\n        with open(self.get_report_filename(), 'w') as fout:\n            fout.write(html)", "response": "Makes a html report and saves it into the same folder where logs are stored."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nactions to be taken when an event is triggered.", "response": "def onscroll(self, event):\r\n        \"\"\"Action to be taken when an event is triggered.\r\n\r\n        Event is scroll of the mouse's wheel. This leads to changing the temporal frame displayed.\r\n\r\n        :param event: Scroll of mouse wheel\r\n        \"\"\"\r\n        if event.button == 'up':\r\n            self.ind = (self.ind + 1) % self.slices\r\n        else:\r\n            self.ind = (self.ind - 1) % self.slices\r\n        self.update()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef update(self):\r\n        if self.single_channel:\r\n            self.im.set_data(self.data[self.ind, :, :])\r\n        else:\r\n            self.im.set_data(self.data[self.ind, :, :, :])\r\n        self.ax.set_ylabel('time frame %s' % self.ind)\r\n        self.im.axes.figure.canvas.draw()", "response": "Updates image to be displayed with new time frame."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns array of data to be displayed and whether it is single channel or not.", "response": "def _get_data_to_display(self, eopatch):\r\n        \"\"\"Performs checks on dimensionality of data to makes it suitable for display.\r\n\r\n        :param eopatch: Input eopatch\r\n        :return: Array to display and whether it is single channel or not\r\n        \"\"\"\r\n        feature_type, feature_name = next(self.feature(eopatch))\r\n\r\n        image_seq = eopatch[feature_type][feature_name]\r\n        single_channel = False\r\n        if image_seq.ndim == 3:\r\n            # single channel\r\n            single_channel = True\r\n        elif image_seq.ndim == 4:\r\n            # If multi-channel make sure indexing is correct\r\n            n_channels = image_seq.shape[-1]\r\n            if n_channels == 1:\r\n                image_seq = np.squeeze(image_seq, axis=-1)\r\n                single_channel = True\r\n            elif n_channels == 3:\r\n                pass\r\n            else:\r\n                if (self.indices is not None) and ((len(self.indices) == 1) or (len(self.indices) == 3)):\r\n                    image_seq = image_seq[..., self.indices]\r\n                    if len(self.indices) == 1:\r\n                        image_seq = np.squeeze(image_seq, axis=-1)\r\n                        single_channel = True\r\n                else:\r\n                    raise ValueError(\"Specify valid indices for multi-channel EOPatch\")\r\n        else:\r\n            raise ValueError(\"Unsupported format for EOPatch\")\r\n        return image_seq, single_channel"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nshows data and scrolls through. Currently not working from Jupyter notebooks.", "response": "def execute(self, eopatch, title=None, colorbar=False):\r\n        \"\"\"Shows data and scrolls through. Currently not working from Jupyter notebooks.\r\n\r\n        :param eopatch: Image sequence to display. Can be single channel, RGB or multi-channel. If multi-channel,\r\n                        indices must be specified.\r\n        :type eopatch: numpy array\r\n        :param title: String to be displayed as title of the plot\r\n        :type title: string\r\n        :param colorbar: Whether to add colorbar to plot or not. Default is ``False``\r\n        :type colorbar: bool\r\n        :return: Same input eopatch\r\n        \"\"\"\r\n        image_seq, single_channel = self._get_data_to_display(eopatch)\r\n        # clip to positive values\r\n        if image_seq.dtype is np.float:\r\n            image_seq = np.clip(image_seq, 0, 1)\r\n        elif image_seq.dtype is np.int:\r\n            image_seq = np.clip(image_seq, 0, 255)\r\n        # Call IndexTracker and visualise time frames\r\n        fig, axis = plt.subplots(1, 1)\r\n        tracker = IndexTracker(axis, image_seq,\r\n                               single_channel=single_channel,\r\n                               msg=title,\r\n                               colorbar=colorbar)\r\n        fig.canvas.mpl_connect('scroll_event', tracker.onscroll)\r\n        plt.show()\r\n        return eopatch"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef execute(self, eopatch):\n        # pylint: disable=invalid-name\n        amax_ndvi, amin_ndvi = eopatch.data_timeless[self.argmax_ndvi], eopatch.data_timeless[self.argmin_ndvi]\n        amax_ndvi_slope, amin_ndvi_slope = eopatch.data_timeless[self.argmax_ndvi_slope], \\\n                                           eopatch.data_timeless[self.argmin_ndvi_slope]\n        amax_red = eopatch.data_timeless[self.argmax_red]\n\n        stf_idx = [amax_ndvi, amin_ndvi, amax_ndvi_slope, amin_ndvi_slope, amax_red]\n\n        bands = eopatch.data[self.data_feature][..., self.indices]\n\n        _, h, w, _ = bands.shape\n        hh, ww = np.ogrid[:h, :w]\n        stf = np.concatenate([bands[ii.squeeze(), hh, ww] for ii in stf_idx if ii is not None], axis=-1)\n\n        eopatch.data_timeless[self.feats_feature] = stf\n\n        return eopatch", "response": "Execute the spatio - temporal features on the input eopatch."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef execute(self, eopatch):\n        if self.mask_data:\n            valid_data_mask = eopatch.mask['VALID_DATA']\n        else:\n            valid_data_mask = eopatch.mask['IS_DATA']\n\n        if self.data_index is None:\n            data = eopatch.data[self.data_feature]\n        else:\n            data = eopatch.data[self.data_feature][..., self.data_index]\n\n        madata = np.ma.array(data,\n                             dtype=np.float32,\n                             mask=~valid_data_mask.astype(np.bool))\n\n        argmax_data = np.ma.MaskedArray.argmax(madata, axis=0)\n        argmin_data = np.ma.MaskedArray.argmin(madata, axis=0)\n\n        if argmax_data.ndim == 2:\n            argmax_data = argmax_data.reshape(argmax_data.shape + (1,))\n\n        if argmin_data.ndim == 2:\n            argmin_data = argmin_data.reshape(argmin_data.shape + (1,))\n\n        eopatch.data_timeless[self.amax_feature] = argmax_data\n        eopatch.data_timeless[self.amin_feature] = argmin_data\n\n        return eopatch", "response": "Compute argmax and argmin of specified data_feature and data_index."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nexecutes the NDVI slope computation on the eopatch.", "response": "def execute(self, eopatch):\n        \"\"\" Computation of NDVI slope using finite central differences\n\n        This implementation loops through every spatial location, considers the valid NDVI values and approximates their\n        first order derivative using central differences. The argument of min and max is added to the eopatch.\n\n        The NDVI slope at date t is comuted as $(NDVI_{t+1}-NDVI_{t-1})/(date_{t+1}-date_{t-1})$.\n\n        :param eopatch: Input eopatch\n        :return: eopatch with NDVI slope argmin/argmax features\n        \"\"\"\n        # pylint: disable=invalid-name\n        if self.mask_data:\n            valid_data_mask = eopatch.mask['VALID_DATA']\n        else:\n            valid_data_mask = eopatch.mask['IS_DATA']\n\n        ndvi = np.ma.array(eopatch.data[self.data_feature],\n                           dtype=np.float32,\n                           mask=~valid_data_mask.astype(np.bool))\n\n        all_dates = np.asarray([x.toordinal() for x in eopatch.timestamp])\n\n        if ndvi.ndim == 4:\n            h, w = ndvi.shape[1: 3]\n        else:\n            raise ValueError('{} feature has incorrect number of dimensions'.format(self.data_feature))\n\n        argmax_ndvi_slope, argmin_ndvi_slope = np.zeros((h, w, 1), dtype=np.uint8), np.zeros((h, w, 1), dtype=np.uint8)\n\n        for ih, iw in it.product(range(h), range(w)):\n\n            ndvi_curve = ndvi[:, ih, iw, :]\n            valid_idx = np.where(~ndvi.mask[:, ih, iw])[0]\n\n            ndvi_curve = ndvi_curve[valid_idx]\n            valid_dates = all_dates[valid_idx]\n\n            ndvi_slope = np.convolve(ndvi_curve.squeeze(), [1, 0, -1], 'valid') / np.convolve(valid_dates, [1, 0, -1],\n                                                                                              'valid')\n\n            # +1 to compensate for the 'valid' convolution which eliminates first and last\n            argmax_ndvi_slope[ih, iw] = valid_idx[np.argmax(ndvi_slope) + 1]\n            argmin_ndvi_slope[ih, iw] = valid_idx[np.argmin(ndvi_slope) + 1]\n\n            del ndvi_curve, valid_idx, valid_dates, ndvi_slope\n\n        eopatch.data_timeless[self.argmax_feature] = argmax_ndvi_slope\n        eopatch.data_timeless[self.argmin_feature] = argmin_ndvi_slope\n\n        return eopatch"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nmapping the binary class data to the scalar raster_value.", "response": "def _map_from_binaries(self, eopatch, dst_shape, request_data):\n        \"\"\"\n        Each request represents a binary class which will be mapped to the scalar `raster_value`\n        \"\"\"\n        if self.feature_name in eopatch[self.feature_type]:\n            raster = eopatch[self.feature_type][self.feature_name].squeeze()\n        else:\n            raster = np.ones(dst_shape, dtype=self.raster_dtype) * self.no_data_val\n\n        new_raster = self._reproject(eopatch, self._to_binary_mask(request_data))\n\n        # update raster\n        raster[new_raster != 0] = new_raster[new_raster != 0]\n\n        return raster"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nmaps from a multiclass to a real raster.", "response": "def _map_from_multiclass(self, eopatch, dst_shape, request_data):\n        \"\"\"\n        `raster_value` is a dictionary specifying the intensity values for each class and the corresponding label value.\n\n        A dictionary example for GLC30 LULC mapping is:\n        raster_value = {'no_data': (0,[0,0,0,0]),\n                        'cultivated land': (1,[193, 243, 249, 255]),\n                        'forest': (2,[73, 119, 20, 255]),\n                        'grassland': (3,[95, 208, 169, 255]),\n                        'schrubland': (4,[112, 179, 62, 255]),\n                        'water': (5,[154, 86, 1, 255]),\n                        'wetland': (6,[244, 206, 126, 255]),\n                        'thundra': (7,[50, 100, 100, 255]),\n                        'artificial surface': (8,[20, 47, 147, 255]),\n                        'bareland': (9,[202, 202, 202, 255]),\n                        'snow and ice': (10,[251, 237, 211, 255])}\n        \"\"\"\n        raster = np.ones(dst_shape, dtype=self.raster_dtype) * self.no_data_val\n\n        for key in self.raster_value.keys():\n            value, intensities = self.raster_value[key]\n            raster[np.mean(np.abs(request_data - intensities), axis=-1) < self.mean_abs_difference] = value\n\n        return self._reproject(eopatch, raster)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef execute(self, eopatch):\n        data_arr = eopatch[FeatureType.MASK]['IS_DATA']\n        _, height, width, _ = data_arr.shape\n\n        request = self._get_wms_request(eopatch.bbox, width, height)\n\n        request_data, = np.asarray(request.get_data())\n\n        if isinstance(self.raster_value, dict):\n            raster = self._map_from_multiclass(eopatch, (height, width), request_data)\n        elif isinstance(self.raster_value, (int, float)):\n            raster = self._map_from_binaries(eopatch, (height, width), request_data)\n        else:\n            raise ValueError(\"Unsupported raster value type\")\n\n        if self.feature_type is FeatureType.MASK_TIMELESS and raster.ndim == 2:\n            raster = raster[..., np.newaxis]\n\n        eopatch[self.feature_type][self.feature_name] = raster\n\n        return eopatch", "response": "Execute the WMS request and add requested feature to this EOPatch."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _get_parameter(self, name, eopatch):\n        if hasattr(self, name) and getattr(self, name) is not None:\n            return getattr(self, name)\n        if name == 'bbox' and eopatch.bbox:\n            return eopatch.bbox\n        if name in eopatch.meta_info:\n            return eopatch.meta_info[name]\n        if name == 'maxcc':\n            return 1.0\n        if name == 'time_difference':\n            return dt.timedelta(seconds=-1)\n        if name in ('size_x', 'size_y'):\n            return None\n\n        raise ValueError('Parameter {} was neither defined in initialization of {} nor is contained in '\n                         'EOPatch'.format(name, self.__class__.__name__))", "response": "Returns the value of the named parameter from the initialization parameters or from the EOPatch."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _prepare_request_data(self, eopatch, bbox, time_interval):\n\n        service_type = ServiceType(self._get_parameter('service_type', eopatch))\n        if time_interval is None:\n            time_interval = self._get_parameter('time_interval', eopatch)\n        if service_type is ServiceType.WMS:\n            size_x_name, size_y_name = 'width', 'height'\n        else:\n            size_x_name, size_y_name = 'resx', 'resy'\n        return {\n            'layer': self.layer,\n            'bbox': bbox if bbox is not None else self._get_parameter('bbox', eopatch),\n            'time': time_interval,\n            'time_difference': self._get_parameter('time_difference', eopatch),\n            'maxcc': self._get_parameter('maxcc', eopatch),\n            'image_format': self.image_format,\n            'custom_url_params': self.custom_url_params,\n            'data_source': self.data_source,\n            'instance_id': self.instance_id,\n            size_x_name: self._get_parameter('size_x', eopatch),\n            size_y_name: self._get_parameter('size_y', eopatch)\n        }, service_type", "response": "Prepare the data for a DataRequest."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _add_data(self, eopatch, data):\n        valid_mask = data[..., -1]\n        data = data[..., :-1]\n\n        if data.ndim == 3:\n            data = data.reshape(data.shape + (1,))\n        if not self.feature_type.is_time_dependent():\n            if data.shape[0] > 1:\n                raise ValueError('Cannot save time dependent data to time independent feature')\n            data = data.squeeze(axis=0)\n        if self.feature_type.is_discrete():\n            data = data.astype(np.int32)\n\n        eopatch[self.feature_type][self.feature_name] = data\n\n        mask_feature_type, mask_feature_name = next(self.valid_data_mask_feature())\n\n        max_value = self.image_format.get_expected_max_value()\n        valid_data = (valid_mask == max_value).astype(np.bool).reshape(valid_mask.shape + (1,))\n\n        if mask_feature_name not in eopatch[mask_feature_type]:\n            eopatch[mask_feature_type][mask_feature_name] = valid_data", "response": "Adds downloaded data to the EOPatch."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nadd any missing metadata info to the EOPatch.", "response": "def _add_meta_info(self, eopatch, request_params, service_type):\n        \"\"\" Adds any missing metadata info to EOPatch \"\"\"\n\n        for param, eoparam in zip(['time', 'time_difference', 'maxcc'], ['time_interval', 'time_difference', 'maxcc']):\n            if eoparam not in eopatch.meta_info:\n                eopatch.meta_info[eoparam] = request_params[param]\n\n        if 'service_type' not in eopatch.meta_info:\n            eopatch.meta_info['service_type'] = service_type.value\n\n        for param in ['size_x', 'size_y']:\n            if param not in eopatch.meta_info:\n                eopatch.meta_info[param] = getattr(self, param)\n\n        if eopatch.bbox is None:\n            eopatch.bbox = request_params['bbox']"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef execute(self, eopatch=None, bbox=None, time_interval=None):\n        if eopatch is None:\n            eopatch = EOPatch()\n\n        request_params, service_type = self._prepare_request_data(eopatch, bbox, time_interval)\n        request = {ServiceType.WMS: WmsRequest,\n                   ServiceType.WCS: WcsRequest}[service_type](**request_params)\n\n        request_dates = request.get_dates()\n\n        if not eopatch.timestamp:\n            eopatch.timestamp = request_dates\n\n        download_frames = None\n        if self.feature_type.is_time_dependent():\n            download_frames = get_common_timestamps(request_dates, eopatch.timestamp)\n\n        images = request.get_data(raise_download_errors=self.raise_download_errors, data_filter=download_frames)\n\n        if not self.raise_download_errors:\n            bad_data = [idx for idx, value in enumerate(images) if value is None]\n            for idx in reversed(bad_data):\n                LOGGER.warning('Data from %s could not be downloaded for %s!', str(request_dates[idx]), self.layer)\n                del images[idx]\n                del request_dates[idx]\n\n            for removed_frame in eopatch.consolidate_timestamps(request_dates):\n                LOGGER.warning('Removed data for frame %s from EOPatch '\n                               'due to unavailability of %s!', str(removed_frame), self.layer)\n\n        self._add_data(eopatch, np.asarray(images))\n        self._add_meta_info(eopatch, request_params, service_type)\n        return eopatch", "response": "Executes the request and returns the result of the request."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_s2_pixel_cloud_detector(threshold=0.4, average_over=4, dilation_size=2, all_bands=True):\n    return S2PixelCloudDetector(threshold=threshold,\n                                average_over=average_over,\n                                dilation_size=dilation_size,\n                                all_bands=all_bands)", "response": "Wrapper function for pixel - based S2 cloud detector"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _get_rescale_factors(self, reference_shape, meta_info):\n        # Figure out resampling size\n        height, width = reference_shape\n\n        service_type = ServiceType(meta_info['service_type'])\n        rescale = None\n        if service_type == ServiceType.WMS:\n\n            if (self.cm_size_x is None) and (self.cm_size_y is not None):\n                rescale = (self.cm_size_y / height, self.cm_size_y / height)\n            elif (self.cm_size_x is not None) and (self.cm_size_y is None):\n                rescale = (self.cm_size_x / width, self.cm_size_x / width)\n            else:\n                rescale = (self.cm_size_y / height, self.cm_size_x / width)\n\n        elif service_type == ServiceType.WCS:\n            # Case where only one resolution for cloud masks is specified in WCS\n            if self.cm_size_y is None:\n                self.cm_size_y = self.cm_size_x\n            elif self.cm_size_x is None:\n                self.cm_size_x = self.cm_size_y\n\n            hr_res_x, hr_res_y = int(meta_info['size_x'].strip('m')), int(meta_info['size_y'].strip('m'))\n            lr_res_x, lr_res_y = int(self.cm_size_x.strip('m')), int(self.cm_size_y.strip('m'))\n            rescale = (hr_res_y / lr_res_y, hr_res_x / lr_res_x)\n\n        return rescale", "response": "Compute the resampling factors for the array of high - resolution cloud masks and the size of the cloud masks."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _upsampling(lr_array, rescale, reference_shape, interp='linear'):\n        hr_shape = reference_shape + (1,)\n        lr_shape = lr_array.shape + (1,)\n\n        if rescale is None:\n            return lr_array.reshape(lr_shape)\n\n        out_array = scipy.ndimage.interpolation.zoom(lr_array.reshape(lr_shape),\n                                                     (1.0,) + tuple(1 / x for x in rescale) + (1.0,),\n                                                     output=lr_array.dtype, order=INTERP_METHODS.index(interp),\n                                                     mode='nearest')\n\n        # Padding and cropping might be needed to get to the reference shape\n        out_shape = out_array.shape\n        padding = tuple((0, np.max((h-o, 0))) for h, o in zip(hr_shape, out_shape))\n        hr_array = np.pad(out_array, padding, 'edge')\n        hr_array = hr_array[:, :hr_shape[1], :hr_shape[2], :]\n\n        return hr_array", "response": "Upsample the low - resolution array to the original high - resolution grid."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nmake OGC request to create input for cloud detector classifier.", "response": "def _make_request(self, bbox, meta_info, timestamps):\n        \"\"\" Make OGC request to create input for cloud detector classifier\n\n        :param bbox: Bounding box\n        :param meta_info: Meta-info dictionary of input eopatch\n        :return: Requested data\n        \"\"\"\n        service_type = ServiceType(meta_info['service_type'])\n\n        # Raise error if resolutions are not specified\n        if self.cm_size_x is None and self.cm_size_y is None:\n            raise ValueError(\"Specify size_x and size_y for data request\")\n\n        # If WCS request, make sure both resolutions are set\n        if service_type == ServiceType.WCS:\n            if self.cm_size_y is None:\n                self.cm_size_y = self.cm_size_x\n            elif self.cm_size_x is None:\n                self.cm_size_x = self.cm_size_y\n\n        custom_url_params = {CustomUrlParam.SHOWLOGO: False,\n                             CustomUrlParam.TRANSPARENT: False,\n                             CustomUrlParam.EVALSCRIPT: self.model_evalscript}\n\n        request = {ServiceType.WMS: self._get_wms_request,\n                   ServiceType.WCS: self._get_wcs_request}[service_type](bbox,\n                                                                         meta_info['time_interval'],\n                                                                         self.cm_size_x,\n                                                                         self.cm_size_y,\n                                                                         meta_info['maxcc'],\n                                                                         meta_info['time_difference'],\n                                                                         custom_url_params)\n\n        request_dates = request.get_dates()\n        download_frames = get_common_timestamps(request_dates, timestamps)\n\n        request_return = request.get_data(raise_download_errors=False, data_filter=download_frames)\n        bad_data = [idx for idx, value in enumerate(request_return) if value is None]\n        for idx in reversed(sorted(bad_data)):\n            LOGGER.warning('Data from %s could not be downloaded for %s!', str(request_dates[idx]), self.data_feature)\n            del request_return[idx]\n            del request_dates[idx]\n\n        return np.asarray(request_return), request_dates"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef execute(self, eopatch):\n        # Downsample or make request\n        if not eopatch.data:\n            raise ValueError('EOPatch must contain some data feature')\n        if self.data_feature in eopatch.data:\n            new_data, rescale = self._downscaling(eopatch.data[self.data_feature], eopatch.meta_info)\n            reference_shape = eopatch.data[self.data_feature].shape[:3]\n        else:\n            new_data, new_dates = self._make_request(eopatch.bbox, eopatch.meta_info, eopatch.timestamp)\n            removed_frames = eopatch.consolidate_timestamps(new_dates)\n            for rm_frame in removed_frames:\n                LOGGER.warning('Removed data for frame %s from '\n                               'eopatch due to unavailability of %s!', str(rm_frame), self.data_feature)\n\n            # Get reference shape from first item in data dictionary\n            reference_shape = next(iter(eopatch.data.values())).shape[:3]\n            rescale = self._get_rescale_factors(reference_shape[1:3], eopatch.meta_info)\n\n        clf_probs_lr = self.classifier.get_cloud_probability_maps(new_data)\n        clf_mask_lr = self.classifier.get_mask_from_prob(clf_probs_lr)\n\n        # Add cloud mask as a feature to EOPatch\n        clf_mask_hr = self._upsampling(clf_mask_lr, rescale, reference_shape, interp='nearest')\n        eopatch.mask[self.cm_feature] = clf_mask_hr.astype(np.bool)\n\n        # If the feature name for cloud probability maps is specified, add as feature\n        if self.cprobs_feature is not None:\n            clf_probs_hr = self._upsampling(clf_probs_lr, rescale, reference_shape, interp='linear')\n            eopatch.data[self.cprobs_feature] = clf_probs_hr.astype(np.float32)\n\n        return eopatch", "response": "Execute the cloud binary mask and cloud probability map transformation on the input eopatch."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nexecute the given eopatches and returns the result.", "response": "def _execute_handling(self, *eopatches, **kwargs):\r\n        \"\"\" Handles measuring execution time and error propagation\r\n        \"\"\"\r\n        self.private_task_config.start_time = datetime.datetime.now()\r\n\r\n        caught_exception = None\r\n        try:\r\n            return_value = self.execute(*eopatches, **kwargs)\r\n        except BaseException as exception:\r\n            caught_exception = exception, sys.exc_info()[2]\r\n\r\n        if caught_exception is not None:  # Exception is not raised in except statement to prevent duplicated traceback\r\n            exception, traceback = caught_exception\r\n            raise type(exception)('During execution of task {}: {}'.format(self.__class__.__name__,\r\n                                                                           exception)).with_traceback(traceback)\r\n\r\n        self.private_task_config.end_time = datetime.datetime.now()\r\n        return return_value"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nparsing a list of features.", "response": "def _parse_features(features, new_names=False, rename_function=None, default_feature_type=None,\r\n                        allowed_feature_types=None):\r\n        \"\"\" See eolearn.core.utilities.FeatureParser class.\r\n        \"\"\"\r\n        return FeatureParser(features, new_names=new_names, rename_function=rename_function,\r\n                             default_feature_type=default_feature_type, allowed_feature_types=allowed_feature_types)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nfunctioning which will process README. md file and divide it into INTRO. md and INSTALL. md which will be used in documentation", "response": "def process_readme():\n    \"\"\" Function which will process README.md file and divide it into INTRO.md and INSTALL.md, which will be used in\n    documentation\n    \"\"\"\n    with open('../../README.md', 'r') as file:\n        readme = file.read()\n\n    readme = readme.replace('# eo-learn', '# Introduction').replace('docs/source/', '')\n    readme = readme.replace('**`', '**').replace('`**', '**')\n\n    chapters = [[]]\n    for line in readme.split('\\n'):\n        if line.strip().startswith('## '):\n            chapters.append([])\n        if line.startswith('<img'):\n            line = '<p></p>'\n\n        chapters[-1].append(line)\n\n    chapters = ['\\n'.join(chapter) for chapter in chapters]\n\n    intro = '\\n'.join([chapter for chapter in chapters if not (chapter.startswith('## Install') or\n                                                               chapter.startswith('## Documentation'))])\n    install = '\\n'.join([chapter for chapter in chapters if chapter.startswith('## Install')])\n\n    with open(os.path.join(MARKDOWNS_FOLDER, 'INTRO.md'), 'w') as file:\n        file.write(intro)\n    with open(os.path.join(MARKDOWNS_FOLDER, 'INSTALL.md'), 'w') as file:\n        file.write(install)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_common_timestamps(source, target):\r\n    remove_from_source = set(source).difference(target)\r\n    remove_from_source_idxs = [source.index(rm_date) for rm_date in remove_from_source]\r\n    return [idx for idx, _ in enumerate(source) if idx not in remove_from_source_idxs]", "response": "Return indices of timestamps from source that are also found in target."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncomparing two lists or tuples using the deep_eq method.", "response": "def deep_eq(fst_obj, snd_obj):\r\n    \"\"\"Compares whether fst_obj and snd_obj are deeply equal.\r\n\r\n    In case when both fst_obj and snd_obj are of type np.ndarray or either np.memmap, they are compared using\r\n    np.array_equal(fst_obj, snd_obj). Otherwise, when they are lists or tuples, they are compared for length and then\r\n    deep_eq is applied component-wise. When they are dict, they are compared for key set equality, and then deep_eq is\r\n    applied value-wise. For all other data types that are not list, tuple, dict, or np.ndarray, the method falls back\r\n    to the __eq__ method.\r\n\r\n    Because np.ndarray is not a hashable object, it is impossible to form a set of numpy arrays, hence deep_eq works\r\n    correctly.\r\n\r\n    :param fst_obj: First object compared\r\n    :param snd_obj: Second object compared\r\n    :return: `True` if objects are deeply equal, `False` otherwise\r\n    \"\"\"\r\n    # pylint: disable=too-many-return-statements\r\n    if isinstance(fst_obj, (np.ndarray, np.memmap)):\r\n        if not isinstance(snd_obj, (np.ndarray, np.memmap)):\r\n            return False\r\n\r\n        if fst_obj.dtype != snd_obj.dtype:\r\n            return False\r\n\r\n        fst_nan_mask = np.isnan(fst_obj)\r\n        snd_nan_mask = np.isnan(snd_obj)\r\n\r\n        return np.array_equal(fst_obj[~fst_nan_mask], snd_obj[~snd_nan_mask]) and \\\r\n            np.array_equal(fst_nan_mask, snd_nan_mask)\r\n\r\n    if not isinstance(fst_obj, type(snd_obj)):\r\n        return False\r\n\r\n    if isinstance(fst_obj, np.ndarray):\r\n        if fst_obj.dtype != snd_obj.dtype:\r\n            return False\r\n        fst_nan_mask = np.isnan(fst_obj)\r\n        snd_nan_mask = np.isnan(snd_obj)\r\n        return np.array_equal(fst_obj[~fst_nan_mask], snd_obj[~snd_nan_mask]) and \\\r\n            np.array_equal(fst_nan_mask, snd_nan_mask)\r\n\r\n    if isinstance(fst_obj, (list, tuple)):\r\n        if len(fst_obj) != len(snd_obj):\r\n            return False\r\n\r\n        for element_fst, element_snd in zip(fst_obj, snd_obj):\r\n            if not deep_eq(element_fst, element_snd):\r\n                return False\r\n        return True\r\n\r\n    if isinstance(fst_obj, dict):\r\n        if fst_obj.keys() != snd_obj.keys():\r\n            return False\r\n\r\n        for key in fst_obj:\r\n            if not deep_eq(fst_obj[key], snd_obj[key]):\r\n                return False\r\n        return True\r\n\r\n    return fst_obj == snd_obj"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef negate_mask(mask):\r\n    res = np.ones(mask.shape, dtype=np.int8)\r\n    res[mask > 0] = 0\r\n\r\n    return res", "response": "Returns the negated mask."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nfunctions pads an image of shape (rows, columns, channels) with zeros. It pads an image so that the shape becomes (rows + padded_rows, columns + padded_columns, channels), where padded_rows = (int(rows/multiple_of[0]) + 1) * multiple_of[0] - rows Same rule is applied to columns. :type X: array of shape (rows, columns, channels) or (rows, columns) :param multiple_of: make X' rows and columns multiple of this tuple :type multiple_of: tuple (rows, columns) :param up_down_rule: Add padded rows evenly to the top/bottom of the image, or up (top) / down (bottom) only :type up_down_rule: up_down_rule: string, (even, up, down) :param up_down_rule: Add padded columns evenly to the left/right of the image, or left / right only :type up_down_rule: up_down_rule: string, (even, left, right) :param pad_value: Value to be assigned to padded rows and columns :type pad_value: int", "response": "def constant_pad(X, multiple_of, up_down_rule='even', left_right_rule='even', pad_value=0):\r\n    \"\"\"Function pads an image of shape (rows, columns, channels) with zeros.\r\n\r\n    It pads an image so that the shape becomes (rows + padded_rows, columns + padded_columns, channels), where\r\n    padded_rows = (int(rows/multiple_of[0]) + 1) * multiple_of[0] - rows\r\n\r\n    Same rule is applied to columns.\r\n\r\n    :type X: array of shape (rows, columns, channels) or (rows, columns)\r\n    :param multiple_of: make X' rows and columns multiple of this tuple\r\n    :type multiple_of: tuple (rows, columns)\r\n    :param up_down_rule: Add padded rows evenly to the top/bottom of the image, or up (top) / down (bottom) only\r\n    :type up_down_rule: up_down_rule: string, (even, up, down)\r\n    :param up_down_rule: Add padded columns evenly to the left/right of the image, or left / right only\r\n    :type up_down_rule: up_down_rule: string, (even, left, right)\r\n    :param pad_value: Value to be assigned to padded rows and columns\r\n    :type pad_value: int\r\n    \"\"\"\r\n    # pylint: disable=invalid-name\r\n    shape = X.shape\r\n\r\n    row_padding, col_padding = 0, 0\r\n\r\n    if shape[0] % multiple_of[0]:\r\n        row_padding = (int(shape[0] / multiple_of[0]) + 1) * multiple_of[0] - shape[0]\r\n\r\n    if shape[1] % multiple_of[1]:\r\n        col_padding = (int(shape[1] / multiple_of[1]) + 1) * multiple_of[1] - shape[1]\r\n\r\n    row_padding_up, row_padding_down, col_padding_left, col_padding_right = 0, 0, 0, 0\r\n\r\n    if row_padding > 0:\r\n        if up_down_rule == 'up':\r\n            row_padding_up = row_padding\r\n        elif up_down_rule == 'down':\r\n            row_padding_down = row_padding\r\n        elif up_down_rule == 'even':\r\n            row_padding_up = int(row_padding / 2)\r\n            row_padding_down = row_padding_up + (row_padding % 2)\r\n        else:\r\n            raise ValueError('Padding rule for rows not supported. Choose beteen even, down or up!')\r\n\r\n    if col_padding > 0:\r\n        if left_right_rule == 'left':\r\n            col_padding_left = col_padding\r\n        elif left_right_rule == 'right':\r\n            col_padding_right = col_padding\r\n        elif left_right_rule == 'even':\r\n            col_padding_left = int(col_padding / 2)\r\n            col_padding_right = col_padding_left + (col_padding % 2)\r\n        else:\r\n            raise ValueError('Padding rule for columns not supported. Choose beteen even, left or right!')\r\n\r\n    return np.lib.pad(X, ((row_padding_up, row_padding_down), (col_padding_left, col_padding_right)),\r\n                      'constant', constant_values=((pad_value, pad_value), (pad_value, pad_value)))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ntaking a collection of features structured in a few ways and parses them into one way.", "response": "def _parse_features(features, new_names):\r\n        \"\"\"Takes a collection of features structured in a various ways and parses them into one way.\r\n\r\n        If input format is not recognized it raises an error.\r\n\r\n        :return: A collection of features\r\n        :rtype: collections.OrderedDict(FeatureType: collections.OrderedDict(str: str or Ellipsis) or Ellipsis)\r\n        :raises: ValueError\r\n        \"\"\"\r\n        if isinstance(features, dict):\r\n            return FeatureParser._parse_dict(features, new_names)\r\n\r\n        if isinstance(features, list):\r\n            return FeatureParser._parse_list(features, new_names)\r\n\r\n        if isinstance(features, tuple):\r\n            return FeatureParser._parse_tuple(features, new_names)\r\n\r\n        if features is ...:\r\n            return OrderedDict([(feature_type, ...) for feature_type in FeatureType])\r\n\r\n        if isinstance(features, FeatureType):\r\n            return OrderedDict([(features, ...)])\r\n\r\n        if isinstance(features, str):\r\n            return OrderedDict([(None, OrderedDict([(features, ...)]))])\r\n\r\n        raise ValueError('Unknown format of input features: {}'.format(features))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _parse_dict(features, new_names):\r\n        feature_collection = OrderedDict()\r\n        for feature_type, feature_names in features.items():\r\n            try:\r\n                feature_type = FeatureType(feature_type)\r\n            except ValueError:\r\n                ValueError('Failed to parse {}, keys of the dictionary have to be instances '\r\n                           'of {}'.format(features, FeatureType.__name__))\r\n\r\n            feature_collection[feature_type] = feature_collection.get(feature_type, OrderedDict())\r\n\r\n            if feature_names is ...:\r\n                feature_collection[feature_type] = ...\r\n\r\n            if feature_type.has_dict() and feature_collection[feature_type] is not ...:\r\n                feature_collection[feature_type].update(FeatureParser._parse_feature_names(feature_names, new_names))\r\n\r\n        return feature_collection", "response": "Helping function of _parse_features that parses a list of features."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nhelp function of _parse_features that parses a list of features.", "response": "def _parse_list(features, new_names):\r\n        \"\"\"Helping function of `_parse_features` that parses a list.\"\"\"\r\n        feature_collection = OrderedDict()\r\n        for feature in features:\r\n            if isinstance(feature, FeatureType):\r\n                feature_collection[feature] = ...\r\n\r\n            elif isinstance(feature, (tuple, list)):\r\n                for feature_type, feature_dict in FeatureParser._parse_tuple(feature, new_names).items():\r\n                    feature_collection[feature_type] = feature_collection.get(feature_type, OrderedDict())\r\n\r\n                    if feature_dict is ...:\r\n                        feature_collection[feature_type] = ...\r\n\r\n                    if feature_collection[feature_type] is not ...:\r\n                        feature_collection[feature_type].update(feature_dict)\r\n            else:\r\n                raise ValueError('Failed to parse {}, expected a tuple'.format(feature))\r\n        return feature_collection"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _parse_tuple(features, new_names):\r\n        name_idx = 1\r\n        try:\r\n            feature_type = FeatureType(features[0])\r\n        except ValueError:\r\n            feature_type = None\r\n            name_idx = 0\r\n\r\n        if feature_type and not feature_type.has_dict():\r\n            return OrderedDict([(feature_type, ...)])\r\n        return OrderedDict([(feature_type, FeatureParser._parse_names_tuple(features[name_idx:], new_names))])", "response": "Helping function of _parse_features that parses a tuple."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nhelp function of _parse_features that parses a collection of feature names.", "response": "def _parse_feature_names(feature_names, new_names):\r\n        \"\"\"Helping function of `_parse_features` that parses a collection of feature names.\"\"\"\r\n        if isinstance(feature_names, set):\r\n            return FeatureParser._parse_names_set(feature_names)\r\n\r\n        if isinstance(feature_names, dict):\r\n            return FeatureParser._parse_names_dict(feature_names)\r\n\r\n        if isinstance(feature_names, (tuple, list)):\r\n            return FeatureParser._parse_names_tuple(feature_names, new_names)\r\n\r\n        raise ValueError('Failed to parse {}, expected dictionary, set or tuple'.format(feature_names))"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nhelps function of _parse_feature_names that parses a set of feature names.", "response": "def _parse_names_set(feature_names):\r\n        \"\"\"Helping function of `_parse_feature_names` that parses a set of feature names.\"\"\"\r\n        feature_collection = OrderedDict()\r\n        for feature_name in feature_names:\r\n            if isinstance(feature_name, str):\r\n                feature_collection[feature_name] = ...\r\n            else:\r\n                raise ValueError('Failed to parse {}, expected string'.format(feature_name))\r\n        return feature_collection"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nhelps function of _parse_feature_names that parses a dictionary of feature names.", "response": "def _parse_names_dict(feature_names):\r\n        \"\"\"Helping function of `_parse_feature_names` that parses a dictionary of feature names.\"\"\"\r\n        feature_collection = OrderedDict()\r\n        for feature_name, new_feature_name in feature_names.items():\r\n            if isinstance(feature_name, str) and (isinstance(new_feature_name, str) or\r\n                                                  new_feature_name is ...):\r\n                feature_collection[feature_name] = new_feature_name\r\n            else:\r\n                if not isinstance(feature_name, str):\r\n                    raise ValueError('Failed to parse {}, expected string'.format(feature_name))\r\n                else:\r\n                    raise ValueError('Failed to parse {}, expected string or Ellipsis'.format(new_feature_name))\r\n        return feature_collection"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _parse_names_tuple(feature_names, new_names):\r\n        for feature in feature_names:\r\n            if not isinstance(feature, str) and feature is not ...:\r\n                raise ValueError('Failed to parse {}, expected a string'.format(feature))\r\n\r\n        if feature_names[0] is ...:\r\n            return ...\r\n\r\n        if new_names:\r\n            if len(feature_names) == 1:\r\n                return OrderedDict([(feature_names[0], ...)])\r\n            if len(feature_names) == 2:\r\n                return OrderedDict([(feature_names[0], feature_names[1])])\r\n            raise ValueError(\"Failed to parse {}, it should contain at most two strings\".format(feature_names))\r\n\r\n        if ... in feature_names:\r\n            return ...\r\n        return OrderedDict([(feature_name, ...) for feature_name in feature_names])", "response": "Helping function of _parse_feature_names that parses a tuple or a list of feature names."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nchecking that the feature types are a subset of the allowed feature types.", "response": "def _check_feature_types(self):\r\n        \"\"\" Checks that feature types are a subset of allowed feature types. (`None` is handled\r\n\r\n        :raises: ValueError\r\n        \"\"\"\r\n        if self.default_feature_type is not None and self.default_feature_type not in self.allowed_feature_types:\r\n            raise ValueError('Default feature type parameter must be one of the allowed feature types')\r\n\r\n        for feature_type in self.feature_collection:\r\n            if feature_type is not None and feature_type not in self.allowed_feature_types:\r\n                raise ValueError('Feature type has to be one of {}, but {} found'.format(self.allowed_feature_types,\r\n                                                                                         feature_type))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _find_feature_type(self, feature_name, eopatch):\r\n        for feature_type in self.allowed_feature_types:\r\n            if feature_type.has_dict() and feature_name in eopatch[feature_type]:\r\n                return feature_type\r\n        return None", "response": "Finds the feature type for which the given feature name exists in the given EOPatch. Returns None if no such feature type exists."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _return_feature(self, feature_type, feature_name, new_feature_name=...):\r\n        if self.new_names:\r\n            return feature_type, feature_name, (self.rename_function(feature_name) if new_feature_name is ... else\r\n                                                new_feature_name)\r\n        return feature_type, feature_name", "response": "Returns the feature type and name for a new feature."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nparse dependencies and adds names of task_names.", "response": "def _parse_dependencies(dependencies, task_names):\r\n        \"\"\"Parses dependencies and adds names of task_names.\r\n\r\n        :param dependencies: Input of dependency parameter\r\n        :type dependencies: list(tuple or Dependency)\r\n        :param task_names: Human-readable names of tasks\r\n        :type task_names: dict(EOTask: str) or None\r\n        :return: List of dependencies\r\n        :rtype: list(Dependency)\r\n        \"\"\"\r\n        parsed_dependencies = [dep if isinstance(dep, Dependency) else Dependency(*dep) for dep in dependencies]\r\n        for dep in parsed_dependencies:\r\n            if task_names and dep.task in task_names:\r\n                dep.set_name(task_names[dep.task])\r\n        return parsed_dependencies"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _set_task_uuid(self, dependencies):\r\n        uuid_dict = {}\r\n        for dep in dependencies:\r\n            task = dep.task\r\n            if task.private_task_config.uuid in uuid_dict:\r\n                raise ValueError('EOWorkflow cannot execute the same instance of EOTask multiple times')\r\n\r\n            task.private_task_config.uuid = self.id_gen.next()\r\n            uuid_dict[task.private_task_config.uuid] = dep\r\n\r\n        return uuid_dict", "response": "Adds universally unique user ids to each task of the workflow."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates a directed graph from the given list of Dependency objects", "response": "def create_dag(self, dependencies):\r\n        \"\"\"Creates a directed graph from dependencies.\r\n\r\n        :param dependencies: A list of Dependency objects\r\n        :type dependencies: list(Dependency)\r\n        :return: A directed graph of the workflow\r\n        :rtype: DirectedGraph\r\n        \"\"\"\r\n        dag = DirectedGraph()\r\n        for dep in dependencies:\r\n            for vertex in dep.inputs:\r\n                task_uuid = vertex.private_task_config.uuid\r\n                if task_uuid not in self.uuid_dict:\r\n                    raise ValueError('Task {}, which is an input of a task {}, is not part of the defined '\r\n                                     'workflow'.format(vertex.__class__.__name__, dep.name))\r\n                dag.add_edge(self.uuid_dict[task_uuid], dep)\r\n            if not dep.inputs:\r\n                dag.add_vertex(dep)\r\n        return dag"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _schedule_dependencies(dag):\r\n        in_degrees = dict(dag.get_indegrees())\r\n\r\n        independent_vertices = collections.deque([vertex for vertex in dag if dag.get_indegree(vertex) == 0])\r\n        topological_order = []\r\n        while independent_vertices:\r\n            v_vertex = independent_vertices.popleft()\r\n            topological_order.append(v_vertex)\r\n\r\n            for u_vertex in dag[v_vertex]:\r\n                in_degrees[u_vertex] -= 1\r\n                if in_degrees[u_vertex] == 0:\r\n                    independent_vertices.append(u_vertex)\r\n\r\n        if len(topological_order) != len(dag):\r\n            raise CyclicDependencyError('Tasks do not form an acyclic graph')\r\n\r\n        return topological_order", "response": "Returns a list of dependencies that are in the topologically ordered order of the tasks in the dag."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef make_linear_workflow(*tasks, **kwargs):\r\n        warnings.warn(\"Method 'make_linear_workflow' will soon be removed. Use LinearWorkflow class instead\",\r\n                      DeprecationWarning, stacklevel=2)\r\n\r\n        return LinearWorkflow(*tasks, **kwargs)", "response": "Factory method for creating linear workflows."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nexecutes the workflow. :param input_args: External input arguments to the workflow. They have to be in a form of a dictionary where each key is an EOTask used in the workflow and each value is a dictionary or a tuple of arguments. :type input_args: dict(EOTask: dict(str: object) or tuple(object)) :param monitor: If True workflow execution will be monitored :type monitor: bool :return: An immutable mapping containing results of terminal tasks :rtype: WorkflowResults", "response": "def execute(self, input_args=None, monitor=False):\r\n        \"\"\"Executes the workflow.\r\n\r\n        :param input_args: External input arguments to the workflow. They have to be in a form of a dictionary where\r\n            each key is an EOTask used in the workflow and each value is a dictionary or a tuple of arguments.\r\n        :type input_args: dict(EOTask: dict(str: object) or tuple(object))\r\n        :param monitor: If True workflow execution will be monitored\r\n        :type monitor: bool\r\n        :return: An immutable mapping containing results of terminal tasks\r\n        :rtype: WorkflowResults\r\n        \"\"\"\r\n        out_degs = dict(self.dag.get_outdegrees())\r\n\r\n        input_args = self.parse_input_args(input_args)\r\n\r\n        _, intermediate_results = self._execute_tasks(input_args=input_args, out_degs=out_degs, monitor=monitor)\r\n\r\n        return WorkflowResults(intermediate_results)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef parse_input_args(input_args):\r\n        input_args = input_args if input_args else {}\r\n        for task, args in input_args.items():\r\n            if not isinstance(task, EOTask):\r\n                raise ValueError('Invalid input argument {}, should be an instance of EOTask'.format(task))\r\n\r\n            if not isinstance(args, (tuple, dict)):\r\n                raise ValueError('Execution input arguments of each task should be a dictionary or a tuple, for task '\r\n                                 '{} got arguments of type {}'.format(task.__class__.__name__, type(args)))\r\n\r\n        return input_args", "response": "Parses input arguments provided by user and raises an error if something is wrong."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nexecuting all the tasks in the predetermined order.", "response": "def _execute_tasks(self, *, input_args, out_degs, monitor):\r\n        \"\"\"Executes tasks comprising the workflow in the predetermined order.\r\n\r\n        :param input_args: External input arguments to the workflow.\r\n        :type input_args: Dict\r\n        :param out_degs: Dictionary mapping vertices (task IDs) to their out-degrees. (The out-degree equals the number\r\n        of tasks that depend on this task.)\r\n        :type out_degs: Dict\r\n        :return: An immutable mapping containing results of terminal tasks\r\n        :rtype: WorkflowResults\r\n        \"\"\"\r\n        done_tasks = set()\r\n\r\n        intermediate_results = {}\r\n\r\n        for dep in self.ordered_dependencies:\r\n            result = self._execute_task(dependency=dep,\r\n                                        input_args=input_args,\r\n                                        intermediate_results=intermediate_results,\r\n                                        monitor=monitor)\r\n\r\n            intermediate_results[dep] = result\r\n\r\n            self._relax_dependencies(dependency=dep,\r\n                                     out_degrees=out_degs,\r\n                                     intermediate_results=intermediate_results)\r\n\r\n        return done_tasks, intermediate_results"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _execute_task(self, *, dependency, input_args, intermediate_results, monitor):\r\n        task = dependency.task\r\n        inputs = tuple(intermediate_results[self.uuid_dict[input_task.private_task_config.uuid]]\r\n                       for input_task in dependency.inputs)\r\n\r\n        kw_inputs = input_args.get(task, {})\r\n        if isinstance(kw_inputs, tuple):\r\n            inputs += kw_inputs\r\n            kw_inputs = {}\r\n\r\n        LOGGER.debug(\"Computing %s(*%s, **%s)\", str(task), str(inputs), str(kw_inputs))\r\n        return task(*inputs, **kw_inputs, monitor=monitor)", "response": "Executes a task of the workflow."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nrelax the dependencies incurred by the task_id.", "response": "def _relax_dependencies(self, *, dependency, out_degrees, intermediate_results):\r\n        \"\"\"\r\n        Relaxes dependencies incurred by ``task_id``. After the task with ID ``task_id`` has been successfully\r\n        executed, all the tasks it depended on are upadted. If ``task_id`` was the last remaining dependency of a task\r\n        ``t`` then ``t``'s result is removed from memory and, depending on ``remove_intermediate``, from disk.\r\n\r\n        :param dependency: A workflow dependecy\r\n        :type dependency: Dependency\r\n        :param out_degrees: Out-degrees of tasks\r\n        :type out_degrees: dict\r\n        :param intermediate_results: The dictionary containing the intermediate results (needed by tasks that have yet\r\n        to be executed) of the already-executed tasks\r\n        :type intermediate_results: dict\r\n        \"\"\"\r\n        current_task = dependency.task\r\n        for input_task in dependency.inputs:\r\n            dep = self.uuid_dict[input_task.private_task_config.uuid]\r\n            out_degrees[dep] -= 1\r\n\r\n            if out_degrees[dep] == 0:\r\n                LOGGER.debug(\"Removing intermediate result for %s\", str(current_task))\r\n                del intermediate_results[dep]"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns an ordered dictionary with key being task_name and an instance of a corresponding task from this workflow.", "response": "def get_tasks(self):\r\n        \"\"\"Returns an ordered dictionary {task_name: task} of all tasks within this workflow.\r\n\r\n        :return: Ordered dictionary with key being task_name (str) and an instance of a corresponding task from this\r\n        workflow\r\n        :rtype: OrderedDict\r\n        \"\"\"\r\n        tasks = collections.OrderedDict()\r\n        for dep in self.ordered_dependencies:\r\n            tasks[dep.name] = dep.task\r\n\r\n        return tasks"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngenerates the DOT representation of the underlying computational graph.", "response": "def get_dot(self):\r\n        \"\"\"Generates the DOT description of the underlying computational graph.\r\n\r\n        :return: The DOT representation of the computational graph\r\n        :rtype: Digraph\r\n        \"\"\"\r\n        dot = Digraph()\r\n\r\n        dep_to_dot_name = self._get_dep_to_dot_name_mapping(self.ordered_dependencies)\r\n\r\n        for dep in self.ordered_dependencies:\r\n            for input_task in dep.inputs:\r\n                dot.edge(dep_to_dot_name[self.uuid_dict[input_task.private_task_config.uuid]],\r\n                         dep_to_dot_name[dep])\r\n        return dot"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a mapping between Dependency classes and names used in DOT graph.", "response": "def _get_dep_to_dot_name_mapping(dependencies):\r\n        \"\"\" Creates mapping between Dependency classes and names used in DOT graph\r\n        \"\"\"\r\n        dot_name_to_deps = {}\r\n        for dep in dependencies:\r\n            dot_name = dep.name\r\n\r\n            if dot_name not in dot_name_to_deps:\r\n                dot_name_to_deps[dot_name] = [dep]\r\n            else:\r\n                dot_name_to_deps[dot_name].append(dep)\r\n\r\n        dep_to_dot_name = {}\r\n        for dot_name, deps in dot_name_to_deps.items():\r\n            if len(deps) == 1:\r\n                dep_to_dot_name[deps[0]] = dot_name\r\n                continue\r\n\r\n            for idx, dep in enumerate(deps):\r\n                dep_to_dot_name[dep] = dot_name + str(idx)\r\n\r\n        return dep_to_dot_name"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nvisualizing the computational graph.", "response": "def dependency_graph(self, filename=None):\r\n        \"\"\"Visualize the computational graph.\r\n\r\n        :param filename: Filename of the output image together with file extension. Supported formats: `png`, `jpg`,\r\n            `pdf`, ... . Check `graphviz` Python package for more options\r\n        :type filename: str\r\n        :return: The DOT representation of the computational graph, with some more formatting\r\n        :rtype: Digraph\r\n        \"\"\"\r\n        dot = self.get_dot()\r\n        dot.attr(rankdir='LR')  # Show graph from left to right\r\n\r\n        if filename is not None:\r\n            file_name, file_format = filename.rsplit('.', 1)\r\n\r\n            dot.render(filename=file_name, format=file_format, cleanup=True)\r\n\r\n        return dot"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a list of tasks that are unique.", "response": "def _make_tasks_unique(tasks):\r\n        \"\"\"If some tasks of the workflow are the same they are deep copied.\"\"\"\r\n        unique_tasks = []\r\n        prev_tasks = set()\r\n\r\n        for task in tasks:\r\n            if task in prev_tasks:\r\n                task = copy.deepcopy(task)\r\n            unique_tasks.append(task)\r\n\r\n        return unique_tasks"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the most appropriate morphological operation for the given morphological type.", "response": "def get_operation(cls, morph_type):\r\n        \"\"\" Maps morphological operation type to function\r\n\r\n        :param morph_type: Morphological operation type\r\n        :type morph_type: MorphologicalOperations\r\n        :return: function\r\n        \"\"\"\r\n        return {\r\n            cls.OPENING: skimage.morphology.opening,\r\n            cls.CLOSING: skimage.morphology.closing,\r\n            cls.DILATION: skimage.morphology.dilation,\r\n            cls.EROSION: skimage.morphology.erosion,\r\n            cls.MEDIAN: skimage.filters.rank.median\r\n        }[morph_type]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nexecuting method takes an EOPatch and changes the specified feature and returns the modified EOPatch", "response": "def execute(self, eopatch):\r\n        \"\"\" Execute method takes EOPatch and changes the specified feature\r\n        \"\"\"\r\n        feature_type, feature_name = next(self.feature(eopatch))\r\n\r\n        eopatch[feature_type][feature_name] = self.process(eopatch[feature_type][feature_name])\r\n\r\n        return eopatch"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef process(self, raster):\r\n        dim = len(raster.shape)\r\n        if dim == 3:\r\n            for dim in range(raster.shape[2]):\r\n                raster[:, :, dim] = self.morph_operation(raster[:, :, dim], self.struct_elem)\r\n        elif dim == 4:\r\n            for time, dim in it.product(range(raster.shape[0]), range(raster.shape[3])):\r\n                raster[time, :, :, dim] = self.morph_operation(raster[time, :, :, dim], self.struct_elem)\r\n        else:\r\n            raise ValueError('Invalid number of dimensions: {}'.format(dim))\r\n\r\n        return raster", "response": "Applies the morphological operation to the mask object"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a dictionary of out - degree", "response": "def get_outdegrees(self):\r\n        \"\"\"\r\n        :return: dictionary of out-degrees, see get_outdegree\r\n        \"\"\"\r\n        return {vertex: len(self.adj_dict[vertex]) for vertex in self.adj_dict}"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nadds the edge u_vertex -> v_vertex to the graph if the edge is not already present. Returns True if the edge was added False otherwise.", "response": "def add_edge(self, u_vertex, v_vertex):\r\n        \"\"\"Adds the edge ``u_vertex -> v_vertex`` to the graph if the edge is not already present.\r\n\r\n        :param u_vertex: Vertex\r\n        :param v_vertex: Vertex\r\n        :return: ``True`` if a new edge was added. ``False`` otherwise.\r\n        \"\"\"\r\n        self._vertices.add(u_vertex)\r\n        self._vertices.add(v_vertex)\r\n        if not self.is_edge(u_vertex, v_vertex):\r\n            self.indegrees[v_vertex] += 1\r\n            self.adj_dict[u_vertex].append(v_vertex)\r\n            return True\r\n\r\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef del_edge(self, u_vertex, v_vertex):\r\n        if self.is_edge(u_vertex, v_vertex):\r\n            self.indegrees[v_vertex] -= 1\r\n            self.adj_dict[u_vertex].remove(v_vertex)\r\n            return True\r\n\r\n        return False", "response": "Removes the edge u_vertex -> v_vertex from the graph if the edge is present. Returns True if the edge was removed False otherwise."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nadds a new vertex to the graph if not already present. Returns True if the vertex was added and False otherwise.", "response": "def add_vertex(self, vertex):\r\n        \"\"\"Adds a new vertex to the graph if not present.\r\n\r\n        :param vertex: Vertex\r\n        :return: ``True`` if ``vertex`` added and not yet present. ``False`` otherwise.\r\n        \"\"\"\r\n        if vertex not in self._vertices:\r\n            self._vertices.add(vertex)\r\n            return True\r\n\r\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nremoves the given vertex and all incident edges from the graph.", "response": "def del_vertex(self, vertex):\r\n        \"\"\"Removes the vertex ``vertex`` and all incident edges from the graph.\r\n\r\n        **Note** that this is an expensive operation that should be avoided!\r\n\r\n        Running time is O(V+E)\r\n\r\n        :param vertex: Vertex\r\n        :return: ``True`` if ``vertex`` was removed from the graph. ``False`` otherwise.\r\n        \"\"\"\r\n        for v_vertex in self.adj_dict[vertex]:\r\n            self.indegrees[v_vertex] -= 1\r\n\r\n        for v_vertex in self.vertices():\r\n            if vertex in self.adj_dict[v_vertex]:\r\n                self.adj_dict[v_vertex].remove(vertex)\r\n\r\n        if vertex in self._vertices:\r\n            self._vertices.remove(vertex)\r\n            return True\r\n\r\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a DirectedGraph created from edges.", "response": "def from_edges(edges):\r\n        \"\"\" Return DirectedGraph created from edges\r\n        :param edges:\r\n        :return: DirectedGraph\r\n        \"\"\"\r\n        dag = DirectedGraph()\r\n        for _u, _v in edges:\r\n            dag.add_edge(_u, _v)\r\n        return dag"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn True if the directed graph dag contains a cycle. False otherwise.", "response": "def _is_cyclic(dag):\r\n        \"\"\"True if the directed graph dag contains a cycle. False otherwise.\r\n\r\n        The algorithm is naive, running in O(V^2) time, and not intended for serious use! For production purposes on\r\n        larger graphs consider implementing Tarjan's O(V+E)-time algorithm instead.\r\n\r\n        :type dag: DirectedGraph\r\n        \"\"\"\r\n        # pylint: disable=invalid-name\r\n        vertices = dag.vertices()\r\n        for w in vertices:\r\n            stack = [w]\r\n            seen = set()\r\n            while stack:\r\n                u = stack.pop()\r\n                seen.add(u)\r\n                for v in dag[u]:\r\n                    if v == w:\r\n                        return True\r\n                    if v not in seen:\r\n                        stack.append(v)\r\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef execute(self, eopatch):\n        feature_type, feature_name = next(self.valid_data_feature())\n        eopatch[feature_type][feature_name] = self.predicate(eopatch)\n        return eopatch", "response": "Execute predicate on input eopatch and return the same eopatch instance with a mask. valid_data array computed according to the predicate\n       "}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nexecutes the masking of the values of the feature and mask_feature.", "response": "def execute(self, eopatch):\n        \"\"\" Mask values of `feature` according to the `mask_values` in `mask_feature`\n\n        :param eopatch: `eopatch` to be processed\n        :return: Same `eopatch` instance with masked `feature`\n        \"\"\"\n        feature_type, feature_name, new_feature_name = next(self.feature(eopatch))\n        mask_feature_type, mask_feature_name = next(self.mask_feature(eopatch))\n\n        data = np.copy(eopatch[feature_type][feature_name])\n        mask = eopatch[mask_feature_type][mask_feature_name]\n\n        if not isinstance(self.mask_values, list):\n            raise ValueError('Incorrect format or values of argument `mask_values`')\n\n        for value in self.mask_values:\n            data[mask.squeeze() == value] = self.no_data_value\n\n        eopatch.add_feature(feature_type, new_feature_name, data)\n\n        return eopatch"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the number of dimensions of the array.", "response": "def ndim(self):\n        \"\"\"If given FeatureType stores a dictionary of numpy.ndarrays it returns dimensions of such arrays.\"\"\"\n        if self.is_raster():\n            return {\n                FeatureType.DATA: 4,\n                FeatureType.MASK: 4,\n                FeatureType.SCALAR: 2,\n                FeatureType.LABEL: 2,\n                FeatureType.DATA_TIMELESS: 3,\n                FeatureType.MASK_TIMELESS: 3,\n                FeatureType.SCALAR_TIMELESS: 1,\n                FeatureType.LABEL_TIMELESS: 1\n            }[self]\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the type of the data for the given FeatureType.", "response": "def type(self):\n        \"\"\"Returns type of the data for the given FeatureType.\"\"\"\n        if self is FeatureType.TIMESTAMP:\n            return list\n        if self is FeatureType.BBOX:\n            return BBox\n        return dict"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef split_by_extensions(filename):\n        parts = filename.split('.')\n        idx = len(parts) - 1\n        while FileFormat.is_file_format(parts[idx]):\n            parts[idx] = FileFormat(parts[idx])\n            idx -= 1\n        return ['.'.join(parts[:idx + 1])] + parts[idx + 1:]", "response": "Splits the filename string by the extension of the file\n           "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreset all counters for this locale.", "response": "def reset_counters(self):\n        \"\"\"\n        Resets all counters, truth and classification masks.\n        \"\"\"\n        self.truth_masks = None\n        self.classification_masks = None\n        self.pixel_truth_counts = None\n        self.pixel_classification_counts = None\n        self.pixel_truth_sum = None\n        self.pixel_classification_sum = None\n        self.val_df = None\n        self.n_validation_sets = 0"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _count_truth_pixels(self):\n        pixel_count = np.array([[np.nonzero(mask)[0].shape[0] for mask in masktype]\n                                for masktype in self.truth_masks])\n\n        pixel_count = np.moveaxis(pixel_count, 0, -1)\n\n        if self.pixel_truth_counts is None:\n            self.pixel_truth_counts = np.copy(pixel_count)\n        else:\n            self.pixel_truth_counts = np.concatenate((self.pixel_truth_counts, pixel_count))", "response": "Counts the number of pixels belonging to each truth class."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _count_classified_pixels(self):\n        class_values = self.class_dictionary.values()\n\n        classification_count = np.array([[[np.count_nonzero(prediction[np.nonzero(mask)] == class_val)\n                                           for prediction, mask in zip(self.classification_masks, masktype)]\n                                          for masktype in self.truth_masks]\n                                         for class_val in class_values])\n\n        classification_count = np.moveaxis(classification_count, 0, -1)\n        classification_count = np.moveaxis(classification_count, 0, -2)\n\n        if self.pixel_classification_counts is None:\n            self.pixel_classification_counts = np.copy(classification_count)\n        else:\n            self.pixel_classification_counts = np.concatenate((self.pixel_classification_counts, classification_count))", "response": "Counts the number of pixels belonging to each classified class."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add_validation_patch(self, patch):\n        # 2. Convert 8-bit mask\n        self._transform_truth(patch)\n\n        # 3. Count truth labeled pixels\n        self._count_truth_pixels()\n\n        # 5. Perform classification\n        self._classify(patch)\n\n        # 6. Count pixel classified as class i\n        self._count_classified_pixels()\n\n        self.n_validation_sets = self.n_validation_sets + 1", "response": "Adds a validation patch to the validation set."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef validate(self):\n        self.pixel_truth_sum = np.sum(self.pixel_truth_counts, axis=0)\n        self.pixel_classification_sum = np.sum(self.pixel_classification_counts, axis=0)", "response": "Aggregate the results from all EOPatches."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsaves the current object to a pickle file.", "response": "def save(self, filename):\n        \"\"\"\n        Save validator object to pickle.\n        \"\"\"\n        with open(filename, 'wb') as output:\n            pickle.dump(self, output, protocol=pickle.HIGHEST_PROTOCOL)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns pandas DataFrame containing pixel counts for all truth classes classified classes and file name of the input ArcGIS EODataSet.", "response": "def pandas_df(self):\n        \"\"\"\n        Returns pandas DataFrame containing pixel counts for all truth classes,\n        classified classes (for each truth class), and file name of the input\n        EODataSet.\n\n        The data frame thus contains\n\n        N =  self.n_validation_sets rows\n\n        and\n\n        M = len(self.truth_classes) + len(self.truth_classes) * len (self.class_dictionary) + 1 columns\n        \"\"\"\n\n        if self.val_df is not None:\n            return self.val_df\n\n        clf = self.pixel_classification_counts.reshape(self.pixel_classification_counts.shape[0],\n                                                       self.pixel_classification_counts.shape[1] *\n                                                       self.pixel_classification_counts.shape[2])\n\n        combo = np.hstack((self.pixel_truth_counts, clf))\n\n        columns = list(itertools.product(self.truth_classes, list(self.class_dictionary.keys())))\n        columns = [(item[0] + '_as_' + item[1]).replace(\" \", \"_\") for item in columns]\n        truth_columns = ['truth_' + item.replace(\" \", \"_\") for item in self.truth_classes]\n\n        self.val_df = pd.DataFrame(combo, columns=truth_columns + columns)\n\n        return self.val_df"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the normalised confusion matrix for the log - level log - level.", "response": "def confusion_matrix(self):\n        \"\"\"\n        Returns the normalised confusion matrix\n        \"\"\"\n        confusion_matrix = self.pixel_classification_sum.astype(np.float)\n        confusion_matrix = np.divide(confusion_matrix.T, self.pixel_truth_sum.T).T\n\n        return confusion_matrix * 100.0"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nplot the confusion matrix.", "response": "def plot_confusion_matrix(self, normalised=True):\n        \"\"\"\n        Plots the confusion matrix.\n        \"\"\"\n        conf_matrix = self.confusion_matrix()\n\n        if normalised:\n            sns.heatmap(conf_matrix,\n                        annot=True, annot_kws={\"size\": 12}, fmt='2.1f', cmap='YlGnBu', vmin=0.0,\n                        vmax=100.0,\n                        xticklabels=list(self.class_dictionary.keys()),\n                        yticklabels=self.truth_classes)\n        else:\n            sns.heatmap(self.pixel_classification_counts,\n                        annot=True, annot_kws={\"size\": 12}, fmt='2.1f', cmap='YlGnBu', vmin=0.0,\n                        vmax=np.max(self.pixel_classification_counts),\n                        xticklabels=list(self.class_dictionary.keys()),\n                        yticklabels=self.truth_classes)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef summary(self, scoring):\n\n        if scoring == 'class_confusion':\n            print('*' * 50)\n            print('  Confusion Matrix ')\n            print('x-axis: ' + ' | '.join(list(self.class_dictionary.keys())))\n            print('y-axis: ' + ' | '.join(self.truth_classes))\n            print(self.confusion_matrix())", "response": "Prints out the summary of validation for giving scoring function."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef execute(self, eopatch):\n        feature_type, feature_name = next(self.feature(eopatch))\n\n        good_idxs = self._get_filtered_indices(eopatch[feature_type][feature_name] if feature_name is not ... else\n                                               eopatch[feature_type])\n\n        for feature_type, feature_name in self.filter_features(eopatch):\n            if feature_type.is_time_dependent():\n                if feature_type.has_dict():\n                    if feature_type.contains_ndarrays():\n                        eopatch[feature_type][feature_name] = np.asarray([eopatch[feature_type][feature_name][idx] for\n                                                                          idx in good_idxs])\n                    # else:\n                    #     NotImplemented\n                else:\n                    eopatch[feature_type] = [eopatch[feature_type][idx] for idx in good_idxs]\n\n        self._update_other_data(eopatch)\n\n        return eopatch", "response": "Execute the filter on the given eopatch."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nexecutes computation of HoG features on input eopatch and return the resulting eopatch.", "response": "def execute(self, eopatch):\n        \"\"\" Execute computation of HoG features on input eopatch\n\n            :param eopatch: Input eopatch\n            :type eopatch: eolearn.core.EOPatch\n            :return: EOPatch instance with new keys holding the HoG features and HoG image for visualisation.\n            :rtype: eolearn.core.EOPatch\n        \"\"\"\n        for feature_type, feature_name, new_feature_name in self.feature:\n            result = self._compute_hog(eopatch[feature_type][feature_name])\n            eopatch[feature_type][new_feature_name] = result[0]\n            if self.visualize:\n                eopatch[feature_type][self.visualize_name] = result[1]\n\n        return eopatch"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nexecute computation of local binary patterns on input eopatch.", "response": "def execute(self, eopatch):\n        \"\"\" Execute computation of local binary patterns on input eopatch\n\n            :param eopatch: Input eopatch\n            :type eopatch: eolearn.core.EOPatch\n            :return: EOPatch instance with new key holding the LBP image.\n            :rtype: eolearn.core.EOPatch\n        \"\"\"\n        for feature_type, feature_name, new_feature_name in self.feature:\n            eopatch[feature_type][new_feature_name] = self._compute_lbp(eopatch[feature_type][feature_name])\n\n        return eopatch"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef ransac(npts, model, n, k, t, d):\n    iterations = 0\n    bestfit = None\n    besterr = np.inf\n    # best_inlier_idxs = None\n    while iterations < k:\n        maybe_idxs, test_idxs = random_partition(n, npts)\n        maybemodel = model.fit(maybe_idxs)\n        test_err = model.score(test_idxs, maybemodel)\n        also_idxs = test_idxs[test_err < t]  # select indices of rows with accepted points\n\n        LOGGER.debug('test_err.min() %f', test_err.min() if test_err.size else None)\n        LOGGER.debug('test_err.max() %f', test_err.max() if test_err.size else None)\n        LOGGER.debug('numpy.mean(test_err) %f', np.mean(test_err) if test_err.size else None)\n        LOGGER.debug('iteration %d, len(alsoinliers) = %d', iterations, len(also_idxs))\n\n        if len(also_idxs) > d:\n            betteridxs = np.concatenate((maybe_idxs, also_idxs))\n            bettermodel = model.fit(betteridxs)\n            better_errs = model.score(betteridxs, bettermodel)\n            thiserr = np.mean(better_errs)\n            if thiserr < besterr:\n                bestfit = bettermodel\n                besterr = thiserr\n                # best_inlier_idxs = np.concatenate((maybe_idxs, also_idxs))\n        iterations += 1\n    return bestfit", "response": "Fit model parameters to data using RANSAC algorithm."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns n random rows of data and also the other lenghts of data", "response": "def random_partition(n, n_data):\n    \"\"\"return n random rows of data (and also the other len(data)-n rows)\"\"\"\n    all_idxs = np.arange(n_data)\n    np.random.shuffle(all_idxs)\n    idxs1 = all_idxs[:n]\n    idxs2 = all_idxs[n:]\n    return idxs1, idxs2"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nestimates the rigid transformation matrix given a set of indices", "response": "def estimate_rigid_transformation(self, idx):\n        \"\"\" Estimate rigid transformation given a set of indices\n\n        :param idx: Array of indices used to estimate the transformation\n        :return: Estimated transformation matrix\n        \"\"\"\n        # Look at points of given indices only\n        src_pts = self.src_pts[idx, :]\n        trg_pts = self.trg_pts[idx, :]\n        # Get centroid location\n        src_centroid, trg_centroid = np.mean(src_pts, axis=0), np.mean(trg_pts, axis=0)\n        # Centre sets of points\n        src_pts_centr = src_pts - src_centroid\n        trg_pts_centr = trg_pts - trg_centroid\n        # SVD decomposition\n        u, _, v = np.linalg.svd(np.matmul(src_pts_centr.transpose(), trg_pts_centr))\n        e = np.eye(2)\n        e[1, 1] = np.linalg.det(np.matmul(v.transpose(), u.transpose()))\n        # Estimate rotation matrix\n        r = np.matmul(v.transpose(), np.matmul(e, u.transpose()))\n        # Estimate translation\n        t = trg_centroid - np.matmul(r, src_centroid.transpose()).transpose()\n        # Fill in transformation matrix and return\n        warp_matrix = np.zeros((2, 3))\n        warp_matrix[:2, :2] = r\n        warp_matrix[:, 2] = t\n        return warp_matrix"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef score(self, idx, warp_matrix):\n        # Transform source points with estimated transformation\n        trg_fit = scipy.dot(warp_matrix, np.concatenate((self.src_pts[idx, :], np.ones((len(idx), 1))), axis=1).T).T\n        # Compute error in transformation\n        err_per_point = np.sqrt(np.sum((self.trg_pts[idx, :] - trg_fit[:, :2])**2, axis=1))  # sum squared error per row\n        return err_per_point", "response": "Estimate the registration error of the estimated transformation matrix\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates a view of array that is larger than a given size window.", "response": "def rolling_window(array, window=(0,), asteps=None, wsteps=None, axes=None, toend=True):\r\n    \"\"\"Create a view of `array` which for every point gives the n-dimensional\r\n    neighbourhood of size window. New dimensions are added at the end of\r\n    `array` or after the corresponding original dimension.\r\n\r\n    Parameters\r\n    ----------\r\n    array : array_like\r\n        Array to which the rolling window is applied.\r\n    window : int or tuple\r\n        Either a single integer to create a window of only the last axis or a\r\n        tuple to create it for the last len(window) axes. 0 can be used as a\r\n        to ignore a dimension in the window.\r\n    asteps : tuple\r\n        Aligned at the last axis, new steps for the original array, ie. for\r\n        creation of non-overlapping windows. (Equivalent to slicing result)\r\n    wsteps : int or tuple (same size as window)\r\n        steps for the added window dimensions. These can be 0 to repeat values\r\n        along the axis.\r\n    axes: int or tuple\r\n        If given, must have the same size as window. In this case window is\r\n        interpreted as the size in the dimension given by axes. IE. a window\r\n        of (2, 1) is equivalent to window=2 and axis=-2.\r\n    toend : bool\r\n        If False, the new dimensions are right after the corresponding original\r\n        dimension, instead of at the end of the array. Adding the new axes at the\r\n        end makes it easier to get the neighborhood, however toend=False will give\r\n        a more intuitive result if you view the whole array.\r\n\r\n    Returns\r\n    -------\r\n    A view on `array` which is smaller to fit the windows and has windows added\r\n    dimensions (0s not counting), ie. every point of `array` is an array of size\r\n    window.\r\n\r\n    Examples\r\n    --------\r\n    >>> a = np.arange(9).reshape(3,3)\r\n    >>> rolling_window(a, (2,2))\r\n    array([[[[0, 1],\r\n             [3, 4]],\r\n\r\n            [[1, 2],\r\n             [4, 5]]],\r\n\r\n\r\n           [[[3, 4],\r\n             [6, 7]],\r\n\r\n            [[4, 5],\r\n             [7, 8]]]])\r\n\r\n    Or to create non-overlapping windows, but only along the first dimension:\r\n    >>> rolling_window(a, (2,0), asteps=(2,1))\r\n    array([[[0, 3],\r\n            [1, 4],\r\n            [2, 5]]])\r\n\r\n    Note that the 0 is discared, so that the output dimension is 3:\r\n    >>> rolling_window(a, (2,0), asteps=(2,1)).shape\r\n    (1, 3, 2)\r\n\r\n    This is useful for example to calculate the maximum in all (overlapping)\r\n    2x2 submatrixes:\r\n    >>> rolling_window(a, (2,2)).max((2,3))\r\n    array([[4, 5],\r\n           [7, 8]])\r\n\r\n    Or delay embedding (3D embedding with delay 2):\r\n    >>> x = np.arange(10)\r\n    >>> rolling_window(x, 3, wsteps=2)\r\n    array([[0, 2, 4],\r\n           [1, 3, 5],\r\n           [2, 4, 6],\r\n           [3, 5, 7],\r\n           [4, 6, 8],\r\n           [5, 7, 9]])\r\n    \"\"\"\r\n    # pylint: disable=too-many-branches\r\n    # pylint: disable=too-many-statements\r\n\r\n    array = np.asarray(array)\r\n    orig_shape = np.asarray(array.shape)\r\n    window = np.atleast_1d(window).astype(int)  # maybe crude to cast to int...\r\n\r\n    if axes is not None:\r\n        axes = np.atleast_1d(axes)\r\n        new_window = np.zeros(array.ndim, dtype=int)\r\n        for axis, size in zip(axes, window):\r\n            new_window[axis] = size\r\n        window = new_window\r\n\r\n    # Check if window is legal:\r\n    if window.ndim > 1:\r\n        raise ValueError(\"`window` must be one-dimensional.\")\r\n    if np.any(window < 0):\r\n        raise ValueError(\"All elements of `window` must be larger then 1.\")\r\n    if len(array.shape) < len(window):\r\n        raise ValueError(\"`window` length must be less or equal `array` dimension.\")\r\n\r\n    _asteps = np.ones_like(orig_shape)\r\n    if asteps is not None:\r\n        asteps = np.atleast_1d(asteps)\r\n        if asteps.ndim != 1:\r\n            raise ValueError(\"`asteps` must be either a scalar or one dimensional.\")\r\n        if len(asteps) > array.ndim:\r\n            raise ValueError(\"`asteps` cannot be longer then the `array` dimension.\")\r\n        # does not enforce alignment, so that steps can be same as window too.\r\n        _asteps[-len(asteps):] = asteps\r\n\r\n        if np.any(asteps < 1):\r\n            raise ValueError(\"All elements of `asteps` must be larger then 1.\")\r\n    asteps = _asteps\r\n\r\n    _wsteps = np.ones_like(window)\r\n    if wsteps is not None:\r\n        wsteps = np.atleast_1d(wsteps)\r\n        if wsteps.shape != window.shape:\r\n            raise ValueError(\"`wsteps` must have the same shape as `window`.\")\r\n        if np.any(wsteps < 0):\r\n            raise ValueError(\"All elements of `wsteps` must be larger then 0.\")\r\n\r\n        _wsteps[:] = wsteps\r\n        _wsteps[window == 0] = 1  # make sure that steps are 1 for non-existing dims.\r\n    wsteps = _wsteps\r\n\r\n    # Check that the window would not be larger then the original:\r\n    if np.any(orig_shape[-len(window):] < window * wsteps):\r\n        raise ValueError(\"`window` * `wsteps` larger then `array` in at least one dimension.\")\r\n\r\n    new_shape = orig_shape  # just renaming...\r\n\r\n    # For calculating the new shape 0s must act like 1s:\r\n    _window = window.copy()\r\n    _window[_window == 0] = 1\r\n\r\n    new_shape[-len(window):] += wsteps - _window * wsteps\r\n    new_shape = (new_shape + asteps - 1) // asteps\r\n    # make sure the new_shape is at least 1 in any \"old\" dimension (ie. steps\r\n    # is (too) large, but we do not care.\r\n    new_shape[new_shape < 1] = 1\r\n    shape = new_shape\r\n\r\n    strides = np.asarray(array.strides)\r\n    strides *= asteps\r\n    new_strides = array.strides[-len(window):] * wsteps\r\n\r\n    # The full new shape and strides:\r\n    if toend:\r\n        new_shape = np.concatenate((shape, window))\r\n        new_strides = np.concatenate((strides, new_strides))\r\n    else:\r\n        _ = np.zeros_like(shape)\r\n        _[-len(window):] = window\r\n        _window = _.copy()\r\n        _[-len(window):] = new_strides\r\n        _new_strides = _\r\n\r\n        new_shape = np.zeros(len(shape) * 2, dtype=int)\r\n        new_strides = np.zeros(len(shape) * 2, dtype=int)\r\n\r\n        new_shape[::2] = shape\r\n        new_strides[::2] = strides\r\n        new_shape[1::2] = _window\r\n        new_strides[1::2] = _new_strides\r\n\r\n    new_strides = new_strides[new_shape != 0]\r\n    new_shape = new_shape[new_shape != 0]\r\n\r\n    return np.lib.stride_tricks.as_strided(array, shape=new_shape, strides=new_strides)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nfunction to warp input image using a linear transformation", "response": "def warp(self, warp_matrix, img, iflag=cv2.INTER_NEAREST):\n        \"\"\" Function to warp input image given an estimated 2D linear transformation\n\n        :param warp_matrix: Linear 2x3 matrix to use to linearly warp the input images\n        :type warp_matrix: ndarray\n        :param img: Image to be warped with estimated transformation\n        :type img: ndarray\n        :param iflag: Interpolation flag, specified interpolation using during resampling of warped image\n        :type iflag: cv2.INTER_*\n        :return: Warped image using the linear matrix\n        \"\"\"\n\n        height, width = img.shape[:2]\n        warped_img = np.zeros_like(img, dtype=img.dtype)\n\n        # Check if image to warp is 2D or 3D. If 3D need to loop over channels\n        if (self.interpolation_type == InterpolationType.LINEAR) or img.ndim == 2:\n            warped_img = cv2.warpAffine(img.astype(np.float32), warp_matrix, (width, height),\n                                        flags=iflag).astype(img.dtype)\n\n        elif img.ndim == 3:\n            for idx in range(img.shape[-1]):\n                warped_img[..., idx] = cv2.warpAffine(img[..., idx].astype(np.float32), warp_matrix, (width, height),\n                                                      flags=iflag).astype(img.dtype)\n        else:\n            raise ValueError('Image has incorrect number of dimensions: {}'.format(img.ndim))\n\n        return warped_img"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef is_registration_suspicious(warp_matrix):\n        if warp_matrix is None:\n            return 1\n\n        cos_theta = np.trace(warp_matrix[:2, :2]) / 2\n        rot_angle = np.arccos(cos_theta)\n        transl_norm = np.linalg.norm(warp_matrix[:, 2])\n        return 1 if int((rot_angle > MAX_ROTATION) or (transl_norm > MAX_TRANSLATION)) else 0", "response": "Static method that checks if estimated linear transformation could be unplausible and returns 1 if it is not."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef register(self, src, trg, trg_mask=None, src_mask=None):\n        # Initialise instance of CrossCorr object\n        ccreg = registration.CrossCorr()\n        # padding_value = 0\n        # Compute translation between pair of images\n        model = ccreg.fit(src, reference=trg)\n        # Get translation as an array\n        translation = [-x for x in model.toarray().tolist()[0]]\n        # Fill in transformation matrix\n        warp_matrix = np.eye(2, 3)\n        warp_matrix[0, 2] = translation[1]\n        warp_matrix[1, 2] = translation[0]\n        # Return transformation matrix\n        return warp_matrix", "response": "Implementation of pair - wise registration using the CrossCorr model."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nnormalise and scale image in 0 - 255 range", "response": "def rescale_image(image):\n        \"\"\" Normalise and scale image in 0-255 range \"\"\"\n        s2_min_value, s2_max_value = 0, 1\n        out_min_value, out_max_value = 0, 255\n        # Clamp values in 0-1 range\n        image[image > s2_max_value] = s2_max_value\n        image[image < s2_min_value] = s2_min_value\n        # Rescale to uint8 range\n        out_image = out_max_value + (image-s2_min_value)*(out_max_value-out_min_value)/(s2_max_value-s2_min_value)\n        return out_image.astype(np.uint8)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef transform(self, X):\r\n        if self.mode_ == 'target':\r\n            return np.apply_along_axis(self._target, 1, np.reshape(X, (X.shape[0], X.shape[1] * X.shape[2])))\r\n\r\n        if self.mode_ == 'majority':\r\n            return np.apply_along_axis(self._majority, 1, np.reshape(X, (X.shape[0], X.shape[1] * X.shape[2])))\r\n\r\n        print('Invalid mode! Set mode to majority or target. Returning input.')\r\n        return X", "response": "Returns a new array with the same shape as the original array."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef transform(self, X):\r\n\r\n        if self.binary_:\r\n            return (X & self.definition_ > 0).astype(int)\r\n        return (X == self.definition_).astype(int)", "response": "Returns True if the array - like X is a valid tag mask False otherwise."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _get_submap(self, eopatch):\n        bbox_poly = eopatch.bbox.get_geometry()\n\n        filtered_data = self.vector_data[self.vector_data.geometry.intersects(bbox_poly)].copy(deep=True)\n        filtered_data.geometry = filtered_data.geometry.intersection(bbox_poly)\n\n        return filtered_data", "response": "Returns a new geopandas dataframe with same structure as original one except that\n        it contains only polygons that are contained within the bounding box."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef execute(self, eopatch):\n        bbox_map = self._get_submap(eopatch)\n        height, width = self._get_shape(eopatch)\n        data_transform = rasterio.transform.from_bounds(*eopatch.bbox, width=width, height=height)\n\n        if self.feature_name in eopatch[self.feature_type]:\n            raster = eopatch[self.feature_type][self.feature_name].squeeze()\n        else:\n            raster = np.ones((height, width), dtype=self.raster_dtype) * self.no_data_value\n\n        if not bbox_map.empty:\n            rasterio.features.rasterize([(bbox_map.cascaded_union.buffer(0), self.raster_value)], out=raster,\n                                        transform=data_transform, dtype=self.raster_dtype)\n\n        eopatch[self.feature_type][self.feature_name] = raster[..., np.newaxis]\n\n        return eopatch", "response": "Execute function which adds new vector layer to the EOPatch"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nexecuting function which adds new vector layer to the EOPatch", "response": "def execute(self, eopatch):\n        \"\"\" Execute function which adds new vector layer to the EOPatch\n\n        :param eopatch: input EOPatch\n        :type eopatch: EOPatch\n        :return: New EOPatch with added vector layer\n        :rtype: EOPatch\n        \"\"\"\n        for raster_ft, raster_fn, vector_fn in self.feature_gen(eopatch):\n            vector_ft = FeatureType.VECTOR_TIMELESS if raster_ft.is_timeless() else FeatureType.VECTOR\n\n            raster = eopatch[raster_ft][raster_fn]\n            height, width = raster.shape[:2] if raster_ft.is_timeless() else raster.shape[1: 3]\n\n            if self.raster_dtype:\n                raster = raster.astype(self.raster_dtype)\n\n            data_transform = rasterio.transform.from_bounds(*eopatch.bbox, width=width, height=height)\n\n            crs = eopatch.bbox.get_crs()\n\n            if raster_ft.is_timeless():\n                eopatch[vector_ft][vector_fn] = self._vectorize_single_raster(raster, data_transform, crs)\n            else:\n                gpd_list = [self._vectorize_single_raster(raster[time_idx, ...], data_transform, crs,\n                                                          timestamp=eopatch.timestamp[time_idx])\n                            for time_idx in range(raster.shape[0])]\n\n                eopatch[vector_ft][vector_fn] = GeoDataFrame(pd.concat(gpd_list, ignore_index=True),\n                                                             crs=gpd_list[0].crs)\n\n        return eopatch"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef area(self, cc_index=None):\n        if cc_index is not None:\n            return self.areas[cc_index]\n        return np.sum(self.areas)", "response": "Returns the area of the selected polygon or all polygons if index is not provided."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsamples n points from the provided raster mask.", "response": "def sample(self, nsamples=1, weighted=True):\n        \"\"\"\n        Sample n points from the provided raster mask. The number of points belonging\n        to each class is proportional to the area this class covers in the raster mask,\n        if weighted is set to True.\n\n        TODO: If polygon has holes the number of sampled points will be less than nsamples\n\n        :param nsamples: number of sampled samples\n        :type nsamples: integer\n        :param weighted: flag to apply weights proportional to total area of each class/polygon when sampling\n        :type weighted: bool, default is True\n        \"\"\"\n        weights = self.areas / np.sum(self.areas) if weighted else None\n        index = np.random.choice(a=len(self.geometries), size=nsamples, p=weights)\n\n        labels = []\n        rows = []\n        cols = []\n        for idx in index:\n            polygon = self.geometries[idx]['polygon']\n            label = self.geometries[idx]['label']\n            point = PointSampler.random_point(polygon.envelope.bounds)\n            if PointSampler.contains(polygon, point):\n                labels.append(label)\n                rows.append(int(point.y))\n                cols.append(int(point.x))\n                # samples.append({'label':label, 'row':point.y, 'col':point.x})\n\n        return labels, rows, cols"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef sample_cc(self, nsamples=1, weighted=True):\n        weights = self.areas / np.sum(self.areas) if weighted else None\n        for index in np.random.choice(a=len(self.geometries), size=nsamples, p=weights):\n            yield self.geometries[index]", "response": "Returns a random polygon of any class."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef sample_within_cc(self, cc_index, nsamples=1):\n        polygon = self.geometries[cc_index]['polygon']\n        samples = []\n        while len(samples) < nsamples:\n            point = PointSampler.random_point(polygon.envelope.bounds)\n            if PointSampler.contains(polygon, point):\n                samples.append(point)\n        return samples", "response": "Returns randomly sampled points from a polygon."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ntest whether a point lies within the polygon.", "response": "def contains(polygon, point):\n        \"\"\"\n        Tests whether point lies within the polygon\n        \"\"\"\n        in_hole = functools.reduce(\n            lambda P, Q: P and Q,\n            [interior.covers(point) for interior in polygon.interiors]\n        ) if polygon.interiors else False\n        return polygon.covers(point) and not in_hole"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nselects a random point in interior of a rectangle", "response": "def random_coords(bounds):\n        \"\"\" Selects a random point in interior of a rectangle\n\n        :param bounds: Rectangle coordinates (x_min, y_min, x_max, y_max)\n        :type bounds: tuple(float)\n        :return: Random point from interior of rectangle\n        :rtype: tuple of x and y coordinates\n        \"\"\"\n        x_min, y_min, x_max, y_max = bounds\n        x = np.random.randint(x_min, x_max)\n        y = np.random.randint(y_min, y_max)\n        return x, y"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef random_point_triangle(triangle, use_int_coords=True):\n        xs, ys = triangle.exterior.coords.xy\n        A, B, C = zip(xs[:-1], ys[:-1])\n        r1, r2 = np.random.rand(), np.random.rand()\n        rx, ry = (1 - sqrt(r1)) * np.asarray(A) + sqrt(r1) * (1 - r2) * np.asarray(B) + sqrt(r1) * r2 * np.asarray(C)\n        if use_int_coords:\n            rx, ry = round(rx), round(ry)\n            return Point(int(rx), int(ry))\n        return Point(rx, ry)", "response": "Selects a random point in interior of a triangle."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _get_unknown_value(self):\n        label_set = set(self.labels)\n        value = 0\n        while value in label_set:\n            value += 1\n        return value", "response": "Finds the smallest integer value that is not in the labels"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nsample nsamples_per_label points from the binary mask corresponding to label.", "response": "def _binary_sample(image, label, n_samples_per_label, label_count):\n        \"\"\" Sample `nsamples_per_label` points from the binary mask corresponding to `label`\n\n        Randomly sample `nsamples_per_label` point form the binary mask corresponding to `label`. Sampling with\n        replacement is used if the required `nsamples_per_label` is larger than the available `label_count`\n\n        :param image: Input 2D raster label image\n        :type image: uint8 numpy array\n        :param label: Scalar value of label to consider\n        :type label: uint8\n        :param n_samples_per_label: Number of points to sample form the binary mask\n        :type n_samples_per_label: uint32\n        :param label_count: Number of points available for `label`\n        :type label_count: uint32\n        :return: Sampled label value, row index of samples, col index of samples\n        \"\"\"\n        h_idx, w_idx = np.where(image == label)\n\n        rand_idx = np.random.choice(h_idx.size, size=n_samples_per_label, replace=label_count < n_samples_per_label)\n\n        return h_idx[rand_idx], w_idx[rand_idx]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nsample the n_samples points of raster into a list of row indices of samples and column indices of samples.", "response": "def sample(self, raster, n_samples=1000):\n        \"\"\" Sample `nsamples` points form raster\n\n        :param raster: Input 2D or single-channel 3D label image\n        :type raster: uint8 numpy array\n        :param n_samples: Number of points to sample in total\n        :type n_samples: uint32\n        :return: List of row indices of samples, list of column indices of samples\n        :rtype: numpy.array, numpy.array\n        \"\"\"\n        # Check dimensionality and reshape to 2D\n        raster = raster.copy()\n        if raster.ndim == 3 and raster.shape[-1] == 1:\n            raster = raster.squeeze()\n        elif raster.ndim != 2:\n            raise ValueError('Class operates on 2D or 3D single-channel raster images')\n\n        # Calculate mask of all pixels which can be sampled\n        mask = np.zeros(raster.shape, dtype=np.bool)\n        for label in self.labels:\n            label_mask = (raster == label)\n            mask |= label_mask\n\n        unique_labels, label_count = np.unique(raster[mask], return_counts=True)\n        if not unique_labels.size:\n            LOGGER.warning('No samples matching given parameters found in EOPatch')\n            return np.empty((0,), dtype=np.uint32), np.empty((0,), dtype=np.uint32)\n\n        if self.even_sampling:\n            # Valid labels have the same (or off by one) number of samples\n            n_samples_per_label = np.diff(np.round(np.linspace(0, n_samples,\n                                                               num=label_count.size + 1))).astype(np.uint32)\n        else:\n            # Number of samples per label is proportional to label frequency\n            label_ratio = label_count / np.sum(label_count)\n            n_samples_per_label = (np.ceil(n_samples * label_ratio)).astype(np.uint32)\n\n        # Apply mask to raster\n        unknown_value = self._get_unknown_value()\n        raster[~mask] = unknown_value\n        if not np.array_equal(~mask, raster == unknown_value):\n            raise ValueError('Failed to set unknown value. Too many labels for sampling reference mask of type '\n                             '{}'.format(raster.dtype))\n\n        # Sample raster\n        samples = np.concatenate([self._binary_sample(raster, label, n_sample_label, label_count)\n                                  for label, n_sample_label, label_count in zip(unique_labels, n_samples_per_label,\n                                                                                label_count)], axis=1).T\n\n        # Shuffle to mix labels in case they are fed directly to train a ML model\n        np.random.shuffle(samples)\n\n        # Return row index and col index. Return exactly `n_sample` values\n        return samples[:n_samples, 0], samples[:n_samples, 1]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nexecute random spatial sampling of time - series stored in the input eopatch.", "response": "def execute(self, eopatch, seed=None):\n        \"\"\" Execute random spatial sampling of time-series stored in the input eopatch\n\n        :param eopatch: Input eopatch to be sampled\n        :type eopatch: EOPatch\n        :param seed: Setting seed of random sampling. If None no seed will be used.\n        :type seed: int or None\n        :return: An EOPatch with spatially sampled temporal features and associated labels\n        :type eopatch: EOPatch\n        \"\"\"\n        np.random.seed(seed)\n\n        # Retrieve data and raster label image from eopatch\n        f_type, f_name = next(self.ref_mask_feature(eopatch))\n        raster = eopatch[f_type][f_name]\n\n        # Initialise sampler\n        sampler = PointRasterSampler(self.ref_labels, **self.sampling_params)\n        # Perform sampling\n        rows, cols = sampler.sample(raster, n_samples=self.n_samples)\n\n        if self.return_new_eopatch:\n            new_eopatch = EOPatch()\n            new_eopatch.timestamp = eopatch.timestamp[:]\n            new_eopatch.bbox = eopatch.bbox  # Should be copied\n            new_eopatch.meta_info = eopatch.meta_info.copy()  # Should be deep copied - implement this in core\n        else:\n            new_eopatch = eopatch\n\n        # Add sampled features\n        for feature_type, feature_name, new_feature_name in self.sample_features(eopatch):\n\n            if feature_type.is_time_dependent():\n                sampled_data = eopatch[feature_type][feature_name][:, rows, cols, :]\n            else:\n                sampled_data = eopatch[feature_type][feature_name][rows, cols, :]\n            new_eopatch[feature_type][new_feature_name] = sampled_data[..., np.newaxis, :]\n\n        return new_eopatch"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef execute(self, eopatch, *, eopatch_folder):\n        eopatch.save(os.path.join(self.folder, eopatch_folder), *self.args, **self.kwargs)\n        return eopatch", "response": "Saves the EOPatch to disk."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nloads the EOPatch from disk.", "response": "def execute(self, *, eopatch_folder):\n        \"\"\"Loads the EOPatch from disk: `folder/eopatch_folder`.\n\n        :param eopatch_folder: name of EOPatch folder containing data\n        :type eopatch_folder: str\n        :return: EOPatch loaded from disk\n        :rtype: EOPatch\n        \"\"\"\n        eopatch = EOPatch.load(os.path.join(self.folder, eopatch_folder), *self.args, **self.kwargs)\n        return eopatch"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef execute(self, eopatch, data):\n        if self.feature_name is None:\n            eopatch[self.feature_type] = data\n        else:\n            eopatch[self.feature_type][self.feature_name] = data\n\n        return eopatch", "response": "Returns the EOPatch with added features."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the EOPatch with removed features.", "response": "def execute(self, eopatch):\n        \"\"\"Returns the EOPatch with removed features.\n\n        :param eopatch: input EOPatch\n        :type eopatch: EOPatch\n        :return: input EOPatch without the specified feature\n        :rtype: EOPatch\n        \"\"\"\n        for feature_type, feature_name in self.feature_gen(eopatch):\n            if feature_name is ...:\n                eopatch.reset_feature_type(feature_type)\n            else:\n                del eopatch[feature_type][feature_name]\n\n        return eopatch"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the EOPatch with renamed features.", "response": "def execute(self, eopatch):\n        \"\"\"Returns the EOPatch with renamed features.\n\n        :param eopatch: input EOPatch\n        :type eopatch: EOPatch\n        :return: input EOPatch with the renamed features\n        :rtype: EOPatch\n        \"\"\"\n        for feature_type, feature_name, new_feature_name in self.feature_gen(eopatch):\n            eopatch[feature_type][new_feature_name] = eopatch[feature_type][feature_name]\n            del eopatch[feature_type][feature_name]\n\n        return eopatch"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _numpy_index_by_percentile(self, data, percentile):\n        data_perc_low = np.nanpercentile(data, percentile, axis=0, interpolation=self.interpolation)\n\n        indices = np.empty(data_perc_low.shape, dtype=np.uint8)\n        indices[:] = np.nan\n\n        abs_diff = np.where(np.isnan(data_perc_low), np.inf, abs(data - data_perc_low))\n\n        indices = np.where(np.isnan(data_perc_low), self.max_index, np.nanargmin(abs_diff, axis=0))\n\n        return indices", "response": "Calculate the percentile of numpy stack and return the index of the chosen pixel."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _geoville_index_by_percentile(self, data, percentile):\n        # no_obs = bn.allnan(arr_tmp[\"data\"], axis=0)\n        data_tmp = np.array(data, copy=True)\n        valid_obs = np.sum(np.isfinite(data_tmp), axis=0)\n        # replace NaN with maximum\n        max_val = np.nanmax(data_tmp) + 1\n        data_tmp[np.isnan(data_tmp)] = max_val\n        # sort - former NaNs will move to the end\n        ind_tmp = np.argsort(data_tmp, kind=\"mergesort\", axis=0)\n        # desired position as well as floor and ceiling of it\n        k_arr = (valid_obs - 1) * (percentile / 100.0)\n        k_arr = np.where(k_arr < 0, 0, k_arr)\n        f_arr = np.floor(k_arr + 0.5)\n        f_arr = f_arr.astype(np.int)\n        # get floor value of reference band and index band\n        ind = f_arr.astype(\"int16\")\n        y_val, x_val = ind_tmp.shape[1], ind_tmp.shape[2]\n        y_val, x_val = np.ogrid[0:y_val, 0:x_val]\n        idx = np.where(valid_obs == 0, self.max_index, ind_tmp[ind, y_val, x_val])\n        return idx", "response": "Calculate the index of the chosen pixel based on the percentile of numpy stack and return the index of the chosen pixel."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _get_indices(self, data):\n        indices = self._index_by_percentile(data, self.percentile)\n        return indices", "response": "Compute indices along temporal dimension corresponding to the sought percentile\n           "}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncomputes composite array merging temporal frames according to the compositing method", "response": "def execute(self, eopatch):\n        \"\"\" Compute composite array merging temporal frames according to the compositing method\n\n            :param eopatch: eopatch holding time-series\n            :return: eopatch with composite image of time-series\n        \"\"\"\n        feature_type, feature_name = next(self.feature(eopatch))\n        data = eopatch[feature_type][feature_name].copy()\n\n        # compute band according to compositing method (e.g. blue, maxNDVI, maxNDWI)\n        reference_bands = self._get_reference_band(data)\n\n        # find temporal indices corresponding to pre-defined percentile\n        indices = self._get_indices(reference_bands)\n\n        # compute composite image selecting values along temporal dimension corresponding to percentile indices\n        composite_image = np.empty((data.shape[1:]), np.float32)\n        composite_image[:] = self.no_data_value\n        for scene_id, scene in enumerate(data):\n            composite_image = np.where(np.dstack([indices]) == scene_id, scene, composite_image)\n\n        eopatch[self.composite_type][self.composite_name] = composite_image\n\n        return eopatch"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nextract the NDVI band from time - series data", "response": "def _get_reference_band(self, data):\n        \"\"\" Extract the NDVI band from time-series\n\n        :param data: 4D array from which to compute the NDVI reference band\n        :type data: numpy array\n        :return: 3D array containing the NDVI reference band\n        \"\"\"\n        nir = data[..., self.nir_idx].astype(\"float32\")\n        red = data[..., self.red_idx].astype(\"float32\")\n        return (nir - red) / (nir + red)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nextract the NDWI band from time - series data", "response": "def _get_reference_band(self, data):\n        \"\"\" Extract the NDWI band from time-series\n\n        :param data: 4D array from which to compute the NDWI reference band\n        :type data: numpy array\n        :return: 3D array containing the NDWI reference band\n        \"\"\"\n        nir = data[..., self.nir_idx].astype(\"float32\")\n        swir1 = data[..., self.swir1_idx].astype(\"float32\")\n        return (nir - swir1) / (nir + swir1)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _get_reference_band(self, data):\n        blue = data[..., self.blue_idx].astype(\"float32\")\n        nir = data[..., self.nir_idx].astype(\"float32\")\n        swir1 = data[..., self.swir1_idx].astype(\"float32\")\n        return np.nanmax(np.array([nir, swir1]), axis=0) / blue", "response": "Extract the max - ratio band from time - series\n           "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nperforming histogram matching of the time - series with respect to a reference scene.", "response": "def execute(self, eopatch):\n        \"\"\" Perform histogram matching of the time-series with respect to a reference scene\n\n            :param eopatch: eopatch holding the time-series and reference data\n            :type eopatch: EOPatch\n            :return: The same eopatch instance with the normalised time-series\n        \"\"\"\n        feature_type, feature_name, new_feature_name = next(self.feature(eopatch))\n        reference_type, reference_name = next(self.reference(eopatch))\n\n        reference_scene = eopatch[reference_type][reference_name]\n        # check if band dimension matches\n        if reference_scene.shape[-1] != eopatch[feature_type][feature_name].shape[-1]:\n            raise ValueError('Time-series and reference scene must have corresponding bands')\n\n        eopatch[feature_type][new_feature_name] = np.zeros_like(eopatch[feature_type][feature_name])\n        for source_id, source in enumerate(eopatch[feature_type][feature_name]):\n            # mask-out same invalid pixels\n            src_masked = np.where(np.isnan(reference_scene), np.nan, source)\n            ref_masked = np.where(np.isnan(source), np.nan, reference_scene)\n            # compute statistics\n            std_ref = np.nanstd(ref_masked, axis=(0, 1), dtype=np.float64)\n            std_src = np.nanstd(src_masked, axis=(0, 1), dtype=np.float64)\n            mean_ref = np.nanmean(ref_masked, axis=(0, 1), dtype=np.float64)\n            mean_src = np.nanmean(src_masked, axis=(0, 1), dtype=np.float64)\n            # normalise values\n            eopatch[feature_type][new_feature_name][source_id] = \\\n                source * (std_ref / std_src) + (mean_ref - (mean_src * (std_ref / std_src)))\n\n        return eopatch"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncheck if the value fits the feature type and returns the corresponding object.", "response": "def _parse_feature_value(self, value):\r\n        \"\"\" Checks if value fits the feature type. If not it tries to fix it or raise an error\r\n\r\n        :raises: ValueError\r\n        \"\"\"\r\n        if isinstance(value, _FileLoader):\r\n            return value\r\n        if not hasattr(self, 'ndim'):  # Because of serialization/deserialization during multiprocessing\r\n            return value\r\n\r\n        if self.ndim:\r\n            if not isinstance(value, np.ndarray):\r\n                raise ValueError('{} feature has to be a numpy array'.format(self.feature_type))\r\n            if value.ndim != self.ndim:\r\n                raise ValueError('Numpy array of {} feature has to have {} '\r\n                                 'dimension{}'.format(self.feature_type, self.ndim, 's' if self.ndim > 1 else ''))\r\n\r\n            if self.feature_type.is_discrete():\r\n                if not issubclass(value.dtype.type, (np.integer, np.bool, np.bool_, np.bool8)):\r\n                    msg = '{} is a discrete feature type therefore dtype of data should be a subtype of ' \\\r\n                          'numpy.integer or numpy.bool, found type {}. In the future an error will be raised because' \\\r\n                          'of this'.format(self.feature_type, value.dtype.type)\r\n                    warnings.warn(msg, DeprecationWarning, stacklevel=3)\r\n\r\n                    # raise ValueError('{} is a discrete feature type therefore dtype of data has to be a subtype of '\r\n                    #                  'numpy.integer or numpy.bool, found type {}'.format(self.feature_type,\r\n                    #                                                                      value.dtype.type))\r\n            # This checking is disabled for now\r\n            # else:\r\n            #     if not issubclass(value.dtype.type, (np.floating, np.float)):\r\n            #         raise ValueError('{} is a floating feature type therefore dtype of data has to be a subtype of '\r\n            #                          'numpy.floating or numpy.float, found type {}'.format(self.feature_type,\r\n            #                                                                                value.dtype.type))\r\n            return value\r\n\r\n        if self.is_vector:\r\n            if isinstance(value, gpd.GeoSeries):\r\n                value = gpd.GeoDataFrame(dict(geometry=value), crs=value.crs)\r\n\r\n            if isinstance(value, gpd.GeoDataFrame):\r\n                if self.feature_type is FeatureType.VECTOR:\r\n                    if FeatureType.TIMESTAMP.value.upper() not in value:\r\n                        raise ValueError(\"{} feature has to contain a column 'TIMESTAMP' with \"\r\n                                         \"timestamps\".format(self.feature_type))\r\n\r\n                return value\r\n\r\n            raise ValueError('{} feature works with data of type {}, parsing data type {} is not supported'\r\n                             'given'.format(self.feature_type, gpd.GeoDataFrame.__name__, type(value)))\r\n\r\n        return value"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _correctly_load_bbox(bbox, path, is_zipped=False):\r\n        warnings.warn(\"Bounding box of your EOPatch is saved in old format which in the future won't be supported \"\r\n                      \"anymore. Please save bounding box again, you can overwrite the existing one\", DeprecationWarning,\r\n                      stacklevel=4)\r\n\r\n        with open(gzip.open(path) if is_zipped else path, 'rb') as pickle_file:\r\n            crs_cnt = -1\r\n            for _, arg, _ in pickletools.genops(pickle_file):\r\n                if arg == 'sentinelhub.constants CRS':\r\n                    crs_cnt = 2\r\n                if crs_cnt == 0:\r\n                    return sentinelhub.BBox(tuple(bbox), sentinelhub.CRS(arg))\r\n                crs_cnt -= 1\r\n\r\n        raise ValueError('Failed to correctly load BBox object, try downgrading sentinelhub package to <=2.4.7')", "response": "Load a pickled BBox object from a file."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef load(self):\r\n        # pylint: disable=too-many-return-statements\r\n        if not os.path.isdir(self.patch_path):\r\n            raise OSError('EOPatch does not exist in path {} anymore'.format(self.patch_path))\r\n\r\n        path = self.get_file_path()\r\n        if not os.path.exists(path):\r\n            raise OSError('Feature in path {} does not exist anymore'.format(path))\r\n\r\n        file_formats = FileFormat.split_by_extensions(path)[1:]\r\n\r\n        if not file_formats or file_formats[-1] is FileFormat.PICKLE:\r\n            with open(path, \"rb\") as infile:\r\n                data = pickle.load(infile)\r\n\r\n                if isinstance(data, sentinelhub.BBox) and not hasattr(data, 'crs'):\r\n                    return self._correctly_load_bbox(data, path)\r\n                return data\r\n\r\n        if file_formats[-1] is FileFormat.NPY:\r\n            if self.mmap:\r\n                return np.load(path, mmap_mode='r')\r\n            return np.load(path)\r\n\r\n        if file_formats[-1] is FileFormat.GZIP:\r\n            if file_formats[-2] is FileFormat.NPY:\r\n                return np.load(gzip.open(path))\r\n\r\n            if len(file_formats) == 1 or file_formats[-2] is FileFormat.PICKLE:\r\n                data = pickle.load(gzip.open(path))\r\n\r\n                if isinstance(data, sentinelhub.BBox) and not hasattr(data, 'crs'):\r\n                    return self._correctly_load_bbox(data, path, is_zipped=True)\r\n                return data\r\n\r\n        raise ValueError('Could not load data from unsupported file format {}'.format(file_formats[-1]))", "response": "Method which loads data from the file\r\n           "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_file_path(self, path):\r\n        feature_filename = self._get_filename_path(path)\r\n\r\n        feature_filename += self.file_format.extension()\r\n        if self.compress_level:\r\n            feature_filename += FileFormat.GZIP.extension()\r\n\r\n        return feature_filename", "response": "Returns a filename with file path"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef save(self, eopatch, use_tmp=True):\r\n        filename = self.tmp_filename if use_tmp else self.final_filename\r\n\r\n        if self.feature_name is None:\r\n            data = eopatch[self.feature_type]\r\n            if self.feature_type.has_dict():\r\n                data = data.get_dict()\r\n\r\n            if self.feature_type is FeatureType.BBOX:\r\n                data = tuple(data) + (int(data.crs.value),)\r\n        else:\r\n            data = eopatch[self.feature_type][self.feature_name]\r\n\r\n        file_dir = os.path.dirname(filename)\r\n        os.makedirs(file_dir, exist_ok=True)\r\n\r\n        if self.compress_level:\r\n            file_handle = gzip.GzipFile(filename, 'w', self.compress_level)\r\n        else:\r\n            file_handle = open(filename, 'wb')\r\n\r\n        with file_handle as outfile:\r\n            LOGGER.debug(\"Saving (%s, %s) to %s\", str(self.feature_type), str(self.feature_name), filename)\r\n\r\n            if self.file_format is FileFormat.NPY:\r\n                np.save(outfile, data)\r\n            elif self.file_format is FileFormat.PICKLE:\r\n                pickle.dump(data, outfile)\r\n            else:\r\n                ValueError('File {} was not saved because saving in file format {} is currently not '\r\n                           'supported'.format(filename, self.file_format))", "response": "Method which saves the data in the eopatch to the final location"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _mask_feature_data(feature_data, mask, mask_type):\n\n        if mask_type.is_spatial() and feature_data.shape[1: 3] != mask.shape[-3: -1]:\n            raise ValueError('Spatial dimensions of interpolation and mask feature do not match: '\n                             '{} {}'.format(feature_data.shape, mask.shape))\n\n        if mask_type.is_time_dependent() and feature_data.shape[0] != mask.shape[0]:\n            raise ValueError('Time dimension of interpolation and mask feature do not match: '\n                             '{} {}'.format(feature_data.shape, mask.shape))\n\n        # This allows masking each channel differently but causes some complications while masking with label\n        if mask.shape[-1] != feature_data.shape[-1]:\n            mask = mask[..., 0]\n\n        if mask_type is FeatureType.MASK:\n            feature_data[mask, ...] = np.nan\n\n        elif mask_type is FeatureType.MASK_TIMELESS:\n            feature_data[:, mask, ...] = np.nan\n\n        elif mask_type is FeatureType.LABEL:\n            np.swapaxes(feature_data, 1, 3)\n            feature_data[mask, ..., :, :] = np.nan\n            np.swapaxes(feature_data, 1, 3)\n\n        return feature_data", "response": "Masks data with a given mask of given mask type."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nfunctioning to find NaN values in data that start or end of time - series.", "response": "def _get_start_end_nans(data):\n        \"\"\" Find NaN values in data that either start or end the time-series\n\n        Function to return a binary array of same size as data where `True` values correspond to NaN values present at\n        beginning or end of time-series. NaNs internal to the time-series are not included in the binary mask.\n\n        :param data: Array of observations of size TxNOBS\n        :type data: numpy.array\n        :return: Binary array of shape TxNOBS. `True` values indicate NaNs present at beginning or end of time-series\n        :rtype: numpy.array\n        \"\"\"\n        # find NaNs that start a time-series\n        start_nan = np.isnan(data)\n        for idx, row in enumerate(start_nan[:-1]):\n            start_nan[idx + 1] = np.logical_and(row, start_nan[idx + 1])\n        # find NaNs that end a time-series\n        end_nan = np.isnan(data)\n        for idx, row in enumerate(end_nan[-2::-1]):\n            end_nan[-idx-2] = np.logical_and(row, end_nan[-idx-1])\n\n        return np.logical_or(start_nan, end_nan)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _get_unique_times(data, times):\n        seen = set()\n        duplicated_indices = np.array([idx for idx, item in enumerate(times) if item in seen or seen.add(item)],\n                                      dtype=int)\n        duplicated_times = np.unique(times[duplicated_indices])\n\n        for time in duplicated_times:\n            indices = np.where(times == time)[0]\n            nan_mask = np.all(np.isnan(data[indices]), axis=0)\n            data[indices[0], ~nan_mask] = np.nanmean(data[indices][:, ~nan_mask], axis=0)\n\n        times = np.delete(times, duplicated_indices, axis=0)\n        data = np.delete(data, duplicated_indices, axis=0)\n\n        return data, times", "response": "Replace duplicate acquisitions which have same values on the chosen time scale with their average."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _copy_old_features(new_eopatch, old_eopatch, copy_features):\n        if copy_features:\n            existing_features = set(new_eopatch.get_feature_list())\n\n            for copy_feature_type, copy_feature_name, copy_new_feature_name in copy_features:\n                new_feature = copy_feature_type, copy_new_feature_name\n\n                if new_feature in existing_features:\n                    raise ValueError('Feature {} of {} already exists in the new EOPatch! '\n                                     'Use a different name!'.format(copy_new_feature_name, copy_feature_type))\n                else:\n                    existing_features.add(new_feature)\n\n                    new_eopatch[copy_feature_type][copy_new_feature_name] = \\\n                        old_eopatch[copy_feature_type][copy_feature_name]\n\n        return new_eopatch", "response": "Copy features from old EOPatch to new EOPatch."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef interpolate_data(self, data, times, resampled_times):\n        # pylint: disable=too-many-locals\n        # get size of 2d array t x nobs\n        nobs = data.shape[-1]\n        if self.interpolate_pixel_wise:\n            # initialise array of interpolated values\n            new_data = data if self.resample_range is None else np.full(\n                (len(resampled_times), nobs),\n                np.nan, dtype=data.dtype)\n\n            # Interpolate for each pixel, could be easily parallelized\n            for obs in range(nobs):\n                valid = ~np.isnan(data[:, obs])\n\n                obs_interpolating_func = self.get_interpolation_function(times[valid], data[valid, obs])\n\n                new_data[:, obs] = obs_interpolating_func(resampled_times[:, np.newaxis])\n\n            # return interpolated values\n            return new_data\n\n        # mask representing overlap between reference and resampled times\n        time_mask = (resampled_times >= np.min(times)) & (resampled_times <= np.max(times))\n\n        # define time values as linear monotonically increasing over the observations\n        const = int(self.filling_factor * (np.max(times) - np.min(times)))\n        temp_values = (times[:, np.newaxis] +\n                       const * np.arange(nobs)[np.newaxis, :].astype(np.float64))\n        res_temp_values = (resampled_times[:, np.newaxis] +\n                           const * np.arange(nobs)[np.newaxis, :].astype(np.float64))\n\n        # initialise array of interpolated values\n        new_data = np.full((len(resampled_times), nobs), np.nan, dtype=data.dtype)\n\n        # array defining index correspondence between reference times and resampled times\n        ori2res = np.array([np.abs(resampled_times - o).argmin()\n                            if np.min(resampled_times) <= o <= np.max(resampled_times) else None for o in times])\n\n        # find NaNs that start or end a time-series\n        row_nans, col_nans = np.where(self._get_start_end_nans(data))\n        nan_row_res_indices = np.array([index for index in ori2res[row_nans] if index is not None], dtype=np.int32)\n        nan_col_res_indices = np.array([index is not None for index in ori2res[row_nans]],\n                                       dtype=np.bool)\n        if nan_row_res_indices.size:\n            # mask out from output values the starting/ending NaNs\n            res_temp_values[nan_row_res_indices, col_nans[nan_col_res_indices]] = np.nan\n        # if temporal values outside the reference dates are required (extrapolation) masked them to NaN\n        res_temp_values[~time_mask, :] = np.nan\n\n        # build 1d array for interpolation. Spline functions require monotonically increasing values of x,\n        # so .T is used\n        input_x = temp_values.T[~np.isnan(data).T]\n        input_y = data.T[~np.isnan(data).T]\n\n        # build interpolation function\n        if len(input_x) > 1:\n            interp_func = self.get_interpolation_function(input_x, input_y)\n\n            # interpolate non-NaN values in resampled time values\n            new_data[~np.isnan(res_temp_values)] = interp_func(res_temp_values[~np.isnan(res_temp_values)])\n\n        # return interpolated values\n        return new_data", "response": "Interpolates data feature containing the values of the specified time intervals."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ninitialize interpolation model :param times: Array of reference times in second relative to the first timestamp :type times: numpy.array :param series: One dimensional array of time series :type series: numpy.array :return: Initialized interpolation model class", "response": "def get_interpolation_function(self, times, series):\n        \"\"\" Initializes interpolation model\n\n        :param times: Array of reference times in second relative to the first timestamp\n        :type times: numpy.array\n        :param series: One dimensional array of time series\n        :type series: numpy.array\n        :return: Initialized interpolation model class\n        \"\"\"\n        return self.interpolation_object(times, series, **self.interpolation_parameters)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_resampled_timestamp(self, timestamp):\n        if self.resample_range is None:\n            return timestamp\n\n        if not isinstance(self.resample_range, (tuple, list)):\n            raise ValueError('Invalid resample_range {}, expected tuple'.format(self.resample_range))\n\n        if tuple(map(type, self.resample_range)) == (str, str, int):\n            start_date = dateutil.parser.parse(self.resample_range[0])\n            end_date = dateutil.parser.parse(self.resample_range[1])\n            step = dt.timedelta(days=self.resample_range[2])\n            days = [start_date]\n            while days[-1] + step < end_date:\n                days.append(days[-1] + step)\n\n        elif self.resample_range and np.all([isinstance(date, str) for date in self.resample_range]):\n            days = [dateutil.parser.parse(date) for date in self.resample_range]\n        elif self.resample_range and np.all([isinstance(date, dt.datetime) for date in self.resample_range]):\n            days = [date for date in self.resample_range]\n        else:\n            raise ValueError('Invalid format in {}, expected strings or datetimes'.format(self.resample_range))\n\n        return days", "response": "Takes a list of timestamps and generates a list of timestamps according to self. resample_range"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nexecuting method that processes an EOPatch and returns EOPatch object", "response": "def execute(self, eopatch):\n        \"\"\" Execute method that processes EOPatch and returns EOPatch\n        \"\"\"\n        # pylint: disable=too-many-locals\n        feature_type, feature_name, new_feature_name = next(self.feature(eopatch))\n\n        # Make a copy not to change original numpy array\n        feature_data = eopatch[feature_type][feature_name].copy()\n        time_num, height, width, band_num = feature_data.shape\n        if time_num <= 1:\n            raise ValueError('Feature {} has time dimension of size {}, required at least size '\n                             '2'.format((feature_type, feature_name), time_num))\n\n        # Apply a mask on data\n        if self.mask_feature is not None:\n            for mask_type, mask_name in self.mask_feature(eopatch):\n                negated_mask = ~eopatch[mask_type][mask_name].astype(np.bool)\n                feature_data = self._mask_feature_data(feature_data, negated_mask, mask_type)\n\n        # Flatten array\n        feature_data = np.reshape(feature_data, (time_num, height * width * band_num))\n\n        # If resampling create new EOPatch\n        new_eopatch = EOPatch() if self.resample_range else eopatch\n\n        # Resample times\n        times = eopatch.time_series(scale_time=self.scale_time)\n        new_eopatch.timestamp = self.get_resampled_timestamp(eopatch.timestamp)\n        total_diff = int((new_eopatch.timestamp[0].date() - eopatch.timestamp[0].date()).total_seconds())\n        resampled_times = new_eopatch.time_series(scale_time=self.scale_time) + total_diff // self.scale_time\n\n        # Add BBox to eopatch if it was created anew\n        if new_eopatch.bbox is None:\n            new_eopatch.bbox = eopatch.bbox\n\n        # Replace duplicate acquisitions which have same values on the chosen time scale with their average\n        feature_data, times = self._get_unique_times(feature_data, times)\n\n        # Interpolate\n        feature_data = self.interpolate_data(feature_data, times, resampled_times)\n\n        # Normalize\n        if self.result_interval:\n            min_val, max_val = self.result_interval\n            valid_mask = ~np.isnan(feature_data)\n            feature_data[valid_mask] = np.maximum(np.minimum(feature_data[valid_mask], max_val), min_val)\n\n        # Replace unknown value\n        if not np.isnan(self.unknown_value):\n            feature_data[np.isnan(feature_data)] = self.unknown_value\n\n        # Reshape back\n        new_eopatch[feature_type][new_feature_name] = np.reshape(feature_data,\n                                                                 (feature_data.shape[0], height, width, band_num))\n\n        # append features from old patch\n        new_eopatch = self._copy_old_features(new_eopatch, eopatch, self.copy_features)\n\n        return new_eopatch"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef interpolate_data(self, data, times, resampled_times):\n        if True in np.unique(np.isnan(data)):\n            raise ValueError('Data must not contain any masked/invalid pixels or NaN values')\n\n        interp_func = self.get_interpolation_function(times, data)\n\n        time_mask = (resampled_times >= np.min(times)) & (resampled_times <= np.max(times))\n        new_data = np.full((resampled_times.size,) + data.shape[1:], np.nan, dtype=data.dtype)\n        new_data[time_mask] = interp_func(resampled_times[time_mask])\n        return new_data", "response": "Interpolates data feature by time."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_interpolation_function(self, times, data):\n        return self.interpolation_object(times, data, axis=0, **self.interpolation_parameters)", "response": "Initializes interpolation model\n\n        :param times: Array of reference times in second relative to the first timestamp\n        :type times: numpy.array\n        :param data: One dimensional array of time series\n        :type data: numpy.array\n        :return: Initialized interpolation model class"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_text(element):\n    ''' return inner text in pyquery element '''\n    _add_links_to_text(element)\n    try:\n        return element.text(squash_space=False)\n    except TypeError:\n        return element.text()", "response": "Get inner text in pyquery element"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef download_file(url, local_filename):\n    local_filename = os.path.abspath(local_filename)\n    path = os.path.dirname(local_filename)\n    if not os.path.isdir(path):\n        os.makedirs(path)\n\n    with tqdm(unit='B', unit_scale=True) as progress:\n        def report(chunk, chunksize, total):\n            progress.total = total\n            progress.update(chunksize)\n        return urlretrieve(url, local_filename, reporthook=report)", "response": "Download a file from url to local_filename"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ntries to find GCC on OSX for OpenMP support.", "response": "def extract_gcc_binaries():\n    \"\"\"Try to find GCC on OSX for OpenMP support.\"\"\"\n    patterns = ['/opt/local/bin/g++-mp-[0-9].[0-9]',\n                '/opt/local/bin/g++-mp-[0-9]',\n                '/usr/local/bin/g++-[0-9].[0-9]',\n                '/usr/local/bin/g++-[0-9]']\n    if 'darwin' in platform.platform().lower():\n        gcc_binaries = []\n        for pattern in patterns:\n            gcc_binaries += glob.glob(pattern)\n        gcc_binaries.sort()\n        if gcc_binaries:\n            _, gcc = os.path.split(gcc_binaries[-1])\n            return gcc\n        else:\n            return None\n    else:\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_gcc():\n    # For macports and homebrew\n\n    if 'darwin' in platform.platform().lower():\n        gcc = extract_gcc_binaries()\n\n        if gcc is not None:\n            os.environ[\"CC\"] = gcc\n            os.environ[\"CXX\"] = gcc\n\n        else:\n            global use_openmp\n            use_openmp = False\n            logging.warning('No GCC available. Install gcc from Homebrew '\n                            'using brew install gcc.')", "response": "Try to use GCC on OS X for OpenMP support."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the non zeroes of a row in csr_matrix", "response": "def nonzeros(m, row):\n    \"\"\" returns the non zeroes of a row in csr_matrix \"\"\"\n    for index in range(m.indptr[row], m.indptr[row+1]):\n        yield m.indices[index], m.data[index]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef check_blas_config():\n    # don't warn repeatedly\n    global _checked_blas_config\n    if _checked_blas_config:\n        return\n    _checked_blas_config = True\n\n    if np.__config__.get_info('openblas_info') and os.environ.get('OPENBLAS_NUM_THREADS') != '1':\n        logging.warning(\"OpenBLAS detected. Its highly recommend to set the environment variable \"\n                        \"'export OPENBLAS_NUM_THREADS=1' to disable its internal multithreading\")\n    if np.__config__.get_info('blas_mkl_info') and os.environ.get('MKL_NUM_THREADS') != '1':\n        logging.warning(\"Intel MKL BLAS detected. Its highly recommend to set the environment \"\n                        \"variable 'export MKL_NUM_THREADS=1' to disable its internal \"\n                        \"multithreading\")", "response": "checks to see if we are using OpenBlas and Intel MKL and if so warns if the number of threads isn t set to 1"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _read_dataframe(filename):\n    import pandas\n\n    # read in triples of user/artist/playcount from the input dataset\n    # get a model based off the input params\n    start = time.time()\n    log.debug(\"reading data from %s\", filename)\n    data = pandas.read_csv(filename, delimiter='|', quotechar='\\\\')\n\n    # map each artist and user to a unique numeric value\n    data['uid'] = data['uid'].astype(\"category\")\n    data['mid'] = data['mid'].astype(\"category\")\n\n    # store as a CSR matrix\n    log.debug(\"read data file in %s\", time.time() - start)\n    return data", "response": "Reads the original dataset PSV as a pandas dataframe"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the lastfm dataset downloaded locally if necessary.", "response": "def get_lastfm():\n    \"\"\" Returns the lastfm360k dataset, downloading locally if necessary.\n    Returns a tuple of (artistids, userids, plays) where plays is a CSR matrix \"\"\"\n\n    filename = os.path.join(_download.LOCAL_CACHE_DIR, \"lastfm_360k.hdf5\")\n    if not os.path.isfile(filename):\n        log.info(\"Downloading dataset to '%s'\", filename)\n        _download.download_file(URL, filename)\n    else:\n        log.info(\"Using cached dataset at '%s'\", filename)\n\n    with h5py.File(filename, 'r') as f:\n        m = f.get('artist_user_plays')\n        plays = csr_matrix((m.get('data'), m.get('indices'), m.get('indptr')))\n        return np.array(f['artist']), np.array(f['user']), plays"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef alternating_least_squares(Ciu, factors, **kwargs):\n    log.warning(\"This method is deprecated. Please use the AlternatingLeastSquares\"\n                \" class instead\")\n\n    model = AlternatingLeastSquares(factors=factors, **kwargs)\n    model.fit(Ciu)\n    return model.item_factors, model.user_factors", "response": "factorizes the matrix Cui using an implicit alternating least squares algorithm"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncalculates factors Xu for each user in Cui using least squares on Y.", "response": "def least_squares(Cui, X, Y, regularization, num_threads=0):\n    \"\"\" For each user in Cui, calculate factors Xu for them\n    using least squares on Y.\n\n    Note: this is at least 10 times slower than the cython version included\n    here.\n    \"\"\"\n    users, n_factors = X.shape\n    YtY = Y.T.dot(Y)\n\n    for u in range(users):\n        X[u] = user_factor(Y, YtY, Cui, u, regularization, n_factors)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef fit(self, item_users, show_progress=True):\n        Ciu = item_users\n        if not isinstance(Ciu, scipy.sparse.csr_matrix):\n            s = time.time()\n            log.debug(\"Converting input to CSR format\")\n            Ciu = Ciu.tocsr()\n            log.debug(\"Converted input to CSR in %.3fs\", time.time() - s)\n\n        if Ciu.dtype != np.float32:\n            Ciu = Ciu.astype(np.float32)\n\n        s = time.time()\n        Cui = Ciu.T.tocsr()\n        log.debug(\"Calculated transpose in %.3fs\", time.time() - s)\n\n        items, users = Ciu.shape\n\n        s = time.time()\n        # Initialize the variables randomly if they haven't already been set\n        if self.user_factors is None:\n            self.user_factors = np.random.rand(users, self.factors).astype(self.dtype) * 0.01\n        if self.item_factors is None:\n            self.item_factors = np.random.rand(items, self.factors).astype(self.dtype) * 0.01\n\n        log.debug(\"Initialized factors in %s\", time.time() - s)\n\n        # invalidate cached norms and squared factors\n        self._item_norms = None\n        self._YtY = None\n\n        if self.use_gpu:\n            return self._fit_gpu(Ciu, Cui, show_progress)\n\n        solver = self.solver\n\n        log.debug(\"Running %i ALS iterations\", self.iterations)\n        with tqdm.tqdm(total=self.iterations, disable=not show_progress) as progress:\n            # alternate between learning the user_factors from the item_factors and vice-versa\n            for iteration in range(self.iterations):\n                s = time.time()\n                solver(Cui, self.user_factors, self.item_factors, self.regularization,\n                       num_threads=self.num_threads)\n                progress.update(.5)\n\n                solver(Ciu, self.item_factors, self.user_factors, self.regularization,\n                       num_threads=self.num_threads)\n                progress.update(.5)\n\n                if self.calculate_training_loss:\n                    loss = _als.calculate_loss(Cui, self.user_factors, self.item_factors,\n                                               self.regularization, num_threads=self.num_threads)\n                    progress.set_postfix({\"loss\": loss})\n\n                if self.fit_callback:\n                    self.fit_callback(iteration, time.time() - s)\n\n        if self.calculate_training_loss:\n            log.info(\"Final training loss %.4f\", loss)", "response": "Fits the latent factor model of the input data."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _fit_gpu(self, Ciu_host, Cui_host, show_progress=True):\n        if not implicit.cuda.HAS_CUDA:\n            raise ValueError(\"No CUDA extension has been built, can't train on GPU.\")\n\n        if self.dtype == np.float64:\n            log.warning(\"Factors of dtype float64 aren't supported with gpu fitting. \"\n                        \"Converting factors to float32\")\n            self.item_factors = self.item_factors.astype(np.float32)\n            self.user_factors = self.user_factors.astype(np.float32)\n\n        Ciu = implicit.cuda.CuCSRMatrix(Ciu_host)\n        Cui = implicit.cuda.CuCSRMatrix(Cui_host)\n        X = implicit.cuda.CuDenseMatrix(self.user_factors.astype(np.float32))\n        Y = implicit.cuda.CuDenseMatrix(self.item_factors.astype(np.float32))\n\n        solver = implicit.cuda.CuLeastSquaresSolver(self.factors)\n        log.debug(\"Running %i ALS iterations\", self.iterations)\n        with tqdm.tqdm(total=self.iterations, disable=not show_progress) as progress:\n            for iteration in range(self.iterations):\n                s = time.time()\n                solver.least_squares(Cui, X, Y, self.regularization, self.cg_steps)\n                progress.update(.5)\n                solver.least_squares(Ciu, Y, X, self.regularization, self.cg_steps)\n                progress.update(.5)\n\n                if self.fit_callback:\n                    self.fit_callback(iteration, time.time() - s)\n\n                if self.calculate_training_loss:\n                    loss = solver.calculate_loss(Cui, X, Y, self.regularization)\n                    progress.set_postfix({\"loss\": loss})\n\n        if self.calculate_training_loss:\n            log.info(\"Final training loss %.4f\", loss)\n\n        X.to_host(self.user_factors)\n        Y.to_host(self.item_factors)", "response": "Fits the GPU on the GPU."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef explain(self, userid, user_items, itemid, user_weights=None, N=10):\n        # user_weights = Cholesky decomposition of Wu^-1\n        # from section 5 of the paper CF for Implicit Feedback Datasets\n        user_items = user_items.tocsr()\n        if user_weights is None:\n            A, _ = user_linear_equation(self.item_factors, self.YtY,\n                                        user_items, userid,\n                                        self.regularization, self.factors)\n            user_weights = scipy.linalg.cho_factor(A)\n        seed_item = self.item_factors[itemid]\n\n        # weighted_item = y_i^t W_u\n        weighted_item = scipy.linalg.cho_solve(user_weights, seed_item)\n\n        total_score = 0.0\n        h = []\n        for i, (itemid, confidence) in enumerate(nonzeros(user_items, userid)):\n            if confidence < 0:\n                continue\n\n            factor = self.item_factors[itemid]\n            # s_u^ij = (y_i^t W^u) y_j\n            score = weighted_item.dot(factor) * confidence\n            total_score += score\n            contribution = (score, itemid)\n            if i < N:\n                heapq.heappush(h, contribution)\n            else:\n                heapq.heappushpop(h, contribution)\n\n        items = (heapq.heappop(h) for i in range(len(h)))\n        top_contributions = list((i, s) for s, i in items)[::-1]\n        return total_score, top_contributions, user_weights", "response": "Provides explanations for why the item is liked by the user."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef augment_inner_product_matrix(factors):\n    norms = numpy.linalg.norm(factors, axis=1)\n    max_norm = norms.max()\n\n    # add an extra dimension so that the norm of each row is the same\n    # (max_norm)\n    extra_dimension = numpy.sqrt(max_norm ** 2 - norms ** 2)\n    return max_norm, numpy.append(factors, extra_dimension.reshape(norms.shape[0], 1), axis=1)", "response": "This function transforms a factor matrix such that an angular nearest neighbours search\n    will return the top related items of the inner product."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconvert a scipy sparse matrix to a spark dataframe", "response": "def convert_sparse_to_dataframe(spark, context, sparse_matrix):\n    \"\"\" Converts a scipy sparse matrix to a spark dataframe \"\"\"\n    m = sparse_matrix.tocoo()\n    data = context.parallelize(numpy.array([m.row, m.col, m.data]).T,\n                               numSlices=len(m.row)/1024)\n    return spark.createDataFrame(data.map(lambda p: Row(row=int(p[0]),\n                                                        col=int(p[1]),\n                                                        data=float(p[2]))))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef generate_dataset(triplets_filename, summary_filename=\"msd_summary_file.h5\",\n                     outputfilename=\"msd_taste_profile.hdf5\"):\n    \"\"\" Generates a hdf5 datasetfile from the raw datafiles:\n\n    You will need to download the train_triplets from here:\n        https://labrosa.ee.columbia.edu/millionsong/tasteprofile#getting\n    And the 'Summary File of the whole dataset' from here\n    https://labrosa.ee.columbia.edu/millionsong/pages/getting-dataset\n\n    You shouldn't have to run this yourself, and can instead just download the\n    output using the 'get_msd_taste_profile' funciton\n    \"\"\"\n    data = _read_triplets_dataframe(triplets_filename)\n    track_info = _join_summary_file(data, summary_filename)\n\n    _hfd5_from_dataframe(data, track_info, outputfilename)", "response": "Generates a hdf5 datasetfile from the raw datafiles"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nread the original dataset TSV as a pandas dataframe", "response": "def _read_triplets_dataframe(filename):\n    \"\"\" Reads the original dataset TSV as a pandas dataframe \"\"\"\n    # delay importing this to avoid another dependency\n    import pandas\n\n    # read in triples of user/artist/playcount from the input dataset\n    # get a model based off the input params\n    start = time.time()\n    log.debug(\"reading data from %s\", filename)\n    data = pandas.read_table(\"train_triplets.txt\", names=['user', 'track', 'plays'])\n\n    # map each artist and user to a unique numeric value\n    data['user'] = data['user'].astype(\"category\")\n    data['track'] = data['track'].astype(\"category\")\n\n    # store as a CSR matrix\n    log.debug(\"read data file in %s\", time.time() - start)\n\n    return data"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the trackinfo array by joining taste profile to the track summary file", "response": "def _join_summary_file(data, summary_filename=\"msd_summary_file.h5\"):\n    \"\"\" Gets the trackinfo array by joining taste profile to the track summary file \"\"\"\n    msd = h5py.File(summary_filename)\n\n    # create a lookup table of trackid -> position\n    track_lookup = dict((t.encode(\"utf8\"), i) for i, t in enumerate(data['track'].cat.categories))\n\n    # join on trackid to the summary file to get the artist/album/songname\n    track_info = np.empty(shape=(len(track_lookup), 4), dtype=np.object)\n    with tqdm.tqdm(total=len(track_info)) as progress:\n        for song in msd['metadata']['songs']:\n            trackid = song[17]\n            if trackid in track_lookup:\n                pos = track_lookup[trackid]\n                track_info[pos] = [x.decode(\"utf8\") for x in (trackid, song[9], song[14], song[18])]\n                progress.update(1)\n\n    return track_info"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef tfidf_weight(X):\n    X = coo_matrix(X)\n\n    # calculate IDF\n    N = float(X.shape[0])\n    idf = log(N) - log1p(bincount(X.col))\n\n    # apply TF-IDF adjustment\n    X.data = sqrt(X.data) * idf[X.col]\n    return X", "response": "Weights a Sparse Matrix by TF - IDF Weighted"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef normalize(X):\n    X = coo_matrix(X)\n    X.data = X.data / sqrt(bincount(X.row, X.data ** 2))[X.row]\n    return X", "response": "normalize matrix X to be a sparse matrix"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nweighing each row of a sparse matrix X by BM25 weighting", "response": "def bm25_weight(X, K1=100, B=0.8):\n    \"\"\" Weighs each row of a sparse matrix X  by BM25 weighting \"\"\"\n    # calculate idf per term (user)\n    X = coo_matrix(X)\n\n    N = float(X.shape[0])\n    idf = log(N) - log1p(bincount(X.col))\n\n    # calculate length_norm per document (artist)\n    row_sums = numpy.ravel(X.sum(axis=1))\n    average_length = row_sums.mean()\n    length_norm = (1.0 - B) + B * row_sums / average_length\n\n    # weight matrix rows by bm25\n    X.data = X.data * (K1 + 1.0) / (K1 * length_norm[X.row] + X.data) * idf[X.col]\n    return X"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncompute and stores the similarity matrix", "response": "def fit(self, weighted, show_progress=True):\n        \"\"\" Computes and stores the similarity matrix \"\"\"\n        self.similarity = all_pairs_knn(weighted, self.K,\n                                        show_progress=show_progress,\n                                        num_threads=self.num_threads).tocsr()\n        self.scorer = NearestNeighboursScorer(self.similarity)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the best N recommendations for a user given its id", "response": "def recommend(self, userid, user_items,\n                  N=10, filter_already_liked_items=True, filter_items=None, recalculate_user=False):\n        \"\"\" returns the best N recommendations for a user given its id\"\"\"\n        if userid >= user_items.shape[0]:\n            raise ValueError(\"userid is out of bounds of the user_items matrix\")\n\n        # recalculate_user is ignored because this is not a model based algorithm\n        items = N\n        if filter_items:\n            items += len(filter_items)\n\n        indices, data = self.scorer.recommend(userid, user_items.indptr, user_items.indices,\n                                              user_items.data, K=items,\n                                              remove_own_likes=filter_already_liked_items)\n        best = sorted(zip(indices, data), key=lambda x: -x[1])\n\n        if not filter_items:\n            return best\n\n        liked = set(filter_items)\n        return list(itertools.islice((rec for rec in best if rec[0] not in liked), N))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nranking given items for a user and returns sorted item list", "response": "def rank_items(self, userid, user_items, selected_items, recalculate_user=False):\n        \"\"\" Rank given items for a user and returns sorted item list \"\"\"\n        # check if selected_items contains itemids that are not in the model(user_items)\n        if max(selected_items) >= user_items.shape[1] or min(selected_items) < 0:\n            raise IndexError(\"Some of selected itemids are not in the model\")\n\n        # calculate the relevance scores\n        liked_vector = user_items[userid]\n        recommendations = liked_vector.dot(self.similarity)\n\n        # remove items that are not in the selected_items\n        best = sorted(zip(recommendations.indices, recommendations.data), key=lambda x: -x[1])\n        ret = [rec for rec in best if rec[0] in selected_items]\n\n        # returned items should be equal to input selected items\n        for itemid in selected_items:\n            if itemid not in recommendations.indices:\n                ret.append((itemid, -1.0))\n        return ret"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef similar_items(self, itemid, N=10):\n        if itemid >= self.similarity.shape[0]:\n            return []\n\n        return sorted(list(nonzeros(self.similarity, itemid)), key=lambda x: -x[1])[:N]", "response": "Returns a list of the most similar items"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_reddit():\n\n    filename = os.path.join(_download.LOCAL_CACHE_DIR, \"reddit.hdf5\")\n    if not os.path.isfile(filename):\n        log.info(\"Downloading dataset to '%s'\", filename)\n        _download.download_file(URL, filename)\n    else:\n        log.info(\"Using cached dataset at '%s'\", filename)\n\n    with h5py.File(filename, 'r') as f:\n        m = f.get('item_user_ratings')\n        return csr_matrix((m.get('data'), m.get('indices'), m.get('indptr')))", "response": "Returns the reddit dataset downloaded locally if necessary."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreading the original dataset TSV as a pandas dataframe", "response": "def _read_dataframe(filename):\n    \"\"\" Reads the original dataset TSV as a pandas dataframe \"\"\"\n    # delay importing this to avoid another dependency\n    import pandas\n\n    # read in triples of user/artist/playcount from the input dataset\n    # get a model based off the input params\n    start = time.time()\n    log.debug(\"reading data from %s\", filename)\n    data = pandas.read_table(filename, usecols=[0, 1, 3], names=['user', 'item', 'rating'])\n\n    # map each artist and user to a unique numeric value\n    data['user'] = data['user'].astype(\"category\")\n    data['item'] = data['item'].astype(\"category\")\n\n    # store as a CSR matrix\n    log.debug(\"read data file in %s\", time.time() - start)\n    return data"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_movielens(variant=\"20m\"):\n    filename = \"movielens_%s.hdf5\" % variant\n\n    path = os.path.join(_download.LOCAL_CACHE_DIR, filename)\n    if not os.path.isfile(path):\n        log.info(\"Downloading dataset to '%s'\", path)\n        _download.download_file(URL_BASE + filename, path)\n    else:\n        log.info(\"Using cached dataset at '%s'\", path)\n\n    with h5py.File(path, 'r') as f:\n        m = f.get('movie_user_ratings')\n        plays = csr_matrix((m.get('data'), m.get('indices'), m.get('indptr')))\n        return np.array(f['movie']), plays", "response": "Gets the movielens datasets for a given variant."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngenerating a hdf5 movielens datasetfile from the raw datafiles found at path.", "response": "def generate_dataset(path, variant='20m', outputpath=\".\"):\n    \"\"\" Generates a hdf5 movielens datasetfile from the raw datafiles found at:\n    https://grouplens.org/datasets/movielens/20m/\n\n    You shouldn't have to run this yourself, and can instead just download the\n    output using the 'get_movielens' funciton./\n    \"\"\"\n    filename = os.path.join(outputpath, \"movielens_%s.hdf5\" % variant)\n\n    if variant == '20m':\n        ratings, movies = _read_dataframes_20M(path)\n    elif variant == '100k':\n        ratings, movies = _read_dataframes_100k(path)\n    else:\n        ratings, movies = _read_dataframes(path)\n\n    _hfd5_from_dataframe(ratings, movies, filename)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nread in the ratings and movies 20M", "response": "def _read_dataframes_20M(path):\n    \"\"\" reads in the movielens 20M\"\"\"\n    import pandas\n\n    ratings = pandas.read_csv(os.path.join(path, \"ratings.csv\"))\n    movies = pandas.read_csv(os.path.join(path, \"movies.csv\"))\n\n    return ratings, movies"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _read_dataframes_100k(path):\n    import pandas\n\n    ratings = pandas.read_table(os.path.join(path, \"u.data\"),\n                                names=['userId', 'movieId', 'rating', 'timestamp'])\n\n    movies = pandas.read_csv(os.path.join(path, \"u.item\"),\n                             names=['movieId', 'title'],\n                             usecols=[0, 1],\n                             delimiter='|',\n                             encoding='ISO-8859-1')\n\n    return ratings, movies", "response": "reads in the movielens 100k dataset"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nrecommending items for a user Calculates the N best recommendations for a user, and returns a list of itemids, score. Parameters ---------- userid : int The userid to calculate recommendations for user_items : csr_matrix A sparse matrix of shape (number_users, number_items). This lets us look up the liked items and their weights for the user. This is used to filter out items that have already been liked from the output, and to also potentially calculate the best items for this user. N : int, optional The number of results to return filter_items : sequence of ints, optional List of extra item ids to filter out from the output recalculate_user : bool, optional When true, don't rely on stored user state and instead recalculate from the passed in user_items Returns ------- list List of (itemid, score) tuples", "response": "def recommend(self, userid, user_items,\n                  N=10, filter_already_liked_items=True, filter_items=None, recalculate_user=False):\n        \"\"\"\n        Recommends items for a user\n\n        Calculates the N best recommendations for a user, and returns a list of itemids, score.\n\n        Parameters\n        ----------\n        userid : int\n            The userid to calculate recommendations for\n        user_items : csr_matrix\n            A sparse matrix of shape (number_users, number_items). This lets us look\n            up the liked items and their weights for the user. This is used to filter out\n            items that have already been liked from the output, and to also potentially\n            calculate the best items for this user.\n        N : int, optional\n            The number of results to return\n        filter_items : sequence of ints, optional\n            List of extra item ids to filter out from the output\n        recalculate_user : bool, optional\n            When true, don't rely on stored user state and instead recalculate from the\n            passed in user_items\n\n        Returns\n        -------\n        list\n            List of (itemid, score) tuples\n        \"\"\"\n        pass"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef find_in_path(name, path):\n    \"Find a file in a search path\"\n    # adapted fom http://code.activestate.com/recipes/52224-find-a-file-given-a-search-path/\n    for dir in path.split(os.pathsep):\n        binpath = os.path.join(dir, name)\n        if os.path.exists(binpath):\n            return os.path.abspath(binpath)\n    return None", "response": "Find a file in a search path"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef locate_cuda():\n    nvcc_bin = 'nvcc'\n    if sys.platform.startswith(\"win\"):\n        nvcc_bin = 'nvcc.exe'\n\n    # first check if the CUDAHOME env variable is in use\n    if 'CUDAHOME' in os.environ:\n        home = os.environ['CUDAHOME']\n        nvcc = os.path.join(home, 'bin', nvcc_bin)\n    elif 'CUDA_PATH' in os.environ:\n        home = os.environ['CUDA_PATH']\n        nvcc = os.path.join(home, 'bin', nvcc_bin)\n    else:\n        # otherwise, search the PATH for NVCC\n        nvcc = find_in_path(nvcc_bin, os.environ['PATH'])\n        if nvcc is None:\n            logging.warning('The nvcc binary could not be located in your $PATH. Either add it to '\n                            'your path, or set $CUDAHOME to enable CUDA extensions')\n            return None\n        home = os.path.dirname(os.path.dirname(nvcc))\n\n    cudaconfig = {'home': home,\n                  'nvcc': nvcc,\n                  'include': os.path.join(home, 'include'),\n                  'lib64':   os.path.join(home, 'lib64')}\n    post_args = ['-gencode=arch=compute_30,code=sm_30',\n                 '-gencode=arch=compute_50,code=sm_50',\n                 '-gencode=arch=compute_60,code=sm_60',\n                 '-gencode=arch=compute_60,code=compute_60',\n                 '--ptxas-options=-v', '-O2']\n\n    if sys.platform == \"win32\":\n        cudaconfig['lib64'] = os.path.join(home, 'lib', 'x64')\n        post_args += ['-Xcompiler', '/MD']\n    else:\n        post_args += ['-c', '--compiler-options', \"'-fPIC'\"]\n\n    for k, v in cudaconfig.items():\n        if not os.path.exists(v):\n            logging.warning('The CUDA %s path could not be located in %s', k, v)\n            return None\n\n    cudaconfig['post_args'] = post_args\n    return cudaconfig", "response": "Locate the cuda installation on the system and return a dict with keys home nvcc include and lib64 and values giving the absolute path to each directory."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngenerating a list of similar artists in lastfm by utiliizing the similar_items API of the models.", "response": "def calculate_similar_artists(output_filename, model_name=\"als\"):\n    \"\"\" generates a list of similar artists in lastfm by utiliizing the 'similar_items'\n    api of the models \"\"\"\n    artists, users, plays = get_lastfm()\n\n    # create a model from the input data\n    model = get_model(model_name)\n\n    # if we're training an ALS based model, weight input for last.fm\n    # by bm25\n    if issubclass(model.__class__, AlternatingLeastSquares):\n        # lets weight these models by bm25weight.\n        logging.debug(\"weighting matrix by bm25_weight\")\n        plays = bm25_weight(plays, K1=100, B=0.8)\n\n        # also disable building approximate recommend index\n        model.approximate_recommend = False\n\n    # this is actually disturbingly expensive:\n    plays = plays.tocsr()\n\n    logging.debug(\"training model %s\", model_name)\n    start = time.time()\n    model.fit(plays)\n    logging.debug(\"trained model '%s' in %0.2fs\", model_name, time.time() - start)\n\n    # write out similar artists by popularity\n    start = time.time()\n    logging.debug(\"calculating top artists\")\n\n    user_count = np.ediff1d(plays.indptr)\n    to_generate = sorted(np.arange(len(artists)), key=lambda x: -user_count[x])\n\n    # write out as a TSV of artistid, otherartistid, score\n    logging.debug(\"writing similar items\")\n    with tqdm.tqdm(total=len(to_generate)) as progress:\n        with codecs.open(output_filename, \"w\", \"utf8\") as o:\n            for artistid in to_generate:\n                artist = artists[artistid]\n                for other, score in model.similar_items(artistid, 11):\n                    o.write(\"%s\\t%s\\t%s\\n\" % (artist, artists[other], score))\n                progress.update(1)\n\n    logging.debug(\"generated similar artists in %0.2fs\",  time.time() - start)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef calculate_recommendations(output_filename, model_name=\"als\"):\n    # train the model based off input params\n    artists, users, plays = get_lastfm()\n\n    # create a model from the input data\n    model = get_model(model_name)\n\n    # if we're training an ALS based model, weight input for last.fm\n    # by bm25\n    if issubclass(model.__class__, AlternatingLeastSquares):\n        # lets weight these models by bm25weight.\n        logging.debug(\"weighting matrix by bm25_weight\")\n        plays = bm25_weight(plays, K1=100, B=0.8)\n\n        # also disable building approximate recommend index\n        model.approximate_similar_items = False\n\n    # this is actually disturbingly expensive:\n    plays = plays.tocsr()\n\n    logging.debug(\"training model %s\", model_name)\n    start = time.time()\n    model.fit(plays)\n    logging.debug(\"trained model '%s' in %0.2fs\", model_name, time.time() - start)\n\n    # generate recommendations for each user and write out to a file\n    start = time.time()\n    user_plays = plays.T.tocsr()\n    with tqdm.tqdm(total=len(users)) as progress:\n        with codecs.open(output_filename, \"w\", \"utf8\") as o:\n            for userid, username in enumerate(users):\n                for artistid, score in model.recommend(userid, user_plays):\n                    o.write(\"%s\\t%s\\t%s\\n\" % (username, artists[artistid], score))\n                progress.update(1)\n    logging.debug(\"generated recommendations in %0.2fs\",  time.time() - start)", "response": "Generates artist recommendations for each user in the dataset."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef ion_or_solid_comp_object(formula):\n    m = re.search(r\"\\[([^\\[\\]]+)\\]|\\(aq\\)\", formula)\n    if m:\n        comp_obj = Ion.from_formula(formula)\n    elif re.search(r\"\\(s\\)\", formula):\n        comp_obj = Composition(formula[:-3])\n    else:\n        comp_obj = Composition(formula)\n    return comp_obj", "response": "Returns either an ion object given\n    a formula."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ngenerate a label for the pourbaix plotter", "response": "def generate_entry_label(entry):\n    \"\"\"\n    Generates a label for the pourbaix plotter\n\n    Args:\n        entry (PourbaixEntry or MultiEntry): entry to get a label for\n    \"\"\"\n    if isinstance(entry, MultiEntry):\n        return \" + \".join([latexify_ion(e.name) for e in entry.entry_list])\n    else:\n        return latexify_ion(latexify(entry.name))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef energy_at_conditions(self, pH, V):\n        return self.energy + self.npH * PREFAC * pH + self.nPhi * V", "response": "Returns the free energy at a given pH and voltage"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the energy at an electrochemical condition normalized by number of non - O atoms at the given conditions.", "response": "def normalized_energy_at_conditions(self, pH, V):\n        \"\"\"\n        Energy at an electrochemical condition, compatible with\n        numpy arrays for pH/V input\n\n        Args:\n            pH (float): pH at condition\n            V (float): applied potential at condition\n\n        Returns:\n            energy normalized by number of non-O/H atoms at condition\n        \"\"\"\n        return self.energy_at_conditions(pH, V) * self.normalization_factor"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a dictionary which contains the Pourbaix Entry data.", "response": "def as_dict(self):\n        \"\"\"\n        Returns dict which contains Pourbaix Entry data.\n        Note that the pH, voltage, H2O factors are always calculated when\n        constructing a PourbaixEntry object.\n        \"\"\"\n        d = {\"@module\": self.__class__.__module__,\n             \"@class\": self.__class__.__name__}\n        if isinstance(self.entry, IonEntry):\n            d[\"entry_type\"] = \"Ion\"\n        else:\n            d[\"entry_type\"] = \"Solid\"\n        d[\"entry\"] = self.entry.as_dict()\n        d[\"concentration\"] = self.concentration\n        d[\"entry_id\"] = self.entry_id\n        return d"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating a new entry from a dictionary.", "response": "def from_dict(cls, d):\n        \"\"\"\n        Invokes\n        \"\"\"\n        entry_type = d[\"entry_type\"]\n        if entry_type == \"Ion\":\n            entry = IonEntry.from_dict(d[\"entry\"])\n        else:\n            entry = PDEntry.from_dict(d[\"entry\"])\n        entry_id = d[\"entry_id\"]\n        concentration = d[\"concentration\"]\n        return PourbaixEntry(entry, entry_id, concentration)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef normalization_factor(self):\n        return 1.0 / (self.num_atoms - self.composition.get('H', 0)\n                      - self.composition.get('O', 0))", "response": "Returns the normalization factor of the current locale."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef from_dict(cls, d):\n        return IonEntry(Ion.from_dict(d[\"ion\"]), d[\"energy\"], d.get(\"name\", None))", "response": "Returns an IonEntry object from a dict."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef as_dict(self):\n        d = {\"ion\": self.ion.as_dict(), \"energy\": self.energy,\n             \"name\": self.name}\n        return d", "response": "Creates a dict of composition energy ion name\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _generate_multielement_entries(self, entries, forced_include=None,\n                                       nproc=None):\n        \"\"\"\n        Create entries for multi-element Pourbaix construction.\n\n        This works by finding all possible linear combinations\n        of entries that can result in the specified composition\n        from the initialized comp_dict.\n\n        Args:\n            entries ([PourbaixEntries]): list of pourbaix entries\n                to process into MultiEntries\n            forced_include ([PourbaixEntries]) list of pourbaix entries\n                that must be included in multielement entries\n            nproc (int): number of processes to be used in parallel\n                treatment of entry combos\n        \"\"\"\n        N = len(self._elt_comp)  # No. of elements\n        total_comp = Composition(self._elt_comp)\n        forced_include = forced_include or []\n\n        # generate all combinations of compounds that have all elements\n        entry_combos = [itertools.combinations(\n            entries, j + 1 - len(forced_include)) for j in range(N)]\n        entry_combos = itertools.chain.from_iterable(entry_combos)\n        if forced_include:\n            entry_combos = [forced_include + list(ec) for ec in entry_combos]\n        entry_combos = filter(lambda x: total_comp < MultiEntry(x).composition,\n                              entry_combos)\n\n        # Generate and filter entries\n        processed_entries = []\n        total = sum([comb(len(entries), j + 1 - len(forced_include))\n                     for j in range(N)])\n        if total > 1e6:\n            warnings.warn(\"Your pourbaix diagram includes {} entries and may \"\n                          \"take a long time to generate.\".format(total))\n\n        # Parallel processing of multi-entry generation\n        if nproc is not None:\n            f = partial(self.process_multientry, prod_comp=total_comp)\n            with Pool(nproc) as p:\n                processed_entries = list(tqdm(p.imap(f, entry_combos),\n                                              total=total))\n            processed_entries = list(filter(bool, processed_entries))\n        # Serial processing of multi-entry generation\n        else:\n            for entry_combo in entry_combos:\n                processed_entry = self.process_multientry(entry_combo, total_comp)\n                if processed_entry is not None:\n                    processed_entries.append(processed_entry)\n\n        return processed_entries", "response": "Generate entries for multi - element Pourbaix construction."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef process_multientry(entry_list, prod_comp, coeff_threshold=1e-4):\n        dummy_oh = [Composition(\"H\"), Composition(\"O\")]\n        try:\n            # Get balanced reaction coeffs, ensuring all < 0 or conc thresh\n            # Note that we get reduced compositions for solids and non-reduced\n            # compositions for ions because ions aren't normalized due to\n            # their charge state.\n            entry_comps = [e.composition for e in entry_list]\n            rxn = Reaction(entry_comps + dummy_oh, [prod_comp])\n            coeffs = -np.array([rxn.get_coeff(comp) for comp in entry_comps])\n            # Return None if reaction coeff threshold is not met\n            # TODO: this filtration step might be put somewhere else\n            if (coeffs > coeff_threshold).all():\n                return MultiEntry(entry_list, weights=coeffs.tolist())\n            else:\n                return None\n        except ReactionError:\n            return None", "response": "This method is used to find a MultiEntry object based on a list of entries and a product composition and returns a MultiEntry object with weights according to the coefficients of the reaction coefficients."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a set of pourbaix stable domains (i. e. polygons) in pH-V space from a list of pourbaix_entries This function works by using scipy's HalfspaceIntersection function to construct all of the 2-D polygons that form the boundaries of the planes corresponding to individual entry gibbs free energies as a function of pH and V. Hyperplanes of the form a*pH + b*V + 1 - g(0, 0) are constructed and supplied to HalfspaceIntersection, which then finds the boundaries of each pourbaix region using the intersection points. Args: pourbaix_entries ([PourbaixEntry]): Pourbaix entries with which to construct stable pourbaix domains limits ([[float]]): limits in which to do the pourbaix analysis Returns: Returns a dict of the form {entry: [boundary_points]}. The list of boundary points are the sides of the N-1 dim polytope bounding the allowable ph-V range of each entry.", "response": "def get_pourbaix_domains(pourbaix_entries, limits=None):\n        \"\"\"\n        Returns a set of pourbaix stable domains (i. e. polygons) in\n        pH-V space from a list of pourbaix_entries\n\n        This function works by using scipy's HalfspaceIntersection\n        function to construct all of the 2-D polygons that form the\n        boundaries of the planes corresponding to individual entry\n        gibbs free energies as a function of pH and V. Hyperplanes\n        of the form a*pH + b*V + 1 - g(0, 0) are constructed and\n        supplied to HalfspaceIntersection, which then finds the\n        boundaries of each pourbaix region using the intersection\n        points.\n\n        Args:\n            pourbaix_entries ([PourbaixEntry]): Pourbaix entries\n                with which to construct stable pourbaix domains\n            limits ([[float]]): limits in which to do the pourbaix\n                analysis\n\n        Returns:\n            Returns a dict of the form {entry: [boundary_points]}.\n            The list of boundary points are the sides of the N-1\n            dim polytope bounding the allowable ph-V range of each entry.\n        \"\"\"\n        if limits is None:\n            limits = [[-2, 16], [-4, 4]]\n\n        # Get hyperplanes\n        hyperplanes = [np.array([-PREFAC * entry.npH, -entry.nPhi,\n                                 0, -entry.energy]) * entry.normalization_factor\n                       for entry in pourbaix_entries]\n        hyperplanes = np.array(hyperplanes)\n        hyperplanes[:, 2] = 1\n\n        max_contribs = np.max(np.abs(hyperplanes), axis=0)\n        g_max = np.dot(-max_contribs, [limits[0][1], limits[1][1], 0, 1])\n\n        # Add border hyperplanes and generate HalfspaceIntersection\n        border_hyperplanes = [[-1, 0, 0, limits[0][0]],\n                              [1, 0, 0, -limits[0][1]],\n                              [0, -1, 0, limits[1][0]],\n                              [0, 1, 0, -limits[1][1]],\n                              [0, 0, -1, 2 * g_max]]\n        hs_hyperplanes = np.vstack([hyperplanes, border_hyperplanes])\n        interior_point = np.average(limits, axis=1).tolist() + [g_max]\n        hs_int = HalfspaceIntersection(hs_hyperplanes, np.array(interior_point))\n\n        # organize the boundary points by entry\n        pourbaix_domains = {entry: [] for entry in pourbaix_entries}\n        for intersection, facet in zip(hs_int.intersections,\n                                       hs_int.dual_facets):\n            for v in facet:\n                if v < len(pourbaix_entries):\n                    this_entry = pourbaix_entries[v]\n                    pourbaix_domains[this_entry].append(intersection)\n\n        # Remove entries with no pourbaix region\n        pourbaix_domains = {k: v for k, v in pourbaix_domains.items() if v}\n        pourbaix_domain_vertices = {}\n\n        for entry, points in pourbaix_domains.items():\n            points = np.array(points)[:, :2]\n            # Initial sort to ensure consistency\n            points = points[np.lexsort(np.transpose(points))]\n            center = np.average(points, axis=0)\n            points_centered = points - center\n\n            # Sort points by cross product of centered points,\n            # isn't strictly necessary but useful for plotting tools\n            point_comparator = lambda x, y: x[0] * y[1] - x[1] * y[0]\n            points_centered = sorted(points_centered,\n                                     key=cmp_to_key(point_comparator))\n            points = points_centered + center\n\n            # Create simplices corresponding to pourbaix boundary\n            simplices = [Simplex(points[indices])\n                         for indices in ConvexHull(points).simplices]\n            pourbaix_domains[entry] = simplices\n            pourbaix_domain_vertices[entry] = points\n\n        return pourbaix_domains, pourbaix_domain_vertices"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nfinding the stable entry at a given pH and V.", "response": "def find_stable_entry(self, pH, V):\n        \"\"\"\n        Finds stable entry at a pH,V condition\n        Args:\n            pH (float): pH to find stable entry\n            V (float): V to find stable entry\n\n        Returns:\n\n        \"\"\"\n        energies_at_conditions = [e.normalized_energy_at_conditions(pH, V)\n                                  for e in self.stable_entries]\n        return self.stable_entries[np.argmin(energies_at_conditions)]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nfinding the decomposition to most stable entry", "response": "def get_decomposition_energy(self, entry, pH, V):\n        \"\"\"\n        Finds decomposition to most stable entry\n\n        Args:\n            entry (PourbaixEntry): PourbaixEntry corresponding to\n                compound to find the decomposition for\n            pH (float): pH at which to find the decomposition\n            V (float): voltage at which to find the decomposition\n\n        Returns:\n            reaction corresponding to the decomposition\n        \"\"\"\n        # Find representative multientry\n        if self._multielement and not isinstance(entry, MultiEntry):\n            possible_entries = self._generate_multielement_entries(\n                self._filtered_entries, forced_include=[entry])\n\n            # Filter to only include materials where the entry is only solid\n            if entry.phase_type == \"solid\":\n                possible_entries = [e for e in possible_entries\n                                    if e.phase_type.count(\"Solid\") == 1]\n            possible_energies = [e.normalized_energy_at_conditions(pH, V)\n                                 for e in possible_entries]\n        else:\n            possible_energies = [entry.normalized_energy_at_conditions(pH, V)]\n\n        min_energy = np.min(possible_energies, axis=0)\n\n        # Find entry and take the difference\n        hull = self.get_hull_energy(pH, V)\n        return min_energy - hull"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nshows the pourbaix plot of the pourbaix plot of the national product of the pourbaix data", "response": "def show(self, *args, **kwargs):\n        \"\"\"\n        Shows the pourbaix plot\n\n        Args:\n            *args: args to get_pourbaix_plot\n            **kwargs: kwargs to get_pourbaix_plot\n\n        Returns:\n            None\n        \"\"\"\n        plt = self.get_pourbaix_plot(*args, **kwargs)\n        plt.show()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_pourbaix_plot(self, limits=None, title=\"\",\n                          label_domains=True, plt=None):\n        \"\"\"\n        Plot Pourbaix diagram.\n\n        Args:\n            limits: 2D list containing limits of the Pourbaix diagram\n                of the form [[xlo, xhi], [ylo, yhi]]\n            title (str): Title to display on plot\n            label_domains (bool): whether to label pourbaix domains\n            plt (pyplot): Pyplot instance for plotting\n\n        Returns:\n            plt (pyplot) - matplotlib plot object with pourbaix diagram\n        \"\"\"\n        if limits is None:\n            limits = [[-2, 16], [-3, 3]]\n\n        plt = plt or pretty_plot(16)\n\n        xlim = limits[0]\n        ylim = limits[1]\n\n        h_line = np.transpose([[xlim[0], -xlim[0] * PREFAC],\n                               [xlim[1], -xlim[1] * PREFAC]])\n        o_line = np.transpose([[xlim[0], -xlim[0] * PREFAC + 1.23],\n                               [xlim[1], -xlim[1] * PREFAC + 1.23]])\n        neutral_line = np.transpose([[7, ylim[0]], [7, ylim[1]]])\n        V0_line = np.transpose([[xlim[0], 0], [xlim[1], 0]])\n\n        ax = plt.gca()\n        ax.set_xlim(xlim)\n        ax.set_ylim(ylim)\n        lw = 3\n        plt.plot(h_line[0], h_line[1], \"r--\", linewidth=lw)\n        plt.plot(o_line[0], o_line[1], \"r--\", linewidth=lw)\n        plt.plot(neutral_line[0], neutral_line[1], \"k-.\", linewidth=lw)\n        plt.plot(V0_line[0], V0_line[1], \"k-.\", linewidth=lw)\n\n        for entry, vertices in self._pd._stable_domain_vertices.items():\n            center = np.average(vertices, axis=0)\n            x, y = np.transpose(np.vstack([vertices, vertices[0]]))\n            plt.plot(x, y, 'k-', linewidth=lw)\n            if label_domains:\n                plt.annotate(generate_entry_label(entry), center, ha='center',\n                             va='center', fontsize=20, color=\"b\")\n\n        plt.xlabel(\"pH\")\n        plt.ylabel(\"E (V)\")\n        plt.title(title, fontsize=20, fontweight='bold')\n        return plt", "response": "Returns a matplotlib plot object with the pourbaix diagram."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef apply_transformation(self, structure, return_ranked_list=False):\n        num_remove_dict = {}\n        total_combis = 0\n        for indices, frac in zip(self.indices, self.fractions):\n            num_to_remove = len(indices) * frac\n            if abs(num_to_remove - int(round(num_to_remove))) > 1e-3:\n                raise ValueError(\"Fraction to remove must be consistent with \"\n                                 \"integer amounts in structure.\")\n            else:\n                num_to_remove = int(round(num_to_remove))\n            num_remove_dict[tuple(indices)] = num_to_remove\n            n = len(indices)\n            total_combis += int(round(math.factorial(n) /\n                                      math.factorial(num_to_remove) /\n                                      math.factorial(n - num_to_remove)))\n\n        self.logger.debug(\"Total combinations = {}\".format(total_combis))\n\n        try:\n            num_to_return = int(return_ranked_list)\n        except ValueError:\n            num_to_return = 1\n\n        num_to_return = max(1, num_to_return)\n        self.logger.debug(\"Will return {} best structures.\"\n                          .format(num_to_return))\n\n        if self.algo == PartialRemoveSitesTransformation.ALGO_FAST:\n            all_structures = self.fast_ordering(structure, num_remove_dict,\n                                                num_to_return)\n        elif self.algo == PartialRemoveSitesTransformation.ALGO_COMPLETE:\n            all_structures = self.complete_ordering(structure, num_remove_dict)\n        elif self.algo == PartialRemoveSitesTransformation.ALGO_BEST_FIRST:\n            all_structures = self.best_first_ordering(structure,\n                                                      num_remove_dict)\n        elif self.algo == PartialRemoveSitesTransformation.ALGO_ENUMERATE:\n            all_structures = self.enumerate_ordering(structure)\n        else:\n            raise ValueError(\"Invalid algo.\")\n\n        opt_s = all_structures[0][\"structure\"]\n        return opt_s if not return_ranked_list \\\n            else all_structures[0:num_to_return]", "response": "Applies the transformation to the structure."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef apply_transformation(self, structure):\n        new_structure = structure.copy()\n        for prop in self.site_properties.keys():\n            new_structure.add_site_property(prop, self.site_properties[prop])\n        return new_structure", "response": "Applies the transformation to the structure."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nwriting the input files for a LAMMPS run.", "response": "def write_lammps_inputs(output_dir, script_template, settings=None,\n                        data=None, script_filename=\"in.lammps\",\n                        make_dir_if_not_present=True, **kwargs):\n    \"\"\"\n    Writes input files for a LAMMPS run. Input script is constructed\n    from a str template with placeholders to be filled by custom\n    settings. Data file is either written from a LammpsData\n    instance or copied from an existing file if read_data cmd is\n    inspected in the input script. Other supporting files are not\n    handled at the moment.\n\n    Args:\n        output_dir (str): Directory to output the input files.\n        script_template (str): String template for input script with\n            placeholders. The format for placeholders has to be\n            '$variable_name', e.g., '$temperature'\n        settings (dict): Contains values to be written to the\n            placeholders, e.g., {'temperature': 1}. Default to None.\n        data (LammpsData or str): Data file as a LammpsData instance or\n            path to an existing data file. Default to None, i.e., no\n            data file supplied. Useful only when read_data cmd is in\n            the script.\n        script_filename (str): Filename for the input script.\n        make_dir_if_not_present (bool): Set to True if you want the\n            directory (and the whole path) to be created if it is not\n            present.\n        **kwargs: kwargs supported by LammpsData.write_file.\n\n    Examples:\n        >>> eam_template = '''units           metal\n        ... atom_style      atomic\n        ...\n        ... lattice         fcc 3.615\n        ... region          box block 0 20 0 20 0 20\n        ... create_box      1 box\n        ... create_atoms    1 box\n        ...\n        ... pair_style      eam\n        ... pair_coeff      1 1 Cu_u3.eam\n        ...\n        ... velocity        all create $temperature 376847 loop geom\n        ...\n        ... neighbor        1.0 bin\n        ... neigh_modify    delay 5 every 1\n        ...\n        ... fix             1 all nvt temp $temperature $temperature 0.1\n        ...\n        ... timestep        0.005\n        ...\n        ... run             $nsteps'''\n        >>> write_lammps_inputs('.', eam_template, settings={'temperature': 1600.0, 'nsteps': 100})\n        >>> with open('in.lammps') as f:\n        ...     script = f.read()\n        ...\n        >>> print(script)\n        units           metal\n        atom_style      atomic\n\n        lattice         fcc 3.615\n        region          box block 0 20 0 20 0 20\n        create_box      1 box\n        create_atoms    1 box\n\n        pair_style      eam\n        pair_coeff      1 1 Cu_u3.eam\n\n        velocity        all create 1600.0 376847 loop geom\n\n        neighbor        1.0 bin\n        neigh_modify    delay 5 every 1\n\n        fix             1 all nvt temp 1600.0 1600.0 0.1\n\n        timestep        0.005\n\n        run             100\n\n\n    \"\"\"\n    variables = {} if settings is None else settings\n    template = Template(script_template)\n    input_script = template.safe_substitute(**variables)\n    if make_dir_if_not_present and not os.path.exists(output_dir):\n        os.makedirs(output_dir)\n    with open(os.path.join(output_dir, script_filename), \"w\") as f:\n        f.write(input_script)\n    read_data = re.search(r\"read_data\\s+(.*)\\n\", input_script)\n    if read_data:\n        data_filename = read_data.group(1).split()[0]\n        if isinstance(data, LammpsData):\n            data.write_file(os.path.join(output_dir, data_filename), **kwargs)\n        elif isinstance(data, str) and os.path.exists(data):\n            shutil.copyfile(data, os.path.join(output_dir, data_filename))\n        else:\n            warnings.warn(\"No data file supplied. Skip writing %s.\"\n                          % data_filename)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nwriting all input files for the current instance of a LammpsData object.", "response": "def write_inputs(self, output_dir, **kwargs):\n        \"\"\"\n        Writes all input files (input script, and data if needed).\n        Other supporting files are not handled at this moment.\n\n        Args:\n            output_dir (str): Directory to output the input files.\n            **kwargs: kwargs supported by LammpsData.write_file.\n\n        \"\"\"\n        write_lammps_inputs(output_dir=output_dir,\n                            script_template=self.script_template,\n                            settings=self.settings, data=self.data,\n                            script_filename=self.script_filename, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef generate_reciprocal_vectors_squared(a1, a2, a3, encut):\n    for vec in genrecip(a1, a2, a3, encut):\n        yield np.dot(vec, vec)", "response": "Generates the reciprocal vectors squared of the specied base - set of lattice vectors."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the closest site to the input position for both bulk and defect structures", "response": "def closestsites(struct_blk, struct_def, pos):\n    \"\"\"\n    Returns closest site to the input position\n    for both bulk and defect structures\n    Args:\n        struct_blk: Bulk structure\n        struct_def: Defect structure\n        pos: Position\n    Return: (site object, dist, index)\n    \"\"\"\n    blk_close_sites = struct_blk.get_sites_in_sphere(pos, 5, include_index=True)\n    blk_close_sites.sort(key=lambda x: x[1])\n    def_close_sites = struct_def.get_sites_in_sphere(pos, 5, include_index=True)\n    def_close_sites.sort(key=lambda x: x[1])\n\n    return blk_close_sites[0], def_close_sites[0]"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the density at the reciprocal vector.", "response": "def rho_rec(self, g2):\n        \"\"\"\n        Reciprocal space model charge value\n        for input squared reciprocal vector.\n        Args:\n            g2: Square of reciprocal vector\n\n        Returns:\n            Charge density at the reciprocal vector magnitude\n        \"\"\"\n        return (self.expnorm / np.sqrt(1 + self.gamma2 * g2) + (\n            1 - self.expnorm) * np.exp(-0.25 * self.beta2 * g2))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the limit of the reciprocal vector 0.", "response": "def rho_rec_limit0(self):\n        \"\"\"\n        Reciprocal space model charge value\n        close to reciprocal vector 0 .\n        rho_rec(g->0) -> 1 + rho_rec_limit0 * g^2\n        \"\"\"\n        return -2 * self.gamma2 * self.expnorm - 0.25 * self.beta2 * (\n            1 - self.expnorm)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef make_supercells_with_defects(self, scaling_matrix):\n        scs = []\n        sc = self._structure.copy()\n        sc.make_supercell(scaling_matrix)\n        scs.append(sc)\n        for ids, defect_site in enumerate(self._defect_sites):\n            sc_with_inter = sc.copy()\n            sc_with_inter.append(\n                defect_site.species_string,\n                defect_site.frac_coords,\n                coords_are_cartesian=False,\n                validate_proximity=False,\n                properties=None)\n            if not sc_with_inter:\n                raise RuntimeError(\n                    \"could not generate supercell with\" \" interstitial {}\".format(\n                        ids + 1))\n            scs.append(sc_with_inter.copy())\n        return scs", "response": "Generates a sequence of supercells in which each supercell contains a single interstitial and a single interstitial."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncluster nodes that are too close together using a tolerance.", "response": "def cluster_nodes(self, tol=0.2):\n        \"\"\"\n        Cluster nodes that are too close together using a tol.\n\n        Args:\n            tol (float): A distance tolerance. PBC is taken into account.\n        \"\"\"\n        lattice = self.structure.lattice\n\n        vfcoords = [v.frac_coords for v in self.vnodes]\n\n        # Manually generate the distance matrix (which needs to take into\n        # account PBC.\n        dist_matrix = np.array(lattice.get_all_distances(vfcoords, vfcoords))\n        dist_matrix = (dist_matrix + dist_matrix.T) / 2\n        for i in range(len(dist_matrix)):\n            dist_matrix[i, i] = 0\n        condensed_m = squareform(dist_matrix)\n        z = linkage(condensed_m)\n        cn = fcluster(z, tol, criterion=\"distance\")\n        merged_vnodes = []\n        for n in set(cn):\n            poly_indices = set()\n            frac_coords = []\n            for i, j in enumerate(np.where(cn == n)[0]):\n                poly_indices.update(self.vnodes[j].polyhedron_indices)\n                if i == 0:\n                    frac_coords.append(self.vnodes[j].frac_coords)\n                else:\n                    fcoords = self.vnodes[j].frac_coords\n                    # We need the image to combine the frac_coords properly.\n                    d, image = lattice.get_distance_and_image(frac_coords[0],\n                                                              fcoords)\n                    frac_coords.append(fcoords + image)\n            merged_vnodes.append(\n                VoronoiPolyhedron(lattice, np.average(frac_coords, axis=0),\n                                  poly_indices, self.coords))\n        self.vnodes = merged_vnodes\n        logger.debug(\"%d vertices after combination.\" % len(self.vnodes))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nremove vnodes that are too close to existing atoms in the structure.", "response": "def remove_collisions(self, min_dist=0.5):\n        \"\"\"\n        Remove vnodes that are too close to existing atoms in the structure\n\n        Args:\n            min_dist(float): The minimum distance that a vertex needs to be\n                from existing atoms.\n        \"\"\"\n        vfcoords = [v.frac_coords for v in self.vnodes]\n        sfcoords = self.structure.frac_coords\n        dist_matrix = self.structure.lattice.get_all_distances(vfcoords,\n                                                               sfcoords)\n        all_dist = np.min(dist_matrix, axis=1)\n        new_vnodes = []\n        for i, v in enumerate(self.vnodes):\n            if all_dist[i] > min_dist:\n                new_vnodes.append(v)\n        self.vnodes = new_vnodes"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the modified structure with the voronoi nodes inserted.", "response": "def get_structure_with_nodes(self):\n        \"\"\"\n        Get the modified structure with the voronoi nodes inserted. The\n        species is set as a DummySpecie X.\n        \"\"\"\n        new_s = Structure.from_sites(self.structure)\n        for v in self.vnodes:\n            new_s.append(\"X\", v.frac_coords)\n        return new_s"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _get_charge_distribution_df(self):\n        # Fraction coordinates and corresponding indices\n        axis_grid = np.array([np.array(self.chgcar.get_axis_grid(i)) /\n                              self.structure.lattice.abc[i] for i in range(3)])\n        axis_index = np.array([range(len(axis_grid[i])) for i in range(3)])\n\n        data = {}\n\n        for index in itertools.product(*axis_index):\n            a, b, c = index\n            f_coords = (axis_grid[0][a], axis_grid[1][b], axis_grid[2][c])\n            data[f_coords] = self.chgcar.data[\"total\"][a][b][c]\n\n        # Fraction coordinates - charge density table\n        df = pd.Series(data).reset_index()\n        df.columns = ['a', 'b', 'c', 'Charge Density']\n        self._charge_distribution_df = df\n\n        return df", "response": "Return a complete table of fractional coordinates - charge density."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nupdating _extrema_df extrema_type and extrema_coords", "response": "def _update_extrema(self, f_coords, extrema_type, threshold_frac=None,\n                        threshold_abs=None):\n        \"\"\"Update _extrema_df, extrema_type and extrema_coords\"\"\"\n\n        if threshold_frac is not None:\n            if threshold_abs is not None:\n                logger.warning(  # Exit if both filter are set\n                    \"Filter can be either threshold_frac or threshold_abs!\")\n                return\n            if threshold_frac > 1 or threshold_frac < 0:\n                raise Exception(\"threshold_frac range is [0, 1]!\")\n\n        # Return empty result if coords list is empty\n        if len(f_coords) == 0:\n            df = pd.DataFrame({}, columns=['A', 'B', 'C', \"Chgcar\"])\n            self._extrema_df = df\n            self.extrema_coords = []\n            logger.info(\"Find {} {}.\".format(len(df), extrema_type))\n            return\n\n        data = {}\n        unit = 1 / np.array(self.chgcar.dim)  # pixel along a, b, c\n\n        for fc in f_coords:\n            a, b, c = tuple(map(int, fc / unit))\n            data[tuple(fc)] = self.chgcar.data[\"total\"][a][b][c]\n\n        df = pd.Series(data).reset_index()\n        df.columns = ['a', 'b', 'c', 'Charge Density']\n        ascending = (extrema_type == \"local minima\")\n\n        if threshold_abs is None:\n            threshold_frac = threshold_frac \\\n                if threshold_frac is not None else 1.0\n            num_extrema = int(threshold_frac * len(f_coords))\n            df = df.sort_values(by=\"Charge Density\", ascending=ascending)[\n                 0:num_extrema]\n            df.reset_index(drop=True, inplace=True)  # reset major index\n        else:  # threshold_abs is set\n            df = df.sort_values(by=\"Charge Density\", ascending=ascending)\n            df = df[df[\"Charge Density\"] <= threshold_abs] if ascending \\\n                else df[df[\"Charge Density\"] >= threshold_abs]\n\n        extrema_coords = []\n        for row in df.iterrows():\n            fc = np.array(row[1][\"a\":\"c\"])\n            extrema_coords.append(fc)\n\n        self._extrema_df = df\n        self.extrema_type = extrema_type\n        self.extrema_coords = extrema_coords\n        logger.info(\"Find {} {}.\".format(len(df), extrema_type))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_local_extrema(self, find_min=True, threshold_frac=None,\n                          threshold_abs=None):\n        \"\"\"\n        Get all local extrema fractional coordinates in charge density,\n        searching for local minimum by default. Note that sites are NOT grouped\n        symmetrically.\n\n        Args:\n            find_min (bool): True to find local minimum else maximum, otherwise\n                find local maximum.\n\n            threshold_frac (float): optional fraction of extrema shown, which\n                returns `threshold_frac * tot_num_extrema` extrema fractional\n                coordinates based on highest/lowest intensity.\n\n                E.g. set 0.2 to show the extrema with 20% highest or lowest\n                intensity. Value range: 0 <= threshold_frac <= 1\n\n                Note that threshold_abs and threshold_frac should not set in the\n                same time.\n\n            threshold_abs (float): optional filter. When searching for local\n                minima, intensity <= threshold_abs returns; when searching for\n                local maxima, intensity >= threshold_abs returns.\n\n                Note that threshold_abs and threshold_frac should not set in the\n                same time.\n\n        Returns:\n            extrema_coords (list): list of fractional coordinates corresponding\n                to local extrema.\n        \"\"\"\n        sign, extrema_type = 1, \"local maxima\"\n\n        if find_min:\n            sign, extrema_type = -1, \"local minima\"\n\n        # Make 3x3x3 supercell\n        # This is a trick to resolve the periodical boundary issue.\n        total_chg = sign * self.chgcar.data[\"total\"]\n        total_chg = np.tile(total_chg, reps=(3, 3, 3))\n        coordinates = peak_local_max(total_chg, min_distance=1)\n\n        # Remove duplicated sites introduced by supercell.\n        f_coords = [coord / total_chg.shape * 3 for coord in coordinates]\n        f_coords = [f - 1 for f in f_coords if\n                    all(np.array(f) < 2) and all(np.array(f) >= 1)]\n\n        # Update information\n        self._update_extrema(f_coords, extrema_type,\n                             threshold_frac=threshold_frac,\n                             threshold_abs=threshold_abs)\n\n        return self.extrema_coords", "response": "Get all local extrema fractional coordinates in charge density."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef cluster_nodes(self, tol=0.2):\n        lattice = self.structure.lattice\n        vf_coords = self.extrema_coords\n\n        if len(vf_coords) == 0:\n            if self.extrema_type is None:\n                logger.warning(\n                    \"Please run ChargeDensityAnalyzer.get_local_extrema first!\")\n                return\n            new_f_coords = []\n            self._update_extrema(new_f_coords, self.extrema_type)\n            return new_f_coords\n\n        # Manually generate the distance matrix (which needs to take into\n        # account PBC.\n        dist_matrix = np.array(lattice.get_all_distances(vf_coords, vf_coords))\n        dist_matrix = (dist_matrix + dist_matrix.T) / 2\n\n        for i in range(len(dist_matrix)):\n            dist_matrix[i, i] = 0\n        condensed_m = squareform(dist_matrix)\n        z = linkage(condensed_m)\n        cn = fcluster(z, tol, criterion=\"distance\")\n        merged_fcoords = []\n\n        for n in set(cn):\n            frac_coords = []\n            for i, j in enumerate(np.where(cn == n)[0]):\n                if i == 0:\n                    frac_coords.append(self.extrema_coords[j])\n                else:\n                    f_coords = self.extrema_coords[j]\n                    # We need the image to combine the frac_coords properly.\n                    d, image = lattice.get_distance_and_image(frac_coords[0],\n                                                              f_coords)\n                    frac_coords.append(f_coords + image)\n            merged_fcoords.append(np.average(frac_coords, axis=0))\n\n        merged_fcoords = [f - np.floor(f) for f in merged_fcoords]\n        merged_fcoords = [f * (np.abs(f - 1) > 1E-15) for f in merged_fcoords]\n        # the second line for fringe cases like \n        # np.array([ 5.0000000e-01 -4.4408921e-17  5.0000000e-01])\n        # where the shift to [0,1) does not work due to float precision\n        self._update_extrema(merged_fcoords, extrema_type=self.extrema_type)\n        logger.debug(\n            \"{} vertices after combination.\".format(len(self.extrema_coords)))", "response": "Cluster nodes that are too close together using a tolerance."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nremoves predicted sites that are too close to existing atoms in the species.", "response": "def remove_collisions(self, min_dist=0.5):\n        \"\"\"\n        Remove predicted sites that are too close to existing atoms in the\n        structure.\n\n        Args:\n            min_dist (float): The minimum distance (in Angstrom) that\n                a predicted site needs to be from existing atoms. A min_dist\n                with value <= 0 returns all sites without distance checking.\n        \"\"\"\n        s_f_coords = self.structure.frac_coords\n        f_coords = self.extrema_coords\n        if len(f_coords) == 0:\n            if self.extrema_type is None:\n                logger.warning(\n                    \"Please run ChargeDensityAnalyzer.get_local_extrema first!\")\n                return\n            new_f_coords = []\n            self._update_extrema(new_f_coords, self.extrema_type)\n            return new_f_coords\n\n        dist_matrix = self.structure.lattice.get_all_distances(f_coords,\n                                                               s_f_coords)\n        all_dist = np.min(dist_matrix, axis=1)\n        new_f_coords = []\n\n        for i, f in enumerate(f_coords):\n            if all_dist[i] > min_dist:\n                new_f_coords.append(f)\n        self._update_extrema(new_f_coords, self.extrema_type)\n\n        return new_f_coords"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_structure_with_nodes(self, find_min=True, min_dist=0.5, tol=0.2,\n                                 threshold_frac=None, threshold_abs=None):\n        \"\"\"\n        Get the modified structure with the possible interstitial sites added.\n        The species is set as a DummySpecie X.\n\n        Args:\n            find_min (bool): True to find local minimum else maximum, otherwise\n                find local maximum.\n\n            min_dist (float): The minimum distance (in Angstrom) that\n                a predicted site needs to be from existing atoms. A min_dist\n                with value <= 0 returns all sites without distance checking.\n\n            tol (float): A distance tolerance of nodes clustering that sites too\n                closed to other predicted sites will be merged. PBC is taken\n                into account.\n\n            threshold_frac (float): optional fraction of extrema, which returns\n                `threshold_frac * tot_num_extrema` extrema fractional\n                coordinates based on highest/lowest intensity.\n\n                E.g. set 0.2 to insert DummySpecie atom at the extrema with 20%\n                highest or lowest intensity.\n                Value range: 0 <= threshold_frac <= 1\n\n                Note that threshold_abs and threshold_frac should not set in the\n                same time.\n\n            threshold_abs (float): optional filter. When searching for local\n                minima, intensity <= threshold_abs returns; when searching for\n                local maxima, intensity >= threshold_abs returns.\n\n                Note that threshold_abs and threshold_frac should not set in the\n                same time.\n\n        Returns:\n            structure (Structure)\n        \"\"\"\n\n        structure = self.structure.copy()\n        self.get_local_extrema(find_min=find_min, threshold_frac=threshold_frac,\n                               threshold_abs=threshold_abs)\n\n        self.remove_collisions(min_dist)\n        self.cluster_nodes(tol=tol)\n        for fc in self.extrema_coords:\n            structure.append(\"X\", fc)\n\n        return structure", "response": "Get the modified structure with the possible interstitial sites added."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef sort_sites_by_integrated_chg(self, r=0.4):\n\n        if self.extrema_type is None:\n            self.get_local_extrema()\n        int_den = []\n        for isite in self.extrema_coords:\n            mask = self._dist_mat(isite) < r\n            vol_sphere = self.chgcar.structure.volume * (mask.sum()/self.chgcar.ngridpts)\n            chg_in_sphere = np.sum(self.chgcar.data['total'] * mask) / mask.size / vol_sphere\n            int_den.append(chg_in_sphere)\n        self._extrema_df['avg_charge_den'] = int_den\n        self._extrema_df.sort_values(by=['avg_charge_den'], inplace=True)\n        self._extrema_df.reset_index(drop=True, inplace=True)", "response": "Sort the sites by the average charge density around each local minima in the charge density\n            and store the result in _extrema_df."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nparse a QChem output file with multiple calculations and returns a list of QCCalcs.", "response": "def multiple_outputs_from_file(cls, filename, keep_sub_files=True):\n        \"\"\"\n            Parses a QChem output file with multiple calculations\n            1.) Seperates the output into sub-files\n                e.g. qcout -> qcout.0, qcout.1, qcout.2 ... qcout.N\n                a.) Find delimeter for multiple calcualtions\n                b.) Make seperate output sub-files\n            2.) Creates seperate QCCalcs for each one from the sub-files\n        \"\"\"\n        to_return = []\n        with zopen(filename, 'rt') as f:\n            text = re.split(r'\\s*(?:Running\\s+)*Job\\s+\\d+\\s+of\\s+\\d+\\s+',\n                            f.read())\n        if text[0] == '':\n            text = text[1:]\n        for i, sub_text in enumerate(text):\n            temp = open(filename + '.' + str(i), 'w')\n            temp.write(sub_text)\n            temp.close()\n            tempOutput = cls(filename + '.' + str(i))\n            to_return.append(tempOutput)\n            if not keep_sub_files:\n                os.remove(filename + '.' + str(i))\n        return to_return"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nparse charge and multiplicity.", "response": "def _read_charge_and_multiplicity(self):\n        \"\"\"\n        Parses charge and multiplicity.\n        \"\"\"\n        temp_charge = read_pattern(\n            self.text, {\n                \"key\": r\"\\$molecule\\s+([\\-\\d]+)\\s+\\d\"\n            },\n            terminate_on_match=True).get('key')\n        if temp_charge != None:\n            self.data[\"charge\"] = int(temp_charge[0][0])\n        else:\n            temp_charge = read_pattern(\n                self.text, {\n                    \"key\": r\"Sum of atomic charges \\=\\s+([\\d\\-\\.\\+]+)\"\n                },\n                terminate_on_match=True).get('key')\n            if temp_charge == None:\n                self.data[\"charge\"] = None\n            else:\n                self.data[\"charge\"] = int(float(temp_charge[0][0]))\n\n        temp_multiplicity = read_pattern(\n            self.text, {\n                \"key\": r\"\\$molecule\\s+[\\-\\d]+\\s+(\\d)\"\n            },\n            terminate_on_match=True).get('key')\n        if temp_multiplicity != None:\n            self.data[\"multiplicity\"] = int(temp_multiplicity[0][0])\n        else:\n            temp_multiplicity = read_pattern(\n                self.text, {\n                    \"key\": r\"Sum of spin\\s+charges \\=\\s+([\\d\\-\\.\\+]+)\"\n                },\n                terminate_on_match=True).get('key')\n            if temp_multiplicity == None:\n                self.data[\"multiplicity\"] = 1\n            else:\n                self.data[\"multiplicity\"] = int(\n                    float(temp_multiplicity[0][0])) + 1"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _read_species_and_inital_geometry(self):\n        header_pattern = r\"Standard Nuclear Orientation \\(Angstroms\\)\\s+I\\s+Atom\\s+X\\s+Y\\s+Z\\s+-+\"\n        table_pattern = r\"\\s*\\d+\\s+([a-zA-Z]+)\\s*([\\d\\-\\.]+)\\s*([\\d\\-\\.]+)\\s*([\\d\\-\\.]+)\\s*\"\n        footer_pattern = r\"\\s*-+\"\n        temp_geom = read_table_pattern(self.text, header_pattern,\n                                       table_pattern, footer_pattern)\n        if temp_geom == None or len(temp_geom) == 0:\n            self.data[\"species\"] = None\n            self.data[\"initial_geometry\"] = None\n            self.data[\"initial_molecule\"] = None\n            self.data[\"point_group\"] = None\n        else:\n            temp_point_group = read_pattern(\n            self.text, {\n                \"key\":\n                r\"Molecular Point Group\\s+([A-Za-z\\d\\*]+)\"\n            },\n            terminate_on_match=True).get('key')\n            if temp_point_group != None:\n                self.data[\"point_group\"] = temp_point_group[0][0]\n            else:\n                self.data[\"point_group\"] = None\n            temp_geom = temp_geom[0]\n            species = []\n            geometry = np.zeros(shape=(len(temp_geom), 3), dtype=float)\n            for ii, entry in enumerate(temp_geom):\n                species += [entry[0]]\n                for jj in range(3):\n                    geometry[ii, jj] = float(entry[jj + 1])\n            self.data[\"species\"] = species\n            self.data[\"initial_geometry\"] = geometry\n            self.data[\"initial_molecule\"] = Molecule(\n                species=species,\n                coords=geometry,\n                charge=self.data.get('charge'),\n                spin_multiplicity=self.data.get('multiplicity'))", "response": "Parses species and initial geometry."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _read_SCF(self):\n        if self.data.get('using_GEN_SCFMAN', []):\n            if \"SCF_failed_to_converge\" in self.data.get(\"errors\"):\n                footer_pattern = r\"^\\s*gen_scfman_exception: SCF failed to converge\"\n            else:\n                footer_pattern = r\"^\\s*\\-+\\n\\s+SCF time\"\n            header_pattern = r\"^\\s*\\-+\\s+Cycle\\s+Energy\\s+(?:(?:DIIS)*\\s+[Ee]rror)*(?:RMS Gradient)*\\s+\\-+(?:\\s*\\-+\\s+OpenMP\\s+Integral\\s+computing\\s+Module\\s+(?:Release:\\s+version\\s+[\\d\\-\\.]+\\,\\s+\\w+\\s+[\\d\\-\\.]+\\, Q-Chem Inc\\. Pittsburgh\\s+)*\\-+)*\\n\"\n            table_pattern = r\"(?:\\s*Nonlocal correlation = [\\d\\-\\.]+e[\\d\\-]+)*(?:\\s*Inaccurate integrated density:\\n\\s+Number of electrons\\s+=\\s+[\\d\\-\\.]+\\n\\s+Numerical integral\\s+=\\s+[\\d\\-\\.]+\\n\\s+Relative error\\s+=\\s+[\\d\\-\\.]+\\s+\\%\\n)*\\s*\\d+\\s+([\\d\\-\\.]+)\\s+([\\d\\-\\.]+)e([\\d\\-\\.\\+]+)(?:\\s+Convergence criterion met)*(?:\\s+Preconditoned Steepest Descent)*(?:\\s+Roothaan Step)*(?:\\s+(?:Normal\\s+)*BFGS [Ss]tep)*(?:\\s+LineSearch Step)*(?:\\s+Line search: overstep)*(?:\\s+Dog-leg BFGS step)*(?:\\s+Line search: understep)*(?:\\s+Descent step)*\"\n        else:\n            if \"SCF_failed_to_converge\" in self.data.get(\"errors\"):\n                footer_pattern = r\"^\\s*\\d+\\s*[\\d\\-\\.]+\\s+[\\d\\-\\.]+E[\\d\\-\\.]+\\s+Convergence\\s+failure\\n\"\n            else:\n                footer_pattern = r\"^\\s*\\-+\\n\"\n            header_pattern = r\"^\\s*\\-+\\s+Cycle\\s+Energy\\s+DIIS Error\\s+\\-+\\n\"\n            table_pattern = r\"(?:\\s*Inaccurate integrated density:\\n\\s+Number of electrons\\s+=\\s+[\\d\\-\\.]+\\n\\s+Numerical integral\\s+=\\s+[\\d\\-\\.]+\\n\\s+Relative error\\s+=\\s+[\\d\\-\\.]+\\s+\\%\\n)*\\s*\\d+\\s*([\\d\\-\\.]+)\\s+([\\d\\-\\.]+)E([\\d\\-\\.\\+]+)(?:\\s*\\n\\s*cpu\\s+[\\d\\-\\.]+\\swall\\s+[\\d\\-\\.]+)*(?:\\nin dftxc\\.C, eleTot sum is:[\\d\\-\\.]+, tauTot is\\:[\\d\\-\\.]+)*(?:\\s+Convergence criterion met)*(?:\\s+Done RCA\\. Switching to DIIS)*(?:\\n\\s*Warning: not using a symmetric Q)*(?:\\nRecomputing EXC\\s*[\\d\\-\\.]+\\s*[\\d\\-\\.]+\\s*[\\d\\-\\.]+(?:\\s*\\nRecomputing EXC\\s*[\\d\\-\\.]+\\s*[\\d\\-\\.]+\\s*[\\d\\-\\.]+)*)*\"\n\n        temp_scf = read_table_pattern(self.text, header_pattern, table_pattern,\n                                      footer_pattern)\n        real_scf = []\n        for one_scf in temp_scf:\n            temp = np.zeros(shape=(len(one_scf), 2))\n            for ii, entry in enumerate(one_scf):\n                temp[ii, 0] = float(entry[0])\n                temp[ii, 1] = float(entry[1]) * 10**float(entry[2])\n            real_scf += [temp]\n\n        self.data[\"SCF\"] = real_scf", "response": "Reads the SCF from the SCF file and returns a list of strings."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _read_mulliken(self):\n        if self.data.get('unrestricted', []):\n            header_pattern = r\"\\-+\\s+Ground-State Mulliken Net Atomic Charges\\s+Atom\\s+Charge \\(a\\.u\\.\\)\\s+Spin\\s\\(a\\.u\\.\\)\\s+\\-+\"\n            table_pattern = r\"\\s+\\d+\\s\\w+\\s+([\\d\\-\\.]+)\\s+([\\d\\-\\.]+)\"\n            footer_pattern = r\"\\s\\s\\-+\\s+Sum of atomic charges\"\n        else:\n            header_pattern = r\"\\-+\\s+Ground-State Mulliken Net Atomic Charges\\s+Atom\\s+Charge \\(a\\.u\\.\\)\\s+\\-+\"\n            table_pattern = r\"\\s+\\d+\\s\\w+\\s+([\\d\\-\\.]+)\"\n            footer_pattern = r\"\\s\\s\\-+\\s+Sum of atomic charges\"\n\n        temp_mulliken = read_table_pattern(self.text, header_pattern,\n                                           table_pattern, footer_pattern)\n        real_mulliken = []\n        for one_mulliken in temp_mulliken:\n            if self.data.get('unrestricted', []):\n                temp = np.zeros(shape=(len(one_mulliken), 2))\n                for ii, entry in enumerate(one_mulliken):\n                    temp[ii, 0] = float(entry[0])\n                    temp[ii, 1] = float(entry[1])\n            else:\n                temp = np.zeros(len(one_mulliken))\n                for ii, entry in enumerate(one_mulliken):\n                    temp[ii] = float(entry[0])\n            real_mulliken += [temp]\n\n        self.data[\"Mulliken\"] = real_mulliken", "response": "Parses Mulliken charges. Parses spins given an unrestricted SCF."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _read_optimized_geometry(self):\n        header_pattern = r\"\\*+\\s+OPTIMIZATION\\s+CONVERGED\\s+\\*+\\s+\\*+\\s+Coordinates \\(Angstroms\\)\\s+ATOM\\s+X\\s+Y\\s+Z\"\n        table_pattern = r\"\\s+\\d+\\s+\\w+\\s+([\\d\\-\\.]+)\\s+([\\d\\-\\.]+)\\s+([\\d\\-\\.]+)\"\n        footer_pattern = r\"\\s+Z-matrix Print:\"\n\n        parsed_optimized_geometry = read_table_pattern(\n            self.text, header_pattern, table_pattern, footer_pattern)\n        if parsed_optimized_geometry == [] or None:\n            self.data[\"optimized_geometry\"] = None\n            header_pattern = r\"^\\s+\\*+\\s+OPTIMIZATION CONVERGED\\s+\\*+\\s+\\*+\\s+Z-matrix\\s+Print:\\s+\\$molecule\\s+[\\d\\-]+\\s+[\\d\\-]+\\n\"\n            table_pattern = r\"\\s*(\\w+)(?:\\s+(\\d+)\\s+([\\d\\-\\.]+)(?:\\s+(\\d+)\\s+([\\d\\-\\.]+)(?:\\s+(\\d+)\\s+([\\d\\-\\.]+))*)*)*(?:\\s+0)*\"\n            footer_pattern = r\"^\\$end\\n\"\n\n            self.data[\"optimized_zmat\"] = read_table_pattern(\n                self.text, header_pattern, table_pattern, footer_pattern)\n        else:\n            self.data[\"optimized_geometry\"] = process_parsed_coords(\n                parsed_optimized_geometry[0])\n            if self.data.get('charge') != None:\n                self.data[\"molecule_from_optimized_geometry\"] = Molecule(\n                    species=self.data.get('species'),\n                    coords=self.data.get('optimized_geometry'),\n                    charge=self.data.get('charge'),\n                    spin_multiplicity=self.data.get('multiplicity'))", "response": "Parses optimized XYZ coordinates."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _read_last_geometry(self):\n        header_pattern = r\"\\s+Optimization\\sCycle:\\s+\" + \\\n            str(len(self.data.get(\"energy_trajectory\"))) + \\\n            r\"\\s+Coordinates \\(Angstroms\\)\\s+ATOM\\s+X\\s+Y\\s+Z\"\n        table_pattern = r\"\\s+\\d+\\s+\\w+\\s+([\\d\\-\\.]+)\\s+([\\d\\-\\.]+)\\s+([\\d\\-\\.]+)\"\n        footer_pattern = r\"\\s+Point Group\\:\\s+[\\d\\w\\*]+\\s+Number of degrees of freedom\\:\\s+\\d+\"\n\n        parsed_last_geometry = read_table_pattern(\n            self.text, header_pattern, table_pattern, footer_pattern)\n        if parsed_last_geometry == [] or None:\n            self.data[\"last_geometry\"] = None\n        else:\n            self.data[\"last_geometry\"] = process_parsed_coords(\n                parsed_last_geometry[0])\n            if self.data.get('charge') != None:\n                self.data[\"molecule_from_last_geometry\"] = Molecule(\n                    species=self.data.get('species'),\n                    coords=self.data.get('last_geometry'),\n                    charge=self.data.get('charge'),\n                    spin_multiplicity=self.data.get('multiplicity'))", "response": "Parses the last geometry from an optimization trajectory and stores it in the self. data."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _read_frequency_data(self):\n        temp_dict = read_pattern(\n            self.text, {\n                \"frequencies\":\n                r\"\\s*Frequency:\\s+([\\d\\-\\.]+)(?:\\s+([\\d\\-\\.]+)(?:\\s+([\\d\\-\\.]+))*)*\",\n                \"IR_intens\":\n                r\"\\s*IR Intens:\\s+([\\d\\-\\.]+)(?:\\s+([\\d\\-\\.]+)(?:\\s+([\\d\\-\\.]+))*)*\",\n                \"IR_active\":\n                r\"\\s*IR Active:\\s+([YESNO]+)(?:\\s+([YESNO]+)(?:\\s+([YESNO]+))*)*\",\n                \"ZPE\":\n                r\"\\s*Zero point vibrational energy:\\s+([\\d\\-\\.]+)\\s+kcal/mol\",\n                \"trans_enthalpy\":\n                r\"\\s*Translational Enthalpy:\\s+([\\d\\-\\.]+)\\s+kcal/mol\",\n                \"rot_enthalpy\":\n                r\"\\s*Rotational Enthalpy:\\s+([\\d\\-\\.]+)\\s+kcal/mol\",\n                \"vib_enthalpy\":\n                r\"\\s*Vibrational Enthalpy:\\s+([\\d\\-\\.]+)\\s+kcal/mol\",\n                \"gas_constant\":\n                r\"\\s*gas constant \\(RT\\):\\s+([\\d\\-\\.]+)\\s+kcal/mol\",\n                \"trans_entropy\":\n                r\"\\s*Translational Entropy:\\s+([\\d\\-\\.]+)\\s+cal/mol\\.K\",\n                \"rot_entropy\":\n                r\"\\s*Rotational Entropy:\\s+([\\d\\-\\.]+)\\s+cal/mol\\.K\",\n                \"vib_entropy\":\n                r\"\\s*Vibrational Entropy:\\s+([\\d\\-\\.]+)\\s+cal/mol\\.K\",\n                \"total_enthalpy\":\n                r\"\\s*Total Enthalpy:\\s+([\\d\\-\\.]+)\\s+kcal/mol\",\n                \"total_entropy\":\n                r\"\\s*Total Entropy:\\s+([\\d\\-\\.]+)\\s+cal/mol\\.K\"\n            })\n\n        keys = [\"ZPE\", \"trans_enthalpy\", \"rot_enthalpy\", \"vib_enthalpy\", \"gas_constant\", \"trans_entropy\", \"rot_entropy\", \"vib_entropy\", \"total_enthalpy\", \"total_entropy\"]\n\n        for key in keys:\n            if temp_dict.get(key) == None:\n                self.data[key] = None\n            else:\n                self.data[key] = float(temp_dict.get(key)[0][0])\n\n        if temp_dict.get('frequencies') == None:\n            self.data['frequencies'] = None\n            self.data['IR_intens'] = None\n            self.data['IR_active'] = None\n        else:\n            temp_freqs = [\n                value for entry in temp_dict.get('frequencies')\n                for value in entry\n            ]\n            temp_intens = [\n                value for entry in temp_dict.get('IR_intens')\n                for value in entry\n            ]\n            active = [\n                value for entry in temp_dict.get('IR_active')\n                for value in entry\n            ]\n            self.data['IR_active'] = active\n\n            freqs = np.zeros(len(temp_freqs) - temp_freqs.count('None'))\n            for ii, entry in enumerate(temp_freqs):\n                if entry != 'None':\n                    freqs[ii] = float(entry)\n            self.data['frequencies'] = freqs\n\n            intens = np.zeros(len(temp_intens) - temp_intens.count('None'))\n            for ii, entry in enumerate(temp_intens):\n                if entry != 'None':\n                    intens[ii] = float(entry)\n            self.data['IR_intens'] = intens\n\n            header_pattern = r\"\\s*Raman Active:\\s+[YESNO]+\\s+(?:[YESNO]+\\s+)*X\\s+Y\\s+Z\\s+(?:X\\s+Y\\s+Z\\s+)*\"\n            table_pattern = r\"\\s*[a-zA-Z][a-zA-Z\\s]\\s*([\\d\\-\\.]+)\\s*([\\d\\-\\.]+)\\s*([\\d\\-\\.]+)\\s*(?:([\\d\\-\\.]+)\\s*([\\d\\-\\.]+)\\s*([\\d\\-\\.]+)\\s*(?:([\\d\\-\\.]+)\\s*([\\d\\-\\.]+)\\s*([\\d\\-\\.]+))*)*\"\n            footer_pattern = r\"TransDip\\s+[\\d\\-\\.]+\\s*[\\d\\-\\.]+\\s*[\\d\\-\\.]+\\s*(?:[\\d\\-\\.]+\\s*[\\d\\-\\.]+\\s*[\\d\\-\\.]+\\s*)*\"\n            temp_freq_mode_vecs = read_table_pattern(\n                self.text, header_pattern, table_pattern, footer_pattern)\n            freq_mode_vecs = np.zeros(\n                shape=(len(freqs), len(temp_freq_mode_vecs[0]), 3))\n\n            for ii, triple_FMV in enumerate(temp_freq_mode_vecs):\n                for jj, line in enumerate(triple_FMV):\n                    for kk, entry in enumerate(line):\n                        if entry != 'None':\n                            freq_mode_vecs[int(ii * 3 + math.floor(kk / 3)),\n                                           jj, kk % 3] = float(entry)\n\n            self.data[\"frequency_mode_vectors\"] = freq_mode_vecs", "response": "Parses frequency data from the log file and returns a dictionary of frequency data."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _read_single_point_data(self):\n        temp_dict = read_pattern(\n            self.text, {\n                \"final_energy\":\n                    r\"\\s*SCF\\s+energy in the final basis set\\s+=\\s*([\\d\\-\\.]+)\"\n            })\n\n        if temp_dict.get('final_energy') == None:\n            self.data['final_energy'] = None\n        else:\n            # -1 in case of pcm\n            # Two lines will match the above; we want final calculation\n            self.data['final_energy'] = float(temp_dict.get('final_energy')[-1][0])", "response": "Parses final free energy information from single - point calculations."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _read_pcm_information(self):\n\n        temp_dict = read_pattern(\n            self.text, {\n                \"g_electrostatic\": r\"\\s*G_electrostatic\\s+=\\s+([\\d\\-\\.]+)\\s+hartree\\s+=\\s+([\\d\\-\\.]+)\\s+kcal/mol\\s*\",\n                \"g_cavitation\": r\"\\s*G_cavitation\\s+=\\s+([\\d\\-\\.]+)\\s+hartree\\s+=\\s+([\\d\\-\\.]+)\\s+kcal/mol\\s*\",\n                \"g_dispersion\": r\"\\s*G_dispersion\\s+=\\s+([\\d\\-\\.]+)\\s+hartree\\s+=\\s+([\\d\\-\\.]+)\\s+kcal/mol\\s*\",\n                \"g_repulsion\": r\"\\s*G_repulsion\\s+=\\s+([\\d\\-\\.]+)\\s+hartree\\s+=\\s+([\\d\\-\\.]+)\\s+kcal/mol\\s*\",\n                \"total_contribution_pcm\": r\"\\s*Total\\s+=\\s+([\\d\\-\\.]+)\\s+hartree\\s+=\\s+([\\d\\-\\.]+)\\s+kcal/mol\\s*\",\n            }\n        )\n\n        if temp_dict.get(\"g_electrostatic\") is None:\n            self.data[\"g_electrostatic\"] = None\n        else:\n            self.data[\"g_electrostatic\"] = float(temp_dict.get(\"g_electrostatic\")[0][0])\n\n        if temp_dict.get(\"g_cavitation\") is None:\n            self.data[\"g_cavitation\"] = None\n        else:\n            self.data[\"g_cavitation\"] = float(temp_dict.get(\"g_cavitation\")[0][0])\n\n        if temp_dict.get(\"g_dispersion\") is None:\n            self.data[\"g_dispersion\"] = None\n        else:\n            self.data[\"g_dispersion\"] = float(temp_dict.get(\"g_dispersion\")[0][0])\n\n        if temp_dict.get(\"g_repulsion\") is None:\n            self.data[\"g_repulsion\"] = None\n        else:\n            self.data[\"g_repulsion\"] = float(temp_dict.get(\"g_repulsion\")[0][0])\n\n        if temp_dict.get(\"total_contribution_pcm\") is None:\n            self.data[\"total_contribution_pcm\"] = []\n        else:\n            self.data[\"total_contribution_pcm\"] = float(temp_dict.get(\"total_contribution_pcm\")[0][0])", "response": "Parses PCM information from the PCM file and stores the values in the self. data attribute."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nparses three potential optimization errors and adds them to the internal data structure.", "response": "def _check_optimization_errors(self):\n        \"\"\"\n        Parses three potential optimization errors: failing to converge within the allowed number\n        of optimization cycles, failure to determine the lamda needed to continue, and inconsistent\n        size of MO files due to a linear dependence in the AO basis.\n        \"\"\"\n        if read_pattern(\n                self.text, {\n                    \"key\": r\"MAXIMUM OPTIMIZATION CYCLES REACHED\"\n                },\n                terminate_on_match=True).get('key') == [[]]:\n            self.data[\"errors\"] += [\"out_of_opt_cycles\"]\n        elif read_pattern(\n                self.text, {\n                    \"key\": r\"UNABLE TO DETERMINE Lamda IN FormD\"\n                },\n                terminate_on_match=True).get('key') == [[]]:\n            self.data[\"errors\"] += [\"unable_to_determine_lamda\"]\n        elif read_pattern(\n                self.text, {\n                    \"key\": r\"Inconsistent size for SCF MO coefficient file\"\n                },\n                terminate_on_match=True).get('key') == [[]]:\n            self.data[\"errors\"] += [\"linear_dependent_basis\"]"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nchecking for potential errors that can cause jobs to crash.", "response": "def _check_completion_errors(self):\n        \"\"\"\n        Parses four potential errors that can cause jobs to crash: inability to transform\n        coordinates due to a bad symmetric specification, an input file that fails to pass\n        inspection, and errors reading and writing files.\n        \"\"\"\n        if read_pattern(\n                self.text, {\n                    \"key\":\n                    r\"Coordinates do not transform within specified threshold\"\n                },\n                terminate_on_match=True).get('key') == [[]]:\n            self.data[\"errors\"] += [\"failed_to_transform_coords\"]\n        elif read_pattern(\n                self.text,\n            {\n                \"key\": r\"The Q\\-Chem input file has failed to pass inspection\"\n            },\n                terminate_on_match=True).get('key') == [[]]:\n            self.data[\"errors\"] += [\"input_file_error\"]\n        elif read_pattern(\n                self.text, {\n                    \"key\": r\"Error opening input stream\"\n                },\n                terminate_on_match=True).get('key') == [[]]:\n            self.data[\"errors\"] += [\"failed_to_read_input\"]\n        elif read_pattern(\n                self.text, {\n                    \"key\": r\"FileMan error: End of file reached prematurely\"\n                },\n                terminate_on_match=True).get('key') == [[]]:\n            self.data[\"errors\"] += [\"IO_error\"]\n        elif read_pattern(\n                self.text, {\n                    \"key\": r\"Could not find \\$molecule section in ParseQInput\"\n                },\n                terminate_on_match=True).get('key') == [[]]:\n            self.data[\"errors\"] += [\"read_molecule_error\"]\n        elif read_pattern(\n                self.text, {\n                    \"key\": r\"Welcome to Q-Chem\"\n                },\n                terminate_on_match=True).get('key') != [[]]:\n            self.data[\"errors\"] += [\"never_called_qchem\"]\n        else:\n            self.data[\"errors\"] += [\"unknown_error\"]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nquery the COD for a structure by id.", "response": "def get_structure_by_id(self, cod_id, **kwargs):\n        \"\"\"\n        Queries the COD for a structure by id.\n\n        Args:\n            cod_id (int): COD id.\n            kwargs: All kwargs supported by\n                :func:`pymatgen.core.structure.Structure.from_str`.\n\n        Returns:\n            A Structure.\n        \"\"\"\n        r = requests.get(\"http://www.crystallography.net/cod/%s.cif\" % cod_id)\n        return Structure.from_str(r.text, fmt=\"cif\", **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nquery the COD for structures by formula. Requires mysql executable to be in the path. Requires mysql executable to be in the path. Requires pymatgen. core. structure. Structure. from_str to be called.", "response": "def get_structure_by_formula(self, formula, **kwargs):\n        \"\"\"\n        Queries the COD for structures by formula. Requires mysql executable to\n        be in the path.\n\n        Args:\n            cod_id (int): COD id.\n            kwargs: All kwargs supported by\n                :func:`pymatgen.core.structure.Structure.from_str`.\n\n        Returns:\n            A list of dict of the format\n            [{\"structure\": Structure, \"cod_id\": cod_id, \"sg\": \"P n m a\"}]\n        \"\"\"\n        structures = []\n        sql = 'select file, sg from data where formula=\"- %s -\"' % \\\n              Composition(formula).hill_formula\n        text = self.query(sql).split(\"\\n\")\n        text.pop(0)\n        for l in text:\n            if l.strip():\n                cod_id, sg = l.split(\"\\t\")\n                r = requests.get(\"http://www.crystallography.net/cod/%s.cif\"\n                                 % cod_id.strip())\n                try:\n                    s = Structure.from_str(r.text, fmt=\"cif\", **kwargs)\n                    structures.append({\"structure\": s, \"cod_id\": int(cod_id),\n                                       \"sg\": sg})\n                except Exception:\n                    import warnings\n                    warnings.warn(\"\\nStructure.from_str failed while parsing CIF file:\\n%s\" % r.text)\n                    raise\n\n        return structures"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_csms(self, isite, mp_symbol):\n        cn = symbol_cn_mapping[mp_symbol]\n        if cn not in self.ce_list[isite]:\n            return []\n        else:\n            return [envs[mp_symbol] for envs in self.ce_list[isite][cn]]", "response": "Returns the continuous symmetry measure of site with index isite with respect to the\n         perfect coordination environment with mp_symbol."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef plot_csm_and_maps(self, isite, max_csm=8.0):\n        try:\n            import matplotlib.pyplot as plt\n        except ImportError:\n            print('Plotting Chemical Environments requires matplotlib ... exiting \"plot\" function')\n            return\n        fig = self.get_csm_and_maps(isite=isite, max_csm=max_csm)\n        if fig is None:\n            return\n        plt.show()", "response": "This function plots the coordination numbers of a given site for all the distfactor and angfactor parameters."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a matplotlib figure object that can be used to plot the chemical environments of a given site.", "response": "def get_environments_figure(self, isite, plot_type=None, title='Coordination numbers', max_dist=2.0,\n                                additional_condition=AC.ONLY_ACB, colormap=None, figsize=None,\n                                strategy=None):\n        \"\"\"\n        Plotting of the coordination environments of a given site for all the distfactor/angfactor regions. The\n        chemical environments with the lowest continuous symmetry measure is shown for each distfactor/angfactor\n        region as the value for the color of that distfactor/angfactor region (using a colormap).\n        :param isite: Index of the site for which the plot has to be done\n        :param plot_type: How to plot the coordinations\n        :param title: Title for the figure\n        :param max_dist: Maximum distance to be plotted when the plotting of the distance is set to 'initial_normalized'\n                         or 'initial_real' (Warning: this is not the same meaning in both cases! In the first case,\n                         the closest atom lies at a \"normalized\" distance of 1.0 so that 2.0 means refers to this\n                         normalized distance while in the second case, the real distance is used)\n        :param figsize: Size of the figure to be plotted\n        :return: The figure object to be plotted or saved to file\n        \"\"\"\n        try:\n            import matplotlib.pyplot as mpl\n            from matplotlib import cm\n            from matplotlib.colors import Normalize, LinearSegmentedColormap, ListedColormap\n            from matplotlib.patches import Rectangle, Polygon\n        except ImportError:\n            print('Plotting Chemical Environments requires matplotlib ... exiting \"plot\" function')\n            return\n\n        #Initializes the figure\n        if figsize is None:\n            fig = mpl.figure()\n        else:\n            fig = mpl.figure(figsize=figsize)\n        subplot = fig.add_subplot(111)\n\n        #Initializes the distance and angle parameters\n        if plot_type is None:\n            plot_type = {'distance_parameter': ('initial_normalized', None),\n                         'angle_parameter': ('initial_normalized_inverted', None)}\n        if colormap is None:\n            mycm = cm.jet\n        else:\n            mycm = colormap\n        mymin = 0.0\n        mymax = 10.0\n        norm = Normalize(vmin=mymin, vmax=mymax)\n        scalarmap = cm.ScalarMappable(norm=norm, cmap=mycm)\n        dist_limits = [1.0, max_dist]\n        ang_limits = [0.0, 1.0]\n        if plot_type['distance_parameter'][0] == 'one_minus_inverse_alpha_power_n':\n            if plot_type['distance_parameter'][1] is None:\n                exponent = 3\n            else:\n                exponent = plot_type['distance_parameter'][1]['exponent']\n            xlabel = 'Distance parameter : $1.0-\\\\frac{{1.0}}{{\\\\alpha^{{{:d}}}}}$'.format(exponent)\n            def dp_func(dp):\n                return 1.0-1.0/np.power(dp, exponent)\n        elif plot_type['distance_parameter'][0] == 'initial_normalized':\n            xlabel = 'Distance parameter : $\\\\alpha$'\n            def dp_func(dp):\n                return dp\n        else:\n            raise ValueError('Wrong value for distance parameter plot type \"{}\"'.\n                             format(plot_type['distance_parameter'][0]))\n\n        if plot_type['angle_parameter'][0] == 'one_minus_gamma':\n            ylabel = 'Angle parameter : $1.0-\\\\gamma$'\n            def ap_func(ap):\n                return 1.0-ap\n        elif plot_type['angle_parameter'][0] in ['initial_normalized_inverted', 'initial_normalized']:\n            ylabel = 'Angle parameter : $\\\\gamma$'\n            def ap_func(ap):\n                return ap\n        else:\n            raise ValueError('Wrong value for angle parameter plot type \"{}\"'.\n                             format(plot_type['angle_parameter'][0]))\n        dist_limits = [dp_func(dp) for dp in dist_limits]\n        ang_limits = [ap_func(ap) for ap in ang_limits]\n\n        for cn, cn_nb_sets in self.neighbors_sets[isite].items():\n            for inb_set, nb_set in enumerate(cn_nb_sets):\n                nb_set_surface_pts = nb_set.voronoi_grid_surface_points()\n                if nb_set_surface_pts is None:\n                    continue\n                ce = self.ce_list[isite][cn][inb_set]\n                if ce is None:\n                    mycolor = 'w'\n                    myinvcolor = 'k'\n                    mytext = '{:d}'.format(cn)\n                else:\n                    mingeom = ce.minimum_geometry()\n                    if mingeom is not None:\n                        mp_symbol = mingeom[0]\n                        csm = mingeom[1]['symmetry_measure']\n                        mycolor = scalarmap.to_rgba(csm)\n                        myinvcolor = [1.0 - mycolor[0], 1.0 - mycolor[1], 1.0 - mycolor[2], 1.0]\n                        mytext = '{}'.format(mp_symbol)\n                    else:\n                        mycolor = 'w'\n                        myinvcolor = 'k'\n                        mytext = '{:d}'.format(cn)\n                nb_set_surface_pts = [(dp_func(pt[0]), ap_func(pt[1])) for pt in nb_set_surface_pts]\n                polygon = Polygon(nb_set_surface_pts, closed=True, edgecolor='k', facecolor=mycolor, linewidth=1.2)\n                subplot.add_patch(polygon)\n                myipt = len(nb_set_surface_pts) / 2\n                ipt = int(myipt)\n                if myipt != ipt:\n                    raise RuntimeError('Number of surface points not even')\n                patch_center = ((nb_set_surface_pts[0][0] + min(nb_set_surface_pts[ipt][0], dist_limits[1])) / 2,\n                                (nb_set_surface_pts[0][1] + nb_set_surface_pts[ipt][1]) / 2)\n\n                if (np.abs(nb_set_surface_pts[-1][1] - nb_set_surface_pts[-2][1]) > 0.06 and\n                      np.abs(min(nb_set_surface_pts[-1][0], dist_limits[1]) - nb_set_surface_pts[0][0]) > 0.125):\n                    xytext = ((min(nb_set_surface_pts[-1][0], dist_limits[1]) + nb_set_surface_pts[0][0]) / 2,\n                              (nb_set_surface_pts[-1][1] + nb_set_surface_pts[-2][1]) / 2)\n                    subplot.annotate(mytext, xy=xytext,\n                                     ha='center', va='center', color=myinvcolor, fontsize='x-small')\n                elif (np.abs(nb_set_surface_pts[ipt][1] - nb_set_surface_pts[0][1]) > 0.1 and\n                    np.abs(min(nb_set_surface_pts[ipt][0], dist_limits[1]) - nb_set_surface_pts[0][0]) > 0.125):\n                    xytext = patch_center\n                    subplot.annotate(mytext, xy=xytext,\n                                     ha='center', va='center', color=myinvcolor, fontsize='x-small')\n\n        subplot.set_title(title)\n        subplot.set_xlabel(xlabel)\n        subplot.set_ylabel(ylabel)\n\n        dist_limits.sort()\n        ang_limits.sort()\n        subplot.set_xlim(dist_limits)\n        subplot.set_ylim(ang_limits)\n        if strategy is not None:\n            try:\n                strategy.add_strategy_visualization_to_subplot(subplot=subplot)\n            except:\n                pass\n        if plot_type['angle_parameter'][0] == 'initial_normalized_inverted':\n            subplot.axes.invert_yaxis()\n\n        scalarmap.set_array([mymin, mymax])\n        cb = fig.colorbar(scalarmap, ax=subplot, extend='max')\n        cb.set_label('Continuous symmetry measure')\n        return fig, subplot"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef plot_environments(self,  isite, plot_type=None, title='Coordination numbers', max_dist=2.0,\n                          additional_condition=AC.ONLY_ACB, figsize=None, strategy=None):\n        \"\"\"\n        Plotting of the coordination numbers of a given site for all the distfactor/angfactor parameters. If the\n        chemical environments are given, a color map is added to the plot, with the lowest continuous symmetry measure\n        as the value for the color of that distfactor/angfactor set.\n        :param isite: Index of the site for which the plot has to be done\n        :param plot_type: How to plot the coordinations\n        :param title: Title for the figure\n        :param max_dist: Maximum distance to be plotted when the plotting of the distance is set to 'initial_normalized'\n                         or 'initial_real' (Warning: this is not the same meaning in both cases! In the first case,\n                         the closest atom lies at a \"normalized\" distance of 1.0 so that 2.0 means refers to this\n                         normalized distance while in the second case, the real distance is used)\n        :param figsize: Size of the figure to be plotted\n        :return: Nothing returned, just plot the figure\n        \"\"\"\n        fig, subplot = self.get_environments_figure(isite=isite, plot_type=plot_type, title=title, max_dist=max_dist,\n                                                    additional_condition=additional_condition, figsize=figsize,\n                                                    strategy=strategy)\n        if fig is None:\n            return\n        fig.show()", "response": "This function plots the chemical environments of a given site."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef as_dict(self):\n        ce_list_dict = [{str(cn): [ce.as_dict() if ce is not None else None for ce in ce_dict[cn]]\n                         for cn in ce_dict} if ce_dict is not None else None for ce_dict in self.ce_list]\n        nbs_sets_dict = [{str(cn): [nb_set.as_dict() for nb_set in nb_sets]\n                          for cn, nb_sets in site_nbs_sets.items()}\n                         if site_nbs_sets is not None else None\n                         for site_nbs_sets in self.neighbors_sets]\n        info_dict = {key: val for key, val in self.info.items() if key not in ['sites_info']}\n        info_dict['sites_info'] = [{'nb_sets_info': {str(cn): {str(inb_set): nb_set_info\n                                                               for inb_set, nb_set_info in cn_sets.items()}\n                                                     for cn, cn_sets in site_info['nb_sets_info'].items()},\n                                    'time': site_info['time']} if 'nb_sets_info' in site_info else {}\n                                   for site_info in self.info['sites_info']]\n\n        return {\"@module\": self.__class__.__module__,\n                \"@class\": self.__class__.__name__,\n                \"voronoi\": self.voronoi.as_dict(),\n                \"valences\": self.valences,\n                \"sites_map\": self.sites_map,\n                \"equivalent_sites\": [[ps.as_dict() for ps in psl] for psl in self.equivalent_sites],\n                \"ce_list\": ce_list_dict,\n                \"structure\": self.structure.as_dict(),\n                \"neighbors_sets\": nbs_sets_dict,\n                \"info\": info_dict}", "response": "Return a dict representation of the StructureEnvironments object."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreconstruct the StructureEnvironments object from a dict representation of the StructureEnvironments created using the as_dict method.", "response": "def from_dict(cls, d):\n        \"\"\"\n        Reconstructs the StructureEnvironments object from a dict representation of the StructureEnvironments created\n        using the as_dict method.\n        :param d: dict representation of the StructureEnvironments object\n        :return: StructureEnvironments object\n        \"\"\"\n        ce_list = [None if (ce_dict == 'None' or ce_dict is None) else {\n            int(cn): [None if (ced is None or ced == 'None') else\n                      ChemicalEnvironments.from_dict(ced) for ced in ce_dict[cn]]\n            for cn in ce_dict} for ce_dict in d['ce_list']]\n        voronoi = DetailedVoronoiContainer.from_dict(d['voronoi'])\n        structure = Structure.from_dict(d['structure'])\n        neighbors_sets = [{int(cn): [cls.NeighborsSet.from_dict(dd=nb_set_dict,\n                                                                structure=structure,\n                                                                detailed_voronoi=voronoi)\n                                     for nb_set_dict in nb_sets]\n                           for cn, nb_sets in site_nbs_sets_dict.items()}\n                          if site_nbs_sets_dict is not None else None\n                          for site_nbs_sets_dict in d['neighbors_sets']]\n        info = {key: val for key, val in d['info'].items() if key not in ['sites_info']}\n        if 'sites_info' in d['info']:\n            info['sites_info'] = [{'nb_sets_info': {int(cn): {int(inb_set): nb_set_info\n                                                              for inb_set, nb_set_info in cn_sets.items()}\n                                                    for cn, cn_sets in site_info['nb_sets_info'].items()},\n                                   'time': site_info['time']} if 'nb_sets_info' in site_info else {}\n                                  for site_info in d['info']['sites_info']]\n        return cls(voronoi=voronoi, valences=d['valences'],\n                   sites_map=d['sites_map'],\n                   equivalent_sites=[[PeriodicSite.from_dict(psd) for psd in psl] for psl in d['equivalent_sites']],\n                   ce_list=ce_list, structure=structure,\n                   neighbors_sets=neighbors_sets,\n                   info=info)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef structure_contains_atom_environment(self, atom_symbol, ce_symbol):\n        for isite, site in enumerate(self.structure):\n            if (Element(atom_symbol) in site.species.\n                    element_composition and self.site_contains_environment(isite, ce_symbol)):\n                return True\n        return False", "response": "Checks whether the structure contains a given atom in a given coordination environment."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a dict representation of the LightStructureEnvironments object.", "response": "def as_dict(self):\n        \"\"\"\n        Bson-serializable dict representation of the LightStructureEnvironments object.\n        :return: Bson-serializable dict representation of the LightStructureEnvironments object.\n        \"\"\"\n        return {\"@module\": self.__class__.__module__,\n                \"@class\": self.__class__.__name__,\n                \"strategy\": self.strategy.as_dict(),\n                \"structure\": self.structure.as_dict(),\n                \"coordination_environments\": self.coordination_environments,\n                \"all_nbs_sites\": [{'site': nb_site['site'].as_dict(),\n                                   'index': nb_site['index'],\n                                   'image_cell': [int(ii) for ii in nb_site['image_cell']]}\n                                  for nb_site in self._all_nbs_sites],\n                \"neighbors_sets\": [[nb_set.as_dict() for nb_set in site_nb_sets] if site_nb_sets is not None else None\n                                   for site_nb_sets in self.neighbors_sets],\n                \"valences\": self.valences}"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreconstructs the LightStructureEnvironments object from a dict representation of the LightStructureEnvironments object.", "response": "def from_dict(cls, d):\n        \"\"\"\n        Reconstructs the LightStructureEnvironments object from a dict representation of the\n        LightStructureEnvironments created using the as_dict method.\n        :param d: dict representation of the LightStructureEnvironments object\n        :return: LightStructureEnvironments object\n        \"\"\"\n        dec = MontyDecoder()\n        structure = dec.process_decoded(d['structure'])\n        all_nbs_sites = []\n        for nb_site in d['all_nbs_sites']:\n            site = dec.process_decoded(nb_site['site'])\n            if 'image_cell' in nb_site:\n                image_cell = np.array(nb_site['image_cell'], np.int)\n            else:\n                diff = site.frac_coords - structure[nb_site['index']].frac_coords\n                rounddiff = np.round(diff)\n                if not np.allclose(diff, rounddiff):\n                    raise ValueError('Weird, differences between one site in a periodic image cell is not '\n                                     'integer ...')\n                image_cell = np.array(rounddiff, np.int)\n            all_nbs_sites.append({'site': site,\n                                  'index': nb_site['index'],\n                                  'image_cell': image_cell})\n        neighbors_sets = [[cls.NeighborsSet.from_dict(dd=nb_set, structure=structure,\n                                                      all_nbs_sites=all_nbs_sites)\n                           for nb_set in site_nb_sets] if site_nb_sets is not None else None\n                          for site_nb_sets in d['neighbors_sets']]\n        return cls(strategy=dec.process_decoded(d['strategy']),\n                   coordination_environments=d['coordination_environments'],\n                   all_nbs_sites=all_nbs_sites,\n                   neighbors_sets=neighbors_sets,\n                   structure=structure,\n                   valences=d['valences'])"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef minimum_geometry(self, symmetry_measure_type=None, max_csm=None):\n        if len(self.coord_geoms) == 0:\n            return None\n        cglist = [cg for cg in self.coord_geoms]\n        if symmetry_measure_type is None:\n            csms = np.array([self.coord_geoms[cg]['other_symmetry_measures']['csm_wcs_ctwcc'] for cg in cglist])\n        else:\n            csms = np.array([self.coord_geoms[cg]['other_symmetry_measures'][symmetry_measure_type] for cg in cglist])\n        csmlist = [self.coord_geoms[cg] for cg in cglist]\n        imin = np.argmin(csms)\n        if max_csm is not None:\n            if csmlist[imin] > max_csm:\n                return None\n        return cglist[imin], csmlist[imin]", "response": "Returns the geometry with the minimum continuous symmetry measure of this ChemicalEnvironments object and csm associated to it."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a list of geometries with increasing continuous symmetry measure in this ChemicalEnvironments object.", "response": "def minimum_geometries(self, n=None, symmetry_measure_type=None, max_csm=None):\n        \"\"\"\n        Returns a list of geometries with increasing continuous symmetry measure in this ChemicalEnvironments object\n        :param n: Number of geometries to be included in the list\n        :return: list of geometries with increasing continuous symmetry measure in this ChemicalEnvironments object\n        :raise: ValueError if no coordination geometry is found in this ChemicalEnvironments object\n        \"\"\"\n        cglist = [cg for cg in self.coord_geoms]\n        if symmetry_measure_type is None:\n            csms = np.array([self.coord_geoms[cg]['other_symmetry_measures']['csm_wcs_ctwcc'] for cg in cglist])\n        else:\n            csms = np.array([self.coord_geoms[cg]['other_symmetry_measures'][symmetry_measure_type] for cg in cglist])\n        csmlist = [self.coord_geoms[cg] for cg in cglist]\n        isorted = np.argsort(csms)\n        if max_csm is not None:\n            if n is None:\n                return [(cglist[ii], csmlist[ii]) for ii in isorted if csms[ii] <= max_csm]\n            else:\n                return [(cglist[ii], csmlist[ii]) for ii in isorted[:n] if csms[ii] <= max_csm]\n        else:\n            if n is None:\n                return [(cglist[ii], csmlist[ii]) for ii in isorted]\n            else:\n                return [(cglist[ii], csmlist[ii]) for ii in isorted[:n]]"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add_coord_geom(self, mp_symbol, symmetry_measure, algo='UNKNOWN', permutation=None, override=False,\n                       local2perfect_map=None, perfect2local_map=None, detailed_voronoi_index=None,\n                       other_symmetry_measures=None, rotation_matrix=None, scaling_factor=None):\n        \"\"\"\n        Adds a coordination geometry to the ChemicalEnvironments object\n        :param mp_symbol: Symbol (internal) of the coordination geometry added\n        :param symmetry_measure: Symmetry measure of the coordination geometry added\n        :param algo: Algorithm used for the search of the coordination geometry added\n        :param permutation: Permutation of the neighbors that leads to the csm stored\n        :param override: If set to True, the coordination geometry will override the existent one if present\n        :return: :raise: ChemenvError if the coordination geometry is already added and override is set to False\n        \"\"\"\n        if not allcg.is_a_valid_coordination_geometry(mp_symbol=mp_symbol):\n            raise ChemenvError(self.__class__,\n                               'add_coord_geom',\n                               'Coordination geometry with mp_symbol \"{mp}\" is not valid'\n                               .format(mp=mp_symbol))\n        if mp_symbol in list(self.coord_geoms.keys()) and not override:\n            raise ChemenvError(self.__class__,\n                               \"add_coord_geom\",\n                               \"This coordination geometry is already present and override is set to False\")\n        else:\n            self.coord_geoms[mp_symbol] = {'symmetry_measure': float(symmetry_measure), 'algo': algo,\n                                           'permutation': [int(i) for i in permutation],\n                                           'local2perfect_map': local2perfect_map,\n                                           'perfect2local_map': perfect2local_map,\n                                           'detailed_voronoi_index': detailed_voronoi_index,\n                                           'other_symmetry_measures': other_symmetry_measures,\n                                           'rotation_matrix': rotation_matrix,\n                                           'scaling_factor': scaling_factor}", "response": "Adds a coordination geometry to the ChemicalEnvironments object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef as_dict(self):\n        return {\"@module\": self.__class__.__module__,\n                \"@class\": self.__class__.__name__,\n                \"coord_geoms\": jsanitize(self.coord_geoms)}", "response": "Returns a dictionary representation of the ChemicalEnvironments object."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreconstructs the ChemicalEnvironments object from a dict representation of the ChemicalEnvironments created by as_dict method.", "response": "def from_dict(cls, d):\n        \"\"\"\n        Reconstructs the ChemicalEnvironments object from a dict representation of the ChemicalEnvironments created\n        using the as_dict method.\n        :param d: dict representation of the ChemicalEnvironments object\n        :return: ChemicalEnvironments object\n        \"\"\"\n        ce = cls()\n        for cg in d['coord_geoms'].keys():\n            if d['coord_geoms'][cg]['local2perfect_map'] is None:\n                l2p_map = None\n            else:\n                l2p_map = {int(key): int(val) for key, val in d['coord_geoms'][cg]['local2perfect_map'].items()}\n            if d['coord_geoms'][cg]['perfect2local_map'] is None:\n                p2l_map = None\n            else:\n                p2l_map = {int(key): int(val) for key, val in d['coord_geoms'][cg]['perfect2local_map'].items()}\n            if ('other_symmetry_measures' in d['coord_geoms'][cg] and\n                        d['coord_geoms'][cg]['other_symmetry_measures'] is not None):\n                other_csms = d['coord_geoms'][cg]['other_symmetry_measures']\n            else:\n                other_csms = None\n            ce.add_coord_geom(cg,\n                              d['coord_geoms'][cg]['symmetry_measure'],\n                              d['coord_geoms'][cg]['algo'],\n                              permutation=d['coord_geoms'][cg]['permutation'],\n                              local2perfect_map=l2p_map,\n                              perfect2local_map=p2l_map,\n                              detailed_voronoi_index=d['coord_geoms'][cg]['detailed_voronoi_index'],\n                              other_symmetry_measures=other_csms,\n                              rotation_matrix=d['coord_geoms'][cg]['rotation_matrix'],\n                              scaling_factor=d['coord_geoms'][cg]['scaling_factor'])\n        return ce"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef icohplist(self):\n        icohplist_new = {}\n        for key, value in self._icohpcollection._icohplist.items():\n            icohplist_new[key] = {\"length\": value._length, \"number_of_bonds\": value._num,\n                                  \"icohp\": value._icohp, \"translation\": value._translation}\n        return icohplist_new", "response": "Returns a new icohplist compatible with older version of this class"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_structure_with_charges(self, structure_filename):\n\n        struct = Structure.from_file(structure_filename)\n        Mulliken = self.Mulliken\n        Loewdin = self.Loewdin\n        site_properties = {\"Mulliken Charges\": Mulliken, \"Loewdin Charges\": Loewdin}\n        new_struct = struct.copy(site_properties=site_properties)\n        return new_struct", "response": "get a Structure object with Mulliken and Loewdin charges as site properties"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a LobsterBandStructureSymmLine object which can be plotted with a normal BSPlotter", "response": "def get_bandstructure(self):\n        \"\"\"\n        returns a LobsterBandStructureSymmLine object which can be plotted with a normal BSPlotter\n        \"\"\"\n\n        return LobsterBandStructureSymmLine(kpoints=self.kpoints_array, eigenvals=self.eigenvals, lattice=self.lattice,\n                                            efermi=self.efermi, labels_dict=self.label_dict,\n                                            structure=self.structure,\n                                            projections=self.p_eigenvals)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the decomposition leading to lowest cost", "response": "def get_lowest_decomposition(self, composition):\n        \"\"\"\n        Get the decomposition leading to lowest cost\n\n        Args:\n            composition:\n                Composition as a pymatgen.core.structure.Composition\n        Returns:\n            Decomposition as a dict of {Entry: amount}\n        \"\"\"\n\n        entries_list = []\n        elements = [e.symbol for e in composition.elements]\n        for i in range(len(elements)):\n            for combi in itertools.combinations(elements, i + 1):\n                chemsys = [Element(e) for e in combi]\n                x = self.costdb.get_entries(chemsys)\n                entries_list.extend(x)\n        try:\n            pd = PhaseDiagram(entries_list)\n            return pd.get_decomposition(composition)\n        except IndexError:\n            raise ValueError(\"Error during PD building; most likely, \"\n                             \"cost data does not exist!\")"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_cost_per_mol(self, comp):\n\n        comp = comp if isinstance(comp, Composition) else Composition(comp)\n        decomp = self.get_lowest_decomposition(comp)\n        return sum(k.energy_per_atom * v * comp.num_atoms for k, v in\n                   decomp.items())", "response": "Get best estimate of minimum cost per mol based on known data."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_cost_per_kg(self, comp):\n        comp = comp if isinstance(comp, Composition) else Composition(comp)\n        return self.get_cost_per_mol(comp) / (\n            comp.weight.to(\"kg\") * const.N_A)", "response": "Get best estimate of minimum cost per kg based on known data."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconvert a string into a boolean.", "response": "def as_bool(s):\n    \"\"\"\n    Convert a string into a boolean.\n\n    >>> assert as_bool(True) is True and as_bool(\"Yes\") is True and as_bool(\"false\") is False\n    \"\"\"\n    if s in (False, True): return s\n    # Assume string\n    s = s.lower()\n    if s in (\"yes\", \"true\"):\n        return True\n    elif s in (\"no\", \"false\"):\n        return False\n    else:\n        raise ValueError(\"Don't know how to convert type %s: %s into a boolean\" % (type(s), s))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsplits the ABINIT extension from a filename.", "response": "def abi_splitext(filename):\n    \"\"\"\n    Split the ABINIT extension from a filename.\n    \"Extension\" are found by searching in an internal database.\n\n    Returns \"(root, ext)\" where ext is the registered ABINIT extension\n    The final \".nc\" is included (if any)\n\n    >>> assert abi_splitext(\"foo_WFK\") == ('foo_', 'WFK')\n    >>> assert abi_splitext(\"/home/guido/foo_bar_WFK.nc\") == ('foo_bar_', 'WFK.nc')\n    \"\"\"\n    filename = os.path.basename(filename)\n    is_ncfile = False\n    if filename.endswith(\".nc\"):\n        is_ncfile = True\n        filename = filename[:-3]\n\n    known_extensions = abi_extensions()\n\n    # This algorith fails if we have two files\n    # e.g. HAYDR_SAVE, ANOTHER_HAYDR_SAVE\n    for i in range(len(filename)-1, -1, -1):\n        ext = filename[i:]\n        if ext in known_extensions:\n            break\n\n    else:\n        raise ValueError(\"Cannot find a registered extension in %s\" % filename)\n\n    root = filename[:i]\n    if is_ncfile:\n        ext += \".nc\"\n\n    return root, ext"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconverts a Mongodb - like dictionary to a list of operands and operators.", "response": "def map2rpn(map, obj):\n    \"\"\"\n    Convert a Mongodb-like dictionary to a RPN list of operands and operators.\n\n    Reverse Polish notation (RPN) is a mathematical notation in which every\n    operator follows all of its operands, e.g.\n\n    3 - 4 + 5 -->   3 4 - 5 +\n\n    >>> d = {2.0: {'$eq': 1.0}}\n    >>> assert map2rpn(d, None) == [2.0, 1.0, '$eq']\n    \"\"\"\n    rpn = []\n\n    for k, v in map.items():\n\n        if k in _ALL_OPS:\n            if isinstance(v, collections.abc.Mapping):\n                # e.g \"$not\": {\"$gt\": \"one\"}\n                # print(\"in op_vmap\",k, v)\n                values = map2rpn(v, obj)\n                rpn.extend(values)\n                rpn.append(k)\n\n            elif isinstance(v, (list, tuple)):\n                # e.g \"$and\": [{\"$not\": {\"one\": 1.0}}, {\"two\": {\"$lt\": 3}}]}\n                # print(\"in_op_list\",k, v)\n                for d in v:\n                    rpn.extend(map2rpn(d, obj))\n\n                rpn.append(k)\n\n            else:\n                # Examples\n                # 1) \"$eq\"\": \"attribute_name\"\n                # 2) \"$eq\"\": 1.0\n                try:\n                    #print(\"in_otherv\",k, v)\n                    rpn.append(getattr(obj, v))\n                    rpn.append(k)\n\n                except TypeError:\n                    #print(\"in_otherv, raised\",k, v)\n                    rpn.extend([v, k])\n        else:\n            try:\n                k = getattr(obj, k)\n            except TypeError:\n                k = k\n\n            if isinstance(v, collections.abc.Mapping):\n                # \"one\": {\"$eq\": 1.0}}\n                values = map2rpn(v, obj)\n                rpn.append(k)\n                rpn.extend(values)\n            else:\n                #\"one\": 1.0\n                rpn.extend([k, v, \"$eq\"])\n\n    return rpn"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nevaluate the RPN form produced my map2rpn.", "response": "def evaluate_rpn(rpn):\n    \"\"\"\n    Evaluates the RPN form produced my map2rpn.\n\n    Returns:\n        bool\n    \"\"\"\n    vals_stack = []\n\n    for item in rpn:\n\n        if item in _ALL_OPS:\n            # Apply the operator and push to the task.\n            v2 = vals_stack.pop()\n\n            if item in _UNARY_OPS:\n                res = _UNARY_OPS[item](v2)\n\n            elif item in _BIN_OPS:\n                v1 = vals_stack.pop()\n                res = _BIN_OPS[item](v1, v2)\n            else:\n                raise ValueError(\"%s not in unary_ops or bin_ops\" % str(item))\n\n            vals_stack.append(res)\n\n        else:\n            # Push the operand\n            vals_stack.append(item)\n\n        #print(vals_stack)\n\n    assert len(vals_stack) == 1\n    assert isinstance(vals_stack[0], bool)\n\n    return vals_stack[0]"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef write(self, string):\n        self.make_dir()\n        with open(self.path, \"w\") as f:\n            if not string.endswith(\"\\n\"):\n                return f.write(string + \"\\n\")\n            else:\n                return f.write(string)", "response": "Write string to file."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef writelines(self, lines):\n        self.make_dir()\n        with open(self.path, \"w\") as f:\n            return f.writelines(lines)", "response": "Write a list of strings to file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef make_dir(self):\n        if not os.path.exists(self.dirname):\n            os.makedirs(self.dirname)", "response": "Make the directory where the file is located."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef list_filepaths(self, wildcard=None):\n        # Select the files in the directory.\n        fnames = [f for f in os.listdir(self.path)]\n        filepaths = filter(os.path.isfile, [os.path.join(self.path, f) for f in fnames])\n\n        # Filter using the shell patterns.\n        if wildcard is not None:\n            filepaths = WildCard(wildcard).filter(filepaths)\n\n        return filepaths", "response": "Returns the list of absolute filepaths in the directory."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the absolute path of the ABINIT file with extension ext.", "response": "def has_abiext(self, ext, single_file=True):\n        \"\"\"\n        Returns the absolute path of the ABINIT file with extension ext.\n        Support both Fortran files and netcdf files. In the later case,\n        we check whether a file with extension ext + \".nc\" is present\n        in the directory. Returns empty string is file is not present.\n\n        Raises:\n            `ValueError` if multiple files with the given ext are found.\n            This implies that this method is not compatible with multiple datasets.\n        \"\"\"\n        if ext != \"abo\":\n            ext = ext if ext.startswith('_') else '_' + ext\n\n        files = []\n        for f in self.list_filepaths():\n            # For the time being, we ignore DDB files in nc format.\n            if ext == \"_DDB\" and f.endswith(\".nc\"): continue\n            # Ignore BSE text files e.g. GW_NLF_MDF\n            if ext == \"_MDF\" and not f.endswith(\".nc\"): continue\n            # Ignore DDK.nc files (temporary workaround for v8.8.2 in which\n            # the DFPT code produces a new file with DDK.nc extension that enters\n            # into conflict with AbiPy convention.\n            if ext == \"_DDK\" and f.endswith(\".nc\"): continue\n\n            if f.endswith(ext) or f.endswith(ext + \".nc\"):\n                files.append(f)\n\n        # This should fix the problem with the 1WF files in which the file extension convention is broken\n        if not files:\n            files = [f for f in self.list_filepaths() if fnmatch(f, \"*%s*\" % ext)]\n\n        if not files:\n            return \"\"\n\n        if len(files) > 1 and single_file:\n            # ABINIT users must learn that multiple datasets are bad!\n            raise ValueError(\"Found multiple files with the same extensions:\\n %s\\n\" % files +\n                             \"Please avoid using multiple datasets!\")\n\n        return files[0] if single_file else files"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating a simbolic link to the given file extension.", "response": "def symlink_abiext(self, inext, outext):\n        \"\"\"\n        Create a simbolic link (outext --> inext). The file names are implicitly\n        given by the ABINIT file extension.\n\n        Example:\n\n            outdir.symlink_abiext('1WF', 'DDK')\n\n        creates the link out_DDK that points to out_1WF\n\n        Return: 0 if success.\n\n        Raise: RuntimeError\n        \"\"\"\n        infile = self.has_abiext(inext)\n        if not infile:\n            raise RuntimeError('no file with extension %s in %s' % (inext, self))\n\n        for i in range(len(infile) - 1, -1, -1):\n            if infile[i] == '_':\n                break\n        else:\n            raise RuntimeError('Extension %s could not be detected in file %s' % (inext, infile))\n\n        outfile = infile[:i] + '_' + outext\n\n        if os.path.exists(outfile):\n            if os.path.islink(outfile):\n                if os.path.realpath(outfile) == infile:\n                    logger.debug(\"link %s already exists but it's ok because it points to the correct file\" % outfile)\n                    return 0\n                else:\n                    raise RuntimeError(\"Expecting link at %s already exists but it does not point to %s\" % (outfile, infile))\n            else:\n                raise RuntimeError('Expecting link at %s but found file.' % outfile)\n\n        os.symlink(infile, outfile)\n        return 0"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef rename_abiext(self, inext, outext):\n        infile = self.has_abiext(inext)\n        if not infile:\n            raise RuntimeError('no file with extension %s in %s' % (inext, self))\n\n        for i in range(len(infile) - 1, -1, -1):\n            if infile[i] == '_':\n                break\n        else:\n            raise RuntimeError('Extension %s could not be detected in file %s' % (inext, infile))\n\n        outfile = infile[:i] + '_' + outext\n        shutil.move(infile, outfile)\n        return 0", "response": "Rename the Abinit file with extension inext with the new extension outext"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef copy_abiext(self, inext, outext):\n        infile = self.has_abiext(inext)\n        if not infile:\n            raise RuntimeError('no file with extension %s in %s' % (inext, self))\n\n        for i in range(len(infile) - 1, -1, -1):\n            if infile[i] == '_':\n                break\n        else:\n            raise RuntimeError('Extension %s could not be detected in file %s' % (inext, infile))\n\n        outfile = infile[:i] + '_' + outext\n        shutil.copy(infile, outfile)\n        return 0", "response": "Copy the Abinit file with extension inext to a new file withw extension outext"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef remove_exts(self, exts):\n        paths = []\n\n        for ext in list_strings(exts):\n            path = self.has_abiext(ext)\n            if not path: continue\n            try:\n                os.remove(path)\n                paths.append(path)\n            except IOError:\n                logger.warning(\"Exception while trying to remove file %s\" % path)\n\n        return paths", "response": "Remove the files with the given extensions."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef find_last_timden_file(self):\n        regex = re.compile(r\"out_TIM(\\d+)_DEN(.nc)?$\")\n\n        timden_paths = [f for f in self.list_filepaths() if regex.match(os.path.basename(f))]\n        if not timden_paths: return None\n\n        # Build list of (step, path) tuples.\n        stepfile_list = []\n        for path in timden_paths:\n            name = os.path.basename(path)\n            match = regex.match(name)\n            step, ncext = match.groups()\n            stepfile_list.append((int(step), path))\n\n        # DSU sort.\n        last = sorted(stepfile_list, key=lambda t: t[0])[-1]\n        return dict2namedtuple(step=last[0], path=last[1])", "response": "This function finds the last TIM?_DEN file in the directory and returns a namedtuple of the path and step number."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef find_1wf_files(self):\n        regex = re.compile(r\"out_1WF(\\d+)(\\.nc)?$\")\n\n        wf_paths = [f for f in self.list_filepaths() if regex.match(os.path.basename(f))]\n        if not wf_paths: return None\n\n        # Build list of (pertcase, path) tuples.\n        pertfile_list = []\n        for path in wf_paths:\n            name = os.path.basename(path)\n            match = regex.match(name)\n            pertcase, ncext = match.groups()\n            pertfile_list.append((int(pertcase), path))\n\n        # DSU sort.\n        pertfile_list = sorted(pertfile_list, key=lambda t: t[0])\n        return [dict2namedtuple(pertcase=item[0], path=item[1]) for item in pertfile_list]", "response": "This method scans the directory structure and returns a list of namedtuple\n       "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef find_1den_files(self):\n        regex = re.compile(r\"out_DEN(\\d+)(\\.nc)?$\")\n        den_paths = [f for f in self.list_filepaths() if regex.match(os.path.basename(f))]\n        if not den_paths: return None\n\n        # Build list of (pertcase, path) tuples.\n        pertfile_list = []\n        for path in den_paths:\n            name = os.path.basename(path)\n            match = regex.match(name)\n            pertcase, ncext = match.groups()\n            pertfile_list.append((int(pertcase), path))\n\n        # DSU sort.\n        pertfile_list = sorted(pertfile_list, key=lambda t: t[0])\n        return [dict2namedtuple(pertcase=item[0], path=item[1]) for item in pertfile_list]", "response": "This method scans the directory tree for 1DEN files and returns a list of namedtuples each containing the path of the 1DEN file and the idir - ipert index."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef fix_paths(self, paths):\n        old2new, fixed_exts = {}, []\n\n        for path in list_strings(paths):\n            newpath, ext = self._fix_path(path)\n\n            if newpath is not None:\n                #if ext not in fixed_exts:\n                #    if ext == \"1WF\": continue\n                #    raise ValueError(\"Unknown extension %s\" % ext)\n                #print(ext, path, fixed_exts)\n                #if ext != '1WF':\n                #    assert ext not in fixed_exts\n                if ext not in fixed_exts:\n                    if ext == \"1WF\": continue\n                    raise ValueError(\"Unknown extension %s\" % ext)\n                fixed_exts.append(ext)\n                old2new[path] = newpath\n\n        return old2new", "response": "Fix the filenames in the iterable paths\n            - > new_path - > new_path - > new_path - > new_path - > new_path - > new_path - > old_path - > new_path - > new_path - > new_path - > new_path - > new_path - > new_path - > new_path - > new_path - > new_path - > new_path - > new_path"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nconverting obj into a condition object.", "response": "def as_condition(cls, obj):\n        \"\"\"Convert obj into :class:`Condition`\"\"\"\n        if isinstance(obj, cls):\n            return obj\n        else:\n            return cls(cmap=obj)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef plot(self, ax=None, **kwargs):\n        ax, fig, plt = get_ax_fig_plt(ax)\n\n        yy = [len(v) for v in self.values]\n        ax.plot(self.binvals, yy, **kwargs)\n\n        return fig", "response": "Plot the histogram with matplotlib returns matplotlib figure."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_cluster_graph(self, engine=\"fdp\", graph_attr=None, node_attr=None, edge_attr=None):\n        # https://www.graphviz.org/doc/info/\n        from graphviz import Digraph\n        g = Digraph(\"directory\", #filename=\"flow_%s.gv\" % os.path.basename(self.relworkdir),\n            engine=engine) # if engine == \"automatic\" else engine)\n\n        # Set graph attributes.\n        #g.attr(label=\"%s@%s\" % (self.__class__.__name__, self.relworkdir))\n        g.attr(label=self.top)\n        #g.attr(fontcolor=\"white\", bgcolor='purple:pink')\n        #g.attr(rankdir=\"LR\", pagedir=\"BL\")\n        #g.attr(constraint=\"false\", pack=\"true\", packMode=\"clust\")\n        g.node_attr.update(color='lightblue2', style='filled')\n        #g.node_attr.update(ranksep='equally')\n\n        # Add input attributes.\n        if graph_attr is not None:\n            fg.graph_attr.update(**graph_attr)\n        if node_attr is not None:\n            fg.node_attr.update(**node_attr)\n        if edge_attr is not None:\n            fg.edge_attr.update(**edge_attr)\n\n        def node_kwargs(path):\n            return dict(\n                #shape=\"circle\",\n                #shape=\"none\",\n                #shape=\"plaintext\",\n                #shape=\"point\",\n                shape=\"record\",\n                #color=node.color_hex,\n                fontsize=\"8.0\",\n                label=os.path.basename(path),\n            )\n\n        edge_kwargs = dict(arrowType=\"vee\", style=\"solid\", minlen=\"1\")\n        cluster_kwargs = dict(rankdir=\"LR\", pagedir=\"BL\", style=\"rounded\", bgcolor=\"azure2\")\n\n        # TODO: Write other method without clusters if not walk.\n        exclude_top_node = False\n        for root, dirs, files in os.walk(self.top):\n            if exclude_top_node and root == self.top: continue\n            cluster_name = \"cluster_%s\" % root\n            #print(\"root\", root, cluster_name, \"dirs\", dirs, \"files\", files, sep=\"\\n\")\n\n            with g.subgraph(name=cluster_name) as d:\n                d.attr(**cluster_kwargs)\n                d.attr(rank=\"source\" if (files or dirs) else \"sink\")\n                d.attr(label=os.path.basename(root))\n                for f in files:\n                    filepath = os.path.join(root, f)\n                    d.node(filepath, **node_kwargs(filepath))\n                    if os.path.islink(filepath):\n                        # Follow the link and use the relpath wrt link as label.\n                        realp = os.path.realpath(filepath)\n                        realp = os.path.relpath(realp, filepath)\n                        #realp = os.path.relpath(realp, self.top)\n                        #print(filepath, realp)\n                        #g.node(realp, **node_kwargs(realp))\n                        g.edge(filepath, realp, **edge_kwargs)\n\n                for dirname in dirs:\n                    dirpath = os.path.join(root, dirname)\n                    #head, basename = os.path.split(dirpath)\n                    new_cluster_name = \"cluster_%s\" % dirpath\n                    #rank = \"source\" if os.listdir(dirpath) else \"sink\"\n                    #g.node(dirpath, rank=rank, **node_kwargs(dirpath))\n                    #g.edge(dirpath, new_cluster_name, **edge_kwargs)\n                    #d.edge(cluster_name, new_cluster_name, minlen=\"2\", **edge_kwargs)\n                    d.edge(cluster_name, new_cluster_name, **edge_kwargs)\n        return g", "response": "Generate a DOT language directory graph in the DOT language. Directories are shown as clusters and edges are shown as clusters."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the entry energy for the target entry in the given PhaseDiagram object.", "response": "def _get_entry_energy(pd, composition):\n        \"\"\"\n        Finds the lowest entry energy for entries matching the composition.\n        Entries with non-negative formation energies are excluded. If no\n        entry is found, use the convex hull energy for the composition.\n\n        Args:\n            pd (PhaseDiagram): PhaseDiagram object.\n            composition (Composition): Composition object that the target\n            entry should match.\n\n        Returns:\n            The lowest entry energy among entries matching the composition.\n        \"\"\"\n        candidate = [i.energy_per_atom for i in pd.qhull_entries if\n                     i.composition.fractional_composition ==\n                     composition.fractional_composition]\n\n        if not candidate:\n            warnings.warn(\"The reactant \" + composition.reduced_formula +\n                          \" has no matching entry with negative formation\"\n                          \" energy, instead convex hull energy for this\"\n                          \" composition will be used for reaction energy \"\n                          \"calculation. \")\n            return pd.get_hull_energy(composition)\n        else:\n            min_entry_energy = min(candidate)\n            return min_entry_energy * composition.num_atoms"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _get_grand_potential(self, composition):\n        if self.use_hull_energy:\n            grand_potential = self.pd_non_grand.get_hull_energy(composition)\n        else:\n            grand_potential = InterfacialReactivity._get_entry_energy(\n                self.pd_non_grand, composition)\n        grand_potential -= sum([composition[e] * mu\n                                for e, mu in self.pd.chempots.items()])\n        if self.norm:\n            # Normalizes energy to the composition excluding element(s)\n            # from reservoir.\n            grand_potential /= sum([composition[el]\n                                    for el in composition\n                                    if el not in self.pd.chempots])\n        return grand_potential", "response": "Computes the grand potential at a given composition and chemical potentials."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _get_energy(self, x):\n        return self.pd.get_hull_energy(self.comp1 * x + self.comp2 * (1-x)) - \\\n            self.e1 * x - self.e2 * (1-x)", "response": "Returns the reaction energy in eV for the given mixing ratio x."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _get_reaction(self, x):\n        mix_comp = self.comp1 * x + self.comp2 * (1-x)\n        decomp = self.pd.get_decomposition(mix_comp)\n\n        # Uses original composition for reactants.\n        if np.isclose(x, 0):\n            reactant = [self.c2_original]\n        elif np.isclose(x, 1):\n            reactant = [self.c1_original]\n        else:\n            reactant = list(set([self.c1_original, self.c2_original]))\n\n        if self.grand:\n            reactant += [Composition(e.symbol)\n                         for e, v in self.pd.chempots.items()]\n\n        product = [Composition(k.name) for k, v in decomp.items()]\n        reaction = Reaction(reactant, product)\n\n        x_original = self._get_original_composition_ratio(reaction)\n        if np.isclose(x_original, 1):\n            reaction.normalize_to(self.c1_original, x_original)\n        else:\n            reaction.normalize_to(self.c2_original, 1-x_original)\n        return reaction", "response": "Returns a balanced reaction at mixing ratio x."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _get_elmt_amt_in_rxt(self, rxt):\n        return sum([rxt.get_el_amount(e) for e in self.pd.elements])", "response": "Calculates the total number of atoms in a reaction formula for elements\n            not in external reservoir elements."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a list of all potential products. E. g. [ Li O2 Mu ]", "response": "def get_products(self):\n        \"\"\"\n        List of formulas of potential products. E.g., ['Li','O2','Mn'].\n        \"\"\"\n        products = set()\n        for _, _, _, react, _ in self.get_kinks():\n            products = products.union(set([k.reduced_formula\n                                           for k in react.products]))\n        return list(products)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _convert(x, factor1, factor2):\n        return x * factor2 / ((1-x) * factor1 + x * factor2)", "response": "Converts mixing ratio x between two comp1 and comp2 tie line into a float between 0 and 1."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreverses conversion of mixing ratio x in c1 - c2 tie line to that in comp1 - comp2 tie line.", "response": "def _reverse_convert(x, factor1, factor2):\n        \"\"\"\n        Converts mixing ratio x in c1 - c2 tie line to that in\n        comp1 - comp2 tie line.\n\n        Args:\n            x (float): Mixing ratio x in c1 - c2 tie line, a float between\n                0 and 1.\n            factor1 (float): Compositional ratio between composition c1 and\n                processed composition comp1. E.g., factor for\n                Composition('SiO2') and Composition('O') is 2.\n            factor2 (float): Compositional ratio between composition c2 and\n                processed composition comp2.\n\n        Returns:\n            Mixing ratio in comp1 - comp2 tie line, a float between 0 and 1.\n        \"\"\"\n        return x * factor1 / ((1-x) * factor2 + x * factor1)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nfind all the kinks in mixing ratio where reaction products changes along the tie line of composition self. c1 and self. c2.", "response": "def get_kinks(self):\n        \"\"\"\n        Finds all the kinks in mixing ratio where reaction products changes\n        along the tie line of composition self.c1 and composition self.c2.\n\n        Returns:\n            Zip object of tuples (index, mixing ratio,\n                                  reaction energy per atom in eV/atom,\n                                  reaction formula,\n                                  reaction energy per mol of reaction\n                                  formula in kJ/mol).\n        \"\"\"\n        c1_coord = self.pd.pd_coords(self.comp1)\n        c2_coord = self.pd.pd_coords(self.comp2)\n        n1 = self.comp1.num_atoms\n        n2 = self.comp2.num_atoms\n        critical_comp = self.pd.get_critical_compositions(self.comp1,\n                                                          self.comp2)\n        x_kink, energy_kink, react_kink, energy_per_rxt_formula = \\\n            [], [], [], []\n        if all(c1_coord == c2_coord):\n            x_kink = [0, 1]\n            energy_kink = [self._get_energy(x) for x in x_kink]\n            react_kink = [self._get_reaction(x) for x in x_kink]\n            num_atoms = [(x * self.comp1.num_atoms +\n                          (1-x) * self.comp2.num_atoms) for x in x_kink]\n            energy_per_rxt_formula = [energy_kink[i] *\n                                      self._get_elmt_amt_in_rxt(\n                                          react_kink[i]) /\n                                      num_atoms[i] *\n                                      InterfacialReactivity.EV_TO_KJ_PER_MOL\n                                      for i in range(2)]\n        else:\n            for i in reversed(critical_comp):\n                # Gets mixing ratio x at kinks.\n                c = self.pd.pd_coords(i)\n                x = np.linalg.norm(c - c2_coord) / \\\n                    np.linalg.norm(c1_coord - c2_coord)\n                # Modifies mixing ratio in case compositions self.comp1 and\n                # self.comp2 are not normalized.\n                x = x * n2 / (n1 + x * (n2 - n1))\n                n_atoms = x * self.comp1.num_atoms \\\n                    + (1-x) * self.comp2.num_atoms\n                # Converts mixing ratio in comp1 - comp2 tie line to that in\n                # c1 - c2 tie line.\n                x_converted = InterfacialReactivity._convert(\n                    x, self.factor1, self.factor2)\n                x_kink.append(x_converted)\n                # Gets reaction energy at kinks\n                normalized_energy = self._get_energy(x)\n                energy_kink.append(normalized_energy)\n                # Gets balanced reaction at kinks\n                rxt = self._get_reaction(x)\n                react_kink.append(rxt)\n                rxt_energy = normalized_energy * \\\n                    self._get_elmt_amt_in_rxt(rxt) / \\\n                    n_atoms\n                energy_per_rxt_formula.append(\n                    rxt_energy *\n                    InterfacialReactivity.EV_TO_KJ_PER_MOL)\n        index_kink = range(1, len(critical_comp)+1)\n        return zip(index_kink, x_kink, energy_kink, react_kink,\n                   energy_per_rxt_formula)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_critical_original_kink_ratio(self):\n        ratios = []\n        if self.c1_original == self.c2_original:\n            return [0, 1]\n        reaction_kink = [k[3] for k in self.get_kinks()]\n        for rxt in reaction_kink:\n            ratios.append(abs(self._get_original_composition_ratio(rxt)))\n        return ratios", "response": "Returns a list of molar mixing ratios between ORIGINALCOOKIECOOKIECOOKIE and ORIGINALCOOKIECOOKIECOOKIE."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the molar mixing ratio between the original reactant and the original reactant.", "response": "def _get_original_composition_ratio(self, reaction):\n        \"\"\"\n        Returns the molar mixing ratio between the reactants with ORIGINAL (\n        instead of processed) compositions for a reaction.\n\n        Args:\n            reaction (Reaction): Reaction object that contains the original\n                reactant compositions.\n\n        Returns:\n            The molar mixing ratio between the original reactant\n            compositions for a reaction.\n        \"\"\"\n        if self.c1_original == self.c2_original:\n            return 1\n        c1_coeff = reaction.get_coeff(self.c1_original) \\\n            if self.c1_original in reaction.reactants else 0\n        c2_coeff = reaction.get_coeff(self.c2_original) \\\n            if self.c2_original in reaction.reactants else 0\n        return c1_coeff * 1.0 / (c1_coeff + c2_coeff)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef labels(self):\n        return {j: 'x= ' + str(round(x, 4)) + ' energy in eV/atom = ' +\n                   str(round(energy, 4)) + ' ' + str(reaction)\n                for j, x, energy, reaction, _ in self.get_kinks()}", "response": "Returns a dictionary containing kink information."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nplots the reaction energy using pylab.", "response": "def plot(self):\n        \"\"\"\n        Plots reaction energy as a function of mixing ratio x in\n        self.c1 - self.c2 tie line using pylab.\n\n        Returns:\n            Pylab object that plots reaction energy as a function of\n            mixing ratio x.\n        \"\"\"\n        plt.rcParams['xtick.major.pad'] = '6'\n        plt.rcParams['ytick.major.pad'] = '6'\n        plt.rcParams['axes.linewidth'] = 2\n        npoint = 1000\n        xs = np.linspace(0, 1, npoint)\n\n        # Converts sampling points in self.c1 - self.c2 tie line to those in\n        # self.comp1 - self.comp2 tie line.\n        xs_reverse_converted = InterfacialReactivity._reverse_convert(\n            xs, self.factor1, self.factor2)\n        energies = [self._get_energy(x) for x in xs_reverse_converted]\n        plt.plot(xs, energies, 'k-')\n\n        # Marks kinks and minimum energy point.\n        kinks = self.get_kinks()\n        _, x_kink, energy_kink, _, _ = zip(*kinks)\n        plt.scatter(x_kink, energy_kink, marker='o', c='blue', s=20)\n        plt.scatter(self.minimum()[0], self.minimum()[1], marker='*',\n                    c='red', s=300)\n\n        # Labels kinks with indices. Labels are made draggable\n        # in case of overlapping.\n        for index, x, energy, _, _ in kinks:\n            plt.annotate(\n                index,\n                xy=(x, energy), xytext=(5, 30),\n                textcoords='offset points', ha='right', va='bottom',\n                arrowprops=dict(arrowstyle='->',\n                                connectionstyle='arc3,rad=0')).draggable()\n        plt.xlim([-0.05, 1.05])\n        if self.norm:\n            plt.ylabel('Energy (eV/atom)')\n        else:\n            plt.ylabel('Energy (eV/f.u.)')\n        plt.xlabel('$x$ in $x$ {} + $(1-x)$ {}'.format(\n            self.c1.reduced_formula, self.c2.reduced_formula))\n        return plt"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef minimum(self):\n        return min([(x, energy) for _, x, energy, _, _ in self.get_kinks()],\n                   key=lambda i: i[1])", "response": "Finds the minimum reaction energy E_min and corresponding\n        mixing ratio x_min."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngenerating the opposite number of energy above grand potential for both reactants.", "response": "def get_no_mixing_energy(self):\n        \"\"\"\n        Generates the opposite number of energy above grand potential\n        convex hull for both reactants.\n\n        Returns:\n            [(reactant1, no_mixing_energy1),(reactant2,no_mixing_energy2)].\n        \"\"\"\n        assert self.grand == 1, \\\n            'Please provide grand potential phase diagram ' \\\n            'for computing no_mixing_energy!'\n\n        energy1 = self.pd.get_hull_energy(self.comp1) - \\\n            self._get_grand_potential(self.c1)\n        energy2 = self.pd.get_hull_energy(self.comp2) - \\\n            self._get_grand_potential(self.c2)\n        unit = 'eV/f.u.'\n        if self.norm:\n            unit = 'eV/atom'\n        return [(self.c1_original.reduced_formula +\n                 ' ({0})'.format(unit), energy1),\n                (self.c2_original.reduced_formula +\n                 ' ({0})'.format(unit), energy2)]"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_chempot_correction(element, temp, pres):\n        if element not in [\"O\", \"N\", \"Cl\", \"F\", \"H\"]:\n            return 0\n        std_temp = 298.15\n        std_pres = 1E5\n        ideal_gas_const = 8.3144598\n        # Cp and S at standard state in J/(K.mol). Data from\n        # https://janaf.nist.gov/tables/O-029.html\n        # https://janaf.nist.gov/tables/N-023.html\n        # https://janaf.nist.gov/tables/Cl-073.html\n        # https://janaf.nist.gov/tables/F-054.html\n        # https://janaf.nist.gov/tables/H-050.html\n        Cp_dict = {\"O\": 29.376,\n                   \"N\": 29.124,\n                   \"Cl\": 33.949,\n                   \"F\": 31.302,\n                   \"H\": 28.836}\n\n        S_dict = {\"O\": 205.147,\n                  \"N\": 191.609,\n                  \"Cl\": 223.079,\n                  \"F\": 202.789,\n                  \"H\": 130.680}\n        Cp_std = Cp_dict[element]\n        S_std = S_dict[element]\n        PV_correction = ideal_gas_const * temp * np.log(pres / std_pres)\n        TS_correction = - Cp_std * (temp * np.log(temp)\n                                    - std_temp * np.log(std_temp)) \\\n                        + Cp_std * (temp - std_temp) \\\n                                 * (1 + np.log(std_temp)) \\\n                        - S_std * (temp - std_temp)\n\n        dG = PV_correction + TS_correction\n        # Convert to eV/molecule unit.\n        dG /= 1000 * InterfacialReactivity.EV_TO_KJ_PER_MOL\n        # Normalize by number of atoms in the gas molecule. For elements\n        # considered, the gas molecules are all diatomic.\n        dG /= 2\n        return dG", "response": "Returns the normalized correction term \u0394\u03bc for a given element at given temperature and pressure."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a dict that maps each atomic symbol to a unique integer starting from 1.", "response": "def get_atom_map(structure):\n    \"\"\"\n    Returns a dict that maps each atomic symbol to a unique integer starting\n    from 1.\n\n    Args:\n        structure (Structure)\n\n    Returns:\n        dict\n    \"\"\"\n    syms = [site.specie.symbol for site in structure]\n    unique_pot_atoms = []\n    [unique_pot_atoms.append(i) for i in syms if not unique_pot_atoms.count(i)]\n    atom_map = {}\n    for i, atom in enumerate(unique_pot_atoms):\n        atom_map[atom] = i + 1\n    return atom_map"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_absorbing_atom_symbol_index(absorbing_atom, structure):\n    if isinstance(absorbing_atom, str):\n        return absorbing_atom, structure.indices_from_symbol(absorbing_atom)[0]\n    elif isinstance(absorbing_atom, int):\n        return str(structure[absorbing_atom].specie), absorbing_atom\n    else:\n        raise ValueError(\"absorbing_atom must be either specie symbol or site index\")", "response": "Returns the absorbing atom symboll and site index in the given structure."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef from_cif_file(cif_file, source='', comment=''):\n        r = CifParser(cif_file)\n        structure = r.get_structures()[0]\n        return Header(structure, source, comment)", "response": "Static method to create a Header object from a Cif file."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef header_string_from_file(filename='feff.inp'):\n        with zopen(filename, \"r\") as fobject:\n            f = fobject.readlines()\n            feff_header_str = []\n            ln = 0\n\n            # Checks to see if generated by pymatgen\n            try:\n                feffpmg = f[0].find(\"pymatgen\")\n            except IndexError:\n                feffpmg = False\n\n            # Reads pymatgen generated header or feff.inp file\n            if feffpmg:\n                nsites = int(f[8].split()[2])\n                for line in f:\n                    ln += 1\n                    if ln <= nsites + 9:\n                        feff_header_str.append(line)\n            else:\n                # Reads header from header from feff.inp file from unknown\n                # source\n                end = 0\n                for line in f:\n                    if (line[0] == \"*\" or line[0] == \"T\") and end == 0:\n                        feff_header_str.append(line.replace(\"\\r\", \"\"))\n                    else:\n                        end = 1\n\n        return ''.join(feff_header_str)", "response": "Reads a header string from either a HEADER file or a non - pymatgen generated feff. inp file. Will also read a header string from either a HEADER file or feff. inp file. Will also read a non - pymatgen generated feff. inp file."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef from_string(header_str):\n        lines = tuple(clean_lines(header_str.split(\"\\n\"), False))\n        comment1 = lines[0]\n        feffpmg = comment1.find(\"pymatgen\")\n\n        if feffpmg:\n            comment2 = ' '.join(lines[1].split()[2:])\n\n            source = ' '.join(lines[2].split()[2:])\n            basis_vec = lines[6].split(\":\")[-1].split()\n            # a, b, c\n            a = float(basis_vec[0])\n            b = float(basis_vec[1])\n            c = float(basis_vec[2])\n            lengths = [a, b, c]\n            # alpha, beta, gamma\n            basis_ang = lines[7].split(\":\")[-1].split()\n            alpha = float(basis_ang[0])\n            beta = float(basis_ang[1])\n            gamma = float(basis_ang[2])\n            angles = [alpha, beta, gamma]\n\n            lattice = Lattice.from_lengths_and_angles(lengths, angles)\n\n            natoms = int(lines[8].split(\":\")[-1].split()[0])\n\n            atomic_symbols = []\n            for i in range(9, 9 + natoms):\n                atomic_symbols.append(lines[i].split()[2])\n\n            # read the atomic coordinates\n            coords = []\n            for i in range(natoms):\n                toks = lines[i + 9].split()\n                coords.append([float(s) for s in toks[3:]])\n\n            struct = Structure(lattice, atomic_symbols, coords, False,\n                               False, False)\n\n            h = Header(struct, source, comment2)\n\n            return h\n        else:\n            return \"Header not generated by pymatgen, cannot return header object\"", "response": "Reads a string containing a structure object and returns a Header object."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef write_file(self, filename='HEADER'):\n        with open(filename, \"w\") as f:\n            f.write(str(self) + \"\\n\")", "response": "Writes the current object into a file on disk."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _set_cluster(self):\n        center = self.struct[self.center_index].coords\n        sphere = self.struct.get_neighbors(self.struct[self.center_index], self.radius)\n\n        symbols = [self.absorbing_atom]\n        coords = [[0, 0, 0]]\n        for i, site_dist in enumerate(sphere):\n            site_symbol = re.sub(r\"[^aA-zZ]+\", \"\", site_dist[0].species_string)\n            symbols.append(site_symbol)\n            coords.append(site_dist[0].coords - center)\n        return Molecule(symbols, coords)", "response": "Compute and set the cluster of atoms as a Molecule object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef atoms_string_from_file(filename):\n        with zopen(filename, \"rt\") as fobject:\n            f = fobject.readlines()\n            coords = 0\n            atoms_str = []\n\n            for line in f:\n                if coords == 0:\n                    find_atoms = line.find(\"ATOMS\")\n                    if find_atoms >= 0:\n                        coords = 1\n                if coords == 1 and not (\"END\" in line):\n                    atoms_str.append(line.replace(\"\\r\", \"\"))\n\n        return ''.join(atoms_str)", "response": "Reads atomic shells from a file such as feff. inp or ATOMS file and returns a string containing the atomic shells."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef cluster_from_file(filename):\n        atoms_string = Atoms.atoms_string_from_file(filename)\n        line_list = [l.split() for l in atoms_string.splitlines()[3:]]\n        coords = []\n        symbols = []\n        for l in line_list:\n            if l:\n                coords.append([float(i) for i in l[:3]])\n                symbols.append(l[4])\n        return Molecule(symbols, coords)", "response": "Parse the feff input file and return the atomic cluster as a Molecule object."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_lines(self):\n        lines = [[\"{:f}\".format(self._cluster[0].x),\n                  \"{:f}\".format(self._cluster[0].y),\n                  \"{:f}\".format(self._cluster[0].z),\n                  0, self.absorbing_atom, \"0.0\", 0]]\n        for i, site in enumerate(self._cluster[1:]):\n            site_symbol = re.sub(r\"[^aA-zZ]+\", \"\", site.species_string)\n            ipot = self.pot_dict[site_symbol]\n            lines.append([\"{:f}\".format(site.x), \"{:f}\".format(site.y),\n                          \"{:f}\".format(site.z), ipot, site_symbol,\n                          \"{:f}\".format(self._cluster.get_distance(0, i + 1)), i + 1])\n\n        return sorted(lines, key=itemgetter(5))", "response": "Returns a list of strings representations of the atomic configuration\n Arc."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef as_dict(self):\n        tags_dict = dict(self)\n        tags_dict['@module'] = self.__class__.__module__\n        tags_dict['@class'] = self.__class__.__name__\n        return tags_dict", "response": "Returns a dictionary representation of the object."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef from_dict(d):\n        i = Tags()\n        for k, v in d.items():\n            if k not in (\"@module\", \"@class\"):\n                i[k] = v\n        return i", "response": "Returns a Tags object from a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a string representation of the Tags.", "response": "def get_string(self, sort_keys=False, pretty=False):\n        \"\"\"\n        Returns a string representation of the Tags.  The reason why this\n        method is different from the __str__ method is to provide options\n        for pretty printing.\n\n        Args:\n            sort_keys: Set to True to sort the Feff parameters alphabetically.\n                Defaults to False.\n            pretty: Set to True for pretty aligned output. Defaults to False.\n\n        Returns:\n            String representation of Tags.\n        \"\"\"\n        keys = self.keys()\n        if sort_keys:\n            keys = sorted(keys)\n        lines = []\n        for k in keys:\n            if isinstance(self[k], dict):\n                if k in [\"ELNES\", \"EXELFS\"]:\n                    lines.append([k, self._stringify_val(self[k][\"ENERGY\"])])\n                    beam_energy = self._stringify_val(self[k][\"BEAM_ENERGY\"])\n                    beam_energy_list = beam_energy.split()\n                    if int(beam_energy_list[1]) == 0:  # aver=0, specific beam direction\n                        lines.append([beam_energy])\n                        lines.append([self._stringify_val(self[k][\"BEAM_DIRECTION\"])])\n                    else:\n                        # no cross terms for orientation averaged spectrum\n                        beam_energy_list[2] = str(0)\n                        lines.append([self._stringify_val(beam_energy_list)])\n                    lines.append([self._stringify_val(self[k][\"ANGLES\"])])\n                    lines.append([self._stringify_val(self[k][\"MESH\"])])\n                    lines.append([self._stringify_val(self[k][\"POSITION\"])])\n            else:\n                lines.append([k, self._stringify_val(self[k])])\n        if pretty:\n            return tabulate(lines)\n        else:\n            return str_delimited(lines, None, \" \")"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _stringify_val(val):\n        if isinstance(val, list):\n            return \" \".join([str(i) for i in val])\n        else:\n            return str(val)", "response": "Convert the given value to string."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreads a feff. inp file and returns a Feff_tag dictionary.", "response": "def from_file(filename=\"feff.inp\"):\n        \"\"\"\n        Creates a Feff_tag dictionary from a PARAMETER or feff.inp file.\n\n        Args:\n            filename: Filename for either PARAMETER or feff.inp file\n\n        Returns:\n            Feff_tag object\n        \"\"\"\n        with zopen(filename, \"rt\") as f:\n            lines = list(clean_lines(f.readlines()))\n        params = {}\n        eels_params = []\n        ieels = -1\n        ieels_max = -1\n        for i, line in enumerate(lines):\n            m = re.match(r\"([A-Z]+\\d*\\d*)\\s*(.*)\", line)\n            if m:\n                key = m.group(1).strip()\n                val = m.group(2).strip()\n                val = Tags.proc_val(key, val)\n                if key not in (\"ATOMS\", \"POTENTIALS\", \"END\", \"TITLE\"):\n                    if key in [\"ELNES\", \"EXELFS\"]:\n                        ieels = i\n                        ieels_max = ieels + 5\n                    else:\n                        params[key] = val\n            if ieels >= 0:\n                if i >= ieels and i <= ieels_max:\n                    if i == ieels + 1:\n                        if int(line.split()[1]) == 1:\n                            ieels_max -= 1\n                    eels_params.append(line)\n\n        if eels_params:\n            if len(eels_params) == 6:\n                eels_keys = ['BEAM_ENERGY', 'BEAM_DIRECTION', 'ANGLES', 'MESH', 'POSITION']\n            else:\n                eels_keys = ['BEAM_ENERGY', 'ANGLES', 'MESH', 'POSITION']\n            eels_dict = {\"ENERGY\": Tags._stringify_val(eels_params[0].split()[1:])}\n            for k, v in zip(eels_keys, eels_params[1:]):\n                eels_dict[k] = str(v)\n            params[str(eels_params[0].split()[0])] = eels_dict\n\n        return Tags(params)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef proc_val(key, val):\n\n        list_type_keys = list(VALID_FEFF_TAGS)\n        del list_type_keys[list_type_keys.index(\"ELNES\")]\n        del list_type_keys[list_type_keys.index(\"EXELFS\")]\n        boolean_type_keys = ()\n        float_type_keys = (\"S02\", \"EXAFS\", \"RPATH\")\n\n        def smart_int_or_float(numstr):\n            if numstr.find(\".\") != -1 or numstr.lower().find(\"e\") != -1:\n                return float(numstr)\n            else:\n                return int(numstr)\n\n        try:\n            if key.lower() == 'cif':\n                m = re.search(r\"\\w+.cif\", val)\n                return m.group(0)\n\n            if key in list_type_keys:\n                output = list()\n                toks = re.split(r\"\\s+\", val)\n\n                for tok in toks:\n                    m = re.match(r\"(\\d+)\\*([\\d\\.\\-\\+]+)\", tok)\n                    if m:\n                        output.extend([smart_int_or_float(m.group(2))] *\n                                      int(m.group(1)))\n                    else:\n                        output.append(smart_int_or_float(tok))\n                return output\n            if key in boolean_type_keys:\n                m = re.search(r\"^\\W+([TtFf])\", val)\n                if m:\n                    if m.group(1) == \"T\" or m.group(1) == \"t\":\n                        return True\n                    else:\n                        return False\n                raise ValueError(key + \" should be a boolean type!\")\n\n            if key in float_type_keys:\n                return float(val)\n\n        except ValueError:\n            return val.capitalize()\n\n        return val.capitalize()", "response": "Process a value of Feff parameter key and return the corresponding value."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef pot_string_from_file(filename='feff.inp'):\n        with zopen(filename, \"rt\") as f_object:\n            f = f_object.readlines()\n            ln = -1\n            pot_str = [\"POTENTIALS\\n\"]\n            pot_tag = -1\n            pot_data = 0\n            pot_data_over = 1\n\n            sep_line_pattern = [re.compile('ipot.*Z.*tag.*lmax1.*lmax2.*spinph'),\n                                re.compile('^[*]+.*[*]+$')]\n\n            for line in f:\n                if pot_data_over == 1:\n                    ln += 1\n                    if pot_tag == -1:\n                        pot_tag = line.find(\"POTENTIALS\")\n                        ln = 0\n                    if pot_tag >= 0 and ln > 0 and pot_data_over > 0:\n                        try:\n                            if len(sep_line_pattern[0].findall(line)) > 0 or \\\n                                            len(sep_line_pattern[1].findall(line)) > 0:\n                                pot_str.append(line)\n                            elif int(line.split()[0]) == pot_data:\n                                pot_data += 1\n                                pot_str.append(line.replace(\"\\r\", \"\"))\n                        except (ValueError, IndexError):\n                            if pot_data > 0:\n                                pot_data_over = 0\n\n        return ''.join(pot_str).rstrip('\\n')", "response": "Reads the Potential parameters from a FEFFPOT file."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates atomic symbol and potential number dictionary from string format.", "response": "def pot_dict_from_string(pot_data):\n        \"\"\"\n        Creates atomic symbol/potential number dictionary\n        forward and reverse\n\n        Arg:\n            pot_data: potential data in string format\n\n        Returns:\n            forward and reverse atom symbol and potential number dictionaries.\n        \"\"\"\n\n        pot_dict = {}\n        pot_dict_reverse = {}\n        begin = 0\n        ln = -1\n\n        for line in pot_data.split(\"\\n\"):\n            try:\n                if begin == 0 and line.split()[0] == \"0\":\n                    begin += 1\n                    ln = 0\n                if begin == 1:\n                    ln += 1\n                if ln > 0:\n                    atom = line.split()[2]\n                    index = int(line.split()[0])\n                    pot_dict[atom] = index\n                    pot_dict_reverse[index] = atom\n            except (ValueError, IndexError):\n                pass\n        return pot_dict, pot_dict_reverse"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nwrites the current object to a file.", "response": "def write_file(self, filename=\"paths.dat\"):\n        \"\"\"\n        Write paths.dat.\n        \"\"\"\n        with zopen(filename, \"wt\") as f:\n            f.write(str(self) + \"\\n\")"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef lattice_from_abivars(cls=None, *args, **kwargs):\n    cls = Lattice if cls is None else cls\n    kwargs.update(dict(*args))\n    d = kwargs\n\n    rprim = d.get(\"rprim\", None)\n    angdeg = d.get(\"angdeg\", None)\n    acell = d[\"acell\"]\n\n    if rprim is not None:\n        if angdeg is not None:\n            raise ValueError(\"angdeg and rprimd are mutually exclusive\")\n        rprim = np.reshape(rprim, (3,3))\n        rprimd = [float(acell[i]) * rprim[i] for i in range(3)]\n        # Call pymatgen constructors (note that pymatgen uses Angstrom instead of Bohr).\n        return cls(ArrayWithUnit(rprimd, \"bohr\").to(\"ang\"))\n\n    elif angdeg is not None:\n        angdeg = np.reshape(angdeg, 3)\n\n        if np.any(angdeg <= 0.):\n            raise ValueError(\"Angles must be > 0 but got %s\" % str(angdeg))\n        if angdeg.sum() >= 360.:\n            raise ValueError(\"The sum of angdeg must be lower that 360, angdeg %s\" % str(angdeg))\n\n        # This code follows the implementation in ingeo.F90\n        # See also http://www.abinit.org/doc/helpfiles/for-v7.8/input_variables/varbas.html#angdeg\n        tol12 = 1e-12\n        pi, sin, cos, sqrt = np.pi, np.sin, np.cos, np.sqrt\n        rprim = np.zeros((3,3))\n        if (abs(angdeg[0] -angdeg[1]) < tol12 and abs(angdeg[1] - angdeg[2]) < tol12 and\n            abs(angdeg[0]-90.) + abs(angdeg[1]-90.) + abs(angdeg[2] -90) > tol12):\n            # Treat the case of equal angles (except all right angles):\n            # generates trigonal symmetry wrt third axis\n            cosang = cos(pi * angdeg[0]/180.0)\n            a2 = 2.0/3.0*(1.0 - cosang)\n            aa = sqrt(a2)\n            cc = sqrt(1.0-a2)\n            rprim[0,0] = aa     ; rprim[0,1] = 0.0              ; rprim[0,2] = cc\n            rprim[1,0] = -0.5*aa; rprim[1,1] = sqrt(3.0)*0.5*aa ; rprim[1,2] = cc\n            rprim[2,0] = -0.5*aa; rprim[2,1] = -sqrt(3.0)*0.5*aa; rprim[2,2] = cc\n        else:\n            # Treat all the other cases\n            rprim[0,0] = 1.0\n            rprim[1,0] = cos(pi*angdeg[2]/180.)\n            rprim[1,1] = sin(pi*angdeg[2]/180.)\n            rprim[2,0] = cos(pi*angdeg[1]/180.)\n            rprim[2,1] = (cos(pi*angdeg[0]/180.0)-rprim[1,0]*rprim[2,0])/rprim[1,1]\n            rprim[2,2] = sqrt(1.0-rprim[2,0]**2-rprim[2,1]**2)\n\n        # Call pymatgen constructors (note that pymatgen uses Angstrom instead of Bohr).\n        rprimd = [float(acell[i]) * rprim[i] for i in range(3)]\n        return cls(ArrayWithUnit(rprimd, \"bohr\").to(\"ang\"))\n\n    raise ValueError(\"Don't know how to construct a Lattice from dict:\\n%s\" % pformat(d))", "response": "Returns a Lattice object from a dictionary of Abinit variables acell and rprim in Bohr or angdeg."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef structure_from_abivars(cls=None, *args, **kwargs):\n    kwargs.update(dict(*args))\n    d = kwargs\n\n    cls = Structure if cls is None else cls\n\n    #lattice = Lattice.from_dict(d, fmt=\"abivars\")\n    lattice = lattice_from_abivars(**d)\n    coords, coords_are_cartesian = d.get(\"xred\", None), False\n\n    if coords is None:\n        coords = d.get(\"xcart\", None)\n        if coords is not None:\n            if \"xangst\" in d:\n                raise ValueError(\"xangst and xcart are mutually exclusive\")\n            coords = ArrayWithUnit(coords, \"bohr\").to(\"ang\")\n        else:\n            coords = d.get(\"xangst\", None)\n        coords_are_cartesian = True\n\n    if coords is None:\n        raise ValueError(\"Cannot extract coordinates from:\\n %s\" % str(d))\n\n    coords = np.reshape(coords, (-1,3))\n\n    znucl_type, typat = d[\"znucl\"], d[\"typat\"]\n\n    if not isinstance(znucl_type, collections.abc.Iterable):\n        znucl_type = [znucl_type]\n\n    if not isinstance(typat, collections.abc.Iterable):\n        typat = [typat]\n\n    if len(typat) != len(coords):\n        raise ValueError(\"len(typat) != len(coords):\\ntypat: %s\\ncoords: %s\" % (typat, coords))\n\n    # Note conversion to int and Fortran --> C indexing\n    typat = np.array(typat, dtype=np.int)\n    species = [znucl_type[typ-1] for typ in typat]\n\n    return cls(lattice, species, coords, validate_proximity=False,\n               to_unit_cell=False, coords_are_cartesian=coords_are_cartesian)", "response": "Build a structure object from a dictionary with ABINIT variables."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nconvert a structure into an ABINIT dictionary.", "response": "def structure_to_abivars(structure, **kwargs):\n    \"\"\"\n    Receives a structure and returns a dictionary with the ABINIT variables.\n    \"\"\"\n    if not structure.is_ordered:\n        raise ValueError(\"\"\"\\\nReceived disordered structure with partial occupancies that cannot be converted into an Abinit input\nPlease use OrderDisorderedStructureTransformation or EnumerateStructureTransformation\nto build an appropriate supercell from partial occupancies or alternatively use the Virtual Crystal Approximation.\"\"\")\n\n    types_of_specie = structure.types_of_specie\n    natom = structure.num_sites\n\n    znucl_type = [specie.number for specie in types_of_specie]\n    znucl_atoms = structure.atomic_numbers\n\n    typat = np.zeros(natom, np.int)\n    for atm_idx, site in enumerate(structure):\n        typat[atm_idx] = types_of_specie.index(site.specie) + 1\n\n    rprim = ArrayWithUnit(structure.lattice.matrix, \"ang\").to(\"bohr\")\n    angdeg = structure.lattice.angles\n    xred = np.reshape([site.frac_coords for site in structure], (-1, 3))\n\n    # Set small values to zero. This usually happens when the CIF file\n    # does not give structure parameters with enough digits.\n    rprim = np.where(np.abs(rprim) > 1e-8, rprim, 0.0)\n    xred = np.where(np.abs(xred) > 1e-8, xred, 0.0)\n\n    # Info on atoms.\n    d = dict(\n        natom=natom,\n        ntypat=len(types_of_specie),\n        typat=typat,\n        znucl=znucl_type,\n        xred=xred,\n    )\n\n    # Add info on the lattice.\n    # Should we use (rprim, acell) or (angdeg, acell) to specify the lattice?\n    geomode = kwargs.pop(\"geomode\", \"rprim\")\n    if geomode == \"automatic\":\n        geomode = \"rprim\"\n        if structure.lattice.is_hexagonal: # or structure.lattice.is_rhombohedral\n            geomode = \"angdeg\"\n            angdeg = structure.lattice.angles\n            # Here one could polish a bit the numerical values if they are not exact.\n            # Note that in pmg the angles are 12, 20, 01 while in Abinit 12, 02, 01\n            # One should make sure that the orientation is preserved (see Curtarolo's settings)\n\n    if geomode == \"rprim\":\n        d.update(\n            acell=3 * [1.0],\n            rprim=rprim,\n        )\n\n    elif geomode == \"angdeg\":\n        d.update(\n            acell=ArrayWithUnit(structure.lattice.abc, \"ang\").to(\"bohr\"),\n            angdeg=angdeg,\n        )\n    else:\n        raise ValueError(\"Wrong value for geomode: %s\" % geomode)\n\n    return d"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef contract(s):\n    if not s: return s\n\n    tokens = s.split()\n    old = tokens[0]\n    count = [[1, old]]\n\n    for t in tokens[1:]:\n        if t == old:\n            count[-1][0] += 1\n        else:\n            old = t\n            count.append([1, t])\n\n    return \" \".join(\"%d*%s\" % (c, t) for c, t in count)", "response": "Returns a string that can be used as a contract of a sequence of items."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef as_spinmode(cls, obj):\n        if isinstance(obj, cls):\n            return obj\n        else:\n            # Assume a string with mode\n            try:\n                return _mode2spinvars[obj]\n            except KeyError:\n                raise KeyError(\"Wrong value for spin_mode: %s\" % str(obj))", "response": "Converts obj into a SpinMode instance."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef as_smearing(cls, obj):\n        if obj is None:\n            return Smearing.nosmearing()\n\n        if isinstance(obj, cls):\n            return obj\n\n        # obj is a string\n        if obj == \"nosmearing\":\n            return cls.nosmearing()\n        else:\n            obj, tsmear = obj.split(\":\")\n            obj.strip()\n\n            occopt = cls._mode2occopt[obj]\n            try:\n                tsmear = float(tsmear)\n            except ValueError:\n                tsmear, unit = tsmear.split()\n                tsmear = units.Energy(float(tsmear), unit).to(\"Ha\")\n\n            return cls(occopt, tsmear)", "response": "Constructs an instance of the class specified by obj."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef as_dict(self):\n        \"json friendly dict representation\"\n        d = {}\n        d[\"@module\"] = self.__class__.__module__\n        d[\"@class\"] = self.__class__.__name__\n        d[\"spin_mode\"] = self.spin_mode.as_dict()\n        d[\"smearing\"] = self.smearing.as_dict()\n        d[\"algorithm\"] = self.algorithm.as_dict() if self.algorithm else None\n        d[\"nband\"] = self.nband\n        d[\"fband\"] = self.fband\n        d[\"charge\"] = self.charge\n        d[\"comment\"] = self.comment\n        return d", "response": "json friendly dict representation"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef gamma_centered(cls, kpts=(1, 1, 1), use_symmetries=True, use_time_reversal=True):\n        return cls(kpts=[kpts], kpt_shifts=(0.0, 0.0, 0.0),\n                   use_symmetries=use_symmetries, use_time_reversal=use_time_reversal,\n                   comment=\"gamma-centered mode\")", "response": "A static constructor for automatic Gamma centered Kpoint grid."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef monkhorst_automatic(cls, structure, ngkpt,\n                            use_symmetries=True, use_time_reversal=True, chksymbreak=None, comment=None):\n        \"\"\"\n        Convenient static constructor for an automatic Monkhorst-Pack mesh.\n\n        Args:\n            structure: :class:`Structure` object.\n            ngkpt: Subdivisions N_1, N_2 and N_3 along reciprocal lattice vectors.\n            use_symmetries: Use spatial symmetries to reduce the number of k-points.\n            use_time_reversal: Use time-reversal symmetry to reduce the number of k-points.\n\n        Returns:\n            :class:`KSampling` object.\n        \"\"\"\n        sg = SpacegroupAnalyzer(structure)\n        #sg.get_crystal_system()\n        #sg.get_point_group_symbol()\n        # TODO\n        nshiftk = 1\n        #shiftk = 3*(0.5,) # this is the default\n        shiftk = 3*(0.5,)\n\n        #if lattice.ishexagonal:\n        #elif lattice.isbcc\n        #elif lattice.isfcc\n\n        return cls.monkhorst(\n            ngkpt, shiftk=shiftk, use_symmetries=use_symmetries, use_time_reversal=use_time_reversal,\n            chksymbreak=chksymbreak, comment=comment if comment else \"Automatic Monkhorst-Pack scheme\")", "response": "Monkhorst - Pack scheme for automatic Monkhorst - Pack meshes."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ngenerate a K - path from a structure.", "response": "def path_from_structure(cls, ndivsm, structure):\n        \"\"\"See _path for the meaning of the variables\"\"\"\n        return cls._path(ndivsm,  structure=structure, comment=\"K-path generated automatically from structure\")"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef explicit_path(cls, ndivsm, kpath_bounds):\n        return cls._path(ndivsm, kpath_bounds=kpath_bounds, comment=\"Explicit K-path\")", "response": "Return explicit K - path for the given ndivsm."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef automatic_density(cls, structure, kppa, chksymbreak=None, use_symmetries=True, use_time_reversal=True,\n                          shifts=(0.5, 0.5, 0.5)):\n        \"\"\"\n        Returns an automatic Kpoint object based on a structure and a kpoint\n        density. Uses Gamma centered meshes for hexagonal cells and Monkhorst-Pack grids otherwise.\n\n        Algorithm:\n            Uses a simple approach scaling the number of divisions along each\n            reciprocal lattice vector proportional to its length.\n\n        Args:\n            structure: Input structure\n            kppa: Grid density\n        \"\"\"\n        lattice = structure.lattice\n        lengths = lattice.abc\n        shifts = np.reshape(shifts, (-1, 3))\n        ngrid = kppa / structure.num_sites / len(shifts)\n\n        mult = (ngrid * lengths[0] * lengths[1] * lengths[2]) ** (1 / 3.)\n\n        num_div = [int(round(1.0 / lengths[i] * mult)) for i in range(3)]\n        # ensure that num_div[i] > 0\n        num_div = [i if i > 0 else 1 for i in num_div]\n\n        angles = lattice.angles\n        hex_angle_tol = 5      # in degrees\n        hex_length_tol = 0.01  # in angstroms\n\n        right_angles = [i for i in range(3) if abs(angles[i] - 90) < hex_angle_tol]\n\n        hex_angles = [i for i in range(3)\n                      if abs(angles[i] - 60) < hex_angle_tol or\n                      abs(angles[i] - 120) < hex_angle_tol]\n\n        is_hexagonal = (len(right_angles) == 2 and len(hex_angles) == 1\n                        and abs(lengths[right_angles[0]] -\n                                lengths[right_angles[1]]) < hex_length_tol)\n\n        #style = KSamplingModes.gamma\n        #if not is_hexagonal:\n        #    num_div = [i + i % 2 for i in num_div]\n        #    style = KSamplingModes.monkhorst\n\n        comment = \"pymatge.io.abinit generated KPOINTS with grid density = \" + \"{} / atom\".format(kppa)\n\n        return cls(\n            mode=\"monkhorst\", num_kpts=0, kpts=[num_div], kpt_shifts=shifts,\n            use_symmetries=use_symmetries, use_time_reversal=use_time_reversal, chksymbreak=chksymbreak,\n            comment=comment)", "response": "Returns an automatic Kpoint object based on a structure and a kpoint - based density."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef to_abivars(self):\n        # These variables are always present.\n        out_vars = {\n            \"ionmov\" : self.abivars.ionmov,\n            \"optcell\": self.abivars.optcell,\n            \"ntime\"  : self.abivars.ntime,\n        }\n\n        # Atom relaxation.\n        if self.move_atoms:\n            out_vars.update({\n                \"tolmxf\": self.abivars.tolmxf,\n            })\n\n        if self.abivars.atoms_constraints:\n            # Add input variables for constrained relaxation.\n            raise NotImplementedError(\"\")\n            out_vars.update(self.abivars.atoms_constraints.to_abivars())\n\n        # Cell relaxation.\n        if self.move_cell:\n            out_vars.update({\n                \"dilatmx\"  : self.abivars.dilatmx,\n                \"ecutsm\"   : self.abivars.ecutsm,\n                \"strfact\"  : self.abivars.strfact,\n                \"strtarget\": self.abivars.strtarget,\n            })\n\n        return out_vars", "response": "Returns a dictionary with the abinit variables"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconstruct an instance of the class cls from the object obj.", "response": "def as_ppmodel(cls, obj):\n        \"\"\"\n        Constructs an instance of PPModel from obj.\n\n        Accepts obj in the form:\n            * PPmodel instance\n            * string. e.g \"godby:12.3 eV\", \"linden\".\n        \"\"\"\n        if isinstance(obj, cls):\n            return obj\n\n        # obj is a string\n        if \":\" not in obj:\n            mode, plasmon_freq = obj, None\n        else:\n            # Extract mode and plasmon_freq\n            mode, plasmon_freq = obj.split(\":\")\n            try:\n                plasmon_freq = float(plasmon_freq)\n            except ValueError:\n                plasmon_freq, unit = plasmon_freq.split()\n                plasmon_freq = units.Energy(float(plasmon_freq), unit).to(\"Ha\")\n\n        return cls(mode=mode, plasmon_freq=plasmon_freq)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef to_abivars(self):\n        return {\n                # Spectral function\n                \"nomegasf\": self.nomegasf,\n                \"domegasf\": self.domegasf,\n                \"spmeth\"  : self.spmeth,\n                 # Frequency mesh for the polarizability\n                \"nfreqre\"  : self.nfreqre,\n                \"freqremax\": self.freqremax,\n                \"nfreqim\"  : self.nfreqim,\n                \"freqremin\": self.freqremin,\n                }", "response": "Returns a dictionary with the abinit variables"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a dictionary with the abinit variables", "response": "def to_abivars(self):\n        \"\"\"Returns a dictionary with the abinit variables\"\"\"\n        abivars = {\n            \"ecuteps\"   : self.ecuteps,\n            \"ecutwfn\"   : self.ecutwfn,\n            \"inclvkb\"   : self.inclvkb,\n            \"gwpara\"    : self.gwpara,\n            \"awtr\"      : self.awtr,\n            \"symchi\"    : self.symchi,\n            \"nband\"     : self.nband,\n            #\"gwcalctyp\": self.gwcalctyp,\n            #\"fftgw\"    : self.fftgw,\n            \"optdriver\" : self.optdriver,\n        }\n\n        # Variables for the Hilber transform.\n        if self.use_hilbert:\n            abivars.update(self.hilbert.to_abivars())\n\n        return abivars"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the value of the gwcalctyp input variable.", "response": "def gwcalctyp(self):\n        \"\"\"Returns the value of the gwcalctyp input variable.\"\"\"\n        dig0 = str(self._SIGMA_TYPES[self.type])\n        dig1 = str(self._SC_MODES[self.sc_mode])\n        return dig1.strip() + dig0.strip()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a dictionary with the abinit variables.", "response": "def to_abivars(self):\n        \"\"\"Returns a dictionary with the abinit variables.\"\"\"\n        abivars = dict(\n            gwcalctyp=self.gwcalctyp,\n            ecuteps=self.ecuteps,\n            ecutsigx=self.ecutsigx,\n            symsigma=self.symsigma,\n            gw_qprange=self.gw_qprange,\n            gwpara=self.gwpara,\n            optdriver=self.optdriver,\n            nband=self.nband\n            #\"ecutwfn\"  : self.ecutwfn,\n            #\"kptgw\"    : self.kptgw,\n            #\"nkptgw\"   : self.nkptgw,\n            #\"bdgw\"     : self.bdgw,\n        )\n\n        # FIXME: problem with the spin\n        #assert len(self.bdgw) == self.nkptgw\n\n        # ppmodel variables\n        if self.use_ppmodel:\n            abivars.update(self.ppmodel.to_abivars())\n\n        return abivars"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a dictionary with the abinit variables.", "response": "def to_abivars(self):\n        \"\"\"Returns a dictionary with the abinit variables.\"\"\"\n        abivars = dict(\n            bs_calctype=1,\n            bs_loband=self.bs_loband,\n            #nband=self.nband,\n            mbpt_sciss=self.mbpt_sciss,\n            ecuteps=self.ecuteps,\n            bs_algorithm=self._ALGO2VAR[self.algo],\n            bs_coulomb_term=21,\n            mdf_epsinf=self.mdf_epsinf,\n            bs_exchange_term=1 if self.with_lf else 0,\n            inclvkb=self.inclvkb,\n            zcut=self.zcut,\n            bs_freq_mesh=self.bs_freq_mesh,\n            bs_coupling=self._EXC_TYPES[self.exc_type],\n            optdriver=self.optdriver,\n        )\n\n        if self.use_haydock:\n            # FIXME\n            abivars.update(\n                bs_haydock_niter=100,      # No. of iterations for Haydock\n                bs_hayd_term=0,            # No terminator\n                bs_haydock_tol=[0.05, 0],  # Stopping criteria\n            )\n\n        elif self.use_direct_diago:\n            raise NotImplementedError(\"\")\n\n        elif self.use_cg:\n            raise NotImplementedError(\"\")\n\n        else:\n            raise ValueError(\"Unknown algorithm for EXC: %s\" % self.algo)\n\n        # Add extra kwargs\n        abivars.update(self.kwargs)\n\n        return abivars"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets fake upper and lower bands for the DOS cluster.", "response": "def set_upper_lower_bands(self,e_lower,e_upper):\n        \"\"\"\n            Set fake upper/lower bands, useful to set the same energy\n            range in the spin up/down bands when calculating the DOS\n        \"\"\"\n        lower_band = e_lower*np.ones((1,self.ebands.shape[1]))\n        upper_band = e_upper*np.ones((1,self.ebands.shape[1]))\n\n        self.ebands = np.vstack((lower_band,self.ebands,upper_band))\n        if isinstance(self.proj,np.ndarray):\n            proj_lower = self.proj[:,0:1,:,:]\n            proj_upper = self.proj[:,-1:,:,:]\n            self.proj = np.concatenate((proj_lower,self.proj,proj_upper),axis=1)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef from_file(self, vasprun_file):\n        vrun_obj = Vasprun(vasprun_file, parse_projected_eigen=True)\n        return VasprunLoader(vrun_obj)", "response": "Get a vasprun. xml file and return a VasprunLoader"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef bandana(self, emin=-np.inf, emax=np.inf):\n        bandmin = np.min(self.ebands, axis=1)\n        bandmax = np.max(self.ebands, axis=1)\n        ii = np.nonzero(bandmin < emax)\n        nemax = ii[0][-1]\n        ii = np.nonzero(bandmax > emin)\n        nemin = ii[0][0]\n        # BoltzTraP2.misc.info(\"BANDANA output\")\n        # for iband in range(len(self.ebands)):\n        # BoltzTraP2.misc.info(iband, bandmin[iband], bandmax[iband], (\n        # (bandmin[iband] < emax) & (bandmax[iband] > emin)))\n        self.ebands = self.ebands[nemin:nemax]\n\n        if isinstance(self.proj, np.ndarray):\n            self.proj = self.proj[:,nemin:nemax,:,:]\n\n        if self.mommat is not None:\n            self.mommat = self.mommat[:, nemin:nemax, :]\n        # Removing bands may change the number of valence electrons\n        if self.nelect is not None:\n            self.nelect -= self.dosweight * nemin\n        return nemin, nemax", "response": "Cut out bands outside the range emin emax"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_band_structure(self):\n\n        kpath = HighSymmKpath(self.data.structure)\n        kpt_line = [Kpoint(k, self.data.structure.lattice) for k\n                    in\n                    kpath.get_kpoints(coords_are_cartesian=False)[\n                        0]]\n        kpoints = np.array(\n            [kp.frac_coords for kp in kpt_line])\n\n        labels_dict = {l: k for k, l in zip(\n            *kpath.get_kpoints(coords_are_cartesian=False)) if l}\n\n        lattvec = self.data.get_lattvec()\n        egrid, vgrid = fite.getBands(kpoints, self.equivalences, lattvec, self.coeffs)\n\n        bands_dict = {Spin.up: (egrid / units.eV)}\n\n        sbs = BandStructureSymmLine(kpoints, bands_dict,\n                                    self.data.structure.lattice.reciprocal_lattice,\n                                    self.efermi / units.eV,\n                                    labels_dict=labels_dict)\n        return sbs", "response": "Returns a BandStructureSymmLine object interpolating bands along a\n        High symmetry path calculated from the structure using HighSymmKpath function"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_dos(self, partial_dos=False, npts_mu=10000, T=None):\n        spin = self.data.spin if isinstance(self.data.spin,int) else 1\n\n        energies, densities, vvdos, cdos = BL.BTPDOS(self.eband, self.vvband, npts=npts_mu)\n        if T is not None:\n            densities = BL.smoothen_DOS(energies, densities, T)\n\n        tdos = Dos(self.efermi / units.eV, energies / units.eV,\n                   {Spin(spin): densities})\n\n        if partial_dos:\n            tdos = self.get_partial_doses(tdos=tdos, npts_mu=npts_mu, T=T)\n\n        return tdos", "response": "Returns a Dos object interpolating bands and partial doses."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_partial_doses(self, tdos, npts_mu, T):\n        spin = self.data.spin if isinstance(self.data.spin,int) else 1\n\n        if not isinstance(self.data.proj,np.ndarray):\n            raise BoltztrapError(\"No projections loaded.\")\n\n        bkp_data_ebands = np.copy(self.data.ebands)\n\n        pdoss = {}\n        # for spin in self.data.proj:\n        for isite, site in enumerate(self.data.structure.sites):\n            if site not in pdoss:\n                pdoss[site] = {}\n            for iorb, orb in enumerate(Orbital):\n                if iorb == self.data.proj.shape[-1]: break\n\n                if orb not in pdoss[site]:\n                    pdoss[site][orb] = {}\n\n                self.data.ebands = self.data.proj[:, :, isite, iorb].T\n                coeffs = fite.fitde3D(self.data, self.equivalences)\n                proj, vvproj, cproj = fite.getBTPbands(self.equivalences,\n                                                       coeffs, self.data.lattvec)\n\n                edos, pdos = BL.DOS(self.eband, npts=npts_mu, weights=np.abs(proj.real))\n\n                if T is not None:\n                    pdos = BL.smoothen_DOS(edos, pdos, T)\n\n                pdoss[site][orb][Spin(spin)] = pdos\n\n        self.data.ebands = bkp_data_ebands\n\n        return CompleteDos(self.data.structure, total_dos=tdos, pdoss=pdoss)", "response": "Returns a CompleteDos object interpolating the projections and the partial doses."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncalculates all the properties w.r.t. the doping levels in input. Args: doping: numpy array specifing the doping levels When executed, it add the following variable at the BztTransportProperties object: Conductivity_doping, Seebeck_doping, Kappa_doping, Power_Factor_doping, cond_Effective_mass_doping are dictionaries with 'n' and 'p' keys and arrays of dim (len(temp_r),len(doping),3,3) as values doping_carriers: number of carriers for each doping level mu_doping_eV: the chemical potential corrispondent to each doping level", "response": "def compute_properties_doping(self, doping, temp_r=None):\n        \"\"\"\n        Calculate all the properties w.r.t. the doping levels in input.\n\n        Args:\n            doping: numpy array specifing the doping levels\n\n        When executed, it add the following variable at the BztTransportProperties\n        object:\n            Conductivity_doping, Seebeck_doping, Kappa_doping, Power_Factor_doping,\n            cond_Effective_mass_doping are dictionaries with 'n' and 'p' keys and\n            arrays of dim (len(temp_r),len(doping),3,3) as values\n        doping_carriers: number of carriers for each doping level\n        mu_doping_eV: the chemical potential corrispondent to each doping level\n        \"\"\"\n\n        if temp_r is None:\n            temp_r = self.temp_r\n\n        self.Conductivity_doping, self.Seebeck_doping, self.Kappa_doping = {}, {}, {}\n        # self.Hall_doping = {}\n\n        self.Power_Factor_doping, self.Effective_mass_doping = {}, {}\n\n        mu_doping = {}\n        doping_carriers = [dop * (self.volume / (units.Meter / 100.) ** 3) for dop in doping]\n\n        for dop_type in ['n', 'p']:\n            sbk = np.zeros((len(temp_r), len(doping), 3, 3))\n            cond = np.zeros((len(temp_r), len(doping), 3, 3))\n            kappa = np.zeros((len(temp_r), len(doping), 3, 3))\n            hall = np.zeros((len(temp_r), len(doping), 3, 3, 3))\n            if dop_type == 'p':\n                doping_carriers = [-dop for dop in doping_carriers]\n\n            mu_doping[dop_type] = np.zeros((len(temp_r), len(doping)))\n            for t, temp in enumerate(temp_r):\n                for i, dop_car in enumerate(doping_carriers):\n                    mu_doping[dop_type][t, i] = self.find_mu_doping(self.epsilon, self.dos, self.nelect + dop_car, temp,\n                                                                    self.dosweight)\n\n                N, L0, L1, L2, Lm11 = BL.fermiintegrals(self.epsilon, self.dos, self.vvdos, mur=mu_doping[dop_type][t],\n                                                        Tr=np.array([temp]), dosweight=self.dosweight)\n                cond[t], sbk[t], kappa[t], hall[t] = BL.calc_Onsager_coefficients(L0, L1, L2, mu_doping[dop_type][t],\n                                                                                  np.array([temp]), self.volume, Lm11)\n\n            self.Conductivity_doping[dop_type] = cond * self.CRTA  # S / m\n            self.Seebeck_doping[dop_type] = sbk * 1e6  # microVolt / K\n            self.Kappa_doping[dop_type] = kappa * self.CRTA  # W / (m K)\n            # self.Hall_doping[dop_type] = hall\n\n            self.Power_Factor_doping[dop_type] = (sbk @ sbk) @ cond * self.CRTA * 1e3\n\n            cond_eff_mass = np.zeros((len(temp_r), len(doping), 3, 3))\n            for t in range(len(temp_r)):\n                for i, dop in enumerate(doping):\n                    try:\n                        cond_eff_mass[t, i] = np.linalg.inv(cond[t, i]) * dop * units.qe_SI ** 2 / units.me_SI * 1e6\n                    except np.linalg.LinAlgError:\n                        pass\n\n            self.Effective_mass_doping[dop_type] = cond_eff_mass\n\n        self.doping_carriers = doping_carriers\n        self.doping = doping\n        self.mu_doping = mu_doping\n        self.mu_doping_eV = {k: v / units.eV - self.efermi for k, v in mu_doping.items()}"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef plot_props(self, prop_y, prop_x, prop_z='temp',\n                   output='avg_eigs', dop_type='n', doping=None,\n                   temps=None, xlim=(-2, 2), ax=None):\n\n        \"\"\"\n            Function to plot the transport properties.\n\n            Args:\n                prop_y: property to plot among (\"Conductivity\",\"Seebeck\",\"Kappa\",\"Carrier_conc\",\"Hall_carrier_conc_trace\"). Abbreviations are possible, like \"S\" for \"Seebeck\"\n                prop_x: independent variable in the x-axis among ('mu','doping','temp')\n                prop_z: third variable to plot multiple curves ('doping','temp')\n                output: 'avg_eigs' to plot the average of the eigenvalues of the properties\n                    tensors; 'eigs' to plot the three eigenvalues of the properties\n                    tensors.\n                dop_type: 'n' or 'p' to specify the doping type in plots that use doping\n                    levels as prop_x or prop_z\n                doping: list of doping level to plot, useful to reduce the number of curves\n                    when prop_z='doping'\n                temps: list of temperatures to plot, useful to reduce the number of curves\n                    when prop_z='temp'\n                xlim: chemical potential range, useful when prop_x='mu'\n                ax: figure.axes where to plot. If None, a new figure is produced.\n\n            Example:\n            bztPlotter.plot_props('S','mu','temp',temps=[600,900,1200]).show()\n            more example are provided in the notebook\n            \"How to use Boltztra2 interface.ipynb\".\n        \"\"\"\n\n        props = (\"Conductivity\", \"Seebeck\", \"Kappa\", \"Effective_mass\",\n                 \"Power_Factor\", \"Carrier_conc\", \"Hall_carrier_conc_trace\")\n        props_lbl = (\"Conductivity\", \"Seebeck\", \"$K_{el}$\", \"Effective mass\",\n                     \"Power Factor\", \"Carrier concentration\", \"Hall carrier conc.\")\n        props_unit = (r\"$(\\mathrm{kS\\,m^{-1}})$\", r\"($\\mu$V/K)\", r\"$(W / (m \\cdot K))$\",\n                      r\"$(m_e)$\", r\"$( mW / (m\\cdot K^2)$\", r\"$(cm^{-3})$\", r\"$(cm^{-3})$\")\n\n        props_short = [p[:len(prop_y)] for p in props]\n\n        if prop_y not in props_short:\n            raise BoltztrapError(\"prop_y not valid\")\n\n        if prop_x not in ('mu', 'doping', 'temp'):\n            raise BoltztrapError(\"prop_x not valid\")\n\n        if prop_z not in ('doping', 'temp'):\n            raise BoltztrapError(\"prop_z not valid\")\n\n        idx_prop = props_short.index(prop_y)\n\n        leg_title = \"\"\n\n        mu = self.bzt_transP.mu_r_eV\n\n        if prop_z == 'doping' and prop_x == 'temp':\n            p_array = eval(\"self.bzt_transP.\" + props[idx_prop] + '_' + prop_z)\n        else:\n            p_array = eval(\"self.bzt_transP.\" + props[idx_prop] + '_' + prop_x)\n\n        if ax is None:\n            fig = plt.figure(figsize=(10, 8))\n\n        temps_all = self.bzt_transP.temp_r.tolist()\n        if temps is None:\n            temps = self.bzt_transP.temp_r.tolist()\n\n        doping_all = self.bzt_transP.doping.tolist()\n        if doping is None:\n            doping = self.bzt_transP.doping.tolist()\n\n        # special case of carrier and hall carrier concentration 2d arrays (temp,mu)\n        if idx_prop in [5, 6]:\n            if prop_z == 'temp' and prop_x == 'mu':\n                for temp in temps:\n                    ti = temps_all.index(temp)\n                    prop_out = p_array[ti]  if idx_prop == 6 else np.abs(p_array[ti])\n                    plt.semilogy(mu, prop_out, label=str(temp) + ' K')\n\n                plt.xlabel(r\"$\\mu$ (eV)\", fontsize=30)\n                plt.xlim(xlim)\n            else:\n                raise BoltztrapError(\"only prop_x=mu and prop_z=temp are available for c.c. and Hall c.c.!\")\n\n        elif prop_z == 'temp' and prop_x == 'mu':\n            for temp in temps:\n                ti = temps_all.index(temp)\n                prop_out = np.linalg.eigh(p_array[ti])[0]\n                if output == 'avg_eigs':\n                    plt.plot(mu, prop_out.mean(axis=1), label=str(temp) + ' K')\n                elif output == 'eigs':\n                    for i in range(3):\n                        plt.plot(mu, prop_out[:, i],\n                                 label='eig ' + str(i) + ' ' + str(temp) + ' K')\n\n            plt.xlabel(r\"$\\mu$ (eV)\", fontsize=30)\n            plt.xlim(xlim)\n\n        elif prop_z == 'temp' and prop_x == 'doping':\n            for temp in temps:\n                ti = temps_all.index(temp)\n                prop_out = np.linalg.eigh(p_array[dop_type][ti])[0]\n                if output == 'avg_eigs':\n                    plt.semilogx(doping_all, prop_out.mean(axis=1), 's-',\n                                 label=str(temp) + ' K')\n                elif output == 'eigs':\n                    for i in range(3):\n                        plt.plot(doping_all, prop_out[:, i], 's-',\n                                 label='eig ' + str(i) + ' ' + str(temp) + ' K')\n            plt.xlabel(r\"Carrier conc. $cm^{-3}$\", fontsize=30)\n            leg_title = dop_type + \"-type\"\n\n        elif prop_z == 'doping' and prop_x == 'temp':\n            for dop in doping:\n                di = doping_all.index(dop)\n                prop_out = np.linalg.eigh(p_array[dop_type][:, di])[0]\n                if output == 'avg_eigs':\n                    plt.plot(temps_all, prop_out.mean(axis=1),\n                             's-', label=str(dop) + ' $cm^{-3}$')\n                elif output == 'eigs':\n                    for i in range(3):\n                        plt.plot(temps_all, prop_out[:, i], 's-',\n                                 label='eig ' + str(i) + ' ' + str(dop) + ' $cm^{-3}$')\n\n            plt.xlabel(r\"Temperature (K)\", fontsize=30)\n            leg_title = dop_type + \"-type\"\n\n        plt.ylabel(props_lbl[idx_prop] + ' ' + props_unit[idx_prop], fontsize=30)\n        plt.xticks(fontsize=25)\n        plt.yticks(fontsize=25)\n        plt.legend(title=leg_title if leg_title != \"\" else \"\", fontsize=15)\n        plt.tight_layout()\n        plt.grid()\n        return plt", "response": "Function to plot the properties of the transport."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nplots a band structure on symmetry line using BSPlotter", "response": "def plot_bands(self):\n        \"\"\"\n            Plot a band structure on symmetry line using BSPlotter()\n        \"\"\"\n        if self.bzt_interp is None:\n            raise BoltztrapError(\"BztInterpolator not present\")\n\n        sbs = self.bzt_interp.get_band_structure()\n\n        return BSPlotter(sbs).get_plot()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef plot_dos(self, T=None, npoints=10000):\n        if self.bzt_interp is None:\n            raise BoltztrapError(\"BztInterpolator not present\")\n\n        tdos = self.bzt_interp.get_dos(T=T,npts_mu=npoints)\n        #print(npoints)\n        dosPlotter = DosPlotter()\n        dosPlotter.add_dos('Total',tdos)\n\n        return dosPlotter", "response": "Plot the total Dos using DosPlotter"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncalculating the energy of the reaction.", "response": "def calculate_energy(self, energies):\n        \"\"\"\n        Calculates the energy of the reaction.\n\n        Args:\n            energies ({Composition: float}): Energy for each composition.\n                E.g ., {comp1: energy1, comp2: energy2}.\n\n        Returns:\n            reaction energy as a float.\n        \"\"\"\n        return sum([amt * energies[c] for amt, c in zip(self._coeffs,\n                                                        self._all_comp)])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nnormalizing the reaction to one of the compositions.", "response": "def normalize_to(self, comp, factor=1):\n        \"\"\"\n        Normalizes the reaction to one of the compositions.\n        By default, normalizes such that the composition given has a\n        coefficient of 1. Another factor can be specified.\n\n        Args:\n            comp (Composition): Composition to normalize to\n            factor (float): Factor to normalize to. Defaults to 1.\n        \"\"\"\n        scale_factor = abs(1 / self._coeffs[self._all_comp.index(comp)]\n                           * factor)\n        self._coeffs = [c * scale_factor for c in self._coeffs]"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef normalize_to_element(self, element, factor=1):\n        all_comp = self._all_comp\n        coeffs = self._coeffs\n        current_el_amount = sum([all_comp[i][element] * abs(coeffs[i])\n                                 for i in range(len(all_comp))]) / 2\n        scale_factor = factor / current_el_amount\n        self._coeffs = [c * scale_factor for c in coeffs]", "response": "Normalizes the reaction to one of the elements."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the amount of the element in the reaction.", "response": "def get_el_amount(self, element):\n        \"\"\"\n        Returns the amount of the element in the reaction.\n\n        Args:\n            element (Element/Specie): Element in the reaction\n\n        Returns:\n            Amount of that element in the reaction.\n        \"\"\"\n        return sum([self._all_comp[i][element] * abs(self._coeffs[i])\n                    for i in range(len(self._all_comp))]) / 2"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a list of all reactants in the hierarchy.", "response": "def reactants(self):\n        \"\"\"\n        List of reactants\n        \"\"\"\n        return [self._all_comp[i] for i in range(len(self._all_comp))\n                if self._coeffs[i] < 0]"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a list of all products in the hierarchy.", "response": "def products(self):\n        \"\"\"\n        List of products\n        \"\"\"\n        return [self._all_comp[i] for i in range(len(self._all_comp))\n                if self._coeffs[i] > 0]"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef as_entry(self, energies):\n        relevant_comp = [comp * abs(coeff) for coeff, comp\n                         in zip(self._coeffs, self._all_comp)]\n        comp = sum(relevant_comp, Composition())\n        entry = ComputedEntry(0.5 * comp, self.calculate_energy(energies))\n        entry.name = self.__str__()\n        return entry", "response": "Returns a ComputedEntry representation of the reaction."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ngenerate a balanced reaction from a string.", "response": "def from_string(rxn_string):\n        \"\"\"\n        Generates a balanced reaction from a string. The reaction must\n        already be balanced.\n\n        Args:\n            rxn_string:\n                The reaction string. For example, \"4 Li + O2-> 2Li2O\"\n\n        Returns:\n            BalancedReaction\n        \"\"\"\n        rct_str, prod_str = rxn_string.split(\"->\")\n\n        def get_comp_amt(comp_str):\n            return {Composition(m.group(2)): float(m.group(1) or 1)\n                    for m in re.finditer(r\"([\\d\\.]*(?:[eE]-?[\\d\\.]+)?)\\s*([A-Z][\\w\\.\\(\\)]*)\",\n                                         comp_str)}\n        return BalancedReaction(get_comp_amt(rct_str), get_comp_amt(prod_str))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef all_entries(self):\n        entries = []\n        for c in self._all_comp:\n            for e in self._all_entries:\n                if e.composition.reduced_formula == c.reduced_formula:\n                    entries.append(e)\n                    break\n        return entries", "response": "Returns a list of all the entries in the order of the entries in the all_comp."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncomputing the energy of a structure using Tersoff potential.", "response": "def get_energy_tersoff(structure, gulp_cmd='gulp'):\n    \"\"\"\n    Compute the energy of a structure using Tersoff potential.\n\n    Args:\n        structure: pymatgen.core.structure.Structure\n        gulp_cmd: GULP command if not in standard place\n    \"\"\"\n    gio = GulpIO()\n    gc = GulpCaller(gulp_cmd)\n    gin = gio.tersoff_input(structure)\n    gout = gc.run(gin)\n    return gio.get_energy(gout)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_energy_buckingham(structure, gulp_cmd='gulp',\n                          keywords=('optimise', 'conp', 'qok'),\n                          valence_dict=None):\n    \"\"\"\n    Compute the energy of a structure using Buckingham potential.\n\n    Args:\n        structure: pymatgen.core.structure.Structure\n        gulp_cmd: GULP command if not in standard place\n        keywords: GULP first line keywords\n        valence_dict: {El: valence}. Needed if the structure is not charge\n            neutral.\n    \"\"\"\n    gio = GulpIO()\n    gc = GulpCaller(gulp_cmd)\n    gin = gio.buckingham_input(\n        structure, keywords, valence_dict=valence_dict\n    )\n    gout = gc.run(gin)\n    return gio.get_energy(gout)", "response": "Compute the energy of a structure using Buckingham potential."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nrelax a structure and compute the energy using Buckingham potential. Args: structure: pymatgen.core.structure.Structure gulp_cmd: GULP command if not in standard place keywords: GULP first line keywords valence_dict: {El: valence}. Needed if the structure is not charge neutral.", "response": "def get_energy_relax_structure_buckingham(structure,\n                                          gulp_cmd='gulp',\n                                          keywords=('optimise', 'conp'),\n                                          valence_dict=None):\n    \"\"\"\n    Relax a structure and compute the energy using Buckingham potential.\n\n    Args:\n        structure: pymatgen.core.structure.Structure\n        gulp_cmd: GULP command if not in standard place\n        keywords: GULP first line keywords\n        valence_dict: {El: valence}. Needed if the structure is not charge\n            neutral.\n    \"\"\"\n    gio = GulpIO()\n    gc = GulpCaller(gulp_cmd)\n    gin = gio.buckingham_input(\n        structure, keywords, valence_dict=valence_dict\n    )\n    gout = gc.run(gin)\n    energy = gio.get_energy(gout)\n    relax_structure = gio.get_relaxed_structure(gout)\n    return energy, relax_structure"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef structure_lines(self, structure, cell_flg=True, frac_flg=True,\n                        anion_shell_flg=True, cation_shell_flg=False,\n                        symm_flg=True):\n        \"\"\"\n        Generates GULP input string corresponding to pymatgen structure.\n\n        Args:\n            structure: pymatgen Structure object\n            cell_flg (default = True): Option to use lattice parameters.\n            fractional_flg (default = True): If True, fractional coordinates\n                are used. Else, cartesian coodinates in Angstroms are used.\n                ******\n                GULP convention is to use fractional coordinates for periodic\n                structures and cartesian coordinates for non-periodic\n                structures.\n                ******\n            anion_shell_flg (default = True): If True, anions are considered\n                polarizable.\n            cation_shell_flg (default = False): If True, cations are\n                considered polarizable.\n            symm_flg (default = True): If True, symmetry information is also\n                written.\n\n        Returns:\n            string containing structure for GULP input\n        \"\"\"\n        gin = \"\"\n        if cell_flg:\n            gin += \"cell\\n\"\n            l = structure.lattice\n            lat_str = [str(i) for i in [l.a, l.b, l.c, l.alpha, l.beta,\n                                        l.gamma]]\n            gin += \" \".join(lat_str) + \"\\n\"\n\n        if frac_flg:\n            gin += \"frac\\n\"\n            coord_attr = \"frac_coords\"\n        else:\n            gin += \"cart\\n\"\n            coord_attr = \"coords\"\n        for site in structure.sites:\n            coord = [str(i) for i in getattr(site, coord_attr)]\n            specie = site.specie\n            core_site_desc = specie.symbol + \" core \" + \" \".join(coord) + \"\\n\"\n            gin += core_site_desc\n            if ((specie in _anions and anion_shell_flg) or\n                    (specie in _cations and cation_shell_flg)):\n                shel_site_desc = specie.symbol + \" shel \" + \" \".join(\n                    coord) + \"\\n\"\n                gin += shel_site_desc\n            else:\n                pass\n\n        if symm_flg:\n            gin += \"space\\n\"\n            gin += str(SpacegroupAnalyzer(structure).get_space_group_number()) + \"\\n\"\n        return gin", "response": "Generates GULP input string corresponding to pymatgen structure object."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn GULP library line", "response": "def library_line(self, file_name):\n        \"\"\"\n        Specifies GULP library file to read species and potential parameters.\n        If using library don't specify species and potential\n        in the input file and vice versa. Make sure the elements of\n        structure are in the library file.\n\n        Args:\n            file_name: Name of GULP library file\n\n        Returns:\n            GULP input string specifying library option\n        \"\"\"\n        gulplib_set = lambda: 'GULP_LIB' in os.environ.keys()\n        readable = lambda f: os.path.isfile(f) and os.access(f, os.R_OK)\n\n        #dirpath, fname = os.path.split(file_name)\n        #if dirpath:  # Full path specified\n        #    if readable(file_name):\n        #        gin = 'library ' + file_name\n        #    else:\n        #        raise GulpError('GULP Library not found')\n        #else:\n        #    fpath = os.path.join(os.getcwd(), file_name)  # Check current dir\n        #    if readable(fpath):\n        #        gin = 'library ' + fpath\n        #    elif gulplib_set():\n        #        fpath = os.path.join(os.environ['GULP_LIB'], file_name)\n        #        if readable(fpath):\n        #            gin = 'library ' + file_name\n        #        else:\n        #            raise GulpError('GULP Library not found')\n        #    else:\n        #        raise GulpError('GULP Library not found')\n        #gin += \"\\n\"\n        #return gin\n\n        gin = \"\"\n        dirpath, fname = os.path.split(file_name)\n        if dirpath and readable(file_name):  # Full path specified\n            gin = 'library ' + file_name\n        else:\n            fpath = os.path.join(os.getcwd(), file_name)  # Check current dir\n            if readable(fpath):\n                gin = 'library ' + fpath\n            elif gulplib_set():         # Check the GULP_LIB path\n                fpath = os.path.join(os.environ['GULP_LIB'], file_name)\n                if readable(fpath):\n                    gin = 'library ' + file_name\n        if gin:\n            return gin + \"\\n\"\n        else:\n            raise GulpError('GULP Library not found')"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets a GULP input for an oxide structure and buckingham potential.", "response": "def buckingham_input(self, structure, keywords, library=None,\n                         uc=True, valence_dict=None):\n        \"\"\"\n        Gets a GULP input for an oxide structure and buckingham potential\n        from library.\n\n        Args:\n            structure: pymatgen.core.structure.Structure\n            keywords: GULP first line keywords.\n            library (Default=None): File containing the species and potential.\n            uc (Default=True): Unit Cell Flag.\n            valence_dict: {El: valence}\n        \"\"\"\n        gin = self.keyword_line(*keywords)\n        gin += self.structure_lines(structure, symm_flg=not uc)\n        if not library:\n            gin += self.buckingham_potential(structure, valence_dict)\n        else:\n            gin += self.library_line(library)\n        return gin"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngenerates species buckingham and spring options for an oxide structure.", "response": "def buckingham_potential(self, structure, val_dict=None):\n        \"\"\"\n        Generate species, buckingham, and spring options for an oxide structure\n        using the parameters in default libraries.\n\n        Ref:\n            1. G.V. Lewis and C.R.A. Catlow, J. Phys. C: Solid State Phys.,\n               18, 1149-1161 (1985)\n            2. T.S.Bush, J.D.Gale, C.R.A.Catlow and P.D. Battle,\n               J. Mater Chem., 4, 831-837 (1994)\n\n        Args:\n            structure: pymatgen.core.structure.Structure\n            val_dict (Needed if structure is not charge neutral): {El:valence}\n                dict, where El is element.\n        \"\"\"\n        if not val_dict:\n            try:\n                #If structure is oxidation state decorated, use that first.\n                el = [site.specie.symbol for site in structure]\n                valences = [site.specie.oxi_state for site in structure]\n                val_dict = dict(zip(el, valences))\n            except AttributeError:\n                bv = BVAnalyzer()\n                el = [site.specie.symbol for site in structure]\n                valences = bv.get_valences(structure)\n                val_dict = dict(zip(el, valences))\n\n        #Try bush library first\n        bpb = BuckinghamPotential('bush')\n        bpl = BuckinghamPotential('lewis')\n        gin = \"\"\n        for key in val_dict.keys():\n            use_bush = True\n            el = re.sub(r'[1-9,+,\\-]', '', key)\n            if el not in bpb.species_dict.keys():\n                use_bush = False\n            elif val_dict[key] != bpb.species_dict[el]['oxi']:\n                use_bush = False\n            if use_bush:\n                gin += \"species \\n\"\n                gin += bpb.species_dict[el]['inp_str']\n                gin += \"buckingham \\n\"\n                gin += bpb.pot_dict[el]\n                gin += \"spring \\n\"\n                gin += bpb.spring_dict[el]\n                continue\n\n            #Try lewis library next if element is not in bush\n            #use_lewis = True\n            if el != \"O\":  # For metals the key is \"Metal_OxiState+\"\n                k = el + '_' + str(int(val_dict[key])) + '+'\n                if k not in bpl.species_dict.keys():\n                    #use_lewis = False\n                    raise GulpError(\"Element {} not in library\".format(k))\n                gin += \"species\\n\"\n                gin += bpl.species_dict[k]\n                gin += \"buckingham\\n\"\n                gin += bpl.pot_dict[k]\n            else:\n                gin += \"species\\n\"\n                k = \"O_core\"\n                gin += bpl.species_dict[k]\n                k = \"O_shel\"\n                gin += bpl.species_dict[k]\n                gin += \"buckingham\\n\"\n                gin += bpl.pot_dict[key]\n                gin += 'spring\\n'\n                gin += bpl.spring_dict[key]\n        return gin"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef tersoff_input(self, structure, periodic=False, uc=True, *keywords):\n        #gin=\"static noelectrostatics \\n \"\n        gin = self.keyword_line(*keywords)\n        gin += self.structure_lines(\n            structure, cell_flg=periodic, frac_flg=periodic,\n            anion_shell_flg=False, cation_shell_flg=False, symm_flg=not uc\n        )\n        gin += self.tersoff_potential(structure)\n        return gin", "response": "Gets a GULP input with Tersoff potential for an oxide structure."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ngenerate the species tersoff potential lines for an oxide structure", "response": "def tersoff_potential(self, structure):\n        \"\"\"\n        Generate the species, tersoff potential lines for an oxide structure\n\n        Args:\n            structure: pymatgen.core.structure.Structure\n        \"\"\"\n        bv = BVAnalyzer()\n        el = [site.specie.symbol for site in structure]\n        valences = bv.get_valences(structure)\n        el_val_dict = dict(zip(el, valences))\n\n        gin = \"species \\n\"\n        qerfstring = \"qerfc\\n\"\n\n        for key in el_val_dict.keys():\n            if key != \"O\" and el_val_dict[key] % 1 != 0:\n                raise SystemError(\"Oxide has mixed valence on metal\")\n            specie_string = key + \" core \" + str(el_val_dict[key]) + \"\\n\"\n            gin += specie_string\n            qerfstring += key + \" \" + key + \" 0.6000 10.0000 \\n\"\n\n        gin += \"# noelectrostatics \\n Morse \\n\"\n        met_oxi_ters = TersoffPotential().data\n        for key in el_val_dict.keys():\n            if key != \"O\":\n                metal = key + \"(\" + str(int(el_val_dict[key])) + \")\"\n                ters_pot_str = met_oxi_ters[metal]\n                gin += ters_pot_str\n\n        gin += qerfstring\n        return gin"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nrunning GULP using the gin as input string", "response": "def run(self, gin):\n        \"\"\"\n        Run GULP using the gin as input\n\n        Args:\n            gin: GULP input string\n\n        Returns:\n            gout: GULP output string\n        \"\"\"\n        with ScratchDir(\".\"):\n            p = subprocess.Popen(\n                self._gulp_cmd, stdout=subprocess.PIPE,\n                stdin=subprocess.PIPE, stderr=subprocess.PIPE\n            )\n\n            out, err = p.communicate(bytearray(gin, \"utf-8\"))\n            out = out.decode(\"utf-8\")\n            err = err.decode(\"utf-8\")\n\n            if \"Error\" in err or \"error\" in err:\n                print(gin)\n                print(\"----output_0---------\")\n                print(out)\n                print(\"----End of output_0------\\n\\n\\n\")\n                print(\"----output_1--------\")\n                print(out)\n                print(\"----End of output_1------\")\n                raise GulpError(err)\n\n            # We may not need this\n            if \"ERROR\" in out:\n                raise GulpError(out)\n\n            # Sometimes optimisation may fail to reach convergence\n            conv_err_string = \"Conditions for a minimum have not been satisfied\"\n            if conv_err_string in out:\n                raise GulpConvergenceError()\n\n            gout = \"\"\n            for line in out.split(\"\\n\"):\n                gout = gout + line + \"\\n\"\n            return gout"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nprints to the given string the documentation for the events and the associated handlers.", "response": "def autodoc_event_handlers(stream=sys.stdout):\n    \"\"\"\n    Print to the given string, the documentation for the events\n    and the associated handlers.\n    \"\"\"\n    lines = []\n    for cls in all_subclasses(EventHandler):\n        if cls in _ABC_EVHANDLER_CLASSES: continue\n        event_class = cls.event_class\n        lines.extend(cls.cls2str().split(\"\\n\"))\n\n        # Here we enforce the abstract protocol of the class\n        # The unit test in tests_events will detect the problem.\n        if not hasattr(cls, \"can_change_physics\"):\n            raise RuntimeError(\"%s: can_change_physics must be defined\" % cls)\n\n    stream.write(\"\\n\".join(lines) + \"\\n\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the list of handler classes.", "response": "def get_event_handler_classes(categories=None):\n    \"\"\"Return the list of handler classes.\"\"\"\n    classes = [c for c in all_subclasses(EventHandler) if c not in _ABC_EVHANDLER_CLASSES]\n    return classes"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconverting obj into a subclass of AbinitEvent.", "response": "def as_event_class(obj):\n    \"\"\"\n    Convert obj into a subclass of AbinitEvent.\n    obj can be either a class or a string with the class name or the YAML tag\n    \"\"\"\n    if is_string(obj):\n        for c in all_subclasses(AbinitEvent):\n            if c.__name__ == obj or c.yaml_tag == obj: return c\n        raise ValueError(\"Cannot find event class associated to %s\" % obj)\n\n    # Assume class.\n    assert obj in all_subclasses(AbinitEvent)\n    return obj"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the baseclass of the object.", "response": "def baseclass(self):\n        \"\"\"The baseclass of self.\"\"\"\n        for cls in _BASE_CLASSES:\n            if isinstance(self, cls):\n                return cls\n\n        raise ValueError(\"Cannot determine the base class of %s\" % self.__class__.__name__)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef append(self, event):\n        self._events.append(event)\n        self._events_by_baseclass[event.baseclass].append(event)", "response": "Add an event to the list."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_run_completed(self, boolean, start_datetime, end_datetime):\n        self._run_completed = boolean\n\n        if (start_datetime, end_datetime) != (None, None):\n            # start_datetime: Sat Feb 28 23:54:27 2015\n            # end_datetime: Sat Feb 28 23:54:30 2015\n            try:\n                fmt = \"%a %b %d %H:%M:%S %Y\"\n                self.start_datetime = datetime.datetime.strptime(start_datetime, fmt)\n                self.end_datetime = datetime.datetime.strptime(end_datetime, fmt)\n            except Exception as exc:\n                # Maybe LOCALE != en_US\n                logger.warning(str(exc))", "response": "Set the value of _run_completed."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef run_etime(self):\n        if self.start_datetime is None or self.end_datetime is None:\n            return None\n\n        return self.end_datetime - self.start_datetime", "response": "Wall - time of the run as timedelta object."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nparses the given file and return a new EventReport object.", "response": "def parse(self, filename, verbose=0):\n        \"\"\"\n        Parse the given file. Return :class:`EventReport`.\n        \"\"\"\n        run_completed, start_datetime, end_datetime = False, None, None\n        filename = os.path.abspath(filename)\n        report = EventReport(filename)\n\n        w = WildCard(\"*Error|*Warning|*Comment|*Bug|*ERROR|*WARNING|*COMMENT|*BUG\")\n        import warnings\n        warnings.simplefilter('ignore', yaml.error.UnsafeLoaderWarning)\n        with YamlTokenizer(filename) as tokens:\n            for doc in tokens:\n                if w.match(doc.tag):\n                    #print(\"got doc.tag\", doc.tag,\"--\")\n                    try:\n                        #print(doc.text)\n                        event = yaml.load(doc.text)   # Can't use ruamel safe_load!\n                        #yaml.load(doc.text, Loader=ruamel.yaml.Loader)\n                        #print(event.yaml_tag, type(event))\n                    except:\n                        #raise\n                        # Wrong YAML doc. Check tha doc tag and instantiate the proper event.\n                        message = \"Malformatted YAML document at line: %d\\n\" % doc.lineno\n                        message += doc.text\n\n                        # This call is very expensive when we have many exceptions due to malformatted YAML docs.\n                        if verbose:\n                            message += \"Traceback:\\n %s\" % straceback()\n\n                        if \"error\" in doc.tag.lower():\n                            print(\"It seems an error. doc.tag:\", doc.tag)\n                            event = AbinitYamlError(message=message, src_file=__file__, src_line=0)\n                        else:\n                            event = AbinitYamlWarning(message=message, src_file=__file__, src_line=0)\n\n                    event.lineno = doc.lineno\n                    report.append(event)\n\n                # Check whether the calculation completed.\n                if doc.tag == \"!FinalSummary\":\n                    #print(doc)\n                    run_completed = True\n                    d = doc.as_dict()\n                    #print(d)\n                    start_datetime, end_datetime = d[\"start_datetime\"], d[\"end_datetime\"]\n\n        report.set_run_completed(run_completed, start_datetime, end_datetime)\n        return report"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the number of times the event associated to this handler has been already fixed in the Task.", "response": "def count(self, task):\n        \"\"\"\n        Return the number of times the event associated to this handler\n        has been already fixed in the :class:`Task`.\n        \"\"\"\n        return len([c for c in task.corrections if c[\"event\"][\"@class\"] == self.event_class])"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef find_stable_charges(self):\n\n        def similar_defect(a):\n            \"\"\"\n            Used to filter out similar defects of different charges which\n            are defined by the same type and location\n            \"\"\"\n            return (a.name, a.site)\n\n        # Limits for search\n        # E_fermi = { -1 eV to band gap+1}\n        # the 1 eV padding provides\n        # E_formation. = { -21 eV to 20 eV}\n        limits = [[-1, self.band_gap + 1], [-21, 20]]\n\n        stable_entries = {}\n        finished_charges = {}\n        transition_level_map = {}\n\n        # Grouping by defect types\n        for _, defects in groupby(sorted(self.entries, key=similar_defect), similar_defect):\n            defects = list(defects)\n\n            # prepping coefficient matrix forx half-space intersection\n            # [-Q, 1, -1*(E_form+Q*VBM)] -> -Q*E_fermi+E+-1*(E_form+Q*VBM) <= 0  where E_fermi and E are the variables in the hyperplanes\n            hyperplanes = np.array(\n                [[-1.0 * entry.charge, 1, -1.0 * (entry.energy + entry.charge * self.vbm)] for entry in defects])\n\n            border_hyperplanes = [[-1, 0, limits[0][0]], [1, 0, -1 * limits[0][1]], [0, -1, limits[1][0]],\n                                  [0, 1, -1 * limits[1][1]]]\n            hs_hyperplanes = np.vstack([hyperplanes, border_hyperplanes])\n\n            interior_point = [self.band_gap / 2, -20]\n\n            hs_ints = HalfspaceIntersection(hs_hyperplanes, np.array(interior_point))\n\n            # Group the intersections and coresponding facets\n            ints_and_facets = zip(hs_ints.intersections, hs_ints.dual_facets)\n            # Only inlcude the facets corresponding to entries, not the boundaries\n            total_entries = len(defects)\n            ints_and_facets = filter(lambda int_and_facet: all(np.array(int_and_facet[1]) < total_entries),\n                                     ints_and_facets)\n            # sort based on transition level\n            ints_and_facets = list(sorted(ints_and_facets, key=lambda int_and_facet: int_and_facet[0][0]))\n\n            if len(ints_and_facets):\n                # Unpack into lists\n                _, facets = zip(*ints_and_facets)\n                # Map of transition level: charge states\n\n                transition_level_map[defects[0].name] = {\n                    intersection[0]: [defects[i].charge for i in facet]\n                    for intersection, facet in ints_and_facets\n                }\n\n                stable_entries[defects[0].name] = list(set([defects[i] for dual in facets for i in dual]))\n\n                finished_charges[defects[0].name] = [defect.charge for defect in defects]\n            else:\n                # if ints_and_facets is empty, then there is likely only one defect...\n                if len(defects) != 1:\n                    raise ValueError(\"ints and facets was empty but more than one defect exists... why?\")\n\n                transition_level_map[defects[0].name] = {}\n\n                stable_entries[defects[0].name] = list([defects[0]])\n\n                finished_charges[defects[0].name] = [defects[0].charge]\n\n\n        self.transition_level_map = transition_level_map\n        self.transition_levels = {\n            defect_name: list(defect_tls.keys())\n            for defect_name, defect_tls in transition_level_map.items()\n        }\n        self.stable_entries = stable_entries\n        self.finished_charges = finished_charges\n        self.stable_charges = {\n            defect_name: [entry.charge for entry in entries]\n            for defect_name, entries in stable_entries.items()\n        }", "response": "This function finds the stable charges and transition states for a series of defect entries."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef all_unstable_entries(self):\n        all_stable_entries = self.all_stable_entries\n        return [e for e in self.entries if e not in all_stable_entries]", "response": "List all unstable entries in the DefectPhaseDiagram"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a list of dictionaries of defect concentrations for all stable entries in the DefectPhaseDiagram that are in the same order as the chemical potentials in the VBM.", "response": "def defect_concentrations(self, chemical_potentials, temperature=300, fermi_level=0.):\n        \"\"\"\n        Give list of all concentrations at specified efermi in the DefectPhaseDiagram\n        args:\n            chemical_potentials = {Element: number} is dictionary of chemical potentials to provide formation energies for\n            temperature = temperature to produce concentrations from\n            fermi_level: (float) is fermi level relative to valence band maximum\n                Default efermi = 0 = VBM energy\n        returns:\n            list of dictionaries of defect concentrations\n        \"\"\"\n        concentrations = []\n        for dfct in self.all_stable_entries:\n            concentrations.append({\n                'conc':\n                dfct.defect_concentration(\n                    chemical_potentials=chemical_potentials, temperature=temperature, fermi_level=fermi_level),\n                'name':\n                dfct.name,\n                'charge':\n                dfct.charge\n            })\n\n        return concentrations"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef suggest_charges(self, tolerance=0.1):\n        recommendations = {}\n\n        for def_type in self.defect_types:\n            test_charges = np.arange(\n                np.min(self.stable_charges[def_type]) - 1,\n                np.max(self.stable_charges[def_type]) + 2)\n            test_charges = [charge for charge in test_charges if charge not in self.finished_charges[def_type]]\n\n            if len(self.transition_level_map[def_type].keys()):\n                # More positive charges will shift the minimum transition level down\n                # Max charge is limited by this if its transition level is close to VBM\n                min_tl = min(self.transition_level_map[def_type].keys())\n                if min_tl < tolerance:\n                    max_charge = max(self.transition_level_map[def_type][min_tl])\n                    test_charges = [charge for charge in test_charges if charge < max_charge]\n\n                # More negative charges will shift the maximum transition level up\n                # Minimum charge is limited by this if transition level is near CBM\n                max_tl = max(self.transition_level_map[def_type].keys())\n                if max_tl > (self.band_gap - tolerance):\n                    min_charge = min(self.transition_level_map[def_type][max_tl])\n                    test_charges = [charge for charge in test_charges if charge > min_charge]\n            else:\n                test_charges = [charge for charge in test_charges if charge not in self.stable_charges[def_type]]\n\n            recommendations[def_type] = test_charges\n\n        return recommendations", "response": "Suggest possible charges for defects to computee based on proximity\nMimeType of known transitions from entires to VBM and CBM."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef solve_for_fermi_energy(self, temperature, chemical_potentials, bulk_dos):\n\n        fdos = FermiDos(bulk_dos, bandgap=self.band_gap)\n\n        def _get_total_q(ef):\n\n            qd_tot = sum([\n                d['charge'] * d['conc']\n                for d in self.defect_concentrations(\n                    chemical_potentials=chemical_potentials, temperature=temperature, fermi_level=ef)\n            ])\n            qd_tot += fdos.get_doping(fermi=ef + self.vbm, T=temperature)\n            return qd_tot\n\n        return bisect(_get_total_q, -1., self.band_gap + 1.)", "response": "Solve for the Fermi energy self - consistently as a function of T\n        and p_O22\n       ."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef asxc(cls, obj):\n        if isinstance(obj, cls): return obj\n        if is_string(obj): return cls.from_name(obj)\n        raise TypeError(\"Don't know how to convert <%s:%s> to Xcfunc\" % (type(obj), str(obj)))", "response": "Convert object into Xcfunc."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef from_abinit_ixc(cls, ixc):\n        ixc = int(ixc)\n        if ixc >= 0:\n            return cls(**cls.abinitixc_to_libxc[ixc])\n        else:\n            # libxc notation employed in Abinit: a six-digit number in the form XXXCCC or CCCXXX\n            #ixc = str(ixc)\n            #assert len(ixc[1:]) == 6\n            #first, last = ixc[1:4], ixc[4:]\n            ixc = abs(ixc)\n            first = ixc // 1000\n            last = ixc - first * 1000\n            x, c = LibxcFunc(int(first)), LibxcFunc(int(last))\n            if not x.is_x_kind: x, c = c, x  # Swap\n            assert x.is_x_kind and c.is_c_kind\n            return cls(x=x, c=c)", "response": "Build the object from an Abinit ixc number."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nbuild the object from the type and name.", "response": "def from_type_name(cls, typ, name):\n        \"\"\"Build the object from (type, name).\"\"\"\n        # Try aliases first.\n        for k, nt in cls.defined_aliases.items():\n            if typ is not None and typ != nt.type: continue\n            #print(name, nt.name)\n            if name == nt.name:\n                if len(k) == 1: return cls(xc=k)\n                if len(k) == 2: return cls(x=k[0], c=k[1])\n                raise ValueError(\"Wrong key: %s\" % k)\n\n        # At this point, we should have something in the form\n        # name=\"GGA_X_PBE+GGA_C_PBE\" or  name=\"\"LDA_XC_TETER93\"\n        if \"+\" in name:\n            #if typ is not None: raise ValueError(\"typ: `%s` but name: `%s`\" % (typ, name))\n            x, c = (s.strip() for s in name.split(\"+\"))\n            x, c = LibxcFunc[x], LibxcFunc[c]\n            return cls(x=x, c=c)\n        else:\n            #if typ is not None: raise ValueError(\"typ: `%s` but name: `%s`\" % (typ, name))\n            xc = LibxcFunc[name]\n            return cls(xc=xc)\n\n        if typ is None:\n            raise ValueError(\"Cannot find name=%s in defined_aliases\" % name)\n        else:\n            raise ValueError(\"Cannot find type=%s, name=%s in defined_aliases\" % (typ, name))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef from_dict(cls, d):\n        return cls(xc=d.get(\"xc\"), x=d.get(\"x\"), c=d.get(\"c\"))", "response": "Create a new XcFunc from a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef as_dict(self):\n        d = {\"@module\": self.__class__.__module__,\n             \"@class\": self.__class__.__name__}\n        # print(\"in as_dict\", type(self.x), type(self.c), type(self.xc))\n        if self.x is not None: d[\"x\"] = self.x.as_dict()\n        if self.c is not None: d[\"c\"] = self.c.as_dict()\n        if self.xc is not None: d[\"xc\"] = self.xc.as_dict()\n        return d", "response": "Returns a dictionary representation of the object."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef type(self):\n        if self.xc in self.defined_aliases: return self.defined_aliases[self.xc].type\n        xc = (self.x, self.c)\n        if xc in self.defined_aliases: return self.defined_aliases[xc].type\n\n        # If self is not in defined_aliases, use LibxcFunc family\n        if self.xc is not None: return self.xc.family\n        return \"+\".join([self.x.family, self.c.family])", "response": "The type of the functional."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef name(self):\n        if self.xc in self.defined_aliases: return self.defined_aliases[self.xc].name\n        xc = (self.x, self.c)\n        if xc in self.defined_aliases: return self.defined_aliases[xc].name\n        if self.xc is not None: return self.xc.name\n        return \"+\".join([self.x.name, self.c.name])", "response": "Returns the name of the functional."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a list of VoronoiContainer objects from a BSON - encoded list of voronoi objects and a structure.", "response": "def from_bson_voronoi_list(bson_nb_voro_list, structure):\n    \"\"\"\n    Returns the voronoi_list needed for the VoronoiContainer object from a bson-encoded voronoi_list (composed of\n    vlist and bson_nb_voro_list).\n    :param vlist: List of voronoi objects\n    :param bson_nb_voro_list: List of periodic sites involved in the Voronoi\n    :return: The voronoi_list needed for the VoronoiContainer (with PeriodicSites as keys of the dictionary - not\n    allowed in the BSON format)\n    \"\"\"\n    voronoi_list = [None] * len(bson_nb_voro_list)\n    for isite, voro in enumerate(bson_nb_voro_list):\n        if voro is None or voro == 'None':\n            continue\n        voronoi_list[isite] = []\n        for psd, dd in voro:\n            struct_site = structure[dd['index']]\n            periodic_site = PeriodicSite(struct_site._species, struct_site.frac_coords + psd[1],\n                                         struct_site._lattice, properties=struct_site.properties)\n            voronoi_list[isite].append((periodic_site, dd))\n    return voronoi_list"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef setup_voronoi_list(self, indices, voronoi_cutoff):\n        self.voronoi_list2 = [None] * len(self.structure)\n        self.voronoi_list_coords = [None] * len(self.structure)\n        logging.info('Getting all neighbors in structure')\n        struct_neighbors = self.structure.get_all_neighbors(voronoi_cutoff, include_index=True)\n        t1 = time.clock()\n        logging.info('Setting up Voronoi list :')\n\n        for jj, isite in enumerate(indices):\n            logging.info('  - Voronoi analysis for site #{:d} ({:d}/{:d})'.format(isite, jj+1, len(indices)))\n            site = self.structure[isite]\n            neighbors1 = [(site, 0.0, isite)]\n            neighbors1.extend(struct_neighbors[isite])\n            distances = [i[1] for i in sorted(neighbors1, key=lambda s: s[1])]\n            neighbors = [i[0] for i in sorted(neighbors1, key=lambda s: s[1])]\n            qvoronoi_input = [s.coords for s in neighbors]\n            voro = Voronoi(points=qvoronoi_input, qhull_options=\"o Fv\")\n            all_vertices = voro.vertices\n\n            results2 = []\n            maxangle = 0.0\n            mindist = 10000.0\n            for iridge, ridge_points in enumerate(voro.ridge_points):\n                if 0 in ridge_points:\n                    ridge_vertices_indices = voro.ridge_vertices[iridge]\n                    if -1 in ridge_vertices_indices:\n                        raise RuntimeError(\"This structure is pathological,\"\n                                           \" infinite vertex in the voronoi \"\n                                           \"construction\")\n\n                    ridge_point2 = max(ridge_points)\n                    facets = [all_vertices[i] for i in ridge_vertices_indices]\n                    sa = my_solid_angle(site.coords, facets)\n                    maxangle = max([sa, maxangle])\n\n                    mindist = min([mindist, distances[ridge_point2]])\n                    for iii, sss in enumerate(self.structure):\n                        if neighbors[ridge_point2].is_periodic_image(sss):\n                            myindex = iii\n                            break\n                    results2.append({'site': neighbors[ridge_point2],\n                                     'angle': sa,\n                                     'distance': distances[ridge_point2],\n                                     'index': myindex})\n            for dd in results2:\n                dd['normalized_angle'] = dd['angle'] / maxangle\n                dd['normalized_distance'] = dd['distance'] / mindist\n            self.voronoi_list2[isite] = results2\n            self.voronoi_list_coords[isite] = np.array([dd['site'].coords for dd in results2])\n        t2 = time.clock()\n        logging.info('Voronoi list set up in {:.2f} seconds'.format(t2-t1))", "response": "This function sets up the voronoi list of neighbours by calling qhull for each site in the structure."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef setup_neighbors_distances_and_angles(self, indices):\n        self.neighbors_distances = [None] * len(self.structure)\n        self.neighbors_normalized_distances = [None] * len(self.structure)\n        self.neighbors_angles = [None] * len(self.structure)\n        self.neighbors_normalized_angles = [None] * len(self.structure)\n        for isite in indices:\n            results = self.voronoi_list2[isite]\n            if results is None:\n                continue\n            #Initializes neighbors distances and normalized distances groups\n            self.neighbors_distances[isite] = []\n            self.neighbors_normalized_distances[isite] = []\n            normalized_distances = [nb_dict['normalized_distance'] for nb_dict in results]\n            isorted_distances = np.argsort(normalized_distances)\n            self.neighbors_normalized_distances[isite].append({'min': normalized_distances[isorted_distances[0]],\n                                                               'max': normalized_distances[isorted_distances[0]]})\n            self.neighbors_distances[isite].append({'min': results[isorted_distances[0]]['distance'],\n                                                    'max': results[isorted_distances[0]]['distance']})\n            icurrent = 0\n            nb_indices = {int(isorted_distances[0])}\n            dnb_indices = {int(isorted_distances[0])}\n            for idist in iter(isorted_distances):\n                wd = normalized_distances[idist]\n                if self.maximum_distance_factor is not None:\n                    if wd > self.maximum_distance_factor:\n                        self.neighbors_normalized_distances[isite][icurrent]['nb_indices'] = list(nb_indices)\n                        self.neighbors_distances[isite][icurrent]['nb_indices'] = list(nb_indices)\n                        self.neighbors_normalized_distances[isite][icurrent]['dnb_indices'] = list(dnb_indices)\n                        self.neighbors_distances[isite][icurrent]['dnb_indices'] = list(dnb_indices)\n                        break\n                if np.isclose(wd, self.neighbors_normalized_distances[isite][icurrent]['max'],\n                              rtol=0.0, atol=self.normalized_distance_tolerance):\n                    self.neighbors_normalized_distances[isite][icurrent]['max'] = wd\n                    self.neighbors_distances[isite][icurrent]['max'] = results[idist]['distance']\n                    dnb_indices.add(int(idist))\n                else:\n                    self.neighbors_normalized_distances[isite][icurrent]['nb_indices'] = list(nb_indices)\n                    self.neighbors_distances[isite][icurrent]['nb_indices'] = list(nb_indices)\n                    self.neighbors_normalized_distances[isite][icurrent]['dnb_indices'] = list(dnb_indices)\n                    self.neighbors_distances[isite][icurrent]['dnb_indices'] = list(dnb_indices)\n                    dnb_indices = {int(idist)}\n                    self.neighbors_normalized_distances[isite].append({'min': wd,\n                                                                       'max': wd})\n                    self.neighbors_distances[isite].append({'min': results[idist]['distance'],\n                                                            'max': results[idist]['distance']})\n                    icurrent += 1\n                nb_indices.add(int(idist))\n            else:\n                self.neighbors_normalized_distances[isite][icurrent]['nb_indices'] = list(nb_indices)\n                self.neighbors_distances[isite][icurrent]['nb_indices'] = list(nb_indices)\n                self.neighbors_normalized_distances[isite][icurrent]['dnb_indices'] = list(dnb_indices)\n                self.neighbors_distances[isite][icurrent]['dnb_indices'] = list(dnb_indices)\n            for idist in range(len(self.neighbors_distances[isite]) - 1):\n                dist_dict = self.neighbors_distances[isite][idist]\n                dist_dict_next = self.neighbors_distances[isite][idist+1]\n                dist_dict['next'] = dist_dict_next['min']\n                ndist_dict = self.neighbors_normalized_distances[isite][idist]\n                ndist_dict_next = self.neighbors_normalized_distances[isite][idist + 1]\n                ndist_dict['next'] = ndist_dict_next['min']\n            if self.maximum_distance_factor is not None:\n                dfact = self.maximum_distance_factor\n            else:\n                dfact = self.default_voronoi_cutoff / self.neighbors_distances[isite][0]['min']\n            self.neighbors_normalized_distances[isite][-1]['next'] = dfact\n            self.neighbors_distances[isite][-1]['next'] = dfact * self.neighbors_distances[isite][0]['min']\n            #Initializes neighbors angles and normalized angles groups\n            self.neighbors_angles[isite] = []\n            self.neighbors_normalized_angles[isite] = []\n            normalized_angles = [nb_dict['normalized_angle'] for nb_dict in results]\n            isorted_angles = np.argsort(normalized_angles)[::-1]\n            self.neighbors_normalized_angles[isite].append({'max': normalized_angles[isorted_angles[0]],\n                                                            'min': normalized_angles[isorted_angles[0]]})\n            self.neighbors_angles[isite].append({'max': results[isorted_angles[0]]['angle'],\n                                                 'min': results[isorted_angles[0]]['angle']})\n            icurrent = 0\n            nb_indices = {int(isorted_angles[0])}\n            dnb_indices = {int(isorted_angles[0])}\n            for iang in iter(isorted_angles):\n                wa = normalized_angles[iang]\n                if self.minimum_angle_factor is not None:\n                    if wa < self.minimum_angle_factor:\n                        self.neighbors_normalized_angles[isite][icurrent]['nb_indices'] = list(nb_indices)\n                        self.neighbors_angles[isite][icurrent]['nb_indices'] = list(nb_indices)\n                        self.neighbors_normalized_angles[isite][icurrent]['dnb_indices'] = list(dnb_indices)\n                        self.neighbors_angles[isite][icurrent]['dnb_indices'] = list(dnb_indices)\n                        break\n                if np.isclose(wa, self.neighbors_normalized_angles[isite][icurrent]['min'],\n                              rtol=0.0, atol=self.normalized_angle_tolerance):\n                    self.neighbors_normalized_angles[isite][icurrent]['min'] = wa\n                    self.neighbors_angles[isite][icurrent]['min'] = results[iang]['angle']\n                    dnb_indices.add(int(iang))\n                else:\n                    self.neighbors_normalized_angles[isite][icurrent]['nb_indices'] = list(nb_indices)\n                    self.neighbors_angles[isite][icurrent]['nb_indices'] = list(nb_indices)\n                    self.neighbors_normalized_angles[isite][icurrent]['dnb_indices'] = list(dnb_indices)\n                    self.neighbors_angles[isite][icurrent]['dnb_indices'] = list(dnb_indices)\n                    dnb_indices = {int(iang)}\n                    self.neighbors_normalized_angles[isite].append({'max': wa,\n                                                                    'min': wa})\n                    self.neighbors_angles[isite].append({'max': results[iang]['angle'],\n                                                         'min': results[iang]['angle']})\n                    icurrent += 1\n                nb_indices.add(int(iang))\n            else:\n                self.neighbors_normalized_angles[isite][icurrent]['nb_indices'] = list(nb_indices)\n                self.neighbors_angles[isite][icurrent]['nb_indices'] = list(nb_indices)\n                self.neighbors_normalized_angles[isite][icurrent]['dnb_indices'] = list(dnb_indices)\n                self.neighbors_angles[isite][icurrent]['dnb_indices'] = list(dnb_indices)\n            for iang in range(len(self.neighbors_angles[isite]) - 1):\n                ang_dict = self.neighbors_angles[isite][iang]\n                ang_dict_next = self.neighbors_angles[isite][iang + 1]\n                ang_dict['next'] = ang_dict_next['max']\n                nang_dict = self.neighbors_normalized_angles[isite][iang]\n                nang_dict_next = self.neighbors_normalized_angles[isite][iang + 1]\n                nang_dict['next'] = nang_dict_next['max']\n            if self.minimum_angle_factor is not None:\n                afact = self.minimum_angle_factor\n            else:\n                afact = 0.0\n            self.neighbors_normalized_angles[isite][-1]['next'] = afact\n            self.neighbors_angles[isite][-1]['next'] = afact * self.neighbors_angles[isite][0]['max']", "response": "Initializes the angle and distance separations for neighbors."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ntransform the voronoi_list into a vlist + bson_nb_voro_list that are BSON - encodable.", "response": "def to_bson_voronoi_list2(self):\n        \"\"\"\n        Transforms the voronoi_list into a vlist + bson_nb_voro_list, that are BSON-encodable.\n        :return: [vlist, bson_nb_voro_list], to be used in the as_dict method\n        \"\"\"\n        bson_nb_voro_list2 = [None] * len(self.voronoi_list2)\n        for ivoro, voro in enumerate(self.voronoi_list2):\n            if voro is None or voro == 'None':\n                continue\n            site_voro = []\n            # {'site': neighbors[nn[1]],\n            #  'angle': sa,\n            #  'distance': distances[nn[1]],\n            #  'index': myindex}\n            for nb_dict in voro:\n                site = nb_dict['site']\n                site_dict = {key: val for key, val in nb_dict.items() if key not in ['site']}\n                #site_voro.append([ps.as_dict(), dd]) [float(c) for c in self.frac_coords]\n                diff = site.frac_coords - self.structure[nb_dict['index']].frac_coords\n                site_voro.append([[nb_dict['index'], [float(c) for c in diff]],\n                                  site_dict])\n            bson_nb_voro_list2[ivoro] = site_voro\n        return bson_nb_voro_list2"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef as_dict(self):\n        bson_nb_voro_list2 = self.to_bson_voronoi_list2()\n        return {\"@module\": self.__class__.__module__,\n                \"@class\": self.__class__.__name__,\n                \"bson_nb_voro_list2\": bson_nb_voro_list2,\n                # \"neighbors_lists\": self.neighbors_lists,\n                \"structure\": self.structure.as_dict(),\n                \"normalized_angle_tolerance\": self.normalized_angle_tolerance,\n                \"normalized_distance_tolerance\": self.normalized_distance_tolerance,\n                \"additional_conditions\": self.additional_conditions,\n                \"valences\": self.valences,\n                \"maximum_distance_factor\": self.maximum_distance_factor,\n                \"minimum_angle_factor\": self.minimum_angle_factor}", "response": "Returns a dictionary representation of the VoronoiContainer."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef from_dict(cls, d):\n        structure = Structure.from_dict(d['structure'])\n        voronoi_list2 = from_bson_voronoi_list2(d['bson_nb_voro_list2'], structure)\n        maximum_distance_factor = d['maximum_distance_factor'] if 'maximum_distance_factor' in d else None\n        minimum_angle_factor = d['minimum_angle_factor'] if 'minimum_angle_factor' in d else None\n        return cls(structure=structure, voronoi_list2=voronoi_list2,\n                   # neighbors_lists=neighbors_lists,\n                   normalized_angle_tolerance=d['normalized_angle_tolerance'],\n                   normalized_distance_tolerance=d['normalized_distance_tolerance'],\n                   additional_conditions=d['additional_conditions'],\n                   valences=d['valences'],\n                   maximum_distance_factor=maximum_distance_factor,\n                   minimum_angle_factor=minimum_angle_factor)", "response": "Reconstructs the VoronoiContainer object from a dictionary representation of the VoronoiContainer object."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsaves the id of the last node created.", "response": "def save_lastnode_id():\n    \"\"\"Save the id of the last node created.\"\"\"\n    init_counter()\n\n    with FileLock(_COUNTER_FILE):\n        with AtomicFile(_COUNTER_FILE, mode=\"w\") as fh:\n            fh.write(\"%d\\n\" % _COUNTER)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef as_status(cls, obj):\n        if obj is None: return None\n        return obj if isinstance(obj, cls) else cls.from_string(obj)", "response": "Convert obj into a Status."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef from_string(cls, s):\n        for num, text in cls._STATUS2STR.items():\n            if text == s:\n                return cls(num)\n        else:\n            raise ValueError(\"Wrong string %s\" % s)", "response": "Return a Status instance from its string representation."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nlisting of output files produces by self.", "response": "def products(self):\n        \"\"\"List of output files produces by self.\"\"\"\n        _products = []\n        for ext in self.exts:\n            prod = Product(ext, self.node.opath_from_ext(ext))\n            _products.append(prod)\n\n        return _products"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef apply_getters(self, task):\n        if not self.getters: return\n\n        for getter in self.getters:\n            if getter == \"@structure\":\n                task.history.info(\"Getting structure from %s\" % self.node)\n                new_structure = self.node.get_final_structure()\n                task._change_structure(new_structure)\n            else:\n                raise ValueError(\"Wrong getter %s\" % getter)", "response": "Applies the getters to the task."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef connecting_vars(self):\n        vars = {}\n        for prod in self.products:\n            vars.update(prod.connecting_vars())\n\n        return vars", "response": "Returns a dictionary with the variables that must be added to the the\n        input file in order to connect this node to its dependencies."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the paths of the output files produced by this object and its extensions", "response": "def get_filepaths_and_exts(self):\n        \"\"\"Returns the paths of the output files produced by self and its extensions\"\"\"\n        filepaths = [prod.filepath for prod in self.products]\n        exts = [prod.ext for prod in self.products]\n\n        return filepaths, exts"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nbuild a : class:`Product instance from a filepath.", "response": "def from_file(cls, filepath):\n        \"\"\"Build a :class:`Product` instance from a filepath.\"\"\"\n        # Find the abinit extension.\n        for i in range(len(filepath)):\n            if filepath[i:] in abi_extensions():\n                ext = filepath[i:]\n                break\n        else:\n            raise ValueError(\"Cannot detect abinit extension in %s\" % filepath)\n\n        return cls(ext, filepath)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef from_node(cls, node):\n        kwargs = dict(\n            node_id=node.node_id,\n            node_finalized=node.finalized,\n            node_history=list(node.history),\n            node_name=node.name,\n            node_class=node.__class__.__name__,\n            node_status=str(node.status),\n        )\n\n        return node.Results(node, **kwargs)", "response": "Initialize an instance of NodeResults from a Node subclass."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef update_collection(self, collection):\n        node = self.node\n        flow = node if node.is_flow else node.flow\n\n        # Build the key used to store the entry in the document.\n        key = node.name\n        if node.is_task:\n            key = \"w\" + str(node.pos[0]) + \"_t\" + str(node.pos[1])\n        elif node.is_work:\n            key = \"w\" + str(node.pos)\n\n        db = collection.database\n\n        # Save files with GridFs first in order to get the ID.\n        if self.gridfs_files:\n            import gridfs\n            fs = gridfs.GridFS(db)\n            for ext, gridfile in self.gridfs_files.items():\n                logger.info(\"gridfs: about to put file:\", str(gridfile))\n                # Here we set gridfile.fs_id that will be stored in the mondodb document\n                try:\n                    with open(gridfile.path, \"r\" + gridfile.mode) as f:\n                        gridfile.fs_id = fs.put(f, filename=gridfile.path)\n                except IOError as exc:\n                    logger.critical(str(exc))\n\n        if flow.mongo_id is None:\n            # Flow does not have a mongo_id, allocate doc for the flow and save its id.\n            flow.mongo_id = collection.insert({})\n            print(\"Creating flow.mongo_id\", flow.mongo_id, type(flow.mongo_id))\n\n        # Get the document from flow.mongo_id and update it.\n        doc = collection.find_one({\"_id\": flow.mongo_id})\n        if key in doc:\n            raise ValueError(\"%s is already in doc!\" % key)\n        doc[key] = self.as_dict()\n\n        collection.save(doc)", "response": "Update a mongodb collection with the current entry."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef color_hex(self):\n        def clamp(x):\n            return max(0, min(int(x), 255))\n\n        r, g, b = np.trunc(self.color_rgb * 255)\n        return \"#{0:02x}{1:02x}{2:02x}\".format(clamp(r), clamp(g), clamp(b))", "response": "Node color as Hex Triplet https://en. wikidata. org."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef isinstance(self, class_or_string):\n        if class_or_string is None:\n            return False\n        import inspect\n        if inspect.isclass(class_or_string):\n            return isinstance(self, class_or_string)\n        else:\n            return self.__class__.__name__.lower() == class_or_string.lower()", "response": "Check whether the node is an instance of class_or_string."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef as_node(cls, obj):\n        if isinstance(obj, cls):\n            return obj\n        elif is_string(obj):\n            # Assume filepath.\n            return FileNode(obj)\n        elif obj is None:\n            return obj\n        else:\n            raise TypeError(\"Don't know how to convert %s to Node instance.\" % obj)", "response": "Convert obj into a Node instance."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the name of the node.", "response": "def name(self):\n        \"\"\"\n        The name of the node\n        (only used for facilitating its identification in the user interface).\n        \"\"\"\n        try:\n            return self._name\n        except AttributeError:\n            if self.is_task:\n                try:\n                    return self.pos_str\n                except:\n                    return os.path.basename(self.workdir)\n            else:\n                return os.path.basename(self.workdir)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a relative version of the workdir", "response": "def relworkdir(self):\n        \"\"\"Return a relative version of the workdir\"\"\"\n        if getattr(self, \"workdir\", None) is None:\n            return None\n        try:\n            return os.path.relpath(self.workdir)\n        except OSError:\n            # current working directory may not be defined!\n            return self.workdir"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef log_correction(self, event, action):\n        # TODO: Create CorrectionObject\n        action = str(action)\n        self.history.info(action)\n\n        self._corrections.append(dict(\n            event=event.as_dict(),\n            action=action,\n        ))", "response": "This method is called when we have fixed the problem associated with this event. It adds a new entry to the correction history."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nadds a list of dependencies to the node.", "response": "def add_deps(self, deps):\n        \"\"\"\n        Add a list of dependencies to the :class:`Node`.\n\n        Args:\n            deps: List of :class:`Dependency` objects specifying the dependencies of the node.\n                  or dictionary mapping nodes to file extensions e.g. {task: \"DEN\"}\n        \"\"\"\n        if isinstance(deps, collections.Mapping):\n            # Convert dictionary into list of dependencies.\n            deps = [Dependency(node, exts) for node, exts in deps.items()]\n\n        # We want a list\n        if not isinstance(deps, (list, tuple)):\n            deps = [deps]\n\n        assert all(isinstance(d, Dependency) for d in deps)\n\n        # Add the dependencies to the node\n        self._deps.extend(deps)\n\n        if self.is_work:\n            # The task in the work should inherit the same dependency.\n            for task in self:\n                task.add_deps(deps)\n\n        # If we have a FileNode as dependency, add self to its children\n        # Node.get_parents will use this list if node.is_isfile.\n        for dep in (d for d in deps if d.node.is_file):\n            dep.node.add_filechild(self)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nremoves a list of dependencies from the Node.", "response": "def remove_deps(self, deps):\n        \"\"\"\n        Remove a list of dependencies from the :class:`Node`.\n\n        Args:\n            deps: List of :class:`Dependency` objects specifying the  dependencies of the node.\n        \"\"\"\n        if not isinstance(deps, (list, tuple)):\n            deps = [deps]\n\n        assert all(isinstance(d, Dependency) for d in deps)\n\n        self._deps = [d for d in self._deps if d not in deps]\n\n        if self.is_work:\n            # remove the same list of dependencies from the task in the work\n            for task in self:\n                task.remove_deps(deps)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a list with the status of the dependencies.", "response": "def deps_status(self):\n        \"\"\"Returns a list with the status of the dependencies.\"\"\"\n        if not self.deps:\n            return [self.S_OK]\n\n        return [d.status for d in self.deps]"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the list of nodes that depend on this node.", "response": "def get_children(self):\n        \"\"\"\n        Return the list of nodes in the :class:`Flow` that depends on this :class:`Node`\n\n        .. note::\n\n            This routine assumes the entire flow has been allocated.\n        \"\"\"\n        # Specialized branch for FileNode.\n        if self.is_file:\n            return self.filechildren\n\n        # Inspect the entire flow to get children.\n        children = []\n        for work in self.flow:\n            if work.depends_on(self): children.append(work)\n            for task in work:\n                if task.depends_on(self): children.append(task)\n        return children"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef str_deps(self):\n        lines = []\n        app = lines.append\n\n        app(\"Dependencies of node %s:\" % str(self))\n        for i, dep in enumerate(self.deps):\n            app(\"%d) %s, status=%s\" % (i, dep.info, str(dep.status)))\n\n        return \"\\n\".join(lines)", "response": "Return the string representation of the dependencies of the node."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns pandas DataFrame with the value of the variables specified in varnames.", "response": "def get_vars_dataframe(self, *varnames):\n        \"\"\"\n        Return pandas DataFrame with the value of the variables specified in `varnames`.\n        Can be used for task/works/flow. It's recursive!\n\n        .. example:\n\n            flow.get_vars_dataframe(\"ecut\", \"ngkpt\")\n            work.get_vars_dataframe(\"acell\", \"usepawu\")\n        \"\"\"\n        import pandas as pd\n        if self.is_task:\n            df = pd.DataFrame([{v: self.input.get(v, None) for v in varnames}], index=[self.name], columns=varnames)\n            df[\"class\"] = self.__class__.__name__\n            return df\n\n        elif self.is_work:\n            frames = [task.get_vars_dataframe(*varnames) for task in self]\n            return pd.concat(frames)\n\n        elif self.is_flow:\n            frames = [work.get_vars_dataframe(*varnames) for work in self]\n            return pd.concat(frames)\n\n        else:\n            #print(\"Ignoring node of type: `%s`\" % type(self))\n            return pd.DataFrame(index=[self.name])"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_graphviz_dirtree(self, engine=\"automatic\", **kwargs):\n        if engine == \"automatic\":\n            engine = \"fdp\"\n\n        return Dirviz(self.workdir).get_cluster_graph(engine=engine, **kwargs)", "response": "Generate a directory tree of files and directories in the node workdir."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef event_handlers(self):\n        if self.is_flow:\n            return self._event_handlers\n\n        try:\n            return self._event_handlers\n        except AttributeError:\n            return self.flow._event_handlers", "response": "Returns a list of handlers registered for this node."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ninstall the EventHandlers for this Node.", "response": "def install_event_handlers(self, categories=None, handlers=None):\n        \"\"\"\n        Install the `EventHandlers for this `Node`. If no argument is provided\n        the default list of handlers is installed.\n\n        Args:\n            categories: List of categories to install e.g. base + can_change_physics\n            handlers: explicit list of :class:`EventHandler` instances.\n                      This is the most flexible way to install handlers.\n\n        .. note::\n\n            categories and handlers are mutually exclusive.\n        \"\"\"\n        if categories is not None and handlers is not None:\n            raise ValueError(\"categories and handlers are mutually exclusive!\")\n\n        from .events import get_event_handler_classes\n        if categories:\n            raise NotImplementedError()\n            handlers = [cls() for cls in get_event_handler_classes(categories=categories)]\n        else:\n            handlers = handlers or [cls() for cls in get_event_handler_classes()]\n\n        self._event_handlers = handlers"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nprints to stream the event handlers installed for this flow.", "response": "def show_event_handlers(self, stream=sys.stdout, verbose=0):\n        \"\"\"Print to `stream` the event handlers installed for this flow.\"\"\"\n        lines = [\"List of event handlers installed:\"]\n        for handler in self.event_handlers:\n            if verbose:\n                lines.extend(handler.__class__.cls2str().split(\"\\n\"))\n            else:\n                lines.extend(str(handler).split(\"\\n\"))\n\n        stream.write(\"\\n\".join(lines))\n        stream.write(\"\\n\")"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsends a signal to all connected receivers unless the node is in spectator mode.", "response": "def send_signal(self, signal):\n        \"\"\"\n        Send signal from this node to all connected receivers unless the node is in spectator mode.\n\n        signal -- (hashable) signal value, see `dispatcher` connect for details\n\n        Return a list of tuple pairs [(receiver, response), ... ]\n        or None if the node is in spectator mode.\n\n        if any receiver raises an error, the error propagates back\n        through send, terminating the dispatch loop, so it is quite\n        possible to not have all receivers called if a raises an error.\n        \"\"\"\n        if self.in_spectator_mode: return None\n        logger.debug(\"Node %s broadcasts signal %s\" % (self, signal))\n        dispatcher.send(signal=signal, sender=self)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the message after merging any user - supplied arguments with the message.", "response": "def get_message(self, metadata=False, asctime=True):\n        \"\"\"\n        Return the message after merging any user-supplied arguments with the message.\n\n        Args:\n            metadata: True if function and module name should be added.\n            asctime: True if time string should be added.\n        \"\"\"\n        msg = self.msg if is_string(self.msg) else str(self.msg)\n        if self.args:\n            try:\n                msg = msg % self.args\n            except:\n                msg += str(self.args)\n\n        if asctime: msg = \"[\" + self.asctime + \"] \" + msg\n\n        # Add metadata\n        if metadata:\n            msg += \"\\nCalled by %s at %s:%s\\n\" % (self.func_name, self.pathname, self.lineno)\n\n        return msg"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef to_string(self, metadata=False):\n        return \"\\n\".join(rec.get_message(metadata=metadata) for rec in self)", "response": "Returns a string with the history."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nlog msg % args with the warning severity level", "response": "def warning(self, msg, *args, **kwargs):\n        \"\"\"Log 'msg % args' with the warning severity level\"\"\"\n        self._log(\"WARNING\", msg, args, kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef critical(self, msg, *args, **kwargs):\n        self._log(\"CRITICAL\", msg, args, kwargs)", "response": "Log msg % args with the critical severity level"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nlow - level logging routine which creates a HistoryRecord.", "response": "def _log(self, level, msg, args, exc_info=None, extra=None):\n        \"\"\"Low-level logging routine which creates a :class:`HistoryRecord`.\"\"\"\n        if exc_info and not isinstance(exc_info, tuple):\n            exc_info = sys.exc_info()\n\n        self.append(HistoryRecord(level, \"unknown filename\", 0, msg, args, exc_info, func=\"unknown func\"))"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nparses libxc_docs. txt file and return dictionary with mapping libxc_id --> info_dict", "response": "def parse_libxc_docs(path):\n    \"\"\"\n    Parse libxc_docs.txt file, return dictionary with mapping:\n    libxc_id --> info_dict\n    \"\"\"\n    def parse_section(section):\n\td = {}\n\tfor l in section:\n\t    key, value = l.split(\":\")\n\t    key = key.strip()\n\t    d[key] = value.strip()\n\n\treturn int(d[\"Number\"]), d\n\n    d = OrderedDict()\n    with open(path, \"rt\") as fh:\n\tsection = []\n\tfor line in fh:\n\t    if not line.startswith(\"-\"):\n\t\tsection.append(line)\n\t    else:\n\t\tnum, entry = parse_section(section)\n\t\tassert num not in d\n\t\td[num] = entry\n\t\tsection = []\n\tassert not section\n\n    return d"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nwrite json file with libxc metadata to path jpath.", "response": "def write_libxc_docs_json(xcfuncs, jpath):\n    \"\"\"Write json file with libxc metadata to path jpath.\"\"\"\n    from copy import deepcopy\n    xcfuncs = deepcopy(xcfuncs)\n\n    # Remove XC_FAMILY from Family and XC_ from Kind to make strings more human-readable.\n    for d in xcfuncs.values():\n        d[\"Family\"] = d[\"Family\"].replace(\"XC_FAMILY_\", \"\", 1)\n        d[\"Kind\"] = d[\"Kind\"].replace(\"XC_\", \"\", 1)\n\n    # Build lightweight version with a subset of keys.\n    for num, d in xcfuncs.items():\n        xcfuncs[num] = {k: d[k] for k in (\"Family\", \"Kind\", \"References\")}\n        # Descriptions are optional\n        for opt in (\"Description 1\", \"Description 2\"):\n            desc = d.get(opt)\n            if desc is not None: xcfuncs[num][opt] = desc\n\n    with open(jpath, \"wt\") as fh:\n        json.dump(xcfuncs, fh)\n\n    return xcfuncs"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef make_movie(structures, output_filename=\"movie.mp4\", zoom=1.0, fps=20,\n               bitrate=\"10000k\", quality=1, **kwargs):\n    \"\"\"\n    Generate a movie from a sequence of structures using vtk and ffmpeg.\n\n    Args:\n        structures ([Structure]): sequence of structures\n        output_filename (str): filename for structure output. defaults to\n            movie.mp4\n        zoom (float): A zoom to be applied to the visualizer. Defaults to 1.0.\n        fps (int): Frames per second for the movie. Defaults to 20.\n        bitrate (str): Video bitate.  Defaults to \"10000k\" (fairly high\n            quality).\n        quality (int): A quality scale. Defaults to 1.\n        \\\\*\\\\*kwargs: Any kwargs supported by StructureVis to modify the images\n            generated.\n    \"\"\"\n    vis = StructureVis(**kwargs)\n    vis.show_help = False\n    vis.redraw()\n    vis.zoom(zoom)\n    sigfig = int(math.floor(math.log10(len(structures))) + 1)\n    filename = \"image{0:0\" + str(sigfig) + \"d}.png\"\n    for i, s in enumerate(structures):\n        vis.set_structure(s)\n        vis.write_image(filename.format(i), 3)\n    filename = \"image%0\" + str(sigfig) + \"d.png\"\n    args = [\"ffmpeg\", \"-y\", \"-i\", filename,\n            \"-q:v\", str(quality), \"-r\", str(fps), \"-b:v\", str(bitrate),\n            output_filename]\n    subprocess.Popen(args)", "response": "Generate a movie from a sequence of structures using vtk and ffmpeg."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nrotate the camera view.", "response": "def rotate_view(self, axis_ind=0, angle=0):\n        \"\"\"\n        Rotate the camera view.\n\n        Args:\n            axis_ind: Index of axis to rotate. Defaults to 0, i.e., a-axis.\n            angle: Angle to rotate by. Defaults to 0.\n        \"\"\"\n        camera = self.ren.GetActiveCamera()\n        if axis_ind == 0:\n            camera.Roll(angle)\n        elif axis_ind == 1:\n            camera.Azimuth(angle)\n        else:\n            camera.Pitch(angle)\n        self.ren_win.Render()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef write_image(self, filename=\"image.png\", magnification=1,\n                    image_format=\"png\"):\n        \"\"\"\n        Save render window to an image.\n\n        Arguments:\n            filename:\n                filename to save to. Defaults to image.png.\n            magnification:\n                magnification. Use it to render high res images.\n            image_format:\n                choose between jpeg, png.  Png is the default.\n        \"\"\"\n        render_large = vtk.vtkRenderLargeImage()\n        render_large.SetInput(self.ren)\n        if image_format == \"jpeg\":\n            writer = vtk.vtkJPEGWriter()\n            writer.SetQuality(80)\n        else:\n            writer = vtk.vtkPNGWriter()\n\n        render_large.SetMagnification(magnification)\n        writer.SetFileName(filename)\n\n        writer.SetInputConnection(render_large.GetOutputPort())\n        self.ren_win.Render()\n        writer.Write()\n        del render_large", "response": "Save render window to an image."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef redraw(self, reset_camera=False):\n        self.ren.RemoveAllViewProps()\n        self.picker = None\n        self.add_picker_fixed()\n        self.helptxt_mapper = vtk.vtkTextMapper()\n        tprops = self.helptxt_mapper.GetTextProperty()\n        tprops.SetFontSize(14)\n        tprops.SetFontFamilyToTimes()\n        tprops.SetColor(0, 0, 0)\n\n        if self.structure is not None:\n            self.set_structure(self.structure, reset_camera)\n\n        self.ren_win.Render()", "response": "Redraw the render window."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef display_help(self):\n        helptxt = [\"h : Toggle help\",\n                   \"A/a, B/b or C/c : Increase/decrease cell by one a,\"\n                   \" b or c unit vector\", \"# : Toggle showing of polyhedrons\",\n                   \"-: Toggle showing of bonds\", \"r : Reset camera direction\",\n                   \"[/]: Decrease or increase poly_radii_tol_factor \"\n                   \"by 0.05. Value = \" + str(self.poly_radii_tol_factor),\n                   \"Up/Down: Rotate view along Up direction by 90 \"\n                   \"clockwise/anticlockwise\",\n                   \"Left/right: Rotate view along camera direction by \"\n                   \"90 clockwise/anticlockwise\", \"s: Save view to image.png\",\n                   \"o: Orthogonalize structure\"]\n        self.helptxt_mapper.SetInput(\"\\n\".join(helptxt))\n        self.helptxt_actor.SetPosition(10, 10)\n        self.helptxt_actor.VisibilityOn()", "response": "Display the help for various keyboard shortcuts."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_structure(self, structure, reset_camera=True, to_unit_cell=True):\n        self.ren.RemoveAllViewProps()\n\n        has_lattice = hasattr(structure, \"lattice\")\n\n        if has_lattice:\n            s = Structure.from_sites(structure, to_unit_cell=to_unit_cell)\n            s.make_supercell(self.supercell, to_unit_cell=to_unit_cell)\n        else:\n            s = structure\n\n        inc_coords = []\n        for site in s:\n            self.add_site(site)\n            inc_coords.append(site.coords)\n\n        count = 0\n        labels = [\"a\", \"b\", \"c\"]\n        colors = [(1, 0, 0), (0, 1, 0), (0, 0, 1)]\n\n        if has_lattice:\n            matrix = s.lattice.matrix\n\n        if self.show_unit_cell and has_lattice:\n            #matrix = s.lattice.matrix\n            self.add_text([0, 0, 0], \"o\")\n            for vec in matrix:\n                self.add_line((0, 0, 0), vec, colors[count])\n                self.add_text(vec, labels[count], colors[count])\n                count += 1\n            for (vec1, vec2) in itertools.permutations(matrix, 2):\n                self.add_line(vec1, vec1 + vec2)\n            for (vec1, vec2, vec3) in itertools.permutations(matrix, 3):\n                self.add_line(vec1 + vec2, vec1 + vec2 + vec3)\n\n        if self.show_bonds or self.show_polyhedron:\n            elements = sorted(s.composition.elements, key=lambda a: a.X)\n            anion = elements[-1]\n\n            def contains_anion(site):\n                for sp in site.species.keys():\n                    if sp.symbol == anion.symbol:\n                        return True\n                return False\n\n            anion_radius = anion.average_ionic_radius\n            for site in s:\n                exclude = False\n                max_radius = 0\n                color = np.array([0, 0, 0])\n                for sp, occu in site.species.items():\n                    if sp.symbol in self.excluded_bonding_elements \\\n                            or sp == anion:\n                        exclude = True\n                        break\n                    max_radius = max(max_radius, sp.average_ionic_radius)\n                    color = color + \\\n                            occu * np.array(self.el_color_mapping.get(sp.symbol,\n                                                                      [0, 0, 0]))\n\n                if not exclude:\n                    max_radius = (1 + self.poly_radii_tol_factor) * \\\n                                 (max_radius + anion_radius)\n                    nn = structure.get_neighbors(site, float(max_radius))\n                    nn_sites = []\n                    for nnsite, dist in nn:\n                        if contains_anion(nnsite):\n                            nn_sites.append(nnsite)\n                            if not in_coord_list(inc_coords, nnsite.coords):\n                                self.add_site(nnsite)\n                    if self.show_bonds:\n                        self.add_bonds(nn_sites, site)\n                    if self.show_polyhedron:\n                        color = [i / 255 for i in color]\n                        self.add_polyhedron(nn_sites, site, color)\n\n        if self.show_help:\n            self.helptxt_actor = vtk.vtkActor2D()\n            self.helptxt_actor.VisibilityOn()\n            self.helptxt_actor.SetMapper(self.helptxt_mapper)\n            self.ren.AddActor(self.helptxt_actor)\n            self.display_help()\n\n        camera = self.ren.GetActiveCamera()\n        if reset_camera:\n            if has_lattice:\n                #Adjust the camera for best viewing\n                lengths = s.lattice.abc\n                pos = (matrix[1] + matrix[2]) * 0.5 + \\\n                      matrix[0] * max(lengths) / lengths[0] * 3.5\n                camera.SetPosition(pos)\n                camera.SetViewUp(matrix[2])\n                camera.SetFocalPoint((matrix[0] + matrix[1] + matrix[2]) * 0.5)\n            else:\n                origin = s.center_of_mass\n                max_site = max(\n                    s, key=lambda site: site.distance_from_point(origin))\n                camera.SetPosition(origin + 5 * (max_site.coords - origin))\n                camera.SetFocalPoint(s.center_of_mass)\n\n        self.structure = structure\n        self.title = s.composition.formula", "response": "Add a structure to the visualizer."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef zoom(self, factor):\n        camera = self.ren.GetActiveCamera()\n        camera.Zoom(factor)\n        self.ren_win.Render()", "response": "Zoom the camera view by a factor."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add_site(self, site):\n        start_angle = 0\n        radius = 0\n        total_occu = 0\n\n        for specie, occu in site.species.items():\n            radius += occu * (specie.ionic_radius\n                              if isinstance(specie, Specie)\n                                 and specie.ionic_radius\n                              else specie.average_ionic_radius)\n            total_occu += occu\n\n        vis_radius = 0.2 + 0.002 * radius\n\n        for specie, occu in site.species.items():\n            if not specie:\n                color = (1, 1, 1)\n            elif specie.symbol in self.el_color_mapping:\n                color = [i / 255 for i in self.el_color_mapping[specie.symbol]]\n            mapper = self.add_partial_sphere(site.coords, vis_radius, color,\n                                             start_angle, start_angle + 360 * occu)\n            self.mapper_map[mapper] = [site]\n            start_angle += 360 * occu\n\n        if total_occu < 1:\n            mapper = self.add_partial_sphere(site.coords, vis_radius, (1,1,1),\n                                             start_angle, start_angle + 360 * (1 - total_occu))\n            self.mapper_map[mapper] = [site]", "response": "Adds a site to the render window."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_text(self, coords, text, color=(0, 0, 0)):\n        source = vtk.vtkVectorText()\n        source.SetText(text)\n        mapper = vtk.vtkPolyDataMapper()\n        mapper.SetInputConnection(source.GetOutputPort())\n        follower = vtk.vtkFollower()\n        follower.SetMapper(mapper)\n        follower.GetProperty().SetColor(color)\n        follower.SetPosition(coords)\n        follower.SetScale(0.5)\n        self.ren.AddActor(follower)\n        follower.SetCamera(self.ren.GetActiveCamera())", "response": "Add text at a coordinate."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding a line to the current set of active classes.", "response": "def add_line(self, start, end, color=(0.5, 0.5, 0.5), width=1):\n        \"\"\"\n        Adds a line.\n\n        Args:\n            start: Starting coordinates for line.\n            end: Ending coordinates for line.\n            color: Color for text as RGB. Defaults to grey.\n            width: Width of line. Defaults to 1.\n        \"\"\"\n        source = vtk.vtkLineSource()\n        source.SetPoint1(start)\n        source.SetPoint2(end)\n\n        vertexIDs = vtk.vtkStringArray()\n        vertexIDs.SetNumberOfComponents(1)\n        vertexIDs.SetName(\"VertexIDs\")\n        # Set the vertex labels\n        vertexIDs.InsertNextValue(\"a\")\n        vertexIDs.InsertNextValue(\"b\")\n        source.GetOutput().GetPointData().AddArray(vertexIDs)\n\n        mapper = vtk.vtkPolyDataMapper()\n        mapper.SetInputConnection(source.GetOutputPort())\n        actor = vtk.vtkActor()\n        actor.SetMapper(mapper)\n        actor.GetProperty().SetColor(color)\n        actor.GetProperty().SetLineWidth(width)\n        self.ren.AddActor(actor)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_polyhedron(self, neighbors, center, color, opacity=1.0,\n                       draw_edges=False, edges_color=[0.0, 0.0, 0.0],\n                       edges_linewidth=2):\n        \"\"\"\n        Adds a polyhedron.\n\n        Args:\n            neighbors: Neighbors of the polyhedron (the vertices).\n            center: The atom in the center of the polyhedron.\n            color: Color for text as RGB.\n            opacity: Opacity of the polyhedron\n            draw_edges: If set to True, the a line will be drawn at each edge\n            edges_color: Color of the line for the edges\n            edges_linewidth: Width of the line drawn for the edges\n        \"\"\"\n        points = vtk.vtkPoints()\n        conv = vtk.vtkConvexPointSet()\n        for i in range(len(neighbors)):\n            x, y, z = neighbors[i].coords\n            points.InsertPoint(i, x, y, z)\n            conv.GetPointIds().InsertId(i, i)\n        grid = vtk.vtkUnstructuredGrid()\n        grid.Allocate(1, 1)\n        grid.InsertNextCell(conv.GetCellType(), conv.GetPointIds())\n        grid.SetPoints(points)\n\n        dsm = vtk.vtkDataSetMapper()\n        polysites = [center]\n        polysites.extend(neighbors)\n        self.mapper_map[dsm] = polysites\n        if vtk.VTK_MAJOR_VERSION <= 5:\n            dsm.SetInputConnection(grid.GetProducerPort())\n        else:\n            dsm.SetInputData(grid)\n        ac = vtk.vtkActor()\n        #ac.SetMapper(mapHull)\n        ac.SetMapper(dsm)\n        ac.GetProperty().SetOpacity(opacity)\n        if color == 'element':\n            # If partial occupations are involved, the color of the specie with\n            # the highest occupation is used\n            myoccu = 0.0\n            for specie, occu in center.species.items():\n                if occu > myoccu:\n                    myspecie = specie\n                    myoccu = occu\n            color = [i / 255 for i in self.el_color_mapping[myspecie.symbol]]\n            ac.GetProperty().SetColor(color)\n        else:\n            ac.GetProperty().SetColor(color)\n        if draw_edges:\n            ac.GetProperty().SetEdgeColor(edges_color)\n            ac.GetProperty().SetLineWidth(edges_linewidth)\n            ac.GetProperty().EdgeVisibilityOn()\n        self.ren.AddActor(ac)", "response": "Adds a polyhedron to the vtkActor."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add_triangle(self, neighbors, color, center=None, opacity=0.4,\n                     draw_edges=False, edges_color=[0.0, 0.0, 0.0],\n                     edges_linewidth=2):\n        \"\"\"\n        Adds a triangular surface between three atoms.\n\n        Args:\n            atoms: Atoms between which a triangle will be drawn.\n            color: Color for triangle as RGB.\n            center: The \"central atom\" of the triangle\n            opacity: opacity of the triangle\n            draw_edges: If set to True, the a line will be  drawn at each edge\n            edges_color: Color of the line for the edges\n            edges_linewidth: Width of the line drawn for the edges\n        \"\"\"\n        points = vtk.vtkPoints()\n        triangle = vtk.vtkTriangle()\n        for ii in range(3):\n            points.InsertNextPoint(neighbors[ii].x, neighbors[ii].y,\n                                   neighbors[ii].z)\n            triangle.GetPointIds().SetId(ii, ii)\n        triangles = vtk.vtkCellArray()\n        triangles.InsertNextCell(triangle)\n\n        # polydata object\n        trianglePolyData = vtk.vtkPolyData()\n        trianglePolyData.SetPoints( points )\n        trianglePolyData.SetPolys( triangles )\n\n        # mapper\n        mapper = vtk.vtkPolyDataMapper()\n        mapper.SetInput(trianglePolyData)\n\n        ac = vtk.vtkActor()\n        ac.SetMapper(mapper)\n        ac.GetProperty().SetOpacity(opacity)\n        if color == 'element':\n            if center is None:\n                raise ValueError(\n                    'Color should be chosen according to the central atom, '\n                    'and central atom is not provided')\n            # If partial occupations are involved, the color of the specie with\n            # the highest occupation is used\n            myoccu = 0.0\n            for specie, occu in center.species.items():\n                if occu > myoccu:\n                    myspecie = specie\n                    myoccu = occu\n            color = [i / 255 for i in self.el_color_mapping[myspecie.symbol]]\n            ac.GetProperty().SetColor(color)\n        else:\n            ac.GetProperty().SetColor(color)\n        if draw_edges:\n            ac.GetProperty().SetEdgeColor(edges_color)\n            ac.GetProperty().SetLineWidth(edges_linewidth)\n            ac.GetProperty().EdgeVisibilityOn()\n        self.ren.AddActor(ac)", "response": "Adds a triangle to the current state of the object."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding bonds to the current site.", "response": "def add_bonds(self, neighbors, center, color=None, opacity=None,\n                  radius=0.1):\n        \"\"\"\n        Adds bonds for a site.\n\n        Args:\n            neighbors: Neighbors of the site.\n            center: The site in the center for all bonds.\n            color: Color of the tubes representing the bonds\n            opacity: Opacity of the tubes representing the bonds\n            radius: Radius of tube s representing the bonds\n        \"\"\"\n        points = vtk.vtkPoints()\n        points.InsertPoint(0, center.x, center.y, center.z)\n        n = len(neighbors)\n        lines = vtk.vtkCellArray()\n        for i in range(n):\n            points.InsertPoint(i + 1, neighbors[i].coords)\n            lines.InsertNextCell(2)\n            lines.InsertCellPoint(0)\n            lines.InsertCellPoint(i + 1)\n        pd = vtk.vtkPolyData()\n        pd.SetPoints(points)\n        pd.SetLines(lines)\n\n        tube = vtk.vtkTubeFilter()\n        if vtk.VTK_MAJOR_VERSION <= 5:\n            tube.SetInputConnection(pd.GetProducerPort())\n        else:\n            tube.SetInputData(pd)\n        tube.SetRadius(radius)\n\n        mapper = vtk.vtkPolyDataMapper()\n        mapper.SetInputConnection(tube.GetOutputPort())\n\n        actor = vtk.vtkActor()\n        actor.SetMapper(mapper)\n        if opacity is not None:\n            actor.GetProperty().SetOpacity(opacity)\n        if color is not None:\n            actor.GetProperty().SetColor(color)\n        self.ren.AddActor(actor)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_rot(slab):\n    new_z = get_mi_vec(slab)\n    a, b, c = slab.lattice.matrix\n    new_x = a / np.linalg.norm(a)\n    new_y = np.cross(new_z, new_x)\n    x, y, z = np.eye(3)\n    rot_matrix = np.array([np.dot(*el) for el in\n                           itertools.product([x, y, z],\n                                             [new_x, new_y, new_z])]).reshape(3, 3)\n    rot_matrix = np.transpose(rot_matrix)\n    sop = SymmOp.from_rotation_and_translation(rot_matrix)\n    return sop", "response": "Gets the transformation to rotate the z axis into the miller index\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconverts a cartesian coordinate such that it is inside the unit cell.", "response": "def put_coord_inside(lattice, cart_coordinate):\n    \"\"\"\n    converts a cartesian coordinate such that it is inside the unit cell.\n    \"\"\"\n    fc = lattice.get_fractional_coords(cart_coordinate)\n    return lattice.get_cartesian_coords([c - np.floor(c) for c in fc])"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef plot_slab(slab, ax, scale=0.8, repeat=5, window=1.5,\n              draw_unit_cell=True, decay=0.2, adsorption_sites=True):\n    \"\"\"\n    Function that helps visualize the slab in a 2-D plot, for\n    convenient viewing of output of AdsorbateSiteFinder.\n\n    Args:\n        slab (slab): Slab object to be visualized\n        ax (axes): matplotlib axes with which to visualize\n        scale (float): radius scaling for sites\n        repeat (int): number of repeating unit cells to visualize\n        window (float): window for setting the axes limits, is essentially\n            a fraction of the unit cell limits\n        draw_unit_cell (bool): flag indicating whether or not to draw cell\n        decay (float): how the alpha-value decays along the z-axis\n    \"\"\"\n    orig_slab = slab.copy()\n    slab = reorient_z(slab)\n    orig_cell = slab.lattice.matrix.copy()\n    if repeat:\n        slab.make_supercell([repeat, repeat, 1])\n    coords = np.array(sorted(slab.cart_coords, key=lambda x: x[2]))\n    sites = sorted(slab.sites, key=lambda x: x.coords[2])\n    alphas = 1 - decay * (np.max(coords[:, 2]) - coords[:, 2])\n    alphas = alphas.clip(min=0)\n    corner = [0, 0, slab.lattice.get_fractional_coords(coords[-1])[-1]]\n    corner = slab.lattice.get_cartesian_coords(corner)[:2]\n    verts = orig_cell[:2, :2]\n    lattsum = verts[0] + verts[1]\n    # Draw circles at sites and stack them accordingly\n    for n, coord in enumerate(coords):\n        r = sites[n].specie.atomic_radius * scale\n        ax.add_patch(patches.Circle(coord[:2] - lattsum * (repeat // 2),\n                                    r, color='w', zorder=2 * n))\n        color = color_dict[sites[n].species_string]\n        ax.add_patch(patches.Circle(coord[:2] - lattsum * (repeat // 2), r,\n                                    facecolor=color, alpha=alphas[n],\n                                    edgecolor='k', lw=0.3, zorder=2 * n + 1))\n    # Adsorption sites\n    if adsorption_sites:\n        asf = AdsorbateSiteFinder(orig_slab)\n        ads_sites = asf.find_adsorption_sites()['all']\n        sop = get_rot(orig_slab)\n        ads_sites = [sop.operate(ads_site)[:2].tolist()\n                     for ads_site in ads_sites]\n        ax.plot(*zip(*ads_sites), color='k', marker='x',\n                markersize=10, mew=1, linestyle='', zorder=10000)\n    # Draw unit cell\n    if draw_unit_cell:\n        verts = np.insert(verts, 1, lattsum, axis=0).tolist()\n        verts += [[0., 0.]]\n        verts = [[0., 0.]] + verts\n        codes = [Path.MOVETO, Path.LINETO, Path.LINETO,\n                 Path.LINETO, Path.CLOSEPOLY]\n        verts = [(np.array(vert) + corner).tolist() for vert in verts]\n        path = Path(verts, codes)\n        patch = patches.PathPatch(path, facecolor='none', lw=2,\n                                  alpha=0.5, zorder=2 * n + 2)\n        ax.add_patch(patch)\n    ax.set_aspect(\"equal\")\n    center = corner + lattsum / 2.\n    extent = np.max(lattsum)\n    lim_array = [center - extent * window, center + extent * window]\n    x_lim = [ele[0] for ele in lim_array]\n    y_lim = [ele[1] for ele in lim_array]\n    ax.set_xlim(x_lim)\n    ax.set_ylim(y_lim)\n    return ax", "response": "Function that helps visualize the slab in a 2 - D plot"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef from_bulk_and_miller(cls, structure, miller_index, min_slab_size=8.0,\n                             min_vacuum_size=10.0, max_normal_search=None,\n                             center_slab=True, selective_dynamics=False,\n                             undercoord_threshold=0.09):\n        \"\"\"\n        This method constructs the adsorbate site finder from a bulk\n        structure and a miller index, which allows the surface sites\n        to be determined from the difference in bulk and slab coordination,\n        as opposed to the height threshold.\n\n        Args:\n            structure (Structure): structure from which slab\n                input to the ASF is constructed\n            miller_index (3-tuple or list): miller index to be used\n            min_slab_size (float): min slab size for slab generation\n            min_vacuum_size (float): min vacuum size for slab generation\n            max_normal_search (int): max normal search for slab generation\n            center_slab (bool): whether to center slab in slab generation\n            selective dynamics (bool): whether to assign surface sites\n                to selective dynamics\n            undercoord_threshold (float): threshold of \"undercoordation\"\n                to use for the assignment of surface sites.  Default is\n                0.1, for which surface sites will be designated if they\n                are 10% less coordinated than their bulk counterpart\n        \"\"\"\n        # TODO: for some reason this works poorly with primitive cells\n        #       may want to switch the coordination algorithm eventually\n        vnn_bulk = VoronoiNN(tol=0.05)\n        bulk_coords = [len(vnn_bulk.get_nn(structure, n))\n                       for n in range(len(structure))]\n        struct = structure.copy(site_properties={'bulk_coordinations': bulk_coords})\n        slabs = generate_all_slabs(struct, max_index=max(miller_index),\n                                   min_slab_size=min_slab_size,\n                                   min_vacuum_size=min_vacuum_size,\n                                   max_normal_search=max_normal_search,\n                                   center_slab=center_slab)\n\n        slab_dict = {slab.miller_index: slab for slab in slabs}\n\n        if miller_index not in slab_dict:\n            raise ValueError(\"Miller index not in slab dict\")\n\n        this_slab = slab_dict[miller_index]\n\n        vnn_surface = VoronoiNN(tol=0.05, allow_pathological=True)\n\n        surf_props, undercoords = [], []\n        this_mi_vec = get_mi_vec(this_slab)\n        mi_mags = [np.dot(this_mi_vec, site.coords) for site in this_slab]\n        average_mi_mag = np.average(mi_mags)\n        for n, site in enumerate(this_slab):\n            bulk_coord = this_slab.site_properties['bulk_coordinations'][n]\n            slab_coord = len(vnn_surface.get_nn(this_slab, n))\n            mi_mag = np.dot(this_mi_vec, site.coords)\n            undercoord = (bulk_coord - slab_coord) / bulk_coord\n            undercoords += [undercoord]\n            if undercoord > undercoord_threshold and mi_mag > average_mi_mag:\n                surf_props += ['surface']\n            else:\n                surf_props += ['subsurface']\n        new_site_properties = {'surface_properties': surf_props,\n                               'undercoords': undercoords}\n        new_slab = this_slab.copy(site_properties=new_site_properties)\n        return cls(new_slab, selective_dynamics)", "response": "This method constructs an adsorbate site finder from a bulk and miller index."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef find_surface_sites_by_height(self, slab, height=0.9, xy_tol=0.05):\n\n        # Get projection of coordinates along the miller index\n        m_projs = np.array([np.dot(site.coords, self.mvec)\n                            for site in slab.sites])\n\n        # Mask based on window threshold along the miller index.\n        mask = (m_projs - np.amax(m_projs)) >= -height\n        surf_sites = [slab.sites[n] for n in np.where(mask)[0]]\n        if xy_tol:\n            # sort surface sites by height\n            surf_sites = [s for (h, s) in zip(m_projs[mask], surf_sites)]\n            surf_sites.reverse()\n            unique_sites, unique_perp_fracs = [], []\n            for site in surf_sites:\n                this_perp = site.coords - np.dot(site.coords, self.mvec)\n                this_perp_frac = slab.lattice.get_fractional_coords(this_perp)\n                if not in_coord_list_pbc(unique_perp_fracs, this_perp_frac):\n                    unique_sites.append(site)\n                    unique_perp_fracs.append(this_perp_frac)\n            surf_sites = unique_sites\n\n        return surf_sites", "response": "This method finds the surface sites within a certain distance from the topmost site in a slab by finding which sites are within a certain threshold in angstroms of distance from the topmost site in a list of sites."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_extended_surface_mesh(self, repeat=(5, 5, 1)):\n        surf_str = Structure.from_sites(self.surface_sites)\n        surf_str.make_supercell(repeat)\n        return surf_str", "response": "Returns an extended surface mesh for the adsorption\n        site finding by constructing supercell of surface sites and then returning the extended surface mesh."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef find_adsorption_sites(self, distance=2.0, put_inside=True,\n                              symm_reduce=1e-2, near_reduce=1e-2,\n                              positions=['ontop', 'bridge', 'hollow'],\n                              no_obtuse_hollow=True):\n        \"\"\"\n        Finds surface sites according to the above algorithm.  Returns\n        a list of corresponding cartesian coordinates.\n\n        Args:\n            distance (float): distance from the coordinating ensemble\n                of atoms along the miller index for the site (i. e.\n                the distance from the slab itself)\n            put_inside (bool): whether to put the site inside the cell\n            symm_reduce (float): symm reduction threshold\n            near_reduce (float): near reduction threshold\n            positions (list): which positions to include in the site finding\n                \"ontop\": sites on top of surface sites\n                \"bridge\": sites at edges between surface sites in Delaunay\n                    triangulation of surface sites in the miller plane\n                \"hollow\": sites at centers of Delaunay triangulation faces\n                \"subsurface\": subsurface positions projected into miller plane\n            no_obtuse_hollow (bool): flag to indicate whether to include\n                obtuse triangular ensembles in hollow sites\n        \"\"\"\n        ads_sites = {k: [] for k in positions}\n        if 'ontop' in positions:\n            ads_sites['ontop'] = [s.coords for s in self.surface_sites]\n        if 'subsurface' in positions:\n            # Get highest site\n            ref = self.slab.sites[np.argmax(self.slab.cart_coords[:, 2])]\n            # Project diff between highest site and subs site into miller\n            ss_sites = [self.mvec * np.dot(ref.coords - s.coords, self.mvec)\n                        + s.coords for s in self.subsurface_sites()]\n            ads_sites['subsurface'] = ss_sites\n        if 'bridge' in positions or 'hollow' in positions:\n            mesh = self.get_extended_surface_mesh()\n            sop = get_rot(self.slab)\n            dt = Delaunay([sop.operate(m.coords)[:2] for m in mesh])\n            # TODO: refactor below to properly account for >3-fold\n            for v in dt.simplices:\n                if -1 not in v:\n                    dots = []\n                    for i_corner, i_opp in zip(range(3), ((1, 2), (0, 2), (0, 1))):\n                        corner, opp = v[i_corner], [v[o] for o in i_opp]\n                        vecs = [mesh[d].coords - mesh[corner].coords for d in opp]\n                        vecs = [vec / np.linalg.norm(vec) for vec in vecs]\n                        dots.append(np.dot(*vecs))\n                        # Add bridge sites at midpoints of edges of D. Tri\n                        if 'bridge' in positions:\n                            ads_sites[\"bridge\"].append(\n                                self.ensemble_center(mesh, opp))\n                    # Prevent addition of hollow sites in obtuse triangles\n                    obtuse = no_obtuse_hollow and (np.array(dots) < 1e-5).any()\n                    # Add hollow sites at centers of D. Tri faces\n                    if 'hollow' in positions and not obtuse:\n                        ads_sites['hollow'].append(\n                            self.ensemble_center(mesh, v))\n        ads_sites['all'] = sum(ads_sites.values(), [])\n        for key, sites in ads_sites.items():\n            # Pare off outer sites for bridge/hollow\n            if key in ['bridge', 'hollow']:\n                frac_coords = [self.slab.lattice.get_fractional_coords(ads_site)\n                               for ads_site in sites]\n                frac_coords = [frac_coord for frac_coord in frac_coords\n                               if (frac_coord[0] > 1 and frac_coord[0] < 4\n                                   and frac_coord[1] > 1 and frac_coord[1] < 4)]\n                sites = [self.slab.lattice.get_cartesian_coords(frac_coord)\n                         for frac_coord in frac_coords]\n            if near_reduce:\n                sites = self.near_reduce(sites, threshold=near_reduce)\n            if put_inside:\n                sites = [put_coord_inside(self.slab.lattice, coord)\n                         for coord in sites]\n            if symm_reduce:\n                sites = self.symm_reduce(sites, threshold=symm_reduce)\n            sites = [site + distance * self.mvec for site in sites]\n\n            ads_sites[key] = sites\n        return ads_sites", "response": "Finds the surface sites of the specified distance from the surface sites of the ensemble and returns a list of corresponding cartesian coordinates."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreduce the set of adsorbate sites by finding duplicates and removing symmetrically equivalent duplicates.", "response": "def symm_reduce(self, coords_set, threshold=1e-6):\n        \"\"\"\n        Reduces the set of adsorbate sites by finding removing\n        symmetrically equivalent duplicates\n\n        Args:\n            coords_set: coordinate set in cartesian coordinates\n            threshold: tolerance for distance equivalence, used\n                as input to in_coord_list_pbc for dupl. checking\n        \"\"\"\n        surf_sg = SpacegroupAnalyzer(self.slab, 0.1)\n        symm_ops = surf_sg.get_symmetry_operations()\n        unique_coords = []\n        # Convert to fractional\n        coords_set = [self.slab.lattice.get_fractional_coords(coords)\n                      for coords in coords_set]\n        for coords in coords_set:\n            incoord = False\n            for op in symm_ops:\n                if in_coord_list_pbc(unique_coords, op.operate(coords),\n                                     atol=threshold):\n                    incoord = True\n                    break\n            if not incoord:\n                unique_coords += [coords]\n        # convert back to cartesian\n        return [self.slab.lattice.get_cartesian_coords(coords)\n                for coords in unique_coords]"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a list of unique coordinates that are within threshold.", "response": "def near_reduce(self, coords_set, threshold=1e-4):\n        \"\"\"\n        Prunes coordinate set for coordinates that are within\n        threshold\n\n        Args:\n            coords_set (Nx3 array-like): list or array of coordinates\n            threshold (float): threshold value for distance\n        \"\"\"\n        unique_coords = []\n        coords_set = [self.slab.lattice.get_fractional_coords(coords)\n                      for coords in coords_set]\n        for coord in coords_set:\n            if not in_coord_list_pbc(unique_coords, coord, threshold):\n                unique_coords += [coord]\n        return [self.slab.lattice.get_cartesian_coords(coords)\n                for coords in unique_coords]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef ensemble_center(self, site_list, indices, cartesian=True):\n        if cartesian:\n            return np.average([site_list[i].coords for i in indices],\n                              axis=0)\n        else:\n            return np.average([site_list[i].frac_coords for i in indices],\n                              axis=0)", "response": "Returns the center of an ensemble of sites selected from a list of sites."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add_adsorbate(self, molecule, ads_coord, repeat=None, reorient=True):\n        if reorient:\n            # Reorient the molecule along slab m_index\n            sop = get_rot(self.slab)\n            molecule.apply_operation(sop.inverse)\n        struct = self.slab.copy()\n        if repeat:\n            struct.make_supercell(repeat)\n        if 'surface_properties' in struct.site_properties.keys():\n            molecule.add_site_property(\"surface_properties\",\n                                       [\"adsorbate\"] * molecule.num_sites)\n        if 'selective_dynamics' in struct.site_properties.keys():\n            molecule.add_site_property(\"selective_dynamics\",\n                                       [[True, True, True]] * molecule.num_sites)\n        for site in molecule:\n            struct.append(site.specie, ads_coord + site.coords, coords_are_cartesian=True,\n                          properties=site.properties)\n        return struct", "response": "Adds an adsorbate at a particular coordinate."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nassigns selective dynamics to a slab", "response": "def assign_selective_dynamics(self, slab):\n        \"\"\"\n        Helper function to assign selective dynamics site_properties\n        based on surface, subsurface site properties\n\n        Args:\n            slab (Slab): slab for which to assign selective dynamics\n        \"\"\"\n        sd_list = []\n        sd_list = [[False, False, False] if site.properties['surface_properties'] == 'subsurface'\n                   else [True, True, True] for site in slab.sites]\n        new_sp = slab.site_properties\n        new_sp['selective_dynamics'] = sd_list\n        return slab.copy(site_properties=new_sp)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nfunctions that generates all adsorption structures for a given molecular adsorbate. Can take repeat argument or minimum length/width of precursor slab as an input Args: molecule (Molecule): molecule corresponding to adsorbate repeat (3-tuple or list): repeat argument for supercell generation min_lw (float): minimum length and width of the slab, only used if repeat is None reorient (bool): flag on whether or not to reorient adsorbate along the miller index find_args (dict): dictionary of arguments to be passed to the call to self.find_adsorption_sites, e.g. {\"distance\":2.0}", "response": "def generate_adsorption_structures(self, molecule, repeat=None, min_lw=5.0,\n                                       reorient=True, find_args={}):\n        \"\"\"\n        Function that generates all adsorption structures for a given\n        molecular adsorbate.  Can take repeat argument or minimum\n        length/width of precursor slab as an input\n\n        Args:\n            molecule (Molecule): molecule corresponding to adsorbate\n            repeat (3-tuple or list): repeat argument for supercell generation\n            min_lw (float): minimum length and width of the slab, only used\n                if repeat is None\n            reorient (bool): flag on whether or not to reorient adsorbate\n                along the miller index\n            find_args (dict): dictionary of arguments to be passed to the\n                call to self.find_adsorption_sites, e.g. {\"distance\":2.0}\n        \"\"\"\n        if repeat is None:\n            xrep = np.ceil(min_lw / np.linalg.norm(self.slab.lattice.matrix[0]))\n            yrep = np.ceil(min_lw / np.linalg.norm(self.slab.lattice.matrix[1]))\n            repeat = [xrep, yrep, 1]\n        structs = []\n\n        for coords in self.find_adsorption_sites(**find_args)['all']:\n            structs.append(self.add_adsorbate(\n                molecule, coords, repeat=repeat, reorient=reorient))\n        return structs"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef adsorb_both_surfaces(self, molecule, repeat=None, min_lw=5.0,\n                             reorient=True, find_args={}):\n        \"\"\"\n        Function that generates all adsorption structures for a given\n        molecular adsorbate on both surfaces of a slab. This is useful\n        for calculating surface energy where both surfaces need to be\n        equivalent or if we want to calculate nonpolar systems.\n\n        Args:\n            molecule (Molecule): molecule corresponding to adsorbate\n            repeat (3-tuple or list): repeat argument for supercell generation\n            min_lw (float): minimum length and width of the slab, only used\n                if repeat is None\n            reorient (bool): flag on whether or not to reorient adsorbate\n                along the miller index\n            find_args (dict): dictionary of arguments to be passed to the\n                call to self.find_adsorption_sites, e.g. {\"distance\":2.0}\n        \"\"\"\n\n        # Get the adsorbed surfaces first\n        adslabs = self.generate_adsorption_structures(molecule, repeat=repeat,\n                                                      min_lw=min_lw,\n                                                      reorient=reorient,\n                                                      find_args=find_args)\n\n        new_adslabs = []\n        for adslab in adslabs:\n\n            # Find the adsorbate sites and indices in each slab\n            symmetric, adsorbates, indices = False, [], []\n            for i, site in enumerate(adslab.sites):\n                if site.surface_properties == \"adsorbate\":\n                    adsorbates.append(site)\n                    indices.append(i)\n\n            # Start with the clean slab\n            adslab.remove_sites(indices)\n            slab = adslab.copy()\n\n            # For each site, we add it back to the slab along with a\n            # symmetrically equivalent position on the other side of\n            # the slab using symmetry operations\n            for adsorbate in adsorbates:\n                p2 = adslab.get_symmetric_site(adsorbate.frac_coords)\n                slab.append(adsorbate.specie, p2,\n                            properties={\"surface_properties\": \"adsorbate\"})\n                slab.append(adsorbate.specie, adsorbate.frac_coords,\n                            properties={\"surface_properties\": \"adsorbate\"})\n            new_adslabs.append(slab)\n\n        return new_adslabs", "response": "This function generates all adsorption structures for a given molecular adsorbate on both surfaces of a slab."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nfunctions that performs substitution-type doping on the surface and returns all possible configurations where one dopant is substituted per surface. Can substitute one surface or both. Args: atom (str): atom corresponding to substitutional dopant sub_both_sides (bool): If true, substitute an equivalent site on the other surface target_species (list): List of specific species to substitute range_tol (float): Find viable substitution sites at a specific distance from the surface +- this tolerance dist_from_surf (float): Distance from the surface to find viable substitution sites, defaults to 0 to substitute at the surface", "response": "def generate_substitution_structures(self, atom, target_species=[],\n                                         sub_both_sides=False, range_tol=1e-2,\n                                         dist_from_surf=0):\n        \"\"\"\n        Function that performs substitution-type doping on the surface and\n            returns all possible configurations where one dopant is substituted\n            per surface. Can substitute one surface or both.\n\n        Args:\n            atom (str): atom corresponding to substitutional dopant\n            sub_both_sides (bool): If true, substitute an equivalent\n                site on the other surface\n            target_species (list): List of specific species to substitute\n            range_tol (float): Find viable substitution sites at a specific\n                distance from the surface +- this tolerance\n            dist_from_surf (float): Distance from the surface to find viable\n                substitution sites, defaults to 0 to substitute at the surface\n        \"\"\"\n\n        # Get symmetrized structure in case we want to substitue both sides\n        sym_slab = SpacegroupAnalyzer(self.slab).get_symmetrized_structure()\n\n        # Define a function for substituting a site\n        def substitute(site, i):\n            slab = self.slab.copy()\n            props = self.slab.site_properties\n            if sub_both_sides:\n                # Find an equivalent site on the other surface\n                eq_indices = [indices for indices in\n                              sym_slab.equivalent_indices if i in indices][0]\n                for ii in eq_indices:\n                    if \"%.6f\" % (sym_slab[ii].frac_coords[2]) != \\\n                                    \"%.6f\" % (site.frac_coords[2]):\n                        props[\"surface_properties\"][ii] = \"substitute\"\n                        slab.replace(ii, atom)\n                        break\n\n            props[\"surface_properties\"][i] = \"substitute\"\n            slab.replace(i, atom)\n            slab.add_site_property(\"surface_properties\",\n                                   props[\"surface_properties\"])\n            return slab\n\n        # Get all possible substitution sites\n        substituted_slabs = []\n        # Sort sites so that we can define a range relative to the position of the\n        # surface atoms, i.e. search for sites above (below) the bottom (top) surface\n        sorted_sites = sorted(sym_slab, key=lambda site: site.frac_coords[2])\n        if sorted_sites[0].surface_properties == \"surface\":\n            d = sorted_sites[0].frac_coords[2] + dist_from_surf\n        else:\n            d = sorted_sites[-1].frac_coords[2] - dist_from_surf\n\n        for i, site in enumerate(sym_slab):\n            if d - range_tol < site.frac_coords[2] < d + range_tol:\n                if target_species and site.species_string in target_species:\n                    substituted_slabs.append(substitute(site, i))\n                elif not target_species:\n                    substituted_slabs.append(substitute(site, i))\n\n        matcher = StructureMatcher()\n        return [s[0] for s in matcher.group_structures(substituted_slabs)]"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreads the exciting input from a string containing XML data.", "response": "def from_string(data):\n        \"\"\"\n        Reads the exciting input from a string\n        \"\"\"\n       \n        root=ET.fromstring(data)\n        speciesnode=root.find('structure').iter('species')\n        elements = []\n        positions = []\n        vectors=[]\n        lockxyz=[]\n        # get title\n        title_in=str(root.find('title').text)\n        # Read elements and coordinates\n        for nodes in speciesnode:\n            symbol = nodes.get('speciesfile').split('.')[0]\n            if len(symbol.split('_'))==2:\n              symbol=symbol.split('_')[0]\n            if Element.is_valid_symbol(symbol):\n                # Try to recognize the element symbol\n                element = symbol\n            else:\n                raise NLValueError(\"Unknown element!\")\n            natoms = nodes.getiterator('atom')\n            for atom in natoms:\n                x, y, z = atom.get('coord').split()\n                positions.append([float(x), float(y), float(z)])\n                elements.append(element)\n                # Obtain lockxyz for each atom\n                if atom.get('lockxyz') is not None:\n                    lxy=[]\n                    for l in atom.get('lockxyz').split():\n                        if l=='True' or l=='true':\n                            lxyz.append(True)\n                        else:\n                            lxyz.append(False)\n                    lockxyz.append(lxyz)\n                else:\n                    lockxyz.append([False, False, False])\n        #check the atomic positions type\n        if 'cartesian' in root.find('structure').attrib.keys():\n          if root.find('structure').attrib['cartesian']:\n            cartesian=True\n            for i in range(len(positions)):\n                for j in range(3):\n                    positions[i][j]=positions[i][j]*ExcitingInput.bohr2ang\n            print(positions)\n        else:\n          cartesian=False\n        # get the scale attribute\n        scale_in=root.find('structure').find('crystal').get('scale')\n        if scale_in:\n            scale=float(scale_in)*ExcitingInput.bohr2ang\n        else:\n            scale=ExcitingInput.bohr2ang\n       # get the stretch attribute\n        stretch_in=root.find('structure').find('crystal').get('stretch')\n        if stretch_in:\n          stretch=np.array([float(a) for a in stretch_in])\n        else:\n          stretch=np.array([1.0,1.0,1.0])\n        # get basis vectors and scale them accordingly\n        basisnode=root.find('structure').find('crystal').iter('basevect')\n        for vect in basisnode:\n          x, y, z=vect.text.split()\n          vectors.append([float(x)*stretch[0]*scale,\n                          float(y)*stretch[1]*scale,\n                          float(z)*stretch[2]*scale])\n        # create lattice and structure object\n        lattice_in=Lattice(vectors)\n        structure_in=Structure(lattice_in,elements,positions,coords_are_cartesian=cartesian)\n\n        return ExcitingInput(structure_in, title_in, lockxyz)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef types_of_specie(self):\n        if not self.is_ordered:\n            raise TypeError(\"\"\"\\\ntypes_of_species cannot be used with disordered structures and partial occupancies.\nUse OrderDisorderedStructureTransformation or EnumerateStructureTransformation\nto build an appropriate supercell from partial occupancies.\"\"\")\n\n        # Cannot use set since we want a deterministic algorithm.\n        types = []\n        for site in self:\n            if site.specie not in types:\n                types.append(site.specie)\n        return types", "response": "Returns a list of types of species. Only works for ordered structures and disordered structures will raise TypeError."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef group_by_types(self):\n        for t in self.types_of_specie:\n            for site in self:\n                if site.specie == t:\n                    yield site", "response": "Iterate over species grouped by type"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a tuple with the sequential indices of the sites that contain an element with the given chemical symbol.", "response": "def indices_from_symbol(self, symbol: str) -> tuple:\n        \"\"\"\n        Returns a tuple with the sequential indices of the sites\n        that contain an element with the given chemical symbol.\n        \"\"\"\n        return tuple((i for i, specie in enumerate(self.species)\n                      if specie.symbol == symbol))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef site_properties(self):\n        props = {}\n        prop_keys = set()\n        for site in self:\n            prop_keys.update(site.properties.keys())\n\n        for k in prop_keys:\n            props[k] = [site.properties.get(k, None) for site in self]\n        return props", "response": "Returns the site properties as a dict of sequences. E. g.."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef composition(self):\n        elmap = collections.defaultdict(float)\n        for site in self:\n            for species, occu in site.species.items():\n                elmap[species] += occu\n        return Composition(elmap)", "response": "Returns the composition of the species and occu of all sites in the site."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef charge(self):\n        charge = 0\n        for site in self:\n            for specie, amt in site.species.items():\n                charge += getattr(specie, \"oxi_state\", 0) * amt\n        return charge", "response": "Returns the net charge of the structure based on oxidation states."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_angle(self, i: int, j: int, k: int) -> float:\n        v1 = self[i].coords - self[j].coords\n        v2 = self[k].coords - self[j].coords\n        return get_angle(v1, v2, units=\"degrees\")", "response": "Returns angle in degrees of the third site of the set of two - site tables."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns dihedral angle of the entry in the system.", "response": "def get_dihedral(self, i: int, j: int, k: int, l: int) -> float:\n        \"\"\"\n        Returns dihedral angle specified by four sites.\n\n        Args:\n            i: Index of first site\n            j: Index of second site\n            k: Index of third site\n            l: Index of fourth site\n\n        Returns:\n            Dihedral angle in degrees.\n        \"\"\"\n        v1 = self[k].coords - self[l].coords\n        v2 = self[j].coords - self[k].coords\n        v3 = self[i].coords - self[j].coords\n        v23 = np.cross(v2, v3)\n        v12 = np.cross(v1, v2)\n        return math.degrees(math.atan2(np.linalg.norm(v2) * np.dot(v1, v23),\n                                       np.dot(v12, v23)))"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn True if the site collection is valid.", "response": "def is_valid(self, tol: float = DISTANCE_TOLERANCE) -> bool:\n        \"\"\"\n        True if SiteCollection does not contain atoms that are too close\n        together. Note that the distance definition is based on type of\n        SiteCollection. Cartesian distances are used for non-periodic\n        Molecules, while PBC is taken into account for periodic structures.\n\n        Args:\n            tol (float): Distance tolerance. Default is 0.5A.\n\n        Returns:\n            (bool) True if SiteCollection does not contain atoms that are too\n            close together.\n        \"\"\"\n        if len(self.sites) == 1:\n            return True\n        all_dists = self.distance_matrix[np.triu_indices(len(self), 1)]\n        return bool(np.min(all_dists) > tol)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd a property to a site.", "response": "def add_site_property(self, property_name, values):\n        \"\"\"\n        Adds a property to a site.\n\n        Args:\n            property_name (str): The name of the property to add.\n            values (list): A sequence of values. Must be same length as\n                number of sites.\n        \"\"\"\n        if len(values) != len(self.sites):\n            raise ValueError(\"Values must be same length as sites.\")\n        for site, val in zip(self.sites, values):\n            site.properties[property_name] = val"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef replace_species(self, species_mapping):\n\n        species_mapping = {get_el_sp(k): v\n                           for k, v in species_mapping.items()}\n        sp_to_replace = set(species_mapping.keys())\n        sp_in_structure = set(self.composition.keys())\n        if not sp_in_structure.issuperset(sp_to_replace):\n            warnings.warn(\n                \"Some species to be substituted are not present in \"\n                \"structure. Pls check your input. Species to be \"\n                \"substituted = %s; Species in structure = %s\"\n                % (sp_to_replace, sp_in_structure))\n\n        for site in self._sites:\n            if sp_to_replace.intersection(site.species):\n                c = Composition()\n                for sp, amt in site.species.items():\n                    new_sp = species_mapping.get(sp, sp)\n                    try:\n                        c += Composition(new_sp) * amt\n                    except Exception:\n                        c += {new_sp: amt}\n                site.species = c", "response": "Replaces all species in the structure with the new ones."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add_oxidation_state_by_element(self, oxidation_states):\n        try:\n            for site in self.sites:\n                new_sp = {}\n                for el, occu in site.species.items():\n                    sym = el.symbol\n                    new_sp[Specie(sym, oxidation_states[sym])] = occu\n                site.species = new_sp\n        except KeyError:\n            raise ValueError(\"Oxidation state of all elements must be \"\n                             \"specified in the dictionary.\")", "response": "Adds oxidation states to the species of all elements in the site."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding oxidation states to a structure by site.", "response": "def add_oxidation_state_by_site(self, oxidation_states):\n        \"\"\"\n        Add oxidation states to a structure by site.\n\n        Args:\n            oxidation_states (list): List of oxidation states.\n                E.g., [1, 1, 1, 1, 2, 2, 2, 2, 5, 5, 5, 5, -2, -2, -2, -2]\n        \"\"\"\n        if len(oxidation_states) != len(self.sites):\n            raise ValueError(\"Oxidation states of all sites must be \"\n                             \"specified.\")\n        for site, ox in zip(self.sites, oxidation_states):\n            new_sp = {}\n            for el, occu in site.species.items():\n                sym = el.symbol\n                new_sp[Specie(sym, ox)] = occu\n            site.species = new_sp"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nremoves oxidation states from a structure.", "response": "def remove_oxidation_states(self):\n        \"\"\"\n        Removes oxidation states from a structure.\n        \"\"\"\n        for site in self.sites:\n            new_sp = collections.defaultdict(float)\n            for el, occu in site.species.items():\n                sym = el.symbol\n                new_sp[Element(sym)] += occu\n            site.species = new_sp"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_oxidation_state_by_guess(self, **kwargs):\n        oxid_guess = self.composition.oxi_state_guesses(**kwargs)\n        oxid_guess = oxid_guess or \\\n                     [dict([(e.symbol, 0) for e in self.composition])]\n        self.add_oxidation_state_by_element(oxid_guess[0])", "response": "Adds the oxidation state by guessing the structure with oxidation state by element."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds spin states to a structure.", "response": "def add_spin_by_element(self, spins):\n        \"\"\"\n        Add spin states to a structure.\n\n        Args:\n            spisn (dict): Dict of spins associated with\n            elements or species, e.g. {\"Ni\":+5} or {\"Ni2+\":5}\n        \"\"\"\n        for site in self.sites:\n            new_sp = {}\n            for sp, occu in site.species.items():\n                sym = sp.symbol\n                oxi_state = getattr(sp, \"oxi_state\", None)\n                new_sp[Specie(sym, oxidation_state=oxi_state,\n                              properties={'spin': spins.get(str(sp), spins.get(sym, None))})] = occu\n            site.species = new_sp"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd spin states to a structure by site.", "response": "def add_spin_by_site(self, spins):\n        \"\"\"\n        Add spin states to a structure by site.\n\n        Args:\n            spins (list): List of spins\n                E.g., [+5, -5, 0, 0]\n        \"\"\"\n        if len(spins) != len(self.sites):\n            raise ValueError(\"Spin of all sites must be \"\n                             \"specified in the dictionary.\")\n\n        for site, spin in zip(self.sites, spins):\n            new_sp = {}\n            for sp, occu in site.species.items():\n                sym = sp.symbol\n                oxi_state = getattr(sp, \"oxi_state\", None)\n                new_sp[Specie(sym, oxidation_state=oxi_state,\n                              properties={'spin': spin})] = occu\n            site.species = new_sp"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef remove_spin(self):\n        for site in self.sites:\n            new_sp = collections.defaultdict(float)\n            for sp, occu in site.species.items():\n                oxi_state = getattr(sp, \"oxi_state\", None)\n                new_sp[Specie(sp.symbol, oxidation_state=oxi_state)] += occu\n            site.species = new_sp", "response": "Removes spin states from a structure."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nextracts a cluster of atoms based on bond lengths.", "response": "def extract_cluster(self, target_sites, **kwargs):\n        \"\"\"\n        Extracts a cluster of atoms based on bond lengths\n\n        Args:\n            target_sites ([Site]): List of initial sites to nucleate cluster.\n            \\\\*\\\\*kwargs: kwargs passed through to CovalentBond.is_bonded.\n\n        Returns:\n            [Site/PeriodicSite] Cluster of atoms.\n        \"\"\"\n        cluster = list(target_sites)\n        others = [site for site in self if site not in cluster]\n        size = 0\n        while len(cluster) > size:\n            size = len(cluster)\n            new_others = []\n            for site in others:\n                for site2 in cluster:\n                    if CovalentBond.is_bonded(site, site2, **kwargs):\n                        cluster.append(site)\n                        break\n                else:\n                    new_others.append(site)\n            others = new_others\n        return cluster"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef from_sites(cls, sites, charge=None, validate_proximity=False,\n                   to_unit_cell=False):\n        \"\"\"\n        Convenience constructor to make a Structure from a list of sites.\n\n        Args:\n            sites: Sequence of PeriodicSites. Sites must have the same\n                lattice.\n            validate_proximity (bool): Whether to check if there are sites\n                that are less than 0.01 Ang apart. Defaults to False.\n            to_unit_cell (bool): Whether to translate sites into the unit\n                cell.\n\n        Returns:\n            (Structure) Note that missing properties are set as None.\n        \"\"\"\n        if len(sites) < 1:\n            raise ValueError(\"You need at least one site to construct a %s\" %\n                             cls)\n        prop_keys = []\n        props = {}\n        lattice = None\n        for i, site in enumerate(sites):\n            if not lattice:\n                lattice = site.lattice\n            elif site.lattice != lattice:\n                raise ValueError(\"Sites must belong to the same lattice\")\n            for k, v in site.properties.items():\n                if k not in prop_keys:\n                    prop_keys.append(k)\n                    props[k] = [None] * len(sites)\n                props[k][i] = v\n        for k, v in props.items():\n            if any((vv is None for vv in v)):\n                warnings.warn(\"Not all sites have property %s. Missing values \"\n                              \"are set to None.\" % k)\n        return cls(lattice, [site.species for site in sites],\n                   [site.frac_coords for site in sites],\n                   charge=charge,\n                   site_properties=props,\n                   validate_proximity=validate_proximity,\n                   to_unit_cell=to_unit_cell)", "response": "Convenience constructor to construct a structure from a list of PeriodicSites."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef from_spacegroup(cls, sg, lattice, species, coords, site_properties=None,\n                        coords_are_cartesian=False, tol=1e-5):\n        \"\"\"\n        Generate a structure using a spacegroup. Note that only symmetrically\n        distinct species and coords should be provided. All equivalent sites\n        are generated from the spacegroup operations.\n\n        Args:\n            sg (str/int): The spacegroup. If a string, it will be interpreted\n                as one of the notations supported by\n                pymatgen.symmetry.groups.Spacegroup. E.g., \"R-3c\" or \"Fm-3m\".\n                If an int, it will be interpreted as an international number.\n            lattice (Lattice/3x3 array): The lattice, either as a\n                :class:`pymatgen.core.lattice.Lattice` or\n                simply as any 2D array. Each row should correspond to a lattice\n                vector. E.g., [[10,0,0], [20,10,0], [0,0,30]] specifies a\n                lattice with lattice vectors [10,0,0], [20,10,0] and [0,0,30].\n                Note that no attempt is made to check that the lattice is\n                compatible with the spacegroup specified. This may be\n                introduced in a future version.\n            species ([Specie]): Sequence of species on each site. Can take in\n                flexible input, including:\n\n                i.  A sequence of element / specie specified either as string\n                    symbols, e.g. [\"Li\", \"Fe2+\", \"P\", ...] or atomic numbers,\n                    e.g., (3, 56, ...) or actual Element or Specie objects.\n\n                ii. List of dict of elements/species and occupancies, e.g.,\n                    [{\"Fe\" : 0.5, \"Mn\":0.5}, ...]. This allows the setup of\n                    disordered structures.\n            coords (Nx3 array): list of fractional/cartesian coordinates of\n                each species.\n            coords_are_cartesian (bool): Set to True if you are providing\n                coordinates in cartesian coordinates. Defaults to False.\n            site_properties (dict): Properties associated with the sites as a\n                dict of sequences, e.g., {\"magmom\":[5,5,5,5]}. The sequences\n                have to be the same length as the atomic species and\n                fractional_coords. Defaults to None for no properties.\n            tol (float): A fractional tolerance to deal with numerical\n               precision issues in determining if orbits are the same.\n        \"\"\"\n        from pymatgen.symmetry.groups import SpaceGroup\n        try:\n            i = int(sg)\n            sgp = SpaceGroup.from_int_number(i)\n        except ValueError:\n            sgp = SpaceGroup(sg)\n\n        if isinstance(lattice, Lattice):\n            latt = lattice\n        else:\n            latt = Lattice(lattice)\n\n        if not sgp.is_compatible(latt):\n            raise ValueError(\n                \"Supplied lattice with parameters %s is incompatible with \"\n                \"supplied spacegroup %s!\" % (latt.lengths_and_angles,\n                                             sgp.symbol)\n            )\n\n        if len(species) != len(coords):\n            raise ValueError(\n                \"Supplied species and coords lengths (%d vs %d) are \"\n                \"different!\" % (len(species), len(coords))\n            )\n\n        frac_coords = np.array(coords, dtype=np.float) \\\n            if not coords_are_cartesian else \\\n            lattice.get_fractional_coords(coords)\n\n        props = {} if site_properties is None else site_properties\n\n        all_sp = []\n        all_coords = []\n        all_site_properties = collections.defaultdict(list)\n        for i, (sp, c) in enumerate(zip(species, frac_coords)):\n            cc = sgp.get_orbit(c, tol=tol)\n            all_sp.extend([sp] * len(cc))\n            all_coords.extend(cc)\n            for k, v in props.items():\n                all_site_properties[k].extend([v[i]] * len(cc))\n\n        return cls(latt, all_sp, all_coords,\n                   site_properties=all_site_properties)", "response": "Generate a new structure from a spacegroup."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngenerates a structure from a magnetic spacegroup.", "response": "def from_magnetic_spacegroup(\n            cls, msg, lattice, species, coords, site_properties,\n            transform_setting=None, coords_are_cartesian=False, tol=1e-5):\n        \"\"\"\n        Generate a structure using a magnetic spacegroup. Note that only\n        symmetrically distinct species, coords and magmoms should be provided.]\n        All equivalent sites are generated from the spacegroup operations.\n\n        Args:\n            msg (str/list/:class:`pymatgen.symmetry.maggroups.MagneticSpaceGroup`):\n                The magnetic spacegroup.\n                If a string, it will be interpreted as one of the notations\n                supported by MagneticSymmetryGroup, e.g., \"R-3'c\" or \"Fm'-3'm\".\n                If a list of two ints, it will be interpreted as the number of\n                the spacegroup in its Belov, Neronova and Smirnova (BNS) setting.\n            lattice (Lattice/3x3 array): The lattice, either as a\n                :class:`pymatgen.core.lattice.Lattice` or\n                simply as any 2D array. Each row should correspond to a lattice\n                vector. E.g., [[10,0,0], [20,10,0], [0,0,30]] specifies a\n                lattice with lattice vectors [10,0,0], [20,10,0] and [0,0,30].\n                Note that no attempt is made to check that the lattice is\n                compatible with the spacegroup specified. This may be\n                introduced in a future version.\n            species ([Specie]): Sequence of species on each site. Can take in\n                flexible input, including:\n                i.  A sequence of element / specie specified either as string\n                symbols, e.g. [\"Li\", \"Fe2+\", \"P\", ...] or atomic numbers,\n                e.g., (3, 56, ...) or actual Element or Specie objects.\n\n                ii. List of dict of elements/species and occupancies, e.g.,\n                    [{\"Fe\" : 0.5, \"Mn\":0.5}, ...]. This allows the setup of\n                    disordered structures.\n            coords (Nx3 array): list of fractional/cartesian coordinates of\n                each species.\n            site_properties (dict): Properties associated with the sites as a\n                dict of sequences, e.g., {\"magmom\":[5,5,5,5]}. The sequences\n                have to be the same length as the atomic species and\n                fractional_coords. Unlike Structure.from_spacegroup(),\n                this argument is mandatory, since magnetic moment information\n                has to be included. Note that the *direction* of the supplied\n                magnetic moment relative to the crystal is important, even if\n                the resulting structure is used for collinear calculations.\n            coords_are_cartesian (bool): Set to True if you are providing\n                coordinates in cartesian coordinates. Defaults to False.\n            tol (float): A fractional tolerance to deal with numerical\n                precision issues in determining if orbits are the same.\n        \"\"\"\n        from pymatgen.electronic_structure.core import Magmom\n        from pymatgen.symmetry.maggroups import MagneticSpaceGroup\n\n        if 'magmom' not in site_properties:\n            raise ValueError('Magnetic moments have to be defined.')\n        else:\n            magmoms = [Magmom(m) for m in site_properties['magmom']]\n\n        if not isinstance(msg, MagneticSpaceGroup):\n            msg = MagneticSpaceGroup(msg)\n\n        if isinstance(lattice, Lattice):\n            latt = lattice\n        else:\n            latt = Lattice(lattice)\n\n        if not msg.is_compatible(latt):\n            raise ValueError(\n                \"Supplied lattice with parameters %s is incompatible with \"\n                \"supplied spacegroup %s!\" % (latt.lengths_and_angles,\n                                             msg.symbol)\n            )\n\n        if len(species) != len(coords):\n            raise ValueError(\n                \"Supplied species and coords lengths (%d vs %d) are \"\n                \"different!\" % (len(species), len(coords))\n            )\n\n        if len(species) != len(magmoms):\n            raise ValueError(\n                \"Supplied species and magmom lengths (%d vs %d) are \"\n                \"different!\" % (len(species), len(magmoms))\n            )\n\n        frac_coords = coords if not coords_are_cartesian else \\\n            lattice.get_fractional_coords(coords)\n\n        all_sp = []\n        all_coords = []\n        all_magmoms = []\n        all_site_properties = collections.defaultdict(list)\n        for i, (sp, c, m) in enumerate(zip(species, frac_coords, magmoms)):\n            cc, mm = msg.get_orbit(c, m, tol=tol)\n            all_sp.extend([sp] * len(cc))\n            all_coords.extend(cc)\n            all_magmoms.extend(mm)\n            for k, v in site_properties.items():\n                if k != 'magmom':\n                    all_site_properties[k].extend([v[i]] * len(cc))\n\n        all_site_properties['magmom'] = all_magmoms\n\n        return cls(latt, all_sp, all_coords,\n                   site_properties=all_site_properties)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef density(self):\n        m = Mass(self.composition.weight, \"amu\")\n        return m.to(\"g\") / (self.volume * Length(1, \"ang\").to(\"cm\") ** 3)", "response": "Returns the density in units of g"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_space_group_info(self, symprec=1e-2, angle_tolerance=5.0):\n        # Import within method needed to avoid cyclic dependency.\n        from pymatgen.symmetry.analyzer import SpacegroupAnalyzer\n        a = SpacegroupAnalyzer(self, symprec=symprec,\n                               angle_tolerance=angle_tolerance)\n        return a.get_space_group_symbol(), a.get_space_group_number()", "response": "Convenience method to quickly get the spacegroup symbol and international number of a structure."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncheck whether this structure is similar to another structure.", "response": "def matches(self, other, **kwargs):\n        \"\"\"\n        Check whether this structure is similar to another structure.\n        Basically a convenience method to call structure matching fitting.\n\n        Args:\n            other (IStructure/Structure): Another structure.\n            **kwargs: Same **kwargs as in\n                :class:`pymatgen.analysis.structure_matcher.StructureMatcher`.\n\n        Returns:\n            (bool) True is the structures are similar under some affine\n            transformation.\n        \"\"\"\n        from pymatgen.analysis.structure_matcher import StructureMatcher\n        m = StructureMatcher(**kwargs)\n        return m.fit(Structure.from_sites(self), Structure.from_sites(other))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_distance(self, i, j, jimage=None):\n        return self[i].distance(self[j], jimage)", "response": "Returns the distance between site i and j assuming periodic boundary\n            conditions."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_sites_in_sphere(self, pt, r, include_index=False, include_image=False):\n        site_fcoords = np.mod(self.frac_coords, 1)\n        neighbors = []\n        for fcoord, dist, i, img in self._lattice.get_points_in_sphere(\n                site_fcoords, pt, r):\n            nnsite = PeriodicSite(self[i].species,\n                                  fcoord, self._lattice,\n                                  properties=self[i].properties)\n\n            # Get the neighbor data\n            nn_data = (nnsite, dist) if not include_index else (nnsite, dist, i)\n            if include_image:\n                nn_data += (img,)\n            neighbors.append(nn_data)\n        return neighbors", "response": "This method returns a list of all sites within a sphere from the point pt."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a list of tuples for each site within a sphere of radius r.", "response": "def get_neighbors(self, site, r, include_index=False, include_image=False):\n        \"\"\"\n        Get all neighbors to a site within a sphere of radius r.  Excludes the\n        site itself.\n\n        Args:\n            site (Site): Which is the center of the sphere.\n            r (float): Radius of sphere.\n            include_index (bool): Whether the non-supercell site index\n                is included in the returned data\n            include_image (bool): Whether to include the supercell image\n                is included in the returned data\n\n        Returns:\n            [(site, dist) ...] since most of the time, subsequent processing\n            requires the distance.\n            If include_index == True, the tuple for each neighbor also includes\n            the index of the neighbor.\n            If include_supercell == True, the tuple for each neighbor also includes\n            the index of supercell.\n        \"\"\"\n        nn = self.get_sites_in_sphere(site.coords, r,\n                                      include_index=include_index,\n                                      include_image=include_image)\n        return [d for d in nn if site != d[0]]"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting neighbors for each atom in the unit cell, out to a distance r Returns a list of list of neighbors for each site in structure. Use this method if you are planning on looping over all sites in the crystal. If you only want neighbors for a particular site, use the method get_neighbors as it may not have to build such a large supercell However if you are looping over all sites in the crystal, this method is more efficient since it only performs one pass over a large enough supercell to contain all possible atoms out to a distance r. The return type is a [(site, dist) ...] since most of the time, subsequent processing requires the distance. A note about periodic images: Before computing the neighbors, this operation translates all atoms to within the unit cell (having fractional coordinates within [0,1)). This means that the \"image\" of a site does not correspond to how much it has been translates from its current position, but which image of the unit cell it resides. Args: r (float): Radius of sphere. include_index (bool): Whether to include the non-supercell site in the returned data include_image (bool): Whether to include the supercell image in the returned data Returns: A list of a list of nearest neighbors for each site, i.e., [[(site, dist, index) ...], ..] Index only supplied if include_index = True. The index is the index of the site in the original (non-supercell) structure. This is needed for ewaldmatrix by keeping track of which sites contribute to the ewald sum. Image only supplied if include_image = True", "response": "def get_all_neighbors(self, r, include_index=False, include_image=False):\n        \"\"\"\n        Get neighbors for each atom in the unit cell, out to a distance r\n        Returns a list of list of neighbors for each site in structure.\n        Use this method if you are planning on looping over all sites in the\n        crystal. If you only want neighbors for a particular site, use the\n        method get_neighbors as it may not have to build such a large supercell\n        However if you are looping over all sites in the crystal, this method\n        is more efficient since it only performs one pass over a large enough\n        supercell to contain all possible atoms out to a distance r.\n        The return type is a [(site, dist) ...] since most of the time,\n        subsequent processing requires the distance.\n\n        A note about periodic images: Before computing the neighbors, this operation\n        translates all atoms to within the unit cell (having fractional coordinates within [0,1)).\n        This means that the \"image\" of a site does not correspond to how much it has been\n        translates from its current position, but which image of the unit cell it resides.\n\n        Args:\n            r (float): Radius of sphere.\n            include_index (bool): Whether to include the non-supercell site\n                in the returned data\n            include_image (bool): Whether to include the supercell image\n                in the returned data\n\n        Returns:\n            A list of a list of nearest neighbors for each site, i.e.,\n            [[(site, dist, index) ...], ..]\n            Index only supplied if include_index = True.\n            The index is the index of the site in the original (non-supercell)\n            structure. This is needed for ewaldmatrix by keeping track of which\n            sites contribute to the ewald sum.\n            Image only supplied if include_image = True\n        \"\"\"\n        # Use same algorithm as get_sites_in_sphere to determine supercell but\n        # loop over all atoms in crystal\n        recp_len = np.array(self.lattice.reciprocal_lattice.abc)\n        maxr = np.ceil((r + 0.15) * recp_len / (2 * math.pi))\n        nmin = np.floor(np.min(self.frac_coords, axis=0)) - maxr\n        nmax = np.ceil(np.max(self.frac_coords, axis=0)) + maxr\n\n        all_ranges = [np.arange(x, y) for x, y in zip(nmin, nmax)]\n\n        latt = self._lattice\n        neighbors = [list() for _ in range(len(self._sites))]\n        all_fcoords = np.mod(self.frac_coords, 1)\n        coords_in_cell = latt.get_cartesian_coords(all_fcoords)\n        site_coords = self.cart_coords\n\n        indices = np.arange(len(self))\n        for image in itertools.product(*all_ranges):\n            coords = latt.get_cartesian_coords(image) + coords_in_cell\n            all_dists = all_distances(coords, site_coords)\n            all_within_r = np.bitwise_and(all_dists <= r, all_dists > 1e-8)\n\n            for (j, d, within_r) in zip(indices, all_dists, all_within_r):\n                nnsite = PeriodicSite(self[j].species, coords[j],\n                                      latt, properties=self[j].properties,\n                                      coords_are_cartesian=True)\n                for i in indices[within_r]:\n                    item = (nnsite, d[i], j) if include_index else (\n                        nnsite, d[i])\n\n                    # Add the image, if requested\n                    if include_image:\n                        item += (image,)\n                    neighbors[i].append(item)\n        return neighbors"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning all sites in a shell centered on origin r - dr and r + dr.", "response": "def get_neighbors_in_shell(self, origin, r, dr, include_index=False, include_image=False):\n        \"\"\"\n        Returns all sites in a shell centered on origin (coords) between radii\n        r-dr and r+dr.\n\n        Args:\n            origin (3x1 array): Cartesian coordinates of center of sphere.\n            r (float): Inner radius of shell.\n            dr (float): Width of shell.\n            include_index (bool): Whether to include the non-supercell site\n                in the returned data\n            include_image (bool): Whether to include the supercell image\n                in the returned data\n\n        Returns:\n            [(site, dist, index) ...] since most of the time, subsequent\n            processing\n            requires the distance. Index only supplied if include_index = True.\n            The index is the index of the site in the original (non-supercell)\n            structure. This is needed for ewaldmatrix by keeping track of which\n            sites contribute to the ewald sum.\n            Image only supplied if include_image = True\n        \"\"\"\n        outer = self.get_sites_in_sphere(origin, r + dr,\n                                         include_index=include_index,\n                                         include_image=include_image)\n        inner = r - dr\n        return [t for t in outer if t[1] > inner]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_sorted_structure(self, key=None, reverse=False):\n        sites = sorted(self, key=key, reverse=reverse)\n        return self.__class__.from_sites(sites, charge=self._charge)", "response": "Returns a sorted copy of the structure."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_reduced_structure(self, reduction_algo=\"niggli\"):\n        if reduction_algo == \"niggli\":\n            reduced_latt = self._lattice.get_niggli_reduced_lattice()\n        elif reduction_algo == \"LLL\":\n            reduced_latt = self._lattice.get_lll_reduced_lattice()\n        else:\n            raise ValueError(\"Invalid reduction algo : {}\"\n                             .format(reduction_algo))\n\n        if reduced_latt != self.lattice:\n            return self.__class__(reduced_latt, self.species_and_occu,\n                                  self.cart_coords,\n                                  coords_are_cartesian=True, to_unit_cell=True,\n                                  site_properties=self.site_properties, charge=self._charge)\n        else:\n            return self.copy()", "response": "Returns a reduced structure."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef copy(self, site_properties=None, sanitize=False):\n        props = self.site_properties\n        if site_properties:\n            props.update(site_properties)\n        if not sanitize:\n            return self.__class__(self._lattice,\n                                  self.species_and_occu,\n                                  self.frac_coords,\n                                  charge=self._charge,\n                                  site_properties=props)\n        else:\n            reduced_latt = self._lattice.get_lll_reduced_lattice()\n            new_sites = []\n            for i, site in enumerate(self):\n                frac_coords = reduced_latt.get_fractional_coords(site.coords)\n                site_props = {}\n                for p in props:\n                    site_props[p] = props[p][i]\n                new_sites.append(PeriodicSite(site.species,\n                                              frac_coords, reduced_latt,\n                                              to_unit_cell=True,\n                                              properties=site_props))\n            new_sites = sorted(new_sites)\n            return self.__class__.from_sites(new_sites, charge=self._charge)", "response": "Returns a copy of the structure with optionally new site properties and sanitized."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ninterpolates between this structure and end_structure.", "response": "def interpolate(self, end_structure, nimages=10,\n                    interpolate_lattices=False, pbc=True, autosort_tol=0):\n        \"\"\"\n        Interpolate between this structure and end_structure. Useful for\n        construction of NEB inputs.\n\n        Args:\n            end_structure (Structure): structure to interpolate between this\n                structure and end.\n            nimages (int): No. of interpolation images. Defaults to 10 images.\n            interpolate_lattices (bool): Whether to interpolate the lattices.\n                Interpolates the lengths and angles (rather than the matrix)\n                so orientation may be affected.\n            pbc (bool): Whether to use periodic boundary conditions to find\n                the shortest path between endpoints.\n            autosort_tol (float): A distance tolerance in angstrom in\n                which to automatically sort end_structure to match to the\n                closest points in this particular structure. This is usually\n                what you want in a NEB calculation. 0 implies no sorting.\n                Otherwise, a 0.5 value usually works pretty well.\n\n        Returns:\n            List of interpolated structures. The starting and ending\n            structures included as the first and last structures respectively.\n            A total of (nimages + 1) structures are returned.\n        \"\"\"\n        # Check length of structures\n        if len(self) != len(end_structure):\n            raise ValueError(\"Structures have different lengths!\")\n\n        if not (interpolate_lattices or self.lattice == end_structure.lattice):\n            raise ValueError(\"Structures with different lattices!\")\n\n        # Check that both structures have the same species\n        for i in range(len(self)):\n            if self[i].species != end_structure[i].species:\n                raise ValueError(\"Different species!\\nStructure 1:\\n\" +\n                                 str(self) + \"\\nStructure 2\\n\" +\n                                 str(end_structure))\n\n        start_coords = np.array(self.frac_coords)\n        end_coords = np.array(end_structure.frac_coords)\n\n        if autosort_tol:\n            dist_matrix = self.lattice.get_all_distances(start_coords,\n                                                         end_coords)\n            site_mappings = collections.defaultdict(list)\n            unmapped_start_ind = []\n            for i, row in enumerate(dist_matrix):\n                ind = np.where(row < autosort_tol)[0]\n                if len(ind) == 1:\n                    site_mappings[i].append(ind[0])\n                else:\n                    unmapped_start_ind.append(i)\n\n            if len(unmapped_start_ind) > 1:\n                raise ValueError(\"Unable to reliably match structures \"\n                                 \"with auto_sort_tol = %f. unmapped indices \"\n                                 \"= %s\" % (autosort_tol, unmapped_start_ind))\n\n            sorted_end_coords = np.zeros_like(end_coords)\n            matched = []\n            for i, j in site_mappings.items():\n                if len(j) > 1:\n                    raise ValueError(\"Unable to reliably match structures \"\n                                     \"with auto_sort_tol = %f. More than one \"\n                                     \"site match!\" % autosort_tol)\n                sorted_end_coords[i] = end_coords[j[0]]\n                matched.append(j[0])\n\n            if len(unmapped_start_ind) == 1:\n                i = unmapped_start_ind[0]\n                j = list(set(range(len(start_coords))).difference(matched))[0]\n                sorted_end_coords[i] = end_coords[j]\n\n            end_coords = sorted_end_coords\n\n        vec = end_coords - start_coords\n        if pbc:\n            vec -= np.round(vec)\n        sp = self.species_and_occu\n        structs = []\n\n        if interpolate_lattices:\n            # interpolate lattice matrices using polar decomposition\n            from scipy.linalg import polar\n            # u is unitary (rotation), p is stretch\n            u, p = polar(np.dot(end_structure.lattice.matrix.T,\n                                np.linalg.inv(self.lattice.matrix.T)))\n            lvec = p - np.identity(3)\n            lstart = self.lattice.matrix.T\n\n        for x in range(nimages + 1):\n            if interpolate_lattices:\n                l_a = np.dot(np.identity(3) + x / nimages * lvec, lstart).T\n                l = Lattice(l_a)\n            else:\n                l = self.lattice\n            fcoords = start_coords + x / nimages * vec\n            structs.append(self.__class__(l, sp, fcoords,\n                                          site_properties=self.site_properties))\n        return structs"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_miller_index_from_site_indexes(self, site_ids, round_dp=4,\n                                           verbose=True):\n        \"\"\"\n        Get the Miller index of a plane from a set of sites indexes.\n\n        A minimum of 3 sites are required. If more than 3 sites are given\n        the best plane that minimises the distance to all points will be\n        calculated.\n\n        Args:\n            site_ids (list of int): A list of site indexes to consider. A\n                minimum of three site indexes are required. If more than three\n                sites are provided, the best plane that minimises the distance\n                to all sites will be calculated.\n            round_dp (int, optional): The number of decimal places to round the\n                miller index to.\n            verbose (bool, optional): Whether to print warnings.\n\n        Returns:\n            (tuple): The Miller index.\n        \"\"\"\n        return self.lattice.get_miller_index_from_coords(\n            self.frac_coords[site_ids], coords_are_cartesian=False,\n            round_dp=round_dp, verbose=verbose)", "response": "This method returns the Miller index of a plane from a set of site indexes."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_primitive_structure(self, tolerance=0.25, use_site_props=False,\n                                constrain_latt=None):\n        \"\"\"\n        This finds a smaller unit cell than the input. Sometimes it doesn\"t\n        find the smallest possible one, so this method is recursively called\n        until it is unable to find a smaller cell.\n\n        NOTE: if the tolerance is greater than 1/2 the minimum inter-site\n        distance in the primitive cell, the algorithm will reject this lattice.\n\n        Args:\n            tolerance (float), Angstroms: Tolerance for each coordinate of a\n                particular site. For example, [0.1, 0, 0.1] in cartesian\n                coordinates will be considered to be on the same coordinates\n                as [0, 0, 0] for a tolerance of 0.25. Defaults to 0.25.\n            use_site_props (bool): Whether to account for site properties in\n                differntiating sites.\n            constrain_latt (list/dict): List of lattice parameters we want to\n                preserve, e.g. [\"alpha\", \"c\"] or dict with the lattice\n                parameter names as keys and values we want the parameters to\n                be e.g. {\"alpha\": 90, \"c\": 2.5}.\n\n        Returns:\n            The most primitive structure found.\n        \"\"\"\n        if constrain_latt is None:\n            constrain_latt = []\n\n        def site_label(site):\n            if not use_site_props:\n                return site.species_string\n            else:\n                d = [site.species_string]\n                for k in sorted(site.properties.keys()):\n                    d.append(k + \"=\" + str(site.properties[k]))\n                return \", \".join(d)\n\n        # group sites by species string\n        sites = sorted(self._sites, key=site_label)\n\n        grouped_sites = [\n            list(a[1])\n            for a in itertools.groupby(sites, key=site_label)]\n        grouped_fcoords = [np.array([s.frac_coords for s in g])\n                           for g in grouped_sites]\n\n        # min_vecs are approximate periodicities of the cell. The exact\n        # periodicities from the supercell matrices are checked against these\n        # first\n        min_fcoords = min(grouped_fcoords, key=lambda x: len(x))\n        min_vecs = min_fcoords - min_fcoords[0]\n\n        # fractional tolerance in the supercell\n        super_ftol = np.divide(tolerance, self.lattice.abc)\n        super_ftol_2 = super_ftol * 2\n\n        def pbc_coord_intersection(fc1, fc2, tol):\n            \"\"\"\n            Returns the fractional coords in fc1 that have coordinates\n            within tolerance to some coordinate in fc2\n            \"\"\"\n            d = fc1[:, None, :] - fc2[None, :, :]\n            d -= np.round(d)\n            np.abs(d, d)\n            return fc1[np.any(np.all(d < tol, axis=-1), axis=-1)]\n\n        # here we reduce the number of min_vecs by enforcing that every\n        # vector in min_vecs approximately maps each site onto a similar site.\n        # The subsequent processing is O(fu^3 * min_vecs) = O(n^4) if we do no\n        # reduction.\n        # This reduction is O(n^3) so usually is an improvement. Using double\n        # the tolerance because both vectors are approximate\n        for g in sorted(grouped_fcoords, key=lambda x: len(x)):\n            for f in g:\n                min_vecs = pbc_coord_intersection(min_vecs, g - f, super_ftol_2)\n\n        def get_hnf(fu):\n            \"\"\"\n            Returns all possible distinct supercell matrices given a\n            number of formula units in the supercell. Batches the matrices\n            by the values in the diagonal (for less numpy overhead).\n            Computational complexity is O(n^3), and difficult to improve.\n            Might be able to do something smart with checking combinations of a\n            and b first, though unlikely to reduce to O(n^2).\n            \"\"\"\n\n            def factors(n):\n                for i in range(1, n + 1):\n                    if n % i == 0:\n                        yield i\n\n            for det in factors(fu):\n                if det == 1:\n                    continue\n                for a in factors(det):\n                    for e in factors(det // a):\n                        g = det // a // e\n                        yield det, np.array(\n                            [[[a, b, c], [0, e, f], [0, 0, g]]\n                             for b, c, f in\n                             itertools.product(range(a), range(a),\n                                               range(e))])\n\n        # we cant let sites match to their neighbors in the supercell\n        grouped_non_nbrs = []\n        for gfcoords in grouped_fcoords:\n            fdist = gfcoords[None, :, :] - gfcoords[:, None, :]\n            fdist -= np.round(fdist)\n            np.abs(fdist, fdist)\n            non_nbrs = np.any(fdist > 2 * super_ftol[None, None, :], axis=-1)\n            # since we want sites to match to themselves\n            np.fill_diagonal(non_nbrs, True)\n            grouped_non_nbrs.append(non_nbrs)\n\n        num_fu = functools.reduce(gcd, map(len, grouped_sites))\n        for size, ms in get_hnf(num_fu):\n            inv_ms = np.linalg.inv(ms)\n\n            # find sets of lattice vectors that are are present in min_vecs\n            dist = inv_ms[:, :, None, :] - min_vecs[None, None, :, :]\n            dist -= np.round(dist)\n            np.abs(dist, dist)\n            is_close = np.all(dist < super_ftol, axis=-1)\n            any_close = np.any(is_close, axis=-1)\n            inds = np.all(any_close, axis=-1)\n\n            for inv_m, m in zip(inv_ms[inds], ms[inds]):\n                new_m = np.dot(inv_m, self.lattice.matrix)\n                ftol = np.divide(tolerance, np.sqrt(np.sum(new_m ** 2, axis=1)))\n\n                valid = True\n                new_coords = []\n                new_sp = []\n                new_props = collections.defaultdict(list)\n                for gsites, gfcoords, non_nbrs in zip(grouped_sites,\n                                                      grouped_fcoords,\n                                                      grouped_non_nbrs):\n                    all_frac = np.dot(gfcoords, m)\n\n                    # calculate grouping of equivalent sites, represented by\n                    # adjacency matrix\n                    fdist = all_frac[None, :, :] - all_frac[:, None, :]\n                    fdist = np.abs(fdist - np.round(fdist))\n                    close_in_prim = np.all(fdist < ftol[None, None, :], axis=-1)\n                    groups = np.logical_and(close_in_prim, non_nbrs)\n\n                    # check that groups are correct\n                    if not np.all(np.sum(groups, axis=0) == size):\n                        valid = False\n                        break\n\n                    # check that groups are all cliques\n                    for g in groups:\n                        if not np.all(groups[g][:, g]):\n                            valid = False\n                            break\n                    if not valid:\n                        break\n\n                    # add the new sites, averaging positions\n                    added = np.zeros(len(gsites))\n                    new_fcoords = all_frac % 1\n                    for i, group in enumerate(groups):\n                        if not added[i]:\n                            added[group] = True\n                            inds = np.where(group)[0]\n                            coords = new_fcoords[inds[0]]\n                            for n, j in enumerate(inds[1:]):\n                                offset = new_fcoords[j] - coords\n                                coords += (offset - np.round(offset)) / (n + 2)\n                            new_sp.append(gsites[inds[0]].species)\n                            for k in gsites[inds[0]].properties:\n                                new_props[k].append(gsites[inds[0]].properties[k])\n                            new_coords.append(coords)\n\n                if valid:\n                    inv_m = np.linalg.inv(m)\n                    new_l = Lattice(np.dot(inv_m, self.lattice.matrix))\n                    s = Structure(new_l, new_sp, new_coords,\n                                  site_properties=new_props,\n                                  coords_are_cartesian=False)\n\n                    # Default behavior\n                    p = s.get_primitive_structure(\n                        tolerance=tolerance, use_site_props=use_site_props,\n                        constrain_latt=constrain_latt\n                    ).get_reduced_structure()\n                    if not constrain_latt:\n                        return p\n\n                    # Only return primitive structures that\n                    # satisfy the restriction condition\n                    p_latt, s_latt = p.lattice, self.lattice\n                    if type(constrain_latt).__name__ == \"list\":\n                        if all([getattr(p_latt, p) == getattr(s_latt, p) for p in constrain_latt]):\n                            return p\n                    elif type(constrain_latt).__name__ == \"dict\":\n                        if all([getattr(p_latt, p) == constrain_latt[p] for p in constrain_latt.keys()]):\n                            return p\n\n        return self.copy()", "response": "This method finds the most primitive structure of the aracite cell."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a dictionary representation of the structure.", "response": "def as_dict(self, verbosity=1, fmt=None, **kwargs):\n        \"\"\"\n        Dict representation of Structure.\n\n        Args:\n            verbosity (int): Verbosity level. Default of 1 includes both\n                direct and cartesian coordinates for all sites, lattice\n                parameters, etc. Useful for reading and for insertion into a\n                database. Set to 0 for an extremely lightweight version\n                that only includes sufficient information to reconstruct the\n                object.\n            fmt (str): Specifies a format for the dict. Defaults to None,\n                which is the default format used in pymatgen. Other options\n                include \"abivars\".\n            **kwargs: Allow passing of other kwargs needed for certain\n            formats, e.g., \"abivars\".\n\n        Returns:\n            JSON serializable dict representation.\n        \"\"\"\n        if fmt == \"abivars\":\n            \"\"\"Returns a dictionary with the ABINIT variables.\"\"\"\n            from pymatgen.io.abinit.abiobjects import structure_to_abivars\n            return structure_to_abivars(self, **kwargs)\n\n        latt_dict = self._lattice.as_dict(verbosity=verbosity)\n        del latt_dict[\"@module\"]\n        del latt_dict[\"@class\"]\n\n        d = {\"@module\": self.__class__.__module__,\n             \"@class\": self.__class__.__name__,\n             \"charge\": self._charge,\n             \"lattice\": latt_dict, \"sites\": []}\n        for site in self:\n            site_dict = site.as_dict(verbosity=verbosity)\n            del site_dict[\"lattice\"]\n            del site_dict[\"@module\"]\n            del site_dict[\"@class\"]\n            d[\"sites\"].append(site_dict)\n        return d"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef from_dict(cls, d, fmt=None):\n        if fmt == \"abivars\":\n            from pymatgen.io.abinit.abiobjects import structure_from_abivars\n            return structure_from_abivars(cls=cls, **d)\n\n        lattice = Lattice.from_dict(d[\"lattice\"])\n        sites = [PeriodicSite.from_dict(sd, lattice) for sd in d[\"sites\"]]\n        charge = d.get(\"charge\", None)\n        return cls.from_sites(sites, charge=charge)", "response": "Reconstitute a Structure object from a dict representation of Structure\n        created using as_dict."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\noutput the structure to a file or string.", "response": "def to(self, fmt=None, filename=None, **kwargs):\n        \"\"\"\n        Outputs the structure to a file or string.\n\n        Args:\n            fmt (str): Format to output to. Defaults to JSON unless filename\n                is provided. If fmt is specifies, it overrides whatever the\n                filename is. Options include \"cif\", \"poscar\", \"cssr\", \"json\".\n                Non-case sensitive.\n            filename (str): If provided, output will be written to a file. If\n                fmt is not specified, the format is determined from the\n                filename. Defaults is None, i.e. string output.\n            \\\\*\\\\*kwargs: Kwargs passthru to relevant methods. E.g., This allows\n                the passing of parameters like symprec to the\n                CifWriter.__init__ method for generation of symmetric cifs.\n\n        Returns:\n            (str) if filename is None. None otherwise.\n        \"\"\"\n        filename = filename or \"\"\n        fmt = \"\" if fmt is None else fmt.lower()\n        fname = os.path.basename(filename)\n\n        if fmt == \"cif\" or fnmatch(fname.lower(), \"*.cif*\"):\n            from pymatgen.io.cif import CifWriter\n            writer = CifWriter(self, **kwargs)\n        elif fmt == \"mcif\" or fnmatch(fname.lower(), \"*.mcif*\"):\n            from pymatgen.io.cif import CifWriter\n            writer = CifWriter(self, write_magmoms=True, **kwargs)\n        elif fmt == \"poscar\" or fnmatch(fname, \"*POSCAR*\"):\n            from pymatgen.io.vasp import Poscar\n            writer = Poscar(self, **kwargs)\n        elif fmt == \"cssr\" or fnmatch(fname.lower(), \"*.cssr*\"):\n            from pymatgen.io.cssr import Cssr\n            writer = Cssr(self, **kwargs)\n        elif fmt == \"json\" or fnmatch(fname.lower(), \"*.json\"):\n            s = json.dumps(self.as_dict())\n            if filename:\n                with zopen(filename, \"wt\") as f:\n                    f.write(\"%s\" % s)\n            return s\n        elif fmt == \"xsf\" or fnmatch(fname.lower(), \"*.xsf*\"):\n            from pymatgen.io.xcrysden import XSF\n            s = XSF(self).to_string()\n            if filename:\n                with zopen(fname, \"wt\", encoding='utf8') as f:\n                    f.write(s)\n            return s\n        elif fmt == 'mcsqs' or fnmatch(fname, \"*rndstr.in*\") \\\n                or fnmatch(fname, \"*lat.in*\") \\\n                or fnmatch(fname, \"*bestsqs*\"):\n            from pymatgen.io.atat import Mcsqs\n            s = Mcsqs(self).to_string()\n            if filename:\n                with zopen(fname, \"wt\", encoding='ascii') as f:\n                    f.write(s)\n            return s\n        else:\n            import ruamel.yaml as yaml\n            if filename:\n                with zopen(filename, \"wt\") as f:\n                    yaml.safe_dump(self.as_dict(), f)\n                return\n            else:\n                return yaml.safe_dump(self.as_dict())\n\n        if filename:\n            writer.write_file(filename)\n        else:\n            return writer.__str__()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nread a structure from a string.", "response": "def from_str(cls, input_string, fmt, primitive=False, sort=False,\n                 merge_tol=0.0):\n        \"\"\"\n        Reads a structure from a string.\n\n        Args:\n            input_string (str): String to parse.\n            fmt (str): A format specification.\n            primitive (bool): Whether to find a primitive cell. Defaults to\n                False.\n            sort (bool): Whether to sort the sites in accordance to the default\n                ordering criteria, i.e., electronegativity.\n            merge_tol (float): If this is some positive number, sites that\n                are within merge_tol from each other will be merged. Usually\n                0.01 should be enough to deal with common numerical issues.\n\n        Returns:\n            IStructure / Structure\n        \"\"\"\n        from pymatgen.io.cif import CifParser\n        from pymatgen.io.vasp import Poscar\n        from pymatgen.io.cssr import Cssr\n        from pymatgen.io.xcrysden import XSF\n        from pymatgen.io.atat import Mcsqs\n        fmt = fmt.lower()\n        if fmt == \"cif\":\n            parser = CifParser.from_string(input_string)\n            s = parser.get_structures(primitive=primitive)[0]\n        elif fmt == \"poscar\":\n            s = Poscar.from_string(input_string, False,\n                                   read_velocities=False).structure\n        elif fmt == \"cssr\":\n            cssr = Cssr.from_string(input_string)\n            s = cssr.structure\n        elif fmt == \"json\":\n            d = json.loads(input_string)\n            s = Structure.from_dict(d)\n        elif fmt == \"yaml\":\n            import ruamel.yaml as yaml\n            d = yaml.safe_load(input_string)\n            s = Structure.from_dict(d)\n        elif fmt == \"xsf\":\n            s = XSF.from_string(input_string).structure\n        elif fmt == \"mcsqs\":\n            s = Mcsqs.structure_from_string(input_string)\n        else:\n            raise ValueError(\"Unrecognized format `%s`!\" % fmt)\n\n        if sort:\n            s = s.get_sorted_structure()\n        if merge_tol:\n            s.merge_sites(merge_tol)\n        return cls.from_sites(s)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nread a structure from a file.", "response": "def from_file(cls, filename, primitive=False, sort=False, merge_tol=0.0):\n        \"\"\"\n        Reads a structure from a file. For example, anything ending in\n        a \"cif\" is assumed to be a Crystallographic Information Format file.\n        Supported formats include CIF, POSCAR/CONTCAR, CHGCAR, LOCPOT,\n        vasprun.xml, CSSR, Netcdf and pymatgen's JSON serialized structures.\n\n        Args:\n            filename (str): The filename to read from.\n            primitive (bool): Whether to convert to a primitive cell\n                Only available for cifs. Defaults to False.\n            sort (bool): Whether to sort sites. Default to False.\n            merge_tol (float): If this is some positive number, sites that\n                are within merge_tol from each other will be merged. Usually\n                0.01 should be enough to deal with common numerical issues.\n\n        Returns:\n            Structure.\n        \"\"\"\n        filename = str(filename)\n        if filename.endswith(\".nc\"):\n            # Read Structure from a netcdf file.\n            from pymatgen.io.abinit.netcdf import structure_from_ncdata\n            s = structure_from_ncdata(filename, cls=cls)\n            if sort:\n                s = s.get_sorted_structure()\n            return s\n\n        from pymatgen.io.lmto import LMTOCtrl\n        from pymatgen.io.vasp import Vasprun, Chgcar\n        from pymatgen.io.exciting import ExcitingInput\n        from monty.io import zopen\n        fname = os.path.basename(filename)\n        with zopen(filename, \"rt\") as f:\n            contents = f.read()\n        if fnmatch(fname.lower(), \"*.cif*\") or fnmatch(fname.lower(), \"*.mcif*\"):\n            return cls.from_str(contents, fmt=\"cif\",\n                                primitive=primitive, sort=sort,\n                                merge_tol=merge_tol)\n        elif fnmatch(fname, \"*POSCAR*\") or fnmatch(fname, \"*CONTCAR*\") or fnmatch(fname, \"*.vasp\"):\n            s = cls.from_str(contents, fmt=\"poscar\",\n                             primitive=primitive, sort=sort,\n                             merge_tol=merge_tol)\n\n        elif fnmatch(fname, \"CHGCAR*\") or fnmatch(fname, \"LOCPOT*\"):\n            s = Chgcar.from_file(filename).structure\n        elif fnmatch(fname, \"vasprun*.xml*\"):\n            s = Vasprun(filename).final_structure\n        elif fnmatch(fname.lower(), \"*.cssr*\"):\n            return cls.from_str(contents, fmt=\"cssr\",\n                                primitive=primitive, sort=sort,\n                                merge_tol=merge_tol)\n        elif fnmatch(fname, \"*.json*\") or fnmatch(fname, \"*.mson*\"):\n            return cls.from_str(contents, fmt=\"json\",\n                                primitive=primitive, sort=sort,\n                                merge_tol=merge_tol)\n        elif fnmatch(fname, \"*.yaml*\"):\n            return cls.from_str(contents, fmt=\"yaml\",\n                                primitive=primitive, sort=sort,\n                                merge_tol=merge_tol)\n        elif fnmatch(fname, \"*.xsf\"):\n            return cls.from_str(contents, fmt=\"xsf\",\n                                primitive=primitive, sort=sort,\n                                merge_tol=merge_tol)\n        elif fnmatch(fname, \"input*.xml\"):\n            return ExcitingInput.from_file(fname).structure\n        elif fnmatch(fname, \"*rndstr.in*\") \\\n                or fnmatch(fname, \"*lat.in*\") \\\n                or fnmatch(fname, \"*bestsqs*\"):\n            return cls.from_str(contents, fmt=\"mcsqs\",\n                                primitive=primitive, sort=sort,\n                                merge_tol=merge_tol)\n        elif fnmatch(fname, \"CTRL*\"):\n            return LMTOCtrl.from_file(filename=filename).structure\n        else:\n            raise ValueError(\"Unrecognized file extension!\")\n        if sort:\n            s = s.get_sorted_structure()\n        if merge_tol:\n            s.merge_sites(merge_tol)\n\n        s.__class__ = cls\n        return s"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the center of mass of the molecule.", "response": "def center_of_mass(self):\n        \"\"\"\n        Center of mass of molecule.\n        \"\"\"\n        center = np.zeros(3)\n        total_weight = 0\n        for site in self:\n            wt = site.species.weight\n            center += site.coords * wt\n            total_weight += wt\n        return center / total_weight"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn two Molecules representing the breaking bond between atoms at index1 and ind2.", "response": "def break_bond(self, ind1, ind2, tol=0.2):\n        \"\"\"\n        Returns two molecules based on breaking the bond between atoms at index\n        ind1 and ind2.\n\n        Args:\n            ind1 (int): Index of first site.\n            ind2 (int): Index of second site.\n            tol (float): Relative tolerance to test. Basically, the code\n                checks if the distance between the sites is less than (1 +\n                tol) * typical bond distances. Defaults to 0.2, i.e.,\n                20% longer.\n\n        Returns:\n            Two Molecule objects representing the two clusters formed from\n            breaking the bond.\n        \"\"\"\n        sites = self._sites\n        clusters = [[sites[ind1]], [sites[ind2]]]\n\n        sites = [site for i, site in enumerate(sites) if i not in (ind1, ind2)]\n\n        def belongs_to_cluster(site, cluster):\n            for test_site in cluster:\n                if CovalentBond.is_bonded(site, test_site, tol=tol):\n                    return True\n            return False\n\n        while len(sites) > 0:\n            unmatched = []\n            for site in sites:\n                for cluster in clusters:\n                    if belongs_to_cluster(site, cluster):\n                        cluster.append(site)\n                        break\n                else:\n                    unmatched.append(site)\n\n            if len(unmatched) == len(sites):\n                raise ValueError(\"Not all sites are matched!\")\n            sites = unmatched\n\n        return (self.__class__.from_sites(cluster)\n                for cluster in clusters)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_covalent_bonds(self, tol=0.2):\n        bonds = []\n        for site1, site2 in itertools.combinations(self._sites, 2):\n            if CovalentBond.is_bonded(site1, site2, tol):\n                bonds.append(CovalentBond(site1, site2))\n        return bonds", "response": "Returns the list of covalent bonds in a molecule."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef from_dict(cls, d):\n        sites = [Site.from_dict(sd) for sd in d[\"sites\"]]\n        charge = d.get(\"charge\", 0)\n        spin_multiplicity = d.get(\"spin_multiplicity\")\n        return cls.from_sites(sites, charge=charge, spin_multiplicity=spin_multiplicity)", "response": "Reconstitute a Molecule object from a dict representation created using\n        as_dict()."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a list of sites that are within a sphere from a point.", "response": "def get_sites_in_sphere(self, pt, r):\n        \"\"\"\n        Find all sites within a sphere from a point.\n\n        Args:\n            pt (3x1 array): Cartesian coordinates of center of sphere.\n            r (float): Radius of sphere.\n\n        Returns:\n            [(site, dist) ...] since most of the time, subsequent processing\n            requires the distance.\n        \"\"\"\n        neighbors = []\n        for site in self._sites:\n            dist = site.distance_from_point(pt)\n            if dist <= r:\n                neighbors.append((site, dist))\n        return neighbors"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_neighbors(self, site, r):\n        nn = self.get_sites_in_sphere(site.coords, r)\n        return [(s, dist) for (s, dist) in nn if site != s]", "response": "Returns a list of neighbors to a site within a sphere of radius r."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn all sites in a shell centered on origin between radii r - dr and r + dr", "response": "def get_neighbors_in_shell(self, origin, r, dr):\n        \"\"\"\n        Returns all sites in a shell centered on origin (coords) between radii\n        r-dr and r+dr.\n\n        Args:\n            origin (3x1 array): Cartesian coordinates of center of sphere.\n            r (float): Inner radius of shell.\n            dr (float): Width of shell.\n\n        Returns:\n            [(site, dist) ...] since most of the time, subsequent processing\n            requires the distance.\n        \"\"\"\n        outer = self.get_sites_in_sphere(origin, r + dr)\n        inner = r - dr\n        return [(site, dist) for (site, dist) in outer if dist > inner]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate a Structure from a Molecule in a box.", "response": "def get_boxed_structure(self, a, b, c, images=(1, 1, 1),\n                            random_rotation=False, min_dist=1, cls=None,\n                            offset=None, no_cross=False):\n        \"\"\"\n        Creates a Structure from a Molecule by putting the Molecule in the\n        center of a orthorhombic box. Useful for creating Structure for\n        calculating molecules using periodic codes.\n\n        Args:\n            a (float): a-lattice parameter.\n            b (float): b-lattice parameter.\n            c (float): c-lattice parameter.\n            images: No. of boxed images in each direction. Defaults to\n                (1, 1, 1), meaning single molecule with 1 lattice parameter\n                in each direction.\n            random_rotation (bool): Whether to apply a random rotation to\n                each molecule. This jumbles all the molecules so that they\n                are not exact images of each other.\n            min_dist (float): The minimum distance that atoms should be from\n                each other. This is only used if random_rotation is True.\n                The randomized rotations are searched such that no two atoms\n                are less than min_dist from each other.\n            cls: The Structure class to instantiate (defaults to pymatgen\n                structure)\n            offset: Translation to offset molecule from center of mass coords\n            no_cross: Whether to forbid molecule coords from extending beyond\n                boundary of box.\n\n        Returns:\n            Structure containing molecule in a box.\n        \"\"\"\n        if offset is None:\n            offset = np.array([0, 0, 0])\n\n        coords = np.array(self.cart_coords)\n        x_range = max(coords[:, 0]) - min(coords[:, 0])\n        y_range = max(coords[:, 1]) - min(coords[:, 1])\n        z_range = max(coords[:, 2]) - min(coords[:, 2])\n\n        if a <= x_range or b <= y_range or c <= z_range:\n            raise ValueError(\"Box is not big enough to contain Molecule.\")\n        lattice = Lattice.from_parameters(a * images[0], b * images[1],\n                                          c * images[2],\n                                          90, 90, 90)\n        nimages = images[0] * images[1] * images[2]\n        coords = []\n\n        centered_coords = self.cart_coords - self.center_of_mass + offset\n\n        for i, j, k in itertools.product(list(range(images[0])),\n                                         list(range(images[1])),\n                                         list(range(images[2]))):\n            box_center = [(i + 0.5) * a, (j + 0.5) * b, (k + 0.5) * c]\n            if random_rotation:\n                while True:\n                    op = SymmOp.from_origin_axis_angle(\n                        (0, 0, 0), axis=np.random.rand(3),\n                        angle=random.uniform(-180, 180))\n                    m = op.rotation_matrix\n                    new_coords = np.dot(m, centered_coords.T).T + box_center\n                    if no_cross:\n                        x_max, x_min = max(new_coords[:, 0]), min(new_coords[:, 0])\n                        y_max, y_min = max(new_coords[:, 1]), min(new_coords[:, 1])\n                        z_max, z_min = max(new_coords[:, 2]), min(new_coords[:, 2])\n                        if x_max > a or x_min < 0 or y_max > b or y_min < 0 or z_max > c or z_min < 0:\n                            raise ValueError(\"Molecule crosses boundary of box.\")\n                    if len(coords) == 0:\n                        break\n                    distances = lattice.get_all_distances(\n                        lattice.get_fractional_coords(new_coords),\n                        lattice.get_fractional_coords(coords))\n                    if np.amin(distances) > min_dist:\n                        break\n            else:\n                new_coords = centered_coords + box_center\n                if no_cross:\n                    x_max, x_min = max(new_coords[:, 0]), min(new_coords[:, 0])\n                    y_max, y_min = max(new_coords[:, 1]), min(new_coords[:, 1])\n                    z_max, z_min = max(new_coords[:, 2]), min(new_coords[:, 2])\n                    if x_max > a or x_min < 0 or y_max > b or y_min < 0 or z_max > c or z_min < 0:\n                        raise ValueError(\"Molecule crosses boundary of box.\")\n            coords.extend(new_coords)\n        sprops = {k: v * nimages for k, v in self.site_properties.items()}\n\n        if cls is None:\n            cls = Structure\n\n        return cls(lattice, self.species * nimages, coords,\n                   coords_are_cartesian=True,\n                   site_properties=sprops).get_sorted_structure()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_centered_molecule(self):\n        center = self.center_of_mass\n        new_coords = np.array(self.cart_coords) - center\n        return self.__class__(self.species_and_occu, new_coords,\n                              charge=self._charge,\n                              spin_multiplicity=self._spin_multiplicity,\n                              site_properties=self.site_properties)", "response": "Returns a Molecule centered at the center of mass."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\noutputting the molecule to a file or string.", "response": "def to(self, fmt=None, filename=None):\n        \"\"\"\n        Outputs the molecule to a file or string.\n\n        Args:\n            fmt (str): Format to output to. Defaults to JSON unless filename\n                is provided. If fmt is specifies, it overrides whatever the\n                filename is. Options include \"xyz\", \"gjf\", \"g03\", \"json\". If\n                you have OpenBabel installed, any of the formats supported by\n                OpenBabel. Non-case sensitive.\n            filename (str): If provided, output will be written to a file. If\n                fmt is not specified, the format is determined from the\n                filename. Defaults is None, i.e. string output.\n\n        Returns:\n            (str) if filename is None. None otherwise.\n        \"\"\"\n        from pymatgen.io.xyz import XYZ\n        from pymatgen.io.gaussian import GaussianInput\n        from pymatgen.io.babel import BabelMolAdaptor\n\n        fmt = \"\" if fmt is None else fmt.lower()\n        fname = os.path.basename(filename or \"\")\n        if fmt == \"xyz\" or fnmatch(fname.lower(), \"*.xyz*\"):\n            writer = XYZ(self)\n        elif any([fmt == r or fnmatch(fname.lower(), \"*.{}*\".format(r))\n                  for r in [\"gjf\", \"g03\", \"g09\", \"com\", \"inp\"]]):\n            writer = GaussianInput(self)\n        elif fmt == \"json\" or fnmatch(fname, \"*.json*\") or fnmatch(fname,\n                                                                   \"*.mson*\"):\n            if filename:\n                with zopen(filename, \"wt\", encoding='utf8') as f:\n                    return json.dump(self.as_dict(), f)\n            else:\n                return json.dumps(self.as_dict())\n        elif fmt == \"yaml\" or fnmatch(fname, \"*.yaml*\"):\n            import ruamel.yaml as yaml\n\n            if filename:\n                with zopen(fname, \"wt\", encoding='utf8') as f:\n                    return yaml.safe_dump(self.as_dict(), f)\n            else:\n                return yaml.safe_dump(self.as_dict())\n\n        else:\n            m = re.search(r\"\\.(pdb|mol|mdl|sdf|sd|ml2|sy2|mol2|cml|mrv)\",\n                          fname.lower())\n            if (not fmt) and m:\n                fmt = m.group(1)\n            writer = BabelMolAdaptor(self)\n            return writer.write_file(filename, file_format=fmt)\n\n        if filename:\n            writer.write_file(filename)\n        else:\n            return str(writer)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef from_str(cls, input_string, fmt):\n        from pymatgen.io.xyz import XYZ\n        from pymatgen.io.gaussian import GaussianInput\n        if fmt.lower() == \"xyz\":\n            m = XYZ.from_string(input_string).molecule\n        elif fmt in [\"gjf\", \"g03\", \"g09\", \"com\", \"inp\"]:\n            m = GaussianInput.from_string(input_string).molecule\n        elif fmt == \"json\":\n            d = json.loads(input_string)\n            return cls.from_dict(d)\n        elif fmt == \"yaml\":\n            import ruamel.yaml as yaml\n            d = yaml.safe_load(input_string)\n            return cls.from_dict(d)\n        else:\n            from pymatgen.io.babel import BabelMolAdaptor\n            m = BabelMolAdaptor.from_string(input_string,\n                                            file_format=fmt).pymatgen_mol\n        return cls.from_sites(m)", "response": "Reads the molecule from a string."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreading a Molecule from a file.", "response": "def from_file(cls, filename):\n        \"\"\"\n        Reads a molecule from a file. Supported formats include xyz,\n        gaussian input (gjf|g03|g09|com|inp), Gaussian output (.out|and\n        pymatgen's JSON serialized molecules. Using openbabel,\n        many more extensions are supported but requires openbabel to be\n        installed.\n\n        Args:\n            filename (str): The filename to read from.\n\n        Returns:\n            Molecule\n        \"\"\"\n        filename = str(filename)\n        from pymatgen.io.gaussian import GaussianOutput\n        with zopen(filename) as f:\n            contents = f.read()\n        fname = filename.lower()\n        if fnmatch(fname, \"*.xyz*\"):\n            return cls.from_str(contents, fmt=\"xyz\")\n        elif any([fnmatch(fname.lower(), \"*.{}*\".format(r))\n                  for r in [\"gjf\", \"g03\", \"g09\", \"com\", \"inp\"]]):\n            return cls.from_str(contents, fmt=\"g09\")\n        elif any([fnmatch(fname.lower(), \"*.{}*\".format(r))\n                  for r in [\"out\", \"lis\", \"log\"]]):\n            return GaussianOutput(filename).final_structure\n        elif fnmatch(fname, \"*.json*\") or fnmatch(fname, \"*.mson*\"):\n            return cls.from_str(contents, fmt=\"json\")\n        elif fnmatch(fname, \"*.yaml*\"):\n            return cls.from_str(contents, fmt=\"yaml\")\n        else:\n            from pymatgen.io.babel import BabelMolAdaptor\n            m = re.search(r\"\\.(pdb|mol|mdl|sdf|sd|ml2|sy2|mol2|cml|mrv)\",\n                          filename.lower())\n            if m:\n                new = BabelMolAdaptor.from_file(filename,\n                                                m.group(1)).pymatgen_mol\n                new.__class__ = cls\n                return new\n\n        raise ValueError(\"Unrecognized file extension!\")"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef append(self, species, coords, coords_are_cartesian=False,\n               validate_proximity=False, properties=None):\n        \"\"\"\n        Append a site to the structure.\n\n        Args:\n            species: Species of inserted site\n            coords (3x1 array): Coordinates of inserted site\n            coords_are_cartesian (bool): Whether coordinates are cartesian.\n                Defaults to False.\n            validate_proximity (bool): Whether to check if inserted site is\n                too close to an existing site. Defaults to False.\n            properties (dict): Properties of the site.\n\n        Returns:\n            New structure with inserted site.\n        \"\"\"\n        return self.insert(len(self), species, coords,\n                           coords_are_cartesian=coords_are_cartesian,\n                           validate_proximity=validate_proximity,\n                           properties=properties)", "response": "Append a site to the structure."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ninserting a site into the structure.", "response": "def insert(self, i, species, coords, coords_are_cartesian=False,\n               validate_proximity=False, properties=None):\n        \"\"\"\n        Insert a site to the structure.\n\n        Args:\n            i (int): Index to insert site\n            species (species-like): Species of inserted site\n            coords (3x1 array): Coordinates of inserted site\n            coords_are_cartesian (bool): Whether coordinates are cartesian.\n                Defaults to False.\n            validate_proximity (bool): Whether to check if inserted site is\n                too close to an existing site. Defaults to False.\n            properties (dict): Properties associated with the site.\n\n        Returns:\n            New structure with inserted site.\n        \"\"\"\n        if not coords_are_cartesian:\n            new_site = PeriodicSite(species, coords, self._lattice,\n                                    properties=properties)\n        else:\n            frac_coords = self._lattice.get_fractional_coords(coords)\n            new_site = PeriodicSite(species, frac_coords, self._lattice,\n                                    properties=properties)\n\n        if validate_proximity:\n            for site in self:\n                if site.distance(new_site) < self.DISTANCE_TOLERANCE:\n                    raise ValueError(\"New site is too close to an existing \"\n                                     \"site!\")\n\n        self._sites.insert(i, new_site)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef replace(self, i, species, coords=None, coords_are_cartesian=False,\n                properties=None):\n        \"\"\"\n        Replace a single site. Takes either a species or a dict of species and\n        occupations.\n\n        Args:\n            i (int): Index of the site in the _sites list.\n            species (species-like): Species of replacement site\n            coords (3x1 array): Coordinates of replacement site. If None,\n                the current coordinates are assumed.\n            coords_are_cartesian (bool): Whether coordinates are cartesian.\n                Defaults to False.\n            properties (dict): Properties associated with the site.\n        \"\"\"\n        if coords is None:\n            frac_coords = self[i].frac_coords\n        elif coords_are_cartesian:\n            frac_coords = self._lattice.get_fractional_coords(coords)\n        else:\n            frac_coords = coords\n\n        new_site = PeriodicSite(species, frac_coords, self._lattice,\n                                properties=properties)\n        self._sites[i] = new_site", "response": "Replaces a single site in the _sites list."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef substitute(self, index, func_grp, bond_order=1):\n\n        # Find the nearest neighbor that is not a terminal atom.\n        all_non_terminal_nn = []\n        for nn, dist in self.get_neighbors(self[index], 3):\n            # Check that the nn has neighbors within a sensible distance but\n            # is not the site being substituted.\n            for inn, dist2 in self.get_neighbors(nn, 3):\n                if inn != self[index] and \\\n                                dist2 < 1.2 * get_bond_length(nn.specie, inn.specie):\n                    all_non_terminal_nn.append((nn, dist))\n                    break\n\n        if len(all_non_terminal_nn) == 0:\n            raise RuntimeError(\"Can't find a non-terminal neighbor to attach\"\n                               \" functional group to.\")\n\n        non_terminal_nn = min(all_non_terminal_nn, key=lambda d: d[1])[0]\n\n        # Set the origin point to be the coordinates of the nearest\n        # non-terminal neighbor.\n        origin = non_terminal_nn.coords\n\n        # Pass value of functional group--either from user-defined or from\n        # functional.json\n        if isinstance(func_grp, Molecule):\n            func_grp = func_grp\n        else:\n            # Check to see whether the functional group is in database.\n            if func_grp not in FunctionalGroups:\n                raise RuntimeError(\"Can't find functional group in list. \"\n                                   \"Provide explicit coordinate instead\")\n            else:\n                func_grp = FunctionalGroups[func_grp]\n\n        # If a bond length can be found, modify func_grp so that the X-group\n        # bond length is equal to the bond length.\n        try:\n            bl = get_bond_length(non_terminal_nn.specie, func_grp[1].specie,\n                                 bond_order=bond_order)\n        # Catches for case of incompatibility between Element(s) and Specie(s)\n        except TypeError:\n            bl = None\n\n        if bl is not None:\n            func_grp = func_grp.copy()\n            vec = func_grp[0].coords - func_grp[1].coords\n            vec /= np.linalg.norm(vec)\n            func_grp[0] = \"X\", func_grp[1].coords + float(bl) * vec\n\n        # Align X to the origin.\n        x = func_grp[0]\n        func_grp.translate_sites(list(range(len(func_grp))), origin - x.coords)\n\n        # Find angle between the attaching bond and the bond to be replaced.\n        v1 = func_grp[1].coords - origin\n        v2 = self[index].coords - origin\n        angle = get_angle(v1, v2)\n\n        if 1 < abs(angle % 180) < 179:\n            # For angles which are not 0 or 180, we perform a rotation about\n            # the origin along an axis perpendicular to both bonds to align\n            # bonds.\n            axis = np.cross(v1, v2)\n            op = SymmOp.from_origin_axis_angle(origin, axis, angle)\n            func_grp.apply_operation(op)\n        elif abs(abs(angle) - 180) < 1:\n            # We have a 180 degree angle. Simply do an inversion about the\n            # origin\n            for i in range(len(func_grp)):\n                func_grp[i] = (func_grp[i].species,\n                               origin - (func_grp[i].coords - origin))\n\n        # Remove the atom to be replaced, and add the rest of the functional\n        # group.\n        del self[index]\n        for site in func_grp[1:]:\n            s_new = PeriodicSite(site.species, site.coords,\n                                 self.lattice, coords_are_cartesian=True)\n            self._sites.append(s_new)", "response": "Substitute atom at index with a functional group."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef remove_species(self, species):\n        new_sites = []\n        species = [get_el_sp(s) for s in species]\n\n        for site in self._sites:\n            new_sp_occu = {sp: amt for sp, amt in site.species.items()\n                           if sp not in species}\n            if len(new_sp_occu) > 0:\n                new_sites.append(PeriodicSite(\n                    new_sp_occu, site.frac_coords, self._lattice,\n                    properties=site.properties))\n        self._sites = new_sites", "response": "Removes all occurrences of several species from a structure."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef remove_sites(self, indices):\n        self._sites = [s for i, s in enumerate(self._sites)\n                       if i not in indices]", "response": "Removes sites with at indices."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\napplies a symmetry operation to the structure and returns the new structure.", "response": "def apply_operation(self, symmop, fractional=False):\n        \"\"\"\n        Apply a symmetry operation to the structure and return the new\n        structure. The lattice is operated by the rotation matrix only.\n        Coords are operated in full and then transformed to the new lattice.\n\n        Args:\n            symmop (SymmOp): Symmetry operation to apply.\n            fractional (bool): Whether the symmetry operation is applied in\n                fractional space. Defaults to False, i.e., symmetry operation\n                is applied in cartesian coordinates.\n        \"\"\"\n        if not fractional:\n            self._lattice = Lattice([symmop.apply_rotation_only(row)\n                                     for row in self._lattice.matrix])\n\n            def operate_site(site):\n                new_cart = symmop.operate(site.coords)\n                new_frac = self._lattice.get_fractional_coords(new_cart)\n                return PeriodicSite(site.species, new_frac,\n                                    self._lattice,\n                                    properties=site.properties)\n\n        else:\n            new_latt = np.dot(symmop.rotation_matrix, self._lattice.matrix)\n            self._lattice = Lattice(new_latt)\n\n            def operate_site(site):\n                return PeriodicSite(site.species,\n                                    symmop.operate(site.frac_coords),\n                                    self._lattice,\n                                    properties=site.properties)\n\n        self._sites = [operate_site(s) for s in self._sites]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef modify_lattice(self, new_lattice):\n        self._lattice = new_lattice\n        for site in self._sites:\n            site.lattice = new_lattice", "response": "Modify the lattice of the structure."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\napplies a strain to the lattice.", "response": "def apply_strain(self, strain):\n        \"\"\"\n        Apply a strain to the lattice.\n\n        Args:\n            strain (float or list): Amount of strain to apply. Can be a float,\n                or a sequence of 3 numbers. E.g., 0.01 means all lattice\n                vectors are increased by 1%. This is equivalent to calling\n                modify_lattice with a lattice with lattice parameters that\n                are 1% larger.\n        \"\"\"\n        s = (1 + np.array(strain)) * np.eye(3)\n        self.lattice = Lattice(np.dot(self._lattice.matrix.T, s).T)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef sort(self, key=None, reverse=False):\n        self._sites.sort(key=key, reverse=reverse)", "response": "Sort the structure in place."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef translate_sites(self, indices, vector, frac_coords=True,\n                        to_unit_cell=True):\n        \"\"\"\n        Translate specific sites by some vector, keeping the sites within the\n        unit cell.\n\n        Args:\n            indices: Integer or List of site indices on which to perform the\n                translation.\n            vector: Translation vector for sites.\n            frac_coords (bool): Whether the vector corresponds to fractional or\n                cartesian coordinates.\n            to_unit_cell (bool): Whether new sites are transformed to unit\n                cell\n        \"\"\"\n        if not isinstance(indices, collections.abc.Iterable):\n            indices = [indices]\n\n        for i in indices:\n            site = self._sites[i]\n            if frac_coords:\n                fcoords = site.frac_coords + vector\n            else:\n                fcoords = self._lattice.get_fractional_coords(\n                    site.coords + vector)\n            if to_unit_cell:\n                fcoords = np.mod(fcoords, 1)\n            self._sites[i].frac_coords = fcoords", "response": "Translate specific sites by some vector keeping the sites within the node."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nrotating specific sites by some angle around vector at anchor.", "response": "def rotate_sites(self, indices=None, theta=0, axis=None, anchor=None,\n                     to_unit_cell=True):\n        \"\"\"\n        Rotate specific sites by some angle around vector at anchor.\n\n        Args:\n            indices (list): List of site indices on which to perform the\n                translation.\n            theta (float): Angle in radians\n            axis (3x1 array): Rotation axis vector.\n            anchor (3x1 array): Point of rotation.\n            to_unit_cell (bool): Whether new sites are transformed to unit\n                cell\n        \"\"\"\n\n        from numpy.linalg import norm\n        from numpy import cross, eye\n        from scipy.linalg import expm\n\n        if indices is None:\n            indices = range(len(self))\n\n        if axis is None:\n            axis = [0, 0, 1]\n\n        if anchor is None:\n            anchor = [0, 0, 0]\n\n        anchor = np.array(anchor)\n        axis = np.array(axis)\n\n        theta %= 2 * np.pi\n\n        rm = expm(cross(eye(3), axis / norm(axis)) * theta)\n        for i in indices:\n            site = self._sites[i]\n            coords = ((np.dot(rm, np.array(site.coords - anchor).T)).T + anchor).ravel()\n            new_site = PeriodicSite(\n                site.species, coords, self._lattice,\n                to_unit_cell=to_unit_cell, coords_are_cartesian=True,\n                properties=site.properties)\n            self._sites[i] = new_site"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nperforming a random perturbation of the sites in a structure to break the symmetries.", "response": "def perturb(self, distance):\n        \"\"\"\n        Performs a random perturbation of the sites in a structure to break\n        symmetries.\n\n        Args:\n            distance (float): Distance in angstroms by which to perturb each\n                site.\n        \"\"\"\n\n        def get_rand_vec():\n            # deals with zero vectors.\n            vector = np.random.randn(3)\n            vnorm = np.linalg.norm(vector)\n            return vector / vnorm * distance if vnorm != 0 else get_rand_vec()\n\n        for i in range(len(self._sites)):\n            self.translate_sites([i], get_rand_vec(), frac_coords=False)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating a supercell of the structure with the given scaling matrix.", "response": "def make_supercell(self, scaling_matrix, to_unit_cell=True):\n        \"\"\"\n        Create a supercell.\n\n        Args:\n            scaling_matrix: A scaling matrix for transforming the lattice\n                vectors. Has to be all integers. Several options are possible:\n\n                a. A full 3x3 scaling matrix defining the linear combination\n                   the old lattice vectors. E.g., [[2,1,0],[0,3,0],[0,0,\n                   1]] generates a new structure with lattice vectors a' =\n                   2a + b, b' = 3b, c' = c where a, b, and c are the lattice\n                   vectors of the original structure.\n                b. An sequence of three scaling factors. E.g., [2, 1, 1]\n                   specifies that the supercell should have dimensions 2a x b x\n                   c.\n                c. A number, which simply scales all lattice vectors by the\n                   same factor.\n            to_unit_cell: Whether or not to fall back sites into the unit cell\n        \"\"\"\n        s = self * scaling_matrix\n        if to_unit_cell:\n            for site in s:\n                site.to_unit_cell(in_place=True)\n        self._sites = s.sites\n        self._lattice = s.lattice"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nmerges the site properties of the current object into a list of site properties.", "response": "def merge_sites(self, tol=0.01, mode=\"sum\"):\n        \"\"\"\n        Merges sites (adding occupancies) within tol of each other.\n        Removes site properties.\n\n        Args:\n            tol (float): Tolerance for distance to merge sites.\n            mode (str): Three modes supported. \"delete\" means duplicate sites are\n                deleted. \"sum\" means the occupancies are summed for the sites.\n                \"average\" means that the site is deleted but the properties are averaged\n                Only first letter is considered.\n\n        \"\"\"\n        mode = mode.lower()[0]\n        from scipy.spatial.distance import squareform\n        from scipy.cluster.hierarchy import fcluster, linkage\n\n        d = self.distance_matrix\n        np.fill_diagonal(d, 0)\n        clusters = fcluster(linkage(squareform((d + d.T) / 2)),\n                            tol, 'distance')\n        sites = []\n        for c in np.unique(clusters):\n            inds = np.where(clusters == c)[0]\n            species = self[inds[0]].species\n            coords = self[inds[0]].frac_coords\n            props = self[inds[0]].properties\n            for n, i in enumerate(inds[1:]):\n                sp = self[i].species\n                if mode == \"s\":\n                    species += sp\n                offset = self[i].frac_coords - coords\n                coords = coords + ((offset - np.round(offset)) / (n + 2)).astype(\n                    coords.dtype)\n                for key in props.keys():\n                    if props[key] is not None and self[i].properties[key] != props[key]:\n                        if mode  == 'a' and isinstance(props[key], float):\n                            # update a running total\n                            props[key] = props[key]*(n+1)/(n+2) + self[i].properties[key]/(n+2)\n                        else:\n                            props[key] = None\n                            warnings.warn(\"Sites with different site property %s are merged. \"\n                                        \"So property is set to none\" % key)\n            sites.append(PeriodicSite(species, coords, self.lattice, properties=props))\n\n        self._sites = sites"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef append(self, species, coords, validate_proximity=True, properties=None):\n        return self.insert(len(self), species, coords,\n                           validate_proximity=validate_proximity,\n                           properties=properties)", "response": "Append a site to the molecule."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset the charge and spin multiplicity for the current object.", "response": "def set_charge_and_spin(self, charge, spin_multiplicity=None):\n        \"\"\"\n        Set the charge and spin multiplicity.\n\n        Args:\n            charge (int): Charge for the molecule. Defaults to 0.\n            spin_multiplicity (int): Spin multiplicity for molecule.\n                Defaults to None, which means that the spin multiplicity is\n                set to 1 if the molecule has no unpaired electrons and to 2\n                if there are unpaired electrons.\n        \"\"\"\n        self._charge = charge\n        nelectrons = 0\n        for site in self._sites:\n            for sp, amt in site.species.items():\n                if not isinstance(sp, DummySpecie):\n                    nelectrons += sp.Z * amt\n        nelectrons -= charge\n        self._nelectrons = nelectrons\n        if spin_multiplicity:\n            if (nelectrons + spin_multiplicity) % 2 != 1:\n                raise ValueError(\n                    \"Charge of {} and spin multiplicity of {} is\"\n                    \" not possible for this molecule\".format(\n                        self._charge, spin_multiplicity))\n            self._spin_multiplicity = spin_multiplicity\n        else:\n            self._spin_multiplicity = 1 if nelectrons % 2 == 0 else 2"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef insert(self, i, species, coords, validate_proximity=False,\n               properties=None):\n        \"\"\"\n        Insert a site to the molecule.\n\n        Args:\n            i (int): Index to insert site\n            species: species of inserted site\n            coords (3x1 array): coordinates of inserted site\n            validate_proximity (bool): Whether to check if inserted site is\n                too close to an existing site. Defaults to True.\n            properties (dict): Dict of properties for the Site.\n\n        Returns:\n            New molecule with inserted site.\n        \"\"\"\n        new_site = Site(species, coords, properties=properties)\n        if validate_proximity:\n            for site in self:\n                if site.distance(new_site) < self.DISTANCE_TOLERANCE:\n                    raise ValueError(\"New site is too close to an existing \"\n                                     \"site!\")\n        self._sites.insert(i, new_site)", "response": "Insert a site into the molecule."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nremove all occurrences of a species from a molecule.", "response": "def remove_species(self, species):\n        \"\"\"\n        Remove all occurrences of a species from a molecule.\n\n        Args:\n            species: Species to remove.\n        \"\"\"\n        new_sites = []\n        species = [get_el_sp(sp) for sp in species]\n        for site in self._sites:\n            new_sp_occu = {sp: amt for sp, amt in site.species.items()\n                           if sp not in species}\n            if len(new_sp_occu) > 0:\n                new_sites.append(Site(new_sp_occu, site.coords,\n                                      properties=site.properties))\n        self._sites = new_sites"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nremove sites with at indices.", "response": "def remove_sites(self, indices):\n        \"\"\"\n        Delete sites with at indices.\n\n        Args:\n            indices: Sequence of indices of sites to delete.\n        \"\"\"\n        self._sites = [self._sites[i] for i in range(len(self._sites))\n                       if i not in indices]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ntranslating specific sites by some vector keeping the sites within the current node.", "response": "def translate_sites(self, indices=None, vector=None):\n        \"\"\"\n        Translate specific sites by some vector, keeping the sites within the\n        unit cell.\n\n        Args:\n            indices (list): List of site indices on which to perform the\n                translation.\n            vector (3x1 array): Translation vector for sites.\n        \"\"\"\n        if indices is None:\n            indices = range(len(self))\n        if vector is None:\n            vector == [0, 0, 0]\n        for i in indices:\n            site = self._sites[i]\n            new_site = Site(site.species, site.coords + vector,\n                            properties=site.properties)\n            self._sites[i] = new_site"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\napplying a symmetry operation to the molecule.", "response": "def apply_operation(self, symmop):\n        \"\"\"\n        Apply a symmetry operation to the molecule.\n\n        Args:\n            symmop (SymmOp): Symmetry operation to apply.\n        \"\"\"\n\n        def operate_site(site):\n            new_cart = symmop.operate(site.coords)\n            return Site(site.species, new_cart,\n                        properties=site.properties)\n\n        self._sites = [operate_site(s) for s in self._sites]"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\napplies transformation to the given bulk structure.", "response": "def apply_transformation(self, structure):\n        \"\"\"\n        :param structure (bulk structure to be scaled up - typically conventional unit cell)\n        :return:\n            defect_structure, with charge applied\n        \"\"\"\n        if structure != self.defect.bulk_structure:\n            raise ValueError(\"Defect bulk_structure is not the same as input structure.\")\n\n        def_structure = self.defect.generate_defect_structure(self.scaling_matrix)\n\n        return def_structure"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _create(self, monomer, mon_vector):\n        while self.length != (self.n_units-1):\n            if self.linear_chain:\n                move_direction = np.array(mon_vector) / np.linalg.norm(mon_vector)\n            else:\n                move_direction = self._next_move_direction()\n            self._add_monomer(monomer.copy(), mon_vector, move_direction)", "response": "Create the polymer from the monomer."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\npick a move at random from the list of moves", "response": "def _next_move_direction(self):\n        \"\"\"\n        pick a move at random from the list of moves\n        \"\"\"\n        nmoves = len(self.moves)\n        move = np.random.randint(1, nmoves+1)\n        while self.prev_move == (move + 3) % nmoves:\n            move = np.random.randint(1, nmoves+1)\n        self.prev_move = move\n        return np.array(self.moves[move])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _align_monomer(self, monomer, mon_vector, move_direction):\n        axis = np.cross(mon_vector, move_direction)\n        origin = monomer[self.start].coords\n        angle = get_angle(mon_vector, move_direction)\n        op = SymmOp.from_origin_axis_angle(origin, axis, angle)\n        monomer.apply_operation(op)", "response": "Aligns the monomer with the given mon_vector along the given move direction."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _add_monomer(self, monomer, mon_vector, move_direction):\n        translate_by = self.molecule.cart_coords[self.end] + \\\n                       self.link_distance * move_direction\n        monomer.translate_sites(range(len(monomer)), translate_by)\n        if not self.linear_chain:\n            self._align_monomer(monomer, mon_vector, move_direction)\n        # add monomer if there are no crossings\n        does_cross = False\n        for i, site in enumerate(monomer):\n            try:\n                self.molecule.append(site.specie, site.coords,\n                                     properties=site.properties)\n            except:\n                does_cross = True\n                polymer_length = len(self.molecule)\n                self.molecule.remove_sites(\n                    range(polymer_length - i, polymer_length))\n                break\n        if not does_cross:\n            self.length += 1\n            self.end += len(self.monomer)", "response": "extend the polymer molecule by adding a monomer along mon_vector direction"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _format_param_val(self, param_val):\n        if isinstance(param_val, list):\n            return ' '.join(str(x) for x in param_val)\n        else:\n            return str(param_val)", "response": "Internal method to format values in the packmol parameter dictionaries\nerset."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _set_box(self):\n        net_volume = 0.0\n        for idx, mol in enumerate(self.mols):\n            length = max([np.max(mol.cart_coords[:, i])-np.min(mol.cart_coords[:, i])\n                           for i in range(3)]) + 2.0\n            net_volume += (length**3.0) * float(self.param_list[idx]['number'])\n        length = net_volume**(1.0/3.0)\n        for idx, mol in enumerate(self.mols):\n            self.param_list[idx]['inside box'] = '0.0 0.0 0.0 {} {} {}'.format(\n                length, length, length)", "response": "Set the box size for the molecular assembly."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _write_input(self, input_dir=\".\"):\n        with open(os.path.join(input_dir, self.input_file), 'wt', encoding=\"utf-8\") as inp:\n            for k, v in self.control_params.items():\n                inp.write('{} {}\\n'.format(k, self._format_param_val(v)))\n            # write the structures of the constituent molecules to file and set\n            # the molecule id and the corresponding filename in the packmol\n            # input file.\n            for idx, mol in enumerate(self.mols):\n                filename = os.path.join(\n                    input_dir, '{}.{}'.format(\n                        idx, self.control_params[\"filetype\"])).encode(\"ascii\")\n                # pdb\n                if self.control_params[\"filetype\"] == \"pdb\":\n                    self.write_pdb(mol, filename, num=idx+1)\n                # all other filetypes\n                else:\n                    a = BabelMolAdaptor(mol)\n                    pm = pb.Molecule(a.openbabel_mol)\n                    pm.write(self.control_params[\"filetype\"], filename=filename,\n                             overwrite=True)\n\n                inp.write(\"\\n\")\n                inp.write(\n                    \"structure {}.{}\\n\".format(\n                        os.path.join(input_dir, str(idx)),\n                        self.control_params[\"filetype\"]))\n                for k, v in self.param_list[idx].items():\n                    inp.write('  {} {}\\n'.format(k, self._format_param_val(v)))\n                inp.write('end structure\\n')", "response": "Write the packmol input file to the input directory."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nwrite the input file to the scratch directory run packmol and return the packed molecule.", "response": "def run(self, copy_to_current_on_exit=False, site_property=None):\n        \"\"\"\n        Write the input file to the scratch directory, run packmol and return\n        the packed molecule.\n\n        Args:\n            copy_to_current_on_exit (bool): Whether or not to copy the packmol\n                input/output files from the scratch directory to the current\n                directory.\n            site_property (str): if set then the specified site property\n                for the the final packed molecule will be restored.\n\n        Returns:\n                Molecule object\n        \"\"\"\n        scratch = tempfile.gettempdir()\n        with ScratchDir(scratch, copy_to_current_on_exit=copy_to_current_on_exit) as scratch_dir:\n            self._write_input(input_dir=scratch_dir)\n            packmol_input = open(os.path.join(scratch_dir, self.input_file), 'r')\n            p = Popen(self.packmol_bin, stdin=packmol_input, stdout=PIPE, stderr=PIPE)\n            (stdout, stderr) = p.communicate()\n            output_file = os.path.join(scratch_dir, self.control_params[\"output\"])\n            if os.path.isfile(output_file):\n                packed_mol = BabelMolAdaptor.from_file(output_file,\n                                                       self.control_params[\"filetype\"])\n                packed_mol = packed_mol.pymatgen_mol\n                print(\"packed molecule written to {}\".format(\n                    self.control_params[\"output\"]))\n                if site_property:\n                    packed_mol = self.restore_site_properties(site_property=site_property, filename=output_file)\n                return packed_mol\n            else:\n                print(\"Packmol execution failed\")\n                print(stdout, stderr)\n                return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndumps the molecule into pdb file with custom residue name and number.", "response": "def write_pdb(self, mol, filename, name=None, num=None):\n        \"\"\"\n        dump the molecule into pdb file with custom residue name and number.\n        \"\"\"\n\n        # ugly hack to get around the openbabel issues with inconsistent\n        # residue labelling.\n        scratch = tempfile.gettempdir()\n        with ScratchDir(scratch, copy_to_current_on_exit=False) as _:\n            mol.to(fmt=\"pdb\", filename=\"tmp.pdb\")\n            bma = BabelMolAdaptor.from_file(\"tmp.pdb\", \"pdb\")\n\n        num = num or 1\n        name = name or \"ml{}\".format(num)\n\n        # bma = BabelMolAdaptor(mol)\n        pbm = pb.Molecule(bma._obmol)\n        for i, x in enumerate(pbm.residues):\n            x.OBResidue.SetName(name)\n            x.OBResidue.SetNum(num)\n\n        pbm.write(format=\"pdb\", filename=filename, overwrite=True)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nmapping each residue to the corresponding molecule.", "response": "def _set_residue_map(self):\n        \"\"\"\n        map each residue to the corresponding molecule.\n        \"\"\"\n        self.map_residue_to_mol = {}\n        lookup = {}\n        for idx, mol in enumerate(self.mols):\n            if not mol.formula in lookup:\n                mol.translate_sites(indices=range(len(mol)),\n                                    vector=-mol.center_of_mass)\n                lookup[mol.formula] = mol.copy()\n            self.map_residue_to_mol[\"ml{}\".format(idx + 1)] = lookup[mol.formula]"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconverts list of openbabel atoms to Molecule.", "response": "def convert_obatoms_to_molecule(self, atoms, residue_name=None, site_property=\"ff_map\"):\n        \"\"\"\n        Convert list of openbabel atoms to MOlecule.\n\n        Args:\n            atoms ([OBAtom]): list of OBAtom objects\n            residue_name (str): the key in self.map_residue_to_mol. Usec to\n                restore the site properties in the final packed molecule.\n            site_property (str): the site property to be restored.\n\n        Returns:\n            Molecule object\n        \"\"\"\n\n        restore_site_props = True if residue_name is not None else False\n\n        if restore_site_props and not hasattr(self, \"map_residue_to_mol\"):\n            self._set_residue_map()\n\n        coords = []\n        zs = []\n        for atm in atoms:\n            coords.append(list(atm.coords))\n            zs.append(atm.atomicnum)\n\n        mol = Molecule(zs, coords)\n\n        if restore_site_props:\n\n            props = []\n\n            ref = self.map_residue_to_mol[residue_name].copy()\n\n            # sanity check\n            assert len(mol) == len(ref)\n            assert ref.formula == mol.formula\n\n            # the packed molecules have the atoms in the same order..sigh!\n            for i, site in enumerate(mol):\n                assert site.specie.symbol == ref[i].specie.symbol\n                props.append(getattr(ref[i], site_property))\n\n            mol.add_site_property(site_property, props)\n\n        return mol"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef restore_site_properties(self, site_property=\"ff_map\", filename=None):\n\n        # only for pdb\n        if not self.control_params[\"filetype\"] == \"pdb\":\n            raise ValueError()\n\n        filename = filename or self.control_params[\"output\"]\n        bma = BabelMolAdaptor.from_file(filename, \"pdb\")\n        pbm = pb.Molecule(bma._obmol)\n\n        assert len(pbm.residues) == sum([x[\"number\"]\n                                         for x in self.param_list])\n\n        packed_mol = self.convert_obatoms_to_molecule(\n            pbm.residues[0].atoms, residue_name=pbm.residues[0].name,\n            site_property=site_property)\n\n        for resid in pbm.residues[1:]:\n            mol = self.convert_obatoms_to_molecule(\n                resid.atoms, residue_name=resid.name,\n                site_property=site_property)\n            for site in mol:\n                packed_mol.append(site.species, site.coords,\n                                  properties=site.properties)\n\n        return packed_mol", "response": "Restore the site properties for the final packed molecule."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef run(self):\n        lammps_cmd = self.lammps_bin + ['-in', self.input_filename]\n        print(\"Running: {}\".format(\" \".join(lammps_cmd)))\n        p = Popen(lammps_cmd, stdout=PIPE, stderr=PIPE)\n        (stdout, stderr) = p.communicate()\n        return stdout, stderr", "response": "Write the input files and run LAMMPS."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_el_sp(obj):\n    if isinstance(obj, (Element, Specie, DummySpecie)):\n        return obj\n\n    if isinstance(obj, (list, tuple)):\n        return [get_el_sp(o) for o in obj]\n\n    try:\n        c = float(obj)\n        i = int(c)\n        i = i if i == c else None\n    except (ValueError, TypeError):\n        i = None\n\n    if i is not None:\n        return Element.from_Z(i)\n\n    try:\n        return Specie.from_string(obj)\n    except (ValueError, KeyError):\n        try:\n            return Element(obj)\n        except (ValueError, KeyError):\n            try:\n                return DummySpecie.from_string(obj)\n            except:\n                raise ValueError(\"Can't parse Element or String from type\"\n                                 \" %s: %s.\" % (type(obj), obj))", "response": "Utility method to get an Element or Specie from an arbitrary object."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\naverages ionic radius for element.", "response": "def average_ionic_radius(self):\n        \"\"\"\n        Average ionic radius for element (with units). The average is taken\n        over all oxidation states of the element for which data is present.\n        \"\"\"\n        if \"Ionic radii\" in self._data:\n            radii = self._data[\"Ionic radii\"]\n            return sum(radii.values()) / len(radii)\n        else:\n            return 0"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef average_cationic_radius(self):\n        if \"Ionic radii\" in self._data:\n            radii = [v for k, v in self._data[\"Ionic radii\"].items()\n                     if int(k) > 0]\n            if radii:\n                return sum(radii) / len(radii)\n        return 0", "response": "Average cationic radius for the element."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the ionic radii of the element as a dict of oxidation state ionic radii.", "response": "def ionic_radii(self):\n        \"\"\"\n        All ionic radii of the element as a dict of\n        {oxidation state: ionic radii}. Radii are given in ang.\n        \"\"\"\n        if \"Ionic radii\" in self._data:\n            return {int(k): v for k, v in self._data[\"Ionic radii\"].items()}\n        else:\n            return {}"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nfull electronic structure as tuple.", "response": "def full_electronic_structure(self):\n        \"\"\"\n        Full electronic structure as tuple.\n        E.g., The electronic structure for Fe is represented as:\n        [(1, \"s\", 2), (2, \"s\", 2), (2, \"p\", 6), (3, \"s\", 2), (3, \"p\", 6),\n        (3, \"d\", 6), (4, \"s\", 2)]\n        \"\"\"\n        estr = self._data[\"Electronic structure\"]\n\n        def parse_orbital(orbstr):\n            m = re.match(r\"(\\d+)([spdfg]+)<sup>(\\d+)</sup>\", orbstr)\n            if m:\n                return int(m.group(1)), m.group(2), int(m.group(3))\n            return orbstr\n\n        data = [parse_orbital(s) for s in estr.split(\".\")]\n        if data[0][0] == \"[\":\n            sym = data[0].replace(\"[\", \"\").replace(\"]\", \"\")\n            data = Element(sym).full_electronic_structure + data[1:]\n        return data"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef valence(self):\n        # the number of valence of noble gas is 0\n        if self.group == 18:\n            return (np.nan, 0)\n\n        L_symbols = 'SPDFGHIKLMNOQRTUVWXYZ'\n        valence = []\n        full_electron_config = self.full_electronic_structure\n        for _, l_symbol, ne in full_electron_config[::-1]:\n            l = L_symbols.lower().index(l_symbol)\n            if ne < (2 * l + 1) * 2:\n                valence.append((l, ne))\n        if len(valence) > 1:\n            raise ValueError(\"Ambiguous valence\")\n\n        return valence[0]", "response": "Get the valence of the noble gas from the full electronic structure."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef term_symbols(self):\n        L_symbols = 'SPDFGHIKLMNOQRTUVWXYZ'\n\n        L, v_e = self.valence\n\n        # for one electron in subshell L\n        ml = list(range(-L, L + 1))\n        ms = [1 / 2, -1 / 2]\n        # all possible configurations of ml,ms for one e in subshell L\n        ml_ms = list(product(ml, ms))\n\n        # Number of possible configurations for r electrons in subshell L.\n        n = (2 * L + 1) * 2\n        # the combination of n_e electrons configurations\n        # C^{n}_{n_e}\n        e_config_combs = list(combinations(range(n), v_e))\n\n        # Total ML = sum(ml1, ml2), Total MS = sum(ms1, ms2)\n        TL = [sum([ml_ms[comb[e]][0] for e in range(v_e)])\n              for comb in e_config_combs]\n        TS = [sum([ml_ms[comb[e]][1] for e in range(v_e)])\n              for comb in e_config_combs]\n        comb_counter = Counter([r for r in zip(TL, TS)])\n\n        term_symbols = []\n        while sum(comb_counter.values()) > 0:\n            # Start from the lowest freq combination,\n            # which corresponds to largest abs(L) and smallest abs(S)\n            L, S = min(comb_counter)\n\n            J = list(np.arange(abs(L - S), abs(L) + abs(S) + 1))\n            term_symbols.append([str(int(2 * (abs(S)) + 1))\n                                 + L_symbols[abs(L)]\n                                 + str(j) for j in J])\n            # Without J\n            # term_symbols.append(str(int(2 * (abs(S)) + 1)) \\\n            #                     + L_symbols[abs(L)])\n\n            # Delete all configurations included in this term\n            for ML in range(-L, L - 1, -1):\n                for MS in np.arange(S, -S + 1, 1):\n                    if (ML, MS) in comb_counter:\n\n                        comb_counter[(ML, MS)] -= 1\n                        if comb_counter[(ML, MS)] == 0:\n                            del comb_counter[(ML, MS)]\n        return term_symbols", "response": "Returns a list of all possible Russell - Saunders term symbols of the current locale."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef ground_state_term_symbol(self):\n        L_symbols = 'SPDFGHIKLMNOQRTUVWXYZ'\n\n        term_symbols = self.term_symbols\n        term_symbol_flat = {term: {\"multiplicity\": int(term[0]),\n                                   \"L\": L_symbols.index(term[1]),\n                                   \"J\": float(term[2:])}\n                            for term in sum(term_symbols, [])}\n\n        multi = [int(item['multiplicity'])\n                 for terms, item in term_symbol_flat.items()]\n        max_multi_terms = {symbol: item\n                           for symbol, item in term_symbol_flat.items()\n                           if item['multiplicity'] == max(multi)}\n\n        Ls = [item['L'] for terms, item in max_multi_terms.items()]\n        max_L_terms = {symbol: item\n                       for symbol, item in term_symbol_flat.items()\n                       if item['L'] == max(Ls)}\n\n        J_sorted_terms = sorted(max_L_terms.items(),\n                                key=lambda k: k[1]['J'])\n        L, v_e = self.valence\n        if v_e <= (2 * L + 1):\n            return J_sorted_terms[0][0]\n        else:\n            return J_sorted_terms[-1][0]", "response": "Returns the ground state term symbol that is selected based on Hund s Rule s TermSymbol."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef from_Z(z: int):\n        for sym, data in _pt_data.items():\n            if data[\"Atomic no\"] == z:\n                return Element(sym)\n        raise ValueError(\"No element with this atomic number %s\" % z)", "response": "Get an element from an atomic number."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning an element from a row and group number.", "response": "def from_row_and_group(row: int, group: int):\n        \"\"\"\n        Returns an element from a row and group number.\n\n        Args:\n            row (int): Row number\n            group (int): Group number\n\n        .. note::\n            The 18 group number system is used, i.e., Noble gases are group 18.\n        \"\"\"\n        for sym in _pt_data.keys():\n            el = Element(sym)\n            if el.row == row and el.group == group:\n                return el\n        raise ValueError(\"No element with this row and group!\")"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef row(self):\n        z = self.Z\n        total = 0\n        if 57 <= z <= 71:\n            return 8\n        elif 89 <= z <= 103:\n            return 9\n\n        for i in range(len(_pt_row_sizes)):\n            total += _pt_row_sizes[i]\n            if total >= z:\n                return i + 1\n        return 8", "response": "Returns the periodic table row of the element."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef group(self):\n        z = self.Z\n        if z == 1:\n            return 1\n        if z == 2:\n            return 18\n        if 3 <= z <= 18:\n            if (z - 2) % 8 == 0:\n                return 18\n            elif (z - 2) % 8 <= 2:\n                return (z - 2) % 8\n            else:\n                return 10 + (z - 2) % 8\n\n        if 19 <= z <= 54:\n            if (z - 18) % 18 == 0:\n                return 18\n            else:\n                return (z - 18) % 18\n\n        if (z - 54) % 32 == 0:\n            return 18\n        elif (z - 54) % 32 >= 18:\n            return (z - 54) % 32 - 14\n        else:\n            return (z - 54) % 32", "response": "Returns the periodic table group of the element."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the block character s p d f", "response": "def block(self):\n        \"\"\"\n        Return the block character \"s,p,d,f\"\n        \"\"\"\n        if (self.is_actinoid or self.is_lanthanoid) and self.Z not in [71, 103]:\n            return \"f\"\n        elif self.is_actinoid or self.is_lanthanoid:\n            return \"d\"\n        elif self.group in [1, 2]:\n            return \"s\"\n        elif self.group in range(13, 19):\n            return \"p\"\n        elif self.group in range(3, 13):\n            return \"d\"\n        raise ValueError(\"unable to determine block\")"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef is_transition_metal(self):\n        ns = list(range(21, 31))\n        ns.extend(list(range(39, 49)))\n        ns.append(57)\n        ns.extend(list(range(72, 81)))\n        ns.append(89)\n        ns.extend(list(range(104, 113)))\n        return self.Z in ns", "response": "True if the element is a transition metal."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef nmr_quadrupole_moment(self):\n        return {k: FloatWithUnit(v, \"mbarn\")\n                for k, v in self.data.get(\"NMR Quadrupole Moment\", {}).items()}", "response": "Get a dictionary of nuclear electric quadrupole moment in units of\n        e*millibarns for various isotopes\n       "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a dict representation of the object.", "response": "def as_dict(self):\n        \"\"\"\n        Makes Element obey the general json interface used in pymatgen for\n        easier serialization.\n        \"\"\"\n        return {\"@module\": self.__class__.__module__,\n                \"@class\": self.__class__.__name__,\n                \"element\": self.symbol}"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef ionic_radius(self):\n\n        if self._oxi_state in self.ionic_radii:\n            return self.ionic_radii[self._oxi_state]\n        d = self._el.data\n        oxstr = str(int(self._oxi_state))\n        if oxstr in d.get(\"Ionic radii hs\", {}):\n            warnings.warn(\"No default ionic radius for %s. Using hs data.\" %\n                          self)\n            return d[\"Ionic radii hs\"][oxstr]\n        elif oxstr in d.get(\"Ionic radii ls\", {}):\n            warnings.warn(\"No default ionic radius for %s. Using ls data.\" %\n                          self)\n            return d[\"Ionic radii ls\"][oxstr]\n        warnings.warn(\"No ionic radius for {}!\".format(self))\n        return None", "response": "Returns the ionic radius of the current specie. Returns None if data is not present."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef from_string(species_string: str):\n        m = re.search(r\"([A-Z][a-z]*)([0-9.]*)([+\\-])(.*)\", species_string)\n        if m:\n            sym = m.group(1)\n            oxi = 1 if m.group(2) == \"\" else float(m.group(2))\n            oxi = -oxi if m.group(3) == \"-\" else oxi\n            properties = None\n            if m.group(4):\n                toks = m.group(4).replace(\",\", \"\").split(\"=\")\n                properties = {toks[0]: float(toks[1])}\n            return Specie(sym, oxi, properties)\n        else:\n            raise ValueError(\"Invalid Species String\")", "response": "Returns a Specie object from a string representation."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the nuclear electric quadrupole moment in units of millibarns e*millibarns", "response": "def get_nmr_quadrupole_moment(self, isotope=None):\n        \"\"\"\n        Gets the nuclear electric quadrupole moment in units of\n        e*millibarns\n\n        Args:\n            isotope (str): the isotope to get the quadrupole moment for\n                default is None, which gets the lowest mass isotope\n        \"\"\"\n\n        quad_mom = self._el.nmr_quadrupole_moment\n\n        if len(quad_mom) == 0:\n            return 0.0\n\n        if isotope is None:\n            isotopes = list(quad_mom.keys())\n            isotopes.sort(key=lambda x: int(x.split(\"-\")[1]), reverse=False)\n            return quad_mom.get(isotopes[0], 0.0)\n        else:\n            if isotope not in quad_mom:\n                raise ValueError(\"No quadrupole moment for isotope {}\".format(\n                    isotope))\n            return quad_mom.get(isotope, 0.0)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_shannon_radius(self, cn: str, spin: str = \"\",\n                           radius_type: str = \"ionic\"):\n        \"\"\"\n        Get the local environment specific ionic radius for species.\n\n        Args:\n            cn (str): Coordination using roman letters. Supported values are\n                I-IX, as well as IIIPY, IVPY and IVSQ.\n            spin (str): Some species have different radii for different\n                spins. You can get specific values using \"High Spin\" or\n                \"Low Spin\". Leave it as \"\" if not available. If only one spin\n                data is available, it is returned and this spin parameter is\n                ignored.\n            radius_type (str): Either \"crystal\" or \"ionic\" (default).\n\n        Returns:\n            Shannon radius for specie in the specified environment.\n        \"\"\"\n        radii = self._el.data[\"Shannon radii\"]\n        # if cn == 1:\n        #     cn_str = \"I\"\n        # elif cn == 2:\n        #     cn_str = \"II\"\n        # elif cn == 3:\n        #     cn_str = \"III\"\n        # elif cn == 4:\n        #     cn_str = \"IV\"\n        # elif cn == 5:\n        #     cn_str = \"V\"\n        # elif cn == 6:\n        #     cn_str = \"VI\"\n        # elif cn == 7:\n        #     cn_str = \"VII\"\n        # elif cn == 8:\n        #     cn_str = \"VIII\"\n        # elif cn == 9:\n        #     cn_str = \"IX\"\n        # else:\n        #     raise ValueError(\"Invalid coordination number\")\n\n        if len(radii[str(int(self._oxi_state))][cn]) == 1:\n            k, data = list(radii[str(int(self._oxi_state))][cn].items())[0]\n            if k != spin:\n                warnings.warn(\n                    \"Specified spin state of %s not consistent with database \"\n                    \"spin of %s. Only one spin data available, and \"\n                    \"that value is returned.\" % (spin, k)\n                )\n        else: \n            data = radii[str(int(self._oxi_state))][cn][spin]\n        return data[\"%s_radius\" % radius_type]", "response": "Returns the ionic radius for a specific environment."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_crystal_field_spin(self, coordination: str = \"oct\",\n                               spin_config: str = \"high\"):\n        \"\"\"\n        Calculate the crystal field spin based on coordination and spin\n        configuration. Only works for transition metal species.\n\n        Args:\n            coordination (str): Only oct and tet are supported at the moment.\n            spin_config (str): Supported keywords are \"high\" or \"low\".\n\n        Returns:\n            Crystal field spin in Bohr magneton.\n\n        Raises:\n            AttributeError if species is not a valid transition metal or has\n            an invalid oxidation state.\n            ValueError if invalid coordination or spin_config.\n        \"\"\"\n        if coordination not in (\"oct\", \"tet\") or \\\n                spin_config not in (\"high\", \"low\"):\n            raise ValueError(\"Invalid coordination or spin config.\")\n        elec = self.full_electronic_structure\n        if len(elec) < 4 or elec[-1][1] != \"s\" or elec[-2][1] != \"d\":\n            raise AttributeError(\n                \"Invalid element {} for crystal field calculation.\".format(\n                    self.symbol))\n        nelectrons = elec[-1][2] + elec[-2][2] - self.oxi_state\n        if nelectrons < 0 or nelectrons > 10:\n            raise AttributeError(\n                \"Invalid oxidation state {} for element {}\"\n                .format(self.oxi_state, self.symbol))\n        if spin_config == \"high\":\n            return nelectrons if nelectrons <= 5 else 10 - nelectrons\n        elif spin_config == \"low\":\n            if coordination == \"oct\":\n                if nelectrons <= 3:\n                    return nelectrons\n                elif nelectrons <= 6:\n                    return 6 - nelectrons\n                elif nelectrons <= 8:\n                    return nelectrons - 6\n                else:\n                    return 10 - nelectrons\n            elif coordination == \"tet\":\n                if nelectrons <= 2:\n                    return nelectrons\n                elif nelectrons <= 4:\n                    return 4 - nelectrons\n                elif nelectrons <= 7:\n                    return nelectrons - 4\n                else:\n                    return 10 - nelectrons", "response": "Calculates the crystal field spin based on the coordination and spin_config."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a Dummy object from a string representation.", "response": "def from_string(species_string: str):\n        \"\"\"\n        Returns a Dummy from a string representation.\n\n        Args:\n            species_string (str): A string representation of a dummy\n                species, e.g., \"X2+\", \"X3+\".\n\n        Returns:\n            A DummySpecie object.\n\n        Raises:\n            ValueError if species_string cannot be intepreted.\n        \"\"\"\n        m = re.search(r\"([A-Z][a-z]*)([0-9.]*)([+\\-]*)(.*)\", species_string)\n        if m:\n            sym = m.group(1)\n            if m.group(2) == \"\" and m.group(3) == \"\":\n                oxi = 0\n            else:\n                oxi = 1 if m.group(2) == \"\" else float(m.group(2))\n                oxi = -oxi if m.group(3) == \"-\" else oxi\n            properties = None\n            if m.group(4):\n                toks = m.group(4).split(\"=\")\n                properties = {toks[0]: float(toks[1])}\n            return DummySpecie(sym, oxi, properties)\n        raise ValueError(\"Invalid DummySpecies String\")"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a DummySpecie object that can be safely used by a given composition.", "response": "def safe_from_composition(cls, comp: \"Composition\",\n                              oxidation_state: float = 0):\n        \"\"\"\n        Returns a DummySpecie object that can be safely used\n        with (i.e. not present in) a given composition\n        \"\"\"\n        # We don't want to add a DummySpecie with the same\n        # symbol as anything in the composition, even if the\n        # oxidation state is different\n        els = comp.element_composition.elements\n        for c in 'abcdfghijklmnopqrstuvwxyz':\n            if DummySpecie('X' + c) not in els:\n                return DummySpecie('X' + c, oxidation_state)\n        raise ValueError(\"All attempted DummySpecies already \"\n                         \"present in {}\".format(comp))"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nprocess a given defect entry and return a dict of all possible defect corrections and flag as delocalized", "response": "def process_entry(self, defect_entry):\n        \"\"\"\n        Process a given Defect entry with qualifiers given from initialization of class.\n        Order of processing is:\n            1) perform all possible defect corrections with information given\n            2) consider delocalization analyses based on qualifier metrics\n            given initialization of class. If delocalized, flag entry as delocalized\n            3) update corrections to defect entry and flag as del\n\n\n        Corrections are applied based on:\n            i) if free charges are more than free_chg_cutoff then will not apply charge correction,\n                because it no longer is applicable\n            ii) use charge correction set by preferred_cc\n            iii) only use BandFilling correction if use_bandfilling is set to True\n            iv) only use BandEdgeShift correction if use_bandedgeshift is set to True\n        \"\"\"\n        self.perform_all_corrections(defect_entry)\n\n        self.delocalization_analysis(defect_entry)\n\n        # apply corrections based on delocalization analysis\n        corrections = {}\n        skip_charge_corrections = False\n        if \"num_hole_vbm\" in defect_entry.parameters.keys():\n            if (self.free_chg_cutoff < defect_entry.parameters[\"num_hole_vbm\"]) or (\n                self.free_chg_cutoff < defect_entry.parameters[\"num_elec_cbm\"]):\n                print('Will not use charge correction because too many free charges')\n                # TODO: should the potential alignment correction still be used in this scenario?\n                # TODO: with too much charge delocalized should probably not use?\n                skip_charge_corrections = True\n\n        if skip_charge_corrections:\n            corrections.update({'charge_correction': 0.})\n        else:\n            if ('freysoldt' in self.preferred_cc.lower()) and ('freysoldt_meta' in defect_entry.parameters.keys()):\n                frey_meta = defect_entry.parameters['freysoldt_meta']\n                frey_corr = frey_meta[\"freysoldt_electrostatic\"] + frey_meta[\"freysoldt_potential_alignment_correction\"]\n                corrections.update({'charge_correction': frey_corr})\n            elif ('kumagai_meta' in defect_entry.parameters.keys()):\n                kumagai_meta = defect_entry.parameters['kumagai_meta']\n                kumagai_corr = kumagai_meta[\"kumagai_electrostatic\"] + \\\n                    kumagai_meta[\"kumagai_potential_alignment_correction\"]\n                corrections.update({'charge_correction': kumagai_corr})\n            else:\n                print('Could not use any charge correction because insufficient metadata was supplied.')\n\n        if self.use_bandfilling:\n            if \"bandfilling_meta\" in defect_entry.parameters.keys():\n                bfc_corr = defect_entry.parameters[\"bandfilling_meta\"][\"bandfilling_correction\"]\n                corrections.update({'bandfilling_correction': bfc_corr})\n            else:\n                print('Could not use band filling correction because insufficient metadata was supplied.')\n        else:\n            corrections.update({'bandfilling_correction': 0.})\n\n\n        if self.use_bandedgeshift:\n            if \"bandshift_meta\" in defect_entry.parameters.keys():\n                bandfill_meta = defect_entry.parameters[\"bandshift_meta\"]\n                bes_corr = bandfill_meta[\"vbm_shift_correction\"] + bandfill_meta[\"hole_vbm_shift_correction\"] + \\\n                    bandfill_meta[\"elec_cbm_shift_correction\"]\n                corrections.update({'bandedgeshifting_correction': bes_corr})\n\n                # also want to update relevant data for phase diagram\n                defect_entry.parameters.update({\n                    'phasediagram_meta': {\n                        'vbm': defect_entry.parameters['hybrid_vbm'],\n                        'gap': defect_entry.parameters['hybrid_cbm'] - defect_entry.parameters['hybrid_vbm']\n                    }\n                })\n            else:\n                print(\"Could not use band edge shifting correction because insufficient metadata was supplied.\")\n                defect_entry.parameters.update({\n                'phasediagram_meta': {\n                    'vbm': defect_entry.parameters['vbm'],\n                    'gap': defect_entry.parameters['cbm'] - defect_entry.parameters['vbm']\n                    }\n                })\n\n\n        else:  # if not using bandedge shift -> still want to have vbm and gap ready for phase diagram\n            corrections.update({'bandedgeshifting_correction': 0.})\n            defect_entry.parameters.update({\n                'phasediagram_meta': {\n                    'vbm': defect_entry.parameters['vbm'],\n                    'gap': defect_entry.parameters['cbm'] - defect_entry.parameters['vbm']\n                }\n            })\n\n        defect_entry.corrections.update(corrections)\n\n        return defect_entry"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef delocalization_analysis(self, defect_entry):\n        defect_entry.parameters.update({'is_compatible': True}) #this will be switched to False if delocalization is detected\n\n        if 'freysoldt_meta' in defect_entry.parameters.keys():\n            defect_entry = self.is_freysoldt_delocalized(defect_entry)\n        else:\n            print('Insufficient information provided for performing Freysoldt '\n                  'correction delocalization analysis.\\n'\n                  'Cannot perform planar averaged electrostatic potential '\n                  'compatibility analysis.')\n\n\n        if 'kumagai_meta' in defect_entry.parameters.keys():\n            defect_entry = self.is_kumagai_delocalized(defect_entry)\n        else:\n            print('Insufficient information provided for performing Kumagai '\n                  'correction delocalization analysis.\\n'\n                  'Cannot perform atomic site averaged electrostatic '\n                  'potential compatibility analysis.')\n\n\n        if ('final_defect_structure' in defect_entry.parameters.keys()) and \\\n                ('initial_defect_structure' in defect_entry.parameters.keys()) and \\\n                ('sampling_radius' in defect_entry.parameters.keys()):\n            defect_entry = self.is_final_relaxed_structure_delocalized(defect_entry)\n        else:\n            print('Insufficient information provided in defect_entry.parameters. '\n                  'Cannot perform full structure site relaxation compatibility analysis.')\n\n        return defect_entry", "response": "Do delocalization analysis for a single defect entry."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndetermine the distance of space between the slab and the last atom along c", "response": "def get_d(slab):\n    \"\"\"\n    Determine the distance of space between\n    each layer of atoms along c\n    \"\"\"\n    sorted_sites = sorted(slab, key=lambda site: site.frac_coords[2])\n    for i, site in enumerate(sorted_sites):\n        if \"%.6f\" % (site.frac_coords[2]) == \\\n                        \"%.6f\" % (sorted_sites[i + 1].frac_coords[2]):\n            continue\n        else:\n            d = abs(site.frac_coords[2] - \\\n                    sorted_sites[i + 1].frac_coords[2])\n            break\n    return slab.lattice.get_cartesian_coords([0, 0, d])[2]"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_recp_symmetry_operation(structure, symprec=0.01):\n    recp_lattice = structure.lattice.reciprocal_lattice_crystallographic\n    # get symmetry operations from input conventional unit cell\n    # Need to make sure recp lattice is big enough, otherwise symmetry\n    # determination will fail. We set the overall volume to 1.\n    recp_lattice = recp_lattice.scale(1)\n    recp = Structure(recp_lattice, [\"H\"], [[0, 0, 0]])\n    # Creates a function that uses the symmetry operations in the\n    # structure to find Miller indices that might give repetitive slabs\n    analyzer = SpacegroupAnalyzer(recp, symprec=symprec)\n    recp_symmops = analyzer.get_symmetry_operations()\n\n    return recp_symmops", "response": "Returns a function that returns the symmetry operations of the reciprocal lattice and the Miller indices that might give repetitive slabs."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_symmetrically_distinct_miller_indices(structure, max_index):\n\n    r = list(range(-max_index, max_index + 1))\n    r.reverse()\n\n    # First we get a list of all hkls for conventional (including equivalent)\n    conv_hkl_list = [miller for miller in itertools.product(r, r, r) if any([i != 0 for i in miller])]\n\n    sg = SpacegroupAnalyzer(structure)\n    # Get distinct hkl planes from the rhombohedral setting if trigonal\n    if sg.get_crystal_system() == \"trigonal\":\n        transf = sg.get_conventional_to_primitive_transformation_matrix()\n        miller_list = [hkl_transformation(transf, hkl) for hkl in conv_hkl_list]\n        prim_structure = SpacegroupAnalyzer(structure).get_primitive_standard_structure()\n        symm_ops = get_recp_symmetry_operation(prim_structure)\n    else:\n        miller_list = conv_hkl_list\n        symm_ops = get_recp_symmetry_operation(structure)\n\n    unique_millers, unique_millers_conv = [], []\n\n    def is_already_analyzed(miller_index):\n        for op in symm_ops:\n            if in_coord_list(unique_millers, op.operate(miller_index)):\n                return True\n        return False\n\n    for i, miller in enumerate(miller_list):\n        d = abs(reduce(gcd, miller))\n        miller = tuple([int(i / d) for i in miller])\n        if not is_already_analyzed(miller):\n            if sg.get_crystal_system() == \"trigonal\":\n                # Now we find the distinct primitive hkls using\n                # the primitive symmetry operations and their\n                # corresponding hkls in the conventional setting\n                unique_millers.append(miller)\n                d = abs(reduce(gcd, conv_hkl_list[i]))\n                cmiller = tuple([int(i / d) for i in conv_hkl_list[i]])\n                unique_millers_conv.append(cmiller)\n            else:\n                unique_millers.append(miller)\n                unique_millers_conv.append(miller)\n\n    return unique_millers_conv", "response": "Returns all symmetrically distinct indices below a certain max - index for a given structure."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the Miller index from setting A to B using a transformation matrix .", "response": "def hkl_transformation(transf, miller_index):\n    \"\"\"\n    Returns the Miller index from setting\n    A to B using a transformation matrix\n    Args:\n        transf (3x3 array): The transformation matrix\n            that transforms a lattice of A to B\n        miller_index ([h, k, l]): Miller index to transform to setting B\n    \"\"\"\n    # Get a matrix of whole numbers (ints)\n    lcm = lambda a, b: a * b // math.gcd(a, b)\n    reduced_transf = reduce(lcm, [int(1 / i) for i in itertools.chain(*transf) if i != 0]) * transf\n    reduced_transf = reduced_transf.astype(int)\n\n    # perform the transformation\n    t_hkl = np.dot(reduced_transf, miller_index)\n    d = abs(reduce(gcd, t_hkl))\n    t_hkl = np.array([int(i / d) for i in t_hkl])\n\n    # get mostly positive oriented Miller index\n    if len([i for i in t_hkl if i < 0]) > 1:\n        t_hkl *= -1\n\n    return tuple(t_hkl)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef generate_all_slabs(structure, max_index, min_slab_size, min_vacuum_size,\n                       bonds=None, tol=1e-3, max_broken_bonds=0,\n                       lll_reduce=False, center_slab=False, primitive=True,\n                       max_normal_search=None, symmetrize=False, repair=False,\n                       include_reconstructions=False, in_unit_planes=False):\n    \"\"\"\n    A function that finds all different slabs up to a certain miller index.\n    Slabs oriented under certain Miller indices that are equivalent to other\n    slabs in other Miller indices are filtered out using symmetry operations\n    to get rid of any repetitive slabs. For example, under symmetry operations,\n    CsCl has equivalent slabs in the (0,0,1), (0,1,0), and (1,0,0) direction.\n\n    Args:\n        structure (Structure): Initial input structure. Note that to\n                ensure that the miller indices correspond to usual\n                crystallographic definitions, you should supply a conventional\n                unit cell structure.\n        max_index (int): The maximum Miller index to go up to.\n        min_slab_size (float): In Angstroms\n        min_vacuum_size (float): In Angstroms\n        bonds ({(specie1, specie2): max_bond_dist}: bonds are\n            specified as a dict of tuples: float of specie1, specie2\n            and the max bonding distance. For example, PO4 groups may be\n            defined as {(\"P\", \"O\"): 3}.\n        tol (float): Threshold parameter in fcluster in order to check\n            if two atoms are lying on the same plane. Default thresh set\n            to 0.1 Angstrom in the direction of the surface normal.\n        max_broken_bonds (int): Maximum number of allowable broken bonds\n            for the slab. Use this to limit # of slabs (some structures\n            may have a lot of slabs). Defaults to zero, which means no\n            defined bonds must be broken.\n        lll_reduce (bool): Whether to perform an LLL reduction on the\n            eventual structure.\n        center_slab (bool): Whether to center the slab in the cell with\n            equal vacuum spacing from the top and bottom.\n        primitive (bool): Whether to reduce any generated slabs to a\n            primitive cell (this does **not** mean the slab is generated\n            from a primitive cell, it simply means that after slab\n            generation, we attempt to find shorter lattice vectors,\n            which lead to less surface area and smaller cells).\n        max_normal_search (int): If set to a positive integer, the code will\n            conduct a search for a normal lattice vector that is as\n            perpendicular to the surface as possible by considering\n            multiples linear combinations of lattice vectors up to\n            max_normal_search. This has no bearing on surface energies,\n            but may be useful as a preliminary step to generating slabs\n            for absorption and other sizes. It is typical that this will\n            not be the smallest possible cell for simulation. Normality\n            is not guaranteed, but the oriented cell will have the c\n            vector as normal as possible (within the search range) to the\n            surface. A value of up to the max absolute Miller index is\n            usually sufficient.\n        symmetrize (bool): Whether or not to ensure the surfaces of the\n            slabs are equivalent.\n        repair (bool): Whether to repair terminations with broken bonds\n            or just omit them\n        include_reconstructions (bool): Whether to include reconstructed\n            slabs available in the reconstructions_archive.json file.\n    \"\"\"\n    all_slabs = []\n\n    for miller in get_symmetrically_distinct_miller_indices(structure,\n                                                            max_index):\n        gen = SlabGenerator(structure, miller, min_slab_size,\n                            min_vacuum_size, lll_reduce=lll_reduce,\n                            center_slab=center_slab, primitive=primitive,\n                            max_normal_search=max_normal_search,\n                            in_unit_planes=in_unit_planes)\n        slabs = gen.get_slabs(bonds=bonds, tol=tol, symmetrize=symmetrize,\n                              max_broken_bonds=max_broken_bonds, repair=repair)\n\n        if len(slabs) > 0:\n            logger.debug(\"%s has %d slabs... \" % (miller, len(slabs)))\n            all_slabs.extend(slabs)\n\n    if include_reconstructions:\n        sg = SpacegroupAnalyzer(structure)\n        symbol = sg.get_space_group_symbol()\n        # enumerate through all posisble reconstructions in the\n        # archive available for this particular structure (spacegroup)\n        for name, instructions in reconstructions_archive.items():\n            if \"base_reconstruction\" in instructions.keys():\n                instructions = reconstructions_archive[instructions[\"base_reconstruction\"]]\n            if instructions[\"spacegroup\"][\"symbol\"] == symbol:\n                # check if this reconstruction has a max index\n                # equal or less than the given max index\n                if max(instructions[\"miller_index\"]) > max_index:\n                    continue\n                recon = ReconstructionGenerator(structure, min_slab_size,\n                                                min_vacuum_size, name)\n                all_slabs.extend(recon.build_slabs())\n\n    return all_slabs", "response": "Generates all the slab tables that are part of a particular Miller index."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nfunction to get the regions of the slab.", "response": "def get_slab_regions(slab, blength=3.5):\n    \"\"\"\n    Function to get the ranges of the slab regions. Useful for discerning where\n    the slab ends and vacuum begins if the slab is not fully within the cell\n    Args:\n        slab (Structure): Structure object modelling the surface\n        blength (float, Ang): The bondlength between atoms. You generally\n            want this value to be larger than the actual bondlengths in\n            order to find atoms that are part of the slab\n    \"\"\"\n\n    fcoords, indices, all_indices = [], [], []\n    for site in slab:\n        # find sites with c < 0 (noncontiguous)\n        neighbors = slab.get_neighbors(site, blength, include_index=True,\n                                       include_image=True)\n        for nn in neighbors:\n            if nn[0].frac_coords[2] < 0:\n                # sites are noncontiguous within cell\n                fcoords.append(nn[0].frac_coords[2])\n                indices.append(nn[-2])\n                if nn[-2] not in all_indices:\n                    all_indices.append(nn[-2])\n\n    if fcoords:\n        # If slab is noncontiguous, locate the lowest\n        # site within the upper region of the slab\n        while fcoords:\n            last_fcoords = copy.copy(fcoords)\n            last_indices = copy.copy(indices)\n            site = slab[indices[fcoords.index(min(fcoords))]]\n            neighbors = slab.get_neighbors(site, blength, include_index=True,\n                                           include_image=True)\n            fcoords, indices = [], []\n            for nn in neighbors:\n                if 1 > nn[0].frac_coords[2] > 0 and \\\n                                nn[0].frac_coords[2] < site.frac_coords[2]:\n                    # sites are noncontiguous within cell\n                    fcoords.append(nn[0].frac_coords[2])\n                    indices.append(nn[-2])\n                    if nn[-2] not in all_indices:\n                        all_indices.append(nn[-2])\n\n        # Now locate the highest site within the lower region of the slab\n        upper_fcoords = []\n        for site in slab:\n            if all([nn[-1] not in all_indices for nn in\n                    slab.get_neighbors(site, blength,\n                                       include_index=True)]):\n                upper_fcoords.append(site.frac_coords[2])\n        coords = copy.copy(last_fcoords) if not fcoords else copy.copy(fcoords)\n        min_top = slab[last_indices[coords.index(min(coords))]].frac_coords[2]\n        ranges = [[0, max(upper_fcoords)], [min_top, 1]]\n    else:\n        # If the entire slab region is within the slab cell, just\n        # set the range as the highest and lowest site in the slab\n        sorted_sites = sorted(slab, key=lambda site: site.frac_coords[2])\n        ranges = [[sorted_sites[0].frac_coords[2],\n                   sorted_sites[-1].frac_coords[2]]]\n\n    return ranges"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the Miller index of a plane from a list of site coordinates.", "response": "def miller_index_from_sites(lattice, coords, coords_are_cartesian=True,\n                            round_dp=4, verbose=True):\n    \"\"\"\n    Get the Miller index of a plane from a list of site coordinates.\n\n    A minimum of 3 sets of coordinates are required. If more than 3 sets of\n    coordinates are given, the best plane that minimises the distance to all\n    points will be calculated.\n\n    Args:\n        lattice (list or Lattice): A 3x3 lattice matrix or `Lattice` object (for\n            example obtained from Structure.lattice).\n        coords (iterable): A list or numpy array of coordinates. Can be\n            cartesian or fractional coordinates. If more than three sets of\n            coordinates are provided, the best plane that minimises the\n            distance to all sites will be calculated.\n        coords_are_cartesian (bool, optional): Whether the coordinates are\n            in cartesian space. If using fractional coordinates set to False.\n        round_dp (int, optional): The number of decimal places to round the\n            miller index to.\n        verbose (bool, optional): Whether to print warnings.\n\n    Returns:\n        (tuple): The Miller index.\n    \"\"\"\n    if not isinstance(lattice, Lattice):\n        lattice = Lattice(lattice)\n\n    return lattice.get_miller_index_from_coords(\n        coords, coords_are_cartesian=coords_are_cartesian, round_dp=round_dp,\n        verbose=verbose)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef center_slab(slab):\n\n    # get a reasonable r cutoff to sample neighbors\n    bdists = sorted([nn[1] for nn in\n                     slab.get_neighbors(slab[0], 10) if nn[1] > 0])\n    r = bdists[0] * 3\n\n    all_indices = [i for i, site in enumerate(slab)]\n\n    # check if structure is case 2 or 3, shift all the\n    # sites up to the other side until it is case 1\n    for site in slab:\n        if any([nn[1] > slab.lattice.c for nn\n                in slab.get_neighbors(site, r)]):\n            shift = 1 - site.frac_coords[2] + 0.05\n            slab.translate_sites(all_indices, [0, 0, shift])\n\n    # now the slab is case 1, shift the center of mass of the slab to 0.5\n    weights = [s.species.weight for s in slab]\n    center_of_mass = np.average(slab.frac_coords,\n                                weights=weights, axis=0)\n    shift = 0.5 - center_of_mass[2]\n    slab.translate_sites(all_indices, [0, 0, shift])\n\n    return slab", "response": "This function centers the slab in a specific region."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_tasker2_slabs(self, tol=0.01, same_species_only=True):\n        sites = list(self.sites)\n        slabs = []\n\n        sortedcsites = sorted(sites, key=lambda site: site.c)\n\n        # Determine what fraction the slab is of the total cell size in the\n        # c direction. Round to nearest rational number.\n        nlayers_total = int(round(self.lattice.c /\n                                  self.oriented_unit_cell.lattice.c))\n        nlayers_slab = int(round((sortedcsites[-1].c - sortedcsites[0].c)\n                                 * nlayers_total))\n        slab_ratio = nlayers_slab / nlayers_total\n\n        a = SpacegroupAnalyzer(self)\n        symm_structure = a.get_symmetrized_structure()\n\n        def equi_index(site):\n            for i, equi_sites in enumerate(symm_structure.equivalent_sites):\n                if site in equi_sites:\n                    return i\n            raise ValueError(\"Cannot determine equi index!\")\n\n        for surface_site, shift in [(sortedcsites[0], slab_ratio),\n                                    (sortedcsites[-1], -slab_ratio)]:\n            tomove = []\n            fixed = []\n            for site in sites:\n                if abs(site.c - surface_site.c) < tol and (\n                        (not same_species_only) or\n                        site.species == surface_site.species):\n                    tomove.append(site)\n                else:\n                    fixed.append(site)\n\n            # Sort and group the sites by the species and symmetry equivalence\n            tomove = sorted(tomove, key=lambda s: equi_index(s))\n\n            grouped = [list(sites) for k, sites in itertools.groupby(\n                tomove, key=lambda s: equi_index(s))]\n\n            if len(tomove) == 0 or any([len(g) % 2 != 0 for g in grouped]):\n                warnings.warn(\"Odd number of sites to divide! Try changing \"\n                              \"the tolerance to ensure even division of \"\n                              \"sites or create supercells in a or b directions \"\n                              \"to allow for atoms to be moved!\")\n                continue\n            combinations = []\n            for g in grouped:\n                combinations.append(\n                    [c for c in itertools.combinations(g, int(len(g) / 2))])\n\n            for selection in itertools.product(*combinations):\n                species = [site.species for site in fixed]\n                fcoords = [site.frac_coords for site in fixed]\n\n                for s in tomove:\n                    species.append(s.species)\n                    for group in selection:\n                        if s in group:\n                            fcoords.append(s.frac_coords)\n                            break\n                    else:\n                        # Move unselected atom to the opposite surface.\n                        fcoords.append(s.frac_coords + [0, 0, shift])\n\n                # sort by species to put all similar species together.\n                sp_fcoord = sorted(zip(species, fcoords), key=lambda x: x[0])\n                species = [x[0] for x in sp_fcoord]\n                fcoords = [x[1] for x in sp_fcoord]\n                slab = Slab(self.lattice, species, fcoords, self.miller_index,\n                            self.oriented_unit_cell, self.shift,\n                            self.scale_factor, energy=self.energy,\n                            reorient_lattice=self.reorient_lattice)\n                slabs.append(slab)\n        s = StructureMatcher()\n        unique = [ss[0] for ss in s.group_structures(slabs)]\n        return unique", "response": "Returns a list of Tasker 2 corrected slabs."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncheck if slab contains inversion symmetry.", "response": "def is_symmetric(self, symprec=0.1):\n        \"\"\"\n        Checks if slab is symmetric, i.e., contains inversion symmetry.\n\n        Args:\n            symprec (float): Symmetry precision used for SpaceGroup analyzer.\n\n        Returns:\n            (bool) Whether slab contains inversion symmetry.\n        \"\"\"\n\n        sg = SpacegroupAnalyzer(self, symprec=symprec)\n        return sg.is_laue()"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a sorted copy of the structure.", "response": "def get_sorted_structure(self, key=None, reverse=False):\n        \"\"\"\n        Get a sorted copy of the structure. The parameters have the same\n        meaning as in list.sort. By default, sites are sorted by the\n        electronegativity of the species. Note that Slab has to override this\n        because of the different __init__ args.\n\n        Args:\n            key: Specifies a function of one argument that is used to extract\n                a comparison key from each list element: key=str.lower. The\n                default value is None (compare the elements directly).\n            reverse (bool): If set to True, then the list elements are sorted\n                as if each comparison were reversed.\n        \"\"\"\n        sites = sorted(self, key=key, reverse=reverse)\n        s = Structure.from_sites(sites)\n        return Slab(s.lattice, s.species_and_occu, s.frac_coords,\n                    self.miller_index, self.oriented_unit_cell, self.shift,\n                    self.scale_factor, site_properties=s.site_properties,\n                    reorient_lattice=self.reorient_lattice)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef copy(self, site_properties=None, sanitize=False):\n        props = self.site_properties\n        if site_properties:\n            props.update(site_properties)\n        return Slab(self.lattice, self.species_and_occu, self.frac_coords,\n                    self.miller_index, self.oriented_unit_cell, self.shift,\n                    self.scale_factor, site_properties=props,\n                    reorient_lattice=self.reorient_lattice)", "response": "Returns a copy of the structure with optionally new site properties and sanitized."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncalculating the dipole of the Slab in the direction of the surface.", "response": "def dipole(self):\n        \"\"\"\n        Calculates the dipole of the Slab in the direction of the surface\n        normal. Note that the Slab must be oxidation state-decorated for this\n        to work properly. Otherwise, the Slab will always have a dipole of 0.\n        \"\"\"\n        dipole = np.zeros(3)\n        mid_pt = np.sum(self.cart_coords, axis=0) / len(self)\n        normal = self.normal\n        for site in self:\n            charge = sum([getattr(sp, \"oxi_state\", 0) * amt\n                          for sp, amt in site.species.items()])\n            dipole += charge * np.dot(site.coords - mid_pt, normal) * normal\n        return dipole"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef is_polar(self, tol_dipole_per_unit_area=1e-3):\n        dip_per_unit_area = self.dipole / self.surface_area\n        return np.linalg.norm(dip_per_unit_area) > tol_dipole_per_unit_area", "response": "Checks whether the surface is polar by computing the dipole per unit area of the Slab."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef normal(self):\n        normal = np.cross(self.lattice.matrix[0], self.lattice.matrix[1])\n        normal /= np.linalg.norm(normal)\n        return normal", "response": "Calculates the surface normal vector of the slab"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef surface_area(self):\n        m = self.lattice.matrix\n        return np.linalg.norm(np.cross(m[0], m[1]))", "response": "Calculates the surface area of the slab object"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncalculates the center of mass of the slab", "response": "def center_of_mass(self):\n        \"\"\"\n        Calculates the center of mass of the slab\n        \"\"\"\n        weights = [s.species.weight for s in self]\n        center_of_mass = np.average(self.frac_coords,\n                                    weights=weights, axis=0)\n        return center_of_mass"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef add_adsorbate_atom(self, indices, specie, distance):\n        # Let's do the work in cartesian coords\n        center = np.sum([self[i].coords for i in indices], axis=0) / len(\n            indices)\n\n        coords = center + self.normal * distance / np.linalg.norm(self.normal)\n\n        self.append(specie, coords, coords_are_cartesian=True)", "response": "Adds an adsorbate atom to the slab structure."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_surface_sites(self, tag=False):\n\n        from pymatgen.analysis.local_env import VoronoiNN\n\n        # Get a dictionary of coordination numbers\n        # for each distinct site in the structure\n        a = SpacegroupAnalyzer(self.oriented_unit_cell)\n        ucell = a.get_symmetrized_structure()\n        cn_dict = {}\n        v = VoronoiNN()\n        unique_indices = [equ[0] for equ in ucell.equivalent_indices]\n\n        for i in unique_indices:\n            el = ucell[i].species_string\n            if el not in cn_dict.keys():\n                cn_dict[el] = []\n            # Since this will get the cn as a result of the weighted polyhedra, the\n            # slightest difference in cn will indicate a different environment for a\n            # species, eg. bond distance of each neighbor or neighbor species. The\n            # decimal place to get some cn to be equal.\n            cn = v.get_cn(ucell, i, use_weights=True)\n            cn = float('%.5f' %(round(cn, 5)))\n            if cn not in cn_dict[el]:\n                cn_dict[el].append(cn)\n\n        v = VoronoiNN()\n\n        surf_sites_dict, properties = {\"top\": [], \"bottom\": []}, []\n        for i, site in enumerate(self):\n            # Determine if site is closer to the top or bottom of the slab\n            top = True if site.frac_coords[2] > self.center_of_mass[2] else False\n\n            try:\n                # A site is a surface site, if its environment does\n                # not fit the environment of other sites\n                cn = float('%.5f' %(round(v.get_cn(self, i, use_weights=True), 5)))\n                if cn < min(cn_dict[site.species_string]):\n                    properties.append(True)\n                    key = \"top\" if top else \"bottom\"\n                    surf_sites_dict[key].append([site, i])\n                else:\n                    properties.append(False)\n            except RuntimeError:\n                # or if pathological error is returned, indicating a surface site\n                properties.append(True)\n                key = \"top\" if top else \"bottom\"\n                surf_sites_dict[key].append([site, i])\n\n        if tag:\n            self.add_site_property(\"is_surf_site\", properties)\n        return surf_sites_dict", "response": "Returns the surface sites and their indices in a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncheck if we have same number of equivalent sites on both surfaces.", "response": "def have_equivalent_surfaces(self):\n        \"\"\"\n        Check if we have same number of equivalent sites on both surfaces.\n        This is an alternative to checking Laue symmetry (is_symmetric())\n        if we want to ensure both surfaces in the slab are the same\n        \"\"\"\n\n        # tag the sites as either surface sites or not\n        surf_sites_dict = self.get_surface_sites(tag=True)\n\n        a = SpacegroupAnalyzer(self)\n        symm_structure = a.get_symmetrized_structure()\n\n        # ensure each site on one surface has a\n        # corresponding equivalent site on the other\n        equal_surf_sites = []\n        for equ in symm_structure.equivalent_sites:\n            # Top and bottom are arbitrary, we will just determine\n            # if one site is on one side of the slab or the other\n            top, bottom = 0, 0\n            for s in equ:\n                if s.is_surf_site:\n                    if s.frac_coords[2] > self.center_of_mass[2]:\n                        top += 1\n                    else:\n                        bottom += 1\n            # Check to see if the number of equivalent sites\n            # on one side of the slab are equal to the other\n            equal_surf_sites.append(top == bottom)\n\n        return all(equal_surf_sites)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_symmetric_site(self, point, cartesian=False):\n\n        sg = SpacegroupAnalyzer(self)\n        ops = sg.get_symmetry_operations(cartesian=cartesian)\n\n        # Each operation on a point will return an equivalent point.\n        # We want to find the point on the other side of the slab.\n        for op in ops:\n            slab = self.copy()\n            site2 = op.operate(point)\n            if \"%.6f\" % (site2[2]) == \"%.6f\" % (point[2]):\n                continue\n\n            # Add dummy site to check the overall structure is symmetric\n            slab.append(\"O\", point, coords_are_cartesian=cartesian)\n            slab.append(\"O\", site2, coords_are_cartesian=cartesian)\n            sg = SpacegroupAnalyzer(slab)\n            if sg.is_laue():\n                break\n            else:\n                # If not symmetric, remove the two added\n                # sites and try another symmetry operator\n                slab.remove_sites([len(slab) - 1])\n                slab.remove_sites([len(slab) - 1])\n\n        return site2", "response": "This method returns the symmetric site of the overall structure."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nclass method for adding a site at a specified point in a slab. Will add the corresponding site on the other side of the slab to maintain equivalent surfaces. Arg: specie (str): The specie to add point (coords): The coordinate of the site in the slab to add. coords_are_cartesian (bool): Is the point in cartesian coordinates Returns: (Slab): The modified slab", "response": "def symmetrically_add_atom(self, specie, point, coords_are_cartesian=False):\n\n        \"\"\"\n        Class method for adding a site at a specified point in a slab.\n            Will add the corresponding site on the other side of the\n            slab to maintain equivalent surfaces.\n\n        Arg:\n            specie (str): The specie to add\n            point (coords): The coordinate of the site in the slab to add.\n            coords_are_cartesian (bool): Is the point in cartesian coordinates\n\n        Returns:\n            (Slab): The modified slab\n        \"\"\"\n\n        # For now just use the species of the\n        # surface atom as the element to add\n\n        # Get the index of the corresponding site at the bottom\n        point2 = self.get_symmetric_site(point, cartesian=coords_are_cartesian)\n\n        self.append(specie, point, coords_are_cartesian=coords_are_cartesian)\n        self.append(specie, point2, coords_are_cartesian=coords_are_cartesian)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nclass method for removing sites corresponding to a list of indices. Will remove the corresponding site on the other side of the slab to maintain equivalent surfaces. Arg: indices ([indices]): The indices of the sites in the slab to remove.", "response": "def symmetrically_remove_atoms(self, indices):\n\n        \"\"\"\n        Class method for removing sites corresponding to a list of indices.\n            Will remove the corresponding site on the other side of the\n            slab to maintain equivalent surfaces.\n\n        Arg:\n            indices ([indices]): The indices of the sites\n                in the slab to remove.\n        \"\"\"\n\n        slabcopy = SpacegroupAnalyzer(self.copy()).get_symmetrized_structure()\n        points = [slabcopy[i].frac_coords for i in indices]\n        removal_list = []\n        \n        for pt in points:\n            # Get the index of the original site on top\n            cart_point = slabcopy.lattice.get_cartesian_coords(pt)\n            dist = [site.distance_from_point(cart_point) for site in slabcopy]\n            site1 = dist.index(min(dist))\n\n            # Get the index of the corresponding site at the bottom\n            for i, eq_sites in enumerate(slabcopy.equivalent_sites):\n                if slabcopy[site1] in eq_sites:\n                    eq_indices = slabcopy.equivalent_indices[i]\n                    break\n            i1 = eq_indices[eq_sites.index(slabcopy[site1])]\n            \n            for i2 in eq_indices:\n                if i2 == i1:\n                    continue\n                if slabcopy[i2].frac_coords[2] == slabcopy[i1].frac_coords[2]:\n                    continue\n                # Test site remove to see if it results in symmetric slab\n                s = self.copy()\n                s.remove_sites([i1, i2])\n                if s.is_symmetric():\n                    removal_list.extend([i1, i2])\n                    break\n                    \n        # If expected, 2 atoms are removed per index\n        if len(removal_list) == 2*len(indices):\n            self.remove_sites(removal_list)\n        else:\n            warnings.warn(\"Equivalent sites could not be found for removal for all indices. Surface unchanged.\")"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_slab(self, shift=0, tol=0.1, energy=None):\n\n        h = self._proj_height\n        p = h/self.parent.lattice.d_hkl(self.miller_index)\n        if self.in_unit_planes:\n            nlayers_slab = int(math.ceil(self.min_slab_size / p))\n            nlayers_vac = int(math.ceil(self.min_vac_size / p))\n        else:\n            nlayers_slab = int(math.ceil(self.min_slab_size / h))\n            nlayers_vac = int(math.ceil(self.min_vac_size / h))\n        nlayers = nlayers_slab + nlayers_vac\n\n        species = self.oriented_unit_cell.species_and_occu\n        props = self.oriented_unit_cell.site_properties\n        props = {k: v * nlayers_slab for k, v in props.items()}\n        frac_coords = self.oriented_unit_cell.frac_coords\n        frac_coords = np.array(frac_coords) + np.array([0, 0, -shift])[None, :]\n        frac_coords -= np.floor(frac_coords)\n        a, b, c = self.oriented_unit_cell.lattice.matrix\n        new_lattice = [a, b, nlayers * c]\n        frac_coords[:, 2] = frac_coords[:, 2] / nlayers\n        all_coords = []\n        for i in range(nlayers_slab):\n            fcoords = frac_coords.copy()\n            fcoords[:, 2] += i / nlayers\n            all_coords.extend(fcoords)\n\n        slab = Structure(new_lattice, species * nlayers_slab, all_coords,\n                         site_properties=props)\n\n        scale_factor = self.slab_scale_factor\n        # Whether or not to orthogonalize the structure\n        if self.lll_reduce:\n            lll_slab = slab.copy(sanitize=True)\n            mapping = lll_slab.lattice.find_mapping(slab.lattice)\n            scale_factor = np.dot(mapping[2], scale_factor)\n            slab = lll_slab\n\n        # Whether or not to center the slab layer around the vacuum\n        if self.center_slab:\n            avg_c = np.average([c[2] for c in slab.frac_coords])\n            slab.translate_sites(list(range(len(slab))), [0, 0, 0.5 - avg_c])\n\n        if self.primitive:\n            prim = slab.get_primitive_structure(tolerance=tol)\n            if energy is not None:\n                energy = prim.volume / slab.volume * energy\n            slab = prim\n\n        # Reorient the lattice to get the correct reduced cell\n        ouc = self.oriented_unit_cell.copy()\n        if self.primitive:\n            #find a reduced ouc\n            slab_l = slab.lattice\n            ouc = ouc.get_primitive_structure(constrain_latt={\"a\": slab_l.a, \"b\": slab_l.b,\n                                                              \"alpha\": slab_l.alpha,\n                                                              \"beta\": slab_l.beta,\n                                                              \"gamma\": slab_l.gamma})\n\n        return Slab(slab.lattice, slab.species_and_occu,\n                    slab.frac_coords, self.miller_index,\n                    ouc, shift, scale_factor, energy=energy,\n                    site_properties=slab.site_properties,\n                    reorient_lattice=self.reorient_lattice)", "response": "This method generates a slab based on the given shift value and the given energy."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_slabs(self, bonds=None, ftol=0.1, tol=0.1, max_broken_bonds=0,\n                  symmetrize=False, repair=False):\n        \"\"\"\n        This method returns a list of slabs that are generated using the list of\n        shift values from the method, _calculate_possible_shifts(). Before the\n        shifts are used to create the slabs however, if the user decides to take\n        into account whether or not a termination will break any polyhedral\n        structure (bonds is not None), this method will filter out any shift\n        values that do so.\n\n        Args:\n            bonds ({(specie1, specie2): max_bond_dist}: bonds are\n                specified as a dict of tuples: float of specie1, specie2\n                and the max bonding distance. For example, PO4 groups may be\n                defined as {(\"P\", \"O\"): 3}.\n            tol (float): General tolerance paramter for getting primitive\n                cells and matching structures\n            ftol (float): Threshold parameter in fcluster in order to check\n                if two atoms are lying on the same plane. Default thresh set\n                to 0.1 Angstrom in the direction of the surface normal.\n            max_broken_bonds (int): Maximum number of allowable broken bonds\n                for the slab. Use this to limit # of slabs (some structures\n                may have a lot of slabs). Defaults to zero, which means no\n                defined bonds must be broken.\n            symmetrize (bool): Whether or not to ensure the surfaces of the\n                slabs are equivalent.\n            repair (bool): Whether to repair terminations with broken bonds\n                or just omit them. Set to False as repairing terminations can\n                lead to many possible slabs as oppose to just omitting them.\n\n        Returns:\n            ([Slab]) List of all possible terminations of a particular surface.\n            Slabs are sorted by the # of bonds broken.\n        \"\"\"\n        c_ranges = set() if bonds is None else self._get_c_ranges(bonds)\n\n        slabs = []\n        for shift in self._calculate_possible_shifts(tol=ftol):\n            bonds_broken = 0\n            for r in c_ranges:\n                if r[0] <= shift <= r[1]:\n                    bonds_broken += 1\n            slab = self.get_slab(shift, tol=tol, energy=bonds_broken)\n            if bonds_broken <= max_broken_bonds:\n                slabs.append(slab)\n            elif repair:\n                # If the number of broken bonds is exceeded,\n                # we repair the broken bonds on the slab\n                slabs.append(self.repair_broken_bonds(slab, bonds))\n\n        # Further filters out any surfaces made that might be the same\n        m = StructureMatcher(ltol=tol, stol=tol, primitive_cell=False,\n                             scale=False)\n\n        new_slabs = []\n        for g in m.group_structures(slabs):\n            # For each unique termination, symmetrize the\n            # surfaces by removing sites from the bottom.\n            if symmetrize:\n                slabs = self.nonstoichiometric_symmetrized_slab(g[0])\n                new_slabs.extend(slabs)\n            else:\n                new_slabs.append(g[0])\n\n        match = StructureMatcher(ltol=tol, stol=tol, primitive_cell=False,\n                                 scale=False)\n        new_slabs = [g[0] for g in match.group_structures(new_slabs)]\n\n        return sorted(new_slabs, key=lambda s: s.energy)", "response": "This method returns a list of all possible terminations of a particular slab."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef repair_broken_bonds(self, slab, bonds):\n\n        for pair in bonds.keys():\n            blength = bonds[pair]\n\n            # First lets determine which element should be the\n            # reference (center element) to determine broken bonds.\n            # e.g. P for a PO4 bond. Find integer coordination\n            # numbers of the pair of elements wrt to each other\n            cn_dict = {}\n            for i, el in enumerate(pair):\n                cnlist = []\n                for site in self.oriented_unit_cell:\n                    poly_coord = 0\n                    if site.species_string == el:\n\n                        for nn in self.oriented_unit_cell.get_neighbors(\n                                site, blength):\n                            if nn[0].species_string == pair[i-1]:\n                                poly_coord += 1\n                    cnlist.append(poly_coord)\n                cn_dict[el] = cnlist\n\n            # We make the element with the higher coordination our reference\n            if max(cn_dict[pair[0]]) > max(cn_dict[pair[1]]):\n                element1, element2 = pair\n            else:\n                element2, element1 = pair\n\n            for i, site in enumerate(slab):\n                # Determine the coordination of our reference\n                if site.species_string == element1:\n                    poly_coord = 0\n                    for neighbor in slab.get_neighbors(site, blength):\n                        poly_coord += 1 if neighbor[0].species_string == element2 else 0\n\n                    # suppose we find an undercoordinated reference atom\n                    if poly_coord not in cn_dict[element1]:\n                        # We get the reference atom of the broken bonds\n                        # (undercoordinated), move it to the other surface\n                        slab = self.move_to_other_side(slab, [i])\n\n                        # find its NNs with the corresponding\n                        # species it should be coordinated with\n                        neighbors = slab.get_neighbors(slab[i], blength,\n                                                       include_index=True)\n                        tomove = [nn[2] for nn in neighbors if\n                                  nn[0].species_string == element2]\n                        tomove.append(i)\n                        # and then move those NNs along with the central\n                        # atom back to the other side of the slab again\n                        slab = self.move_to_other_side(slab, tomove)\n\n        return slab", "response": "This method will find undercoordinated atoms due to the slab and move them to the other surface."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef build_slabs(self):\n\n        slabs = self.get_unreconstructed_slabs()\n        recon_slabs = []\n\n        for slab in slabs:\n            d = get_d(slab)\n            top_site = sorted(slab, key=lambda site: site.frac_coords[2])[-1].coords\n\n            # Remove any specified sites\n            if \"points_to_remove\" in self.reconstruction_json.keys():\n                pts_to_rm = copy.deepcopy(self.reconstruction_json[\"points_to_remove\"])\n                for p in pts_to_rm:\n                    p[2] = slab.lattice.get_fractional_coords([top_site[0], top_site[1],\n                                                               top_site[2]+p[2]*d])[2]\n                    cart_point = slab.lattice.get_cartesian_coords(p)\n                    dist = [site.distance_from_point(cart_point) for site in slab]\n                    site1 = dist.index(min(dist))\n                    slab.symmetrically_remove_atoms([site1])\n\n            # Add any specified sites\n            if \"points_to_add\" in self.reconstruction_json.keys():\n                pts_to_add = copy.deepcopy(self.reconstruction_json[\"points_to_add\"])\n                for p in pts_to_add:\n                    p[2] = slab.lattice.get_fractional_coords([top_site[0], top_site[1],\n                                                               top_site[2]+p[2]*d])[2]\n                    slab.symmetrically_add_atom(slab[0].specie, p)\n\n            slab.reconstruction = self.name\n            setattr(slab, \"recon_trans_matrix\", self.trans_matrix)\n\n            # Get the oriented_unit_cell with the same axb area.\n            ouc = slab.oriented_unit_cell.copy()\n            ouc.make_supercell(self.trans_matrix)\n            slab.oriented_unit_cell = ouc\n            recon_slabs.append(slab)\n\n        return recon_slabs", "response": "Builds the unreconstructed slab by the specified parameters."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_unreconstructed_slabs(self):\n\n        \"\"\"\n        Generates the unreconstructed or pristine super slab.\n        \"\"\"\n\n        slabs = []\n        for slab in SlabGenerator(**self.slabgen_params).get_slabs():\n            slab.make_supercell(self.trans_matrix)\n            slabs.append(slab)\n        return slabs", "response": "Generates the unreconstructed or pristine super slab."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef from_file(filename, check_for_POTCAR=True, read_velocities=True):\n        dirname = os.path.dirname(os.path.abspath(filename))\n        names = None\n        if check_for_POTCAR:\n            potcars = glob.glob(os.path.join(dirname, \"*POTCAR*\"))\n            if potcars:\n                try:\n                    potcar = Potcar.from_file(sorted(potcars)[0])\n                    names = [sym.split(\"_\")[0] for sym in potcar.symbols]\n                    [get_el_sp(n) for n in names]  # ensure valid names\n                except:\n                    names = None\n        with zopen(filename, \"rt\") as f:\n            return Poscar.from_string(f.read(), names,\n                                      read_velocities=read_velocities)", "response": "Reads a Poscar from a file."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef from_string(data, default_names=None, read_velocities=True):\n        # \"^\\s*$\" doesn't match lines with no whitespace\n        chunks = re.split(r\"\\n\\s*\\n\", data.rstrip(), flags=re.MULTILINE)\n        try:\n            if chunks[0] == \"\":\n                chunks.pop(0)\n                chunks[0] = \"\\n\" + chunks[0]\n        except IndexError:\n            raise ValueError(\"Empty POSCAR\")\n\n        # Parse positions\n        lines = tuple(clean_lines(chunks[0].split(\"\\n\"), False))\n        comment = lines[0]\n        scale = float(lines[1])\n        lattice = np.array([[float(i) for i in line.split()]\n                            for line in lines[2:5]])\n        if scale < 0:\n            # In vasp, a negative scale factor is treated as a volume. We need\n            # to translate this to a proper lattice vector scaling.\n            vol = abs(det(lattice))\n            lattice *= (-scale / vol) ** (1 / 3)\n        else:\n            lattice *= scale\n\n        vasp5_symbols = False\n        try:\n            natoms = [int(i) for i in lines[5].split()]\n            ipos = 6\n        except ValueError:\n            vasp5_symbols = True\n            symbols = lines[5].split()\n\n            \"\"\"\n            Atoms and number of atoms in POSCAR written with vasp appear on \n            multiple lines when atoms of the same type are not grouped together \n            and more than 20 groups are then defined ...\n            \n            Example :\n            \n            Cr16 Fe35 Ni2\n               1.00000000000000\n                 8.5415010000000002   -0.0077670000000000   -0.0007960000000000\n                -0.0077730000000000    8.5224019999999996    0.0105580000000000\n                -0.0007970000000000    0.0105720000000000    8.5356889999999996\n               Fe   Cr   Fe   Cr   Fe   Cr   Fe   Cr   Fe   Cr   Fe   Cr   Fe   Cr   Fe   Ni   Fe   Cr   Fe   Cr\n               Fe   Ni   Fe   Cr   Fe\n                 1     1     2     4     2     1     1     1     2     1     1     1     4     1     1     1     5     3     6     1\n                 2     1     3     2     5\n            Direct\n              ...\n            \"\"\"\n            nlines_symbols = 1\n            for nlines_symbols in range(1, 11):\n                try:\n                    int(lines[5+nlines_symbols].split()[0])\n                    break\n                except ValueError:\n                    pass\n            for iline_symbols in range(6, 5+nlines_symbols):\n                symbols.extend(lines[iline_symbols].split())\n            natoms = []\n            iline_natoms_start = 5+nlines_symbols\n            for iline_natoms in range(iline_natoms_start,\n                                      iline_natoms_start+nlines_symbols):\n                natoms.extend([int(i) for i in lines[iline_natoms].split()])\n            atomic_symbols = list()\n            for i in range(len(natoms)):\n                atomic_symbols.extend([symbols[i]] * natoms[i])\n            ipos = 5+2*nlines_symbols\n\n        postype = lines[ipos].split()[0]\n\n        sdynamics = False\n        # Selective dynamics\n        if postype[0] in \"sS\":\n            sdynamics = True\n            ipos += 1\n            postype = lines[ipos].split()[0]\n\n        cart = postype[0] in \"cCkK\"\n        nsites = sum(natoms)\n\n        # If default_names is specified (usually coming from a POTCAR), use\n        # them. This is in line with Vasp\"s parsing order that the POTCAR\n        # specified is the default used.\n        if default_names:\n            try:\n                atomic_symbols = []\n                for i in range(len(natoms)):\n                    atomic_symbols.extend([default_names[i]] * natoms[i])\n                vasp5_symbols = True\n            except IndexError:\n                pass\n\n        if not vasp5_symbols:\n            ind = 3 if not sdynamics else 6\n            try:\n                # Check if names are appended at the end of the coordinates.\n                atomic_symbols = [l.split()[ind]\n                                  for l in lines[ipos + 1:ipos + 1 + nsites]]\n                # Ensure symbols are valid elements\n                if not all([Element.is_valid_symbol(sym)\n                            for sym in atomic_symbols]):\n                    raise ValueError(\"Non-valid symbols detected.\")\n                vasp5_symbols = True\n            except (ValueError, IndexError):\n                # Defaulting to false names.\n                atomic_symbols = []\n                for i in range(len(natoms)):\n                    sym = Element.from_Z(i + 1).symbol\n                    atomic_symbols.extend([sym] * natoms[i])\n                warnings.warn(\"Elements in POSCAR cannot be determined. \"\n                              \"Defaulting to false names %s.\" %\n                              \" \".join(atomic_symbols))\n\n        # read the atomic coordinates\n        coords = []\n        selective_dynamics = list() if sdynamics else None\n        for i in range(nsites):\n            toks = lines[ipos + 1 + i].split()\n            crd_scale = scale if cart else 1\n            coords.append([float(j) * crd_scale for j in toks[:3]])\n            if sdynamics:\n                selective_dynamics.append([tok.upper()[0] == \"T\"\n                                           for tok in toks[3:6]])\n\n        struct = Structure(lattice, atomic_symbols, coords,\n                           to_unit_cell=False, validate_proximity=False,\n                           coords_are_cartesian=cart)\n\n        if read_velocities:\n            # Parse velocities if any\n            velocities = []\n            if len(chunks) > 1:\n                for line in chunks[1].strip().split(\"\\n\"):\n                    velocities.append([float(tok) for tok in line.split()])\n\n            # Parse the predictor-corrector data\n            predictor_corrector = []\n            predictor_corrector_preamble = None\n\n            if len(chunks) > 2:\n                lines = chunks[2].strip().split(\"\\n\")\n                # There are 3 sets of 3xN Predictor corrector parameters\n                # So can't be stored as a single set of \"site_property\"\n\n                # First line in chunk is a key in CONTCAR\n                # Second line is POTIM\n                # Third line is the thermostat parameters\n                predictor_corrector_preamble = (lines[0] + \"\\n\" + lines[1]\n                                                + \"\\n\" + lines[2])\n                # Rest is three sets of parameters, each set contains\n                # x, y, z predictor-corrector parameters for every atom in orde\n                lines = lines[3:]\n                for st in range(nsites):\n                    d1 = [float(tok) for tok in lines[st].split()]\n                    d2 = [float(tok) for tok in lines[st+nsites].split()]\n                    d3 = [float(tok) for tok in lines[st+2*nsites].split()]\n                    predictor_corrector.append([d1,d2,d3])\n        else:\n            velocities = None\n            predictor_corrector = None\n            predictor_corrector_preamble = None\n\n        return Poscar(struct, comment, selective_dynamics, vasp5_symbols,\n                      velocities=velocities,\n                      predictor_corrector=predictor_corrector,\n                      predictor_corrector_preamble=predictor_corrector_preamble)", "response": "Reads a Poscar from a string containing a set of elemental properties."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_string(self, direct=True, vasp4_compatible=False,\n                   significant_figures=6):\n        \"\"\"\n        Returns a string to be written as a POSCAR file. By default, site\n        symbols are written, which means compatibility is for vasp >= 5.\n\n        Args:\n            direct (bool): Whether coordinates are output in direct or\n                cartesian. Defaults to True.\n            vasp4_compatible (bool): Set to True to omit site symbols on 6th\n                line to maintain backward vasp 4.x compatibility. Defaults\n                to False.\n            significant_figures (int): No. of significant figures to\n                output all quantities. Defaults to 6. Note that positions are\n                output in fixed point, while velocities are output in\n                scientific format.\n\n        Returns:\n            String representation of POSCAR.\n        \"\"\"\n\n        # This corrects for VASP really annoying bug of crashing on lattices\n        # which have triple product < 0. We will just invert the lattice\n        # vectors.\n        latt = self.structure.lattice\n        if np.linalg.det(latt.matrix) < 0:\n            latt = Lattice(-latt.matrix)\n\n        format_str = \"{{:.{0}f}}\".format(significant_figures)\n        lines = [self.comment, \"1.0\"]\n        for v in latt.matrix:\n            lines.append(\" \".join([format_str.format(c) for c in v]))\n\n        if self.true_names and not vasp4_compatible:\n            lines.append(\" \".join(self.site_symbols))\n        lines.append(\" \".join([str(x) for x in self.natoms]))\n        if self.selective_dynamics:\n            lines.append(\"Selective dynamics\")\n        lines.append(\"direct\" if direct else \"cartesian\")\n\n        selective_dynamics = self.selective_dynamics\n        for (i, site) in enumerate(self.structure):\n            coords = site.frac_coords if direct else site.coords\n            line = \" \".join([format_str.format(c) for c in coords])\n            if selective_dynamics is not None:\n                sd = [\"T\" if j else \"F\" for j in selective_dynamics[i]]\n                line += \" %s %s %s\" % (sd[0], sd[1], sd[2])\n            line += \" \" + site.species_string\n            lines.append(line)\n\n        if self.velocities:\n            try:\n                lines.append(\"\")\n                for v in self.velocities:\n                    lines.append(\" \".join([format_str.format(i) for i in v]))\n            except:\n                warnings.warn(\"Velocities are missing or corrupted.\")\n\n        if self.predictor_corrector:\n            lines.append(\"\")\n            if self.predictor_corrector_preamble:\n                lines.append(self.predictor_corrector_preamble)\n                pred = np.array(self.predictor_corrector)\n                for col in range(3):\n                    for z in pred[:,col]:\n                        lines.append(\" \".join([format_str.format(i) for i in z]))\n            else:\n                warnings.warn(\n                    \"Preamble information missing or corrupt. \" \n                    \"Writing Poscar with no predictor corrector data.\")\n\n        return \"\\n\".join(lines) + \"\\n\"", "response": "Returns a string representation of the structure as a POSCAR file."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef write_file(self, filename, **kwargs):\n        with zopen(filename, \"wt\") as f:\n            f.write(self.get_string(**kwargs))", "response": "Writes a POSCAR to a file."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset the temperature of the entry in the structure.", "response": "def set_temperature(self, temperature):\n        \"\"\"\n        Initializes the velocities based on Maxwell-Boltzmann distribution.\n        Removes linear, but not angular drift (same as VASP)\n\n        Scales the energies to the exact temperature (microcanonical ensemble)\n        Velocities are given in A/fs. This is the vasp default when\n        direct/cartesian is not specified (even when positions are given in\n        direct coordinates)\n\n        Overwrites imported velocities, if any.\n\n        Args:\n            temperature (float): Temperature in Kelvin.\n        \"\"\"\n        # mean 0 variance 1\n        velocities = np.random.randn(len(self.structure), 3)\n\n        # in AMU, (N,1) array\n        atomic_masses = np.array([site.specie.atomic_mass.to(\"kg\")\n                                  for site in self.structure])\n        dof = 3 * len(self.structure) - 3\n\n        # scale velocities due to atomic masses\n        # mean 0 std proportional to sqrt(1/m)\n        velocities /= atomic_masses[:, np.newaxis] ** (1 / 2)\n\n        # remove linear drift (net momentum)\n        velocities -= np.average(atomic_masses[:, np.newaxis] * velocities,\n                                 axis=0) / np.average(atomic_masses)\n\n        # scale velocities to get correct temperature\n        energy = np.sum(1 / 2 * atomic_masses *\n                        np.sum(velocities ** 2, axis=1))\n        scale = (temperature * dof / (2 * energy / const.k)) ** (1 / 2)\n\n        velocities *= scale * 1e-5  # these are in A/fs\n\n        self.temperature = temperature\n        try:\n            del self.structure.site_properties[\"selective_dynamics\"]\n        except KeyError:\n            pass\n\n        try:\n            del self.structure.site_properties[\"predictor_corrector\"]\n        except KeyError:\n            pass\n        # returns as a list of lists to be consistent with the other\n        # initializations\n\n        self.structure.add_site_property(\"velocities\", velocities.tolist())"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_string(self, sort_keys=False, pretty=False):\n        keys = self.keys()\n        if sort_keys:\n            keys = sorted(keys)\n        lines = []\n        for k in keys:\n            if k == \"MAGMOM\" and isinstance(self[k], list):\n                value = []\n\n                if (isinstance(self[k][0], list) or isinstance(self[k][0], Magmom)) and \\\n                        (self.get(\"LSORBIT\") or self.get(\"LNONCOLLINEAR\")):\n                    value.append(\" \".join(str(i) for j in self[k] for i in j))\n                elif self.get(\"LSORBIT\") or self.get(\"LNONCOLLINEAR\"):\n                    for m, g in itertools.groupby(self[k]):\n                        value.append(\"3*{}*{}\".format(len(tuple(g)), m))\n                else:\n                    # float() to ensure backwards compatibility between\n                    # float magmoms and Magmom objects\n                    for m, g in itertools.groupby(self[k], lambda x: float(x)):\n                        value.append(\"{}*{}\".format(len(tuple(g)), m))\n\n                lines.append([k, \" \".join(value)])\n            elif isinstance(self[k], list):\n                lines.append([k, \" \".join([str(i) for i in self[k]])])\n            else:\n                lines.append([k, self[k]])\n\n        if pretty:\n            return str(tabulate([[l[0], \"=\", l[1]] for l in lines],\n                                tablefmt=\"plain\"))\n        else:\n            return str_delimited(lines, None, \" = \") + \"\\n\"", "response": "Returns a string representation of the INCAR."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreading an Incar object from a string.", "response": "def from_string(string):\n        \"\"\"\n        Reads an Incar object from a string.\n\n        Args:\n            string (str): Incar string\n\n        Returns:\n            Incar object\n        \"\"\"\n        lines = list(clean_lines(string.splitlines()))\n        params = {}\n        for line in lines:\n            for sline in line.split(';'):\n                m = re.match(r'(\\w+)\\s*=\\s*(.*)', sline.strip())\n                if m:\n                    key = m.group(1).strip()\n                    val = m.group(2).strip()\n                    val = Incar.proc_val(key, val)\n                    params[key] = val\n        return Incar(params)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nprocessing INCAR parameter values.", "response": "def proc_val(key, val):\n        \"\"\"\n        Static helper method to convert INCAR parameters to proper types, e.g.,\n        integers, floats, lists, etc.\n\n        Args:\n            key: INCAR parameter key\n            val: Actual value of INCAR parameter.\n        \"\"\"\n        list_keys = (\"LDAUU\", \"LDAUL\", \"LDAUJ\", \"MAGMOM\", \"DIPOL\",\n                     \"LANGEVIN_GAMMA\", \"QUAD_EFG\", \"EINT\")\n        bool_keys = (\"LDAU\", \"LWAVE\", \"LSCALU\", \"LCHARG\", \"LPLANE\", \"LUSE_VDW\",\n                     \"LHFCALC\", \"ADDGRID\", \"LSORBIT\", \"LNONCOLLINEAR\")\n        float_keys = (\"EDIFF\", \"SIGMA\", \"TIME\", \"ENCUTFOCK\", \"HFSCREEN\",\n                      \"POTIM\", \"EDIFFG\", \"AGGAC\", \"PARAM1\", \"PARAM2\")\n        int_keys = (\"NSW\", \"NBANDS\", \"NELMIN\", \"ISIF\", \"IBRION\", \"ISPIN\",\n                    \"ICHARG\", \"NELM\", \"ISMEAR\", \"NPAR\", \"LDAUPRINT\", \"LMAXMIX\",\n                    \"ENCUT\", \"NSIM\", \"NKRED\", \"NUPDOWN\", \"ISPIND\", \"LDAUTYPE\",\n                    \"IVDW\")\n\n        def smart_int_or_float(numstr):\n            if numstr.find(\".\") != -1 or numstr.lower().find(\"e\") != -1:\n                return float(numstr)\n            else:\n                return int(numstr)\n\n        try:\n            if key in list_keys:\n                output = []\n                toks = re.findall(\n                    r\"(-?\\d+\\.?\\d*)\\*?(-?\\d+\\.?\\d*)?\\*?(-?\\d+\\.?\\d*)?\", val)\n                for tok in toks:\n                    if tok[2] and \"3\" in tok[0]:\n                        output.extend(\n                            [smart_int_or_float(tok[2])] * int(tok[0])\n                            * int(tok[1]))\n                    elif tok[1]:\n                        output.extend([smart_int_or_float(tok[1])] *\n                                      int(tok[0]))\n                    else:\n                        output.append(smart_int_or_float(tok[0]))\n                return output\n            if key in bool_keys:\n                m = re.match(r\"^\\.?([T|F|t|f])[A-Za-z]*\\.?\", val)\n                if m:\n                    if m.group(1) == \"T\" or m.group(1) == \"t\":\n                        return True\n                    else:\n                        return False\n                raise ValueError(key + \" should be a boolean type!\")\n\n            if key in float_keys:\n                return float(re.search(r\"^-?\\d*\\.?\\d*[e|E]?-?\\d*\", val).group(0))\n\n            if key in int_keys:\n                return int(re.match(r\"^-?[0-9]+\", val).group(0))\n\n        except ValueError:\n            pass\n\n        # Not in standard keys. We will try a hierarchy of conversions.\n        try:\n            val = int(val)\n            return val\n        except ValueError:\n            pass\n\n        try:\n            val = float(val)\n            return val\n        except ValueError:\n            pass\n\n        if \"true\" in val.lower():\n            return True\n\n        if \"false\" in val.lower():\n            return False\n\n        return val.strip().capitalize()"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a dictionary that contains the difference between two Incar objects.", "response": "def diff(self, other):\n        \"\"\"\n        Diff function for Incar.  Compares two Incars and indicates which\n        parameters are the same and which are not. Useful for checking whether\n        two runs were done using the same parameters.\n\n        Args:\n            other (Incar): The other Incar object to compare to.\n\n        Returns:\n            Dict of the following format:\n            {\"Same\" : parameters_that_are_the_same,\n            \"Different\": parameters_that_are_different}\n            Note that the parameters are return as full dictionaries of values.\n            E.g. {\"ISIF\":3}\n        \"\"\"\n        similar_param = {}\n        different_param = {}\n        for k1, v1 in self.items():\n            if k1 not in other:\n                different_param[k1] = {\"INCAR1\": v1, \"INCAR2\": None}\n            elif v1 != other[k1]:\n                different_param[k1] = {\"INCAR1\": v1, \"INCAR2\": other[k1]}\n            else:\n                similar_param[k1] = v1\n        for k2, v2 in other.items():\n            if k2 not in similar_param and k2 not in different_param:\n                if k2 not in self:\n                    different_param[k2] = {\"INCAR1\": None, \"INCAR2\": v2}\n        return {\"Same\": similar_param, \"Different\": different_param}"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef gamma_automatic(kpts=(1, 1, 1), shift=(0, 0, 0)):\n        return Kpoints(\"Automatic kpoint scheme\", 0,\n                       Kpoints.supported_modes.Gamma, kpts=[kpts],\n                       kpts_shift=shift)", "response": "A static constructor for an automatic Gamma centered Kpoint - set grid."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns an automatic Kpoint object based on a structure and a kpoint - based grid density.", "response": "def automatic_density(structure, kppa, force_gamma=False):\n        \"\"\"\n        Returns an automatic Kpoint object based on a structure and a kpoint\n        density. Uses Gamma centered meshes for hexagonal cells and\n        Monkhorst-Pack grids otherwise.\n\n        Algorithm:\n            Uses a simple approach scaling the number of divisions along each\n            reciprocal lattice vector proportional to its length.\n\n        Args:\n            structure (Structure): Input structure\n            kppa (int): Grid density\n            force_gamma (bool): Force a gamma centered mesh (default is to\n                use gamma only for hexagonal cells or odd meshes)\n\n        Returns:\n            Kpoints\n        \"\"\"\n        comment = \"pymatgen v%s with grid density = %.0f / atom\" % (\n            __version__, kppa)\n        if math.fabs((math.floor(kppa ** (1 / 3) + 0.5)) ** 3 - kppa) < 1:\n            kppa += kppa * 0.01\n        latt = structure.lattice\n        lengths = latt.abc\n        ngrid = kppa / structure.num_sites\n        mult = (ngrid * lengths[0] * lengths[1] * lengths[2]) ** (1 / 3)\n\n        num_div = [int(math.floor(max(mult / l, 1))) for l in lengths]\n\n        is_hexagonal = latt.is_hexagonal()\n\n        has_odd = any([i % 2 == 1 for i in num_div])\n        if has_odd or is_hexagonal or force_gamma:\n            style = Kpoints.supported_modes.Gamma\n        else:\n            style = Kpoints.supported_modes.Monkhorst\n\n        return Kpoints(comment, 0, style, [num_div], [0, 0, 0])"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns an automatic Kpoint object based on a structure and a kpoint - based grid density.", "response": "def automatic_gamma_density(structure, kppa):\n        \"\"\"\n        Returns an automatic Kpoint object based on a structure and a kpoint\n        density. Uses Gamma centered meshes always. For GW.\n\n        Algorithm:\n            Uses a simple approach scaling the number of divisions along each\n            reciprocal lattice vector proportional to its length.\n\n        Args:\n            structure:\n                Input structure\n            kppa:\n                Grid density\n        \"\"\"\n\n        latt = structure.lattice\n        lengths = latt.abc\n        ngrid = kppa / structure.num_sites\n\n        mult = (ngrid * lengths[0] * lengths[1] * lengths[2]) ** (1 / 3)\n        num_div = [int(round(mult / l)) for l in lengths]\n\n        # ensure that numDiv[i] > 0\n        num_div = [i if i > 0 else 1 for i in num_div]\n\n        # VASP documentation recommends to use even grids for n <= 8 and odd\n        # grids for n > 8.\n        num_div = [i + i % 2 if i <= 8 else i - i % 2 + 1 for i in num_div]\n\n        style = Kpoints.supported_modes.Gamma\n\n        comment = \"pymatgen 4.7.6+ generated KPOINTS with grid density = \" + \\\n                  \"{} / atom\".format(kppa)\n        num_kpts = 0\n        return Kpoints(comment, num_kpts, style, [num_div], [0, 0, 0])"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef automatic_linemode(divisions, ibz):\n        kpoints = list()\n        labels = list()\n        for path in ibz.kpath[\"path\"]:\n            kpoints.append(ibz.kpath[\"kpoints\"][path[0]])\n            labels.append(path[0])\n            for i in range(1, len(path) - 1):\n                kpoints.append(ibz.kpath[\"kpoints\"][path[i]])\n                labels.append(path[i])\n                kpoints.append(ibz.kpath[\"kpoints\"][path[i]])\n                labels.append(path[i])\n\n            kpoints.append(ibz.kpath[\"kpoints\"][path[-1]])\n            labels.append(path[-1])\n\n        return Kpoints(\"Line_mode KPOINTS file\",\n                       style=Kpoints.supported_modes.Line_mode,\n                       coord_type=\"Reciprocal\",\n                       kpts=kpoints,\n                       labels=labels,\n                       num_kpts=int(divisions))", "response": "A static constructor for automatic line mode KPOINTS file."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef from_string(string):\n        lines = [line.strip() for line in string.splitlines()]\n\n        comment = lines[0]\n        num_kpts = int(lines[1].split()[0].strip())\n        style = lines[2].lower()[0]\n\n        # Fully automatic KPOINTS\n        if style == \"a\":\n            return Kpoints.automatic(int(lines[3]))\n\n        coord_pattern = re.compile(r'^\\s*([\\d+.\\-Ee]+)\\s+([\\d+.\\-Ee]+)\\s+'\n                                   r'([\\d+.\\-Ee]+)')\n\n        # Automatic gamma and Monk KPOINTS, with optional shift\n        if style == \"g\" or style == \"m\":\n            kpts = [int(i) for i in lines[3].split()]\n            kpts_shift = (0, 0, 0)\n            if len(lines) > 4 and coord_pattern.match(lines[4]):\n                try:\n                    kpts_shift = [float(i) for i in lines[4].split()]\n                except ValueError:\n                    pass\n            return Kpoints.gamma_automatic(kpts, kpts_shift) if style == \"g\" \\\n                else Kpoints.monkhorst_automatic(kpts, kpts_shift)\n\n        # Automatic kpoints with basis\n        if num_kpts <= 0:\n            style = Kpoints.supported_modes.Cartesian if style in \"ck\" \\\n                else Kpoints.supported_modes.Reciprocal\n            kpts = [[float(j) for j in lines[i].split()] for i in range(3, 6)]\n            kpts_shift = [float(i) for i in lines[6].split()]\n            return Kpoints(comment=comment, num_kpts=num_kpts, style=style,\n                           kpts=kpts, kpts_shift=kpts_shift)\n\n        # Line-mode KPOINTS, usually used with band structures\n        if style == \"l\":\n            coord_type = \"Cartesian\" if lines[3].lower()[0] in \"ck\" \\\n                else \"Reciprocal\"\n            style = Kpoints.supported_modes.Line_mode\n            kpts = []\n            labels = []\n            patt = re.compile(r'([e0-9.\\-]+)\\s+([e0-9.\\-]+)\\s+([e0-9.\\-]+)'\n                              r'\\s*!*\\s*(.*)')\n            for i in range(4, len(lines)):\n                line = lines[i]\n                m = patt.match(line)\n                if m:\n                    kpts.append([float(m.group(1)), float(m.group(2)),\n                                 float(m.group(3))])\n                    labels.append(m.group(4).strip())\n            return Kpoints(comment=comment, num_kpts=num_kpts, style=style,\n                           kpts=kpts, coord_type=coord_type, labels=labels)\n\n        # Assume explicit KPOINTS if all else fails.\n        style = Kpoints.supported_modes.Cartesian if style in \"ck\" \\\n            else Kpoints.supported_modes.Reciprocal\n        kpts = []\n        kpts_weights = []\n        labels = []\n        tet_number = 0\n        tet_weight = 0\n        tet_connections = None\n\n        for i in range(3, 3 + num_kpts):\n            toks = lines[i].split()\n            kpts.append([float(j) for j in toks[0:3]])\n            kpts_weights.append(float(toks[3]))\n            if len(toks) > 4:\n                labels.append(toks[4])\n            else:\n                labels.append(None)\n        try:\n            # Deal with tetrahedron method\n            if lines[3 + num_kpts].strip().lower()[0] == \"t\":\n                toks = lines[4 + num_kpts].split()\n                tet_number = int(toks[0])\n                tet_weight = float(toks[1])\n                tet_connections = []\n                for i in range(5 + num_kpts, 5 + num_kpts + tet_number):\n                    toks = lines[i].split()\n                    tet_connections.append((int(toks[0]),\n                                            [int(toks[j])\n                                             for j in range(1, 5)]))\n        except IndexError:\n            pass\n\n        return Kpoints(comment=comment, num_kpts=num_kpts,\n                       style=Kpoints.supported_modes[str(style)],\n                       kpts=kpts, kpts_weights=kpts_weights,\n                       tet_number=tet_number, tet_weight=tet_weight,\n                       tet_connections=tet_connections, labels=labels)", "response": "Reads a Kpoints object from a string."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef as_dict(self):\n        d = {\"comment\": self.comment, \"nkpoints\": self.num_kpts,\n             \"generation_style\": self.style.name, \"kpoints\": self.kpts,\n             \"usershift\": self.kpts_shift,\n             \"kpts_weights\": self.kpts_weights, \"coord_type\": self.coord_type,\n             \"labels\": self.labels, \"tet_number\": self.tet_number,\n             \"tet_weight\": self.tet_weight,\n             \"tet_connections\": self.tet_connections}\n\n        optional_paras = [\"genvec1\", \"genvec2\", \"genvec3\", \"shift\"]\n        for para in optional_paras:\n            if para in self.__dict__:\n                d[para] = self.__dict__[para]\n        d[\"@module\"] = self.__class__.__module__\n        d[\"@class\"] = self.__class__.__name__\n        return d", "response": "json friendly dict representation of Kpoints"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef element(self):\n        element = self.keywords[\"VRHFIN\"].split(\":\")[0].strip()\n        try:\n            return Element(element).symbol\n        except ValueError:\n            # VASP incorrectly gives the element symbol for Xe as \"X\"\n            # Some potentials, e.g., Zr_sv, gives the symbol as r.\n            if element == \"X\":\n                return \"Xe\"\n            return Element(self.symbol.split(\"_\")[0]).symbol", "response": "Attempt to return the atomic symbol based on the VRHFIN keyword."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ninitializes the POTCARs from a list of symbols.", "response": "def set_symbols(self, symbols, functional=None,\n                    sym_potcar_map=None):\n        \"\"\"\n        Initialize the POTCAR from a set of symbols. Currently, the POTCARs can\n        be fetched from a location specified in .pmgrc.yaml. Use pmg config\n        to add this setting.\n\n        Args:\n            symbols ([str]): A list of element symbols\n            functional (str): The functional to use. If None, the setting\n                PMG_DEFAULT_FUNCTIONAL in .pmgrc.yaml is used, or if this is\n                not set, it will default to PBE.\n            sym_potcar_map (dict): A map of symbol:raw POTCAR string. If\n                sym_potcar_map is specified, POTCARs will be generated from\n                the given map data rather than the config file location.\n        \"\"\"\n        del self[:]\n        if sym_potcar_map:\n            for el in symbols:\n                self.append(PotcarSingle(sym_potcar_map[el]))\n        else:\n            for el in symbols:\n                p = PotcarSingle.from_symbol_and_functional(el, functional)\n                self.append(p)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nwriting the input to a directory.", "response": "def write_input(self, output_dir=\".\", make_dir_if_not_present=True):\n        \"\"\"\n        Write VASP input to a directory.\n\n        Args:\n            output_dir (str): Directory to write to. Defaults to current\n                directory (\".\").\n            make_dir_if_not_present (bool): Create the directory if not\n                present. Defaults to True.\n        \"\"\"\n        if make_dir_if_not_present and not os.path.exists(output_dir):\n            os.makedirs(output_dir)\n        for k, v in self.items():\n            with zopen(os.path.join(output_dir, k), \"wt\") as f:\n                f.write(v.__str__())"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef from_directory(input_dir, optional_files=None):\n        sub_d = {}\n        for fname, ftype in [(\"INCAR\", Incar), (\"KPOINTS\", Kpoints),\n                             (\"POSCAR\", Poscar), (\"POTCAR\", Potcar)]:\n            fullzpath = zpath(os.path.join(input_dir, fname))\n            sub_d[fname.lower()] = ftype.from_file(fullzpath)\n        sub_d[\"optional_files\"] = {}\n        if optional_files is not None:\n            for fname, ftype in optional_files.items():\n                sub_d[\"optional_files\"][fname] = \\\n                    ftype.from_file(os.path.join(input_dir, fname))\n        return VaspInput(**sub_d)", "response": "Reads in a set of VASP input from a directory."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef run_vasp(self, run_dir: PathLike = \".\",\n                 vasp_cmd: list = None,\n                 output_file: PathLike = \"vasp.out\",\n                 err_file: PathLike = \"vasp.err\"):\n        \"\"\"\n        Write input files and run VASP.\n\n        :param run_dir: Where to write input files and do the run.\n        :param vasp_cmd: Args to be supplied to run VASP. Otherwise, the\n            PMG_VASP_EXE in .pmgrc.yaml is used.\n        :param output_file: File to write output.\n        :param err_file: File to write err.\n        \"\"\"\n        self.write_input(output_dir=run_dir)\n        vasp_cmd = vasp_cmd or SETTINGS.get(\"PMG_VASP_EXE\")\n        vasp_cmd = [os.path.expanduser(os.path.expandvars(t)) for t in vasp_cmd]\n        if not vasp_cmd:\n            raise RuntimeError(\"You need to supply vasp_cmd or set the PMG_VASP_EXE in .pmgrc.yaml to run VASP.\")\n        with cd(run_dir):\n            with open(output_file, 'w') as f_std, \\\n                    open(err_file, \"w\", buffering=1) as f_err:\n                subprocess.check_call(vasp_cmd, stdout=f_std, stderr=f_err)", "response": "Runs VASP on the specified directory."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_kpoints(structure, min_distance=0, min_total_kpoints=1, \n                kppra=None, gap_distance=7, remove_symmetry=None, \n                include_gamma=\"auto\", header=\"simple\", incar=None):\n    \"\"\"\n    Get kpoints object from JHU servlet, per Wisesa-McGill-Mueller\n    methodology.  Refer to http://muellergroup.jhu.edu/K-Points.html\n    and P. Wisesa, K. A. McGill, T. Mueller, Phys. Rev. B 93, \n    155109 (2016)\n\n    Args:\n        structure (Structure): structure object\n        min_distance (float): The minimum allowed distance \n            between lattice points on the real-space superlattice \n        min_total_kpoints (int): The minimum allowed number of \n            total k-points in the Brillouin zone.\n        kppra (float): minimum k-points per reciprocal atom.\n        gap_distance (float): auto-detection threshold for\n            non-periodicity (in slabs, nanowires, etc.)\n        remove_symmetry (string): optional flag to control\n            symmetry options, can be none, structural, \n            time_reversal, or all\n        include_gamma (string or bool): whether to include\n            gamma point\n        header (string): \"verbose\" or \"simple\", denotes\n            the verbosity of the header\n        incar (Incar): incar object to upload\n    \"\"\"\n    config = locals()\n    config.pop(\"structure\", \"incar\")\n\n    # Generate PRECALC string\n    precalc = ''.join([\"{}={}\\n\".format(k, v) for k, v in config.items()])\n    precalc = precalc.replace('_', '').upper()\n    precalc = precalc.replace('REMOVESYMMETRY', 'REMOVE_SYMMETRY')\n    precalc = precalc.replace('TIMEREVERSAL', 'TIME_REVERSAL')\n    url = \"http://muellergroup.jhu.edu:8080/PreCalcServer/PreCalcServlet\"\n    temp_dir_name = tempfile.mkdtemp()\n    cwd = os.getcwd()\n    os.chdir(temp_dir_name)\n\n    precalc_file = open(\"PRECALC\", 'w+')\n    poscar_file = open(\"POSCAR\", 'w+')\n    incar_file = open(\"INCAR\", 'w+')\n    \n    precalc_file.write(precalc)\n    poscar_file.write(structure.to(\"POSCAR\"))\n    files = [(\"fileupload\", precalc_file),\n             (\"fileupload\", poscar_file)]\n    if incar:\n        incar_file.write(incar.get_string())\n        files.append((\"fileupload\", incar_file))\n    \n    precalc_file.seek(0)\n    poscar_file.seek(0)\n    incar_file.seek(0)\n    \n    r = requests.post(url, files=files)\n    \n    precalc_file.close()\n    poscar_file.close()\n    incar_file.close()\n    kpoints = Kpoints.from_string(r.text)\n    os.chdir(cwd)\n\n    shutil.rmtree(temp_dir_name)\n\n    return kpoints", "response": "Returns a k - points object from the JHU servlet."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the simplex facets of the Convex Hull.", "response": "def get_facets(qhull_data, joggle=False):\n    \"\"\"\n    Get the simplex facets for the Convex hull.\n\n    Args:\n        qhull_data (np.ndarray): The data from which to construct the convex\n            hull as a Nxd array (N being number of data points and d being the\n            dimension)\n        joggle (boolean): Whether to joggle the input to avoid precision\n            errors.\n\n    Returns:\n        List of simplices of the Convex Hull.\n    \"\"\"\n    if joggle:\n        return ConvexHull(qhull_data, qhull_options=\"QJ i\").simplices\n    else:\n        return ConvexHull(qhull_data, qhull_options=\"Qt i\").simplices"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef uniquelines(q):\n    setoflines = set()\n    for facets in q:\n        for line in itertools.combinations(facets, 2):\n            setoflines.add(tuple(sorted(line)))\n    return setoflines", "response": "Given all the facets convert it into a set of unique lines."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nconvert a 2D coordinate into a triangular - based coordinate system.", "response": "def triangular_coord(coord):\n    \"\"\"\n    Convert a 2D coordinate into a triangle-based coordinate system for a\n    prettier phase diagram.\n\n    Args:\n        coordinate: coordinate used in the convex hull computation.\n\n    Returns:\n        coordinates in a triangular-based coordinate system.\n    \"\"\"\n    unitvec = np.array([[1, 0], [0.5, math.sqrt(3) / 2]])\n    result = np.dot(np.array(coord), unitvec)\n    return result.transpose()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nordering the entries (their coordinates) in a phase diagram plot according to the user specified ordering. Ordering should be given as ['Up', 'Left', 'Right'], where Up, Left and Right are the names of the entries in the upper, left and right corners of the triangle respectively. Args: lines: list of list of coordinates for lines in the PD. stable_entries: {coordinate : entry} for each stable node in the phase diagram. (Each coordinate can only have one stable phase) unstable_entries: {entry: coordinates} for all unstable nodes in the phase diagram. ordering: Ordering of the phase diagram, given as a list ['Up', 'Left','Right'] Returns: (newlines, newstable_entries, newunstable_entries): - newlines is a list of list of coordinates for lines in the PD. - newstable_entries is a {coordinate : entry} for each stable node in the phase diagram. (Each coordinate can only have one stable phase) - newunstable_entries is a {entry: coordinates} for all unstable nodes in the phase diagram.", "response": "def order_phase_diagram(lines, stable_entries, unstable_entries, ordering):\n    \"\"\"\n    Orders the entries (their coordinates) in a phase diagram plot according\n    to the user specified ordering.\n    Ordering should be given as ['Up', 'Left', 'Right'], where Up,\n    Left and Right are the names of the entries in the upper, left and right\n    corners of the triangle respectively.\n\n    Args:\n        lines: list of list of coordinates for lines in the PD.\n        stable_entries: {coordinate : entry} for each stable node in the\n            phase diagram. (Each coordinate can only have one stable phase)\n        unstable_entries: {entry: coordinates} for all unstable nodes in the\n            phase diagram.\n        ordering: Ordering of the phase diagram, given as a list ['Up',\n            'Left','Right']\n\n    Returns:\n        (newlines, newstable_entries, newunstable_entries):\n        - newlines is a list of list of coordinates for lines in the PD.\n        - newstable_entries is a {coordinate : entry} for each stable node\n        in the phase diagram. (Each coordinate can only have one\n        stable phase)\n        - newunstable_entries is a {entry: coordinates} for all unstable\n        nodes in the phase diagram.\n    \"\"\"\n    yup = -1000.0\n    xleft = 1000.0\n    xright = -1000.0\n\n    for coord in stable_entries:\n        if coord[0] > xright:\n            xright = coord[0]\n            nameright = stable_entries[coord].name\n        if coord[0] < xleft:\n            xleft = coord[0]\n            nameleft = stable_entries[coord].name\n        if coord[1] > yup:\n            yup = coord[1]\n            nameup = stable_entries[coord].name\n\n    if (not nameup in ordering) or (not nameright in ordering) or \\\n            (not nameleft in ordering):\n        raise ValueError(\n            'Error in ordering_phase_diagram : \\n\"{up}\", \"{left}\" and \"{'\n            'right}\"'\n            ' should be in ordering : {ord}'.format(up=nameup, left=nameleft,\n                                                    right=nameright,\n                                                    ord=ordering))\n\n    cc = np.array([0.5, np.sqrt(3.0) / 6.0], np.float)\n\n    if nameup == ordering[0]:\n        if nameleft == ordering[1]:\n            # The coordinates were already in the user ordering\n            return lines, stable_entries, unstable_entries\n        else:\n            newlines = [[np.array(1.0 - x), y] for x, y in lines]\n            newstable_entries = {(1.0 - c[0], c[1]): entry\n                                 for c, entry in stable_entries.items()}\n            newunstable_entries = {entry: (1.0 - c[0], c[1])\n                                   for entry, c in\n                                   unstable_entries.items()}\n            return newlines, newstable_entries, newunstable_entries\n    elif nameup == ordering[1]:\n        if nameleft == ordering[2]:\n            c120 = np.cos(2.0 * np.pi / 3.0)\n            s120 = np.sin(2.0 * np.pi / 3.0)\n            newlines = []\n            for x, y in lines:\n                newx = np.zeros_like(x)\n                newy = np.zeros_like(y)\n                for ii, xx in enumerate(x):\n                    newx[ii] = c120 * (xx - cc[0]) - s120 * (y[ii] - cc[1]) + \\\n                               cc[0]\n                    newy[ii] = s120 * (xx - cc[0]) + c120 * (y[ii] - cc[1]) + \\\n                               cc[1]\n                newlines.append([newx, newy])\n            newstable_entries = {\n                (c120 * (c[0] - cc[0]) - s120 * (c[1] - cc[1]) + cc[0],\n                 s120 * (c[0] - cc[0]) + c120 * (c[1] - cc[1]) + cc[1]): entry\n                for c, entry in stable_entries.items()}\n            newunstable_entries = {\n                entry: (c120 * (c[0] - cc[0]) - s120 * (c[1] - cc[1]) + cc[0],\n                        s120 * (c[0] - cc[0]) + c120 * (c[1] - cc[1]) + cc[1])\n                for entry, c in unstable_entries.items()}\n            return newlines, newstable_entries, newunstable_entries\n        else:\n            c120 = np.cos(2.0 * np.pi / 3.0)\n            s120 = np.sin(2.0 * np.pi / 3.0)\n            newlines = []\n            for x, y in lines:\n                newx = np.zeros_like(x)\n                newy = np.zeros_like(y)\n                for ii, xx in enumerate(x):\n                    newx[ii] = -c120 * (xx - 1.0) - s120 * y[ii] + 1.0\n                    newy[ii] = -s120 * (xx - 1.0) + c120 * y[ii]\n                newlines.append([newx, newy])\n            newstable_entries = {(-c120 * (c[0] - 1.0) - s120 * c[1] + 1.0,\n                                  -s120 * (c[0] - 1.0) + c120 * c[1]): entry\n                                 for c, entry in stable_entries.items()}\n            newunstable_entries = {\n                entry: (-c120 * (c[0] - 1.0) - s120 * c[1] + 1.0,\n                        -s120 * (c[0] - 1.0) + c120 * c[1])\n                for entry, c in unstable_entries.items()}\n            return newlines, newstable_entries, newunstable_entries\n    elif nameup == ordering[2]:\n        if nameleft == ordering[0]:\n            c240 = np.cos(4.0 * np.pi / 3.0)\n            s240 = np.sin(4.0 * np.pi / 3.0)\n            newlines = []\n            for x, y in lines:\n                newx = np.zeros_like(x)\n                newy = np.zeros_like(y)\n                for ii, xx in enumerate(x):\n                    newx[ii] = c240 * (xx - cc[0]) - s240 * (y[ii] - cc[1]) + \\\n                               cc[0]\n                    newy[ii] = s240 * (xx - cc[0]) + c240 * (y[ii] - cc[1]) + \\\n                               cc[1]\n                newlines.append([newx, newy])\n            newstable_entries = {\n                (c240 * (c[0] - cc[0]) - s240 * (c[1] - cc[1]) + cc[0],\n                 s240 * (c[0] - cc[0]) + c240 * (c[1] - cc[1]) + cc[1]): entry\n                for c, entry in stable_entries.items()}\n            newunstable_entries = {\n                entry: (c240 * (c[0] - cc[0]) - s240 * (c[1] - cc[1]) + cc[0],\n                        s240 * (c[0] - cc[0]) + c240 * (c[1] - cc[1]) + cc[1])\n                for entry, c in unstable_entries.items()}\n            return newlines, newstable_entries, newunstable_entries\n        else:\n            c240 = np.cos(4.0 * np.pi / 3.0)\n            s240 = np.sin(4.0 * np.pi / 3.0)\n            newlines = []\n            for x, y in lines:\n                newx = np.zeros_like(x)\n                newy = np.zeros_like(y)\n                for ii, xx in enumerate(x):\n                    newx[ii] = -c240 * xx - s240 * y[ii]\n                    newy[ii] = -s240 * xx + c240 * y[ii]\n                newlines.append([newx, newy])\n            newstable_entries = {(-c240 * c[0] - s240 * c[1],\n                                  -s240 * c[0] + c240 * c[1]): entry\n                                 for c, entry in stable_entries.items()}\n            newunstable_entries = {entry: (-c240 * c[0] - s240 * c[1],\n                                           -s240 * c[0] + c240 * c[1])\n                                   for entry, c in unstable_entries.items()}\n            return newlines, newstable_entries, newunstable_entries"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef pd_coords(self, comp):\n        if set(comp.elements).difference(self.elements):\n            raise ValueError('{} has elements not in the phase diagram {}'\n                             ''.format(comp, self.elements))\n        return np.array(\n            [comp.get_atomic_fraction(el) for el in self.elements[1:]])", "response": "Returns the coordinates of the phase diagram in that space."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the formation energy for an entry from the elemental references.", "response": "def get_form_energy(self, entry):\n        \"\"\"\n        Returns the formation energy for an entry (NOT normalized) from the\n        elemental references.\n\n        Args:\n            entry: A PDEntry-like object.\n\n        Returns:\n            Formation energy from the elemental references.\n        \"\"\"\n        c = entry.composition\n        return entry.energy - sum([c[el] * self.el_refs[el].energy_per_atom\n                                   for el in c.elements])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget any facet that a composition falls into.", "response": "def _get_facet_and_simplex(self, comp):\n        \"\"\"\n        Get any facet that a composition falls into. Cached so successive\n        calls at same composition are fast.\n        \"\"\"\n        c = self.pd_coords(comp)\n        for f, s in zip(self.facets, self.simplexes):\n            if s.in_simplex(c, PhaseDiagram.numerical_tol / 10):\n                return f, s\n        raise RuntimeError(\"No facet found for comp = {}\".format(comp))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _get_facet_chempots(self, facet):\n        complist = [self.qhull_entries[i].composition for i in facet]\n        energylist = [self.qhull_entries[i].energy_per_atom for i in facet]\n        m = [[c.get_atomic_fraction(e) for e in self.elements] for c in\n             complist]\n        chempots = np.linalg.solve(m, energylist)\n        return dict(zip(self.elements, chempots))", "response": "Calculates the chemical potentials for each element within a facet."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_decomposition(self, comp):\n        facet, simplex = self._get_facet_and_simplex(comp)\n        decomp_amts = simplex.bary_coords(self.pd_coords(comp))\n        return {self.qhull_entries[f]: amt\n                for f, amt in zip(facet, decomp_amts)\n                if abs(amt) > PhaseDiagram.numerical_tol}", "response": "Provides the decomposition at a particular composition."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the lowest energy of the given composition.", "response": "def get_hull_energy(self, comp):\n        \"\"\"\n        Args:\n            comp (Composition): Input composition\n\n        Returns:\n            Energy of lowest energy equilibrium at desired composition. Not\n            normalized by atoms, i.e. E(Li4O2) = 2 * E(Li2O)\n        \"\"\"\n        e = 0\n        for k, v in self.get_decomposition(comp).items():\n            e += k.energy_per_atom * v\n        return e * comp.num_atoms"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_decomp_and_e_above_hull(self, entry, allow_negative=False):\n        if entry in self.stable_entries:\n            return {entry: 1}, 0\n\n        comp = entry.composition\n        facet, simplex = self._get_facet_and_simplex(comp)\n        decomp_amts = simplex.bary_coords(self.pd_coords(comp))\n        decomp = {self.qhull_entries[f]: amt\n                  for f, amt in zip(facet, decomp_amts)\n                  if abs(amt) > PhaseDiagram.numerical_tol}\n        energies = [self.qhull_entries[i].energy_per_atom for i in facet]\n        ehull = entry.energy_per_atom - np.dot(decomp_amts, energies)\n        if allow_negative or ehull >= -PhaseDiagram.numerical_tol:\n            return decomp, ehull\n        raise ValueError(\"No valid decomp found!\")", "response": "Provides the decomposition and energy above convex hull for an entry."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_equilibrium_reaction_energy(self, entry):\n        if entry not in self.stable_entries:\n            raise ValueError(\"Equilibrium reaction energy is available only \"\n                             \"for stable entries.\")\n        if entry.is_element:\n            return 0\n        entries = [e for e in self.stable_entries if e != entry]\n        modpd = PhaseDiagram(entries, self.elements)\n        return modpd.get_decomp_and_e_above_hull(entry,\n                                                 allow_negative=True)[1]", "response": "Returns the reaction energy of a stable entry."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_transition_chempots(self, element):\n        if element not in self.elements:\n            raise ValueError(\"get_transition_chempots can only be called with \"\n                             \"elements in the phase diagram.\")\n\n        critical_chempots = []\n        for facet in self.facets:\n            chempots = self._get_facet_chempots(facet)\n            critical_chempots.append(chempots[element])\n\n        clean_pots = []\n        for c in sorted(critical_chempots):\n            if len(clean_pots) == 0:\n                clean_pots.append(c)\n            else:\n                if abs(c - clean_pots[-1]) > PhaseDiagram.numerical_tol:\n                    clean_pots.append(c)\n        clean_pots.reverse()\n        return tuple(clean_pots)", "response": "Returns a sorted sequence of critical chemical potentials for an element in the PhaseDiagram."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the critical compositions along the tieline between two compositions.", "response": "def get_critical_compositions(self, comp1, comp2):\n        \"\"\"\n        Get the critical compositions along the tieline between two\n        compositions. I.e. where the decomposition products change.\n        The endpoints are also returned.\n        Args:\n            comp1, comp2 (Composition): compositions that define the tieline\n        Returns:\n            [(Composition)]: list of critical compositions. All are of\n                the form x * comp1 + (1-x) * comp2\n        \"\"\"\n\n        n1 = comp1.num_atoms\n        n2 = comp2.num_atoms\n        pd_els = self.elements\n\n        # the reduced dimensionality Simplexes don't use the\n        # first element in the PD\n        c1 = self.pd_coords(comp1)\n        c2 = self.pd_coords(comp2)\n\n        # none of the projections work if c1 == c2, so just return *copies*\n        # of the inputs\n        if np.all(c1 == c2):\n            return [comp1.copy(), comp2.copy()]\n\n        intersections = [c1, c2]\n        for sc in self.simplexes:\n            intersections.extend(sc.line_intersection(c1, c2))\n        intersections = np.array(intersections)\n\n        # find position along line\n        l = (c2 - c1)\n        l /= np.sum(l ** 2) ** 0.5\n        proj = np.dot(intersections - c1, l)\n\n        # only take compositions between endpoints\n        proj = proj[np.logical_and(proj > -self.numerical_tol,\n                                   proj < proj[1] + self.numerical_tol)]\n        proj.sort()\n\n        # only unique compositions\n        valid = np.ones(len(proj), dtype=np.bool)\n        valid[1:] = proj[1:] > proj[:-1] + self.numerical_tol\n        proj = proj[valid]\n\n        ints = c1 + l * proj[:, None]\n        # reconstruct full-dimensional composition array\n        cs = np.concatenate([np.array([1 - np.sum(ints, axis=-1)]).T,\n                             ints], axis=-1)\n        # mixing fraction when compositions are normalized\n        x = proj / np.dot(c2 - c1, l)\n        # mixing fraction when compositions are not normalized\n        x_unnormalized = x * n1 / (n2 + x * (n1 - n2))\n        num_atoms = n1 + (n2 - n1) * x_unnormalized\n        cs *= num_atoms[:, None]\n        return [Composition((c, v) for c, v in zip(pd_els, m)) for m in cs]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_element_profile(self, element, comp, comp_tol=1e-5):\n        element = get_el_sp(element)\n        element = Element(element.symbol)\n\n        if element not in self.elements:\n            raise ValueError(\"get_transition_chempots can only be called with\"\n                             \" elements in the phase diagram.\")\n        gccomp = Composition({el: amt for el, amt in comp.items()\n                              if el != element})\n        elref = self.el_refs[element]\n        elcomp = Composition(element.symbol)\n        evolution = []\n\n        for cc in self.get_critical_compositions(elcomp, gccomp)[1:]:\n            decomp_entries = self.get_decomposition(cc).keys()\n            decomp = [k.composition for k in decomp_entries]\n            rxn = Reaction([comp], decomp + [elcomp])\n            rxn.normalize_to(comp)\n            c = self.get_composition_chempots(cc + elcomp * 1e-5)[element]\n            amt = -rxn.coeffs[rxn.all_comp.index(elcomp)]\n            evolution.append({'chempot': c,\n                              'evolution': amt,\n                              'element_reference': elref,\n                              'reaction': rxn, 'entries': decomp_entries})\n        return evolution", "response": "Returns the evolution data for an element in the phase diagram."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_chempot_range_map(self, elements, referenced=True, joggle=True):\n        all_chempots = []\n        pd = self\n        facets = pd.facets\n        for facet in facets:\n            chempots = self._get_facet_chempots(facet)\n            all_chempots.append([chempots[el] for el in pd.elements])\n        inds = [pd.elements.index(el) for el in elements]\n        el_energies = {el: 0.0 for el in elements}\n        if referenced:\n            el_energies = {el: pd.el_refs[el].energy_per_atom\n                           for el in elements}\n        chempot_ranges = collections.defaultdict(list)\n        vertices = [list(range(len(self.elements)))]\n        if len(all_chempots) > len(self.elements):\n            vertices = get_facets(all_chempots, joggle=joggle)\n        for ufacet in vertices:\n            for combi in itertools.combinations(ufacet, 2):\n                data1 = facets[combi[0]]\n                data2 = facets[combi[1]]\n                common_ent_ind = set(data1).intersection(set(data2))\n                if len(common_ent_ind) == len(elements):\n                    common_entries = [pd.qhull_entries[i]\n                                      for i in common_ent_ind]\n                    data = np.array([[all_chempots[i][j]\n                                      - el_energies[pd.elements[j]]\n                                      for j in inds] for i in combi])\n                    sim = Simplex(data)\n                    for entry in common_entries:\n                        chempot_ranges[entry].append(sim)\n\n        return chempot_ranges", "response": "Returns a chemical potential range map for each stable entry."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef getmu_vertices_stability_phase(self, target_comp, dep_elt, tol_en=1e-2):\n        muref = np.array([self.el_refs[e].energy_per_atom\n                          for e in self.elements if e != dep_elt])\n        chempot_ranges = self.get_chempot_range_map(\n            [e for e in self.elements if e != dep_elt])\n\n        for e in self.elements:\n            if not e in target_comp.elements:\n                target_comp = target_comp + Composition({e: 0.0})\n        coeff = [-target_comp[e] for e in self.elements if e != dep_elt]\n        for e in chempot_ranges.keys():\n            if e.composition.reduced_composition == \\\n                    target_comp.reduced_composition:\n                multiplicator = e.composition[dep_elt] / target_comp[dep_elt]\n                ef = e.energy / multiplicator\n                all_coords = []\n                for s in chempot_ranges[e]:\n                    for v in s._coords:\n                        elts = [e for e in self.elements if e != dep_elt]\n                        res = {}\n                        for i in range(len(elts)):\n                            res[elts[i]] = v[i] + muref[i]\n                        res[dep_elt] = (np.dot(v + muref, coeff) + ef) / \\\n                                       target_comp[dep_elt]\n                        already_in = False\n                        for di in all_coords:\n                            dict_equals = True\n                            for k in di:\n                                if abs(di[k] - res[k]) > tol_en:\n                                    dict_equals = False\n                                    break\n                            if dict_equals:\n                                already_in = True\n                                break\n                        if not already_in:\n                            all_coords.append(res)\n        return all_coords", "response": "This method returns the set of chemical potentials corresponding to the vertices of the simplex in the chemical potential phase diagram."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a set of chemical potentials corresponding to the max and min chemical potential of the open element for a given composition. It is quite common to have for instance a ternary oxide (e.g., ABO3) for which you want to know what are the A and B chemical potential leading to the highest and lowest oxygen chemical potential (reducing and oxidizing conditions). This is useful for defect computations. Args: target_comp: A Composition object open_elt: Element that you want to constrain to be max or min Returns: {Element:(mu_min,mu_max)}: Chemical potentials are given in \"absolute\" values (i.e., not referenced to 0)", "response": "def get_chempot_range_stability_phase(self, target_comp, open_elt):\n        \"\"\"\n        returns a set of chemical potentials corresponding to the max and min\n        chemical potential of the open element for a given composition. It is\n        quite common to have for instance a ternary oxide (e.g., ABO3) for\n        which you want to know what are the A and B chemical potential leading\n        to the highest and lowest oxygen chemical potential (reducing and\n        oxidizing conditions). This is useful for defect computations.\n\n        Args:\n            target_comp: A Composition object\n            open_elt: Element that you want to constrain to be max or min\n\n        Returns:\n             {Element:(mu_min,mu_max)}: Chemical potentials are given in\n             \"absolute\" values (i.e., not referenced to 0)\n        \"\"\"\n        muref = np.array([self.el_refs[e].energy_per_atom\n                          for e in self.elements if e != open_elt])\n        chempot_ranges = self.get_chempot_range_map(\n            [e for e in self.elements if e != open_elt])\n        for e in self.elements:\n            if not e in target_comp.elements:\n                target_comp = target_comp + Composition({e: 0.0})\n        coeff = [-target_comp[e] for e in self.elements if e != open_elt]\n        max_open = -float('inf')\n        min_open = float('inf')\n        max_mus = None\n        min_mus = None\n        for e in chempot_ranges.keys():\n            if e.composition.reduced_composition == \\\n                    target_comp.reduced_composition:\n                multiplicator = e.composition[open_elt] / target_comp[open_elt]\n                ef = e.energy / multiplicator\n                all_coords = []\n                for s in chempot_ranges[e]:\n                    for v in s._coords:\n                        all_coords.append(v)\n                        if (np.dot(v + muref, coeff) + ef) / target_comp[\n                                open_elt] > max_open:\n                            max_open = (np.dot(v + muref, coeff) + ef) / \\\n                                       target_comp[open_elt]\n                            max_mus = v\n                        if (np.dot(v + muref, coeff) + ef) / target_comp[\n                                open_elt] < min_open:\n                            min_open = (np.dot(v + muref, coeff) + ef) / \\\n                                       target_comp[open_elt]\n                            min_mus = v\n        elts = [e for e in self.elements if e != open_elt]\n        res = {}\n        for i in range(len(elts)):\n            res[elts[i]] = (min_mus[i] + muref[i], max_mus[i] + muref[i])\n        res[open_elt] = (min_open, max_open)\n        return res"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the CompoundPhaseDiagram object which can then be used for plotting.", "response": "def get_compound_pd(self):\n        \"\"\"\n        Get the CompoundPhaseDiagram object, which can then be used for\n        plotting.\n\n        Returns:\n            (CompoundPhaseDiagram)\n        \"\"\"\n        # For this plot, since the reactions are reported in formation\n        # energies, we need to set the energies of the terminal compositions\n        # to 0. So we make create copies with 0 energy.\n        entry1 = PDEntry(self.entry1.composition, 0)\n        entry2 = PDEntry(self.entry2.composition, 0)\n\n        cpd = CompoundPhaseDiagram(\n            self.rxn_entries + [entry1, entry2],\n            [Composition(entry1.composition.reduced_formula),\n             Composition(entry2.composition.reduced_formula)],\n            normalize_terminal_compositions=False) \n        return cpd"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nplots data for the current phase diagram.", "response": "def pd_plot_data(self):\n        \"\"\"\n        Plot data for phase diagram.\n        2-comp - Full hull with energies\n        3/4-comp - Projection into 2D or 3D Gibbs triangle.\n\n        Returns:\n            (lines, stable_entries, unstable_entries):\n            - lines is a list of list of coordinates for lines in the PD.\n            - stable_entries is a {coordinate : entry} for each stable node\n            in the phase diagram. (Each coordinate can only have one\n            stable phase)\n            - unstable_entries is a {entry: coordinates} for all unstable\n            nodes in the phase diagram.\n        \"\"\"\n        pd = self._pd\n        entries = pd.qhull_entries\n        data = np.array(pd.qhull_data)\n        lines = []\n        stable_entries = {}\n        for line in self.lines:\n            entry1 = entries[line[0]]\n            entry2 = entries[line[1]]\n            if self._dim < 3:\n                x = [data[line[0]][0], data[line[1]][0]]\n                y = [pd.get_form_energy_per_atom(entry1),\n                     pd.get_form_energy_per_atom(entry2)]\n                coord = [x, y]\n            elif self._dim == 3:\n                coord = triangular_coord(data[line, 0:2])\n            else:\n                coord = tet_coord(data[line, 0:3])\n            lines.append(coord)\n            labelcoord = list(zip(*coord))\n            stable_entries[labelcoord[0]] = entry1\n            stable_entries[labelcoord[1]] = entry2\n\n        all_entries = pd.all_entries\n        all_data = np.array(pd.all_entries_hulldata)\n        unstable_entries = dict()\n        stable = pd.stable_entries\n        for i in range(0, len(all_entries)):\n            entry = all_entries[i]\n            if entry not in stable:\n                if self._dim < 3:\n                    x = [all_data[i][0], all_data[i][0]]\n                    y = [pd.get_form_energy_per_atom(entry),\n                         pd.get_form_energy_per_atom(entry)]\n                    coord = [x, y]\n                elif self._dim == 3:\n                    coord = triangular_coord([all_data[i, 0:2],\n                                              all_data[i, 0:2]])\n                else:\n                    coord = tet_coord([all_data[i, 0:3], all_data[i, 0:3],\n                                       all_data[i, 0:3]])\n                labelcoord = list(zip(*coord))\n                unstable_entries[entry] = labelcoord[0]\n\n        return lines, stable_entries, unstable_entries"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndraw the element profile evolution by varying the chemical potential of an element.", "response": "def plot_element_profile(self, element, comp, show_label_index=None,\n                             xlim=5):\n        \"\"\"\n        Draw the element profile plot for a composition varying different\n        chemical potential of an element.\n        X value is the negative value of the chemical potential reference to\n        elemental chemical potential. For example, if choose Element(\"Li\"),\n        X= -(\u00b5Li-\u00b5Li0), which corresponds to the voltage versus metal anode.\n        Y values represent for the number of element uptake in this composition\n        (unit: per atom). All reactions are printed to help choosing the\n        profile steps you want to show label in the plot.\n\n        Args:\n         element (Element): An element of which the chemical potential is\n            considered. It also must be in the phase diagram.\n         comp (Composition): A composition.\n         show_label_index (list of integers): The labels for reaction products\n            you want to show in the plot. Default to None (not showing any\n            annotation for reaction products). For the profile steps you want\n            to show the labels, just add it to the show_label_index. The\n            profile step counts from zero. For example, you can set\n            show_label_index=[0, 2, 5] to label profile step 0,2,5.\n         xlim (float): The max x value. x value is from 0 to xlim. Default to\n            5 eV.\n\n        Returns:\n            Plot of element profile evolution by varying the chemical potential\n            of an element.\n        \"\"\"\n        plt = pretty_plot(12, 8)\n        pd = self._pd\n        evolution = pd.get_element_profile(element, comp)\n        num_atoms = evolution[0][\"reaction\"].reactants[0].num_atoms\n        element_energy = evolution[0]['chempot']\n        for i, d in enumerate(evolution):\n            v = -(d[\"chempot\"] - element_energy)\n            print (\"index= %s, -\\u0394\\u03BC=%.4f(eV),\" % (i, v), d[\"reaction\"])\n            if i != 0:\n                plt.plot([x2, x2], [y1, d[\"evolution\"] / num_atoms],\n                         'k', linewidth=2.5)\n            x1 = v\n            y1 = d[\"evolution\"] / num_atoms\n\n            if i != len(evolution) - 1:\n                x2 = - (evolution[i + 1][\"chempot\"] - element_energy)\n            else:\n                x2 = 5.0\n            if show_label_index is not None and i in show_label_index:\n                products = [re.sub(r\"(\\d+)\", r\"$_{\\1}$\", p.reduced_formula)\n                            for p in d[\"reaction\"].products\n                            if p.reduced_formula != element.symbol]\n                plt.annotate(\", \".join(products), xy=(v + 0.05, y1 + 0.05),\n                             fontsize=24, color='r')\n                plt.plot([x1, x2], [y1, y1], 'r', linewidth=3)\n            else:\n                plt.plot([x1, x2], [y1, y1], 'k', linewidth=2.5)\n\n        plt.xlim((0, xlim))\n        plt.xlabel(\"-$\\\\Delta{\\\\mu}$ (eV)\")\n        plt.ylabel(\"Uptake per atom\")\n\n        return plt"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a 2D plot of the data of the ICSD and MP.", "response": "def _get_2d_plot(self, label_stable=True, label_unstable=True,\n                     ordering=None, energy_colormap=None, vmin_mev=-60.0,\n                     vmax_mev=60.0, show_colorbar=True,\n                     process_attributes=False, plt=None):\n        \"\"\"\n        Shows the plot using pylab.  Usually I won't do imports in methods,\n        but since plotting is a fairly expensive library to load and not all\n        machines have matplotlib installed, I have done it this way.\n        \"\"\"\n        if plt is None:\n            plt = pretty_plot(8, 6)\n        from matplotlib.font_manager import FontProperties\n        if ordering is None:\n            (lines, labels, unstable) = self.pd_plot_data\n        else:\n            (_lines, _labels, _unstable) = self.pd_plot_data\n            (lines, labels, unstable) = order_phase_diagram(\n                _lines, _labels, _unstable, ordering)\n        if energy_colormap is None:\n            if process_attributes:\n                for x, y in lines:\n                    plt.plot(x, y, \"k-\", linewidth=3, markeredgecolor=\"k\")\n                # One should think about a clever way to have \"complex\"\n                # attributes with complex processing options but with a clear\n                # logic. At this moment, I just use the attributes to know\n                # whether an entry is a new compound or an existing (from the\n                #  ICSD or from the MP) one.\n                for x, y in labels.keys():\n                    if labels[(x, y)].attribute is None or \\\n                                    labels[(x, y)].attribute == \"existing\":\n                        plt.plot(x, y, \"ko\", **self.plotkwargs)\n                    else:\n                        plt.plot(x, y, \"k*\", **self.plotkwargs)\n            else:\n                for x, y in lines:\n                    plt.plot(x, y, \"ko-\", **self.plotkwargs)\n        else:\n            from matplotlib.colors import Normalize, LinearSegmentedColormap\n            from matplotlib.cm import ScalarMappable\n            for x, y in lines:\n                plt.plot(x, y, \"k-\", markeredgecolor=\"k\")\n            vmin = vmin_mev / 1000.0\n            vmax = vmax_mev / 1000.0\n            if energy_colormap == 'default':\n                mid = - vmin / (vmax - vmin)\n                cmap = LinearSegmentedColormap.from_list(\n                    'my_colormap', [(0.0, '#005500'), (mid, '#55FF55'),\n                                    (mid, '#FFAAAA'), (1.0, '#FF0000')])\n            else:\n                cmap = energy_colormap\n            norm = Normalize(vmin=vmin, vmax=vmax)\n            _map = ScalarMappable(norm=norm, cmap=cmap)\n            _energies = [self._pd.get_equilibrium_reaction_energy(entry)\n                         for coord, entry in labels.items()]\n            energies = [en if en < 0.0 else -0.00000001 for en in _energies]\n            vals_stable = _map.to_rgba(energies)\n            ii = 0\n            if process_attributes:\n                for x, y in labels.keys():\n                    if labels[(x, y)].attribute is None or \\\n                                    labels[(x, y)].attribute == \"existing\":\n                        plt.plot(x, y, \"o\", markerfacecolor=vals_stable[ii],\n                                 markersize=12)\n                    else:\n                        plt.plot(x, y, \"*\", markerfacecolor=vals_stable[ii],\n                                 markersize=18)\n                    ii += 1\n            else:\n                for x, y in labels.keys():\n                    plt.plot(x, y, \"o\", markerfacecolor=vals_stable[ii],\n                             markersize=15)\n                    ii += 1\n\n        font = FontProperties()\n        font.set_weight(\"bold\")\n        font.set_size(24)\n\n        # Sets a nice layout depending on the type of PD. Also defines a\n        # \"center\" for the PD, which then allows the annotations to be spread\n        # out in a nice manner.\n        if len(self._pd.elements) == 3:\n            plt.axis(\"equal\")\n            plt.xlim((-0.1, 1.2))\n            plt.ylim((-0.1, 1.0))\n            plt.axis(\"off\")\n            center = (0.5, math.sqrt(3) / 6)\n        else:\n            all_coords = labels.keys()\n            miny = min([c[1] for c in all_coords])\n            ybuffer = max(abs(miny) * 0.1, 0.1)\n            plt.xlim((-0.1, 1.1))\n            plt.ylim((miny - ybuffer, ybuffer))\n            center = (0.5, miny / 2)\n            plt.xlabel(\"Fraction\", fontsize=28, fontweight='bold')\n            plt.ylabel(\"Formation energy (eV/fu)\", fontsize=28,\n                       fontweight='bold')\n\n        for coords in sorted(labels.keys(), key=lambda x: -x[1]):\n            entry = labels[coords]\n            label = entry.name\n\n            # The follow defines an offset for the annotation text emanating\n            # from the center of the PD. Results in fairly nice layouts for the\n            # most part.\n            vec = (np.array(coords) - center)\n            vec = vec / np.linalg.norm(vec) * 10 if np.linalg.norm(vec) != 0 \\\n                else vec\n            valign = \"bottom\" if vec[1] > 0 else \"top\"\n            if vec[0] < -0.01:\n                halign = \"right\"\n            elif vec[0] > 0.01:\n                halign = \"left\"\n            else:\n                halign = \"center\"\n            if label_stable:\n                if process_attributes and entry.attribute == 'new':\n                    plt.annotate(latexify(label), coords, xytext=vec,\n                                 textcoords=\"offset points\",\n                                 horizontalalignment=halign,\n                                 verticalalignment=valign,\n                                 fontproperties=font,\n                                 color='g')\n                else:\n                    plt.annotate(latexify(label), coords, xytext=vec,\n                                 textcoords=\"offset points\",\n                                 horizontalalignment=halign,\n                                 verticalalignment=valign,\n                                 fontproperties=font)\n\n        if self.show_unstable:\n            font = FontProperties()\n            font.set_size(16)\n            energies_unstable = [self._pd.get_e_above_hull(entry)\n                                 for entry, coord in unstable.items()]\n            if energy_colormap is not None:\n                energies.extend(energies_unstable)\n                vals_unstable = _map.to_rgba(energies_unstable)\n            ii = 0\n            for entry, coords in unstable.items():\n                ehull = self._pd.get_e_above_hull(entry)\n                if ehull < self.show_unstable:\n                    vec = (np.array(coords) - center)\n                    vec = vec / np.linalg.norm(vec) * 10 \\\n                        if np.linalg.norm(vec) != 0 else vec\n                    label = entry.name\n                    if energy_colormap is None:\n                        plt.plot(coords[0], coords[1], \"ks\", linewidth=3,\n                                 markeredgecolor=\"k\", markerfacecolor=\"r\",\n                                 markersize=8)\n                    else:\n                        plt.plot(coords[0], coords[1], \"s\", linewidth=3,\n                                 markeredgecolor=\"k\",\n                                 markerfacecolor=vals_unstable[ii],\n                                 markersize=8)\n                    if label_unstable:\n                        plt.annotate(latexify(label), coords, xytext=vec,\n                                     textcoords=\"offset points\",\n                                     horizontalalignment=halign, color=\"b\",\n                                     verticalalignment=valign,\n                                     fontproperties=font)\n                    ii += 1\n        if energy_colormap is not None and show_colorbar:\n            _map.set_array(energies)\n            cbar = plt.colorbar(_map)\n            cbar.set_label(\n                'Energy [meV/at] above hull (in red)\\nInverse energy ['\n                'meV/at] above hull (in green)',\n                rotation=-90, ha='left', va='center')\n            ticks = cbar.ax.get_yticklabels()\n            # cbar.ax.set_yticklabels(['${v}$'.format(\n            #     v=float(t.get_text().strip('$'))*1000.0) for t in ticks])\n        f = plt.gcf()\n        f.set_size_inches((8, 6))\n        plt.subplots_adjust(left=0.09, right=0.98, top=0.98, bottom=0.07)\n        return plt"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nwrite the phase diagram to an image in a stream.", "response": "def write_image(self, stream, image_format=\"svg\", **kwargs):\n        \"\"\"\n        Writes the phase diagram to an image in a stream.\n\n        Args:\n            stream:\n                stream to write to. Can be a file stream or a StringIO stream.\n            image_format\n                format for image. Can be any of matplotlib supported formats.\n                Defaults to svg for best results for vector graphics.\n            \\\\*\\\\*kwargs: Pass through to get_plot functino.\n        \"\"\"\n        plt = self.get_plot(**kwargs)\n\n        f = plt.gcf()\n        f.set_size_inches((12, 10))\n\n        plt.savefig(stream, format=image_format)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef plot_chempot_range_map(self, elements, referenced=True):\n        self.get_chempot_range_map_plot(elements, referenced=referenced).show()", "response": "This function plots the chemical potential range map for the given set of elements."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_chempot_range_map_plot(self, elements, referenced=True):\n\n        plt = pretty_plot(12, 8)\n        chempot_ranges = self._pd.get_chempot_range_map(\n            elements, referenced=referenced)\n        missing_lines = {}\n        excluded_region = []\n        for entry, lines in chempot_ranges.items():\n            comp = entry.composition\n            center_x = 0\n            center_y = 0\n            coords = []\n            contain_zero = any([comp.get_atomic_fraction(el) == 0\n                                for el in elements])\n            is_boundary = (not contain_zero) and \\\n                          sum([comp.get_atomic_fraction(el) for el in\n                               elements]) == 1\n            for line in lines:\n                (x, y) = line.coords.transpose()\n                plt.plot(x, y, \"k-\")\n\n                for coord in line.coords:\n                    if not in_coord_list(coords, coord):\n                        coords.append(coord.tolist())\n                        center_x += coord[0]\n                        center_y += coord[1]\n                if is_boundary:\n                    excluded_region.extend(line.coords)\n\n            if coords and contain_zero:\n                missing_lines[entry] = coords\n            else:\n                xy = (center_x / len(coords), center_y / len(coords))\n                plt.annotate(latexify(entry.name), xy, fontsize=22)\n\n        ax = plt.gca()\n        xlim = ax.get_xlim()\n        ylim = ax.get_ylim()\n\n        # Shade the forbidden chemical potential regions.\n        excluded_region.append([xlim[1], ylim[1]])\n        excluded_region = sorted(excluded_region, key=lambda c: c[0])\n        (x, y) = np.transpose(excluded_region)\n        plt.fill(x, y, \"0.80\")\n\n        # The hull does not generate the missing horizontal and vertical lines.\n        # The following code fixes this.\n        el0 = elements[0]\n        el1 = elements[1]\n        for entry, coords in missing_lines.items():\n            center_x = sum([c[0] for c in coords])\n            center_y = sum([c[1] for c in coords])\n            comp = entry.composition\n            is_x = comp.get_atomic_fraction(el0) < 0.01\n            is_y = comp.get_atomic_fraction(el1) < 0.01\n            n = len(coords)\n            if not (is_x and is_y):\n                if is_x:\n                    coords = sorted(coords, key=lambda c: c[1])\n                    for i in [0, -1]:\n                        x = [min(xlim), coords[i][0]]\n                        y = [coords[i][1], coords[i][1]]\n                        plt.plot(x, y, \"k\")\n                        center_x += min(xlim)\n                        center_y += coords[i][1]\n                elif is_y:\n                    coords = sorted(coords, key=lambda c: c[0])\n                    for i in [0, -1]:\n                        x = [coords[i][0], coords[i][0]]\n                        y = [coords[i][1], min(ylim)]\n                        plt.plot(x, y, \"k\")\n                        center_x += coords[i][0]\n                        center_y += min(ylim)\n                xy = (center_x / (n + 2), center_y / (n + 2))\n            else:\n                center_x = sum(coord[0] for coord in coords) + xlim[0]\n                center_y = sum(coord[1] for coord in coords) + ylim[0]\n                xy = (center_x / (n + 1), center_y / (n + 1))\n\n            plt.annotate(latexify(entry.name), xy,\n                         horizontalalignment=\"center\",\n                         verticalalignment=\"center\", fontsize=22)\n\n        plt.xlabel(\"$\\\\mu_{{{0}}} - \\\\mu_{{{0}}}^0$ (eV)\"\n                   .format(el0.symbol))\n        plt.ylabel(\"$\\\\mu_{{{0}}} - \\\\mu_{{{0}}}^0$ (eV)\"\n                   .format(el1.symbol))\n        plt.tight_layout()\n        return plt", "response": "Returns a matplotlib plot of the chemical potential range map for the given set of elements."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a contour phase diagram plot.", "response": "def get_contour_pd_plot(self):\n        \"\"\"\n        Plot a contour phase diagram plot, where phase triangles are colored\n        according to degree of instability by interpolation. Currently only\n        works for 3-component phase diagrams.\n\n        Returns:\n            A matplotlib plot object.\n        \"\"\"\n        from scipy import interpolate\n        from matplotlib import cm\n\n        pd = self._pd\n        entries = pd.qhull_entries\n        data = np.array(pd.qhull_data)\n\n        plt = self._get_2d_plot()\n        data[:, 0:2] = triangular_coord(data[:, 0:2]).transpose()\n        for i, e in enumerate(entries):\n            data[i, 2] = self._pd.get_e_above_hull(e)\n\n        gridsize = 0.005\n        xnew = np.arange(0, 1., gridsize)\n        ynew = np.arange(0, 1, gridsize)\n\n        f = interpolate.LinearNDInterpolator(data[:, 0:2], data[:, 2])\n        znew = np.zeros((len(ynew), len(xnew)))\n        for (i, xval) in enumerate(xnew):\n            for (j, yval) in enumerate(ynew):\n                znew[j, i] = f(xval, yval)\n\n        plt.contourf(xnew, ynew, znew, 1000, cmap=cm.autumn_r)\n\n        plt.colorbar()\n        return plt"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef all_input(self):\n        d = {\"HEADER\": self.header(), \"PARAMETERS\": self.tags}\n\n        if \"RECIPROCAL\" not in self.tags:\n            d.update({\"POTENTIALS\": self.potential, \"ATOMS\": self.atoms})\n\n        return d", "response": "Returns all input files as a dict of filename - > feffio object"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef write_input(self, output_dir=\".\", make_dir_if_not_present=True):\n        if make_dir_if_not_present and not os.path.exists(output_dir):\n            os.makedirs(output_dir)\n\n        feff = self.all_input()\n\n        feff_input = \"\\n\\n\".join(str(feff[k]) for k in\n                                 [\"HEADER\", \"PARAMETERS\", \"POTENTIALS\", \"ATOMS\"]\n                                 if k in feff)\n\n        for k, v in feff.items():\n            with open(os.path.join(output_dir, k), \"w\") as f:\n                f.write(str(v))\n\n        with open(os.path.join(output_dir, \"feff.inp\"), \"w\") as f:\n            f.write(feff_input)\n\n        # write the structure to cif file\n        if \"ATOMS\" not in feff:\n            self.atoms.struct.to(fmt=\"cif\",\n                                 filename=os.path.join(\n                                     output_dir, feff[\"PARAMETERS\"][\"CIF\"]))", "response": "Writes a set of FEFF input files to a directory."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef tags(self):\n        if \"RECIPROCAL\" in self.config_dict:\n            if self.small_system:\n                self.config_dict[\"CIF\"] = \"{}.cif\".format(\n                    self.structure.formula.replace(\" \", \"\"))\n                self.config_dict[\"TARGET\"] = self.atoms.center_index + 1\n                self.config_dict[\"COREHOLE\"] = \"RPA\"\n                logger.warning(\"Setting COREHOLE = RPA for K-space calculation\")\n                if not self.config_dict.get(\"KMESH\", None):\n                    abc = self.structure.lattice.abc\n                    mult = (self.nkpts * abc[0] * abc[1] * abc[2]) ** (1 / 3)\n                    self.config_dict[\"KMESH\"] = [int(round(mult / l)) for l in abc]\n            else:\n                logger.warning(\"Large system(>=14 atoms) or EXAFS calculation, \\\n                                removing K-space settings\")\n                del self.config_dict[\"RECIPROCAL\"]\n                self.config_dict.pop(\"CIF\", None)\n                self.config_dict.pop(\"TARGET\", None)\n                self.config_dict.pop(\"KMESH\", None)\n                self.config_dict.pop(\"STRFAC\", None)\n\n        return Tags(self.config_dict)", "response": "Returns a new instance of Tags class."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef from_directory(input_dir):\n        sub_d = {}\n        for fname, ftype in [(\"HEADER\", Header), (\"PARAMETERS\", Tags)]:\n            fullzpath = zpath(os.path.join(input_dir, fname))\n            sub_d[fname.lower()] = ftype.from_file(fullzpath)\n\n        # Generation of FEFFDict set requires absorbing atom, need to search\n        # the index of absorption atom in the structure according to the\n        # distance matrix and shell species information contained in feff.inp\n\n        absorber_index = []\n        radius = None\n        feffinp = zpath(os.path.join(input_dir, 'feff.inp'))\n\n        if \"RECIPROCAL\" not in sub_d[\"parameters\"]:\n            input_atoms = Atoms.cluster_from_file(feffinp)\n            shell_species = np.array([x.species_string for x in input_atoms])\n\n            # First row of distance matrix represents the distance from the absorber to\n            # the rest atoms\n            distance_matrix = input_atoms.distance_matrix[0, :]\n\n            # Get radius value\n            from math import ceil\n            radius = int(ceil(input_atoms.get_distance(input_atoms.index(input_atoms[0]),\n                                                       input_atoms.index(input_atoms[-1]))))\n\n            for site_index, site in enumerate(sub_d['header'].struct):\n\n                if site.specie == input_atoms[0].specie:\n                    site_atoms = Atoms(sub_d['header'].struct, absorbing_atom=site_index,\n                                       radius=radius)\n                    site_distance = np.array(site_atoms.get_lines())[:, 5].astype(np.float64)\n                    site_shell_species = np.array(site_atoms.get_lines())[:, 4]\n                    shell_overlap = min(shell_species.shape[0], site_shell_species.shape[0])\n\n                    if np.allclose(distance_matrix[:shell_overlap], site_distance[:shell_overlap]) and \\\n                            np.all(site_shell_species[:shell_overlap] == shell_species[:shell_overlap]):\n                        absorber_index.append(site_index)\n\n        if \"RECIPROCAL\" in sub_d[\"parameters\"]:\n            absorber_index = sub_d[\"parameters\"][\"TARGET\"]\n            absorber_index[0] = int(absorber_index[0]) - 1\n\n        # Generate the input set\n        if 'XANES' in sub_d[\"parameters\"]:\n            CONFIG = loadfn(os.path.join(MODULE_DIR, \"MPXANESSet.yaml\"))\n            if radius is None:\n                radius = 10\n            return FEFFDictSet(absorber_index[0], sub_d['header'].struct, radius=radius,\n                               config_dict=CONFIG, edge=sub_d[\"parameters\"][\"EDGE\"],\n                               nkpts=1000, user_tag_settings=sub_d[\"parameters\"])", "response": "Read in a set of FEFF input files from a directory which is\n            is used when existing FEFF input needs some adjustment."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef function_comparison(f1, f2, x1, x2, numpoints_check=500):\n    xx = np.linspace(x1, x2, num=numpoints_check)\n    y1 = f1(xx)\n    y2 = f2(xx)\n    if np.all(y1 < y2):\n        return '<'\n    elif np.all(y1 > y2):\n        return '>'\n    elif np.all(y1 == y2):\n        return '='\n    elif np.all(y1 <= y2):\n        return '<='\n    elif np.all(y1 >= y2):\n        return '>='\n    else:\n        raise RuntimeError('Error in comparing functions f1 and f2 ...')", "response": "Method that compares two functions returning a string that is the result of the function f1 and f2."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef rectangle_surface_intersection(rectangle, f_lower, f_upper,\n                                   bounds_lower=None, bounds_upper=None,\n                                   check=True, numpoints_check=500):\n    \"\"\"\n    Method to calculate the surface of the intersection of a rectangle (aligned with axes) and another surface\n    defined by two functions f_lower and f_upper.\n\n    Args:\n        rectangle:\n            Rectangle defined as : ((x1, x2), (y1, y2)).\n        f_lower:\n            Function defining the lower bound of the surface.\n        f_upper:\n            Function defining the upper bound of the surface.\n        bounds_lower:\n            Interval in which the f_lower function is defined.\n        bounds_upper:\n            Interval in which the f_upper function is defined.\n        check:\n            Whether to check if f_lower is always lower than f_upper.\n        numpoints_check:\n            Number of points used to check whether f_lower is always lower than f_upper\n\n    Returns:\n        The surface of the intersection of the rectangle and the surface defined by f_lower and f_upper.\n    \"\"\"\n    x1 = np.min(rectangle[0])\n    x2 = np.max(rectangle[0])\n    y1 = np.min(rectangle[1])\n    y2 = np.max(rectangle[1])\n    # Check that f_lower is allways lower than f_upper between x1 and x2 if no bounds are given or between the bounds\n    #  of the f_lower and f_upper functions if they are given.\n    if check:\n        if bounds_lower is not None:\n            if bounds_upper is not None:\n                if not all(np.array(bounds_lower) == np.array(bounds_upper)):\n                    raise ValueError('Bounds should be identical for both f_lower and f_upper')\n                if not '<' in function_comparison(f1=f_lower, f2=f_upper,\n                                                  x1=bounds_lower[0], x2=bounds_lower[1],\n                                                  numpoints_check=numpoints_check):\n                    raise RuntimeError('Function f_lower is not allways lower or equal to function f_upper within '\n                                       'the domain defined by the functions bounds.')\n            else:\n                raise ValueError('Bounds are given for f_lower but not for f_upper')\n        elif bounds_upper is not None:\n            if bounds_lower is None:\n                raise ValueError('Bounds are given for f_upper but not for f_lower')\n            else:\n                if not '<' in function_comparison(f1=f_lower, f2=f_upper,\n                                                  x1=bounds_lower[0], x2=bounds_lower[1],\n                                                  numpoints_check=numpoints_check):\n                    raise RuntimeError('Function f_lower is not allways lower or equal to function f_upper within '\n                                       'the domain defined by the functions bounds.')\n        else:\n            if not '<' in function_comparison(f1=f_lower, f2=f_upper,\n                                              x1=x1, x2=x2, numpoints_check=numpoints_check):\n                raise RuntimeError('Function f_lower is not allways lower or equal to function f_upper within '\n                                   'the domain defined by x1 and x2.')\n    if bounds_lower is None:\n        raise NotImplementedError('Bounds should be given right now ...')\n    else:\n        if x2 < bounds_lower[0] or x1 > bounds_lower[1]:\n            return (0.0, 0.0)\n        if x1 < bounds_lower[0]:\n            xmin = bounds_lower[0]\n        else:\n            xmin = x1\n        if x2 > bounds_lower[1]:\n            xmax = bounds_lower[1]\n        else:\n            xmax = x2\n        def diff(x):\n            flwx = f_lower(x)\n            fupx = f_upper(x)\n            minup = np.min([fupx, y2 * np.ones_like(fupx)], axis=0)\n            maxlw = np.max([flwx, y1 * np.ones_like(flwx)], axis=0)\n            zeros = np.zeros_like(fupx)\n            upper = np.where(y2 >= flwx, np.where(y1 <= fupx, minup, zeros), zeros)\n            lower = np.where(y1 <= fupx, np.where(y2 >= flwx, maxlw, zeros), zeros)\n            return upper-lower\n        return quad(diff, xmin, xmax)", "response": "This method calculates the surface of the intersection of a rectangle and another rectangle."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef my_solid_angle(center, coords):\n    o = np.array(center)\n    r = [np.array(c) - o for c in coords]\n    r.append(r[0])\n    n = [np.cross(r[i + 1], r[i]) for i in range(len(r) - 1)]\n    n.append(np.cross(r[1], r[0]))\n    phi = 0.0\n    for i in range(len(n) - 1):\n        try:\n            value = math.acos(-np.dot(n[i], n[i + 1]) / (np.linalg.norm(n[i]) * np.linalg.norm(n[i + 1])))\n        except ValueError:\n            mycos = -np.dot(n[i], n[i + 1]) / (np.linalg.norm(n[i]) * np.linalg.norm(n[i + 1]))\n            if 0.999999999999 < mycos < 1.000000000001:\n                value = math.acos(1.0)\n            elif -0.999999999999 > mycos > -1.000000000001:\n                value = math.acos(-1.0)\n            else:\n                raise SolidAngleError(mycos)\n        phi += value\n    return phi + (3 - len(r)) * math.pi", "response": "This method calculates the solid angle of a set of coords from the center."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ntakes the elements of two vectors and returns a 3x3 matrix M.", "response": "def vectorsToMatrix(aa, bb):\n    \"\"\"\n    Performs the vector multiplication of the elements of two vectors, constructing the 3x3 matrix.\n    :param aa: One vector of size 3\n    :param bb: Another vector of size 3\n    :return: A 3x3 matrix M composed of the products of the elements of aa and bb :\n     M_ij = aa_i * bb_j\n    \"\"\"\n    MM = np.zeros([3, 3], np.float)\n    for ii in range(3):\n        for jj in range(3):\n            MM[ii, jj] = aa[ii] * bb[jj]\n    return MM"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef rotateCoords(coords, R):\n    newlist = list()\n    for pp in coords:\n        rpp = matrixTimesVector(R, pp)\n        newlist.append(rpp)\n    return newlist", "response": "Rotates the list of points using the rotation matrix R"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef collinear(p1, p2, p3=None, tolerance=0.25):\n    if p3 is None:\n        triangle_area = 0.5 * np.linalg.norm(np.cross(p1, p2))\n        dist = np.sort([np.linalg.norm(p2 - p1), np.linalg.norm(p1), np.linalg.norm(p2)])\n    else:\n        triangle_area = 0.5 * np.linalg.norm(np.cross(p1 - p3, p2 - p3))\n        dist = np.sort([np.linalg.norm(p2 - p1), np.linalg.norm(p3 - p1), np.linalg.norm(p3 - p2)])\n    largest_triangle_area = 0.5 * dist[0] * dist[1]\n    return triangle_area < tolerance * largest_triangle_area", "response": "Checks if three points p1 p2 and p3 are collinear."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsorts a list of 2D points in anticlockwise order", "response": "def anticlockwise_sort(pps):\n    \"\"\"\n    Sort a list of 2D points in anticlockwise order\n    :param pps: List of points to be sorted\n    :return: Sorted list of points\n    \"\"\"\n    newpps = list()\n    angles = np.zeros(len(pps), np.float)\n    for ipp, pp in enumerate(pps):\n        angles[ipp] = np.arctan2(pp[1], pp[0])\n    iisorted = np.argsort(angles)\n    for ii in range(len(pps)):\n        newpps.append(pps[iisorted[ii]])\n    return newpps"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef anticlockwise_sort_indices(pps):\n    angles = np.zeros(len(pps), np.float)\n    for ipp, pp in enumerate(pps):\n        angles[ipp] = np.arctan2(pp[1], pp[0])\n    return np.argsort(angles)", "response": "Returns the indices that would sort a list of 2D points in anticlockwise order\n   "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef separation_in_list(separation_indices, separation_indices_list):\n    sorted_separation = sort_separation(separation_indices)\n    for sep in separation_indices_list:\n        if len(sep[1]) == len(sorted_separation[1]) and np.allclose(sorted_separation[1], sep[1]):\n            return True\n    return False", "response": "Checks if the separation indices of a plane are already in the list"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef is_anion_cation_bond(valences, ii, jj):\n    if valences == 'undefined':\n        return True\n    if valences[ii] == 0 or valences[jj] == 0:\n        return True\n    return (valences[ii] > 0 > valences[jj]) or (valences[jj] > 0 > valences[ii])", "response": "Checks if two given sites are an anion and a cation."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef is_in_plane(self, pp, dist_tolerance):\n        return np.abs(np.dot(self.normal_vector, pp) + self._coefficients[3]) <= dist_tolerance", "response": "Determines if point pp is in the plane within the tolerance dist_tolerance"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncheck whether the resource is in the list of Planes.", "response": "def is_in_list(self, plane_list):\n        \"\"\"\n        Checks whether the plane is identical to one of the Planes in the plane_list list of Planes\n        :param plane_list: List of Planes to be compared to\n        :return: True if the plane is in the list, False otherwise\n        \"\"\"\n        for plane in plane_list:\n            if self.is_same_plane_as(plane):\n                return True\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef indices_separate(self, points, dist_tolerance):\n        side1 = list()\n        inplane = list()\n        side2 = list()\n        for ip, pp in enumerate(points):\n            if self.is_in_plane(pp, dist_tolerance):\n                inplane.append(ip)\n            else:\n                if np.dot(pp + self.vector_to_origin, self.normal_vector) < 0.0:\n                    side1.append(ip)\n                else:\n                    side2.append(ip)\n        return [side1, inplane, side2]", "response": "Returns three lists containing the indices of the points lying on one side of the plane and on the other side of the plane."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef distance_to_point(self, point):\n        return np.abs(np.dot(self.normal_vector, point) + self.d)", "response": "Computes the absolute distance from the plane to the point"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef distances(self, points):\n        return [np.dot(self.normal_vector, pp) + self.d for pp in points]", "response": "Computes the distances from the plane to each of the points"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncomputing the distances from the plane to each of the points.", "response": "def distances_indices_sorted(self, points, sign=False):\n        \"\"\"\n        Computes the distances from the plane to each of the points. Positive distances are on the side of the\n        normal of the plane while negative distances are on the other side. Indices sorting the points from closest\n        to furthest is also computed.\n        :param points: Points for which distances are computed\n        :param sign: Whether to add sign information in the indices sorting the points distances\n        :return: Distances from the plane to the points (positive values on the side of the normal to the plane,\n                 negative values on the other side), as well as indices of the points from closest to furthest. For\n                 the latter, when the sign parameter is True, items of the sorting list are given as tuples of\n                 (index, sign).\n        \"\"\"\n        distances = [np.dot(self.normal_vector, pp) + self.d for pp in points]\n        indices = sorted(range(len(distances)), key=lambda k: np.abs(distances[k]))\n        if sign:\n            indices = [(ii, int(np.sign(distances[ii]))) for ii in indices]\n        return distances, indices"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef distances_indices_groups(self, points, delta=None, delta_factor=0.05, sign=False):\n        distances, indices = self.distances_indices_sorted(points=points)\n        if delta is None:\n            delta = delta_factor*np.abs(distances[indices[-1]])\n        iends = [ii for ii, idist in enumerate(indices, start=1)\n                 if ii == len(distances) or (np.abs(distances[indices[ii]])-np.abs(distances[idist])>delta)]\n        if sign:\n            indices = [(ii, int(np.sign(distances[ii]))) for ii in indices]\n        grouped_indices = [indices[iends[ii - 1]:iend]\n                           if ii > 0 else indices[:iend]\n                           for ii, iend in enumerate(iends)]\n        return distances, indices, grouped_indices", "response": "Computes the distances between the plane and the points."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef projectionpoints(self, pps):\n        return [pp - np.dot(pp - self.p1, self.normal_vector) * self.normal_vector for pp in pps]", "response": "Projects each point in the point list pps on plane and returns the list of projected points on plane"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a list of three orthogonal vectors the two first being parallel to the plane and the third one being the normal vector of the plane.", "response": "def orthonormal_vectors(self):\n        \"\"\"\n        Returns a list of three orthogonal vectors, the two first being parallel to the plane and the\n        third one is the normal vector of the plane\n        :return: List of orthogonal vectors\n        :raise: ValueError if all the coefficients are zero or if there is some other strange error\n        \"\"\"\n        if self.e1 is None:\n            diff = self.p2 - self.p1\n            self.e1 = diff / norm(diff)\n            self.e2 = np.cross(self.e3, self.e1)\n        return [self.e1, self.e2, self.e3]"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a list of three orthogonal vectors the two first being parallel to the plane and the third one being the normal vector of the plane.", "response": "def orthonormal_vectors_old(self):\n        \"\"\"\n        Returns a list of three orthogonal vectors, the two first being parallel to the plane and the\n        third one is the normal vector of the plane\n        :return: List of orthogonal vectors\n        :raise: ValueError if all the coefficients are zero or if there is some other strange error\n        \"\"\"\n        if self.e1 is None:\n            imax = np.argmax(np.abs(self.normal_vector))\n            if imax == 0:\n                self.e1 = np.array([self.e3[1], -self.e3[0], 0.0]) / np.sqrt(self.e3[0] ** 2 + self.e3[1] ** 2)\n            elif imax == 1:\n                self.e1 = np.array([0.0, self.e3[2], -self.e3[1]]) / np.sqrt(self.e3[1] ** 2 + self.e3[2] ** 2)\n            elif imax == 2:\n                self.e1 = np.array([-self.e3[2], 0.0, self.e3[0]]) / np.sqrt(self.e3[0] ** 2 + self.e3[2] ** 2)\n            else:\n                raise ValueError('Only three values in the normal vector, should not be here ...')\n            self.e2 = np.cross(self.e3, self.e1)\n        return [self.e1, self.e2, self.e3]"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef project_and_to2dim_ordered_indices(self, pps, plane_center='mean'):\n        pp2d = self.project_and_to2dim(pps, plane_center)\n        return anticlockwise_sort_indices(pp2d)", "response": "Projects each point list pps on plane and returns the indices that would sort the list of projected points in anticlockwise order\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef project_and_to2dim(self, pps, plane_center):\n        proj = self.projectionpoints(pps)\n        [u1, u2, u3] = self.orthonormal_vectors()\n        PP = np.array([[u1[0], u2[0], u3[0]],\n                       [u1[1], u2[1], u3[1]],\n                       [u1[2], u2[2], u3[2]]])\n        xypps = list()\n        for pp in proj:\n            xyzpp = np.dot(pp, PP)\n            xypps.append(xyzpp[0:2])\n        if str(plane_center) == str('mean'):\n            mean = np.zeros(2, np.float)\n            for pp in xypps:\n                mean += pp\n            mean /= len(xypps)\n            xypps = [pp - mean for pp in xypps]\n        elif plane_center is not None:\n            projected_plane_center = self.projectionpoints([plane_center])[0]\n            xy_projected_plane_center = np.dot(projected_plane_center, PP)[0:2]\n            xypps = [pp - xy_projected_plane_center for pp in xypps]\n        return xypps", "response": "Projects the list of points pps to the plane and changes the basis from 3D to 2D basis of the plane."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nfunction to actually open a ring using OpenBabel s local opt.", "response": "def open_ring(mol_graph, bond, opt_steps):\n    \"\"\"\n    Function to actually open a ring using OpenBabel's local opt. Given a molecule\n    graph and a bond, convert the molecule graph into an OpenBabel molecule, remove\n    the given bond, perform the local opt with the number of steps determined by\n    self.steps, and then convert the resulting structure back into a molecule graph\n    to be returned.\n    \"\"\"\n    obmol = BabelMolAdaptor.from_molecule_graph(mol_graph)\n    obmol.remove_bond(bond[0][0]+1, bond[0][1]+1)\n    obmol.localopt(steps=opt_steps)\n    return MoleculeGraph.with_local_env_strategy(obmol.pymatgen_mol, OpenBabelNN(), reorder=False, extend_structure=False)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nperform one step of iterative fragmentation on a list of molecule graphs.", "response": "def _fragment_one_level(self, mol_graphs):\n        \"\"\"\n        Perform one step of iterative fragmentation on a list of molecule graphs. Loop through the graphs,\n        then loop through each graph's edges and attempt to remove that edge in order to obtain two\n        disconnected subgraphs, aka two new fragments. If successful, check to see if the new fragments\n        are already present in self.unique_fragments, and append them if not. If unsucessful, we know\n        that edge belongs to a ring. If we are opening rings, do so with that bond, and then again\n        check if the resulting fragment is present in self.unique_fragments and add it if it is not.\n        \"\"\"\n        unique_fragments_on_this_level = []\n        for mol_graph in mol_graphs:\n            for edge in mol_graph.graph.edges:\n                bond = [(edge[0],edge[1])]\n                try:\n                    fragments = mol_graph.split_molecule_subgraphs(bond, allow_reverse=True)\n                    for fragment in fragments:\n                        found = False\n                        for unique_fragment in self.unique_fragments:\n                            if unique_fragment.isomorphic_to(fragment):\n                                found = True\n                                break\n                        if not found:\n                            self.unique_fragments.append(fragment)\n                            unique_fragments_on_this_level.append(fragment)\n                except MolGraphSplitError:\n                    if self.open_rings:\n                        fragment = open_ring(mol_graph, bond, self.opt_steps)\n                        found = False\n                        for unique_fragment in self.unique_fragments:\n                            if unique_fragment.isomorphic_to(fragment):\n                                found = True\n                                break\n                        if not found:\n                            self.unique_fragments.append(fragment)\n                            self.unique_fragments_from_ring_openings.append(fragment)\n                            unique_fragments_on_this_level.append(fragment)\n        return unique_fragments_on_this_level"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nopen all rings in the unique_fragments list.", "response": "def _open_all_rings(self):\n        \"\"\"\n        Having already generated all unique fragments that did not require ring opening,\n        now we want to also obtain fragments that do require opening. We achieve this by\n        looping through all unique fragments and opening each bond present in any ring\n        we find. We also temporarily add the principle molecule graph to self.unique_fragments\n        so that its rings are opened as well.\n        \"\"\"\n        self.unique_fragments.insert(0, self.mol_graph)\n        for fragment in self.unique_fragments:\n            ring_edges = fragment.find_rings()\n            if ring_edges != []:\n                for bond in ring_edges[0]:\n                    new_fragment = open_ring(fragment, [bond], self.opt_steps)\n                    found = False\n                    for unique_fragment in self.unique_fragments:\n                        if unique_fragment.isomorphic_to(new_fragment):\n                            found = True\n                            break\n                    if not found:\n                        self.unique_fragments_from_ring_openings.append(new_fragment)\n                        self.unique_fragments.append(new_fragment)\n        # Finally, remove the principle molecule graph:\n        self.unique_fragments.pop(0)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a dict representation of the COHP.", "response": "def as_dict(self):\n        \"\"\"\n        Json-serializable dict representation of COHP.\n        \"\"\"\n        d = {\"@module\": self.__class__.__module__,\n             \"@class\": self.__class__.__name__,\n             \"are_coops\": self.are_coops,\n             \"efermi\": self.efermi,\n             \"energies\": self.energies.tolist(),\n             \"COHP\": {str(spin): pops.tolist()\n                      for spin, pops in self.cohp.items()}}\n        if self.icohp:\n            d[\"ICOHP\"] = {str(spin): pops.tolist()\n                          for spin, pops in self.icohp.items()}\n        return d"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_cohp(self, spin=None, integrated=False):\n        if not integrated:\n            populations = self.cohp\n        else:\n            populations = self.icohp\n\n        if populations is None:\n            return None\n        elif spin is None:\n            return populations\n        else:\n            if isinstance(spin, int):\n                spin = Spin(spin)\n            elif isinstance(spin, str):\n                s = {\"up\": 1, \"down\": -1}[spin.lower()]\n                spin = Spin(s)\n            return {spin: populations[spin]}", "response": "Returns the COHP or ICOHP for a particular spin."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the COHP value for a particular energy.", "response": "def get_interpolated_value(self, energy, integrated=False):\n        \"\"\"\n        Returns the COHP for a particular energy.\n\n        Args:\n            energy: Energy to return the COHP value for.\n        \"\"\"\n        inter = {}\n        for spin in self.cohp:\n            if not integrated:\n                inter[spin] = get_linear_interpolated_value(self.energies,\n                                                            self.cohp[spin],\n                                                            energy)\n            elif self.icohp is not None:\n                inter[spin] = get_linear_interpolated_value(self.energies,\n                                                            self.icohp[spin],\n                                                            energy)\n            else:\n                raise ValueError(\"ICOHP is empty.\")\n        return inter"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef has_antibnd_states_below_efermi(self, spin=None, limit=0.01):\n        warnings.warn(\"This method has not been tested on many examples. Check the parameter limit, pls!\")\n\n        populations = self.cohp\n        number_energies_below_efermi = len([x for x in self.energies if x <= self.efermi])\n\n        if populations is None:\n            return None\n        elif spin is None:\n            dict_to_return = {}\n            for spin, cohpvalues in populations.items():\n                if (max(cohpvalues[0:number_energies_below_efermi])) > limit:\n                    dict_to_return[spin] = True\n                else:\n                    dict_to_return[spin] = False\n        else:\n            dict_to_return = {}\n            if isinstance(spin, int):\n                spin = Spin(spin)\n            elif isinstance(spin, str):\n                s = {\"up\": 1, \"down\": -1}[spin.lower()]\n                spin = Spin(s)\n            if (max(populations[spin][0:number_energies_below_efermi])) > limit:\n                dict_to_return[spin] = True\n            else:\n                dict_to_return[spin] = False\n\n        return dict_to_return", "response": "Returns dict indicating if there are antibonding states below the Fermi level depending on the spin."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef from_dict(cls, d):\n        if \"ICOHP\" in d:\n            icohp = {Spin(int(key)): np.array(val)\n                     for key, val in d[\"ICOHP\"].items()}\n        else:\n            icohp = None\n        return Cohp(d[\"efermi\"], d[\"energies\"],\n                    {Spin(int(key)): np.array(val)\n                     for key, val in d[\"COHP\"].items()},\n                    icohp=icohp, are_coops=d[\"are_coops\"])", "response": "Returns a COHP object from a dict representation of the COHP."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget specific COHP object.", "response": "def get_cohp_by_label(self, label):\n        \"\"\"\n        Get specific COHP object.\n\n        Args:\n            label: string (for newer Lobster versions: a number)\n\n        Returns:\n            Returns the COHP object to simplify plotting\n        \"\"\"\n        if label.lower() == \"average\":\n            return Cohp(efermi=self.efermi, energies=self.energies,\n                        cohp=self.cohp, are_coops=self.are_coops, icohp=self.icohp)\n        else:\n            try:\n                return Cohp(efermi=self.efermi, energies=self.energies,\n                            cohp=self.all_cohps[label].get_cohp(spin=None, integrated=False),\n                            are_coops=self.are_coops,\n                            icohp=self.all_cohps[label].get_icohp(spin=None))\n\n            except KeyError:\n                print(\"The label does not exist\")"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a COHP object that includes a summed COHP divided by divisor.", "response": "def get_summed_cohp_by_label_list(self, label_list, divisor=1):\n        \"\"\"\n        Returns a COHP object that includes a summed COHP divided by divisor\n\n        Args:\n            label_list: list of labels for the COHP that should be included in the summed cohp\n            divisor: float/int, the summed cohp will be divided by this divisor\n        Returns:\n            Returns a COHP object including a summed COHP\n        \"\"\"\n        # check if cohps are spinpolarized or not\n        first_cohpobject = self.get_cohp_by_label(label_list[0])\n        summed_cohp = first_cohpobject.cohp.copy()\n        summed_icohp = first_cohpobject.icohp.copy()\n        for label in label_list[1:]:\n            cohp_here = self.get_cohp_by_label(label)\n            summed_cohp[Spin.up] = np.sum([summed_cohp[Spin.up], cohp_here.cohp[Spin.up]], axis=0)\n            if Spin.down in summed_cohp:\n                summed_cohp[Spin.down] = np.sum([summed_cohp[Spin.down], cohp_here.cohp[Spin.down]], axis=0)\n            summed_icohp[Spin.up] = np.sum([summed_icohp[Spin.up], cohp_here.icohp[Spin.up]], axis=0)\n            if Spin.down in summed_icohp:\n                summed_icohp[Spin.down] = np.sum([summed_icohp[Spin.down], cohp_here.icohp[Spin.down]], axis=0)\n\n        divided_cohp = {}\n        divided_icohp = {}\n        divided_cohp[Spin.up] = np.divide(summed_cohp[Spin.up], divisor)\n        divided_icohp[Spin.up] = np.divide(summed_icohp[Spin.up], divisor)\n        if Spin.down in summed_cohp:\n            divided_cohp[Spin.down] = np.divide(summed_cohp[Spin.down], divisor)\n            divided_icohp[Spin.down] = np.divide(summed_icohp[Spin.down], divisor)\n\n        return Cohp(efermi=first_cohpobject.efermi, energies=first_cohpobject.energies, cohp=divided_cohp,\n                    are_coops=first_cohpobject.are_coops,\n                    icohp=divided_icohp)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a COHP object that includes a summed COHP divided by divisor.", "response": "def get_summed_cohp_by_label_and_orbital_list(self, label_list, orbital_list, divisor=1):\n        \"\"\"\n        Returns a COHP object that includes a summed COHP divided by divisor\n\n        Args:\n            label_list: list of labels for the COHP that should be included in the summed cohp\n            orbital_list: list of orbitals for the COHPs that should be included in the summed cohp (same order as label_list)\n            divisor: float/int, the summed cohp will be divided by this divisor\n        Returns:\n            Returns a COHP object including a summed COHP\n        \"\"\"\n        # check if cohps are spinpolarized or not\n        first_cohpobject = self.get_orbital_resolved_cohp(label_list[0], orbital_list[0])\n        summed_cohp = first_cohpobject.cohp.copy()\n        summed_icohp = first_cohpobject.icohp.copy()\n        for ilabel, label in enumerate(label_list[1:], 1):\n            cohp_here = self.get_orbital_resolved_cohp(label, orbital_list[ilabel])\n            summed_cohp[Spin.up] = np.sum([summed_cohp[Spin.up], cohp_here.cohp.copy()[Spin.up]], axis=0)\n            if Spin.down in summed_cohp:\n                summed_cohp[Spin.down] = np.sum([summed_cohp[Spin.down], cohp_here.cohp.copy()[Spin.down]], axis=0)\n            summed_icohp[Spin.up] = np.sum([summed_icohp[Spin.up], cohp_here.icohp.copy()[Spin.up]], axis=0)\n            if Spin.down in summed_icohp:\n                summed_icohp[Spin.down] = np.sum([summed_icohp[Spin.down], cohp_here.icohp.copy()[Spin.down]], axis=0)\n\n        divided_cohp = {}\n        divided_icohp = {}\n        divided_cohp[Spin.up] = np.divide(summed_cohp[Spin.up], divisor)\n        divided_icohp[Spin.up] = np.divide(summed_icohp[Spin.up], divisor)\n        if Spin.down in summed_cohp:\n            divided_cohp[Spin.down] = np.divide(summed_cohp[Spin.down], divisor)\n            divided_icohp[Spin.down] = np.divide(summed_icohp[Spin.down], divisor)\n\n        return Cohp(efermi=first_cohpobject.efermi, energies=first_cohpobject.energies, cohp=divided_cohp,\n                    are_coops=first_cohpobject.are_coops,\n                    icohp=divided_icohp)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a cohp object with the orbital - resolved COHP.", "response": "def get_orbital_resolved_cohp(self, label, orbitals):\n        \"\"\"\n        Get orbital-resolved COHP.\n\n        Args:\n            label: bond label (Lobster: labels as in ICOHPLIST/ICOOPLIST.lobster).\n\n            orbitals: The orbitals as a label, or list or tuple of the form\n                [(n1, orbital1), (n2, orbital2)]. Orbitals can either be str,\n                int, or Orbital.\n\n        Returns:\n            A Cohp object if CompleteCohp contains orbital-resolved cohp,\n            or None if it doesn't.\n\n        Note: It currently assumes that orbitals are str if they aren't the\n            other valid types. This is not ideal, but the easiest way to\n            avoid unicode issues between python 2 and python 3.\n        \"\"\"\n        if self.orb_res_cohp is None:\n            return None\n        elif isinstance(orbitals, list) or isinstance(orbitals, tuple):\n            cohp_orbs = [d[\"orbitals\"] for d in\n                         self.orb_res_cohp[label].values()]\n            orbs = []\n            for orbital in orbitals:\n                if isinstance(orbital[1], int):\n                    orbs.append(tuple((orbital[0], Orbital(orbital[1]))))\n                elif isinstance(orbital[1], Orbital):\n                    orbs.append(tuple((orbital[0], orbital[1])))\n                elif isinstance(orbital[1], str):\n                    orbs.append(tuple((orbital[0], Orbital[orbital[1]])))\n                else:\n                    raise TypeError(\"Orbital must be str, int, or Orbital.\")\n            orb_index = cohp_orbs.index(orbs)\n            orb_label = list(self.orb_res_cohp[label].keys())[orb_index]\n        elif isinstance(orbitals, str):\n            orb_label = orbitals\n        else:\n            raise TypeError(\"Orbitals must be str, list, or tuple.\")\n        try:\n            icohp = self.orb_res_cohp[label][orb_label][\"ICOHP\"]\n        except KeyError:\n            icohp = None\n        return Cohp(self.efermi, self.energies,\n                    self.orb_res_cohp[label][orb_label][\"COHP\"],\n                    icohp=icohp, are_coops=self.are_coops)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef from_dict(cls, d):\n        cohp_dict = {}\n        efermi = d[\"efermi\"]\n        energies = d[\"energies\"]\n        structure = Structure.from_dict(d[\"structure\"])\n        if \"bonds\" in d.keys():\n            bonds = {bond: {\"length\": d[\"bonds\"][bond][\"length\"],\n                            \"sites\": tuple(PeriodicSite.from_dict(site)\n                                           for site in d[\"bonds\"][bond][\"sites\"])}\n                     for bond in d[\"bonds\"]}\n        else:\n            bonds = None\n        for label in d[\"COHP\"]:\n            cohp = {Spin(int(spin)): np.array(d[\"COHP\"][label][spin])\n                    for spin in d[\"COHP\"][label]}\n            try:\n                icohp = {Spin(int(spin)): np.array(d[\"ICOHP\"][label][spin])\n                         for spin in d[\"ICOHP\"][label]}\n            except KeyError:\n                icohp = None\n            if label == \"average\":\n                avg_cohp = Cohp(efermi, energies, cohp, icohp=icohp)\n            else:\n                cohp_dict[label] = Cohp(efermi, energies, cohp, icohp=icohp)\n\n        if \"orb_res_cohp\" in d.keys():\n            orb_cohp = {}\n            for label in d[\"orb_res_cohp\"]:\n                orb_cohp[label] = {}\n                for orb in d[\"orb_res_cohp\"][label]:\n                    cohp = {Spin(int(s)): np.array(\n                        d[\"orb_res_cohp\"][label][orb][\"COHP\"][s],\n                        dtype=float)\n                        for s in d[\"orb_res_cohp\"][label][orb][\"COHP\"]}\n                    try:\n                        icohp = {Spin(int(s)): np.array(\n                            d[\"orb_res_cohp\"][label][orb][\"ICOHP\"][s],\n                            dtype=float)\n                            for s in d[\"orb_res_cohp\"][label][orb][\"ICOHP\"]}\n                    except KeyError:\n                        icohp = None\n                    orbitals = [tuple((int(o[0]), Orbital[o[1]])) for o in\n                                d[\"orb_res_cohp\"][label][orb][\"orbitals\"]]\n                    orb_cohp[label][orb] = {\"COHP\": cohp, \"ICOHP\": icohp,\n                                            \"orbitals\": orbitals}\n                # If no total COHPs are present, calculate the total\n                # COHPs from the single-orbital populations. Total COHPs\n                # may not be present when the cohpgenerator keyword is used\n                # in LOBSTER versions 2.2.0 and earlier.\n                if label not in d[\"COHP\"] or d[\"COHP\"][label] is None:\n                    cohp = {Spin.up: np.sum(np.array(\n                        [orb_cohp[label][orb][\"COHP\"][Spin.up]\n                         for orb in orb_cohp[label]]), axis=0)}\n                    try:\n                        cohp[Spin.down] = np.sum(np.array(\n                            [orb_cohp[label][orb][\"COHP\"][Spin.down]\n                             for orb in orb_cohp[label]]), axis=0)\n                    except KeyError:\n                        pass\n\n                orb_res_icohp = None in [orb_cohp[label][orb][\"ICOHP\"]\n                                         for orb in orb_cohp[label]]\n                if (label not in d[\"ICOHP\"] or\n                    d[\"ICOHP\"][label] is None) and orb_res_icohp:\n                    icohp = {Spin.up: np.sum(np.array(\n                        [orb_cohp[label][orb][\"ICOHP\"][Spin.up]\n                         for orb in orb_cohp[label]]), axis=0)}\n                    try:\n                        icohp[Spin.down] = np.sum(np.array(\n                            [orb_cohp[label][orb][\"ICOHP\"][Spin.down]\n                             for orb in orb_cohp[label]]), axis=0)\n                    except KeyError:\n                        pass\n        else:\n            orb_cohp = None\n\n        if \"average\" not in d[\"COHP\"].keys():\n            # calculate average\n            cohp = np.array([np.array(c)\n                             for c in d[\"COHP\"].values()]).mean(axis=0)\n            try:\n                icohp = np.array([np.array(c)\n                                  for c in d[\"ICOHP\"].values()]).mean(axis=0)\n            except KeyError:\n                icohp = None\n            avg_cohp = Cohp(efermi, energies, cohp, icohp=icohp)\n\n        return CompleteCohp(structure, avg_cohp, cohp_dict, bonds=bonds,\n                            are_coops=d[\"are_coops\"], orb_res_cohp=orb_cohp)", "response": "Returns a CompleteCohp object from a dictionary representation."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate a CompleteCohp object from an output file of a COHP.", "response": "def from_file(cls, fmt, filename=None,\n                  structure_file=None, are_coops=False):\n        \"\"\"\n        Creates a CompleteCohp object from an output file of a COHP\n        calculation. Valid formats are either LMTO (for the Stuttgart\n        LMTO-ASA code) or LOBSTER (for the LOBSTER code).\n\n        Args:\n            cohp_file: Name of the COHP output file. Defaults to COPL\n                for LMTO and COHPCAR.lobster/COOPCAR.lobster for LOBSTER.\n\n            are_coops: Indicates whether the populations are COOPs or\n                COHPs. Defaults to False for COHPs.\n\n            fmt: A string for the code that was used to calculate\n                the COHPs so that the output file can be handled\n                correctly. Can take the values \"LMTO\" or \"LOBSTER\".\n\n            structure_file: Name of the file containing the structure.\n                If no file name is given, use CTRL for LMTO and POSCAR\n                for LOBSTER.\n\n        Returns:\n            A CompleteCohp object.\n        \"\"\"\n        fmt = fmt.upper()\n        if fmt == \"LMTO\":\n            # LMTO COOPs and orbital-resolved COHP cannot be handled yet.\n            are_coops = False\n            orb_res_cohp = None\n            if structure_file is None:\n                structure_file = \"CTRL\"\n            if filename is None:\n                filename = \"COPL\"\n            cohp_file = LMTOCopl(filename=filename, to_eV=True)\n        elif fmt == \"LOBSTER\":\n            if structure_file is None:\n                structure_file = \"POSCAR\"\n            if filename is None:\n                filename = \"COOPCAR.lobster\" if are_coops \\\n                    else \"COHPCAR.lobster\"\n            warnings.warn(\n                \"The bond labels are currently consistent with ICOHPLIST.lobster/ICOOPLIST.lobster, not with COHPCAR.lobster/COOPCAR.lobster. Please be aware!\")\n            cohp_file = Cohpcar(filename=filename, are_coops=are_coops)\n            orb_res_cohp = cohp_file.orb_res_cohp\n        else:\n            raise ValueError(\"Unknown format %s. Valid formats are LMTO \"\n                             \"and LOBSTER.\" % fmt)\n\n        structure = Structure.from_file(structure_file)\n        efermi = cohp_file.efermi\n        cohp_data = cohp_file.cohp_data\n        energies = cohp_file.energies\n\n        # Lobster shifts the energies so that the Fermi energy is at zero.\n        # Shifting should be done by the plotter object though.\n\n        spins = [Spin.up, Spin.down] if cohp_file.is_spin_polarized \\\n            else [Spin.up]\n        if fmt == \"LOBSTER\":\n            energies += efermi\n\n        if orb_res_cohp is not None:\n            # If no total COHPs are present, calculate the total\n            # COHPs from the single-orbital populations. Total COHPs\n            # may not be present when the cohpgenerator keyword is used\n            # in LOBSTER versions 2.2.0 and earlier.\n            # TODO: Test this more extensively\n            for label in orb_res_cohp:\n                if cohp_file.cohp_data[label][\"COHP\"] is None:\n                    # print(label)\n                    cohp_data[label][\"COHP\"] = {\n                        sp: np.sum([orb_res_cohp[label][orbs][\"COHP\"][sp] for orbs in orb_res_cohp[label]], axis=0) for\n                        sp\n                        in spins}\n                if cohp_file.cohp_data[label][\"ICOHP\"] is None:\n                    cohp_data[label][\"ICOHP\"] = \\\n                        {sp: np.sum([orb_res_cohp[label][orbs][\"ICOHP\"][sp]\n                                     for orbs in orb_res_cohp[label]],\n                                    axis=0) for sp in spins}\n\n        if fmt == \"LMTO\":\n            # Calculate the average COHP for the LMTO file to be\n            # consistent with LOBSTER output.\n            avg_data = {\"COHP\": {}, \"ICOHP\": {}}\n            for i in avg_data:\n                for spin in spins:\n                    rows = np.array([cohp_data[label][i][spin]\n                                     for label in cohp_data])\n                    avg = np.average(rows, axis=0)\n                    # LMTO COHPs have 5 significant figures\n                    avg_data[i].update({spin:\n                                            np.array([round_to_sigfigs(a, 5)\n                                                      for a in avg],\n                                                     dtype=float)})\n            avg_cohp = Cohp(efermi, energies,\n                            avg_data[\"COHP\"],\n                            icohp=avg_data[\"ICOHP\"])\n        else:\n            avg_cohp = Cohp(efermi, energies,\n                            cohp_data[\"average\"][\"COHP\"],\n                            icohp=cohp_data[\"average\"][\"COHP\"],\n                            are_coops=are_coops)\n            del cohp_data[\"average\"]\n\n        cohp_dict = {label: Cohp(efermi, energies,\n                                 cohp_data[label][\"COHP\"],\n                                 icohp=cohp_data[label][\"ICOHP\"],\n                                 are_coops=are_coops)\n                     for label in cohp_data}\n\n        bond_dict = {label: {\"length\": cohp_data[label][\"length\"],\n                             \"sites\": [structure.sites[site]\n                                       for site in cohp_data[label][\"sites\"]]}\n                     for label in cohp_data}\n\n        return CompleteCohp(structure, avg_cohp, cohp_dict, bonds=bond_dict,\n                            are_coops=are_coops, orb_res_cohp=orb_res_cohp)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef icohpvalue(self, spin=Spin.up):\n        if not self.is_spin_polarized and spin == Spin.down:\n            raise ValueError(\"The calculation was not performed with spin polarization\")\n\n        return self._icohp[spin]", "response": "Returns the icohpvalue corresponding to the chosen spin"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the sum of ICOHPs of both spin channels for polarized compounds", "response": "def summed_icohp(self):\n        \"\"\"\n        Adds ICOHPs of both spin channels for spin polarized compounds\n        Returns:\n             icohp value in eV\n        \"\"\"\n        if self._is_spin_polarized:\n            sum_icohp = self._icohp[Spin.down] + self._icohp[Spin.up]\n        else:\n            sum_icohp = self._icohp[Spin.up]\n        return sum_icohp"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_icohp_by_label(self, label, summed_spin_channels=True, spin=Spin.up):\n\n        icohp_here = self._icohplist[label]\n        if icohp_here._is_spin_polarized:\n            if summed_spin_channels:\n                return icohp_here.summed_icohp\n            else:\n                return icohp_here.icohpvalue(spin)\n        else:\n            return icohp_here.icohpvalue(spin)", "response": "get an icohp value for a certain label"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the sum of all ICOHPs in a list of labels", "response": "def get_summed_icohp_by_label_list(self, label_list, divisor=1.0, summed_spin_channels=True, spin=Spin.up):\n        \"\"\"\n        get the sum of several ICOHP values that are indicated by a list of labels (labels of the bonds are the same as in ICOHPLIST/ICOOPLIST)\n        Args:\n            label_list: list of labels of the ICOHPs/ICOOPs that should be summed\n            divisor: is used to divide the sum\n            summed_spin_channels: Boolean to indicate whether the ICOHPs/ICOOPs of both spin channels should be summed\n            spin: if summed_spin_channels is equal to False, this spin indicates which spin channel should be returned\n\n        Returns:\n             float that is a sum of all ICOHPs/ICOOPs as indicated with label_list\n        \"\"\"\n        sum_icohp = 0\n        for label in label_list:\n            icohp_here = self._icohplist[label]\n            if icohp_here.num_bonds != 1:\n                warnings.warn(\"One of the ICOHP values is an average over bonds. This is currently not considered.\")\n            # prints warning if num_bonds is not equal to 1\n            if icohp_here._is_spin_polarized:\n                if summed_spin_channels:\n                    sum_icohp = sum_icohp + icohp_here.summed_icohp\n                else:\n                    sum_icohp = sum_icohp + icohp_here.icohpvalue(spin)\n            else:\n                sum_icohp = sum_icohp + icohp_here.icohpvalue(spin)\n        return sum_icohp / divisor"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_icohp_dict_by_bondlengths(self, minbondlength=0.0, maxbondlength=8.0):\n        newicohp_dict = {}\n        for value in self._icohplist.values():\n            if value._length >= minbondlength and value._length <= maxbondlength:\n                newicohp_dict[value._label] = value\n        return newicohp_dict", "response": "get a dict of IcohpValues corresponding to certaind bond lengths\n       "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_icohp_dict_of_site(self, site, minsummedicohp=None, maxsummedicohp=None, minbondlength=0.0,\n                               maxbondlength=8.0, only_bonds_to=None):\n        \"\"\"\n        get a dict of IcohpValue for a certain site (indicated by integer)\n        Args:\n            site: integer describing the site of interest, order as in Icohplist.lobster/Icooplist.lobster, starts at 0\n            minsummedicohp: float, minimal icohp/icoop of the bonds that are considered. It is the summed ICOHP value from both spin channels for spin polarized cases\n            maxsummedicohp: float, maximal icohp/icoop of the bonds that are considered. It is the summed ICOHP value from both spin channels for spin polarized cases\n            minbondlength: float, defines the minimum of the bond lengths of the bonds\n            maxbondlength: float, defines the maximum of the bond lengths of the bonds\n            only_bonds_to: list of strings describing the bonding partners that are allowed, e.g. ['O']\n        Returns:\n             dict of IcohpValues, the keys correspond to the values from the initial list_labels\n        \"\"\"\n\n        newicohp_dict = {}\n        for key, value in self._icohplist.items():\n            atomnumber1 = int(re.split(r'(\\d+)', value._atom1)[1]) - 1\n            atomnumber2 = int(re.split(r'(\\d+)', value._atom2)[1]) - 1\n            if site == atomnumber1 or site == atomnumber2:\n                # manipulate order of atoms so that searched one is always atom1\n                if site == atomnumber2:\n                    save = value._atom1\n                    value._atom1 = value._atom2\n                    value._atom2 = save\n\n                if only_bonds_to is None:\n                    second_test = True\n                else:\n                    second_test = (re.split(r'(\\d+)', value._atom2)[0] in only_bonds_to)\n                if value._length >= minbondlength and value._length <= maxbondlength and second_test:\n                    if minsummedicohp is not None:\n                        if value.summed_icohp >= minsummedicohp:\n                            if maxsummedicohp is not None:\n                                if value.summed_icohp <= maxsummedicohp:\n                                    newicohp_dict[key] = value\n                            else:\n                                newicohp_dict[key] = value\n                    else:\n                        if maxsummedicohp is not None:\n                            if value.summed_icohp <= maxsummedicohp:\n                                newicohp_dict[key] = value\n                        else:\n                            newicohp_dict[key] = value\n\n        return newicohp_dict", "response": "get a dict of ICOHP values for a certain site"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef extremum_icohpvalue(self, summed_spin_channels=True, spin=Spin.up):\n        if not self._are_coops:\n            extremum = sys.float_info.max\n        else:\n            extremum = -sys.float_info.max\n\n        if not self._is_spin_polarized:\n            if spin == Spin.down:\n                warnings.warn(\"This spin channel does not exist. I am switching to Spin.up\")\n            spin = Spin.up\n\n        for value in self._icohplist.values():\n            if not value.is_spin_polarized or not summed_spin_channels:\n                if not self._are_coops:\n                    if value.icohpvalue(spin) < extremum:\n                        extremum = value.icohpvalue(spin)\n                        # print(extremum)\n                else:\n                    if value.icohpvalue(spin) > extremum:\n                        extremum = value.icohpvalue(spin)\n                        # print(extremum)\n            else:\n                if not self._are_coops:\n                    if value.summed_icohp < extremum:\n                        extremum = value.summed_icohp\n                        # print(extremum)\n                else:\n                    if value.summed_icohp > extremum:\n                        extremum = value.summed_icohp\n                        # print(extremum)\n        return extremum", "response": "get the extremum value of the ICOHP of strongest bond"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef distance(self, other):\n        return np.linalg.norm(other.coords - self.coords)", "response": "Get distance between two sites."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef distance_from_point(self, pt):\n        return np.linalg.norm(np.array(pt) - self.coords)", "response": "Returns the distance between the site and a point in space."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef species_string(self):\n        if self.is_ordered:\n            return list(self.species.keys())[0].__str__()\n        else:\n            sorted_species = sorted(self.species.keys())\n            return \", \".join([\"{}:{:.3f}\".format(sp, self.species[sp])\n                              for sp in sorted_species])", "response": "Returns a string representation of the species of the current object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ntruing if site is an ordered site i. e. with a single species with occupancy 1.", "response": "def is_ordered(self):\n        \"\"\"\n        True if site is an ordered site, i.e., with a single species with\n        occupancy 1.\n        \"\"\"\n        totaloccu = self.species.num_atoms\n        return totaloccu == 1 and len(self.species) == 1"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a Site object from a dictionary representation.", "response": "def from_dict(cls, d):\n        \"\"\"\n        Create Site from dict representation\n        \"\"\"\n        atoms_n_occu = {}\n        for sp_occu in d[\"species\"]:\n            if \"oxidation_state\" in sp_occu and Element.is_valid_symbol(\n                    sp_occu[\"element\"]):\n                sp = Specie.from_dict(sp_occu)\n            elif \"oxidation_state\" in sp_occu:\n                sp = DummySpecie.from_dict(sp_occu)\n            else:\n                sp = Element(sp_occu[\"element\"])\n            atoms_n_occu[sp] = sp_occu[\"occu\"]\n        props = d.get(\"properties\", None)\n        return cls(atoms_n_occu, d[\"xyz\"], properties=props)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets the lattice associated with this object", "response": "def lattice(self, lattice):\n        \"\"\"\n        Sets Lattice associated with PeriodicSite\n        \"\"\"\n        self._lattice = lattice\n        self._coords = self._lattice.get_cartesian_coords(self._frac_coords)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef coords(self, coords):\n        self._coords = np.array(coords)\n        self._frac_coords = self._lattice.get_fractional_coords(self._coords)", "response": "Set the coordinates of the log entry"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the fractional coordinates of the log entries", "response": "def frac_coords(self, frac_coords):\n        \"\"\"\n        Fractional a coordinate\n        \"\"\"\n        self._frac_coords = np.array(frac_coords)\n        self._coords = self._lattice.get_cartesian_coords(self._frac_coords)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a PeriodicSite object that is a unit cell cell.", "response": "def to_unit_cell(self, in_place=False):\n        \"\"\"\n        Move frac coords to within the unit cell cell.\n        \"\"\"\n        frac_coords = np.mod(self.frac_coords, 1)\n        if in_place:\n            self.frac_coords = frac_coords\n        else:\n            return PeriodicSite(self.species, frac_coords, self.lattice,\n                                properties=self.properties)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef is_periodic_image(self, other, tolerance=1e-8, check_lattice=True):\n        if check_lattice and self.lattice != other.lattice:\n            return False\n        if self.species != other.species:\n            return False\n\n        frac_diff = pbc_diff(self.frac_coords, other.frac_coords)\n        return np.allclose(frac_diff, [0, 0, 0], atol=tolerance)", "response": "Returns True if the two sites are periodic images of each other."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the distance between site and a fractional coordinate assuming the periodic boundary conditions.", "response": "def distance_and_image_from_frac_coords(self, fcoords, jimage=None):\n        \"\"\"\n        Gets distance between site and a fractional coordinate assuming\n        periodic boundary conditions. If the index jimage of two sites atom j\n        is not specified it selects the j image nearest to the i atom and\n        returns the distance and jimage indices in terms of lattice vector\n        translations. If the index jimage of atom j is specified it returns the\n        distance between the i atom and the specified jimage atom, the given\n        jimage is also returned.\n\n        Args:\n            fcoords (3x1 array): fcoords to get distance from.\n            jimage (3x1 array): Specific periodic image in terms of\n                lattice translations, e.g., [1,0,0] implies to take periodic\n                image that is one a-lattice vector away. If jimage is None,\n                the image that is nearest to the site is found.\n\n        Returns:\n            (distance, jimage): distance and periodic lattice translations\n            of the other site for which the distance applies.\n        \"\"\"\n        return self.lattice.get_distance_and_image(self.frac_coords, fcoords,\n                                                   jimage=jimage)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef as_dict(self, verbosity=0):\n        species_list = []\n        for spec, occu in self._species.items():\n            d = spec.as_dict()\n            del d[\"@module\"]\n            del d[\"@class\"]\n            d[\"occu\"] = occu\n            species_list.append(d)\n\n        d = {\"species\": species_list,\n             \"abc\": [float(c) for c in self._frac_coords],\n             \"lattice\": self._lattice.as_dict(verbosity=verbosity),\n             \"@module\": self.__class__.__module__,\n             \"@class\": self.__class__.__name__}\n\n        if verbosity > 0:\n            d[\"xyz\"] = [float(c) for c in self.coords]\n            d[\"label\"] = self.species_string\n\n        d[\"properties\"] = self.properties\n        return d", "response": "Json - serializable dict representation of the PeriodicSite."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the energy of the entry in the system.", "response": "def get_energies(rootdir, reanalyze, verbose, detailed, sort, fmt):\n    \"\"\"\n    Doc string.\n    \"\"\"\n    if verbose:\n        logformat = \"%(relativeCreated)d msecs : %(message)s\"\n        logging.basicConfig(level=logging.INFO, format=logformat)\n\n    if not detailed:\n        drone = SimpleVaspToComputedEntryDrone(inc_structure=True)\n    else:\n        drone = VaspToComputedEntryDrone(inc_structure=True,\n                                         data=[\"filename\",\n                                               \"initial_structure\"])\n\n    ncpus = multiprocessing.cpu_count()\n    logging.info(\"Detected {} cpus\".format(ncpus))\n    queen = BorgQueen(drone, number_of_drones=ncpus)\n    if os.path.exists(SAVE_FILE) and not reanalyze:\n        msg = \"Using previously assimilated data from {}.\".format(SAVE_FILE) \\\n            + \" Use -r to force re-analysis.\"\n        queen.load_data(SAVE_FILE)\n    else:\n        if ncpus > 1:\n            queen.parallel_assimilate(rootdir)\n        else:\n            queen.serial_assimilate(rootdir)\n        msg = \"Analysis results saved to {} for faster \".format(SAVE_FILE) + \\\n              \"subsequent loading.\"\n        queen.save_data(SAVE_FILE)\n\n    entries = queen.get_data()\n    if sort == \"energy_per_atom\":\n        entries = sorted(entries, key=lambda x: x.energy_per_atom)\n    elif sort == \"filename\":\n        entries = sorted(entries, key=lambda x: x.data[\"filename\"])\n\n    all_data = []\n    for e in entries:\n        if not detailed:\n            delta_vol = \"{:.2f}\".format(e.data[\"delta_volume\"] * 100)\n        else:\n            delta_vol = e.structure.volume / \\\n                e.data[\"initial_structure\"].volume - 1\n            delta_vol = \"{:.2f}\".format(delta_vol * 100)\n        all_data.append((e.data[\"filename\"].replace(\"./\", \"\"),\n                         re.sub(r\"\\s+\", \"\", e.composition.formula),\n                         \"{:.5f}\".format(e.energy),\n                         \"{:.5f}\".format(e.energy_per_atom),\n                         delta_vol))\n    if len(all_data) > 0:\n        headers = (\"Directory\", \"Formula\", \"Energy\", \"E/Atom\", \"% vol chg\")\n        print(tabulate(all_data, headers=headers, tablefmt=fmt))\n        print(\"\")\n        print(msg)\n    else:\n        print(\"No valid vasp run found.\")\n        os.unlink(SAVE_FILE)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_pattern(self, structure, scaled=True, two_theta_range=(0, 90)):\n        if self.symprec:\n            finder = SpacegroupAnalyzer(structure, symprec=self.symprec)\n            structure = finder.get_refined_structure()\n\n        wavelength = self.wavelength\n        latt = structure.lattice\n        is_hex = latt.is_hexagonal()\n\n        # Obtained from Bragg condition. Note that reciprocal lattice\n        # vector length is 1 / d_hkl.\n        min_r, max_r = (0, 2 / wavelength) if two_theta_range is None else \\\n            [2 * sin(radians(t / 2)) / wavelength for t in two_theta_range]\n\n        # Obtain crystallographic reciprocal lattice points within range\n        recip_latt = latt.reciprocal_lattice_crystallographic\n        recip_pts = recip_latt.get_points_in_sphere(\n            [[0, 0, 0]], [0, 0, 0], max_r)\n        if min_r:\n            recip_pts = [pt for pt in recip_pts if pt[1] >= min_r]\n\n        # Create a flattened array of coeffs, fcoords and occus. This is\n        # used to perform vectorized computation of atomic scattering factors\n        # later. Note that these are not necessarily the same size as the\n        # structure as each partially occupied specie occupies its own\n        # position in the flattened array.\n        coeffs = []\n        fcoords = []\n        occus = []\n        dwfactors = []\n\n        for site in structure:\n            for sp, occu in site.species.items():\n                try:\n                    c = ATOMIC_SCATTERING_LEN[sp.symbol]\n                except KeyError:\n                    raise ValueError(\"Unable to calculate ND pattern as \"\n                                     \"there is no scattering coefficients for\"\n                                     \" %s.\" % sp.symbol)\n                coeffs.append(c)\n                dwfactors.append(self.debye_waller_factors.get(sp.symbol, 0))\n                fcoords.append(site.frac_coords)\n                occus.append(occu)\n\n        coeffs = np.array(coeffs)\n        fcoords = np.array(fcoords)\n        occus = np.array(occus)\n        dwfactors = np.array(dwfactors)\n        peaks = {}\n        two_thetas = []\n\n        for hkl, g_hkl, ind, _ in sorted(\n                recip_pts, key=lambda i: (i[1], -i[0][0], -i[0][1], -i[0][2])):\n            # Force miller indices to be integers.\n            hkl = [int(round(i)) for i in hkl]\n            if g_hkl != 0:\n\n                d_hkl = 1 / g_hkl\n\n                # Bragg condition\n                theta = asin(wavelength * g_hkl / 2)\n\n                # s = sin(theta) / wavelength = 1 / 2d = |ghkl| / 2 (d =\n                # 1/|ghkl|)\n                s = g_hkl / 2\n\n                # Calculate Debye-Waller factor\n                dw_correction = np.exp(-dwfactors * (s**2))\n\n                # Vectorized computation of g.r for all fractional coords and\n                # hkl.\n                g_dot_r = np.dot(fcoords, np.transpose([hkl])).T[0]\n\n                # Structure factor = sum of atomic scattering factors (with\n                # position factor exp(2j * pi * g.r and occupancies).\n                # Vectorized computation.\n                f_hkl = np.sum(coeffs * occus * np.exp(2j * pi * g_dot_r)\n                               * dw_correction)\n\n                # Lorentz polarization correction for hkl\n                lorentz_factor = 1 / (sin(theta) ** 2 * cos(theta))\n\n                # Intensity for hkl is modulus square of structure factor.\n                i_hkl = (f_hkl * f_hkl.conjugate()).real\n\n                two_theta = degrees(2 * theta)\n\n                if is_hex:\n                    # Use Miller-Bravais indices for hexagonal lattices.\n                    hkl = (hkl[0], hkl[1], - hkl[0] - hkl[1], hkl[2])\n                # Deal with floating point precision issues.\n                ind = np.where(np.abs(np.subtract(two_thetas, two_theta)) <\n                               self.TWO_THETA_TOL)\n                if len(ind[0]) > 0:\n                    peaks[two_thetas[ind[0][0]]][0] += i_hkl * lorentz_factor\n                    peaks[two_thetas[ind[0][0]]][1].append(tuple(hkl))\n                else:\n                    peaks[two_theta] = [i_hkl * lorentz_factor, [tuple(hkl)],\n                                        d_hkl]\n                    two_thetas.append(two_theta)\n\n        # Scale intensities so that the max intensity is 100.\n        max_intensity = max([v[0] for v in peaks.values()])\n        x = []\n        y = []\n        hkls = []\n        d_hkls = []\n        for k in sorted(peaks.keys()):\n            v = peaks[k]\n            fam = get_unique_families(v[1])\n            if v[0] / max_intensity * 100 > self.SCALED_INTENSITY_TOL:\n                x.append(k)\n                y.append(v[0])\n                hkls.append(fam)\n                d_hkls.append(v[2])\n        nd = DiffractionPattern(x, y, hkls, d_hkls)\n        if scaled:\n            nd.normalize(mode=\"max\", value=100)\n        return nd", "response": "Calculates the powder neutron diffraction pattern for a structure."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef find_equivalent_sites(self, site):\n        for sites in self.equivalent_sites:\n            if site in sites:\n                return sites\n\n        raise ValueError(\"Site not in structure\")", "response": "Finds all symmetrically equivalent sites for a particular site in the structure."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef run(self):\n\n        init_folder = os.getcwd()\n        os.chdir(self.folder)\n\n        with zopen(self.log_file, 'w') as fout:\n            subprocess.call([self._NWCHEM2FIESTA_cmd, self._nwcheminput_fn,\n                             self._nwchemoutput_fn, self._nwchemmovecs_fn],\n                            stdout=fout)\n\n        os.chdir(init_folder)", "response": "Runs actual NWCHEM2FIESTA run"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef gw_run(self):\n\n        if self.folder != os.getcwd():\n            init_folder = os.getcwd()\n            os.chdir(self.folder)\n\n        with zopen(self.log_file, 'w') as fout:\n            subprocess.call([\"mpirun\", \"-n\", str(self.mpi_procs), \"fiesta\",\n                             str(self.grid[0]), str(self.grid[1]),\n                             str(self.grid[2])], stdout=fout)\n\n        if self.folder != os.getcwd():\n            os.chdir(init_folder)", "response": "Performs FIESTA ( gw ) run\n           "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the number of nlm orbitals for the basis set", "response": "def set_n_nlmo(self):\n        \"\"\"\n                :return: the number of nlm orbitals for the basis set\n        \"\"\"\n\n        nnlmo = 0\n\n        data_tmp = self.data\n        data_tmp.pop('lmax')\n        data_tmp.pop('n_nlo')\n        data_tmp.pop('preamble')\n\n        for l_zeta_ng in data_tmp:\n            l = l_zeta_ng.split(\"_\")[0]\n            nnlmo = nnlmo + (2 * int(l) + 1)\n\n        return str(nnlmo)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a string with the information on the basis set", "response": "def infos_on_basis_set(self):\n        \"\"\"\n        infos on the basis set as in Fiesta log\n        \"\"\"\n        o = []\n        o.append(\"=========================================\")\n        o.append(\"Reading basis set:\")\n        o.append(\"\")\n        o.append(\" Basis set for {} atom \".format(str(self.filename)))\n        o.append(\" Maximum angular momentum = {}\".format(self.data['lmax']))\n        o.append(\" Number of atomics orbitals = {}\".format(self.data['n_nlo']))\n        o.append(\" Number of nlm orbitals = {}\".format(self.data['n_nlmo']))\n        o.append(\"=========================================\")\n\n        return str(0)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncopy in the desired folder the needed auxiliary basis set X2. ion", "response": "def set_auxiliary_basis_set(self, folder, auxiliary_folder,\n                                auxiliary_basis_set_type=\"aug_cc_pvtz\"):\n        \"\"\"\n        copy in the desired folder the needed auxiliary basis set \"X2.ion\" where X is a specie.\n        :param auxiliary_folder: folder where the auxiliary basis sets are stored\n        :param auxiliary_basis_set_type: type of basis set (string to be found in the extension of the file name; must be in lower case)\n               ex: C2.ion_aug_cc_pvtz_RI_Weigend find \"aug_cc_pvtz\"\n        \"\"\"\n\n        list_files = os.listdir(auxiliary_folder)\n\n        for specie in self._mol.symbol_set:\n            for file in list_files:\n                if file.upper().find(\n                                specie.upper() + \"2\") != -1 and file.lower().find(\n                        auxiliary_basis_set_type) != -1:\n                    shutil.copyfile(auxiliary_folder + \"/\" + file,\n                                    folder + \"/\" + specie + \"2.ion\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_GW_options(self, nv_band=10, nc_band=10, n_iteration=5, n_grid=6,\n                       dE_grid=0.5):\n        \"\"\"\n        Set parameters in cell.in for a GW computation\n        :param nv__band: number of valence bands to correct with GW\n        :param nc_band: number of conduction bands to correct with GW\n        :param n_iteration: number of iteration\n        :param n_grid and dE_grid:: number of points and spacing in eV for correlation grid\n        \"\"\"\n\n        self.GW_options.update(nv_corr=nv_band, nc_corr=nc_band,\n                               nit_gw=n_iteration)\n        self.correlation_grid.update(dE_grid=dE_grid, n_grid=n_grid)", "response": "Set parameters in cell. in for a GW computation"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nmaking the full BSE Densities folder.", "response": "def make_FULL_BSE_Densities_folder(self, folder):\n        \"\"\"\n        mkdir \"FULL_BSE_Densities\" folder (needed for bse run) in the desired folder\n        \"\"\"\n\n        if os.path.exists(folder + \"/FULL_BSE_Densities\"):\n            return \"FULL_BSE_Densities folder already exists\"\n        else:\n            os.makedirs(folder + \"/FULL_BSE_Densities\")\n            return \"makedirs FULL_BSE_Densities folder\""}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_BSE_options(self, n_excitations=10, nit_bse=200):\n\n        self.BSE_TDDFT_options.update(npsi_bse=n_excitations, nit_bse=nit_bse)", "response": "Set parameters in cell. in for a BSE computation"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndumping the BSE data in the GW run", "response": "def dump_BSE_data_in_GW_run(self, BSE_dump=True):\n        \"\"\"\n        :param BSE_dump: boolean\n        :return: set the \"do_bse\" variable to one in cell.in\n        \"\"\"\n\n        if BSE_dump:\n            self.BSE_TDDFT_options.update(do_bse=1, do_tddft=0)\n        else:\n            self.BSE_TDDFT_options.update(do_bse=0, do_tddft=0)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndump the TDDFT data in the GW run", "response": "def dump_TDDFT_data_in_GW_run(self, TDDFT_dump=True):\n        \"\"\"\n        :param TDDFT_dump: boolen\n        :return: set the do_tddft variable to one in cell.in\n        \"\"\"\n        if TDDFT_dump == True:\n            self.BSE_TDDFT_options.update(do_bse=0, do_tddft=1)\n        else:\n            self.BSE_TDDFT_options.update(do_bse=0, do_tddft=0)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef infos_on_system(self):\n\n        o = []\n        o.append(\"=========================================\")\n        o.append(\"Reading infos on system:\")\n        o.append(\"\")\n        o.append(\" Number of atoms = {} ; number of species = {}\".format(\n            int(self._mol.composition.num_atoms), len(self._mol.symbol_set)))\n        o.append(\" Number of valence bands = {}\".format(\n            int(self._mol.nelectrons / 2)))\n        o.append(\" Sigma grid specs: n_grid = {} ;  dE_grid = {} (eV)\".format(\n            self.correlation_grid['n_grid'], self.correlation_grid['dE_grid']))\n        if int(self.Exc_DFT_option['rdVxcpsi']) == 1:\n            o.append(\" Exchange and correlation energy read from Vxcpsi.mat\")\n        elif int(self.Exc_DFT_option['rdVxcpsi']) == 0:\n            o.append(\" Exchange and correlation energy re-computed\")\n\n        if self.COHSEX_options['eigMethod'] == \"C\":\n            o.append(\n                \" Correcting  {} valence bands and   {} conduction bands at COHSEX level\".format(\n                    self.COHSEX_options['nv_cohsex'],\n                    self.COHSEX_options['nc_cohsex']))\n            o.append(\" Performing   {} diagonal COHSEX iterations\".format(\n                self.COHSEX_options['nit_cohsex']))\n        elif self.COHSEX_options['eigMethod'] == \"HF\":\n            o.append(\n                \" Correcting  {} valence bands and   {} conduction bands at HF level\".format(\n                    self.COHSEX_options['nv_cohsex'],\n                    self.COHSEX_options['nc_cohsex']))\n            o.append(\" Performing   {} diagonal HF iterations\".format(\n                self.COHSEX_options['nit_cohsex']))\n\n        o.append(\" Using resolution of identity : {}\".format(\n            self.COHSEX_options['resMethod']))\n        o.append(\n            \" Correcting  {} valence bands and  {} conduction bands at GW level\".format(\n                self.GW_options['nv_corr'], self.GW_options['nc_corr']))\n        o.append(\n            \" Performing   {} GW iterations\".format(self.GW_options['nit_gw']))\n\n        if int(self.BSE_TDDFT_options['do_bse']) == 1:\n            o.append(\" Dumping data for BSE treatment\")\n\n        if int(self.BSE_TDDFT_options['do_tddft']) == 1:\n            o.append(\" Dumping data for TD-DFT treatment\")\n        o.append(\"\")\n        o.append(\" Atoms in cell cartesian A:\")\n        symbols = []\n        for syb in self._mol.symbol_set:\n            symbols.append(syb)\n\n        for site in self._mol:\n            o.append(\" {} {} {} {}\".format(site.x, site.y,\n                                           site.z, int(\n                    symbols.index(site.specie.symbol)) + 1))\n\n        o.append(\"=========================================\")\n\n        return str(o)", "response": "Returns a list of infos on the initial parameters as in the log file of Fiesta\n       "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nread an FiestaInput from a string.", "response": "def from_string(cls, string_input):\n        \"\"\"\n        Read an FiestaInput from a string. Currently tested to work with\n        files generated from this class itself.\n\n        Args:\n            string_input: string_input to parse.\n        Returns:\n            FiestaInput object\n        \"\"\"\n\n        correlation_grid = {}\n        Exc_DFT_option = {}\n        COHSEX_options = {}\n        GW_options = {}\n        BSE_TDDFT_options = {}\n\n        lines = string_input.strip().split(\"\\n\")\n\n        # number of atoms and species\n        lines.pop(0)\n        l = lines.pop(0).strip()\n        toks = l.split()\n        nat = toks[0]\n        nsp = toks[1]\n        # number of valence bands\n        lines.pop(0)\n        l = lines.pop(0).strip()\n        toks = l.split()\n        nvbands = toks[0]\n\n        # correlation_grid\n        # number of points and spacing in eV for correlation grid\n        lines.pop(0)\n        l = lines.pop(0).strip()\n        toks = l.split()\n        correlation_grid['n_grid'] = toks[0]\n        correlation_grid['dE_grid'] = toks[1]\n\n        # Exc DFT\n        # relire=1 ou recalculer=0 Exc DFT\n        lines.pop(0)\n        l = lines.pop(0).strip()\n        toks = l.split()\n        Exc_DFT_option['rdVxcpsi'] = toks[0]\n\n        # COHSEX\n        # number of COHSEX corrected occp and unoccp bands: C=COHSEX  H=HF\n        lines.pop(0)\n        l = lines.pop(0).strip()\n        toks = l.split()\n        COHSEX_options['nv_cohsex'] = toks[0]\n        COHSEX_options['nc_cohsex'] = toks[1]\n        COHSEX_options['eigMethod'] = toks[2]\n        # number of COHSEX iter, scf on wfns, mixing coeff; V=RI-V  I=RI-D\n        lines.pop(0)\n        l = lines.pop(0).strip()\n        toks = l.split()\n        COHSEX_options['nit_cohsex'] = toks[0]\n        COHSEX_options['resMethod'] = toks[1]\n        COHSEX_options['scf_cohsex_wf'] = toks[2]\n        COHSEX_options['mix_cohsex'] = toks[3]\n\n        # GW\n        # number of GW corrected occp and unoccp bands\n        lines.pop(0)\n        l = lines.pop(0).strip()\n        toks = l.split()\n        GW_options['nv_corr'] = toks[0]\n        GW_options['nc_corr'] = toks[1]\n        # number of GW iterations\n        lines.pop(0)\n        l = lines.pop(0).strip()\n        toks = l.split()\n        GW_options['nit_gw'] = toks[0]\n\n        # BSE\n        # dumping for BSE and TDDFT\n        lines.pop(0)\n        l = lines.pop(0).strip()\n        toks = l.split()\n        BSE_TDDFT_options['do_bse'] = toks[0]\n        BSE_TDDFT_options['do_tddft'] = toks[1]\n        # number of occp. and virtual bands fo BSE: nocore and up to 40 eVs\n        lines.pop(0)\n        l = lines.pop(0).strip()\n        toks = l.split()\n        BSE_TDDFT_options['nv_bse'] = toks[0]\n        BSE_TDDFT_options['nc_bse'] = toks[1]\n        # number of excitations needed and number of iterations\n        lines.pop(0)\n        l = lines.pop(0).strip()\n        toks = l.split()\n        BSE_TDDFT_options['npsi_bse'] = toks[0]\n        BSE_TDDFT_options['nit_bse'] = toks[1]\n\n        # Molecule\n        # list of symbols in order\n        lines.pop(0)\n        atname = []\n        i = int(nsp)\n        while i != 0:\n            l = lines.pop(0).strip()\n            toks = l.split()\n            atname.append(toks[0])\n            i -= 1\n\n        # scaling factor\n        lines.pop(0)\n        l = lines.pop(0).strip()\n        toks = l.split()\n        scale = toks[0]\n        # atoms x,y,z cartesian .. will be multiplied by scale\n        lines.pop(0)\n        # Parse geometry\n        species = []\n        coords = []\n        i = int(nat)\n        while i != 0:\n            l = lines.pop(0).strip()\n            toks = l.split()\n            coords.append([float(j) for j in toks[0:3]])\n            species.append(atname[int(toks[3]) - 1])\n            i -= 1\n\n        mol = Molecule(species, coords)\n\n        return FiestaInput(mol=mol, correlation_grid=correlation_grid,\n                           Exc_DFT_option=Exc_DFT_option,\n                           COHSEX_options=COHSEX_options,\n                           GW_options=GW_options,\n                           BSE_TDDFT_options=BSE_TDDFT_options)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef from_file(cls, filename):\n        with zopen(filename) as f:\n            return cls.from_string(f.read())", "response": "Read an Fiesta input from a file. Currently tested to work with\n            files generated from this class itself."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nundoing the last change in the TransformedStructure.", "response": "def undo_last_change(self):\n        \"\"\"\n        Undo the last change in the TransformedStructure.\n\n        Raises:\n            IndexError: If already at the oldest change.\n        \"\"\"\n        if len(self.history) == 0:\n            raise IndexError(\"Can't undo. Already at oldest change.\")\n        if 'input_structure' not in self.history[-1]:\n            raise IndexError(\"Can't undo. Latest history has no \"\n                             \"input_structure\")\n        h = self.history.pop()\n        self._undone.append((h, self.final_structure))\n        s = h[\"input_structure\"]\n        if isinstance(s, dict):\n            s = Structure.from_dict(s)\n        self.final_structure = s"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef redo_next_change(self):\n        if len(self._undone) == 0:\n            raise IndexError(\"Can't redo. Already at latest change.\")\n        h, s = self._undone.pop()\n        self.history.append(h)\n        self.final_structure = s", "response": "Redo the last undone change in the TransformedStructure."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nappends a transformation to the TransformedStructure.", "response": "def append_transformation(self, transformation, return_alternatives=False,\n                              clear_redo=True):\n        \"\"\"\n        Appends a transformation to the TransformedStructure.\n\n        Args:\n            transformation: Transformation to append\n            return_alternatives: Whether to return alternative\n                TransformedStructures for one-to-many transformations.\n                return_alternatives can be a number, which stipulates the\n                total number of structures to return.\n            clear_redo: Boolean indicating whether to clear the redo list.\n                By default, this is True, meaning any appends clears the\n                history of undoing. However, when using append_transformation\n                to do a redo, the redo list should not be cleared to allow\n                multiple redos.\n        \"\"\"\n        if clear_redo:\n            self._undone = []\n\n        if return_alternatives and transformation.is_one_to_many:\n            ranked_list = transformation.apply_transformation(\n                self.final_structure, return_ranked_list=return_alternatives)\n\n            input_structure = self.final_structure.as_dict()\n            alts = []\n            for x in ranked_list[1:]:\n                s = x.pop(\"structure\")\n                actual_transformation = x.pop(\"transformation\", transformation)\n                hdict = actual_transformation.as_dict()\n                hdict[\"input_structure\"] = input_structure\n                hdict[\"output_parameters\"] = x\n                self.final_structure = s\n                d = self.as_dict()\n                d['history'].append(hdict)\n                d['final_structure'] = s.as_dict()\n                alts.append(TransformedStructure.from_dict(d))\n\n            x = ranked_list[0]\n            s = x.pop(\"structure\")\n            actual_transformation = x.pop(\"transformation\", transformation)\n            hdict = actual_transformation.as_dict()\n            hdict[\"input_structure\"] = self.final_structure.as_dict()\n            hdict[\"output_parameters\"] = x\n            self.history.append(hdict)\n            self.final_structure = s\n            return alts\n        else:\n            s = transformation.apply_transformation(self.final_structure)\n            hdict = transformation.as_dict()\n            hdict[\"input_structure\"] = self.final_structure.as_dict()\n            hdict[\"output_parameters\"] = {}\n            self.history.append(hdict)\n            self.final_structure = s"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd a filter to the list of entries in the final structure.", "response": "def append_filter(self, structure_filter):\n        \"\"\"\n        Adds a filter.\n\n        Args:\n            structure_filter (StructureFilter): A filter implementating the\n                AbstractStructureFilter API. Tells transmuter waht structures\n                to retain.\n        \"\"\"\n        hdict = structure_filter.as_dict()\n        hdict[\"input_structure\"] = self.final_structure.as_dict()\n        self.history.append(hdict)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef extend_transformations(self, transformations,\n                               return_alternatives=False):\n        \"\"\"\n        Extends a sequence of transformations to the TransformedStructure.\n\n        Args:\n            transformations: Sequence of Transformations\n            return_alternatives: Whether to return alternative\n                TransformedStructures for one-to-many transformations.\n                return_alternatives can be a number, which stipulates the\n                total number of structures to return.\n        \"\"\"\n        for t in transformations:\n            self.append_transformation(t,\n                                       return_alternatives=return_alternatives)", "response": "Extends a sequence of transformations to the TransformedStructure."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning VASP input as a dict of vasp objects.", "response": "def get_vasp_input(self, vasp_input_set=MPRelaxSet, **kwargs):\n        \"\"\"\n        Returns VASP input as a dict of vasp objects.\n\n        Args:\n            vasp_input_set (pymatgen.io.vaspio_set.VaspInputSet): input set\n                to create vasp input files from structures\n        \"\"\"\n        d = vasp_input_set(self.final_structure, **kwargs).get_vasp_input()\n        d[\"transformations.json\"] = json.dumps(self.as_dict())\n        return d"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef write_vasp_input(self, vasp_input_set=MPRelaxSet, output_dir=\".\",\n                         create_directory=True, **kwargs):\n        \"\"\"\n        Writes VASP input to an output_dir.\n\n        Args:\n            vasp_input_set:\n                pymatgen.io.vaspio_set.VaspInputSet like object that creates\n                vasp input files from structures\n            output_dir: Directory to output files\n            create_directory: Create the directory if not present. Defaults to\n                True.\n            \\\\*\\\\*kwargs: All keyword args supported by the VASP input set.\n        \"\"\"\n        vasp_input_set(self.final_structure, **kwargs).write_input(\n            output_dir, make_dir_if_not_present=create_directory)\n        with open(os.path.join(output_dir, \"transformations.json\"), \"w\") as fp:\n            json.dump(self.as_dict(), fp)", "response": "Writes VASP input to an output_dir."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a list of all structures in the TransformedStructure.", "response": "def structures(self):\n        \"\"\"\n        Copy of all structures in the TransformedStructure. A\n        structure is stored after every single transformation.\n        \"\"\"\n        hstructs = [Structure.from_dict(s['input_structure'])\n                    for s in self.history if 'input_structure' in s]\n        return hstructs + [self.final_structure]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef from_cif_string(cif_string, transformations=None, primitive=True,\n                        occupancy_tolerance=1.):\n        \"\"\"\n        Generates TransformedStructure from a cif string.\n\n        Args:\n            cif_string (str): Input cif string. Should contain only one\n                structure. For cifs containing multiple structures, please use\n                CifTransmuter.\n            transformations ([Transformations]): Sequence of transformations\n                to be applied to the input structure.\n            primitive (bool): Option to set if the primitive cell should be\n                extracted. Defaults to True. However, there are certain\n                instances where you might want to use a non-primitive cell,\n                e.g., if you are trying to generate all possible orderings of\n                partial removals or order a disordered structure.\n            occupancy_tolerance (float): If total occupancy of a site is\n                between 1 and occupancy_tolerance, the occupancies will be\n                scaled down to 1.\n\n        Returns:\n            TransformedStructure\n        \"\"\"\n        parser = CifParser.from_string(cif_string, occupancy_tolerance)\n        raw_string = re.sub(r\"'\", \"\\\"\", cif_string)\n        cif_dict = parser.as_dict()\n        cif_keys = list(cif_dict.keys())\n        s = parser.get_structures(primitive)[0]\n        partial_cif = cif_dict[cif_keys[0]]\n        if \"_database_code_ICSD\" in partial_cif:\n            source = partial_cif[\"_database_code_ICSD\"] + \"-ICSD\"\n        else:\n            source = \"uploaded cif\"\n        source_info = {\"source\": source,\n                       \"datetime\": str(datetime.datetime.now()),\n                       \"original_file\": raw_string,\n                       \"cif_data\": cif_dict[cif_keys[0]]}\n        return TransformedStructure(s, transformations, history=[source_info])", "response": "Generates a TransformedStructure from a string containing only one cifite structure."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ngenerate a TransformedStructure from a string containing a POSCAR string.", "response": "def from_poscar_string(poscar_string, transformations=None):\n        \"\"\"\n        Generates TransformedStructure from a poscar string.\n\n        Args:\n            poscar_string (str): Input POSCAR string.\n            transformations ([Transformations]): Sequence of transformations\n                to be applied to the input structure.\n        \"\"\"\n        p = Poscar.from_string(poscar_string)\n        if not p.true_names:\n            raise ValueError(\"Transformation can be craeted only from POSCAR \"\n                             \"strings with proper VASP5 element symbols.\")\n        raw_string = re.sub(r\"'\", \"\\\"\", poscar_string)\n        s = p.structure\n        source_info = {\"source\": \"POSCAR\",\n                       \"datetime\": str(datetime.datetime.now()),\n                       \"original_file\": raw_string}\n        return TransformedStructure(s, transformations, history=[source_info])"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a dict representation of the TransformedStructure.", "response": "def as_dict(self):\n        \"\"\"\n        Dict representation of the TransformedStructure.\n        \"\"\"\n        d = self.final_structure.as_dict()\n        d[\"@module\"] = self.__class__.__module__\n        d[\"@class\"] = self.__class__.__name__\n        d[\"history\"] = jsanitize(self.history)\n        d[\"version\"] = __version__\n        d[\"last_modified\"] = str(datetime.datetime.utcnow())\n        d[\"other_parameters\"] = jsanitize(self.other_parameters)\n        return d"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating a TransformedStructure from a dict.", "response": "def from_dict(cls, d):\n        \"\"\"\n        Creates a TransformedStructure from a dict.\n        \"\"\"\n        s = Structure.from_dict(d)\n        return cls(s, history=d[\"history\"],\n                   other_parameters=d.get(\"other_parameters\", None))"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates TransformedStructure from SNL.", "response": "def from_snl(cls, snl):\n        \"\"\"\n        Create TransformedStructure from SNL.\n\n        Args:\n            snl (StructureNL): Starting snl\n\n        Returns:\n            TransformedStructure\n        \"\"\"\n        hist = []\n        for h in snl.history:\n            d = h.description\n            d['_snl'] = {'url': h.url, 'name': h.name}\n            hist.append(d)\n        return cls(snl.structure, history=hist)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef from_file(feff_inp_file='feff.inp', ldos_file='ldos'):\n        header_str = Header.header_string_from_file(feff_inp_file)\n        header = Header.from_string(header_str)\n        structure = header.struct\n        nsites = structure.num_sites\n        parameters = Tags.from_file(feff_inp_file)\n\n        if \"RECIPROCAL\" in parameters:\n            pot_dict = dict()\n            pot_readstart = re.compile('.*iz.*lmaxsc.*xnatph.*xion.*folp.*')\n            pot_readend = re.compile('.*ExternalPot.*switch.*')\n            pot_inp = re.sub(r'feff.inp', r'pot.inp', feff_inp_file)\n            dos_index = 1\n            begin = 0\n\n            with zopen(pot_inp, \"r\") as potfile:\n                for line in potfile:\n                    if len(pot_readend.findall(line)) > 0:\n                        break\n\n                    if begin == 1:\n                        begin += 1\n                        continue\n\n                    if begin == 2:\n                        z_number = int(line.strip().split()[0])\n                        ele_name = Element.from_Z(z_number).name\n                        if ele_name not in pot_dict:\n                            pot_dict[ele_name] = dos_index\n                        else:\n                            pot_dict[ele_name] = min(dos_index, pot_dict[ele_name])\n                        dos_index += 1\n\n                    if len(pot_readstart.findall(line)) > 0:\n                        begin = 1\n        else:\n            pot_string = Potential.pot_string_from_file(feff_inp_file)\n            dicts = Potential.pot_dict_from_string(pot_string)\n            pot_dict = dicts[0]\n\n        with zopen(ldos_file + \"00.dat\", \"r\") as fobject:\n            f = fobject.readlines()\n        efermi = float(f[0].split()[4])\n\n        dos_energies = []\n        ldos = {}\n\n        for i in range(1, len(pot_dict) + 1):\n            if len(str(i)) == 1:\n                ldos[i] = np.loadtxt(\"{}0{}.dat\".format(ldos_file, i))\n            else:\n                ldos[i] = np.loadtxt(\"{}{}.dat\".format(ldos_file, i))\n\n        for i in range(0, len(ldos[1])):\n            dos_energies.append(ldos[1][i][0])\n\n        all_pdos = []\n        vorb = {\"s\": Orbital.s, \"p\": Orbital.py, \"d\": Orbital.dxy,\n                \"f\": Orbital.f0}\n        forb = {\"s\": 0, \"p\": 1, \"d\": 2, \"f\": 3}\n\n        dlength = len(ldos[1])\n\n        for i in range(nsites):\n            pot_index = pot_dict[structure.species[i].symbol]\n            all_pdos.append(defaultdict(dict))\n            for k, v in vorb.items():\n                density = [ldos[pot_index][j][forb[k] + 1]\n                           for j in range(dlength)]\n                updos = density\n                downdos = None\n                if downdos:\n                    all_pdos[-1][v] = {Spin.up: updos, Spin.down: downdos}\n                else:\n                    all_pdos[-1][v] = {Spin.up: updos}\n\n        pdos = all_pdos\n        vorb2 = {0: Orbital.s, 1: Orbital.py, 2: Orbital.dxy, 3: Orbital.f0}\n        pdoss = {structure[i]: {v: pdos[i][v]\n                                for v in vorb2.values()}\n                 for i in range(len(pdos))}\n\n        forb = {\"s\": 0, \"p\": 1, \"d\": 2, \"f\": 3}\n\n        tdos = [0] * dlength\n        for i in range(nsites):\n            pot_index = pot_dict[structure.species[i].symbol]\n            for v in forb.values():\n                density = [ldos[pot_index][j][v + 1] for j in range(dlength)]\n                for j in range(dlength):\n                    tdos[j] = tdos[j] + density[j]\n        tdos = {Spin.up: tdos}\n\n        dos = Dos(efermi, dos_energies, tdos)\n        complete_dos = CompleteDos(structure, dos, pdoss)\n        charge_transfer = LDos.charge_transfer_from_file(feff_inp_file,\n                                                         ldos_file)\n        return LDos(complete_dos, charge_transfer)", "response": "Creates a CFG object from a Feff input file."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget charge transfer from feff. inp file and ldos. dat.", "response": "def charge_transfer_from_file(feff_inp_file, ldos_file):\n        \"\"\"\n        Get charge transfer from file.\n\n        Args:\n            feff_inp_file (str): name of feff.inp file for run\n            ldos_file (str): ldos filename for run, assume consequetive order,\n                i.e., ldos01.dat, ldos02.dat....\n\n        Returns:\n            dictionary of dictionaries in order of potential sites\n            ({\"p\": 0.154, \"s\": 0.078, \"d\": 0.0, \"tot\": 0.232}, ...)\n        \"\"\"\n        cht = OrderedDict()\n        parameters = Tags.from_file(feff_inp_file)\n\n        if 'RECIPROCAL' in parameters:\n            dicts = [dict()]\n            pot_dict = dict()\n            dos_index = 1\n            begin = 0\n            pot_inp = re.sub(r'feff.inp', r'pot.inp', feff_inp_file)\n            pot_readstart = re.compile('.*iz.*lmaxsc.*xnatph.*xion.*folp.*')\n            pot_readend = re.compile('.*ExternalPot.*switch.*')\n            with zopen(pot_inp, \"r\") as potfile:\n                for line in potfile:\n                    if len(pot_readend.findall(line)) > 0:\n                        break\n                    if begin == 1:\n                        z_number = int(line.strip().split()[0])\n                        ele_name = Element.from_Z(z_number).name\n                        if len(pot_dict) == 0:\n                            pot_dict[0] = ele_name\n                        elif len(pot_dict) > 0:\n                            pot_dict[max(pot_dict.keys()) + 1] = ele_name\n                        begin += 1\n                        continue\n                    if begin == 2:\n                        z_number = int(line.strip().split()[0])\n                        ele_name = Element.from_Z(z_number).name\n                        dicts[0][ele_name] = dos_index\n                        dos_index += 1\n                        if len(pot_dict) == 0:\n                            pot_dict[0] = ele_name\n                        elif len(pot_dict) > 0:\n                            pot_dict[max(pot_dict.keys()) + 1] = ele_name\n                    if len(pot_readstart.findall(line)) > 0:\n                        begin = 1\n        else:\n            pot_string = Potential.pot_string_from_file(feff_inp_file)\n            dicts = Potential.pot_dict_from_string(pot_string)\n            pot_dict = dicts[1]\n\n        for i in range(0, len(dicts[0]) + 1):\n            if len(str(i)) == 1:\n                with zopen(\"{}0{}.dat\".format(ldos_file, i), \"rt\") \\\n                        as fobject:\n                    f = fobject.readlines()\n                    s = float(f[3].split()[2])\n                    p = float(f[4].split()[2])\n                    d = float(f[5].split()[2])\n                    f1 = float(f[6].split()[2])\n                    tot = float(f[1].split()[4])\n                    cht[str(i)] = {pot_dict[i]: {'s': s, 'p': p, 'd': d,\n                                                 'f': f1,\n                                                 'tot': tot}}\n            else:\n                with zopen(ldos_file + str(i) + \".dat\", \"rt\") as fid:\n                    f = fid.readlines()\n                    s = float(f[3].split()[2])\n                    p = float(f[4].split()[2])\n                    d = float(f[5].split()[2])\n                    f1 = float(f[6].split()[2])\n                    tot = float(f[1].split()[4])\n                    cht[str(i)] = {pot_dict[i]: {'s': s, 'p': p, 'd': d,\n                                                 'f': f1,\n                                                 'tot': tot}}\n\n        return cht"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns shrage transfer as string", "response": "def charge_transfer_to_string(self):\n        \"\"\"returns shrage transfer as string\"\"\"\n        ch = self.charge_transfer\n        chts = ['\\nCharge Transfer\\n\\nabsorbing atom']\n        for i in range(len(ch)):\n            for atom, v2 in ch[str(i)].items():\n                a = ['\\n', atom, '\\n', 's   ', str(v2['s']), '\\n',\n                     'p   ', str(v2['p']), '\\n',\n                     'd   ', str(v2['d']), '\\n',\n                     'f   ', str(v2['f']), '\\n',\n                     'tot ', str(v2['tot']), '\\n']\n                chts.extend(a)\n        return ''.join(chts)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef from_file(xmu_dat_file=\"xmu.dat\", feff_inp_file=\"feff.inp\"):\n        data = np.loadtxt(xmu_dat_file)\n        header = Header.from_file(feff_inp_file)\n        parameters = Tags.from_file(feff_inp_file)\n        pots = Potential.pot_string_from_file(feff_inp_file)\n        # site index (Note: in feff it starts from 1)\n        if \"RECIPROCAL\" in parameters:\n            absorbing_atom = parameters[\"TARGET\"]\n        # species symbol\n        else:\n            absorbing_atom = pots.splitlines()[3].split()[2]\n        return Xmu(header, parameters, absorbing_atom, data)", "response": "Get Xmu object from file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn chemical formula of material from feff. inp file", "response": "def material_formula(self):\n        \"\"\"\n        Returns chemical formula of material from feff.inp file\n        \"\"\"\n        try:\n            form = self.header.formula\n        except IndexError:\n            form = 'No formula provided'\n        return \"\".join(map(str, form))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning dict representation of Xmu object", "response": "def as_dict(self):\n        \"\"\"\n        Returns dict representations of Xmu object\n        \"\"\"\n        d = MSONable.as_dict(self)\n        d[\"data\"] = self.data.tolist()\n        return d"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef iterlines(s):\n    prevnl = -1\n    while True:\n        nextnl = s.find('\\n', prevnl + 1)\n        if nextnl < 0:\n            yield s[(prevnl+1):]\n            break\n        else:\n            yield s[(prevnl+1):nextnl]\n            prevnl = nextnl", "response": "A generator form of s split for reducing memory overhead."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the option string.", "response": "def _options_string(self):\n        \"\"\"\n        Return the option string.\n        \"\"\"\n        if len(self.options) > 0:\n            s = \"\"\n            for op in self.options:\n                if self._sized_op:\n                    s += \"{:s}={:s} \".format(*map(str, op))\n                else:\n                    s += \"{:s} \".format(str(op))\n            return s.strip()\n        else:\n            return \"\""}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns True if this AdfKey contains the given subkey.", "response": "def has_subkey(self, subkey):\n        \"\"\"\n        Return True if this AdfKey contains the given subkey.\n\n        Parameters\n        ----------\n        subkey : str or AdfKey\n            A key name or an AdfKey object.\n\n        Returns\n        -------\n        has : bool\n            True if this key contains the given key. Otherwise False.\n\n        \"\"\"\n        if isinstance(subkey, str):\n            key = subkey\n        elif isinstance(subkey, AdfKey):\n            key = subkey.key\n        else:\n            raise ValueError(\"The subkey should be an AdfKey or a string!\")\n        if len(self.subkeys) > 0:\n            if key in map(lambda k: k.key, self.subkeys):\n                return True\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd a new subkey to this key.", "response": "def add_subkey(self, subkey):\n        \"\"\"\n        Add a new subkey to this key.\n\n        Parameters\n        ----------\n        subkey : AdfKey\n            A new subkey.\n\n        Notes\n        -----\n        Duplicate check will not be performed if this is an 'Atoms' block.\n\n        \"\"\"\n        if self.key.lower() == 'atoms' or not self.has_subkey(subkey):\n            self.subkeys.append(subkey)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef remove_subkey(self, subkey):\n        if len(self.subkeys) > 0:\n            key = subkey if isinstance(subkey, str) else subkey.key\n            for i in range(len(self.subkeys)):\n                if self.subkeys[i].key == key:\n                    self.subkeys.pop(i)\n                    break", "response": "Removes the given subkey from this AdfKey."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd a new option to this key.", "response": "def add_option(self, option):\n        \"\"\"\n        Add a new option to this key.\n\n        Parameters\n        ----------\n        option : Sized or str or int or float\n            A new option to add. This must have the same format with exsiting\n            options.\n\n        Raises\n        ------\n        TypeError\n            If the format of the given ``option`` is different.\n\n        \"\"\"\n        if len(self.options) == 0:\n            self.options.append(option)\n        else:\n            sized_op = isinstance(option, (list, tuple))\n            if self._sized_op != sized_op:\n                raise TypeError(\"Option type is mismatched!\")\n            self.options.append(option)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nremove an option from the log.", "response": "def remove_option(self, option):\n        \"\"\"\n        Remove an option.\n\n        Parameters\n        ----------\n        option : str or int\n            The name (str) or index (int) of the option to remove.\n\n        Raises\n        ------\n        TypeError\n            If the option has a wrong type.\n\n        \"\"\"\n        if len(self.options) > 0:\n            if self._sized_op:\n                if not isinstance(option, str):\n                    raise TypeError(\"``option`` should be a name string!\")\n                for i in range(len(self.options)):\n                    if self.options[i][0] == option:\n                        self.options.pop(i)\n                        break\n            else:\n                if not isinstance(option, int):\n                    raise TypeError(\"``option`` should be an integer index!\")\n                self.options.pop(option)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef has_option(self, option):\n        if len(self.options) == 0:\n            return False\n        for op in self.options:\n            if (self._sized_op and op[0] == option) or (op == option):\n                return True\n        return False", "response": "Returns True if the option is included in this key."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef as_dict(self):\n        d = {\"@module\": self.__class__.__module__,\n             \"@class\": self.__class__.__name__,\n             \"name\": self.name, \"options\": self.options}\n        if len(self.subkeys) > 0:\n            subkeys = []\n            for subkey in self.subkeys:\n                subkeys.append(subkey.as_dict())\n            d.update({\"subkeys\": subkeys})\n        return d", "response": "Returns a JSON serializable dict representation of this object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef from_dict(cls, d):\n        key = d.get(\"name\")\n        options = d.get(\"options\", None)\n        subkey_list = d.get(\"subkeys\", [])\n        if len(subkey_list) > 0:\n            subkeys = list(map(lambda k: AdfKey.from_dict(k), subkey_list))\n        else:\n            subkeys = None\n        return cls(key, options, subkeys)", "response": "Constructs an AdfKey object from the JSON dict d."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef from_string(string):\n        def is_float(s):\n            if '.' in s or 'E' in s or 'e' in s:\n                return True\n            else:\n                return False\n\n        if string.find(\"\\n\") == -1:\n            el = string.split()\n            if len(el) > 1:\n                if string.find(\"=\") != -1:\n                    options = list(map(lambda s: s.split(\"=\"), el[1:]))\n                else:\n                    options = el[1:]\n                for i, op in enumerate(options):\n                    if isinstance(op, list) and is_numeric(op[1]):\n                        op[1] = float(op[1]) if is_float(op[1]) else int(op[1])\n                    elif is_numeric(op):\n                        options[i] = float(op) if is_float(op) else int(op)\n            else:\n                options = None\n            return AdfKey(el[0], options)\n\n        if string.find('subend') != -1:\n            raise ValueError(\"Nested subkeys are not supported!\")\n\n        key = None\n        for line in iterlines(string):\n            if line == \"\":\n                continue\n            el = line.strip().split()\n            if len(el) == 0:\n                continue\n            if el[0].upper() in AdfKey.block_keys:\n                if key is None:\n                    key = AdfKey.from_string(line)\n                else:\n                    return key\n            elif el[0].upper() == 'END':\n                return key\n            elif key is not None:\n                key.add_subkey(AdfKey.from_string(line))\n        else:\n            raise Exception(\"IncompleteKey: 'END' is missing!\")", "response": "Construct an AdfKey object from the string."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _setup_task(self, geo_subkeys):\n        self.geo = AdfKey(\"Geometry\", subkeys=geo_subkeys)\n        if self.operation.lower() == \"energy\":\n            self.geo.add_option(\"SinglePoint\")\n            if self.geo.has_subkey(\"Frequencies\"):\n                self.geo.remove_subkey(\"Frequencies\")\n        elif self.operation.lower() == \"optimize\":\n            self.geo.add_option(\"GeometryOptimization\")\n            if self.geo.has_subkey(\"Frequencies\"):\n                self.geo.remove_subkey(\"Frequencies\")\n        elif self.operation.lower() == \"numerical_frequencies\":\n            self.geo.add_subkey(AdfKey(\"Frequencies\"))\n        else:\n            self.other_directives.append(AdfKey(\"AnalyticalFreq\"))\n            if self.geo.has_subkey(\"Frequencies\"):\n                self.geo.remove_subkey(\"Frequencies\")", "response": "Setup the ADF task for the current ADF."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconstructs an AdfTask object from the given dictionary.", "response": "def from_dict(cls, d):\n        \"\"\"\n        Construct a MSONable AdfTask object from the JSON dict.\n\n        Parameters\n        ----------\n        d : dict\n            A dict of saved attributes.\n\n        Returns\n        -------\n        task : AdfTask\n            An AdfTask object recovered from the JSON dict ``d``.\n\n        \"\"\"\n        def _from_dict(_d):\n            return AdfKey.from_dict(_d) if _d is not None else None\n\n        operation = d.get(\"operation\")\n        title = d.get(\"title\")\n        basis_set = _from_dict(d.get(\"basis_set\"))\n        xc = _from_dict(d.get(\"xc\"))\n        units = _from_dict(d.get(\"units\"))\n        scf = _from_dict(d.get(\"scf\"))\n        others = [AdfKey.from_dict(o) for o in d.get(\"others\", [])]\n        geo = _from_dict(d.get(\"geo\"))\n\n        return cls(operation, basis_set, xc, title, units, geo.subkeys, scf,\n                   others)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nwrite an ADF input file.", "response": "def write_file(self, molecule, inpfile):\n        \"\"\"\n        Write an ADF input file.\n\n        Parameters\n        ----------\n        molecule : Molecule\n            The molecule for this task.\n        inpfile : str\n            The name where the input file will be saved.\n\n        \"\"\"\n\n        mol_blocks = []\n        atom_block = AdfKey(\"Atoms\", options=[\"cartesian\"])\n        for site in molecule:\n            atom_block.add_subkey(AdfKey(str(site.specie), list(site.coords)))\n        mol_blocks.append(atom_block)\n\n        if molecule.charge != 0:\n            netq = molecule.charge\n            ab = molecule.spin_multiplicity - 1\n            charge_block = AdfKey(\"Charge\", [netq, ab])\n            mol_blocks.append(charge_block)\n            if ab != 0:\n                unres_block = AdfKey(\"Unrestricted\")\n                mol_blocks.append(unres_block)\n\n        with open(inpfile, \"w+\") as f:\n            for block in mol_blocks:\n                f.write(str(block) + \"\\n\")\n            f.write(str(self.task) + \"\\n\")\n            f.write(\"END INPUT\")"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _parse(self):\n        workdir = os.path.dirname(self.filename)\n        logfile = os.path.join(workdir, \"logfile\")\n        if not os.path.isfile(logfile):\n            raise IOError(\"The ADF logfile can not be accessed!\")\n\n        self.is_failed = False\n        self.error = None\n        self.final_energy = None\n        self.final_structure = None\n        self.energies = []\n        self.structures = []\n        self.frequencies = []\n        self.normal_modes = None\n        self.freq_type = None\n        self.run_type = None\n        self.is_internal_crash = False\n\n        self._parse_logfile(logfile)\n        if not self.is_failed and self.run_type != \"SinglePoint\":\n            self._parse_adf_output()", "response": "Parse the ADF output file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nparse the formatted logfile and return a list of the TAPE13 objects.", "response": "def _parse_logfile(self, logfile):\n        \"\"\"\n        Parse the formatted logfile.\n        \"\"\"\n\n        cycle_patt = re.compile(r\"Coordinates\\sin\\sGeometry\\sCycle\\s(\\d+)\")\n        coord_patt = re.compile(r\"\\s+([0-9]+)\\.([A-Za-z]+)\"+3*r\"\\s+([-\\.0-9]+)\")\n        energy_patt = re.compile(r\"<.*>\\s<.*>\\s+current\\senergy\\s+([-\\.0-9]+)\\s\"\n                                 \"Hartree\")\n        final_energy_patt = re.compile(\n            r\"<.*>\\s<.*>\\s+Bond\\sEnergy\\s+([-\\.0-9]+)\\sa\\.u\\.\")\n        error_patt = re.compile(r\"<.*>\\s<.*>\\s+ERROR\\sDETECTED:\\s(.*)\")\n        runtype_patt = re.compile(r\"<.*>\\s<.*>\\s+RunType\\s+:\\s(.*)\")\n        end_patt = re.compile(r\"<.*>\\s<.*>\\s+END\")\n        parse_cycle = False\n        sites = []\n        last_cycle = -1\n        parse_final = False\n\n        # Stop parsing the logfile is this job is not terminated successfully.\n        # The last non-empty line of the logfile must match the end pattern.\n        # Otherwise the job has some internal failure. The TAPE13 part of the\n        # ADF manual has a detailed explanantion.\n        with open(logfile, \"r\") as f:\n            for line in reverse_readline(f):\n                if line == \"\":\n                    continue\n                if end_patt.search(line) is None:\n                    self.is_internal_crash = True\n                    self.error = \"Internal crash. TAPE13 is generated!\"\n                    self.is_failed = True\n                    return\n                else:\n                    break\n\n        with open(logfile, \"r\") as f:\n            for line in f:\n                m = error_patt.search(line)\n                if m:\n                    self.is_failed = True\n                    self.error = m.group(1)\n                    break\n\n                if self.run_type is None:\n                    m = runtype_patt.search(line)\n                    if m:\n                        if m.group(1) == 'FREQUENCIES':\n                            self.freq_type = \"Numerical\"\n                            self.run_type = \"NumericalFreq\"\n                        elif m.group(1) == 'GEOMETRY OPTIMIZATION':\n                            self.run_type = \"GeometryOptimization\"\n                        elif m.group(1) == 'CREATE':\n                            self.run_type = None\n                        elif m.group(1) == 'SINGLE POINT':\n                            self.run_type = 'SinglePoint'\n                        else:\n                            raise AdfOutputError(\"Undefined Runtype!\")\n\n                elif self.run_type == 'SinglePoint':\n                    m = coord_patt.search(line)\n                    if m:\n                        sites.append([m.groups()[0],\n                                      list(map(float, m.groups()[2:]))])\n                    else:\n                        m = final_energy_patt.search(line)\n                        if m:\n                            self.final_energy = float(m.group(1))\n                            self.final_structure = self._sites_to_mol(sites)\n\n                elif self.run_type == 'GeometryOptimization':\n                    m = cycle_patt.search(line)\n                    if m:\n                        cycle = int(m.group(1))\n                        if cycle <= 0:\n                            raise AdfOutputError(\"Wrong cycle {}\".format(cycle))\n                        if cycle > last_cycle:\n                            parse_cycle = True\n                            last_cycle = cycle\n                        else:\n                            parse_final = True\n                    elif parse_cycle:\n                        m = coord_patt.search(line)\n                        if m:\n                            sites.append([m.groups()[1],\n                                          list(map(float, m.groups()[2:]))])\n                        else:\n                            m = energy_patt.search(line)\n                            if m:\n                                self.energies.append(float(m.group(1)))\n                                mol = self._sites_to_mol(sites)\n                                self.structures.append(mol)\n                                parse_cycle = False\n                                sites = []\n                    elif parse_final:\n                        m = final_energy_patt.search(line)\n                        if m:\n                            self.final_energy = float(m.group(1))\n\n                elif self.run_type == \"NumericalFreq\":\n                    break\n\n        if not self.is_failed:\n            if self.run_type == \"GeometryOptimization\":\n                if len(self.structures) > 0:\n                    self.final_structure = self.structures[-1]\n                if self.final_energy is None:\n                    raise AdfOutputError(\"The final energy can not be read!\")\n            elif self.run_type == \"SinglePoint\":\n                if self.final_structure is None:\n                    raise AdfOutputError(\"The final structure is missing!\")\n                if self.final_energy is None:\n                    raise AdfOutputError(\"The final energy can not be read!\")"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nparses the ADF output file.", "response": "def _parse_adf_output(self):\n        \"\"\"\n        Parse the standard ADF output file.\n        \"\"\"\n        numerical_freq_patt = re.compile(\n            r\"\\s+\\*\\s+F\\sR\\sE\\sQ\\sU\\sE\\sN\\sC\\sI\\sE\\sS\\s+\\*\")\n        analytic_freq_patt = re.compile(\n            r\"\\s+\\*\\s+F\\sR\\sE\\sQ\\sU\\sE\\sN\\sC\\sY\\s+A\\sN\\sA\\sL\\sY\\sS\\sI\\sS\\s+\\*\")\n        freq_on_patt = re.compile(r\"Vibrations\\sand\\sNormal\\sModes\\s+\\*+.*\\*+\")\n        freq_off_patt = re.compile(r\"List\\sof\\sAll\\sFrequencies:\")\n        mode_patt = re.compile(r\"\\s+(\\d+)\\.([A-Za-z]+)\\s+(.*)\")\n        coord_patt = re.compile(r\"\\s+(\\d+)\\s+([A-Za-z]+)\" + 6 * r\"\\s+([0-9\\.-]+)\")\n        coord_on_patt = re.compile(r\"\\s+\\*\\s+R\\sU\\sN\\s+T\\sY\\sP\\sE\\s:\\sFREQUENCIES\\s+\\*\")\n        parse_freq = False\n        parse_mode = False\n        nnext = 0\n        nstrike = 0\n        sites = []\n\n        self.frequencies = []\n        self.normal_modes = []\n\n        if self.final_structure is None:\n            find_structure = True\n            parse_coord = False\n            natoms = 0\n        else:\n            find_structure = False\n            parse_coord = False\n            natoms = self.final_structure.num_sites\n\n        with open(self.filename, \"r\") as f:\n            for line in f:\n                if self.run_type == \"NumericalFreq\" and find_structure:\n                    if not parse_coord:\n                        m = coord_on_patt.search(line)\n                        if m:\n                            parse_coord = True\n                    else:\n                        m = coord_patt.search(line)\n                        if m:\n                            sites.append(\n                                [m.group(2), list(map(float, m.groups()[2:5]))])\n                            nstrike += 1\n                        elif nstrike > 0:\n                            find_structure = False\n                            self.final_structure = self._sites_to_mol(sites)\n                            natoms = self.final_structure.num_sites\n\n                elif self.freq_type is None:\n                    if numerical_freq_patt.search(line):\n                        self.freq_type = \"Numerical\"\n                    elif analytic_freq_patt.search(line):\n                        self.freq_type = \"Analytical\"\n                        self.run_type = \"AnalyticalFreq\"\n\n                elif freq_on_patt.search(line):\n                    parse_freq = True\n\n                elif parse_freq:\n                    if freq_off_patt.search(line):\n                        break\n                    el = line.strip().split()\n                    if 1 <= len(el) <= 3 and line.find(\".\") != -1:\n                        nnext = len(el)\n                        parse_mode = True\n                        parse_freq = False\n                        self.frequencies.extend(map(float, el))\n                        for i in range(nnext):\n                            self.normal_modes.append([])\n\n                elif parse_mode:\n                    m = mode_patt.search(line)\n                    if m:\n                        v = list(chunks(map(float, m.group(3).split()), 3))\n                        if len(v) != nnext:\n                            raise AdfOutputError(\"Odd Error!\")\n                        for i, k in enumerate(range(-nnext, 0, 1)):\n                            self.normal_modes[k].extend(v[i])\n                        if int(m.group(1)) == natoms:\n                            parse_freq = True\n                            parse_mode = False\n        if isinstance(self.final_structure, list):\n            self.final_structure = self._sites_to_mol(self.final_structure)\n\n        if self.freq_type is not None:\n            if len(self.frequencies) != len(self.normal_modes):\n                raise AdfOutputError(\"The number of normal modes is wrong!\")\n            if len(self.normal_modes[0]) != natoms * 3:\n                raise AdfOutputError(\"The dimensions of the modes are wrong!\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_reconstructed_band_structure(list_bs, efermi=None):\n    if efermi is None:\n        efermi = sum([b.efermi for b in list_bs]) / len(list_bs)\n\n    kpoints = []\n    labels_dict = {}\n    rec_lattice = list_bs[0].lattice_rec\n    nb_bands = min([list_bs[i].nb_bands for i in range(len(list_bs))])\n\n    kpoints = np.concatenate([[k.frac_coords for k in bs.kpoints]\n                              for bs in list_bs])\n    dicts = [bs.labels_dict for bs in list_bs]\n    labels_dict = {k: v.frac_coords for d in dicts for k, v in d.items()}\n\n    eigenvals = {}\n    eigenvals[Spin.up] = np.concatenate([bs.bands[Spin.up][:nb_bands]\n                                         for bs in list_bs], axis=1)\n\n    if list_bs[0].is_spin_polarized:\n        eigenvals[Spin.down] = np.concatenate([bs.bands[Spin.down][:nb_bands]\n                                               for bs in list_bs], axis=1)\n\n    projections = {}\n    if len(list_bs[0].projections) != 0:\n        projs = [bs.projections[Spin.up][:nb_bands] for bs in list_bs]\n        projections[Spin.up] = np.concatenate(projs, axis=1)\n\n        if list_bs[0].is_spin_polarized:\n            projs = [bs.projections[Spin.down][:nb_bands] for bs in list_bs]\n            projections[Spin.down] = np.concatenate(projs, axis=1)\n\n    if isinstance(list_bs[0], BandStructureSymmLine):\n        return BandStructureSymmLine(kpoints, eigenvals, rec_lattice,\n                                     efermi, labels_dict,\n                                     structure=list_bs[0].structure,\n                                     projections=projections)\n    else:\n        return BandStructure(kpoints, eigenvals, rec_lattice, efermi,\n                             labels_dict, structure=list_bs[0].structure,\n                             projections=projections)", "response": "This method takes a list of BandStructureSymmLine objects and reconstructs the corresponding BandStructureSymmLine object from all of them."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_projection_on_elements(self):\n        result = {}\n        structure = self.structure\n        for spin, v in self.projections.items():\n            result[spin] = [[collections.defaultdict(float)\n                             for i in range(len(self.kpoints))]\n                            for j in range(self.nb_bands)]\n            for i, j, k in itertools.product(range(self.nb_bands),\n                                             range(len(self.kpoints)),\n                                             range(structure.num_sites)):\n                result[spin][i][j][str(structure[k].specie)] += np.sum(\n                    v[i, j, :, k])\n        return result", "response": "Method returning a dictionary of projections on elements."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_projections_on_elements_and_orbitals(self, el_orb_spec):\n        result = {}\n        structure = self.structure\n        el_orb_spec = {get_el_sp(el): orbs for el, orbs in el_orb_spec.items()}\n        for spin, v in self.projections.items():\n            result[spin] = [[{str(e): collections.defaultdict(float)\n                              for e in el_orb_spec}\n                             for i in range(len(self.kpoints))]\n                            for j in range(self.nb_bands)]\n\n            for i, j, k in itertools.product(\n                    range(self.nb_bands), range(len(self.kpoints)),\n                    range(structure.num_sites)):\n                sp = structure[k].specie\n                for orb_i in range(len(v[i][j])):\n                    o = Orbital(orb_i).name[0]\n                    if sp in el_orb_spec:\n                        if o in el_orb_spec[sp]:\n                            result[spin][i][j][str(sp)][o] += v[i][j][\n                                orb_i][k]\n        return result", "response": "Method returns a dictionary of projections on elements and orbitals for which we want to have projections on."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef is_metal(self, efermi_tol=1e-4):\n        for spin, values in self.bands.items():\n            for i in range(self.nb_bands):\n                if np.any(values[i, :] - self.efermi < -efermi_tol) and \\\n                        np.any(values[i, :] - self.efermi > efermi_tol):\n                    return True\n        return False", "response": "Check if the band structure indicates a metal"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the data about the VBM.", "response": "def get_vbm(self):\n        \"\"\"\n        Returns data about the VBM.\n\n        Returns:\n            dict as {\"band_index\",\"kpoint_index\",\"kpoint\",\"energy\"}\n            - \"band_index\": A dict with spin keys pointing to a list of the\n            indices of the band containing the VBM (please note that you\n            can have several bands sharing the VBM) {Spin.up:[],\n            Spin.down:[]}\n            - \"kpoint_index\": The list of indices in self.kpoints for the\n            kpoint vbm. Please note that there can be several\n            kpoint_indices relating to the same kpoint (e.g., Gamma can\n            occur at different spots in the band structure line plot)\n            - \"kpoint\": The kpoint (as a kpoint object)\n            - \"energy\": The energy of the VBM\n            - \"projections\": The projections along sites and orbitals of the\n            VBM if any projection data is available (else it is an empty\n            dictionnary). The format is similar to the projections field in\n            BandStructure: {spin:{'Orbital': [proj]}} where the array\n            [proj] is ordered according to the sites in structure\n    \"\"\"\n        if self.is_metal():\n            return {\"band_index\": [], \"kpoint_index\": [],\n                    \"kpoint\": [], \"energy\": None, \"projections\": {}}\n        max_tmp = -float(\"inf\")\n        index = None\n        kpointvbm = None\n        for spin, v in self.bands.items():\n            for i, j in zip(*np.where(v < self.efermi)):\n                if v[i, j] > max_tmp:\n                    max_tmp = float(v[i, j])\n                    index = j\n                    kpointvbm = self.kpoints[j]\n\n        list_ind_kpts = []\n        if kpointvbm.label is not None:\n            for i in range(len(self.kpoints)):\n                if self.kpoints[i].label == kpointvbm.label:\n                    list_ind_kpts.append(i)\n        else:\n            list_ind_kpts.append(index)\n        # get all other bands sharing the vbm\n        list_ind_band = collections.defaultdict(list)\n        for spin in self.bands:\n            for i in range(self.nb_bands):\n                if math.fabs(self.bands[spin][i][index] - max_tmp) < 0.001:\n                    list_ind_band[spin].append(i)\n        proj = {}\n        for spin, v in self.projections.items():\n            if len(list_ind_band[spin]) == 0:\n                continue\n            proj[spin] = v[list_ind_band[spin][0]][list_ind_kpts[0]]\n        return {'band_index': list_ind_band,\n                'kpoint_index': list_ind_kpts,\n                'kpoint': kpointvbm, 'energy': max_tmp,\n                'projections': proj}"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_cbm(self):\n        if self.is_metal():\n            return {\"band_index\": [], \"kpoint_index\": [],\n                    \"kpoint\": [], \"energy\": None, \"projections\": {}}\n        max_tmp = float(\"inf\")\n\n        index = None\n        kpointcbm = None\n        for spin, v in self.bands.items():\n            for i, j in zip(*np.where(v >= self.efermi)):\n                if v[i, j] < max_tmp:\n                    max_tmp = float(v[i, j])\n                    index = j\n                    kpointcbm = self.kpoints[j]\n\n        list_index_kpoints = []\n        if kpointcbm.label is not None:\n            for i in range(len(self.kpoints)):\n                if self.kpoints[i].label == kpointcbm.label:\n                    list_index_kpoints.append(i)\n        else:\n            list_index_kpoints.append(index)\n\n        # get all other bands sharing the cbm\n        list_index_band = collections.defaultdict(list)\n        for spin in self.bands:\n            for i in range(self.nb_bands):\n                if math.fabs(self.bands[spin][i][index] - max_tmp) < 0.001:\n                    list_index_band[spin].append(i)\n        proj = {}\n        for spin, v in self.projections.items():\n            if len(list_index_band[spin]) == 0:\n                continue\n            proj[spin] = v[list_index_band[spin][0]][list_index_kpoints[0]]\n\n        return {'band_index': list_index_band,\n                'kpoint_index': list_index_kpoints,\n                'kpoint': kpointcbm, 'energy': max_tmp,\n                'projections': proj}", "response": "Returns the data about the CBM."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the band gap data.", "response": "def get_band_gap(self):\n        \"\"\"\n        Returns band gap data.\n\n        Returns:\n            A dict {\"energy\",\"direct\",\"transition\"}:\n            \"energy\": band gap energy\n            \"direct\": A boolean telling if the gap is direct or not\n            \"transition\": kpoint labels of the transition (e.g., \"\\\\Gamma-X\")\n        \"\"\"\n        if self.is_metal():\n            return {\"energy\": 0.0, \"direct\": False, \"transition\": None}\n        cbm = self.get_cbm()\n        vbm = self.get_vbm()\n        result = dict(direct=False, energy=0.0, transition=None)\n\n        result[\"energy\"] = cbm[\"energy\"] - vbm[\"energy\"]\n\n        if (cbm[\"kpoint\"].label is not None and cbm[\"kpoint\"].label == vbm[\n            \"kpoint\"].label) \\\n                or np.linalg.norm(cbm[\"kpoint\"].cart_coords\n                                  - vbm[\"kpoint\"].cart_coords) < 0.01:\n            result[\"direct\"] = True\n\n        result[\"transition\"] = \"-\".join(\n            [str(c.label) if c.label is not None else\n             str(\"(\") + \",\".join([\"{0:.3f}\".format(c.frac_coords[i])\n                                  for i in range(3)])\n             + str(\")\") for c in [vbm[\"kpoint\"], cbm[\"kpoint\"]]])\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_direct_band_gap_dict(self):\n        if self.is_metal():\n            raise ValueError(\"get_direct_band_gap_dict should\"\n                             \"only be used with non-metals\")\n        direct_gap_dict = {}\n        for spin, v in self.bands.items():\n            above = v[np.all(v > self.efermi, axis=1)]\n            min_above = np.min(above, axis=0)\n            below = v[np.all(v < self.efermi, axis=1)]\n            max_below = np.max(below, axis=0)\n            diff = min_above - max_below\n            kpoint_index = np.argmin(diff)\n            band_indices = [np.argmax(below[:, kpoint_index]),\n                            np.argmin(above[:, kpoint_index]) + len(below)]\n            direct_gap_dict[spin] = {\"value\": diff[kpoint_index],\n                                     \"kpoint_index\": kpoint_index,\n                                     \"band_indices\": band_indices}\n        return direct_gap_dict", "response": "Returns a dictionary of information about the direct band gap containing the k - point indices and the k - point index."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the value of the direct band gap.", "response": "def get_direct_band_gap(self):\n        \"\"\"\n        Returns the direct band gap.\n\n        Returns:\n             the value of the direct band gap\n        \"\"\"\n        if self.is_metal():\n            return 0.0\n        dg = self.get_direct_band_gap_dict()\n        return min(v['value'] for v in dg.values())"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a list of unique symmetrically equivalent k - points.", "response": "def get_sym_eq_kpoints(self, kpoint, cartesian=False, tol=1e-2):\n        \"\"\"\n        Returns a list of unique symmetrically equivalent k-points.\n\n        Args:\n            kpoint (1x3 array): coordinate of the k-point\n            cartesian (bool): kpoint is in cartesian or fractional coordinates\n            tol (float): tolerance below which coordinates are considered equal\n\n        Returns:\n            ([1x3 array] or None): if structure is not available returns None\n        \"\"\"\n        if not self.structure:\n            return None\n        sg = SpacegroupAnalyzer(self.structure)\n        symmops = sg.get_point_group_operations(cartesian=cartesian)\n        points = np.dot(kpoint, [m.rotation_matrix for m in symmops])\n        rm_list = []\n        # identify and remove duplicates from the list of equivalent k-points:\n        for i in range(len(points) - 1):\n            for j in range(i + 1, len(points)):\n                if np.allclose(pbc_diff(points[i], points[j]), [0, 0, 0], tol):\n                    rm_list.append(i)\n                    break\n        return np.delete(points, rm_list, axis=0)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the number of degeneracy of a given k - point in the structure", "response": "def get_kpoint_degeneracy(self, kpoint, cartesian=False, tol=1e-2):\n        \"\"\"\n        Returns degeneracy of a given k-point based on structure symmetry\n        Args:\n            kpoint (1x3 array): coordinate of the k-point\n            cartesian (bool): kpoint is in cartesian or fractional coordinates\n            tol (float): tolerance below which coordinates are considered equal\n\n        Returns:\n            (int or None): degeneracy or None if structure is not available\n        \"\"\"\n        all_kpts = self.get_sym_eq_kpoints(kpoint, cartesian, tol=tol)\n        if all_kpts is not None:\n            return len(all_kpts)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates a new object from a dictionary.", "response": "def from_dict(cls, d):\n        \"\"\"\n        Create from dict.\n\n        Args:\n            A dict with all data for a band structure object.\n\n        Returns:\n            A BandStructure object\n        \"\"\"\n        labels_dict = d['labels_dict']\n        projections = {}\n        structure = None\n        if isinstance(list(d['bands'].values())[0], dict):\n            eigenvals = {Spin(int(k)): np.array(d['bands'][k]['data'])\n                         for k in d['bands']}\n        else:\n            eigenvals = {Spin(int(k)): d['bands'][k] for k in d['bands']}\n        if 'structure' in d:\n            structure = Structure.from_dict(d['structure'])\n        if d.get('projections'):\n            projections = {Spin(int(spin)): np.array(v)\n                           for spin, v in d[\"projections\"].items()}\n\n        return BandStructure(\n            d['kpoints'], eigenvals,\n            Lattice(d['lattice_rec']['matrix']), d['efermi'],\n            labels_dict, structure=structure, projections=projections)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the list of kpoint indices equivalent to the given kpoint index.", "response": "def get_equivalent_kpoints(self, index):\n        \"\"\"\n        Returns the list of kpoint indices equivalent (meaning they are the\n        same frac coords) to the given one.\n\n        Args:\n            index: the kpoint index\n\n        Returns:\n            a list of equivalent indices\n\n        TODO: now it uses the label we might want to use coordinates instead\n        (in case there was a mislabel)\n        \"\"\"\n        # if the kpoint has no label it can\"t have a repetition along the band\n        # structure line object\n\n        if self.kpoints[index].label is None:\n            return [index]\n\n        list_index_kpoints = []\n        for i in range(len(self.kpoints)):\n            if self.kpoints[i].label == self.kpoints[index].label:\n                list_index_kpoints.append(i)\n\n        return list_index_kpoints"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a BandStructureSymmLine object from a dict with all data for a band structure symm line.", "response": "def from_dict(cls, d):\n        \"\"\"\n        Args:\n            d (dict): A dict with all data for a band structure symm line\n                object.\n\n        Returns:\n            A BandStructureSymmLine object\n        \"\"\"\n        try:\n            # Strip the label to recover initial string (see trick used in as_dict to handle $ chars)\n            labels_dict = {k.strip(): v for k, v in d['labels_dict'].items()}\n            projections = {}\n            structure = None\n            if d.get('projections'):\n                if isinstance(d[\"projections\"]['1'][0][0], dict):\n                    raise ValueError(\"Old band structure dict format detected!\")\n                structure = Structure.from_dict(d['structure'])\n                projections = {Spin(int(spin)): np.array(v)\n                               for spin, v in d[\"projections\"].items()}\n\n            return BandStructureSymmLine(\n                d['kpoints'], {Spin(int(k)): d['bands'][k]\n                               for k in d['bands']},\n                Lattice(d['lattice_rec']['matrix']), d['efermi'],\n                labels_dict, structure=structure, projections=projections)\n        except:\n            warnings.warn(\"Trying from_dict failed. Now we are trying the old \"\n                          \"format. Please convert your BS dicts to the new \"\n                          \"format. The old format will be retired in pymatgen \"\n                          \"5.0.\")\n            return BandStructureSymmLine.from_old_dict(d)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef from_old_dict(cls, d):\n        # Strip the label to recover initial string (see trick used in as_dict to handle $ chars)\n        labels_dict = {k.strip(): v for k, v in d['labels_dict'].items()}\n        projections = {}\n        structure = None\n        if 'projections' in d and len(d['projections']) != 0:\n            structure = Structure.from_dict(d['structure'])\n            projections = {}\n            for spin in d['projections']:\n                dd = []\n                for i in range(len(d['projections'][spin])):\n                    ddd = []\n                    for j in range(len(d['projections'][spin][i])):\n                        dddd = []\n                        for k in range(len(d['projections'][spin][i][j])):\n                            ddddd = []\n                            orb = Orbital(k).name\n                            for l in range(len(d['projections'][spin][i][j][\n                                                   orb])):\n                                ddddd.append(d['projections'][spin][i][j][\n                                                 orb][l])\n                            dddd.append(np.array(ddddd))\n                        ddd.append(np.array(dddd))\n                    dd.append(np.array(ddd))\n                projections[Spin(int(spin))] = np.array(dd)\n\n        return BandStructureSymmLine(\n            d['kpoints'], {Spin(int(k)): d['bands'][k]\n                           for k in d['bands']},\n            Lattice(d['lattice_rec']['matrix']), d['efermi'],\n            labels_dict, structure=structure, projections=projections)", "response": "Returns a BandStructureSymmLine object from a dict with all data for a band structure symm line."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef apply_scissor(self, new_band_gap):\n        if self.is_metal():\n            # moves then the highest index band crossing the fermi level\n            # find this band...\n            max_index = -1000\n            # spin_index = None\n            for i in range(self.nb_bands):\n                below = False\n                above = False\n                for j in range(len(self.kpoints)):\n                    if self.bands[Spin.up][i][j] < self.efermi:\n                        below = True\n                    if self.bands[Spin.up][i][j] > self.efermi:\n                        above = True\n                if above and below:\n                    if i > max_index:\n                        max_index = i\n                        # spin_index = Spin.up\n                if self.is_spin_polarized:\n                    below = False\n                    above = False\n                    for j in range(len(self.kpoints)):\n                        if self.bands[Spin.down][i][j] < self.efermi:\n                            below = True\n                        if self.bands[Spin.down][i][j] > self.efermi:\n                            above = True\n                    if above and below:\n                        if i > max_index:\n                            max_index = i\n                            # spin_index = Spin.down\n            old_dict = self.as_dict()\n            shift = new_band_gap\n            for spin in old_dict['bands']:\n                for k in range(len(old_dict['bands'][spin])):\n                    for v in range(len(old_dict['bands'][spin][k])):\n                        if k >= max_index:\n                            old_dict['bands'][spin][k][v] = \\\n                                old_dict['bands'][spin][k][v] + shift\n        else:\n\n            shift = new_band_gap - self.get_band_gap()['energy']\n            old_dict = self.as_dict()\n            for spin in old_dict['bands']:\n                for k in range(len(old_dict['bands'][spin])):\n                    for v in range(len(old_dict['bands'][spin][k])):\n                        if old_dict['bands'][spin][k][v] >= \\\n                                old_dict['cbm']['energy']:\n                            old_dict['bands'][spin][k][v] = \\\n                                old_dict['bands'][spin][k][v] + shift\n            old_dict['efermi'] = old_dict['efermi'] + shift\n\n            return LobsterBandStructureSymmLine.from_dict(old_dict)", "response": "This function applies a scissor operator to the band structure."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a new object from a dictionary with all data for a band structure symm line.", "response": "def from_old_dict(cls, d):\n        \"\"\"\n        Args:\n            d (dict): A dict with all data for a band structure symm line\n                object.\n        Returns:\n            A BandStructureSymmLine object\n        \"\"\"\n        # Strip the label to recover initial string (see trick used in as_dict to handle $ chars)\n        labels_dict = {k.strip(): v for k, v in d['labels_dict'].items()}\n        projections = {}\n        structure = None\n        if 'projections' in d and len(d['projections']) != 0:\n            structure = Structure.from_dict(d['structure'])\n            projections = {}\n            for spin in d['projections']:\n                dd = []\n                for i in range(len(d['projections'][spin])):\n                    ddd = []\n                    for j in range(len(d['projections'][spin][i])):\n                        dddd = []\n                        ddd.append(d['projections'][spin][i][j])\n                    dd.append(np.array(ddd))\n                projections[Spin(int(spin))] = np.array(dd)\n\n        return LobsterBandStructureSymmLine(\n            d['kpoints'], {Spin(int(k)): d['bands'][k]\n                           for k in d['bands']},\n            Lattice(d['lattice_rec']['matrix']), d['efermi'],\n            labels_dict, structure=structure, projections=projections)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _initial_guess(self):\n        a, b, c = np.polyfit(self.volumes, self.energies, 2)\n        self.eos_params = [a, b, c]\n\n        v0 = -b/(2*a)\n        e0 = a*(v0**2) + b*v0 + c\n        b0 = 2 * a * v0\n        b1 = 4  # b1 is usually a small number like 4\n\n        vmin, vmax = min(self.volumes), max(self.volumes)\n\n        if not vmin < v0 and v0 < vmax:\n            raise EOSError('The minimum volume of a fitted parabola is '\n                           'not in the input volumes\\n.')\n\n        return e0, b0, b1, v0", "response": "Get an initial guess for the parameters."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfits the least square algorithm to obtain the current state of the object.", "response": "def fit(self):\n        \"\"\"\n        Do the fitting. Does least square fitting. If you want to use custom\n        fitting, must override this.\n        \"\"\"\n        # the objective function that will be minimized in the least square\n        # fitting\n        objective_func = lambda pars, x, y: y - self._func(x, pars)\n        self._params = self._initial_guess()\n        self.eos_params, ierr = leastsq(\n            objective_func, self._params, args=(self.volumes, self.energies))\n        # e0, b0, b1, v0\n        self._params = self.eos_params\n        if ierr not in [1, 2, 3, 4]:\n            raise EOSError(\"Optimal parameters not found\")"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef results(self):\n        return dict(e0=self.e0, b0=self.b0, b1=self.b1, v0=self.v0)", "response": "Returns a summary dict."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nplots the equation of state.", "response": "def plot(self, width=8, height=None, plt=None, dpi=None, **kwargs):\n        \"\"\"\n        Plot the equation of state.\n\n        Args:\n            width (float): Width of plot in inches. Defaults to 8in.\n            height (float): Height of plot in inches. Defaults to width *\n                golden ratio.\n            plt (matplotlib.pyplot): If plt is supplied, changes will be made\n                to an existing plot. Otherwise, a new plot will be created.\n            dpi:\n            kwargs (dict): additional args fed to pyplot.plot.\n                supported keys: style, color, text, label\n\n        Returns:\n            Matplotlib plot object.\n        \"\"\"\n        plt = pretty_plot(width=width, height=height, plt=plt, dpi=dpi)\n\n        color = kwargs.get(\"color\", \"r\")\n        label = kwargs.get(\"label\", \"{} fit\".format(self.__class__.__name__))\n        lines = [\"Equation of State: %s\" % self.__class__.__name__,\n                 \"Minimum energy = %1.2f eV\" % self.e0,\n                 \"Minimum or reference volume = %1.2f Ang^3\" % self.v0,\n                 \"Bulk modulus = %1.2f eV/Ang^3 = %1.2f GPa\" %\n                 (self.b0, self.b0_GPa),\n                 \"Derivative of bulk modulus wrt pressure = %1.2f\" % self.b1]\n        text = \"\\n\".join(lines)\n        text = kwargs.get(\"text\", text)\n\n        # Plot input data.\n        plt.plot(self.volumes, self.energies, linestyle=\"None\", marker=\"o\",\n                 color=color)\n\n        # Plot eos fit.\n        vmin, vmax = min(self.volumes), max(self.volumes)\n        vmin, vmax = (vmin - 0.01 * abs(vmin), vmax + 0.01 * abs(vmax))\n        vfit = np.linspace(vmin, vmax, 100)\n\n        plt.plot(vfit, self.func(vfit), linestyle=\"dashed\", color=color,\n                 label=label)\n\n        plt.grid(True)\n        plt.xlabel(\"Volume $\\\\AA^3$\")\n        plt.ylabel(\"Energy (eV)\")\n        plt.legend(loc=\"best\", shadow=True)\n        # Add text with fit parameters.\n        plt.text(0.4, 0.5, text, transform=plt.gca().transAxes)\n\n        return plt"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef plot_ax(self, ax=None, fontsize=12, **kwargs):\n        ax, fig, plt = get_ax_fig_plt(ax=ax)\n\n        color = kwargs.get(\"color\", \"r\")\n        label = kwargs.get(\"label\", \"{} fit\".format(self.__class__.__name__))\n        lines = [\"Equation of State: %s\" % self.__class__.__name__,\n                 \"Minimum energy = %1.2f eV\" % self.e0,\n                 \"Minimum or reference volume = %1.2f Ang^3\" % self.v0,\n                 \"Bulk modulus = %1.2f eV/Ang^3 = %1.2f GPa\" %\n                 (self.b0, self.b0_GPa),\n                 \"Derivative of bulk modulus wrt pressure = %1.2f\" % self.b1]\n        text = \"\\n\".join(lines)\n        text = kwargs.get(\"text\", text)\n\n        # Plot input data.\n        ax.plot(self.volumes, self.energies, linestyle=\"None\", marker=\"o\", color=color)\n\n        # Plot eos fit.\n        vmin, vmax = min(self.volumes), max(self.volumes)\n        vmin, vmax = (vmin - 0.01 * abs(vmin), vmax + 0.01 * abs(vmax))\n        vfit = np.linspace(vmin, vmax, 100)\n\n        ax.plot(vfit, self.func(vfit), linestyle=\"dashed\", color=color, label=label)\n\n        ax.grid(True)\n        ax.set_xlabel(\"Volume $\\\\AA^3$\")\n        ax.set_ylabel(\"Energy (eV)\")\n        ax.legend(loc=\"best\", shadow=True)\n        # Add text with fit parameters.\n        ax.text(0.5, 0.5, text, fontsize=fontsize, horizontalalignment='center',\n            verticalalignment='center', transform=ax.transAxes)\n\n        return fig", "response": "Plots the equation of state on axis ax."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncompute the log - level of the log - level entry for the Intermetallic compounds.", "response": "def _func(self, volume, params):\n        \"\"\"\n        From Intermetallic compounds: Principles and Practice, Vol. I:\n        Principles Chapter 9 pages 195-210 by M. Mehl. B. Klein,\n        D. Papaconstantopoulos.\n        case where n=0\n        \"\"\"\n        e0, b0, b1, v0 = tuple(params)\n        return (e0\n                + 9.0 / 8.0 * b0 * v0 * ((v0 / volume)**(2.0/3.0) - 1.0) ** 2\n                + 9.0 / 16.0 * b0 * v0 * (b1 - 4.) *\n                ((v0 / volume)**(2.0/3.0) - 1.0) ** 3)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _func(self, volume, params):\n        e0, b0, b1, v0 = tuple(params)\n        eta = (v0 / volume) ** (1. / 3.)\n        return (e0 +\n                9. * b0 * v0 / 16. * (eta ** 2 - 1)**2 *\n                (6 + b1 * (eta ** 2 - 1.) - 4. * eta ** 2))", "response": "Compute the BirchMurnaghan equation from PRB 70 224107"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _func(self, volume, params):\n        e0, b0, b1, v0 = tuple(params)\n        eta = (volume / v0) ** (1. / 3.)\n        squiggle = -3.*np.log(eta)\n        return e0 + b0 * v0 * squiggle ** 2 / 6. * (3. + squiggle * (b1 - 2))", "response": "Compute the log - likelihood of a set of log - likelihoods."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncomputes the parameter e0 b0 b1 and v0 and set to the _params attribute.", "response": "def _set_params(self):\n        \"\"\"\n        Use the fit polynomial to compute the parameter e0, b0, b1 and v0\n        and set to the _params attribute.\n        \"\"\"\n        fit_poly = np.poly1d(self.eos_params)\n        # the volume at min energy, used as the intial guess for the\n        # optimization wrt volume.\n        v_e_min = self.volumes[np.argmin(self.energies)]\n        # evaluate e0, v0, b0 and b1\n        min_wrt_v = minimize(fit_poly, v_e_min)\n        e0, v0 = min_wrt_v.fun, min_wrt_v.x[0]\n        pderiv2 = np.polyder(fit_poly, 2)\n        pderiv3 = np.polyder(fit_poly, 3)\n        b0 = v0 * np.poly1d(pderiv2)(v0)\n        db0dv = np.poly1d(pderiv2)(v0) + v0 * np.poly1d(pderiv3)(v0)\n        # db/dp\n        b1 = - v0 * db0dv / b0\n        self._params = [e0, b0, b1, v0]"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef fit(self, order=3):\n        x = self.volumes**(-2./3.)\n        self.eos_params = np.polyfit(x, self.energies, order)\n        self._set_params()", "response": "Fit the eos parameters to the energy of the local eos."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the parameters of the EOS system.", "response": "def _set_params(self):\n        \"\"\"\n        Overriden to account for the fact the fit with volume**(2/3) instead\n        of volume.\n        \"\"\"\n        deriv0 = np.poly1d(self.eos_params)\n        deriv1 = np.polyder(deriv0, 1)\n        deriv2 = np.polyder(deriv1, 1)\n        deriv3 = np.polyder(deriv2, 1)\n\n        for x in np.roots(deriv1):\n            if x > 0 and deriv2(x) > 0:\n                v0 = x**(-3./2.)\n                break\n        else:\n            raise EOSError(\"No minimum could be found\")\n\n        derivV2 = 4./9. * x**5. * deriv2(x)\n        derivV3 = (-20./9. * x**(13./2.) * deriv2(x) - 8./27. *\n                   x**(15./2.) * deriv3(x))\n        b0 = derivV2 / x**(3./2.)\n        b1 = -1 - x**(-3./2.) * derivV3 / derivV2\n\n        # e0, b0, b1, v0\n        self._params = [deriv0(v0**(-2./3.)), b0, b1, v0]"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nfitting the input data to the numerical eos model.", "response": "def fit(self, min_ndata_factor=3, max_poly_order_factor=5, min_poly_order=2):\n        \"\"\"\n        Fit the input data to the 'numerical eos', the equation of state employed\n        in the quasiharmonic Debye model described in the paper:\n        10.1103/PhysRevB.90.174107.\n\n        credits: Cormac Toher\n\n        Args:\n            min_ndata_factor (int): parameter that controls the minimum number\n                of data points that will be used for fitting.\n                minimum number of data points =\n                    total data points-2*min_ndata_factor\n            max_poly_order_factor (int): parameter that limits the max order\n                of the polynomial used for fitting.\n                max_poly_order = number of data points used for fitting -\n                                 max_poly_order_factor\n            min_poly_order (int): minimum order of the polynomial to be\n                considered for fitting.\n        \"\"\"\n        warnings.simplefilter('ignore', np.RankWarning)\n\n        get_rms = lambda x, y: np.sqrt(np.sum((np.array(x)-np.array(y))**2)/len(x))\n\n        # list of (energy, volume) tuples\n        e_v = [(i, j) for i, j in zip(self.energies, self.volumes)]\n        ndata = len(e_v)\n        # minimum number of data points used for fitting\n        ndata_min = max(ndata - 2 * min_ndata_factor, min_poly_order + 1)\n        rms_min = np.inf\n        # number of data points available for fit in each iteration\n        ndata_fit = ndata\n        # store the fit polynomial coefficients and the rms in a dict,\n        # where the key=(polynomial order, number of data points used for\n        # fitting)\n        all_coeffs = {}\n\n        # sort by energy\n        e_v = sorted(e_v, key=lambda x: x[0])\n        # minimum energy tuple\n        e_min = e_v[0]\n        # sort by volume\n        e_v = sorted(e_v, key=lambda x: x[1])\n        # index of minimum energy tuple in the volume sorted list\n        emin_idx = e_v.index(e_min)\n        # the volume lower than the volume corresponding to minimum energy\n        v_before = e_v[emin_idx - 1][1]\n        # the volume higher than the volume corresponding to minimum energy\n        v_after = e_v[emin_idx + 1][1]\n        e_v_work = deepcopy(e_v)\n\n        # loop over the data points.\n        while (ndata_fit >= ndata_min) and (e_min in e_v_work):\n            max_poly_order = ndata_fit - max_poly_order_factor\n            e = [ei[0] for ei in e_v_work]\n            v = [ei[1] for ei in e_v_work]\n            # loop over polynomial order\n            for i in range(min_poly_order, max_poly_order + 1):\n                coeffs = np.polyfit(v, e, i)\n                pder = np.polyder(coeffs)\n                a = np.poly1d(pder)(v_before)\n                b = np.poly1d(pder)(v_after)\n                if a * b < 0:\n                    rms = get_rms(e, np.poly1d(coeffs)(v))\n                    rms_min = min(rms_min, rms * i / ndata_fit)\n                    all_coeffs[(i, ndata_fit)] = [coeffs.tolist(), rms]\n                    # store the fit coefficients small to large,\n                    # i.e a0, a1, .. an\n                    all_coeffs[(i, ndata_fit)][0].reverse()\n            # remove 1 data point from each end.\n            e_v_work.pop()\n            e_v_work.pop(0)\n            ndata_fit = len(e_v_work)\n\n        logger.info(\"total number of polynomials: {}\".format(len(all_coeffs)))\n\n        norm = 0.\n        fit_poly_order = ndata\n        # weight average polynomial coefficients.\n        weighted_avg_coeffs = np.zeros((fit_poly_order,))\n\n        # combine all the filtered polynomial candidates to get the final fit.\n        for k, v in all_coeffs.items():\n            # weighted rms = rms * polynomial order / rms_min / ndata_fit\n            weighted_rms = v[1] * k[0] / rms_min / k[1]\n            weight = np.exp(-(weighted_rms ** 2))\n            norm += weight\n            coeffs = np.array(v[0])\n            # pad the coefficient array with zeros\n            coeffs = np.lib.pad(coeffs,\n                                (0, max(fit_poly_order-len(coeffs), 0)),\n                                'constant')\n            weighted_avg_coeffs += weight * coeffs\n\n        # normalization\n        weighted_avg_coeffs /= norm\n        weighted_avg_coeffs = weighted_avg_coeffs.tolist()\n        # large to small(an, an-1, ..., a1, a0) as expected by np.poly1d\n        weighted_avg_coeffs.reverse()\n\n        self.eos_params = weighted_avg_coeffs\n        self._set_params()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef fit(self, volumes, energies):\n        eos_fit = self.model(np.array(volumes), np.array(energies))\n        eos_fit.fit()\n        return eos_fit", "response": "Fit volumes as function of energies."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef dilute_solution_model(structure, e0, vac_defs, antisite_defs, T, trial_chem_pot=None, generate='plot'):\n\n    if not check_input(vac_defs):\n        raise ValueError('Vacancy energy is not defined')\n    if not check_input(antisite_defs):\n        raise ValueError('Antisite energy is not defined')\n\n    formation_energies = {}\n    formation_energies['vacancies'] = copy.deepcopy(vac_defs)\n    formation_energies['antisites'] = copy.deepcopy(antisite_defs)\n    for vac in formation_energies['vacancies']:\n        del vac['energy']\n    for asite in formation_energies['antisites']:\n        del asite['energy']\n    # Setup the system\n    site_species = [vac_def['site_specie'] for vac_def in vac_defs]\n    multiplicity = [vac_def['site_multiplicity'] for vac_def in vac_defs]\n    m = len(set(site_species))  # distinct species\n    n = len(vac_defs)  # inequivalent sites\n\n    # Reduce the system and associated parameters such that only distinctive\n    # atoms are retained\n    comm_div = gcd(*tuple(multiplicity))\n    multiplicity = [val / comm_div for val in multiplicity]\n    e0 = e0 / comm_div\n    T = Float(T)\n\n    #c0 = np.diag(multiplicity)\n    c0 = np.diag(np.ones(n))\n    mu = [Symbol('mu' + i.__str__()) for i in range(m)]\n\n    # Generate maps for hashing\n    # Generate specie->mu map and use it for site->mu map\n    specie_order = []  # Contains hash for site->mu map    Eg: [Al, Ni]\n    site_specie_set = set()  # Eg: {Ni, Al}\n    for i in range(n):\n        site_specie = site_species[i]\n        if site_specie not in site_specie_set:\n            site_specie_set.add(site_specie)\n            specie_order.append(site_specie)\n    site_mu_map = []  # Eg: [mu0,mu0,mu0,mu1] where mu0->Al, and mu1->Ni\n    for i in range(n):\n        site_specie = site_species[i]\n        j = specie_order.index(site_specie)\n        site_mu_map.append(j)\n    specie_site_index_map = []  # Eg: [(0,3),(3,4)] for Al & Ni\n    for i in range(m):\n        low_ind = site_species.index(specie_order[i])\n        if i < m - 1:\n            hgh_ind = site_species.index(specie_order[i + 1])\n        else:\n            hgh_ind = n\n        specie_site_index_map.append((low_ind, hgh_ind))\n    \"\"\"\n    dC: delta concentration matrix:\n    dC[i,j,k]: Concentration change of atom i, due to presence of atom\n    j on lattice site k\n    Special case is [i,i,i] which is considered as vacancy\n    Few cases: dC[i,i,i] = -1 due to being vacancy special case\n                dC[k,k,i] = +1 due to increment in k at i lattice if i\n                               lattice type is of different element\n                dC[i,k,i] = -1 due to decrement of ith type atom due to\n                presence of kth type atom on ith sublattice and kth type\n                atom specie is different from ith sublattice atom specie\n                dC[i,k,k] = 0 due to no effect on ith type atom\n                dC[i,j,k] = 0 if i!=j!=k\n    \"\"\"\n    dC = np.zeros((n, n, n), dtype=np.int)\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                if i == j and site_species[j] != site_species[k] and \\\n                        site_species[i] != site_species[k]:\n                    dC[i, j, k] = 1\n        for j in range(n):\n            for k in range(n):\n                if i == k:\n                    dC[i, j, k] = -1\n    for k in range(n):\n        for j in range(n):\n            for i in range(n):\n                if i != j:\n                    if site_species[j] == site_species[k]:\n                        dC[i, j, k] = 0\n\n    for ind_map in specie_site_index_map:\n        if ind_map[1] - ind_map[0] > 1:\n            for index1 in range(ind_map[0] + 1, ind_map[1]):\n                for index2 in range(ind_map[0]):\n                    for i in range(n):\n                        dC[i, index1, index2] = 0\n                for index2 in range(ind_map[1], n):\n                    for i in range(n):\n                        dC[i, index1, index2] = 0\n\n    # dE matrix: Flip energies (or raw defect energies)\n    els = [vac_def['site_specie'] for vac_def in vac_defs]\n    dE = []\n    for i in range(n):\n        dE.append([])\n    for i in range(n):\n        for j in range(n):\n            dE[i].append(0)\n\n    for j in range(n):\n        for i in range(n):\n            if i == j:\n                dE[i][j] = vac_defs[i]['energy']\n            else:\n                sub_specie = vac_defs[i]['site_specie']\n                site_specie = vac_defs[j]['site_specie']\n                if site_specie == sub_specie:\n                    dE[i][j] = 0\n                else:\n                    for as_def in antisite_defs:\n                        if int(as_def['site_index']) == j + 1 and \\\n                                sub_specie == as_def['substitution_specie']:\n                            dE[i][j] = as_def['energy']\n                            break\n    dE = np.array(dE)\n\n    # Initialization for concentrations\n    # c(i,p) == presence of ith type atom on pth type site\n    c = Matrix(n, n, [0] * n**2)\n    for i in range(n):\n        for p in range(n):\n            c[i, p] = Integer(c0[i, p])\n            site_flip_contribs = []\n            for epi in range(n):\n                sum_mu = sum([mu[site_mu_map[j]] * Integer(dC[j, epi, p]) for j in range(n)])\n                flip = Integer(dC[i, epi, p]) * \\\n                    exp(-(dE[epi, p] - sum_mu) / (k_B * T))\n                if flip not in site_flip_contribs:\n                    site_flip_contribs.append(flip)\n                    c[i, p] += flip\n\n    total_c = []\n    for ind in specie_site_index_map:\n        val = 0\n        for i in range(*ind):\n            sum_i = sum([c[i, j] * multiplicity[j] for j in range(n)])\n            val += sum_i\n        total_c.append(val)\n\n    c_ratio = [total_c[-1] / total_c[i] for i in range(m)]\n\n    # Expression for Omega, the Grand Potential\n    omega1 = e0 - sum([mu[site_mu_map[i]] * sum(c0[i, :]) * multiplicity[i] for i in range(n)])\n    omega2 = []\n    fm_en_eff = []\n    used_dEs = []\n    for p_r in range(n):\n        for epi in range(n):\n            sum_mu = sum([mu[site_mu_map[j]] * dC[j, epi, p_r] for j in range(n)])\n            if p_r != epi and site_mu_map[p_r] == site_mu_map[epi]:\n                continue\n            if dE[epi, p_r] not in used_dEs:\n                omega2.append(k_B * T * multiplicity[p_r] * exp(-(dE[epi, p_r] - sum_mu) / (k_B * T)))\n                fm_en_eff.append(dE[epi, p_r] - sum_mu)\n                used_dEs.append(dE[epi, p_r])\n    omega = omega1 - sum(omega2)\n\n    # Compute composition range\n    li = specie_site_index_map[0][0]\n    hi = specie_site_index_map[0][1]\n    comp1_min = sum(multiplicity[li:hi]) / sum(multiplicity) * 100 - 1\n    comp1_max = sum(multiplicity[li:hi]) / sum(multiplicity) * 100 + 1\n    delta = float(comp1_max - comp1_min) / 120.0\n    yvals = []\n    for comp1 in np.arange(comp1_min, comp1_max + delta, delta):\n        comp2 = 100 - comp1\n        y = comp2 / comp1\n        yvals.append(y)\n\n    def reduce_mu():\n        omega = [e0 - sum([mu[site_mu_map[i]] * sum(c0[i, :]) for i in range(n)])]\n        x = solve(omega)\n        return x\n\n    def compute_mus_by_search():\n        # Compute trial mu\n        mu_red = reduce_mu()\n\n        mult = multiplicity\n        specie_concen = [sum(mult[ind[0]:ind[1]]) for ind in specie_site_index_map]\n        y_vect = [specie_concen[-1] / specie_concen[i] for i in range(m)]\n        vector_func = [y_vect[i] - c_ratio[i] for i in range(m - 1)]\n        vector_func.append(omega)\n        min_diff = 1e10\n        mu_vals = None\n        c_val = None\n        m1_min = -20.0\n        if e0 > 0:\n            m1_max = 10  # Search space needs to be modified\n        else:\n            m1_max = 0\n        for m1 in np.arange(m1_min, m1_max, 0.01):\n            m0 = mu_red[mu[0]].subs(mu[-1], m1)\n\n            try:\n                x = nsolve(vector_func, mu, [m0, m1], module=\"numpy\")\n            except:\n                continue\n\n            c_val = c.subs(dict(zip(mu, x)))\n            # if all(x >= 0 for x in c_val):\n            specie_concen = []\n            for ind in specie_site_index_map:\n                specie_concen.append(sum([sum(c_val[i, :]) for i in range(*ind)]))\n            y_comp = [specie_concen[-1] / specie_concen[i] for i in range(m)]\n            diff = math.sqrt(sum([pow(abs(y_comp[i] - y_vect[i]), 2) for i in range(m)]))\n            if diff < min_diff:\n                min_diff = diff\n                mu_vals = x\n\n        if mu_vals:\n            mu_vals = [float(mu_val) for mu_val in mu_vals]\n        else:\n            raise ValueError()\n        return mu_vals\n\n    def compute_def_formation_energies():\n        i = 0\n        for vac_def in vac_defs:\n            site_specie = vac_def['site_specie']\n            ind = specie_order.index(site_specie)\n            uncor_energy = vac_def['energy']\n            formation_energy = uncor_energy + mu_vals[ind]\n            formation_energies['vacancies'][i]['formation_energy'] = formation_energy\n            specie_ind = site_mu_map[i]\n            indices = specie_site_index_map[specie_ind]\n            specie_ind_del = indices[1] - indices[0]\n            cur_ind = i - indices[0] + 1\n            if not specie_ind_del - 1:\n                label = '$V_{' + site_specie + '}$'\n            else:\n                label = '$V_{' + site_specie + '_' + str(cur_ind) + '}$'\n            formation_energies['vacancies'][i]['label'] = label\n            i += 1\n        i = 0\n        for as_def in antisite_defs:\n            site_specie = as_def['site_specie']\n            sub_specie = as_def['substitution_specie']\n            ind1 = specie_order.index(site_specie)\n            ind2 = specie_order.index(sub_specie)\n            uncor_energy = as_def['energy']\n            formation_energy = uncor_energy + mu_vals[ind1] - mu_vals[ind2]\n            formation_energies['antisites'][i]['formation_energy'] = formation_energy\n            specie_ind = site_mu_map[i]\n            indices = specie_site_index_map[specie_ind]\n            specie_ind_del = indices[1] - indices[0]\n            cur_ind = i - indices[0] + 1\n            if not specie_ind_del - 1:\n                label = '$' + sub_specie + '_{' + site_specie + '}$'\n            else:\n                label = '$' + sub_specie + '_{' + site_specie + '_' + str(cur_ind) + '}$'\n            formation_energies['antisites'][i]['label'] = label\n            i += 1\n        return formation_energies\n\n    # If generate option is energy compute effective formation energies\n    # at ideal stoichiometry and return the formation energies and chem pot.\n    if generate == 'energy':\n        if not trial_chem_pot:\n            mu_vals = compute_mus_by_search()\n        else:\n            try:\n                mu_vals = [trial_chem_pot[element] for element in specie_order]\n            except:\n                mu_vals = compute_mus()\n\n        formation_energies = compute_def_formation_energies()\n        mu_dict = dict(zip(specie_order, mu_vals))\n        return formation_energies, mu_dict\n\n    if not trial_chem_pot:\n        # Try computing mus by assuming one of the defects is dominant at 0.01\n        # concen.  First vacancy is tried and then antisite\n\n        # Generate trial mus assuming vacancy as dominant defect\n        # for specie-0 at lower yval\n        li = specie_site_index_map[0][0]\n        hi = specie_site_index_map[0][1]\n        li1 = specie_site_index_map[1][0]\n        hi1 = specie_site_index_map[1][1]\n        spec_mult = [sum(multiplicity[li:hi]), sum(multiplicity[li1:hi1])]\n        ln_def_conc = 4.60517\n        for i in range(li, hi):\n            vac_flip_en = vac_defs[i]['energy']\n            mu_vals = [ln_def_conc * k_B * T - vac_flip_en]\n            mu_vals.append((e0 - spec_mult[0] * mu_vals[0]) / spec_mult[1])\n            comp_ratio = yvals[0]\n\n            # Test if the trial mus are good\n            vector_func = [comp_ratio - c_ratio[0]]\n            vector_func.append(omega)\n            try:\n                mu_vals = nsolve(vector_func, mu, mu_vals)\n                if mu_vals:\n                    mu_vals = [float(mu_val) for mu_val in mu_vals]\n                break\n            except:  # Go for antisite as dominant defect\n                mu_gs = [Symbol('mu_gs' + j.__str__()) for j in range(m)]\n\n                eqs = [mu_gs[0] - mu_gs[1] - (ln_def_conc * k_B * T - antisite_defs[i]['energy'])]\n                eqs.append(spec_mult[0] * mu_gs[0] + spec_mult[1] * mu_gs[1] - e0)\n                x = solve(eqs, mu_gs)\n                #mu_names = sorted([key.name for key in x.keys()])\n                mu_vals = []\n                for key in sorted(x.keys(), key=lambda inp: inp.name):\n                    mu_vals.append(x[key])\n                vector_func = [comp_ratio - c_ratio[0]]\n                vector_func.append(omega)\n\n                try:\n                    mu_vals = nsolve(vector_func, mu, mu_vals)\n                    if mu_vals:\n                        mu_vals = [float(mu_val) for mu_val in mu_vals]\n                    break\n                except:  # Go to the default option (search the space)\n                    pass\n        else:\n            mu_vals = compute_mus_by_search()\n\n    else:\n        try:\n            mu_vals = [trial_chem_pot[element] for element in specie_order]\n        except:\n            mu_vals = compute_mus_by_search()\n\n    # Compile mu's for all composition ratios in the range\n    #+/- 1% from the stoichiometry\n    result = {}\n    i = 0\n    len_y = len(yvals)\n    failed_y, failed_i = [], []\n    for y in yvals:\n        vector_func = [y - c_ratio[0]]\n        vector_func.append(omega)\n        try:\n            x = nsolve(vector_func, mu, mu_vals, module=\"numpy\")\n            if x:\n                mu_vals = [float(mu_val) for mu_val in x]\n        except:\n            failed_y.append(y)\n            failed_i.append(i)\n            continue\n        result[y] = list(mu_vals)\n        x = None\n        i += 1\n\n    def get_next_mu_val(i):\n        if i >= len(yvals):\n            return None\n\n        y = yvals[i + 1]\n        x = result.get(y, None)\n        if x:\n            mu_vals = [float(mu_val) for mu_val in x]\n            return mu_vals\n        else:\n            return get_next_mu_val(i + 1)\n\n    def get_prev_mu_val(i):\n        if i <= 0:\n            return None\n\n        y = yvals[i - 1]\n        x = result.get(y, None)\n        if x:\n            mu_vals = [float(mu_val) for mu_val in x]\n            return mu_vals\n        else:\n            return get_next_mu_val(i - 1)\n\n    # Try to get better trial mus for failed cases\n    for j in range(len(failed_y)):\n        i = failed_i[j]\n\n        prev_mu_val = get_prev_mu_val(i)\n        if not prev_mu_val:\n            continue\n        next_mu_val = get_next_mu_val(i)\n        if not next_mu_val:\n            continue\n\n        y = failed_y[j]\n        vector_func = [y - c_ratio[0]]\n        vector_func.append(omega)\n        trial_mu = list(map(lambda x: float(sum(x)) / len(x), zip(prev_mu_val, next_mu_val)))\n        try:\n            x = nsolve(vector_func, mu, trial_mu, module=\"numpy\")\n            if x:\n                mu_vals = [float(mu_val) for mu_val in x]\n        except:\n            continue\n        result[y] = mu_vals\n        x = None\n\n    # Alternate way of calculating trial mus for failed cases\n    # by taking average of trial mus at extremes.\n    # for j in range(len(failed_y)):\n    #    y = yvals[0]\n    #    prev_mu_val = result[y]\n    #    y = yvals[-1]\n    #    next_mu_val = result[y]\n    #\n    #    trial_mu = list(map(lambda x: float(sum(x))/len(x),  \\\n    #            zip(prev_mu_val,next_mu_val)))\n    #    y = failed_y[j]\n    #    vector_func = [y-c_ratio[0]]\n    #    vector_func.append(omega)\n    #    try:\n    #        x = nsolve(vector_func,mu,trial_mu,module=\"numpy\")\n    #        if x:\n    #            mu_vals = [float(mu_val) for mu_val in x]\n    #    except:\n    #        continue\n    #    result[y] = list(mu_vals)\n\n    if len(result.keys()) < len(yvals) / 2:\n        raise ValueError('Not sufficient data')\n\n    res = []\n    new_mu_dict = {}\n    # Compute the concentrations for all the compositions\n    for key in sorted(result.keys()):\n        mu_val = result[key]\n        total_c_val = [total_c[i].subs(dict(zip(mu, mu_val))) for i in range(len(total_c))]\n        c_val = c.subs(dict(zip(mu, mu_val)))\n        res1 = []\n        # Concentration of first element/over total concen\n        res1.append(float(total_c_val[0] / sum(total_c_val)))\n        new_mu_dict[res1[0]] = mu_val\n        sum_c0 = sum([c0[i, i] for i in range(n)])\n        for i in range(n):\n            for j in range(n):\n                if i == j:  # Vacancy\n                    vac_conc = float(exp(-(mu_val[site_mu_map[i]] + dE[i, i]) / (k_B * T)))\n                    res1.append(vac_conc)\n                else:  # Antisite\n                    res1.append(float(c_val[i, j] / c0[j, j]))\n        res.append(res1)\n\n    res = np.array(res)\n    dtype = [(str('x'), np.float64)] + [(str('y%d%d' % (i, j)), np.float64) for i in range(n) for j in range(n)]\n    res1 = np.sort(res.view(dtype), order=[str('x')], axis=0)\n\n    conc_data = {}\n    \"\"\"Because all the plots have identical x-points storing it in a\n    single array\"\"\"\n    conc_data['x'] = [dat[0][0] for dat in res1]  # x-axis data\n    # Element whose composition is varied. For x-label\n    conc_data['x_label'] = els[0] + \" mole fraction\"\n    conc_data['y_label'] = \"Point defect concentration\"\n    conc = []\n    for i in range(n):\n        conc.append([])\n        for j in range(n):\n            conc[i].append([])\n    for i in range(n):\n        for j in range(n):\n            y1 = [dat[0][i * n + j + 1] for dat in res1]\n            conc[i][j] = y1\n\n    y_data = []\n    for i in range(n):\n        data = conc[i][i]\n        specie = els[i]\n        specie_ind = site_mu_map[i]\n        indices = specie_site_index_map[specie_ind]\n        specie_ind_del = indices[1] - indices[0]\n        cur_ind = i - indices[0] + 1\n        vac_string = \"$Vac_{\"\n        if not specie_ind_del - 1:\n            label = vac_string + specie + '}$'\n        else:\n            label = vac_string + specie + '_' + str(cur_ind) + '}$'\n        # Plot data and legend info\n        y_data.append({'data': data, 'name': label})\n\n    for i in range(n):\n        site_specie = els[i]\n        specie_ind = site_mu_map[i]\n        indices = specie_site_index_map[specie_ind]\n        specie_ind_del = indices[1] - indices[0]\n        cur_ind = i - indices[0] + 1\n        for j in range(m):  # Antisite plot dat\n            sub_specie = specie_order[j]\n            if sub_specie == site_specie:\n                continue\n            if not specie_ind_del - 1:\n                label = '$' + sub_specie + '_{' + site_specie + '}$'\n            else:\n                label = '$' + sub_specie + '_{' + site_specie + '_' + str(cur_ind) + '}$'\n            inds = specie_site_index_map[j]\n            # TODO: Investigate the value below\n            data = np.sum([conc[ind][i] for ind in range(*inds)], axis=0)\n            data = data.tolist()\n            y_data.append({'data': data, 'name': label})\n\n    conc_data['y'] = y_data\n\n    # Compute the  formation energies\n    def compute_vac_formation_energies(mu_vals):\n        en = []\n        for vac_def in vac_defs:\n            site_specie = vac_def['site_specie']\n            ind = specie_order.index(site_specie)\n            uncor_energy = vac_def['energy']\n            formation_energy = uncor_energy + mu_vals[ind]\n            en.append(float(formation_energy))\n        return en\n\n    en_res = []\n    for key in sorted(new_mu_dict.keys()):\n        mu_val = new_mu_dict[key]\n        en_res.append(compute_vac_formation_energies(mu_val))\n\n    en_data = {'x_label': els[0] + ' mole fraction', 'x': []}\n    en_data['x'] = [dat[0][0] for dat in res1]  # x-axis data\n\n    i = 0\n    y_data = []\n    for vac_def in vac_defs:\n        data = [data[i] for data in en_res]\n        site_specie = vac_def['site_specie']\n        ind = specie_order.index(site_specie)\n        specie_ind = site_mu_map[i]\n        indices = specie_site_index_map[specie_ind]\n        specie_ind_del = indices[1] - indices[0]\n        cur_ind = i - indices[0] + 1\n        vac_string = \"$Vac_{\"\n        if not specie_ind_del - 1:\n            label = vac_string + site_specie + '}$'\n        else:\n            label = vac_string + site_specie + '_' + str(cur_ind) + '}$'\n        y_data.append({'data': data, 'name': label})\n        i += 1\n\n    def compute_as_formation_energies(mu_vals):\n        en = []\n        for as_def in antisite_defs:\n            site_specie = as_def['site_specie']\n            sub_specie = as_def['substitution_specie']\n            ind1 = specie_order.index(site_specie)\n            ind2 = specie_order.index(sub_specie)\n            uncor_energy = as_def['energy']\n            form_en = uncor_energy + mu_vals[ind1] - mu_vals[ind2]\n            en.append(form_en)\n        return en\n\n    en_res = []\n    for key in sorted(new_mu_dict.keys()):\n        mu_val = new_mu_dict[key]\n        en_res.append(compute_as_formation_energies(mu_val))\n    i = 0\n    for as_def in antisite_defs:\n        data = [data[i] for data in en_res]\n        site_specie = as_def['site_specie']\n        sub_specie = as_def['substitution_specie']\n        ind1 = specie_order.index(site_specie)\n        ind2 = specie_order.index(sub_specie)\n        specie_ind = site_mu_map[i]\n        indices = specie_site_index_map[specie_ind]\n        specie_ind_del = indices[1] - indices[0]\n        cur_ind = i - indices[0] + 1\n        if not specie_ind_del - 1:\n            label = '$' + sub_specie + '_{' + site_specie + '}$'\n        else:\n            label = '$' + sub_specie + '_{' + site_specie + '_' + str(cur_ind) + '}$'\n        y_data.append({'data': data, 'name': label})\n        i += 1\n\n    en_data['y'] = y_data\n\n    # Return chem potential as well\n    mu_data = {'x_label': els[0] + ' mole fraction', 'x': []}\n    mu_data['x'] = [dat[0][0] for dat in res1]  # x-axis data\n\n    y_data = []\n    for j in range(m):\n        specie = specie_order[j]\n        mus = [new_mu_dict[key][j] for key in sorted(new_mu_dict.keys())]\n        y_data.append({'data': mus, 'name': specie})\n    mu_data['y'] = y_data\n\n    return conc_data, en_data, mu_data", "response": "Compute the defect densities using dilute solution model."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef compute_defect_density(structure, e0, vac_defs, antisite_defs, T=800, trial_chem_pot=None, plot_style=\"highcharts\"):\n    conc_data, en_data, mu_data = dilute_solution_model(\n        structure, e0, vac_defs, antisite_defs, T, trial_chem_pot=trial_chem_pot)\n\n    if plot_style == 'highcharts':\n        \"Energy data is ignored in this mode\"\n        hgh_chrt_data = {}\n        hgh_chrt_data['xAxis'] = conc_data['x_label']\n        hgh_chrt_data['yAxis'] = conc_data['y_label']\n\n        series = []\n        x = conc_data['x']\n        for y_data in conc_data['y']:\n            y = y_data['data']\n            xy = zip(x, y)\n            xy = [list(el) for el in xy]\n            name = y_data['name'].strip('$')\n            flds = name.split('_')\n            def_string = flds[0]\n            site_string = flds[1].strip('{}')\n            name = def_string + \"<sub>\" + site_string + \"</sub>\"\n            #series.append({'data':xy, 'name':y_data['name']})\n            series.append({'data': xy, 'name': name})\n        hgh_chrt_data['series'] = series\n        return hgh_chrt_data\n    elif plot_style == 'gnuplot':\n\n        def data_to_rows(inp_data):\n            rows = []\n            labels = []\n            labels.append(inp_data['x_label'])\n            labels += [y['name'] for y in inp_data['y']]\n            # labels.sort()\n            rows.append('#' + '\\t'.join(labels))\n            m = len(inp_data['x'])\n            for i in range(m):\n                data = []\n                data.append(inp_data['x'][i])\n                data += [y['data'][i] for y in inp_data['y']]\n                data = [float(x) for x in data]\n                rows.append('\\t'.join(list(map(str, data))))\n            return rows\n\n        conc_rows = data_to_rows(conc_data)\n        en_rows = data_to_rows(en_data)\n        mu_rows = data_to_rows(mu_data)\n\n        return conc_rows, en_rows, mu_rows", "response": "This function computes the density of the defects in the undefected system."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef solute_site_preference_finder(structure,\n                                  e0,\n                                  T,\n                                  vac_defs,\n                                  antisite_defs,\n                                  solute_defs,\n                                  solute_concen=0.01,\n                                  trial_chem_pot=None):\n    \"\"\"\n    Compute the solute defect densities using dilute solution model.\n    Args:\n        structure: pymatgen.core.structure.Structure object representing the\n            primitive or unitcell of the crystal.\n        e0: The total energy of the undefected system.\n            This is E0 from VASP calculation.\n        T: Temperature in Kelvin\n        vac_defs: List of vacancy defect parameters in the dictionary format.\n            The keys of the dict associated with each vacancy defect are\n            1) site_index, 2) site_specie, 3) site_multiplicity, and\n            4) energy. 1-3 can be obtained from\n            pymatgen.analysis.defects.point_defects.Vacancy class.\n            Site index is expected to start with 1 (fortran index).\n        antisite_defs: List of antisite defect parameters in the dictionary\n            format. The keys of the dict associated with each antisite\n            defect are 1) site_index, 2) site_specie, 3) site_multiplicity,\n            4) substitution_specie, and 5) energy. 1-3 can be obtained\n            from pymatgen.analysis.defects.point_defects.Vacancy class.\n        solute_defs: List of solute defect parameters in the dictionary\n            format. Similary to that of antisite defs, wtih solute specie\n            specified in substitution_specie\n        solute_concen: Solute concentration (in fractional value)\n        trial_chem_pot: Trial chemical potentials to speedup the plot\n            generation. Format is {el1:mu1,...}\n\n    Returns:\n        plot_data: The data for plotting the solute defect concentration.\n    \"\"\"\n\n    if not check_input(vac_defs):\n        raise ValueError('Vacancy energy is not defined')\n    if not check_input(antisite_defs):\n        raise ValueError('Antisite energy is not defined')\n\n    formation_energies = {}\n    formation_energies['vacancies'] = copy.deepcopy(vac_defs)\n    formation_energies['antisites'] = copy.deepcopy(antisite_defs)\n    formation_energies['solute'] = copy.deepcopy(solute_defs)\n    for vac in formation_energies['vacancies']:\n        del vac['energy']\n    for asite in formation_energies['antisites']:\n        del asite['energy']\n    for solute in formation_energies['solute']:\n        del solute['energy']\n    # Setup the system\n    site_species = [vac_def['site_specie'] for vac_def in vac_defs]\n    solute_specie = solute_defs[0]['substitution_specie']\n    site_species.append(solute_specie)\n    multiplicity = [vac_def['site_multiplicity'] for vac_def in vac_defs]\n    m = len(set(site_species))  # distinct species\n    n = len(vac_defs)  # inequivalent sites\n\n    # Reduce the system and associated parameters such that only distinctive\n    # atoms are retained\n    comm_div = gcd(*tuple(multiplicity))\n    multiplicity = [val / comm_div for val in multiplicity]\n    multiplicity.append(0)\n    e0 = e0 / comm_div\n    T = Float(T)\n\n    #c0 = np.diag(multiplicity)\n    c0 = np.diag(np.ones(n + 1))\n    c0[n, n] = 0\n    mu = [Symbol('mu' + str(i)) for i in range(m)]\n\n    # Generate maps for hashing\n    # Generate specie->mu map and use it for site->mu map\n    specie_order = []  # Contains hash for site->mu map    Eg: [Al, Ni]\n    site_specie_set = set()  # Eg: {Ni, Al}\n    for i in range(len(site_species)):\n        site_specie = site_species[i]\n        if site_specie not in site_specie_set:\n            site_specie_set.add(site_specie)\n            specie_order.append(site_specie)\n    site_mu_map = []  # Eg: [mu0,mu0,mu0,mu1] where mu0->Al, and mu1->Ni\n    for i in range(len(site_species)):\n        site_specie = site_species[i]\n        j = specie_order.index(site_specie)\n        site_mu_map.append(j)\n    specie_site_index_map = []  # Eg: [(0,3),(3,4)] for Al & Ni\n    for i in range(m):\n        low_ind = site_species.index(specie_order[i])\n        if i < m - 1:\n            hgh_ind = site_species.index(specie_order[i + 1])\n        else:\n            hgh_ind = len(site_species)\n        specie_site_index_map.append((low_ind, hgh_ind))\n    \"\"\"\n    dC: delta concentration matrix:\n    dC[i,j,k]: Concentration change of atom i, due to presence of atom\n    j on lattice site k\n    Special case is [i,i,i] which is considered as vacancy\n    Few cases: dC[i,i,i] = -1 due to being vacancy special case\n                dC[k,k,i] = +1 due to increment in k at i lattice if i\n                               lattice type is of different element\n                dC[i,k,i] = -1 due to decrement of ith type atom due to\n                presence of kth type atom on ith sublattice and kth type\n                atom specie is different from ith sublattice atom specie\n                dC[i,k,k] = 0 due to no effect on ith type atom\n                dC[i,j,k] = 0 if i!=j!=k\n    \"\"\"\n    dC = np.zeros((n + 1, n + 1, n), dtype=np.int)\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                if i == j and site_species[j] != site_species[k] and \\\n                        site_species[i] != site_species:\n                    dC[i, j, k] = 1\n        for j in range(n + 1):\n            for k in range(n):\n                if i == k:\n                    dC[i, j, k] = -1\n    for k in range(n):\n        dC[n, n, k] = 1\n    for k in range(n):\n        for j in range(n):\n            if i != j:\n                if site_species[i] == site_species[k]:\n                    dC[i, j, k] = 0\n\n    for ind_map in specie_site_index_map:\n        if ind_map[1] - ind_map[0] > 1:\n            for index1 in range(ind_map[0] + 1, ind_map[1]):\n                for index2 in range(ind_map[0]):\n                    for i in range(n):\n                        dC[i, index1, index2] = 0\n                for index2 in range(ind_map[1], n):\n                    for i in range(n):\n                        dC[i, index1, index2] = 0\n\n    # dE matrix: Flip energies (or raw defect energies)\n    els = [vac_def['site_specie'] for vac_def in vac_defs]\n    dE = []\n    for i in range(n + 1):\n        dE.append([])\n    for i in range(n + 1):\n        for j in range(n):\n            dE[i].append(0)\n\n    for j in range(n):\n        for i in range(n):\n            if i == j:\n                dE[i][j] = vac_defs[i]['energy']\n            else:\n                sub_specie = vac_defs[i]['site_specie']\n                site_specie = vac_defs[j]['site_specie']\n                if site_specie == sub_specie:\n                    dE[i][j] = 0\n                else:\n                    for as_def in antisite_defs:\n                        if int(as_def['site_index']) == j + 1 and \\\n                                sub_specie == as_def['substitution_specie']:\n                            dE[i][j] = as_def['energy']\n                            break\n        # Solute\n        site_specie = vac_defs[j]['site_specie']\n        for solute_def in solute_defs:\n            def_site_ind = int(solute_def['site_index'])\n            def_site_specie = solute_def['site_specie']\n            if def_site_specie == site_specie and def_site_ind == j + 1:\n                dE[n][j] = solute_def['energy']\n                break\n\n    dE = np.array(dE)\n    #np.where(dE == np.array(None), 0, dE)\n\n    # Initialization for concentrations\n    # c(i,p) == presence of ith type atom on pth type site\n    c = Matrix(n + 1, n, [0] * n * (n + 1))\n    for i in range(n + 1):\n        for p in range(n):\n            c[i, p] = Integer(c0[i, p])\n            site_flip_contribs = []\n            for epi in range(n + 1):\n                sum_mu = sum([mu[site_mu_map[j]] * Integer(dC[j, epi, p]) for j in range(n + 1)])\n                flip = dC[i, epi, p] * exp(-(dE[epi, p] - sum_mu) / (k_B * T))\n                if flip not in site_flip_contribs:\n                    site_flip_contribs.append(flip)\n                    c[i, p] += flip\n    host_c = Matrix(n, n, [0] * n * n)\n    for i in range(n):\n        for p in range(n):\n            host_c[i, p] = Integer(c0[i, p])\n            site_flip_contribs = []\n            for epi in range(n):\n                sum_mu = sum([mu[site_mu_map[j]] * Integer(dC[j, epi, p]) for j in range(n)])\n                flip = dC[i, epi, p] * exp(-(dE[epi, p] - sum_mu) / (k_B * T))\n                if flip not in site_flip_contribs:\n                    site_flip_contribs.append(flip)\n                    host_c[i, p] += flip\n\n    #specie_concen = [sum(mult[ind[0]:ind[1]]) for ind in specie_site_index_map]\n    #total_c = [sum(c[ind[0]:ind[1]]) for ind in specie_site_index_map]\n    total_c = []\n    for ind in specie_site_index_map:\n        val = 0\n        for i in range(*ind):\n            sum_i = sum([c[i, j] * multiplicity[j] for j in range(n)])\n            val += sum_i\n        total_c.append(val)\n\n    c_ratio = [total_c[i] / sum(total_c) for i in range(m)]\n\n    host_total_c = []\n    for ind in specie_site_index_map[:-1]:\n        val = 0\n        for i in range(*ind):\n            sum_i = sum([host_c[i, j] * multiplicity[j] for j in range(n)])\n            val += sum_i\n        host_total_c.append(val)\n\n    host_c_ratio = [host_total_c[i] / sum(host_total_c) for i in range(m - 1)]\n\n    # Expression for Omega, the Grand Potential\n    omega1 = e0 - sum([mu[site_mu_map[i]] * sum(c0[i, :]) * multiplicity[i] for i in range(n)])\n    omega = omega1\n\n    used_dEs = []\n    for p_r in range(n):\n        for epi in range(n):\n            sum_mu1 = sum([mu[site_mu_map[j]] * Integer(dC[j, epi, p_r]) for j in range(n)])\n            sum_mu = sum_mu1 - mu[site_mu_map[n]] * dC[n, epi, p_r]\n            if p_r != epi and site_mu_map[p_r] == site_mu_map[epi]:\n                continue\n            if dE[epi, p_r] not in used_dEs:\n                omega1 -= k_B * T * multiplicity[p_r] * \\\n                    exp(-(dE[epi, p_r] - sum_mu1) / (k_B * T))\n                omega -= k_B * T * multiplicity[p_r] * \\\n                    exp(-(dE[epi, p_r] - sum_mu) / (k_B * T))\n                used_dEs.append(dE[epi, p_r])\n\n    # Compute composition ranges\n    max_host_specie_concen = 1 - solute_concen\n    mult = multiplicity\n    specie_concen = [sum(mult[ind[0]:ind[1]]) for ind in specie_site_index_map]\n    host_specie_concen_ratio = [specie_concen[i] / sum(specie_concen) * max_host_specie_concen for i in range(m)]\n    host_specie_concen_ratio[-1] = solute_concen\n    li = specie_site_index_map[0][0]\n    hi = specie_site_index_map[0][1]\n    comp1_min = sum(multiplicity[li:hi]) / sum(multiplicity) * \\\n        max_host_specie_concen - 0.01\n    comp1_max = sum(multiplicity[li:hi]) / sum(multiplicity) * \\\n        max_host_specie_concen + 0.01\n    delta = (comp1_max - comp1_min) / 50.0\n\n    # def reduce_mu():\n    #    omega = [e0 - sum([mu[site_mu_map[i]]*sum(c0[i,:]) for i in range(n)])]\n    #    x = solve(omega)\n    #    return x\n    def reduce_mu():\n        host_concen = 1 - solute_concen\n        new_c0 = c0.astype(float)\n        for i in range(n):\n            new_c0[i, i] = host_concen * c0[i, i]\n        new_c0[n, n] = 2 * solute_concen\n        omega = [e0 - sum([mu[site_mu_map[i]] * sum(new_c0[i, :]) for i in range(n + 1)])]\n        x = solve(omega)\n        return x\n\n    def compute_solute_mu_by_lin_search(host_mu_vals):\n        # Compute trial mu\n        mu_red = reduce_mu()\n\n        mult = multiplicity\n        specie_concen = [sum(mult[ind[0]:ind[1]]) for ind in specie_site_index_map]\n        max_host_specie_concen = 1 - solute_concen\n        host_specie_concen_ratio = [specie_concen[i] / sum(specie_concen) * max_host_specie_concen for i in range(m)]\n        host_specie_concen_ratio[-1] = solute_concen\n        y_vect = host_specie_concen_ratio\n        vector_func = [y_vect[i] - c_ratio[i] for i in range(m)]\n        vector_func.append(omega)\n        min_diff = 1e10\n        mu_vals = None\n        c_val = None\n        m1_min = -20.0\n        if e0 > 0:\n            m1_max = 10  # Search space needs to be modified\n        else:\n            m1_max = 0\n        for m1 in np.arange(m1_min, m1_max, 0.1):\n            trial_mus = host_mu_vals + [m1]\n            try:\n                x = nsolve(vector_func, mu, trial_mus, module=\"numpy\")\n                if x:\n                    mu_vals = [float(mu_val) for mu_val in x]\n                break\n            except:\n                continue\n        else:\n            raise ValueError()\n        return mu_vals\n\n    def compute_mus():\n\n        # Compute trial mu\n        mu_red = reduce_mu()\n        mult = multiplicity\n        specie_concen = [sum(mult[ind[0]:ind[1]]) for ind in specie_site_index_map]\n        max_host_specie_concen = 1 - solute_concen\n        host_specie_concen_ratio = [specie_concen[i] / sum(specie_concen) * max_host_specie_concen for i in range(m)]\n        host_specie_concen_ratio[-1] = solute_concen\n\n        y_vect = host_specie_concen_ratio\n        vector_func = [y_vect[i] - c_ratio[i] for i in range(m)]\n        vector_func.append(omega)\n        mu_vals = None\n        c_val = None\n        m_min = -15.0\n        if e0 > 0:\n            m_max = 10  # Search space needs to be modified\n        else:\n            m_max = 0\n        for m1 in np.arange(m_min, m_max, 0.3):\n            for m2 in np.arange(m_min, m_max, 0.3):\n                m0 = mu_red[mu[0]].subs([(mu[1], m1), (mu[2], m2)])\n                try:\n                    mu_vals = nsolve(vector_func, mu, [m0, m1, m2], module=\"numpy\")\n                    # Line needs to be modified to include all mus when n > 2\n                except:\n                    continue\n                break\n            if mu_vals:\n                mu_vals = [float(mu_val) for mu_val in mu_vals]\n                break\n        else:\n            raise ValueError(\"Couldn't find mus\")\n        return mu_vals\n\n    if not trial_chem_pot:\n        # Try computing mus by assuming one of the defects is dominant at 0.01\n        # concen.  First vacancy is tried and then antisite\n\n        # Generate trial mus assuming vacancy as dominant defect\n        # for specie-0 at lower yval\n        li = specie_site_index_map[0][0]\n        hi = specie_site_index_map[0][1]\n        li1 = specie_site_index_map[1][0]\n        hi1 = specie_site_index_map[1][1]\n        spec_mult = [sum(multiplicity[li:hi]), sum(multiplicity[li1:hi1])]\n        ln_def_conc = 4.60517\n        for i in range(li, hi):\n            vac_flip_en = vac_defs[i]['energy']\n            mu_vals = [ln_def_conc * k_B * T - vac_flip_en]\n            mu_vals.append((e0 - spec_mult[0] * mu_vals[0]) / spec_mult[1])\n            comp_ratio = comp1_min\n\n            # Test if the trial mus are good\n            vector_func = [comp_ratio - host_c_ratio[0]]\n            vector_func.append(omega1)\n            try:\n                host_mu_vals = nsolve(vector_func, mu[:-1], mu_vals)\n                if host_mu_vals:\n                    host_mu_vals = [float(mu_val) for mu_val in host_mu_vals]\n                compute_solute_mu_by_lin_search(host_mu_vals)\n                break\n            except:  # Go for antisite as dominant defect\n                mu_gs = [Symbol('mu_gs' + j.__str__()) for j in range(m - 1)]\n\n                eqs = [mu_gs[0] - mu_gs[1] - (ln_def_conc * k_B * T - antisite_defs[i]['energy'])]\n                eqs.append(spec_mult[0] * mu_gs[0] + spec_mult[1] * mu_gs[1] - e0)\n                x = solve(eqs, mu_gs)\n                host_mu_vals = []\n                for key in sorted(x.keys(), key=lambda inp: inp.name):\n                    host_mu_vals.append(x[key])\n                vector_func = [comp_ratio - host_c_ratio[0]]\n                vector_func.append(omega1)\n\n                try:\n                    host_mu_vals = nsolve(vector_func, mu[:-1], host_mu_vals)\n                    if host_mu_vals:\n                        host_mu_vals = [float(mu_val) for mu_val in host_mu_vals]\n                    mu_vals = compute_solute_mu_by_lin_search(host_mu_vals)\n                    break\n                except:  # Go to the default option (search the space)\n                    pass\n        else:\n            mu_vals = compute_mus()\n\n    else:\n        try:\n            mu_vals = [trial_chem_pot[element] for element in specie_order]\n        except:\n            mu_vals = compute_mus()\n\n    # Compile mu's for all composition ratios in the range\n    #+/- 1% from the stoichiometry\n    result = {}\n    for y in np.arange(comp1_min, comp1_max + delta, delta):\n        y_vect = []\n        y_vect.append(y)\n        y2 = max_host_specie_concen - y\n        y_vect.append(y2)\n        y_vect.append(solute_concen)\n        vector_func = [y_vect[i] - c_ratio[i] for i in range(1, m)]\n        vector_func.append(omega)\n\n        try:\n            x = nsolve(vector_func, mu, mu_vals)\n            if x:\n                mu_vals = [float(mu_val) for mu_val in x]\n        except:\n            continue\n        result[y] = mu_vals\n\n    res = []\n\n    # Compute the concentrations for all the compositions\n    for key in sorted(result.keys()):\n        mu_val = result[key]\n        total_c_val = [total_c[i].subs(dict(zip(mu, mu_val))) for i in range(len(total_c))]\n        c_val = c.subs(dict(zip(mu, mu_val)))\n        # Concentration of first element/over total concen\n        res1 = []\n        res1.append(float(total_c_val[0] / sum(total_c_val)))\n\n        sum_c0 = sum([c0[i, i] for i in range(n)])\n        for i in range(n + 1):\n            for j in range(n):\n                if i == j:  # Vacancy\n                    vac_conc = float(exp(-(mu_val[site_mu_map[i]] + dE[i, i]) / (k_B * T)))\n                    res1.append(vac_conc)\n                else:  # Antisite\n                    res1.append(float(c_val[i, j] / c0[j, j]))\n        res.append(res1)\n\n    res = np.array(res)\n    dtype = [(str('x'), np.float64)] + [(str('y%d%d' % (i, j)), np.float64) for i in range(n + 1) for j in range(n)]\n    res1 = np.sort(res.view(dtype), order=[str('x')], axis=0)\n\n    conc = []\n    for i in range(n + 1):\n        conc.append([])\n        for j in range(n):\n            conc[i].append([])\n    for i in range(n + 1):  # Append vacancies\n        for j in range(n):\n            y1 = [dat[0][i * n + j + 1] for dat in res1]\n            conc[i][j] = y1\n\n    # Compute solute site preference\n    # Removing the functionality\n    #site_pref_data = {}\n    \"\"\"Because all the plots have identical x-points storing it in a\n    single array\"\"\"\n    # site_pref_data['x'] = [dat[0][0] for dat in res1]         # x-axis data\n    # Element whose composition is varied. For x-label\n    #site_pref_data['x_label'] = els[0]+ \"_mole_fraction\"\n    # site_pref_data['y_label'] = \"$\"+solute_specie+\"_{\"+els[0]+\"}/(\"+\\\n    #    solute_specie+\"_{\"+els[0]+\"}+\"+solute_specie+\"_{\"+els[1]+\"})$\"\n\n    #y_data = []\n    #inds = specie_site_index_map[m-1]\n    #data1 = np.sum([multiplicity[0]*conc[ind][0] for ind in range(*inds)],axis=0)\n    #data2 = np.sum([multiplicity[1]*conc[ind][1] for ind in range(*inds)],axis=0)\n    #frac_data = data1/(data1+data2)\n    #frac_data = frac_data.tolist()\n    # y_data.append({'data':frac_data})\n\n    #site_pref_data['y'] = y_data\n\n    #  Return all defect concentrations\n    conc_data = {}\n    \"\"\"Because all the plots have identical x-points storing it in a\n    single array\"\"\"\n    conc_data['x'] = [dat[0][0] for dat in res1]  # x-axis data\n    # Element whose composition is varied. For x-label\n    conc_data['x_label'] = els[0] + \" mole fraction\"\n    conc_data['y_label'] = \"Point defect concentration\"\n\n    y_data = []\n    # Vacancy\n    for i in range(n):\n        data = conc[i][i]\n        specie = els[i]\n        specie_ind = site_mu_map[i]\n        indices = specie_site_index_map[specie_ind]\n        specie_ind_del = indices[1] - indices[0]\n        cur_ind = i - indices[0] + 1\n        vac_string = \"$Vac_{\"\n        if not specie_ind_del - 1:\n            label = vac_string + specie + '}$'\n        else:\n            label = vac_string + specie + '_' + str(cur_ind) + '}$'\n        # Plot data and legend info\n        y_data.append({'data': data, 'name': label})\n\n    # Antisites and solute\n    for i in range(n):\n        site_specie = els[i]\n        specie_ind = site_mu_map[i]\n        indices = specie_site_index_map[specie_ind]\n        specie_ind_del = indices[1] - indices[0]\n        cur_ind = i - indices[0] + 1\n        for j in range(m):\n            sub_specie = specie_order[j]\n            if sub_specie == site_specie:\n                continue\n            if not specie_ind_del - 1:\n                label = '$' + sub_specie + '_{' + site_specie + '}$'\n            else:\n                label = '$' + sub_specie + '_{' + site_specie + '_' + str(cur_ind) + '}$'\n            inds = specie_site_index_map[j]\n            # TODO: Investigate the value below\n            data = np.sum([conc[ind][i] for ind in range(*inds)], axis=0)\n            data = data.tolist()\n            y_data.append({'data': data, 'name': label})\n\n    conc_data['y'] = y_data\n    # return site_pref_data, conc_data\n    return conc_data", "response": "This function calculates the solute defect densities using dilute solution model."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef solute_defect_density(structure,\n                          e0,\n                          vac_defs,\n                          antisite_defs,\n                          solute_defs,\n                          solute_concen=0.01,\n                          T=800,\n                          trial_chem_pot=None,\n                          plot_style=\"highchargs\"):\n    \"\"\"\n    Wrapper for the solute_site_preference_finder.\n    The computed plot data is prepared based on plot_style.\n\n    Args:\n        structure: pymatgen.core.structure.Structure object representing the\n            primitive or unitcell of the crystal.\n        e0: The total energy of the undefected system.\n            This is E0 from VASP calculation.\n        vac_defs: List of vacancy defect parameters in the dictionary format.\n            The keys of the dict associated with each vacancy defect are\n            1) site_index, 2) site_specie, 3) site_multiplicity, and\n            4) energy. 1-3 can be obtained from\n            pymatgen.analysis.defects.point_defects.Vacancy class.\n            Site index is expected to start with 1 (fortran index).\n        antisite_defs: List of antisite defect parameters in the dictionary\n            format. The keys of the dict associated with each antisite defect\n            are 1) site_index, 2) site_specie, 3) site_multiplicity,\n            4) substitution_specie, and 5) energy. 1-3 can be obtained\n            from pymatgen.analysis.defects.point_defects.Vacancy class.\n        solute_defs: List of solute defect parameters in the dictionary\n            format. Similary to that of antisite defs, wtih solute specie\n            specified in substitution_specie\n        solute_concen: Solute concentration (in fractional value)\n        T: Temperature in Kelvin\n        trial_chem_pot (optional): Trial chemical potentials to speedup\n            the plot generation. Format is {el1:mu1,...}\n        plot_style (string): Allowed options are\n            1) highcharts (default)\n            2) gnuplot\n\n    Returns:\n        The plot data is generated and returned in asked format.\n    \"\"\"\n\n    # solute_site_pref_data, def_conc_data = solute_site_preference_finder(\n    def_conc_data = solute_site_preference_finder(\n        structure,\n        e0,\n        T,\n        vac_defs,\n        antisite_defs,\n        solute_defs,\n        solute_concen=solute_concen,\n        trial_chem_pot=trial_chem_pot)\n\n    if plot_style == 'highcharts':\n        \"Energy data is ignored in this mode\"\n        hgh_chrt_data = {}\n        hgh_chrt_data['xAxis'] = def_conc_data['x_label']\n        hgh_chrt_data['yAxis'] = def_conc_data['y_label']\n\n        series = []\n        x = def_conc_data['x']\n        for y_data in def_conc_data['y']:\n            y = y_data['data']\n            xy = zip(x, y)\n            xy = [list(el) for el in xy]\n            name = y_data['name'].strip('$')\n            flds = name.split('_')\n            def_string = flds[0]\n            site_string = flds[1].strip('{}')\n            name = def_string + \"<sub>\" + site_string + \"</sub>\"\n            #series.append({'data':xy, 'name':y_data['name']})\n            series.append({'data': xy, 'name': name})\n        hgh_chrt_data['series'] = series\n        return hgh_chrt_data\n    elif plot_style == 'gnuplot':\n\n        def data_to_rows(inp_data, y_lbl_flg):\n            rows = []\n            labels = []\n            labels.append(inp_data['x_label'])\n            if y_lbl_flg:\n                labels.append(inp_data['y_label'])\n            else:\n                labels += [y['name'] for y in inp_data['y']]\n            rows.append('#' + '\\t'.join(labels))\n            m = len(inp_data['x'])\n            for i in range(m):\n                data = []\n                data.append(inp_data['x'][i])\n                data += [y['data'][i] for y in inp_data['y']]\n                data = [float(x) for x in data]\n                rows.append('\\t'.join(list(map(str, data))))\n            return rows\n\n        #solute_site_pref_rows = data_to_rows(solute_site_pref_data, True)\n        pt_def_conc_rows = data_to_rows(def_conc_data, False)\n        # return solute_site_pref_rows, pt_def_conc_rows\n        return pt_def_conc_rows", "response": "This function calculates the solute defect density of a single object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef optimize_gibbs_free_energy(self):\n        temperatures = np.linspace(\n            self.temperature_min,  self.temperature_max,\n            int(np.ceil((self.temperature_max - self.temperature_min)\n            / self.temperature_step) + 1))\n\n        for t in temperatures:\n            try:\n                G_opt, V_opt = self.optimizer(t)\n            except:\n                if len(temperatures) > 1:\n                    print(\"EOS fitting failed, so skipping this data point, {}\".\n                          format(t))\n                    continue\n                else:\n                    raise\n            self.gibbs_free_energy.append(G_opt)\n            self.temperatures.append(t)\n            self.optimum_volumes.append(V_opt)", "response": "Evaluate the gibbs free energy as a function of V T and P and store the optimum volumes wrt V for each T."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nevaluate G at the given temperature and pressure and minimize it wrt V.", "response": "def optimizer(self, temperature):\n        \"\"\"\n        Evaluate G(V, T, P) at the given temperature(and pressure) and\n        minimize it wrt V.\n\n        1. Compute the  vibrational helmholtz free energy, A_vib.\n        2. Compute the gibbs free energy as a function of volume, temperature\n            and pressure, G(V,T,P).\n        3. Preform an equation of state fit to get the functional form of\n            gibbs free energy:G(V, T, P).\n        4. Finally G(V, P, T) is minimized with respect to V.\n\n        Args:\n            temperature (float): temperature in K\n\n        Returns:\n            float, float: G_opt(V_opt, T, P) in eV and V_opt in Ang^3.\n        \"\"\"\n        G_V = []  # G for each volume\n        # G = E(V) + PV + A_vib(V, T)\n        for i, v in enumerate(self.volumes):\n            G_V.append(self.energies[i] +\n                       self.pressure * v * self.gpa_to_ev_ang +\n                       self.vibrational_free_energy(temperature, v))\n\n        # fit equation of state, G(V, T, P)\n        eos_fit = self.eos.fit(self.volumes, G_V)\n        # minimize the fit eos wrt volume\n        # Note: the ref energy and the ref volume(E0 and V0) not necessarily\n        # the same as minimum energy and min volume.\n        volume_guess = eos_fit.volumes[np.argmin(eos_fit.energies)]\n        min_wrt_vol = minimize(eos_fit.func, volume_guess)\n        # G_opt=G(V_opt, T, P), V_opt\n        return min_wrt_vol.fun, min_wrt_vol.x[0]"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the vibrational free energy in eVova.", "response": "def vibrational_free_energy(self, temperature, volume):\n        \"\"\"\n        Vibrational Helmholtz free energy, A_vib(V, T).\n        Eq(4) in doi.org/10.1016/j.comphy.2003.12.001\n\n        Args:\n            temperature (float): temperature in K\n            volume (float)\n\n        Returns:\n            float: vibrational free energy in eV\n        \"\"\"\n        y = self.debye_temperature(volume) / temperature\n        return self.kb * self.natoms * temperature * (\n            9./8. * y + 3 * np.log(1 - np.exp(-y)) - self.debye_integral(y))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef vibrational_internal_energy(self, temperature, volume):\n        y = self.debye_temperature(volume) / temperature\n        return self.kb * self.natoms * temperature * (9./8. * y +\n                                                      3*self.debye_integral(y))", "response": "Returns the vibrational internal energy in eVibrational."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncalculating the debye temperature for a given volume in the species.", "response": "def debye_temperature(self, volume):\n        \"\"\"\n        Calculates the debye temperature.\n        Eq(6) in doi.org/10.1016/j.comphy.2003.12.001. Thanks to Joey.\n\n        Eq(6) above is equivalent to Eq(3) in doi.org/10.1103/PhysRevB.37.790\n        which does not consider anharmonic effects. Eq(20) in the same paper\n        and Eq(18) in doi.org/10.1016/j.commatsci.2009.12.006 both consider\n        anharmonic contributions to the Debye temperature through the Gruneisen\n        parameter at 0K (Gruneisen constant).\n\n        The anharmonic contribution is toggled by setting the anharmonic_contribution\n        to True or False in the QuasiharmonicDebyeApprox constructor.\n\n        Args:\n            volume (float): in Ang^3\n\n        Returns:\n            float: debye temperature in K\n         \"\"\"\n        term1 = (2./3. * (1. + self.poisson) / (1. - 2. * self.poisson))**1.5\n        term2 = (1./3. * (1. + self.poisson) / (1. - self.poisson))**1.5\n        f = (3. / (2. * term1 + term2))**(1. / 3.)\n        debye = 2.9772e-11 * (volume / self.natoms) ** (-1. / 6.) * f * \\\n               np.sqrt(self.bulk_modulus/self.avg_mass)\n        if self.anharmonic_contribution:\n            gamma = self.gruneisen_parameter(0, self.ev_eos_fit.v0)  # 0K equilibrium Gruneisen parameter\n            return debye * (self.ev_eos_fit.v0 / volume) ** (gamma)\n        else:\n            return debye"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef thermal_conductivity(self, temperature, volume):\n        gamma = self.gruneisen_parameter(temperature, volume)\n        theta_d = self.debye_temperature(volume)  # K\n        theta_a = theta_d * self.natoms**(-1./3.)  # K\n        prefactor = (0.849 * 3 * 4**(1./3.)) / (20. * np.pi**3)\n        # kg/K^3/s^3\n        prefactor = prefactor * (self.kb/self.hbar)**3 * self.avg_mass\n        kappa = prefactor / (gamma**2 - 0.514 * gamma + 0.228)\n        # kg/K/s^3 * Ang = (kg m/s^2)/(Ks)*1e-10\n        # = N/(Ks)*1e-10 = Nm/(Kms)*1e-10 = W/K/m*1e-10\n        kappa = kappa * theta_a**2 * volume**(1./3.) * 1e-10\n        return kappa", "response": "Equation 17 in 10. 1103. 1348. 1348."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a dict with a summary of the computed properties.", "response": "def get_summary_dict(self):\n        \"\"\"\n        Returns a dict with a summary of the computed properties.\n        \"\"\"\n        d = defaultdict(list)\n        d[\"pressure\"] = self.pressure\n        d[\"poisson\"] = self.poisson\n        d[\"mass\"] = self.mass\n        d[\"natoms\"] = int(self.natoms)\n        d[\"bulk_modulus\"] = self.bulk_modulus\n        d[\"gibbs_free_energy\"] = self.gibbs_free_energy\n        d[\"temperatures\"] = self.temperatures\n        d[\"optimum_volumes\"] = self.optimum_volumes\n        for v, t in zip(self.optimum_volumes, self.temperatures):\n            d[\"debye_temperature\"].append(self.debye_temperature(v))\n            d[\"gruneisen_parameter\"].append(self.gruneisen_parameter(t, v))\n            d[\"thermal_conductivity\"].append(self.thermal_conductivity(t, v))\n        return d"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef fix_pbc(structure, matrix=None):\n\n    spec = []\n    coords = []\n    if matrix is None:\n        latte = Lattice(structure.lattice.matrix)\n    else:\n        latte = Lattice(matrix)\n\n    for site in structure:\n        spec.append(site.specie)\n        coord = np.array(site.frac_coords)\n        for i in range(3):\n            coord[i] -= floor(coord[i])\n            if np.allclose(coord[i], 1):\n                coord[i] = 0\n            elif np.allclose(coord[i], 0):\n                coord[i] = 0\n            else:\n                coord[i] = round(coord[i], 7)\n        coords.append(coord)\n\n    return Structure(latte, spec, coords, site_properties=structure.site_properties)", "response": "Fixes the frac_coords of the input structure within [ 0 1 )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nobtaining cubic symmetric eqivalents of the list of vectors. Args: matrix (lattice matrix, n by 3 array/matrix) Return: cubic symmetric eqivalents of the list of vectors.", "response": "def symm_group_cubic(mat):\n    \"\"\"\n     obtain cubic symmetric eqivalents of the list of vectors.\n\n    Args:\n        matrix (lattice matrix, n by 3 array/matrix)\n\n    Return:\n        cubic symmetric eqivalents of the list of vectors.\n    \"\"\"\n    sym_group = np.zeros([24, 3, 3])\n    sym_group[0, :] = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    sym_group[1, :] = [[1, 0, 0], [0, -1, 0], [0, 0, -1]]\n    sym_group[2, :] = [[-1, 0, 0], [0, 1, 0], [0, 0, -1]]\n    sym_group[3, :] = [[-1, 0, 0], [0, -1, 0], [0, 0, 1]]\n    sym_group[4, :] = [[0, -1, 0], [-1, 0, 0], [0, 0, -1]]\n    sym_group[5, :] = [[0, -1, 0], [1, 0, 0], [0, 0, 1]]\n    sym_group[6, :] = [[0, 1, 0], [-1, 0, 0], [0, 0, 1]]\n    sym_group[7, :] = [[0, 1, 0], [1, 0, 0], [0, 0, -1]]\n    sym_group[8, :] = [[-1, 0, 0], [0, 0, -1], [0, -1, 0]]\n    sym_group[9, :] = [[-1, 0, 0], [0, 0, 1], [0, 1, 0]]\n    sym_group[10, :] = [[1, 0, 0], [0, 0, -1], [0, 1, 0]]\n    sym_group[11, :] = [[1, 0, 0], [0, 0, 1], [0, -1, 0]]\n    sym_group[12, :] = [[0, 1, 0], [0, 0, 1], [1, 0, 0]]\n    sym_group[13, :] = [[0, 1, 0], [0, 0, -1], [-1, 0, 0]]\n    sym_group[14, :] = [[0, -1, 0], [0, 0, 1], [-1, 0, 0]]\n    sym_group[15, :] = [[0, -1, 0], [0, 0, -1], [1, 0, 0]]\n    sym_group[16, :] = [[0, 0, 1], [1, 0, 0], [0, 1, 0]]\n    sym_group[17, :] = [[0, 0, 1], [-1, 0, 0], [0, -1, 0]]\n    sym_group[18, :] = [[0, 0, -1], [1, 0, 0], [0, -1, 0]]\n    sym_group[19, :] = [[0, 0, -1], [-1, 0, 0], [0, 1, 0]]\n    sym_group[20, :] = [[0, 0, -1], [0, -1, 0], [-1, 0, 0]]\n    sym_group[21, :] = [[0, 0, -1], [0, 1, 0], [1, 0, 0]]\n    sym_group[22, :] = [[0, 0, 1], [0, -1, 0], [1, 0, 0]]\n    sym_group[23, :] = [[0, 0, 1], [0, 1, 0], [-1, 0, 0]]\n\n    mat = np.atleast_2d(mat)\n    all_vectors = []\n    for sym in sym_group:\n        for vec in mat:\n            all_vectors.append(np.dot(sym, vec))\n    return np.unique(np.array(all_vectors), axis=0)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a copy of the structure with optionally new site properties and optionally sanitized site properties.", "response": "def copy(self):\n        \"\"\"\n        Convenience method to get a copy of the structure, with options to add\n        site properties.\n\n        Returns:\n            A copy of the Structure, with optionally new site_properties and\n            optionally sanitized.\n        \"\"\"\n        return GrainBoundary(self.lattice, self.species_and_occu, self.frac_coords,\n                             self.rotation_axis, self.rotation_angle, self.gb_plane,\n                             self.join_plane, self.init_cell, self.vacuum_thickness,\n                             self.ab_shift, self.site_properties, self.oriented_unit_cell)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a sorted copy of the structure.", "response": "def get_sorted_structure(self, key=None, reverse=False):\n        \"\"\"\n        Get a sorted copy of the structure. The parameters have the same\n        meaning as in list.sort. By default, sites are sorted by the\n        electronegativity of the species. Note that Slab has to override this\n        because of the different __init__ args.\n        Args:\n            key: Specifies a function of one argument that is used to extract\n                a comparison key from each list element: key=str.lower. The\n                default value is None (compare the elements directly).\n            reverse (bool): If set to True, then the list elements are sorted\n                as if each comparison were reversed.\n        \"\"\"\n        sites = sorted(self, key=key, reverse=reverse)\n        s = Structure.from_sites(sites)\n        return GrainBoundary(s.lattice, s.species_and_occu, s.frac_coords,\n                             self.rotation_axis, self.rotation_angle, self.gb_plane,\n                             self.join_plane, self.init_cell, self.vacuum_thickness,\n                             self.ab_shift, self.site_properties, self.oriented_unit_cell)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the sigma value of the current set of cell names.", "response": "def sigma(self):\n        \"\"\"\n        This method returns the sigma value of the gb.\n        If using 'quick_gen' to generate GB, this value is not valid.\n        \"\"\"\n        return int(round(self.oriented_unit_cell.volume / self.init_cell.volume))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef sigma_from_site_prop(self):\n        num_coi = 0\n        if None in self.site_properties['grain_label']:\n            raise RuntimeError('Site were merged, this property do not work')\n        for tag in self.site_properties['grain_label']:\n            if 'incident' in tag:\n                num_coi += 1\n        return int(round(self.num_sites / num_coi))", "response": "This method returns the sigma value of the gb from site properties."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the top grain of the GB.", "response": "def top_grain(self):\n        \"\"\"\n        return the top grain (Structure) of the GB.\n        \"\"\"\n        top_sites = []\n        for i, tag in enumerate(self.site_properties['grain_label']):\n            if 'top' in tag:\n                top_sites.append(self.sites[i])\n        return Structure.from_sites(top_sites)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef bottom_grain(self):\n        bottom_sites = []\n        for i, tag in enumerate(self.site_properties['grain_label']):\n            if 'bottom' in tag:\n                bottom_sites.append(self.sites[i])\n        return Structure.from_sites(bottom_sites)", "response": "Return the bottom grain of the GB."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a list of coincident sites.", "response": "def coincidents(self):\n        \"\"\"\n        return the a list of coincident sites.\n        \"\"\"\n        coincident_sites = []\n        for i, tag in enumerate(self.site_properties['grain_label']):\n            if 'incident' in tag:\n                coincident_sites.append(self.sites[i])\n        return coincident_sites"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef gb_from_parameters(self, rotation_axis, rotation_angle, expand_times=4, vacuum_thickness=0.0,\n                           ab_shift=[0, 0], normal=False, ratio=None, plane=None, max_search=20,\n                           tol_coi=1.e-8, rm_ratio=0.7, quick_gen=False):\n\n        \"\"\"\n        Args:\n           rotation_axis (list): Rotation axis of GB in the form of a list of integer\n                e.g.: [1, 1, 0]\n           rotation_angle (float, in unit of degree): rotation angle used to generate GB.\n                Make sure the angle is accurate enough. You can use the enum* functions\n                in this class to extract the accurate angle.\n                e.g.: The rotation angle of sigma 3 twist GB with the rotation axis\n                [1, 1, 1] and GB plane (1, 1, 1) can be 60.000000000 degree.\n                If you do not know the rotation angle, but know the sigma value, we have\n                provide the function get_rotation_angle_from_sigma which is able to return\n                all the rotation angles of sigma value you provided.\n           expand_times (int): The multiple times used to expand one unit grain to larger grain.\n                This is used to tune the grain length of GB to warrant that the two GBs in one\n                cell do not interact with each other. Default set to 4.\n           vacuum_thickness (float, in angstrom): The thickness of vacuum that you want to insert\n                between two grains of the GB. Default to 0.\n            ab_shift (list of float, in unit of a, b vectors of Gb): in plane shift of two grains\n            normal (logic):\n                determine if need to require the c axis of top grain (first transformation matrix)\n                perperdicular to the surface or not.\n                default to false.\n            ratio (list of integers):\n                    lattice axial ratio.\n                    For cubic system, ratio is not needed.\n                    For tetragonal system, ratio = [mu, mv], list of two integers,\n                    that is, mu/mv = c2/a2. If it is irrational, set it to none.\n                    For orthorhombic system, ratio = [mu, lam, mv], list of three integers,\n                    that is, mu:lam:mv = c2:b2:a2. If irrational for one axis, set it to None.\n                    e.g. mu:lam:mv = c2,None,a2, means b2 is irrational.\n                    For rhombohedral system, ratio = [mu, mv], list of two integers,\n                    that is, mu/mv is the ratio of (1+2*cos(alpha))/cos(alpha).\n                    If irrational, set it to None.\n                    For hexagonal system, ratio = [mu, mv], list of two integers,\n                    that is, mu/mv = c2/a2. If it is irrational, set it to none.\n                    This code also supplies a class method to generate the ratio from the\n                    structure (get_ratio). User can also make their own approximation and\n                    input the ratio directly.\n            plane (list): Grain boundary plane in the form of a list of integers\n                e.g.: [1, 2, 3]. If none, we set it as twist GB. The plane will be perpendicular\n                to the rotation axis.\n            max_search (int): max search for the GB lattice vectors that give the smallest GB\n                lattice. If normal is true, also max search the GB c vector that perpendicular\n                to the plane. For complex GB, if you want to speed up, you can reduce this value.\n                But too small of this value may lead to error.\n            tol_coi (float): tolerance to find the coincidence sites. When making approximations to\n                the ratio needed to generate the GB, you probably need to increase this tolerance to\n                obtain the correct number of coincidence sites. To check the number of coincidence\n                sites are correct or not, you can compare the generated Gb object's sigma_from_site_prop\n                with enum* sigma values (what user expected by input).\n            rm_ratio (float): the criteria to remove the atoms which are too close with each other.\n                rm_ratio*bond_length of bulk system is the criteria of bond length, below which the atom\n                will be removed. Default to 0.7.\n            quick_gen (bool): whether to quickly generate a supercell, if set to true, no need to\n                find the smallest cell.\n\n        Returns:\n           Grain boundary structure (gb object).\n               \"\"\"\n        lat_type = self.lat_type\n        # if the initial structure is primitive cell in cubic system,\n        # calculate the transformation matrix from its conventional cell\n        # to primitive cell, basically for bcc and fcc systems.\n        trans_cry = np.eye(3)\n        if lat_type == 'c':\n            analyzer = SpacegroupAnalyzer(self.initial_structure)\n            convention_cell = analyzer.get_conventional_standard_structure()\n            vol_ratio = self.initial_structure.volume / convention_cell.volume\n            # bcc primitive cell, belong to cubic system\n            if abs(vol_ratio - 0.5) < 1.e-3:\n                trans_cry = np.array([[0.5, 0.5, -0.5], [-0.5, 0.5, 0.5], [0.5, -0.5, 0.5]])\n                logger.info(\"Make sure this is for cubic with bcc primitive cell\")\n            # fcc primitive cell, belong to cubic system\n            elif abs(vol_ratio - 0.25) < 1.e-3:\n                trans_cry = np.array([[0.5, 0.5, 0], [0, 0.5, 0.5], [0.5, 0, 0.5]])\n                logger.info(\"Make sure this is for cubic with fcc primitive cell\")\n            else:\n                logger.info(\"Make sure this is for cubic with conventional cell\")\n        elif lat_type == 't':\n            logger.info(\"Make sure this is for tetragonal system\")\n            if ratio is None:\n                logger.info('Make sure this is for irrational c2/a2')\n            elif len(ratio) != 2:\n                raise RuntimeError('Tetragonal system needs correct c2/a2 ratio')\n        elif lat_type == 'o':\n            logger.info('Make sure this is for orthorhombic system')\n            if ratio is None:\n                raise RuntimeError('CSL does not exist if all axial ratios are irrational '\n                                   'for an orthorhombic system')\n            elif len(ratio) != 3:\n                raise RuntimeError('Orthorhombic system needs correct c2:b2:a2 ratio')\n        elif lat_type == 'h':\n            logger.info('Make sure this is for hexagonal system')\n            if ratio is None:\n                logger.info('Make sure this is for irrational c2/a2')\n            elif len(ratio) != 2:\n                raise RuntimeError('Hexagonal system needs correct c2/a2 ratio')\n        elif lat_type == 'r':\n            logger.info('Make sure this is for rhombohedral system')\n            if ratio is None:\n                logger.info('Make sure this is for irrational (1+2*cos(alpha)/cos(alpha) ratio')\n            elif len(ratio) != 2:\n                raise RuntimeError('Rhombohedral system needs correct '\n                                   '(1+2*cos(alpha)/cos(alpha) ratio')\n        else:\n            raise RuntimeError('Lattice type not implemented. This code works for cubic, '\n                               'tetragonal, orthorhombic, rhombehedral, hexagonal systems')\n\n        # transform four index notation to three index notation for hexagonal and rhombohedral\n        if len(rotation_axis) == 4:\n            u1 = rotation_axis[0]\n            v1 = rotation_axis[1]\n            w1 = rotation_axis[3]\n            if lat_type.lower() == 'h':\n                u = 2 * u1 + v1\n                v = 2 * v1 + u1\n                w = w1\n                rotation_axis = [u, v, w]\n            elif lat_type.lower() == 'r':\n                u = 2 * u1 + v1 + w1\n                v = v1 + w1 - u1\n                w = w1 - 2 * v1 - u1\n                rotation_axis = [u, v, w]\n\n        # make sure gcd(rotation_axis)==1\n        if reduce(gcd, rotation_axis) != 1:\n            rotation_axis = [int(round(x / reduce(gcd, rotation_axis))) for x in rotation_axis]\n        # transform four index notation to three index notation for plane\n        if plane is not None:\n            if len(plane) == 4:\n                u1 = plane[0]\n                v1 = plane[1]\n                w1 = plane[3]\n                plane = [u1, v1, w1]\n        # set the plane for grain boundary when plane is None.\n        if plane is None:\n            if lat_type.lower() == 'c':\n                plane = rotation_axis\n            else:\n                if lat_type.lower() == 'h':\n                    if ratio is None:\n                        c2_a2_ratio = 1\n                    else:\n                        c2_a2_ratio = ratio[0] / ratio[1]\n                    metric = np.array([[1, -0.5, 0], [-0.5, 1, 0], [0, 0, c2_a2_ratio]])\n                elif lat_type.lower() == 'r':\n                    if ratio is None:\n                        cos_alpha = 0.5\n                    else:\n                        cos_alpha = 1.0 / (ratio[0] / ratio[1] - 2)\n                    metric = np.array([[1, cos_alpha, cos_alpha], [cos_alpha, 1, cos_alpha],\n                                       [cos_alpha, cos_alpha, 1]])\n                elif lat_type.lower() == 't':\n                    if ratio is None:\n                        c2_a2_ratio = 1\n                    else:\n                        c2_a2_ratio = ratio[0] / ratio[1]\n                    metric = np.array([[1, 0, 0], [0, 1, 0], [0, 0, c2_a2_ratio]])\n                elif lat_type.lower() == 'o':\n                    for i in range(3):\n                        if ratio[i] is None:\n                            ratio[i] = 1\n                    metric = np.array([[1, 0, 0], [0, ratio[1] / ratio[2], 0],\n                                       [0, 0, ratio[0] / ratio[2]]])\n                else:\n                    raise RuntimeError('Lattice type has not implemented.')\n\n                plane = np.matmul(rotation_axis, metric)\n                fractions = [Fraction(x).limit_denominator() for x in plane]\n                least_mul = reduce(lcm, [f.denominator for f in fractions])\n                plane = [int(round(x * least_mul)) for x in plane]\n\n        if reduce(gcd, plane) != 1:\n            index = reduce(gcd, plane)\n            plane = [int(round(x / index)) for x in plane]\n\n        t1, t2 = self.get_trans_mat(r_axis=rotation_axis, angle=rotation_angle, normal=normal,\n                                    trans_cry=trans_cry, lat_type=lat_type, ratio=ratio,\n                                    surface=plane, max_search=max_search, quick_gen=quick_gen)\n\n        # find the join_plane\n        if lat_type.lower() != 'c':\n            if lat_type.lower() == 'h':\n                if ratio is None:\n                    mu, mv = [1, 1]\n                else:\n                    mu, mv = ratio\n                trans_cry1 = np.array([[1, 0, 0], [-0.5, np.sqrt(3.0) / 2.0, 0],\n                                       [0, 0, np.sqrt(mu / mv)]])\n            elif lat_type.lower() == 'r':\n                if ratio is None:\n                    c2_a2_ratio = 1\n                else:\n                    mu, mv = ratio\n                    c2_a2_ratio = 3.0 / (2 - 6 * mv / mu)\n                trans_cry1 = np.array([[0.5, np.sqrt(3.0) / 6.0, 1.0 / 3 * np.sqrt(c2_a2_ratio)],\n                                       [-0.5, np.sqrt(3.0) / 6.0, 1.0 / 3 * np.sqrt(c2_a2_ratio)],\n                                       [0, -1 * np.sqrt(3.0) / 3.0, 1.0 / 3 * np.sqrt(c2_a2_ratio)]])\n            else:\n                if lat_type.lower() == 't':\n                    if ratio is None:\n                        mu, mv = [1, 1]\n                    else:\n                        mu, mv = ratio\n                    lam = mv\n                elif lat_type.lower() == 'o':\n                    new_ratio = [1 if v is None else v for v in ratio]\n                    mu, lam, mv = new_ratio\n                trans_cry1 = np.array([[1, 0, 0], [0, np.sqrt(lam / mv), 0], [0, 0, np.sqrt(mu / mv)]])\n        else:\n            trans_cry1 = trans_cry\n        grain_matrix = np.dot(t2, trans_cry1)\n        plane_init = np.cross(grain_matrix[0], grain_matrix[1])\n        if lat_type.lower() != 'c':\n            plane_init = np.dot(plane_init, trans_cry1.T)\n        join_plane = self.vec_to_surface(plane_init)\n\n        parent_structure = self.initial_structure.copy()\n        # calculate the bond_length in bulk system.\n        if len(parent_structure) == 1:\n            temp_str = parent_structure.copy()\n            temp_str.make_supercell([1, 1, 2])\n            distance = temp_str.distance_matrix\n        else:\n            distance = parent_structure.distance_matrix\n        bond_length = np.min(distance[np.nonzero(distance)])\n\n        # top grain\n        top_grain = fix_pbc(parent_structure * t1)\n\n        # obtain the smallest oriended cell\n        if normal and not quick_gen:\n            t_temp = self.get_trans_mat(r_axis=rotation_axis, angle=rotation_angle, normal=False,\n                                        trans_cry=trans_cry, lat_type=lat_type, ratio=ratio,\n                                        surface=plane, max_search=max_search)\n            oriended_unit_cell = fix_pbc(parent_structure * t_temp[0])\n            t_matrix = oriended_unit_cell.lattice.matrix\n            normal_v_plane = np.cross(t_matrix[0], t_matrix[1])\n            unit_normal_v = normal_v_plane / np.linalg.norm(normal_v_plane)\n            unit_ab_adjust = (t_matrix[2] - np.dot(unit_normal_v, t_matrix[2]) * unit_normal_v) \\\n                             / np.dot(unit_normal_v, t_matrix[2])\n        else:\n            oriended_unit_cell = top_grain.copy()\n            unit_ab_adjust = 0.0\n\n        # bottom grain, using top grain's lattice matrix\n        bottom_grain = fix_pbc(parent_structure * t2, top_grain.lattice.matrix)\n\n        # label both grains with 'top','bottom','top_incident','bottom_incident'\n        n_sites = top_grain.num_sites\n        t_and_b = Structure(top_grain.lattice, top_grain.species + bottom_grain.species,\n                            list(top_grain.frac_coords) + list(bottom_grain.frac_coords))\n        t_and_b_dis = t_and_b.lattice.get_all_distances(t_and_b.frac_coords[0:n_sites],\n                                                        t_and_b.frac_coords[n_sites:n_sites * 2])\n        index_incident = np.nonzero(t_and_b_dis < np.min(t_and_b_dis) + tol_coi)\n\n        top_labels = []\n        for i in range(n_sites):\n            if i in index_incident[0]:\n                top_labels.append('top_incident')\n            else:\n                top_labels.append('top')\n        bottom_labels = []\n        for i in range(n_sites):\n            if i in index_incident[1]:\n                bottom_labels.append('bottom_incident')\n            else:\n                bottom_labels.append('bottom')\n        top_grain = Structure(Lattice(top_grain.lattice.matrix), top_grain.species,\n                              top_grain.frac_coords, site_properties={'grain_label': top_labels})\n        bottom_grain = Structure(Lattice(bottom_grain.lattice.matrix), bottom_grain.species,\n                                 bottom_grain.frac_coords, site_properties={'grain_label': bottom_labels})\n\n        # expand both grains\n        top_grain.make_supercell([1, 1, expand_times])\n        bottom_grain.make_supercell([1, 1, expand_times])\n        top_grain = fix_pbc(top_grain)\n        bottom_grain = fix_pbc(bottom_grain)\n\n        # determine the top-grain location.\n        edge_b = 1.0 - max(bottom_grain.frac_coords[:, 2])\n        edge_t = 1.0 - max(top_grain.frac_coords[:, 2])\n        c_adjust = (edge_t - edge_b) / 2.0\n\n        # construct all species\n        all_species = []\n        all_species.extend([site.specie for site in bottom_grain])\n        all_species.extend([site.specie for site in top_grain])\n\n        half_lattice = top_grain.lattice\n        # calculate translation vector, perpendicular to the plane\n        normal_v_plane = np.cross(half_lattice.matrix[0], half_lattice.matrix[1])\n        unit_normal_v = normal_v_plane / np.linalg.norm(normal_v_plane)\n        translation_v = unit_normal_v * vacuum_thickness\n\n        # construct the final lattice\n        whole_matrix_no_vac = np.array(half_lattice.matrix)\n        whole_matrix_no_vac[2] = half_lattice.matrix[2] * 2\n        whole_matrix_with_vac = whole_matrix_no_vac.copy()\n        whole_matrix_with_vac[2] = whole_matrix_no_vac[2] + translation_v * 2\n        whole_lat = Lattice(whole_matrix_with_vac)\n\n        # construct the coords, move top grain with translation_v\n        all_coords = []\n        grain_labels = bottom_grain.site_properties['grain_label'] \\\n                       + top_grain.site_properties['grain_label']\n        for site in bottom_grain:\n            all_coords.append(site.coords)\n        for site in top_grain:\n            all_coords.append(site.coords + half_lattice.matrix[2] * (1 + c_adjust) +\n                              unit_ab_adjust * np.linalg.norm(half_lattice.matrix[2] * (1 + c_adjust)) +\n                              translation_v + ab_shift[0] * whole_matrix_with_vac[0] +\n                              ab_shift[1] * whole_matrix_with_vac[1])\n\n        gb_with_vac = Structure(whole_lat, all_species, all_coords,\n                                coords_are_cartesian=True,\n                                site_properties={'grain_label': grain_labels})\n        # merge closer atoms. extract near gb atoms.\n        cos_c_norm_plane = np.dot(unit_normal_v, whole_matrix_with_vac[2]) / whole_lat.c\n        range_c_len = abs(bond_length / cos_c_norm_plane / whole_lat.c)\n        sites_near_gb = []\n        sites_away_gb = []\n        for site in gb_with_vac.sites:\n            if site.frac_coords[2] < range_c_len or site.frac_coords[2] > 1 - range_c_len \\\n                    or (site.frac_coords[2] > 0.5 - range_c_len and site.frac_coords[2] < 0.5 + range_c_len):\n                sites_near_gb.append(site)\n            else:\n                sites_away_gb.append(site)\n        if len(sites_near_gb) >= 1:\n            s_near_gb = Structure.from_sites(sites_near_gb)\n            s_near_gb.merge_sites(tol=bond_length * rm_ratio, mode='d')\n            all_sites = sites_away_gb + s_near_gb.sites\n            gb_with_vac = Structure.from_sites(all_sites)\n\n        return GrainBoundary(whole_lat, gb_with_vac.species, gb_with_vac.cart_coords, rotation_axis,\n                             rotation_angle, plane, join_plane, self.initial_structure,\n                             vacuum_thickness, ab_shift, site_properties=gb_with_vac.site_properties,\n                             oriented_unit_cell=oriended_unit_cell,\n                             coords_are_cartesian=True)", "response": "Generate a new object from parameters in order to generate a new object."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the ratio needed for the GB generator input.", "response": "def get_ratio(self, max_denominator=5, index_none=None):\n        \"\"\"\n        find the axial ratio needed for GB generator input.\n        Args:\n            max_denominator (int): the maximum denominator for\n                the computed ratio, default to be 5.\n            index_none (int): specify the irrational axis.\n                0-a, 1-b, 2-c. Only may be needed for orthorombic system.\n        Returns:\n               axial ratio needed for GB generator (list of integers).\n\n        \"\"\"\n        structure = self.initial_structure\n        lat_type = self.lat_type\n        if lat_type == 't' or lat_type == 'h':\n            # For tetragonal and hexagonal system, ratio = c2 / a2.\n            a, c = (structure.lattice.a, structure.lattice.c)\n            if c > a:\n                frac = Fraction(c ** 2 / a ** 2).limit_denominator(max_denominator)\n                ratio = [frac.numerator, frac.denominator]\n            else:\n                frac = Fraction(a ** 2 / c ** 2).limit_denominator(max_denominator)\n                ratio = [frac.denominator, frac.numerator]\n        elif lat_type == 'r':\n            # For rhombohedral system, ratio = (1 + 2 * cos(alpha)) / cos(alpha).\n            cos_alpha = cos(structure.lattice.alpha / 180 * np.pi)\n            frac = Fraction((1 + 2 * cos_alpha) / cos_alpha).limit_denominator(max_denominator)\n            ratio = [frac.numerator, frac.denominator]\n        elif lat_type == 'o':\n            # For orthorhombic system, ratio = c2:b2:a2.If irrational for one axis, set it to None.\n            ratio = [None] * 3\n            lat = (structure.lattice.c, structure.lattice.b, structure.lattice.a)\n            index = [0, 1, 2]\n            if index_none is None:\n                min_index = np.argmin(lat)\n                index.pop(min_index)\n                frac1 = Fraction(lat[index[0]] ** 2 / lat[min_index] ** 2).limit_denominator(max_denominator)\n                frac2 = Fraction(lat[index[1]] ** 2 / lat[min_index] ** 2).limit_denominator(max_denominator)\n                com_lcm = lcm(frac1.denominator, frac2.denominator)\n                ratio[min_index] = com_lcm\n                ratio[index[0]] = frac1.numerator * int(round((com_lcm / frac1.denominator)))\n                ratio[index[1]] = frac2.numerator * int(round((com_lcm / frac2.denominator)))\n            else:\n                index.pop(index_none)\n                if (lat[index[0]] > lat[index[1]]):\n                    frac = Fraction(lat[index[0]] ** 2 / lat[index[1]] ** 2).limit_denominator(max_denominator)\n                    ratio[index[0]] = frac.numerator\n                    ratio[index[1]] = frac.denominator\n                else:\n                    frac = Fraction(lat[index[1]] ** 2 / lat[index[0]] ** 2).limit_denominator(max_denominator)\n                    ratio[index[1]] = frac.numerator\n                    ratio[index[0]] = frac.denominator\n        elif lat_type == 'c':\n            raise RuntimeError('Cubic system does not need axial ratio.')\n        else:\n            raise RuntimeError('Lattice type not implemented.')\n        return ratio"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nfind the two transformation matrix for each grain from given rotation axis, GB plane, rotation angle and corresponding ratio (see explanation for ratio below). The structure of each grain can be obtained by applying the corresponding transformation matrix to the conventional cell. The algorithm for this code is from reference, Acta Cryst, A32,783(1976). Args: r_axis (list of three integers, e.g. u, v, w or four integers, e.g. u, v, t, w for hex/rho system only): the rotation axis of the grain boundary. angle (float, in unit of degree) : the rotation angle of the grain boundary normal (logic): determine if need to require the c axis of one grain associated with the first transformation matrix perperdicular to the surface or not. default to false. trans_cry (3 by 3 array): if the structure given are primitive cell in cubic system, e.g. bcc or fcc system, trans_cry is the transformation matrix from its conventional cell to the primitive cell. lat_type ( one character): 'c' or 'C': cubic system 't' or 'T': tetragonal system 'o' or 'O': orthorhombic system 'h' or 'H': hexagonal system 'r' or 'R': rhombohedral system default to cubic system ratio (list of integers): lattice axial ratio. For cubic system, ratio is not needed. For tetragonal system, ratio = [mu, mv], list of two integers, that is, mu/mv = c2/a2. If it is irrational, set it to none. For orthorhombic system, ratio = [mu, lam, mv], list of three integers, that is, mu:lam:mv = c2:b2:a2. If irrational for one axis, set it to None. e.g. mu:lam:mv = c2,None,a2, means b2 is irrational. For rhombohedral system, ratio = [mu, mv], list of two integers, that is, mu/mv is the ratio of (1+2*cos(alpha)/cos(alpha). If irrational, set it to None. For hexagonal system, ratio = [mu, mv], list of two integers, that is, mu/mv = c2/a2. If it is irrational, set it to none. surface (list of three integers, e.g. h, k, l or four integers, e.g. h, k, i, l for hex/rho system only): the miller index of grain boundary plane, with the format of [h,k,l] if surface is not given, the default is perpendicular to r_axis, which is a twist grain boundary. max_search (int): max search for the GB lattice vectors that give the smallest GB lattice. If normal is true, also max search the GB c vector that perpendicular to the plane. quick_gen (bool): whether to quickly generate a supercell, if set to true, no need to find the smallest cell. Returns: t1 (3 by 3 integer array): The transformation array for one grain. t2 (3 by 3 integer array): The transformation array for the other grain", "response": "def get_trans_mat(r_axis, angle, normal=False, trans_cry=np.eye(3), lat_type='c',\n                      ratio=None, surface=None, max_search=20, quick_gen=False):\n        \"\"\"\n        Find the two transformation matrix for each grain from given rotation axis,\n        GB plane, rotation angle and corresponding ratio (see explanation for ratio\n        below).\n        The structure of each grain can be obtained by applying the corresponding\n        transformation matrix to the conventional cell.\n        The algorithm for this code is from reference, Acta Cryst, A32,783(1976).\n\n        Args:\n            r_axis (list of three integers, e.g. u, v, w\n                    or four integers, e.g. u, v, t, w for hex/rho system only):\n                    the rotation axis of the grain boundary.\n            angle (float, in unit of degree) :\n                    the rotation angle of the grain boundary\n            normal (logic):\n                    determine if need to require the c axis of one grain associated with\n                    the first transformation matrix perperdicular to the surface or not.\n                    default to false.\n            trans_cry (3 by 3 array):\n                    if the structure given are primitive cell in cubic system, e.g.\n                    bcc or fcc system, trans_cry is the transformation matrix from its\n                    conventional cell to the primitive cell.\n            lat_type ( one character):\n                    'c' or 'C': cubic system\n                     't' or 'T': tetragonal system\n                     'o' or 'O': orthorhombic system\n                     'h' or 'H': hexagonal system\n                     'r' or 'R': rhombohedral system\n                     default to cubic system\n            ratio (list of integers):\n                    lattice axial ratio.\n                    For cubic system, ratio is not needed.\n                    For tetragonal system, ratio = [mu, mv], list of two integers,\n                    that is, mu/mv = c2/a2. If it is irrational, set it to none.\n                    For orthorhombic system, ratio = [mu, lam, mv], list of three integers,\n                    that is, mu:lam:mv = c2:b2:a2. If irrational for one axis, set it to None.\n                    e.g. mu:lam:mv = c2,None,a2, means b2 is irrational.\n                    For rhombohedral system, ratio = [mu, mv], list of two integers,\n                    that is, mu/mv is the ratio of (1+2*cos(alpha)/cos(alpha).\n                    If irrational, set it to None.\n                    For hexagonal system, ratio = [mu, mv], list of two integers,\n                    that is, mu/mv = c2/a2. If it is irrational, set it to none.\n            surface (list of three integers, e.g. h, k, l\n                     or four integers, e.g. h, k, i, l for hex/rho system only):\n                    the miller index of grain boundary plane, with the format of [h,k,l]\n                    if surface is not given, the default is perpendicular to r_axis, which is\n                    a twist grain boundary.\n            max_search (int): max search for the GB lattice vectors that give the smallest GB\n                lattice. If normal is true, also max search the GB c vector that perpendicular\n                to the plane.\n            quick_gen (bool): whether to quickly generate a supercell, if set to true, no need to\n                find the smallest cell.\n        Returns:\n            t1 (3 by 3 integer array):\n                    The transformation array for one grain.\n            t2 (3 by 3 integer array):\n                    The transformation array for the other grain\n        \"\"\"\n        # transform four index notation to three index notation\n        if len(r_axis) == 4:\n            u1 = r_axis[0]\n            v1 = r_axis[1]\n            w1 = r_axis[3]\n            if lat_type.lower() == 'h':\n                u = 2 * u1 + v1\n                v = 2 * v1 + u1\n                w = w1\n                r_axis = [u, v, w]\n            elif lat_type.lower() == 'r':\n                u = 2 * u1 + v1 + w1\n                v = v1 + w1 - u1\n                w = w1 - 2 * v1 - u1\n                r_axis = [u, v, w]\n\n        # make sure gcd(r_axis)==1\n        if reduce(gcd, r_axis) != 1:\n            r_axis = [int(round(x / reduce(gcd, r_axis))) for x in r_axis]\n\n        if surface is not None:\n            if len(surface) == 4:\n                u1 = surface[0]\n                v1 = surface[1]\n                w1 = surface[3]\n                surface = [u1, v1, w1]\n        # set the surface for grain boundary.\n        if surface is None:\n            if lat_type.lower() == 'c':\n                surface = r_axis\n            else:\n                if lat_type.lower() == 'h':\n                    if ratio is None:\n                        c2_a2_ratio = 1\n                    else:\n                        c2_a2_ratio = ratio[0] / ratio[1]\n                    metric = np.array([[1, -0.5, 0], [-0.5, 1, 0], [0, 0, c2_a2_ratio]])\n                elif lat_type.lower() == 'r':\n                    if ratio is None:\n                        cos_alpha = 0.5\n                    else:\n                        cos_alpha = 1.0 / (ratio[0] / ratio[1] - 2)\n                    metric = np.array([[1, cos_alpha, cos_alpha], [cos_alpha, 1, cos_alpha],\n                                       [cos_alpha, cos_alpha, 1]])\n                elif lat_type.lower() == 't':\n                    if ratio is None:\n                        c2_a2_ratio = 1\n                    else:\n                        c2_a2_ratio = ratio[0] / ratio[1]\n                    metric = np.array([[1, 0, 0], [0, 1, 0], [0, 0, c2_a2_ratio]])\n                elif lat_type.lower() == 'o':\n                    for i in range(3):\n                        if ratio[i] is None:\n                            ratio[i] = 1\n                    metric = np.array([[1, 0, 0], [0, ratio[1] / ratio[2], 0],\n                                       [0, 0, ratio[0] / ratio[2]]])\n                else:\n                    raise RuntimeError('Lattice type has not implemented.')\n\n                surface = np.matmul(r_axis, metric)\n                fractions = [Fraction(x).limit_denominator() for x in surface]\n                least_mul = reduce(lcm, [f.denominator for f in fractions])\n                surface = [int(round(x * least_mul)) for x in surface]\n\n        if reduce(gcd, surface) != 1:\n            index = reduce(gcd, surface)\n            surface = [int(round(x / index)) for x in surface]\n\n        if lat_type.lower() == 'h':\n            # set the value for u,v,w,mu,mv,m,n,d,x\n            # check the reference for the meaning of these parameters\n            u, v, w = r_axis\n            # make sure mu, mv are coprime integers.\n            if ratio is None:\n                mu, mv = [1, 1]\n                if w != 0:\n                    if u != 0 or (v != 0):\n                        raise RuntimeError('For irrational c2/a2, CSL only exist for [0,0,1] '\n                                           'or [u,v,0] and m = 0')\n            else:\n                mu, mv = ratio\n            if gcd(mu, mv) != 1:\n                temp = gcd(mu, mv)\n                mu = int(round(mu / temp))\n                mv = int(round(mv / temp))\n            d = (u ** 2 + v ** 2 - u * v) * mv + w ** 2 * mu\n            if abs(angle - 180.0) < 1.e0:\n                m = 0\n                n = 1\n            else:\n                fraction = Fraction(np.tan(angle / 2 / 180.0 * np.pi) /\n                                    np.sqrt(float(d) / 3.0 / mu)).limit_denominator()\n                m = fraction.denominator\n                n = fraction.numerator\n\n            # construct the rotation matrix, check reference for details\n            r_list = [(u ** 2 * mv - v ** 2 * mv - w ** 2 * mu) * n ** 2 +\n                      2 * w * mu * m * n + 3 * mu * m ** 2,\n                      (2 * v - u) * u * mv * n ** 2 - 4 * w * mu * m * n,\n                      2 * u * w * mu * n ** 2 + 2 * (2 * v - u) * mu * m * n,\n                      (2 * u - v) * v * mv * n ** 2 + 4 * w * mu * m * n,\n                      (v ** 2 * mv - u ** 2 * mv - w ** 2 * mu) * n ** 2 -\n                      2 * w * mu * m * n + 3 * mu * m ** 2,\n                      2 * v * w * mu * n ** 2 - 2 * (2 * u - v) * mu * m * n,\n                      (2 * u - v) * w * mv * n ** 2 - 3 * v * mv * m * n,\n                      (2 * v - u) * w * mv * n ** 2 + 3 * u * mv * m * n,\n                      (w ** 2 * mu - u ** 2 * mv - v ** 2 * mv + u * v * mv) *\n                      n ** 2 + 3 * mu * m ** 2]\n            m = -1 * m\n            r_list_inv = [(u ** 2 * mv - v ** 2 * mv - w ** 2 * mu) * n ** 2 +\n                          2 * w * mu * m * n + 3 * mu * m ** 2,\n                          (2 * v - u) * u * mv * n ** 2 - 4 * w * mu * m * n,\n                          2 * u * w * mu * n ** 2 + 2 * (2 * v - u) * mu * m * n,\n                          (2 * u - v) * v * mv * n ** 2 + 4 * w * mu * m * n,\n                          (v ** 2 * mv - u ** 2 * mv - w ** 2 * mu) * n ** 2 -\n                          2 * w * mu * m * n + 3 * mu * m ** 2,\n                          2 * v * w * mu * n ** 2 - 2 * (2 * u - v) * mu * m * n,\n                          (2 * u - v) * w * mv * n ** 2 - 3 * v * mv * m * n,\n                          (2 * v - u) * w * mv * n ** 2 + 3 * u * mv * m * n,\n                          (w ** 2 * mu - u ** 2 * mv - v ** 2 * mv + u * v * mv) *\n                          n ** 2 + 3 * mu * m ** 2]\n            m = -1 * m\n            F = 3 * mu * m ** 2 + d * n ** 2\n            all_list = r_list + r_list_inv + [F]\n            com_fac = reduce(gcd, all_list)\n            sigma = F / com_fac\n            r_matrix = (np.array(r_list) / com_fac / sigma).reshape(3, 3)\n        elif lat_type.lower() == 'r':\n            # set the value for u,v,w,mu,mv,m,n,d\n            # check the reference for the meaning of these parameters\n            u, v, w = r_axis\n            # make sure mu, mv are coprime integers.\n            if ratio is None:\n                mu, mv = [1, 1]\n                if u + v + w != 0:\n                    if u != v or u != w:\n                        raise RuntimeError('For irrational ratio_alpha, CSL only exist for [1,1,1]'\n                                           'or [u, v, -(u+v)] and m =0')\n            else:\n                mu, mv = ratio\n            if gcd(mu, mv) != 1:\n                temp = gcd(mu, mv)\n                mu = int(round(mu / temp))\n                mv = int(round(mv / temp))\n            d = (u ** 2 + v ** 2 + w ** 2) * (mu - 2 * mv) + \\\n                2 * mv * (v * w + w * u + u * v)\n            if abs(angle - 180.0) < 1.e0:\n                m = 0\n                n = 1\n            else:\n                fraction = Fraction(np.tan(angle / 2 / 180.0 * np.pi) /\n                                    np.sqrt(float(d) / mu)).limit_denominator()\n                m = fraction.denominator\n                n = fraction.numerator\n\n            # construct the rotation matrix, check reference for details\n            r_list = [(mu - 2 * mv) * (u ** 2 - v ** 2 - w ** 2) * n ** 2 +\n                      2 * mv * (v - w) * m * n - 2 * mv * v * w * n ** 2 +\n                      mu * m ** 2,\n                      2 * (mv * u * n * (w * n + u * n - m) - (mu - mv) *\n                           m * w * n + (mu - 2 * mv) * u * v * n ** 2),\n                      2 * (mv * u * n * (v * n + u * n + m) + (mu - mv) *\n                           m * v * n + (mu - 2 * mv) * w * u * n ** 2),\n                      2 * (mv * v * n * (w * n + v * n + m) + (mu - mv) *\n                           m * w * n + (mu - 2 * mv) * u * v * n ** 2),\n                      (mu - 2 * mv) * (v ** 2 - w ** 2 - u ** 2) * n ** 2 +\n                      2 * mv * (w - u) * m * n - 2 * mv * u * w * n ** 2 +\n                      mu * m ** 2,\n                      2 * (mv * v * n * (v * n + u * n - m) - (mu - mv) *\n                           m * u * n + (mu - 2 * mv) * w * v * n ** 2),\n                      2 * (mv * w * n * (w * n + v * n - m) - (mu - mv) *\n                           m * v * n + (mu - 2 * mv) * w * u * n ** 2),\n                      2 * (mv * w * n * (w * n + u * n + m) + (mu - mv) *\n                           m * u * n + (mu - 2 * mv) * w * v * n ** 2),\n                      (mu - 2 * mv) * (w ** 2 - u ** 2 - v ** 2) * n ** 2 +\n                      2 * mv * (u - v) * m * n - 2 * mv * u * v * n ** 2 +\n                      mu * m ** 2]\n            m = -1 * m\n            r_list_inv = [(mu - 2 * mv) * (u ** 2 - v ** 2 - w ** 2) * n ** 2 +\n                          2 * mv * (v - w) * m * n - 2 * mv * v * w * n ** 2 +\n                          mu * m ** 2,\n                          2 * (mv * u * n * (w * n + u * n - m) - (mu - mv) *\n                               m * w * n + (mu - 2 * mv) * u * v * n ** 2),\n                          2 * (mv * u * n * (v * n + u * n + m) + (mu - mv) *\n                               m * v * n + (mu - 2 * mv) * w * u * n ** 2),\n                          2 * (mv * v * n * (w * n + v * n + m) + (mu - mv) *\n                               m * w * n + (mu - 2 * mv) * u * v * n ** 2),\n                          (mu - 2 * mv) * (v ** 2 - w ** 2 - u ** 2) * n ** 2 +\n                          2 * mv * (w - u) * m * n - 2 * mv * u * w * n ** 2 +\n                          mu * m ** 2,\n                          2 * (mv * v * n * (v * n + u * n - m) - (mu - mv) *\n                               m * u * n + (mu - 2 * mv) * w * v * n ** 2),\n                          2 * (mv * w * n * (w * n + v * n - m) - (mu - mv) *\n                               m * v * n + (mu - 2 * mv) * w * u * n ** 2),\n                          2 * (mv * w * n * (w * n + u * n + m) + (mu - mv) *\n                               m * u * n + (mu - 2 * mv) * w * v * n ** 2),\n                          (mu - 2 * mv) * (w ** 2 - u ** 2 - v ** 2) * n ** 2 +\n                          2 * mv * (u - v) * m * n - 2 * mv * u * v * n ** 2 +\n                          mu * m ** 2]\n            m = -1 * m\n            F = mu * m ** 2 + d * n ** 2\n            all_list = r_list_inv + r_list + [F]\n            com_fac = reduce(gcd, all_list)\n            sigma = F / com_fac\n            r_matrix = (np.array(r_list) / com_fac / sigma).reshape(3, 3)\n        else:\n            u, v, w = r_axis\n            if lat_type.lower() == 'c':\n                mu = 1\n                lam = 1\n                mv = 1\n            elif lat_type.lower() == 't':\n                if ratio is None:\n                    mu, mv = [1, 1]\n                    if w != 0:\n                        if u != 0 or (v != 0):\n                            raise RuntimeError('For irrational c2/a2, CSL only exist for [0,0,1] '\n                                               'or [u,v,0] and m = 0')\n                else:\n                    mu, mv = ratio\n                lam = mv\n            elif lat_type.lower() == 'o':\n                if None in ratio:\n                    mu, lam, mv = ratio\n                    non_none = [i for i in ratio if i is not None]\n                    if len(non_none) < 2:\n                        raise RuntimeError('No CSL exist for two irrational numbers')\n                    non1, non2 = non_none\n                    if mu is None:\n                        lam = non1\n                        mv = non2\n                        mu = 1\n                        if w != 0:\n                            if u != 0 or (v != 0):\n                                raise RuntimeError('For irrational c2, CSL only exist for [0,0,1] '\n                                                   'or [u,v,0] and m = 0')\n                    elif lam is None:\n                        mu = non1\n                        mv = non2\n                        lam = 1\n                        if v != 0:\n                            if u != 0 or (w != 0):\n                                raise RuntimeError('For irrational b2, CSL only exist for [0,1,0] '\n                                                   'or [u,0,w] and m = 0')\n                    elif mv is None:\n                        mu = non1\n                        lam = non2\n                        mv = 1\n                        if u != 0:\n                            if w != 0 or (v != 0):\n                                raise RuntimeError('For irrational a2, CSL only exist for [1,0,0] '\n                                                   'or [0,v,w] and m = 0')\n                else:\n                    mu, lam, mv = ratio\n                    if u == 0 and v == 0:\n                        mu = 1\n                    if u == 0 and w == 0:\n                        lam = 1\n                    if v == 0 and w == 0:\n                        mv = 1\n\n            # make sure mu, lambda, mv are coprime integers.\n            if reduce(gcd, [mu, lam, mv]) != 1:\n                temp = reduce(gcd, [mu, lam, mv])\n                mu = int(round(mu / temp))\n                mv = int(round(mv / temp))\n                lam = int(round(lam / temp))\n            d = (mv * u ** 2 + lam * v ** 2) * mv + w ** 2 * mu * mv\n            if abs(angle - 180.0) < 1.e0:\n                m = 0\n                n = 1\n            else:\n                fraction = Fraction(np.tan(angle / 2 / 180.0 * np.pi) /\n                                    np.sqrt(d / mu / lam)).limit_denominator()\n                m = fraction.denominator\n                n = fraction.numerator\n            r_list = [(u ** 2 * mv * mv - lam * v ** 2 * mv -\n                       w ** 2 * mu * mv) * n ** 2 + lam * mu * m ** 2,\n                      2 * lam * (v * u * mv * n ** 2 - w * mu * m * n),\n                      2 * mu * (u * w * mv * n ** 2 + v * lam * m * n),\n                      2 * mv * (u * v * mv * n ** 2 + w * mu * m * n),\n                      (v ** 2 * mv * lam - u ** 2 * mv * mv -\n                       w ** 2 * mu * mv) * n ** 2 + lam * mu * m ** 2,\n                      2 * mv * mu * (v * w * n ** 2 - u * m * n),\n                      2 * mv * (u * w * mv * n ** 2 - v * lam * m * n),\n                      2 * lam * mv * (v * w * n ** 2 + u * m * n),\n                      (w ** 2 * mu * mv - u ** 2 * mv * mv -\n                       v ** 2 * mv * lam) * n ** 2 + lam * mu * m ** 2]\n            m = -1 * m\n            r_list_inv = [(u ** 2 * mv * mv - lam * v ** 2 * mv -\n                           w ** 2 * mu * mv) * n ** 2 + lam * mu * m ** 2,\n                          2 * lam * (v * u * mv * n ** 2 - w * mu * m * n),\n                          2 * mu * (u * w * mv * n ** 2 + v * lam * m * n),\n                          2 * mv * (u * v * mv * n ** 2 + w * mu * m * n),\n                          (v ** 2 * mv * lam - u ** 2 * mv * mv -\n                           w ** 2 * mu * mv) * n ** 2 + lam * mu * m ** 2,\n                          2 * mv * mu * (v * w * n ** 2 - u * m * n),\n                          2 * mv * (u * w * mv * n ** 2 - v * lam * m * n),\n                          2 * lam * mv * (v * w * n ** 2 + u * m * n),\n                          (w ** 2 * mu * mv - u ** 2 * mv * mv -\n                           v ** 2 * mv * lam) * n ** 2 + lam * mu * m ** 2]\n            m = -1 * m\n            F = mu * lam * m ** 2 + d * n ** 2\n            all_list = r_list + r_list_inv + [F]\n            com_fac = reduce(gcd, all_list)\n            sigma = F / com_fac\n            r_matrix = (np.array(r_list) / com_fac / sigma).reshape(3, 3)\n\n        if (sigma > 1000):\n            raise RuntimeError('Sigma >1000 too large. Are you sure what you are doing, '\n                               'Please check the GB if exist')\n        # transform surface, r_axis, r_matrix in terms of primitive lattice\n        surface = np.matmul(surface, np.transpose(trans_cry))\n        fractions = [Fraction(x).limit_denominator() for x in surface]\n        least_mul = reduce(lcm, [f.denominator for f in fractions])\n        surface = [int(round(x * least_mul)) for x in surface]\n        if reduce(gcd, surface) != 1:\n            index = reduce(gcd, surface)\n            surface = [int(round(x / index)) for x in surface]\n        r_axis = np.rint(np.matmul(r_axis, np.linalg.inv(trans_cry))).astype(int)\n        if reduce(gcd, r_axis) != 1:\n            r_axis = [int(round(x / reduce(gcd, r_axis))) for x in r_axis]\n        r_matrix = np.dot(np.dot(np.linalg.inv(trans_cry.T), r_matrix), trans_cry.T)\n        # set one vector of the basis to the rotation axis direction, and\n        # obtain the corresponding transform matrix\n        eye = np.eye(3, dtype=np.int)\n        for h in range(3):\n            if abs(r_axis[h]) != 0:\n                eye[h] = np.array(r_axis)\n                k = h + 1 if h + 1 < 3 else abs(2 - h)\n                l = h + 2 if h + 2 < 3 else abs(1 - h)\n                break\n        trans = eye.T\n        new_rot = np.array(r_matrix)\n\n        # with the rotation matrix to construct the CSL lattice, check reference for details\n        fractions = [Fraction(x).limit_denominator() for x in new_rot[:, k]]\n        least_mul = reduce(lcm, [f.denominator for f in fractions])\n        scale = np.zeros((3, 3))\n        scale[h, h] = 1\n        scale[k, k] = least_mul\n        scale[l, l] = sigma / least_mul\n        for i in range(least_mul):\n            check_int = i * new_rot[:, k] + (sigma / least_mul) * new_rot[:, l]\n            if all([np.round(x, 5).is_integer() for x in list(check_int)]):\n                n_final = i\n                break\n        try:\n            n_final\n        except NameError:\n            raise RuntimeError('Something is wrong. Check if this GB exists or not')\n        scale[k, l] = n_final\n        # each row of mat_csl is the CSL lattice vector\n        csl_init = np.rint(np.dot(np.dot(r_matrix, trans), scale)).astype(int).T\n        if abs(r_axis[h]) > 1:\n            csl_init = GrainBoundaryGenerator.reduce_mat(np.array(csl_init), r_axis[h], r_matrix)\n        csl = np.rint(Lattice(csl_init).get_niggli_reduced_lattice().matrix).astype(int)\n\n        # find the best slab supercell in terms of the conventional cell from the csl lattice,\n        # which is the transformation matrix\n\n        # now trans_cry is the transformation matrix from crystal to cartesian coordinates.\n        # for cubic, do not need to change.\n        if lat_type.lower() != 'c':\n            if lat_type.lower() == 'h':\n                trans_cry = np.array([[1, 0, 0], [-0.5, np.sqrt(3.0) / 2.0, 0],\n                                      [0, 0, np.sqrt(mu / mv)]])\n            elif lat_type.lower() == 'r':\n                if ratio is None:\n                    c2_a2_ratio = 1\n                else:\n                    c2_a2_ratio = 3.0 / (2 - 6 * mv / mu)\n                trans_cry = np.array([[0.5, np.sqrt(3.0) / 6.0, 1.0 / 3 * np.sqrt(c2_a2_ratio)],\n                                      [-0.5, np.sqrt(3.0) / 6.0, 1.0 / 3 * np.sqrt(c2_a2_ratio)],\n                                      [0, -1 * np.sqrt(3.0) / 3.0, 1.0 / 3 * np.sqrt(c2_a2_ratio)]])\n            else:\n                trans_cry = np.array([[1, 0, 0], [0, np.sqrt(lam / mv), 0], [0, 0, np.sqrt(mu / mv)]])\n        t1_final = GrainBoundaryGenerator.slab_from_csl(csl, surface, normal, trans_cry, max_search=max_search,\n                                                        quick_gen=quick_gen)\n        t2_final = np.array(np.rint(np.dot(t1_final, np.linalg.inv(r_matrix.T)))).astype(int)\n        return t1_final, t2_final"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef enum_sigma_cubic(cutoff, r_axis):\n        sigmas = {}\n        # make sure gcd(r_axis)==1\n        if reduce(gcd, r_axis) != 1:\n            r_axis = [int(round(x / reduce(gcd, r_axis))) for x in r_axis]\n\n        # count the number of odds in r_axis\n        odd_r = len(list(filter(lambda x: x % 2 == 1, r_axis)))\n        # Compute the max n we need to enumerate.\n        if odd_r == 3:\n            a_max = 4\n        elif odd_r == 0:\n            a_max = 1\n        else:\n            a_max = 2\n        n_max = int(np.sqrt(cutoff * a_max / sum(np.array(r_axis) ** 2)))\n        # enumerate all possible n, m to give possible sigmas within the cutoff.\n        for n_loop in range(1, n_max + 1):\n            n = n_loop\n            m_max = int(np.sqrt(cutoff * a_max - n ** 2 * sum(np.array(r_axis) ** 2)))\n            for m in range(0, m_max + 1):\n                if gcd(m, n) == 1 or m == 0:\n                    if m == 0:\n                        n = 1\n                    else:\n                        n = n_loop\n                    # construct the quadruple [m, U,V,W], count the number of odds in\n                    # quadruple to determine the parameter a, refer to the reference\n                    quadruple = [m] + [x * n for x in r_axis]\n                    odd_qua = len(list(filter(lambda x: x % 2 == 1, quadruple)))\n                    if odd_qua == 4:\n                        a = 4\n                    elif odd_qua == 2:\n                        a = 2\n                    else:\n                        a = 1\n                    sigma = int(round((m ** 2 + n ** 2 * sum(np.array(r_axis) ** 2)) / a))\n                    if (sigma <= cutoff) and (sigma > 1):\n                        if sigma not in list(sigmas.keys()):\n                            if m == 0:\n                                angle = 180.0\n                            else:\n                                angle = 2 * np.arctan(n * np.sqrt(sum(np.array(r_axis) ** 2)) / m) \\\n                                        / np.pi * 180\n                            sigmas[sigma] = [angle]\n                        else:\n                            if m == 0:\n                                angle = 180.0\n                            else:\n                                angle = 2 * np.arctan(n * np.sqrt(sum(np.array(r_axis) ** 2)) / m) \\\n                                        / np.pi * 180\n                            if angle not in sigmas[sigma]:\n                                sigmas[sigma].append(angle)\n        return sigmas", "response": "Enumerate all possible sigma values and corresponding rotation angles within a known cubic system."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef enum_sigma_rho(cutoff, r_axis, ratio_alpha):\n        sigmas = {}\n        # transform four index notation to three index notation\n        if len(r_axis) == 4:\n            u1 = r_axis[0]\n            v1 = r_axis[1]\n            w1 = r_axis[3]\n            u = 2 * u1 + v1 + w1\n            v = v1 + w1 - u1\n            w = w1 - 2 * v1 - u1\n            r_axis = [u, v, w]\n        # make sure gcd(r_axis)==1\n        if reduce(gcd, r_axis) != 1:\n            r_axis = [int(round(x / reduce(gcd, r_axis))) for x in r_axis]\n        u, v, w = r_axis\n        # make sure mu, mv are coprime integers.\n        if ratio_alpha is None:\n            mu, mv = [1, 1]\n            if u + v + w != 0:\n                if u != v or u != w:\n                    raise RuntimeError('For irrational ratio_alpha, CSL only exist for [1,1,1]'\n                                       'or [u, v, -(u+v)] and m =0')\n        else:\n            mu, mv = ratio_alpha\n            if gcd(mu, mv) != 1:\n                temp = gcd(mu, mv)\n                mu = int(round(mu / temp))\n                mv = int(round(mv / temp))\n\n        # refer to the meaning of d in reference\n        d = (u ** 2 + v ** 2 + w ** 2) * (mu - 2 * mv) + \\\n            2 * mv * (v * w + w * u + u * v)\n        # Compute the max n we need to enumerate.\n        n_max = int(np.sqrt((cutoff * abs(4 * mu * (mu - 3 * mv))) / abs(d)))\n\n        # Enumerate all possible n, m to give possible sigmas within the cutoff.\n        for n in range(1, n_max + 1):\n            if ratio_alpha is None and u + v + w == 0:\n                m_max = 0\n            else:\n                m_max = int(np.sqrt((cutoff * abs(4 * mu * (mu - 3 * mv)) - n ** 2 * d) / (mu)))\n            for m in range(0, m_max + 1):\n                if gcd(m, n) == 1 or m == 0:\n                    # construct the rotation matrix, refer to the reference\n                    R_list = [(mu - 2 * mv) * (u ** 2 - v ** 2 - w ** 2) * n ** 2 +\n                              2 * mv * (v - w) * m * n - 2 * mv * v * w * n ** 2 +\n                              mu * m ** 2,\n                              2 * (mv * u * n * (w * n + u * n - m) - (mu - mv) *\n                                   m * w * n + (mu - 2 * mv) * u * v * n ** 2),\n                              2 * (mv * u * n * (v * n + u * n + m) + (mu - mv) *\n                                   m * v * n + (mu - 2 * mv) * w * u * n ** 2),\n                              2 * (mv * v * n * (w * n + v * n + m) + (mu - mv) *\n                                   m * w * n + (mu - 2 * mv) * u * v * n ** 2),\n                              (mu - 2 * mv) * (v ** 2 - w ** 2 - u ** 2) * n ** 2 +\n                              2 * mv * (w - u) * m * n - 2 * mv * u * w * n ** 2 +\n                              mu * m ** 2,\n                              2 * (mv * v * n * (v * n + u * n - m) - (mu - mv) *\n                                   m * u * n + (mu - 2 * mv) * w * v * n ** 2),\n                              2 * (mv * w * n * (w * n + v * n - m) - (mu - mv) *\n                                   m * v * n + (mu - 2 * mv) * w * u * n ** 2),\n                              2 * (mv * w * n * (w * n + u * n + m) + (mu - mv) *\n                                   m * u * n + (mu - 2 * mv) * w * v * n ** 2),\n                              (mu - 2 * mv) * (w ** 2 - u ** 2 - v ** 2) * n ** 2 +\n                              2 * mv * (u - v) * m * n - 2 * mv * u * v * n ** 2 +\n                              mu * m ** 2]\n                    m = -1 * m\n                    # inverse of the rotation matrix\n                    R_list_inv = [(mu - 2 * mv) * (u ** 2 - v ** 2 - w ** 2) * n ** 2 +\n                                  2 * mv * (v - w) * m * n - 2 * mv * v * w * n ** 2 +\n                                  mu * m ** 2,\n                                  2 * (mv * u * n * (w * n + u * n - m) - (mu - mv) *\n                                       m * w * n + (mu - 2 * mv) * u * v * n ** 2),\n                                  2 * (mv * u * n * (v * n + u * n + m) + (mu - mv) *\n                                       m * v * n + (mu - 2 * mv) * w * u * n ** 2),\n                                  2 * (mv * v * n * (w * n + v * n + m) + (mu - mv) *\n                                       m * w * n + (mu - 2 * mv) * u * v * n ** 2),\n                                  (mu - 2 * mv) * (v ** 2 - w ** 2 - u ** 2) * n ** 2 +\n                                  2 * mv * (w - u) * m * n - 2 * mv * u * w * n ** 2 +\n                                  mu * m ** 2,\n                                  2 * (mv * v * n * (v * n + u * n - m) - (mu - mv) *\n                                       m * u * n + (mu - 2 * mv) * w * v * n ** 2),\n                                  2 * (mv * w * n * (w * n + v * n - m) - (mu - mv) *\n                                       m * v * n + (mu - 2 * mv) * w * u * n ** 2),\n                                  2 * (mv * w * n * (w * n + u * n + m) + (mu - mv) *\n                                       m * u * n + (mu - 2 * mv) * w * v * n ** 2),\n                                  (mu - 2 * mv) * (w ** 2 - u ** 2 - v ** 2) * n ** 2 +\n                                  2 * mv * (u - v) * m * n - 2 * mv * u * v * n ** 2 +\n                                  mu * m ** 2]\n                    m = -1 * m\n                    F = mu * m ** 2 + d * n ** 2\n                    all_list = R_list_inv + R_list + [F]\n                    # Compute the max common factors for the elements of the rotation matrix\n                    #  and its inverse.\n                    com_fac = reduce(gcd, all_list)\n                    sigma = int(round(abs(F / com_fac)))\n                    if (sigma <= cutoff) and (sigma > 1):\n                        if sigma not in list(sigmas.keys()):\n                            if m == 0:\n                                angle = 180.0\n                            else:\n                                angle = 2 * np.arctan(n / m * np.sqrt(d / mu)) \\\n                                        / np.pi * 180\n                            sigmas[sigma] = [angle]\n                        else:\n                            if m == 0:\n                                angle = 180\n                            else:\n                                angle = 2 * np.arctan(n / m * np.sqrt(d / mu)) \\\n                                        / np.pi * 180.0\n                            if angle not in sigmas[sigma]:\n                                sigmas[sigma].append(angle)\n            if m_max == 0:\n                break\n        return sigmas", "response": "Enumerate all possible sigma values and corresponding rotation angles within a rhombohedral system."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nenumerating all possible sigma values and corresponding rotation angles within a tetragonal system.", "response": "def enum_sigma_tet(cutoff, r_axis, c2_a2_ratio):\n        \"\"\"\n        Find all possible sigma values and corresponding rotation angles\n        within a sigma value cutoff with known rotation axis in tetragonal system.\n        The algorithm for this code is from reference, Acta Cryst, B46,117(1990)\n\n        Args:\n            cutoff (integer): the cutoff of sigma values.\n            r_axis (list of three integers, e.g. u, v, w):\n                    the rotation axis of the grain boundary, with the format of [u,v,w].\n            c2_a2_ratio (list of two integers, e.g. mu, mv):\n                    mu/mv is the square of the tetragonal axial ratio with rational number.\n                    if irrational, set c2_a2_ratio = None\n        Returns:\n            sigmas (dict):\n                    dictionary with keys as the possible integer sigma values\n                    and values as list of the possible rotation angles to the\n                    corresponding sigma values.\n                    e.g. the format as\n                    {sigma1: [angle11,angle12,...], sigma2: [angle21, angle22,...],...}\n                    Note: the angles are the rotation angle of one grain respect to the\n                    other grain.\n                    When generate the microstructure of the grain boundary using these\n                    angles, you need to analyze the symmetry of the structure. Different\n                    angles may result in equivalent microstructures.\n\n        \"\"\"\n        sigmas = {}\n        # make sure gcd(r_axis)==1\n        if reduce(gcd, r_axis) != 1:\n            r_axis = [int(round(x / reduce(gcd, r_axis))) for x in r_axis]\n\n        u, v, w = r_axis\n\n        # make sure mu, mv are coprime integers.\n        if c2_a2_ratio is None:\n            mu, mv = [1, 1]\n            if w != 0:\n                if u != 0 or (v != 0):\n                    raise RuntimeError('For irrational c2/a2, CSL only exist for [0,0,1] '\n                                       'or [u,v,0] and m = 0')\n        else:\n            mu, mv = c2_a2_ratio\n            if gcd(mu, mv) != 1:\n                temp = gcd(mu, mv)\n                mu = int(round(mu / temp))\n                mv = int(round(mv / temp))\n\n        # refer to the meaning of d in reference\n        d = (u ** 2 + v ** 2) * mv + w ** 2 * mu\n\n        # Compute the max n we need to enumerate.\n        n_max = int(np.sqrt((cutoff * 4 * mu * mv) / d))\n\n        # Enumerate all possible n, m to give possible sigmas within the cutoff.\n        for n in range(1, n_max + 1):\n            if c2_a2_ratio is None and w == 0:\n                m_max = 0\n            else:\n                m_max = int(np.sqrt((cutoff * 4 * mu * mv - n ** 2 * d) / mu))\n            for m in range(0, m_max + 1):\n                if gcd(m, n) == 1 or m == 0:\n                    # construct the rotation matrix, refer to the reference\n                    R_list = [(u ** 2 * mv - v ** 2 * mv - w ** 2 * mu) * n ** 2 +\n                              mu * m ** 2,\n                              2 * v * u * mv * n ** 2 - 2 * w * mu * m * n,\n                              2 * u * w * mu * n ** 2 + 2 * v * mu * m * n,\n                              2 * u * v * mv * n ** 2 + 2 * w * mu * m * n,\n                              (v ** 2 * mv - u ** 2 * mv - w ** 2 * mu) * n ** 2 +\n                              mu * m ** 2,\n                              2 * v * w * mu * n ** 2 - 2 * u * mu * m * n,\n                              2 * u * w * mv * n ** 2 - 2 * v * mv * m * n,\n                              2 * v * w * mv * n ** 2 + 2 * u * mv * m * n,\n                              (w ** 2 * mu - u ** 2 * mv - v ** 2 * mv) * n ** 2 +\n                              mu * m ** 2]\n                    m = -1 * m\n                    # inverse of rotation matrix\n                    R_list_inv = [(u ** 2 * mv - v ** 2 * mv - w ** 2 * mu) * n ** 2 +\n                                  mu * m ** 2,\n                                  2 * v * u * mv * n ** 2 - 2 * w * mu * m * n,\n                                  2 * u * w * mu * n ** 2 + 2 * v * mu * m * n,\n                                  2 * u * v * mv * n ** 2 + 2 * w * mu * m * n,\n                                  (v ** 2 * mv - u ** 2 * mv - w ** 2 * mu) * n ** 2 +\n                                  mu * m ** 2,\n                                  2 * v * w * mu * n ** 2 - 2 * u * mu * m * n,\n                                  2 * u * w * mv * n ** 2 - 2 * v * mv * m * n,\n                                  2 * v * w * mv * n ** 2 + 2 * u * mv * m * n,\n                                  (w ** 2 * mu - u ** 2 * mv - v ** 2 * mv) * n ** 2 +\n                                  mu * m ** 2]\n                    m = -1 * m\n                    F = mu * m ** 2 + d * n ** 2\n                    all_list = R_list + R_list_inv + [F]\n                    # Compute the max common factors for the elements of the rotation matrix\n                    #  and its inverse.\n                    com_fac = reduce(gcd, all_list)\n                    sigma = int(round((mu * m ** 2 + d * n ** 2) / com_fac))\n                    if (sigma <= cutoff) and (sigma > 1):\n                        if sigma not in list(sigmas.keys()):\n                            if m == 0:\n                                angle = 180.0\n                            else:\n                                angle = 2 * np.arctan(n / m * np.sqrt(d / mu)) \\\n                                        / np.pi * 180\n                            sigmas[sigma] = [angle]\n                        else:\n                            if m == 0:\n                                angle = 180.0\n                            else:\n                                angle = 2 * np.arctan(n / m * np.sqrt(d / mu)) \\\n                                        / np.pi * 180\n                            if angle not in sigmas[sigma]:\n                                sigmas[sigma].append(angle)\n            if m_max == 0:\n                break\n\n        return sigmas"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef enum_sigma_ort(cutoff, r_axis, c2_b2_a2_ratio):\n        sigmas = {}\n        # make sure gcd(r_axis)==1\n        if reduce(gcd, r_axis) != 1:\n            r_axis = [int(round(x / reduce(gcd, r_axis))) for x in r_axis]\n\n        u, v, w = r_axis\n        # make sure mu, lambda, mv are coprime integers.\n        if None in c2_b2_a2_ratio:\n            mu, lam, mv = c2_b2_a2_ratio\n            non_none = [i for i in c2_b2_a2_ratio if i is not None]\n            if len(non_none) < 2:\n                raise RuntimeError('No CSL exist for two irrational numbers')\n            non1, non2 = non_none\n            if reduce(gcd, non_none) != 1:\n                temp = reduce(gcd, non_none)\n                non1 = int(round(non1 / temp))\n                non2 = int(round(non2 / temp))\n            if mu is None:\n                lam = non1\n                mv = non2\n                mu = 1\n                if w != 0:\n                    if u != 0 or (v != 0):\n                        raise RuntimeError('For irrational c2, CSL only exist for [0,0,1] '\n                                           'or [u,v,0] and m = 0')\n            elif lam is None:\n                mu = non1\n                mv = non2\n                lam = 1\n                if v != 0:\n                    if u != 0 or (w != 0):\n                        raise RuntimeError('For irrational b2, CSL only exist for [0,1,0] '\n                                           'or [u,0,w] and m = 0')\n            elif mv is None:\n                mu = non1\n                lam = non2\n                mv = 1\n                if u != 0:\n                    if w != 0 or (v != 0):\n                        raise RuntimeError('For irrational a2, CSL only exist for [1,0,0] '\n                                           'or [0,v,w] and m = 0')\n        else:\n            mu, lam, mv = c2_b2_a2_ratio\n            if reduce(gcd, c2_b2_a2_ratio) != 1:\n                temp = reduce(gcd, c2_b2_a2_ratio)\n                mu = int(round(mu / temp))\n                mv = int(round(mv / temp))\n                lam = int(round(lam / temp))\n            if u == 0 and v == 0:\n                mu = 1\n            if u == 0 and w == 0:\n                lam = 1\n            if v == 0 and w == 0:\n                mv = 1\n        # refer to the meaning of d in reference\n        d = (mv * u ** 2 + lam * v ** 2) * mv + w ** 2 * mu * mv\n\n        # Compute the max n we need to enumerate.\n        n_max = int(np.sqrt((cutoff * 4 * mu * mv * mv * lam) / d))\n        # Enumerate all possible n, m to give possible sigmas within the cutoff.\n        for n in range(1, n_max + 1):\n            mu_temp, lam_temp, mv_temp = c2_b2_a2_ratio\n            if (mu_temp is None and w == 0) or (lam_temp is None and v == 0) \\\n                    or (mv_temp is None and u == 0):\n                m_max = 0\n            else:\n                m_max = int(np.sqrt((cutoff * 4 * mu * mv * lam * mv -\n                                     n ** 2 * d) / mu / lam))\n            for m in range(0, m_max + 1):\n\n                if gcd(m, n) == 1 or m == 0:\n                    # construct the rotation matrix, refer to the reference\n                    R_list = [(u ** 2 * mv * mv - lam * v ** 2 * mv -\n                               w ** 2 * mu * mv) * n ** 2 + lam * mu * m ** 2,\n                              2 * lam * (v * u * mv * n ** 2 - w * mu * m * n),\n                              2 * mu * (u * w * mv * n ** 2 + v * lam * m * n),\n                              2 * mv * (u * v * mv * n ** 2 + w * mu * m * n),\n                              (v ** 2 * mv * lam - u ** 2 * mv * mv -\n                               w ** 2 * mu * mv) * n ** 2 + lam * mu * m ** 2,\n                              2 * mv * mu * (v * w * n ** 2 - u * m * n),\n                              2 * mv * (u * w * mv * n ** 2 - v * lam * m * n),\n                              2 * lam * mv * (v * w * n ** 2 + u * m * n),\n                              (w ** 2 * mu * mv - u ** 2 * mv * mv -\n                               v ** 2 * mv * lam) * n ** 2 + lam * mu * m ** 2]\n                    m = -1 * m\n                    # inverse of rotation matrix\n                    R_list_inv = [(u ** 2 * mv * mv - lam * v ** 2 * mv -\n                                   w ** 2 * mu * mv) * n ** 2 + lam * mu * m ** 2,\n                                  2 * lam * (v * u * mv * n ** 2 - w * mu * m * n),\n                                  2 * mu * (u * w * mv * n ** 2 + v * lam * m * n),\n                                  2 * mv * (u * v * mv * n ** 2 + w * mu * m * n),\n                                  (v ** 2 * mv * lam - u ** 2 * mv * mv -\n                                   w ** 2 * mu * mv) * n ** 2 + lam * mu * m ** 2,\n                                  2 * mv * mu * (v * w * n ** 2 - u * m * n),\n                                  2 * mv * (u * w * mv * n ** 2 - v * lam * m * n),\n                                  2 * lam * mv * (v * w * n ** 2 + u * m * n),\n                                  (w ** 2 * mu * mv - u ** 2 * mv * mv -\n                                   v ** 2 * mv * lam) * n ** 2 + lam * mu * m ** 2]\n                    m = -1 * m\n                    F = mu * lam * m ** 2 + d * n ** 2\n                    all_list = R_list + R_list_inv + [F]\n                    # Compute the max common factors for the elements of the rotation matrix\n                    #  and its inverse.\n                    com_fac = reduce(gcd, all_list)\n                    sigma = int(round((mu * lam * m ** 2 + d * n ** 2) / com_fac))\n                    if (sigma <= cutoff) and (sigma > 1):\n                        if sigma not in list(sigmas.keys()):\n                            if m == 0:\n                                angle = 180.0\n                            else:\n                                angle = 2 * np.arctan(n / m * np.sqrt(d / mu / lam)) \\\n                                        / np.pi * 180\n                            sigmas[sigma] = [angle]\n                        else:\n                            if m == 0:\n                                angle = 180.0\n                            else:\n                                angle = 2 * np.arctan(n / m * np.sqrt(d / mu / lam)) \\\n                                        / np.pi * 180\n                            if angle not in sigmas[sigma]:\n                                sigmas[sigma].append(angle)\n            if m_max == 0:\n                break\n\n        return sigmas", "response": "Enumerate all possible sigma values and corresponding rotation angles within a given cutoff with known rotation axis."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nenumerate all possible plane combinations for a given cubic system.", "response": "def enum_possible_plane_cubic(plane_cutoff, r_axis, r_angle):\n        \"\"\"\n        Find all possible plane combinations for GBs given a rotaion axis and angle for\n        cubic system, and classify them to different categories, including 'Twist',\n        'Symmetric tilt', 'Normal tilt', 'Mixed' GBs.\n\n        Args:\n            plane_cutoff (integer): the cutoff of plane miller index.\n            r_axis (list of three integers, e.g. u, v, w):\n                    the rotation axis of the grain boundary, with the format of [u,v,w].\n            r_angle (float): rotation angle of the GBs.\n        Returns:\n            all_combinations (dict):\n                    dictionary with keys as GB type, e.g. 'Twist','Symmetric tilt',etc.\n                    and values as the combination of the two plane miller index\n                     (GB plane and joining plane).\n        \"\"\"\n        all_combinations = {}\n        all_combinations['Symmetric tilt'] = []\n        all_combinations['Twist'] = []\n        all_combinations['Normal tilt'] = []\n        all_combinations['Mixed'] = []\n        sym_plane = symm_group_cubic([[1, 0, 0], [1, 1, 0]])\n        j = np.arange(0, plane_cutoff + 1)\n        combination = []\n        for i in itertools.product(j, repeat=3):\n            if sum(abs(np.array(i))) != 0:\n                combination.append(list(i))\n            if len(np.nonzero(i)[0]) == 3:\n                for i1 in range(3):\n                    new_i = list(i).copy()\n                    new_i[i1] = -1 * new_i[i1]\n                    combination.append(new_i)\n            elif len(np.nonzero(i)[0]) == 2:\n                new_i = list(i).copy()\n                new_i[np.nonzero(i)[0][0]] = -1 * new_i[np.nonzero(i)[0][0]]\n                combination.append(new_i)\n        miller = np.array(combination)\n        miller = miller[np.argsort(np.linalg.norm(miller, axis=1))]\n        for i, val in enumerate(miller):\n            if reduce(gcd, val) == 1:\n                matrix = GrainBoundaryGenerator.get_trans_mat(r_axis, r_angle, surface=val, quick_gen=True)\n                vec = np.cross(matrix[1][0], matrix[1][1])\n                miller2 = GrainBoundaryGenerator.vec_to_surface(vec)\n                if np.all(np.abs(np.array(miller2)) <= plane_cutoff):\n                    cos_1 = abs(np.dot(val, r_axis) / np.linalg.norm(val) / np.linalg.norm(r_axis))\n                    if 1 - cos_1 < 1.e-5:\n                        all_combinations['Twist'].append([list(val), miller2])\n                    elif cos_1 < 1.e-8:\n                        sym_tilt = False\n                        if np.sum(np.abs(val)) == np.sum(np.abs(miller2)):\n                            ave = (np.array(val) + np.array(miller2)) / 2\n                            ave1 = (np.array(val) - np.array(miller2)) / 2\n                            for plane in sym_plane:\n                                cos_2 = abs(np.dot(ave, plane) / np.linalg.norm(ave) / np.linalg.norm(plane))\n                                cos_3 = abs(np.dot(ave1, plane) / np.linalg.norm(ave1) / np.linalg.norm(plane))\n                                if 1 - cos_2 < 1.e-5 or 1 - cos_3 < 1.e-5:\n                                    all_combinations['Symmetric tilt'].append([list(val), miller2])\n                                    sym_tilt = True\n                                    break\n                        if not sym_tilt:\n                            all_combinations['Normal tilt'].append([list(val), miller2])\n                    else:\n                        all_combinations['Mixed'].append([list(val), miller2])\n        return all_combinations"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the rotation angle corresponding to the given sigma value.", "response": "def get_rotation_angle_from_sigma(sigma, r_axis, lat_type='C', ratio=None):\n        \"\"\"\n        Find all possible rotation angle for the given sigma value.\n\n        Args:\n            sigma (integer):\n                    sigma value provided\n            r_axis (list of three integers, e.g. u, v, w\n                    or four integers, e.g. u, v, t, w for hex/rho system only):\n                    the rotation axis of the grain boundary.\n            lat_type ( one character):\n                    'c' or 'C': cubic system\n                     't' or 'T': tetragonal system\n                     'o' or 'O': orthorhombic system\n                     'h' or 'H': hexagonal system\n                     'r' or 'R': rhombohedral system\n                     default to cubic system\n            ratio (list of integers):\n                    lattice axial ratio.\n                    For cubic system, ratio is not needed.\n                    For tetragonal system, ratio = [mu, mv], list of two integers,\n                    that is, mu/mv = c2/a2. If it is irrational, set it to none.\n                    For orthorhombic system, ratio = [mu, lam, mv], list of three integers,\n                    that is, mu:lam:mv = c2:b2:a2. If irrational for one axis, set it to None.\n                    e.g. mu:lam:mv = c2,None,a2, means b2 is irrational.\n                    For rhombohedral system, ratio = [mu, mv], list of two integers,\n                    that is, mu/mv is the ratio of (1+2*cos(alpha)/cos(alpha).\n                    If irrational, set it to None.\n                    For hexagonal system, ratio = [mu, mv], list of two integers,\n                    that is, mu/mv = c2/a2. If it is irrational, set it to none.\n\n        Returns:\n            rotation_angles corresponding to the provided sigma value.\n            If the sigma value is not correct, return the rotation angle corresponding\n            to the correct possible sigma value right smaller than the wrong sigma value provided.\n        \"\"\"\n        if lat_type.lower() == 'c':\n            logger.info('Make sure this is for cubic system')\n            sigma_dict = GrainBoundaryGenerator.enum_sigma_cubic(cutoff=sigma, r_axis=r_axis)\n        elif lat_type.lower() == 't':\n            logger.info('Make sure this is for tetragonal system')\n            if ratio is None:\n                logger.info('Make sure this is for irrational c2/a2 ratio')\n            elif len(ratio) != 2:\n                raise RuntimeError('Tetragonal system needs correct c2/a2 ratio')\n            sigma_dict = GrainBoundaryGenerator.enum_sigma_tet(cutoff=sigma, r_axis=r_axis, c2_a2_ratio=ratio)\n        elif lat_type.lower() == 'o':\n            logger.info('Make sure this is for orthorhombic system')\n            if len(ratio) != 3:\n                raise RuntimeError('Orthorhombic system needs correct c2:b2:a2 ratio')\n            sigma_dict = GrainBoundaryGenerator.enum_sigma_ort(cutoff=sigma, r_axis=r_axis, c2_b2_a2_ratio=ratio)\n        elif lat_type.lower() == 'h':\n            logger.info('Make sure this is for hexagonal system')\n            if ratio is None:\n                logger.info('Make sure this is for irrational c2/a2 ratio')\n            elif len(ratio) != 2:\n                raise RuntimeError('Hexagonal system needs correct c2/a2 ratio')\n            sigma_dict = GrainBoundaryGenerator.enum_sigma_hex(cutoff=sigma, r_axis=r_axis, c2_a2_ratio=ratio)\n        elif lat_type.lower() == 'r':\n            logger.info('Make sure this is for rhombohedral system')\n            if ratio is None:\n                logger.info('Make sure this is for irrational (1+2*cos(alpha)/cos(alpha) ratio')\n            elif len(ratio) != 2:\n                raise RuntimeError('Rhombohedral system needs correct '\n                                   '(1+2*cos(alpha)/cos(alpha) ratio')\n            sigma_dict = GrainBoundaryGenerator.enum_sigma_rho(cutoff=sigma, r_axis=r_axis, ratio_alpha=ratio)\n        else:\n            raise RuntimeError('Lattice type not implemented')\n\n        sigmas = list(sigma_dict.keys())\n        if not sigmas:\n            raise RuntimeError('This is a wriong sigma value, and no sigma exists smaller than this value.')\n        if sigma in sigmas:\n            rotation_angles = sigma_dict[sigma]\n        else:\n            sigmas.sort()\n            warnings.warn(\"This is not the possible sigma value according to the rotation axis!\"\n                          \"The nearest neighbor sigma and its corresponding angle are returned\")\n            rotation_angles = sigma_dict[sigmas[-1]]\n        rotation_angles.sort()\n        return rotation_angles"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef slab_from_csl(csl, surface, normal, trans_cry, max_search=20, quick_gen=False):\n\n        # set the transform matrix in real space\n        trans = trans_cry\n        # transform matrix in reciprocal space\n        ctrans = np.linalg.inv(trans.T)\n\n        t_matrix = csl.copy()\n        # vectors constructed from csl that perpendicular to surface\n        ab_vector = []\n        # obtain the miller index of surface in terms of csl.\n        miller = np.matmul(surface, csl.T)\n        if reduce(gcd, miller) != 1:\n            miller = [int(round(x / reduce(gcd, miller))) for x in miller]\n        miller_nonzero = []\n        # quickly generate a supercell, normal is not work in this way\n        if quick_gen:\n            scale_factor = []\n            eye = np.eye(3, dtype=np.int)\n            for i, j in enumerate(miller):\n                if j == 0:\n                    scale_factor.append(eye[i])\n                else:\n                    miller_nonzero.append(i)\n            if len(scale_factor) < 2:\n                index_len = len(miller_nonzero)\n                for i in range(index_len):\n                    for j in range(i + 1, index_len):\n                        lcm_miller = lcm(miller[miller_nonzero[i]], miller[miller_nonzero[j]])\n                        l = [0, 0, 0]\n                        l[miller_nonzero[i]] = -int(round(lcm_miller / miller[miller_nonzero[i]]))\n                        l[miller_nonzero[j]] = int(round(lcm_miller / miller[miller_nonzero[j]]))\n                        scale_factor.append(l)\n                        if len(scale_factor) == 2:\n                            break\n            t_matrix[0] = np.array(np.dot(scale_factor[0], csl))\n            t_matrix[1] = np.array(np.dot(scale_factor[1], csl))\n            t_matrix[2] = csl[miller_nonzero[0]]\n            if abs(np.linalg.det(t_matrix)) > 1000:\n                warnings.warn('Too large matrix. Suggest to use quick_gen=False')\n            return t_matrix\n\n        for i, j in enumerate(miller):\n            if j == 0:\n                ab_vector.append(csl[i])\n            else:\n                c_index = i\n                miller_nonzero.append(j)\n\n        if len(miller_nonzero) > 1:\n            t_matrix[2] = csl[c_index]\n            index_len = len(miller_nonzero)\n            lcm_miller = []\n            for i in range(index_len):\n                for j in range(i + 1, index_len):\n                    com_gcd = gcd(miller_nonzero[i], miller_nonzero[j])\n                    mil1 = int(round(miller_nonzero[i] / com_gcd))\n                    mil2 = int(round(miller_nonzero[j] / com_gcd))\n                    lcm_miller.append(max(abs(mil1), abs(mil2)))\n            lcm_sorted = sorted(lcm_miller)\n            if index_len == 2:\n                max_j = lcm_sorted[0]\n            else:\n                max_j = lcm_sorted[1]\n        else:\n            if not normal:\n                t_matrix[0] = ab_vector[0]\n                t_matrix[1] = ab_vector[1]\n                t_matrix[2] = csl[c_index]\n                return t_matrix\n            else:\n                max_j = abs(miller_nonzero[0])\n        if max_j > max_search:\n            max_j = max_search\n        # area of a, b vectors\n        area = None\n        # length of c vector\n        c_norm = np.linalg.norm(np.matmul(t_matrix[2], trans))\n        # c vector length along the direction perpendicular to surface\n        c_length = np.abs(np.dot(t_matrix[2], surface))\n        # check if the init c vector perpendicular to the surface\n        if normal:\n            c_cross = np.cross(np.matmul(t_matrix[2], trans), np.matmul(surface, ctrans))\n            if np.linalg.norm(c_cross) < 1.e-8:\n                normal_init = True\n            else:\n                normal_init = False\n\n        j = np.arange(0, max_j + 1)\n        combination = []\n        for i in itertools.product(j, repeat=3):\n            if sum(abs(np.array(i))) != 0:\n                combination.append(list(i))\n            if len(np.nonzero(i)[0]) == 3:\n                for i1 in range(3):\n                    new_i = list(i).copy()\n                    new_i[i1] = -1 * new_i[i1]\n                    combination.append(new_i)\n            elif len(np.nonzero(i)[0]) == 2:\n                new_i = list(i).copy()\n                new_i[np.nonzero(i)[0][0]] = -1 * new_i[np.nonzero(i)[0][0]]\n                combination.append(new_i)\n        for i in combination:\n            if reduce(gcd, i) == 1:\n                temp = np.dot(np.array(i), csl)\n                if abs(np.dot(temp, surface) - 0) < 1.e-8:\n                    ab_vector.append(temp)\n                else:\n                    # c vector length along the direction perpendicular to surface\n                    c_len_temp = np.abs(np.dot(temp, surface))\n                    # c vector length itself\n                    c_norm_temp = np.linalg.norm(np.matmul(temp, trans))\n                    if normal:\n                        c_cross = np.cross(np.matmul(temp, trans), np.matmul(surface, ctrans))\n                        if np.linalg.norm(c_cross) < 1.e-8:\n                            if normal_init:\n                                if c_norm_temp < c_norm:\n                                    t_matrix[2] = temp\n                                    c_norm = c_norm_temp\n                            else:\n                                c_norm = c_norm_temp\n                                normal_init = True\n                                t_matrix[2] = temp\n                    else:\n                        if c_len_temp < c_length or \\\n                                (abs(c_len_temp - c_length) < 1.e-8 and c_norm_temp < c_norm):\n                            t_matrix[2] = temp\n                            c_norm = c_norm_temp\n                            c_length = c_len_temp\n\n        if normal and (not normal_init):\n            logger.info('Did not find the perpendicular c vector, increase max_j')\n            while (not normal_init):\n                if max_j == max_search:\n                    warnings.warn('Cannot find the perpendicular c vector, please increase max_search')\n                    break\n                max_j = 3 * max_j\n                if max_j > max_search:\n                    max_j = max_search\n                j = np.arange(0, max_j + 1)\n                combination = []\n                for i in itertools.product(j, repeat=3):\n                    if sum(abs(np.array(i))) != 0:\n                        combination.append(list(i))\n                    if len(np.nonzero(i)[0]) == 3:\n                        for i1 in range(3):\n                            new_i = list(i).copy()\n                            new_i[i1] = -1 * new_i[i1]\n                            combination.append(new_i)\n                    elif len(np.nonzero(i)[0]) == 2:\n                        new_i = list(i).copy()\n                        new_i[np.nonzero(i)[0][0]] = -1 * new_i[np.nonzero(i)[0][0]]\n                        combination.append(new_i)\n                for i in combination:\n                    if reduce(gcd, i) == 1:\n                        temp = np.dot(np.array(i), csl)\n                        if abs(np.dot(temp, surface) - 0) > 1.e-8:\n                            c_cross = np.cross(np.matmul(temp, trans), np.matmul(surface, ctrans))\n                            if np.linalg.norm(c_cross) < 1.e-8:\n                                # c vetor length itself\n                                c_norm_temp = np.linalg.norm(np.matmul(temp, trans))\n                                if normal_init:\n                                    if c_norm_temp < c_norm:\n                                        t_matrix[2] = temp\n                                        c_norm = c_norm_temp\n                                else:\n                                    c_norm = c_norm_temp\n                                    normal_init = True\n                                    t_matrix[2] = temp\n                if normal_init:\n                    logger.info('Found perpendicular c vector')\n\n        # find the best a, b vectors with their formed area smallest and average norm of a,b smallest.\n        for i in itertools.combinations(ab_vector, 2):\n            area_temp = np.linalg.norm(np.cross(np.matmul(i[0], trans),\n                                                np.matmul(i[1], trans)))\n            if abs(area_temp - 0) > 1.e-8:\n                ab_norm_temp = np.linalg.norm(np.matmul(i[0], trans)) + \\\n                               np.linalg.norm(np.matmul(i[1], trans))\n                if area is None:\n                    area = area_temp\n                    ab_norm = ab_norm_temp\n                    t_matrix[0] = i[0]\n                    t_matrix[1] = i[1]\n                elif area_temp < area:\n                    t_matrix[0] = i[0]\n                    t_matrix[1] = i[1]\n                    area = area_temp\n                    ab_norm = ab_norm_temp\n                elif abs(area - area_temp) < 1.e-8 and ab_norm_temp < ab_norm:\n                    t_matrix[0] = i[0]\n                    t_matrix[1] = i[1]\n                    area = area_temp\n                    ab_norm = ab_norm_temp\n\n        # make sure we have a left-handed crystallographic system\n        if np.linalg.det(np.matmul(t_matrix, trans)) < 0:\n            t_matrix *= -1\n\n        if normal and abs(np.linalg.det(t_matrix)) > 1000:\n            warnings.warn('Too large matrix. Suggest to use Normal=False')\n        return t_matrix", "response": "This function creates a slab from a crystal system and a surface and a normal vector."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreduces integer array mat by linear combination of determinant and rotation matrix r_matrix.", "response": "def reduce_mat(mat, mag, r_matrix):\n        \"\"\"\n        Reduce integer array mat's determinant mag times by linear combination\n        of its row vectors, so that the new array after rotation (r_matrix) is\n        still an integer array\n\n        Args:\n            mat (3 by 3 array): input matrix\n            mag (integer): reduce times for the determinant\n            r_matrix (3 by 3 array): rotation matrix\n        Return:\n            the reduced integer array\n        \"\"\"\n        max_j = abs(int(round(np.linalg.det(mat) / mag)))\n        reduced = False\n        for h in range(3):\n            k = h + 1 if h + 1 < 3 else abs(2 - h)\n            l = h + 2 if h + 2 < 3 else abs(1 - h)\n            j = np.arange(-max_j, max_j + 1)\n            for j1, j2 in itertools.product(j, repeat=2):\n                temp = mat[h] + j1 * mat[k] + j2 * mat[l]\n                if all([np.round(x, 5).is_integer() for x in list(temp / mag)]):\n                    mat_copy = mat.copy()\n                    mat_copy[h] = np.array([int(round(ele / mag)) for ele in temp])\n                    new_mat = np.dot(mat_copy, np.linalg.inv(r_matrix.T))\n                    if all([np.round(x, 5).is_integer() for x in list(np.ravel(new_mat))]):\n                        reduced = True\n                        mat[h] = np.array([int(round(ele / mag)) for ele in temp])\n                        break\n            if reduced:\n                break\n\n        if not reduced:\n            warnings.warn(\"Matrix reduction not performed, may lead to non-primitive gb cell.\")\n        return mat"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef vec_to_surface(vec):\n        miller = [None] * 3\n        index = []\n        for i, value in enumerate(vec):\n            if abs(value) < 1.e-8:\n                miller[i] = 0\n            else:\n                index.append(i)\n        if len(index) == 1:\n            miller[index[0]] = 1\n        else:\n            min_index = np.argmin([i for i in vec if i != 0])\n            true_index = index[min_index]\n            index.pop(min_index)\n            frac = []\n            for i, value in enumerate(index):\n                frac.append(Fraction(vec[value] / vec[true_index]).limit_denominator(100))\n            if len(index) == 1:\n                miller[true_index] = frac[0].denominator\n                miller[index[0]] = frac[0].numerator\n            else:\n                com_lcm = lcm(frac[0].denominator, frac[1].denominator)\n                miller[true_index] = com_lcm\n                miller[index[0]] = frac[0].numerator * int(round((com_lcm / frac[0].denominator)))\n                miller[index[1]] = frac[1].numerator * int(round((com_lcm / frac[1].denominator)))\n        return miller", "response": "Transform a vector to a surface miller index with integers."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add_spectrum(self, label, spectrum, color=None):\n        self._spectra[label] = spectrum\n        self.colors.append(\n            color or\n            self.colors_cycle[len(self._spectra) % len(self.colors_cycle)])", "response": "Adds a Spectrum to the internal list of available colors."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add_spectra(self, spectra_dict, key_sort_func=None):\n        if key_sort_func:\n            keys = sorted(spectra_dict.keys(), key=key_sort_func)\n        else:\n            keys = spectra_dict.keys()\n        for label in keys:\n            self.add_spectra(label, spectra_dict[label])", "response": "Adds a dictionary of doses to the set of doses."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_plot(self, xlim=None, ylim=None):\n\n        plt = pretty_plot(12, 8)\n        base = 0.0\n        i = 0\n        for key, sp in self._spectra.items():\n            if not self.stack:\n                plt.plot(sp.x, sp.y + self.yshift * i, color=self.colors[i],\n                         label=str(key), linewidth=3)\n            else:\n                plt.fill_between(sp.x, base, sp.y + self.yshift * i,\n                                 color=self.colors[i],\n                                 label=str(key), linewidth=3)\n                base = sp.y + base\n            plt.xlabel(sp.XLABEL)\n            plt.ylabel(sp.YLABEL)\n            i += 1\n\n        if xlim:\n            plt.xlim(xlim)\n        if ylim:\n            plt.ylim(ylim)\n\n        plt.legend()\n        leg = plt.gca().get_legend()\n        ltext = leg.get_texts()  # all the text.Text instance in the legend\n        plt.setp(ltext, fontsize=30)\n        plt.tight_layout()\n        return plt", "response": "Returns a matplotlib plot showing the DOS."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsaving matplotlib plot to a file.", "response": "def save_plot(self, filename, img_format=\"eps\", **kwargs):\n        \"\"\"\n        Save matplotlib plot to a file.\n\n        Args:\n            filename: Filename to write to.\n            img_format: Image format to use. Defaults to EPS.\n        \"\"\"\n        plt = self.get_plot(**kwargs)\n        plt.savefig(filename, format=img_format)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef apply_transformation(self, structure, return_ranked_list=False):\n        sp = get_el_sp(self.specie_to_remove)\n        specie_indices = [i for i in range(len(structure))\n                          if structure[i].species ==\n                          Composition({sp: 1})]\n        trans = PartialRemoveSitesTransformation([specie_indices],\n                                                 [self.fraction_to_remove],\n                                                 algo=self.algo)\n        return trans.apply_transformation(structure, return_ranked_list)", "response": "Applies the transformation to the structure."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef apply_transformation(self, structure):\n        sga = SpacegroupAnalyzer(structure, symprec=self.symprec,\n                                 angle_tolerance=self.angle_tolerance)\n        return sga.get_conventional_standard_structure(international_monoclinic=self.international_monoclinic)", "response": "Returns most primitive cell for structure."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\napplying the transformation to a structure.", "response": "def apply_transformation(self, structure):\n        \"\"\"\n        Discretizes the site occupancies in the structure.\n\n        Args:\n            structure: disordered Structure to discretize occupancies\n\n        Returns:\n            A new disordered Structure with occupancies discretized\n        \"\"\"\n        if structure.is_ordered:\n            return structure\n\n        species = [dict(sp) for sp in structure.species_and_occu]\n\n        for sp in species:\n            for k, v in sp.items():\n                old_occ = sp[k]\n                new_occ = float(\n                    Fraction(old_occ).limit_denominator(self.max_denominator))\n                if self.fix_denominator:\n                    new_occ = around(old_occ*self.max_denominator)\\\n                        / self.max_denominator\n                if round(abs(old_occ - new_occ), 6) > self.tol:\n                    raise RuntimeError(\n                        \"Cannot discretize structure within tolerance!\")\n                sp[k] = new_occ\n\n        return Structure(structure.lattice, species, structure.frac_coords)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a copy of the structure with the parameters scaled to the same degree as the relaxed_structure.", "response": "def apply_transformation(self, structure):\n        \"\"\"\n        Returns a copy of structure with lattice parameters\n        and sites scaled to the same degree as the relaxed_structure.\n\n        Arg:\n            structure (Structure): A structurally similar structure in\n                regards to crystal and site positions.\n        \"\"\"\n\n        if self.species_map == None:\n            match = StructureMatcher()\n            s_map = \\\n                match.get_best_electronegativity_anonymous_mapping(self.unrelaxed_structure,\n                                                                   structure)\n        else:\n            s_map = self.species_map\n\n        params = list(structure.lattice.abc)\n        params.extend(structure.lattice.angles)\n        new_lattice = Lattice.from_parameters(*[p*self.params_percent_change[i] \\\n                                                for i, p in enumerate(params)])\n        species, frac_coords = [], []\n        for site in self.relaxed_structure:\n            species.append(s_map[site.specie])\n            frac_coords.append(site.frac_coords)\n\n        return Structure(new_lattice, species, frac_coords)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a dict representation of the object.", "response": "def as_dict(self):\n        \"\"\"\n        Makes LibxcFunc obey the general json interface used in pymatgen for\n        easier serialization.\n        \"\"\"\n        return {\"name\": self.name,\n                \"@module\": self.__class__.__module__,\n                \"@class\": self.__class__.__name__}"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef lattice_2_lmpbox(lattice, origin=(0, 0, 0)):\n    a, b, c = lattice.abc\n    xlo, ylo, zlo = origin\n    xhi = a + xlo\n    m = lattice.matrix\n    xy = np.dot(m[1], m[0] / a)\n    yhi = np.sqrt(b ** 2 - xy ** 2) + ylo\n    xz = np.dot(m[2], m[0] / a)\n    yz = (np.dot(m[1], m[2]) - xy * xz) / (yhi - ylo)\n    zhi = np.sqrt(c ** 2 - xz ** 2 - yz ** 2) + zlo\n    tilt = None if lattice.is_orthogonal else [xy, xz, yz]\n    rot_matrix = np.linalg.solve([[xhi - xlo, 0, 0],\n                                  [xy, yhi - ylo, 0],\n                                  [xz, yz, zhi - zlo]], m)\n    bounds = [[xlo, xhi], [ylo, yhi], [zlo, zhi]]\n    symmop = SymmOp.from_rotation_and_translation(rot_matrix, origin)\n    return LammpsBox(bounds, tilt), symmop", "response": "Converts a Lattice object to LammpsBox and calculates the symmetry\n            simulation box used."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nconvert a structure to a LammpsData object with no force field parameters and topologies.", "response": "def structure_2_lmpdata(structure, ff_elements=None, atom_style=\"charge\"):\n    \"\"\"\n    Converts a structure to a LammpsData object with no force field\n    parameters and topologies.\n\n    Args:\n        structure (Structure): Input structure.\n        ff_elements ([str]): List of strings of elements that must be\n            present due to force field settings but not necessarily in\n            the structure. Default to None.\n        atom_style (str): Choose between \"atomic\" (neutral) and\n            \"charge\" (charged). Default to \"charge\".\n\n    Returns:\n        LammpsData\n\n    \"\"\"\n    s = structure.get_sorted_structure()\n\n    a, b, c = s.lattice.abc\n    m = s.lattice.matrix\n    xhi = a\n    xy = np.dot(m[1], m[0] / xhi)\n    yhi = np.sqrt(b ** 2 - xy ** 2)\n    xz = np.dot(m[2], m[0] / xhi)\n    yz = (np.dot(m[1], m[2]) - xy * xz) / yhi\n    zhi = np.sqrt(c ** 2 - xz ** 2 - yz ** 2)\n    box_bounds = [[0.0, xhi], [0.0, yhi], [0.0, zhi]]\n    box_tilt = [xy, xz, yz]\n    box_tilt = None if not any(box_tilt) else box_tilt\n    box = LammpsBox(box_bounds, box_tilt)\n    new_latt = Lattice([[xhi, 0, 0], [xy, yhi, 0], [xz, yz, zhi]])\n    s.lattice = new_latt\n\n    symbols = list(s.symbol_set)\n    if ff_elements:\n        symbols.extend(ff_elements)\n    elements = sorted(Element(el) for el in set(symbols))\n    mass_info = [tuple([i.symbol] * 2) for i in elements]\n    ff = ForceField(mass_info)\n    topo = Topology(s)\n    return LammpsData.from_ff_and_topologies(box=box, ff=ff, topologies=[topo],\n                                             atom_style=atom_style)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef volume(self):\n        m = self._matrix\n        return np.dot(np.cross(m[0], m[1]), m[2])", "response": "Returns the volume of the current system in the system."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the string representation of the simulation box in LAMMPS data file format.", "response": "def get_string(self, significant_figures=6):\n        \"\"\"\n        Returns the string representation of simulation box in LAMMPS\n        data file format.\n\n        Args:\n            significant_figures (int): No. of significant figures to\n                output for box settings. Default to 6.\n\n        Returns:\n            String representation\n\n        \"\"\"\n        ph = \"{:.%df}\" % significant_figures\n        lines = []\n        for bound, d in zip(self.bounds, \"xyz\"):\n            fillers = bound + [d] * 2\n            bound_format = \" \".join([ph] * 2 + [\" {}lo {}hi\"])\n            lines.append(bound_format.format(*fillers))\n        if self.tilt:\n            tilt_format = \" \".join([ph] * 3 + [\" xy xz yz\"])\n            lines.append(tilt_format.format(*self.tilt))\n        return \"\\n\".join(lines)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a periodic structure object representing the simulation box.", "response": "def structure(self):\n        \"\"\"\n        Exports a periodic structure object representing the simulation\n        box.\n\n        Return:\n            Structure\n\n        \"\"\"\n        masses = self.masses\n        atoms = self.atoms.copy()\n        if \"nx\" in atoms.columns:\n            atoms.drop([\"nx\", \"ny\", \"nz\"], axis=1, inplace=True)\n        atoms[\"molecule-ID\"] = 1\n        ld_copy = self.__class__(self.box, masses, atoms)\n        topologies = ld_copy.disassemble()[-1]\n        molecule = topologies[0].sites\n        coords = molecule.cart_coords - np.array(self.box.bounds)[:, 0]\n        species = molecule.species\n        latt = self.box.to_lattice()\n        site_properties = {}\n        if \"q\" in atoms:\n            site_properties[\"charge\"] = atoms[\"q\"].values\n        if self.velocities is not None:\n            site_properties[\"velocities\"] = self.velocities.values\n        return Structure(latt, species, coords, coords_are_cartesian=True,\n                         site_properties=site_properties)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the string representation of the LammpsData object.", "response": "def get_string(self, distance=6, velocity=8, charge=3):\n        \"\"\"\n        Returns the string representation of LammpsData, essentially\n        the string to be written to a file.\n\n        Args:\n            distance (int): No. of significant figures to output for\n                box settings (bounds and tilt) and atomic coordinates.\n                Default to 6.\n            velocity (int): No. of significant figures to output for\n                velocities. Default to 8.\n            charge (int): No. of significant figures to output for\n                charges. Default to 3.\n\n        Returns:\n            String representation\n\n        \"\"\"\n        file_template = \"\"\"Generated by pymatgen.io.lammps.data.LammpsData\n\n{stats}\n\n{box}\n\n{body}\n\"\"\"\n        box = self.box.get_string(distance)\n\n        body_dict = OrderedDict()\n        body_dict[\"Masses\"] = self.masses\n        types = OrderedDict()\n        types[\"atom\"] = len(self.masses)\n        if self.force_field:\n            all_ff_kws = SECTION_KEYWORDS[\"ff\"] + SECTION_KEYWORDS[\"class2\"]\n            ff_kws = [k for k in all_ff_kws if k in self.force_field]\n            for kw in ff_kws:\n                body_dict[kw] = self.force_field[kw]\n                if kw in SECTION_KEYWORDS[\"ff\"][2:]:\n                    types[kw.lower()[:-7]] = len(self.force_field[kw])\n\n        body_dict[\"Atoms\"] = self.atoms\n        counts = OrderedDict()\n        counts[\"atoms\"] = len(self.atoms)\n        if self.velocities is not None:\n            body_dict[\"Velocities\"] = self.velocities\n        if self.topology:\n            for kw in SECTION_KEYWORDS[\"topology\"]:\n                if kw in self.topology:\n                    body_dict[kw] = self.topology[kw]\n                    counts[kw.lower()] = len(self.topology[kw])\n\n        all_stats = list(counts.values()) + list(types.values())\n        stats_template = \"{:>%d}  {}\" % len(str(max(all_stats)))\n        count_lines = [stats_template.format(v, k) for k, v in counts.items()]\n        type_lines = [stats_template.format(v, k + \" types\")\n                      for k, v in types.items()]\n        stats = \"\\n\".join(count_lines + [\"\"] + type_lines)\n\n        map_coords = lambda q: (\"{:.%df}\" % distance).format(q)\n        map_velos = lambda q: (\"{:.%df}\" % velocity).format(q)\n        map_charges = lambda q: (\"{:.%df}\" % charge).format(q)\n        formatters = {\"x\": map_coords, \"y\": map_coords, \"z\": map_coords,\n                      \"vx\": map_velos, \"vy\": map_velos, \"vz\": map_velos,\n                      \"q\": map_charges}\n        section_template = \"{kw}\\n\\n{df}\\n\"\n        parts = []\n        for k, v in body_dict.items():\n            index = True if k != \"PairIJ Coeffs\" else False\n            df_string = v.to_string(header=False, formatters=formatters,\n                                    index_names=False, index=index)\n            parts.append(section_template.format(kw=k, df=df_string))\n        body = \"\\n\".join(parts)\n\n        return file_template.format(stats=stats, box=box, body=body)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef write_file(self, filename, distance=6, velocity=8, charge=3):\n        with open(filename, \"w\") as f:\n            f.write(self.get_string(distance=distance, velocity=velocity,\n                                    charge=charge))", "response": "Writes LammpsData to file."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndisassembles the LammpsData into a single block structure and returns a single Topology object.", "response": "def disassemble(self, atom_labels=None, guess_element=True,\n                    ff_label=\"ff_map\"):\n        \"\"\"\n        Breaks down LammpsData to building blocks\n        (LammpsBox, ForceField and a series of Topology).\n        RESTRICTIONS APPLIED:\n\n        1. No complex force field defined not just on atom\n            types, where the same type or equivalent types of topology\n            may have more than one set of coefficients.\n        2. No intermolecular topologies (with atoms from different\n            molecule-ID) since a Topology object includes data for ONE\n            molecule or structure only.\n\n        Args:\n            atom_labels ([str]): List of strings (must be different\n                from one another) for labelling each atom type found in\n                Masses section. Default to None, where the labels are\n                automaticaly added based on either element guess or\n                dummy specie assignment.\n            guess_element (bool): Whether to guess the element based on\n                its atomic mass. Default to True, otherwise dummy\n                species \"Qa\", \"Qb\", ... will be assigned to various\n                atom types. The guessed or assigned elements will be\n                reflected on atom labels if atom_labels is None, as\n                well as on the species of molecule in each Topology.\n            ff_label (str): Site property key for labeling atoms of\n                different types. Default to \"ff_map\".\n\n        Returns:\n            LammpsBox, ForceField, [Topology]\n\n        \"\"\"\n        atoms_df = self.atoms.copy()\n        if \"nx\" in atoms_df.columns:\n            atoms_df[[\"x\", \"y\", \"z\"]] += \\\n                self.box.get_box_shift(atoms_df[[\"nx\", \"ny\", \"nz\"]].values)\n        atoms_df = pd.concat([atoms_df, self.velocities], axis=1)\n\n        mids = atoms_df.get(\"molecule-ID\")\n        if mids is None:\n            unique_mids = [1]\n            data_by_mols = {1: {\"Atoms\": atoms_df}}\n        else:\n            unique_mids = np.unique(mids)\n            data_by_mols = {}\n            for k in unique_mids:\n                df = atoms_df[atoms_df[\"molecule-ID\"] == k]\n                data_by_mols[k] = {\"Atoms\": df}\n\n        masses = self.masses.copy()\n        masses[\"label\"] = atom_labels\n        unique_masses = np.unique(masses[\"mass\"])\n        if guess_element:\n            ref_masses = [el.atomic_mass.real for el in Element]\n            diff = np.abs(np.array(ref_masses) - unique_masses[:, None])\n            atomic_numbers = np.argmin(diff, axis=1) + 1\n            symbols = [Element.from_Z(an).symbol for an in atomic_numbers]\n        else:\n            symbols = [\"Q%s\" % a for a in\n                       map(chr, range(97, 97 + len(unique_masses)))]\n        for um, s in zip(unique_masses, symbols):\n            masses.loc[masses[\"mass\"] == um, \"element\"] = s\n        if atom_labels is None:  # add unique labels based on elements\n            for el, vc in masses[\"element\"].value_counts().iteritems():\n                masses.loc[masses[\"element\"] == el, \"label\"] = \\\n                    [\"%s%d\" % (el, c) for c in range(1, vc + 1)]\n        assert masses[\"label\"].nunique(dropna=False) == len(masses), \\\n            \"Expecting unique atom label for each type\"\n        mass_info = [tuple([r[\"label\"], r[\"mass\"]])\n                     for _, r in masses.iterrows()]\n\n        nonbond_coeffs, topo_coeffs = None, None\n        if self.force_field:\n            if \"PairIJ Coeffs\" in self.force_field:\n                nbc = self.force_field[\"PairIJ Coeffs\"]\n                nbc = nbc.sort_values([\"id1\", \"id2\"]).drop([\"id1\", \"id2\"], axis=1)\n                nonbond_coeffs = [list(t) for t in nbc.itertuples(False, None)]\n            elif \"Pair Coeffs\" in self.force_field:\n                nbc = self.force_field[\"Pair Coeffs\"].sort_index()\n                nonbond_coeffs = [list(t) for t in nbc.itertuples(False, None)]\n\n            topo_coeffs = {k: [] for k in SECTION_KEYWORDS[\"ff\"][2:]\n                           if k in self.force_field}\n            for kw in topo_coeffs.keys():\n                class2_coeffs = {k: list(v.itertuples(False, None))\n                                 for k, v in self.force_field.items()\n                                 if k in CLASS2_KEYWORDS.get(kw, [])}\n                ff_df = self.force_field[kw]\n                for t in ff_df.itertuples(True, None):\n                    d = {\"coeffs\": list(t[1:]), \"types\": []}\n                    if class2_coeffs:\n                        d.update({k: list(v[t[0] - 1])\n                                  for k, v in class2_coeffs.items()})\n                    topo_coeffs[kw].append(d)\n\n        if self.topology:\n            label_topo = lambda t: tuple(masses.loc[atoms_df.loc[t, \"type\"],\n                                                    \"label\"])\n            for k, v in self.topology.items():\n                ff_kw = k[:-1] + \" Coeffs\"\n                for topo in v.itertuples(False, None):\n                    topo_idx = topo[0] - 1\n                    indices = topo[1:]\n                    mids = atoms_df.loc[indices, \"molecule-ID\"].unique()\n                    assert len(mids) == 1, \\\n                        \"Do not support intermolecular topology formed \" \\\n                        \"by atoms with different molecule-IDs\"\n                    label = label_topo(indices)\n                    topo_coeffs[ff_kw][topo_idx][\"types\"].append(label)\n                    if data_by_mols[mids[0]].get(k):\n                        data_by_mols[mids[0]][k].append(indices)\n                    else:\n                        data_by_mols[mids[0]][k] = [indices]\n\n        if topo_coeffs:\n            for v in topo_coeffs.values():\n                for d in v:\n                    d[\"types\"] = list(set(d[\"types\"]))\n\n        ff = ForceField(mass_info=mass_info, nonbond_coeffs=nonbond_coeffs,\n                        topo_coeffs=topo_coeffs)\n\n        topo_list = []\n        for mid in unique_mids:\n            data = data_by_mols[mid]\n            atoms = data[\"Atoms\"]\n            shift = min(atoms.index)\n            type_ids = atoms[\"type\"]\n            species = masses.loc[type_ids, \"element\"]\n            labels = masses.loc[type_ids, \"label\"]\n            coords = atoms[[\"x\", \"y\", \"z\"]]\n            m = Molecule(species.values, coords.values,\n                         site_properties={ff_label: labels.values})\n            charges = atoms.get(\"q\")\n            velocities = atoms[[\"vx\", \"vy\", \"vz\"]] if \"vx\" in atoms.columns \\\n                else None\n            topologies = {}\n            for kw in SECTION_KEYWORDS[\"topology\"]:\n                if data.get(kw):\n                    topologies[kw] = (np.array(data[kw]) - shift).tolist()\n            topologies = None if not topologies else topologies\n            topo_list.append(Topology(sites=m, ff_label=ff_label,\n                                      charges=charges, velocities=velocities,\n                                      topologies=topologies))\n\n        return self.box, ff, topo_list"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef from_file(cls, filename, atom_style=\"full\", sort_id=False):\n        with open(filename) as f:\n            lines = f.readlines()\n        kw_pattern = r\"|\".join(itertools.chain(*SECTION_KEYWORDS.values()))\n        section_marks = [i for i, l in enumerate(lines)\n                         if re.search(kw_pattern, l)]\n        parts = np.split(lines, section_marks)\n\n        float_group = r\"([0-9eE.+-]+)\"\n        header_pattern = dict()\n        header_pattern[\"counts\"] = r\"^\\s*(\\d+)\\s+([a-zA-Z]+)$\"\n        header_pattern[\"types\"] = r\"^\\s*(\\d+)\\s+([a-zA-Z]+)\\s+types$\"\n        header_pattern[\"bounds\"] = r\"^\\s*{}$\".format(r\"\\s+\".join(\n            [float_group] * 2 + [r\"([xyz])lo \\3hi\"]))\n        header_pattern[\"tilt\"] = r\"^\\s*{}$\".format(r\"\\s+\".join(\n            [float_group] * 3 + [\"xy xz yz\"]))\n\n        header = {\"counts\": {}, \"types\": {}}\n        bounds = {}\n        for l in clean_lines(parts[0][1:]):  # skip the 1st line\n            match = None\n            for k, v in header_pattern.items():\n                match = re.match(v, l)\n                if match:\n                    break\n                else:\n                    continue\n            if match and k in [\"counts\", \"types\"]:\n                header[k][match.group(2)] = int(match.group(1))\n            elif match and k == \"bounds\":\n                g = match.groups()\n                bounds[g[2]] = [float(i) for i in g[:2]]\n            elif match and k == \"tilt\":\n                header[\"tilt\"] = [float(i) for i in match.groups()]\n        header[\"bounds\"] = [bounds.get(i, [-0.5, 0.5]) for i in \"xyz\"]\n        box = LammpsBox(header[\"bounds\"], header.get(\"tilt\"))\n\n        def parse_section(sec_lines):\n            title_info = sec_lines[0].split(\"#\", 1)\n            kw = title_info[0].strip()\n            sio = StringIO(\"\".join(sec_lines[2:]))  # skip the 2nd line\n            df = pd.read_csv(sio, header=None, comment=\"#\",\n                             delim_whitespace=True)\n            if kw.endswith(\"Coeffs\") and not kw.startswith(\"PairIJ\"):\n                names = [\"id\"] + [\"coeff%d\" % i\n                                  for i in range(1, df.shape[1])]\n            elif kw == \"PairIJ Coeffs\":\n                names = [\"id1\", \"id2\"] + [\"coeff%d\" % i\n                                          for i in range(1, df.shape[1] - 1)]\n                df.index.name = None\n            elif kw in SECTION_HEADERS:\n                names = [\"id\"] + SECTION_HEADERS[kw]\n            elif kw == \"Atoms\":\n                names = [\"id\"] + ATOMS_HEADERS[atom_style]\n                if df.shape[1] == len(names):\n                    pass\n                elif df.shape[1] == len(names) + 3:\n                    names += [\"nx\", \"ny\", \"nz\"]\n                else:\n                    raise ValueError(\"Format in Atoms section inconsistent\"\n                                     \" with atom_style %s\" % atom_style)\n            else:\n                raise NotImplementedError(\"Parser for %s section\"\n                                          \" not implemented\" % kw)\n            df.columns = names\n            if sort_id:\n                sort_by = \"id\" if kw != \"PairIJ Coeffs\" else [\"id1\", \"id2\"]\n                df.sort_values(sort_by, inplace=True)\n            if \"id\" in df.columns:\n                df.set_index(\"id\", drop=True, inplace=True)\n                df.index.name = None\n            return kw, df\n\n        err_msg = \"Bad LAMMPS data format where \"\n        body = {}\n        seen_atoms = False\n        for part in parts[1:]:\n            name, section = parse_section(part)\n            if name == \"Atoms\":\n                seen_atoms = True\n            if name in [\"Velocities\"] + SECTION_KEYWORDS[\"topology\"] and \\\n                    not seen_atoms:  # Atoms must appear earlier than these\n                raise RuntimeError(err_msg + \"%s section appears before\"\n                                             \" Atoms section\" % name)\n            body.update({name: section})\n\n        err_msg += \"Nos. of {} do not match between header and {} section\"\n        assert len(body[\"Masses\"]) == header[\"types\"][\"atom\"], \\\n            err_msg.format(\"atom types\", \"Masses\")\n        atom_sections = [\"Atoms\", \"Velocities\"] \\\n            if \"Velocities\" in body else [\"Atoms\"]\n        for s in atom_sections:\n            assert len(body[s]) == header[\"counts\"][\"atoms\"], \\\n                err_msg.format(\"atoms\", s)\n        for s in SECTION_KEYWORDS[\"topology\"]:\n            if header[\"counts\"].get(s.lower(), 0) > 0:\n                assert len(body[s]) == header[\"counts\"][s.lower()], \\\n                    err_msg.format(s.lower(), s)\n\n        items = {k.lower(): body[k] for k in [\"Masses\", \"Atoms\"]}\n        items[\"velocities\"] = body.get(\"Velocities\")\n        ff_kws = [k for k in body if k\n                  in SECTION_KEYWORDS[\"ff\"] + SECTION_KEYWORDS[\"class2\"]]\n        items[\"force_field\"] = {k: body[k] for k in ff_kws} if ff_kws \\\n            else None\n        topo_kws = [k for k in body if k in SECTION_KEYWORDS[\"topology\"]]\n        items[\"topology\"] = {k: body[k] for k in topo_kws} \\\n            if topo_kws else None\n        items[\"atom_style\"] = atom_style\n        items[\"box\"] = box\n        return cls(**items)", "response": "Constructor that parses a file containing a set of keywords and a set of types and bounds."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef from_ff_and_topologies(cls, box, ff, topologies, atom_style=\"full\"):\n        atom_types = set.union(*[t.species for t in topologies])\n        assert atom_types.issubset(ff.maps[\"Atoms\"].keys()),\\\n            \"Unknown atom type found in topologies\"\n\n        items = dict(box=box, atom_style=atom_style, masses=ff.masses,\n                     force_field=ff.force_field)\n\n        mol_ids, charges, coords, labels = [], [], [], []\n        v_collector = [] if topologies[0].velocities else None\n        topo_collector = {\"Bonds\": [], \"Angles\": [], \"Dihedrals\": [],\n                          \"Impropers\": []}\n        topo_labels = {\"Bonds\": [], \"Angles\": [], \"Dihedrals\": [],\n                       \"Impropers\": []}\n        for i, topo in enumerate(topologies):\n            if topo.topologies:\n                shift = len(labels)\n                for k, v in topo.topologies.items():\n                    topo_collector[k].append(np.array(v) + shift + 1)\n                    topo_labels[k].extend([tuple([topo.type_by_sites[j]\n                                                  for j in t]) for t in v])\n            if isinstance(v_collector, list):\n                v_collector.append(topo.velocities)\n            mol_ids.extend([i + 1] * len(topo.sites))\n            labels.extend(topo.type_by_sites)\n            coords.append(topo.sites.cart_coords)\n            q = [0.0] * len(topo.sites) if not topo.charges else topo.charges\n            charges.extend(q)\n\n        atoms = pd.DataFrame(np.concatenate(coords), columns=[\"x\", \"y\", \"z\"])\n        atoms[\"molecule-ID\"] = mol_ids\n        atoms[\"q\"] = charges\n        atoms[\"type\"] = list(map(ff.maps[\"Atoms\"].get, labels))\n        atoms.index += 1\n        atoms = atoms[ATOMS_HEADERS[atom_style]]\n\n        velocities = None\n        if v_collector:\n            velocities = pd.DataFrame(np.concatenate(v_collector),\n                                      columns=SECTION_HEADERS[\"Velocities\"])\n            velocities.index += 1\n\n        topology = {k: None for k, v in topo_labels.items() if len(v) > 0}\n        for k in topology:\n            df = pd.DataFrame(np.concatenate(topo_collector[k]),\n                              columns=SECTION_HEADERS[k][1:])\n            df[\"type\"] = list(map(ff.maps[k].get, topo_labels[k]))\n            if any(pd.isnull(df[\"type\"])):  # Throw away undefined topologies\n                warnings.warn(\"Undefined %s detected and removed\" % k.lower())\n                df.dropna(subset=[\"type\"], inplace=True)\n                df.reset_index(drop=True, inplace=True)\n            df.index += 1\n            topology[k] = df[SECTION_HEADERS[k]]\n        topology = {k: v for k, v in topology.items() if not v.empty}\n\n        items.update({\"atoms\": atoms, \"velocities\": velocities,\n                      \"topology\": topology})\n        return cls(**items)", "response": "Constructs a LammpsData object from a ForceField object and a list of Topology objects."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef from_bonding(cls, molecule, bond=True, angle=True, dihedral=True,\n                     tol=0.1, **kwargs):\n        \"\"\"\n        Another constructor that creates an instance from a molecule.\n        Covalent bonds and other bond-based topologies (angles and\n        dihedrals) can be automatically determined. Cannot be used for\n        non bond-based topologies, e.g., improper dihedrals.\n\n        Args:\n            molecule (Molecule): Input molecule.\n            bond (bool): Whether find bonds. If set to False, angle and\n                dihedral searching will be skipped. Default to True.\n            angle (bool): Whether find angles. Default to True.\n            dihedral (bool): Whether find dihedrals. Default to True.\n            tol (float): Bond distance tolerance. Default to 0.1.\n                Not recommended to alter.\n            **kwargs: Other kwargs supported by Topology.\n\n        \"\"\"\n        real_bonds = molecule.get_covalent_bonds(tol=tol)\n        bond_list = [list(map(molecule.index, [b.site1, b.site2]))\n                     for b in real_bonds]\n        if not all((bond, bond_list)):\n            # do not search for others if not searching for bonds or no bonds\n            return cls(sites=molecule, **kwargs)\n        else:\n            angle_list, dihedral_list = [], []\n            dests, freq = np.unique(bond_list, return_counts=True)\n            hubs = dests[np.where(freq > 1)].tolist()\n            bond_arr = np.array(bond_list)\n            if len(hubs) > 0:\n                hub_spokes = {}\n                for hub in hubs:\n                    ix = np.any(np.isin(bond_arr, hub), axis=1)\n                    bonds = np.unique(bond_arr[ix]).tolist()\n                    bonds.remove(hub)\n                    hub_spokes[hub] = bonds\n            # skip angle or dihedral searching if too few bonds or hubs\n            dihedral = False if len(bond_list) < 3 or len(hubs) < 2 \\\n                else dihedral\n            angle = False if len(bond_list) < 2 or len(hubs) < 1 else angle\n\n            if angle:\n                for k, v in hub_spokes.items():\n                    angle_list.extend([[i, k, j] for i, j in\n                                       itertools.combinations(v, 2)])\n            if dihedral:\n                hub_cons = bond_arr[np.all(np.isin(bond_arr, hubs), axis=1)]\n                for i, j in hub_cons.tolist():\n                    ks = [k for k in hub_spokes[i] if k != j]\n                    ls = [l for l in hub_spokes[j] if l != i]\n                    dihedral_list.extend([[k, i, j, l] for k, l in\n                                          itertools.product(ks, ls)\n                                          if k != l])\n\n            topologies = {k: v for k, v\n                          in zip(SECTION_KEYWORDS[\"topology\"][:3],\n                                 [bond_list, angle_list, dihedral_list])\n                          if len(v) > 0}\n            topologies = None if len(topologies) == 0 else topologies\n            return cls(sites=molecule, topologies=topologies, **kwargs)", "response": "A method that creates an instance of a SequenceRecord from a molecule with bonding and angle and dihedral."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsaves the current object to a file in YAML format.", "response": "def to_file(self, filename):\n        \"\"\"\n        Saves object to a file in YAML format.\n\n        Args:\n            filename (str): Filename.\n\n        \"\"\"\n        d = {\"mass_info\": self.mass_info,\n             \"nonbond_coeffs\": self.nonbond_coeffs,\n             \"topo_coeffs\": self.topo_coeffs}\n        yaml = YAML(typ=\"safe\")\n        with open(filename, \"w\") as f:\n            yaml.dump(d, f)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef from_file(cls, filename):\n        yaml = YAML(typ=\"safe\")\n        with open(filename, \"r\") as f:\n            d = yaml.load(f)\n        return cls.from_dict(d)", "response": "Constructor that reads in a file in YAML format."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nread at most nlines lines from file filename.", "response": "def _read_nlines(filename, nlines):\n    \"\"\"\n    Read at most nlines lines from file filename.\n    If nlines is < 0, the entire file is read.\n    \"\"\"\n    if nlines < 0:\n        with open(filename, 'r') as fh:\n            return fh.readlines()\n\n    lines = []\n    with open(filename, 'r') as fh:\n        for lineno, line in enumerate(fh):\n            if lineno == nlines: break\n            lines.append(line)\n        return lines"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _dict_from_lines(lines, key_nums, sep=None):\n    if is_string(lines):\n        lines = [lines]\n\n    if not isinstance(key_nums, collections.abc.Iterable):\n        key_nums = list(key_nums)\n\n    if len(lines) != len(key_nums):\n        err_msg = \"lines = %s\\n key_num =  %s\" % (str(lines), str(key_nums))\n        raise ValueError(err_msg)\n\n    kwargs = Namespace()\n\n    for (i, nk) in enumerate(key_nums):\n        if nk == 0: continue\n        line = lines[i]\n\n        tokens = [t.strip() for t in line.split()]\n        values, keys = tokens[:nk], \"\".join(tokens[nk:])\n        # Sanitize keys: In some case we might get strings in the form: foo[,bar]\n        keys.replace(\"[\", \"\").replace(\"]\", \"\")\n        keys = keys.split(\",\")\n\n        if sep is not None:\n            check = keys[0][0]\n            if check != sep:\n                raise ValueError(\"Expecting separator %s, got %s\" % (sep, check))\n            keys[0] = keys[0][1:]\n\n        if len(values) != len(keys):\n            msg = \"line: %s\\n len(keys) != len(value)\\nkeys: %s\\n values: %s\" % (line, keys, values)\n            raise ValueError(msg)\n\n        kwargs.update(zip(keys, values))\n\n    return kwargs", "response": "Helper function to parse a list of lines into a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _int_from_str(string):\n    float_num = float(string)\n    int_num = int(float_num)\n    if float_num == int_num:\n        return int_num\n    else:\n        # Needed to handle pseudos with fractional charge\n        int_num = np.rint(float_num)\n        logger.warning(\"Converting float %s to int %s\" % (float_num, int_num))\n        return int_num", "response": "Convert string into integer\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef as_pseudo(cls, obj):\n        return obj if isinstance(obj, cls) else cls.from_file(obj)", "response": "Convert obj into a pseudo object. Accepts obj as a pseudo object."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef to_string(self, verbose=0):\n        lines = []\n        app = lines.append\n        app(\"<%s: %s>\" % (self.__class__.__name__, self.basename))\n        app(\"  summary: \" + self.summary.strip())\n        app(\"  number of valence electrons: %s\" % self.Z_val)\n        app(\"  maximum angular momentum: %s\" % l2str(self.l_max))\n        app(\"  angular momentum for local part: %s\" % l2str(self.l_local))\n        app(\"  XC correlation: %s\" % self.xc)\n        app(\"  supports spin-orbit: %s\" % self.supports_soc)\n\n        if self.isnc:\n            app(\"  radius for non-linear core correction: %s\" % self.nlcc_radius)\n\n        if self.has_hints:\n            for accuracy in (\"low\", \"normal\", \"high\"):\n                hint = self.hint_for_accuracy(accuracy=accuracy)\n                app(\"  hint for %s accuracy: %s\" % (accuracy, str(hint)))\n\n        return \"\\n\".join(lines)", "response": "String representation of the object."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef element(self):\n        try:\n            return Element.from_Z(self.Z)\n        except (KeyError, IndexError):\n            return Element.from_Z(int(self.Z))", "response": "Pymatgen : class : Element."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncomputing and erturn MD5 hash value.", "response": "def compute_md5(self):\n        \"\"\"Compute and erturn MD5 hash value.\"\"\"\n        import hashlib\n        with open(self.path, \"rt\") as fh:\n            text = fh.read()\n            m = hashlib.md5(text.encode(\"utf-8\"))\n            return m.hexdigest()"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncopies the pseudopotential to a temporary file and return a new pseudopotential object.", "response": "def as_tmpfile(self, tmpdir=None):\n        \"\"\"\n        Copy the pseudopotential to a temporary a file and returns a new pseudopotential object.\n        Useful for unit tests in which we have to change the content of the file.\n\n        Args:\n            tmpdir: If None, a new temporary directory is created and files are copied here\n                else tmpdir is used.\n        \"\"\"\n        import tempfile, shutil\n        tmpdir = tempfile.mkdtemp() if tmpdir is None else tmpdir\n        new_path = os.path.join(tmpdir, self.basename)\n        shutil.copy(self.filepath, new_path)\n\n        # Copy dojoreport file if present.\n        root, ext = os.path.splitext(self.filepath)\n        djrepo = root + \".djrepo\"\n        if os.path.exists(djrepo):\n            shutil.copy(djrepo, os.path.join(tmpdir, os.path.basename(djrepo)))\n\n        # Build new object and copy dojo_report if present.\n        new = self.__class__.from_file(new_path)\n        if self.has_dojo_report: new.dojo_report = self.dojo_report.deepcopy()\n\n        return new"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef djrepo_path(self):\n        root, ext = os.path.splitext(self.filepath)\n        path = root + \".djrepo\"\n        return path", "response": "The path of the djrepo file. None if file does not exist."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef hint_for_accuracy(self, accuracy=\"normal\"):\n        if not self.has_dojo_report:\n            return Hint(ecut=0., pawecutdg=0.)\n\n        # Get hints from dojoreport. Try first in hints then in ppgen_hints.\n        if \"hints\" in self.dojo_report:\n            return Hint.from_dict(self.dojo_report[\"hints\"][accuracy])\n        elif \"ppgen_hints\" in self.dojo_report:\n            return Hint.from_dict(self.dojo_report[\"ppgen_hints\"][accuracy])\n        return Hint(ecut=0., pawecutdg=0.)", "response": "Returns a Hint object with the suggested value of ecut and pawecutdg for the given accuracy."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef has_hints(self):\n        for acc in [\"low\", \"normal\", \"high\"]:\n            try:\n                if self.hint_for_accuracy(acc) is None:\n                    return False\n            except KeyError:\n                return False\n        return True", "response": "Returns True if this object provides hints on the cutoff energy."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nopen the PSPS. nc file and returns a new object providing methods to plot and analyze the data.", "response": "def open_pspsfile(self, ecut=20, pawecutdg=None):\n        \"\"\"\n        Calls Abinit to compute the internal tables for the application of the\n        pseudopotential part. Returns :class:`PspsFile` object providing methods\n        to plot and analyze the data or None if file is not found or it's not readable.\n\n        Args:\n            ecut: Cutoff energy in Hartree.\n            pawecutdg: Cutoff energy for the PAW double grid.\n        \"\"\"\n        from pymatgen.io.abinit.tasks import AbinitTask\n        from abipy.core.structure import Structure\n        from abipy.abio.factories import gs_input\n        from abipy.electrons.psps import PspsFile\n\n        # Build fake structure.\n        lattice = 10 * np.eye(3)\n        structure = Structure(lattice, [self.element], coords=[[0, 0, 0]])\n\n        if self.ispaw and pawecutdg is None: pawecutdg = ecut * 4\n        inp = gs_input(structure, pseudos=[self], ecut=ecut, pawecutdg=pawecutdg,\n                       spin_mode=\"unpolarized\", kppa=1)\n        # Add prtpsps = -1 to make Abinit print the PSPS.nc file and stop.\n        inp[\"prtpsps\"] = -1\n\n        # Build temporary task and run it (ignore retcode because we don't exit cleanly)\n        task = AbinitTask.temp_shell_task(inp)\n        task.start_and_wait()\n\n        filepath = task.outdir.has_abiext(\"_PSPS.nc\")\n        if not filepath:\n            logger.critical(\"Cannot find PSPS.nc file in %s\" % task.outdir)\n            return None\n\n        # Open the PSPS.nc file.\n        try:\n            return PspsFile(filepath)\n        except Exception as exc:\n            logger.critical(\"Exception while reading PSPS file at %s:\\n%s\" % (filepath, str(exc)))\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nparse the FHI abinit header.", "response": "def fhi_header(filename, ppdesc):\n        \"\"\"\n        Parse the FHI abinit header. Example:\n\n        Troullier-Martins psp for element  Sc        Thu Oct 27 17:33:22 EDT 1994\n         21.00000   3.00000    940714                zatom, zion, pspdat\n           1    1    2    0      2001    .00000      pspcod,pspxc,lmax,lloc,mmax,r2well\n        1.80626423934776     .22824404341771    1.17378968127746   rchrg,fchrg,qchrg\n        \"\"\"\n        lines = _read_nlines(filename, 4)\n\n        try:\n            header = _dict_from_lines(lines[:4], [0, 3, 6, 3])\n        except ValueError:\n            # The last record with rchrg ... seems to be optional.\n            header = _dict_from_lines(lines[:3], [0, 3, 6])\n\n        summary = lines[0]\n\n        return NcAbinitHeader(summary, **header)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nparse the HGH abinit header.", "response": "def hgh_header(filename, ppdesc):\n        \"\"\"\n        Parse the HGH abinit header. Example:\n\n        Hartwigsen-Goedecker-Hutter psp for Ne,  from PRB58, 3641 (1998)\n           10   8  010605 zatom,zion,pspdat\n         3 1   1 0 2001 0  pspcod,pspxc,lmax,lloc,mmax,r2well\n        \"\"\"\n        lines = _read_nlines(filename, 3)\n\n        header = _dict_from_lines(lines[:3], [0, 3, 6])\n        summary = lines[0]\n\n        return NcAbinitHeader(summary, **header)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef oncvpsp_header(filename, ppdesc):\n        lines = _read_nlines(filename, 6)\n\n        header = _dict_from_lines(lines[:3], [0, 3, 6])\n        summary = lines[0]\n\n        # Replace pspd with pspdata\n        header.update({'pspdat': header['pspd']})\n        header.pop('pspd')\n\n        # Read extension switch\n        header[\"extension_switch\"] = int(lines[5].split()[0])\n\n        return NcAbinitHeader(summary, **header)", "response": "Parse the ONCVPSP abinit header."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef tm_header(filename, ppdesc):\n        lines = _read_nlines(filename, -1)\n        header = []\n\n        for lineno, line in enumerate(lines):\n            header.append(line)\n            if lineno == 2:\n                # Read lmax.\n                tokens = line.split()\n                pspcod, pspxc, lmax, lloc = map(int, tokens[:4])\n                mmax, r2well = map(float, tokens[4:6])\n                #if tokens[-1].strip() != \"pspcod,pspxc,lmax,lloc,mmax,r2well\":\n                #    raise RuntimeError(\"%s: Invalid line\\n %s\"  % (filename, line))\n\n                lines = lines[3:]\n                break\n\n        # TODO\n        # Parse the section with the projectors.\n        #0   4.085   6.246    0   2.8786493        l,e99.0,e99.9,nproj,rcpsp\n        #.00000000    .0000000000    .0000000000    .00000000   rms,ekb1,ekb2,epsatm\n        projectors = OrderedDict()\n        for idx in range(2*(lmax+1)):\n            line = lines[idx]\n            if idx % 2 == 0: proj_info = [line,]\n            if idx % 2 == 1:\n                proj_info.append(line)\n                d = _dict_from_lines(proj_info, [5,4])\n                projectors[int(d[\"l\"])] = d\n\n        # Add the last line with info on nlcc.\n        header.append(lines[idx+1])\n        summary = header[0]\n\n        header = _dict_from_lines(header, [0,3,6,3])\n\n        return NcAbinitHeader(summary, **header)", "response": "Parse the TM abinit header."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nparsing the PAW header file.", "response": "def paw_header(filename, ppdesc):\n        \"\"\"\n        Parse the PAW abinit header. Examples:\n\n        Paw atomic data for element Ni - Generated by AtomPAW (N. Holzwarth) + AtomPAW2Abinit v3.0.5\n          28.000  18.000 20061204               : zatom,zion,pspdat\n          7  7  2 0   350 0.                    : pspcod,pspxc,lmax,lloc,mmax,r2well\n         paw3 1305                              : pspfmt,creatorID\n          5 13                                  : basis_size,lmn_size\n         0 0 1 1 2                              : orbitals\n         3                                      : number_of_meshes\n         1 3  350 1.1803778368E-05 3.5000000000E-02 : mesh 1, type,size,rad_step[,log_step]\n         2 1  921 2.500000000000E-03                : mesh 2, type,size,rad_step[,log_step]\n         3 3  391 1.1803778368E-05 3.5000000000E-02 : mesh 3, type,size,rad_step[,log_step]\n          2.3000000000                          : r_cut(SPH)\n         2 0.\n\n        Another format:\n\n        C  (US d-loc) - PAW data extracted from US-psp (D.Vanderbilt) - generated by USpp2Abinit v2.3.0\n           6.000   4.000 20090106               : zatom,zion,pspdat\n          7 11  1 0   560 0.                    : pspcod,pspxc,lmax,lloc,mmax,r2well\n         paw4 2230                              : pspfmt,creatorID\n          4  8                                  : basis_size,lmn_size\n         0 0 1 1                                : orbitals\n         5                                      : number_of_meshes\n         1 2  560 1.5198032759E-04 1.6666666667E-02 : mesh 1, type,size,rad_step[,log_step]\n         2 2  556 1.5198032759E-04 1.6666666667E-02 : mesh 2, type,size,rad_step[,log_step]\n         3 2  576 1.5198032759E-04 1.6666666667E-02 : mesh 3, type,size,rad_step[,log_step]\n         4 2  666 1.5198032759E-04 1.6666666667E-02 : mesh 4, type,size,rad_step[,log_step]\n         5 2  673 1.5198032759E-04 1.6666666667E-02 : mesh 5, type,size,rad_step[,log_step]\n          1.5550009124                          : r_cut(PAW)\n         3 0.                                   : shape_type,rshape\n\n        Yet nnother one:\n\n        Paw atomic data for element Si - Generated by atompaw v3.0.1.3 & AtomPAW2Abinit v3.3.1\n          14.000   4.000 20120814               : zatom,zion,pspdat\n          7      11  1 0   663 0.               : pspcod,pspxc,lmax,lloc,mmax,r2well\n         paw5 1331                              : pspfmt,creatorID\n          4  8                                  : basis_size,lmn_size\n         0 0 1 1                                : orbitals\n         5                                      : number_of_meshes\n         1 2  663 8.2129718540404674E-04 1.1498160595656655E-02 : mesh 1, type,size,rad_step[,log_step]\n         2 2  658 8.2129718540404674E-04 1.1498160595656655E-02 : mesh 2, type,size,rad_step[,log_step]\n         3 2  740 8.2129718540404674E-04 1.1498160595656655E-02 : mesh 3, type,size,rad_step[,log_step]\n         4 2  819 8.2129718540404674E-04 1.1498160595656655E-02 : mesh 4, type,size,rad_step[,log_step]\n         5 2  870 8.2129718540404674E-04 1.1498160595656655E-02 : mesh 5, type,size,rad_step[,log_step]\n          1.5669671236                          : r_cut(PAW)\n         2 0.                                   : shape_type,rshape\n        \"\"\"\n        supported_formats = [\"paw3\", \"paw4\", \"paw5\"]\n        if ppdesc.format not in supported_formats:\n            raise NotImplementedError(\"format %s not in %s\" % (ppdesc.format, supported_formats))\n\n        lines = _read_nlines(filename, -1)\n\n        summary = lines[0]\n        header = _dict_from_lines(lines[:5], [0, 3, 6, 2, 2], sep=\":\")\n\n        lines = lines[5:]\n        # TODO\n        # Parse orbitals and number of meshes.\n        header[\"orbitals\"] = [int(t) for t in lines[0].split(\":\")[0].split()]\n        header[\"number_of_meshes\"] = num_meshes = int(lines[1].split(\":\")[0])\n        #print filename, header\n\n        # Skip meshes =\n        lines = lines[2+num_meshes:]\n        #for midx in range(num_meshes):\n        #    l = midx + 1\n\n        #print lines[0]\n        header[\"r_cut\"] = float(lines[0].split(\":\")[0])\n        #print lines[1]\n        header.update(_dict_from_lines(lines[1], [2], sep=\":\"))\n\n        #print(\"PAW header\\n\", header)\n        return PawAbinitHeader(summary, **header)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef scan_directory(self, dirname, exclude_exts=(), exclude_fnames=()):\n        for i, ext in enumerate(exclude_exts):\n            if not ext.strip().startswith(\".\"):\n                exclude_exts[i] =  \".\" + ext.strip()\n\n        # Exclude files depending on the extension.\n        paths = []\n        for fname in os.listdir(dirname):\n            root, ext = os.path.splitext(fname)\n            path = os.path.join(dirname, fname)\n            if (ext in exclude_exts or fname in exclude_fnames or\n                fname.startswith(\".\") or not os.path.isfile(path)): continue\n            paths.append(path)\n\n        pseudos = []\n        for path in paths:\n            # Parse the file and generate the pseudo.\n            try:\n                pseudo = self.parse(path)\n            except:\n                pseudo = None\n\n            if pseudo is not None:\n                pseudos.append(pseudo)\n                self._parsed_paths.extend(path)\n            else:\n                self._wrong_paths.extend(path)\n\n        return pseudos", "response": "Scan a directory for pseudopotentials."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef read_ppdesc(self, filename):\n        if filename.endswith(\".xml\"):\n            raise self.Error(\"XML pseudo not supported yet\")\n\n        else:\n            # Assume file with the abinit header.\n            lines = _read_nlines(filename, 80)\n\n            for lineno, line in enumerate(lines):\n\n                if lineno == 2:\n                    try:\n                        tokens = line.split()\n                        pspcod, pspxc = map(int, tokens[:2])\n                    except:\n                        msg = \"%s: Cannot parse pspcod, pspxc in line\\n %s\" % (filename, line)\n                        logger.critical(msg)\n                        return None\n\n                    #if tokens[-1].strip().replace(\" \",\"\") not in [\"pspcod,pspxc,lmax,lloc,mmax,r2well\",\n                    #                              \"pspcod,pspxc,lmax,llocal,mmax,r2well\"]:\n                    #    raise self.Error(\"%s: Invalid line\\n %s\"  % (filename, line))\n                    #    return None\n\n                    if pspcod not in self._PSPCODES:\n                        raise self.Error(\"%s: Don't know how to handle pspcod %s\\n\" % (filename, pspcod))\n\n                    ppdesc = self._PSPCODES[pspcod]\n\n                    if pspcod == 7:\n                        # PAW -> need to know the format pspfmt\n                        tokens = lines[lineno+1].split()\n                        pspfmt, creatorID = tokens[:2]\n                        #if tokens[-1].strip() != \"pspfmt,creatorID\":\n                        #    raise self.Error(\"%s: Invalid line\\n %s\" % (filename, line))\n                        #    return None\n\n                        ppdesc = ppdesc._replace(format = pspfmt)\n\n                    return ppdesc\n\n            return None", "response": "Read the pseudopotential descriptor from a file."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef parse(self, filename):\n        path = os.path.abspath(filename)\n\n        # Only PAW supports XML at present.\n        if filename.endswith(\".xml\"):\n            return PawXmlSetup(path)\n\n        ppdesc = self.read_ppdesc(path)\n\n        if ppdesc is None:\n            logger.critical(\"Cannot find ppdesc in %s\" % path)\n            return None\n\n        psp_type = ppdesc.psp_type\n\n        parsers = {\n            \"FHI\": NcAbinitHeader.fhi_header,\n            \"GTH\": NcAbinitHeader.gth_header,\n            \"TM\": NcAbinitHeader.tm_header,\n            \"Teter\": NcAbinitHeader.tm_header,\n            \"HGH\": NcAbinitHeader.hgh_header,\n            \"HGHK\": NcAbinitHeader.hgh_header,\n            \"ONCVPSP\": NcAbinitHeader.oncvpsp_header,\n            \"PAW_abinit_text\": PawAbinitHeader.paw_header,\n        }\n\n        try:\n            header = parsers[ppdesc.name](path, ppdesc)\n        except Exception:\n            raise self.Error(path + \":\\n\" + straceback())\n\n        if psp_type == \"NC\":\n            pseudo = NcAbinitPseudo(path, header)\n        elif psp_type == \"PAW\":\n            pseudo = PawAbinitPseudo(path, header)\n        else:\n            raise NotImplementedError(\"psp_type not in [NC, PAW]\")\n\n        return pseudo", "response": "Read and parse a pseudopotential file and return a pseudopotential object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nparse the first occurence of func_name in the XML file.", "response": "def _parse_radfunc(self, func_name):\n        \"\"\"Parse the first occurence of func_name in the XML file.\"\"\"\n        node = self.root.find(func_name)\n        grid = node.attrib[\"grid\"]\n        values = np.array([float(s) for s in node.text.split()])\n\n        return self.rad_grids[grid], values, node.attrib"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nparses all the nodes with tag func_name in the XML file.", "response": "def _parse_all_radfuncs(self, func_name):\n        \"\"\"Parse all the nodes with tag func_name in the XML file.\"\"\"\n        for node in self.root.findall(func_name):\n            grid = node.attrib[\"grid\"]\n            values = np.array([float(s) for s in node.text.split()])\n\n            yield self.rad_grids[grid], values, node.attrib"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef ae_core_density(self):\n        mesh, values, attrib = self._parse_radfunc(\"ae_core_density\")\n        return RadialFunction(mesh, values)", "response": "The all - electron radial density."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef ae_partial_waves(self):\n        ae_partial_waves = OrderedDict()\n        for mesh, values, attrib in self._parse_all_radfuncs(\"ae_partial_wave\"):\n            state = attrib[\"state\"]\n            #val_state = self.valence_states[state]\n            ae_partial_waves[state] = RadialFunction(mesh, values)\n\n        return ae_partial_waves", "response": "Dictionary with the AE partial waves indexed by state."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef pseudo_partial_waves(self):\n        pseudo_partial_waves = OrderedDict()\n        for (mesh, values, attrib) in self._parse_all_radfuncs(\"pseudo_partial_wave\"):\n            state = attrib[\"state\"]\n            #val_state = self.valence_states[state]\n            pseudo_partial_waves[state] = RadialFunction(mesh, values)\n\n        return pseudo_partial_waves", "response": "Dictionary with the pseudo partial waves indexed by state."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nyielding a predefined list of matplotlib figures with minimal input from the user.", "response": "def yield_figs(self, **kwargs):  # pragma: no cover\n        \"\"\"\n        This function *generates* a predefined list of matplotlib figures with minimal input from the user.\n        \"\"\"\n        yield self.plot_densities(title=\"PAW densities\", show=False)\n        yield self.plot_waves(title=\"PAW waves\", show=False)\n        yield self.plot_projectors(title=\"PAW projectors\", show=False)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nplots the PAW densities.", "response": "def plot_densities(self, ax=None, **kwargs):\n        \"\"\"\n        Plot the PAW densities.\n\n        Args:\n            ax: matplotlib :class:`Axes` or None if a new figure should be created.\n\n        Returns:\n            `matplotlib` figure\n        \"\"\"\n        ax, fig, plt = get_ax_fig_plt(ax)\n\n        ax.grid(True)\n        ax.set_xlabel('r [Bohr]')\n        #ax.set_ylabel('density')\n\n        for i, den_name in enumerate([\"ae_core_density\", \"pseudo_core_density\"]):\n            rden = getattr(self, den_name)\n            label = \"$n_c$\" if i == 1 else r\"$\\tilde{n}_c$\"\n            ax.plot(rden.mesh, rden.mesh * rden.values, label=label, lw=2)\n\n        ax.legend(loc=\"best\")\n\n        return fig"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nplots the AE and the pseudo partial waves.", "response": "def plot_waves(self, ax=None, fontsize=12, **kwargs):\n        \"\"\"\n        Plot the AE and the pseudo partial waves.\n\n        Args:\n            ax: matplotlib :class:`Axes` or None if a new figure should be created.\n            fontsize: fontsize for legends and titles\n\n        Returns: `matplotlib` figure\n        \"\"\"\n        ax, fig, plt = get_ax_fig_plt(ax)\n\n        ax.grid(True)\n        ax.set_xlabel(\"r [Bohr]\")\n        ax.set_ylabel(r\"$r\\phi,\\, r\\tilde\\phi\\, [Bohr]^{-\\frac{1}{2}}$\")\n\n        #ax.axvline(x=self.paw_radius, linewidth=2, color='k', linestyle=\"--\")\n        #ax.annotate(\"$r_c$\", xy=(self.paw_radius + 0.1, 0.1))\n\n        for state, rfunc in self.pseudo_partial_waves.items():\n            ax.plot(rfunc.mesh, rfunc.mesh * rfunc.values, lw=2, label=\"PS-WAVE: \" + state)\n\n        for state, rfunc in self.ae_partial_waves.items():\n            ax.plot(rfunc.mesh, rfunc.mesh * rfunc.values, lw=2, label=\"AE-WAVE: \" + state)\n\n        ax.legend(loc=\"best\", shadow=True, fontsize=fontsize)\n\n        return fig"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef plot_projectors(self, ax=None, fontsize=12, **kwargs):\n        ax, fig, plt = get_ax_fig_plt(ax)\n        title = kwargs.pop(\"title\", \"Projectors\")\n        ax.grid(True)\n        ax.set_xlabel('r [Bohr]')\n        ax.set_ylabel(r\"$r\\tilde p\\, [Bohr]^{-\\frac{1}{2}}$\")\n\n        #ax.axvline(x=self.paw_radius, linewidth=2, color='k', linestyle=\"--\")\n        #ax.annotate(\"$r_c$\", xy=(self.paw_radius + 0.1, 0.1))\n\n        for state, rfunc in self.projector_functions.items():\n            ax.plot(rfunc.mesh, rfunc.mesh * rfunc.values, label=\"TPROJ: \" + state)\n\n        ax.legend(loc=\"best\", shadow=True, fontsize=fontsize)\n\n        return fig", "response": "Plot the PAW projectors."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a new PseudoTable from a directory tree.", "response": "def from_dir(cls, top, exts=None, exclude_dirs=\"_*\"):\n        \"\"\"\n        Find all pseudos in the directory tree starting from top.\n\n        Args:\n            top: Top of the directory tree\n            exts: List of files extensions. if exts == \"all_files\"\n                    we try to open all files in top\n            exclude_dirs: Wildcard used to exclude directories.\n\n        return: :class:`PseudoTable` sorted by atomic number Z.\n        \"\"\"\n        pseudos = []\n\n        if exts == \"all_files\":\n            for f in [os.path.join(top, fn) for fn in os.listdir(top)]:\n                if os.path.isfile(f):\n                    try:\n                        p = Pseudo.from_file(f)\n                        if p:\n                            pseudos.append(p)\n                        else:\n                            logger.info('Skipping file %s' % f)\n                    except:\n                        logger.info('Skipping file %s' % f)\n            if not pseudos:\n                logger.warning('No pseudopotentials parsed from folder %s' % top)\n                return None\n            logger.info('Creating PseudoTable with %i pseudopotentials' % len(pseudos))\n\n        else:\n            if exts is None: exts=(\"psp8\",)\n\n            for p in find_exts(top, exts, exclude_dirs=exclude_dirs):\n                try:\n                    pseudos.append(Pseudo.from_file(p))\n                except Exception as exc:\n                    logger.critical(\"Error in %s:\\n%s\" % (p, exc))\n\n        return cls(pseudos).sort_by_z()"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ntrues if the table is complete i. e. all elements with Z < zmax have at least on pseudopotential .", "response": "def is_complete(self, zmax=118):\n        \"\"\"\n        True if table is complete i.e. all elements with Z < zmax have at least on pseudopotential\n        \"\"\"\n        for z in range(1, zmax):\n            if not self[z]: return False\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef all_combinations_for_elements(self, element_symbols):\n        d = OrderedDict()\n        for symbol in element_symbols:\n            d[symbol] = self.select_symbols(symbol, ret_list=True)\n\n        from itertools import product\n        return list(product(*d.values()))", "response": "Return a list with all the possible combinations of pseudos\n            for the given list of element_symbols."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the pseudo with the given chemical symbol.", "response": "def pseudo_with_symbol(self, symbol, allow_multi=False):\n        \"\"\"\n        Return the pseudo with the given chemical symbol.\n\n        Args:\n            symbols: String with the chemical symbol of the element\n            allow_multi: By default, the method raises ValueError\n                if multiple occurrences are found. Use allow_multi to prevent this.\n\n        Raises:\n            ValueError if symbol is not found or multiple occurences are present and not allow_multi\n        \"\"\"\n        pseudos = self.select_symbols(symbol, ret_list=True)\n        if not pseudos or (len(pseudos) > 1 and not allow_multi):\n            raise ValueError(\"Found %d occurrences of symbol %s\" % (len(pseudos), symbol))\n\n        if not allow_multi:\n            return pseudos[0]\n        else:\n            return pseudos"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the pseudos with the given chemical symbols.", "response": "def pseudos_with_symbols(self, symbols):\n        \"\"\"\n        Return the pseudos with the given chemical symbols.\n\n        Raises:\n            ValueError if one of the symbols is not found or multiple occurences are present.\n        \"\"\"\n        pseudos = self.select_symbols(symbols, ret_list=True)\n        found_symbols = [p.symbol for p in pseudos]\n        duplicated_elements = [s for s, o in collections.Counter(found_symbols).items() if o > 1]\n\n        if duplicated_elements:\n            raise ValueError(\"Found multiple occurrences of symbol(s) %s\" % ', '.join(duplicated_elements))\n        missing_symbols = [s for s in symbols if s not in found_symbols]\n\n        if missing_symbols:\n            raise ValueError(\"Missing data for symbol(s) %s\" % ', '.join(missing_symbols))\n\n        return pseudos"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a new instance of the table with the pseudopotentials with the given list of chemical symbols.", "response": "def select_symbols(self, symbols, ret_list=False):\n        \"\"\"\n        Return a :class:`PseudoTable` with the pseudopotentials with the given list of chemical symbols.\n\n        Args:\n            symbols: str or list of symbols\n                Prepend the symbol string with \"-\", to exclude pseudos.\n            ret_list: if True a list of pseudos is returned instead of a :class:`PseudoTable`\n        \"\"\"\n        symbols = list_strings(symbols)\n        exclude = symbols[0].startswith(\"-\")\n\n        if exclude:\n            if not all(s.startswith(\"-\") for s in symbols):\n                raise ValueError(\"When excluding symbols, all strings must start with `-`\")\n            symbols = [s[1:] for s in symbols]\n\n        symbols = set(symbols)\n        pseudos = []\n        for p in self:\n            if exclude:\n                if p.symbol in symbols: continue\n            else:\n                if p.symbol not in symbols: continue\n\n            pseudos.append(p)\n\n        if ret_list:\n            return pseudos\n        else:\n            return self.__class__(pseudos)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef print_table(self, stream=sys.stdout, filter_function=None):\n        print(self.to_table(filter_function=filter_function), file=stream)", "response": "Print the table of the current object to the stream."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef to_table(self, filter_function=None):\n        table = []\n        for p in self:\n            if filter_function is not None and filter_function(p): continue\n            table.append([p.basename, p.symbol, p.Z_val, p.l_max, p.l_local, p.xc, p.type])\n        return tabulate(table, headers= [\"basename\", \"symbol\", \"Z_val\", \"l_max\", \"l_local\", \"XC\", \"type\"],\n                        tablefmt=\"grid\")", "response": "Return string with data in tabular form."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef sorted(self, attrname, reverse=False):\n        attrs = []\n        for i, pseudo in self:\n            try:\n                a = getattr(pseudo, attrname)\n            except AttributeError:\n                a = np.inf\n            attrs.append((i, a))\n\n        # Sort attrs, and build new table with sorted pseudos.\n        return self.__class__([self[a[0]] for a in sorted(attrs, key=lambda t: t[1], reverse=reverse)])", "response": "Sort the table according to the value of attribute attrname."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef sort_by_z(self):\n        return self.__class__(sorted(self, key=lambda p: p.Z))", "response": "Return a new : class : PseudoTable with pseudos sorted by Z"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef select(self, condition):\n        return self.__class__([p for p in self if condition(p)])", "response": "Returns a new class:`PseudoTable` object with only those pseudopotentials for which condition is True."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a new class:`PseudoTable` with pseudos in the given rows.", "response": "def select_rows(self, rows):\n        \"\"\"\n        Return new class:`PseudoTable` object with pseudos in the given rows of the periodic table.\n        rows can be either a int or a list of integers.\n        \"\"\"\n        if not isinstance(rows, (list, tuple)): rows = [rows]\n        return self.__class__([p for p in self if p.element.row in rows])"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_task_data(self, chemsys_formula_id, prop=\"\"):\n        sub_url = \"/tasks/%s\" % chemsys_formula_id\n        if prop:\n            sub_url += \"/\" + prop\n        return self._make_request(sub_url)", "response": "This method returns the task data for a specific run."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets a list of Structures corresponding to a chemical system formula or materials_id.", "response": "def get_structures(self, chemsys_formula_id, final=True):\n        \"\"\"\n        Get a list of Structures corresponding to a chemical system, formula,\n        or materials_id.\n\n        Args:\n            chemsys_formula_id (str): A chemical system (e.g., Li-Fe-O),\n                or formula (e.g., Fe2O3) or materials_id (e.g., mp-1234).\n            final (bool): Whether to get the final structure, or the initial\n                (pre-relaxation) structure. Defaults to True.\n\n        Returns:\n            List of Structure objects.\n        \"\"\"\n        prop = \"final_structure\" if final else \"initial_structure\"\n        data = self.get_data(chemsys_formula_id, prop=prop)\n        return [d[prop] for d in data]"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nfind matching structures on the Materials Project site.", "response": "def find_structure(self, filename_or_structure):\n        \"\"\"\n        Finds matching structures on the Materials Project site.\n\n        Args:\n            filename_or_structure: filename or Structure object\n\n        Returns:\n            A list of matching structures.\n\n        Raises:\n            MPRestError\n        \"\"\"\n        try:\n            if isinstance(filename_or_structure, str):\n                s = Structure.from_file(filename_or_structure)\n            elif isinstance(filename_or_structure, Structure):\n                s = filename_or_structure\n            else:\n                raise MPRestError(\"Provide filename or Structure object.\")\n            payload = {'structure': json.dumps(s.as_dict(), cls=MontyEncoder)}\n            response = self.session.post(\n                '{}/find_structure'.format(self.preamble), data=payload\n            )\n            if response.status_code in [200, 400]:\n                resp = json.loads(response.text, cls=MontyDecoder)\n                if resp['valid_response']:\n                    return resp['response']\n                else:\n                    raise MPRestError(resp[\"error\"])\n            raise MPRestError(\"REST error with status code {} and error {}\"\n                              .format(response.status_code, response.text))\n        except Exception as ex:\n            raise MPRestError(str(ex))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_entries(self, chemsys_formula_id_criteria, compatible_only=True,\n                    inc_structure=None, property_data=None,\n                    conventional_unit_cell=False, sort_by_e_above_hull=False):\n        \"\"\"\n        Get a list of ComputedEntries or ComputedStructureEntries corresponding\n        to a chemical system, formula, or materials_id or full criteria.\n\n        Args:\n            chemsys_formula_id_criteria (str/dict): A chemical system\n                (e.g., Li-Fe-O), or formula (e.g., Fe2O3) or materials_id\n                (e.g., mp-1234) or full Mongo-style dict criteria.\n            compatible_only (bool): Whether to return only \"compatible\"\n                entries. Compatible entries are entries that have been\n                processed using the MaterialsProjectCompatibility class,\n                which performs adjustments to allow mixing of GGA and GGA+U\n                calculations for more accurate phase diagrams and reaction\n                energies.\n            inc_structure (str): If None, entries returned are\n                ComputedEntries. If inc_structure=\"initial\",\n                ComputedStructureEntries with initial structures are returned.\n                Otherwise, ComputedStructureEntries with final structures\n                are returned.\n            property_data (list): Specify additional properties to include in\n                entry.data. If None, no data. Should be a subset of\n                supported_properties.\n            conventional_unit_cell (bool): Whether to get the standard\n                conventional unit cell\n            sort_by_e_above_hull (bool): Whether to sort the list of entries by\n                e_above_hull (will query e_above_hull as a property_data if True).\n\n        Returns:\n            List of ComputedEntry or ComputedStructureEntry objects.\n        \"\"\"\n        # TODO: This is a very hackish way of doing this. It should be fixed\n        # on the REST end.\n        params = [\"run_type\", \"is_hubbard\", \"pseudo_potential\", \"hubbards\",\n                  \"potcar_symbols\", \"oxide_type\"]\n        props = [\"energy\", \"unit_cell_formula\", \"task_id\"] + params\n        if sort_by_e_above_hull:\n            if property_data and \"e_above_hull\" not in property_data:\n                property_data.append(\"e_above_hull\")\n            elif not property_data:\n                property_data = [\"e_above_hull\"]\n        if property_data:\n            props += property_data\n        if inc_structure:\n            if inc_structure == \"initial\":\n                props.append(\"initial_structure\")\n            else:\n                props.append(\"structure\")\n\n        if not isinstance(chemsys_formula_id_criteria, dict):\n            criteria = MPRester.parse_criteria(chemsys_formula_id_criteria)\n        else:\n            criteria = chemsys_formula_id_criteria\n        data = self.query(criteria, props)\n        \n        entries = []\n        for d in data:\n            d[\"potcar_symbols\"] = [\n                \"%s %s\" % (d[\"pseudo_potential\"][\"functional\"], l)\n                for l in d[\"pseudo_potential\"][\"labels\"]]\n            data = {\"oxide_type\": d[\"oxide_type\"]}\n            if property_data:\n                data.update({k: d[k] for k in property_data})\n            if not inc_structure:\n                e = ComputedEntry(d[\"unit_cell_formula\"], d[\"energy\"],\n                                  parameters={k: d[k] for k in params},\n                                  data=data,\n                                  entry_id=d[\"task_id\"])\n\n            else:\n                prim = d[\"initial_structure\"] if inc_structure == \"initial\" \\\n                    else d[\"structure\"]\n                if conventional_unit_cell:\n                    s = SpacegroupAnalyzer(prim).get_conventional_standard_structure()\n                    energy = d[\"energy\"] * (len(s) / len(prim))\n                else:\n                    s = prim.copy()\n                    energy = d[\"energy\"]\n                e = ComputedStructureEntry(\n                    s, energy,\n                    parameters={k: d[k] for k in params},\n                    data=data,\n                    entry_id=d[\"task_id\"])\n            entries.append(e)\n        if compatible_only:\n            from pymatgen.entries.compatibility import \\\n                MaterialsProjectCompatibility\n            entries = MaterialsProjectCompatibility().process_entries(entries)\n        if sort_by_e_above_hull:\n            entries = sorted(entries, key=lambda entry: entry.data[\"e_above_hull\"])\n        return entries", "response": "Get a list of ComputedEntries or ComputedStructureEntries corresponding to a chemical system formula or materials_id or full criteria."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_structure_by_material_id(self, material_id, final=True,\n                                     conventional_unit_cell=False):\n        \"\"\"\n        Get a Structure corresponding to a material_id.\n\n        Args:\n            material_id (str): Materials Project material_id (a string,\n                e.g., mp-1234).\n            final (bool): Whether to get the final structure, or the initial\n                (pre-relaxation) structure. Defaults to True.\n            conventional_unit_cell (bool): Whether to get the standard\n                conventional unit cell\n\n        Returns:\n            Structure object.\n        \"\"\"\n        prop = \"final_structure\" if final else \"initial_structure\"\n        data = self.get_data(material_id, prop=prop)\n        if conventional_unit_cell:\n            data[0][prop] = SpacegroupAnalyzer(data[0][prop]). \\\n                get_conventional_standard_structure()\n        return data[0][prop]", "response": "Get a Structure object corresponding to a material_id."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_entry_by_material_id(self, material_id, compatible_only=True,\n                                 inc_structure=None, property_data=None,\n                                 conventional_unit_cell=False):\n        \"\"\"\n        Get a ComputedEntry corresponding to a material_id.\n\n        Args:\n            material_id (str): Materials Project material_id (a string,\n                e.g., mp-1234).\n            compatible_only (bool): Whether to return only \"compatible\"\n                entries. Compatible entries are entries that have been\n                processed using the MaterialsProjectCompatibility class,\n                which performs adjustments to allow mixing of GGA and GGA+U\n                calculations for more accurate phase diagrams and reaction\n                energies.\n            inc_structure (str): If None, entries returned are\n                ComputedEntries. If inc_structure=\"final\",\n                ComputedStructureEntries with final structures are returned.\n                Otherwise, ComputedStructureEntries with initial structures\n                are returned.\n            property_data (list): Specify additional properties to include in\n                entry.data. If None, no data. Should be a subset of\n                supported_properties.\n            conventional_unit_cell (bool): Whether to get the standard\n                conventional unit cell\n\n        Returns:\n            ComputedEntry or ComputedStructureEntry object.\n        \"\"\"\n        data = self.get_entries(material_id, compatible_only=compatible_only,\n                                inc_structure=inc_structure,\n                                property_data=property_data,\n                                conventional_unit_cell=conventional_unit_cell)\n        return data[0]", "response": "Get a ComputedEntry object corresponding to a material_id."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_bandstructure_by_material_id(self, material_id, line_mode=True):\n        prop = \"bandstructure\" if line_mode else \"bandstructure_uniform\"\n        data = self.get_data(material_id, prop=prop)\n        return data[0][prop]", "response": "Get a BandStructure object corresponding to a material_id."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_entries_in_chemsys(self, elements, compatible_only=True,\n                               inc_structure=None, property_data=None,\n                               conventional_unit_cell=False):\n        \"\"\"\n        Helper method to get a list of ComputedEntries in a chemical system.\n        For example, elements = [\"Li\", \"Fe\", \"O\"] will return a list of all\n        entries in the Li-Fe-O chemical system, i.e., all LixOy,\n        FexOy, LixFey, LixFeyOz, Li, Fe and O phases. Extremely useful for\n        creating phase diagrams of entire chemical systems.\n\n        Args:\n            elements ([str]): List of element symbols, e.g., [\"Li\", \"Fe\",\n                \"O\"].\n            compatible_only (bool): Whether to return only \"compatible\"\n                entries. Compatible entries are entries that have been\n                processed using the MaterialsProjectCompatibility class,\n                which performs adjustments to allow mixing of GGA and GGA+U\n                calculations for more accurate phase diagrams and reaction\n                energies.\n            inc_structure (str): If None, entries returned are\n                ComputedEntries. If inc_structure=\"final\",\n                ComputedStructureEntries with final structures are returned.\n                Otherwise, ComputedStructureEntries with initial structures\n                are returned.\n            property_data (list): Specify additional properties to include in\n                entry.data. If None, no data. Should be a subset of\n                supported_properties.\n            conventional_unit_cell (bool): Whether to get the standard\n                conventional unit cell\n\n        Returns:\n            List of ComputedEntries.\n        \"\"\"\n        entries = []\n        for i in range(len(elements)):\n            for els in itertools.combinations(elements, i + 1):\n                entries.extend(\n                    self.get_entries(\n                        \"-\".join(els), compatible_only=compatible_only,\n                        inc_structure=inc_structure,\n                        property_data=property_data,\n                        conventional_unit_cell=conventional_unit_cell))\n        return entries", "response": "This method returns a list of ComputedEntries in a chemical system."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsubmits a list of structures to the Materials Project as SNL files.", "response": "def submit_structures(self, structures, authors, projects=None,\n                          references='', remarks=None, data=None,\n                          histories=None, created_at=None):\n        \"\"\"\n        Submits a list of structures to the Materials Project as SNL files.\n        The argument list mirrors the arguments for the StructureNL object,\n        except that a list of structures with the same metadata is used as an\n        input.\n\n        .. note::\n\n            As of now, this MP REST feature is open only to a select group of\n            users. Opening up submissions to all users is being planned for\n            the future.\n\n        Args:\n            structures: A list of Structure objects\n            authors (list): List of {\"name\":'', \"email\":''} dicts,\n                *list* of Strings as 'John Doe <johndoe@gmail.com>',\n                or a single String with commas separating authors\n            projects ([str]): List of Strings ['Project A', 'Project B'].\n                This applies to all structures.\n            references (str): A String in BibTeX format. Again, this applies to\n                all structures.\n            remarks ([str]): List of Strings ['Remark A', 'Remark B']\n            data ([dict]): A list of free form dict. Namespaced at the root\n                level with an underscore, e.g. {\"_materialsproject\":<custom\n                data>}. The length of data should be the same as the list of\n                structures if not None.\n            histories: List of list of dicts - [[{'name':'', 'url':'',\n                'description':{}}], ...] The length of histories should be the\n                same as the list of structures if not None.\n            created_at (datetime): A datetime object\n\n        Returns:\n            A list of inserted submission ids.\n        \"\"\"\n        from pymatgen.util.provenance import StructureNL\n        snl_list = StructureNL.from_structures(structures, authors, projects,\n                                               references, remarks, data,\n                                               histories, created_at)\n        self.submit_snl(snl_list)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsubmits a list of StructureNL objects to the Materials Project site.", "response": "def submit_snl(self, snl):\n        \"\"\"\n        Submits a list of StructureNL to the Materials Project site.\n\n        .. note::\n\n            As of now, this MP REST feature is open only to a select group of\n            users. Opening up submissions to all users is being planned for\n            the future.\n\n        Args:\n            snl (StructureNL/[StructureNL]): A single StructureNL, or a list\n            of StructureNL objects\n\n        Returns:\n            A list of inserted submission ids.\n\n        Raises:\n            MPRestError\n        \"\"\"\n        try:\n            snl = snl if isinstance(snl, list) else [snl]\n            jsondata = [s.as_dict() for s in snl]\n            payload = {\"snl\": json.dumps(jsondata, cls=MontyEncoder)}\n            response = self.session.post(\"{}/snl/submit\".format(self.preamble),\n                                         data=payload)\n            if response.status_code in [200, 400]:\n                resp = json.loads(response.text, cls=MontyDecoder)\n                if resp[\"valid_response\"]:\n                    if resp.get(\"warning\"):\n                        warnings.warn(resp[\"warning\"])\n                    return resp['inserted_ids']\n                else:\n                    raise MPRestError(resp[\"error\"])\n\n            raise MPRestError(\"REST error with status code {} and error {}\"\n                              .format(response.status_code, response.text))\n\n        except Exception as ex:\n            raise MPRestError(str(ex))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef delete_snl(self, snl_ids):\n        try:\n            payload = {\"ids\": json.dumps(snl_ids)}\n            response = self.session.post(\n                \"{}/snl/delete\".format(self.preamble), data=payload)\n\n            if response.status_code in [200, 400]:\n                resp = json.loads(response.text, cls=MontyDecoder)\n                if resp[\"valid_response\"]:\n                    if resp.get(\"warning\"):\n                        warnings.warn(resp[\"warning\"])\n                    return resp\n                else:\n                    raise MPRestError(resp[\"error\"])\n\n            raise MPRestError(\"REST error with status code {} and error {}\"\n                              .format(response.status_code, response.text))\n\n        except Exception as ex:\n            raise MPRestError(str(ex))", "response": "Delete earlier submitted SNLs."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nquerying for submitted SNLs.", "response": "def query_snl(self, criteria):\n        \"\"\"\n        Query for submitted SNLs.\n\n        .. note::\n\n            As of now, this MP REST feature is open only to a select group of\n            users. Opening up submissions to all users is being planned for\n            the future.\n\n        Args:\n            criteria (dict): Query criteria.\n\n        Returns:\n            A dict, with a list of submitted SNLs in the \"response\" key.\n\n        Raises:\n            MPRestError\n        \"\"\"\n        try:\n            payload = {\"criteria\": json.dumps(criteria)}\n            response = self.session.post(\"{}/snl/query\".format(self.preamble),\n                                         data=payload)\n            if response.status_code in [200, 400]:\n                resp = json.loads(response.text)\n                if resp[\"valid_response\"]:\n                    if resp.get(\"warning\"):\n                        warnings.warn(resp[\"warning\"])\n                    return resp[\"response\"]\n                else:\n                    raise MPRestError(resp[\"error\"])\n\n            raise MPRestError(\"REST error with status code {} and error {}\"\n                              .format(response.status_code, response.text))\n\n        except Exception as ex:\n            raise MPRestError(str(ex))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nsubmit all vasp runs in a particular rootdir to the Materials Project as SNL files.", "response": "def submit_vasp_directory(self, rootdir, authors, projects=None,\n                              references='', remarks=None, master_data=None,\n                              master_history=None, created_at=None,\n                              ncpus=None):\n        \"\"\"\n        Assimilates all vasp run directories beneath a particular\n        directory using BorgQueen to obtain structures, and then submits thhem\n        to the Materials Project as SNL files. VASP related meta data like\n        initial structure and final energies are automatically incorporated.\n\n        .. note::\n\n            As of now, this MP REST feature is open only to a select group of\n            users. Opening up submissions to all users is being planned for\n            the future.\n\n        Args:\n            rootdir (str): Rootdir to start assimilating VASP runs from.\n            authors: *List* of {\"name\":'', \"email\":''} dicts,\n                *list* of Strings as 'John Doe <johndoe@gmail.com>',\n                or a single String with commas separating authors. The same\n                list of authors should apply to all runs.\n            projects ([str]): List of Strings ['Project A', 'Project B'].\n                This applies to all structures.\n            references (str): A String in BibTeX format. Again, this applies to\n                all structures.\n            remarks ([str]): List of Strings ['Remark A', 'Remark B']\n            master_data (dict): A free form dict. Namespaced at the root\n                level with an underscore, e.g. {\"_materialsproject\":<custom\n                data>}. This data is added to all structures detected in the\n                directory, in addition to other vasp data on a per structure\n                basis.\n            master_history: A master history to be added to all entries.\n            created_at (datetime): A datetime object\n            ncpus (int): Number of cpus to use in using BorgQueen to\n                assimilate. Defaults to None, which means serial.\n        \"\"\"\n        from pymatgen.apps.borg.hive import VaspToComputedEntryDrone\n        from pymatgen.apps.borg.queen import BorgQueen\n        drone = VaspToComputedEntryDrone(inc_structure=True,\n                                         data=[\"filename\",\n                                               \"initial_structure\"])\n        queen = BorgQueen(drone, number_of_drones=ncpus)\n        queen.parallel_assimilate(rootdir)\n\n        structures = []\n        metadata = []\n        histories = []\n        for e in queen.get_data():\n            structures.append(e.structure)\n            m = {\n                \"_vasp\": {\n                    \"parameters\": e.parameters,\n                    \"final_energy\": e.energy,\n                    \"final_energy_per_atom\": e.energy_per_atom,\n                    \"initial_structure\": e.data[\"initial_structure\"].as_dict()\n                }\n            }\n            if \"history\" in e.parameters:\n                histories.append(e.parameters[\"history\"])\n            if master_data is not None:\n                m.update(master_data)\n            metadata.append(m)\n        if master_history is not None:\n            histories = master_history * len(structures)\n\n        return self.submit_structures(\n            structures, authors, projects=projects, references=references,\n            remarks=remarks, data=metadata, histories=histories,\n            created_at=created_at)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_cohesive_energy(self, material_id, per_atom=False):\n        entry = self.get_entry_by_material_id(material_id)\n        ebulk = entry.energy / \\\n                entry.composition.get_integer_formula_and_factor()[1]\n        comp_dict = entry.composition.reduced_composition.as_dict()\n\n        isolated_atom_e_sum, n = 0, 0\n        for el in comp_dict.keys():\n            e = self._make_request(\"/element/%s/tasks/isolated_atom\" % (el),\n                                  mp_decode=False)[0]\n            isolated_atom_e_sum += e['output'][\"final_energy\"] * comp_dict[el]\n            n += comp_dict[el]\n        ecoh_per_formula = isolated_atom_e_sum - ebulk\n        return ecoh_per_formula/n if per_atom else ecoh_per_formula", "response": "Gets the cohesive energy for a material."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_reaction(self, reactants, products):\n        return self._make_request(\"/reaction\",\n                                  payload={\"reactants[]\": reactants,\n                                           \"products[]\": products}, mp_decode=False)", "response": "Gets a reaction from the Materials Project."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_substrates(self, material_id, number=50, orient=None):\n        req = \"/materials/{}/substrates?n={}\".format(material_id, number)\n        if orient:\n            req += \"&orient={}\".format(\" \".join(map(str, orient)))\n        return self._make_request(req)", "response": "Get a list of substrates for a material id."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_surface_data(self, material_id, inc_structures=False):\n        req = \"/materials/{}/surfaces\".format(material_id)\n        if inc_structures:\n            req += \"?include_structures=true\"\n        return self._make_request(req)", "response": "Gets the surface data for a material. Useful for Wulff shapes."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_wulff_shape(self, material_id):\n        from pymatgen.symmetry.analyzer import SpacegroupAnalyzer\n        from pymatgen.analysis.wulff import WulffShape, hkl_tuple_to_str\n\n        structure = self.get_structure_by_material_id(material_id)\n        surfaces = self.get_surface_data(material_id)[\"surfaces\"]\n        lattice = (SpacegroupAnalyzer(structure)\n                   .get_conventional_standard_structure().lattice)\n        miller_energy_map = {}\n        for surf in surfaces:\n            miller = tuple(surf[\"miller_index\"])\n            # Prefer reconstructed surfaces, which have lower surface energies.\n            if (miller not in miller_energy_map) or surf[\"is_reconstructed\"]:\n                miller_energy_map[miller] = surf[\"surface_energy\"]\n        millers, energies = zip(*miller_energy_map.items())\n        return WulffShape(lattice, millers, energies)", "response": "Constructs a Wulff shape for a material."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_interface_reactions(self, reactant1, reactant2,\n                                open_el=None, relative_mu=None,\n                                use_hull_energy=False):\n        \"\"\"\n        Gets critical reactions between two reactants.\n\n        Get critical reactions (\"kinks\" in the mixing ratio where\n        reaction products change) between two reactants. See the\n        `pymatgen.analysis.interface_reactions` module for more info.\n\n        Args:\n            reactant1 (str): Chemical formula for reactant\n            reactant2 (str): Chemical formula for reactant\n            open_el (str): Element in reservoir available to system\n            relative_mu (float): Relative chemical potential of element in\n                reservoir with respect to pure substance. Must be non-positive.\n            use_hull_energy (bool): Whether to use the convex hull energy for a\n            given composition for the reaction energy calculation. If false,\n            the energy of the ground state structure will be preferred; if a\n            ground state can not be found for a composition, the convex hull\n            energy will be used with a warning message.\n\n        Returns:\n            list: list of dicts of form {ratio,energy,rxn} where `ratio` is the\n                reactant mixing ratio, `energy` is the reaction energy\n                in eV/atom, and `rxn` is a\n                `pymatgen.analysis.reaction_calculator.Reaction`.\n\n        \"\"\"\n        payload = {\"reactants\": \" \".join([reactant1, reactant2]),\n                   \"open_el\": open_el,\n                   \"relative_mu\": relative_mu,\n                   \"use_hull_energy\": use_hull_energy}\n        return self._make_request(\"/interface_reactions\",\n                                  payload=payload, method=\"POST\")", "response": "Returns a list of dicts containing the critical reactions between two reactants."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nparsing a powerful and simple string criteria and generates a proper mongo syntax criteria.", "response": "def parse_criteria(criteria_string):\n        \"\"\"\n        Parses a powerful and simple string criteria and generates a proper\n        mongo syntax criteria.\n\n        Args:\n            criteria_string (str): A string representing a search criteria.\n                Also supports wild cards. E.g.,\n                something like \"*2O\" gets converted to\n                {'pretty_formula': {'$in': [u'B2O', u'Xe2O', u\"Li2O\", ...]}}\n\n                Other syntax examples:\n                    mp-1234: Interpreted as a Materials ID.\n                    Fe2O3 or *2O3: Interpreted as reduced formulas.\n                    Li-Fe-O or *-Fe-O: Interpreted as chemical systems.\n\n                You can mix and match with spaces, which are interpreted as\n                \"OR\". E.g., \"mp-1234 FeO\" means query for all compounds with\n                reduced formula FeO or with materials_id mp-1234.\n\n        Returns:\n            A mongo query dict.\n        \"\"\"\n        toks = criteria_string.split()\n\n        def parse_sym(sym):\n            if sym == \"*\":\n                return [el.symbol for el in Element]\n            else:\n                m = re.match(r\"\\{(.*)\\}\", sym)\n                if m:\n                    return [s.strip() for s in m.group(1).split(\",\")]\n                else:\n                    return [sym]\n\n        def parse_tok(t):\n            if re.match(r\"\\w+-\\d+\", t):\n                return {\"task_id\": t}\n            elif \"-\" in t:\n                elements = [parse_sym(sym) for sym in t.split(\"-\")]\n                chemsyss = []\n                for cs in itertools.product(*elements):\n                    if len(set(cs)) == len(cs):\n                        # Check for valid symbols\n                        cs = [Element(s).symbol for s in cs]\n                        chemsyss.append(\"-\".join(sorted(cs)))\n                return {\"chemsys\": {\"$in\": chemsyss}}\n            else:\n                all_formulas = set()\n                explicit_els = []\n                wild_card_els = []\n                for sym in re.findall(\n                        r\"(\\*[\\.\\d]*|\\{.*\\}[\\.\\d]*|[A-Z][a-z]*)[\\.\\d]*\", t):\n                    if (\"*\" in sym) or (\"{\" in sym):\n                        wild_card_els.append(sym)\n                    else:\n                        m = re.match(r\"([A-Z][a-z]*)[\\.\\d]*\", sym)\n                        explicit_els.append(m.group(1))\n                nelements = len(wild_card_els) + len(set(explicit_els))\n                parts = re.split(r\"(\\*|\\{.*\\})\", t)\n                parts = [parse_sym(s) for s in parts if s != \"\"]\n                for f in itertools.product(*parts):\n                    c = Composition(\"\".join(f))\n                    if len(c) == nelements:\n                        # Check for valid Elements in keys.\n                        for e in c.keys():\n                            Element(e.symbol)\n                        all_formulas.add(c.reduced_formula)\n                return {\"pretty_formula\": {\"$in\": list(all_formulas)}}\n\n        if len(toks) == 1:\n            return parse_tok(toks[0])\n        else:\n            return {\"$or\": list(map(parse_tok, toks))}"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the maximum pairwise electronegativity difference", "response": "def max_electronegativity(self):\n        '''\n        returns the maximum pairwise electronegativity difference\n        '''\n        maximum = 0\n        for e1, e2 in combinations(self.elements, 2):\n            if abs(Element(e1).X - Element(e2).X) > maximum:\n                maximum = abs(Element(e1).X - Element(e2).X)\n        return maximum"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef aos_as_list(self):\n        '''\n        Returns a list of atomic orbitals, sorted from lowest to highest energy\n        '''\n        return sorted(chain.from_iterable(\n            [self.aos[el] * int(self.composition[el]) for el in self.elements]\n        ), key=lambda x: x[2])", "response": "Returns a list of atomic orbitals sorted from lowest to highest energy\n       "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef obtain_band_edges(self):\n        '''\n        Fill up the atomic orbitals with available electrons.\n        Return HOMO, LUMO, and whether it's a metal.\n        '''\n        orbitals = self.aos_as_list()\n        electrons = Composition(self.composition).total_electrons\n        partial_filled = []\n        for orbital in orbitals:\n            if electrons <= 0:\n                break\n            if 's' in orbital[1]:\n                electrons += -2\n            elif 'p' in orbital[1]:\n                electrons += -6\n            elif 'd' in orbital[1]:\n                electrons += -10\n            elif 'f' in orbital[1]:\n                electrons += -14\n            partial_filled.append(orbital)\n\n        if electrons != 0:\n            homo = partial_filled[-1]\n            lumo = partial_filled[-1]\n        else:\n            homo = partial_filled[-1]\n            try:\n                lumo = orbitals[len(partial_filled)]\n            except:\n                lumo = None\n\n        if homo == lumo:\n            metal = True\n        else:\n            metal = False\n\n        return {'HOMO': homo, 'LUMO': lumo, 'metal': metal}", "response": "Obtain the band edges for the current atomic orbital."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef group_entries_by_structure(entries, species_to_remove=None,\n                               ltol=0.2, stol=.4, angle_tol=5,\n                               primitive_cell=True, scale=True,\n                               comparator=SpeciesComparator(),\n                               ncpus=None):\n    \"\"\"\n    Given a sequence of ComputedStructureEntries, use structure fitter to group\n    them by structural similarity.\n\n    Args:\n        entries: Sequence of ComputedStructureEntries.\n        species_to_remove: Sometimes you want to compare a host framework\n            (e.g., in Li-ion battery analysis). This allows you to specify\n            species to remove before structural comparison.\n        ltol (float): Fractional length tolerance. Default is 0.2.\n        stol (float): Site tolerance in Angstrom. Default is 0.4 Angstrom.\n        angle_tol (float): Angle tolerance in degrees. Default is 5 degrees.\n        primitive_cell (bool): If true: input structures will be reduced to\n            primitive cells prior to matching. Defaults to True.\n        scale: Input structures are scaled to equivalent volume if true;\n            For exact matching, set to False.\n        comparator: A comparator object implementing an equals method that\n            declares equivalency of sites. Default is SpeciesComparator,\n            which implies rigid species mapping.\n        ncpus: Number of cpus to use. Use of multiple cpus can greatly improve\n            fitting speed. Default of None means serial processing.\n\n    Returns:\n        Sequence of sequence of entries by structural similarity. e.g,\n        [[ entry1, entry2], [entry3, entry4, entry5]]\n    \"\"\"\n    start = datetime.datetime.now()\n    logger.info(\"Started at {}\".format(start))\n    entries_host = [(entry, _get_host(entry.structure, species_to_remove))\n                    for entry in entries]\n    if ncpus:\n        symm_entries = collections.defaultdict(list)\n        for entry, host in entries_host:\n            symm_entries[comparator.get_structure_hash(host)].append((entry,\n                                                                      host))\n        import multiprocessing as mp\n        logging.info(\"Using {} cpus\".format(ncpus))\n        manager = mp.Manager()\n        groups = manager.list()\n        p = mp.Pool(ncpus)\n        # Parallel processing only supports Python primitives and not objects.\n        p.map(_perform_grouping,\n              [(json.dumps([e[0] for e in eh], cls=MontyEncoder),\n                json.dumps([e[1] for e in eh], cls=MontyEncoder),\n                ltol, stol, angle_tol, primitive_cell, scale,\n                comparator, groups)\n               for eh in symm_entries.values()])\n    else:\n        groups = []\n        hosts = [host for entry, host in entries_host]\n        _perform_grouping((json.dumps(entries, cls=MontyEncoder),\n                           json.dumps(hosts, cls=MontyEncoder),\n                           ltol, stol, angle_tol, primitive_cell, scale,\n                           comparator, groups))\n    entry_groups = []\n    for g in groups:\n        entry_groups.append(json.loads(g, cls=MontyDecoder))\n    logging.info(\"Finished at {}\".format(datetime.datetime.now()))\n    logging.info(\"Took {}\".format(datetime.datetime.now() - start))\n    return entry_groups", "response": "Given a sequence of ComputedStructureEntries use structure fitter to group them by structural similarity."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a set containing the chemical system names in this entry.", "response": "def chemsys(self) -> set:\n        \"\"\"\n        Returns:\n            set representing the chemical system, e.g., {\"Li\", \"Fe\", \"P\", \"O\"}\n        \"\"\"\n        chemsys = set()\n        for e in self.entries:\n            chemsys.update([el.symbol for el in e.composition.keys()])\n        return chemsys"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nremove all non - ground state entries i. e. only keep the lowest energy_per_atom entry at each composition.", "response": "def remove_non_ground_states(self):\n        \"\"\"\n        Removes all non-ground state entries, i.e., only keep the lowest energy\n        per atom entry at each composition.\n        \"\"\"\n        group_func = lambda e: e.composition.reduced_formula\n        entries = sorted(self.entries, key=group_func)\n        ground_states = set()\n        for _, g in itertools.groupby(entries, key=group_func):\n            ground_states.add(min(g, key=lambda e: e.energy_per_atom))\n        self.entries = ground_states"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_subset_in_chemsys(self, chemsys: List[str]):\n        chemsys = set(chemsys)\n        if not chemsys.issubset(self.chemsys):\n            raise ValueError(\"%s is not a subset of %s\" % (chemsys,\n                                                           self.chemsys))\n        subset = set()\n        for e in self.entries:\n            elements = [sp.symbol for sp in e.composition.keys()]\n            if chemsys.issuperset(elements):\n                subset.add(e)\n        return EntrySet(subset)", "response": "Returns an EntrySet containing only the set of entries belonging to the given chemical system."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nexporting PDEntries to a CSV file.", "response": "def to_csv(self, filename: str, latexify_names: bool = False):\n        \"\"\"\n        Exports PDEntries to a csv\n\n        Args:\n            filename: Filename to write to.\n            entries: PDEntries to export.\n            latexify_names: Format entry names to be LaTex compatible,\n                e.g., Li_{2}O\n        \"\"\"\n\n        elements = set()\n        for entry in self.entries:\n            elements.update(entry.composition.elements)\n        elements = sorted(list(elements), key=lambda a: a.X)\n        writer = csv.writer(open(filename, \"w\"), delimiter=unicode2str(\",\"),\n                            quotechar=unicode2str(\"\\\"\"),\n                            quoting=csv.QUOTE_MINIMAL)\n        writer.writerow([\"Name\"] + elements + [\"Energy\"])\n        for entry in self.entries:\n            row = [entry.name if not latexify_names\n                   else re.sub(r\"([0-9]+)\", r\"_{\\1}\", entry.name)]\n            row.extend([entry.composition[el] for el in elements])\n            row.append(entry.energy)\n            writer.writerow(row)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef from_csv(cls, filename: str):\n        with open(filename, \"r\", encoding=\"utf-8\") as f:\n            reader = csv.reader(f, delimiter=unicode2str(\",\"),\n                                quotechar=unicode2str(\"\\\"\"),\n                                quoting=csv.QUOTE_MINIMAL)\n            entries = list()\n            header_read = False\n            elements = None\n            for row in reader:\n                if not header_read:\n                    elements = row[1:(len(row) - 1)]\n                    header_read = True\n                else:\n                    name = row[0]\n                    energy = float(row[-1])\n                    comp = dict()\n                    for ind in range(1, len(row) - 1):\n                        if float(row[ind]) > 0:\n                            comp[Element(elements[ind - 1])] = float(row[ind])\n                    entries.append(PDEntry(Composition(comp), energy, name))\n        return cls(entries)", "response": "Imports PDEntries from a csv file."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _parse_parameters(val_type, val):\n    if val_type == \"logical\":\n        return val == \"T\"\n    elif val_type == \"int\":\n        return int(val)\n    elif val_type == \"string\":\n        return val.strip()\n    else:\n        return float(val)", "response": "Helper function to convert a Vasprun parameter into the proper type."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _parse_v_parameters(val_type, val, filename, param_name):\n    if val_type == \"logical\":\n        val = [i == \"T\" for i in val.split()]\n    elif val_type == \"int\":\n        try:\n            val = [int(i) for i in val.split()]\n        except ValueError:\n            # Fix for stupid error in vasprun sometimes which displays\n            # LDAUL/J as 2****\n            val = _parse_from_incar(filename, param_name)\n            if val is None:\n                raise IOError(\"Error in parsing vasprun.xml\")\n    elif val_type == \"string\":\n        val = val.split()\n    else:\n        try:\n            val = [float(i) for i in val.split()]\n        except ValueError:\n            # Fix for stupid error in vasprun sometimes which displays\n            # MAGMOM as 2****\n            val = _parse_from_incar(filename, param_name)\n            if val is None:\n                raise IOError(\"Error in parsing vasprun.xml\")\n    return val", "response": "Helper function to convert a Vasprun array - type parameter into the proper base class."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _vasprun_float(f):\n    try:\n        return float(f)\n    except ValueError as e:\n        f = f.strip()\n        if f == '*' * len(f):\n            warnings.warn('Float overflow (*******) encountered in vasprun')\n            return np.nan\n        raise e", "response": "Convert a string to a float."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_band_structure_from_vasp_multiple_branches(dir_name, efermi=None,\n                                                   projections=False):\n    \"\"\"\n    This method is used to get band structure info from a VASP directory. It\n    takes into account that the run can be divided in several branches named\n    \"branch_x\". If the run has not been divided in branches the method will\n    turn to parsing vasprun.xml directly.\n\n    The method returns None is there\"s a parsing error\n\n    Args:\n        dir_name: Directory containing all bandstructure runs.\n        efermi: Efermi for bandstructure.\n        projections: True if you want to get the data on site projections if\n            any. Note that this is sometimes very large\n\n    Returns:\n        A BandStructure Object\n    \"\"\"\n    # TODO: Add better error handling!!!\n    if os.path.exists(os.path.join(dir_name, \"branch_0\")):\n        # get all branch dir names\n        branch_dir_names = [os.path.abspath(d)\n                            for d in glob.glob(\"{i}/branch_*\"\n                                               .format(i=dir_name))\n                            if os.path.isdir(d)]\n\n        # sort by the directory name (e.g, branch_10)\n        sort_by = lambda x: int(x.split(\"_\")[-1])\n        sorted_branch_dir_names = sorted(branch_dir_names, key=sort_by)\n\n        # populate branches with Bandstructure instances\n        branches = []\n        for dir_name in sorted_branch_dir_names:\n            xml_file = os.path.join(dir_name, \"vasprun.xml\")\n            if os.path.exists(xml_file):\n                run = Vasprun(xml_file, parse_projected_eigen=projections)\n                branches.append(run.get_band_structure(efermi=efermi))\n            else:\n                # It might be better to throw an exception\n                warnings.warn(\"Skipping {}. Unable to find {}\"\n                              .format(d=dir_name, f=xml_file))\n\n        return get_reconstructed_band_structure(branches, efermi)\n    else:\n        xml_file = os.path.join(dir_name, \"vasprun.xml\")\n        # Better handling of Errors\n        if os.path.exists(xml_file):\n            return Vasprun(xml_file, parse_projected_eigen=projections) \\\n                .get_band_structure(kpoints_filename=None, efermi=efermi)\n        else:\n            return None", "response": "This method gets the bandstructure information from a VASP directory. It takes into account that the run can be divided in several branches named branch_0 and branch_10."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_adjusted_fermi_level(efermi, cbm, band_structure):\n    # make a working copy of band_structure\n    bs_working = BandStructureSymmLine.from_dict(band_structure.as_dict())\n    if bs_working.is_metal():\n        e = efermi\n        while e < cbm:\n            e += 0.01\n            bs_working._efermi = e\n            if not bs_working.is_metal():\n                return e\n    return efermi", "response": "This function returns the adjusted fermi level for a given fermi energy and band minimum."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef optical_absorption_coeff(self):\n        if self.dielectric_data[\"density\"]:\n            real_avg = [sum(self.dielectric_data[\"density\"][1][i][0:3]) / 3\n                        for i in range(len(self.dielectric_data[\"density\"][0]))]\n            imag_avg = [sum(self.dielectric_data[\"density\"][2][i][0:3]) / 3\n                        for i in range(len(self.dielectric_data[\"density\"][0]))]\n\n            def f(freq, real, imag):\n                \"\"\"\n                The optical absorption coefficient calculated in terms of\n                \u0004\u0001equation\n                \"\"\"\n                hbar = 6.582119514e-16  # eV/K\n                coeff = np.sqrt(\n                    np.sqrt(real ** 2 + imag ** 2) - real) * \\\n                        np.sqrt(2) / hbar * freq\n                return coeff\n\n            absorption_coeff = [f(freq, real, imag) for freq, real, imag in\n                                zip(self.dielectric_data[\"density\"][0],\n                                    real_avg, imag_avg)]\n        return absorption_coeff", "response": "Calculates the optical absorption coefficient for the current locale."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef converged_electronic(self):\n        final_esteps = self.ionic_steps[-1][\"electronic_steps\"]\n        if 'LEPSILON' in self.incar and self.incar['LEPSILON']:\n            i = 1\n            to_check = set(['e_wo_entrp', 'e_fr_energy', 'e_0_energy'])\n            while set(final_esteps[i].keys()) == to_check:\n                i += 1\n            return i + 1 != self.parameters[\"NELM\"]\n        return len(final_esteps) < self.parameters[\"NELM\"]", "response": "Checks that the electronic step convergence has been reached in the final ionic step."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncheck that ionic step convergence has been reached i. e. that the vasp exited before reaching the max ionic steps for a relaxation run.", "response": "def converged_ionic(self):\n        \"\"\"\n        Checks that ionic step convergence has been reached, i.e. that vasp\n        exited before reaching the max ionic steps for a relaxation run\n        \"\"\"\n        nsw = self.parameters.get(\"NSW\", 0)\n        return nsw <= 1 or len(self.ionic_steps) < nsw"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the final energy from the vasp run.", "response": "def final_energy(self):\n        \"\"\"\n        Final energy from the vasp run.\n        \"\"\"\n        try:\n            final_istep = self.ionic_steps[-1]\n            if final_istep[\"e_wo_entrp\"] != final_istep[\n                'electronic_steps'][-1][\"e_0_energy\"]:\n                warnings.warn(\"Final e_wo_entrp differs from the final \"\n                              \"electronic step. VASP may have included some \"\n                              \"corrections, e.g., vdw. Vasprun will return \"\n                              \"the final e_wo_entrp, i.e., including \"\n                              \"corrections in such instances.\")\n                return final_istep[\"e_wo_entrp\"]\n            return final_istep['electronic_steps'][-1][\"e_0_energy\"]\n        except (IndexError, KeyError):\n            warnings.warn(\"Calculation does not have a total energy. \"\n                          \"Possibly a GW or similar kind of run. A value of \"\n                          \"infinity is returned.\")\n            return float('inf')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef hubbards(self):\n        symbols = [s.split()[1] for s in self.potcar_symbols]\n        symbols = [re.split(r\"_\", s)[0] for s in symbols]\n        if not self.incar.get(\"LDAU\", False):\n            return {}\n        us = self.incar.get(\"LDAUU\", self.parameters.get(\"LDAUU\"))\n        js = self.incar.get(\"LDAUJ\", self.parameters.get(\"LDAUJ\"))\n        if len(js) != len(us):\n            js = [0] * len(us)\n        if len(us) == len(symbols):\n            return {symbols[i]: us[i] - js[i] for i in range(len(symbols))}\n        elif sum(us) == 0 and sum(js) == 0:\n            return {}\n        else:\n            raise VaspParserError(\"Length of U value parameters and atomic \"\n                                  \"symbols are mismatched\")", "response": "Returns a dict of hubbard U values used if a vasprun is a GGA + U run."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef run_type(self):\n\n        METAGGA_TYPES = {\"TPSS\", \"RTPSS\", \"M06L\", \"MBJL\", \"SCAN\", \"MS0\", \"MS1\", \"MS2\"}\n\n        if self.parameters.get(\"LHFCALC\", False):\n            rt = \"HF\"\n        elif self.parameters.get(\"METAGGA\", \"\").strip().upper() in METAGGA_TYPES:\n            rt = self.parameters[\"METAGGA\"].strip().upper()\n        elif self.parameters.get(\"LUSE_VDW\", False):\n            vdw_gga = {\"RE\": \"DF\", \"OR\": \"optPBE\", \"BO\": \"optB88\",\n                       \"MK\": \"optB86b\", \"ML\": \"DF2\"}\n            gga = self.parameters.get(\"GGA\").upper()\n            rt = \"vdW-\" + vdw_gga[gga]\n        elif self.potcar_symbols[0].split()[0] == 'PAW':\n            rt = \"LDA\"\n        else:\n            rt = \"GGA\"\n        if self.is_hubbard:\n            rt += \"+U\"\n        return rt", "response": "Returns the run type of the current log entry. Currently supports LDA GGA vdW - DF and HF calcs. Currently supports LDA GGA vdW - DF and HF calcs."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns True if the run is a DFT + U run.", "response": "def is_hubbard(self):\n        \"\"\"\n        True if run is a DFT+U run.\n        \"\"\"\n        if len(self.hubbards) == 0:\n            return False\n        return sum(self.hubbards.values()) > 1e-8"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_computed_entry(self, inc_structure=True, parameters=None,\n                           data=None):\n        \"\"\"\n        Returns a ComputedStructureEntry from the vasprun.\n\n        Args:\n            inc_structure (bool): Set to True if you want\n                ComputedStructureEntries to be returned instead of\n                ComputedEntries.\n            parameters (list): Input parameters to include. It has to be one of\n                the properties supported by the Vasprun object. If\n                parameters is None, a default set of parameters that are\n                necessary for typical post-processing will be set.\n            data (list): Output data to include. Has to be one of the properties\n                supported by the Vasprun object.\n\n        Returns:\n            ComputedStructureEntry/ComputedEntry\n        \"\"\"\n        param_names = {\"is_hubbard\", \"hubbards\", \"potcar_symbols\",\n                       \"potcar_spec\", \"run_type\"}\n        if parameters:\n            param_names.update(parameters)\n        params = {p: getattr(self, p) for p in param_names}\n        data = {p: getattr(self, p) for p in data} if data is not None else {}\n\n        if inc_structure:\n            return ComputedStructureEntry(self.final_structure,\n                                          self.final_energy, parameters=params,\n                                          data=data)\n        else:\n            return ComputedEntry(self.final_structure.composition,\n                                 self.final_energy, parameters=params,\n                                 data=data)", "response": "Returns a ComputedStructureEntry from the vasprun."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_band_structure(self, kpoints_filename=None, efermi=None,\n                           line_mode=False, force_hybrid_mode=False):\n        \"\"\"\n        Returns the band structure as a BandStructure object\n\n        Args:\n            kpoints_filename (str): Full path of the KPOINTS file from which\n                the band structure is generated.\n                If none is provided, the code will try to intelligently\n                determine the appropriate KPOINTS file by substituting the\n                filename of the vasprun.xml with KPOINTS.\n                The latter is the default behavior.\n            efermi (float): If you want to specify manually the fermi energy\n                this is where you should do it. By default, the None value\n                means the code will get it from the vasprun.\n            line_mode (bool): Force the band structure to be considered as\n                a run along symmetry lines.\n            force_hybrid_mode (bool): Makes it possible to read in self-consistent band structure calculations for every type of functional\n\n        Returns:\n            a BandStructure object (or more specifically a\n            BandStructureSymmLine object if the run is detected to be a run\n            along symmetry lines)\n\n            Two types of runs along symmetry lines are accepted: non-sc with\n            Line-Mode in the KPOINT file or hybrid, self-consistent with a\n            uniform grid+a few kpoints along symmetry lines (explicit KPOINTS\n            file) (it's not possible to run a non-sc band structure with hybrid\n            functionals). The explicit KPOINTS file needs to have data on the\n            kpoint label as commentary.\n        \"\"\"\n\n        if not kpoints_filename:\n            kpoints_filename = zpath(\n                os.path.join(os.path.dirname(self.filename), 'KPOINTS'))\n        if not os.path.exists(kpoints_filename) and line_mode is True:\n            raise VaspParserError('KPOINTS needed to obtain band structure '\n                                  'along symmetry lines.')\n\n        if efermi is None:\n            efermi = self.efermi\n\n        kpoint_file = None\n        if os.path.exists(kpoints_filename):\n            kpoint_file = Kpoints.from_file(kpoints_filename)\n        lattice_new = Lattice(self.lattice_rec.matrix)\n\n        kpoints = [np.array(self.actual_kpoints[i])\n                   for i in range(len(self.actual_kpoints))]\n\n        p_eigenvals = defaultdict(list)\n        eigenvals = defaultdict(list)\n\n        nkpts = len(kpoints)\n\n        neigenvalues = [len(v) for v in self.eigenvalues[Spin.up]]\n        min_eigenvalues = min(neigenvalues)\n\n        for spin, v in self.eigenvalues.items():\n            v = np.swapaxes(v, 0, 1)\n            eigenvals[spin] = v[:, :, 0]\n\n            if self.projected_eigenvalues:\n                peigen = self.projected_eigenvalues[spin]\n                # Original axes for self.projected_eigenvalues are kpoints,\n                # band, ion, orb.\n                # For BS input, we need band, kpoints, orb, ion.\n                peigen = np.swapaxes(peigen, 0, 1)  # Swap kpoint and band axes\n                peigen = np.swapaxes(peigen, 2, 3)  # Swap ion and orb axes\n\n                p_eigenvals[spin] = peigen\n                # for b in range(min_eigenvalues):\n                #     p_eigenvals[spin].append(\n                #         [{Orbital(orb): v for orb, v in enumerate(peigen[b, k])}\n                #          for k in range(nkpts)])\n\n        # check if we have an hybrid band structure computation\n        # for this we look at the presence of the LHFCALC tag\n        hybrid_band = False\n        if self.parameters.get('LHFCALC', False) or \\\n                0. in self.actual_kpoints_weights:\n            hybrid_band = True\n\n        if kpoint_file is not None:\n            if kpoint_file.style == Kpoints.supported_modes.Line_mode:\n                line_mode = True\n\n        if line_mode:\n            labels_dict = {}\n            if hybrid_band or force_hybrid_mode:\n                start_bs_index = 0\n                for i in range(len(self.actual_kpoints)):\n                    if self.actual_kpoints_weights[i] == 0.0:\n                        start_bs_index = i\n                        break\n                for i in range(start_bs_index, len(kpoint_file.kpts)):\n                    if kpoint_file.labels[i] is not None:\n                        labels_dict[kpoint_file.labels[i]] = \\\n                            kpoint_file.kpts[i]\n                # remake the data only considering line band structure k-points\n                # (weight = 0.0 kpoints)\n                nbands = len(eigenvals[Spin.up])\n                kpoints = kpoints[start_bs_index:nkpts]\n                up_eigen = [eigenvals[Spin.up][i][start_bs_index:nkpts]\n                            for i in range(nbands)]\n                if self.projected_eigenvalues:\n                    p_eigenvals[Spin.up] = [p_eigenvals[Spin.up][i][\n                                            start_bs_index:nkpts]\n                                            for i in range(nbands)]\n                if self.is_spin:\n                    down_eigen = [eigenvals[Spin.down][i][start_bs_index:nkpts]\n                                  for i in range(nbands)]\n                    eigenvals = {Spin.up: up_eigen, Spin.down: down_eigen}\n                    if self.projected_eigenvalues:\n                        p_eigenvals[Spin.down] = [p_eigenvals[Spin.down][i][\n                                                  start_bs_index:nkpts]\n                                                  for i in range(nbands)]\n                else:\n                    eigenvals = {Spin.up: up_eigen}\n            else:\n                if '' in kpoint_file.labels:\n                    raise Exception(\"A band structure along symmetry lines \"\n                                    \"requires a label for each kpoint. \"\n                                    \"Check your KPOINTS file\")\n                labels_dict = dict(zip(kpoint_file.labels, kpoint_file.kpts))\n                labels_dict.pop(None, None)\n            return BandStructureSymmLine(kpoints, eigenvals, lattice_new,\n                                         efermi, labels_dict,\n                                         structure=self.final_structure,\n                                         projections=p_eigenvals)\n        else:\n            return BandStructure(kpoints, eigenvals, lattice_new, efermi,\n                                 structure=self.final_structure,\n                                 projections=p_eigenvals)", "response": "Returns the band structure object for the specified kpoints file and efermi."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef eigenvalue_band_properties(self):\n        vbm = -float(\"inf\")\n        vbm_kpoint = None\n        cbm = float(\"inf\")\n        cbm_kpoint = None\n        for spin, d in self.eigenvalues.items():\n            for k, val in enumerate(d):\n                for (eigenval, occu) in val:\n                    if occu > self.occu_tol and eigenval > vbm:\n                        vbm = eigenval\n                        vbm_kpoint = k\n                    elif occu <= self.occu_tol and eigenval < cbm:\n                        cbm = eigenval\n                        cbm_kpoint = k\n        return max(cbm - vbm, 0), cbm, vbm, vbm_kpoint == cbm_kpoint", "response": "Return the band properties of the eigenvalues as a tuple."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef read_pattern(self, patterns, reverse=False, terminate_on_match=False,\n                     postprocess=str):\n        \"\"\"\n        General pattern reading. Uses monty's regrep method. Takes the same\n        arguments.\n\n        Args:\n            patterns (dict): A dict of patterns, e.g.,\n                {\"energy\": r\"energy\\\\(sigma->0\\\\)\\\\s+=\\\\s+([\\\\d\\\\-.]+)\"}.\n            reverse (bool): Read files in reverse. Defaults to false. Useful for\n                large files, esp OUTCARs, especially when used with\n                terminate_on_match.\n            terminate_on_match (bool): Whether to terminate when there is at\n                least one match in each key in pattern.\n            postprocess (callable): A post processing function to convert all\n                matches. Defaults to str, i.e., no change.\n\n        Renders accessible:\n            Any attribute in patterns. For example,\n            {\"energy\": r\"energy\\\\(sigma->0\\\\)\\\\s+=\\\\s+([\\\\d\\\\-.]+)\"} will set the\n            value of self.data[\"energy\"] = [[-1234], [-3453], ...], to the\n            results from regex and postprocess. Note that the returned values\n            are lists of lists, because you can grep multiple items on one line.\n        \"\"\"\n        matches = regrep(self.filename, patterns, reverse=reverse,\n                         terminate_on_match=terminate_on_match,\n                         postprocess=postprocess)\n        for k in patterns.keys():\n            self.data[k] = [i[0] for i in matches.get(k, [])]", "response": "General pattern reading. Uses monty s regrep method."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nparsing the entire table - like data file and returns a list of tables.", "response": "def read_table_pattern(self, header_pattern, row_pattern, footer_pattern,\n                           postprocess=str, attribute_name=None,\n                           last_one_only=True):\n        \"\"\"\n        Parse table-like data. A table composes of three parts: header,\n        main body, footer. All the data matches \"row pattern\" in the main body\n        will be returned.\n\n        Args:\n            header_pattern (str): The regular expression pattern matches the\n                table header. This pattern should match all the text\n                immediately before the main body of the table. For multiple\n                sections table match the text until the section of\n                interest. MULTILINE and DOTALL options are enforced, as a\n                result, the \".\" meta-character will also match \"\\n\" in this\n                section.\n            row_pattern (str): The regular expression matches a single line in\n                the table. Capture interested field using regular expression\n                groups.\n            footer_pattern (str): The regular expression matches the end of the\n                table. E.g. a long dash line.\n            postprocess (callable): A post processing function to convert all\n                matches. Defaults to str, i.e., no change.\n            attribute_name (str): Name of this table. If present the parsed data\n                will be attached to \"data. e.g. self.data[\"efg\"] = [...]\n            last_one_only (bool): All the tables will be parsed, if this option\n                is set to True, only the last table will be returned. The\n                enclosing list will be removed. i.e. Only a single table will\n                be returned. Default to be True.\n\n        Returns:\n            List of tables. 1) A table is a list of rows. 2) A row if either a list of\n            attribute values in case the the capturing group is defined without name in\n            row_pattern, or a dict in case that named capturing groups are defined by\n            row_pattern.\n        \"\"\"\n        with zopen(self.filename, 'rt') as f:\n            text = f.read()\n        table_pattern_text = header_pattern + r\"\\s*^(?P<table_body>(?:\\s+\" + \\\n                             row_pattern + r\")+)\\s+\" + footer_pattern\n        table_pattern = re.compile(table_pattern_text, re.MULTILINE | re.DOTALL)\n        rp = re.compile(row_pattern)\n        tables = []\n        for mt in table_pattern.finditer(text):\n            table_body_text = mt.group(\"table_body\")\n            table_contents = []\n            for line in table_body_text.split(\"\\n\"):\n                ml = rp.search(line)\n                d = ml.groupdict()\n                if len(d) > 0:\n                    processed_line = {k: postprocess(v) for k, v in d.items()}\n                else:\n                    processed_line = [postprocess(v) for v in ml.groups()]\n                table_contents.append(processed_line)\n            tables.append(table_contents)\n        if last_one_only:\n            retained_data = tables[-1]\n        else:\n            retained_data = tables\n        if attribute_name is not None:\n            self.data[attribute_name] = retained_data\n        return retained_data"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nparsing the eletrostatic potential for the last ionic step", "response": "def read_electrostatic_potential(self):\n        \"\"\"\n        Parses the eletrostatic potential for the last ionic step\n        \"\"\"\n        pattern = {\"ngf\": r\"\\s+dimension x,y,z NGXF=\\s+([\\.\\-\\d]+)\\sNGYF=\\s+([\\.\\-\\d]+)\\sNGZF=\\s+([\\.\\-\\d]+)\"}\n        self.read_pattern(pattern, postprocess=int)\n        self.ngf = self.data.get(\"ngf\", [[]])[0]\n\n        pattern = {\"radii\": r\"the test charge radii are((?:\\s+[\\.\\-\\d]+)+)\"}\n        self.read_pattern(pattern, reverse=True, terminate_on_match=True, postprocess=str)\n        self.sampling_radii = [float(f) for f in self.data[\"radii\"][0][0].split()]\n\n        header_pattern = r\"\\(the norm of the test charge is\\s+[\\.\\-\\d]+\\)\"\n        table_pattern = r\"((?:\\s+\\d+\\s*[\\.\\-\\d]+)+)\"\n        footer_pattern = r\"\\s+E-fermi :\"\n\n        pots = self.read_table_pattern(header_pattern, table_pattern, footer_pattern)\n        pots = \"\".join(itertools.chain.from_iterable(pots))\n\n        pots = re.findall(r\"\\s+\\d+\\s?([\\.\\-\\d]+)+\", pots)\n        pots = [float(f) for f in pots]\n\n        self.electrostatic_potential = pots"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreading the frequency dependent dielectric function and returns a dictionary of the frequency dependent dielectric functions.", "response": "def read_freq_dielectric(self):\n        \"\"\"\n        Parses the frequency dependent dielectric function (obtained with\n        LOPTICS). Frequencies (in eV) are in self.frequencies, and dielectric\n        tensor function is given as self.dielectric_tensor_function.\n        \"\"\"\n\n        plasma_pattern = r\"plasma frequency squared.*\"\n        dielectric_pattern = r\"frequency dependent\\s+IMAGINARY \" \\\n                             r\"DIELECTRIC FUNCTION \\(independent particle, \" \\\n                             r\"no local field effects\\)(\\sdensity-density)*$\"\n        row_pattern = r\"\\s+\".join([r\"([\\.\\-\\d]+)\"] * 3)\n        plasma_frequencies = collections.defaultdict(list)\n        read_plasma = False\n        read_dielectric = False\n        energies = []\n        data = {\"REAL\": [], \"IMAGINARY\": []}\n        count = 0\n        component = \"IMAGINARY\"\n        with zopen(self.filename, \"rt\") as f:\n            for l in f:\n                l = l.strip()\n                if re.match(plasma_pattern, l):\n                    read_plasma = \"intraband\" if \"intraband\" in l else \"interband\"\n                elif re.match(dielectric_pattern, l):\n                    read_plasma = False\n                    read_dielectric = True\n                    row_pattern = r\"\\s+\".join([r\"([\\.\\-\\d]+)\"] * 7)\n\n                if read_plasma and re.match(row_pattern, l):\n                    plasma_frequencies[read_plasma].append(\n                        [float(t) for t in l.strip().split()])\n                elif read_dielectric:\n                    if re.match(row_pattern, l.strip()):\n                        toks = l.strip().split()\n                        if component == \"IMAGINARY\":\n                            energies.append(float(toks[0]))\n                        xx, yy, zz, xy, yz, xz = [float(t) for t in toks[1:]]\n                        matrix = [[xx, xy, xz], [xy, yy, yz], [xz, yz, zz]]\n                        data[component].append(matrix)\n                    elif re.match(r\"\\s*-+\\s*\", l):\n                        count += 1\n                    if count == 2:\n                        component = \"REAL\"\n                    elif count == 3:\n                        break\n\n        self.plasma_frequencies = {k: np.array(v[:3])\n                                   for k, v in plasma_frequencies.items()}\n        self.dielectric_energies = np.array(energies)\n        self.dielectric_tensor_function = np.array(data[\"REAL\"]) + \\\n                                          1j * np.array(data[\"IMAGINARY\"])"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef read_chemical_shielding(self):\n        header_pattern = r\"\\s+CSA tensor \\(J\\. Mason, Solid State Nucl\\. Magn\\. Reson\\. 2, \" \\\n                         r\"285 \\(1993\\)\\)\\s+\" \\\n                         r\"\\s+-{50,}\\s+\" \\\n                         r\"\\s+EXCLUDING G=0 CONTRIBUTION\\s+INCLUDING G=0 CONTRIBUTION\\s+\" \\\n                         r\"\\s+-{20,}\\s+-{20,}\\s+\" \\\n                         r\"\\s+ATOM\\s+ISO_SHIFT\\s+SPAN\\s+SKEW\\s+ISO_SHIFT\\s+SPAN\\s+SKEW\\s+\" \\\n                         r\"-{50,}\\s*$\"\n        first_part_pattern = r\"\\s+\\(absolute, valence only\\)\\s+$\"\n        swallon_valence_body_pattern = r\".+?\\(absolute, valence and core\\)\\s+$\"\n        row_pattern = r\"\\d+(?:\\s+[-]?\\d+\\.\\d+){3}\\s+\" + r'\\s+'.join(\n            [r\"([-]?\\d+\\.\\d+)\"] * 3)\n        footer_pattern = r\"-{50,}\\s*$\"\n        h1 = header_pattern + first_part_pattern\n        cs_valence_only = self.read_table_pattern(\n            h1, row_pattern, footer_pattern, postprocess=float,\n            last_one_only=True)\n        h2 = header_pattern + swallon_valence_body_pattern\n        cs_valence_and_core = self.read_table_pattern(\n            h2, row_pattern, footer_pattern, postprocess=float,\n            last_one_only=True)\n        all_cs = {}\n        for name, cs_table in [[\"valence_only\", cs_valence_only],\n                               [\"valence_and_core\", cs_valence_and_core]]:\n            all_cs[name] = cs_table\n        self.data[\"chemical_shielding\"] = all_cs", "response": "Parses the NMR chemical shieldings data."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nparses the \u00ab G0 contribution of NMR chemical shielding.", "response": "def read_cs_g0_contribution(self):\n        \"\"\"\n            Parse the  G0 contribution of NMR chemical shielding.\n\n            Returns:\n            G0 contribution matrix as list of list.\n        \"\"\"\n        header_pattern = r'^\\s+G\\=0 CONTRIBUTION TO CHEMICAL SHIFT \\(field along BDIR\\)\\s+$\\n' \\\n                         r'^\\s+-{50,}$\\n' \\\n                         r'^\\s+BDIR\\s+X\\s+Y\\s+Z\\s*$\\n' \\\n                         r'^\\s+-{50,}\\s*$\\n'\n        row_pattern = r'(?:\\d+)\\s+' + r'\\s+'.join([r'([-]?\\d+\\.\\d+)'] * 3)\n        footer_pattern = r'\\s+-{50,}\\s*$'\n        self.read_table_pattern(header_pattern, row_pattern, footer_pattern, postprocess=float,\n                                last_one_only=True, attribute_name=\"cs_g0_contribution\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef read_cs_core_contribution(self):\n        header_pattern = r'^\\s+Core NMR properties\\s*$\\n' \\\n                         r'\\n' \\\n                         r'^\\s+typ\\s+El\\s+Core shift \\(ppm\\)\\s*$\\n' \\\n                         r'^\\s+-{20,}$\\n'\n        row_pattern = r'\\d+\\s+(?P<element>[A-Z][a-z]?\\w?)\\s+(?P<shift>[-]?\\d+\\.\\d+)'\n        footer_pattern = r'\\s+-{20,}\\s*$'\n        self.read_table_pattern(header_pattern, row_pattern, footer_pattern, postprocess=str,\n                                last_one_only=True, attribute_name=\"cs_core_contribution\")\n        core_contrib = {d['element']: float(d['shift'])\n                        for d in self.data[\"cs_core_contribution\"]}\n        self.data[\"cs_core_contribution\"] = core_contrib", "response": "Parse the core contribution of NMR chemical shielding."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef read_cs_raw_symmetrized_tensors(self):\n        header_pattern = r\"\\s+-{50,}\\s+\" \\\n                         r\"\\s+Absolute Chemical Shift tensors\\s+\" \\\n                         r\"\\s+-{50,}$\"\n        first_part_pattern = r\"\\s+UNSYMMETRIZED TENSORS\\s+$\"\n        row_pattern = r\"\\s+\".join([r\"([-]?\\d+\\.\\d+)\"] * 3)\n        unsym_footer_pattern = r\"^\\s+SYMMETRIZED TENSORS\\s+$\"\n\n        with zopen(self.filename, 'rt') as f:\n            text = f.read()\n        unsym_table_pattern_text = header_pattern + first_part_pattern + \\\n                                   r\"(?P<table_body>.+)\" + unsym_footer_pattern\n        table_pattern = re.compile(unsym_table_pattern_text,\n                                   re.MULTILINE | re.DOTALL)\n        rp = re.compile(row_pattern)\n        m = table_pattern.search(text)\n        if m:\n            table_text = m.group(\"table_body\")\n            micro_header_pattern = r\"ion\\s+\\d+\"\n            micro_table_pattern_text = micro_header_pattern + \\\n                                       r\"\\s*^(?P<table_body>(?:\\s*\" + \\\n                                       row_pattern + r\")+)\\s+\"\n            micro_table_pattern = re.compile(micro_table_pattern_text,\n                                             re.MULTILINE | re.DOTALL)\n            unsym_tensors = []\n            for mt in micro_table_pattern.finditer(table_text):\n                table_body_text = mt.group(\"table_body\")\n                tensor_matrix = []\n                for line in table_body_text.rstrip().split(\"\\n\"):\n                    ml = rp.search(line)\n                    processed_line = [float(v) for v in ml.groups()]\n                    tensor_matrix.append(processed_line)\n                unsym_tensors.append(tensor_matrix)\n            self.data[\"unsym_cs_tensor\"] = unsym_tensors\n        else:\n            raise ValueError(\"NMR UNSYMMETRIZED TENSORS is not found\")", "response": "Parses the matrix form of NMR tensor before corrected to table."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef read_nmr_efg_tensor(self):\n\n        header_pattern = r'Electric field gradients \\(V/A\\^2\\)\\n' \\\n                         r'-*\\n' \\\n                         r' ion\\s+V_xx\\s+V_yy\\s+V_zz\\s+V_xy\\s+V_xz\\s+V_yz\\n' \\\n                         r'-*\\n'\n\n        row_pattern = r'\\d+\\s+([-\\d\\.]+)\\s+([-\\d\\.]+)\\s+([-\\d\\.]+)\\s+([-\\d\\.]+)\\s+([-\\d\\.]+)\\s+([-\\d\\.]+)'\n        footer_pattern = r'-*\\n'\n\n        data = self.read_table_pattern(header_pattern, row_pattern, footer_pattern, postprocess=float)\n        tensors = [make_symmetric_matrix_from_upper_tri(d) for d in data]\n        self.data[\"unsym_efg_tensor\"] = tensors\n        return tensors", "response": "Parses the NMR Electric Field Gradient Raw Tensors\n        returns a list of symmetrized matrices"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nparse the NMR Electric Field Gradient interpretted values.", "response": "def read_nmr_efg(self):\n        \"\"\"\n        Parse the NMR Electric Field Gradient interpretted values.\n\n        Returns:\n            Electric Field Gradient tensors as a list of dict in the order of atoms from OUTCAR.\n            Each dict key/value pair corresponds to a component of the tensors.\n        \"\"\"\n        header_pattern = r'^\\s+NMR quadrupolar parameters\\s+$\\n' \\\n                         r'^\\s+Cq : quadrupolar parameter\\s+Cq=e[*]Q[*]V_zz/h$\\n' \\\n                         r'^\\s+eta: asymmetry parameters\\s+\\(V_yy - V_xx\\)/ V_zz$\\n' \\\n                         r'^\\s+Q  : nuclear electric quadrupole moment in mb \\(millibarn\\)$\\n' \\\n                         r'^-{50,}$\\n' \\\n                         r'^\\s+ion\\s+Cq\\(MHz\\)\\s+eta\\s+Q \\(mb\\)\\s+$\\n' \\\n                         r'^-{50,}\\s*$\\n'\n        row_pattern = r'\\d+\\s+(?P<cq>[-]?\\d+\\.\\d+)\\s+(?P<eta>[-]?\\d+\\.\\d+)\\s+' \\\n                      r'(?P<nuclear_quadrupole_moment>[-]?\\d+\\.\\d+)'\n        footer_pattern = r'-{50,}\\s*$'\n        self.read_table_pattern(header_pattern, row_pattern, footer_pattern, postprocess=float,\n                                last_one_only=True, attribute_name=\"efg\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef read_elastic_tensor(self):\n        header_pattern = r\"TOTAL ELASTIC MODULI \\(kBar\\)\\s+\" \\\n                         r\"Direction\\s+([X-Z][X-Z]\\s+)+\" \\\n                         r\"\\-+\"\n        row_pattern = r\"[X-Z][X-Z]\\s+\" + r\"\\s+\".join([r\"(\\-*[\\.\\d]+)\"] * 6)\n        footer_pattern = r\"\\-+\"\n        et_table = self.read_table_pattern(header_pattern, row_pattern,\n                                           footer_pattern, postprocess=float)\n        self.data[\"elastic_tensor\"] = et_table", "response": "Parse the elastic tensor data."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef read_piezo_tensor(self):\n        header_pattern = r\"PIEZOELECTRIC TENSOR  for field in x, y, \" \\\n                         r\"z\\s+\\(C/m\\^2\\)\\s+([X-Z][X-Z]\\s+)+\\-+\"\n        row_pattern = r\"[x-z]\\s+\" + r\"\\s+\".join([r\"(\\-*[\\.\\d]+)\"] * 6)\n        footer_pattern = r\"BORN EFFECTIVE\"\n        pt_table = self.read_table_pattern(header_pattern, row_pattern,\n                                           footer_pattern, postprocess=float)\n        self.data[\"piezo_tensor\"] = pt_table", "response": "Parse the piezo tensor data"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef read_neb(self, reverse=True, terminate_on_match=True):\n        patterns = {\n            \"energy\": r\"energy\\(sigma->0\\)\\s+=\\s+([\\d\\-\\.]+)\",\n            \"tangent_force\": r\"(NEB: projections on to tangent \\(spring, REAL\\)\\s+\\S+|tangential force \\(eV/A\\))\\s+([\\d\\-\\.]+)\"\n        }\n        self.read_pattern(patterns, reverse=reverse,\n                          terminate_on_match=terminate_on_match,\n                          postprocess=str)\n        self.data[\"energy\"] = float(self.data[\"energy\"][0][0])\n        if self.data.get(\"tangent_force\"):\n            self.data[\"tangent_force\"] = float(\n                self.data[\"tangent_force\"][0][1])", "response": "Reads NEB data from the OUTCAR file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nread the internal strain tensor and populates self. internal_strain_tensor with an array of voigt notation tensors for each site.", "response": "def read_internal_strain_tensor(self):\n        \"\"\"\n        Reads the internal strain tensor and populates self.internal_strain_tensor with an array of voigt notation\n            tensors for each site.\n        \"\"\"\n        search = []\n\n        def internal_strain_start(results, match):\n            results.internal_strain_ion = int(match.group(1)) - 1\n            results.internal_strain_tensor.append(np.zeros((3, 6)))\n\n        search.append([r\"INTERNAL STRAIN TENSOR FOR ION\\s+(\\d+)\\s+for displacements in x,y,z  \\(eV/Angst\\):\",\n                       None, internal_strain_start])\n\n        def internal_strain_data(results, match):\n            if match.group(1).lower() == \"x\":\n                index = 0\n            elif match.group(1).lower() == \"y\":\n                index = 1\n            elif match.group(1).lower() == \"z\":\n                index = 2\n            else:\n                raise Exception(\n                    \"Couldn't parse row index from symbol for internal strain tensor: {}\".format(match.group(1)))\n            results.internal_strain_tensor[results.internal_strain_ion][index] = np.array([float(match.group(i))\n                                                                                           for i in range(2, 8)])\n            if index == 2:\n                results.internal_strain_ion = None\n\n        search.append([r\"^\\s+([x,y,z])\\s+\" + r\"([-]?\\d+\\.\\d+)\\s+\" * 6, lambda results,\n                                                                              line: results.internal_strain_ion is not None,\n                       internal_strain_data])\n\n        self.internal_strain_ion = None\n        self.internal_strain_tensor = []\n        micro_pyawk(self.filename, search, self)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef read_pseudo_zval(self):\n        try:\n            def poscar_line(results, match):\n                poscar_line = match.group(1)\n                results.poscar_line = re.findall(r'[A-Z][a-z]?', poscar_line)\n\n            def zvals(results, match):\n                zvals = match.group(1)\n                results.zvals = map(float, re.findall(r'-?\\d+\\.\\d*', zvals))\n\n            search = []\n            search.append([r'^.*POSCAR.*=(.*)', None, poscar_line])\n            search.append([r'^\\s+ZVAL.*=(.*)', None, zvals])\n\n            micro_pyawk(self.filename, search, self)\n\n            zval_dict = {}\n            for x, y in zip(self.poscar_line, self.zvals):\n                zval_dict.update({x: y})\n            self.zval_dict = zval_dict\n\n            # Clean-up\n            del (self.poscar_line)\n            del (self.zvals)\n        except:\n            raise Exception(\"ZVAL dict could not be parsed.\")", "response": "Read pseudopotential ZVAL dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nread the core state eigenenergies at each ionic step.", "response": "def read_core_state_eigen(self):\n        \"\"\"\n        Read the core state eigenenergies at each ionic step.\n\n        Returns:\n            A list of dict over the atom such as [{\"AO\":[core state eig]}].\n            The core state eigenenergie list for each AO is over all ionic\n            step.\n\n        Example:\n            The core state eigenenergie of the 2s AO of the 6th atom of the\n            structure at the last ionic step is [5][\"2s\"][-1]\n        \"\"\"\n\n        with zopen(self.filename, \"rt\") as foutcar:\n            line = foutcar.readline()\n            while line != \"\":\n                line = foutcar.readline()\n                if \"NIONS =\" in line:\n                    natom = int(line.split(\"NIONS =\")[1])\n                    cl = [defaultdict(list) for i in range(natom)]\n                if \"the core state eigen\" in line:\n                    iat = -1\n                    while line != \"\":\n                        line = foutcar.readline()\n                        # don't know number of lines to parse without knowing\n                        # specific species, so stop parsing when we reach\n                        # \"E-fermi\" instead\n                        if \"E-fermi\" in line:\n                            break\n                        data = line.split()\n                        # data will contain odd number of elements if it is\n                        # the start of a new entry, or even number of elements\n                        # if it continues the previous entry\n                        if len(data) % 2 == 1:\n                            iat += 1  # started parsing a new ion\n                            data = data[1:]  # remove element with ion number\n                        for i in range(0, len(data), 2):\n                            cl[iat][data[i]].append(float(data[i + 1]))\n        return cl"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreading the average core potentials at each ionic step.", "response": "def read_avg_core_poten(self):\n        \"\"\"\n        Read the core potential at each ionic step.\n\n        Returns:\n            A list for each ionic step containing a list of the average core\n            potentials for each atom: [[avg core pot]].\n\n        Example:\n            The average core potential of the 2nd atom of the structure at the\n            last ionic step is: [-1][1]\n        \"\"\"\n\n        def pairwise(iterable):\n            \"s -> (s0,s1), (s1,s2), (s2, s3), ...\"\n            a = iter(iterable)\n            return zip(a, a)\n\n        with zopen(self.filename, \"rt\") as foutcar:\n            line = foutcar.readline()\n            aps = []\n            while line != \"\":\n                line = foutcar.readline()\n                if \"the norm of the test charge is\" in line:\n                    ap = []\n                    while line != \"\":\n                        line = foutcar.readline()\n                        # don't know number of lines to parse without knowing\n                        # specific species, so stop parsing when we reach\n                        # \"E-fermi\" instead\n                        if \"E-fermi\" in line:\n                            aps.append(ap)\n                            break\n                        data = line.split()\n                        # the average core potentials of up to 5 elements are\n                        # given per line\n                        for i, pot in pairwise(data):\n                            ap.append(float(pot))\n        return aps"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreading the Fermi contact shift table from fch data", "response": "def read_fermi_contact_shift(self):\n        '''\n        output example:\n        Fermi contact (isotropic) hyperfine coupling parameter (MHz)\n        -------------------------------------------------------------\n        ion      A_pw      A_1PS     A_1AE     A_1c      A_tot\n        -------------------------------------------------------------\n         1      -0.002    -0.002    -0.051     0.000    -0.052\n         2      -0.002    -0.002    -0.051     0.000    -0.052\n         3       0.056     0.056     0.321    -0.048     0.321\n        -------------------------------------------------------------\n        , which corresponds to\n        [[-0.002, -0.002, -0.051, 0.0, -0.052],\n         [-0.002, -0.002, -0.051, 0.0, -0.052],\n         [0.056, 0.056, 0.321, -0.048, 0.321]] from 'fch' data\n        '''\n\n        # Fermi contact (isotropic) hyperfine coupling parameter (MHz)\n        header_pattern1 = r\"\\s*Fermi contact \\(isotropic\\) hyperfine coupling parameter \\(MHz\\)\\s+\" \\\n                          r\"\\s*\\-+\" \\\n                          r\"\\s*ion\\s+A_pw\\s+A_1PS\\s+A_1AE\\s+A_1c\\s+A_tot\\s+\" \\\n                          r\"\\s*\\-+\"\n        row_pattern1 = r'(?:\\d+)\\s+' + r'\\s+'.join([r'([-]?\\d+\\.\\d+)'] * 5)\n        footer_pattern = r\"\\-+\"\n        fch_table = self.read_table_pattern(header_pattern1, row_pattern1,\n                                            footer_pattern, postprocess=float,\n                                            last_one_only=True)\n\n        # Dipolar hyperfine coupling parameters (MHz)\n        header_pattern2 = r\"\\s*Dipolar hyperfine coupling parameters \\(MHz\\)\\s+\" \\\n                          r\"\\s*\\-+\" \\\n                          r\"\\s*ion\\s+A_xx\\s+A_yy\\s+A_zz\\s+A_xy\\s+A_xz\\s+A_yz\\s+\" \\\n                          r\"\\s*\\-+\"\n        row_pattern2 = r'(?:\\d+)\\s+' + r'\\s+'.join([r'([-]?\\d+\\.\\d+)'] * 6)\n        dh_table = self.read_table_pattern(header_pattern2, row_pattern2,\n                                           footer_pattern, postprocess=float,\n                                           last_one_only=True)\n\n        # Total hyperfine coupling parameters after diagonalization (MHz)\n        header_pattern3 = r\"\\s*Total hyperfine coupling parameters after diagonalization \\(MHz\\)\\s+\" \\\n                          r\"\\s*\\(convention: \\|A_zz\\| > \\|A_xx\\| > \\|A_yy\\|\\)\\s+\" \\\n                          r\"\\s*\\-+\" \\\n                          r\"\\s*ion\\s+A_xx\\s+A_yy\\s+A_zz\\s+asymmetry \\(A_yy - A_xx\\)/ A_zz\\s+\" \\\n                          r\"\\s*\\-+\"\n        row_pattern3 = r'(?:\\d+)\\s+' + r'\\s+'.join([r'([-]?\\d+\\.\\d+)'] * 4)\n        th_table = self.read_table_pattern(header_pattern3, row_pattern3,\n                                           footer_pattern, postprocess=float,\n                                           last_one_only=True)\n\n        fc_shift_table = {'fch': fch_table, 'dh': dh_table, 'th': th_table}\n\n        self.data[\"fermi_contact_shift\"] = fc_shift_table"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the grid for a particular axis.", "response": "def get_axis_grid(self, ind):\n        \"\"\"\n        Returns the grid for a particular axis.\n\n        Args:\n            ind (int): Axis index.\n        \"\"\"\n        ng = self.dim\n        num_pts = ng[ind]\n        lengths = self.structure.lattice.abc\n        return [i / num_pts * lengths[ind] for i in range(num_pts)]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef parse_file(filename):\n        poscar_read = False\n        poscar_string = []\n        dataset = []\n        all_dataset = []\n        # for holding any strings in input that are not Poscar\n        # or VolumetricData (typically augmentation charges)\n        all_dataset_aug = {}\n        dim = None\n        dimline = None\n        read_dataset = False\n        ngrid_pts = 0\n        data_count = 0\n        poscar = None\n        with zopen(filename, \"rt\") as f:\n            for line in f:\n                original_line = line\n                line = line.strip()\n                if read_dataset:\n                    toks = line.split()\n                    for tok in toks:\n                        if data_count < ngrid_pts:\n                            # This complicated procedure is necessary because\n                            # vasp outputs x as the fastest index, followed by y\n                            # then z.\n                            x = data_count % dim[0]\n                            y = int(math.floor(data_count / dim[0])) % dim[1]\n                            z = int(math.floor(data_count / dim[0] / dim[1]))\n                            dataset[x, y, z] = float(tok)\n                            data_count += 1\n                    if data_count >= ngrid_pts:\n                        read_dataset = False\n                        data_count = 0\n                        all_dataset.append(dataset)\n                elif not poscar_read:\n                    if line != \"\" or len(poscar_string) == 0:\n                        poscar_string.append(line)\n                    elif line == \"\":\n                        poscar = Poscar.from_string(\"\\n\".join(poscar_string))\n                        poscar_read = True\n                elif not dim:\n                    dim = [int(i) for i in line.split()]\n                    ngrid_pts = dim[0] * dim[1] * dim[2]\n                    dimline = line\n                    read_dataset = True\n                    dataset = np.zeros(dim)\n                elif line == dimline:\n                    # when line == dimline, expect volumetric data to follow\n                    # so set read_dataset to True\n                    read_dataset = True\n                    dataset = np.zeros(dim)\n                else:\n                    # store any extra lines that were not part of the\n                    # volumetric data so we know which set of data the extra\n                    # lines are associated with\n                    key = len(all_dataset) - 1\n                    if key not in all_dataset_aug:\n                        all_dataset_aug[key] = []\n                    all_dataset_aug[key].append(original_line)\n            if len(all_dataset) == 4:\n\n                data = {\"total\": all_dataset[0], \"diff_x\": all_dataset[1],\n                        \"diff_y\": all_dataset[2], \"diff_z\": all_dataset[3]}\n                data_aug = {\"total\": all_dataset_aug.get(0, None),\n                            \"diff_x\": all_dataset_aug.get(1, None),\n                            \"diff_y\": all_dataset_aug.get(2, None),\n                            \"diff_z\": all_dataset_aug.get(3, None)}\n\n                # construct a \"diff\" dict for scalar-like magnetization density,\n                # referenced to an arbitrary direction (using same method as\n                # pymatgen.electronic_structure.core.Magmom, see\n                # Magmom documentation for justification for this)\n                # TODO: re-examine this, and also similar behavior in\n                # Magmom - @mkhorton\n                # TODO: does CHGCAR change with different SAXIS?\n                diff_xyz = np.array([data[\"diff_x\"], data[\"diff_y\"],\n                                     data[\"diff_z\"]])\n                diff_xyz = diff_xyz.reshape((3, dim[0] * dim[1] * dim[2]))\n                ref_direction = np.array([1.01, 1.02, 1.03])\n                ref_sign = np.sign(np.dot(ref_direction, diff_xyz))\n                diff = np.multiply(np.linalg.norm(diff_xyz, axis=0), ref_sign)\n                data[\"diff\"] = diff.reshape((dim[0], dim[1], dim[2]))\n\n            elif len(all_dataset) == 2:\n                data = {\"total\": all_dataset[0], \"diff\": all_dataset[1]}\n                data_aug = {\"total\": all_dataset_aug.get(0, None),\n                            \"diff\": all_dataset_aug.get(1, None)}\n            else:\n                data = {\"total\": all_dataset[0]}\n                data_aug = {\"total\": all_dataset_aug.get(0, None)}\n            return poscar, data, data_aug", "response": "Parses a generic volumetric data file in the vasp - specific format."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef write_file(self, file_name, vasp4_compatible=False):\n\n        def _print_fortran_float(f):\n            \"\"\"\n            Fortran codes print floats with a leading zero in scientific\n            notation. When writing CHGCAR files, we adopt this convention\n            to ensure written CHGCAR files are byte-to-byte identical to\n            their input files as far as possible.\n            :param f: float\n            :return: str\n            \"\"\"\n            s = \"{:.10E}\".format(f)\n            if f >= 0:\n                return \"0.\" + s[0] + s[2:12] + 'E' + \"{:+03}\".format(int(s[13:]) + 1)\n            else:\n                return \"-.\" + s[1] + s[3:13] + 'E' + \"{:+03}\".format(int(s[14:]) + 1)\n\n        with zopen(file_name, \"wt\") as f:\n            p = Poscar(self.structure)\n\n            # use original name if it's been set (e.g. from Chgcar)\n            comment = getattr(self, 'name', p.comment)\n\n            lines = comment + \"\\n\"\n            lines += \"   1.00000000000000\\n\"\n            latt = self.structure.lattice.matrix\n            lines += \" %12.6f%12.6f%12.6f\\n\" % tuple(latt[0, :])\n            lines += \" %12.6f%12.6f%12.6f\\n\" % tuple(latt[1, :])\n            lines += \" %12.6f%12.6f%12.6f\\n\" % tuple(latt[2, :])\n            if not vasp4_compatible:\n                lines += \"\".join([\"%5s\" % s for s in p.site_symbols]) + \"\\n\"\n            lines += \"\".join([\"%6d\" % x for x in p.natoms]) + \"\\n\"\n            lines += \"Direct\\n\"\n            for site in self.structure:\n                lines += \"%10.6f%10.6f%10.6f\\n\" % tuple(site.frac_coords)\n            lines += \" \\n\"\n            f.write(lines)\n            a = self.dim\n\n            def write_spin(data_type):\n                lines = []\n                count = 0\n                f.write(\"   {}   {}   {}\\n\".format(a[0], a[1], a[2]))\n                for (k, j, i) in itertools.product(list(range(a[2])),\n                                                   list(range(a[1])),\n                                                   list(range(a[0]))):\n                    lines.append(_print_fortran_float(self.data[data_type][i, j, k]))\n                    count += 1\n                    if count % 5 == 0:\n                        f.write(\" \" + \"\".join(lines) + \"\\n\")\n                        lines = []\n                    else:\n                        lines.append(\" \")\n                f.write(\" \" + \"\".join(lines) + \" \\n\")\n                f.write(\"\".join(self.data_aug.get(data_type, [])))\n\n            write_spin(\"total\")\n            if self.is_spin_polarized and self.is_soc:\n                write_spin(\"diff_x\")\n                write_spin(\"diff_y\")\n                write_spin(\"diff_z\")\n            elif self.is_spin_polarized:\n                write_spin(\"diff\")", "response": "Writes the VolumetricData object to a vasp compatible file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the integrated difference of atom index ind up to radius.", "response": "def get_integrated_diff(self, ind, radius, nbins=1):\n        \"\"\"\n        Get integrated difference of atom index ind up to radius. This can be\n        an extremely computationally intensive process, depending on how many\n        grid points are in the VolumetricData.\n\n        Args:\n            ind (int): Index of atom.\n            radius (float): Radius of integration.\n            nbins (int): Number of bins. Defaults to 1. This allows one to\n                obtain the charge integration up to a list of the cumulative\n                charge integration values for radii for [radius/nbins,\n                2 * radius/nbins, ....].\n\n        Returns:\n            Differential integrated charge as a np array of [[radius, value],\n            ...]. Format is for ease of plotting. E.g., plt.plot(data[:,0],\n            data[:,1])\n        \"\"\"\n        # For non-spin-polarized runs, this is zero by definition.\n        if not self.is_spin_polarized:\n            radii = [radius / nbins * (i + 1) for i in range(nbins)]\n            data = np.zeros((nbins, 2))\n            data[:, 0] = radii\n            return data\n\n        struct = self.structure\n        a = self.dim\n        if ind not in self._distance_matrix or \\\n                self._distance_matrix[ind][\"max_radius\"] < radius:\n            coords = []\n            for (x, y, z) in itertools.product(*[list(range(i)) for i in a]):\n                coords.append([x / a[0], y / a[1], z / a[2]])\n            sites_dist = struct.lattice.get_points_in_sphere(\n                coords, struct[ind].coords, radius)\n            self._distance_matrix[ind] = {\"max_radius\": radius,\n                                          \"data\": np.array(sites_dist)}\n\n        data = self._distance_matrix[ind][\"data\"]\n\n        # Use boolean indexing to find all charges within the desired distance.\n        inds = data[:, 1] <= radius\n        dists = data[inds, 1]\n        data_inds = np.rint(np.mod(list(data[inds, 0]), 1) *\n                            np.tile(a, (len(dists), 1))).astype(int)\n        vals = [self.data[\"diff\"][x, y, z] for x, y, z in data_inds]\n\n        hist, edges = np.histogram(dists, bins=nbins,\n                                   range=[0, radius],\n                                   weights=vals)\n        data = np.zeros((nbins, 2))\n        data[:, 0] = edges[1:]\n        data[:, 1] = [sum(hist[0:i + 1]) / self.ngridpts\n                      for i in range(nbins)]\n        return data"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_average_along_axis(self, ind):\n        m = self.data[\"total\"]\n        ng = self.dim\n        if ind == 0:\n            total = np.sum(np.sum(m, axis=1), 1)\n        elif ind == 1:\n            total = np.sum(np.sum(m, axis=0), 1)\n        else:\n            total = np.sum(np.sum(m, axis=0), 0)\n        return total / ng[(ind + 1) % 3] / ng[(ind + 2) % 3]", "response": "Get the averaged total of the volumetric data along a certain axis."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef to_hdf5(self, filename):\n        import h5py\n        with h5py.File(filename, \"w\") as f:\n            ds = f.create_dataset(\"lattice\", (3, 3), dtype='float')\n            ds[...] = self.structure.lattice.matrix\n            ds = f.create_dataset(\"Z\", (len(self.structure.species),),\n                                  dtype=\"i\")\n            ds[...] = np.array([sp.Z for sp in self.structure.species])\n            ds = f.create_dataset(\"fcoords\", self.structure.frac_coords.shape,\n                                  dtype='float')\n            ds[...] = self.structure.frac_coords\n            dt = h5py.special_dtype(vlen=str)\n            ds = f.create_dataset(\"species\", (len(self.structure.species),),\n                                  dtype=dt)\n            ds[...] = [str(sp) for sp in self.structure.species]\n            grp = f.create_group(\"vdata\")\n            for k, v in self.data.items():\n                ds = grp.create_dataset(k, self.data[k].shape, dtype='float')\n                ds[...] = self.data[k]\n            f.attrs[\"name\"] = self.name\n            f.attrs[\"structure_json\"] = json.dumps(self.structure.as_dict())", "response": "Writes the VolumetricData to a HDF5 file."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the occupation for a particular orbital of a particular atom.", "response": "def get_occupation(self, atom_index, orbital):\n        \"\"\"\n        Returns the occupation for a particular orbital of a particular atom.\n\n        Args:\n            atom_num (int): Index of atom in the PROCAR. It should be noted\n                that VASP uses 1-based indexing for atoms, but this is\n                converted to 0-based indexing in this parser to be\n                consistent with representation of structures in pymatgen.\n            orbital (str): An orbital. If it is a single character, e.g., s,\n                p, d or f, the sum of all s-type, p-type, d-type or f-type\n                orbitals occupations are returned respectively. If it is a\n                specific orbital, e.g., px, dxy, etc., only the occupation\n                of that orbital is returned.\n\n        Returns:\n            Sum occupation of orbital of atom.\n        \"\"\"\n\n        orbital_index = self.orbitals.index(orbital)\n        return {spin: np.sum(d[:, :, atom_index, orbital_index] * self.weights[:, None])\n                for spin, d in self.data.items()}"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a tuple of all energies from all electronic steps and ionic steps as a list of energies", "response": "def all_energies(self):\n        \"\"\"\n        Compilation of all energies from all electronic steps and ionic steps\n        as a tuple of list of energies, e.g.,\n        ((4507.24605593, 143.824705755, -512.073149912, ...), ...)\n        \"\"\"\n        all_energies = []\n        for i in range(len(self.electronic_steps)):\n            energies = [step[\"E\"] for step in self.electronic_steps[i]]\n            energies.append(self.ionic_steps[i][\"F\"])\n            all_energies.append(tuple(energies))\n        return tuple(all_energies)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef site_symbols(self):\n        syms = [site.specie.symbol for site in self.structures[0]]\n        return [a[0] for a in itertools.groupby(syms)]", "response": "Sequence of symbols associated with the Xdatcar."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nsequence of number of sites of each type associated with the Poscar.", "response": "def natoms(self):\n        \"\"\"\n        Sequence of number of sites of each type associated with the Poscar.\n        Similar to 7th line in vasp 5+ Xdatcar.\n        \"\"\"\n        syms = [site.specie.symbol for site in self.structures[0]]\n        return [len(tuple(a[1])) for a in itertools.groupby(syms)]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_string(self, ionicstep_start=1,\n                   ionicstep_end=None,\n                   significant_figures=8):\n        \"\"\"\n        Write  Xdatcar class into a file\n        Args:\n            filename (str): Filename of output XDATCAR file.\n            ionicstep_start (int): Starting number of ionic step.\n            ionicstep_end (int): Ending number of ionic step.\n        \"\"\"\n        from pymatgen.io.vasp import Poscar\n        if (ionicstep_start < 1):\n            raise Exception('Start ionic step cannot be less than 1')\n        if (ionicstep_end is not None and\n                ionicstep_start < 1):\n            raise Exception('End ionic step cannot be less than 1')\n        latt = self.structures[0].lattice\n        if np.linalg.det(latt.matrix) < 0:\n            latt = Lattice(-latt.matrix)\n        lines = [self.comment, \"1.0\", str(latt)]\n        lines.append(\" \".join(self.site_symbols))\n        lines.append(\" \".join([str(x) for x in self.natoms]))\n        format_str = \"{{:.{0}f}}\".format(significant_figures)\n        ionicstep_cnt = 1\n        output_cnt = 1\n        for cnt, structure in enumerate(self.structures):\n            ionicstep_cnt = cnt + 1\n            if ionicstep_end is None:\n                if (ionicstep_cnt >= ionicstep_start):\n                    lines.append(\"Direct configuration=\" +\n                                 ' ' * (7 - len(str(output_cnt))) + str(output_cnt))\n                    for (i, site) in enumerate(structure):\n                        coords = site.frac_coords\n                        line = \" \".join([format_str.format(c) for c in coords])\n                        lines.append(line)\n                    output_cnt += 1\n            else:\n                if ionicstep_start <= ionicstep_cnt < ionicstep_end:\n                    lines.append(\"Direct configuration=\" +\n                                 ' ' * (7 - len(str(output_cnt))) + str(output_cnt))\n                    for (i, site) in enumerate(structure):\n                        coords = site.frac_coords\n                        line = \" \".join([format_str.format(c) for c in coords])\n                        lines.append(line)\n                    output_cnt += 1\n        return \"\\n\".join(lines) + \"\\n\"", "response": "Return a string representation of the XDATCAR file."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef evaluate_wavefunc(self, kpoint, band, r, spin=0):\n        v = self.Gpoints[kpoint] + self.kpoints[kpoint]\n        u = np.dot(np.dot(v, self.b), r)\n        c = self.coeffs[spin][kpoint][band] if self.spin == 2 else \\\n            self.coeffs[kpoint][band]\n        return np.sum(np.dot(c, np.exp(1j * u, dtype=np.complex64))) / \\\n               np.sqrt(self.vol)", "response": "Evaluates the wavefunction at a given position r."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef fft_mesh(self, kpoint, band, spin=0, shift=True):\n        mesh = np.zeros(tuple(self.ng), dtype=np.complex)\n        tcoeffs = self.coeffs[spin][kpoint][band] if self.spin == 2 else \\\n            self.coeffs[kpoint][band]\n        for gp, coeff in zip(self.Gpoints[kpoint], tcoeffs):\n            t = tuple(gp.astype(np.int) + (self.ng / 2).astype(np.int))\n            mesh[t] = coeff\n        if shift:\n            return np.fft.ifftshift(mesh)\n        else:\n            return mesh", "response": "This function takes a wavefunction and returns a 3D mesh of the coefficients of the wavefunction at the specified kpoint and band."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ngenerate a Chgcar object, which is the charge density of the specified wavefunction. This function generates a Chgcar object with the charge density of the wavefunction specified by band and kpoint (and spin, if the WAVECAR corresponds to a spin-polarized calculation). The phase tag is a feature that is not present in VASP. For a real wavefunction, the phase tag being turned on means that the charge density is multiplied by the sign of the wavefunction at that point in space. A warning is generated if the phase tag is on and the chosen kpoint is not Gamma. Note: Augmentation from the PAWs is NOT included in this function. The maximal charge density will differ from the PARCHG from VASP, but the qualitative shape of the charge density will match. Args: poscar (pymatgen.io.vasp.inputs.Poscar): Poscar object that has the structure associated with the WAVECAR file kpoint (int): the index of the kpoint for the wavefunction band (int): the index of the band for the wavefunction spin (int): optional argument to specify the spin. If the Wavecar has ISPIN = 2, spin == None generates a Chgcar with total spin and magnetization, and spin == {0, 1} specifies just the spin up or down component. phase (bool): flag to determine if the charge density is multiplied by the sign of the wavefunction. Only valid for real wavefunctions. scale (int): scaling for the FFT grid. The default value of 2 is at least as fine as the VASP default. Returns: a pymatgen.io.vasp.outputs.Chgcar object", "response": "def get_parchg(self, poscar, kpoint, band, spin=None, phase=False,\n                   scale=2):\n        \"\"\"\n        Generates a Chgcar object, which is the charge density of the specified\n        wavefunction.\n\n        This function generates a Chgcar object with the charge density of the\n        wavefunction specified by band and kpoint (and spin, if the WAVECAR\n        corresponds to a spin-polarized calculation). The phase tag is a\n        feature that is not present in VASP. For a real wavefunction, the phase\n        tag being turned on means that the charge density is multiplied by the\n        sign of the wavefunction at that point in space. A warning is generated\n        if the phase tag is on and the chosen kpoint is not Gamma.\n\n        Note: Augmentation from the PAWs is NOT included in this function. The\n        maximal charge density will differ from the PARCHG from VASP, but the\n        qualitative shape of the charge density will match.\n\n        Args:\n            poscar (pymatgen.io.vasp.inputs.Poscar): Poscar object that has the\n                                structure associated with the WAVECAR file\n            kpoint (int):   the index of the kpoint for the wavefunction\n            band (int):     the index of the band for the wavefunction\n            spin (int):     optional argument to specify the spin. If the\n                                Wavecar has ISPIN = 2, spin == None generates a\n                                Chgcar with total spin and magnetization, and\n                                spin == {0, 1} specifies just the spin up or\n                                down component.\n            phase (bool):   flag to determine if the charge density is\n                                multiplied by the sign of the wavefunction.\n                                Only valid for real wavefunctions.\n            scale (int):    scaling for the FFT grid. The default value of 2 is\n                                at least as fine as the VASP default.\n        Returns:\n            a pymatgen.io.vasp.outputs.Chgcar object\n        \"\"\"\n\n        if phase and not np.all(self.kpoints[kpoint] == 0.):\n            warnings.warn('phase == True should only be used for the Gamma '\n                          'kpoint! I hope you know what you\\'re doing!')\n\n        # scaling of ng for the fft grid, need to restore value at the end\n        temp_ng = self.ng\n        self.ng = self.ng * scale\n        N = np.prod(self.ng)\n\n        data = {}\n        if self.spin == 2:\n            if spin is not None:\n                wfr = np.fft.ifftn(self.fft_mesh(kpoint, band, spin=spin)) * N\n                den = np.abs(np.conj(wfr) * wfr)\n                if phase:\n                    den = np.sign(np.real(wfr)) * den\n                data['total'] = den\n            else:\n                wfr = np.fft.ifftn(self.fft_mesh(kpoint, band, spin=0)) * N\n                denup = np.abs(np.conj(wfr) * wfr)\n                wfr = np.fft.ifftn(self.fft_mesh(kpoint, band, spin=1)) * N\n                dendn = np.abs(np.conj(wfr) * wfr)\n                data['total'] = denup + dendn\n                data['diff'] = denup - dendn\n        else:\n            wfr = np.fft.ifftn(self.fft_mesh(kpoint, band)) * N\n            den = np.abs(np.conj(wfr) * wfr)\n            if phase:\n                den = np.sign(np.real(wfr)) * den\n            data['total'] = den\n\n        self.ng = temp_ng\n        return Chgcar(poscar, data)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef from_rotation_and_translation(\n            rotation_matrix=((1, 0, 0), (0, 1, 0), (0, 0, 1)),\n            translation_vec=(0, 0, 0), tol=0.1):\n        \"\"\"\n        Creates a symmetry operation from a rotation matrix and a translation\n        vector.\n\n        Args:\n            rotation_matrix (3x3 array): Rotation matrix.\n            translation_vec (3x1 array): Translation vector.\n            tol (float): Tolerance to determine if rotation matrix is valid.\n\n        Returns:\n            SymmOp object\n        \"\"\"\n        rotation_matrix = np.array(rotation_matrix)\n        translation_vec = np.array(translation_vec)\n        if rotation_matrix.shape != (3, 3):\n            raise ValueError(\"Rotation Matrix must be a 3x3 numpy array.\")\n        if translation_vec.shape != (3,):\n            raise ValueError(\"Translation vector must be a rank 1 numpy array \"\n                             \"with 3 elements.\")\n        affine_matrix = np.eye(4)\n        affine_matrix[0:3][:, 0:3] = rotation_matrix\n        affine_matrix[0:3][:, 3] = translation_vec\n        return SymmOp(affine_matrix, tol)", "response": "Creates a SymmOp object from a rotation matrix and a translation vector."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef operate(self, point):\n        affine_point = np.array([point[0], point[1], point[2], 1])\n        return np.dot(self.affine_matrix, affine_point)[0:3]", "response": "Apply the operation on a point."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef operate_multi(self, points):\n        points = np.array(points)\n        affine_points = np.concatenate(\n            [points, np.ones(points.shape[:-1] + (1,))], axis=-1)\n        return np.inner(affine_points, self.affine_matrix)[..., :-1]", "response": "Apply the operation on a list of points."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\napplying rotation portion to a tensor.", "response": "def transform_tensor(self, tensor):\n        \"\"\"\n        Applies rotation portion to a tensor. Note that tensor has to be in\n        full form, not the Voigt form.\n\n        Args:\n            tensor (numpy array): a rank n tensor\n\n        Returns:\n            Transformed tensor.\n        \"\"\"\n        dim = tensor.shape\n        rank = len(dim)\n        assert all([i == 3 for i in dim])\n        # Build einstein sum string\n        lc = string.ascii_lowercase\n        indices = lc[:rank], lc[rank:2 * rank]\n        einsum_string = ','.join([a + i for a, i in zip(*indices)])\n        einsum_string += ',{}->{}'.format(*indices[::-1])\n        einsum_args = [self.rotation_matrix] * rank + [tensor]\n\n        return np.einsum(einsum_string, *einsum_args)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef are_symmetrically_related(self, point_a, point_b, tol=0.001):\n        if np.allclose(self.operate(point_a), point_b, atol=tol):\n            return True\n        if np.allclose(self.operate(point_b), point_a, atol=tol):\n            return True\n        return False", "response": "Checks if two points are symmetrically related."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef inverse(self):\n        invr = np.linalg.inv(self.affine_matrix)\n        return SymmOp(invr)", "response": "Returns inverse of transformation."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngenerating a SymmOp for a rotation about a given axis and a translation vector.", "response": "def from_axis_angle_and_translation(axis, angle, angle_in_radians=False,\n                                        translation_vec=(0, 0, 0)):\n        \"\"\"\n        Generates a SymmOp for a rotation about a given axis plus translation.\n\n        Args:\n            axis: The axis of rotation in cartesian space. For example,\n                [1, 0, 0]indicates rotation about x-axis.\n            angle (float): Angle of rotation.\n            angle_in_radians (bool): Set to True if angles are given in\n                radians. Or else, units of degrees are assumed.\n            translation_vec: A translation vector. Defaults to zero.\n\n        Returns:\n            SymmOp for a rotation about given axis and translation.\n        \"\"\"\n        if isinstance(axis, (tuple, list)):\n            axis = np.array(axis)\n\n        if isinstance(translation_vec, (tuple, list)):\n            vec = np.array(translation_vec)\n        else:\n            vec = translation_vec\n\n        a = angle if angle_in_radians else angle * pi / 180\n        cosa = cos(a)\n        sina = sin(a)\n        u = axis / np.linalg.norm(axis)\n        r = np.zeros((3, 3))\n        r[0, 0] = cosa + u[0] ** 2 * (1 - cosa)\n        r[0, 1] = u[0] * u[1] * (1 - cosa) - u[2] * sina\n        r[0, 2] = u[0] * u[2] * (1 - cosa) + u[1] * sina\n        r[1, 0] = u[0] * u[1] * (1 - cosa) + u[2] * sina\n        r[1, 1] = cosa + u[1] ** 2 * (1 - cosa)\n        r[1, 2] = u[1] * u[2] * (1 - cosa) - u[0] * sina\n        r[2, 0] = u[0] * u[2] * (1 - cosa) - u[1] * sina\n        r[2, 1] = u[1] * u[2] * (1 - cosa) + u[0] * sina\n        r[2, 2] = cosa + u[2] ** 2 * (1 - cosa)\n\n        return SymmOp.from_rotation_and_translation(r, vec)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef from_origin_axis_angle(origin, axis, angle, angle_in_radians=False):\n        theta = angle * pi / 180 if not angle_in_radians else angle\n        a = origin[0]\n        b = origin[1]\n        c = origin[2]\n        u = axis[0]\n        v = axis[1]\n        w = axis[2]\n        # Set some intermediate values.\n        u2 = u * u\n        v2 = v * v\n        w2 = w * w\n        cos_t = cos(theta)\n        sin_t = sin(theta)\n        l2 = u2 + v2 + w2\n        l = sqrt(l2)\n\n        # Build the matrix entries element by element.\n        m11 = (u2 + (v2 + w2) * cos_t) / l2\n        m12 = (u * v * (1 - cos_t) - w * l * sin_t) / l2\n        m13 = (u * w * (1 - cos_t) + v * l * sin_t) / l2\n        m14 = (a * (v2 + w2) - u * (b * v + c * w) +\n               (u * (b * v + c * w) - a * (v2 + w2)) * cos_t +\n               (b * w - c * v) * l * sin_t) / l2\n\n        m21 = (u * v * (1 - cos_t) + w * l * sin_t) / l2\n        m22 = (v2 + (u2 + w2) * cos_t) / l2\n        m23 = (v * w * (1 - cos_t) - u * l * sin_t) / l2\n        m24 = (b * (u2 + w2) - v * (a * u + c * w) +\n               (v * (a * u + c * w) - b * (u2 + w2)) * cos_t +\n               (c * u - a * w) * l * sin_t) / l2\n\n        m31 = (u * w * (1 - cos_t) - v * l * sin_t) / l2\n        m32 = (v * w * (1 - cos_t) + u * l * sin_t) / l2\n        m33 = (w2 + (u2 + v2) * cos_t) / l2\n        m34 = (c * (u2 + v2) - w * (a * u + b * v) +\n               (w * (a * u + b * v) - c * (u2 + v2)) * cos_t +\n               (a * v - b * u) * l * sin_t) / l2\n\n        return SymmOp([[m11, m12, m13, m14], [m21, m22, m23, m24],\n                       [m31, m32, m33, m34], [0, 0, 0, 1]])", "response": "Generates a SymmOp for a rotation about a given axis through an origin."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the reflection symmetry operation for the current object.", "response": "def reflection(normal, origin=(0, 0, 0)):\n        \"\"\"\n        Returns reflection symmetry operation.\n\n        Args:\n            normal (3x1 array): Vector of the normal to the plane of\n                reflection.\n            origin (3x1 array): A point in which the mirror plane passes\n                through.\n\n        Returns:\n            SymmOp for the reflection about the plane\n        \"\"\"\n        # Normalize the normal vector first.\n        n = np.array(normal, dtype=float) / np.linalg.norm(normal)\n\n        u, v, w = n\n\n        translation = np.eye(4)\n        translation[0:3, 3] = -np.array(origin)\n\n        xx = 1 - 2 * u ** 2\n        yy = 1 - 2 * v ** 2\n        zz = 1 - 2 * w ** 2\n        xy = -2 * u * v\n        xz = -2 * u * w\n        yz = -2 * v * w\n        mirror_mat = [[xx, xy, xz, 0], [xy, yy, yz, 0], [xz, yz, zz, 0],\n                      [0, 0, 0, 1]]\n\n        if np.linalg.norm(origin) > 1e-6:\n            mirror_mat = np.dot(np.linalg.inv(translation),\n                                np.dot(mirror_mat, translation))\n        return SymmOp(mirror_mat)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a roto - reflection symmetry operation that rotates the object with the specified axis and angle.", "response": "def rotoreflection(axis, angle, origin=(0, 0, 0)):\n        \"\"\"\n        Returns a roto-reflection symmetry operation\n\n        Args:\n            axis (3x1 array): Axis of rotation / mirror normal\n            angle (float): Angle in degrees\n            origin (3x1 array): Point left invariant by roto-reflection.\n                Defaults to (0, 0, 0).\n\n        Return:\n            Roto-reflection operation\n        \"\"\"\n        rot = SymmOp.from_origin_axis_angle(origin, axis, angle)\n        refl = SymmOp.reflection(axis, origin)\n        m = np.dot(rot.affine_matrix, refl.affine_matrix)\n        return SymmOp(m)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a string of the form x y z", "response": "def as_xyz_string(self):\n        \"\"\"\n        Returns a string of the form 'x, y, z', '-x, -y, z',\n        '-y+1/2, x+1/2, z+1/2', etc. Only works for integer rotation matrices\n        \"\"\"\n        xyz = ['x', 'y', 'z']\n        strings = []\n\n        # test for invalid rotation matrix\n        if not np.all(np.isclose(self.rotation_matrix,\n                                 np.round(self.rotation_matrix))):\n            warnings.warn('Rotation matrix should be integer')\n\n        return transformation_to_string(self.rotation_matrix, translation_vec=self.translation_vector, delim=\", \")"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\napplying time reversal operator on the magnetic moment.", "response": "def operate_magmom(self, magmom):\n        \"\"\"\n        Apply time reversal operator on the magnetic moment. Note that\n        magnetic moments transform as axial vectors, not polar vectors. \n\n        See 'Symmetry and magnetic structures', Rodr\u00edguez-Carvajal and\n        Bour\u00e9e for a good discussion. DOI: 10.1051/epjconf/20122200010\n\n        Args:\n            magmom: Magnetic moment as electronic_structure.core.Magmom\n            class or as list or np array-like\n\n        Returns:\n            Magnetic moment after operator applied as Magmom class\n        \"\"\"\n\n        magmom = Magmom(magmom)  # type casting to handle lists as input\n\n        transformed_moment = self.apply_rotation_only(magmom.global_moment) * \\\n            np.linalg.det(self.rotation_matrix) * self.time_reversal\n\n        # retains input spin axis if different from default\n        return Magmom.from_global_moment_and_saxis(transformed_moment, magmom.saxis)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef from_symmop(cls, symmop, time_reversal):\n        magsymmop = cls(symmop.affine_matrix, time_reversal, symmop.tol)\n        return magsymmop", "response": "Initialize a MagSymmOp object from a SymmOp and time reversal operator."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef from_rotation_and_translation_and_time_reversal(\n            rotation_matrix=((1, 0, 0), (0, 1, 0), (0, 0, 1)),\n            translation_vec=(0, 0, 0), time_reversal=1, tol=0.1):\n        \"\"\"\n        Creates a symmetry operation from a rotation matrix, translation\n        vector and time reversal operator.\n\n        Args:\n            rotation_matrix (3x3 array): Rotation matrix.\n            translation_vec (3x1 array): Translation vector.\n            time_reversal (int): Time reversal operator, +1 or -1.\n            tol (float): Tolerance to determine if rotation matrix is valid.\n\n        Returns:\n            MagSymmOp object\n        \"\"\"\n        symmop = SymmOp.from_rotation_and_translation(rotation_matrix=rotation_matrix,\n                                                      translation_vec=translation_vec,\n                                                      tol=tol)\n        return MagSymmOp.from_symmop(symmop, time_reversal)", "response": "Creates a symmetry operation from a rotation matrix translation vector and time reversal operator."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef from_xyzt_string(xyzt_string):\n        symmop = SymmOp.from_xyz_string(xyzt_string.rsplit(',', 1)[0])\n        try:\n            time_reversal = int(xyzt_string.rsplit(',', 1)[1])\n        except:\n            raise Exception(\"Time reversal operator could not be parsed.\")\n        return MagSymmOp.from_symmop(symmop, time_reversal)", "response": "Returns a new object from a string containing the string representation of a set of system - specific elements."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef as_xyzt_string(self):\n        xyzt_string = SymmOp.as_xyz_string(self)\n        return xyzt_string + \", {:+}\".format(self.time_reversal)", "response": "Returns the string representation of the current object as a xyzt string."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating a new instance of the class object from a Molecule object.", "response": "def from_molecule(cls, mol, theory, charge=None, spin_multiplicity=None,\n                      basis_set=\"6-31g\", basis_set_option=\"cartesian\",\n                      title=None, operation=\"optimize\", theory_directives=None,\n                      alternate_directives=None):\n        \"\"\"\n        Very flexible arguments to support many types of potential setups.\n        Users should use more friendly static methods unless they need the\n        flexibility.\n\n        Args:\n            mol: Input molecule\n            charge: Charge of the molecule. If None, charge on molecule is\n                used. Defaults to None. This allows the input file to be set a\n                charge independently from the molecule itself.\n            spin_multiplicity: Spin multiplicity of molecule. Defaults to None,\n                which means that the spin multiplicity is set to 1 if the\n                molecule has no unpaired electrons and to 2 if there are\n                unpaired electrons.\n            basis_set: The basis set to be used as string or a dict. E.g.,\n                {\"C\": \"6-311++G**\", \"H\": \"6-31++G**\"} or \"6-31G\". If string,\n                same basis set is used for all elements.\n            basis_set_option: cartesian (default) | spherical,\n            title: Title for the task. Defaults to None, which means a title\n                based on the theory and operation of the task is\n                autogenerated.\n            theory: The theory used for the task. Defaults to \"dft\".\n            operation: The operation for the task. Defaults to \"optimize\".\n            theory_directives: A dict of theory directives. For example,\n                if you are running dft calculations, you may specify the\n                exchange correlation functional using {\"xc\": \"b3lyp\"}.\n            alternate_directives: A dict of alternate directives. For\n                example, to perform cosmo calculations with DFT, you'd supply\n                {'cosmo': \"cosmo\"}.\n        \"\"\"\n        title = title if title is not None else \"{} {} {}\".format(\n            re.sub(r\"\\s\", \"\", mol.formula), theory, operation)\n\n        charge = charge if charge is not None else mol.charge\n        nelectrons = - charge + mol.charge + mol.nelectrons\n        if spin_multiplicity is not None:\n            spin_multiplicity = spin_multiplicity\n            if (nelectrons + spin_multiplicity) % 2 != 1:\n                raise ValueError(\n                    \"Charge of {} and spin multiplicity of {} is\"\n                    \" not possible for this molecule\".format(\n                        charge, spin_multiplicity))\n        elif charge == mol.charge:\n            spin_multiplicity = mol.spin_multiplicity\n        else:\n            spin_multiplicity = 1 if nelectrons % 2 == 0 else 2\n\n        elements = set(mol.composition.get_el_amt_dict().keys())\n        if isinstance(basis_set, str):\n            basis_set = {el: basis_set for el in elements}\n\n        basis_set_option = basis_set_option\n\n        return NwTask(charge, spin_multiplicity, basis_set,\n                      basis_set_option=basis_set_option,\n                      title=title, theory=theory, operation=operation,\n                      theory_directives=theory_directives,\n                      alternate_directives=alternate_directives)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef dft_task(cls, mol, xc=\"b3lyp\", **kwargs):\n        t = NwTask.from_molecule(mol, theory=\"dft\", **kwargs)\n        t.theory_directives.update({\"xc\": xc,\n                                    \"mult\": t.spin_multiplicity})\n        return t", "response": "A class method for quickly creating DFT tasks with optional kwargs."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreads an NwInput from a string. Currently tested to work with NwInput files generated from this class itself.", "response": "def from_string(cls, string_input):\n        \"\"\"\n        Read an NwInput from a string. Currently tested to work with\n        files generated from this class itself.\n\n        Args:\n            string_input: string_input to parse.\n\n        Returns:\n            NwInput object\n        \"\"\"\n        directives = []\n        tasks = []\n        charge = None\n        spin_multiplicity = None\n        title = None\n        basis_set = None\n        basis_set_option = None\n        theory_directives = {}\n        geom_options = None\n        symmetry_options = None\n        memory_options = None\n        lines = string_input.strip().split(\"\\n\")\n        while len(lines) > 0:\n            l = lines.pop(0).strip()\n            if l == \"\":\n                continue\n\n            toks = l.split()\n            if toks[0].lower() == \"geometry\":\n                geom_options = toks[1:]\n                l = lines.pop(0).strip()\n                toks = l.split()\n                if toks[0].lower() == \"symmetry\":\n                    symmetry_options = toks[1:]\n                    l = lines.pop(0).strip()\n                # Parse geometry\n                species = []\n                coords = []\n                while l.lower() != \"end\":\n                    toks = l.split()\n                    species.append(toks[0])\n                    coords.append([float(i) for i in toks[1:]])\n                    l = lines.pop(0).strip()\n                mol = Molecule(species, coords)\n            elif toks[0].lower() == \"charge\":\n                charge = int(toks[1])\n            elif toks[0].lower() == \"title\":\n                title = l[5:].strip().strip(\"\\\"\")\n            elif toks[0].lower() == \"basis\":\n                # Parse basis sets\n                l = lines.pop(0).strip()\n                basis_set = {}\n                while l.lower() != \"end\":\n                    toks = l.split()\n                    basis_set[toks[0]] = toks[-1].strip(\"\\\"\")\n                    l = lines.pop(0).strip()\n            elif toks[0].lower() in NwTask.theories:\n                # read the basis_set_option\n                if len(toks) > 1:\n                    basis_set_option = toks[1]\n                # Parse theory directives.\n                theory = toks[0].lower()\n                l = lines.pop(0).strip()\n                theory_directives[theory] = {}\n                while l.lower() != \"end\":\n                    toks = l.split()\n                    theory_directives[theory][toks[0]] = toks[-1]\n                    if toks[0] == \"mult\":\n                        spin_multiplicity = float(toks[1])\n                    l = lines.pop(0).strip()\n            elif toks[0].lower() == \"task\":\n                tasks.append(\n                    NwTask(charge=charge,\n                           spin_multiplicity=spin_multiplicity,\n                           title=title, theory=toks[1],\n                           operation=toks[2], basis_set=basis_set,\n                           basis_set_option=basis_set_option,\n                           theory_directives=theory_directives.get(toks[1])))\n            elif toks[0].lower() == \"memory\":\n                    memory_options = ' '.join(toks[1:])\n            else:\n                directives.append(l.strip().split())\n\n        return NwInput(mol, tasks=tasks, directives=directives,\n                       geometry_options=geom_options,\n                       symmetry_options=symmetry_options,\n                       memory_options=memory_options)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nparse TDDFT roots. Adapted from nw_spectrum. py script.", "response": "def parse_tddft(self):\n        \"\"\"\n        Parses TDDFT roots. Adapted from nw_spectrum.py script.\n\n        Returns:\n            {\n                \"singlet\": [\n                    {\n                        \"energy\": float,\n                        \"osc_strength: float\n                    }\n                ],\n                \"triplet\": [\n                    {\n                        \"energy\": float\n                    }\n                ]\n            }\n        \"\"\"\n        start_tag = \"Convergence criterion met\"\n        end_tag = \"Excited state energy\"\n        singlet_tag = \"singlet excited\"\n        triplet_tag = \"triplet excited\"\n        state = \"singlet\"\n        inside = False  # true when we are inside output block\n\n        lines = self.raw.split(\"\\n\")\n\n        roots = {\"singlet\": [], \"triplet\": []}\n\n        while lines:\n            line = lines.pop(0).strip()\n\n            if start_tag in line:\n                inside = True\n\n            elif end_tag in line:\n                inside = False\n\n            elif singlet_tag in line:\n                state = \"singlet\"\n\n            elif triplet_tag in line:\n                state = \"triplet\"\n\n            elif inside and \"Root\" in line and \"eV\" in line:\n                toks = line.split()\n                roots[state].append({\"energy\": float(toks[-2])})\n\n            elif inside and \"Dipole Oscillator Strength\" in line:\n                osc = float(line.split()[-1])\n                roots[state][-1][\"osc_strength\"] = osc\n\n        return roots"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ngenerate an excitation spectra from the singlet roots of TDDFT and returns it.", "response": "def get_excitation_spectrum(self, width=0.1, npoints=2000):\n        \"\"\"\n        Generate an excitation spectra from the singlet roots of TDDFT\n        calculations.\n\n        Args:\n            width (float): Width for Gaussian smearing.\n            npoints (int): Number of energy points. More points => smoother\n                curve.\n\n        Returns:\n            (ExcitationSpectrum) which can be plotted using\n                pymatgen.vis.plotters.SpectrumPlotter.\n        \"\"\"\n        roots = self.parse_tddft()\n        data = roots[\"singlet\"]\n        en = np.array([d[\"energy\"] for d in data])\n        osc = np.array([d[\"osc_strength\"] for d in data])\n\n        epad = 20.0 * width\n        emin = en[0] - epad\n        emax = en[-1] + epad\n        de = (emax - emin) / npoints\n\n        # Use width of at least two grid points\n        if width < 2 * de:\n            width = 2 * de\n\n        energies = [emin + ie * de for ie in range(npoints)]\n\n        cutoff = 20.0 * width\n        gamma = 0.5 * width\n        gamma_sqrd = gamma * gamma\n\n        de = (energies[-1] - energies[0]) / (len(energies) - 1)\n        prefac = gamma / np.pi * de\n\n        x = []\n        y = []\n        for energy in energies:\n            xx0 = energy - en\n            stot = osc / (xx0 * xx0 + gamma_sqrd)\n            t = np.sum(stot[np.abs(xx0) <= cutoff])\n            x.append(energy)\n            y.append(t * prefac)\n        return ExcitationSpectrum(x, y)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a formula string with elements sorted by electronegativity and elements sorted by electronegativity.", "response": "def formula(self):\n        \"\"\"\n        Returns a formula string, with elements sorted by electronegativity,\n        e.g., Li4 Fe4 P4 O16.\n        \"\"\"\n        formula = super().formula\n        chg_str = \"\"\n        if self.charge > 0:\n            chg_str = \" +\" + formula_double_format(self.charge, False)\n        elif self._charge < 0:\n            chg_str = \" \" + formula_double_format(self.charge, False)\n        return formula + chg_str"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a reduced formula string with appended charge.", "response": "def reduced_formula(self):\n        \"\"\"\n        Returns a reduced formula string with appended charge.\n        \"\"\"\n        reduced_formula = super().reduced_formula\n        charge = self._charge / self.get_reduced_composition_and_factor()[1]\n        if charge > 0:\n            if abs(charge) == 1:\n                chg_str = \"[+]\"\n            else:\n                chg_str = \"[\" + formula_double_format(charge, False) + \"+]\"\n        elif charge < 0:\n            if abs(charge) == 1:\n                chg_str = \"[-]\"\n            else:\n                chg_str = \"[{}-]\".format(formula_double_format(abs(charge),\n                                                               False))\n        else:\n            chg_str = \"(aq)\"\n        return reduced_formula + chg_str"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef alphabetical_formula(self):\n        alph_formula = super().alphabetical_formula\n        chg_str = \"\"\n        if self.charge > 0:\n            chg_str = \" +\" + formula_double_format(self.charge, False)\n        elif self.charge < 0:\n            chg_str = \" \" + formula_double_format(self.charge, False)\n        return alph_formula + chg_str", "response": "Returns a reduced formula string with appended charge\n       "}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngenerates an ion object from a dict created by as_dict.", "response": "def from_dict(cls, d):\n        \"\"\"\n        Generates an ion object from a dict created by as_dict().\n\n        Args:\n            d:\n                {symbol: amount} dict.\n        \"\"\"\n        charge = d.pop('charge')\n        composition = Composition(d)\n        return Ion(composition, charge)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a reduced dictionary with element symbol and reduced amount e. g..", "response": "def to_reduced_dict(self):\n        \"\"\"\n        Returns:\n            dict with element symbol and reduced amount e.g.,\n            {\"Fe\": 2.0, \"O\":3.0}.\n        \"\"\"\n        d = self.composition.to_reduced_dict\n        d['charge'] = self.charge\n        return d"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the cost of the best assignment of the current object.", "response": "def min_cost(self):\n        \"\"\"\n        Returns the cost of the best assignment\n        \"\"\"\n        if self._min_cost:\n            return self._min_cost\n        self._min_cost = np.sum(self.c[np.arange(self.nx), self.solution])\n        return self._min_cost"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _column_reduction(self):\n        #assign each column to its lowest cost row, ensuring that only row\n        #or column is assigned once\n        i1, j = np.unique(np.argmin(self.c, axis=0), return_index=True)\n        self._x[i1] = j\n\n        #if problem is solved, return\n        if len(i1) == self.n:\n            return False\n\n        self._y[j] = i1\n\n        #reduction_transfer\n        #tempc is array with previously assigned matchings masked\n        self._v = np.min(self.c, axis=0)\n        tempc = self.c.copy()\n        tempc[i1, j] = np.inf\n        mu = np.min(tempc[i1, :] - self._v[None, :], axis=1)\n        self._v[j] -= mu\n        return True", "response": "Column reduction and reduction transfer steps from LAPJV algorithm\n       "}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\naugment row reduction step from LAPJV algorithm.", "response": "def _augmenting_row_reduction(self):\n        \"\"\"\n        Augmenting row reduction step from LAPJV algorithm\n        \"\"\"\n        unassigned = np.where(self._x == -1)[0]\n        for i in unassigned:\n            for _ in range(self.c.size):\n                # Time in this loop can be proportional to 1/epsilon\n                # This step is not strictly necessary, so cutoff early\n                # to avoid near-infinite loops\n\n                # find smallest 2 values and indices\n                temp = self.c[i] - self._v\n                j1 = np.argmin(temp)\n                u1 = temp[j1]\n                temp[j1] = np.inf\n                j2 = np.argmin(temp)\n                u2 = temp[j2]\n\n                if u1 < u2:\n                    self._v[j1] -= u2 - u1\n                elif self._y[j1] != -1:\n                    j1 = j2\n                k = self._y[j1]\n                if k != -1:\n                    self._x[k] = -1\n                    self._x[i] = j1\n                    self._y[j1] = i\n                    i = k\n                if k == -1 or abs(u1 - u2) < self.epsilon:\n                    break"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nupdates the reduced costs with the values from the the dual solution.", "response": "def _update_cred(self):\n        \"\"\"\n        Updates the reduced costs with the values from the\n        dual solution\n        \"\"\"\n        ui = self.c[self._inds, self._x] - self._v[self._x]\n        self.cred = self.c - ui[:, None] - self._v[None, :]"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\naugments the solution with the minimum cost path from the tree.", "response": "def _augment(self):\n        \"\"\"\n        Finds a minimum cost path and adds it to the matching\n        \"\"\"\n        #build a minimum cost tree\n        _pred, _ready, istar, j, mu = self._build_tree()\n\n        #update prices\n        self._v[_ready] += self._d[_ready] - mu\n\n        #augment the solution with the minimum cost path from the\n        #tree. Follows an alternating path along matched, unmatched\n        #edges from X to Y\n        while True:\n            i = _pred[j]\n            self._y[j] = i\n            k = j\n            j = self._x[i]\n            self._x[i] = k\n            if i == istar:\n                break\n        self._update_cred()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nbuild the tree for the hierarchy of unassigned entries.", "response": "def _build_tree(self):\n        \"\"\"\n        Builds the tree finding an augmenting path. Alternates along\n        matched and unmatched edges between X and Y. The paths are\n        stored in _pred (new predecessor of nodes in Y), and\n        self._x and self._y\n        \"\"\"\n        #find unassigned i*\n        istar = np.argmin(self._x)\n\n        #compute distances\n        self._d = self.c[istar] - self._v\n        _pred = np.zeros(self.n, dtype=np.int) + istar\n\n        #initialize sets\n        #READY: set of nodes visited and in the path (whose price gets\n        #updated in augment)\n        #SCAN: set of nodes at the bottom of the tree, which we need to\n        #look at\n        #T0DO: unvisited nodes\n        _ready = np.zeros(self.n, dtype=np.bool)\n        _scan = np.zeros(self.n, dtype=np.bool)\n        _todo = np.zeros(self.n, dtype=np.bool) + True\n\n        while True:\n            #populate scan with minimum reduced distances\n            if True not in _scan:\n                mu = np.min(self._d[_todo])\n                _scan[self._d == mu] = True\n                _todo[_scan] = False\n                j = np.argmin(self._y * _scan)\n                if self._y[j] == -1 and _scan[j]:\n                    return _pred, _ready, istar, j, mu\n\n            #pick jstar from scan (scan always has at least 1)\n            _jstar = np.argmax(_scan)\n\n            #pick i associated with jstar\n            i = self._y[_jstar]\n\n            _scan[_jstar] = False\n            _ready[_jstar] = True\n\n            #find shorter distances\n            newdists = mu + self.cred[i, :]\n            shorter = np.logical_and(newdists < self._d, _todo)\n\n            #update distances\n            self._d[shorter] = newdists[shorter]\n\n            #update predecessors\n            _pred[shorter] = i\n\n            for j in np.nonzero(np.logical_and(self._d == mu, _todo))[0]:\n                if self._y[j] == -1:\n                    return _pred, _ready, istar, j, mu\n                _scan[j] = True\n                _todo[j] = False"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nserializes obj as a JSON formatted stream to the given filename", "response": "def json_pretty_dump(obj, filename):\n    \"\"\"\n    Serialize obj as a JSON formatted stream to the given filename (\n    pretty printing version)\n    \"\"\"\n    with open(filename, \"wt\") as fh:\n        json.dump(obj, fh, indent=4, sort_keys=4)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the persistent ID of the object.", "response": "def persistent_id(self, obj):\n        \"\"\"Instead of pickling as a regular class instance, we emit a\n        persistent ID.\"\"\"\n        if isinstance(obj, Element):\n            # Here, our persistent ID is simply a tuple, containing a tag and\n            # a key\n            return obj.__class__.__name__, obj.symbol\n        else:\n            # If obj does not have a persistent ID, return None. This means obj\n            # needs to be pickled as usual.\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef persistent_load(self, pid):\n        try:\n            type_tag, key_id = pid\n        except Exception as exc:\n            # Sometimes we get a string such as ('Element', u'C') instead\n            # of a real tuple. Use ast to evalute the expression (much safer\n            # than eval).\n            import ast\n            type_tag, key_id = ast.literal_eval(pid)\n\n        if type_tag == \"Element\":\n            return Element(key_id)\n        else:\n            # Always raises an error if you cannot return the correct object.\n            # Otherwise, the unpickler will think None is the object referenced\n            # by the persistent ID.\n            raise pickle.UnpicklingError(\n                \"unsupported persistent object with pid %s\" % pid)", "response": "This method is invoked whenever a persistent ID is encountered. This method is invoked whenever a persistent ID is encountered. This method is invoked whenever a persistent ID is encountered. Here the pid is the tuple returned by PmgPickler."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef mongo_getattr(rec, key):\n    if not isinstance(rec, collections.Mapping):\n        raise AttributeError('input record must act like a dict')\n    if not rec:\n        raise AttributeError('Empty dict')\n\n    if not '.' in key:\n        return rec.get(key)\n\n    for key_part in key.split('.'):\n        if not isinstance(rec, collections.Mapping):\n            raise AttributeError('not a mapping for rec_part %s' % key_part)\n        if not key_part in rec:\n            raise AttributeError('key %s not in dict %s' % key)\n        rec = rec[key_part]\n\n    return rec", "response": "Get value from dict using MongoDB dot - separated path semantics."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef scan_nestdict(d, key):\n    if isinstance(d, (list, tuple)):\n        for item in d:\n            res = scan_nestdict(item, key)\n            if res is not None:\n                return res\n        return None\n\n    if not isinstance(d, collections.Mapping):\n        return None\n\n    if key in d:\n        return d[key]\n    else:\n        for v in d.values():\n            res = scan_nestdict(v, key)\n            if res is not None:\n                return res\n        return None", "response": "Scan a nested dict d and return the first value associated to the given key. Returns None if key is not found."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_collection_name(self, value):\n        old = self.collection\n        self.collection = str(value)\n        return old", "response": "Set the name of the collection return old value"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nestablish a connection with the database and return the collection name.", "response": "def get_collection(self, **kwargs):\n        \"\"\"\n        Establish a connection with the database.\n\n        Returns MongoDb collection\n        \"\"\"\n        from pymongo import MongoClient\n\n        if self.host and self.port:\n            client = MongoClient(host=config.host, port=config.port)\n        else:\n            client = MongoClient()\n        db = client[self.dbname]\n\n        # Authenticate if needed\n        if self.user and self.password:\n            db.autenticate(self.user, password=self.password)\n\n        return db[self.collection]"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncheck for a transformations. json file and returns the history.", "response": "def _get_transformation_history(path):\n    \"\"\"\n    Checks for a transformations.json* file and returns the history.\n    \"\"\"\n    trans_json = glob.glob(os.path.join(path, \"transformations.json*\"))\n    if trans_json:\n        try:\n            with zopen(trans_json[0]) as f:\n                return json.load(f)[\"history\"]\n        except:\n            return None\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a SpaceGroup symbol from its international number.", "response": "def sg_symbol_from_int_number(int_number, hexagonal=True):\n    \"\"\"\n    Obtains a SpaceGroup name from its international number.\n\n    Args:\n        int_number (int): International number.\n        hexagonal (bool): For rhombohedral groups, whether to return the\n            hexagonal setting (default) or rhombohedral setting.\n\n    Returns:\n        (str) Spacegroup symbol\n    \"\"\"\n    syms = []\n    for n, v in get_symm_data(\"space_group_encoding\").items():\n        if v[\"int_number\"] == int_number:\n            syms.append(n)\n    if len(syms) == 0:\n        raise ValueError(\"Invalid international number!\")\n    if len(syms) == 2:\n        if hexagonal:\n            syms = list(filter(lambda s: s.endswith(\"H\"), syms))\n        else:\n            syms = list(filter(lambda s: not s.endswith(\"H\"), syms))\n    return syms.pop()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning True if this group is a subgroup of the supplied group.", "response": "def is_subgroup(self, supergroup):\n        \"\"\"\n        True if this group is a subgroup of the supplied group.\n\n        Args:\n            supergroup (SymmetryGroup): Supergroup to test.\n\n        Returns:\n            True if this group is a subgroup of the supplied group.\n        \"\"\"\n        warnings.warn(\"This is not fully functional. Only trivial subsets are tested right now. \")\n        return set(self.symmetry_ops).issubset(supergroup.symmetry_ops)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn True if this group is a supergroup of the supplied subgroup.", "response": "def is_supergroup(self, subgroup):\n        \"\"\"\n        True if this group is a supergroup of the supplied group.\n\n        Args:\n            subgroup (SymmetryGroup): Subgroup to test.\n\n        Returns:\n            True if this group is a supergroup of the supplied group.\n        \"\"\"\n        warnings.warn(\"This is not fully functional. Only trivial subsets are \"\n                      \"tested right now. \")\n        return set(subgroup.symmetry_ops).issubset(self.symmetry_ops)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef clean_lines(string_list, remove_empty_lines=True):\n\n    for s in string_list:\n        clean_s = s\n        if '#' in s:\n            ind = s.index('#')\n            clean_s = s[:ind]\n        clean_s = clean_s.strip()\n        if (not remove_empty_lines) or clean_s != '':\n            yield clean_s", "response": "Returns a list of strings that are empty lines."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _maketemp(name, createmode=None):\n    d, fn = os.path.split(name)\n    fd, tempname = tempfile.mkstemp(prefix=\".%s-\" % fn, dir=d)\n    os.close(fd)\n\n    # Temporary files are created with mode 0600, which is usually not\n    # what we want. If the original file already exists, just copy its mode.\n    # Otherwise, manually obey umask.\n    try:\n        st_mode = os.lstat(name).st_mode & 0o777\n    except OSError as err:\n        if err.errno != errno.ENOENT:\n            raise\n        st_mode = createmode\n        if st_mode is None:\n            st_mode = ~umask\n        st_mode &= 0o666\n    os.chmod(tempname, st_mode)\n\n    return tempname", "response": "Create a temporary file with the filename similar to the given name."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a pymatgen Structure object from a PhonopyAtoms object.", "response": "def get_pmg_structure(phonopy_structure):\n    \"\"\"\n    Convert a PhonopyAtoms object to pymatgen Structure object.\n\n    Args:\n        phonopy_structure (PhonopyAtoms): A phonopy structure object.\n\n    \"\"\"\n\n    lattice = phonopy_structure.get_cell()\n    frac_coords = phonopy_structure.get_scaled_positions()\n    symbols = phonopy_structure.get_chemical_symbols()\n    masses = phonopy_structure.get_masses()\n    mms = phonopy_structure.get_magnetic_moments()\n    mms = mms or [0] * len(symbols)\n\n    return Structure(lattice, symbols, frac_coords,\n                     site_properties={\"phonopy_masses\": masses,\n                                      \"magnetic_moments\": mms})"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconverts a pymatgen Structure object to a PhonopyAtoms object.", "response": "def get_phonopy_structure(pmg_structure):\n    \"\"\"\n    Convert a pymatgen Structure object to a PhonopyAtoms object.\n\n    Args:\n        pmg_structure (pymatgen Structure): A Pymatgen structure object.\n\n    \"\"\"\n\n    symbols = [site.specie.symbol for site in pmg_structure]\n\n    return PhonopyAtoms(symbols=symbols, cell=pmg_structure.lattice.matrix,\n                        scaled_positions=pmg_structure.frac_coords)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_structure_from_dict(d):\n\n    species = []\n    frac_coords = []\n    masses = []\n    if 'points' in d:\n        for p in d['points']:\n            species.append(p['symbol'])\n            frac_coords.append(p['coordinates'])\n            masses.append(p['mass'])\n    elif 'atoms' in d:\n        for p in d['atoms']:\n            species.append(p['symbol'])\n            frac_coords.append(p['position'])\n            masses.append(p['mass'])\n    else:\n        raise ValueError('The dict does not contain structural information')\n\n    return Structure(d['lattice'], species, frac_coords,\n                     site_properties={\"phonopy_masses\": masses})", "response": "Returns a Structure object from a dictionary containing phonopy structure information."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconvert a single eigenvector to an eigendisplacement in the primitive cell according to the formula", "response": "def eigvec_to_eigdispl(v, q, frac_coords, mass):\n    \"\"\"\n    Converts a single eigenvector to an eigendisplacement in the primitive cell\n    according to the formula::\n        \n        exp(2*pi*i*(frac_coords \\\\dot q) / sqrt(mass) * v\n    \n    Compared to the modulation option in phonopy, here all the additional\n    multiplicative and phase factors are set to 1.\n    \n    Args:\n        v: the vector that should be converted. A 3D complex numpy array.\n        q: the q point in fractional coordinates\n        frac_coords: the fractional coordinates of the atom\n        mass: the mass of the atom\n    \"\"\"\n\n    c = np.exp(2j * np.pi * np.dot(frac_coords, q)) / np.sqrt(mass)\n\n    return c*v"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates a pymatgen PhononBandStructure object from the dictionary extracted by the band.yaml file produced by phonopy. The labels will be extracted from the dictionary, if present. If the 'eigenvector' key is found the eigendisplacements will be calculated according to the formula:: exp(2*pi*i*(frac_coords \\\\dot q) / sqrt(mass) * v and added to the object. Args: bands_dict: the dictionary extracted from the band.yaml file has_nac: True if the data have been obtained with the option --nac option. Default False. labels_dict: dict that links a qpoint in frac coords to a label. Its value will replace the data contained in the band.yaml.", "response": "def get_ph_bs_symm_line_from_dict(bands_dict, has_nac=False, labels_dict=None):\n    \"\"\"\n    Creates a pymatgen PhononBandStructure object from the dictionary\n    extracted by the band.yaml file produced by phonopy. The labels\n    will be extracted from the dictionary, if present. If the 'eigenvector'\n    key is found the eigendisplacements will be calculated according to the \n    formula::\n        \n        exp(2*pi*i*(frac_coords \\\\dot q) / sqrt(mass) * v\n    \n    and added to the object.\n\n    Args:\n        bands_dict: the dictionary extracted from the band.yaml file\n        has_nac: True if the data have been obtained with the option\n            --nac option. Default False.\n        labels_dict: dict that links a qpoint in frac coords to a label.\n            Its value will replace the data contained in the band.yaml.\n    \"\"\"\n\n    structure = get_structure_from_dict(bands_dict)\n\n    qpts = []\n    frequencies = []\n    eigendisplacements = []\n    phonopy_labels_dict = {}\n    for p in bands_dict['phonon']:\n        q = p['q-position']\n        qpts.append(q)\n        bands = []\n        eig_q = []\n        for b in p['band']:\n            bands.append(b['frequency'])\n            if 'eigenvector' in b:\n                eig_b = []\n                for i, eig_a in enumerate(b['eigenvector']):\n                    v = np.zeros(3, np.complex)\n                    for x in range(3):\n                        v[x] = eig_a[x][0] + eig_a[x][1]*1j\n                    eig_b.append(eigvec_to_eigdispl(\n                        v, q, structure[i].frac_coords,\n                        structure.site_properties['phonopy_masses'][i]))\n                eig_q.append(eig_b)\n        frequencies.append(bands)\n        if 'label' in p:\n            phonopy_labels_dict[p['label']] = p['q-position']\n        if eig_q:\n            eigendisplacements.append(eig_q)\n\n    qpts = np.array(qpts)\n    # transpose to match the convention in PhononBandStructure\n    frequencies = np.transpose(frequencies)\n    if eigendisplacements:\n        eigendisplacements = np.transpose(eigendisplacements, (1, 0, 2, 3))\n\n    rec_latt = Lattice(bands_dict['reciprocal_lattice'])\n\n    labels_dict = labels_dict or phonopy_labels_dict\n\n    ph_bs = PhononBandStructureSymmLine(\n        qpts, frequencies, rec_latt, has_nac=has_nac, labels_dict=labels_dict,\n        structure=structure, eigendisplacements=eigendisplacements)\n\n    return ph_bs"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate a pymatgen PhononBandStructure from a band.yaml file. The labels will be extracted from the dictionary, if present. If the 'eigenvector' key is found the eigendisplacements will be calculated according to the formula: \\\\exp(2*pi*i*(frac_coords \\\\dot q) / sqrt(mass) * v and added to the object. Args: bands_path: path to the band.yaml file has_nac: True if the data have been obtained with the option --nac option. Default False. labels_dict: dict that links a qpoint in frac coords to a label.", "response": "def get_ph_bs_symm_line(bands_path, has_nac=False, labels_dict=None):\n    \"\"\"\n    Creates a pymatgen PhononBandStructure from a band.yaml file.\n    The labels will be extracted from the dictionary, if present.\n    If the 'eigenvector'  key is found the eigendisplacements will be\n    calculated according to the formula:\n    \\\\exp(2*pi*i*(frac_coords \\\\dot q) / sqrt(mass) * v\n     and added to the object.\n\n    Args:\n        bands_path: path to the band.yaml file\n        has_nac: True if the data have been obtained with the option\n            --nac option. Default False.\n        labels_dict: dict that links a qpoint in frac coords to a label.\n    \"\"\"\n    return get_ph_bs_symm_line_from_dict(loadfn(bands_path), has_nac,\n                                         labels_dict)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_complete_ph_dos(partial_dos_path, phonopy_yaml_path):\n    a = np.loadtxt(partial_dos_path).transpose()\n    d = loadfn(phonopy_yaml_path)\n\n    structure = get_structure_from_dict(d['primitive_cell'])\n\n    total_dos = PhononDos(a[0], a[1:].sum(axis=0))\n\n    pdoss = {}\n    for site, pdos in zip(structure, a[1:]):\n        pdoss[site] = pdos.tolist()\n\n    return CompletePhononDos(structure, total_dos, pdoss)", "response": "Returns a CompletePhononDos object from a partial_dos. dat and phonopy. yaml file."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_displaced_structures(pmg_structure, atom_disp=0.01,\n                             supercell_matrix=None, yaml_fname=None, **kwargs):\n    \"\"\"\n    Generate a set of symmetrically inequivalent displaced structures for\n    phonon calculations.\n\n    Args:\n        pmg_structure (Structure): A pymatgen structure object.\n        atom_disp (float): Atomic displacement. Default is 0.01 $\\\\AA$.\n        supercell_matrix (3x3 array): Scaling matrix for supercell.\n        yaml_fname (string): If not None, it represents the full path to\n            the outputting displacement yaml file, e.g. disp.yaml.\n        **kwargs: Parameters used in Phonopy.generate_displacement method.\n\n    Return:\n        A list of symmetrically inequivalent structures with displacements, in\n        which the first element is the perfect supercell structure.\n    \"\"\"\n\n    is_plusminus = kwargs.get(\"is_plusminus\", \"auto\")\n    is_diagonal = kwargs.get(\"is_diagonal\", True)\n    is_trigonal = kwargs.get(\"is_trigonal\", False)\n\n    ph_structure = get_phonopy_structure(pmg_structure)\n\n    if supercell_matrix is None:\n        supercell_matrix = np.eye(3) * np.array((1, 1, 1))\n\n    phonon = Phonopy(unitcell=ph_structure, supercell_matrix=supercell_matrix)\n    phonon.generate_displacements(distance=atom_disp,\n                                  is_plusminus=is_plusminus,\n                                  is_diagonal=is_diagonal,\n                                  is_trigonal=is_trigonal)\n\n    if yaml_fname is not None:\n        displacements = phonon.get_displacements()\n        directions = phonon.get_displacement_directions()\n        write_disp_yaml(displacements=displacements,\n                        supercell=phonon.get_supercell(),\n                        directions=directions, filename=yaml_fname)\n\n    # Supercell structures with displacement\n    disp_supercells = phonon.get_supercells_with_displacements()\n    # Perfect supercell structure\n    init_supercell = phonon.get_supercell()\n    # Structure list to be returned\n    structure_list = [get_pmg_structure(init_supercell)]\n\n    for c in disp_supercells:\n        if c is not None:\n            structure_list.append(get_pmg_structure(c))\n\n    return structure_list", "response": "Generate a set of symmetrically inequivalent structures for a given PMM structure."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a dict with unique families of Miller indices.", "response": "def get_unique_families(hkls):\n    \"\"\"\n    Returns unique families of Miller indices. Families must be permutations\n    of each other.\n\n    Args:\n        hkls ([h, k, l]): List of Miller indices.\n\n    Returns:\n        {hkl: multiplicity}: A dict with unique hkl and multiplicity.\n    \"\"\"\n    # TODO: Definitely can be sped up.\n    def is_perm(hkl1, hkl2):\n        h1 = np.abs(hkl1)\n        h2 = np.abs(hkl2)\n        return all([i == j for i, j in zip(sorted(h1), sorted(h2))])\n\n    unique = collections.defaultdict(list)\n    for hkl1 in hkls:\n        found = False\n        for hkl2 in unique.keys():\n            if is_perm(hkl1, hkl2):\n                found = True\n                unique[hkl2].append(hkl1)\n                break\n        if not found:\n            unique[hkl1].append(hkl1)\n\n    pretty_unique = {}\n    for k, v in unique.items():\n        pretty_unique[sorted(v)[-1]] = len(v)\n\n    return pretty_unique"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_plot(self, structure, two_theta_range=(0, 90),\n                 annotate_peaks=True, ax=None, with_labels=True,\n                 fontsize=16):\n        \"\"\"\n        Returns the diffraction plot as a matplotlib.pyplot.\n\n        Args:\n            structure: Input structure\n            two_theta_range ([float of length 2]): Tuple for range of\n                two_thetas to calculate in degrees. Defaults to (0, 90). Set to\n                None if you want all diffracted beams within the limiting\n                sphere of radius 2 / wavelength.\n            annotate_peaks: Whether to annotate the peaks with plane\n                information.\n            ax: matplotlib :class:`Axes` or None if a new figure should be created.\n            with_labels: True to add xlabels and ylabels to the plot.\n            fontsize: (int) fontsize for peak labels.\n\n        Returns:\n            (matplotlib.pyplot)\n        \"\"\"\n        if ax is None:\n            from pymatgen.util.plotting import pretty_plot\n            plt = pretty_plot(16, 10)\n            ax = plt.gca()\n        else:\n            # This to maintain the type of the return value.\n            import matplotlib.pyplot as plt\n\n        xrd = self.get_pattern(structure, two_theta_range=two_theta_range)\n\n        for two_theta, i, hkls, d_hkl in zip(xrd.x, xrd.y, xrd.hkls, xrd.d_hkls):\n            if two_theta_range[0] <= two_theta <= two_theta_range[1]:\n                print(hkls)\n                label = \", \".join([str(hkl[\"hkl\"]) for hkl in hkls])\n                ax.plot([two_theta, two_theta], [0, i], color='k',\n                         linewidth=3, label=label)\n                if annotate_peaks:\n                    ax.annotate(label, xy=[two_theta, i],\n                                xytext=[two_theta, i], fontsize=fontsize)\n\n        if with_labels:\n            ax.set_xlabel(r\"$2\\theta$ ($^\\circ$)\")\n            ax.set_ylabel(\"Intensities (scaled)\")\n\n        if hasattr(ax, \"tight_layout\"):\n            ax.tight_layout()\n\n        return plt", "response": "Returns the diffraction plot as a matplotlib. pyplot."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef plot_structures(self, structures, fontsize=6, **kwargs):\n        import matplotlib.pyplot as plt\n        nrows = len(structures)\n        fig, axes = plt.subplots(nrows=nrows, ncols=1, sharex=True,\n                                 squeeze=False)\n\n        for i, (ax, structure) in enumerate(zip(axes.ravel(), structures)):\n            self.get_plot(structure,\n                          fontsize=fontsize, ax=ax, with_labels=i == nrows - 1,\n                          **kwargs)\n            spg_symbol, spg_number = structure.get_space_group_info()\n            ax.set_title(\"{} {} ({}) \".format(structure.formula, spg_symbol,\n                                              spg_number))\n\n        return fig", "response": "Plot diffraction patterns for multiple structures on the same figure."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nnormalizing the spectrum with respect to the sum of intensity", "response": "def normalize(self, mode=\"max\", value=1):\n        \"\"\"\n        Normalize the spectrum with respect to the sum of intensity\n\n        Args:\n            mode (str): Normalization mode. Supported modes are \"max\" (set the\n                max y value to value, e.g., in XRD patterns), \"sum\" (set the\n                sum of y to a value, i.e., like a probability density).\n            value (float): Value to normalize to. Defaults to 1.\n        \"\"\"\n        if mode.lower() == \"sum\":\n            factor = np.sum(self.y, axis=0)\n        elif mode.lower() == \"max\":\n            factor = np.max(self.y, axis=0)\n        else:\n            raise ValueError(\"Unsupported normalization mode %s!\" % mode)\n\n        self.y /= factor / value"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\napply Gaussian smearing to spectrum y value.", "response": "def smear(self, sigma):\n        \"\"\"\n        Apply Gaussian smearing to spectrum y value.\n\n        Args:\n            sigma: Std dev for Gaussian smear function\n        \"\"\"\n        diff = [self.x[i + 1] - self.x[i] for i in range(len(self.x) - 1)]\n        avg_x_per_step = np.sum(diff) / len(diff)\n        if len(self.ydim) == 1:\n            self.y = gaussian_filter1d(self.y, sigma / avg_x_per_step)\n        else:\n            self.y = np.array([\n                gaussian_filter1d(self.y[:, k], sigma / avg_x_per_step)\n                for k in range(self.ydim[1])]).T"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_interpolated_value(self, x):\n        if len(self.ydim) == 1:\n            return get_linear_interpolated_value(self.x, self.y, x)\n        else:\n            return [get_linear_interpolated_value(self.x, self.y[:, k], x)\n                    for k in range(self.ydim[1])]", "response": "Returns an interpolated y value for a particular x value."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef copy(self):\n        return self.__class__(self.x, self.y, *self._args, **self._kwargs)", "response": "Returns a copy of the object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nwrite all magnetic space groups to a human - readable text file.", "response": "def _write_all_magnetic_space_groups_to_file(filename):\n    \"\"\"\n    Write all magnetic space groups to a human-readable text file.\n    Should contain same information as text files provided by ISO-MAG.\n    :param filename: \n    :return: \n    \"\"\"\n    s = ('Data parsed from raw data from:\\n'\n         'ISO-MAG, ISOTROPY Software Suite, iso.byu.edu\\n'\n         'http://stokes.byu.edu/iso/magnetic_data.txt\\n'\n         'Used with kind permission from Professor Branton Campbell, BYU\\n\\n')\n    all_msgs = []\n    for i in range(1, 1652):\n        all_msgs.append(MagneticSpaceGroup(i))\n    for msg in all_msgs:\n        s += '\\n{}\\n\\n--------\\n'.format(msg.data_str())\n    f = open(filename, 'w')\n    f.write(s)\n    f.close()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef combine_neb_plots(neb_analyses, arranged_neb_analyses=False,\n                      reverse_plot=False):\n    \"\"\"\n    neb_analyses: a list of NEBAnalysis objects\n\n    arranged_neb_analyses: The code connects two end points with the\n    smallest-energy difference. If all end points have very close energies, it's\n    likely to result in an inaccurate connection. Manually arrange neb_analyses\n    if the combined plot is not as expected compared with all individual plots.\n    E.g., if there are two NEBAnalysis objects to combine, arrange in such a\n    way that the end-point energy of the first NEBAnalysis object is the\n    start-point energy of the second NEBAnalysis object.\n    Note that the barrier labeled in y-axis in the combined plot might be\n    different from that in the individual plot due to the reference energy used.\n    reverse_plot: reverse the plot or percolation direction.\n    return: a NEBAnalysis object\n    \"\"\"\n    x = StructureMatcher()\n    for neb_index in range(len(neb_analyses)):\n        if neb_index == 0:\n            neb1 = neb_analyses[neb_index]\n            neb1_energies = list(neb1.energies)\n            neb1_structures = neb1.structures\n            neb1_forces = neb1.forces\n            neb1_r = neb1.r\n            continue\n\n        neb2 = neb_analyses[neb_index]\n        neb2_energies = list(neb2.energies)\n\n        matching = 0\n        for neb1_s in [neb1_structures[0], neb1_structures[-1]]:\n            if x.fit(neb1_s, neb2.structures[0]) or \\\n                    x.fit(neb1_s, neb2.structures[-1]):\n                matching += 1\n                break\n        if matching == 0:\n            raise ValueError(\"no matched structures for connection!\")\n\n        neb1_start_e, neb1_end_e = neb1_energies[0], neb1_energies[-1]\n        neb2_start_e, neb2_end_e = neb2_energies[0], neb2_energies[-1]\n        min_e_diff = min(([abs(neb1_start_e - neb2_start_e),\n                         abs(neb1_start_e - neb2_end_e),\n                         abs(neb1_end_e - neb2_start_e),\n                         abs(neb1_end_e - neb2_end_e)]))\n\n        if arranged_neb_analyses:\n            neb1_energies = neb1_energies[0:len(neb1_energies) - 1] \\\n                            + [(neb1_energies[-1] + neb2_energies[0]) / 2] \\\n                            + neb2_energies[\n                              1:]\n            neb1_structures = neb1_structures + neb2.structures[1:]\n            neb1_forces = list(neb1_forces) + list(neb2.forces)[1:]\n            neb1_r = list(neb1_r) + [i + neb1_r[-1] for i in\n                                     list(neb2.r)[1:]]\n\n        elif abs(neb1_start_e - neb2_start_e) == min_e_diff:\n            neb1_energies = list(reversed(neb1_energies[1:])) + neb2_energies\n            neb1_structures = list(\n                reversed((neb1_structures[1:]))) + neb2.structures\n            neb1_forces = list(reversed(list(neb1_forces)[1:])) + list(\n                neb2.forces)\n            neb1_r = list(reversed(\n                [i * -1 - neb1_r[-1] * -1 for i in list(neb1_r)[1:]])) + [\n                         i + neb1_r[-1] for i in list(neb2.r)]\n\n        elif abs(neb1_start_e - neb2_end_e) == min_e_diff:\n            neb1_energies = neb2_energies + neb1_energies[1:]\n            neb1_structures = neb2.structures + neb1_structures[1:]\n            neb1_forces = list(neb2.forces) + list(neb1_forces)[1:]\n            neb1_r = [i for i in list(neb2.r)] + \\\n                     [i + list(neb2.r)[-1] for i in list(neb1_r)[1:]]\n\n        elif abs(neb1_end_e - neb2_start_e) == min_e_diff:\n            neb1_energies = neb1_energies + neb2_energies[1:]\n            neb1_structures = neb1_structures + neb2.structures[1:]\n            neb1_forces = list(neb1_forces) + list(neb2.forces)[1:]\n            neb1_r = [i for i in list(neb1_r)] + \\\n                     [i + neb1_r[-1] for i in list(neb2.r)[1:]]\n\n        else:\n            neb1_energies = neb1_energies + list(reversed(neb2_energies))[1:]\n            neb1_structures = neb1_structures + list(\n                reversed((neb2.structures)))[1:]\n            neb1_forces = list(neb1_forces) + \\\n                          list(reversed(list(neb2.forces)))[1:]\n            neb1_r = list(neb1_r) + list(\n                reversed([i * -1 - list(neb2.r)[-1] * -1 + list(neb1_r)[-1]\n                          for i in list(neb2.r)[:-1]]))\n\n    if reverse_plot:\n        na = NEBAnalysis(\n            list(reversed([i * -1 - neb1_r[-1] * -1 for i in list(neb1_r)])),\n            list(reversed(neb1_energies)),\n            list(reversed(neb1_forces)), list(reversed(neb1_structures)))\n    else:\n        na = NEBAnalysis(neb1_r, neb1_energies, neb1_forces, neb1_structures)\n    return na", "response": "Combine two NEBAnalysis objects into a single one."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ninitializing an NEBAnalysis from a list of Outcar objects and a list of Structures.", "response": "def from_outcars(cls, outcars, structures, **kwargs):\n        \"\"\"\n        Initializes an NEBAnalysis from Outcar and Structure objects. Use\n        the static constructors, e.g., :class:`from_dir` instead if you\n        prefer to have these automatically generated from a directory of NEB\n        calculations.\n\n        Args:\n            outcars ([Outcar]): List of Outcar objects. Note that these have\n                to be ordered from start to end along reaction coordinates.\n            structures ([Structure]): List of Structures along reaction\n                coordinate. Must be same length as outcar.\n            interpolation_order (int): Order of polynomial to use to\n                interpolate between images. Same format as order parameter in\n                scipy.interplotate.PiecewisePolynomial.\n        \"\"\"\n        if len(outcars) != len(structures):\n            raise ValueError(\"# of Outcars must be same as # of Structures\")\n\n        # Calculate cumulative root mean square distance between structures,\n        # which serves as the reaction coordinate. Note that these are\n        # calculated from the final relaxed structures as the coordinates may\n        # have changed from the initial interpolation.\n        r = [0]\n        prev = structures[0]\n        for st in structures[1:]:\n            dists = np.array([s2.distance(s1) for s1, s2 in zip(prev, st)])\n            r.append(np.sqrt(np.sum(dists ** 2)))\n            prev = st\n        r = np.cumsum(r)\n\n        energies = []\n        forces = []\n        for i, o in enumerate(outcars):\n            o.read_neb()\n            energies.append(o.data[\"energy\"])\n            if i in [0, len(outcars) - 1]:\n                forces.append(0)\n            else:\n                forces.append(o.data[\"tangent_force\"]) \n        forces = np.array(forces)\n        r = np.array(r)\n        return cls(r=r, energies=energies, forces=forces,\n                   structures=structures, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the positions of the extrema along the MEP.", "response": "def get_extrema(self, normalize_rxn_coordinate=True):\n        \"\"\"\n        Returns the positions of the extrema along the MEP. Both local\n        minimums and maximums are returned.\n\n        Args:\n            normalize_rxn_coordinate (bool): Whether to normalize the\n                reaction coordinate to between 0 and 1. Defaults to True.\n\n        Returns:\n            (min_extrema, max_extrema), where the extrema are given as\n            [(x1, y1), (x2, y2), ...].\n        \"\"\"\n        x = np.arange(0, np.max(self.r), 0.01)\n        y = self.spline(x) * 1000\n\n        scale = 1 if not normalize_rxn_coordinate else 1 / self.r[-1]\n        min_extrema = []\n        max_extrema = []\n        for i in range(1, len(x) - 1):\n            if y[i] < y[i-1] and y[i] < y[i+1]:\n                min_extrema.append((x[i] * scale, y[i]))\n            elif y[i] > y[i-1] and y[i] > y[i+1]:\n                max_extrema.append((x[i] * scale, y[i]))\n        return min_extrema, max_extrema"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the NEB plot of the reaction path.", "response": "def get_plot(self, normalize_rxn_coordinate=True, label_barrier=True):\n        \"\"\"\n        Returns the NEB plot. Uses Henkelman's approach of spline fitting\n        each section of the reaction path based on tangent force and energies.\n\n        Args:\n            normalize_rxn_coordinate (bool): Whether to normalize the\n                reaction coordinate to between 0 and 1. Defaults to True.\n            label_barrier (bool): Whether to label the maximum barrier.\n\n        Returns:\n            matplotlib.pyplot object.\n        \"\"\"\n        plt = pretty_plot(12, 8)\n        scale = 1 if not normalize_rxn_coordinate else 1 / self.r[-1]\n        x = np.arange(0, np.max(self.r), 0.01)\n        y = self.spline(x) * 1000\n        relative_energies = self.energies - self.energies[0]\n        plt.plot(self.r * scale, relative_energies * 1000, 'ro',\n                 x * scale, y, 'k-', linewidth=2, markersize=10)\n        plt.xlabel(\"Reaction coordinate\")\n        plt.ylabel(\"Energy (meV)\")\n        plt.ylim((np.min(y) - 10, np.max(y) * 1.02 + 20))\n        if label_barrier:\n            data = zip(x * scale, y)\n            barrier = max(data, key=lambda d: d[1])\n            plt.plot([0, barrier[0]], [barrier[1], barrier[1]], 'k--')\n            plt.annotate('%.0f meV' % (np.max(y) - np.min(y)),\n                         xy=(barrier[0] / 2, barrier[1] * 1.02),\n                         xytext=(barrier[0] / 2, barrier[1] * 1.02),\n                         horizontalalignment='center')\n        plt.tight_layout()\n        return plt"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef from_dir(cls, root_dir, relaxation_dirs=None, **kwargs):\n        neb_dirs = []\n\n        for d in os.listdir(root_dir):\n            pth = os.path.join(root_dir, d)\n            if os.path.isdir(pth) and d.isdigit():\n                i = int(d)\n                neb_dirs.append((i, pth))\n        neb_dirs = sorted(neb_dirs, key=lambda d: d[0])\n        outcars = []\n        structures = []\n\n        # Setup the search sequence for the OUTCARs for the terminal\n        # directories.\n        terminal_dirs = []\n        if relaxation_dirs is not None:\n            terminal_dirs.append(relaxation_dirs)\n        terminal_dirs.append((neb_dirs[0][1], neb_dirs[-1][1]))\n        terminal_dirs.append([os.path.join(root_dir, d)\n                              for d in [\"start\", \"end\"]])\n        terminal_dirs.append([os.path.join(root_dir, d)\n                              for d in [\"initial\", \"final\"]])\n\n        for i, d in neb_dirs:\n            outcar = glob.glob(os.path.join(d, \"OUTCAR*\"))\n            contcar = glob.glob(os.path.join(d, \"CONTCAR*\"))\n            poscar = glob.glob(os.path.join(d, \"POSCAR*\"))\n            terminal = i == 0 or i == neb_dirs[-1][0]\n            if terminal:\n                for ds in terminal_dirs:\n                    od = ds[0] if i == 0 else ds[1]\n                    outcar = glob.glob(os.path.join(od, \"OUTCAR*\"))\n                    if outcar:\n                        outcar = sorted(outcar)\n                        outcars.append(Outcar(outcar[-1]))\n                        break\n                else:\n                    raise ValueError(\"OUTCAR cannot be found for terminal \"\n                                     \"point %s\" % d)\n                structures.append(Poscar.from_file(poscar[0]).structure)\n            else:\n                outcars.append(Outcar(outcar[0]))\n                structures.append(Poscar.from_file(contcar[0]).structure)\n        return NEBAnalysis.from_outcars(outcars, structures, **kwargs)", "response": "Initializes a NEBAnalysis object from a directory containing the NEB output files."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef as_dict(self):\n        return {\"@module\": self.__class__.__module__,\n                \"@class\": self.__class__.__name__,\n                'r': jsanitize(self.r),\n                'energies': jsanitize(self.energies),\n                'forces': jsanitize(self.forces),\n                'structures': [s.as_dict() for s in self.structures]}", "response": "Returns a dict representation of the NEBAnalysis."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nbuild a Flow object for band structure calculations.", "response": "def bandstructure_flow(workdir, scf_input, nscf_input, dos_inputs=None, manager=None, flow_class=Flow, allocate=True):\n    \"\"\"\n    Build a :class:`Flow` for band structure calculations.\n\n    Args:\n        workdir: Working directory.\n        scf_input: Input for the GS SCF run.\n        nscf_input: Input for the NSCF run (band structure run).\n        dos_inputs: Input(s) for the NSCF run (dos run).\n        manager: :class:`TaskManager` object used to submit the jobs\n                 Initialized from manager.yml if manager is None.\n        flow_class: Flow subclass\n        allocate: True if the flow should be allocated before returning.\n\n    Returns:\n        :class:`Flow` object\n    \"\"\"\n    flow = flow_class(workdir, manager=manager)\n    work = BandStructureWork(scf_input, nscf_input, dos_inputs=dos_inputs)\n    flow.register_work(work)\n\n    # Handy aliases\n    flow.scf_task, flow.nscf_task, flow.dos_tasks = work.scf_task, work.nscf_task, work.dos_tasks\n\n    if allocate: flow.allocate()\n    return flow"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nbuild a Flow object for one - shot G0W0 calculations.", "response": "def g0w0_flow(workdir, scf_input, nscf_input, scr_input, sigma_inputs, manager=None, flow_class=Flow, allocate=True):\n    \"\"\"\n    Build a :class:`Flow` for one-shot $G_0W_0$ calculations.\n\n    Args:\n        workdir: Working directory.\n        scf_input: Input for the GS SCF run.\n        nscf_input: Input for the NSCF run (band structure run).\n        scr_input: Input for the SCR run.\n        sigma_inputs: List of inputs for the SIGMA run.\n        flow_class: Flow class\n        manager: :class:`TaskManager` object used to submit the jobs.\n                 Initialized from manager.yml if manager is None.\n        allocate: True if the flow should be allocated before returning.\n\n    Returns:\n        :class:`Flow` object\n    \"\"\"\n    flow = flow_class(workdir, manager=manager)\n    work = G0W0Work(scf_input, nscf_input, scr_input, sigma_inputs)\n    flow.register_work(work)\n    if allocate: flow.allocate()\n    return flow"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate a new container that can be used to run phonon calculations on a set of inputs.", "response": "def phonon_flow(workdir, scf_input, ph_inputs, with_nscf=False, with_ddk=False, with_dde=False,\n                manager=None, flow_class=PhononFlow, allocate=True):\n    \"\"\"\n    Build a :class:`PhononFlow` for phonon calculations.\n\n    Args:\n        workdir: Working directory.\n        scf_input: Input for the GS SCF run.\n        ph_inputs: List of Inputs for the phonon runs.\n        with_nscf: add an nscf task in front of al phonon tasks to make sure the q point is covered\n        with_ddk: add the ddk step\n        with_dde: add the dde step it the dde is set ddk is switched on automatically\n        manager: :class:`TaskManager` used to submit the jobs\n                 Initialized from manager.yml if manager is None.\n        flow_class: Flow class\n\n    Returns:\n        :class:`Flow` object\n    \"\"\"\n    logger.critical(\"phonon_flow is deprecated and could give wrong results\")\n    if with_dde:\n        with_ddk = True\n\n    natom = len(scf_input.structure)\n\n    # Create the container that will manage the different works.\n    flow = flow_class(workdir, manager=manager)\n\n    # Register the first work (GS calculation)\n    # register_task creates a work for the task, registers it to the flow and returns the work\n    # the 0the element of the work is the task\n    scf_task = flow.register_task(scf_input, task_class=ScfTask)[0]\n\n    # Build a temporary work with a shell manager just to run\n    # ABINIT to get the list of irreducible pertubations for this q-point.\n    shell_manager = flow.manager.to_shell_manager(mpi_procs=1)\n\n    if with_ddk:\n        logger.info('add ddk')\n        # TODO\n        # MG Warning: be careful here because one should use tolde or tolwfr (tolvrs shall not be used!)\n        ddk_input = ph_inputs[0].deepcopy()\n        ddk_input.set_vars(qpt=[0, 0, 0], rfddk=1, rfelfd=2, rfdir=[1, 1, 1])\n        ddk_task = flow.register_task(ddk_input, deps={scf_task: 'WFK'}, task_class=DdkTask)[0]\n\n    if with_dde:\n        logger.info('add dde')\n        dde_input = ph_inputs[0].deepcopy()\n        dde_input.set_vars(qpt=[0, 0, 0], rfddk=1, rfelfd=2)\n        dde_input_idir = dde_input.deepcopy()\n        dde_input_idir.set_vars(rfdir=[1, 1, 1])\n        dde_task = flow.register_task(dde_input, deps={scf_task: 'WFK', ddk_task: 'DDK'}, task_class=DdeTask)[0]\n\n    if not isinstance(ph_inputs, (list, tuple)):\n        ph_inputs = [ph_inputs]\n\n    for i, ph_input in enumerate(ph_inputs):\n        fake_input = ph_input.deepcopy()\n\n        # Run abinit on the front-end to get the list of irreducible pertubations.\n        tmp_dir = os.path.join(workdir, \"__ph_run\" + str(i) + \"__\")\n        w = PhononWork(workdir=tmp_dir, manager=shell_manager)\n        fake_task = w.register(fake_input)\n\n        # Use the magic value paral_rf = -1 to get the list of irreducible perturbations for this q-point.\n        abivars = dict(\n            paral_rf=-1,\n            rfatpol=[1, natom],  # Set of atoms to displace.\n            rfdir=[1, 1, 1],     # Along this set of reduced coordinate axis.\n        )\n\n        fake_task.set_vars(abivars)\n        w.allocate()\n        w.start(wait=True)\n\n        # Parse the file to get the perturbations.\n        try:\n            irred_perts = yaml_read_irred_perts(fake_task.log_file.path)\n        except:\n            print(\"Error in %s\" % fake_task.log_file.path)\n            raise\n\n        logger.info(irred_perts)\n\n        w.rmtree()\n\n        # Now we can build the final list of works:\n        # One work per q-point, each work computes all\n        # the irreducible perturbations for a singe q-point.\n\n        work_qpt = PhononWork()\n\n        if with_nscf:\n            # MG: Warning this code assume 0 is Gamma!\n            nscf_input = copy.deepcopy(scf_input)\n            nscf_input.set_vars(kptopt=3, iscf=-3, qpt=irred_perts[0]['qpt'], nqpt=1)\n            nscf_task = work_qpt.register_nscf_task(nscf_input, deps={scf_task: \"DEN\"})\n            deps = {nscf_task: \"WFQ\", scf_task: \"WFK\"}\n        else:\n            deps = {scf_task: \"WFK\"}\n\n        if with_ddk:\n            deps[ddk_task] = 'DDK'\n\n        logger.info(irred_perts[0]['qpt'])\n\n        for irred_pert in irred_perts:\n            #print(irred_pert)\n            new_input = ph_input.deepcopy()\n\n            #rfatpol   1 1   # Only the first atom is displaced\n            #rfdir   1 0 0   # Along the first reduced coordinate axis\n            qpt = irred_pert[\"qpt\"]\n            idir = irred_pert[\"idir\"]\n            ipert = irred_pert[\"ipert\"]\n\n            # TODO this will work for phonons, but not for the other types of perturbations.\n            rfdir = 3 * [0]\n            rfdir[idir -1] = 1\n            rfatpol = [ipert, ipert]\n\n            new_input.set_vars(\n                #rfpert=1,\n                qpt=qpt,\n                rfdir=rfdir,\n                rfatpol=rfatpol,\n            )\n\n            if with_ddk:\n                new_input.set_vars(rfelfd=3)\n\n            work_qpt.register_phonon_task(new_input, deps=deps)\n\n        flow.register_work(work_qpt)\n\n    if allocate: flow.allocate()\n\n    return flow"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate a Flow object to perform phonon calculations for a given set of q - points.", "response": "def phonon_conv_flow(workdir, scf_input, qpoints, params, manager=None, allocate=True):\n    \"\"\"\n    Create a :class:`Flow` to perform convergence studies for phonon calculations.\n\n    Args:\n        workdir: Working directory of the flow.\n        scf_input: :class:`AbinitInput` object defining a GS-SCF calculation.\n        qpoints: List of list of lists with the reduced coordinates of the q-point(s).\n        params:\n            To perform a converge study wrt ecut: params=[\"ecut\", [2, 4, 6]]\n        manager: :class:`TaskManager` object responsible for the submission of the jobs.\n            If manager is None, the object is initialized from the yaml file\n            located either in the working directory or in the user configuration dir.\n        allocate: True if the flow should be allocated before returning.\n\n    Return:\n        :class:`Flow` object.\n    \"\"\"\n    qpoints = np.reshape(qpoints, (-1, 3))\n\n    flow = Flow(workdir=workdir, manager=manager)\n\n    for qpt in qpoints:\n        for gs_inp in scf_input.product(*params):\n            # Register the SCF task\n            work = flow.register_scf_task(gs_inp)\n\n            # Add the PhononWork connected to this scf_task.\n            flow.register_work(PhononWork.from_scf_task(work[0], qpoints=qpt))\n\n    if allocate: flow.allocate()\n    return flow"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ninitializes an instance from a Work instance.", "response": "def from_node(cls, flow):\n        \"\"\"Initialize an instance from a Work instance.\"\"\"\n        new = super().from_node(flow)\n\n        # Will put all files found in outdir in GridFs\n        d = {os.path.basename(f): f for f in flow.outdir.list_filepaths()}\n\n        # Add the pickle file.\n        d[\"pickle\"] = flow.pickle_file if flow.pickle_protocol != 0 else (flow.pickle_file, \"t\")\n        new.add_gridfs_files(**d)\n\n        return new"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef from_inputs(cls, workdir, inputs, manager=None, pickle_protocol=-1, task_class=ScfTask,\n                    work_class=Work, remove=False):\n\n        \"\"\"\n        Construct a simple flow from a list of inputs. The flow contains a single Work with\n        tasks whose class is given by task_class.\n\n        .. warning::\n\n            Don't use this interface if you have dependencies among the tasks.\n\n        Args:\n            workdir: String specifying the directory where the works will be produced.\n            inputs: List of inputs.\n            manager: :class:`TaskManager` object responsible for the submission of the jobs.\n                If manager is None, the object is initialized from the yaml file\n                located either in the working directory or in the user configuration dir.\n            pickle_protocol: Pickle protocol version used for saving the status of the object.\n                -1 denotes the latest version supported by the python interpreter.\n            task_class: The class of the :class:`Task`.\n            work_class: The class of the :class:`Work`.\n            remove: attempt to remove working directory `workdir` if directory already exists.\n        \"\"\"\n        if not isinstance(inputs, (list, tuple)): inputs = [inputs]\n\n        flow = cls(workdir, manager=manager, pickle_protocol=pickle_protocol, remove=remove)\n        work = work_class()\n        for inp in inputs:\n            work.register(inp, task_class=task_class)\n        flow.register_work(work)\n\n        return flow.allocate()", "response": "Construct a simple flow from a list of inputs."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconverts obj into a Flow. Accepts filepath dict or Flow object.", "response": "def as_flow(cls, obj):\n        \"\"\"Convert obj into a Flow. Accepts filepath, dict, or Flow object.\"\"\"\n        if isinstance(obj, cls): return obj\n        if is_string(obj):\n            return cls.pickle_load(obj)\n        elif isinstance(obj, collections.Mapping):\n            return cls.from_dict(obj)\n        else:\n            raise TypeError(\"Don't know how to convert type %s into a Flow\" % type(obj))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_workdir(self, workdir, chroot=False):\n        if not chroot and hasattr(self, \"workdir\") and self.workdir != workdir:\n            raise ValueError(\"self.workdir != workdir: %s, %s\" % (self.workdir,  workdir))\n\n        # Directories with (input|output|temporary) data.\n        self.workdir = os.path.abspath(workdir)\n        self.indir = Directory(os.path.join(self.workdir, \"indata\"))\n        self.outdir = Directory(os.path.join(self.workdir, \"outdata\"))\n        self.tmpdir = Directory(os.path.join(self.workdir, \"tmpdata\"))\n        self.wdir = Directory(self.workdir)", "response": "Sets the working directory for the current instance of the class."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreloading the flow from the pickle file.", "response": "def reload(self):\n        \"\"\"\n        Reload the flow from the pickle file. Used when we are monitoring the flow\n        executed by the scheduler. In this case, indeed, the flow might have been changed\n        by the scheduler and we have to reload the new flow in memory.\n        \"\"\"\n        new = self.__class__.pickle_load(self.workdir)\n        self = new"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nloads the flow from a pickle file.", "response": "def pickle_load(cls, filepath, spectator_mode=True, remove_lock=False):\n        \"\"\"\n        Loads the object from a pickle file and performs initial setup.\n\n        Args:\n            filepath: Filename or directory name. It filepath is a directory, we\n                scan the directory tree starting from filepath and we\n                read the first pickle database. Raise RuntimeError if multiple\n                databases are found.\n            spectator_mode: If True, the nodes of the flow are not connected by signals.\n                This option is usually used when we want to read a flow\n                in read-only mode and we want to avoid callbacks that can change the flow.\n            remove_lock:\n                True to remove the file lock if any (use it carefully).\n        \"\"\"\n        if os.path.isdir(filepath):\n            # Walk through each directory inside path and find the pickle database.\n            for dirpath, dirnames, filenames in os.walk(filepath):\n                fnames = [f for f in filenames if f == cls.PICKLE_FNAME]\n                if fnames:\n                    if len(fnames) == 1:\n                        filepath = os.path.join(dirpath, fnames[0])\n                        break  # Exit os.walk\n                    else:\n                        err_msg = \"Found multiple databases:\\n %s\" % str(fnames)\n                        raise RuntimeError(err_msg)\n            else:\n                err_msg = \"Cannot find %s inside directory %s\" % (cls.PICKLE_FNAME, filepath)\n                raise ValueError(err_msg)\n\n        if remove_lock and os.path.exists(filepath + \".lock\"):\n            try:\n                os.remove(filepath + \".lock\")\n            except:\n                pass\n\n        with FileLock(filepath):\n            with open(filepath, \"rb\") as fh:\n                flow = pmg_pickle_load(fh)\n\n        # Check if versions match.\n        if flow.VERSION != cls.VERSION:\n            msg = (\"File flow version %s != latest version %s\\n.\"\n                   \"Regenerate the flow to solve the problem \" % (flow.VERSION, cls.VERSION))\n            warnings.warn(msg)\n\n        flow.set_spectator_mode(spectator_mode)\n\n        # Recompute the status of each task since tasks that\n        # have been submitted previously might be completed.\n        flow.check_status()\n        return flow"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef pickle_loads(cls, s):\n        strio = StringIO()\n        strio.write(s)\n        strio.seek(0)\n        flow = pmg_pickle_load(strio)\n        return flow", "response": "Reconstruct the flow from a string."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncheck if the pid file of the scheduler exists and if so restarts it.", "response": "def check_pid_file(self):\n        \"\"\"\n        This function checks if we are already running the :class:`Flow` with a :class:`PyFlowScheduler`.\n        Raises: Flow.Error if the pid file of the scheduler exists.\n        \"\"\"\n        if not os.path.exists(self.pid_file):\n            return 0\n\n        self.show_status()\n        raise self.Error(\"\"\"\\n\\\n            pid_file\n            %s\n            already exists. There are two possibilities:\n\n               1) There's an another instance of PyFlowScheduler running\n               2) The previous scheduler didn't exit in a clean way\n\n            To solve case 1:\n               Kill the previous scheduler (use 'kill pid' where pid is the number reported in the file)\n               Then you can restart the new scheduler.\n\n            To solve case 2:\n               Remove the pid_file and restart the scheduler.\n\n            Exiting\"\"\" % self.pid_file)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nvalidates the JSON schema. Return list of errors.", "response": "def validate_json_schema(self):\n        \"\"\"Validate the JSON schema. Return list of errors.\"\"\"\n        errors = []\n\n        for work in self:\n            for task in work:\n                if not task.get_results().validate_json_schema():\n                    errors.append(task)\n            if not work.get_results().validate_json_schema():\n                errors.append(work)\n        if not self.get_results().validate_json_schema():\n            errors.append(self)\n\n        return errors"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nlist of errored tasks.", "response": "def errored_tasks(self):\n        \"\"\"List of errored tasks.\"\"\"\n        etasks = []\n        for status in [self.S_ERROR, self.S_QCRITICAL, self.S_ABICRITICAL]:\n            etasks.extend(list(self.iflat_tasks(status=status)))\n\n        return set(etasks)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef status_counter(self):\n        # Count the number of tasks with given status in each work.\n        counter = self[0].status_counter\n        for work in self[1:]:\n            counter += work.status_counter\n\n        return counter", "response": "Returns a Counter object that counts the number of tasks with given status in each work."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef chroot(self, new_workdir):\n        self._chrooted_from = self.workdir\n        self.set_workdir(new_workdir, chroot=True)\n\n        for i, work in enumerate(self):\n            new_wdir = os.path.join(self.workdir, \"w\" + str(i))\n            work.chroot(new_wdir)", "response": "Change the workir of the Flow."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef groupby_status(self):\n        Entry = collections.namedtuple(\"Entry\", \"task wi ti\")\n        d = collections.defaultdict(list)\n\n        for task, wi, ti in self.iflat_tasks_wti():\n            d[task.status].append(Entry(task, wi, ti))\n\n        # Sort keys according to their status.\n        return OrderedDict([(k, d[k]) for k in sorted(list(d.keys()))])", "response": "Returns an ordered dictionary mapping the task status to\n        the list of named tuples of task wi ti"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef groupby_task_class(self):\n        # Find all Task classes\n        class2tasks = OrderedDict()\n        for task in self.iflat_tasks():\n            cls = task.__class__\n            if cls not in class2tasks: class2tasks[cls] = []\n            class2tasks[cls].append(task)\n\n        return class2tasks", "response": "Returns a dictionary mapping the task class to the list of tasks in the flow\n       "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef iflat_nodes(self, status=None, op=\"==\", nids=None):\n        nids = as_set(nids)\n\n        if status is None:\n            if not (nids and self.node_id not in nids):\n                yield self\n\n            for work in self:\n                if nids and work.node_id not in nids: continue\n                yield work\n                for task in work:\n                    if nids and task.node_id not in nids: continue\n                    yield task\n        else:\n            # Get the operator from the string.\n            op = operator_from_str(op)\n\n            # Accept Task.S_FLAG or string.\n            status = Status.as_status(status)\n\n            if not (nids and self.node_id not in nids):\n                if op(self.status, status): yield self\n\n            for wi, work in enumerate(self):\n                if nids and work.node_id not in nids: continue\n                if op(work.status, status): yield work\n\n                for ti, task in enumerate(work):\n                    if nids and task.node_id not in nids: continue\n                    if op(task.status, status): yield task", "response": "Generates a flat sequence of nodes."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef node_from_nid(self, nid):\n        for node in self.iflat_nodes():\n            if node.node_id == nid: return node\n        raise ValueError(\"Cannot find node with node id: %s\" % nid)", "response": "Return the node in the Flow with the given nid identifier"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef iflat_tasks_wti(self, status=None, op=\"==\", nids=None):\n        return self._iflat_tasks_wti(status=status, op=op, nids=nids, with_wti=True)", "response": "Generator to iterate over all the tasks in the Flow that satisfy the condition."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngenerates a flat sequence of tasks in the iflat database.", "response": "def _iflat_tasks_wti(self, status=None, op=\"==\", nids=None, with_wti=True):\n        \"\"\"\n        Generators that produces a flat sequence of task.\n        if status is not None, only the tasks with the specified status are selected.\n        nids is an optional list of node identifiers used to filter the tasks.\n\n        Returns:\n            (task, work_index, task_index) if with_wti is True else task\n        \"\"\"\n        nids = as_set(nids)\n\n        if status is None:\n            for wi, work in enumerate(self):\n                for ti, task in enumerate(work):\n                    if nids and task.node_id not in nids: continue\n                    if with_wti:\n                        yield task, wi, ti\n                    else:\n                        yield task\n\n        else:\n            # Get the operator from the string.\n            op = operator_from_str(op)\n\n            # Accept Task.S_FLAG or string.\n            status = Status.as_status(status)\n\n            for wi, work in enumerate(self):\n                for ti, task in enumerate(work):\n                    if nids and task.node_id not in nids: continue\n                    if op(task.status, status):\n                        if with_wti:\n                            yield task, wi, ti\n                        else:\n                            yield task"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef abivalidate_inputs(self):\n        if not self.allocated:\n            self.allocate()\n\n        isok, tuples = True, []\n        for task in self.iflat_tasks():\n            t = task.input.abivalidate()\n            if t.retcode != 0: isok = False\n            tuples.append(t)\n\n        return isok, tuples", "response": "Run ABINIT in dry mode to validate all the inputs of the flow."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ntests the dependencies of the nodes for possible deadlocks.", "response": "def check_dependencies(self):\n        \"\"\"Test the dependencies of the nodes for possible deadlocks.\"\"\"\n        deadlocks = []\n\n        for task in self.iflat_tasks():\n            for dep in task.deps:\n                if dep.node.depends_on(task):\n                    deadlocks.append((task, dep.node))\n\n        if deadlocks:\n            lines = [\"Detect wrong list of dependecies that will lead to a deadlock:\"]\n            lines.extend([\"%s <--> %s\" % nodes for nodes in deadlocks])\n            raise RuntimeError(\"\\n\".join(lines))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef find_deadlocks(self):\n        # Find jobs that can be submitted and and the jobs that are already in the queue.\n        runnables = []\n        for work in self:\n            runnables.extend(work.fetch_alltasks_to_run())\n        runnables.extend(list(self.iflat_tasks(status=self.S_SUB)))\n\n        # Running jobs.\n        running = list(self.iflat_tasks(status=self.S_RUN))\n\n        # Find deadlocks.\n        err_tasks = self.errored_tasks\n        deadlocked = []\n        if err_tasks:\n            for task in self.iflat_tasks():\n                if any(task.depends_on(err_task) for err_task in err_tasks):\n                    deadlocked.append(task)\n\n        return dict2namedtuple(deadlocked=deadlocked, runnables=runnables, running=running)", "response": "This function detects deadlocks and runs jobs and deadlocks."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nchecks the status of the works in the flow.", "response": "def check_status(self, **kwargs):\n        \"\"\"\n        Check the status of the works in self.\n\n        Args:\n            show: True to show the status of the flow.\n            kwargs: keyword arguments passed to show_status\n        \"\"\"\n        for work in self:\n            work.check_status()\n\n        if kwargs.pop(\"show\", False):\n            self.show_status(**kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef fix_abicritical(self):\n        count = 0\n        for task in self.iflat_tasks(status=self.S_ABICRITICAL):\n            count += task.fix_abicritical()\n\n        return count", "response": "This function tries to fix critical events originating from ABINIT."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef show_info(self, **kwargs):\n        stream = kwargs.pop(\"stream\", sys.stdout)\n\n        lines = [str(self)]\n        app = lines.append\n\n        app(\"Number of works: %d, total number of tasks: %s\" % (len(self), self.num_tasks) )\n        app(\"Number of tasks with a given class:\\n\")\n\n        # Build Table\n        data = [[cls.__name__, len(tasks)]\n                for cls, tasks in self.groupby_task_class().items()]\n        app(str(tabulate(data, headers=[\"Task Class\", \"Number\"])))\n\n        stream.write(\"\\n\".join(lines))", "response": "Print info on the flow i. e. total number of tasks works tasks grouped by class."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef show_summary(self, **kwargs):\n        stream = kwargs.pop(\"stream\", sys.stdout)\n        stream.write(\"\\n\")\n        table = list(self.status_counter.items())\n        s = tabulate(table, headers=[\"Status\", \"Count\"])\n        stream.write(s + \"\\n\")\n        stream.write(\"\\n\")\n        stream.write(\"%s, num_tasks=%s, all_ok=%s\\n\" % (str(self), self.num_tasks, self.all_ok))\n        stream.write(\"\\n\")", "response": "Prints a short summary of the status of the flow and the number of tasks of the flow and the status of the flow and the status of the flow and the number of tasks of the flow."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef show_status(self, **kwargs):\n        stream = kwargs.pop(\"stream\", sys.stdout)\n        nids = as_set(kwargs.pop(\"nids\", None))\n        wslice = kwargs.pop(\"wslice\", None)\n        verbose = kwargs.pop(\"verbose\", 0)\n        wlist = None\n        if wslice is not None:\n            # Convert range to list of work indices.\n            wlist = list(range(wslice.start, wslice.step, wslice.stop))\n\n        #has_colours = stream_has_colours(stream)\n        has_colours = True\n        red = \"red\" if has_colours else None\n\n        for i, work in enumerate(self):\n            if nids and work.node_id not in nids: continue\n            print(\"\", file=stream)\n            cprint_map(\"Work #%d: %s, Finalized=%s\" % (i, work, work.finalized), cmap={\"True\": \"green\"}, file=stream)\n            if wlist is not None and i in wlist: continue\n            if verbose == 0 and work.finalized:\n                print(\"  Finalized works are not shown. Use verbose > 0 to force output.\", file=stream)\n                continue\n\n            headers = [\"Task\", \"Status\", \"Queue\", \"MPI|Omp|Gb\",\n                       \"Warn|Com\", \"Class\", \"Sub|Rest|Corr\", \"Time\",\n                       \"Node_ID\"]\n            table = []\n            tot_num_errors = 0\n            for task in work:\n                if nids and task.node_id not in nids: continue\n                task_name = os.path.basename(task.name)\n\n                # FIXME: This should not be done here.\n                # get_event_report should be called only in check_status\n                # Parse the events in the main output.\n                report = task.get_event_report()\n\n                # Get time info (run-time or time in queue or None)\n                stime = None\n                timedelta = task.datetimes.get_runtime()\n                if timedelta is not None:\n                    stime = str(timedelta) + \"R\"\n                else:\n                    timedelta = task.datetimes.get_time_inqueue()\n                    if timedelta is not None:\n                        stime = str(timedelta) + \"Q\"\n\n                events = \"|\".join(2*[\"NA\"])\n                if report is not None:\n                    events = '{:>4}|{:>3}'.format(*map(str, (\n                       report.num_warnings, report.num_comments)))\n\n                para_info = '{:>4}|{:>3}|{:>3}'.format(*map(str, (\n                   task.mpi_procs, task.omp_threads, \"%.1f\" % task.mem_per_proc.to(\"Gb\"))))\n\n                task_info = list(map(str, [task.__class__.__name__,\n                                 (task.num_launches, task.num_restarts, task.num_corrections), stime, task.node_id]))\n\n                qinfo = \"None\"\n                if task.queue_id is not None:\n                    qname = str(task.qname)\n                    if not verbose:\n                        qname = qname[:min(5, len(qname))]\n                    qinfo = str(task.queue_id) + \"@\" + qname\n\n                if task.status.is_critical:\n                    tot_num_errors += 1\n                    task_name = colored(task_name, red)\n\n                if has_colours:\n                    table.append([task_name, task.status.colored, qinfo,\n                                  para_info, events] + task_info)\n                else:\n                    table.append([task_name, str(task.status), qinfo, events,\n                                  para_info] + task_info)\n\n            # Print table and write colorized line with the total number of errors.\n            print(tabulate(table, headers=headers, tablefmt=\"grid\"), file=stream)\n            if tot_num_errors:\n                cprint(\"Total number of errors: %d\" % tot_num_errors, \"red\", file=stream)\n            print(\"\", file=stream)\n\n        if self.all_ok:\n            cprint(\"\\nall_ok reached\\n\", \"green\", file=stream)", "response": "Prints the status of the works and the status of different tasks on the specified stream."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nprint the events of Abinit tasks in the terminal.", "response": "def show_events(self, status=None, nids=None):\n        \"\"\"\n        Print the Abinit events (ERRORS, WARNIING, COMMENTS) to stdout\n\n        Args:\n            status: if not None, only the tasks with this status are select\n            nids: optional list of node identifiers used to filter the tasks.\n\t\"\"\"\n        nrows, ncols = get_terminal_size()\n\n        for task in self.iflat_tasks(status=status, nids=nids):\n            report = task.get_event_report()\n            if report:\n                print(make_banner(str(task), width=ncols, mark=\"=\"))\n                print(report)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef show_corrections(self, status=None, nids=None):\n        nrows, ncols = get_terminal_size()\n        count = 0\n        for task in self.iflat_tasks(status=status, nids=nids):\n            if task.num_corrections == 0: continue\n            count += 1\n            print(make_banner(str(task), width=ncols, mark=\"=\"))\n            for corr in task.corrections:\n                pprint(corr)\n\n        if not count: print(\"No correction found.\")\n        return count", "response": "Show the corrections applied to the flow at run - time."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef show_history(self, status=None, nids=None, full_history=False, metadata=False):\n        nrows, ncols = get_terminal_size()\n\n        works_done = []\n        # Loop on the tasks and show the history of the work is not in works_done\n        for task in self.iflat_tasks(status=status, nids=nids):\n            work = task.work\n\n            if work not in works_done:\n                works_done.append(work)\n                if work.history or full_history:\n                    cprint(make_banner(str(work), width=ncols, mark=\"=\"), **work.status.color_opts)\n                    print(work.history.to_string(metadata=metadata))\n\n            if task.history or full_history:\n                cprint(make_banner(str(task), width=ncols, mark=\"=\"), **task.status.color_opts)\n                print(task.history.to_string(metadata=metadata))\n\n        # Print the history of the flow.\n        if self.history or full_history:\n            cprint(make_banner(str(self), width=ncols, mark=\"=\"), **self.status.color_opts)\n            print(self.history.to_string(metadata=metadata))", "response": "Prints the history of the flow."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef show_inputs(self, varnames=None, nids=None, wslice=None, stream=sys.stdout):\n        if varnames is not None:\n            # Build dictionary varname --> [(task1, value), (task2, value), ...]\n            varnames = [s.strip() for s in list_strings(varnames)]\n            dlist = collections.defaultdict(list)\n            for task in self.select_tasks(nids=nids, wslice=wslice):\n                dstruct = task.input.structure.as_dict(fmt=\"abivars\")\n\n                for vname in varnames:\n                    value = task.input.get(vname, None)\n                    if value is None: # maybe in structure?\n                        value = dstruct.get(vname, None)\n                    if value is not None:\n                        dlist[vname].append((task, value))\n\n            for vname in varnames:\n                tv_list = dlist[vname]\n                if not tv_list:\n                    stream.write(\"[%s]: Found 0 tasks with this variable\\n\" % vname)\n                else:\n                    stream.write(\"[%s]: Found %s tasks with this variable\\n\" % (vname, len(tv_list)))\n                    for i, (task, value) in enumerate(tv_list):\n                        stream.write(\"   %s --> %s\\n\" % (str(value), task))\n                stream.write(\"\\n\")\n\n        else:\n            lines = []\n            for task in self.select_tasks(nids=nids, wslice=wslice):\n                s = task.make_input(with_header=True)\n\n                # Add info on dependencies.\n                if task.deps:\n                    s += \"\\n\\nDependencies:\\n\" + \"\\n\".join(str(dep) for dep in task.deps)\n                else:\n                    s += \"\\n\\nDependencies: None\"\n\n                lines.append(2*\"\\n\" + 80 * \"=\" + \"\\n\" + s + 2*\"\\n\")\n\n            stream.writelines(lines)", "response": "Prints the input of the tasks in the given stream."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef listext(self, ext, stream=sys.stdout):\n        nodes_files = []\n        for node in self.iflat_nodes():\n            filepath = node.outdir.has_abiext(ext)\n            if filepath:\n                nodes_files.append((node, File(filepath)))\n\n        if nodes_files:\n            print(\"Found %s files with extension `%s` produced by the flow\" % (len(nodes_files), ext), file=stream)\n\n            table = [[f.relpath, \"%.2f\" % (f.get_stat().st_size / 1024**2),\n                      node.node_id, node.__class__.__name__]\n                     for node, f in nodes_files]\n            print(tabulate(table, headers=[\"File\", \"Size [Mb]\", \"Node_ID\", \"Node Class\"]), file=stream)\n\n        else:\n            print(\"No output file with extension %s has been produced by the flow\" % ext, file=stream)", "response": "Print to the given stream a table with the list of the output files that have the given extension produced by the flow."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a list with a subset of tasks.", "response": "def select_tasks(self, nids=None, wslice=None, task_class=None):\n        \"\"\"\n        Return a list with a subset of tasks.\n\n        Args:\n            nids: List of node identifiers.\n            wslice: Slice object used to select works.\n            task_class: String or class used to select tasks. Ignored if None.\n\n        .. note::\n\n            nids and wslice are mutually exclusive.\n            If no argument is provided, the full list of tasks is returned.\n        \"\"\"\n        if nids is not None:\n            assert wslice is None\n            tasks = self.tasks_from_nids(nids)\n\n        elif wslice is not None:\n            tasks = []\n            for work in self[wslice]:\n                tasks.extend([t for t in work])\n        else:\n            # All tasks selected if no option is provided.\n            tasks = list(self.iflat_tasks())\n\n        # Filter by task class\n        if task_class is not None:\n            tasks = [t for t in tasks if t.isinstance(task_class)]\n\n        return tasks"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_task_scfcycles(self, nids=None, wslice=None, task_class=None, exclude_ok_tasks=False):\n        select_status = [self.S_RUN] if exclude_ok_tasks else [self.S_RUN, self.S_OK]\n        tasks_cycles = []\n\n        for task in self.select_tasks(nids=nids, wslice=wslice):\n            # Fileter\n            if task.status not in select_status or task.cycle_class is None:\n                continue\n            if task_class is not None and not task.isinstance(task_class):\n                continue\n            try:\n                cycle = task.cycle_class.from_file(task.output_file.path)\n                if cycle is not None:\n                    tasks_cycles.append((task, cycle))\n            except Exception:\n                # This is intentionally ignored because from_file can fail for several reasons.\n                pass\n\n        return tasks_cycles", "response": "Returns a list of tuples for all the tasks in the flow with a SCF algorithm."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nprinting a list of tricky tasks i. e. tasks that have been restarted more than once or tasks with corrections.", "response": "def show_tricky_tasks(self, verbose=0):\n        \"\"\"\n        Print list of tricky tasks i.e. tasks that have been restarted or\n        launched more than once or tasks with corrections.\n\n        Args:\n            verbose: Verbosity level. If > 0, task history and corrections (if any) are printed.\n        \"\"\"\n        nids, tasks = [], []\n        for task in self.iflat_tasks():\n            if task.num_launches > 1 or any(n > 0 for n in (task.num_restarts, task.num_corrections)):\n                nids.append(task.node_id)\n                tasks.append(task)\n\n        if not nids:\n            cprint(\"Everything's fine, no tricky tasks found\", color=\"green\")\n        else:\n            self.show_status(nids=nids)\n            if not verbose:\n                print(\"Use --verbose to print task history.\")\n                return\n\n            for nid, task in zip(nids, tasks):\n                cprint(repr(task), **task.status.color_opts)\n                self.show_history(nids=[nid], full_history=False, metadata=False)\n                #if task.num_restarts:\n                #    self.show_restarts(nids=[nid])\n                if task.num_corrections:\n                    self.show_corrections(nids=[nid])"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef inspect(self, nids=None, wslice=None, **kwargs):\n        figs = []\n        for task in self.select_tasks(nids=nids, wslice=wslice):\n            if hasattr(task, \"inspect\"):\n                fig = task.inspect(**kwargs)\n                if fig is None:\n                    cprint(\"Cannot inspect Task %s\" % task, color=\"blue\")\n                else:\n                    figs.append(fig)\n            else:\n                cprint(\"Task %s does not provide an inspect method\" % task, color=\"blue\")\n\n        return figs", "response": "Inspect the tasks and produce matplotlib plots."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_dict_for_mongodb_queries(self):\n        d = {}\n        return d\n        # TODO\n        all_structures = [task.input.structure for task in self.iflat_tasks()]\n        all_pseudos = [task.input.pseudos for task in self.iflat_tasks()]", "response": "This function returns a dictionary that will be used to create the mongodb document for the query."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ninsert results in the MongDB database.", "response": "def db_insert(self):\n        \"\"\"\n        Insert results in the `MongDB` database.\n        \"\"\"\n        assert self.has_db\n        # Connect to MongoDb and get the collection.\n        coll = self.manager.db_connector.get_collection()\n        print(\"Mongodb collection %s with count %d\", coll, coll.count())\n\n        start = time.time()\n        for work in self:\n            for task in work:\n                results = task.get_results()\n                pprint(results)\n                results.update_collection(coll)\n            results = work.get_results()\n            pprint(results)\n            results.update_collection(coll)\n        print(\"MongoDb update done in %s [s]\" % time.time() - start)\n\n        results = self.get_results()\n        pprint(results)\n        results.update_collection(coll)\n\n        # Update the pickle file to save the mongo ids.\n        self.pickle_dump()\n\n        for d in coll.find():\n            pprint(d)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the list of tasks associated to the given list of node identifiers.", "response": "def tasks_from_nids(self, nids):\n        \"\"\"\n        Return the list of tasks associated to the given list of node identifiers (nids).\n\n        .. note::\n\n            Invalid ids are ignored\n        \"\"\"\n        if not isinstance(nids, collections.abc.Iterable): nids = [nids]\n\n        n2task = {task.node_id: task for task in self.iflat_tasks()}\n        return [n2task[n] for n in nids if n in n2task]"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef open_files(self, what=\"o\", status=None, op=\"==\", nids=None, editor=None):\n        # Build list of files to analyze.\n        files = []\n        for task in self.iflat_tasks(status=status, op=op, nids=nids):\n            lst = task.select_files(what)\n            if lst:\n                files.extend(lst)\n\n        return Editor(editor=editor).edit_files(files)", "response": "Open the files of the flow inside an editor."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef parse_timing(self, nids=None):\n        # Get the list of output files according to nids.\n        paths = [task.output_file.path for task in self.iflat_tasks(nids=nids)]\n\n        # Parse data.\n        from .abitimer import AbinitTimerParser\n        parser = AbinitTimerParser()\n        read_ok = parser.parse(paths)\n        if read_ok:\n            return parser\n        return None", "response": "Parse the timer data in the main output file of Abinit."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nprints out a list of ABINIT errors for all tasks whose status is S_ABICRITICAL.", "response": "def show_abierrors(self, nids=None, stream=sys.stdout):\n        \"\"\"\n        Write to the given stream the list of ABINIT errors for all tasks whose status is S_ABICRITICAL.\n\n        Args:\n            nids: optional list of node identifiers used to filter the tasks.\n            stream: File-like object. Default: sys.stdout\n        \"\"\"\n        lines = []\n        app = lines.append\n\n        for task in self.iflat_tasks(status=self.S_ABICRITICAL, nids=nids):\n            header = \"=== \" + task.qout_file.path + \"===\"\n            app(header)\n            report = task.get_event_report()\n\n            if report is not None:\n                app(\"num_errors: %s, num_warnings: %s, num_comments: %s\" % (\n                    report.num_errors, report.num_warnings, report.num_comments))\n                app(\"*** ERRORS ***\")\n                app(\"\\n\".join(str(e) for e in report.errors))\n                app(\"*** BUGS ***\")\n                app(\"\\n\".join(str(b) for b in report.bugs))\n\n            else:\n                app(\"get_envent_report returned None!\")\n\n            app(\"=\" * len(header) + 2*\"\\n\")\n\n        return stream.writelines(lines)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef show_qouts(self, nids=None, stream=sys.stdout):\n        lines = []\n\n        for task in self.iflat_tasks(status=self.S_QCRITICAL, nids=nids):\n            header = \"=== \" + task.qout_file.path + \"===\"\n            lines.append(header)\n            if task.qout_file.exists:\n                with open(task.qout_file.path, \"rt\") as fh:\n                    lines += fh.readlines()\n            else:\n                lines.append(\"File does not exist!\")\n\n            lines.append(\"=\" * len(header) + 2*\"\\n\")\n\n        return stream.writelines(lines)", "response": "Prints out the content of the queue output file for all tasks whose status is S_QCRITICAL."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef debug(self, status=None, nids=None):\n        nrows, ncols = get_terminal_size()\n\n        # Test for scheduler exceptions first.\n        sched_excfile = os.path.join(self.workdir, \"_exceptions\")\n        if os.path.exists(sched_excfile):\n            with open(sched_excfile, \"r\") as fh:\n                cprint(\"Found exceptions raised by the scheduler\", \"red\")\n                cprint(fh.read(), color=\"red\")\n                return\n\n        if status is not None:\n            tasks = list(self.iflat_tasks(status=status, nids=nids))\n        else:\n            errors = list(self.iflat_tasks(status=self.S_ERROR, nids=nids))\n            qcriticals = list(self.iflat_tasks(status=self.S_QCRITICAL, nids=nids))\n            abicriticals = list(self.iflat_tasks(status=self.S_ABICRITICAL, nids=nids))\n            tasks = errors + qcriticals + abicriticals\n\n        # For each task selected:\n        #     1) Check the error files of the task. If not empty, print the content to stdout and we are done.\n        #     2) If error files are empty, look at the master log file for possible errors\n        #     3) If also this check failes, scan all the process log files.\n        #        TODO: This check is not needed if we introduce a new __abinit_error__ file\n        #        that is created by the first MPI process that invokes MPI abort!\n        #\n        ntasks = 0\n        for task in tasks:\n            print(make_banner(str(task), width=ncols, mark=\"=\"))\n            ntasks += 1\n\n            #  Start with error files.\n            for efname in [\"qerr_file\", \"stderr_file\",]:\n                err_file = getattr(task, efname)\n                if err_file.exists:\n                    s = err_file.read()\n                    if not s: continue\n                    print(make_banner(str(err_file), width=ncols, mark=\"=\"))\n                    cprint(s, color=\"red\")\n                    #count += 1\n\n            # Check main log file.\n            try:\n                report = task.get_event_report()\n                if report and report.num_errors:\n                    print(make_banner(os.path.basename(report.filename), width=ncols, mark=\"=\"))\n                    s = \"\\n\".join(str(e) for e in report.errors)\n                else:\n                    s = None\n            except Exception as exc:\n                s = str(exc)\n\n            count = 0 # count > 0 means we found some useful info that could explain the failures.\n            if s is not None:\n                cprint(s, color=\"red\")\n                count += 1\n\n            if not count:\n                # Inspect all log files produced by the other nodes.\n                log_files = task.tmpdir.list_filepaths(wildcard=\"*LOG_*\")\n                if not log_files:\n                    cprint(\"No *LOG_* file in tmpdir. This usually happens if you are running with many CPUs\", color=\"magenta\")\n\n                for log_file in log_files:\n                    try:\n                        report = EventsParser().parse(log_file)\n                        if report.errors:\n                            print(report)\n                            count += 1\n                            break\n                    except Exception as exc:\n                        cprint(str(exc), color=\"red\")\n                        count += 1\n                        break\n\n            if not count:\n                cprint(\"Houston, we could not find any error message that can explain the problem\", color=\"magenta\")\n\n        print(\"Number of tasks analyzed: %d\" % ntasks)", "response": "This method prints out info about the tasks produced by the flow."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncancels all the tasks in the queue.", "response": "def cancel(self, nids=None):\n        \"\"\"\n        Cancel all the tasks that are in the queue.\n        nids is an optional list of node identifiers used to filter the tasks.\n\n        Returns:\n            Number of jobs cancelled, negative value if error\n        \"\"\"\n        if self.has_chrooted:\n            # TODO: Use paramiko to kill the job?\n            warnings.warn(\"Cannot cancel the flow via sshfs!\")\n            return -1\n\n        # If we are running with the scheduler, we must send a SIGKILL signal.\n        if os.path.exists(self.pid_file):\n            cprint(\"Found scheduler attached to this flow.\", \"yellow\")\n            cprint(\"Sending SIGKILL to the scheduler before cancelling the tasks!\", \"yellow\")\n\n            with open(self.pid_file, \"rt\") as fh:\n                pid = int(fh.readline())\n\n            retcode = os.system(\"kill -9 %d\" % pid)\n            self.history.info(\"Sent SIGKILL to the scheduler, retcode: %s\" % retcode)\n            try:\n                os.remove(self.pid_file)\n            except IOError:\n                pass\n\n        num_cancelled = 0\n        for task in self.iflat_tasks(nids=nids):\n            num_cancelled += task.cancel()\n\n        return num_cancelled"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nremove workdir (same API as shutil.rmtree).", "response": "def rmtree(self, ignore_errors=False, onerror=None):\n        \"\"\"Remove workdir (same API as shutil.rmtree).\"\"\"\n        if not os.path.exists(self.workdir): return\n        shutil.rmtree(self.workdir, ignore_errors=ignore_errors, onerror=onerror)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef build(self, *args, **kwargs):\n        # Allocate here if not done yet!\n        if not self.allocated: self.allocate()\n\n        self.indir.makedirs()\n        self.outdir.makedirs()\n        self.tmpdir.makedirs()\n\n        # Check the nodeid file in workdir\n        nodeid_path = os.path.join(self.workdir, \".nodeid\")\n\n        if os.path.exists(nodeid_path):\n            with open(nodeid_path, \"rt\") as fh:\n                node_id = int(fh.read())\n\n            if self.node_id != node_id:\n                msg = (\"\\nFound node_id %s in file:\\n\\n  %s\\n\\nwhile the node_id of the present flow is %d.\\n\"\n                       \"This means that you are trying to build a new flow in a directory already used by another flow.\\n\"\n                       \"Possible solutions:\\n\"\n                       \"   1) Change the workdir of the new flow.\\n\"\n                       \"   2) remove the old directory either with `rm -r` or by calling the method flow.rmtree()\\n\"\n                        % (node_id, nodeid_path, self.node_id))\n                raise RuntimeError(msg)\n\n        else:\n            with open(nodeid_path, \"wt\") as fh:\n                fh.write(str(self.node_id))\n\n        if self.pyfile and os.path.isfile(self.pyfile):\n            shutil.copy(self.pyfile, self.workdir)\n\n        for work in self:\n            work.build(*args, **kwargs)", "response": "Make directories and files of the `Flow`."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nbuilds the directories and file of the Flow and saves the object in pickle format.", "response": "def build_and_pickle_dump(self, abivalidate=False):\n        \"\"\"\n        Build dirs and file of the `Flow` and save the object in pickle format.\n        Returns 0 if success\n\n        Args:\n            abivalidate: If True, all the input files are validate by calling\n                the abinit parser. If the validation fails, ValueError is raise.\n        \"\"\"\n        self.build()\n        if not abivalidate: return self.pickle_dump()\n\n        # Validation with Abinit.\n        isok, errors = self.abivalidate_inputs()\n        if isok: return self.pickle_dump()\n        errlines = []\n        for i, e in enumerate(errors):\n            errlines.append(\"[%d] %s\" % (i, e))\n        raise ValueError(\"\\n\".join(errlines))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsave the status of the object in pickle format. Returns 0 if success", "response": "def pickle_dump(self):\n        \"\"\"\n        Save the status of the object in pickle format.\n        Returns 0 if success\n        \"\"\"\n        if self.has_chrooted:\n            warnings.warn(\"Cannot pickle_dump since we have chrooted from %s\" % self.has_chrooted)\n            return -1\n\n        #if self.in_spectator_mode:\n        #    warnings.warn(\"Cannot pickle_dump since flow is in_spectator_mode\")\n        #    return -2\n\n        protocol = self.pickle_protocol\n\n        # Atomic transaction with FileLock.\n        with FileLock(self.pickle_file):\n            with AtomicFile(self.pickle_file, mode=\"wb\") as fh:\n                pmg_pickle_dump(self, fh, protocol=protocol)\n\n        return 0"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a string with the pickle representation.", "response": "def pickle_dumps(self, protocol=None):\n        \"\"\"\n        Return a string with the pickle representation.\n        `protocol` selects the pickle protocol. self.pickle_protocol is\n         used if `protocol` is None\n        \"\"\"\n        strio = StringIO()\n        pmg_pickle_dump(self, strio,\n                        protocol=self.pickle_protocol if protocol is None\n                        else protocol)\n        return strio.getvalue()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef register_work(self, work, deps=None, manager=None, workdir=None):\n        if getattr(self, \"workdir\", None) is not None:\n            # The flow has a directory, build the named of the directory of the work.\n            work_workdir = None\n            if workdir is None:\n                work_workdir = os.path.join(self.workdir, \"w\" + str(len(self)))\n            else:\n                work_workdir = os.path.join(self.workdir, os.path.basename(workdir))\n\n            work.set_workdir(work_workdir)\n\n        if manager is not None:\n            work.set_manager(manager)\n\n        self.works.append(work)\n\n        if deps:\n            deps = [Dependency(node, exts) for node, exts in deps.items()]\n            work.add_deps(deps)\n\n        return work", "response": "Register a new work and add it to the internal list."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nregistering a callback function that will generate the Task of the given work.", "response": "def register_work_from_cbk(self, cbk_name, cbk_data, deps, work_class, manager=None):\n        \"\"\"\n        Registers a callback function that will generate the :class:`Task` of the :class:`Work`.\n\n        Args:\n            cbk_name: Name of the callback function (must be a bound method of self)\n            cbk_data: Additional data passed to the callback function.\n            deps: List of :class:`Dependency` objects specifying the dependency of the work.\n            work_class: :class:`Work` class to instantiate.\n            manager: The :class:`TaskManager` responsible for the submission of the task.\n                    If manager is None, we use the `TaskManager` specified during the creation of the :class:`Flow`.\n\n        Returns:\n            The :class:`Work` that will be finalized by the callback.\n        \"\"\"\n        # TODO: pass a Work factory instead of a class\n        # Directory of the Work.\n        work_workdir = os.path.join(self.workdir, \"w\" + str(len(self)))\n\n        # Create an empty work and register the callback\n        work = work_class(workdir=work_workdir, manager=manager)\n\n        self._works.append(work)\n\n        deps = [Dependency(node, exts) for node, exts in deps.items()]\n        if not deps:\n            raise ValueError(\"A callback must have deps!\")\n\n        work.add_deps(deps)\n\n        # Wrap the callable in a Callback object and save\n        # useful info such as the index of the work and the callback data.\n        cbk = FlowCallback(cbk_name, self, deps=deps, cbk_data=cbk_data)\n        self._callbacks.append(cbk)\n\n        return work"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef allocate(self, workdir=None, use_smartio=False):\n        if workdir is not None:\n            # We set the workdir of the flow here\n            self.set_workdir(workdir)\n            for i, work in enumerate(self):\n                work.set_workdir(os.path.join(self.workdir, \"w\" + str(i)))\n\n        if not hasattr(self, \"workdir\"):\n            raise RuntimeError(\"You must call flow.allocate(workdir) if the workdir is not passed to __init__\")\n\n        for work in self:\n            # Each work has a reference to its flow.\n            work.allocate(manager=self.manager)\n            work.set_flow(self)\n            # Each task has a reference to its work.\n            for task in work:\n                task.set_work(work)\n\n        self.check_dependencies()\n\n        if not hasattr(self, \"_allocated\"): self._allocated = 0\n        self._allocated += 1\n\n        if use_smartio:\n            self.use_smartio()\n\n        return self", "response": "Allocate the Flow i. e. assign the workdir and the TaskManager to the different tasks in the Flow."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nprint to the given stream the ASCII representation of the dependency tree.", "response": "def show_dependencies(self, stream=sys.stdout):\n        \"\"\"Writes to the given stream the ASCII representation of the dependency tree.\"\"\"\n        def child_iter(node):\n            return [d.node for d in node.deps]\n\n        def text_str(node):\n            return colored(str(node), color=node.status.color_opts[\"color\"])\n\n        for task in self.iflat_tasks():\n            print(draw_tree(task, child_iter, text_str), file=stream)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef finalize(self):\n        if self.finalized:\n            self.history.warning(\"Calling finalize on an already finalized flow.\")\n            return 1\n\n        self.history.info(\"Calling flow.finalize.\")\n        self.finalized = True\n\n        if self.has_db:\n            self.history.info(\"Saving results in database.\")\n            try:\n                self.flow.db_insert()\n                self.finalized = True\n            except Exception:\n                 logger.critical(\"MongoDb insertion failed.\")\n                 return 2\n\n        # Here we remove the big output files if we have the garbage collector\n        # and the policy is set to \"flow.\"\n        if self.gc is not None and self.gc.policy == \"flow\":\n            self.history.info(\"gc.policy set to flow. Will clean task output files.\")\n            for task in self.iflat_tasks():\n                task.clean_output_files()\n\n        return 0", "response": "This method is called when the flow is complete."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_garbage_collector(self, exts=None, policy=\"task\"):\n        assert policy in (\"task\", \"flow\")\n        exts = list_strings(exts) if exts is not None else (\"WFK\", \"SUS\", \"SCR\", \"BSR\", \"BSC\")\n\n        gc = GarbageCollector(exts=set(exts), policy=policy)\n\n        self.set_gc(gc)\n        for work in self:\n            #work.set_gc(gc) # TODO Add support for Works and flow policy\n            for task in work:\n                task.set_gc(gc)", "response": "Enable the garbage collector that will remove the big output files that are not needed."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconnect the signals within the Flow and the callbacks.", "response": "def connect_signals(self):\n        \"\"\"\n        Connect the signals within the `Flow`.\n        The `Flow` is responsible for catching the important signals raised from its works.\n        \"\"\"\n        # Connect the signals inside each Work.\n        for work in self:\n            work.connect_signals()\n\n        # Observe the nodes that must reach S_OK in order to call the callbacks.\n        for cbk in self._callbacks:\n            #cbk.enable()\n            for dep in cbk.deps:\n                logger.info(\"connecting %s \\nwith sender %s, signal %s\" % (str(cbk), dep.node, dep.node.S_OK))\n                dispatcher.connect(self.on_dep_ok, signal=dep.node.S_OK, sender=dep.node, weak=False)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndisabling the signals within the Flow.", "response": "def disconnect_signals(self):\n        \"\"\"Disable the signals within the `Flow`.\"\"\"\n        # Disconnect the signals inside each Work.\n        for work in self:\n            work.disconnect_signals()\n\n        # Disable callbacks.\n        for cbk in self._callbacks:\n            cbk.disable()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_spectator_mode(self, mode=True):\n        # Set the flags of all the nodes in the flow.\n        mode = bool(mode)\n        self.in_spectator_mode = mode\n        for node in self.iflat_nodes():\n            node.in_spectator_mode = mode\n\n        # connect/disconnect signals depending on mode.\n        if not mode:\n            self.connect_signals()\n        else:\n            self.disconnect_signals()", "response": "Set the flow in spectator mode."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nuses PyLauncher to submits tasks in rapidfire mode.", "response": "def rapidfire(self, check_status=True, max_nlaunch=-1, max_loops=1, sleep_time=5, **kwargs):\n        \"\"\"\n        Use :class:`PyLauncher` to submits tasks in rapidfire mode.\n        kwargs contains the options passed to the launcher.\n\n        Args:\n            check_status:\n            max_nlaunch: Maximum number of launches. default: no limit.\n            max_loops: Maximum number of loops\n            sleep_time: seconds to sleep between rapidfire loop iterations\n\n        Return:\n            Number of tasks submitted.\n        \"\"\"\n        self.check_pid_file()\n        self.set_spectator_mode(False)\n        if check_status: self.check_status()\n        from .launcher import PyLauncher\n        return PyLauncher(self, **kwargs).rapidfire(max_nlaunch=max_nlaunch, max_loops=max_loops, sleep_time=sleep_time)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nusing PyLauncher to submit one task.", "response": "def single_shot(self, check_status=True, **kwargs):\n        \"\"\"\n        Use :class:`PyLauncher` to submits one task.\n        kwargs contains the options passed to the launcher.\n\n        Return:\n            number of tasks submitted.\n        \"\"\"\n        self.check_pid_file()\n        self.set_spectator_mode(False)\n        if check_status: self.check_status()\n        from .launcher import PyLauncher\n        return PyLauncher(self, **kwargs).single_shot()"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nbuilds a return a PyFlowScheduler to run the flow.", "response": "def make_scheduler(self, **kwargs):\n        \"\"\"\n        Build a return a :class:`PyFlowScheduler` to run the flow.\n\n        Args:\n            kwargs: if empty we use the user configuration file.\n                    if `filepath` in kwargs we init the scheduler from filepath.\n                    else pass **kwargs to :class:`PyFlowScheduler` __init__ method.\n        \"\"\"\n        from .launcher import PyFlowScheduler\n        if not kwargs:\n            # User config if kwargs is empty\n            sched = PyFlowScheduler.from_user_config()\n        else:\n            # Use from_file if filepath if present, else call __init__\n            filepath = kwargs.pop(\"filepath\", None)\n            if filepath is not None:\n                assert not kwargs\n                sched = PyFlowScheduler.from_file(filepath)\n            else:\n                sched = PyFlowScheduler(**kwargs)\n\n        sched.add_flow(self)\n        return sched"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nrunning the flow in batch mode returns exit status of the job script.", "response": "def batch(self, timelimit=None):\n        \"\"\"\n        Run the flow in batch mode, return exit status of the job script.\n        Requires a manager.yml file and a batch_adapter adapter.\n\n        Args:\n            timelimit: Time limit (int with seconds or string with time given with the slurm convention:\n            \"days-hours:minutes:seconds\"). If timelimit is None, the default value specified in the\n            `batch_adapter` entry of `manager.yml` is used.\n        \"\"\"\n        from .launcher import BatchLauncher\n        # Create a batch dir from the flow.workdir.\n        prev_dir = os.path.join(*self.workdir.split(os.path.sep)[:-1])\n        prev_dir = os.path.join(os.path.sep, prev_dir)\n        workdir = os.path.join(prev_dir, os.path.basename(self.workdir) + \"_batch\")\n\n        return BatchLauncher(workdir=workdir, flows=self).submit(timelimit=timelimit)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef make_light_tarfile(self, name=None):\n        name = os.path.basename(self.workdir) + \"-light.tar.gz\" if name is None else name\n        return self.make_tarfile(name=name, exclude_dirs=[\"outdata\", \"indata\", \"tmpdata\"])", "response": "Lightweight tarball file. Mainly used for debugging. Return the name of the tarball file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef make_tarfile(self, name=None, max_filesize=None, exclude_exts=None, exclude_dirs=None, verbose=0, **kwargs):\n        def any2bytes(s):\n            \"\"\"Convert string or number to memory in bytes.\"\"\"\n            if is_string(s):\n                return int(Memory.from_string(s).to(\"b\"))\n            else:\n                return int(s)\n\n        if max_filesize is not None:\n            max_filesize = any2bytes(max_filesize)\n\n        if exclude_exts:\n            # Add/remove \".nc\" so that we can simply pass \"GSR\" instead of \"GSR.nc\"\n            # Moreover this trick allows one to treat WFK.nc and WFK file on the same footing.\n            exts = []\n            for e in list_strings(exclude_exts):\n                exts.append(e)\n                if e.endswith(\".nc\"):\n                    exts.append(e.replace(\".nc\", \"\"))\n                else:\n                    exts.append(e + \".nc\")\n            exclude_exts = exts\n\n        def filter(tarinfo):\n            \"\"\"\n            Function that takes a TarInfo object argument and returns the changed TarInfo object.\n            If it instead returns None the TarInfo object will be excluded from the archive.\n            \"\"\"\n            # Skip links.\n            if tarinfo.issym() or tarinfo.islnk():\n                if verbose: print(\"Excluding link: %s\" % tarinfo.name)\n                return None\n\n            # Check size in bytes\n            if max_filesize is not None and tarinfo.size > max_filesize:\n                if verbose: print(\"Excluding %s due to max_filesize\" % tarinfo.name)\n                return None\n\n            # Filter filenames.\n            if exclude_exts and any(tarinfo.name.endswith(ext) for ext in exclude_exts):\n                if verbose: print(\"Excluding %s due to extension\" % tarinfo.name)\n                return None\n\n            # Exlude directories (use dir basenames).\n            if exclude_dirs and any(dir_name in exclude_dirs for dir_name in tarinfo.name.split(os.path.sep)):\n                if verbose: print(\"Excluding %s due to exclude_dirs\" % tarinfo.name)\n                return None\n\n            return tarinfo\n\n        back = os.getcwd()\n        os.chdir(os.path.join(self.workdir, \"..\"))\n\n        import tarfile\n        name = os.path.basename(self.workdir) + \".tar.gz\" if name is None else name\n        with tarfile.open(name=name, mode='w:gz', **kwargs) as tar:\n            tar.add(os.path.basename(self.workdir), arcname=None, recursive=True, exclude=None, filter=filter)\n\n            # Add the script used to generate the flow.\n            if self.pyfile is not None and os.path.exists(self.pyfile):\n                tar.add(self.pyfile)\n\n        os.chdir(back)\n        return name", "response": "Create a tarball file from a TarFile object."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_graphviz(self, engine=\"automatic\", graph_attr=None, node_attr=None, edge_attr=None):\n        self.allocate()\n\n        from graphviz import Digraph\n        fg = Digraph(\"flow\", #filename=\"flow_%s.gv\" % os.path.basename(self.relworkdir),\n            engine=\"fdp\" if engine == \"automatic\" else engine)\n\n        # Set graph attributes.\n        # https://www.graphviz.org/doc/info/\n        #fg.attr(label=\"%s@%s\" % (self.__class__.__name__, self.relworkdir))\n        fg.attr(label=repr(self))\n        #fg.attr(fontcolor=\"white\", bgcolor='purple:pink')\n        fg.attr(rankdir=\"LR\", pagedir=\"BL\")\n        #fg.attr(constraint=\"false\", pack=\"true\", packMode=\"clust\")\n        fg.node_attr.update(color='lightblue2', style='filled')\n        #fg.node_attr.update(ranksep='equally')\n\n        # Add input attributes.\n        if graph_attr is not None:\n            fg.graph_attr.update(**graph_attr)\n        if node_attr is not None:\n            fg.node_attr.update(**node_attr)\n        if edge_attr is not None:\n            fg.edge_attr.update(**edge_attr)\n\n        def node_kwargs(node):\n            return dict(\n                #shape=\"circle\",\n                color=node.color_hex,\n                fontsize=\"8.0\",\n                label=(str(node) if not hasattr(node, \"pos_str\") else\n                    node.pos_str + \"\\n\" + node.__class__.__name__),\n            )\n\n        edge_kwargs = dict(arrowType=\"vee\", style=\"solid\")\n        cluster_kwargs = dict(rankdir=\"LR\", pagedir=\"BL\", style=\"rounded\", bgcolor=\"azure2\")\n\n        for work in self:\n            # Build cluster with tasks.\n            cluster_name = \"cluster%s\" % work.name\n            with fg.subgraph(name=cluster_name) as wg:\n                wg.attr(**cluster_kwargs)\n                wg.attr(label=\"%s (%s)\" % (work.__class__.__name__, work.name))\n                #wg.attr(label=repr(work))\n                #wg.attr(label=\"%s (%s)\\n%s (%s)\" % (\n                #    work.__class__.__name__, work.name, work.relworkdir, work.node_id))\n                for task in work:\n                    wg.node(task.name, **node_kwargs(task))\n                    # Connect children to task.\n                    for child in task.get_children():\n                        # Find file extensions required by this task\n                        i = [dep.node for dep in child.deps].index(task)\n                        edge_label = \"+\".join(child.deps[i].exts)\n                        fg.edge(task.name, child.name, label=edge_label, color=task.color_hex,\n                                **edge_kwargs)\n\n        # Treat the case in which we have a work producing output for other tasks.\n        for work in self:\n            children = work.get_children()\n            if not children: continue\n            cluster_name = \"cluster%s\" % work.name\n            seen = set()\n            for child in children:\n                # This is not needed, too much confusing\n                #fg.edge(cluster_name, child.name, color=work.color_hex, **edge_kwargs)\n                # Find file extensions required by work\n                i = [dep.node for dep in child.deps].index(work)\n                for ext in child.deps[i].exts:\n                    out = \"%s (%s)\" % (ext, work.name)\n                    fg.node(out)\n                    fg.edge(out, child.name, **edge_kwargs)\n                    key = (cluster_name, out)\n                    if key not in seen:\n                        seen.add(key)\n                        fg.edge(cluster_name, out, color=work.color_hex, **edge_kwargs)\n\n        # Treat the case in which we have a task that depends on external files.\n        seen = set()\n        for task in self.iflat_tasks():\n            #print(task.get_parents())\n            for node in (p for p in task.get_parents() if p.is_file):\n                #print(\"parent file node\", node)\n                #infile = \"%s (%s)\" % (ext, work.name)\n                infile = node.filepath\n                if infile not in seen:\n                    seen.add(infile)\n                    fg.node(infile, **node_kwargs(node))\n\n                fg.edge(infile, task.name, color=node.color_hex, **edge_kwargs)\n\n        return fg", "response": "Generate a flow in the DOT language."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef graphviz_imshow(self, ax=None, figsize=None, dpi=300, fmt=\"png\", **kwargs):\n        graph = self.get_graphviz(**kwargs)\n        graph.format = fmt\n        graph.attr(dpi=str(dpi))\n        #print(graph)\n        _, tmpname = tempfile.mkstemp()\n        path = graph.render(tmpname, view=False, cleanup=True)\n        ax, fig, _ = get_ax_fig_plt(ax=ax, figsize=figsize, dpi=dpi)\n        import matplotlib.image as mpimg\n        ax.imshow(mpimg.imread(path, format=\"png\")) #, interpolation=\"none\")\n        ax.axis(\"off\")\n\n        return fig", "response": "Generate flow graph in the DOT language and plot it with matplotlib."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nplotting the flow with the connections among the nodes and the status of the tasks.", "response": "def plot_networkx(self, mode=\"network\", with_edge_labels=False, ax=None, arrows=False,\n                      node_size=\"num_cores\", node_label=\"name_class\", layout_type=\"spring\", **kwargs):\n        \"\"\"\n        Use networkx to draw the flow with the connections among the nodes and\n        the status of the tasks.\n\n        Args:\n            mode: `networkx` to show connections, `status` to group tasks by status.\n            with_edge_labels: True to draw edge labels.\n            ax: matplotlib :class:`Axes` or None if a new figure should be created.\n            arrows: if True draw arrowheads.\n            node_size: By default, the size of the node is proportional to the number of cores used.\n            node_label: By default, the task class is used to label node.\n            layout_type: Get positions for all nodes using `layout_type`. e.g. pos = nx.spring_layout(g)\n\n        .. warning::\n\n            Requires networkx package.\n        \"\"\"\n        self.allocate()\n\n        # Build the graph\n        import networkx as nx\n        g = nx.Graph() if not arrows else nx.DiGraph()\n        edge_labels = {}\n        for task in self.iflat_tasks():\n            g.add_node(task, name=task.name)\n            for child in task.get_children():\n                g.add_edge(task, child)\n                # TODO: Add getters! What about locked nodes!\n                i = [dep.node for dep in child.deps].index(task)\n                edge_labels[(task, child)] = \" \".join(child.deps[i].exts)\n\n            filedeps = [d for d in task.deps if d.node.is_file]\n            for d in filedeps:\n                #print(d.node, d.exts)\n                g.add_node(d.node, name=\"%s (%s)\" % (d.node.basename, d.node.node_id))\n                g.add_edge(d.node, task)\n                edge_labels[(d.node, task)] = \"+\".join(d.exts)\n\n        # This part is needed if we have a work that produces output used by other nodes.\n        for work in self:\n            children = work.get_children()\n            if not children:\n                continue\n            g.add_node(work, name=work.name)\n            for task in work:\n                g.add_edge(task, work)\n                edge_labels[(task, work)] = \"all_ok \"\n            for child in children:\n                #print(child)\n                g.add_edge(work, child)\n                i = [dep.node for dep in child.deps].index(work)\n                edge_labels[(work, child)] = \"+\".join(child.deps[i].exts)\n\n        # Get positions for all nodes using layout_type.\n        # e.g. pos = nx.spring_layout(g)\n        pos = getattr(nx, layout_type + \"_layout\")(g)\n\n        # Select function used to compute the size of the node\n        def make_node_size(node):\n            if node.is_task:\n                return 300 * node.manager.num_cores\n            else:\n                return 600\n\n        # Function used to build the label\n        def make_node_label(node):\n            if node_label == \"name_class\":\n                if node.is_file:\n                    return \"%s\\n(%s)\" % (node.basename, node.node_id)\n                else:\n                    return (node.pos_str + \"\\n\" + node.__class__.__name__\n                            if hasattr(node, \"pos_str\") else str(node))\n            else:\n                raise NotImplementedError(\"node_label: %s\" % str(node_label))\n\n        labels = {node: make_node_label(node) for node in g.nodes()}\n        ax, fig, plt = get_ax_fig_plt(ax=ax)\n\n        # Select plot type.\n        if mode == \"network\":\n            nx.draw_networkx(g, pos, labels=labels,\n                             node_color=[node.color_rgb for node in g.nodes()],\n                             node_size=[make_node_size(node) for node in g.nodes()],\n                             width=1, style=\"dotted\", with_labels=True, arrows=arrows, ax=ax)\n\n            # Draw edge labels\n            if with_edge_labels:\n                nx.draw_networkx_edge_labels(g, pos, edge_labels=edge_labels, ax=ax)\n\n        elif mode == \"status\":\n            # Group tasks by status (only tasks are show here).\n            for status in self.ALL_STATUS:\n                tasks = list(self.iflat_tasks(status=status))\n\n                # Draw nodes (color is given by status)\n                node_color = status.color_opts[\"color\"]\n                if node_color is None: node_color = \"black\"\n                #print(\"num nodes %s with node_color %s\" % (len(tasks), node_color))\n\n                nx.draw_networkx_nodes(g, pos,\n                                       nodelist=tasks,\n                                       node_color=node_color,\n                                       node_size=[make_node_size(task) for task in tasks],\n                                       alpha=0.5, ax=ax\n                                       #label=str(status),\n                                       )\n            # Draw edges.\n            nx.draw_networkx_edges(g, pos, width=2.0, alpha=0.5, arrows=arrows, ax=ax) # edge_color='r')\n\n            # Draw labels\n            nx.draw_networkx_labels(g, pos, labels, font_size=12, ax=ax)\n\n            # Draw edge labels\n            if with_edge_labels:\n                nx.draw_networkx_edge_labels(g, pos, edge_labels=edge_labels, ax=ax)\n                #label_pos=0.5, font_size=10, font_color='k', font_family='sans-serif', font_weight='normal',\n                # alpha=1.0, bbox=None, ax=None, rotate=True, **kwds)\n\n        else:\n            raise ValueError(\"Unknown value for mode: %s\" % str(mode))\n\n        ax.axis(\"off\")\n        return fig"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef can_execute(self):\n        return not self._disabled and all(dep.status == dep.node.S_OK for dep in self.deps)", "response": "True if we can execute the callback."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate a PhononFlow object from an AbinitInput object defining a ground - state run.", "response": "def from_scf_input(cls, workdir, scf_input, ph_ngqpt, with_becs=True, manager=None, allocate=True):\n        \"\"\"\n        Create a `PhononFlow` for phonon calculations from an `AbinitInput` defining a ground-state run.\n\n        Args:\n            workdir: Working directory of the flow.\n            scf_input: :class:`AbinitInput` object with the parameters for the GS-SCF run.\n            ph_ngqpt: q-mesh for phonons. Must be a sub-mesh of the k-mesh used for\n                electrons. e.g if ngkpt = (8, 8, 8). ph_ngqpt = (4, 4, 4) is a valid choice\n                whereas ph_ngqpt = (3, 3, 3) is not!\n            with_becs: True if Born effective charges are wanted.\n            manager: :class:`TaskManager` object. Read from `manager.yml` if None.\n            allocate: True if the flow should be allocated before returning.\n\n        Return:\n            :class:`PhononFlow` object.\n        \"\"\"\n        flow = cls(workdir, manager=manager)\n\n        # Register the SCF task\n        flow.register_scf_task(scf_input)\n        scf_task = flow[0][0]\n\n        # Make sure k-mesh and q-mesh are compatible.\n        scf_ngkpt, ph_ngqpt = np.array(scf_input[\"ngkpt\"]), np.array(ph_ngqpt)\n\n        if any(scf_ngkpt % ph_ngqpt != 0):\n            raise ValueError(\"ph_ngqpt %s should be a sub-mesh of scf_ngkpt %s\" % (ph_ngqpt, scf_ngkpt))\n\n        # Get the q-points in the IBZ from Abinit\n        qpoints = scf_input.abiget_ibz(ngkpt=ph_ngqpt, shiftk=(0, 0, 0), kptopt=1).points\n\n        # Create a PhononWork for each q-point. Add DDK and E-field if q == Gamma and with_becs.\n        for qpt in qpoints:\n            if np.allclose(qpt, 0) and with_becs:\n                ph_work = BecWork.from_scf_task(scf_task)\n            else:\n                ph_work = PhononWork.from_scf_task(scf_task, qpoints=qpt)\n\n            flow.register_work(ph_work)\n\n        if allocate: flow.allocate()\n\n        return flow"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef open_final_ddb(self):\n        ddb_path = self.outdir.has_abiext(\"DDB\")\n        if not ddb_path:\n            if self.status == self.S_OK:\n                logger.critical(\"%s reached S_OK but didn't produce a GSR file in %s\" % (self, self.outdir))\n            return None\n\n        from abipy.dfpt.ddb import DdbFile\n        try:\n            return DdbFile(ddb_path)\n        except Exception as exc:\n            logger.critical(\"Exception while reading DDB file at %s:\\n%s\" % (ddb_path, str(exc)))\n            return None", "response": "Open the final DDB file."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef finalize(self):\n        # Merge all the out_DDB files found in work.outdir.\n        ddb_files = list(filter(None, [work.outdir.has_abiext(\"DDB\") for work in self]))\n\n        # Final DDB file will be produced in the outdir of the work.\n        out_ddb = self.outdir.path_in(\"out_DDB\")\n        desc = \"DDB file merged by %s on %s\" % (self.__class__.__name__, time.asctime())\n\n        mrgddb = wrappers.Mrgddb(manager=self.manager, verbose=0)\n        mrgddb.merge(self.outdir.path, ddb_files, out_ddb=out_ddb, description=desc)\n        print(\"Final DDB file available at %s\" % out_ddb)\n\n        # Call the method of the super class.\n        retcode = super().finalize()\n        return retcode", "response": "This method is called when the flow is completed."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef from_scf_input(cls, workdir, scf_input, manager=None, allocate=True):\n        flow = cls(workdir, manager=manager)\n\n        flow.register_scf_task(scf_input)\n        scf_task = flow[0][0]\n\n        nl_work = DteWork.from_scf_task(scf_task)\n\n        flow.register_work(nl_work)\n\n        if allocate: flow.allocate()\n\n        return flow", "response": "Create a NonlinearFlow object from a GS - SCF run."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef from_global_moment_and_saxis(cls, global_moment, saxis):\n        magmom = Magmom(global_moment)\n        return cls(magmom.get_moment(saxis=saxis), saxis=saxis)", "response": "Convenience method to initialize a new object from a given global Magmom and saxis."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the magnetic moment relative to a given spin quantization axis.", "response": "def get_moment(self, saxis=(0, 0, 1)):\n        \"\"\"\n        Get magnetic moment relative to a given spin quantization axis.\n        If no axis is provided, moment will be given relative to the\n        Magmom's internal spin quantization axis, i.e. equivalent to\n        Magmom.moment\n\n        :param axis: (list/numpy array) spin quantization axis\n        :return: np.ndarray of length 3\n        \"\"\"\n\n        # transform back to moment with spin axis [0, 0, 1]\n        m_inv = self._get_transformation_matrix_inv(self.saxis)\n        moment = np.matmul(self.moment, m_inv)\n\n        # transform to new saxis\n        m = self._get_transformation_matrix(saxis)\n        moment = np.matmul(moment, m)\n\n        # round small values to zero\n        moment[np.abs(moment) < 1e-8] = 0\n\n        return moment"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef have_consistent_saxis(magmoms):\n        magmoms = [Magmom(magmom) for magmom in magmoms]\n        ref_saxis = magmoms[0].saxis\n        match_ref = [magmom.saxis == ref_saxis for magmom in magmoms]\n        if np.all(match_ref):\n            return True\n        else:\n            return False", "response": "This method checks that all MAGMOM objects in a list have consistent spin quantization axis."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef are_collinear(magmoms):\n        magmoms = [Magmom(magmom) for magmom in magmoms]\n        if not Magmom.have_consistent_saxis(magmoms):\n            magmoms = Magmom.get_consistent_set(magmoms)\n\n        # convert to numpy array for convenience\n        magmoms = np.array([list(magmom) for magmom in magmoms])\n        magmoms = magmoms[np.any(magmoms, axis=1)] # remove zero magmoms\n        if len(magmoms) == 0:\n            return True\n\n        # use first moment as reference to compare against\n        ref_magmom = magmoms[0]\n        # magnitude of cross products != 0 if non-collinear with reference\n        num_ncl = np.count_nonzero(np.linalg.norm(np.cross(ref_magmom, magmoms), axis=1))\n        if num_ncl > 0:\n            return False\n        else:\n            return True", "response": "Method checks to see if a set of magmoms are collinear with each other."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating a Magmom object from a magnetic moment provided relative to crystal axes.", "response": "def from_moment_relative_to_crystal_axes(cls, moment, lattice):\n        \"\"\"\n        Obtaining a Magmom object from a magnetic moment provided\n        relative to crystal axes.\n\n        Used for obtaining moments from magCIF file.\n        :param magmom: list of floats specifying vector magmom\n        :param lattice: Lattice\n        :return: Magmom\n        \"\"\"\n        # get matrix representing unit lattice vectors\n        unit_m = lattice.matrix / np.linalg.norm(lattice.matrix, axis=1)[:, None]\n        moment = np.matmul(list(moment), unit_m)\n        # round small values to zero\n        moment[np.abs(moment) < 1e-8] = 0\n        return cls(moment)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_moment_relative_to_crystal_axes(self, lattice):\n        # get matrix representing unit lattice vectors\n        unit_m = lattice.matrix / np.linalg.norm(lattice.matrix, axis=1)[:, None]\n        # note np.matmul() requires numpy version >= 1.10\n        moment = np.matmul(self.global_moment, np.linalg.inv(unit_m))\n        # round small values to zero\n        moment[np.abs(moment) < 1e-8] = 0\n        return moment", "response": "Returns the moments relative to the crystal axes of the magnetic CIF file."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a Structure object from the Materials Project database via MP Rester.", "response": "def get_structure_from_mp(formula):\n    \"\"\"\n    Convenience method to get a crystal from the Materials Project database via\n    the API. Requires PMG_MAPI_KEY to be set.\n\n    Args:\n        formula (str): A formula\n\n    Returns:\n        (Structure) The lowest energy structure in Materials Project with that\n            formula.\n    \"\"\"\n    m = MPRester()\n    entries = m.get_entries(formula, inc_structure=\"final\")\n    if len(entries) == 0:\n        raise ValueError(\"No structure with formula %s in Materials Project!\" %\n                         formula)\n    elif len(entries) > 1:\n        warnings.warn(\"%d structures with formula %s found in Materials \"\n                      \"Project. The lowest energy structure will be returned.\" %\n                      (len(entries), formula))\n    return min(entries, key=lambda e: e.energy_per_atom).structure"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef order_assimilation(args):\n    (path, drone, data, status) = args\n    newdata = drone.assimilate(path)\n    if newdata:\n        data.append(json.dumps(newdata, cls=MontyEncoder))\n    status['count'] += 1\n    count = status['count']\n    total = status['total']\n    logger.info('{}/{} ({:.2f}%) done'.format(count, total,\n                                              count / total * 100))", "response": "Internal helper method for BorgQueen to process assimilation\n   "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nassimilate the entire subdirectory structure in rootpath.", "response": "def parallel_assimilate(self, rootpath):\n        \"\"\"\n        Assimilate the entire subdirectory structure in rootpath.\n        \"\"\"\n        logger.info('Scanning for valid paths...')\n        valid_paths = []\n        for (parent, subdirs, files) in os.walk(rootpath):\n            valid_paths.extend(self._drone.get_valid_paths((parent, subdirs,\n                                                            files)))\n        manager = Manager()\n        data = manager.list()\n        status = manager.dict()\n        status['count'] = 0\n        status['total'] = len(valid_paths)\n        logger.info('{} valid paths found.'.format(len(valid_paths)))\n        p = Pool(self._num_drones)\n        p.map(order_assimilation, ((path, self._drone, data, status)\n                                   for path in valid_paths))\n        for d in data:\n            self._data.append(json.loads(d, cls=MontyDecoder))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef serial_assimilate(self, rootpath):\n        valid_paths = []\n        for (parent, subdirs, files) in os.walk(rootpath):\n            valid_paths.extend(self._drone.get_valid_paths((parent, subdirs,\n                                                            files)))\n        data = []\n        count = 0\n        total = len(valid_paths)\n        for path in valid_paths:\n            newdata = self._drone.assimilate(path)\n            self._data.append(newdata)\n            count += 1\n            logger.info('{}/{} ({:.2f}%) done'.format(count, total,\n                                                      count / total * 100))\n        for d in data:\n            self._data.append(json.loads(d, cls=MontyDecoder))", "response": "Assimilate the entire subdirectory structure in rootpath serially."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nsave the assimilated data to a file.", "response": "def save_data(self, filename):\n        \"\"\"\n        Save the assimilated data to a file.\n\n        Args:\n            filename (str): filename to save the assimilated data to. Note\n                that if the filename ends with gz or bz2, the relevant gzip\n                or bz2 compression will be applied.\n        \"\"\"\n        with zopen(filename, \"wt\") as f:\n            json.dump(list(self._data), f, cls=MontyEncoder)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef load_data(self, filename):\n        with zopen(filename, \"rt\") as f:\n            self._data = json.load(f, cls=MontyDecoder)", "response": "Load assimilated data from a file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef eigenvectors_from_displacements(disp,masses):\n    nphonons,natoms,ndirections = disp.shape\n    sqrt_masses = np.sqrt(masses)\n    return np.einsum(\"nax,a->nax\",disp,sqrt_masses)", "response": "Calculate the eigenvectors from the atomic displacements\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the point where the minimum frequency is reached and its value", "response": "def min_freq(self):\n        \"\"\"\n        Returns the point where the minimum frequency is reached and its value\n        \"\"\"\n        i = np.unravel_index(np.argmin(self.bands), self.bands.shape)\n\n        return self.qpoints[i[1]], self.bands[i]"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the nac_frequencies for the given direction.", "response": "def get_nac_frequencies_along_dir(self, direction):\n        \"\"\"\n        Returns the nac_frequencies for the given direction (not necessarily a versor).\n        None if the direction is not present or nac_frequencies has not been calculated.\n\n        Args:\n            direction: the direction as a list of 3 elements\n        Returns:\n            the frequencies as a numpy array o(3*len(structure), len(qpoints)).\n            None if not found.\n        \"\"\"\n        versor = [i / np.linalg.norm(direction) for i in direction]\n        for d, f in self.nac_frequencies:\n            if np.allclose(versor, d):\n                return f\n\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the nac_eigendisplacements for the given direction.", "response": "def get_nac_eigendisplacements_along_dir(self, direction):\n        \"\"\"\n        Returns the nac_eigendisplacements for the given direction (not necessarily a versor).\n        None if the direction is not present or nac_eigendisplacements has not been calculated.\n\n        Args:\n            direction: the direction as a list of 3 elements\n        Returns:\n            the eigendisplacements as a numpy array of complex numbers with shape\n            (3*len(structure), len(structure), 3). None if not found.\n        \"\"\"\n        versor = [i / np.linalg.norm(direction) for i in direction]\n        for d, e in self.nac_eigendisplacements:\n            if np.allclose(versor, d):\n                return e\n\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef asr_breaking(self, tol_eigendisplacements=1e-5):\n\n        for i in range(self.nb_qpoints):\n            if np.allclose(self.qpoints[i].frac_coords, (0, 0, 0)):\n\n                if self.has_eigendisplacements:\n                    acoustic_modes_index = []\n                    for j in range(self.nb_bands):\n                        eig = self.eigendisplacements[j][i]\n                        if np.max(np.abs(eig[1:] - eig[:1])) < tol_eigendisplacements:\n                            acoustic_modes_index.append(j)\n                    # if acoustic modes are not correctly identified return use\n                    # the first three modes\n                    if len(acoustic_modes_index) != 3:\n                        acoustic_modes_index = [0, 1, 2]\n                    return self.bands[acoustic_modes_index, i]\n                else:\n                    return self.bands[:3, i]\n\n        return None", "response": "Returns the breaking of the acoustic sum rule for the three acoustic modes and the first three bands."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the list of equivalent qpoints to the given index.", "response": "def get_equivalent_qpoints(self, index):\n        \"\"\"\n        Returns the list of qpoint indices equivalent (meaning they are the\n        same frac coords) to the given one.\n\n        Args:\n            index: the qpoint index\n\n        Returns:\n            a list of equivalent indices\n\n        TODO: now it uses the label we might want to use coordinates instead\n        (in case there was a mislabel)\n        \"\"\"\n        #if the qpoint has no label it can\"t have a repetition along the band\n        #structure line object\n\n        if self.qpoints[index].label is None:\n            return [index]\n\n        list_index_qpoints = []\n        for i in range(self.nb_qpoints):\n            if self.qpoints[i].label == self.qpoints[index].label:\n                list_index_qpoints.append(i)\n\n        return list_index_qpoints"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_branch(self, index):\n        to_return = []\n        for i in self.get_equivalent_qpoints(index):\n            for b in self.branches:\n                    if b[\"start_index\"] <= i <= b[\"end_index\"]:\n                        to_return.append({\"name\": b[\"name\"],\n                                          \"start_index\": b[\"start_index\"],\n                                          \"end_index\": b[\"end_index\"],\n                                          \"index\": i})\n        return to_return", "response": "Returns in what branches are in which the qpoint is. There can be several\n            branches."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef write_phononwebsite(self,filename):\n        import json\n        with open(filename,'w') as f:\n            phononwebsite_json = json.dump(self.as_phononwebsite(),f)", "response": "Write a json file for the phononwebsite"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a dictionary with the phononwebsite format for the current state of the object.", "response": "def as_phononwebsite(self):\n        \"\"\"\n        Return a dictionary with the phononwebsite format:\n        http://henriquemiranda.github.io/phononwebsite\n        \"\"\"\n        d = {}\n\n        #define the lattice\n        d[\"lattice\"] = self.structure.lattice._matrix.tolist()\n      \n        #define atoms\n        atom_pos_car = []\n        atom_pos_red = []\n        atom_types = []\n        for site in self.structure.sites:\n            atom_pos_car.append(site.coords.tolist())\n            atom_pos_red.append(site.frac_coords.tolist())\n            atom_types.append(site.species_string)\n\n        #default for now\n        d[\"repetitions\"] = get_reasonable_repetitions(len(atom_pos_car))\n    \n        d[\"natoms\"] = len(atom_pos_car)\n        d[\"atom_pos_car\"] = atom_pos_car\n        d[\"atom_pos_red\"] = atom_pos_red\n        d[\"atom_types\"] = atom_types\n        d[\"atom_numbers\"] = self.structure.atomic_numbers\n        d[\"formula\"] = self.structure.formula\n        d[\"name\"] = self.structure.formula\n\n        #get qpoints\n        qpoints = []\n        for q in self.qpoints:\n            qpoints.append(list(q.frac_coords))\n        d[\"qpoints\"] = qpoints\n\n        # get labels\n        hsq_dict = collections.OrderedDict()\n        for nq,q in enumerate(self.qpoints):\n            if q.label is not None:\n                hsq_dict[nq] = q.label\n\n        #get distances\n        dist = 0\n        nqstart = 0\n        distances = [dist]\n        line_breaks = []\n        for nq in range(1,len(qpoints)):\n            q1 = np.array(qpoints[nq])\n            q2 = np.array(qpoints[nq-1])\n            #detect jumps\n            if ((nq in hsq_dict) and (nq-1 in hsq_dict)):\n                if (hsq_dict[nq] != hsq_dict[nq-1]):\n                    hsq_dict[nq-1] += \"|\"+hsq_dict[nq]\n                del hsq_dict[nq]\n                line_breaks.append((nqstart,nq))\n                nqstart = nq\n            else:\n                dist += np.linalg.norm(q1-q2)\n            distances.append(dist)\n        line_breaks.append((nqstart,len(qpoints)))\n        d[\"distances\"] = distances\n        d[\"line_breaks\"] = line_breaks\n        d[\"highsym_qpts\"] = list(hsq_dict.items())\n\n        #eigenvalues\n        thz2cm1 = 33.35641\n        bands = self.bands.copy()*thz2cm1\n        d[\"eigenvalues\"] = bands.T.tolist()\n\n        #eigenvectors\n        eigenvectors = self.eigendisplacements.copy()\n        eigenvectors /= np.linalg.norm(eigenvectors[0,0])\n        eigenvectors = eigenvectors.swapaxes(0,1)\n        eigenvectors = np.array([eigenvectors.real, eigenvectors.imag])\n        eigenvectors = np.rollaxis(eigenvectors,0,5)\n        d[\"vectors\"] = eigenvectors.tolist()\n \n        return d"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef band_reorder(self):\n        eiv = self.eigendisplacements\n        eig = self.bands\n    \n        nphonons,nqpoints = self.bands.shape\n        order = np.zeros([nqpoints,nphonons],dtype=int)\n        order[0] = np.array(range(nphonons))\n        \n        #get the atomic masses\n        atomic_masses = [ site.specie.atomic_mass for site in self.structure.sites ]\n \n        #get order\n        for nq in range(1,nqpoints):\n            old_eiv = eigenvectors_from_displacements(eiv[:,nq-1],atomic_masses)\n            new_eiv = eigenvectors_from_displacements(eiv[:,nq],  atomic_masses)\n            order[nq] = estimate_band_connection(old_eiv.reshape([nphonons,nphonons]).T,\n                                                 new_eiv.reshape([nphonons,nphonons]).T,\n                                                 order[nq-1])\n\n        #reorder\n        for nq in range(1,nqpoints):\n            eivq=eiv[:,nq]\n            eigq=eig[:,nq]\n            eiv[:,nq] = eivq[order[nq]]\n            eig[:,nq] = eigq[order[nq]]", "response": "Re - order the eigenvalues according to the similarity of the eigenvalues of the two structure objects."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nwrites a batch of vasp input files for a sequence of transformed structures to a single directory.", "response": "def batch_write_vasp_input(transformed_structures, vasp_input_set=MPRelaxSet,\n                           output_dir=\".\", create_directory=True,\n                           subfolder=None,\n                           include_cif=False, **kwargs):\n    \"\"\"\n    Batch write vasp input for a sequence of transformed structures to\n    output_dir, following the format output_dir/{group}/{formula}_{number}.\n\n    Args:\n        transformed_structures: Sequence of TransformedStructures.\n        vasp_input_set: pymatgen.io.vaspio_set.VaspInputSet to creates\n            vasp input files from structures.\n        output_dir: Directory to output files\n        create_directory (bool): Create the directory if not present.\n            Defaults to True.\n        subfolder: Function to create subdirectory name from\n            transformed_structure.\n            e.g., lambda x: x.other_parameters[\"tags\"][0] to use the first\n            tag.\n        include_cif (bool): Boolean indication whether to output a CIF as\n            well. CIF files are generally better supported in visualization\n            programs.\n    \"\"\"\n    for i, s in enumerate(transformed_structures):\n        formula = re.sub(r\"\\s+\", \"\", s.final_structure.formula)\n        if subfolder is not None:\n            subdir = subfolder(s)\n            dirname = os.path.join(output_dir, subdir,\n                                   \"{}_{}\".format(formula, i))\n        else:\n            dirname = os.path.join(output_dir, \"{}_{}\".format(formula, i))\n        s.write_vasp_input(vasp_input_set, dirname,\n                           create_directory=create_directory, **kwargs)\n        if include_cif:\n            from pymatgen.io.cif import CifWriter\n\n            writer = CifWriter(s.final_structure)\n            writer.write_file(os.path.join(dirname, \"{}.cif\".format(formula)))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef append_transformation(self, transformation, extend_collection=False,\n                              clear_redo=True):\n        \"\"\"\n        Appends a transformation to all TransformedStructures.\n\n        Args:\n            transformation: Transformation to append\n            extend_collection: Whether to use more than one output structure\n                from one-to-many transformations. extend_collection can be a\n                number, which determines the maximum branching for each\n                transformation.\n            clear_redo (bool): Whether to clear the redo list. By default,\n                this is True, meaning any appends clears the history of\n                undoing. However, when using append_transformation to do a\n                redo, the redo list should not be cleared to allow multiple\n                redos.\n\n        Returns:\n            List of booleans corresponding to initial transformed structures\n            each boolean describes whether the transformation altered the\n            structure\n        \"\"\"\n        if self.ncores and transformation.use_multiprocessing:\n            p = Pool(self.ncores)\n            # need to condense arguments into single tuple to use map\n            z = map(\n                lambda x: (x, transformation, extend_collection, clear_redo),\n                self.transformed_structures)\n            new_tstructs = p.map(_apply_transformation, z, 1)\n            self.transformed_structures = []\n            for ts in new_tstructs:\n                self.transformed_structures.extend(ts)\n        else:\n            new_structures = []\n            for x in self.transformed_structures:\n                new = x.append_transformation(transformation,\n                                              extend_collection,\n                                              clear_redo=clear_redo)\n                if new is not None:\n                    new_structures.extend(new)\n            self.transformed_structures.extend(new_structures)", "response": "Appends a transformation to all TransformedStructures in the current TransformedStructures."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef apply_filter(self, structure_filter):\n\n        def test_transformed_structure(ts):\n            return structure_filter.test(ts.final_structure)\n\n        self.transformed_structures = list(filter(test_transformed_structure,\n                                                  self.transformed_structures))\n        for ts in self.transformed_structures:\n            ts.append_filter(structure_filter)", "response": "Applies a structure_filter to the list of TransformedStructures\n            in the transmuter."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the value of a parameter in the transmuter.", "response": "def set_parameter(self, key, value):\n        \"\"\"\n        Add parameters to the transmuter. Additional parameters are stored in\n        the as_dict() output.\n\n        Args:\n            key: The key for the parameter.\n            value: The value for the parameter.\n        \"\"\"\n        for x in self.transformed_structures:\n            x.other_parameters[key] = value"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef append_transformed_structures(self, tstructs_or_transmuter):\n        if isinstance(tstructs_or_transmuter, self.__class__):\n            self.transformed_structures.extend(tstructs_or_transmuter\n                                               .transformed_structures)\n        else:\n            for ts in tstructs_or_transmuter:\n                assert isinstance(ts, TransformedStructure)\n            self.transformed_structures.extend(tstructs_or_transmuter)", "response": "Method appends the transformed structures to the transmuter list."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef from_structures(structures, transformations=None, extend_collection=0):\n        tstruct = [TransformedStructure(s, []) for s in structures]\n        return StandardTransmuter(tstruct, transformations, extend_collection)", "response": "This is a convenience method for creating a new instance of the Alternative class from a sequence of structures."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef from_filenames(filenames, transformations=None, primitive=True,\n                       extend_collection=False):\n        \"\"\"\n        Generates a TransformedStructureCollection from a cif, possibly\n        containing multiple structures.\n\n        Args:\n            filenames: List of strings of the cif files\n            transformations: New transformations to be applied to all\n                structures\n            primitive: Same meaning as in __init__.\n            extend_collection: Same meaning as in __init__.\n        \"\"\"\n\n        allcifs = []\n        for fname in filenames:\n            with open(fname, \"r\") as f:\n                allcifs.append(f.read())\n        return CifTransmuter(\"\\n\".join(allcifs), transformations,\n                             primitive=primitive,\n                             extend_collection=extend_collection)", "response": "Generates a TransformedStructureCollection from a list of filenames."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nparsing the SCF cycle and return a dictionary of the names of columns and values.", "response": "def _magic_parser(stream, magic):\n    \"\"\"\n    Parse the section with the SCF cycle\n\n    Returns:\n        dict where the key are the name of columns and\n        the values are list of numbers. Note if no section was found.\n\n    .. warning::\n\n        The parser is very fragile and should be replaced by YAML.\n    \"\"\"\n    #Example (SCF cycle, similar format is used for phonons):\n    #\n    #  iter   Etot(hartree)      deltaE(h)  residm     vres2\n    #  ETOT  1  -8.8604027880849    -8.860E+00 2.458E-02 3.748E+00\n\n    #  At SCF step    5       vres2   =  3.53E-08 < tolvrs=  1.00E-06 =>converged.\n    in_doc, fields = 0, None\n\n    for line in stream:\n        line = line.strip()\n\n        if line.startswith(magic):\n            keys = line.split()\n            fields = OrderedDict((k, []) for k in keys)\n\n        if fields is not None:\n            #print(line)\n            in_doc += 1\n            if in_doc == 1:\n                continue\n\n            # End of the section.\n            if not line: break\n\n            tokens = list(map(float, line.split()[1:]))\n            assert len(tokens) == len(keys)\n            for l, v in zip(fields.values(), tokens):\n                l.append(v)\n\n    # Convert values to numpy arrays.\n    if fields:\n        return OrderedDict([(k, np.array(v)) for k, v in fields.items()])\n    else:\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef yaml_read_kpoints(filename, doc_tag=\"!Kpoints\"):\n    with YamlTokenizer(filename) as r:\n        doc = r.next_doc_with_tag(doc_tag)\n        d = yaml.safe_load(doc.text_notag)\n\n        return np.array(d[\"reduced_coordinates_of_qpoints\"])", "response": "Read the K - points from file."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef yaml_read_irred_perts(filename, doc_tag=\"!IrredPerts\"):\n    with YamlTokenizer(filename) as r:\n        doc = r.next_doc_with_tag(doc_tag)\n        d = yaml.safe_load(doc.text_notag)\n\n        return [AttrDict(**pert) for pert in d[\"irred_perts\"]]", "response": "Read the list of irreducible perturbations from file."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef to_string(self, verbose=0):\n        rows = [[it + 1] + list(map(str, (self[k][it] for k in self.keys())))\n                for it in range(self.num_iterations)]\n\n        return tabulate(rows, headers=[\"Iter\"] + list(self.keys()))", "response": "String representation of the object."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef from_stream(cls, stream):\n        fields = _magic_parser(stream, magic=cls.MAGIC)\n\n        if fields:\n            fields.pop(\"iter\")\n            return cls(fields)\n        else:\n            return None", "response": "Read the first occurrence of ScfCycle from stream."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_label_cycle(self, label, cycle):\n        self.labels.append(label)\n        self.cycles.append(cycle)", "response": "Add a cycle to the plotter with label label."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nplot multiple cycels on a grid per quantity.", "response": "def combiplot(self, fontsize=8, **kwargs):\n        \"\"\"\n        Compare multiple cycels on a grid: one subplot per quantity,\n        all cycles on the same subplot.\n\n        Args:\n            fontsize: Legend fontsize.\n        \"\"\"\n        ax_list = None\n        for i, (label, cycle) in enumerate(self.items()):\n            fig = cycle.plot(ax_list=ax_list, label=label, fontsize=fontsize,\n                             lw=2.0, marker=\"o\", linestyle=\"-\", show=False)\n            ax_list = fig.axes\n\n        return fig"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef slideshow(self, **kwargs):\n        for label, cycle in self.items():\n            cycle.plot(title=label, tight_layout=True)", "response": "Produce slideshow of the different cycles. One plot per cycle."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nstring representation of the set of related items.", "response": "def to_string(self, verbose=0):\n        \"\"\"String representation.\"\"\"\n        lines = []\n        app = lines.append\n        for i, cycle in enumerate(self):\n            app(\"\")\n            app(\"RELAXATION STEP: %d\" % (i + 1))\n            app(cycle.to_string(verbose=verbose))\n\n        return \"\\n\".join(lines)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nextract data from stream. Returns None if some error occurred.", "response": "def from_stream(cls, stream):\n        \"\"\"\n        Extract data from stream. Returns None if some error occurred.\n        \"\"\"\n        cycles = []\n        while True:\n            scf_cycle = GroundStateScfCycle.from_stream(stream)\n            if scf_cycle is None: break\n            cycles.append(scf_cycle)\n\n        return cls(cycles) if cycles else None"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef history(self):\n        history = OrderedDict()\n        for cycle in self:\n            d = cycle.last_iteration\n            for k, v in d.items():\n                if k in history:\n                    history[k].append(v)\n                else:\n                    history[k] = [v]\n\n        # Convert to numpy arrays.\n        for k, v in history.items():\n            history[k] = np.array(v)\n\n        return history", "response": "Returns an ordered dictionary of lists with the evolution of\n            the data as function of the relaxation step."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nuses matplotlib to plot the evolution of the structural relaxation.", "response": "def slideshow(self, **kwargs):\n        \"\"\"\n        Uses matplotlib to plot the evolution of the structural relaxation.\n\n        Args:\n            ax_list: List of axes. If None a new figure is produced.\n\n        Returns:\n            `matplotlib` figure\n        \"\"\"\n        for i, cycle in enumerate(self.cycles):\n            cycle.plot(title=\"Relaxation step %s\" % (i + 1),\n                       tight_layout=kwargs.pop(\"tight_layout\", True),\n                       show=kwargs.pop(\"show\", True))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nplot relaxation history i. e. the results of the last iteration of each SCF cycle.", "response": "def plot(self, ax_list=None, fontsize=12, **kwargs):\n        \"\"\"\n        Plot relaxation history i.e. the results of the last iteration of each SCF cycle.\n\n        Args:\n            ax_list: List of axes. If None a new figure is produced.\n            fontsize: legend fontsize.\n            kwargs: keyword arguments are passed to ax.plot\n\n        Returns: matplotlib figure\n        \"\"\"\n        history = self.history\n\n        # Build grid of plots.\n        num_plots, ncols, nrows = len(history), 1, 1\n        if num_plots > 1:\n            ncols = 2\n            nrows = num_plots // ncols + num_plots % ncols\n\n        ax_list, fig, plot = get_axarray_fig_plt(ax_list, nrows=nrows, ncols=ncols,\n                                                 sharex=True, sharey=False, squeeze=False)\n        ax_list = np.array(ax_list).ravel()\n\n        iter_num = np.array(list(range(self.num_iterations))) + 1\n        label = kwargs.pop(\"label\", None)\n\n        for i, ((key, values), ax) in enumerate(zip(history.items(), ax_list)):\n            ax.grid(True)\n            ax.set_xlabel('Relaxation Step')\n            ax.set_xticks(iter_num, minor=False)\n            ax.set_ylabel(key)\n\n            xx, yy = iter_num, values\n            if not kwargs and label is None:\n                ax.plot(xx, yy, \"-o\", lw=2.0)\n            else:\n                ax.plot(xx, yy, label=label if i == 0 else None, **kwargs)\n\n            if key in _VARS_SUPPORTING_LOGSCALE and np.all(yy > 1e-22):\n                ax.set_yscale(\"log\")\n\n            if key in _VARS_WITH_YRANGE:\n                ymin, ymax = _VARS_WITH_YRANGE[key]\n                val_min, val_max = np.min(yy), np.max(yy)\n                if abs(val_max - val_min) > abs(ymax - ymin):\n                    ax.set_ylim(ymin, ymax)\n\n            if label is not None:\n                ax.legend(loc=\"best\", fontsize=fontsize, shadow=True)\n\n        # Get around a bug in matplotlib.\n        if num_plots % ncols != 0:\n            ax_list[-1].plot(xx, yy, lw=0.0)\n            ax_list[-1].axis('off')\n\n        return fig"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nmove to new file position.", "response": "def seek(self, offset, whence=0):\n        \"\"\"\n        seek(offset[, whence]) -> None.  Move to new file position.\n\n        Argument offset is a byte count.  Optional argument whence defaults to\n        0 (offset from start of file, offset should be >= 0); other values are 1\n        (move relative to current position, positive or negative), and 2 (move\n        relative to end of file, usually negative, although many platforms allow\n        seeking beyond the end of a file).  If the file is opened in text mode,\n        only offsets returned by tell() are legal.  Use of other offsets causes\n        undefined behavior.\n        Note that not all file objects are seekable.\n        \"\"\"\n        assert offset == 0\n        self.linepos = 0\n        return self.stream.seek(offset, whence)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the next YAML document in the stream.", "response": "def next(self):\n        \"\"\"\n        Returns the first YAML document in stream.\n\n        .. warning::\n\n            Assume that the YAML document are closed explicitely with the sentinel '...'\n        \"\"\"\n        in_doc, lines, doc_tag = None, [], None\n\n        for i, line in enumerate(self.stream):\n            self.linepos += 1\n            #print(i, line)\n\n            if line.startswith(\"---\"):\n                # Include only lines in the form:\n                #  \"--- !tag\"\n                #  \"---\"\n                # Other lines are spurious.\n                in_doc = False\n                l = line[3:].strip().lstrip()\n\n                if l.startswith(\"!\"):\n                    # \"--- !tag\"\n                    doc_tag = l\n                    in_doc = True\n                elif not l:\n                    #  \"---\"\n                    in_doc = True\n                    doc_tag = None\n\n                if in_doc:\n                    lineno = self.linepos\n\n            if in_doc:\n                lines.append(line)\n\n            if in_doc and line.startswith(\"...\"):\n                return YamlDoc(text=\"\".join(lines), lineno=lineno, tag=doc_tag)\n\n        raise StopIteration(\"Cannot find next YAML document in %s\" % self.filename)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef next_doc_with_tag(self, doc_tag):\n        while True:\n            try:\n                doc = next(self)\n                if doc.tag == doc_tag:\n                    return doc\n\n            except StopIteration:\n                raise", "response": "Returns the next document with the specified tag. Empty string is no doc is found."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning all the documents with the specified tag.", "response": "def all_docs_with_tag(self, doc_tag):\n        \"\"\"\n        Returns all the documents with the specified tag.\n        \"\"\"\n        docs = []\n\n        while True:\n            try:\n                doc = self.next_doc_with(doc_tag)\n                docs.append(doc)\n\n            except StopIteration:\n                break\n\n        self.seek(0)\n        return docs"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the YAML text without the tag.", "response": "def text_notag(self):\n        \"\"\"\n        Returns the YAML text without the tag.\n        Useful if we don't have any constructor registered for the tag\n        (we used the tag just to locate the document).\n        \"\"\"\n        if self.tag is not None:\n            return self.text.replace(self.tag, \"\")\n        else:\n            return self.text"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _execute(self, workdir, with_mpirun=False, exec_args=None):\n        qadapter = self.manager.qadapter\n        if not with_mpirun: qadapter.name = None\n        if self.verbose:\n            print(\"Working in:\", workdir)\n\n        script = qadapter.get_script_str(\n            job_name=self.name,\n            launch_dir=workdir,\n            executable=self.executable,\n            qout_path=\"qout_file.path\",\n            qerr_path=\"qerr_file.path\",\n            stdin=self.stdin_fname,\n            stdout=self.stdout_fname,\n            stderr=self.stderr_fname,\n            exec_args=exec_args\n        )\n\n        # Write the script.\n        script_file = os.path.join(workdir, \"run\" + self.name + \".sh\")\n        with open(script_file, \"w\") as fh:\n            fh.write(script)\n            os.chmod(script_file, 0o740)\n\n        qjob, process = qadapter.submit_to_queue(script_file)\n        self.stdout_data, self.stderr_data = process.communicate()\n        self.returncode = process.returncode\n        #raise self.Error(\"%s returned %s\\n cmd_str: %s\" % (self, self.returncode, self.cmd_str))\n\n        return self.returncode", "response": "Execute the executable in a subprocess inside workdir."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef merge_qpoints(self, workdir, files_to_merge, out_prefix):\n        # We work with absolute paths.\n        files_to_merge = [os.path.abspath(s) for s in list_strings(files_to_merge)]\n        nfiles = len(files_to_merge)\n\n        if self.verbose:\n            print(\"Will merge %d files with output_prefix %s\" % (nfiles, out_prefix))\n            for (i, f) in enumerate(files_to_merge):\n                print(\" [%d] %s\" % (i, f))\n\n        if nfiles == 1:\n            raise self.Error(\"merge_qpoints does not support nfiles == 1\")\n\n        self.stdin_fname, self.stdout_fname, self.stderr_fname = \\\n            map(os.path.join, 3 * [workdir], [\"mrgscr.stdin\", \"mrgscr.stdout\", \"mrgscr.stderr\"])\n\n        inp = StringIO()\n        inp.write(str(nfiles) + \"\\n\")     # Number of files to merge.\n        inp.write(out_prefix + \"\\n\")      # Prefix for the final output file:\n\n        for filename in files_to_merge:\n            inp.write(filename + \"\\n\")   # List with the files to merge.\n\n        inp.write(\"1\\n\")                 # Option for merging q-points.\n\n        self.stdin_data = [s for s in inp.getvalue()]\n\n        with open(self.stdin_fname, \"w\") as fh:\n            fh.writelines(self.stdin_data)\n            # Force OS to write data to disk.\n            fh.flush()\n            os.fsync(fh.fileno())\n\n        self.execute(workdir)", "response": "Execute mrgscr inside directory workdir to merge files_to_merge and produce new file with prefix out_prefix."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef merge(self, workdir, gswfk_file, dfpt_files, gkk_files, out_gkk, binascii=0):\n        raise NotImplementedError(\"This method should be tested\")\n        #out_gkk = out_gkk if cwd is None else os.path.join(os.path.abspath(cwd), out_gkk)\n\n        # We work with absolute paths.\n        gswfk_file = os.path.absath(gswfk_file)\n        dfpt_files = [os.path.abspath(s) for s in list_strings(dfpt_files)]\n        gkk_files = [os.path.abspath(s) for s in list_strings(gkk_files)]\n\n        print(\"Will merge %d 1WF files, %d GKK file in output %s\" %\n              (len(dfpt_files), len(gkk_files), out_gkk))\n\n        if self.verbose:\n            for i, f in enumerate(dfpt_files): print(\" [%d] 1WF %s\" % (i, f))\n            for i, f in enumerate(gkk_files): print(\" [%d] GKK %s\" % (i, f))\n\n        self.stdin_fname, self.stdout_fname, self.stderr_fname = \\\n            map(os.path.join, 3 * [workdir], [\"mrggkk.stdin\", \"mrggkk.stdout\", \"mrggkk.stderr\"])\n\n        inp = StringIO()\n        inp.write(out_gkk + \"\\n\")        # Name of the output file\n        inp.write(str(binascii) + \"\\n\")  # Integer flag: 0 --> binary output, 1 --> ascii formatted output\n        inp.write(gswfk_file + \"\\n\")     # Name of the groud state wavefunction file WF\n\n        #dims = len(dfpt_files, gkk_files, ?)\n        dims = \" \".join([str(d) for d in dims])\n        inp.write(dims + \"\\n\")             # Number of 1WF, of GKK files, and number of 1WF files in all the GKK files\n\n        # Names of the 1WF files...\n        for fname in dfpt_files:\n            inp.write(fname + \"\\n\")\n\n        # Names of the GKK files...\n        for fname in gkk_files:\n            inp.write(fname + \"\\n\")\n\n        self.stdin_data = [s for s in inp.getvalue()]\n\n        with open(self.stdin_fname, \"w\") as fh:\n            fh.writelines(self.stdin_data)\n            # Force OS to write data to disk.\n            fh.flush()\n            os.fsync(fh.fileno())\n\n        self.execute(workdir)\n\n        return out_gkk", "response": "This method merges the GKK files into one database file."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef merge(self, workdir, ddb_files, out_ddb, description, delete_source_ddbs=True):\n        # We work with absolute paths.\n        ddb_files = [os.path.abspath(s) for s in list_strings(ddb_files)]\n        if not os.path.isabs(out_ddb):\n            out_ddb = os.path.join(os.path.abspath(workdir), os.path.basename(out_ddb))\n\n        if self.verbose:\n            print(\"Will merge %d files into output DDB %s\" % (len(ddb_files), out_ddb))\n            for i, f in enumerate(ddb_files):\n                print(\" [%d] %s\" % (i, f))\n\n        # Handle the case of a single file since mrgddb uses 1 to denote GS files!\n        if len(ddb_files) == 1:\n            with open(ddb_files[0], \"r\") as inh, open(out_ddb, \"w\") as out:\n                for line in inh:\n                    out.write(line)\n            return out_ddb\n\n        self.stdin_fname, self.stdout_fname, self.stderr_fname = \\\n            map(os.path.join, 3 * [os.path.abspath(workdir)], [\"mrgddb.stdin\", \"mrgddb.stdout\", \"mrgddb.stderr\"])\n\n        inp = StringIO()\n        inp.write(out_ddb + \"\\n\")              # Name of the output file.\n        inp.write(str(description) + \"\\n\")     # Description.\n        inp.write(str(len(ddb_files)) + \"\\n\")  # Number of input DDBs.\n\n        # Names of the DDB files.\n        for fname in ddb_files:\n            inp.write(fname + \"\\n\")\n\n        self.stdin_data = [s for s in inp.getvalue()]\n\n        with open(self.stdin_fname, \"wt\") as fh:\n            fh.writelines(self.stdin_data)\n            # Force OS to write data to disk.\n            fh.flush()\n            os.fsync(fh.fileno())\n\n        retcode = self.execute(workdir, exec_args=['--nostrict'])\n        if retcode == 0 and delete_source_ddbs:\n            # Remove ddb files.\n            for f in ddb_files:\n                try:\n                    os.remove(f)\n                except IOError:\n                    pass\n\n        return out_ddb", "response": "Merge the DDB files into a single file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef merge(self, workdir, pot_files, out_dvdb, delete_source=True):\n        # We work with absolute paths.\n        pot_files = [os.path.abspath(s) for s in list_strings(pot_files)]\n        if not os.path.isabs(out_dvdb):\n            out_dvdb = os.path.join(os.path.abspath(workdir), os.path.basename(out_dvdb))\n\n        if self.verbose:\n            print(\"Will merge %d files into output DVDB %s\" % (len(pot_files), out_dvdb))\n            for i, f in enumerate(pot_files):\n                print(\" [%d] %s\" % (i, f))\n\n        # Handle the case of a single file since mrgddb uses 1 to denote GS files!\n        if len(pot_files) == 1:\n            with open(pot_files[0], \"r\") as inh, open(out_dvdb, \"w\") as out:\n                for line in inh:\n                    out.write(line)\n            return out_dvdb\n\n        self.stdin_fname, self.stdout_fname, self.stderr_fname = \\\n            map(os.path.join, 3 * [os.path.abspath(workdir)], [\"mrgdvdb.stdin\", \"mrgdvdb.stdout\", \"mrgdvdb.stderr\"])\n\n        inp = StringIO()\n        inp.write(out_dvdb + \"\\n\")             # Name of the output file.\n        inp.write(str(len(pot_files)) + \"\\n\")  # Number of input POT files.\n\n        # Names of the POT files.\n        for fname in pot_files:\n            inp.write(fname + \"\\n\")\n\n        self.stdin_data = [s for s in inp.getvalue()]\n\n        with open(self.stdin_fname, \"wt\") as fh:\n            fh.writelines(self.stdin_data)\n            # Force OS to write data to disk.\n            fh.flush()\n            os.fsync(fh.fileno())\n\n        retcode = self.execute(workdir)\n        if retcode == 0 and delete_source:\n            # Remove pot files.\n            for f in pot_files:\n                try:\n                    os.remove(f)\n                except IOError:\n                    pass\n\n        return out_dvdb", "response": "Merge POT files into a single DVDB file."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nrun cut3d on the specified workdir and returns the standard output and the output filepath.", "response": "def cut3d(self, cut3d_input, workdir):\n        \"\"\"\n        Runs cut3d with a Cut3DInput\n\n        Args:\n            cut3d_input: a Cut3DInput object.\n            workdir: directory where cut3d is executed.\n\n        Returns:\n            (string) absolute path to the standard output of the cut3d execution.\n            (string) absolute path to the output filepath. None if output is required.\n        \"\"\"\n        self.stdin_fname, self.stdout_fname, self.stderr_fname = \\\n            map(os.path.join, 3 * [os.path.abspath(workdir)], [\"cut3d.stdin\", \"cut3d.stdout\", \"cut3d.stderr\"])\n\n        cut3d_input.write(self.stdin_fname)\n\n        retcode = self._execute(workdir, with_mpirun=False)\n\n        if retcode != 0:\n            raise RuntimeError(\"Error while running cut3d in %s.\" % workdir)\n\n        output_filepath = cut3d_input.output_filepath\n\n        if output_filepath is not None:\n            if not os.path.isabs(output_filepath):\n                output_filepath = os.path.abspath(os.path.join(workdir, output_filepath))\n\n            if not os.path.isfile(output_filepath):\n                raise RuntimeError(\"The file was not converted correctly in %s.\" % workdir)\n\n        return self.stdout_fname, output_filepath"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef from_path(cls, path, suffix=''):\n\n        def _get_filepath(filename, warning, path=path, suffix=suffix):\n            paths = glob.glob(os.path.join(path, filename + suffix + '*'))\n            if not paths:\n                warnings.warn(warning)\n                return None\n            if len(paths) > 1:\n                # using reverse=True because, if multiple files are present,\n                # they likely have suffixes 'static', 'relax', 'relax2', etc.\n                # and this would give 'static' over 'relax2' over 'relax'\n                # however, better to use 'suffix' kwarg to avoid this!\n                paths.sort(reverse=True)\n                warnings.warn('Multiple files detected, using {}'.format(os.path.basename(path)))\n            path = paths[0]\n            return path\n\n        chgcar_path = _get_filepath('CHGCAR', 'Could not find CHGCAR!')\n        chgcar = Chgcar.from_file(chgcar_path)\n\n        aeccar0_path = _get_filepath('AECCAR0', 'Could not find AECCAR0, interpret Bader results with caution.')\n        aeccar0 = Chgcar.from_file(aeccar0_path) if aeccar0_path else None\n\n        aeccar2_path = _get_filepath('AECCAR2', 'Could not find AECCAR2, interpret Bader results with caution.')\n        aeccar2 = Chgcar.from_file(aeccar2_path) if aeccar2_path else None\n\n        chgcar_ref = aeccar0.linear_add(aeccar2) if (aeccar0 and aeccar2) else None\n\n        return cls(chgcar.structure, chgcar, chgcar_ref)", "response": "This method creates a new instance of the class from a path to a VASP file."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the ellipticity of the species.", "response": "def ellipticity(self):\n        '''\n        Most meaningful for bond critical points,\n        can be physically interpreted as e.g. degree\n        of pi-bonding in organic molecules. Consult\n        literature for more information.\n        :return:\n        '''\n        eig = np.linalg.eig(self.field_hessian)\n        eig.sort()\n        return eig[0]/eig[1] - 1"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef structure_graph(self, edge_weight=\"bond_length\", edge_weight_units=\"\u00c5\"):\n\n        sg = StructureGraph.with_empty_graph(self.structure, name=\"bonds\",\n                                             edge_weight_name=edge_weight,\n                                             edge_weight_units=edge_weight_units)\n\n        edges = self.edges.copy()\n        idx_to_delete = []\n        # check for duplicate bonds\n        for idx, edge in edges.items():\n            unique_idx = self.nodes[idx]['unique_idx']\n            # only check edges representing bonds, not rings\n            if self.critical_points[unique_idx].type == CriticalPointType.bond:\n                if idx not in idx_to_delete:\n                    for idx2, edge2 in edges.items():\n                        if idx != idx2 and edge == edge2:\n                            idx_to_delete.append(idx2)\n                            warnings.warn(\"Duplicate edge detected, try re-running \"\n                                          \"critic2 with custom parameters to fix this. \"\n                                          \"Mostly harmless unless user is also \"\n                                          \"interested in rings/cages.\")\n                            logger.debug(\"Duplicate edge between points {} (unique point {})\"\n                                         \"and {} ({}).\".format(idx, self.nodes[idx]['unique_idx'],\n                                                               idx2, self.nodes[idx2]['unique_idx']))\n        # and remove any duplicate bonds present\n        for idx in idx_to_delete:\n            del edges[idx]\n\n        for idx, edge in edges.items():\n            unique_idx = self.nodes[idx]['unique_idx']\n            # only add edges representing bonds, not rings\n            if self.critical_points[unique_idx].type == CriticalPointType.bond:\n\n                from_idx = edge['from_idx']\n                to_idx = edge['to_idx']\n\n                from_lvec = edge['from_lvec']\n                to_lvec = edge['to_lvec']\n\n                relative_lvec = np.subtract(to_lvec, from_lvec)\n\n                if edge_weight == \"bond_length\":\n                    weight = self.structure.get_distance(from_idx, to_idx, jimage=relative_lvec)\n                else:\n                    weight = getattr(self.critical_points[unique_idx],\n                                     edge_weight, None)\n\n                sg.add_edge(from_idx, to_idx,\n                            from_jimage=from_lvec, to_jimage=to_lvec,\n                            weight=weight)\n\n        return sg", "response": "Returns a StructureGraph object describing the bonding information for the current crystal."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _add_node(self, idx, unique_idx, frac_coords):\n        self.nodes[idx] = {'unique_idx': unique_idx, 'frac_coords': frac_coords}", "response": "Add information about a node describing a critical point."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding an edge linking two critical points to the graph.", "response": "def _add_edge(self, idx, from_idx, from_lvec, to_idx, to_lvec):\n        \"\"\"\n        Add information about an edge linking two critical points.\n\n        This actually describes two edges:\n\n        from_idx ------ idx ------ to_idx\n\n        However, in practice, from_idx and to_idx will typically be\n        atom nuclei, with the center node (idx) referring to a bond\n        critical point. Thus, it will be more convenient to model\n        this as a single edge linking nuclei with the properties\n        of the bond critical point stored as an edge attribute.\n\n        :param idx: index of node\n        :param from_idx: from index of node\n        :param from_lvec: vector of lattice image the from node is in\n        as tuple of ints\n        :param to_idx: to index of node\n        :param to_lvec:  vector of lattice image the to node is in as\n        tuple of ints\n        :return:\n        \"\"\"\n        self.edges[idx] = {'from_idx': from_idx, 'from_lvec': from_lvec,\n                           'to_idx': to_idx, 'to_lvec': to_lvec}"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef calculate_bv_sum(site, nn_list, scale_factor=1.0):\n    el1 = Element(site.specie.symbol)\n    bvsum = 0\n    for (nn, dist) in nn_list:\n        el2 = Element(nn.specie.symbol)\n        if (el1 in ELECTRONEG or el2 in ELECTRONEG) and el1 != el2:\n            r1 = BV_PARAMS[el1][\"r\"]\n            r2 = BV_PARAMS[el2][\"r\"]\n            c1 = BV_PARAMS[el1][\"c\"]\n            c2 = BV_PARAMS[el2][\"c\"]\n            R = r1 + r2 - r1 * r2 * (sqrt(c1) - sqrt(c2)) ** 2 / \\\n                (c1 * r1 + c2 * r2)\n            vij = exp((R - dist * scale_factor) / 0.31)\n            bvsum += vij * (1 if el1.X < el2.X else -1)\n    return bvsum", "response": "Calculates the BV sum of a site."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncalculate the BV sum of a site for unordered structures.", "response": "def calculate_bv_sum_unordered(site, nn_list, scale_factor=1):\n    \"\"\"\n    Calculates the BV sum of a site for unordered structures.\n\n    Args:\n        site:\n            The site\n        nn_list:\n            List of nearest neighbors in the format [(nn_site, dist), ...].\n        scale_factor:\n            A scale factor to be applied. This is useful for scaling distance,\n            esp in the case of calculation-relaxed structures which may tend\n            to under (GGA) or over bind (LDA).\n    \"\"\"\n    # If the site \"site\" has N partial occupations as : f_{site}_0,\n    # f_{site}_1, ... f_{site}_N of elements\n    # X_{site}_0, X_{site}_1, ... X_{site}_N, and each neighbors nn_i in nn\n    # has N_{nn_i} partial occupations as :\n    # f_{nn_i}_0, f_{nn_i}_1, ..., f_{nn_i}_{N_{nn_i}}, then the bv sum of\n    # site \"site\" is obtained as :\n    # \\sum_{nn} \\sum_j^N \\sum_k^{N_{nn}} f_{site}_j f_{nn_i}_k vij_full\n    # where vij_full is the valence bond of the fully occupied bond\n    bvsum = 0\n    for specie1, occu1 in site.species.items():\n        el1 = Element(specie1.symbol)\n        for (nn, dist) in nn_list:\n            for specie2, occu2 in nn.species.items():\n                el2 = Element(specie2.symbol)\n                if (el1 in ELECTRONEG or el2 in ELECTRONEG) and el1 != el2:\n                    r1 = BV_PARAMS[el1][\"r\"]\n                    r2 = BV_PARAMS[el2][\"r\"]\n                    c1 = BV_PARAMS[el1][\"c\"]\n                    c2 = BV_PARAMS[el2][\"c\"]\n                    R = r1 + r2 - r1 * r2 * (sqrt(c1) - sqrt(c2)) ** 2 / \\\n                        (c1 * r1 + c2 * r2)\n                    vij = exp((R - dist * scale_factor) / 0.31)\n                    bvsum += occu1 * occu2 * vij * (1 if el1.X < el2.X else -1)\n    return bvsum"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds oxidation states to a structure by site fraction.", "response": "def add_oxidation_state_by_site_fraction(structure, oxidation_states):\n        \"\"\"\n        Add oxidation states to a structure by fractional site.\n\n        Args:\n            oxidation_states (list): List of list of oxidation states for each\n                site fraction for each site.\n                E.g., [[2, 4], [3], [-2], [-2], [-2]]\n        \"\"\"\n        try:\n            for i, site in enumerate(structure):\n                new_sp = collections.defaultdict(float)\n                for j, (el, occu) in enumerate(get_z_ordered_elmap(site\n                        .species)):\n                    specie = Specie(el.symbol, oxidation_states[i][j])\n                    new_sp[specie] += occu\n                structure[i] = new_sp\n            return structure\n        except IndexError:\n            raise ValueError(\"Oxidation state of all sites must be \"\n                             \"specified in the list.\")"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a list of valences for the structure. This currently works only for ordered structures only. Args: structure: Structure to analyze Returns: A list of valences for each site in the structure (for an ordered structure), e.g., [1, 1, -2] or a list of lists with the valences for each fractional element of each site in the structure (for an unordered structure), e.g., [[2, 4], [3], [-2], [-2], [-2]] Raises: A ValueError if the valences cannot be determined.", "response": "def get_valences(self, structure):\n        \"\"\"\n        Returns a list of valences for the structure. This currently works only\n        for ordered structures only.\n\n        Args:\n            structure: Structure to analyze\n\n        Returns:\n            A list of valences for each site in the structure (for an ordered\n            structure), e.g., [1, 1, -2] or a list of lists with the\n            valences for each fractional element of each site in the\n            structure (for an unordered structure),\n            e.g., [[2, 4], [3], [-2], [-2], [-2]]\n\n        Raises:\n            A ValueError if the valences cannot be determined.\n        \"\"\"\n        els = [Element(el.symbol) for el in structure.composition.elements]\n\n        if not set(els).issubset(set(BV_PARAMS.keys())):\n            raise ValueError(\n                \"Structure contains elements not in set of BV parameters!\"\n            )\n\n        # Perform symmetry determination and get sites grouped by symmetry.\n        if self.symm_tol:\n            finder = SpacegroupAnalyzer(structure, self.symm_tol)\n            symm_structure = finder.get_symmetrized_structure()\n            equi_sites = symm_structure.equivalent_sites\n        else:\n            equi_sites = [[site] for site in structure]\n\n        # Sort the equivalent sites by decreasing electronegativity.\n        equi_sites = sorted(equi_sites,\n                            key=lambda sites: -sites[0].species\n                            .average_electroneg)\n\n        # Get a list of valences and probabilities for each symmetrically\n        # distinct site.\n        valences = []\n        all_prob = []\n        if structure.is_ordered:\n            for sites in equi_sites:\n                test_site = sites[0]\n                nn = structure.get_neighbors(test_site, self.max_radius)\n                prob = self._calc_site_probabilities(test_site, nn)\n                all_prob.append(prob)\n                val = list(prob.keys())\n                # Sort valences in order of decreasing probability.\n                val = sorted(val, key=lambda v: -prob[v])\n                # Retain probabilities that are at least 1/100 of highest prob.\n                valences.append(\n                    list(filter(lambda v: prob[v] > 0.01 * prob[val[0]],\n                                val)))\n        else:\n            full_all_prob = []\n            for sites in equi_sites:\n                test_site = sites[0]\n                nn = structure.get_neighbors(test_site, self.max_radius)\n                prob = self._calc_site_probabilities_unordered(test_site, nn)\n                all_prob.append(prob)\n                full_all_prob.extend(prob.values())\n                vals = []\n                for (elsp, occ) in get_z_ordered_elmap(\n                        test_site.species):\n                    val = list(prob[elsp.symbol].keys())\n                    # Sort valences in order of decreasing probability.\n                    val = sorted(val, key=lambda v: -prob[elsp.symbol][v])\n                    # Retain probabilities that are at least 1/100 of highest\n                    # prob.\n                    vals.append(\n                        list(filter(\n                            lambda v: prob[elsp.symbol][v] > 0.001 * prob[\n                                elsp.symbol][val[0]], val)))\n                valences.append(vals)\n\n        # make variables needed for recursion\n        if structure.is_ordered:\n            nsites = np.array([len(i) for i in equi_sites])\n            vmin = np.array([min(i) for i in valences])\n            vmax = np.array([max(i) for i in valences])\n\n            self._n = 0\n            self._best_score = 0\n            self._best_vset = None\n\n            def evaluate_assignment(v_set):\n                el_oxi = collections.defaultdict(list)\n                for i, sites in enumerate(equi_sites):\n                    el_oxi[sites[0].specie.symbol].append(v_set[i])\n                max_diff = max([max(v) - min(v) for v in el_oxi.values()])\n                if max_diff > 1:\n                    return\n                score = functools.reduce(\n                    operator.mul, [all_prob[i][v] for i, v in enumerate(v_set)])\n                if score > self._best_score:\n                    self._best_vset = v_set\n                    self._best_score = score\n\n            def _recurse(assigned=[]):\n                # recurses to find permutations of valences based on whether a\n                # charge balanced assignment can still be found\n                if self._n > self.max_permutations:\n                    return\n\n                i = len(assigned)\n                highest = vmax.copy()\n                highest[:i] = assigned\n                highest *= nsites\n                highest = np.sum(highest)\n\n                lowest = vmin.copy()\n                lowest[:i] = assigned\n                lowest *= nsites\n                lowest = np.sum(lowest)\n\n                if highest < 0 or lowest > 0:\n                    self._n += 1\n                    return\n\n                if i == len(valences):\n                    evaluate_assignment(assigned)\n                    self._n += 1\n                    return\n                else:\n                    for v in valences[i]:\n                        new_assigned = list(assigned)\n                        _recurse(new_assigned + [v])\n        else:\n            nsites = np.array([len(i) for i in equi_sites])\n            tmp = []\n            attrib = []\n            for insite, nsite in enumerate(nsites):\n                for val in valences[insite]:\n                    tmp.append(nsite)\n                    attrib.append(insite)\n            new_nsites = np.array(tmp)\n            fractions = []\n            elements = []\n            for sites in equi_sites:\n                for sp, occu in get_z_ordered_elmap(sites[0].species):\n                    elements.append(sp.symbol)\n                    fractions.append(occu)\n            fractions = np.array(fractions, np.float)\n            new_valences = []\n            for vals in valences:\n                for val in vals:\n                    new_valences.append(val)\n            vmin = np.array([min(i) for i in new_valences], np.float)\n            vmax = np.array([max(i) for i in new_valences], np.float)\n\n            self._n = 0\n            self._best_score = 0\n            self._best_vset = None\n\n            def evaluate_assignment(v_set):\n                el_oxi = collections.defaultdict(list)\n                jj = 0\n                for i, sites in enumerate(equi_sites):\n                    for specie, occu in get_z_ordered_elmap(\n                            sites[0].species):\n                        el_oxi[specie.symbol].append(v_set[jj])\n                        jj += 1\n                max_diff = max([max(v) - min(v) for v in el_oxi.values()])\n                if max_diff > 2:\n                    return\n\n                score = six.moves.reduce(\n                    operator.mul,\n                    [all_prob[attrib[iv]][elements[iv]][vv]\n                     for iv, vv in enumerate(v_set)])\n                if score > self._best_score:\n                    self._best_vset = v_set\n                    self._best_score = score\n\n            def _recurse(assigned=[]):\n                # recurses to find permutations of valences based on whether a\n                # charge balanced assignment can still be found\n                if self._n > self.max_permutations:\n                    return\n\n                i = len(assigned)\n                highest = vmax.copy()\n                highest[:i] = assigned\n                highest *= new_nsites\n                highest *= fractions\n                highest = np.sum(highest)\n\n                lowest = vmin.copy()\n                lowest[:i] = assigned\n                lowest *= new_nsites\n                lowest *= fractions\n                lowest = np.sum(lowest)\n\n                if (highest < -self.charge_neutrality_tolerance or\n                        lowest > self.charge_neutrality_tolerance):\n                    self._n += 1\n                    return\n\n                if i == len(new_valences):\n                    evaluate_assignment(assigned)\n                    self._n += 1\n                    return\n                else:\n                    for v in new_valences[i]:\n                        new_assigned = list(assigned)\n                        _recurse(new_assigned + [v])\n\n        _recurse()\n\n        if self._best_vset:\n            if structure.is_ordered:\n                assigned = {}\n                for val, sites in zip(self._best_vset, equi_sites):\n                    for site in sites:\n                        assigned[site] = val\n\n                return [int(assigned[site]) for site in structure]\n            else:\n                assigned = {}\n                new_best_vset = []\n                for ii in range(len(equi_sites)):\n                    new_best_vset.append(list())\n                for ival, val in enumerate(self._best_vset):\n                    new_best_vset[attrib[ival]].append(val)\n                for val, sites in zip(new_best_vset, equi_sites):\n                    for site in sites:\n                        assigned[site] = val\n\n                return [[int(frac_site) for frac_site in assigned[site]]\n                        for site in structure]\n        else:\n            raise ValueError(\"Valences cannot be assigned!\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets an oxidation state decorated structure. This currently works only for ordered structures only.", "response": "def get_oxi_state_decorated_structure(self, structure):\n        \"\"\"\n        Get an oxidation state decorated structure. This currently works only\n        for ordered structures only.\n\n        Args:\n            structure: Structure to analyze\n\n        Returns:\n            A modified structure that is oxidation state decorated.\n\n        Raises:\n            ValueError if the valences cannot be determined.\n        \"\"\"\n        s = structure.copy()\n        if s.is_ordered:\n            valences = self.get_valences(s)\n            s.add_oxidation_state_by_site(valences)\n        else:\n            valences = self.get_valences(s)\n            s = add_oxidation_state_by_site_fraction(s, valences)\n        return s"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconverts fractional coordinates of trajectory into positions", "response": "def to_positions(self):\n        \"\"\"\n        Converts fractional coordinates of trajectory into positions\n        \"\"\"\n        if self.coords_are_displacement:\n            cumulative_displacements = np.cumsum(self.frac_coords, axis=0)\n            positions = self.base_positions + cumulative_displacements\n            self.frac_coords = positions\n            self.coords_are_displacement = False\n        return"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef to_displacements(self):\n        if not self.coords_are_displacement:\n            displacements = np.subtract(self.frac_coords, np.roll(self.frac_coords, 1, axis=0))\n            displacements[0] = np.zeros(np.shape(self.frac_coords[0]))\n            # Deal with PBC\n            displacements = [np.subtract(item, np.round(item)) for item in displacements]\n\n            self.frac_coords = displacements\n            self.coords_are_displacement = True\n        return", "response": "Converts position coordinates of trajectory into displacements between consecutive frames\n           "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef extend(self, trajectory):\n        if self.time_step != trajectory.time_step:\n            raise ValueError('Trajectory not extended: Time steps of trajectories is incompatible')\n\n        if len(self.species) != len(trajectory.species) and self.species != trajectory.species:\n            raise ValueError('Trajectory not extended: species in trajectory do not match')\n\n        self.to_positions()\n        trajectory.to_positions()\n\n        self.frac_coords = np.concatenate((self.frac_coords, trajectory.frac_coords), axis=0)\n        self.lattice, self.constant_lattice = self._combine_attribute(self.lattice, trajectory.lattice,\n                                                                      self.frac_coords.shape[0],\n                                                                      trajectory.frac_coords.shape[0])\n        self.site_properties = self._combine_attribute(self.site_properties, trajectory.site_properties,\n                                                       self.frac_coords.shape[0], trajectory.frac_coords.shape[0])", "response": "Extends this object with the contents of another trajectory."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_correction(self, entry):\n\n        if not self.axis:\n            list_axis_grid = np.array(entry.parameters[\"axis_grid\"])\n            list_bulk_plnr_avg_esp = np.array(entry.parameters[\"bulk_planar_averages\"])\n            list_defect_plnr_avg_esp = np.array(entry.parameters[\"defect_planar_averages\"])\n            list_axes = range(len(list_axis_grid))\n        else:\n            list_axes = np.array(self.axis)\n            list_axis_grid, list_bulk_plnr_avg_esp, list_defect_plnr_avg_esp = [], [], []\n            for ax in list_axes:\n                list_axis_grid.append(np.array(entry.parameters[\"axis_grid\"][ax]))\n                list_bulk_plnr_avg_esp.append(np.array(entry.parameters[\"bulk_planar_averages\"][ax]))\n                list_defect_plnr_avg_esp.append(np.array(entry.parameters[\"defect_planar_averages\"][ax]))\n\n        bulk_struct = entry.defect.bulk_structure.copy()\n        if \"scaling_matrix\" in entry.parameters.keys():\n            bulk_struct.make_supercell(entry.parameters[\"scaling_matrix\"])\n\n        lattice = bulk_struct.lattice\n        q = entry.defect.charge\n\n        es_corr = self.perform_es_corr(lattice, entry.charge)\n\n        pot_corr_tracker = []\n\n        for x, pureavg, defavg, axis in zip(list_axis_grid, list_bulk_plnr_avg_esp, list_defect_plnr_avg_esp,\n                                            list_axes):\n            tmp_pot_corr = self.perform_pot_corr(\n                x, pureavg, defavg, lattice, entry.charge, entry.site.coords, axis, widthsample=1.0)\n            pot_corr_tracker.append(tmp_pot_corr)\n\n        pot_corr = np.mean(pot_corr_tracker)\n\n        entry.parameters[\"freysoldt_meta\"] = dict(self.metadata)\n        entry.parameters[\"potalign\"] = pot_corr / (-q) if q else 0.\n\n        return {\"freysoldt_electrostatic\": es_corr, \"freysoldt_potential_alignment\": pot_corr}", "response": "This function returns the Freysoldt correction for a defect entry."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nperforms Electrostatic Freysoldt Correction on the species.", "response": "def perform_es_corr(self, lattice, q, step=1e-4):\n        \"\"\"\n        Peform Electrostatic Freysoldt Correction\n        \"\"\"\n        logger.info(\"Running Freysoldt 2011 PC calculation (should be \" \"equivalent to sxdefectalign)\")\n        logger.debug(\"defect lattice constants are (in angstroms)\" + str(lattice.abc))\n\n        [a1, a2, a3] = ang_to_bohr * np.array(lattice.get_cartesian_coords(1))\n        logging.debug(\"In atomic units, lat consts are (in bohr):\" + str([a1, a2, a3]))\n        vol = np.dot(a1, np.cross(a2, a3))  # vol in bohr^3\n\n        def e_iso(encut):\n            gcut = eV_to_k(encut)  # gcut is in units of 1/A\n            return scipy.integrate.quad(lambda g: self.q_model.rho_rec(g * g)**2, step, gcut)[0] * (q**2) / np.pi\n\n        def e_per(encut):\n            eper = 0\n            for g2 in generate_reciprocal_vectors_squared(a1, a2, a3, encut):\n                eper += (self.q_model.rho_rec(g2)**2) / g2\n            eper *= (q**2) * 2 * round(np.pi, 6) / vol\n            eper += (q**2) * 4 * round(np.pi, 6) \\\n                * self.q_model.rho_rec_limit0 / vol\n            return eper\n\n        eiso = converge(e_iso, 5, self.madetol, self.energy_cutoff)\n        logger.debug(\"Eisolated : %f\", round(eiso, 5))\n\n        eper = converge(e_per, 5, self.madetol, self.energy_cutoff)\n\n        logger.info(\"Eperiodic : %f hartree\", round(eper, 5))\n        logger.info(\"difference (periodic-iso) is %f hartree\", round(eper - eiso, 6))\n        logger.info(\"difference in (eV) is %f\", round((eper - eiso) * hart_to_ev, 4))\n\n        es_corr = round((eiso - eper) / self.dielectric * hart_to_ev, 6)\n        logger.info(\"Defect Correction without alignment %f (eV): \", es_corr)\n        return es_corr"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nperforming potential alignment correction for a given axis.", "response": "def perform_pot_corr(self,\n                         axis_grid,\n                         pureavg,\n                         defavg,\n                         lattice,\n                         q,\n                         defect_position,\n                         axis,\n                         madetol=0.0001,\n                         widthsample=1.0):\n        \"\"\"\n        For performing planar averaging potential alignment\n\n        title is for name of plot, if you dont want a plot then leave it as None\n        widthsample is the width (in Angstroms) of the region in between defects where the potential alignment correction is averaged\n        \"\"\"\n        logging.debug(\"run Freysoldt potential alignment method for axis \" + str(axis))\n        nx = len(axis_grid)\n\n        # shift these planar averages to have defect at origin\n        axfracval = lattice.get_fractional_coords(defect_position)[axis]\n        axbulkval = axfracval * lattice.abc[axis]\n        if axbulkval < 0:\n            axbulkval += lattice.abc[axis]\n        elif axbulkval > lattice.abc[axis]:\n            axbulkval -= lattice.abc[axis]\n\n        if axbulkval:\n            for i in range(nx):\n                if axbulkval < axis_grid[i]:\n                    break\n            rollind = len(axis_grid) - i\n            pureavg = np.roll(pureavg, rollind)\n            defavg = np.roll(defavg, rollind)\n\n        # if not self._silence:\n        logger.debug(\"calculating lr part along planar avg axis\")\n        reci_latt = lattice.reciprocal_lattice\n        dg = reci_latt.abc[axis]\n        dg /= ang_to_bohr  # convert to bohr to do calculation in atomic units\n\n        # Build background charge potential with defect at origin\n        v_G = np.empty(len(axis_grid), np.dtype(\"c16\"))\n        v_G[0] = 4 * np.pi * -q / self.dielectric * self.q_model.rho_rec_limit0\n        g = np.roll(np.arange(-nx / 2, nx / 2, 1, dtype=int), int(nx / 2)) * dg\n        g2 = np.multiply(g, g)[1:]\n        v_G[1:] = 4 * np.pi / (self.dielectric * g2) * -q * self.q_model.rho_rec(g2)\n        v_G[nx // 2] = 0 if not (nx % 2) else v_G[nx // 2]\n\n        # Get the real space potential by peforming a  fft and grabbing the imaginary portion\n        v_R = np.fft.fft(v_G)\n\n        if abs(np.imag(v_R).max()) > self.madetol:\n            raise Exception(\"imaginary part found to be %s\", repr(np.imag(v_R).max()))\n        v_R /= (lattice.volume * ang_to_bohr**3)\n        v_R = np.real(v_R) * hart_to_ev\n\n        # get correction\n        short = (defavg - pureavg - v_R)\n        checkdis = int((widthsample / 2) / (axis_grid[1] - axis_grid[0]))\n        mid = int(len(short) / 2)\n\n        tmppot = [short[i] for i in range(mid - checkdis, mid + checkdis + 1)]\n        logger.debug(\"shifted defect position on axis (%s) to origin\", repr(axbulkval))\n        logger.debug(\"means sampling region is (%f,%f)\", axis_grid[mid - checkdis], axis_grid[mid + checkdis])\n\n        C = -np.mean(tmppot)\n        logger.debug(\"C = %f\", C)\n        final_shift = [short[j] + C for j in range(len(v_R))]\n        v_R = [elmnt - C for elmnt in v_R]\n\n        logger.info(\"C value is averaged to be %f eV \", C)\n        logger.info(\"Potentital alignment energy correction (-q*delta V):  %f (eV)\", -q * C)\n        self.pot_corr = -q * C\n\n        # log plotting data:\n        self.metadata[\"pot_plot_data\"][axis] = {\n            \"Vr\": v_R,\n            \"x\": axis_grid,\n            \"dft_diff\": defavg - pureavg,\n            \"final_shift\": final_shift,\n            \"check\": [mid - checkdis, mid + checkdis + 1]\n        }\n\n        # log uncertainty:\n        self.metadata[\"pot_corr_uncertainty_md\"][axis] = {\"stats\": stats.describe(tmppot)._asdict(), \"potcorr\": -q * C}\n\n        return self.pot_corr"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef plot(self, axis, title=None, saved=False):\n\n        x = self.metadata['pot_plot_data'][axis]['x']\n        v_R = self.metadata['pot_plot_data'][axis]['Vr']\n        dft_diff = self.metadata['pot_plot_data'][axis]['dft_diff']\n        final_shift = self.metadata['pot_plot_data'][axis]['final_shift']\n        check = self.metadata['pot_plot_data'][axis]['check']\n\n        plt.figure()\n        plt.clf()\n        plt.plot(x, v_R, c=\"green\", zorder=1, label=\"long range from model\")\n        plt.plot(x, dft_diff, c=\"red\", label=\"DFT locpot diff\")\n        plt.plot(x, final_shift, c=\"blue\", label=\"short range (aligned)\")\n\n        tmpx = [x[i] for i in range(check[0], check[1])]\n        plt.fill_between(tmpx, -100, 100, facecolor=\"red\", alpha=0.15, label=\"sampling region\")\n\n        plt.xlim(round(x[0]), round(x[-1]))\n        ymin = min(min(v_R), min(dft_diff), min(final_shift))\n        ymax = max(max(v_R), max(dft_diff), max(final_shift))\n        plt.ylim(-0.2 + ymin, 0.2 + ymax)\n        plt.xlabel(\"distance along axis ($\\AA$)\", fontsize=15)\n        plt.ylabel(\"Potential (V)\", fontsize=15)\n        plt.legend(loc=9)\n        plt.axhline(y=0, linewidth=0.2, color=\"black\")\n        plt.title(str(title) + \" defect potential\", fontsize=18)\n        plt.xlim(0, max(x))\n        if saved:\n            plt.savefig(str(title) + \"FreyplnravgPlot.pdf\")\n        else:\n            return plt", "response": "Plots the planar average electrostatic potential against the Long range and short range models from Freysoldt"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the BandFilling correction for a defect entry", "response": "def get_correction(self, entry):\n        \"\"\"\n        Gets the BandFilling correction for a defect entry\n        \"\"\"\n        eigenvalues = entry.parameters[\"eigenvalues\"]\n        kpoint_weights = entry.parameters[\"kpoint_weights\"]\n        potalign = entry.parameters[\"potalign\"]\n        vbm = entry.parameters[\"vbm\"]\n        cbm = entry.parameters[\"cbm\"]\n\n        bf_corr = self.perform_bandfill_corr(eigenvalues, kpoint_weights, potalign, vbm, cbm)\n\n        entry.parameters[\"bandfilling_meta\"] = dict(self.metadata)\n\n        return {\"bandfilling\": bf_corr}"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef perform_bandfill_corr(self, eigenvalues, kpoint_weights, potalign, vbm, cbm):\n        bf_corr = 0.\n\n        self.metadata[\"potalign\"] = potalign\n        self.metadata[\"num_hole_vbm\"] = 0.\n        self.metadata[\"num_elec_cbm\"] = 0.\n\n        if len(eigenvalues.keys()) == 1:  # needed because occupation of non-spin calcs is still 1... should be 2\n            spinfctr = 2.\n        elif len(eigenvalues.keys()) == 2:\n            spinfctr = 1.\n        else:\n            raise ValueError(\"Eigenvalue keys greater than 2\")\n\n        # for tracking mid gap states...\n        resolution = self.resolution\n        shifted_cbm = potalign + cbm  # shift cbm with potential alignment\n        shifted_vbm = potalign + vbm  # shift vbm with potential alignment\n\n        occupied_midgap = {en: [] for en in np.arange(shifted_vbm, shifted_cbm + resolution, resolution)}\n        occupation = {en: 0. for en in np.arange(shifted_vbm, shifted_cbm + resolution, resolution)}\n        unoccupied_midgap = {en: [] for en in np.arange(shifted_vbm, shifted_cbm + resolution, resolution)}\n\n        for spinset in eigenvalues.values():\n            for kptset, weight in zip(spinset, kpoint_weights):\n                for eig in kptset:  # eig[0] is eigenvalue and eig[1] is occupation\n                    if (eig[1] and (eig[0] > shifted_cbm)):  # donor MB correction\n                        bf_corr += weight * spinfctr * eig[1] * (eig[0] - shifted_cbm)  # \"move the electrons down\"\n                        self.metadata[\"num_elec_cbm\"] += weight * spinfctr * eig[1]\n                    elif (eig[1] != 1.) and (eig[0] <= shifted_vbm):  # acceptor MB correction\n                        bf_corr += weight * spinfctr * (1. - eig[1]) * (shifted_vbm - eig[0])  # \"move the holes up\"\n                        self.metadata[\"num_hole_vbm\"] += weight * spinfctr * (1. - eig[1])\n                    elif (eig[0] > shifted_vbm) and (eig[0] < shifted_cbm):\n                        for en in np.arange(shifted_vbm, shifted_cbm + resolution, resolution):\n                            if (eig[0] < en + resolution) and (eig[0] > en):\n                                if eig[1]:\n                                    occupied_midgap[en].append(eig[0])\n                                    occupation[en] += eig[1] * weight * spinfctr\n                                else:\n                                    unoccupied_midgap[en].append(eig[0])\n                                continue\n\n        bf_corr *= -1  # need to take negative of this shift for energetic correction\n\n        # summarize defect level results\n        self.metadata[\"total_occupation_defect_levels\"] = 0.\n        self.metadata[\"occupied_def_levels\"] = []\n        self.metadata[\"unoccupied_def_levels\"] = []\n        for en in occupied_midgap.keys():\n            if len(occupied_midgap[en]):\n                self.metadata[\"occupied_def_levels\"].append([np.mean(occupied_midgap[en]), occupation[en]])\n                self.metadata[\"total_occupation_defect_levels\"] += occupation[en]\n            elif len(unoccupied_midgap[en]):\n                self.metadata[\"unoccupied_def_levels\"].append(np.mean(unoccupied_midgap[en]))\n\n        return bf_corr", "response": "This function calculates the band filling correction based on the given eigenvalues and kpoint weights."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the BandEdge correction for a defect entry.", "response": "def get_correction(self, entry):\n        \"\"\"\n        Gets the BandEdge correction for a defect entry\n        \"\"\"\n        # TODO: add smarter defect level shifting based on defect level projection onto host bands\n        hybrid_cbm = entry.parameters[\"hybrid_cbm\"]\n        hybrid_vbm = entry.parameters[\"hybrid_vbm\"]\n        vbm = entry.parameters[\"vbm\"]\n        cbm = entry.parameters[\"cbm\"]\n        num_hole_vbm = entry.parameters[\"num_hole_vbm\"]\n        num_elec_cbm = entry.parameters[\"num_elec_cbm\"]\n\n        self.metadata[\"vbmshift\"] = hybrid_vbm - vbm  # note vbmshift has UPWARD as positive convention\n        self.metadata[\"cbmshift\"] = hybrid_cbm - cbm  # note cbmshift has UPWARD as positive convention\n\n        charge = entry.charge\n        vbm_shift_correction = charge * self.metadata[\"vbmshift\"]\n        # negative sign has to do with fact that these are holes\n        hole_vbm_shift_correction = -1. * num_hole_vbm * self.metadata[\"vbmshift\"]\n        elec_cbm_shift_correction = num_elec_cbm * self.metadata[\"cbmshift\"]\n\n        entry.parameters[\"bandshift_meta\"] = dict(self.metadata)\n\n        return {\n            \"vbm_shift_correction\": vbm_shift_correction,\n            \"hole_vbm_shift_correction\": hole_vbm_shift_correction,\n            \"elec_cbm_shift_correction\": elec_cbm_shift_correction\n        }"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef from_string(cls, s):\n        for num, text in cls._STATUS_TABLE.items():\n            if text == s: return cls(num)\n        else:\n            #raise ValueError(\"Wrong string %s\" % s)\n            logger.warning(\"Got unknown status: %s\" % s)\n            return cls.from_string(\"UNKNOWN\")", "response": "Return a : class : JobStatus instance from its string representation."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a new istance of the appropriate subclass of QueueJob.", "response": "def from_qtype_and_id(qtype, queue_id, qname=None):\n        \"\"\"\n        Return a new istance of the appropriate subclass.\n\n        Args:\n            qtype: String specifying the Resource manager type.\n            queue_id: Job identifier.\n            qname: Name of the queue (optional).\n        \"\"\"\n        for cls in all_subclasses(QueueJob):\n            if cls.QTYPE == qtype: break\n        else:\n            logger.critical(\"Cannot find QueueJob subclass registered for qtype %s\" % qtype)\n            cls = QueueJob\n\n        return cls(queue_id, qname=qname)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_stable_entries(self, charge_to_discharge=True):\n        list_copy = list(self._stable_entries)\n        return list_copy if charge_to_discharge else list_copy.reverse()", "response": "Get the stable entries in the electrode."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the unstable entries for the electrode.", "response": "def get_unstable_entries(self, charge_to_discharge=True):\n        \"\"\"\n        Returns the unstable entries for the electrode.\n\n        Args:\n            charge_to_discharge: Order from most charge to most discharged\n                state? Defaults to True.\n\n        Returns:\n            A list of unstable entries in the electrode, ordered by amount of\n            the working ion.\n        \"\"\"\n        list_copy = list(self._unstable_entries)\n        return list_copy if charge_to_discharge else list_copy.reverse()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_all_entries(self, charge_to_discharge=True):\n        all_entries = list(self.get_stable_entries())\n        all_entries.extend(self.get_unstable_entries())\n        # sort all entries by amount of working ion ASC\n        fsrt = lambda e: e.composition.get_atomic_fraction(self.working_ion)\n        all_entries = sorted([e for e in all_entries],\n                             key=fsrt)\n        return all_entries if charge_to_discharge else all_entries.reverse()", "response": "Returns a list of all entries in the electrode ordered by amount of working ion."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_max_instability(self, min_voltage=None, max_voltage=None):\n        data = []\n        for pair in self._select_in_voltage_range(min_voltage, max_voltage):\n            if pair.decomp_e_charge is not None:\n                data.append(pair.decomp_e_charge)\n            if pair.decomp_e_discharge is not None:\n                data.append(pair.decomp_e_discharge)\n        return max(data) if len(data) > 0 else None", "response": "Returns the maximum instability of all compounds along a path for a specific voltage range."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_min_instability(self, min_voltage=None, max_voltage=None):\n        data = []\n        for pair in self._select_in_voltage_range(min_voltage, max_voltage):\n            if pair.decomp_e_charge is not None:\n                data.append(pair.decomp_e_charge)\n            if pair.decomp_e_discharge is not None:\n                data.append(pair.decomp_e_discharge)\n        return min(data) if len(data) > 0 else None", "response": "Returns the minimum instability along a path for a specific voltage range."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_max_muO2(self, min_voltage=None, max_voltage=None):\n        data = []\n        for pair in self._select_in_voltage_range(min_voltage, max_voltage):\n            if pair.muO2_discharge is not None:\n                data.extend([d['chempot'] for d in pair.muO2_discharge])\n            if pair.muO2_charge is not None:\n                data.extend([d['chempot'] for d in pair.muO2_discharge])\n        return max(data) if len(data) > 0 else None", "response": "Returns the maximum critical oxygen chemical potential along path."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_min_muO2(self, min_voltage=None, max_voltage=None):\n        data = []\n        for pair in self._select_in_voltage_range(min_voltage, max_voltage):\n            if pair.muO2_discharge is not None:\n                data.extend([d['chempot'] for d in pair.muO2_discharge])\n            if pair.muO2_charge is not None:\n                data.extend([d['chempot'] for d in pair.muO2_discharge])\n        return min(data) if len(data) > 0 else None", "response": "Returns the minimum critical oxygen chemical potential along path."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_sub_electrodes(self, adjacent_only=True, include_myself=True):\n        battery_list = []\n        pair_it = self._vpairs if adjacent_only \\\n            else itertools.combinations_with_replacement(self._vpairs, 2)\n\n        ion = self._working_ion\n\n        for pair in pair_it:\n            entry_charge = pair.entry_charge if adjacent_only \\\n                else pair[0].entry_charge\n            entry_discharge = pair.entry_discharge if adjacent_only \\\n                else pair[1].entry_discharge\n\n            chg_frac = entry_charge.composition.get_atomic_fraction(ion)\n            dischg_frac = entry_discharge.composition.get_atomic_fraction(ion)\n\n            def in_range(entry):\n                frac = entry.composition.get_atomic_fraction(ion)\n                return chg_frac <= frac <= dischg_frac\n\n            if include_myself or entry_charge != self.fully_charged_entry \\\n                    or entry_discharge != self.fully_discharged_entry:\n                unstable_entries = filter(in_range,\n                                          self.get_unstable_entries())\n                stable_entries = filter(in_range, self.get_stable_entries())\n                all_entries = list(stable_entries)\n                all_entries.extend(unstable_entries)\n                battery_list.append(self.__class__(all_entries,\n                                                   self.working_ion_entry))\n        return battery_list", "response": "Returns a list of InsertionElectrode objects for all subelectrodes in the current region."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngenerating a dict representation of the current object.", "response": "def as_dict_summary(self, print_subelectrodes=True):\n        \"\"\"\n        Generate a summary dict.\n\n        Args:\n            print_subelectrodes: Also print data on all the possible\n                subelectrodes.\n\n        Returns:\n            A summary of this electrode\"s properties in dict format.\n        \"\"\"\n        chg_comp = self.fully_charged_entry.composition\n        dischg_comp = self.fully_discharged_entry.composition\n\n        ion = self.working_ion\n        d = {\"average_voltage\": self.get_average_voltage(),\n             \"max_voltage\": self.max_voltage,\n             \"min_voltage\": self.min_voltage,\n             \"max_delta_volume\": self.max_delta_volume,\n             \"max_voltage_step\": self.max_voltage_step,\n             \"capacity_grav\": self.get_capacity_grav(),\n             \"capacity_vol\": self.get_capacity_vol(),\n             \"energy_grav\": self.get_specific_energy(),\n             \"energy_vol\": self.get_energy_density(),\n             \"working_ion\": self._working_ion.symbol,\n             \"nsteps\": self.num_steps,\n             \"framework\": self._vpairs[0].framework.to_data_dict,\n             \"formula_charge\": chg_comp.reduced_formula,\n             \"id_charge\": self.fully_charged_entry.entry_id,\n             \"formula_discharge\": dischg_comp.reduced_formula,\n             \"id_discharge\": self.fully_discharged_entry.entry_id,\n             \"fracA_charge\": chg_comp.get_atomic_fraction(ion),\n             \"fracA_discharge\": dischg_comp.get_atomic_fraction(ion),\n             \"max_instability\": self.get_max_instability(),\n             \"min_instability\": self.get_min_instability(),\n             \"material_ids\" : [itr_ent.entry_id for itr_ent in self._entries],\n             \"stable_material_ids\" : [itr_ent.entry_id for itr_ent in self.get_stable_entries()],\n             \"unstable_material_ids\": [itr_ent.entry_id for itr_ent in self.get_unstable_entries()],\n             }\n\n        if all(['decomposition_energy' in itr_ent.data for itr_ent in self._entries]):\n            d.update({\"stability_charge\": self.fully_charged_entry.data['decomposition_energy'],\n                 \"stability_discharge\": self.fully_discharged_entry.data['decomposition_energy'],\n                 \"stability_data\":{itr_ent.entry_id: itr_ent.data['decomposition_energy'] for itr_ent in self._entries},\n                 })\n\n        if all(['muO2' in itr_ent.data for itr_ent in self._entries]):\n            d.update({\"muO2_data\" : {itr_ent.entry_id: itr_ent.data['muO2'] for itr_ent in self._entries}})\n\n        if print_subelectrodes:\n            f_dict = lambda c: c.as_dict_summary(print_subelectrodes=False)\n            d[\"adj_pairs\"] = list(map(f_dict,\n                                 self.get_sub_electrodes(adjacent_only=True)))\n            d[\"all_pairs\"] = list(map(f_dict,\n                                 self.get_sub_electrodes(adjacent_only=False)))\n        return d"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef zval_dict_from_potcar(potcar):\n    zval_dict = {}\n    for p in potcar:\n        zval_dict.update({p.element: p.ZVAL})\n    return zval_dict", "response": "Creates zval_dict for calculating the ionic polarization from the ionic polarization from the object\n   "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef calc_ionic(site, structure, zval):\n    norms = structure.lattice.lengths_and_angles[0]\n    return np.multiply(norms, -site.frac_coords * zval)", "response": "Calculates the ionic dipole moment using ZVAL from pseudopotential structure Returns polarization in electron Angstroms."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the total ionic dipole moment for a structure.", "response": "def get_total_ionic_dipole(structure, zval_dict):\n    \"\"\"\n    Get the total ionic dipole moment for a structure.\n\n    structure: pymatgen Structure\n    zval_dict: specie, zval dictionary pairs\n    center (np.array with shape [3,1]) : dipole center used by VASP\n    tiny (float) : tolerance for determining boundary of calculation.\n    \"\"\"\n\n    tot_ionic = []\n    for site in structure:\n        zval = zval_dict[str(site.specie)]\n        tot_ionic.append(calc_ionic(site, structure, zval))\n    return np.sum(tot_ionic, axis=0)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ngive coords and a site find closest site to coords.", "response": "def get_nearest_site(self, coords, site, r=None):\n        \"\"\"\n        Given coords and a site, find closet site to coords.\n        Args:\n            coords (3x1 array): cartesian coords of center of sphere\n            site: site to find closest to coords\n            r: radius of sphere. Defaults to diagonal of unit cell\n\n        Returns:\n            Closest site and distance.\n        \"\"\"\n        index = self.index(site)\n        if r is None:\n            r = np.linalg.norm(np.sum(self.lattice.matrix, axis=0))\n        ns = self.get_sites_in_sphere(coords, r, include_index=True)\n        # Get sites with identical index to site\n        ns = [n for n in ns if n[2] == index]\n        # Sort by distance to coords\n        ns.sort(key=lambda x: x[1])\n        # Return PeriodicSite and distance of closest image\n        return ns[0][0:2]"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef from_outcars_and_structures(cls, outcars, structures,\n                                    calc_ionic_from_zval=False):\n        \"\"\"\n        Create Polarization object from list of Outcars and Structures in order\n        of nonpolar to polar.\n\n        Note, we recommend calculating the ionic dipole moment using calc_ionic\n        than using the values in Outcar (see module comments). To do this set\n        calc_ionic_from_zval = True\n        \"\"\"\n        p_elecs = []\n        p_ions = []\n\n        for i, o in enumerate(outcars):\n            p_elecs.append(o.p_elec)\n            if calc_ionic_from_zval:\n                p_ions.append(\n                    get_total_ionic_dipole(structures[i], o.zval_dict))\n            else:\n                p_ions.append(o.p_ion)\n        return cls(p_elecs, p_ions, structures)", "response": "Create Polarization object from list of Outcars and Structures."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the electronic and ionic dipole moments and polarizations.", "response": "def get_pelecs_and_pions(self, convert_to_muC_per_cm2=False):\n        \"\"\"\n        Get the electronic and ionic dipole moments / polarizations.\n\n        convert_to_muC_per_cm2: Convert from electron * Angstroms to microCoulomb\n            per centimeter**2\n        \"\"\"\n\n        if not convert_to_muC_per_cm2:\n            return self.p_elecs, self.p_ions\n\n        if convert_to_muC_per_cm2:\n            p_elecs = self.p_elecs.T\n            p_ions = self.p_ions.T\n\n            volumes = [s.lattice.volume for s in self.structures]\n            e_to_muC = -1.6021766e-13\n            cm2_to_A2 = 1e16\n            units = 1.0 / np.array(volumes)\n            units *= e_to_muC * cm2_to_A2\n\n            p_elecs = np.matmul(units, p_elecs)\n            p_ions = np.matmul(units, p_ions)\n\n            p_elecs, p_ions = p_elecs.T, p_ions.T\n\n            return p_elecs, p_ions"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_same_branch_polarization_data(self, convert_to_muC_per_cm2=True, all_in_polar=True):\n\n        p_elec, p_ion = self.get_pelecs_and_pions()\n        p_tot = p_elec + p_ion\n        p_tot = np.array(p_tot)\n\n        lattices = [s.lattice for s in self.structures]\n        volumes = np.array([s.lattice.volume for s in self.structures])\n\n        L = len(p_elec)\n\n        e_to_muC = -1.6021766e-13\n        cm2_to_A2 = 1e16\n        units = 1.0 / np.array(volumes)\n        units *= e_to_muC * cm2_to_A2\n\n        # convert polarizations and lattice lengths prior to adjustment\n        if convert_to_muC_per_cm2 and not all_in_polar:\n            # Convert the total polarization\n            p_tot = np.multiply(units.T[:, np.newaxis], p_tot)\n            # adjust lattices\n            for i in range(L):\n                lattice = lattices[i]\n                l, a = lattice.lengths_and_angles\n                lattices[i] = Lattice.from_lengths_and_angles(\n                    np.array(l) * units.ravel()[i], a)\n        #  convert polarizations to polar lattice\n        elif convert_to_muC_per_cm2 and all_in_polar:\n            abc = [lattice.abc for lattice in lattices]\n            abc = np.array(abc)  # [N, 3]\n            p_tot /= abc  # e * Angstroms to e\n            p_tot *= abc[-1] / volumes[-1] * e_to_muC * cm2_to_A2  # to muC / cm^2\n            for i in range(L):\n                lattice = lattices[-1]  # Use polar lattice\n                l, a = lattice.lengths_and_angles\n                lattices[i] = Lattice.from_lengths_and_angles(\n                    np.array(l) * units.ravel()[-1], a)  # Use polar units (volume)\n\n\n        d_structs = []\n        sites = []\n        for i in range(L):\n            l = lattices[i]\n            frac_coord = np.divide(np.array([p_tot[i]]),\n                                   np.array([l.a, l.b, l.c]))\n            d = PolarizationLattice(l, [\"C\"], [np.array(frac_coord).ravel()])\n            d_structs.append(d)\n            site = d[0]\n            if i == 0:\n                # Adjust nonpolar polarization to be closest to zero.\n                # This is compatible with both a polarization of zero or a half quantum.\n                prev_site = [0, 0, 0]\n            else:\n                prev_site = sites[-1].coords\n            new_site = d.get_nearest_site(prev_site, site)\n            sites.append(new_site[0])\n\n        adjust_pol = []\n        for s, d in zip(sites, d_structs):\n            l = d.lattice\n            adjust_pol.append(\n                np.multiply(s.frac_coords, np.array([l.a, l.b, l.c])).ravel())\n        adjust_pol = np.array(adjust_pol)\n\n        return adjust_pol", "response": "This method returns the same branch dipole moment or polarization for given polarization data."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the dipole / polarization quanta along a b and c for all structures.", "response": "def get_lattice_quanta(self, convert_to_muC_per_cm2=True, all_in_polar=True):\n        \"\"\"\n        Returns the dipole / polarization quanta along a, b, and c for\n        all structures.\n        \"\"\"\n        lattices = [s.lattice for s in self.structures]\n        volumes = np.array([s.lattice.volume for s in self.structures])\n\n        L = len(self.structures)\n\n        e_to_muC = -1.6021766e-13\n        cm2_to_A2 = 1e16\n        units = 1.0 / np.array(volumes)\n        units *= e_to_muC * cm2_to_A2\n\n        # convert polarizations and lattice lengths prior to adjustment\n        if convert_to_muC_per_cm2 and not all_in_polar:\n            # adjust lattices\n            for i in range(L):\n                lattice = lattices[i]\n                l, a = lattice.lengths_and_angles\n                lattices[i] = Lattice.from_lengths_and_angles(\n                    np.array(l) * units.ravel()[i], a)\n        elif convert_to_muC_per_cm2 and all_in_polar:\n            for i in range(L):\n                lattice = lattices[-1]\n                l, a = lattice.lengths_and_angles\n                lattices[i] = Lattice.from_lengths_and_angles(\n                    np.array(l) * units.ravel()[-1], a)\n\n        quanta = np.array(\n            [np.array(l.lengths_and_angles[0]) for l in lattices])\n\n        return quanta"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting difference between nonpolar and polar same branch polarization.", "response": "def get_polarization_change(self, convert_to_muC_per_cm2=True, all_in_polar=True):\n        \"\"\"\n        Get difference between nonpolar and polar same branch polarization.\n        \"\"\"\n        tot = self.get_same_branch_polarization_data(\n            convert_to_muC_per_cm2=convert_to_muC_per_cm2, all_in_polar=all_in_polar)\n        # reshape to preserve backwards compatibility due to changes\n        # when switching from np.matrix to np.array\n        return (tot[-1] - tot[0]).reshape((1,  3))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting magnitude of difference between nonpolar and polar same branch.", "response": "def get_polarization_change_norm(self, convert_to_muC_per_cm2=True, all_in_polar=True):\n        \"\"\"\n        Get magnitude of difference between nonpolar and polar same branch\n        polarization.\n        \"\"\"\n        polar = self.structures[-1]\n        a, b, c = polar.lattice.matrix\n        a, b, c = a / np.linalg.norm(a), b / np.linalg.norm(\n            b), c / np.linalg.norm(c)\n        P = self.get_polarization_change(convert_to_muC_per_cm2=convert_to_muC_per_cm2,\n                                         all_in_polar=all_in_polar).ravel()\n        P_norm = np.linalg.norm(a * P[0] + b * P[1] + c * P[2])\n        return P_norm"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nfit splines to same branch polarization.", "response": "def same_branch_splines(self, convert_to_muC_per_cm2=True, all_in_polar=True):\n        \"\"\"\n        Fit splines to same branch polarization. This is used to assess any jumps\n        in the same branch polarizaiton.\n        \"\"\"\n        from scipy.interpolate import UnivariateSpline\n        tot = self.get_same_branch_polarization_data(\n            convert_to_muC_per_cm2=convert_to_muC_per_cm2, all_in_polar=all_in_polar)\n        L = tot.shape[0]\n        try:\n            sp_a = UnivariateSpline(range(L), tot[:, 0].ravel())\n        except:\n            sp_a = None\n        try:\n            sp_b = UnivariateSpline(range(L), tot[:, 1].ravel())\n        except:\n            sp_b = None\n        try:\n            sp_c = UnivariateSpline(range(L), tot[:, 2].ravel())\n        except:\n            sp_c = None\n        return sp_a, sp_b, sp_c"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef max_spline_jumps(self, convert_to_muC_per_cm2=True, all_in_polar=True):\n        tot = self.get_same_branch_polarization_data(\n            convert_to_muC_per_cm2=convert_to_muC_per_cm2, all_in_polar=all_in_polar)\n        sps = self.same_branch_splines(convert_to_muC_per_cm2=convert_to_muC_per_cm2,\n                                       all_in_polar=all_in_polar)\n        max_jumps = [None, None, None]\n        for i, sp in enumerate(sps):\n            if sp != None:\n                max_jumps[i] = max(tot[:, i].ravel() - sp(range(len(tot[:, i].ravel()))))\n        return max_jumps", "response": "Get maximum difference between spline and same branch polarization data."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the average difference between spline and same branch polarization data.", "response": "def smoothness(self, convert_to_muC_per_cm2=True, all_in_polar=True):\n        \"\"\"\n        Get rms average difference between spline and same branch polarization data.\n        \"\"\"\n        tot = self.get_same_branch_polarization_data(\n            convert_to_muC_per_cm2=convert_to_muC_per_cm2, all_in_polar=all_in_polar)\n        L = tot.shape[0]\n        try:\n            sp = self.same_branch_splines(convert_to_muC_per_cm2=convert_to_muC_per_cm2,\n                                          all_in_polar=all_in_polar)\n        except:\n            print(\"Something went wrong.\")\n            return None\n        sp_latt = [sp[i](range(L)) for i in range(3)]\n        diff = [sp_latt[i] - tot[:, i].ravel() for i in range(3)]\n        rms = [np.sqrt(np.sum(np.square(diff[i])) / L) for i in range(3)]\n        return rms"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef spline(self):\n        from scipy.interpolate import UnivariateSpline\n        sp = UnivariateSpline(range(len(self.energies)), self.energies, k=4)\n        return sp", "response": "Fit spline to energy trend data."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef smoothness(self):\n        energies = self.energies\n        try:\n            sp = self.spline()\n        except:\n            print(\"Energy spline failed.\")\n            return None\n        spline_energies = sp(range(len(energies)))\n        diff = spline_energies - energies\n        rms = np.sqrt(np.sum(np.square(diff)) / len(energies))\n        return rms", "response": "Get the average difference between spline and energy trend."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef max_spline_jump(self):\n        sp = self.spline()\n        return max(self.energies - sp(range(len(self.energies))))", "response": "Get maximum difference between spline and energy trend."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef endpoints_minima(self, slope_cutoff=5e-3):\n        energies = self.energies\n        try:\n            sp = self.spline()\n        except:\n            print(\"Energy spline failed.\")\n            return None\n        der = sp.derivative()\n        der_energies = der(range(len(energies)))\n        return {\"polar\": abs(der_energies[-1]) <= slope_cutoff,\n                \"nonpolar\": abs(der_energies[0]) <= slope_cutoff}", "response": "Test if spline endpoints are at minima for a given slope cutoff."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nprocesses a single entry with the chosen Corrections.", "response": "def process_entry(self, entry):\n        \"\"\"\n        Process a single entry with the chosen Corrections.\n\n        Args:\n            entry: A ComputedEntry object.\n\n        Returns:\n            An adjusted entry if entry is compatible, otherwise None is\n            returned.\n        \"\"\"\n        try:\n            corrections = self.get_corrections_dict(entry)\n        except CompatibilityError:\n            return None\n        entry.correction = sum(corrections.values())\n        return entry"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_corrections_dict(self, entry):\n        corrections = {}\n        for c in self.corrections:\n            val = c.get_correction(entry)\n            if val != 0:\n                corrections[str(c)] = val\n        return corrections", "response": "Returns the corrections applied to a particular entry."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_explanation_dict(self, entry):\n        centry = self.process_entry(entry)\n        if centry is None:\n            uncorrected_energy = entry.uncorrected_energy\n            corrected_energy = None\n        else:\n            uncorrected_energy = centry.uncorrected_energy\n            corrected_energy = centry.energy\n        d = {\"compatibility\": self.__class__.__name__,\n             \"uncorrected_energy\": uncorrected_energy,\n             \"corrected_energy\": corrected_energy}\n        corrections = []\n        corr_dict = self.get_corrections_dict(entry)\n        for c in self.corrections:\n            cd = {\"name\": str(c),\n                  \"description\": c.__doc__.split(\"Args\")[0].strip(),\n                  \"value\": corr_dict.get(str(c), 0)}\n            corrections.append(cd)\n        d[\"corrections\"] = corrections\n        return d", "response": "Returns an explanation dict of the corrections that are being applied to a given compute entry."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef explain(self, entry):\n        d = self.get_explanation_dict(entry)\n        print(\"The uncorrected value of the energy of %s is %f eV\" %\n              (entry.composition, d[\"uncorrected_energy\"]))\n        print(\"The following corrections / screening are applied for %s:\\n\" %\n              d[\"compatibility\"])\n        for c in d[\"corrections\"]:\n            print(\"%s correction: %s\\n\" % (c[\"name\"],\n                                           c[\"description\"]))\n            print(\"For the entry, this correction has the value %f eV.\" % c[\n                \"value\"])\n            print(\"-\" * 30)\n\n        print(\"The final energy after corrections is %f\" % d[\n            \"corrected_energy\"])", "response": "Prints an explanation of the corrections that are being applied for a specific entry."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreading a string representation of a CSSR object.", "response": "def from_string(string):\n        \"\"\"\n        Reads a string representation to a Cssr object.\n\n        Args:\n            string (str): A string representation of a CSSR.\n\n        Returns:\n            Cssr object.\n        \"\"\"\n        lines = string.split(\"\\n\")\n        toks = lines[0].split()\n        lengths = [float(i) for i in toks]\n        toks = lines[1].split()\n        angles = [float(i) for i in toks[0:3]]\n        latt = Lattice.from_lengths_and_angles(lengths, angles)\n        sp = []\n        coords = []\n        for l in lines[4:]:\n            m = re.match(\n                r\"\\d+\\s+(\\w+)\\s+([0-9\\-\\.]+)\\s+([0-9\\-\\.]+)\\s+([0-9\\-\\.]+)\",\n                l.strip())\n            if m:\n                sp.append(m.group(1))\n                coords.append([float(m.group(i)) for i in range(2, 5)])\n        return Cssr(Structure(latt, sp, coords))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef freq_units(units):\n\n    d = {\"thz\": FreqUnits(1, \"THz\"),\n         \"ev\": FreqUnits(const.value(\"hertz-electron volt relationship\") * const.tera, \"eV\"),\n         \"mev\": FreqUnits(const.value(\"hertz-electron volt relationship\") * const.tera / const.milli, \"meV\"),\n         \"ha\": FreqUnits(const.value(\"hertz-hartree relationship\") * const.tera, \"Ha\"),\n         \"cm-1\": FreqUnits(const.value(\"hertz-inverse meter relationship\") * const.tera * const.centi, \"cm^{-1}\"),\n         'cm^-1': FreqUnits(const.value(\"hertz-inverse meter relationship\") * const.tera * const.centi, \"cm^{-1}\")\n         }\n    try:\n        return d[units.lower().strip()]\n    except KeyError:\n        raise KeyError('Value for units `{}` unknown\\nPossible values are:\\n {}'.format(units, list(d.keys())))", "response": "Returns conversion factor from THz to the requred units and label in the form of a namedtuple\n   "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding a dos for plotting.", "response": "def add_dos(self, label, dos):\n        \"\"\"\n        Adds a dos for plotting.\n\n        Args:\n            label:\n                label for the DOS. Must be unique.\n            dos:\n                PhononDos object\n        \"\"\"\n\n        densities = dos.get_smeared_densities(self.sigma) if self.sigma \\\n            else dos.densities\n        self._doses[label] = {'frequencies': dos.frequencies, 'densities': densities}"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef add_dos_dict(self, dos_dict, key_sort_func=None):\n        if key_sort_func:\n            keys = sorted(dos_dict.keys(), key=key_sort_func)\n        else:\n            keys = dos_dict.keys()\n        for label in keys:\n            self.add_dos(label, dos_dict[label])", "response": "Adds a dictionary of Dos to the set of Doses."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_plot(self, xlim=None, ylim=None, units=\"thz\"):\n\n        u = freq_units(units)\n\n        ncolors = max(3, len(self._doses))\n        ncolors = min(9, ncolors)\n\n        import palettable\n\n        colors = palettable.colorbrewer.qualitative.Set1_9.mpl_colors\n\n        y = None\n        alldensities = []\n        allfrequencies = []\n        plt = pretty_plot(12, 8)\n\n        # Note that this complicated processing of frequencies is to allow for\n        # stacked plots in matplotlib.\n        for key, dos in self._doses.items():\n            frequencies = dos['frequencies'] * u.factor\n            densities = dos['densities']\n            if y is None:\n                y = np.zeros(frequencies.shape)\n            if self.stack:\n                y += densities\n                newdens = y.copy()\n            else:\n                newdens = densities\n            allfrequencies.append(frequencies)\n            alldensities.append(newdens)\n\n        keys = list(self._doses.keys())\n        keys.reverse()\n        alldensities.reverse()\n        allfrequencies.reverse()\n        allpts = []\n        for i, (key, frequencies, densities) in enumerate(zip(keys, allfrequencies, alldensities)):\n            allpts.extend(list(zip(frequencies, densities)))\n            if self.stack:\n                plt.fill(frequencies, densities, color=colors[i % ncolors],\n                         label=str(key))\n            else:\n                plt.plot(frequencies, densities, color=colors[i % ncolors],\n                         label=str(key), linewidth=3)\n\n        if xlim:\n            plt.xlim(xlim)\n        if ylim:\n            plt.ylim(ylim)\n        else:\n            xlim = plt.xlim()\n            relevanty = [p[1] for p in allpts\n                         if xlim[0] < p[0] < xlim[1]]\n            plt.ylim((min(relevanty), max(relevanty)))\n\n        ylim = plt.ylim()\n        plt.plot([0, 0], ylim, 'k--', linewidth=2)\n\n        plt.xlabel(r'$\\mathrm{{Frequencies\\ ({})}}$'.format(u.label))\n        plt.ylabel(r'$\\mathrm{Density\\ of\\ states}$')\n\n        plt.legend()\n        leg = plt.gca().get_legend()\n        ltext = leg.get_texts()  # all the text.Text instance in the legend\n        plt.setp(ltext, fontsize=30)\n        plt.tight_layout()\n        return plt", "response": "Returns a matplotlib plot showing the DOS."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef show(self, xlim=None, ylim=None, units=\"thz\"):\n        plt = self.get_plot(xlim, ylim, units=units)\n        plt.show()", "response": "Show the plot using matplotlib."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the data nicely formatted for a plot", "response": "def bs_plot_data(self):\n\n        \"\"\"\n        Get the data nicely formatted for a plot\n\n        Returns:\n            A dict of the following format:\n            ticks: A dict with the 'distances' at which there is a qpoint (the\n            x axis) and the labels (None if no label)\n            frequencies: A list (one element for each branch) of frequencies for\n            each qpoint: [branch][qpoint][mode]. The data is\n            stored by branch to facilitate the plotting\n            lattice: The reciprocal lattice.\n        \"\"\"\n        distance = []\n        frequency = []\n\n        ticks = self.get_ticks()\n\n        for b in self._bs.branches:\n\n            frequency.append([])\n            distance.append([self._bs.distance[j]\n                             for j in range(b['start_index'],\n                                            b['end_index'] + 1)])\n\n            for i in range(self._nb_bands):\n                frequency[-1].append(\n                    [self._bs.bands[i][j]\n                     for j in range(b['start_index'], b['end_index'] + 1)])\n\n        return {'ticks': ticks, 'distances': distance, 'frequency': frequency,\n                'lattice': self._bs.lattice_rec.as_dict()}"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_plot(self, ylim=None, units=\"thz\"):\n\n        u = freq_units(units)\n\n        plt = pretty_plot(12, 8)\n\n        band_linewidth = 1\n\n        data = self.bs_plot_data()\n        for d in range(len(data['distances'])):\n            for i in range(self._nb_bands):\n                plt.plot(data['distances'][d],\n                         [data['frequency'][d][i][j] * u.factor\n                          for j in range(len(data['distances'][d]))], 'b-',\n                         linewidth=band_linewidth)\n\n        self._maketicks(plt)\n\n        # plot y=0 line\n        plt.axhline(0, linewidth=1, color='k')\n\n        # Main X and Y Labels\n        plt.xlabel(r'$\\mathrm{Wave\\ Vector}$', fontsize=30)\n        ylabel = r'$\\mathrm{{Frequencies\\ ({})}}$'.format(u.label)\n        plt.ylabel(ylabel, fontsize=30)\n\n        # X range (K)\n        # last distance point\n        x_max = data['distances'][-1][-1]\n        plt.xlim(0, x_max)\n\n        if ylim is not None:\n            plt.ylim(ylim)\n\n        plt.tight_layout()\n\n        return plt", "response": "Returns a matplotlib object for the bandstructure plot."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef save_plot(self, filename, img_format=\"eps\", ylim=None, units=\"thz\"):\n        plt = self.get_plot(ylim=ylim, units=units)\n        plt.savefig(filename, format=img_format)\n        plt.close()", "response": "Save matplotlib plot to a file."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting all ticks and labels for a band structure plot.", "response": "def get_ticks(self):\n        \"\"\"\n        Get all ticks and labels for a band structure plot.\n\n        Returns:\n            A dict with 'distance': a list of distance at which ticks should\n            be set and 'label': a list of label for each of those ticks.\n        \"\"\"\n        tick_distance = []\n        tick_labels = []\n        previous_label = self._bs.qpoints[0].label\n        previous_branch = self._bs.branches[0]['name']\n        for i, c in enumerate(self._bs.qpoints):\n            if c.label is not None:\n                tick_distance.append(self._bs.distance[i])\n                this_branch = None\n                for b in self._bs.branches:\n                    if b['start_index'] <= i <= b['end_index']:\n                        this_branch = b['name']\n                        break\n                if c.label != previous_label \\\n                        and previous_branch != this_branch:\n                    label1 = c.label\n                    if label1.startswith(\"\\\\\") or label1.find(\"_\") != -1:\n                        label1 = \"$\" + label1 + \"$\"\n                    label0 = previous_label\n                    if label0.startswith(\"\\\\\") or label0.find(\"_\") != -1:\n                        label0 = \"$\" + label0 + \"$\"\n                    tick_labels.pop()\n                    tick_distance.pop()\n                    tick_labels.append(label0 + \"$\\\\mid$\" + label1)\n                else:\n                    if c.label.startswith(\"\\\\\") or c.label.find(\"_\") != -1:\n                        tick_labels.append(\"$\" + c.label + \"$\")\n                    else:\n                        tick_labels.append(c.label)\n                previous_label = c.label\n                previous_branch = this_branch\n        return {'distance': tick_distance, 'label': tick_labels}"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nplots two band structure for comparison. One is in red the other in blue. The two band structures need to be defined on the same symmetry lines! and the distance between symmetry lines is the one of the band structure used to build the PhononBSPlotter Args: another PhononBSPlotter object defined along the same symmetry lines Returns: a matplotlib object with both band structures", "response": "def plot_compare(self, other_plotter):\n        \"\"\"\n        plot two band structure for comparison. One is in red the other in blue.\n        The two band structures need to be defined on the same symmetry lines!\n        and the distance between symmetry lines is\n        the one of the band structure used to build the PhononBSPlotter\n\n        Args:\n            another PhononBSPlotter object defined along the same symmetry lines\n\n        Returns:\n            a matplotlib object with both band structures\n\n        \"\"\"\n\n        data_orig = self.bs_plot_data()\n        data = other_plotter.bs_plot_data()\n\n        if len(data_orig['distances']) != len(data['distances']):\n            raise ValueError('The two objects are not compatible.')\n\n        plt = self.get_plot()\n        band_linewidth = 1\n        for i in range(other_plotter._nb_bands):\n            for d in range(len(data_orig['distances'])):\n                plt.plot(data_orig['distances'][d],\n                         [e[i] for e in data['frequency']][d],\n                         'r-', linewidth=band_linewidth)\n\n        return plt"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef plot_brillouin(self):\n\n        # get labels and lines\n        labels = {}\n        for q in self._bs.qpoints:\n            if q.label:\n                labels[q.label] = q.frac_coords\n\n        lines = []\n        for b in self._bs.branches:\n            lines.append([self._bs.qpoints[b['start_index']].frac_coords,\n                          self._bs.qpoints[b['end_index']].frac_coords])\n\n        plot_brillouin_zone(self._bs.lattice_rec, lines=lines, labels=labels)", "response": "Plot the Brillouin zone."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _plot_thermo(self, func, temperatures, factor=1, ax=None, ylabel=None, label=None, ylim=None, **kwargs):\n\n        ax, fig, plt = get_ax_fig_plt(ax)\n\n        values = []\n\n        for t in temperatures:\n            values.append(func(t, structure=self.structure) * factor)\n\n        ax.plot(temperatures, values, label=label, **kwargs)\n\n        if ylim:\n            ax.set_ylim(ylim)\n\n        ax.set_xlim((np.min(temperatures), np.max(temperatures)))\n        ylim = plt.ylim()\n        if ylim[0] < 0 < ylim[1]:\n            plt.plot(plt.xlim(), [0, 0], 'k-', linewidth=1)\n\n        ax.set_xlabel(r\"$T$ (K)\")\n        if ylabel:\n            ax.set_ylabel(ylabel)\n\n        return fig", "response": "Plots a thermodynamic property for a generic function from a PhononDos instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef plot_cv(self, tmin, tmax, ntemp, ylim=None, **kwargs):\n        temperatures = np.linspace(tmin, tmax, ntemp)\n\n        if self.structure:\n            ylabel = r\"$C_v$ (J/K/mol)\"\n        else:\n            ylabel = r\"$C_v$ (J/K/mol-c)\"\n\n        fig = self._plot_thermo(self.dos.cv, temperatures, ylabel=ylabel, ylim=ylim, **kwargs)\n\n        return fig", "response": "Plots the constant volume specific heat C_v in a temperature range."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nplots the vibrational entrpy in a temperature range.", "response": "def plot_entropy(self, tmin, tmax, ntemp, ylim=None, **kwargs):\n        \"\"\"\n        Plots the vibrational entrpy in a temperature range.\n\n        Args:\n            tmin: minimum temperature\n            tmax: maximum temperature\n            ntemp: number of steps\n            ylim: tuple specifying the y-axis limits.\n            kwargs: kwargs passed to the matplotlib function 'plot'.\n        Returns:\n            matplotlib figure\n        \"\"\"\n        temperatures = np.linspace(tmin, tmax, ntemp)\n\n        if self.structure:\n            ylabel = r\"$S$ (J/K/mol)\"\n        else:\n            ylabel = r\"$S$ (J/K/mol-c)\"\n\n        fig = self._plot_thermo(self.dos.entropy, temperatures, ylabel=ylabel, ylim=ylim, **kwargs)\n\n        return fig"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nplots the internal energy of the vibrational in a temperature range.", "response": "def plot_internal_energy(self, tmin, tmax, ntemp, ylim=None, **kwargs):\n        \"\"\"\n        Plots the vibrational internal energy in a temperature range.\n\n        Args:\n            tmin: minimum temperature\n            tmax: maximum temperature\n            ntemp: number of steps\n            ylim: tuple specifying the y-axis limits.\n            kwargs: kwargs passed to the matplotlib function 'plot'.\n        Returns:\n            matplotlib figure\n        \"\"\"\n        temperatures = np.linspace(tmin, tmax, ntemp)\n\n        if self.structure:\n            ylabel = r\"$\\Delta E$ (kJ/mol)\"\n        else:\n            ylabel = r\"$\\Delta E$ (kJ/mol-c)\"\n\n        fig = self._plot_thermo(self.dos.internal_energy, temperatures, ylabel=ylabel, ylim=ylim,\n                                factor=1e-3, **kwargs)\n\n        return fig"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nplots the vibrational contribution to the Helmoltz free energy in a temperature range.", "response": "def plot_helmholtz_free_energy(self, tmin, tmax, ntemp, ylim=None, **kwargs):\n        \"\"\"\n        Plots the vibrational contribution to the Helmoltz free energy in a temperature range.\n\n        Args:\n            tmin: minimum temperature\n            tmax: maximum temperature\n            ntemp: number of steps\n            ylim: tuple specifying the y-axis limits.\n            kwargs: kwargs passed to the matplotlib function 'plot'.\n        Returns:\n            matplotlib figure\n        \"\"\"\n        temperatures = np.linspace(tmin, tmax, ntemp)\n\n        if self.structure:\n            ylabel = r\"$\\Delta F$ (kJ/mol)\"\n        else:\n            ylabel = r\"$\\Delta F$ (kJ/mol-c)\"\n\n        fig = self._plot_thermo(self.dos.helmholtz_free_energy, temperatures, ylabel=ylabel, ylim=ylim,\n                                factor=1e-3, **kwargs)\n\n        return fig"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nplot all the thermodynamic properties in a temperature range.", "response": "def plot_thermodynamic_properties(self, tmin, tmax, ntemp, ylim=None, **kwargs):\n        \"\"\"\n        Plots all the thermodynamic properties in a temperature range.\n\n        Args:\n            tmin: minimum temperature\n            tmax: maximum temperature\n            ntemp: number of steps\n            ylim: tuple specifying the y-axis limits.\n            kwargs: kwargs passed to the matplotlib function 'plot'.\n        Returns:\n            matplotlib figure\n        \"\"\"\n        temperatures = np.linspace(tmin, tmax, ntemp)\n\n        mol = \"\" if self.structure else \"-c\"\n\n        fig = self._plot_thermo(self.dos.cv, temperatures, ylabel=\"Thermodynamic properties\", ylim=ylim,\n                                label=r\"$C_v$ (J/K/mol{})\".format(mol), **kwargs)\n        self._plot_thermo(self.dos.entropy, temperatures, ylim=ylim, ax=fig.axes[0],\n                          label=r\"$S$ (J/K/mol{})\".format(mol), **kwargs)\n        self._plot_thermo(self.dos.internal_energy, temperatures, ylim=ylim, ax=fig.axes[0], factor=1e-3,\n                          label=r\"$\\Delta E$ (kJ/K/mol{})\".format(mol), **kwargs)\n        self._plot_thermo(self.dos.helmholtz_free_energy, temperatures, ylim=ylim, ax=fig.axes[0], factor=1e-3,\n                          label=r\"$\\Delta F$ (kJ/K/mol{})\".format(mol), **kwargs)\n\n        fig.axes[0].legend(loc=\"best\")\n\n        return fig"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef as_dict(self):\n        pwinput_dict = {'structure': self.structure.as_dict(),\n                        'pseudo': self.pseudo,\n                        'sections': self.sections,\n                        'kpoints_mode': self.kpoints_mode,\n                        'kpoints_grid': self.kpoints_grid,\n                        'kpoints_shift': self.kpoints_shift}\n        return pwinput_dict", "response": "Create a dictionary representation of a PWInput object\n        \n       "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef from_dict(cls, pwinput_dict):\n        pwinput = cls(structure=Structure.from_dict(pwinput_dict['structure']),\n                          pseudo=pwinput_dict['pseudo'],\n                          control=pwinput_dict['sections']['control'],\n                          system=pwinput_dict['sections']['system'],\n                          electrons=pwinput_dict['sections']['electrons'],\n                          ions=pwinput_dict['sections']['ions'],\n                          cell=pwinput_dict['sections']['cell'],\n                          kpoints_mode=pwinput_dict['kpoints_mode'],\n                          kpoints_grid=pwinput_dict['kpoints_grid'],\n                          kpoints_shift=pwinput_dict['kpoints_shift'])\n        return pwinput", "response": "Load a PWInput object from a dictionary with PWInput data."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nwrite the PWSCF input file to a file.", "response": "def write_file(self, filename):\n        \"\"\"\n        Write the PWSCF input file.\n\n        Args:\n            filename (str): The string filename to output to.\n        \"\"\"\n        with open(filename, \"w\") as f:\n            f.write(self.__str__())"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef from_string(string):\n        lines = list(clean_lines(string.splitlines()))\n\n        def input_mode(line):\n            if line[0] == \"&\":\n                return (\"sections\", line[1:].lower())\n            elif \"ATOMIC_SPECIES\" in line:\n                return (\"pseudo\", )\n            elif \"K_POINTS\" in line:\n                return (\"kpoints\", line.split(\"{\")[1][:-1])\n            elif \"CELL_PARAMETERS\" in line or \"ATOMIC_POSITIONS\" in line:\n                return (\"structure\", line.split(\"{\")[1][:-1])\n            elif line == \"/\":\n                return None\n            else:\n                return mode\n\n        sections = {\"control\": {}, \"system\": {}, \"electrons\": {}, \n                    \"ions\": {}, \"cell\":{}}\n        pseudo = {}\n        pseudo_index = 0\n        lattice = []\n        species = []\n        coords = []\n        structure = None\n        site_properties = {\"pseudo\":[]}\n        mode = None\n        for line in lines:\n            mode = input_mode(line)\n            if mode == None:\n                pass\n            elif mode[0] == \"sections\":\n                section = mode[1]\n                m = re.match(r'(\\w+)\\(?(\\d*?)\\)?\\s*=\\s*(.*)', line)\n                if m:\n                    key = m.group(1).strip()\n                    key_ = m.group(2).strip()\n                    val = m.group(3).strip()\n                    if key_ != \"\":\n                        if sections[section].get(key, None) == None:\n                            val_ = [0.0]*20 # MAX NTYP DEFINITION\n                            val_[int(key_)-1] = PWInput.proc_val(key, val)\n                            sections[section][key] = val_\n\n                            site_properties[key] = []\n                        else:\n                            sections[section][key][int(key_)-1] = PWInput.proc_val(key, val) \n                    else:\n                        sections[section][key] = PWInput.proc_val(key, val)\n\n            elif mode[0] == \"pseudo\":\n                m = re.match(r'(\\w+)\\s+(\\d*.\\d*)\\s+(.*)', line)\n                if m:\n                    pseudo[m.group(1).strip()] = {}\n                    pseudo[m.group(1).strip()][\"index\"] = pseudo_index\n                    pseudo[m.group(1).strip()][\"pseudopot\"] = m.group(3).strip()\n                    pseudo_index += 1\n            elif mode[0] == \"kpoints\":\n                m = re.match(r'(\\d+)\\s+(\\d+)\\s+(\\d+)\\s+(\\d+)\\s+(\\d+)\\s+(\\d+)', line)\n                if m:\n                    kpoints_grid = (int(m.group(1)), int(m.group(2)), int(m.group(3)))\n                    kpoints_shift = (int(m.group(4)), int(m.group(5)), int(m.group(6)))\n                else:\n                    kpoints_mode = mode[1]\n            elif mode[0] == \"structure\":\n                m_l = re.match(r'(-?\\d+\\.?\\d*)\\s+(-?\\d+\\.?\\d*)\\s+(-?\\d+\\.?\\d*)', line)\n                m_p = re.match(r'(\\w+)\\s+(-?\\d+\\.\\d*)\\s+(-?\\d+\\.?\\d*)\\s+(-?\\d+\\.?\\d*)', line)\n                if m_l:\n                    lattice += [ float(m_l.group(1)), float(m_l.group(2)), float(m_l.group(3)) ]\n                elif m_p:\n                    site_properties[\"pseudo\"].append(pseudo[m_p.group(1)][\"pseudopot\"])\n                    species += [pseudo[m_p.group(1)][\"pseudopot\"].split(\".\")[0]]\n                    coords += [[float(m_p.group(2)), float(m_p.group(3)), float(m_p.group(4))]]\n\n                    for k, v in site_properties.items():\n                        if k != \"pseudo\":\n                            site_properties[k].append(sections['system'][k][pseudo[m_p.group(1)][\"index\"]])\n                if mode[1] == \"angstrom\":\n                    coords_are_cartesian = True\n                elif mode[1] == \"crystal\":\n                    coords_are_cartesian = False\n\n        structure = Structure(Lattice(lattice), species, coords, \n                              coords_are_cartesian=coords_are_cartesian,\n                              site_properties=site_properties)\n        return PWInput(structure=structure, control=sections[\"control\"],\n                       system=sections[\"system\"], electrons=sections[\"electrons\"], \n                       ions=sections[\"ions\"], cell=sections[\"cell\"], kpoints_mode=kpoints_mode,\n                       kpoints_grid=kpoints_grid, kpoints_shift=kpoints_shift)", "response": "Reads an object from a string."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef proc_val(key, val):\n        float_keys = ('etot_conv_thr','forc_conv_thr','conv_thr','Hubbard_U','Hubbard_J0','defauss',\n                      'starting_magnetization',)\n\n        int_keys = ('nstep','iprint','nberrycyc','gdir','nppstr','ibrav','nat','ntyp','nbnd','nr1',\n                    'nr2','nr3','nr1s','nr2s','nr3s','nspin','nqx1','nqx2','nqx3','lda_plus_u_kind',\n                    'edir','report','esm_nfit','space_group','origin_choice','electron_maxstep',\n                    'mixing_ndim','mixing_fixed_ns','ortho_para','diago_cg_maxiter','diago_david_ndim',\n                    'nraise','bfgs_ndim','if_pos','nks','nk1','nk2','nk3','sk1','sk2','sk3','nconstr')\n\n        bool_keys = ('wf_collect','tstress','tprnfor','lkpoint_dir','tefield','dipfield','lelfield',\n                     'lorbm','lberry','lfcpopt','monopole','nosym','nosym_evc','noinv','no_t_rev',\n                     'force_symmorphic','use_all_frac','one_atom_occupations','starting_spin_angle',\n                     'noncolin','x_gamma_extrapolation','lda_plus_u','lspinorb','london',\n                     'ts_vdw_isolated','xdm','uniqueb','rhombohedral','realxz','block',\n                     'scf_must_converge','adaptive_thr','diago_full_acc','tqr','remove_rigid_rot',\n                     'refold_pos')\n\n        def smart_int_or_float(numstr):\n            if numstr.find(\".\") != -1 or numstr.lower().find(\"e\") != -1:\n                return float(numstr)\n            else:\n                return int(numstr)\n\n        try:\n            if key in bool_keys:\n                if val.lower() == \".true.\":\n                    return True\n                elif val.lower() == \".false.\":\n                    return False\n                else:\n                    raise ValueError(key + \" should be a boolean type!\")\n\n            if key in float_keys:\n                return float(re.search(r\"^-?\\d*\\.?\\d*d?-?\\d*\", val.lower()).group(0).replace(\"d\", \"e\"))\n\n            if key in int_keys:\n                return int(re.match(r\"^-?[0-9]+\", val).group(0))\n\n        except ValueError:\n            pass\n\n        try:\n            val = val.replace(\"d\",\"e\")\n            return smart_int_or_float(val)\n        except ValueError:\n            pass\n\n        if \"true\" in val.lower():\n            return True\n        if \"false\" in val.lower():\n            return False\n\n        m = re.match(r\"^[\\\"|'](.+)[\\\"|']$\", val)\n        if m:\n            return m.group(1)", "response": "This method is used to convert the values of the PWINPUT parameters to proper types."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nprinting to the given stream the template of the class of type qtype.", "response": "def show_qparams(qtype, stream=sys.stdout):\n    \"\"\"Print to the given stream the template of the :class:`QueueAdapter` of type `qtype`.\"\"\"\n    for cls in all_subclasses(QueueAdapter):\n        if cls.QTYPE == qtype: return stream.write(cls.QTEMPLATE)\n\n    raise ValueError(\"Cannot find class associated to qtype %s\" % qtype)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef make_qadapter(**kwargs):\n    # Get all known subclasses of QueueAdapter.\n    d = {c.QTYPE: c for c in all_subclasses(QueueAdapter)}\n\n    # Preventive copy before pop\n    kwargs = copy.deepcopy(kwargs)\n    qtype = kwargs[\"queue\"].pop(\"qtype\")\n\n    return d[qtype](**kwargs)", "response": "Return the concrete class of QueueAdapter class from a string."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nbuilds and returns a string with the command required to execute the qadapter with the qadapter.", "response": "def string_to_run(self, qad, executable, stdin=None, stdout=None, stderr=None, exec_args=None):\n        \"\"\"\n        Build and return a string with the command required to launch `executable` with the qadapter `qad`.\n\n        Args\n            qad: Qadapter instance.\n            executable (str): Executable name or path\n            stdin (str): Name of the file to be used as standard input. None means no redirection.\n            stdout (str): Name of the file to be used as standard output. None means no redirection.\n            stderr (str): Name of the file to be used as standard error. None means no redirection.\n            exec_args: Optional list of strings with options passed to `executable`.\n\n        Return:\n            String with command to execute.\n        \"\"\"\n        stdin = \"< \" + stdin if stdin is not None else \"\"\n        stdout = \"> \" + stdout if stdout is not None else \"\"\n        stderr = \"2> \" + stderr if stderr is not None else \"\"\n\n        if exec_args:\n            executable = executable + \" \" + \" \".join(list_strings(exec_args))\n\n        basename = os.path.basename(self.name)\n        if basename in [\"mpirun\", \"mpiexec\", \"srun\"]:\n            if self.type is None:\n                # $MPIRUN -n $MPI_PROCS $EXECUTABLE < $STDIN > $STDOUT 2> $STDERR\n                num_opt = \"-n \" + str(qad.mpi_procs)\n                cmd = \" \".join([self.name, self.options, num_opt, executable, stdin, stdout, stderr])\n            else:\n                raise NotImplementedError(\"type %s is not supported!\" % self.type)\n\n        elif basename == \"runjob\":\n            #runjob --ranks-per-node 2 --exp-env OMP_NUM_THREADS --exe $ABINIT < $STDIN > $STDOUT 2> $STDERR\n            #runjob -n 2 --exp-env=OMP_NUM_THREADS --exe $ABINIT < $STDIN > $STDOUT 2> $STDERR\n            # exe must be absolute path or relative to cwd.\n            bg_size, rpn = qad.bgsize_rankspernode()\n            #num_opt = \"-n \" + str(qad.mpi_procs)\n            num_opt = \"--ranks-per-node \" + str(rpn)\n            cmd = \" \".join([self.name, self.options, num_opt, \"--exp-env OMP_NUM_THREADS\",\n                           \"--exe `which \" + executable + \"` \", stdin, stdout, stderr])\n        else:\n            if qad.mpi_procs != 1:\n                raise ValueError(\"Cannot use mpi_procs > when mpi_runner basename=%s\" % basename)\n            cmd = \" \".join([executable, stdin, stdout, stderr])\n\n        return cmd"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef as_ompenv(cls, obj):\n        if isinstance(obj, cls): return obj\n        if obj is None: return cls()\n        return cls(**obj)", "response": "Convert an object into an OmpEnv object"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a dictionary representation of the object.", "response": "def as_dict(self):\n        \"\"\"\n        Provides a simple though not complete dict serialization of the object (OMP missing, not all limits are\n        kept in the dictionary, ... other things to be checked)\n\n        Raise:\n            `ValueError` if errors.\n        \"\"\"\n        if self.has_omp:\n            raise NotImplementedError('as_dict method of QueueAdapter not yet implemented when OpenMP is activated')\n        return {'@module': self.__class__.__module__,\n                '@class': self.__class__.__name__,\n                'priority': self.priority,\n                'hardware': self.hw.as_dict(),\n                'queue': {'qtype': self.QTYPE,\n                          'qname': self._qname,\n                          'qnodes': self.qnodes,\n                          'qparams': self._qparams},\n                'limits': {'timelimit_hard': self._timelimit_hard,\n                           'timelimit': self._timelimit,\n                           'min_cores': self.min_cores,\n                           'max_cores': self.max_cores,\n                           'min_mem_per_proc': self.min_mem_per_proc,\n                           'max_mem_per_proc': self.max_mem_per_proc,\n                           'memory_policy': self.memory_policy\n                           },\n                'job': {},\n                'mpi_procs': self._mpi_procs,\n                'mem_per_proc': self._mem_per_proc,\n                'master_mem_overhead': self._master_mem_overhead\n                }"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nvalidate the list of supported parameters for the current class.", "response": "def validate_qparams(self):\n        \"\"\"\n        Check if the keys specified by the user in qparams are supported.\n\n        Raise:\n            `ValueError` if errors.\n        \"\"\"\n        # No validation for ShellAdapter.\n        if isinstance(self, ShellAdapter): return\n\n        # Parse the template so that we know the list of supported options.\n        err_msg = \"\"\n        for param in self.qparams:\n            if param not in self.supported_qparams:\n                err_msg += \"Unsupported QUEUE parameter name %s\\n\" % param\n                err_msg += \"Supported parameters:\\n\"\n                for param_sup in self.supported_qparams:\n                    err_msg += \"    %s \\n\" % param_sup\n\n        if err_msg:\n            raise ValueError(err_msg)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nvalidate the parameters of the run. Raises self. Error if invalid parameters.", "response": "def validate(self):\n        \"\"\"Validate the parameters of the run. Raises self.Error if invalid parameters.\"\"\"\n        errors = []\n        app = errors.append\n\n        if not self.hint_cores >= self.mpi_procs * self.omp_threads >= self.min_cores:\n            app(\"self.hint_cores >= mpi_procs * omp_threads >= self.min_cores not satisfied\")\n\n        if self.omp_threads > self.hw.cores_per_node:\n            app(\"omp_threads > hw.cores_per_node\")\n\n        if self.mem_per_proc > self.hw.mem_per_node:\n            app(\"mem_mb >= self.hw.mem_per_node\")\n\n        if not self.max_mem_per_proc >= self.mem_per_proc >= self.min_mem_per_proc:\n            app(\"self.max_mem_per_proc >= mem_mb >= self.min_mem_per_proc not satisfied\")\n\n        if self.priority <= 0:\n            app(\"priority must be > 0\")\n\n        if not (1 <= self.min_cores <= self.hw.num_cores >= self.hint_cores):\n            app(\"1 <= min_cores <= hardware num_cores >= hint_cores not satisfied\")\n\n        if errors:\n            raise self.Error(str(self) + \"\\n\".join(errors))"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ntrues if the qadapter can run the ParalConf pconf", "response": "def can_run_pconf(self, pconf):\n        \"\"\"True if the qadapter in principle is able to run the :class:`ParalConf` pconf\"\"\"\n        if not self.hint_cores >= pconf.num_cores >= self.min_cores: return False\n        if not self.hw.can_use_omp_threads(self.omp_threads): return False\n        if pconf.mem_per_proc > self.hw.mem_per_node: return False\n        if self.allocation == \"force_nodes\" and pconf.num_cores % self.hw.cores_per_node != 0:\n            return False\n\n        return self.condition(pconf)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ndistribute the current set of processes and threads to the other processes.", "response": "def distribute(self, mpi_procs, omp_threads, mem_per_proc):\n        \"\"\"\n        Returns (num_nodes, mpi_per_node)\n\n        Aggressive: When Open MPI thinks that it is in an exactly- or under-subscribed mode\n        (i.e., the number of running processes is equal to or less than the number of available processors),\n        MPI processes will automatically run in aggressive mode, meaning that they will never voluntarily give\n        up the processor to other processes. With some network transports, this means that Open MPI will spin\n        in tight loops attempting to make message passing progress, effectively causing other processes to not get\n        any CPU cycles (and therefore never make any progress)\n        \"\"\"\n        class Distrib(namedtuple(\"Distrib\", \"num_nodes mpi_per_node exact\")):\n            pass\n            #@property\n            #def mem_per_node\n            #    return self.mpi_per_node * mem_per_proc\n            #def set_nodes(self, nodes):\n\n        hw = self.hw\n\n        # TODO: Add check on user-memory\n        if mem_per_proc <= 0:\n            logger.warning(\"mem_per_proc <= 0\")\n            mem_per_proc = hw.mem_per_core\n\n        if mem_per_proc > hw.mem_per_node:\n            raise self.Error(\n                \"mem_per_proc > mem_per_node.\\n Cannot distribute mpi_procs %d, omp_threads %d, mem_per_proc %s\" %\n                             (mpi_procs, omp_threads, mem_per_proc))\n\n        # Try to use all then cores in the node.\n        num_nodes, rest_cores = hw.divmod_node(mpi_procs, omp_threads)\n\n        if num_nodes == 0 and mpi_procs * mem_per_proc <= hw.mem_per_node:\n            # One node is enough\n            return Distrib(num_nodes=1, mpi_per_node=mpi_procs, exact=True)\n\n        if num_nodes == 0: num_nodes = 2\n        mpi_per_node = mpi_procs // num_nodes\n        if mpi_per_node * mem_per_proc <= hw.mem_per_node and rest_cores == 0:\n            # Commensurate with nodes.\n            return Distrib(num_nodes=num_nodes, mpi_per_node=mpi_per_node, exact=True)\n\n        #if mode == \"block\", \"cyclic\"\n\n        # Try first to pack MPI processors in a node as much as possible\n        mpi_per_node = int(hw.mem_per_node / mem_per_proc)\n        assert mpi_per_node != 0\n        num_nodes = (mpi_procs * omp_threads) // mpi_per_node\n        print(\"exact --> false\", num_nodes, mpi_per_node)\n\n        if mpi_per_node * omp_threads <= hw.cores_per_node and mem_per_proc <= hw.mem_per_node:\n            return Distrib(num_nodes=num_nodes, mpi_per_node=mpi_per_node, exact=False)\n\n        if (mpi_procs * omp_threads) % mpi_per_node != 0:\n            # Have to reduce the number of MPI procs per node\n            for mpi_per_node in reversed(range(1, mpi_per_node)):\n                if mpi_per_node > hw.cores_per_node: continue\n                num_nodes = (mpi_procs * omp_threads) // mpi_per_node\n                if (mpi_procs * omp_threads) % mpi_per_node == 0 and mpi_per_node * mem_per_proc <= hw.mem_per_node:\n                    return Distrib(num_nodes=num_nodes, mpi_per_node=mpi_per_node, exact=False)\n        else:\n            raise self.Error(\"Cannot distribute mpi_procs %d, omp_threads %d, mem_per_proc %s\" %\n                            (mpi_procs, omp_threads, mem_per_proc))"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns substitution dict for replacements into the template", "response": "def get_subs_dict(self, qnodes=None):\n        \"\"\"\n        Return substitution dict for replacements into the template\n        Subclasses may want to customize this method.\n        \"\"\"\n        #d = self.qparams.copy()\n        d = self.qparams\n        d.update(self.optimize_params(qnodes=qnodes))\n        # clean null values\n        subs_dict = {k: v for k, v in d.items() if v is not None}\n        #print(\"subs_dict:\", subs_dict)\n        return subs_dict"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a string with the options that are passed to the resource manager.", "response": "def _make_qheader(self, job_name, qout_path, qerr_path):\n        \"\"\"Return a string with the options that are passed to the resource manager.\"\"\"\n        # get substitution dict for replacements into the template\n        subs_dict = self.get_subs_dict()\n\n        # Set job_name and the names for the stderr and stdout of the\n        # queue manager (note the use of the extensions .qout and .qerr\n        # so that we can easily locate this file.\n        subs_dict['job_name'] = job_name.replace('/', '_')\n        subs_dict['_qout_path'] = qout_path\n        subs_dict['_qerr_path'] = qerr_path\n\n        qtemplate = QScriptTemplate(self.QTEMPLATE)\n        # might contain unused parameters as leftover $$.\n        unclean_template = qtemplate.safe_substitute(subs_dict)\n\n        # Remove lines with leftover $$.\n        clean_template = []\n        for line in unclean_template.split('\\n'):\n            if '$$' not in line:\n                clean_template.append(line)\n\n        return '\\n'.join(clean_template)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a string representing the queue manager script.", "response": "def get_script_str(self, job_name, launch_dir, executable, qout_path, qerr_path,\n                       stdin=None, stdout=None, stderr=None, exec_args=None):\n        \"\"\"\n        Returns a (multi-line) String representing the queue script, e.g. PBS script.\n        Uses the template_file along with internal parameters to create the script.\n\n        Args:\n            job_name: Name of the job.\n            launch_dir: (str) The directory the job will be launched in.\n            executable: String with the name of the executable to be executed or list of commands\n            qout_path Path of the Queue manager output file.\n            qerr_path: Path of the Queue manager error file.\n            exec_args: List of arguments passed to executable (used only if executable is a string, default: empty)\n        \"\"\"\n        # PbsPro does not accept job_names longer than 15 chars.\n        if len(job_name) > 14 and isinstance(self, PbsProAdapter):\n            job_name = job_name[:14]\n\n        # Construct the header for the Queue Manager.\n        qheader = self._make_qheader(job_name, qout_path, qerr_path)\n\n        # Add the bash section.\n        se = ScriptEditor()\n\n        # Cd to launch_dir immediately.\n        se.add_line(\"cd \" + os.path.abspath(launch_dir))\n\n        if self.setup:\n            se.add_comment(\"Setup section\")\n            se.add_lines(self.setup)\n            se.add_emptyline()\n\n        if self.modules:\n            # stderr is redirected to mods.err file.\n            # module load 2>> mods.err\n            se.add_comment(\"Load Modules\")\n            se.add_line(\"module purge\")\n            se.load_modules(self.modules)\n            se.add_emptyline()\n\n        se.add_comment(\"OpenMp Environment\")\n        if self.has_omp:\n            se.declare_vars(self.omp_env)\n            se.add_emptyline()\n        else:\n            se.declare_vars({\"OMP_NUM_THREADS\": 1})\n\n        if self.shell_env:\n            se.add_comment(\"Shell Environment\")\n            se.declare_vars(self.shell_env)\n            se.add_emptyline()\n\n        if self.pre_run:\n            se.add_comment(\"Commands before execution\")\n            se.add_lines(self.pre_run)\n            se.add_emptyline()\n\n        # Construct the string to run the executable with MPI and mpi_procs.\n        if is_string(executable):\n            line = self.mpi_runner.string_to_run(self, executable,\n                                                 stdin=stdin, stdout=stdout, stderr=stderr, exec_args=exec_args)\n            se.add_line(line)\n        else:\n            assert isinstance(executable, (list, tuple))\n            se.add_lines(executable)\n\n        if self.post_run:\n            se.add_emptyline()\n            se.add_comment(\"Commands after execution\")\n            se.add_lines(self.post_run)\n\n        return qheader + se.get_script_str() + \"\\n\""}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef submit_to_queue(self, script_file):\n        if not os.path.exists(script_file):\n            raise self.Error('Cannot find script file located at: {}'.format(script_file))\n\n        if self.num_launches == self.max_num_launches:\n            raise self.MaxNumLaunchesError(\"num_launches %s == max_num_launches %s\" % (self.num_launches, self.max_num_launches))\n\n        # Call the concrete implementation.\n        s = self._submit_to_queue(script_file)\n        self.record_launch(s.qid)\n\n        if s.qid is None:\n            raise self.Error(\"Error in job submission with %s. file %s \\n\" %\n                            (self.__class__.__name__, script_file) +\n                             \"The error response reads:\\n %s \\n \" % s.err +\n                             \"The out response reads:\\n %s \\n\" % s.out)\n\n        # Here we create a concrete instance of QueueJob\n        return QueueJob.from_qtype_and_id(self.QTYPE, s.qid, self.qname), s.process", "response": "Submits the job to the queue."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the number of jobs in the queue.", "response": "def get_njobs_in_queue(self, username=None):\n        \"\"\"\n        returns the number of jobs in the queue, probably using subprocess or shutil to\n        call a command like 'qstat'. returns None when the number of jobs cannot be determined.\n\n        Args:\n            username: (str) the username of the jobs to count (default is to autodetect)\n        \"\"\"\n        if username is None: username = getpass.getuser()\n        njobs, process = self._get_njobs_in_queue(username=username)\n\n        if process is not None and process.returncode != 0:\n            # there's a problem talking to squeue server?\n            err_msg = ('Error trying to get the number of jobs in the queue' +\n                       'The error response reads:\\n {}'.format(process.stderr.read()))\n            logger.critical(err_msg)\n\n        if not isinstance(self, ShellAdapter):\n            logger.info('The number of jobs currently in the queue is: {}'.format(njobs))\n\n        return njobs"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef more_master_mem_overhead(self, mem_increase_mb=1000):\n        old_master_mem_overhead = self.master_mem_overhead\n        new_master_mem_overhead = old_master_mem_overhead + mem_increase_mb\n        if new_master_mem_overhead + self.mem_per_proc < self.hw.mem_per_node:\n            self.set_master_mem_overhead(new_master_mem_overhead)\n            return new_master_mem_overhead\n\n        raise self.Error('could not increase master_mem_overhead further')", "response": "Method to increase the amount of memory overheaded asked for the master node."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef more_time(self, factor=1):\n        base_increase = int(self.timelimit_hard / 10)\n\n        new_time = self.timelimit + base_increase*factor\n        print('qadapter: trying to increase time')\n        if new_time < self.timelimit_hard:\n            self.set_timelimit(new_time)\n            print('new time set: ', new_time)\n            return new_time\n\n        self.priority = -1\n\n        raise self.Error(\"increasing time is not possible, the hard limit has been reached\")", "response": "Method to increase the wall time based on the hard limit"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_mem_per_proc(self, mem_mb):\n        super().set_mem_per_proc(mem_mb)\n        self.qparams[\"mem_per_cpu\"] = self.mem_per_proc", "response": "Set the memory per process in megabytes"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_select(self, ret_dict=False, qnodes=None, memory_policy=None):\n        hw, mem_per_proc = self.hw, int(self.mem_per_proc)\n        #dist = self.distribute(self.mpi_procs, self.omp_threads, mem_per_proc)\n        \"\"\"\n        if self.pure_mpi:\n            num_nodes, rest_cores = hw.divmod_node(self.mpi_procs, self.omp_threads)\n\n            if num_nodes == 0:\n                logger.info(\"IN_CORE PURE MPI: %s\" % self.run_info)\n                chunks = 1\n                ncpus = rest_cores\n                mpiprocs = rest_cores\n                mem = mem_per_proc * ncpus\n                ompthreads = 1\n\n            elif rest_cores == 0:\n                # Can allocate entire nodes because self.mpi_procs is divisible by cores_per_node.\n                logger.info(\"PURE MPI run commensurate with cores_per_node %s\" % self.run_info)\n                chunks = num_nodes\n                ncpus = hw.cores_per_node\n                mpiprocs = hw.cores_per_node\n                mem = ncpus * mem_per_proc\n                ompthreads = 1\n\n            else:\n                logger.info(\"OUT-OF-CORE PURE MPI (not commensurate with cores_per_node): %s\" % self.run_info)\n                chunks = self.mpi_procs\n                ncpus = 1\n                mpiprocs = 1\n                mem = mem_per_proc\n                ompthreads = 1\n\n        elif self.pure_omp:\n            # Pure OMP run.\n            logger.info(\"PURE OPENMP run: %s\" % self.run_info)\n            assert hw.can_use_omp_threads(self.omp_threads)\n            chunks = 1\n            ncpus = self.omp_threads\n            mpiprocs = 1\n            mem = mem_per_proc\n            ompthreads = self.omp_threads\n\n        elif self.hybrid_mpi_omp:\n            assert hw.can_use_omp_threads(self.omp_threads)\n            num_nodes, rest_cores = hw.divmod_node(self.mpi_procs, self.omp_threads)\n            #print(num_nodes, rest_cores)\n            # TODO: test this\n\n            if rest_cores == 0 or num_nodes == 0:\n                logger.info(\"HYBRID MPI-OPENMP run, perfectly divisible among nodes: %s\" % self.run_info)\n                chunks = max(num_nodes, 1)\n                mpiprocs = self.mpi_procs // chunks\n\n                chunks = chunks\n                ncpus = mpiprocs * self.omp_threads\n                mpiprocs = mpiprocs\n                mem = mpiprocs * mem_per_proc\n                ompthreads = self.omp_threads\n\n            else:\n                logger.info(\"HYBRID MPI-OPENMP, NOT commensurate with nodes: %s\" % self.run_info)\n                chunks=self.mpi_procs\n                ncpus=self.omp_threads\n                mpiprocs=1\n                mem= mem_per_proc\n                ompthreads=self.omp_threads\n\n        else:\n            raise RuntimeError(\"You should not be here\")\n        \"\"\"\n        if memory_policy is None:\n            memory_policy = self.memory_policy\n        if qnodes is None:\n            qnodes = self.qnodes\n        else:\n            if qnodes not in [\"standard\", \"shared\", \"exclusive\"]:\n                raise ValueError(\"Nodes must be either in standard, shared or exclusive mode \"\n                                 \"while qnodes parameter was {}\".format(self.qnodes))\n        if qnodes == \"standard\":\n            return self._get_select_standard(ret_dict=ret_dict, memory_policy=memory_policy)\n        else:\n            return self._get_select_with_master_mem_overhead(ret_dict=ret_dict, qnodes=qnodes,\n                                                             memory_policy=memory_policy)", "response": "Get select from the current state of the current state of the current object."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsubmits a job script to the queue.", "response": "def _submit_to_queue(self, script_file):\n        \"\"\"Submit a job script to the queue.\"\"\"\n        if sys.version_info[0] < 3:\n            process = Popen(['qsub', script_file], stdout=PIPE, stderr=PIPE)\n        else:\n            # need string not bytes so must use universal_newlines\n            process = Popen(['qsub', script_file], stdout=PIPE, stderr=PIPE, universal_newlines=True)\n\n        out, err = process.communicate()\n        # grab the return code. PBS returns 0 if the job was successful\n        queue_id = None\n        if process.returncode == 0:\n            try:\n                # output should of the form '2561553.sdb' or '352353.jessup' - just grab the first part for job id\n                queue_id = int(out.split('.')[0])\n            except:\n                # probably error parsing job code\n                logger.critical(\"Could not parse job id following qsub...\")\n        return SubmitResults(qid=queue_id, out=out, err=err, process=process)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_mpi_procs(self, mpi_procs):\n        QueueAdapter.set_mpi_procs(self, mpi_procs)\n\n        num_nodes, rest_cores = self.hw.divmod_node(mpi_procs, omp_threads=1)\n        if num_nodes == 0:\n            self.qparams[\"nodes\"] = 1\n            self.qparams[\"ppn\"] = mpi_procs\n        else:\n            if rest_cores != 0:\n                # Pack cores as much as possible.\n                num_nodes += 1\n            self.qparams[\"nodes\"] = num_nodes\n            self.qparams[\"ppn\"] = self.hw.cores_per_node", "response": "Set the number of CPUs used for MPI."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the memory per process in megabytes", "response": "def set_mem_per_proc(self, mem_mb):\n        \"\"\"Set the memory per process in megabytes\"\"\"\n        super().set_mem_per_proc(mem_mb)\n        self.qparams[\"mem_per_slot\"] = str(int(self.mem_per_proc)) + \"M\""}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_timelimit(self, timelimit):\n        super().set_timelimit(timelimit)\n        self.qparams[\"wall_clock_limit\"] = qu.time2loadlever(timelimit)", "response": "Sets the time limit for the loadlever of the current record."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns ( bg_size ranks_per_node ) from mpi_procs and omp_threads.", "response": "def bgsize_rankspernode(self):\n\t    \"\"\"Return (bg_size, ranks_per_node) from mpi_procs and omp_threads.\"\"\"\n\t    bg_size = int(math.ceil((self.mpi_procs * self.omp_threads)/ self.hw.cores_per_node))\n\t    bg_size = max(bg_size, 32) # TODO hardcoded\n\t    ranks_per_node = int(math.ceil(self.mpi_procs / bg_size))\n\n\t    return bg_size, ranks_per_node"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef alternate(*iterables):\n    items = []\n    for tup in zip(*iterables):\n        items.extend([item for item in tup])\n    return items", "response": "A generator that returns all the items in the iterable."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef walk(cls, top=\".\", ext=\".abo\"):\n        paths = []\n        for root, dirs, files in os.walk(top):\n            for f in files:\n                if f.endswith(ext):\n                    paths.append(os.path.join(root, f))\n\n        parser = cls()\n        okfiles = parser.parse(paths)\n        return parser, paths, okfiles", "response": "Walk the directory tree starting from top and parse timing data."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef parse(self, filenames):\n        filenames = list_strings(filenames)\n\n        read_ok = []\n        for fname in filenames:\n            try:\n                fh = open(fname)\n            except IOError:\n                logger.warning(\"Cannot open file %s\" % fname)\n                continue\n\n            try:\n                self._read(fh, fname)\n                read_ok.append(fname)\n\n            except self.Error as e:\n                logger.warning(\"exception while parsing file %s:\\n%s\" % (fname, str(e)))\n                continue\n\n            finally:\n                fh.close()\n\n        # Add read_ok to the list of files that have been parsed.\n        self._filenames.extend(read_ok)\n        return read_ok", "response": "Read and parse a filename or a list of filenames."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _read(self, fh, fname):\n        if fname in self._timers:\n            raise self.Error(\"Cannot overwrite timer associated to: %s \" % fname)\n\n        def parse_line(line):\n            \"\"\"Parse single line.\"\"\"\n            name, vals = line[:25], line[25:].split()\n            try:\n                ctime, cfract, wtime, wfract, ncalls, gflops = vals\n            except ValueError:\n                # v8.3 Added two columns at the end [Speedup, Efficacity]\n                ctime, cfract, wtime, wfract, ncalls, gflops, speedup, eff = vals\n\n            return AbinitTimerSection(name, ctime, cfract, wtime, wfract, ncalls, gflops)\n\n        data = {}\n        inside, has_timer = 0, False\n        for line in fh:\n            #print(line.strip())\n            if line.startswith(self.BEGIN_TAG):\n                has_timer = True\n                sections = []\n                info = {}\n                inside = 1\n                line = line[len(self.BEGIN_TAG):].strip()[:-1]\n\n                info[\"fname\"] = fname\n                for tok in line.split(\",\"):\n                    key, val = [s.strip() for s in tok.split(\"=\")]\n                    info[key] = val\n\n            elif line.startswith(self.END_TAG):\n                inside = 0\n                timer = AbinitTimer(sections, info, cpu_time, wall_time)\n                mpi_rank = info[\"mpi_rank\"]\n                data[mpi_rank] = timer\n\n            elif inside:\n                inside += 1\n                line = line[1:].strip()\n\n                if inside == 2:\n                    d = dict()\n                    for tok in line.split(\",\"):\n                        key, val = [s.strip() for s in tok.split(\"=\")]\n                        d[key] = float(val)\n                    cpu_time, wall_time = d[\"cpu_time\"], d[\"wall_time\"]\n\n                elif inside > 5:\n                    sections.append(parse_line(line))\n\n                else:\n                    try:\n                        parse_line(line)\n                    except:\n                        parser_failed = True\n\n                    if not parser_failed:\n                        raise self.Error(\"line should be empty: \" + str(inside) + line)\n\n        if not has_timer:\n            raise self.Error(\"%s: No timer section found\" % fname)\n\n        # Add it to the dict\n        self._timers[fname] = data", "response": "Read the contents of the file and return a dictionary of the data."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef timers(self, filename=None, mpi_rank=\"0\"):\n        if filename is not None:\n            return [self._timers[filename][mpi_rank]]\n        else:\n            return [self._timers[filename][mpi_rank] for filename in self._filenames]", "response": "Return the list of timers associated to the given filename and MPI rank mpi_rank."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the names of sections ordered by ordkey.", "response": "def section_names(self, ordkey=\"wall_time\"):\n        \"\"\"\n        Return the names of sections ordered by ordkey.\n        For the time being, the values are taken from the first timer.\n        \"\"\"\n        section_names = []\n\n        # FIXME this is not trivial\n        for idx, timer in enumerate(self.timers()):\n            if idx == 0:\n                section_names = [s.name for s in timer.order_sections(ordkey)]\n                #check = section_names\n                #else:\n                #  new_set = set( [s.name for s in timer.order_sections(ordkey)])\n                #  section_names.intersection_update(new_set)\n                #  check = check.union(new_set)\n\n        #if check != section_names:\n        #  print(\"sections\", section_names)\n        #  print(\"check\",check)\n\n        return section_names"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_sections(self, section_name):\n        sections = []\n        for timer in self.timers():\n            for sect in timer.sections:\n                if sect.name == section_name:\n                    sections.append(sect)\n                    break\n            else:\n                sections.append(AbinitTimerSection.fake())\n\n        return sections", "response": "Return the list of sections stored in self. timers() given section_name."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nanalyzing the parallel efficiency.", "response": "def pefficiency(self):\n        \"\"\"\n        Analyze the parallel efficiency.\n\n        Return:\n            :class:`ParallelEfficiency` object.\n        \"\"\"\n        timers = self.timers()\n\n        # Number of CPUs employed in each calculation.\n        ncpus = [timer.ncpus for timer in timers]\n\n        # Find the minimum number of cpus used and its index in timers.\n        min_idx = minloc(ncpus)\n        min_ncpus = ncpus[min_idx]\n\n        # Reference timer\n        ref_t = timers[min_idx]\n\n        # Compute the parallel efficiency (total and section efficiency)\n        peff = {}\n        ctime_peff = [(min_ncpus * ref_t.wall_time) / (t.wall_time * ncp) for (t, ncp) in zip(timers, ncpus)]\n        wtime_peff = [(min_ncpus * ref_t.cpu_time) / (t.cpu_time * ncp) for (t, ncp) in zip(timers, ncpus)]\n        n = len(timers)\n\n        peff[\"total\"] = {}\n        peff[\"total\"][\"cpu_time\"] = ctime_peff\n        peff[\"total\"][\"wall_time\"] = wtime_peff\n        peff[\"total\"][\"cpu_fract\"] = n * [100]\n        peff[\"total\"][\"wall_fract\"] = n * [100]\n\n        for sect_name in self.section_names():\n            #print(sect_name)\n            ref_sect = ref_t.get_section(sect_name)\n            sects = [t.get_section(sect_name) for t in timers]\n            try:\n                ctime_peff = [(min_ncpus * ref_sect.cpu_time) / (s.cpu_time * ncp) for (s, ncp) in zip(sects, ncpus)]\n                wtime_peff = [(min_ncpus * ref_sect.wall_time) / (s.wall_time * ncp) for (s, ncp) in zip(sects, ncpus)]\n            except ZeroDivisionError:\n                ctime_peff = n * [-1]\n                wtime_peff = n * [-1]\n\n            assert sect_name not in peff\n            peff[sect_name] = {}\n            peff[sect_name][\"cpu_time\"] = ctime_peff\n            peff[sect_name][\"wall_time\"] = wtime_peff\n\n            peff[sect_name][\"cpu_fract\"] = [s.cpu_fract for s in sects]\n            peff[sect_name][\"wall_fract\"] = [s.wall_fract for s in sects]\n\n        return ParallelEfficiency(self._filenames, min_idx, peff)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef summarize(self, **kwargs):\n        import pandas as pd\n        colnames = [\"fname\", \"wall_time\", \"cpu_time\", \"mpi_nprocs\", \"omp_nthreads\", \"mpi_rank\"]\n\n        frame = pd.DataFrame(columns=colnames)\n        for i, timer in enumerate(self.timers()):\n            frame = frame.append({k: getattr(timer, k) for k in colnames}, ignore_index=True)\n        frame[\"tot_ncpus\"] = frame[\"mpi_nprocs\"] * frame[\"omp_nthreads\"]\n\n        # Compute parallel efficiency (use the run with min number of cpus to normalize).\n        i = frame[\"tot_ncpus\"].values.argmin()\n        ref_wtime = frame.ix[i][\"wall_time\"]\n        ref_ncpus = frame.ix[i][\"tot_ncpus\"]\n        frame[\"peff\"] = (ref_ncpus * ref_wtime) / (frame[\"wall_time\"] * frame[\"tot_ncpus\"])\n\n        return frame", "response": "Return pandas DataFrame with the most important results stored in the timers."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nplots the parallel efficiency of the current object.", "response": "def plot_efficiency(self, key=\"wall_time\", what=\"good+bad\", nmax=5, ax=None, **kwargs):\n        \"\"\"\n        Plot the parallel efficiency\n\n        Args:\n            key: Parallel efficiency is computed using the wall_time.\n            what: Specifies what to plot: `good` for sections with good parallel efficiency.\n                `bad` for sections with bad efficiency. Options can be concatenated with `+`.\n            nmax: Maximum number of entries in plot\n            ax: matplotlib :class:`Axes` or None if a new figure should be created.\n\n        ================  ====================================================\n        kwargs            Meaning\n        ================  ====================================================\n        linewidth         matplotlib linewidth. Default: 2.0\n        markersize        matplotlib markersize. Default: 10\n        ================  ====================================================\n\n        Returns:\n            `matplotlib` figure\n        \"\"\"\n        ax, fig, plt = get_ax_fig_plt(ax=ax)\n        lw = kwargs.pop(\"linewidth\", 2.0)\n        msize = kwargs.pop(\"markersize\", 10)\n        what = what.split(\"+\")\n\n        timers = self.timers()\n        peff = self.pefficiency()\n        n = len(timers)\n        xx = np.arange(n)\n\n        #ax.set_color_cycle(['g', 'b', 'c', 'm', 'y', 'k'])\n        ax.set_prop_cycle(color=['g', 'b', 'c', 'm', 'y', 'k'])\n\n        lines, legend_entries = [], []\n        # Plot sections with good efficiency.\n        if \"good\" in what:\n            good = peff.good_sections(key=key, nmax=nmax)\n            for g in good:\n                #print(g, peff[g])\n                yy = peff[g][key]\n                line, = ax.plot(xx, yy, \"-->\", linewidth=lw, markersize=msize)\n                lines.append(line)\n                legend_entries.append(g)\n\n        # Plot sections with bad efficiency.\n        if \"bad\" in what:\n            bad = peff.bad_sections(key=key, nmax=nmax)\n            for b in bad:\n                #print(b, peff[b])\n                yy = peff[b][key]\n                line, = ax.plot(xx, yy, \"-.<\", linewidth=lw, markersize=msize)\n                lines.append(line)\n                legend_entries.append(b)\n\n        # Add total if not already done\n        if \"total\" not in legend_entries:\n            yy = peff[\"total\"][key]\n            total_line, = ax.plot(xx, yy, \"r\", linewidth=lw, markersize=msize)\n            lines.append(total_line)\n            legend_entries.append(\"total\")\n\n        ax.legend(lines, legend_entries, loc=\"best\", shadow=True)\n\n        #ax.set_title(title)\n        ax.set_xlabel('Total_NCPUs')\n        ax.set_ylabel('Efficiency')\n        ax.grid(True)\n\n        # Set xticks and labels.\n        labels = [\"MPI=%d, OMP=%d\" % (t.mpi_nprocs, t.omp_nthreads) for t in timers]\n        ax.set_xticks(xx)\n        ax.set_xticklabels(labels, fontdict=None, minor=False, rotation=15)\n\n        return fig"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nplots pie charts of the different timers.", "response": "def plot_pie(self, key=\"wall_time\", minfract=0.05, **kwargs):\n        \"\"\"\n        Plot pie charts of the different timers.\n\n        Args:\n            key: Keyword used to extract data from timers.\n            minfract: Don't show sections whose relative weight is less that minfract.\n\n        Returns:\n            `matplotlib` figure\n        \"\"\"\n        timers = self.timers()\n        n = len(timers)\n\n        # Make square figures and axes\n        import matplotlib.pyplot as plt\n        from matplotlib.gridspec import GridSpec\n        fig = plt.gcf()\n        gspec = GridSpec(n, 1)\n        for idx, timer in enumerate(timers):\n            ax = plt.subplot(gspec[idx, 0])\n            ax.set_title(str(timer))\n            timer.pie(ax=ax, key=key, minfract=minfract, show=False)\n\n        return fig"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nplot the stacked histogram of the different timers.", "response": "def plot_stacked_hist(self, key=\"wall_time\", nmax=5, ax=None, **kwargs):\n        \"\"\"\n        Plot stacked histogram of the different timers.\n\n        Args:\n            key: Keyword used to extract data from the timers. Only the first `nmax`\n                sections with largest value are show.\n            mmax: Maximum nuber of sections to show. Other entries are grouped together\n                in the `others` section.\n            ax: matplotlib :class:`Axes` or None if a new figure should be created.\n\n        Returns:\n            `matplotlib` figure\n        \"\"\"\n        ax, fig, plt = get_ax_fig_plt(ax=ax)\n\n        mpi_rank = \"0\"\n        timers = self.timers(mpi_rank=mpi_rank)\n        n = len(timers)\n\n        names, values = [], []\n        rest = np.zeros(n)\n\n        for idx, sname in enumerate(self.section_names(ordkey=key)):\n            sections = self.get_sections(sname)\n            svals = np.asarray([s.__dict__[key] for s in sections])\n            if idx < nmax:\n                names.append(sname)\n                values.append(svals)\n            else:\n                rest += svals\n\n        names.append(\"others (nmax=%d)\" % nmax)\n        values.append(rest)\n\n        # The dataset is stored in values. Now create the stacked histogram.\n        ind = np.arange(n) # the locations for the groups\n        width = 0.35       # the width of the bars\n        colors = nmax * ['r', 'g', 'b', 'c', 'k', 'y', 'm']\n\n        bars = []\n        bottom = np.zeros(n)\n        for idx, vals in enumerate(values):\n            color = colors[idx]\n            bar = ax.bar(ind, vals, width, color=color, bottom=bottom)\n            bars.append(bar)\n            bottom += vals\n\n        ax.set_ylabel(key)\n        ax.set_title(\"Stacked histogram with the %d most important sections\" % nmax)\n\n        ticks = ind + width / 2.0\n        labels = [\"MPI=%d, OMP=%d\" % (t.mpi_nprocs, t.omp_nthreads) for t in timers]\n        ax.set_xticks(ticks)\n        ax.set_xticklabels(labels, rotation=15)\n\n        # Add legend.\n        ax.legend([bar[0] for bar in bars], names, loc=\"best\")\n\n        return fig"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncalling all plot methods provided by the parser.", "response": "def plot_all(self, show=True, **kwargs):\n        \"\"\"\n        Call all plot methods provided by the parser.\n        \"\"\"\n        figs = []; app = figs.append\n        app(self.plot_stacked_hist(show=show))\n        app(self.plot_efficiency(show=show))\n        app(self.plot_pie(show=show))\n        return figs"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef to_csvline(self, with_header=False):\n        string = \"\"\n\n        if with_header:\n            string += \"# \" + \" \".join(at for at in AbinitTimerSection.FIELDS) + \"\\n\"\n\n        string += \", \".join(str(v) for v in self.to_tuple()) + \"\\n\"\n        return string", "response": "Return a string with data in CSV format"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nwrite data on file fileobj using CSV format.", "response": "def to_csv(self, fileobj=sys.stdout):\n        \"\"\"Write data on file fileobj using CSV format.\"\"\"\n        openclose = is_string(fileobj)\n\n        if openclose:\n            fileobj = open(fileobj, \"w\")\n\n        for idx, section in enumerate(self.sections):\n            fileobj.write(section.to_csvline(with_header=(idx == 0)))\n        fileobj.flush()\n\n        if openclose:\n            fileobj.close()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef to_table(self, sort_key=\"wall_time\", stop=None):\n        table = [list(AbinitTimerSection.FIELDS), ]\n        ord_sections = self.order_sections(sort_key)\n\n        if stop is not None:\n            ord_sections = ord_sections[:stop]\n\n        for osect in ord_sections:\n            row = [str(item) for item in osect.to_tuple()]\n            table.append(row)\n\n        return table", "response": "Return a list of lists with timer data"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_dataframe(self, sort_key=\"wall_time\", **kwargs):\n        import pandas as pd\n        frame = pd.DataFrame(columns=AbinitTimerSection.FIELDS)\n\n        for osect in self.order_sections(sort_key):\n            frame = frame.append(osect.to_dict(), ignore_index=True)\n\n        # Monkey patch\n        frame.info =  self.info\n        frame.cpu_time =  self.cpu_time\n        frame.wall_time =  self.wall_time\n        frame.mpi_nprocs =  self.mpi_nprocs\n        frame.omp_nthreads =  self.omp_nthreads\n        frame.mpi_rank =  self.mpi_rank\n        frame.fname =  self.fname\n\n        return frame", "response": "Return a pandas DataFrame with entries sorted according to sort_key."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_values(self, keys):\n        if is_string(keys):\n            return [s.__dict__[keys] for s in self.sections]\n        else:\n            values = []\n            for k in keys:\n                values.append([s.__dict__[k] for s in self.sections])\n            return values", "response": "Return a list of values associated to a particular list of keys."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the names and values of the entries whose value [ key ] is < minval or whose fraction [ key ] is < minfract.", "response": "def names_and_values(self, key, minval=None, minfract=None, sorted=True):\n        \"\"\"\n        Select the entries whose value[key] is >= minval or whose fraction[key] is >= minfract\n        Return the names of the sections and the corresponding values.\n        \"\"\"\n        values = self.get_values(key)\n        names = self.get_values(\"name\")\n\n        new_names, new_values = [], []\n        other_val = 0.0\n\n        if minval is not None:\n            assert minfract is None\n\n            for n, v in zip(names, values):\n                if v >= minval:\n                    new_names.append(n)\n                    new_values.append(v)\n                else:\n                    other_val += v\n\n            new_names.append(\"below minval \" + str(minval))\n            new_values.append(other_val)\n\n        elif minfract is not None:\n            assert minval is None\n\n            total = self.sum_sections(key)\n\n            for n, v in zip(names, values):\n                if v / total >= minfract:\n                    new_names.append(n)\n                    new_values.append(v)\n                else:\n                    other_val += v\n\n            new_names.append(\"below minfract \" + str(minfract))\n            new_values.append(other_val)\n\n        else:\n            # all values\n            new_names, new_values = names, values\n\n        if sorted:\n            # Sort new_values and rearrange new_names.\n            fsort = lambda t: t[1]\n            nandv = [nv for nv in zip(new_names, new_values)]\n            nandv.sort(key=fsort)\n            new_names, new_values = [n[0] for n in nandv], [n[1] for n in nandv]\n\n        return new_names, new_values"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef order_sections(self, key, reverse=True):\n        fsort = lambda s: s.__dict__[key]\n        return sorted(self.sections, key=fsort, reverse=reverse)", "response": "Sort sections according to the value of key."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nplot a pie chart for this timer.", "response": "def pie(self, key=\"wall_time\", minfract=0.05, ax=None, **kwargs):\n        \"\"\"\n        Plot pie chart for this timer.\n\n        Args:\n            key: Keyword used to extract data from the timer.\n            minfract: Don't show sections whose relative weight is less that minfract.\n            ax: matplotlib :class:`Axes` or None if a new figure should be created.\n\n        Returns:\n            `matplotlib` figure\n        \"\"\"\n        ax, fig, plt = get_ax_fig_plt(ax=ax)\n        # Set aspect ratio to be equal so that pie is drawn as a circle.\n        ax.axis(\"equal\")\n        # Don't show section whose value is less that minfract\n        labels, vals = self.names_and_values(key, minfract=minfract)\n        ax.pie(vals, explode=None, labels=labels, autopct='%1.1f%%', shadow=True)\n        return fig"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_atoms(structure, **kwargs):\n        if not structure.is_ordered:\n            raise ValueError(\"ASE Atoms only supports ordered structures\")\n        symbols = [str(site.specie.symbol) for site in structure]\n        positions = [site.coords for site in structure]\n        cell = structure.lattice.matrix\n        return Atoms(symbols=symbols, positions=positions, pbc=True,\n                     cell=cell, **kwargs)", "response": "Returns ASE Atoms object from pymatgen. core. structure. Structure object"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_structure(atoms, cls=None):\n        symbols = atoms.get_chemical_symbols()\n        positions = atoms.get_positions()\n        lattice = atoms.get_cell()\n\n        cls = Structure if cls is None else cls\n        return cls(lattice, symbols, positions,\n                   coords_are_cartesian=True)", "response": "Returns pymatgen. core. structure. Structure object from ASE Atoms object"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_smeared_densities(self, sigma):\n\n        from scipy.ndimage.filters import gaussian_filter1d\n        diff = [self.frequencies[i + 1] - self.frequencies[i]\n                for i in range(len(self.frequencies) - 1)]\n        avgdiff = sum(diff) / len(diff)\n\n        smeared_dens = gaussian_filter1d(self.densities, sigma / avgdiff)\n        return smeared_dens", "response": "Returns the densities but with a Gaussian smearing of the standard dev sigma applied."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a dict representation of the object.", "response": "def as_dict(self):\n        \"\"\"\n        Json-serializable dict representation of PhononDos.\n        \"\"\"\n        return {\"@module\": self.__class__.__module__,\n                \"@class\": self.__class__.__name__,\n                \"frequencies\": list(self.frequencies),\n                \"densities\": list(self.densities)}"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef ind_zero_freq(self):\n        ind = np.searchsorted(self.frequencies, 0)\n        if ind >= len(self.frequencies):\n            raise ValueError(\"No positive frequencies found\")\n        return ind", "response": "Returns the index of the first point for which the frequencies are equal or greater than zero."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncalculating the Constant volume specific heat C_v at a given temperature.", "response": "def cv(self, t, structure=None):\n        \"\"\"\n        Constant volume specific heat C_v at temperature T obtained from the integration of the DOS.\n        Only positive frequencies will be used.\n        Result in J/(K*mol-c). A mol-c is the abbreviation of a mole-cell, that is, the number\n        of Avogadro times the atoms in a unit cell. To compare with experimental data the result\n        should be divided by the number of unit formulas in the cell. If the structure is provided\n        the division is performed internally and the result is in J/(K*mol)\n\n        Args:\n            t: a temperature in K\n            structure: the structure of the system. If not None it will be used to determine the numer of\n                formula units\n        Returns:\n            Constant volume specific heat C_v\n        \"\"\"\n\n        if t == 0:\n            return 0\n\n        freqs = self._positive_frequencies\n        dens = self._positive_densities\n\n        csch2 = lambda x: 1.0 / (np.sinh(x) ** 2)\n\n        wd2kt = freqs / (2 * BOLTZ_THZ_PER_K * t)\n        cv = np.trapz(wd2kt ** 2 * csch2(wd2kt) * dens, x=freqs)\n        cv *= const.Boltzmann * const.Avogadro\n\n        if structure:\n            formula_units = structure.composition.num_atoms / structure.composition.reduced_composition.num_atoms\n            cv /= formula_units\n\n        return cv"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef entropy(self, t, structure=None):\n\n        if t == 0:\n            return 0\n\n        freqs = self._positive_frequencies\n        dens = self._positive_densities\n\n        coth = lambda x: 1.0 / np.tanh(x)\n\n        wd2kt = freqs / (2 * BOLTZ_THZ_PER_K * t)\n        s = np.trapz((wd2kt * coth(wd2kt) - np.log(2 * np.sinh(wd2kt))) * dens, x=freqs)\n\n        s *= const.Boltzmann * const.Avogadro\n\n        if structure:\n            formula_units = structure.composition.num_atoms / structure.composition.reduced_composition.num_atoms\n            s /= formula_units\n\n        return s", "response": "Returns the Vibrational entropy at temperature t obtained from the integration of the DOS."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the internal energy at a given temperature", "response": "def internal_energy(self, t, structure=None):\n        \"\"\"\n        Phonon contribution to the internal energy at temperature T obtained from the integration of the DOS.\n        Only positive frequencies will be used.\n        Result in J/mol-c. A mol-c is the abbreviation of a mole-cell, that is, the number\n        of Avogadro times the atoms in a unit cell. To compare with experimental data the result\n        should be divided by the number of unit formulas in the cell. If the structure is provided\n        the division is performed internally and the result is in J/mol\n\n        Args:\n            t: a temperature in K\n            structure: the structure of the system. If not None it will be used to determine the numer of\n                formula units\n        Returns:\n            Phonon contribution to the internal energy\n        \"\"\"\n\n        if t==0:\n            return self.zero_point_energy(structure=structure)\n\n        freqs = self._positive_frequencies\n        dens = self._positive_densities\n\n        coth = lambda x: 1.0 / np.tanh(x)\n\n        wd2kt = freqs / (2 * BOLTZ_THZ_PER_K * t)\n        e = np.trapz(freqs * coth(wd2kt) * dens, x=freqs) / 2\n\n        e *= THZ_TO_J * const.Avogadro\n\n        if structure:\n            formula_units = structure.composition.num_atoms / structure.composition.reduced_composition.num_atoms\n            e /= formula_units\n\n        return e"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the Helmholtz free energy at a given temperature.", "response": "def helmholtz_free_energy(self, t, structure=None):\n        \"\"\"\n        Phonon contribution to the Helmholtz free energy at temperature T obtained from the integration of the DOS.\n        Only positive frequencies will be used.\n        Result in J/mol-c. A mol-c is the abbreviation of a mole-cell, that is, the number\n        of Avogadro times the atoms in a unit cell. To compare with experimental data the result\n        should be divided by the number of unit formulas in the cell. If the structure is provided\n        the division is performed internally and the result is in J/mol\n\n        Args:\n            t: a temperature in K\n            structure: the structure of the system. If not None it will be used to determine the numer of\n                formula units\n        Returns:\n            Phonon contribution to the Helmholtz free energy\n        \"\"\"\n\n        if t==0:\n            return self.zero_point_energy(structure=structure)\n\n        freqs = self._positive_frequencies\n        dens = self._positive_densities\n\n        wd2kt = freqs / (2 * BOLTZ_THZ_PER_K * t)\n        f = np.trapz(np.log(2 * np.sinh(wd2kt)) * dens, x=freqs)\n\n        f *= const.Boltzmann * const.Avogadro * t\n\n        if structure:\n            formula_units = structure.composition.num_atoms / structure.composition.reduced_composition.num_atoms\n            f /= formula_units\n\n        return f"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef zero_point_energy(self, structure=None):\n\n        freqs = self._positive_frequencies\n        dens = self._positive_densities\n\n        zpe = 0.5 * np.trapz(freqs * dens, x=freqs)\n        zpe *= THZ_TO_J * const.Avogadro\n\n        if structure:\n            formula_units = structure.composition.num_atoms / structure.composition.reduced_composition.num_atoms\n            zpe /= formula_units\n\n        return zpe", "response": "Returns the zero point energy of the system. Only positive frequencies will be used."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_element_dos(self):\n\n        el_dos = {}\n        for site, atom_dos in self.pdos.items():\n            el = site.specie\n            if el not in el_dos:\n                el_dos[el] = np.array(atom_dos)\n            else:\n                el_dos[el] += np.array(atom_dos)\n        return {el: PhononDos(self.frequencies, densities)\n                for el, densities in el_dos.items()}", "response": "Get element projected Dos."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef from_dict(cls, d):\n        tdos = PhononDos.from_dict(d)\n        struct = Structure.from_dict(d[\"structure\"])\n        pdoss = {}\n        for at, pdos in zip(struct, d[\"pdos\"]):\n            pdoss[at] = pdos\n\n        return cls(struct, tdos, pdoss)", "response": "Returns CompleteDos object from dict representation."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsorting a dictionary by value.", "response": "def sort_dict(d, key=None, reverse=False):\n    \"\"\"\n    Sorts a dict by value.\n\n    Args:\n        d: Input dictionary\n        key: Function which takes an tuple (key, object) and returns a value to\n            compare and sort by. By default, the function compares the values\n            of the dict i.e. key = lambda t : t[1]\n        reverse: Allows to reverse sort order.\n\n    Returns:\n        OrderedDict object whose keys are ordered according to their value.\n    \"\"\"\n    kv_items = [kv for kv in d.items()]\n\n    # Sort kv_items according to key.\n    if key is None:\n        kv_items.sort(key=lambda t: t[1], reverse=reverse)\n    else:\n        kv_items.sort(key=key, reverse=reverse)\n\n    # Build ordered dict.\n    return collections.OrderedDict(kv_items)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef min_max_indexes(seq):\n    l = sorted(enumerate(seq), key=lambda s: s[1])\n    return l[0][0], l[-1][0]", "response": "Uses enumerate max and min to return the indices of the maximum and minimum values in a list with the minimum and maximum value"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ntrues if values are stricly increasing.", "response": "def strictly_increasing(values):\n    \"\"\"True if values are stricly increasing.\"\"\"\n    return all(x < y for x, y in zip(values, values[1:]))"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ntrues if values are stricly decreasing.", "response": "def strictly_decreasing(values):\n    \"\"\"True if values are stricly decreasing.\"\"\"\n    return all(x > y for x, y in zip(values, values[1:]))"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ntrues if values are not increasing.", "response": "def non_increasing(values):\n    \"\"\"True if values are not increasing.\"\"\"\n    return all(x >= y for x, y in zip(values, values[1:]))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef non_decreasing(values):\n    return all(x <= y for x, y in zip(values, values[1:]))", "response": "True if values are not decreasing."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef monotonic(values, mode=\"<\", atol=1.e-8):\n    if len(values) == 1:\n        return True\n\n    if mode == \">\":\n        for i in range(len(values)-1):\n            v, vp = values[i], values[i+1]\n            if abs(vp - v) > atol and vp <= v:\n                return False\n\n    elif mode == \"<\":\n        for i in range(len(values)-1):\n            v, vp = values[i], values[i+1]\n            if abs(vp - v) > atol and vp >= v:\n                return False\n\n    else:\n        raise ValueError(\"Wrong mode %s\" % str(mode))\n\n    return True", "response": "Returns True if values are monotonic."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef round_to_sigfigs(num, sigfigs):\n    if type(sigfigs) != int:\n        raise TypeError(\"Number of significant figures must be integer.\")\n    elif sigfigs < 1:\n        raise ValueError(\"Number of significant figures \"\n                         \"must be larger than zero.\")\n    elif num == 0:\n        return num\n    else:\n        prec = int(sigfigs - np.ceil(np.log10(np.absolute(num))))\n        return round(num, prec)", "response": "Rounds a number to a specific number of significant figures instead of to a specific number of significant figures."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngiving a symmetric matrix in upper triangular form as flat array indexes as : [ A_xx yy A_yy zz A_xz yz A_yy zz A_xy xz yz z z", "response": "def make_symmetric_matrix_from_upper_tri(val):\n    \"\"\"\n    Given a symmetric matrix in upper triangular matrix form as flat array indexes as:\n    [A_xx,A_yy,A_zz,A_xy,A_xz,A_yz]\n    This will generate the full matrix:\n    [[A_xx,A_xy,A_xz],[A_xy,A_yy,A_yz],[A_xz,A_yz,A_zz]\n    \"\"\"\n    idx = [0,3,4,1,5,2]\n    val = np.array(val)[idx]\n    mask = ~np.tri(3,k=-1,dtype=bool)\n    out = np.zeros((3,3),dtype=val.dtype)\n    out[mask] = val\n    out.T[mask] = val\n    return out"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef g0w0_extended_work(structure, pseudos, kppa, nscf_nband, ecuteps, ecutsigx, scf_nband, accuracy=\"normal\",\n                       spin_mode=\"polarized\", smearing=\"fermi_dirac:0.1 eV\", response_models=[\"godby\"], charge=0.0,\n                       inclvkb=2, scr_nband=None, sigma_nband=None, workdir=None, manager=None, gamma=True, nksmall=20,\n                       work_class=None, **extra_abivars):\n    \"\"\"\n    Returns a :class:`Work` object that performs G0W0 calculations for the given the material.\n\n    Args:\n        structure: Pymatgen structure.\n        pseudos: List of `Pseudo` objects.\n        scf_ Defines the sampling used for the SCF run.\n        nscf_nband: Number of bands included in the NSCF run.\n        ecuteps: Cutoff energy [Ha] for the screening matrix.\n        ecutsigx: Cutoff energy [Ha] for the exchange part of the self-energy.\n        accuracy: Accuracy of the calculation.\n        spin_mode: Spin polarization.\n        smearing: Smearing technique.\n        ppmodel: Plasmonpole technique.\n        charge: Electronic charge added to the unit cell.\n        scf_algorithm: Algorithm used for solving of the SCF cycle.\n        inclvkb: Treatment of the dipole matrix elements (see abinit variable).\n        scr_nband: Number of bands used to compute the screening (default is nscf_nband)\n        sigma_nband: Number of bands used to compute the self-energy (default is nscf_nband)\n        workdir: Working directory.\n        manager: :class:`TaskManager` instance.\n        nksamll: if not None, a DFT bandstucture calculation will be added after the sc run\n        extra_abivars: Dictionary with extra variables passed to ABINIT.\n    \"\"\"\n    # TODO: Cannot use istwfk != 1.\n\n    # all these too many options are for development only the current idea for the final version is\n    #if gamma:\n    #    scf_ksampling = KSampling.automatic_density(structure=structure, kppa=10000, chksymbreak=0, shifts=(0, 0, 0))\n    #    nscf_ksampling = KSampling.gamma_centered(kpts=(2, 2, 2))\n    #    if kppa <= 13:\n    #        nscf_ksampling = KSampling.gamma_centered(kpts=(scf_kppa, scf_kppa, scf_kppa))\n    #    else:\n    #        nscf_ksampling = KSampling.automatic_density(structure, scf_kppa, chksymbreak=0, shifts=(0, 0, 0))\n    #else:\n    #    scf_ksampling = KSampling.automatic_density(structure, scf_kppa, chksymbreak=0)\n    #    nscf_ksampling = KSampling.automatic_density(structure, scf_kppa, chksymbreak=0)\n\n    if gamma:\n        if kppa == 1:\n            scf_ksampling = KSampling.gamma_centered(kpts=(1, 1, 1))\n            nscf_ksampling = KSampling.gamma_centered(kpts=(1, 1, 1))\n        elif kppa == 2:\n            scf_ksampling = KSampling.gamma_centered(kpts=(2, 2, 2))\n            nscf_ksampling = KSampling.gamma_centered(kpts=(2, 2, 2))\n        elif kppa < 0:\n            scf_ksampling = KSampling.gamma_centered(kpts=(-kppa, -kppa, -kppa))\n            nscf_ksampling = KSampling.gamma_centered(kpts=(2, 2, 2))\n        elif kppa <= 13:\n            scf_ksampling = KSampling.gamma_centered(kpts=(kppa, kppa, kppa))\n            nscf_ksampling = KSampling.gamma_centered(kpts=(kppa, kppa, kppa))\n        else:\n            scf_ksampling = KSampling.automatic_density(structure, kppa, chksymbreak=0, shifts=(0, 0, 0))\n            nscf_ksampling = KSampling.automatic_density(structure, kppa, chksymbreak=0, shifts=(0, 0, 0))\n    else:\n        #this is the original behaviour before the devellopment of the gwwrapper\n        scf_ksampling = KSampling.automatic_density(structure, kppa, chksymbreak=0)\n        nscf_ksampling = KSampling.automatic_density(structure, kppa, chksymbreak=0)\n\n    print(scf_ksampling)\n    print(nscf_ksampling)\n\n    if \"istwfk\" not in extra_abivars:\n        extra_abivars[\"istwfk\"] = \"*1\"\n\n    scf_inputs = []\n    to_add = {}\n    #scf_nband = min(nscf_nband)\n    #print(scf_nband)\n    extra_abivars.update(to_add)\n\n    for k in extra_abivars.keys():\n        if k[-2:] == '_s':\n            var = k[:len(k)-2]\n            values = extra_abivars.pop(k)\n            to_add.update({k: values[-1]})\n            for value in values:\n                extra_abivars[var] = value\n                extra_abivars['pawecutdg'] = extra_abivars['ecut']*2\n                scf_inputs.append(ScfStrategy(structure, pseudos, scf_ksampling, accuracy=accuracy,\n                                                spin_mode=spin_mode, smearing=smearing, charge=charge,\n                                                scf_algorithm=None, nband=scf_nband, **extra_abivars))\n\n    #temporary for testing a new approach ...\n    spread_scr = False if os.path.isfile('no_spread_scr') else True\n\n    if len(scf_strategy) == 0:\n        scf_strategy.append(ScfStrategy(structure, pseudos, scf_ksampling, accuracy=accuracy, spin_mode=spin_mode,\n                                        smearing=smearing, charge=charge, scf_algorithm=None, nband=scf_nband,\n                                        **extra_abivars))\n\n\n    nscf_strategy = NscfStrategy(scf_strategy[-1], nscf_ksampling, int(max(nscf_nband)*1.1)+1,\n                                 nbdbuf=int(0.1*max(nscf_nband)), nstep=200, **extra_abivars)\n\n    if scr_nband is None:\n        scr_nband = nscf_nband\n    if sigma_nband is None:\n        sigma_nband = nscf_nband\n\n    if ecutsigx < max(ecuteps):\n        ecutsigx = max(ecuteps)\n\n    sigma_strategy = []\n\n    if 'cd' in response_models:\n        hilbert = HilbertTransform(nomegasf=100, domegasf=None, spmeth=1, nfreqre=None, freqremax=None, nfreqim=None,\n                                   freqremin=None)\n\n    for response_model in response_models:\n        for ecuteps_v in ecuteps:\n            for nscf_nband_v in nscf_nband:\n                scr_nband = nscf_nband_v\n                sigma_nband = nscf_nband_v\n                if response_model == 'cd':\n                    screening = Screening(ecuteps_v, scr_nband, w_type=\"RPA\", sc_mode=\"one_shot\", hilbert=hilbert,\n                                          ecutwfn=None, inclvkb=inclvkb)\n                    self_energy = SelfEnergy(\"gw\", \"one_shot\", sigma_nband, ecutsigx, screening, hilbert=hilbert)\n                else:\n                    ppmodel = response_model\n                    screening = Screening(ecuteps_v, scr_nband, w_type=\"RPA\", sc_mode=\"one_shot\", ecutwfn=None,\n                                          inclvkb=inclvkb)\n                    self_energy = SelfEnergy(\"gw\", \"one_shot\", sigma_nband, ecutsigx, screening, ppmodel=ppmodel,\n                                             gw_qprange=1)\n                scr_strategy = ScreeningStrategy(scf_strategy[-1], nscf_strategy, screening, **extra_abivars)\n                sigma_strategy.append(SelfEnergyStrategy(scf_strategy[-1], nscf_strategy, scr_strategy, self_energy,\n                                                         **extra_abivars))\n\n    if work_class is None: work_class = G0W0Work\n    print(work_class)\n\n    return work_class(scf_strategy, nscf_strategy, scr_strategy, sigma_strategy, workdir=workdir, manager=manager,\n                      spread_scr=spread_scr, nksmall=nksmall)", "response": "Returns a new extended work object that performs G0W0 calculations for the given structure."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a list of dictionaries describing the components of a structure in a bonded structure.", "response": "def get_structure_components(bonded_structure, inc_orientation=False,\n                             inc_site_ids=False, inc_molecule_graph=False):\n    \"\"\"\n    Gets information on the components in a bonded structure.\n\n    Correctly determines the dimensionality of all structures, regardless of\n    structure type or improper connections due to periodic boundary conditions.\n\n    Requires a StructureGraph object as input. This can be generated using one\n    of the NearNeighbor classes. For example, using the CrystalNN class::\n\n        bonded_structure = CrystalNN().get_bonded_structure(structure)\n\n    Based on the modified breadth-first-search algorithm described in:\n\n    P. Larsem, M. Pandey, M. Strange, K. W. Jacobsen, 2018, arXiv:1808.02114\n\n    Args:\n        bonded_structure (StructureGraph): A structure with bonds, represented\n            as a pymatgen structure graph. For example, generated using the\n            CrystalNN.get_bonded_structure() method.\n        inc_orientation (bool, optional): Whether to include the orientation\n            of the structure component. For surfaces, the miller index is given,\n            for one-dimensional structures, the direction of the chain is given.\n        inc_site_ids (bool, optional): Whether to include the site indices\n            of the sites in the structure component.\n        inc_molecule_graph (bool, optional): Whether to include MoleculeGraph\n            objects for zero-dimensional components.\n\n    Returns:\n        (list of dict): Information on the components in a structure as a list\n        of dictionaries with the keys:\n\n        - \"structure_graph\": A pymatgen StructureGraph object for the\n            component.\n        - \"dimensionality\": The dimensionality of the structure component as an\n            int.\n        - \"orientation\": If inc_orientation is `True`, the orientation of the\n            component as a tuple. E.g. (1, 1, 1)\n        - \"site_ids\": If inc_site_ids is `True`, the site indices of the\n            sites in the component as a tuple.\n        - \"molecule_graph\": If inc_molecule_graph is `True`, the site a\n            MoleculeGraph object for zero-dimensional components.\n    \"\"\"\n    import networkx as nx  # optional dependency therefore not top level import\n\n    comp_graphs = (bonded_structure.graph.subgraph(c) for c in\n                   nx.weakly_connected_components(bonded_structure.graph))\n\n    components = []\n    for graph in comp_graphs:\n        dimensionality, vertices = calculate_dimensionality_of_site(\n            bonded_structure, list(graph.nodes())[0], inc_vertices=True)\n\n        component = {'dimensionality': dimensionality}\n\n        if inc_orientation:\n            if dimensionality in [1, 2]:\n                vertices = np.array(vertices)\n\n                g = vertices.sum(axis=0) / vertices.shape[0]\n\n                # run singular value decomposition\n                _, _, vh = np.linalg.svd(vertices - g)\n\n                # get direction (first column is best fit line,\n                # 3rd column is unitary norm)\n                index = 2 if dimensionality == 2 else 0\n                orientation = get_integer_index(vh[index, :])\n            else:\n                orientation = None\n\n            component['orientation'] = orientation\n\n        if inc_site_ids:\n            component['site_ids'] = tuple(graph.nodes())\n\n        if inc_molecule_graph and dimensionality == 0:\n            component['molecule_graph'] = zero_d_graph_to_molecule_graph(\n                bonded_structure, graph)\n\n        component_structure = Structure.from_sites(\n            [bonded_structure.structure[n] for n in sorted(graph.nodes())])\n\n        sorted_graph = nx.convert_node_labels_to_integers(\n            graph, ordering=\"sorted\")\n        component_graph = StructureGraph(\n            component_structure,\n            graph_data=json_graph.adjacency_data(sorted_graph))\n        component['structure_graph'] = component_graph\n\n        components.append(component)\n    return components"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef calculate_dimensionality_of_site(bonded_structure, site_index,\n                                     inc_vertices=False):\n    \"\"\"\n    Calculates the dimensionality of the component containing the given site.\n\n    Implements directly the modified breadth-first-search algorithm described in\n    Algorithm 1 of:\n\n    P. Larsem, M. Pandey, M. Strange, K. W. Jacobsen, 2018, arXiv:1808.02114\n\n    Args:\n        bonded_structure (StructureGraph): A structure with bonds, represented\n            as a pymatgen structure graph. For example, generated using the\n            CrystalNN.get_bonded_structure() method.\n        site_index (int): The index of a site in the component of interest.\n        inc_vertices (bool, optional): Whether to return the vertices (site\n            images) of the component.\n\n    Returns:\n        (int or tuple): If inc_vertices is False, the dimensionality of the\n        component will be returned as an int. If inc_vertices is true, the\n        function will return a tuple of (dimensionality, vertices), where\n        vertices is a list of tuples. E.g. [(0, 0, 0), (1, 1, 1)].\n    \"\"\"\n    def neighbours(comp_index):\n        return [(s.index, s.jimage) for s\n                in bonded_structure.get_connected_sites(comp_index)]\n\n    def rank(vertices):\n        if len(vertices) == 0:\n            return -1\n        elif len(vertices) == 1:\n            return 0\n        else:\n            vertices = np.array(list(vertices))\n            return np.linalg.matrix_rank(vertices[1:] - vertices[0])\n\n    connected_sites = {i: neighbours(i) for i in\n                       range(bonded_structure.structure.num_sites)}\n\n    seen_vertices = set()\n    seen_comp_vertices = defaultdict(set)\n\n    queue = [(site_index, (0, 0, 0))]\n    while len(queue) > 0:\n        comp_i, image_i = queue.pop(0)\n\n        if (comp_i, image_i) in seen_vertices:\n            continue\n        seen_vertices.add((comp_i, image_i))\n\n        if (rank(seen_comp_vertices[comp_i].union({image_i})) >\n                rank(seen_comp_vertices[comp_i])):\n            seen_comp_vertices[comp_i].add(image_i)\n\n        for comp_j, image_j in connected_sites[comp_i]:\n\n            image_j = tuple(np.add(image_j, image_i))\n\n            if (comp_j, image_j) in seen_vertices:\n                continue\n\n            if (rank(seen_comp_vertices[comp_j].union({image_j})) >\n                    rank(seen_comp_vertices[comp_j])):\n                queue.append((comp_j, image_j))\n\n    if inc_vertices:\n        return (rank(seen_comp_vertices[site_index]),\n                list(seen_comp_vertices[site_index]))\n    else:\n        return rank(seen_comp_vertices[site_index])", "response": "Calculates the dimensionality of the component containing the given site."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef zero_d_graph_to_molecule_graph(bonded_structure, graph):\n    import networkx as nx\n    seen_indices = []\n    sites = []\n\n    start_index = list(graph.nodes())[0]\n    queue = [(start_index, (0, 0, 0),\n              bonded_structure.structure[start_index])]\n    while len(queue) > 0:\n        comp_i, image_i, site_i = queue.pop(0)\n\n        if comp_i in [x[0] for x in seen_indices]:\n            raise ValueError(\"Graph component is not 0D\")\n\n        seen_indices.append((comp_i, image_i))\n        sites.append(site_i)\n\n        for site_j in bonded_structure.get_connected_sites(\n                comp_i, jimage=image_i):\n\n            if ((site_j.index, site_j.jimage) not in seen_indices and\n                    (site_j.index, site_j.jimage, site_j.site) not in queue):\n                queue.append((site_j.index, site_j.jimage, site_j.site))\n\n    # sort the list of indices and the graph by index to make consistent\n    indices_ordering = np.argsort([x[0] for x in seen_indices])\n    sorted_sites = np.array(sites, dtype=object)[indices_ordering]\n    sorted_graph = nx.convert_node_labels_to_integers(graph, ordering=\"sorted\")\n    mol = Molecule([s.specie for s in sorted_sites],\n                   [s.coords for s in sorted_sites])\n    mol_graph = MoleculeGraph.with_edges(mol, nx.Graph(sorted_graph).edges())\n\n    return mol_graph", "response": "Converts a zero - dimensional networkx Graph object into a MoleculeGraph object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nfinding bonded atoms and returns a adjacency matrix of bonded atoms.", "response": "def find_connected_atoms(struct, tolerance=0.45, ldict=JmolNN().el_radius):\n    \"\"\"\n    Finds bonded atoms and returns a adjacency matrix of bonded atoms.\n\n    Author: \"Gowoon Cheon\"\n    Email: \"gcheon@stanford.edu\"\n\n    Args:\n        struct (Structure): Input structure\n        tolerance: length in angstroms used in finding bonded atoms. Two atoms\n            are considered bonded if (radius of atom 1) + (radius of atom 2) +\n            (tolerance) < (distance between atoms 1 and 2). Default\n            value = 0.45, the value used by JMol and Cheon et al.\n        ldict: dictionary of bond lengths used in finding bonded atoms. Values\n            from JMol are used as default\n\n    Returns:\n        (np.ndarray): A numpy array of shape (number of atoms, number of atoms);\n        If any image of atom j is bonded to atom i with periodic boundary\n        conditions, the matrix element [atom i, atom j] is 1.\n    \"\"\"\n    n_atoms = len(struct.species)\n    fc = np.array(struct.frac_coords)\n    fc_copy = np.repeat(fc[:, :, np.newaxis], 27, axis=2)\n    neighbors = np.array(list(itertools.product([0, 1, -1], [0, 1, -1], [0, 1, -1]))).T\n    neighbors = np.repeat(neighbors[np.newaxis, :, :], 1, axis=0)\n    fc_diff = fc_copy - neighbors\n    species = list(map(str, struct.species))\n    # in case of charged species\n    for i, item in enumerate(species):\n        if not item in ldict.keys():\n            species[i] = str(Specie.from_string(item).element)\n    latmat = struct.lattice.matrix\n    connected_matrix = np.zeros((n_atoms,n_atoms))\n\n    for i in range(n_atoms):\n        for j in range(i + 1, n_atoms):\n            max_bond_length = ldict[species[i]] + ldict[species[j]] + tolerance\n            frac_diff = fc_diff[j] - fc_copy[i]\n            distance_ij = np.dot(latmat.T, frac_diff)\n            # print(np.linalg.norm(distance_ij,axis=0))\n            if sum(np.linalg.norm(distance_ij, axis=0) < max_bond_length) > 0:\n                connected_matrix[i, j] = 1\n                connected_matrix[j, i] = 1\n    return connected_matrix"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef find_clusters(struct, connected_matrix):\n    n_atoms = len(struct.species)\n    if n_atoms == 0:\n        return [0, 0, 0]\n    if 0 in np.sum(connected_matrix, axis=0):\n        return [0, 1, 0]\n\n    cluster_sizes = []\n    clusters = []\n    visited = [False for item in range(n_atoms)]\n    connected_matrix += np.eye(len(connected_matrix))\n\n    def visit(atom, atom_cluster):\n        visited[atom] = True\n        new_cluster = set(np.where(connected_matrix[atom] != 0)[0]).union(atom_cluster)\n        atom_cluster = new_cluster\n        for new_atom in atom_cluster:\n            if not visited[new_atom]:\n                visited[new_atom] = True\n                atom_cluster = visit(new_atom, atom_cluster)\n        return atom_cluster\n\n    for i in range(n_atoms):\n        if not visited[i]:\n            atom_cluster = set()\n            cluster=visit(i, atom_cluster)\n            clusters.append(cluster)\n            cluster_sizes.append(len(cluster))\n\n    max_cluster = max(cluster_sizes)\n    min_cluster = min(cluster_sizes)\n    return [max_cluster, min_cluster, clusters]", "response": "This function finds bonded clusters of atoms in the structure with periodic boundary conditions."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef deviator_stress(self):\n        if not self.is_symmetric:\n            raise warnings.warn(\"The stress tensor is not symmetric, \"\n                                \"so deviator stress will not be either\")\n        return self - self.mean_stress*np.eye(3)", "response": "returns the deviator component of the stress tensor"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncalculate the first Piola - Kirchoff stress for a single object.", "response": "def piola_kirchoff_1(self, def_grad):\n        \"\"\"\n        calculates the first Piola-Kirchoff stress\n\n        Args:\n            def_grad (3x3 array-like): deformation gradient tensor\n        \"\"\"\n        if not self.is_symmetric:\n            raise ValueError(\"The stress tensor is not symmetric, \\\n                             PK stress is based on a symmetric stress tensor.\")\n        def_grad = SquareTensor(def_grad)\n        return def_grad.det*np.dot(self, def_grad.inv.trans)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef time2slurm(timeval, unit=\"s\"):\n    d, h, m, s = 24*3600, 3600, 60, 1\n\n    timeval = Time(timeval, unit).to(\"s\")\n    days, hours = divmod(timeval, d)\n    hours, minutes = divmod(hours, h)\n    minutes, secs = divmod(minutes, m)\n\n    return \"%d-%d:%d:%d\" % (days, hours, minutes, secs)", "response": "Convert a time value in the given unit to a string following the slurm convention."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconvert a time value in the given unit to a string following the PbsPro convention.", "response": "def time2pbspro(timeval, unit=\"s\"):\n    \"\"\"\n    Convert a number representing a time value in the given unit (Default: seconds)\n    to a string following the PbsPro convention: \"hours:minutes:seconds\".\n\n    >>> assert time2pbspro(2, unit=\"d\") == '48:0:0'\n    \"\"\"\n    h, m, s = 3600, 60, 1\n\n    timeval = Time(timeval, unit).to(\"s\")\n    hours, minutes = divmod(timeval, h)\n    minutes, secs = divmod(minutes, m)\n\n    return \"%d:%d:%d\" % (hours, minutes, secs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef any2mb(s):\n    if is_string(s):\n        return int(Memory.from_string(s).to(\"Mb\"))\n    else:\n        return int(s)", "response": "Convert string or number to memory in megabytes."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef max_cation_removal(self):\n\n        # how much 'spare charge' is left in the redox metals for oxidation?\n        oxid_pot = sum(\n            [(Element(spec.symbol).max_oxidation_state - spec.oxi_state) * self.comp[spec] for spec\n             in self.comp if is_redox_active_intercalation(Element(spec.symbol))])\n\n        oxid_limit = oxid_pot / self.cation_charge\n\n        #the number of A that exist in the structure for removal\n        num_cation = self.comp[Specie(self.cation.symbol, self.cation_charge)]\n\n        return min(oxid_limit, num_cation)", "response": "Maximum number of cation A that can be removed while maintaining charge - balance."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _get_max_cap_ah(self, remove, insert):\n        num_cations = 0\n        if remove:\n            num_cations += self.max_cation_removal\n        if insert:\n            num_cations += self.max_cation_insertion\n\n        return num_cations * self.cation_charge * ELECTRON_TO_AMPERE_HOURS", "response": "Get the maximum capacity in mAh for inserting and removing charged cationEntries."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_max_capgrav(self, remove=True, insert=True):\n        weight = self.comp.weight\n        if insert:\n            weight += self.max_cation_insertion * self.cation.atomic_mass\n        return self._get_max_cap_ah(remove, insert) / (weight / 1000)", "response": "Returns the maximum grav in mAh for inserting and removing a charged cation Arc Arc."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the max capacity in mAh for inserting and removing a charged cation into base structure.", "response": "def get_max_capvol(self, remove=True, insert=True, volume=None):\n        \"\"\"\n        Give max capacity in mAh/cc for inserting and removing a charged cation into base structure.\n\n        Args:\n            remove: (bool) whether to allow cation removal\n            insert: (bool) whether to allow cation insertion\n            volume: (float) volume to use for normalization (default=volume of initial structure)\n\n        Returns:\n            max vol capacity in mAh/cc\n        \"\"\"\n\n        vol = volume if volume else self.struc_oxid.volume\n        return self._get_max_cap_ah(remove, insert) * 1000 * 1E24 / (vol * const.N_A)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_removals_int_oxid(self):\n\n        # the elements that can possibly be oxidized\n        oxid_els = [Element(spec.symbol) for spec in self.comp if\n                    is_redox_active_intercalation(spec)]\n\n        numa = set()\n        for oxid_el in oxid_els:\n            numa = numa.union(self._get_int_removals_helper(self.comp.copy(), oxid_el, oxid_els, numa))\n\n        # convert from num A in structure to num A removed\n        num_cation = self.comp[Specie(self.cation.symbol, self.cation_charge)]\n        return set([num_cation - a for a in numa])", "response": "Returns a set of integer cation removals in the order of the redox metals."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncalculates the energy of a composition.", "response": "def get_energy(self, composition, strict=True):\n        \"\"\"\n        Calculates the energy of a composition.\n        \n        Args:\n            composition (Composition): input composition\n            strict (bool): Whether all potentials must be specified\n        \"\"\"\n        if strict and set(composition.keys()) > set(self.keys()):\n            s = set(composition.keys()) - set(self.keys())\n            raise ValueError(\"Potentials not specified for {}\".format(s))\n        return sum(self.get(k, 0) * v for k, v in composition.items())"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef with_edges(structure, edges):\n\n        sg = StructureGraph.with_empty_graph(structure, name=\"bonds\",\n                                             edge_weight_name=\"weight\",\n                                             edge_weight_units=\"\")\n\n        for edge, props in edges.items():\n\n            try:\n                from_index = edge[0]\n                to_index = edge[1]\n                from_image = edge[2]\n                to_image = edge[3]\n            except TypeError:\n                raise ValueError(\"Edges must be given as (from_index, to_index,\"\n                                 \" from_image, to_image) tuples\")\n\n            if props is not None:\n                if \"weight\" in props.keys():\n                    weight = props[\"weight\"]\n                    del props[\"weight\"]\n                else:\n                    weight = None\n\n                if len(props.items()) == 0:\n                    props = None\n            else:\n                weight = None\n\n            nodes = sg.graph.nodes\n            if not (from_index in nodes and to_index in nodes):\n                raise ValueError(\"Edges cannot be added if nodes are not\"\n                                 \" present in the graph. Please check your\"\n                                 \" indices.\")\n\n            sg.add_edge(from_index, to_index, from_jimage=from_image,\n                        to_jimage=to_image, weight=weight,\n                        edge_properties=props)\n\n        sg.set_node_attributes()\n        return sg", "response": "Returns a StructureGraph with the given edges added to the functional object."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a StructureGraph with local_env edges added to the structure.", "response": "def with_local_env_strategy(structure, strategy):\n        \"\"\"\n        Constructor for StructureGraph, using a strategy\n        from :Class: `pymatgen.analysis.local_env`.\n\n        :param structure: Structure object\n        :param strategy: an instance of a\n            :Class: `pymatgen.analysis.local_env.NearNeighbors` object\n        :return:\n        \"\"\"\n\n        sg = StructureGraph.with_empty_graph(structure, name=\"bonds\",\n                                             edge_weight_name=\"weight\",\n                                             edge_weight_units=\"\")\n\n        for n, neighbors in enumerate(strategy.get_all_nn_info(structure)):\n            for neighbor in neighbors:\n\n                # local_env will always try to add two edges\n                # for any one bond, one from site u to site v\n                # and another form site v to site u: this is\n                # harmless, so warn_duplicates=False\n                sg.add_edge(from_index=n,\n                            from_jimage=(0, 0, 0),\n                            to_index=neighbor['site_index'],\n                            to_jimage=neighbor['image'],\n                            weight=neighbor['weight'],\n                            warn_duplicates=False)\n\n        return sg"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd an edge from one site to another.", "response": "def add_edge(self, from_index, to_index,\n                 from_jimage=(0, 0, 0), to_jimage=None,\n                 weight=None, warn_duplicates=True,\n                 edge_properties=None):\n        \"\"\"\n        Add edge to graph.\n\n        Since physically a 'bond' (or other connection\n        between sites) doesn't have a direction, from_index,\n        from_jimage can be swapped with to_index, to_jimage.\n\n        However, images will always always be shifted so that\n        from_index < to_index and from_jimage becomes (0, 0, 0).\n\n        :param from_index: index of site connecting from\n        :param to_index: index of site connecting to\n        :param from_jimage (tuple of ints): lattice vector of periodic\n        image, e.g. (1, 0, 0) for periodic image in +x direction\n        :param to_jimage (tuple of ints): lattice vector of image\n        :param weight (float): e.g. bond length\n        :param warn_duplicates (bool): if True, will warn if\n        trying to add duplicate edges (duplicate edges will not\n        be added in either case)\n        :param edge_properties (dict): any other information to\n        store on graph edges, similar to Structure's site_properties\n        :return:\n        \"\"\"\n\n        # this is not necessary for the class to work, but\n        # just makes it neater\n        if to_index < from_index:\n            to_index, from_index = from_index, to_index\n            to_jimage, from_jimage = from_jimage, to_jimage\n\n        # constrain all from_jimages to be (0, 0, 0),\n        # initial version of this class worked even if\n        # from_jimage != (0, 0, 0), but making this\n        # assumption simplifies logic later\n        if not np.array_equal(from_jimage, (0, 0, 0)):\n            shift = from_jimage\n            from_jimage = np.subtract(from_jimage, shift)\n            to_jimage = np.subtract(to_jimage, shift)\n\n        # automatic detection of to_jimage if user doesn't specify\n        # will try and detect all equivalent images and add multiple\n        # edges if appropriate\n        if to_jimage is None:\n            # assume we want the closest site\n            warnings.warn(\"Please specify to_jimage to be unambiguous, \"\n                          \"trying to automatically detect.\")\n            dist, to_jimage = self.structure[from_index]\\\n                .distance_and_image(self.structure[to_index])\n            if dist == 0:\n                # this will happen when from_index == to_index,\n                # typically in primitive single-atom lattices\n                images = [1, 0, 0], [0, 1, 0], [0, 0, 1]\n                dists = []\n                for image in images:\n                    dists.append(self.structure[from_index]\n                                 .distance_and_image(self.structure[from_index],\n                                                                               jimage=image)[0])\n                dist = min(dists)\n            equiv_sites = self.structure.get_neighbors_in_shell(self.structure[from_index].coords,\n                                                                dist,\n                                                                dist*0.01,\n                                                                include_index=True)\n            for site, dist, to_index in equiv_sites:\n                to_jimage = np.subtract(site.frac_coords, self.structure[from_index].frac_coords)\n                to_jimage = to_jimage.astype(int)\n                self.add_edge(from_index=from_index, from_jimage=(0, 0, 0),\n                              to_jimage=to_jimage, to_index=to_index)\n            return\n\n        # sanitize types\n        from_jimage, to_jimage = tuple(map(int, from_jimage)), tuple(map(int, to_jimage))\n        from_index, to_index = int(from_index), int(to_index)\n\n        # check we're not trying to add a duplicate edge\n        # there should only ever be at most one edge\n        # between a given (site, jimage) pair and another\n        # (site, jimage) pair\n        existing_edge_data = self.graph.get_edge_data(from_index, to_index)\n        if existing_edge_data:\n            for key, d in existing_edge_data.items():\n                if d[\"to_jimage\"] == to_jimage:\n                    if warn_duplicates:\n                        warnings.warn(\"Trying to add an edge that already exists from \"\n                                      \"site {} to site {} in {}.\".format(from_index,\n                                                                         to_index,\n                                                                         to_jimage))\n                    return\n\n        # generic container for additional edge properties,\n        # similar to site properties\n        edge_properties = edge_properties or {}\n\n        if weight:\n            self.graph.add_edge(from_index, to_index,\n                                to_jimage=to_jimage,\n                                weight=weight,\n                                **edge_properties)\n        else:\n            self.graph.add_edge(from_index, to_index,\n                                to_jimage=to_jimage,\n                                **edge_properties)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nchanges the weight of an edge in the StructureGraph.", "response": "def alter_edge(self, from_index, to_index, to_jimage=None,\n                   new_weight=None, new_edge_properties=None):\n        \"\"\"\n        Alters either the weight or the edge_properties of\n        an edge in the StructureGraph.\n\n        :param from_index: int\n        :param to_index: int\n        :param to_jimage: tuple\n        :param new_weight: alter_edge does not require\n        that weight be altered. As such, by default, this\n        is None. If weight is to be changed, it should be a\n        float.\n        :param new_edge_properties: alter_edge does not require\n        that edge_properties be altered. As such, by default,\n        this is None. If any edge properties are to be changed,\n        it should be a dictionary of edge properties to be changed.\n        :return:\n        \"\"\"\n\n        existing_edges = self.graph.get_edge_data(from_index, to_index)\n\n        # ensure that edge exists before attempting to change it\n        if not existing_edges:\n            raise ValueError(\"Edge between {} and {} cannot be altered;\\\n                                no edge exists between those sites.\".format(\n                                from_index, to_index\n                                ))\n\n        if to_jimage is None:\n            edge_index = 0\n        else:\n            for i, properties in existing_edges.items():\n                if properties[\"to_jimage\"] == to_jimage:\n                    edge_index = i\n\n        if new_weight is not None:\n            self.graph[from_index][to_index][edge_index]['weight'] = new_weight\n\n        if new_edge_properties is not None:\n            for prop in list(new_edge_properties.keys()):\n                self.graph[from_index][to_index][edge_index][prop] = new_edge_properties[prop]"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nremove an edge from the StructureGraph.", "response": "def break_edge(self, from_index, to_index, to_jimage=None, allow_reverse=False):\n        \"\"\"\n        Remove an edge from the StructureGraph. If no image is given, this method will fail.\n\n        :param from_index: int\n        :param to_index: int\n        :param to_jimage: tuple\n        :param allow_reverse: If allow_reverse is True, then break_edge will\n        attempt to break both (from_index, to_index) and, failing that,\n        will attempt to break (to_index, from_index).\n        :return:\n        \"\"\"\n\n        # ensure that edge exists before attempting to remove it\n        existing_edges = self.graph.get_edge_data(from_index, to_index)\n        existing_reverse = None\n\n        if to_jimage is None:\n            raise ValueError(\"Image must be supplied, to avoid ambiguity.\")\n\n        if existing_edges:\n            for i, properties in existing_edges.items():\n                if properties[\"to_jimage\"] == to_jimage:\n                    edge_index = i\n\n            self.graph.remove_edge(from_index, to_index, edge_index)\n\n        else:\n            if allow_reverse:\n                existing_reverse = self.graph.get_edge_data(to_index, from_index)\n\n            if existing_reverse:\n                for i, properties in existing_reverse.items():\n                    if properties[\"to_jimage\"] == to_jimage:\n                        edge_index = i\n\n                self.graph.remove_edge(to_index, from_index, edge_index)\n            else:\n                raise ValueError(\"Edge cannot be broken between {} and {};\\\n                                no edge exists between those sites.\".format(\n                                from_index, to_index\n                                ))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef substitute_group(self, index, func_grp, strategy, bond_order=1,\n                         graph_dict=None, strategy_params=None):\n        \"\"\"\n        Builds off of Structure.substitute to replace an atom in self.structure\n        with a functional group. This method also amends self.graph to\n        incorporate the new functional group.\n\n        NOTE: Care must be taken to ensure that the functional group that is\n        substituted will not place atoms to close to each other, or violate the\n        dimensions of the Lattice.\n\n        :param index: Index of atom to substitute.\n        :param func_grp: Substituent molecule. There are two options:\n\n                1. Providing an actual Molecule as the input. The first atom\n                   must be a DummySpecie X, indicating the position of\n                   nearest neighbor. The second atom must be the next\n                   nearest atom. For example, for a methyl group\n                   substitution, func_grp should be X-CH3, where X is the\n                   first site and C is the second site. What the code will\n                   do is to remove the index site, and connect the nearest\n                   neighbor to the C atom in CH3. The X-C bond indicates the\n                   directionality to connect the atoms.\n                2. A string name. The molecule will be obtained from the\n                   relevant template in func_groups.json.\n        :param strategy: Class from pymatgen.analysis.local_env.\n        :param bond_order: A specified bond order to calculate the bond\n                length between the attached functional group and the nearest\n                neighbor site. Defaults to 1.\n        :param graph_dict: Dictionary representing the bonds of the functional\n                group (format: {(u, v): props}, where props is a dictionary of\n                properties, including weight. If None, then the algorithm\n                will attempt to automatically determine bonds using one of\n                a list of strategies defined in pymatgen.analysis.local_env.\n        :param strategy_params: dictionary of keyword arguments for strategy.\n                If None, default parameters will be used.\n        :return:\n        \"\"\"\n\n        def map_indices(grp):\n            grp_map = {}\n\n            # Get indices now occupied by functional group\n            # Subtracting 1 because the dummy atom X should not count\n            atoms = len(grp) - 1\n            offset = len(self.structure) - atoms\n\n            for i in range(atoms):\n                grp_map[i] = i + offset\n\n            return grp_map\n\n        if isinstance(func_grp, Molecule):\n            func_grp = copy.deepcopy(func_grp)\n        else:\n            try:\n                func_grp = copy.deepcopy(FunctionalGroups[func_grp])\n            except:\n                raise RuntimeError(\"Can't find functional group in list. \"\n                                   \"Provide explicit coordinate instead\")\n\n        self.structure.substitute(index, func_grp, bond_order=bond_order)\n\n        mapping = map_indices(func_grp)\n\n        # Remove dummy atom \"X\"\n        func_grp.remove_species(\"X\")\n\n        if graph_dict is not None:\n            for (u, v) in graph_dict.keys():\n                edge_props = graph_dict[(u, v)]\n                if \"to_jimage\" in edge_props.keys():\n                    to_jimage = edge_props[\"to_jimage\"]\n                    del edge_props[\"to_jimage\"]\n                else:\n                    # By default, assume that all edges should stay remain\n                    # inside the initial image\n                    to_jimage = (0, 0, 0)\n                if \"weight\" in edge_props.keys():\n                    weight = edge_props[\"weight\"]\n                    del edge_props[\"weight\"]\n                self.add_edge(mapping[u], mapping[v], to_jimage=to_jimage,\n                              weight=weight, edge_properties=edge_props)\n\n        else:\n            if strategy_params is None:\n                strategy_params = {}\n            strat = strategy(**strategy_params)\n\n            for site in mapping.values():\n                neighbors = strat.get_nn_info(self.structure, site)\n\n                for neighbor in neighbors:\n                    self.add_edge(from_index=site,\n                                  from_jimage=(0, 0, 0),\n                                  to_index=neighbor['site_index'],\n                                  to_jimage=neighbor['image'],\n                                  weight=neighbor['weight'],\n                                  warn_duplicates=False)", "response": "Substitute an atom in self. structure with a functional group."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a list of tuples of neighbors of site n and jimage indices and weight.", "response": "def get_connected_sites(self, n, jimage=(0, 0, 0)):\n        \"\"\"\n        Returns a named tuple of neighbors of site n:\n        periodic_site, jimage, index, weight.\n        Index is the index of the corresponding site\n        in the original structure, weight can be\n        None if not defined.\n        :param n: index of Site in Structure\n        :param jimage: lattice vector of site\n        :return: list of ConnectedSite tuples,\n        sorted by closest first\n        \"\"\"\n\n        connected_sites = set()\n        connected_site_images = set()\n\n        out_edges = [(u, v, d, 'out') for u, v, d in self.graph.out_edges(n, data=True)]\n        in_edges = [(u, v, d, 'in') for u, v, d in self.graph.in_edges(n, data=True)]\n\n        for u, v, d, dir in out_edges + in_edges:\n\n            to_jimage = d['to_jimage']\n\n            if dir == 'in':\n                u, v = v, u\n                to_jimage = np.multiply(-1, to_jimage)\n\n            to_jimage = tuple(map(int, np.add(to_jimage, jimage)))\n            site_d = self.structure[v].as_dict()\n            site_d['abc'] = np.add(site_d['abc'], to_jimage).tolist()\n            site = PeriodicSite.from_dict(site_d)\n\n            # from_site if jimage arg != (0, 0, 0)\n            relative_jimage = np.subtract(to_jimage, jimage)\n            dist = self.structure[u].distance(self.structure[v], jimage=relative_jimage)\n\n            weight = d.get('weight', None)\n\n            if (v, to_jimage) not in connected_site_images:\n\n                connected_site = ConnectedSite(site=site,\n                                               jimage=to_jimage,\n                                               index=v,\n                                               weight=weight,\n                                               dist=dist)\n\n                connected_sites.add(connected_site)\n                connected_site_images.add((v, to_jimage))\n\n        # return list sorted by closest sites first\n        connected_sites = list(connected_sites)\n        connected_sites.sort(key=lambda x: x.dist)\n\n        return connected_sites"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the number of neighbors of site n in graph terms.", "response": "def get_coordination_of_site(self, n):\n        \"\"\"\n        Returns the number of neighbors of site n.\n        In graph terms, simply returns degree\n        of node corresponding to site n.\n        :param n: index of site\n        :return (int):\n        \"\"\"\n        number_of_self_loops = sum([1 for n, v in self.graph.edges(n) if n == v])\n        return self.graph.degree(n) - number_of_self_loops"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef draw_graph_to_file(self, filename=\"graph\",\n                           diff=None,\n                           hide_unconnected_nodes=False,\n                           hide_image_edges=True,\n                           edge_colors=False,\n                           node_labels=False,\n                           weight_labels=False,\n                           image_labels=False,\n                           color_scheme=\"VESTA\",\n                           keep_dot=False,\n                           algo=\"fdp\"):\n        \"\"\"\n        Draws graph using GraphViz.\n\n        The networkx graph object itself can also be drawn\n        with networkx's in-built graph drawing methods, but\n        note that this might give misleading results for\n        multigraphs (edges are super-imposed on each other).\n\n        If visualization is difficult to interpret,\n        `hide_image_edges` can help, especially in larger\n        graphs.\n\n        :param filename: filename to output, will detect filetype\n        from extension (any graphviz filetype supported, such as\n        pdf or png)\n        :param diff (StructureGraph): an additional graph to\n        compare with, will color edges red that do not exist in diff\n        and edges green that are in diff graph but not in the\n        reference graph\n        :param hide_unconnected_nodes: if True, hide unconnected\n        nodes\n        :param hide_image_edges: if True, do not draw edges that\n        go through periodic boundaries\n        :param edge_colors (bool): if True, use node colors to\n        color edges\n        :param node_labels (bool): if True, label nodes with\n        species and site index\n        :param weight_labels (bool): if True, label edges with\n        weights\n        :param image_labels (bool): if True, label edges with\n        their periodic images (usually only used for debugging,\n        edges to periodic images always appear as dashed lines)\n        :param color_scheme (str): \"VESTA\" or \"JMOL\"\n        :param keep_dot (bool): keep GraphViz .dot file for later\n        visualization\n        :param algo: any graphviz algo, \"neato\" (for simple graphs)\n        or \"fdp\" (for more crowded graphs) usually give good outputs\n        :return:\n        \"\"\"\n\n        if not which(algo):\n            raise RuntimeError(\"StructureGraph graph drawing requires \"\n                               \"GraphViz binaries to be in the path.\")\n\n        # Developer note: NetworkX also has methods for drawing\n        # graphs using matplotlib, these also work here. However,\n        # a dedicated tool like GraphViz allows for much easier\n        # control over graph appearance and also correctly displays\n        # mutli-graphs (matplotlib can superimpose multiple edges).\n\n        g = self.graph.copy()\n\n        g.graph = {'nodesep': 10.0, 'dpi': 300, 'overlap': \"false\"}\n\n        # add display options for nodes\n        for n in g.nodes():\n\n            # get label by species name\n            label = \"{}({})\".format(str(self.structure[n].specie), n) if node_labels else \"\"\n\n            # use standard color scheme for nodes\n            c = EL_COLORS[color_scheme].get(str(self.structure[n].specie.symbol), [0, 0, 0])\n\n            # get contrasting font color\n            # magic numbers account for perceived luminescence\n            # https://stackoverflow.com/questions/1855884/determine-font-color-based-on-background-color\n            fontcolor = '#000000' if 1 - (c[0] * 0.299 + c[1] * 0.587\n                                          + c[2] * 0.114) / 255 < 0.5 else '#ffffff'\n\n            # convert color to hex string\n            color = \"#{:02x}{:02x}{:02x}\".format(c[0], c[1], c[2])\n\n            g.add_node(n, fillcolor=color, fontcolor=fontcolor, label=label,\n                       fontname=\"Helvetica-bold\", style=\"filled\", shape=\"circle\")\n\n        edges_to_delete = []\n\n        # add display options for edges\n        for u, v, k, d in g.edges(keys=True, data=True):\n\n            # retrieve from/to images, set as origin if not defined\n            to_image = d['to_jimage']\n\n            # set edge style\n            d['style'] = \"solid\"\n            if to_image != (0, 0, 0):\n                d['style'] = \"dashed\"\n                if hide_image_edges:\n                    edges_to_delete.append((u, v, k))\n\n            # don't show edge directions\n            d['arrowhead'] = \"none\"\n\n            # only add labels for images that are not the origin\n            if image_labels:\n                d['headlabel'] = \"\" if to_image == (0, 0, 0) else \"to {}\".format((to_image))\n                d['arrowhead'] = \"normal\" if d['headlabel'] else \"none\"\n\n            # optionally color edges using node colors\n            color_u = g.node[u]['fillcolor']\n            color_v = g.node[v]['fillcolor']\n            d['color_uv'] = \"{};0.5:{};0.5\".format(color_u, color_v) if edge_colors else \"#000000\"\n\n            # optionally add weights to graph\n            if weight_labels:\n                units = g.graph.get('edge_weight_units', \"\")\n                if d.get('weight'):\n                    d['label'] = \"{:.2f} {}\".format(d['weight'], units)\n\n            # update edge with our new style attributes\n            g.edges[u, v, k].update(d)\n\n        # optionally remove periodic image edges,\n        # these can be confusing due to periodic boundaries\n        if hide_image_edges:\n            for edge_to_delete in edges_to_delete:\n                g.remove_edge(*edge_to_delete)\n\n        # optionally hide unconnected nodes,\n        # these can appear when removing periodic edges\n        if hide_unconnected_nodes:\n            g = g.subgraph([n for n in g.degree() if g.degree()[n] != 0])\n\n        # optionally highlight differences with another graph\n        if diff:\n            diff = self.diff(diff, strict=True)\n            green_edges = []\n            red_edges = []\n            for u, v, k, d in g.edges(keys=True, data=True):\n                if (u, v, d['to_jimage']) in diff['self']:\n                    # edge has been deleted\n                    red_edges.append((u, v, k))\n                elif (u, v, d['to_jimage']) in diff['other']:\n                    # edge has been added\n                    green_edges.append((u, v, k))\n            for u, v, k in green_edges:\n                g.edges[u, v, k].update({'color_uv': '#00ff00'})\n            for u, v, k in red_edges:\n                g.edges[u, v, k].update({'color_uv': '#ff0000'})\n\n        basename, extension = os.path.splitext(filename)\n        extension = extension[1:]\n\n        write_dot(g, basename+\".dot\")\n\n        with open(filename, \"w\") as f:\n\n            args = [algo, \"-T\", extension, basename+\".dot\"]\n            rs = subprocess.Popen(args,\n                                  stdout=f,\n                                  stdin=subprocess.PIPE, close_fds=True)\n            rs.communicate()\n            if rs.returncode != 0:\n                raise RuntimeError(\"{} exited with return code {}.\".format(algo, rs.returncode))\n\n        if not keep_dot:\n            os.remove(basename+\".dot\")", "response": "Draw a graph to a file."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef types_and_weights_of_connections(self):\n        def get_label(u, v):\n            u_label = self.structure[u].species_string\n            v_label = self.structure[v].species_string\n            return \"-\".join(sorted((u_label, v_label)))\n\n        types = defaultdict(list)\n        for u, v, d in self.graph.edges(data=True):\n            label = get_label(u, v)\n            types[label].append(d['weight'])\n\n        return dict(types)", "response": "Extract a dictionary summarizing the types and weights of the edges in the graph."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef weight_statistics(self):\n\n        all_weights = [d.get('weight', None) for u, v, d\n                       in self.graph.edges(data=True)]\n        stats = describe(all_weights, nan_policy='omit')\n\n        return {\n            'all_weights': all_weights,\n            'min': stats.minmax[0],\n            'max': stats.minmax[1],\n            'mean': stats.mean,\n            'variance': stats.variance\n        }", "response": "Extract a statistical summary of edge weights present in\n           "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nextract information on the different co - ordination environments present in the graph.", "response": "def types_of_coordination_environments(self, anonymous=False):\n        \"\"\"\n        Extract information on the different co-ordination environments\n        present in the graph.\n\n        :param anonymous: if anonymous, will replace specie names\n        with A, B, C, etc.\n        :return: a list of co-ordination environments,\n        e.g. ['Mo-S(6)', 'S-Mo(3)']\n        \"\"\"\n\n        motifs = set()\n        for idx, site in enumerate(self.structure):\n\n            centre_sp = site.species_string\n\n            connected_sites = self.get_connected_sites(idx)\n            connected_species = [connected_site.site.species_string\n                                 for connected_site in connected_sites]\n\n            labels = []\n            for sp in set(connected_species):\n                count = connected_species.count(sp)\n                labels.append((count, sp))\n\n            labels = sorted(labels, reverse=True)\n\n            if anonymous:\n                mapping = {centre_sp: 'A'}\n                available_letters = [chr(66+i) for i in range(25)]\n                for label in labels:\n                    sp = label[1]\n                    if sp not in mapping:\n                        mapping[sp] = available_letters.pop(0)\n                centre_sp = 'A'\n                labels = [(label[0], mapping[label[1]]) for label in labels]\n\n            labels = [\"{}({})\".format(label[1], label[0]) for label in labels]\n            motif = '{}-{}'.format(centre_sp, ','.join(labels))\n            motifs.add(motif)\n\n        return sorted(list(motifs))"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates a new object from a dictionary.", "response": "def from_dict(cls, d):\n        \"\"\"\n        As in :Class: `pymatgen.core.Structure` except\n        restoring graphs using `from_dict_of_dicts`\n        from NetworkX to restore graph information.\n        \"\"\"\n        s = Structure.from_dict(d['structure'])\n        return cls(s, d['graphs'])"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nsort the structure in - place.", "response": "def sort(self, key=None, reverse=False):\n        \"\"\"\n        Same as Structure.sort(), also remaps nodes in graph.\n        :param key:\n        :param reverse:\n        :return:\n        \"\"\"\n\n        old_structure = self.structure.copy()\n\n        # sort Structure\n        self.structure._sites = sorted(self.structure._sites, key=key, reverse=reverse)\n\n        # apply Structure ordering to graph\n        mapping = {idx:self.structure.index(site) for idx, site in enumerate(old_structure)}\n        self.graph = nx.relabel_nodes(self.graph, mapping, copy=True)\n\n        # normalize directions of edges\n        edges_to_remove = []\n        edges_to_add = []\n        for u, v, k, d in self.graph.edges(keys=True, data=True):\n            if v < u:\n                new_v, new_u, new_d = u, v, d.copy()\n                new_d['to_jimage'] = tuple(np.multiply(-1, d['to_jimage']).astype(int))\n                edges_to_remove.append((u, v, k))\n                edges_to_add.append((new_u, new_v, new_d))\n\n        # add/delete marked edges\n        for edges_to_remove in edges_to_remove:\n            self.graph.remove_edge(*edges_to_remove)\n        for (u, v, d) in edges_to_add:\n            self.graph.add_edge(u, v, **d)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncompare two StructureGraphs and returns a dictionary with keys self and other and edges that are present in only one StructureGraph and edges that are present in both StructureGraphs and both are both present in only one StructureGraph.", "response": "def diff(self, other, strict=True):\n        \"\"\"\n        Compares two StructureGraphs. Returns dict with\n        keys 'self', 'other', 'both' with edges that are\n        present in only one StructureGraph ('self' and\n        'other'), and edges that are present in both.\n\n        The Jaccard distance is a simple measure of the\n        dissimilarity between two StructureGraphs (ignoring\n        edge weights), and is defined by 1 - (size of the\n        intersection / size of the union) of the sets of\n        edges. This is returned with key 'dist'.\n\n        Important note: all node indices are in terms\n        of the StructureGraph this method is called\n        from, not the 'other' StructureGraph: there\n        is no guarantee the node indices will be the\n        same if the underlying Structures are ordered\n        differently.\n\n        :param other: StructureGraph\n        :param strict: if False, will compare bonds\n        from different Structures, with node indices\n        replaced by Specie strings, will not count\n        number of occurrences of bonds\n        :return:\n        \"\"\"\n\n        if self.structure != other.structure and strict:\n            return ValueError(\"Meaningless to compare StructureGraphs if \"\n                              \"corresponding Structures are different.\")\n\n        if strict:\n\n            # sort for consistent node indices\n            # PeriodicSite should have a proper __hash__() value,\n            # using its frac_coords as a convenient key\n            mapping = {tuple(site.frac_coords):self.structure.index(site) for site in other.structure}\n            other_sorted = other.__copy__()\n            other_sorted.sort(key=lambda site: mapping[tuple(site.frac_coords)])\n\n            edges = {(u, v, d['to_jimage'])\n                     for u, v, d in self.graph.edges(keys=False, data=True)}\n\n            edges_other = {(u, v, d['to_jimage'])\n                           for u, v, d in other_sorted.graph.edges(keys=False, data=True)}\n\n        else:\n\n            edges = {(str(self.structure[u].specie),\n                      str(self.structure[v].specie))\n                     for u, v, d in self.graph.edges(keys=False, data=True)}\n\n            edges_other = {(str(other.structure[u].specie),\n                            str(other.structure[v].specie))\n                           for u, v, d in other.graph.edges(keys=False, data=True)}\n\n        if len(edges) == 0 and len(edges_other) == 0:\n            jaccard_dist = 0  # by definition\n        else:\n            jaccard_dist = 1 - len(edges.intersection(edges_other)) / len(edges.union(edges_other))\n\n        return {\n            'self': edges - edges_other,\n            'other': edges_other - edges,\n            'both': edges.intersection(edges_other),\n            'dist': jaccard_dist\n        }"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_subgraphs_as_molecules(self, use_weights=False):\n\n        # creating a supercell is an easy way to extract\n        # molecules (and not, e.g., layers of a 2D crystal)\n        # without adding extra logic\n        if getattr(self, '_supercell_sg', None) is None:\n            self._supercell_sg = supercell_sg = self*(3,3,3)\n\n        # make undirected to find connected subgraphs\n        supercell_sg.graph = nx.Graph(supercell_sg.graph)\n\n        # find subgraphs\n        all_subgraphs = list(nx.connected_component_subgraphs(supercell_sg.graph))\n\n        # discount subgraphs that lie across *supercell* boundaries\n        # these will subgraphs representing crystals\n        molecule_subgraphs = []\n        for subgraph in all_subgraphs:\n            intersects_boundary = any([d['to_jimage'] != (0, 0, 0)\n                                      for u, v, d in subgraph.edges(data=True)])\n            if not intersects_boundary:\n                molecule_subgraphs.append(subgraph)\n\n        # add specie names to graph to be able to test for isomorphism\n        for subgraph in molecule_subgraphs:\n            for n in subgraph:\n                subgraph.add_node(n, specie=str(supercell_sg.structure[n].specie))\n\n        # now define how we test for isomorphism\n        def node_match(n1, n2):\n            return n1['specie'] == n2['specie']\n        def edge_match(e1, e2):\n            if use_weights:\n                return e1['weight'] == e2['weight']\n            else:\n                return True\n\n        # prune duplicate subgraphs\n        unique_subgraphs = []\n        for subgraph in molecule_subgraphs:\n\n            already_present = [nx.is_isomorphic(subgraph, g,\n                                                node_match=node_match,\n                                                edge_match=edge_match)\n                               for g in unique_subgraphs]\n\n            if not any(already_present):\n                unique_subgraphs.append(subgraph)\n\n        # get Molecule objects for each subgraph\n        molecules = []\n        for subgraph in unique_subgraphs:\n\n            coords = [supercell_sg.structure[n].coords for n\n                      in subgraph.nodes()]\n            species = [supercell_sg.structure[n].specie for n\n                      in subgraph.nodes()]\n\n            molecule = Molecule(species, coords)\n\n            # shift so origin is at center of mass\n            molecule = molecule.get_centered_molecule()\n\n            molecules.append(molecule)\n\n        return molecules", "response": "Retrieve subgraphs as molecules useful for extracting the crystal as a list of unique Molecules."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a MoleculeGraph object with an empty graph.", "response": "def with_empty_graph(cls, molecule, name=\"bonds\",\n                         edge_weight_name=None,\n                         edge_weight_units=None):\n        \"\"\"\n        Constructor for MoleculeGraph, returns a MoleculeGraph\n        object with an empty graph (no edges, only nodes defined\n        that correspond to Sites in Molecule).\n\n        :param molecule (Molecule):\n        :param name (str): name of graph, e.g. \"bonds\"\n        :param edge_weight_name (str): name of edge weights,\n        e.g. \"bond_length\" or \"exchange_constant\"\n        :param edge_weight_units (str): name of edge weight units\n        e.g. \"\u00c5\" or \"eV\"\n        :return (MoleculeGraph):\n        \"\"\"\n\n        if edge_weight_name and (edge_weight_units is None):\n            raise ValueError(\"Please specify units associated \"\n                             \"with your edge weights. Can be \"\n                             \"empty string if arbitrary or \"\n                             \"dimensionless.\")\n\n        # construct graph with one node per site\n        # graph attributes don't change behavior of graph,\n        # they're just for book-keeping\n        graph = nx.MultiDiGraph(edge_weight_name=edge_weight_name,\n                                edge_weight_units=edge_weight_units,\n                                name=name)\n        graph.add_nodes_from(range(len(molecule)))\n\n        graph_data = json_graph.adjacency_data(graph)\n\n        return cls(molecule, graph_data=graph_data)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef with_edges(molecule, edges):\n\n        mg = MoleculeGraph.with_empty_graph(molecule, name=\"bonds\",\n                                            edge_weight_name=\"weight\",\n                                            edge_weight_units=\"\")\n\n        for edge, props in edges.items():\n\n            try:\n                from_index = edge[0]\n                to_index = edge[1]\n            except TypeError:\n                raise ValueError(\"Edges must be given as (from_index, to_index)\"\n                                 \"tuples\")\n\n            if props is not None:\n                if \"weight\" in props.keys():\n                    weight = props[\"weight\"]\n                    del props[\"weight\"]\n                else:\n                    weight = None\n\n                if len(props.items()) == 0:\n                    props = None\n            else:\n                weight = None\n\n            nodes = mg.graph.nodes\n            if not (from_index in nodes and to_index in nodes):\n                raise ValueError(\"Edges cannot be added if nodes are not\"\n                                 \" present in the graph. Please check your\"\n                                 \" indices.\")\n\n            mg.add_edge(from_index, to_index, weight=weight,\n                        edge_properties=props)\n\n        mg.set_node_attributes()\n        return mg", "response": "Returns a MoleculeGraph with the given edges added."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef with_local_env_strategy(molecule, strategy, reorder=True,\n                                extend_structure=True):\n        \"\"\"\n        Constructor for MoleculeGraph, using a strategy\n        from :Class: `pymatgen.analysis.local_env`.\n\n        :param molecule: Molecule object\n        :param strategy: an instance of a\n            :Class: `pymatgen.analysis.local_env.NearNeighbors` object\n        :param reorder: bool, representing if graph nodes need to be reordered\n            following the application of the local_env strategy\n        :param extend_structure: If True (default), then a large artificial box\n            will be placed around the Molecule, because some strategies assume\n            periodic boundary conditions.\n        :return: mg, a MoleculeGraph\n        \"\"\"\n\n        mg = MoleculeGraph.with_empty_graph(molecule, name=\"bonds\",\n                                            edge_weight_name=\"weight\",\n                                            edge_weight_units=\"\")\n\n        # NearNeighbor classes only (generally) work with structures\n        # molecules have to be boxed first\n        coords = molecule.cart_coords\n\n        if extend_structure:\n            a = max(coords[:, 0]) - min(coords[:, 0]) + 100\n            b = max(coords[:, 1]) - min(coords[:, 1]) + 100\n            c = max(coords[:, 2]) - min(coords[:, 2]) + 100\n\n            molecule = molecule.get_boxed_structure(a, b, c, no_cross=True)\n\n        for n in range(len(molecule)):\n            neighbors = strategy.get_nn_info(molecule, n)\n            for neighbor in neighbors:\n\n                # all bonds in molecules should not cross\n                # (artificial) periodic boundaries\n                if not np.array_equal(neighbor['image'], [0, 0, 0]):\n                    continue\n\n                # local_env will always try to add two edges\n                # for any one bond, one from site u to site v\n                # and another form site v to site u: this is\n                # harmless, so warn_duplicates=False\n                mg.add_edge(from_index=n,\n                            to_index=neighbor['site_index'],\n                            weight=neighbor['weight'],\n                            warn_duplicates=False)\n\n        if reorder:\n            # Reverse order of nodes to match with molecule\n            n = len(mg.molecule)\n            mapping = {i: (n-i) for i in range(n)}\n            mapping = {i: (j-1) for i, j in mapping.items()}\n\n            mg.graph = nx.relabel_nodes(mg.graph, mapping)\n\n        duplicates = []\n        for edge in mg.graph.edges:\n            if edge[2] != 0:\n                duplicates.append(edge)\n\n        for duplicate in duplicates:\n            mg.graph.remove_edge(duplicate[0], duplicate[1], key=duplicate[2])\n\n        mg.set_node_attributes()\n        return mg", "response": "Returns a MoleculeGraph with a local_env strategy."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef add_edge(self, from_index, to_index,\n                 weight=None, warn_duplicates=True,\n                 edge_properties=None):\n        \"\"\"\n        Add edge to graph.\n\n        Since physically a 'bond' (or other connection\n        between sites) doesn't have a direction, from_index,\n        from_jimage can be swapped with to_index, to_jimage.\n\n        However, images will always always be shifted so that\n        from_index < to_index and from_jimage becomes (0, 0, 0).\n\n        :param from_index: index of site connecting from\n        :param to_index: index of site connecting to\n        :param weight (float): e.g. bond length\n        :param warn_duplicates (bool): if True, will warn if\n        trying to add duplicate edges (duplicate edges will not\n        be added in either case)\n        :param edge_properties (dict): any other information to\n        store on graph edges, similar to Structure's site_properties\n        :return:\n        \"\"\"\n\n        # this is not necessary for the class to work, but\n        # just makes it neater\n        if to_index < from_index:\n            to_index, from_index = from_index, to_index\n\n        # sanitize types\n        from_index, to_index = int(from_index), int(to_index)\n\n        # check we're not trying to add a duplicate edge\n        # there should only ever be at most one edge\n        # between two sites\n        existing_edge_data = self.graph.get_edge_data(from_index, to_index)\n        if existing_edge_data and warn_duplicates:\n            warnings.warn(\"Trying to add an edge that already exists from \"\n                            \"site {} to site {}.\".format(from_index,\n                                                         to_index))\n            return\n\n        # generic container for additional edge properties,\n        # similar to site properties\n        edge_properties = edge_properties or {}\n\n        if weight:\n            self.graph.add_edge(from_index, to_index,\n                                weight=weight,\n                                **edge_properties)\n        else:\n            self.graph.add_edge(from_index, to_index,\n                                **edge_properties)", "response": "Add an edge from one site to another."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ninsert a node into the MoleculeGraph.", "response": "def insert_node(self, i, species, coords, validate_proximity=False,\n                    site_properties=None, edges=None):\n        \"\"\"\n        A wrapper around Molecule.insert(), which also incorporates the new\n        site into the MoleculeGraph.\n\n        :param i: Index at which to insert the new site\n        :param species: Species for the new site\n        :param coords: 3x1 array representing coordinates of the new site\n        :param validate_proximity: For Molecule.insert(); if True (default\n            False), distance will be checked to ensure that site can be safely\n            added.\n        :param site_properties: Site properties for Molecule\n        :param edges: List of dicts representing edges to be added to the\n            MoleculeGraph. These edges must include the index of the new site i,\n            and all indices used for these edges should reflect the\n            MoleculeGraph AFTER the insertion, NOT before. Each dict should at\n            least have a \"to_index\" and \"from_index\" key, and can also have a\n            \"weight\" and a \"properties\" key.\n        :return:\n        \"\"\"\n\n        self.molecule.insert(i, species, coords,\n                             validate_proximity=validate_proximity,\n                             properties=site_properties)\n\n        mapping = {}\n        for j in range(len(self.molecule) - 1):\n            if j < i:\n                mapping[j] = j\n            else:\n                mapping[j] = j + 1\n        nx.relabel_nodes(self.graph, mapping, copy=False)\n\n        self.graph.add_node(i)\n        self.set_node_attributes()\n\n        if edges is not None:\n            for edge in edges:\n                try:\n                    self.add_edge(edge[\"from_index\"], edge[\"to_index\"],\n                                  weight=edge.get(\"weight\", None),\n                                  edge_properties=edge.get(\"properties\", None))\n                except KeyError:\n                    raise RuntimeError(\"Some edges are invalid.\")"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset the node attributes of the MoleculeGraph to the values of the species coords and properties of the nodes in the MoleculeGraph.", "response": "def set_node_attributes(self):\n        \"\"\"\n        Replicates molecule site properties (specie, coords, etc.) in the\n        MoleculeGraph.\n\n        :return:\n        \"\"\"\n\n        species = {}\n        coords = {}\n        properties = {}\n        for node in self.graph.nodes():\n            species[node] = self.molecule[node].specie.symbol\n            coords[node] = self.molecule[node].coords\n            properties[node] = self.molecule[node].properties\n\n        nx.set_node_attributes(self.graph, species, \"specie\")\n        nx.set_node_attributes(self.graph, coords, \"coords\")\n        nx.set_node_attributes(self.graph, properties, \"properties\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nalters either the weight or the edge_properties of an edge in the MoleculeGraph. :param from_index: int :param to_index: int :param new_weight: alter_edge does not require that weight be altered. As such, by default, this is None. If weight is to be changed, it should be a float. :param new_edge_properties: alter_edge does not require that edge_properties be altered. As such, by default, this is None. If any edge properties are to be changed, it should be a dictionary of edge properties to be changed. :return:", "response": "def alter_edge(self, from_index, to_index,\n                   new_weight=None, new_edge_properties=None):\n        \"\"\"\n        Alters either the weight or the edge_properties of\n        an edge in the MoleculeGraph.\n\n        :param from_index: int\n        :param to_index: int\n        :param new_weight: alter_edge does not require\n        that weight be altered. As such, by default, this\n        is None. If weight is to be changed, it should be a\n        float.\n        :param new_edge_properties: alter_edge does not require\n        that edge_properties be altered. As such, by default,\n        this is None. If any edge properties are to be changed,\n        it should be a dictionary of edge properties to be changed.\n        :return:\n        \"\"\"\n\n        existing_edge = self.graph.get_edge_data(from_index, to_index)\n\n        # ensure that edge exists before attempting to change it\n        if not existing_edge:\n            raise ValueError(\"Edge between {} and {} cannot be altered;\\\n                                no edge exists between those sites.\".format(\n                                from_index, to_index\n                                ))\n\n        # Third index should always be 0 because there should only be one edge between any two nodes\n        if new_weight is not None:\n            self.graph[from_index][to_index][0]['weight'] = new_weight\n\n        if new_edge_properties is not None:\n            for prop in list(new_edge_properties.keys()):\n                self.graph[from_index][to_index][0][prop] = new_edge_properties[prop]"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nremove an edge from the MoleculeGraph and returns the MoleculeGraphVersion.", "response": "def break_edge(self, from_index, to_index, allow_reverse=False):\n        \"\"\"\n        Remove an edge from the MoleculeGraph\n\n        :param from_index: int\n        :param to_index: int\n        :param allow_reverse: If allow_reverse is True, then break_edge will\n        attempt to break both (from_index, to_index) and, failing that,\n        will attempt to break (to_index, from_index).\n        :return:\n        \"\"\"\n\n        # ensure that edge exists before attempting to remove it\n        existing_edge = self.graph.get_edge_data(from_index, to_index)\n        existing_reverse = None\n\n        if existing_edge:\n            self.graph.remove_edge(from_index, to_index)\n\n        else:\n            if allow_reverse:\n                existing_reverse = self.graph.get_edge_data(to_index,\n                                                            from_index)\n\n            if existing_reverse:\n                self.graph.remove_edge(to_index, from_index)\n            else:\n                raise ValueError(\"Edge cannot be broken between {} and {};\\\n                                no edge exists between those sites.\".format(\n                                from_index, to_index\n                                ))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsplits MoleculeGraph into two or more MoleculeGraphs by breaking a set of bonds. This function uses MoleculeGraph.break_edge repeatedly to create disjoint graphs (two or more separate molecules). This function does not only alter the graph information, but also changes the underlying Moledules. If the bonds parameter does not include sufficient bonds to separate two molecule fragments, then this function will fail. Currently, this function naively assigns the charge of the total molecule to a single submolecule. A later effort will be to actually accurately assign charge. NOTE: This function does not modify the original MoleculeGraph. It creates a copy, modifies that, and returns two or more new MoleculeGraph objects. :param bonds: list of tuples (from_index, to_index) representing bonds to be broken to split the MoleculeGraph. :param alterations: a dict {(from_index, to_index): alt}, where alt is a dictionary including weight and/or edge properties to be changed following the split. :param allow_reverse: If allow_reverse is True, then break_edge will attempt to break both (from_index, to_index) and, failing that, will attempt to break (to_index, from_index). :return: list of MoleculeGraphs", "response": "def split_molecule_subgraphs(self, bonds, allow_reverse=False,\n                                 alterations=None):\n        \"\"\"\n        Split MoleculeGraph into two or more MoleculeGraphs by\n        breaking a set of bonds. This function uses\n        MoleculeGraph.break_edge repeatedly to create\n        disjoint graphs (two or more separate molecules).\n        This function does not only alter the graph\n        information, but also changes the underlying\n        Moledules.\n        If the bonds parameter does not include sufficient\n        bonds to separate two molecule fragments, then this\n        function will fail.\n        Currently, this function naively assigns the charge\n        of the total molecule to a single submolecule. A\n        later effort will be to actually accurately assign\n        charge.\n        NOTE: This function does not modify the original\n        MoleculeGraph. It creates a copy, modifies that, and\n        returns two or more new MoleculeGraph objects.\n\n        :param bonds: list of tuples (from_index, to_index)\n        representing bonds to be broken to split the MoleculeGraph.\n        :param alterations: a dict {(from_index, to_index): alt},\n        where alt is a dictionary including weight and/or edge\n        properties to be changed following the split.\n        :param allow_reverse: If allow_reverse is True, then break_edge will\n        attempt to break both (from_index, to_index) and, failing that,\n        will attempt to break (to_index, from_index).\n        :return: list of MoleculeGraphs\n        \"\"\"\n\n        self.set_node_attributes()\n\n        original = copy.deepcopy(self)\n\n        for bond in bonds:\n            original.break_edge(bond[0], bond[1], allow_reverse=allow_reverse)\n\n        if nx.is_weakly_connected(original.graph):\n            raise MolGraphSplitError(\"Cannot split molecule; \\\n                                MoleculeGraph is still connected.\")\n        else:\n\n            # alter any bonds before partition, to avoid remapping\n            if alterations is not None:\n                for (u, v) in alterations.keys():\n                    if \"weight\" in alterations[(u, v)]:\n                        weight = alterations[(u, v)][\"weight\"]\n                        del alterations[(u, v)][\"weight\"]\n                        edge_properties = alterations[(u, v)] \\\n                            if len(alterations[(u, v)]) != 0 else None\n                        original.alter_edge(u, v, new_weight=weight,\n                                        new_edge_properties=edge_properties)\n                    else:\n                        original.alter_edge(u, v,\n                                        new_edge_properties=alterations[(u, v)])\n\n            sub_mols = []\n\n            # Had to use nx.weakly_connected_components because of deprecation\n            # of nx.weakly_connected_component_subgraphs\n            components = nx.weakly_connected_components(original.graph)\n            subgraphs = [original.graph.subgraph(c) for c in components]\n\n            for subg in subgraphs:\n\n                nodes = sorted(list(subg.nodes))\n\n                # Molecule indices are essentially list-based, so node indices\n                # must be remapped, incrementing from 0\n                mapping = {}\n                for i in range(len(nodes)):\n                    mapping[nodes[i]] = i\n\n                # just give charge to whatever subgraph has node with index 0\n                # TODO: actually figure out how to distribute charge\n                if 0 in nodes:\n                    charge = self.molecule.charge\n                else:\n                    charge = 0\n\n                # relabel nodes in graph to match mapping\n                new_graph = nx.relabel_nodes(subg, mapping)\n\n                species = nx.get_node_attributes(new_graph, \"specie\")\n                coords = nx.get_node_attributes(new_graph, \"coords\")\n                raw_props = nx.get_node_attributes(new_graph, \"properties\")\n\n                properties = {}\n                for prop_set in raw_props.values():\n                    for prop in prop_set.keys():\n                        if prop in properties:\n                            properties[prop].append(prop_set[prop])\n                        else:\n                            properties[prop] = [prop_set[prop]]\n\n                # Site properties must be present for all atoms in the molecule\n                # in order to be used for Molecule instantiation\n                for k, v in properties.items():\n                    if len(v) != len(species):\n                        del properties[k]\n\n                new_mol = Molecule(species, coords, charge=charge,\n                                   site_properties=properties)\n                graph_data = json_graph.adjacency_data(new_graph)\n\n                # create new MoleculeGraph\n                sub_mols.append(MoleculeGraph(new_mol, graph_data=graph_data))\n\n            return sub_mols"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef build_unique_fragments(self):\n        self.set_node_attributes()\n\n        graph = self.graph.to_undirected()\n\n        nm = iso.categorical_node_match(\"specie\", \"ERROR\")\n\n        # find all possible fragments, aka connected induced subgraphs\n        all_fragments = []\n        for ii in range(1, len(self.molecule)):\n            for combination in combinations(graph.nodes, ii):\n                subgraph = nx.subgraph(graph, combination)\n                if nx.is_connected(subgraph):\n                    all_fragments.append(subgraph)\n\n        # narrow to all unique fragments using graph isomorphism\n        unique_fragments = []\n        for fragment in all_fragments:\n            if not [nx.is_isomorphic(fragment, f, node_match=nm)\n                    for f in unique_fragments].count(True) >= 1:\n                unique_fragments.append(fragment)\n\n        # convert back to molecule graphs\n        unique_mol_graphs = []\n        for fragment in unique_fragments:\n            mapping = {e: i for i, e in enumerate(sorted(fragment.nodes))}\n            remapped = nx.relabel_nodes(fragment, mapping)\n\n            species = nx.get_node_attributes(remapped, \"specie\")\n            coords = nx.get_node_attributes(remapped, \"coords\")\n\n            edges = {}\n\n            for from_index, to_index, key in remapped.edges:\n                edge_props = fragment.get_edge_data(from_index, to_index, key=key)\n\n                edges[(from_index, to_index)] = edge_props\n\n            unique_mol_graphs.append(self.with_edges(Molecule(species=species,\n                                                              coords=coords,\n                                                              charge=self.molecule.charge),\n                                                     edges))\n        return unique_mol_graphs", "response": "Build a list of unique fragments for the current Molecule."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsubstitutes an atom in self. molecule to a functional group.", "response": "def substitute_group(self, index, func_grp, strategy, bond_order=1,\n                         graph_dict=None, strategy_params=None, reorder=True,\n                         extend_structure=True):\n        \"\"\"\n        Builds off of Molecule.substitute to replace an atom in self.molecule\n        with a functional group. This method also amends self.graph to\n        incorporate the new functional group.\n\n        NOTE: using a MoleculeGraph will generally produce a different graph\n        compared with using a Molecule or str (when not using graph_dict).\n        This is because of the reordering that occurs when using some of the\n        local_env strategies.\n\n        :param index: Index of atom to substitute.\n        :param func_grp: Substituent molecule. There are three options:\n\n                1. Providing an actual molecule as the input. The first atom\n                   must be a DummySpecie X, indicating the position of\n                   nearest neighbor. The second atom must be the next\n                   nearest atom. For example, for a methyl group\n                   substitution, func_grp should be X-CH3, where X is the\n                   first site and C is the second site. What the code will\n                   do is to remove the index site, and connect the nearest\n                   neighbor to the C atom in CH3. The X-C bond indicates the\n                   directionality to connect the atoms.\n                2. A string name. The molecule will be obtained from the\n                   relevant template in func_groups.json.\n                3. A MoleculeGraph object.\n        :param strategy: Class from pymatgen.analysis.local_env.\n        :param bond_order: A specified bond order to calculate the bond\n                length between the attached functional group and the nearest\n                neighbor site. Defaults to 1.\n        :param graph_dict: Dictionary representing the bonds of the functional\n                group (format: {(u, v): props}, where props is a dictionary of\n                properties, including weight. If None, then the algorithm\n                will attempt to automatically determine bonds using one of\n                a list of strategies defined in pymatgen.analysis.local_env.\n        :param strategy_params: dictionary of keyword arguments for strategy.\n                If None, default parameters will be used.\n        :param reorder: bool, representing if graph nodes need to be reordered\n                following the application of the local_env strategy\n        :param extend_structure: If True (default), then a large artificial box\n                will be placed around the Molecule, because some strategies assume\n                periodic boundary conditions.\n        :return:\n        \"\"\"\n\n        def map_indices(grp):\n            grp_map = {}\n\n            # Get indices now occupied by functional group\n            # Subtracting 1 because the dummy atom X should not count\n            atoms = len(grp) - 1\n            offset = len(self.molecule) - atoms\n\n            for i in range(atoms):\n                grp_map[i] = i + offset\n\n            return grp_map\n\n        # Work is simplified if a graph is already in place\n        if isinstance(func_grp, MoleculeGraph):\n\n            self.molecule.substitute(index, func_grp.molecule,\n                                     bond_order=bond_order)\n\n            mapping = map_indices(func_grp.molecule)\n\n            for (u, v) in list(func_grp.graph.edges()):\n                edge_props = func_grp.graph.get_edge_data(u, v)[0]\n                weight = None\n                if \"weight\" in edge_props.keys():\n                    weight = edge_props[\"weight\"]\n                    del edge_props[\"weight\"]\n                self.add_edge(mapping[u], mapping[v],\n                              weight=weight, edge_properties=edge_props)\n\n        else:\n            if isinstance(func_grp, Molecule):\n                func_grp = copy.deepcopy(func_grp)\n            else:\n                try:\n                    func_grp = copy.deepcopy(FunctionalGroups[func_grp])\n                except:\n                    raise RuntimeError(\"Can't find functional group in list. \"\n                                       \"Provide explicit coordinate instead\")\n\n            self.molecule.substitute(index, func_grp, bond_order=bond_order)\n\n            mapping = map_indices(func_grp)\n\n            # Remove dummy atom \"X\"\n            func_grp.remove_species(\"X\")\n\n            if graph_dict is not None:\n                for (u, v) in graph_dict.keys():\n                    edge_props = graph_dict[(u, v)]\n                    if \"weight\" in edge_props.keys():\n                        weight = edge_props[\"weight\"]\n                        del edge_props[\"weight\"]\n                    self.add_edge(mapping[u], mapping[v],\n                                  weight=weight, edge_properties=edge_props)\n\n            else:\n                if strategy_params is None:\n                    strategy_params = {}\n                strat = strategy(**strategy_params)\n                graph = self.with_local_env_strategy(func_grp, strat, reorder=reorder,\n                                                     extend_structure=extend_structure)\n\n                for (u, v) in list(graph.graph.edges()):\n                    edge_props = graph.graph.get_edge_data(u, v)[0]\n                    weight = None\n                    if \"weight\" in edge_props.keys():\n                        weight = edge_props[\"weight\"]\n                        del edge_props[\"weight\"]\n\n                    if 0 not in list(graph.graph.nodes()):\n                        # If graph indices have different indexing\n                        u, v = (u-1), (v-1)\n\n                    self.add_edge(mapping[u], mapping[v],\n                                  weight=weight, edge_properties=edge_props)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef replace_group(self, index, func_grp, strategy, bond_order=1,\n                      graph_dict=None, strategy_params=None, reorder=True,\n                      extend_structure=True):\n        \"\"\"\n        Builds off of Molecule.substitute and MoleculeGraph.substitute_group\n        to replace a functional group in self.molecule with a functional group.\n        This method also amends self.graph to incorporate the new functional\n        group.\n\n        TODO: Figure out how to replace into a ring structure.\n\n        :param index: Index of atom to substitute.\n        :param func_grp: Substituent molecule. There are three options:\n\n                1. Providing an actual molecule as the input. The first atom\n                   must be a DummySpecie X, indicating the position of\n                   nearest neighbor. The second atom must be the next\n                   nearest atom. For example, for a methyl group\n                   substitution, func_grp should be X-CH3, where X is the\n                   first site and C is the second site. What the code will\n                   do is to remove the index site, and connect the nearest\n                   neighbor to the C atom in CH3. The X-C bond indicates the\n                   directionality to connect the atoms.\n                2. A string name. The molecule will be obtained from the\n                   relevant template in func_groups.json.\n                3. A MoleculeGraph object.\n        :param strategy: Class from pymatgen.analysis.local_env.\n        :param bond_order: A specified bond order to calculate the bond\n                length between the attached functional group and the nearest\n                neighbor site. Defaults to 1.\n        :param graph_dict: Dictionary representing the bonds of the functional\n                group (format: {(u, v): props}, where props is a dictionary of\n                properties, including weight. If None, then the algorithm\n                will attempt to automatically determine bonds using one of\n                a list of strategies defined in pymatgen.analysis.local_env.\n        :param strategy_params: dictionary of keyword arguments for strategy.\n                If None, default parameters will be used.\n        :param reorder: bool, representing if graph nodes need to be reordered\n                following the application of the local_env strategy\n        :param extend_structure: If True (default), then a large artificial box\n                will be placed around the Molecule, because some strategies assume\n                periodic boundary conditions.\n        :return:\n        \"\"\"\n\n        self.set_node_attributes()\n        neighbors = self.get_connected_sites(index)\n\n        # If the atom at index is terminal\n        if len(neighbors) == 1:\n            self.substitute_group(index, func_grp, strategy,\n                                  bond_order=bond_order, graph_dict=graph_dict,\n                                  strategy_params=strategy_params,\n                                  reorder=reorder,\n                                  extend_structure=extend_structure)\n\n        else:\n            rings = self.find_rings(including=[index])\n            if len(rings) != 0:\n                raise RuntimeError(\"Currently functional group replacement\"\n                                   \"cannot occur at an atom within a ring\"\n                                   \"structure.\")\n\n            to_remove = set()\n            sizes = dict()\n            disconnected = self.graph.to_undirected()\n            disconnected.remove_node(index)\n            for neighbor in neighbors:\n                sizes[neighbor[2]] = len(nx.descendants(disconnected, neighbor[2]))\n\n            keep = max(sizes, key=lambda x: sizes[x])\n            for i in sizes.keys():\n                if i != keep:\n                    to_remove.add(i)\n\n            self.remove_nodes(list(to_remove))\n\n            self.substitute_group(index, func_grp, strategy,\n                                  bond_order=bond_order, graph_dict=graph_dict,\n                                  strategy_params=strategy_params,\n                                  reorder=reorder,\n                                  extend_structure=extend_structure)", "response": "Substitute a functional group in self. molecule with a functional group."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef find_rings(self, including=None):\n\n        # Copies self.graph such that all edges (u, v) matched by edges (v, u)\n        undirected = self.graph.to_undirected()\n        directed = undirected.to_directed()\n\n        cycles_nodes = []\n        cycles_edges = []\n\n        # Remove all two-edge cycles\n        all_cycles = [c for c in nx.simple_cycles(directed) if len(c) > 2]\n\n        # Using to_directed() will mean that each cycle always appears twice\n        # So, we must also remove duplicates\n        unique_sorted = []\n        unique_cycles = []\n        for cycle in all_cycles:\n            if sorted(cycle) not in unique_sorted:\n                unique_sorted.append(sorted(cycle))\n                unique_cycles.append(cycle)\n\n        if including is None:\n            cycles_nodes = unique_cycles\n        else:\n            for i in including:\n                for cycle in unique_cycles:\n                    if i in cycle and cycle not in cycles_nodes:\n                        cycles_nodes.append(cycle)\n\n        for cycle in cycles_nodes:\n            edges = []\n            for i, e in enumerate(cycle):\n                edges.append((cycle[i-1], e))\n            cycles_edges.append(edges)\n\n        return cycles_edges", "response": "Find all rings in the MoleculeGraph."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a list of connected sites for a given site in the Molecule.", "response": "def get_connected_sites(self, n):\n        \"\"\"\n        Returns a named tuple of neighbors of site n:\n        periodic_site, jimage, index, weight.\n        Index is the index of the corresponding site\n        in the original structure, weight can be\n        None if not defined.\n        :param n: index of Site in Molecule\n        :param jimage: lattice vector of site\n        :return: list of ConnectedSite tuples,\n        sorted by closest first\n        \"\"\"\n\n        connected_sites = set()\n\n        out_edges = [(u, v, d) for u, v, d in self.graph.out_edges(n, data=True)]\n        in_edges = [(u, v, d) for u, v, d in self.graph.in_edges(n, data=True)]\n\n        for u, v, d in out_edges + in_edges:\n\n            weight = d.get('weight', None)\n\n            if v == n:\n                site = self.molecule[u]\n                dist = self.molecule[v].distance(self.molecule[u])\n\n                connected_site = ConnectedSite(site=site,\n                                               jimage=(0, 0, 0),\n                                               index=u,\n                                               weight=weight,\n                                               dist=dist)\n            else:\n                site = self.molecule[v]\n                dist = self.molecule[u].distance(self.molecule[v])\n\n                connected_site = ConnectedSite(site=site,\n                                               jimage=(0, 0, 0),\n                                               index=v,\n                                               weight=weight,\n                                               dist=dist)\n\n            connected_sites.add(connected_site)\n\n        # return list sorted by closest sites first\n        connected_sites = list(connected_sites)\n        connected_sites.sort(key=lambda x: x.dist)\n\n        return connected_sites"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef as_dict(self):\n\n        d = {\"@module\": self.__class__.__module__,\n             \"@class\": self.__class__.__name__,\n             \"molecule\": self.molecule.as_dict(),\n             \"graphs\": json_graph.adjacency_data(self.graph)}\n\n        return d", "response": "As in dict of dicts"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates a new Molecule object from a dictionary.", "response": "def from_dict(cls, d):\n        \"\"\"\n        As in :Class: `pymatgen.core.Molecule` except\n        restoring graphs using `from_dict_of_dicts`\n        from NetworkX to restore graph information.\n        \"\"\"\n        m = Molecule.from_dict(d['molecule'])\n        return cls(m, d['graphs'])"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsorts the Molecule object by the given key.", "response": "def sort(self, key=None, reverse=False):\n        \"\"\"\n        Same as Molecule.sort(), also remaps nodes in graph.\n        :param key:\n        :param reverse:\n        :return:\n        \"\"\"\n\n        old_molecule = self.molecule.copy()\n\n        # sort Molecule\n        self.molecule._sites = sorted(self.molecule._sites, key=key, reverse=reverse)\n\n        # apply Molecule ordering to graph\n        mapping = {idx: self.molecule.index(site) for idx, site in enumerate(old_molecule)}\n        self.graph = nx.relabel_nodes(self.graph, mapping, copy=True)\n\n        # normalize directions of edges\n        edges_to_remove = []\n        edges_to_add = []\n        for u, v, k, d in self.graph.edges(keys=True, data=True):\n            if v < u:\n                new_v, new_u, new_d = u, v, d.copy()\n                new_d['to_jimage'] = (0, 0, 0)\n                edges_to_remove.append((u, v, k))\n                edges_to_add.append((new_u, new_v, new_d))\n\n        # add/delete marked edges\n        for edges_to_remove in edges_to_remove:\n            self.graph.remove_edge(*edges_to_remove)\n        for (u, v, d) in edges_to_add:\n            self.graph.add_edge(u, v, **d)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef isomorphic_to(self, other):\n        if self.molecule.composition != other.molecule.composition:\n            return False\n        else:\n            self_undir = self.graph.to_undirected()\n            other_undir = other.graph.to_undirected()\n            nm = iso.categorical_node_match(\"specie\", \"ERROR\")\n            isomorphic = nx.is_isomorphic(self_undir, other_undir, node_match=nm)\n            return isomorphic", "response": "Checks if the graphs of two MoleculeGraphs are isomorphic to one MoleculeGraph object."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _load_bond_length_data():\n    with open(os.path.join(os.path.dirname(__file__),\n                           \"bond_lengths.json\")) as f:\n        data = collections.defaultdict(dict)\n        for row in json.load(f):\n            els = sorted(row['elements'])\n            data[tuple(els)][row['bond_order']] = row['length']\n        return data", "response": "Loads bond length data from json file"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef obtain_all_bond_lengths(sp1, sp2, default_bl=None):\n    if isinstance(sp1, Element):\n        sp1 = sp1.symbol\n    if isinstance(sp2, Element):\n        sp2 = sp2.symbol\n    syms = tuple(sorted([sp1, sp2]))\n    if syms in bond_lengths:\n        return bond_lengths[syms].copy()\n    elif default_bl is not None:\n        return {1: default_bl}\n    else:\n        raise ValueError(\"No bond data for elements {} - {}\".format(*syms))", "response": "Obtain all bond lengths for all bond orders in the species."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncalculates the bond order between two species and returns the value of the bond order.", "response": "def get_bond_order(sp1, sp2, dist, tol=0.2, default_bl=None):\n    \"\"\"\n    Calculate the bond order given the distance of 2 species\n\n    Args:\n        sp1 (Specie): First specie.\n        sp2 (Specie): Second specie.\n        dist: Their distance in angstrom\n        tol (float): Relative tolerance to test. Basically, the code\n            checks if the distance between the sites is larger than\n            (1 + tol) * the longest bond distance or smaller than\n            (1 - tol) * the shortest bond distance to determine if\n            they are bonded or the distance is too short.\n            Defaults to 0.2.\n        default_bl: If a particular type of bond does not exist, use this\n            bond length (bond order = 1). If None, a ValueError will be thrown.\n\n    Returns:\n        Float value of bond order. For example, for C-C bond in benzene,\n        return 1.7.\n    \"\"\"\n    all_lengths = obtain_all_bond_lengths(sp1, sp2, default_bl)\n    # Transform bond lengths dict to list assuming bond data is successive\n    # and add an imaginary bond 0 length\n    lengths_list = [all_lengths[1] * (1 + tol)] + \\\n                   [all_lengths[idx+1] for idx in range(len(all_lengths))]\n    trial_bond_order = 0\n    while trial_bond_order < len(lengths_list):\n        if lengths_list[trial_bond_order] < dist:\n            if trial_bond_order == 0:\n                return trial_bond_order\n            else:\n                low_bl = lengths_list[trial_bond_order]\n                high_bl = lengths_list[trial_bond_order - 1]\n                return trial_bond_order - (dist - low_bl) / (high_bl - low_bl)\n        trial_bond_order += 1\n    # Distance shorter than the shortest bond length stored,\n    # check if the distance is too short\n    if dist < lengths_list[-1] * (1 - tol):  # too short\n        warnings.warn('%.2f angstrom distance is too short for %s and %s'\n                      % (dist, sp1, sp2))\n    # return the highest bond order\n    return trial_bond_order - 1"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_bond_length(sp1, sp2, bond_order=1):\n    sp1 = Element(sp1) if isinstance(sp1, str) else sp1\n    sp2 = Element(sp2) if isinstance(sp2, str) else sp2\n    try:\n        all_lengths = obtain_all_bond_lengths(sp1, sp2)\n        return all_lengths[bond_order]\n    # The ValueError is raised in `obtain_all_bond_lengths` where no bond\n    # data for both elements is found. The KeyError is raised in\n    # `__getitem__` method of `dict` builtin class where although bond data\n    # for both elements is found, the data for specified bond order does\n    # not exist. In both cases, sum of atomic radius is returned.\n    except (ValueError, KeyError):\n        warnings.warn(\"No order %d bond lengths between %s and %s found in \"\n                      \"database. Returning sum of atomic radius.\"\n                      % (bond_order, sp1, sp2))\n        return sp1.atomic_radius + sp2.atomic_radius", "response": "Get the bond length between two species."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_bond_order(self, tol=0.2, default_bl=None):\n        sp1 = list(self.site1.species.keys())[0]\n        sp2 = list(self.site2.species.keys())[0]\n        dist = self.site1.distance(self.site2)\n        return get_bond_order(sp1, sp2, dist, tol, default_bl)", "response": "Returns the bond order of the species in the species list."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ntest if two sites are bonded.", "response": "def is_bonded(site1, site2, tol=0.2, bond_order=None, default_bl=None):\n        \"\"\"\n        Test if two sites are bonded, up to a certain limit.\n        Args:\n            site1 (Site): First site\n            site2 (Site): Second site\n            tol (float): Relative tolerance to test. Basically, the code\n                checks if the distance between the sites is less than (1 +\n                tol) * typical bond distances. Defaults to 0.2, i.e.,\n                20% longer.\n            bond_order: Bond order to test. If None, the code simply checks\n                against all possible bond data. Defaults to None.\n            default_bl: If a particular type of bond does not exist, use this\n                bond length. If None, a ValueError will be thrown.\n        Returns:\n            Boolean indicating whether two sites are bonded.\n        \"\"\"\n        sp1 = list(site1.species.keys())[0]\n        sp2 = list(site2.species.keys())[0]\n        dist = site1.distance(site2)\n        syms = tuple(sorted([sp1.symbol, sp2.symbol]))\n        if syms in bond_lengths:\n            all_lengths = bond_lengths[syms]\n            if bond_order:\n                return dist < (1 + tol) * all_lengths[bond_order]\n            for v in all_lengths.values():\n                if dist < (1 + tol) * v:\n                    return True\n            return False\n        elif default_bl:\n            return dist < (1 + tol) * default_bl\n        raise ValueError(\"No bond data for elements {} - {}\".format(*syms))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef sendmail(subject, text, mailto, sender=None):\n    def user_at_host():\n        from socket import gethostname\n        return os.getlogin() + \"@\" + gethostname()\n\n    # Body of the message.\n    try:\n        sender = user_at_host() if sender is None else sender\n    except OSError:\n        sender = 'abipyscheduler@youknowwhere'\n\n    if is_string(mailto): mailto = [mailto]\n\n    from email.mime.text import MIMEText\n    mail = MIMEText(text)\n    mail[\"Subject\"] = subject\n    mail[\"From\"] = sender\n    mail[\"To\"] = \", \".join(mailto)\n\n    msg = mail.as_string()\n\n    # sendmail works much better than the python interface.\n    # Note that sendmail is available only on Unix-like OS.\n    from subprocess import Popen, PIPE\n    import sys\n\n    sendmail = which(\"sendmail\")\n    if sendmail is None: return -1\n    if sys.version_info[0] < 3:\n        p = Popen([sendmail, \"-t\"], stdin=PIPE, stderr=PIPE)\n    else:\n        # msg is string not bytes so must use universal_newlines\n        p = Popen([sendmail, \"-t\"], stdin=PIPE, stderr=PIPE, universal_newlines=True)\n\n    outdata, errdata = p.communicate(msg)\n    return len(errdata)", "response": "Send an e - mail with unix sendmail."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndeclare a env variable.", "response": "def declare_var(self, key, val):\n        \"\"\"Declare a env variable. If val is None the variable is unset.\"\"\"\n        if val is not None:\n            line = \"export \" + key + '=' + str(val)\n        else:\n            line = \"unset \" + key\n\n        self._add(line)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef declare_vars(self, d):\n        for k, v in d.items():\n            self.declare_var(k, v)", "response": "Declare the variables defined in the dictionary d."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nexports an environment variable.", "response": "def export_envar(self, key, val):\n        \"\"\"Export an environment variable.\"\"\"\n        line = \"export \" + key + \"=\" + str(val)\n        self._add(line)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nexporting the environment variables contained in the dict env.", "response": "def export_envars(self, env):\n        \"\"\"Export the environment variables contained in the dict env.\"\"\"\n        for k, v in env.items():\n            self.export_envar(k, v)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a string with the script and reset the editor if reset is True", "response": "def get_script_str(self, reset=True):\n        \"\"\"Returns a string with the script and reset the editor if reset is True\"\"\"\n        s = \"\\n\".join(l for l in self._lines)\n        if reset:\n            self.reset()\n        return s"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nrun the first task that can be executed in each workflow and updates the database.", "response": "def single_shot(self):\n        \"\"\"\n        Run the first :class:`Task` than is ready for execution.\n\n        Returns:\n            Number of jobs launched.\n        \"\"\"\n        num_launched = 0\n\n        # Get the tasks that can be executed in each workflow.\n        tasks = []\n        for work in self.flow:\n            try:\n                task = work.fetch_task_to_run()\n\n                if task is not None:\n                    tasks.append(task)\n                else:\n                    # No task found, this usually happens when we have dependencies.\n                    # Beware of possible deadlocks here!\n                    logger.debug(\"No task to run! Possible deadlock\")\n\n            except StopIteration:\n                logger.info(\"All tasks completed.\")\n\n        # Submit the tasks and update the database.\n        if tasks:\n            tasks[0].start()\n            num_launched += 1\n\n            self.flow.pickle_dump()\n\n        return num_launched"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nkeeps submitting `Tasks` until we are out of jobs or no job is ready to run. Args: max_nlaunch: Maximum number of launches. default: no limit. max_loops: Maximum number of loops sleep_time: seconds to sleep between rapidfire loop iterations Returns: The number of tasks launched.", "response": "def rapidfire(self, max_nlaunch=-1, max_loops=1, sleep_time=5):\n        \"\"\"\n        Keeps submitting `Tasks` until we are out of jobs or no job is ready to run.\n\n        Args:\n            max_nlaunch: Maximum number of launches. default: no limit.\n            max_loops: Maximum number of loops\n            sleep_time: seconds to sleep between rapidfire loop iterations\n\n        Returns:\n            The number of tasks launched.\n        \"\"\"\n        num_launched, do_exit, launched = 0, False, []\n\n        for count in range(max_loops):\n            if do_exit:\n                break\n            if count > 0:\n                time.sleep(sleep_time)\n\n            tasks = self.fetch_tasks_to_run()\n\n            # I don't know why but we receive duplicated tasks.\n            if any(task in launched for task in tasks):\n                logger.critical(\"numtasks %d already in launched list:\\n%s\" % (len(tasks), launched))\n\n            # Preventive test.\n            tasks = [t for t in tasks if t not in launched]\n\n            if not tasks:\n                continue\n\n            for task in tasks:\n                fired = task.start()\n                if fired:\n                    launched.append(task)\n                    num_launched += 1\n\n                if num_launched >= max_nlaunch > 0:\n                    logger.info('num_launched >= max_nlaunch, going back to sleep')\n                    do_exit = True\n                    break\n\n        # Update the database.\n        self.flow.pickle_dump()\n\n        return num_launched"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the list of tasks that can be submitted.", "response": "def fetch_tasks_to_run(self):\n        \"\"\"\n        Return the list of tasks that can be submitted.\n        Empty list if no task has been found.\n        \"\"\"\n        tasks_to_run = []\n\n        for work in self.flow:\n            tasks_to_run.extend(work.fetch_alltasks_to_run())\n\n        return tasks_to_run"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nread the configuration parameters from a Yaml file.", "response": "def from_file(cls, filepath):\n        \"\"\"Read the configuration parameters from a Yaml file.\"\"\"\n        with open(filepath, \"rt\") as fh:\n            return cls(**yaml.safe_load(fh))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate an istance from a string containing a YAML dictionary.", "response": "def from_string(cls, s):\n        \"\"\"Create an istance from string s containing a YAML dictionary.\"\"\"\n        stream = cStringIO(s)\n        stream.seek(0)\n        return cls(**yaml.safe_load(stream))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef from_user_config(cls):\n        # Try in the current directory.\n        path = os.path.join(os.getcwd(), cls.YAML_FILE)\n\n        if os.path.exists(path):\n            return cls.from_file(path)\n\n        # Try in the configuration directory.\n        path = os.path.join(cls.USER_CONFIG_DIR, cls.YAML_FILE)\n\n        if os.path.exists(path):\n            return cls.from_file(path)\n\n        raise cls.Error(\"Cannot locate %s neither in current directory nor in %s\" % (cls.YAML_FILE, path))", "response": "Initialize the PyFlowScheduler from the user - supplied YAML file."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add_flow(self, flow):\n        if hasattr(self, \"_flow\"):\n            raise self.Error(\"Only one flow can be added to the scheduler.\")\n\n        # Check if we are already using a scheduler to run this flow\n        flow.check_pid_file()\n        flow.set_spectator_mode(False)\n\n        # Build dirs and files (if not yet done)\n        flow.build()\n\n        with open(flow.pid_file, \"wt\") as fh:\n            fh.write(str(self.pid))\n\n        self._pid_file = flow.pid_file\n        self._flow = flow", "response": "Add an entry to the flow list."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nvalidates input parameters if customer service is on then create directory for tarball files with correct premissions for user and group.", "response": "def _validate_customer_service(self):\n        \"\"\"\n        Validate input parameters if customer service is on then\n        create directory for tarball files with correct premissions for user and group.\n        \"\"\"\n        direc = self.customer_service_dir\n        if not direc.exists:\n            mode = 0o750\n            print(\"Creating customer_service_dir %s with mode %s\" % (direc, mode))\n            direc.makedirs()\n            os.chmod(direc.path, mode)\n\n        if self.mailto is None:\n            raise RuntimeError(\"customer_service_dir requires mailto option in scheduler.yml\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef start(self):\n        self.history.append(\"Started on %s\" % time.asctime())\n        self.start_time = time.time()\n\n        if not has_apscheduler:\n            raise RuntimeError(\"Install apscheduler with pip\")\n\n        if has_sched_v3:\n            self.sched.add_job(self.callback, \"interval\", **self.sched_options)\n        else:\n            self.sched.add_interval_job(self.callback, **self.sched_options)\n\n        errors = self.flow.look_before_you_leap()\n        if errors:\n            self.exceptions.append(errors)\n            return 1\n\n        # Try to run the job immediately. If something goes wrong return without initializing the scheduler.\n        self._runem_all()\n\n        if self.exceptions:\n            self.cleanup()\n            self.send_email(msg=\"Error while trying to run the flow for the first time!\\n %s\" % self.exceptions)\n            return 1\n\n        try:\n            self.sched.start()\n            return 0\n\n        except KeyboardInterrupt:\n            self.shutdown(msg=\"KeyboardInterrupt from user\")\n            if ask_yesno(\"Do you want to cancel all the jobs in the queue? [Y/n]\"):\n                print(\"Number of jobs cancelled:\", self.flow.cancel())\n\n            self.flow.pickle_dump()\n            return -1", "response": "Starts the scheduler in a new thread. Returns 0 if success."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _runem_all(self):\n        excs = []\n        flow = self.flow\n\n        # Allow to change the manager at run-time\n        if self.use_dynamic_manager:\n            from pymatgen.io.abinit.tasks import TaskManager\n            new_manager = TaskManager.from_user_config()\n            for work in flow:\n                work.set_manager(new_manager)\n\n        nqjobs = 0\n        if self.contact_resource_manager: # and flow.TaskManager.qadapter.QTYPE == \"shell\":\n            # This call is expensive and therefore it's optional (must be activate in manager.yml)\n            nqjobs = flow.get_njobs_in_queue()\n            if nqjobs is None:\n                nqjobs = 0\n                if flow.manager.has_queue:\n                    logger.warning('Cannot get njobs_inqueue')\n        else:\n            # Here we just count the number of tasks in the flow who are running.\n            # This logic breaks down if there are multiple schedulers runnig\n            # but it's easy to implement without having to contact the resource manager.\n            nqjobs = (len(list(flow.iflat_tasks(status=flow.S_RUN))) +\n                      len(list(flow.iflat_tasks(status=flow.S_SUB))))\n\n        if nqjobs >= self.max_njobs_inqueue:\n            print(\"Too many jobs in the queue: %s. No job will be submitted.\" % nqjobs)\n            flow.check_status(show=False)\n            return\n\n        if self.max_nlaunches == -1:\n            max_nlaunch = self.max_njobs_inqueue - nqjobs\n        else:\n            max_nlaunch = min(self.max_njobs_inqueue - nqjobs, self.max_nlaunches)\n\n        # check status.\n        flow.check_status(show=False)\n\n        # This check is not perfect, we should make a list of tasks to sumbit\n        # and select only the subset so that we don't exceeed mac_ncores_used\n        # Many sections of this code should be rewritten.\n        #if self.max_ncores_used is not None and flow.ncores_used > self.max_ncores_used:\n        if self.max_ncores_used is not None and flow.ncores_allocated > self.max_ncores_used:\n            print(\"Cannot exceed max_ncores_used %s\" % self.max_ncores_used)\n            return\n\n        # Try to restart the unconverged tasks\n        # TODO: do not fire here but prepare for fireing in rapidfire\n        for task in self.flow.unconverged_tasks:\n            try:\n                logger.info(\"Flow will try restart task %s\" % task)\n                fired = task.restart()\n                if fired:\n                    self.nlaunch += 1\n                    max_nlaunch -= 1\n                    if max_nlaunch == 0:\n                        logger.info(\"Restart: too many jobs in the queue, returning\")\n                        flow.pickle_dump()\n                        return\n\n            except task.RestartError:\n                excs.append(straceback())\n\n        # Temporarily disable by MG because I don't know if fix_critical works after the\n        # introduction of the new qadapters\n        # reenabled by MsS disable things that do not work at low level\n        # fix only prepares for restarting, and sets to ready\n        if self.fix_qcritical:\n            nfixed = flow.fix_queue_critical()\n            if nfixed: print(\"Fixed %d QCritical error(s)\" % nfixed)\n\n        nfixed = flow.fix_abicritical()\n        if nfixed: print(\"Fixed %d AbiCritical error(s)\" % nfixed)\n\n        # update database\n        flow.pickle_dump()\n\n        # Submit the tasks that are ready.\n        try:\n            nlaunch = PyLauncher(flow).rapidfire(max_nlaunch=max_nlaunch, sleep_time=10)\n            self.nlaunch += nlaunch\n            if nlaunch:\n                cprint(\"[%s] Number of launches: %d\" % (time.asctime(), nlaunch), \"yellow\")\n\n        except Exception:\n            excs.append(straceback())\n\n        # check status.\n        flow.show_status()\n\n        if excs:\n            logger.critical(\"*** Scheduler exceptions:\\n *** %s\" % \"\\n\".join(excs))\n            self.exceptions.extend(excs)", "response": "This function checks the status of all tasks and runs all the tasks that can be submitted."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _callback(self):\n        if self.debug:\n            # Show the number of open file descriptors\n            print(\">>>>> _callback: Number of open file descriptors: %s\" % get_open_fds())\n\n        self._runem_all()\n\n        # Mission accomplished. Shutdown the scheduler.\n        all_ok = self.flow.all_ok\n        if all_ok:\n            return self.shutdown(msg=\"All tasks have reached S_OK. Will shutdown the scheduler and exit\")\n\n        # Handle failures.\n        err_lines = []\n\n        # Shall we send a reminder to the user?\n        delta_etime = self.get_delta_etime()\n\n        if delta_etime.total_seconds() > self.num_reminders * self.remindme_s:\n            self.num_reminders += 1\n            msg = (\"Just to remind you that the scheduler with pid %s, flow %s\\n has been running for %s \" %\n                  (self.pid, self.flow, delta_etime))\n            retcode = self.send_email(msg, tag=\"[REMINDER]\")\n\n            if retcode:\n                # Cannot send mail, shutdown now!\n                msg += (\"\\nThe scheduler tried to send an e-mail to remind the user\\n\" +\n                        \" but send_email returned %d. Error is not critical though!\" % retcode)\n                print(msg)\n                #err_lines.append(msg)\n\n        #if delta_etime.total_seconds() > self.max_etime_s:\n        #    err_lines.append(\"\\nExceeded max_etime_s %s. Will shutdown the scheduler and exit\" % self.max_etime_s)\n\n        # Too many exceptions. Shutdown the scheduler.\n        if self.num_excs > self.max_num_pyexcs:\n            msg = \"Number of exceptions %s > %s. Will shutdown the scheduler and exit\" % (\n                self.num_excs, self.max_num_pyexcs)\n            err_lines.append(boxed(msg))\n\n        # Paranoid check: disable the scheduler if we have submitted\n        # too many jobs (it might be due to some bug or other external reasons\n        # such as race conditions between difference callbacks!)\n        if self.nlaunch > self.safety_ratio * self.flow.num_tasks:\n            msg = \"Too many jobs launched %d. Total number of tasks = %s, Will shutdown the scheduler and exit\" % (\n                self.nlaunch, self.flow.num_tasks)\n            err_lines.append(boxed(msg))\n\n        # Count the number of tasks with status == S_ERROR.\n        if self.flow.num_errored_tasks > self.max_num_abierrs:\n            msg = \"Number of tasks with ERROR status %s > %s. Will shutdown the scheduler and exit\" % (\n                self.flow.num_errored_tasks, self.max_num_abierrs)\n            err_lines.append(boxed(msg))\n\n        # Test on the presence of deadlocks.\n        g = self.flow.find_deadlocks()\n        if g.deadlocked:\n            # Check the flow again so that status are updated.\n            self.flow.check_status()\n\n            g = self.flow.find_deadlocks()\n            #print(\"deadlocked:\\n\", g.deadlocked, \"\\nrunnables:\\n\", g.runnables, \"\\nrunning\\n\", g.running)\n            print(\"deadlocked:\", len(g.deadlocked), \", runnables:\", len(g.runnables), \", running:\", len(g.running))\n            if g.deadlocked and not g.runnables and not g.running:\n                err_lines.append(\"No runnable job with deadlocked tasks:\\n%s.\" % str(g.deadlocked))\n\n        if not g.runnables and not g.running:\n            # Check the flow again so that status are updated.\n            self.flow.check_status()\n            g = self.flow.find_deadlocks()\n            if not g.runnables and not g.running:\n                err_lines.append(\"No task is running and cannot find other tasks to submit.\")\n\n        # Something wrong. Quit\n        if err_lines:\n            # Cancel all jobs.\n            if self.killjobs_if_errors:\n                cprint(\"killjobs_if_errors set to 'yes' in scheduler file. Will kill jobs before exiting.\", \"yellow\")\n                try:\n                    num_cancelled = 0\n                    for task in self.flow.iflat_tasks():\n                        num_cancelled += task.cancel()\n                    cprint(\"Killed %d tasks\" % num_cancelled, \"yellow\")\n                except Exception as exc:\n                    cprint(\"Exception while trying to kill jobs:\\n%s\" % str(exc), \"red\")\n\n            self.shutdown(\"\\n\".join(err_lines))\n\n        return len(self.exceptions)", "response": "The main callback function."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef send_email(self, msg, tag=None):\n        try:\n            return self._send_email(msg, tag)\n        except:\n            self.exceptions.append(straceback())\n            return -2", "response": "Sends an e - mail before completing the shutdown. Returns 0 if success."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates a new instance of the class from a directory.", "response": "def from_dir(cls, top, workdir=None, name=None, manager=None, max_depth=2):\n        \"\"\"\n        Find all flows located withing the directory `top` and build the `BatchLauncher`.\n\n        Args:\n            top: Top level directory or list of directories.\n            workdir: Batch workdir.\n            name:\n            manager: :class:`TaskManager` object. If None, the manager is read from `manager.yml`\n                In this case the YAML file must provide the entry `batch_manager` that defined\n                the queue adapter used to submit the batch script.\n            max_depth: Search in directory only if it is N or fewer levels below top\n        \"\"\"\n        from .flows import Flow\n        def find_pickles(dirtop):\n            # Walk through each directory inside path and find the pickle database.\n            paths = []\n            for dirpath, dirnames, filenames in os.walk(dirtop):\n                fnames = [f for f in filenames if f == Flow.PICKLE_FNAME]\n                paths.extend([os.path.join(dirpath, f) for f in fnames])\n            return paths\n\n        if is_string(top):\n            pickle_paths = find_pickles(top)\n        else:\n            # List of directories.\n            pickle_paths = []\n            for p in top:\n                pickle_paths.extend(find_pickles(p))\n\n        #workdir = os.path.join(top, \"batch\") if workdir is None else workdir\n        workdir = \"batch\" if workdir is None else workdir\n        new = cls(workdir, name=name, manager=manager)\n\n        for path in pickle_paths:\n            new.add_flow(path)\n\n        return new"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef pickle_load(cls, filepath):\n        if os.path.isdir(filepath):\n            # Walk through each directory inside path and find the pickle database.\n            for dirpath, dirnames, filenames in os.walk(filepath):\n                fnames = [f for f in filenames if f == cls.PICKLE_FNAME]\n                if fnames:\n                    if len(fnames) == 1:\n                        filepath = os.path.join(dirpath, fnames[0])\n                        break  # Exit os.walk\n                    else:\n                        err_msg = \"Found multiple databases:\\n %s\" % str(fnames)\n                        raise RuntimeError(err_msg)\n            else:\n                err_msg = \"Cannot find %s inside directory %s\" % (cls.PICKLE_FNAME, filepath)\n                raise ValueError(err_msg)\n\n        with open(filepath, \"rb\") as fh:\n            new = pickle.load(fh)\n\n        # new.flows is a list of strings with the workdir of the flows (see __getstate__).\n        # Here we read the Flow from the pickle file so that we have\n        # and up-to-date version and we set the flow in visitor_mode\n        from .flows import Flow\n        flow_workdirs, new.flows = new.flows, []\n        for flow in map(Flow.pickle_load, flow_workdirs):\n            new.add_flow(flow)\n\n        return new", "response": "Loads the object from a pickle file."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef pickle_dump(self):\n        with open(os.path.join(self.workdir, self.PICKLE_FNAME), mode=\"wb\") as fh:\n            pickle.dump(self, fh)", "response": "Save the status of the object in pickle format."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadds a flow to the batchLauncher.", "response": "def add_flow(self, flow):\n        \"\"\"\n        Add a flow. Accept filepath or :class:`Flow` object. Return 1 if flow was added else 0.\n        \"\"\"\n        from .flows import Flow\n        flow = Flow.as_flow(flow)\n\n        if flow in self.flows:\n            raise self.Error(\"Cannot add same flow twice!\")\n\n        if not flow.allocated:\n            # Set the workdir of the flow here. Create a dir in self.workdir with name flow.name\n            flow_workdir = os.path.join(self.workdir, os.path.basename(flow.name))\n            if flow_workdir in (flow.workdir for flow in self.flows):\n                raise self.Error(\"Two flows have the same name and hence the same workdir!\")\n            flow.allocate(workdir=flow_workdir)\n\n        # Check if we are already using a scheduler to run this flow\n        flow.check_pid_file()\n        flow.set_spectator_mode(False)\n\n        flow.check_status(show=False)\n\n        #if flow.all_ok:\n        #    print(\"flow.all_ok: Ignoring %s\" % flow)\n        #    return 0\n\n        self.flows.append(flow)\n        #print(\"Flow %s added to the BatchLauncher\" % flow)\n\n        return 1"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsubmitting a job to the queue.", "response": "def submit(self, **kwargs):\n        \"\"\"\n        Submit a job script that will run the schedulers with `abirun.py`.\n\n        Args:\n            verbose: Verbosity level\n            dry_run: Don't submit the script if dry_run. Default: False\n\n        Returns:\n            namedtuple with attributes:\n                retcode: Return code as returned by the submission script.\n                qjob: :class:`QueueJob` object.\n                num_flows_inbatch: Number of flows executed by the batch script\n\n            Return code of the job script submission.\n        \"\"\"\n        verbose, dry_run = kwargs.pop(\"verbose\", 0), kwargs.pop(\"dry_run\", False)\n\n        if not self.flows:\n            print(\"Cannot submit an empty list of flows!\")\n            return 0\n\n        if hasattr(self, \"qjob\"):\n            # This usually happens when we have loaded the object from pickle\n            # and we have already submitted to batch script to the queue.\n            # At this point we need to understand if the previous batch job\n            # is still running before trying to submit it again. There are three cases:\n            #\n            # 1) The batch script has completed withing timelimit and therefore\n            #    the pid_file has been removed by the script. In this case, we\n            #    should not try to submit it again.\n\n            # 2) The batch script has been killed due to timelimit (other reasons are possible\n            #    but we neglect them). In this case the pid_file exists but there's no job with\n            #    this pid runnig and we can resubmit it again.\n\n            # 3) The batch script is still running.\n            print(\"BatchLauncher has qjob %s\" % self.qjob)\n\n            if not self.batch_pid_file.exists:\n                print(\"It seems that the batch script reached the end. Wont' try to submit it again\")\n                return 0\n\n            msg = (\"Here I have to understand if qjob is in the queue.\"\n                   \" but I need an abstract API that can retrieve info from the queue id\")\n            raise RuntimeError(msg)\n\n            # TODO: Temptative API\n            if self.qjob.in_status(\"Running|Queued\"):\n                print(\"Job is still running. Cannot submit\")\n            else:\n                del self.qjob\n\n        script, num_flows_inbatch = self._get_script_nflows()\n\n        if num_flows_inbatch == 0:\n            print(\"All flows have reached all_ok! Batch script won't be submitted\")\n            return 0\n\n        if verbose:\n            print(\"*** submission script ***\")\n            print(script)\n\n        # Write the script.\n        self.script_file.write(script)\n        self.script_file.chmod(0o740)\n\n        # Builf the flow.\n        for flow in self.flows:\n            flow.build_and_pickle_dump()\n\n        # Submit the task and save the queue id.\n        if dry_run: return -1\n\n        print(\"Will submit %s flows in batch script\" % len(self.flows))\n        self.qjob, process = self.qadapter.submit_to_queue(self.script_file.path)\n\n        # Save the queue id in the pid file\n        # The file will be removed by the job script if execution is completed.\n        self.batch_pidfile.write(str(self.qjob.qid))\n\n        self.pickle_dump()\n        process.wait()\n\n        return dict2namedtuple(retcode=process.returncode, qjob=self.qjob,\n                               num_flows_inbatch=num_flows_inbatch)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nwrites the submission script. Return the script and the number of flows in batch.", "response": "def _get_script_nflows(self):\n        \"\"\"\n        Write the submission script. Return (script, num_flows_in_batch)\n        \"\"\"\n        flows_torun = [f for f in self.flows if not f.all_ok]\n        if not flows_torun:\n            return \"\", 0\n\n        executable = [\n            'export _LOG=%s' % self.log_file.path,\n            'date1=$(date +\"%s\")',\n            'echo Running abirun.py in batch mode > ${_LOG}',\n            \" \",\n        ]\n        app = executable.append\n\n        # Build list of abirun commands and save the name of the log files.\n        self.sched_logs, num_flows = [], len(flows_torun)\n        for i, flow in enumerate(flows_torun):\n\n            logfile = os.path.join(self.workdir, \"log_\" + os.path.basename(flow.workdir))\n\n            app(\"echo Starting flow %d/%d on: `date` >> ${LOG}\" % (i+1, num_flows))\n            app(\"\\nabirun.py %s scheduler > %s\" % (flow.workdir, logfile))\n            app(\"echo Returning from abirun on `date` with retcode $? >> ${_LOG}\")\n\n            assert logfile not in self.sched_logs\n            self.sched_logs.append(logfile)\n\n        # Remove the batch pid_file and compute elapsed time.\n        executable.extend([\n            \" \",\n            \"# Remove batch pid file\",\n            'rm %s' % self.batch_pidfile.path,\n            \" \",\n            \"# Compute elapsed time\",\n            'date2=$(date +\"%s\")',\n            'diff=$(($date2-$date1))',\n            'echo $(($diff / 60)) minutes and $(($diff % 60)) seconds elapsed. >> ${_LOG}'\n        ])\n\n        return self.qadapter.get_script_str(\n            job_name=self.name,\n            launch_dir=self.workdir,\n            executable=executable,\n            qout_path=self.qout_file.path,\n            qerr_path=self.qerr_file.path,\n        ), num_flows"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngenerating the string representation of the CTRL file. This is the first line of the string that is generated by the lmhart. run.", "response": "def get_string(self, sigfigs=8):\n        \"\"\"\n        Generates the string representation of the CTRL file. This is\n        the mininmal CTRL file necessary to execute lmhart.run.\n        \"\"\"\n        ctrl_dict = self.as_dict()\n        lines = [] if \"HEADER\" not in ctrl_dict else \\\n            [\"HEADER\".ljust(10) + self.header]\n        if \"VERS\" in ctrl_dict:\n            lines.append(\"VERS\".ljust(10) + self.version)\n\n        lines.append(\"STRUC\".ljust(10) +\n                     \"ALAT=\"+str(round(ctrl_dict[\"ALAT\"], sigfigs)))\n        for l, latt in enumerate(ctrl_dict[\"PLAT\"]):\n            if l == 0:\n                line = \"PLAT=\".rjust(15)\n            else:\n                line = \" \".ljust(15)\n            line += \" \".join([str(round(v, sigfigs)) for v in latt])\n            lines.append(line)\n\n        for cat in [\"CLASS\", \"SITE\"]:\n            for a, atoms in enumerate(ctrl_dict[cat]):\n                if a == 0:\n                    line = [cat.ljust(9)]\n                else:\n                    line = [\" \".ljust(9)]\n                for token, val in sorted(atoms.items()):\n                    if token == \"POS\":\n                        line.append(\"POS=\" +\n                                    \" \".join([str(round(p, sigfigs))\n                                              for p in val]))\n                    else:\n                        line.append(token + \"=\" + str(val))\n                line = \" \".join(line)\n                lines.append(line)\n\n        return \"\\n\".join(lines)+\"\\n\""}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef as_dict(self):\n        ctrl_dict = {\"@module\": self.__class__.__module__,\n                     \"@class\": self.__class__.__name__}\n        if self.header is not None:\n            ctrl_dict[\"HEADER\"] = self.header\n        if self.version is not None:\n            ctrl_dict[\"VERS\"] = self.version\n        sga = SpacegroupAnalyzer(self.structure)\n        alat = sga.get_conventional_standard_structure().lattice.a\n        plat = self.structure.lattice.matrix/alat\n\n        \"\"\"\n        The following is to find the classes (atoms that are not symmetry\n        equivalent, and create labels. Note that LMTO only attaches\n        numbers with the second atom of the same species, e.g. \"Bi\", \"Bi1\",\n        \"Bi2\", etc.\n        \"\"\"\n\n        eq_atoms = sga.get_symmetry_dataset()['equivalent_atoms']\n        ineq_sites_index = list(set(eq_atoms))\n        sites = []\n        classes = []\n        num_atoms = {}\n        for s, site in enumerate(self.structure.sites):\n            atom = site.specie\n            label_index = ineq_sites_index.index(eq_atoms[s])\n            if atom.symbol in num_atoms:\n                if label_index + 1 > sum(num_atoms.values()):\n                    num_atoms[atom.symbol] += 1\n                    atom_label = atom.symbol + str(num_atoms[atom.symbol] - 1)\n                    classes.append({\"ATOM\": atom_label, \"Z\": atom.Z})\n            else:\n                num_atoms[atom.symbol] = 1\n                classes.append({\"ATOM\": atom.symbol, \"Z\": atom.Z})\n            sites.append({\"ATOM\": classes[label_index][\"ATOM\"],\n                          \"POS\": site.coords/alat})\n\n        ctrl_dict.update({\"ALAT\": alat/bohr_to_angstrom,\n                          \"PLAT\": plat,\n                          \"CLASS\": classes,\n                          \"SITE\": sites})\n        return ctrl_dict", "response": "Returns the CTRL as a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating a LMTOCtrl object from an existing CTRL file.", "response": "def from_file(cls, filename=\"CTRL\", **kwargs):\n        \"\"\"\n        Creates a CTRL file object from an existing file.\n\n        Args:\n            filename: The name of the CTRL file. Defaults to 'CTRL'.\n\n        Returns:\n            An LMTOCtrl object.\n        \"\"\"\n        with zopen(filename, \"rt\") as f:\n            contents = f.read()\n        return LMTOCtrl.from_string(contents, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating a new LMTOCtrl object from a string representation of the CTRL file.", "response": "def from_string(cls, data, sigfigs=8):\n        \"\"\"\n        Creates a CTRL file object from a string. This will mostly be\n        used to read an LMTOCtrl object from a CTRL file. Empty spheres\n        are ignored.\n\n        Args:\n            data: String representation of the CTRL file.\n\n        Returns:\n            An LMTOCtrl object.\n        \"\"\"\n        lines = data.split(\"\\n\")[:-1]\n        struc_lines = {\"HEADER\": [], \"VERS\": [], \"SYMGRP\": [],\n                       \"STRUC\": [], \"CLASS\": [], \"SITE\": []}\n        for line in lines:\n            if line != \"\" and not line.isspace():\n                if not line[0].isspace():\n                    cat = line.split()[0]\n                if cat in struc_lines:\n                    struc_lines[cat].append(line)\n                else:\n                    pass\n        for cat in struc_lines:\n            struc_lines[cat] = \" \".join(struc_lines[cat]).replace(\"= \", \"=\")\n\n        structure_tokens = {\"ALAT\": None,\n                            \"PLAT\": [],\n                            \"CLASS\": [],\n                            \"SITE\": []}\n\n        for cat in [\"STRUC\", \"CLASS\", \"SITE\"]:\n            fields = struc_lines[cat].split(\"=\")\n            for f, field in enumerate(fields):\n                token = field.split()[-1]\n                if token == \"ALAT\":\n                    alat = round(float(fields[f+1].split()[0]), sigfigs)\n                    structure_tokens[\"ALAT\"] = alat\n                elif token == \"ATOM\":\n                    atom = fields[f+1].split()[0]\n                    if not bool(re.match(\"E[0-9]*$\", atom)):\n                        if cat == \"CLASS\":\n                            structure_tokens[\"CLASS\"].append(atom)\n                        else:\n                            structure_tokens[\"SITE\"].append({\"ATOM\": atom})\n                    else:\n                        pass\n                elif token in [\"PLAT\", \"POS\"]:\n                    try:\n                        arr = np.array([round(float(i), sigfigs)\n                                       for i in fields[f+1].split()])\n                    except ValueError:\n                        arr = np.array([round(float(i), sigfigs)\n                                       for i in fields[f+1].split()[:-1]])\n                    if token == \"PLAT\":\n                        structure_tokens[\"PLAT\"] = arr.reshape([3, 3])\n                    elif not bool(re.match(\"E[0-9]*$\", atom)):\n                        structure_tokens[\"SITE\"][-1][\"POS\"] = arr\n                    else:\n                        pass\n                else:\n                    pass\n        try:\n            spcgrp_index = struc_lines[\"SYMGRP\"].index(\"SPCGRP\")\n            spcgrp = struc_lines[\"SYMGRP\"][spcgrp_index:spcgrp_index+12]\n            structure_tokens[\"SPCGRP\"] = spcgrp.split(\"=\")[1].split()[0]\n        except ValueError:\n            pass\n\n        for token in [\"HEADER\", \"VERS\"]:\n                try:\n                    value = re.split(token + r\"\\s*\", struc_lines[token])[1]\n                    structure_tokens[token] = value.strip()\n                except IndexError:\n                    pass\n        return LMTOCtrl.from_dict(structure_tokens)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef from_dict(cls, d):\n        for cat in [\"HEADER\", \"VERS\"]:\n            if cat not in d:\n                d[cat] = None\n        alat = d[\"ALAT\"] * bohr_to_angstrom\n        plat = d[\"PLAT\"] * alat\n        species = []\n        positions = []\n        for site in d[\"SITE\"]:\n            species.append(re.split(\"[0-9*]\", site[\"ATOM\"])[0])\n            positions.append(site[\"POS\"] * alat)\n\n        # Only check if the structure is to be generated from the space\n        # group if the number of sites is the same as the number of classes.\n        # If lattice and the spacegroup don't match, assume it's primitive.\n        if \"CLASS\" in d and \"SPCGRP\" in d \\\n           and len(d[\"SITE\"]) == len(d[\"CLASS\"]):\n            try:\n                structure = Structure.from_spacegroup(d[\"SPCGRP\"], plat,\n                                                      species, positions,\n                                                      coords_are_cartesian=True)\n            except ValueError:\n                structure = Structure(plat, species, positions,\n                                      coords_are_cartesian=True,\n                                      to_unit_cell=True)\n        else:\n            structure = Structure(plat, species, positions,\n                                  coords_are_cartesian=True,\n                                  to_unit_cell=True)\n\n        return cls(structure, header=d[\"HEADER\"], version=d[\"VERS\"])", "response": "Creates a new LMTOCtrl object from a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _get_bond_data(line):\n\n        line = line.split()\n        length = float(line[2])\n        # Replacing \"/\" with \"-\" makes splitting easier\n        sites = line[0].replace(\"/\", \"-\").split(\"-\")\n        site_indices = tuple(int(ind) - 1 for ind in sites[1:4:2])\n        species = tuple(re.split(r\"\\d+\", spec)[0] for spec in sites[0:3:2])\n        label = \"%s%d-%s%d\" % (species[0], site_indices[0] + 1,\n                               species[1], site_indices[1] + 1)\n        return label, length, site_indices", "response": "Subroutine to extract bond label site indices and length from a COHPCAR header line."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef interpolate(self):\n        images = self.__s1.interpolate(self.__s2, nimages=self.__n_images,\n                                       interpolate_lattices=False)\n        for site_i in self.__relax_sites:\n            start_f = images[0].sites[site_i].frac_coords\n            end_f = images[-1].sites[site_i].frac_coords\n\n            path = NEBPathfinder.string_relax(\n                NEBPathfinder.__f2d(start_f, self.__v),\n                NEBPathfinder.__f2d(end_f, self.__v),\n                self.__v, n_images=(self.__n_images + 1),\n                dr=[self.__s1.lattice.a / self.__v.shape[0],\n                    self.__s1.lattice.b / self.__v.shape[1],\n                    self.__s1.lattice.c / self.__v.shape[2]])\n            for image_i, image in enumerate(images):\n                image.translate_sites(site_i,\n                                      NEBPathfinder.__d2f(path[image_i],\n                                                          self.__v) -\n                                      image.sites[site_i].frac_coords,\n                                      frac_coords=True, to_unit_cell=True)\n        self.__images = images", "response": "Interpolates the site indices of the two structures."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngenerates a POSCAR with the calculated diffusion path with respect to the first endpoint.", "response": "def plot_images(self, outfile):\n        \"\"\"\n        Generates a POSCAR with the calculated diffusion path with respect to the first endpoint.\n        :param outfile: Output file for the POSCAR\n        \"\"\"\n        sum_struct = self.__images[0].sites\n        for image in self.__images:\n            for site_i in self.__relax_sites:\n                sum_struct.append(PeriodicSite(image.sites[site_i].specie,\n                                               image.sites[site_i].frac_coords,\n                                               self.__images[0].lattice,\n                                               to_unit_cell=True,\n                                               coords_are_cartesian=False))\n        sum_struct = Structure.from_sites(sum_struct, validate_proximity=False)\n        p = Poscar(sum_struct)\n        p.write_file(outfile)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef string_relax(start, end, V, n_images=25, dr=None, h=3.0, k=0.17,\n                     min_iter=100, max_iter=10000, max_tol=5e-6):\n        \"\"\"\n        Implements path relaxation via the elastic band method. In general, the\n        method is to define a path by a set of points (images) connected with\n        bands with some elasticity constant k. The images then relax along the\n        forces found in the potential field V, counterbalanced by the elastic\n        response of the elastic band. In general the endpoints of the band can\n        be allowed to relax also to their local minima, but in this calculation\n        they are kept fixed.\n\n        Args:\n            start, end: Endpoints of the path calculation given in discrete\n                coordinates with respect to the grid in V\n            V: potential field through which to calculate the path\n            n_images: number of images used to define the path. In general\n                anywhere from 20 to 40 seems to be good.\n            dr: Conversion ratio from discrete coordinates to real coordinates\n                for each of the three coordinate vectors\n            h: Step size for the relaxation. h = 0.1 works reliably, but is\n                slow. h=10 diverges with large gradients but for the types of\n                gradients seen in CHGCARs, works pretty reliably\n            k: Elastic constant for the band (in real units, not discrete)\n            min_iter, max_iter: Number of optimization steps the string will\n                take before exiting (even if unconverged)\n            max_tol: Convergence threshold such that if the string moves by\n                less than max_tol in a step, and at least min_iter steps have\n                passed, the algorithm will terminate. Depends strongly on the\n                size of the gradients in V, but 5e-6 works reasonably well for\n                CHGCARs.\n        \"\"\"\n        #\n        # This code is based on the MATLAB example provided by\n        # Prof. Eric Vanden-Eijnden of NYU\n        # (http://www.cims.nyu.edu/~eve2/main.htm)\n        #\n\n        # print(\"Getting path from {} to {} (coords wrt V grid)\".format(start, end))\n        \n        # Set parameters\n        if not dr:\n            dr = np.array(\n                [1.0 / V.shape[0], 1.0 / V.shape[1], 1.0 / V.shape[2]])\n        else:\n            dr = np.array(dr, dtype=float)\n        keff = k * dr * n_images\n        h0 = h\n\n        # Initialize string\n        g1 = np.linspace(0, 1, n_images)\n        s0 = start\n        s1 = end\n        s = np.array([g * (s1 - s0) for g in g1]) + s0\n        ds = s - np.roll(s, 1, axis=0)\n        ds[0] = (ds[0] - ds[0])\n        ls = np.cumsum(la.norm(ds, axis=1))\n        ls = ls / ls[-1]\n        fi = interp1d(ls, s, axis=0)\n        s = fi(g1)\n\n        # Evaluate initial distances (for elastic equilibrium)\n        ds0_plus = s - np.roll(s, 1, axis=0)\n        ds0_minus = s - np.roll(s, -1, axis=0)\n        ds0_plus[0] = (ds0_plus[0] - ds0_plus[0])\n        ds0_minus[-1] = (ds0_minus[-1] - ds0_minus[-1])\n\n        # Evaluate potential gradient outside the loop, as potential does not\n        # change per step in this approximation.\n        dV = np.gradient(V)\n\n        # Evolve string\n        for step in range(0, max_iter):\n            if step > min_iter:\n                # Gradually decay step size to prevent oscillations\n                h = h0 * np.exp(-2.0 * (step - min_iter) / max_iter)\n            else:\n                h = h0\n            # Calculate forces acting on string\n            d = V.shape\n            s0 = s\n            edV = np.array([[dV[0][int(pt[0]) % d[0]][int(pt[1]) % d[1]][\n                                 int(pt[2]) % d[2]] / dr[0],\n                             dV[1][int(pt[0]) % d[0]][int(pt[1]) % d[1]][\n                                 int(pt[2]) % d[2]] / dr[0],\n                             dV[2][int(pt[0]) % d[0]][int(pt[1]) % d[1]][\n                                 int(pt[2]) % d[2]] / dr[0]] for pt in s])\n            # if(step % 100 == 0):\n            #    print(edV)\n\n            # Update according to force due to potential and string elasticity\n            ds_plus = s - np.roll(s, 1, axis=0)\n            ds_minus = s - np.roll(s, -1, axis=0)\n            ds_plus[0] = (ds_plus[0] - ds_plus[0])\n            ds_minus[-1] = (ds_minus[-1] - ds_minus[-1])\n            Fpot = edV\n            Fel = keff * (la.norm(ds_plus) - la.norm(ds0_plus)) * (\n                ds_plus / la.norm(ds_plus))\n            Fel += keff * (la.norm(ds_minus) - la.norm(ds0_minus)) * (\n                ds_minus / la.norm(ds_minus))\n            s -= h * (Fpot + Fel)\n\n            # Fix endpoints\n            s[0] = s0[0]\n            s[-1] = s0[-1]\n\n            # Reparametrize string\n            ds = s - np.roll(s, 1, axis=0)\n            ds[0] = (ds[0] - ds[0])\n            ls = np.cumsum(la.norm(ds, axis=1))\n            ls = ls / ls[-1]\n            fi = interp1d(ls, s, axis=0)\n            s = fi(g1)\n\n            tol = la.norm((s - s0) * dr) / n_images / h\n\n            if tol > 1e10:\n                raise ValueError(\n                    \"Pathfinding failed, path diverged! Consider reducing h to \"\n                    \"avoid divergence.\")\n\n            if step > min_iter and tol < max_tol:\n                print(\"Converged at step {}\".format(step))\n                break\n\n            if step % 100 == 0:\n                print(\"Step {} - ds = {}\".format(step, tol))\n        return s", "response": "This function calculates the path relaxation of a string in a given potential field V."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef __f2d(frac_coords, v):\n        # frac_coords = frac_coords % 1\n        return np.array([int(frac_coords[0] * v.shape[0]),\n                         int(frac_coords[1] * v.shape[1]),\n                         int(frac_coords[2] * v.shape[2])])", "response": "Convert fractional coordinates to discrete coordinates with respect to\n        the grid size of v\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef __d2f(disc_coords, v):\n        return np.array([disc_coords[0] / v.shape[0],\n                         disc_coords[1] / v.shape[1],\n                         disc_coords[2] / v.shape[2]])", "response": "Convert a point given in discrete coordinates withe respect to the\n        grid in v to fractional coordinates."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef normalize(self):\n        self.__v = self.__v - np.amin(self.__v)\n        self.__v = self.__v / np.amax(self.__v)", "response": "Normalizes the potential range 0 to 1."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef rescale_field(self, new_dim):\n        v_dim = self.__v.shape\n        padded_v = np.lib.pad(self.__v, ((0, 1), (0, 1), (0, 1)), mode='wrap')\n        ogrid_list = np.array([list(c) for c in list(\n            np.ndindex(v_dim[0] + 1, v_dim[1] + 1, v_dim[2] + 1))])\n        v_ogrid = padded_v.reshape(\n            ((v_dim[0] + 1) * (v_dim[1] + 1) * (v_dim[2] + 1), -1))\n        ngrid_a, ngrid_b, ngrid_c = np.mgrid[0: v_dim[0]: v_dim[0] / new_dim[0],\n                                    0: v_dim[1]: v_dim[1] / new_dim[1],\n                                    0: v_dim[2]: v_dim[2] / new_dim[2]]\n\n        v_ngrid = scipy.interpolate.griddata(ogrid_list, v_ogrid,\n                                             (ngrid_a, ngrid_b, ngrid_c),\n                                             method='linear').reshape(\n            (new_dim[0], new_dim[1], new_dim[2]))\n        self.__v = v_ngrid", "response": "Rescales the potential field by linear interpolation."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef gaussian_smear(self, r):\n        # Since scaling factor in fractional coords is not isotropic, have to\n        # have different radii in 3 directions\n        a_lat = self.__s.lattice.a\n        b_lat = self.__s.lattice.b\n        c_lat = self.__s.lattice.c\n\n        # Conversion factors for discretization of v\n        v_dim = self.__v.shape\n        r_frac = (r / a_lat, r / b_lat, r / c_lat)\n        r_disc = (int(math.ceil(r_frac[0] * v_dim[0])),\n                  int(math.ceil(r_frac[1] * v_dim[1])),\n                  int(math.ceil(r_frac[2] * v_dim[2])))\n\n        # Apply smearing\n        # Gaussian filter\n        gauss_dist = np.zeros(\n            (r_disc[0] * 4 + 1, r_disc[1] * 4 + 1, r_disc[2] * 4 + 1))\n        for g_a in np.arange(-2.0 * r_disc[0], 2.0 * r_disc[0] + 1, 1.0):\n            for g_b in np.arange(-2.0 * r_disc[1], 2.0 * r_disc[1] + 1, 1.0):\n                for g_c in np.arange(-2.0 * r_disc[2], 2.0 * r_disc[2] + 1,\n                                     1.0):\n                    g = np.array(\n                        [g_a / v_dim[0], g_b / v_dim[1], g_c / v_dim[2]]).T\n                    gauss_dist[int(g_a + r_disc[0])][int(g_b + r_disc[1])][\n                        int(g_c + r_disc[2])] = la.norm(\n                        np.dot(self.__s.lattice.matrix, g)) / r\n        gauss = scipy.stats.norm.pdf(gauss_dist)\n        gauss = gauss / np.sum(gauss, dtype=float)\n        padded_v = np.pad(self.__v, (\n        (r_disc[0], r_disc[0]), (r_disc[1], r_disc[1]), (r_disc[2], r_disc[2])),\n                          mode='wrap')\n        smeared_v = scipy.signal.convolve(padded_v, gauss, mode='valid')\n        self.__v = smeared_v", "response": "Applies an isotropic Gaussian smear of width r to the potential field."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngives a structure returns the predicted volume.", "response": "def predict(self, structure, ref_structure):\n        \"\"\"\n        Given a structure, returns the predicted volume.\n        Args:\n            structure (Structure): structure w/unknown volume\n            ref_structure (Structure): A reference structure with a similar\n                structure but different species.\n        Returns:\n            a float value of the predicted volume\n        \"\"\"\n\n        if self.check_isostructural:\n            m = StructureMatcher()\n            mapping = m.get_best_electronegativity_anonymous_mapping(\n                structure, ref_structure)\n            if mapping is None:\n                raise ValueError(\"Input structures do not match!\")\n\n        if \"ionic\" in self.radii_type:\n            try:\n                # Use BV analyzer to determine oxidation states only if the\n                # oxidation states are not already specified in the structure\n                # and use_bv is true.\n                if (not is_ox(structure)) and self.use_bv:\n                    a = BVAnalyzer()\n                    structure = a.get_oxi_state_decorated_structure(structure)\n                if (not is_ox(ref_structure)) and self.use_bv:\n                    a = BVAnalyzer()\n                    ref_structure = a.get_oxi_state_decorated_structure(\n                        ref_structure)\n\n                comp = structure.composition\n                ref_comp = ref_structure.composition\n\n                # Check if all the associated ionic radii are available.\n                if any([k.ionic_radius is None for k in list(comp.keys())]) or \\\n                        any([k.ionic_radius is None for k in\n                             list(ref_comp.keys())]):\n                    raise ValueError(\"Not all the ionic radii are available!\")\n\n                numerator = 0\n                denominator = 0\n                # Here, the 1/3 factor on the composition accounts for atomic\n                # packing. We want the number per unit length.\n                for k, v in comp.items():\n                    numerator += k.ionic_radius * v ** (1 / 3)\n                for k, v in ref_comp.items():\n                    denominator += k.ionic_radius * v ** (1 / 3)\n\n                return ref_structure.volume * (numerator / denominator) ** 3\n            except Exception as ex:\n                warnings.warn(\"Exception occured. Will attempt atomic radii.\")\n                # If error occurs during use of ionic radii scheme, pass\n                # and see if we can resolve it using atomic radii.\n                pass\n\n        if \"atomic\" in self.radii_type:\n            comp = structure.composition\n            ref_comp = ref_structure.composition\n            # Here, the 1/3 factor on the composition accounts for atomic\n            # packing. We want the number per unit length.\n            numerator = 0\n            denominator = 0\n            for k, v in comp.items():\n                numerator += k.atomic_radius * v ** (1 / 3)\n            for k, v in ref_comp.items():\n                denominator += k.atomic_radius * v ** (1 / 3)\n            return ref_structure.volume * (numerator / denominator) ** 3\n\n        raise ValueError(\"Cannot find volume scaling based on radii choices \"\n                         \"specified!\")"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_predicted_structure(self, structure, ref_structure):\n        new_structure = structure.copy()\n        new_structure.scale_lattice(self.predict(structure, ref_structure))\n\n        return new_structure", "response": "Returns back the structure scaled to predicted\n        volume."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef predict(self, structure, icsd_vol=False):\n\n        # Get standard deviation of electronnegativity in the structure.\n        std_x = np.std([site.specie.X for site in structure])\n        # Sites that have atomic radii\n        sub_sites = []\n        # Record the \"DLS estimated radius\" from bond_params.\n        bp_dict = {}\n\n        for sp in list(structure.composition.keys()):\n            if sp.atomic_radius:\n                sub_sites.extend([site for site in structure\n                                  if site.specie == sp])\n            else:\n                warnings.warn(\"VolumePredictor: no atomic radius data for \"\n                              \"{}\".format(sp))\n\n            if sp.symbol not in bond_params:\n                warnings.warn(\"VolumePredictor: bond parameters not found, \"\n                              \"used atomic radii for {}\".format(sp))\n            else:\n                r, k = bond_params[sp.symbol][\"r\"], bond_params[sp.symbol][\"k\"]\n                bp_dict[sp] = float(r) + float(k) * std_x\n\n        # Structure object that include only sites with known atomic radii.\n        reduced_structure = Structure.from_sites(sub_sites)\n        smallest_ratio = None\n\n        for site1 in reduced_structure:\n            sp1 = site1.specie\n            neighbors = reduced_structure.get_neighbors(site1,\n                                                        sp1.atomic_radius +\n                                                        self.cutoff)\n\n            for site2, dist in neighbors:\n                sp2 = site2.specie\n\n                if sp1 in bp_dict and sp2 in bp_dict:\n                    expected_dist = bp_dict[sp1] + bp_dict[sp2]\n                else:\n                    expected_dist = sp1.atomic_radius + sp2.atomic_radius\n\n                if not smallest_ratio or dist / expected_dist < smallest_ratio:\n                    smallest_ratio = dist / expected_dist\n\n        if not smallest_ratio:\n            raise ValueError(\"Could not find any bonds within the given cutoff \"\n                             \"in this structure.\")\n\n        volume_factor = (1 / smallest_ratio) ** 3\n\n        # icsd volume fudge factor\n        if icsd_vol:\n            volume_factor *= 1.05\n\n        if self.min_scaling:\n            volume_factor = max(self.min_scaling, volume_factor)\n        if self.max_scaling:\n            volume_factor = min(self.max_scaling, volume_factor)\n\n        return structure.volume * volume_factor", "response": "Predicts the predicted volume of a crystal structure."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn back the structure scaled to predicted volume.", "response": "def get_predicted_structure(self, structure, icsd_vol=False):\n        \"\"\"\n        Given a structure, returns back the structure scaled to predicted\n        volume.\n        Args:\n            structure (Structure): structure w/unknown volume\n\n        Returns:\n            a Structure object with predicted volume\n        \"\"\"\n        new_structure = structure.copy()\n        new_structure.scale_lattice(self.predict(structure, icsd_vol=icsd_vol))\n        return new_structure"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef uniform_labels(self, mol1, mol2):\n        obmol1 = BabelMolAdaptor(mol1).openbabel_mol\n        obmol2 = BabelMolAdaptor(mol2).openbabel_mol\n\n        h1 = self.get_molecule_hash(obmol1)\n        h2 = self.get_molecule_hash(obmol2)\n        if h1 != h2:\n            return None, None\n\n        query = ob.CompileMoleculeQuery(obmol1)\n        isomapper = ob.OBIsomorphismMapper.GetInstance(query)\n        isomorph = ob.vvpairUIntUInt()\n        isomapper.MapAll(obmol2, isomorph)\n\n        sorted_isomorph = [sorted(x, key=lambda morp: morp[0])\n                           for x in isomorph]\n        label2_list = tuple([tuple([p[1] + 1 for p in x])\n                             for x in sorted_isomorph])\n\n        vmol1 = obmol1\n        aligner = ob.OBAlign(True, False)\n        aligner.SetRefMol(vmol1)\n        least_rmsd = float(\"Inf\")\n        best_label2 = None\n        label1 = list(range(1, obmol1.NumAtoms() + 1))\n        # noinspection PyProtectedMember\n        elements1 = InchiMolAtomMapper._get_elements(vmol1, label1)\n        for label2 in label2_list:\n            # noinspection PyProtectedMember\n            elements2 = InchiMolAtomMapper._get_elements(obmol2, label2)\n            if elements1 != elements2:\n                continue\n            vmol2 = ob.OBMol()\n            for i in label2:\n                vmol2.AddAtom(obmol2.GetAtom(i))\n            aligner.SetTargetMol(vmol2)\n            aligner.Align()\n            rmsd = aligner.GetRMSD()\n            if rmsd < least_rmsd:\n                least_rmsd = rmsd\n                best_label2 = copy.copy(label2)\n        return label1, best_label2", "response": "Calculates the RMSD of the two molecules and returns the mapping for the least RMSD atom."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns inchi as molecular hash", "response": "def get_molecule_hash(self, mol):\n        \"\"\"\n        Return inchi as molecular hash\n        \"\"\"\n        obconv = ob.OBConversion()\n        obconv.SetOutFormat(str(\"inchi\"))\n        obconv.AddOption(str(\"X\"), ob.OBConversion.OUTOPTIONS, str(\"DoNotAddH\"))\n        inchi_text = obconv.WriteString(mol)\n        match = re.search(r\"InChI=(?P<inchi>.+)\\n\", inchi_text)\n        return match.group(\"inchi\")"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the inchi canonical labels of the heavy atoms in the molecule.", "response": "def _inchi_labels(mol):\n        \"\"\"\n        Get the inchi canonical labels of the heavy atoms in the molecule\n\n        Args:\n            mol: The molecule. OpenBabel OBMol object\n\n        Returns:\n            The label mappings. List of tuple of canonical label,\n            original label\n            List of equivalent atoms.\n        \"\"\"\n        obconv = ob.OBConversion()\n        obconv.SetOutFormat(str(\"inchi\"))\n        obconv.AddOption(str(\"a\"), ob.OBConversion.OUTOPTIONS)\n        obconv.AddOption(str(\"X\"), ob.OBConversion.OUTOPTIONS, str(\"DoNotAddH\"))\n        inchi_text = obconv.WriteString(mol)\n        match = re.search(r\"InChI=(?P<inchi>.+)\\nAuxInfo=.+\"\n                          r\"/N:(?P<labels>[0-9,;]+)/(E:(?P<eq_atoms>[0-9,\"\n                          r\";\\(\\)]*)/)?\", inchi_text)\n        inchi = match.group(\"inchi\")\n        label_text = match.group(\"labels\")\n        eq_atom_text = match.group(\"eq_atoms\")\n        heavy_atom_labels = tuple([int(i) for i in label_text.replace(\n            ';', ',').split(',')])\n        eq_atoms = []\n        if eq_atom_text is not None:\n            eq_tokens = re.findall(r'\\(((?:[0-9]+,)+[0-9]+)\\)', eq_atom_text\n                                   .replace(';', ','))\n            eq_atoms = tuple([tuple([int(i) for i in t.split(',')])\n                              for t in eq_tokens])\n        return heavy_atom_labels, eq_atoms, inchi"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _group_centroid(mol, ilabels, group_atoms):\n        c1x, c1y, c1z = 0.0, 0.0, 0.0\n        for i in group_atoms:\n            orig_idx = ilabels[i-1]\n            oa1 = mol.GetAtom(orig_idx)\n            c1x += float(oa1.x())\n            c1y += float(oa1.y())\n            c1z += float(oa1.z())\n        num_atoms = len(group_atoms)\n        c1x /= num_atoms\n        c1y /= num_atoms\n        c1z /= num_atoms\n        return c1x, c1y, c1z", "response": "Calculates the centroids of a group inchi - related object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate a virtual molecule by unique atoms the centriods of the equivalent atoms and the farthest atom.", "response": "def _virtual_molecule(self, mol, ilabels, eq_atoms):\n        \"\"\"\n        Create a virtual molecule by unique atoms, the centriods of the\n        equivalent atoms\n\n        Args:\n            mol: The molecule. OpenBabel OBMol object\n            ilables: inchi label map\n            eq_atoms: equivalent atom labels\n            farthest_group_idx: The equivalent atom group index in which\n                there is the farthest atom to the centroid\n\n        Return:\n            The virtual molecule\n        \"\"\"\n        vmol = ob.OBMol()\n\n        non_unique_atoms = set([a for g in eq_atoms for a in g])\n        all_atoms = set(range(1, len(ilabels) + 1))\n        unique_atom_labels = sorted(all_atoms - non_unique_atoms)\n\n        #try to align molecules using unique atoms\n        for i in unique_atom_labels:\n            orig_idx = ilabels[i-1]\n            oa1 = mol.GetAtom(orig_idx)\n            a1 = vmol.NewAtom()\n            a1.SetAtomicNum(oa1.GetAtomicNum())\n            a1.SetVector(oa1.GetVector())\n\n        #try to align using centroids of the equivalent atoms\n        if vmol.NumAtoms() < 3:\n            for symm in eq_atoms:\n                c1x, c1y, c1z = self._group_centroid(mol, ilabels, symm)\n                min_distance = float(\"inf\")\n                for i in range(1, vmol.NumAtoms()+1):\n                    va = vmol.GetAtom(i)\n                    distance = math.sqrt((c1x - va.x())**2 + (c1y - va.y())**2\n                                         + (c1z - va.z())**2)\n                    if distance < min_distance:\n                        min_distance = distance\n                if min_distance > 0.2:\n                    a1 = vmol.NewAtom()\n                    a1.SetAtomicNum(9)\n                    a1.SetVector(c1x, c1y, c1z)\n\n        return vmol"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _align_heavy_atoms(mol1, mol2, vmol1, vmol2, ilabel1, ilabel2,\n                           eq_atoms):\n        \"\"\"\n        Align the label of topologically identical atoms of second molecule\n        towards first molecule\n\n        Args:\n            mol1: First molecule. OpenBabel OBMol object\n            mol2: Second molecule. OpenBabel OBMol object\n            vmol1: First virtual molecule constructed by centroids. OpenBabel\n                OBMol object\n            vmol2: First virtual molecule constructed by centroids. OpenBabel\n                OBMol object\n            ilabel1: inchi label map of the first molecule\n            ilabel2: inchi label map of the second molecule\n            eq_atoms: equivalent atom lables\n\n        Return:\n            corrected inchi labels of heavy atoms of the second molecule\n        \"\"\"\n\n        nvirtual = vmol1.NumAtoms()\n        nheavy = len(ilabel1)\n\n        for i in ilabel2:  # add all heavy atoms\n            a1 = vmol1.NewAtom()\n            a1.SetAtomicNum(1)\n            a1.SetVector(0.0, 0.0, 0.0)  # useless, just to pair with vmol2\n            oa2 = mol2.GetAtom(i)\n            a2 = vmol2.NewAtom()\n            a2.SetAtomicNum(1)\n            # align using the virtual atoms, these atoms are not\n            # used to align, but match by positions\n            a2.SetVector(oa2.GetVector())\n\n        aligner = ob.OBAlign(False, False)\n        aligner.SetRefMol(vmol1)\n        aligner.SetTargetMol(vmol2)\n        aligner.Align()\n        aligner.UpdateCoords(vmol2)\n\n        canon_mol1 = ob.OBMol()\n        for i in ilabel1:\n            oa1 = mol1.GetAtom(i)\n            a1 = canon_mol1.NewAtom()\n            a1.SetAtomicNum(oa1.GetAtomicNum())\n            a1.SetVector(oa1.GetVector())\n\n        aligned_mol2 = ob.OBMol()\n        for i in range(nvirtual + 1, nvirtual + nheavy + 1):\n            oa2 = vmol2.GetAtom(i)\n            a2 = aligned_mol2.NewAtom()\n            a2.SetAtomicNum(oa2.GetAtomicNum())\n            a2.SetVector(oa2.GetVector())\n\n        canon_label2 = list(range(1, nheavy+1))\n        for symm in eq_atoms:\n            for i in symm:\n                canon_label2[i-1] = -1\n        for symm in eq_atoms:\n            candidates1 = list(symm)\n            candidates2 = list(symm)\n            for c2 in candidates2:\n                distance = 99999.0\n                canon_idx = candidates1[0]\n                a2 = aligned_mol2.GetAtom(c2)\n                for c1 in candidates1:\n                    a1 = canon_mol1.GetAtom(c1)\n                    d = a1.GetDistance(a2)\n                    if d < distance:\n                        distance = d\n                        canon_idx = c1\n                canon_label2[c2-1] = canon_idx\n                candidates1.remove(canon_idx)\n\n        canon_inchi_orig_map2 = [(canon, inchi, orig)\n                                 for canon, inchi, orig in\n                                 zip(canon_label2, list(range(1, nheavy + 1)),\n                                     ilabel2)]\n        canon_inchi_orig_map2.sort(key=lambda m: m[0])\n        heavy_atom_indices2 = tuple([x[2] for x in canon_inchi_orig_map2])\n        return heavy_atom_indices2", "response": "Align the label of topologically identical atoms of first molecule with second molecule."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nalign the label of topologically identical atoms of the first molecule with the second molecule.", "response": "def _align_hydrogen_atoms(mol1, mol2, heavy_indices1,\n                              heavy_indices2):\n        \"\"\"\n        Align the label of topologically identical atoms of second molecule\n        towards first molecule\n\n        Args:\n            mol1: First molecule. OpenBabel OBMol object\n            mol2: Second molecule. OpenBabel OBMol object\n            heavy_indices1: inchi label map of the first molecule\n            heavy_indices2: label map of the second molecule\n\n        Return:\n            corrected label map of all atoms of the second molecule\n        \"\"\"\n        num_atoms = mol2.NumAtoms()\n        all_atom = set(range(1, num_atoms+1))\n        hydrogen_atoms1 = all_atom - set(heavy_indices1)\n        hydrogen_atoms2 = all_atom - set(heavy_indices2)\n        label1 = heavy_indices1 + tuple(hydrogen_atoms1)\n        label2 = heavy_indices2 + tuple(hydrogen_atoms2)\n\n        cmol1 = ob.OBMol()\n        for i in label1:\n            oa1 = mol1.GetAtom(i)\n            a1 = cmol1.NewAtom()\n            a1.SetAtomicNum(oa1.GetAtomicNum())\n            a1.SetVector(oa1.GetVector())\n        cmol2 = ob.OBMol()\n        for i in label2:\n            oa2 = mol2.GetAtom(i)\n            a2 = cmol2.NewAtom()\n            a2.SetAtomicNum(oa2.GetAtomicNum())\n            a2.SetVector(oa2.GetVector())\n\n        aligner = ob.OBAlign(False, False)\n        aligner.SetRefMol(cmol1)\n        aligner.SetTargetMol(cmol2)\n        aligner.Align()\n        aligner.UpdateCoords(cmol2)\n\n        hydrogen_label2 = []\n        hydrogen_label1 = list(range(len(heavy_indices1) + 1, num_atoms + 1))\n        for h2 in range(len(heavy_indices2) + 1, num_atoms + 1):\n            distance = 99999.0\n            idx = hydrogen_label1[0]\n            a2 = cmol2.GetAtom(h2)\n            for h1 in hydrogen_label1:\n                a1 = cmol1.GetAtom(h1)\n                d = a1.GetDistance(a2)\n                if d < distance:\n                    distance = d\n                    idx = h1\n            hydrogen_label2.append(idx)\n            hydrogen_label1.remove(idx)\n\n        hydrogen_orig_idx2 = label2[len(heavy_indices2):]\n        hydrogen_canon_orig_map2 = [(canon, orig) for canon, orig\n                                    in zip(hydrogen_label2,\n                                           hydrogen_orig_idx2)]\n        hydrogen_canon_orig_map2.sort(key=lambda m: m[0])\n        hydrogen_canon_indices2 = [x[1] for x in hydrogen_canon_orig_map2]\n\n        canon_label1 = label1\n        canon_label2 = heavy_indices2 + tuple(hydrogen_canon_indices2)\n\n        return canon_label1, canon_label2"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the elements of the atoms in the specified order", "response": "def _get_elements(mol, label):\n        \"\"\"\n        The the elements of the atoms in the specified order\n\n        Args:\n            mol: The molecule. OpenBabel OBMol object.\n            label: The atom indices. List of integers.\n\n        Returns:\n            Elements. List of integers.\n        \"\"\"\n        elements = [int(mol.GetAtom(i).GetAtomicNum()) for i in label]\n        return elements"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn True if the molecule is a linear one.", "response": "def _is_molecule_linear(self, mol):\n        \"\"\"\n        Is the molecule a linear one\n\n        Args:\n            mol: The molecule. OpenBabel OBMol object.\n\n        Returns:\n            Boolean value.\n        \"\"\"\n        if mol.NumAtoms() < 3:\n            return True\n        a1 = mol.GetAtom(1)\n        a2 = mol.GetAtom(2)\n        for i in range(3, mol.NumAtoms()+1):\n            angle = float(mol.GetAtom(i).GetAngle(a2, a1))\n            if angle < 0.0:\n                angle = -angle\n            if angle > 90.0:\n                angle = 180.0 - angle\n            if angle > self._angle_tolerance:\n                return False\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_molecule_hash(self, mol):\n        obmol = BabelMolAdaptor(mol).openbabel_mol\n        inchi = self._inchi_labels(obmol)[2]\n        return inchi", "response": "Return inchi as molecular hash"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef fit(self, mol1, mol2):\n        return self.get_rmsd(mol1, mol2) < self._tolerance", "response": "Fit two molecules.\n\n        Args:\n            mol1: First molecule. OpenBabel OBMol or pymatgen Molecule object\n            mol2: Second molecule. OpenBabel OBMol or pymatgen Molecule object\n\n        Returns:\n            A boolean value indicates whether two molecules are the same."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_rmsd(self, mol1, mol2):\n        label1, label2 = self._mapper.uniform_labels(mol1, mol2)\n        if label1 is None or label2 is None:\n            return float(\"Inf\")\n        return self._calc_rms(mol1, mol2, label1, label2)", "response": "Get the RMSD between two molecules."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _calc_rms(mol1, mol2, clabel1, clabel2):\n        obmol1 = BabelMolAdaptor(mol1).openbabel_mol\n        obmol2 = BabelMolAdaptor(mol2).openbabel_mol\n\n        cmol1 = ob.OBMol()\n        for i in clabel1:\n            oa1 = obmol1.GetAtom(i)\n            a1 = cmol1.NewAtom()\n            a1.SetAtomicNum(oa1.GetAtomicNum())\n            a1.SetVector(oa1.GetVector())\n        cmol2 = ob.OBMol()\n        for i in clabel2:\n            oa2 = obmol2.GetAtom(i)\n            a2 = cmol2.NewAtom()\n            a2.SetAtomicNum(oa2.GetAtomicNum())\n            a2.SetVector(oa2.GetVector())\n\n        aligner = ob.OBAlign(True, False)\n        aligner.SetRefMol(cmol1)\n        aligner.SetTargetMol(cmol2)\n        aligner.Align()\n        return aligner.GetRMSD()", "response": "Calculates the RMSD of the two Molecules."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ngroup molecules by structural equality.", "response": "def group_molecules(self, mol_list):\n        \"\"\"\n        Group molecules by structural equality.\n\n        Args:\n            mol_list: List of OpenBabel OBMol or pymatgen objects\n\n        Returns:\n            A list of lists of matched molecules\n            Assumption: if s1=s2 and s2=s3, then s1=s3\n            This may not be true for small tolerances.\n        \"\"\"\n        mol_hash = [(i, self._mapper.get_molecule_hash(m))\n                    for i, m in enumerate(mol_list)]\n        mol_hash.sort(key=lambda x: x[1])\n\n        #Use molecular hash to pre-group molecules.\n        raw_groups = tuple([tuple([m[0] for m in g]) for k, g\n                            in itertools.groupby(mol_hash,\n                                                 key=lambda x: x[1])])\n\n        group_indices = []\n        for rg in raw_groups:\n            mol_eq_test = [(p[0], p[1], self.fit(mol_list[p[0]],\n                                                 mol_list[p[1]]))\n                           for p in itertools.combinations(sorted(rg), 2)]\n            mol_eq = set([(p[0], p[1]) for p in mol_eq_test if p[2]])\n            not_alone_mols = set(itertools.chain.from_iterable(mol_eq))\n            alone_mols = set(rg) - not_alone_mols\n            group_indices.extend([[m] for m in alone_mols])\n            while len(not_alone_mols) > 0:\n                current_group = {not_alone_mols.pop()}\n                while len(not_alone_mols) > 0:\n                    candidate_pairs = set(\n                        [tuple(sorted(p)) for p\n                         in itertools.product(current_group, not_alone_mols)])\n                    mutual_pairs = candidate_pairs & mol_eq\n                    if len(mutual_pairs) == 0:\n                        break\n                    mutual_mols = set(itertools.chain\n                                      .from_iterable(mutual_pairs))\n                    current_group |= mutual_mols\n                    not_alone_mols -= mutual_mols\n                group_indices.append(sorted(current_group))\n\n        group_indices.sort(key=lambda x: (len(x), -x[0]), reverse=True)\n        all_groups = [[mol_list[i] for i in g] for g in group_indices]\n        return all_groups"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef nmltostring(nml):\n    if not isinstance(nml,dict):\n      raise ValueError(\"nml should be a dict !\")\n\n    curstr = \"\"\n    for key,group in nml.items():\n       namelist = [\"&\" + key]\n       for k, v in group.items():\n         if isinstance(v, list) or isinstance(v, tuple):\n           namelist.append(k + \" = \" + \",\".join(map(str, v)) + \",\")\n         elif is_string(v):\n           namelist.append(k + \" = '\" + str(v) + \"',\")\n         else:\n           namelist.append(k + \" = \" + str(v) + \",\")\n       namelist.append(\"/\")\n\n       curstr = curstr + \"\\n\".join(namelist) + \"\\n\"\n\n    return curstr", "response": "Convert a dictionary representing a Fortran namelist into a string."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ninitialize an instance from an AbinitTask instance.", "response": "def from_node(cls, task):\n        \"\"\"Initialize an instance from an :class:`AbinitTask` instance.\"\"\"\n        new = super().from_node(task)\n\n        new.update(\n            executable=task.executable,\n            #executable_version:\n            #task_events=\n            pseudos=[p.as_dict() for p in task.input.pseudos],\n            #input=task.input\n        )\n\n        new.register_gridfs_files(\n            run_abi=(task.input_file.path, \"t\"),\n            run_abo=(task.output_file.path, \"t\"),\n        )\n\n        return new"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef parse(self, filename):\n        with abiinspect.YamlTokenizer(filename) as r:\n            doc = r.next_doc_with_tag(\"!Autoparal\")\n            try:\n                d = yaml.safe_load(doc.text_notag)\n                return ParalHints(info=d[\"info\"], confs=d[\"configurations\"])\n            except:\n                import traceback\n                sexc = traceback.format_exc()\n                err_msg = \"Wrong YAML doc:\\n%s\\n\\nException:\\n%s\" % (doc.text, sexc)\n                self.add_error(err_msg)\n                logger.critical(err_msg)\n                raise self.Error(err_msg)", "response": "Read the AutoParal section from filename."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef from_mpi_omp_lists(cls, mpi_procs, omp_threads):\n        info = {}\n        confs = [ParalConf(mpi_ncpus=p, omp_ncpus=p, efficiency=1.0)\n                 for p, t in product(mpi_procs, omp_threads)]\n\n        return cls(info, confs)", "response": "Build a list of Parallel configurations from two lists containing the number of MPI processes and number of OpenMP threads."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef select_with_condition(self, condition, key=None):\n        condition = Condition.as_condition(condition)\n        new_confs = []\n\n        for conf in self:\n            # Select the object on which condition is applied\n            obj = conf if key is None else AttrDict(conf[key])\n            add_it = condition(obj=obj)\n            #if key is \"vars\": print(\"conf\", conf, \"added:\", add_it)\n            if add_it: new_confs.append(conf)\n\n        self._confs = new_confs", "response": "Select all the configurations that satisfy the given condition."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsort the configurations in place. items with highest efficiency come first", "response": "def sort_by_efficiency(self, reverse=True):\n        \"\"\"Sort the configurations in place. items with highest efficiency come first\"\"\"\n        self._confs.sort(key=lambda c: c.efficiency, reverse=reverse)\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef sort_by_speedup(self, reverse=True):\n        self._confs.sort(key=lambda c: c.speedup, reverse=reverse)\n        return self", "response": "Sort the configurations in place. items with highest speedup come first"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef sort_by_mem_per_proc(self, reverse=False):\n        # Avoid sorting if mem_per_cpu is not available.\n        if any(c.mem_per_proc > 0.0 for c in self):\n            self._confs.sort(key=lambda c: c.mem_per_proc, reverse=reverse)\n        return self", "response": "Sort the configurations in place. items with lowest memory per proc come first."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_ordered_with_policy(self, policy, max_ncpus):\n        # Build new list since we are gonna change the object in place.\n        hints = self.__class__(self.info, confs=[c for c in self if c.num_cores <= max_ncpus])\n\n        # First select the configurations satisfying the condition specified by the user (if any)\n        bkp_hints = hints.copy()\n        if policy.condition:\n            logger.info(\"Applying condition %s\" % str(policy.condition))\n            hints.select_with_condition(policy.condition)\n\n            # Undo change if no configuration fullfills the requirements.\n            if not hints:\n                hints = bkp_hints\n                logger.warning(\"Empty list of configurations after policy.condition\")\n\n        # Now filter the configurations depending on the values in vars\n        bkp_hints = hints.copy()\n        if policy.vars_condition:\n            logger.info(\"Applying vars_condition %s\" % str(policy.vars_condition))\n            hints.select_with_condition(policy.vars_condition, key=\"vars\")\n\n            # Undo change if no configuration fullfills the requirements.\n            if not hints:\n                hints = bkp_hints\n                logger.warning(\"Empty list of configurations after policy.vars_condition\")\n\n        if len(policy.autoparal_priorities) == 1:\n            # Example: hints.sort_by_speedup()\n            if policy.autoparal_priorities[0] in ['efficiency', 'speedup', 'mem_per_proc']:\n                getattr(hints, \"sort_by_\" + policy.autoparal_priorities[0])()\n            elif isinstance(policy.autoparal_priorities[0], collections.Mapping):\n                if policy.autoparal_priorities[0]['meta_priority'] == 'highest_speedup_minimum_efficiency_cutoff':\n                    min_efficiency = policy.autoparal_priorities[0].get('minimum_efficiency', 1.0)\n                    hints.select_with_condition({'efficiency': {'$gte': min_efficiency}})\n                    hints.sort_by_speedup()\n        else:\n            hints = hints.multidimensional_optimization(priorities=policy.autoparal_priorities)\n            if len(hints) == 0: raise ValueError(\"len(hints) == 0\")\n\n        #TODO: make sure that num_cores == 1 is never selected when we have more than one configuration\n        #if len(hints) > 1:\n        #    hints.select_with_condition(dict(num_cores={\"$eq\": 1)))\n\n        # Return final (orderded ) list of configurations (best first).\n        return hints", "response": "Returns a new list of all the configurations in the current set according to the given TaskPolicy."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconvert an object obj into a TaskPolicy. Accepts a dict - like object containing the key - value pairs as keys and the value - value pairs as values.", "response": "def as_policy(cls, obj):\n        \"\"\"\n        Converts an object obj into a `:class:`TaskPolicy. Accepts:\n\n            * None\n            * TaskPolicy\n            * dict-like object\n        \"\"\"\n        if obj is None:\n            # Use default policy.\n            return TaskPolicy()\n        else:\n            if isinstance(obj, cls):\n                return obj\n            elif isinstance(obj, collections.abc.Mapping):\n                return cls(**obj)\n            else:\n                raise TypeError(\"Don't know how to convert type %s to %s\" % (type(obj), cls))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef from_user_config(cls):\n        global _USER_CONFIG_TASKMANAGER\n        if _USER_CONFIG_TASKMANAGER is not None:\n            return _USER_CONFIG_TASKMANAGER\n\n        # Try in the current directory then in user configuration directory.\n        path = os.path.join(os.getcwd(), cls.YAML_FILE)\n        if not os.path.exists(path):\n            path = os.path.join(cls.USER_CONFIG_DIR, cls.YAML_FILE)\n\n        if not os.path.exists(path):\n            raise RuntimeError(colored(\n\t\t\"\\nCannot locate %s neither in current directory nor in %s\\n\"\n                \"!!! PLEASE READ THIS: !!!\\n\"\n                \"To use AbiPy to run jobs this file must be present\\n\"\n                \"It provides a description of the cluster/computer you are running on\\n\"\n                \"Examples are provided in abipy/data/managers.\" % (cls.YAML_FILE, path), color=\"red\"))\n\n        _USER_CONFIG_TASKMANAGER = cls.from_file(path)\n        return _USER_CONFIG_TASKMANAGER", "response": "Initialize the TaskManager from the user - supplied configuration file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nread the configuration parameters from the Yaml file filename.", "response": "def from_file(cls, filename):\n        \"\"\"Read the configuration parameters from the Yaml file filename.\"\"\"\n        try:\n            with open(filename, \"r\") as fh:\n                return cls.from_dict(yaml.safe_load(fh))\n        except Exception as exc:\n            print(\"Error while reading TaskManager parameters from %s\\n\" % filename)\n            raise"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef as_manager(cls, obj):\n        if isinstance(obj, cls): return obj\n        if obj is None: return cls.from_user_config()\n\n        if is_string(obj):\n            if os.path.exists(obj):\n                return cls.from_file(obj)\n            else:\n                return cls.from_string(obj)\n\n        elif isinstance(obj, collections.abc.Mapping):\n            return cls.from_dict(obj)\n        else:\n            raise TypeError(\"Don't know how to convert type %s to TaskManager\" % type(obj))", "response": "Convert obj into TaskManager instance. Accepts string filepath dictionary TaskManager object. Accepts string filepath TaskManager object. Accepts dictionary TaskManager object. Accepts None."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef from_dict(cls, d):\n        return cls(**{k: v for k, v in d.items() if k in cls.ENTRIES})", "response": "Create an instance from a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a new TaskManager with the same parameters as self but replace the QueueAdapter with a ShellAdapter with mpi_procs so that we can submit the job with passing through the queue.", "response": "def to_shell_manager(self, mpi_procs=1):\n        \"\"\"\n        Returns a new `TaskManager` with the same parameters as self but replace the :class:`QueueAdapter`\n        with a :class:`ShellAdapter` with mpi_procs so that we can submit the job without passing through the queue.\n        \"\"\"\n        my_kwargs = copy.deepcopy(self._kwargs)\n        my_kwargs[\"policy\"] = TaskPolicy(autoparal=0)\n\n        # On BlueGene we need at least two qadapters.\n        # One for running jobs on the computing nodes and another one\n        # for running small jobs on the fronted. These two qadapters\n        # will have different enviroments and different executables.\n        # If None of the q-adapters has qtype==shell, we change qtype to shell\n        # and we return a new Manager for sequential jobs with the same parameters as self.\n        # If the list contains a qadapter with qtype == shell, we ignore the remaining qadapters\n        # when we build the new Manager.\n        has_shell_qad = False\n        for d in my_kwargs[\"qadapters\"]:\n            if d[\"queue\"][\"qtype\"] == \"shell\": has_shell_qad = True\n        if has_shell_qad:\n            my_kwargs[\"qadapters\"] = [d for d in my_kwargs[\"qadapters\"] if d[\"queue\"][\"qtype\"] == \"shell\"]\n\n        for d in my_kwargs[\"qadapters\"]:\n            d[\"queue\"][\"qtype\"] = \"shell\"\n            d[\"limits\"][\"min_cores\"] = mpi_procs\n            d[\"limits\"][\"max_cores\"] = mpi_procs\n\n            # If shell_runner is specified, replace mpi_runner with shell_runner\n            # in the script used to run jobs on the frontend.\n            # On same machines based on Slurm, indeed, mpirun/mpiexec is not available\n            # and jobs should be executed with `srun -n4 exec` when running on the computing nodes\n            # or with `exec` when running in sequential on the frontend.\n            if \"job\" in d and \"shell_runner\" in d[\"job\"]:\n                shell_runner = d[\"job\"][\"shell_runner\"]\n                #print(\"shell_runner:\", shell_runner, type(shell_runner))\n                if not shell_runner or shell_runner == \"None\": shell_runner = \"\"\n                d[\"job\"][\"mpi_runner\"] = shell_runner\n                #print(\"shell_runner:\", shell_runner)\n\n        #print(my_kwargs)\n        new = self.__class__(**my_kwargs)\n        new.set_mpi_procs(mpi_procs)\n\n        return new"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a new TaskManager with fixed MPI processes and OpenMP threads.", "response": "def new_with_fixed_mpi_omp(self, mpi_procs, omp_threads):\n        \"\"\"\n        Return a new `TaskManager` in which autoparal has been disabled.\n        The jobs will be executed with `mpi_procs` MPI processes and `omp_threads` OpenMP threads.\n        Useful for generating input files for benchmarks.\n        \"\"\"\n        new = self.deepcopy()\n        new.policy.autoparal = 0\n        new.set_mpi_procs(mpi_procs)\n        new.set_omp_threads(omp_threads)\n        return new"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef select_qadapter(self, pconfs):\n        # Order the list of configurations according to policy.\n        policy, max_ncpus = self.policy, self.max_cores\n        pconfs = pconfs.get_ordered_with_policy(policy, max_ncpus)\n\n        if policy.precedence == \"qadapter\":\n\n            # Try to run on the qadapter with the highest priority.\n            for qadpos, qad in enumerate(self.qads):\n                possible_pconfs = [pc for pc in pconfs if qad.can_run_pconf(pc)]\n\n                if qad.allocation == \"nodes\":\n                #if qad.allocation in [\"nodes\", \"force_nodes\"]:\n                    # Select the configuration divisible by nodes if possible.\n                    for pconf in possible_pconfs:\n                        if pconf.num_cores % qad.hw.cores_per_node == 0:\n                            return self._use_qadpos_pconf(qadpos, pconf)\n\n                # Here we select the first one.\n                if possible_pconfs:\n                    return self._use_qadpos_pconf(qadpos, possible_pconfs[0])\n\n        elif policy.precedence == \"autoparal_conf\":\n            # Try to run on the first pconf irrespectively of the priority of the qadapter.\n            for pconf in pconfs:\n                for qadpos, qad in enumerate(self.qads):\n\n                    if qad.allocation == \"nodes\" and not pconf.num_cores % qad.hw.cores_per_node == 0:\n                        continue # Ignore it. not very clean\n\n                    if qad.can_run_pconf(pconf):\n                        return self._use_qadpos_pconf(qadpos, pconf)\n\n        else:\n            raise ValueError(\"Wrong value of policy.precedence = %s\" % policy.precedence)\n\n        # No qadapter could be found\n        raise RuntimeError(\"Cannot find qadapter for this run!\")", "response": "Given a list of parallel configurations and a list of ParalHints object with the optimal configuration select an appropriate QueueAdapter."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nwrite the submission script. Return the path of the script.", "response": "def write_jobfile(self, task, **kwargs):\n        \"\"\"\n        Write the submission script. Return the path of the script\n\n        ================  ============================================\n        kwargs            Meaning\n        ================  ============================================\n        exec_args         List of arguments passed to task.executable.\n                          Default: no arguments.\n\n        ================  ============================================\n        \"\"\"\n        script = self.qadapter.get_script_str(\n            job_name=task.name,\n            launch_dir=task.workdir,\n            executable=task.executable,\n            qout_path=task.qout_file.path,\n            qerr_path=task.qerr_file.path,\n            stdin=task.files_file.path,\n            stdout=task.log_file.path,\n            stderr=task.stderr_file.path,\n            exec_args=kwargs.pop(\"exec_args\", []),\n        )\n\n        # Write the script.\n        with open(task.job_file.path, \"w\") as fh:\n            fh.write(script)\n            task.job_file.chmod(0o740)\n            return task.job_file.path"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef launch(self, task, **kwargs):\n        if task.status == task.S_LOCKED:\n            raise ValueError(\"You shall not submit a locked task!\")\n\n        # Build the task\n        task.build()\n\n        # Pass information on the time limit to Abinit (we always assume ndtset == 1)\n        if isinstance(task, AbinitTask):\n            args = kwargs.get(\"exec_args\", [])\n            if args is None: args = []\n            args = args[:]\n            args.append(\"--timelimit %s\" % qu.time2slurm(self.qadapter.timelimit))\n            kwargs[\"exec_args\"] = args\n\n        # Write the submission script\n        script_file = self.write_jobfile(task, **kwargs)\n\n        # Submit the task and save the queue id.\n        try:\n            qjob, process = self.qadapter.submit_to_queue(script_file)\n            task.set_status(task.S_SUB, msg='Submitted to queue')\n            task.set_qjob(qjob)\n            return process\n\n        except self.qadapter.MaxNumLaunchesError as exc:\n            # TODO: Here we should try to switch to another qadapter\n            # 1) Find a new parallel configuration in those stored in task.pconfs\n            # 2) Change the input file.\n            # 3) Regenerate the submission script\n            # 4) Relaunch\n            task.set_status(task.S_ERROR, msg=\"max_num_launches reached: %s\" % str(exc))\n            raise", "response": "This method is used to submit the task to the queue and return the Process object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncomparing Abinit version to version_string with operator op", "response": "def compare_version(self, version_string, op):\n        \"\"\"Compare Abinit version to `version_string` with operator `op`\"\"\"\n        from pkg_resources import parse_version\n        from monty.operator import operator_from_str\n        op = operator_from_str(op)\n        return op(parse_version(self.version), parse_version(version_string))"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconverts a MyTimedelta object into a MyTimedelta object.", "response": "def as_timedelta(cls, delta):\n        \"\"\"Convert delta into a MyTimedelta object.\"\"\"\n        # Cannot monkey patch the __class__ and must pass through __new__ as the object is immutable.\n        if isinstance(delta, cls): return delta\n        return cls(delta.days, delta.seconds, delta.microseconds)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the runtime time of the task", "response": "def get_runtime(self):\n        \"\"\":class:`timedelta` with the run-time, None if the Task is not running\"\"\"\n        if self.start is None: return None\n\n        if self.end is None:\n            delta = datetime.datetime.now() - self.start\n        else:\n            delta = self.end - self.start\n\n        return MyTimedelta.as_timedelta(delta)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_time_inqueue(self):\n        if self.submission is None: return None\n\n        if self.start is None:\n            delta = datetime.datetime.now() - self.submission\n        else:\n            delta = self.start - self.submission\n            # This happens when we read the exact start datetime from the ABINIT log file.\n            if delta.total_seconds() < 0: delta = datetime.timedelta(seconds=0)\n\n        return MyTimedelta.as_timedelta(delta)", "response": "Returns the time spent in the Queue."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_workdir(self, workdir, chroot=False):\n        if not chroot and hasattr(self, \"workdir\") and self.workdir != workdir:\n            raise ValueError(\"self.workdir != workdir: %s, %s\" % (self.workdir,  workdir))\n\n        self.workdir = os.path.abspath(workdir)\n\n        # Files required for the execution.\n        self.input_file = File(os.path.join(self.workdir, \"run.abi\"))\n        self.output_file = File(os.path.join(self.workdir, \"run.abo\"))\n        self.files_file = File(os.path.join(self.workdir, \"run.files\"))\n        self.job_file = File(os.path.join(self.workdir, \"job.sh\"))\n        self.log_file = File(os.path.join(self.workdir, \"run.log\"))\n        self.stderr_file = File(os.path.join(self.workdir, \"run.err\"))\n        self.start_lockfile = File(os.path.join(self.workdir, \"__startlock__\"))\n        # This file is produced by Abinit if nprocs > 1 and MPI_ABORT.\n        self.mpiabort_file = File(os.path.join(self.workdir, \"__ABI_MPIABORTFILE__\"))\n\n        # Directories with input|output|temporary data.\n        self.wdir = Directory(self.workdir)\n        self.indir = Directory(os.path.join(self.workdir, \"indata\"))\n        self.outdir = Directory(os.path.join(self.workdir, \"outdata\"))\n        self.tmpdir = Directory(os.path.join(self.workdir, \"tmpdata\"))\n\n        # stderr and output file of the queue manager. Note extensions.\n        self.qerr_file = File(os.path.join(self.workdir, \"queue.qerr\"))\n        self.qout_file = File(os.path.join(self.workdir, \"queue.qout\"))", "response": "Set the working directory for this instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets the : class : Work associated to this Task.", "response": "def set_work(self, work):\n        \"\"\"Set the :class:`Work` associated to this `Task`.\"\"\"\n        if not hasattr(self, \"_work\"):\n            self._work = work\n        else:\n            if self._work != work:\n                raise ValueError(\"self._work != work\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the position of the task in the flow.", "response": "def pos(self):\n        \"\"\"The position of the task in the :class:`Flow`\"\"\"\n        for i, task in enumerate(self.work):\n            if self == task:\n                return self.work.pos, i\n        raise ValueError(\"Cannot find the position of %s in flow %s\" % (self, self.flow))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting the values of the ABINIT variables in the input file. Return dict with old values.", "response": "def set_vars(self, *args, **kwargs):\n        \"\"\"\n        Set the values of the ABINIT variables in the input file. Return dict with old values.\n        \"\"\"\n        kwargs.update(dict(*args))\n        old_values = {vname: self.input.get(vname) for vname in kwargs}\n        self.input.set_vars(**kwargs)\n        if kwargs or old_values:\n            self.history.info(\"Setting input variables: %s\" % str(kwargs))\n            self.history.info(\"Old values: %s\" % str(old_values))\n\n        return old_values"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconstruct the input file of the calculation.", "response": "def make_input(self, with_header=False):\n        \"\"\"Construct the input file of the calculation.\"\"\"\n        s = str(self.input)\n        if with_header: s = str(self) + \"\\n\" + s\n        return s"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the path of the input file with extension ext.", "response": "def ipath_from_ext(self, ext):\n        \"\"\"\n        Returns the path of the input file with extension ext.\n        Use it when the file does not exist yet.\n        \"\"\"\n        return os.path.join(self.workdir, self.prefix.idata + \"_\" + ext)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the path of the output file with extension ext.", "response": "def opath_from_ext(self, ext):\n        \"\"\"\n        Returns the path of the output file with extension ext.\n        Use it when the file does not exist yet.\n        \"\"\"\n        return os.path.join(self.workdir, self.prefix.odata + \"_\" + ext)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncancel the job. Returns 1 if the job was cancelled. Returns 0 if the job was cancelled. Returns 1 if the job was cancelled. Returns 0 if the job was not done. Returns 1 if the job was cancelled. Returns 0 if the job was not done. Returns 1 if the job was cancelled. Returns 0 if the job was not done.", "response": "def cancel(self):\n        \"\"\"Cancel the job. Returns 1 if job was cancelled.\"\"\"\n        if self.queue_id is None: return 0\n        if self.status >= self.S_DONE: return 0\n\n        exit_status = self.manager.cancel(self.queue_id)\n        if exit_status != 0:\n            logger.warning(\"manager.cancel returned exit_status: %s\" % exit_status)\n            return 0\n\n        # Remove output files and reset the status.\n        self.history.info(\"Job %s cancelled by user\" % self.queue_id)\n        self.reset()\n        return 1"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndisabling autoparal and force execution with mpi_procs MPI processes and omp_threads OpenMP threads. Useful for generating benchmarks.", "response": "def with_fixed_mpi_omp(self, mpi_procs, omp_threads):\n        \"\"\"\n        Disable autoparal and force execution with `mpi_procs` MPI processes\n        and `omp_threads` OpenMP threads. Useful for generating benchmarks.\n        \"\"\"\n        manager = self.manager if hasattr(self, \"manager\") else self.flow.manager\n        self.manager = manager.new_with_fixed_mpi_omp(mpi_procs, omp_threads)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef fix_ofiles(self):\n        filepaths = self.outdir.list_filepaths()\n        #logger.info(\"in fix_ofiles with filepaths %s\" % list(filepaths))\n\n        old2new = FilepathFixer().fix_paths(filepaths)\n\n        for old, new in old2new.items():\n            self.history.info(\"will rename old %s to new %s\" % (old, new))\n            os.rename(old, new)", "response": "This method is called when the task reaches S_OK. It will rename all of the files in the output directory to the new ones."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncalling by restart once the task has finished preparing the task for restarting.", "response": "def _restart(self, submit=True):\n        \"\"\"\n        Called by restart once we have finished preparing the task for restarting.\n\n        Return:\n            True if task has been restarted\n        \"\"\"\n        self.set_status(self.S_READY, msg=\"Restarted on %s\" % time.asctime())\n\n        # Increase the counter.\n        self.num_restarts += 1\n        self.history.info(\"Restarted, num_restarts %d\" % self.num_restarts)\n\n        # Reset datetimes\n        self.datetimes.reset()\n\n        # Remove the lock file\n        self.start_lockfile.remove()\n\n        if submit:\n            # Relaunch the task.\n            fired = self.start()\n            if not fired: self.history.warning(\"Restart failed\")\n        else:\n            fired = False\n\n        return fired"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nchecks if child process has terminated. Set and return returncode attribute.", "response": "def poll(self):\n        \"\"\"Check if child process has terminated. Set and return returncode attribute.\"\"\"\n        self._returncode = self.process.poll()\n\n        if self._returncode is not None:\n            self.set_status(self.S_DONE, \"status set to Done\")\n\n        return self._returncode"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef wait(self):\n        self._returncode = self.process.wait()\n        try:\n            self.process.stderr.close()\n        except:\n            pass\n        self.set_status(self.S_DONE, \"status set to Done\")\n\n        return self._returncode", "response": "Wait for child process to terminate. Set and return returncode attribute."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ninteracting with process and return stdout and stderr data.", "response": "def communicate(self, input=None):\n        \"\"\"\n        Interact with process: Send data to stdin. Read data from stdout and stderr, until end-of-file is reached.\n        Wait for process to terminate. The optional input argument should be a string to be sent to the\n        child process, or None, if no data should be sent to the child.\n\n        communicate() returns a tuple (stdoutdata, stderrdata).\n        \"\"\"\n        stdoutdata, stderrdata = self.process.communicate(input=input)\n        self._returncode = self.process.returncode\n        self.set_status(self.S_DONE, \"status set to Done\")\n\n        return stdoutdata, stderrdata"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nresetting the status of the current queue manager.", "response": "def reset(self):\n        \"\"\"\n        Reset the task status. Mainly used if we made a silly mistake in the initial\n        setup of the queue manager and we want to fix it and rerun the task.\n\n        Returns:\n            0 on success, 1 if reset failed.\n        \"\"\"\n        # Can only reset tasks that are done.\n        # One should be able to reset 'Submitted' tasks (sometimes, they are not in the queue\n        # and we want to restart them)\n        #if self.status != self.S_SUB and self.status < self.S_DONE: return 1\n\n        # Remove output files otherwise the EventParser will think the job is still running\n        self.output_file.remove()\n        self.log_file.remove()\n        self.stderr_file.remove()\n        self.start_lockfile.remove()\n        self.qerr_file.remove()\n        self.qout_file.remove()\n        if self.mpiabort_file.exists:\n            self.mpiabort_file.remove()\n\n        self.set_status(self.S_INIT, msg=\"Reset on %s\" % time.asctime())\n        self.num_restarts = 0\n        self.set_qjob(None)\n\n        # Reset finalized flags.\n        self.work.finalized = False\n        self.flow.finalized = False\n\n        return 0"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef lock(self, source_node):\n        if self.status != self.S_INIT:\n            raise ValueError(\"Trying to lock a task with status %s\" % self.status)\n\n        self._status = self.S_LOCKED\n        self.history.info(\"Locked by node %s\", source_node)", "response": "Lock the task, source is the :class:`Node` that applies the lock."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nunlocking the task and set its status to S_READY.", "response": "def unlock(self, source_node, check_status=True):\n        \"\"\"\n        Unlock the task, set its status to `S_READY` so that the scheduler can submit it.\n        source_node is the :class:`Node` that removed the lock\n        Call task.check_status if check_status is True.\n        \"\"\"\n        if self.status != self.S_LOCKED:\n            raise RuntimeError(\"Trying to unlock a task with status %s\" % self.status)\n\n        self._status = self.S_READY\n        if check_status: self.check_status()\n        self.history.info(\"Unlocked by %s\", source_node)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_status(self, status, msg):\n        # truncate string if it's long. msg will be logged in the object and we don't want to waste memory.\n        if len(msg) > 2000:\n            msg = msg[:2000]\n            msg += \"\\n... snip ...\\n\"\n\n        # Locked files must be explicitly unlocked\n        if self.status == self.S_LOCKED or status == self.S_LOCKED:\n            err_msg = (\n                 \"Locked files must be explicitly unlocked before calling set_status but\\n\"\n                 \"task.status = %s, input status = %s\" % (self.status, status))\n            raise RuntimeError(err_msg)\n\n        status = Status.as_status(status)\n\n        changed = True\n        if hasattr(self, \"_status\"):\n            changed = (status != self._status)\n\n        self._status = status\n\n        if status == self.S_RUN:\n            # Set datetimes.start when the task enters S_RUN\n            if self.datetimes.start is None:\n                self.datetimes.start = datetime.datetime.now()\n\n        # Add new entry to history only if the status has changed.\n        if changed:\n            if status == self.S_SUB:\n                self.datetimes.submission = datetime.datetime.now()\n                self.history.info(\"Submitted with MPI=%s, Omp=%s, Memproc=%.1f [Gb] %s \" % (\n                    self.mpi_procs, self.omp_threads, self.mem_per_proc.to(\"Gb\"), msg))\n\n            elif status == self.S_OK:\n                self.history.info(\"Task completed %s\", msg)\n\n            elif status == self.S_ABICRITICAL:\n                self.history.info(\"Status set to S_ABI_CRITICAL due to: %s\", msg)\n\n            else:\n                self.history.info(\"Status changed to %s. msg: %s\", status, msg)\n\n        #######################################################\n        # The section belows contains callbacks that should not\n        # be executed if we are in spectator_mode\n        #######################################################\n        if status == self.S_DONE:\n            # Execute the callback\n            self._on_done()\n\n        if status == self.S_OK:\n            # Finalize the task.\n            if not self.finalized:\n                self._on_ok()\n\n                # here we remove the output files of the task and of its parents.\n                if self.gc is not None and self.gc.policy == \"task\":\n                    self.clean_output_files()\n\n            if self.status == self.S_OK:\n                # Because _on_ok might have changed the status.\n                self.send_signal(self.S_OK)\n\n        return status", "response": "Sets the status of the current task and returns the status of the task."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef check_status(self):\n        # 1) see it the job is blocked\n        # 2) see if an error occured at submitting the job the job was submitted, TODO these problems can be solved\n        # 3) see if there is output\n        # 4) see if abinit reports problems\n        # 5) see if both err files exist and are empty\n        # 6) no output and no err files, the job must still be running\n        # 7) try to find out what caused the problems\n        # 8) there is a problem but we did not figure out what ...\n        # 9) the only way of landing here is if there is a output file but no err files...\n\n        # 1) A locked task can only be unlocked by calling set_status explicitly.\n        # an errored task, should not end up here but just to be sure\n        black_list = (self.S_LOCKED, self.S_ERROR)\n        #if self.status in black_list: return self.status\n\n        # 2) Check the returncode of the job script\n        if self.returncode != 0:\n            msg = \"job.sh return code: %s\\nPerhaps the job was not submitted properly?\" % self.returncode\n            return self.set_status(self.S_QCRITICAL, msg=msg)\n\n        # If we have an abort file produced by Abinit\n        if self.mpiabort_file.exists:\n            return self.set_status(self.S_ABICRITICAL, msg=\"Found ABINIT abort file\")\n\n        # Analyze the stderr file for Fortran runtime errors.\n        # getsize is 0 if the file is empty or it does not exist.\n        err_msg = None\n        if self.stderr_file.getsize() != 0:\n            err_msg = self.stderr_file.read()\n\n        # Analyze the stderr file of the resource manager runtime errors.\n        # TODO: Why are we looking for errors in queue.qerr?\n        qerr_info = None\n        if self.qerr_file.getsize() != 0:\n            qerr_info = self.qerr_file.read()\n\n        # Analyze the stdout file of the resource manager (needed for PBS !)\n        qout_info = None\n        if self.qout_file.getsize():\n            qout_info = self.qout_file.read()\n\n        # Start to check ABINIT status if the output file has been created.\n        #if self.output_file.getsize() != 0:\n        if self.output_file.exists:\n            try:\n                report = self.get_event_report()\n            except Exception as exc:\n                msg = \"%s exception while parsing event_report:\\n%s\" % (self, exc)\n                return self.set_status(self.S_ABICRITICAL, msg=msg)\n\n            if report is None:\n                return self.set_status(self.S_ERROR, msg=\"got None report!\")\n\n            if report.run_completed:\n                # Here we  set the correct timing data reported by Abinit\n                self.datetimes.start = report.start_datetime\n                self.datetimes.end = report.end_datetime\n\n                # Check if the calculation converged.\n                not_ok = report.filter_types(self.CRITICAL_EVENTS)\n                if not_ok:\n                    return self.set_status(self.S_UNCONVERGED, msg='status set to unconverged based on abiout')\n                else:\n                    return self.set_status(self.S_OK, msg=\"status set to ok based on abiout\")\n\n            # Calculation still running or errors?\n            if report.errors:\n                # Abinit reported problems\n                logger.debug('Found errors in report')\n                for error in report.errors:\n                    logger.debug(str(error))\n                    try:\n                        self.abi_errors.append(error)\n                    except AttributeError:\n                        self.abi_errors = [error]\n\n                # The job is unfixable due to ABINIT errors\n                logger.debug(\"%s: Found Errors or Bugs in ABINIT main output!\" % self)\n                msg = \"\\n\".join(map(repr, report.errors))\n                return self.set_status(self.S_ABICRITICAL, msg=msg)\n\n            # 5)\n            if self.stderr_file.exists and not err_msg:\n                if self.qerr_file.exists and not qerr_info:\n                    # there is output and no errors\n                    # The job still seems to be running\n                    return self.set_status(self.S_RUN, msg='there is output and no errors: job still seems to be running')\n\n        # 6)\n        if not self.output_file.exists:\n            logger.debug(\"output_file does not exists\")\n            if not self.stderr_file.exists and not self.qerr_file.exists:\n                # No output at allThe job is still in the queue.\n                return self.status\n\n        # 7) Analyze the files of the resource manager and abinit and execution err (mvs)\n        # MG: This section has been disabled: several portability issues\n        # Need more robust logic in error_parser, perhaps logic provided by users via callbacks.\n        if False and (qerr_info or qout_info):\n            from pymatgen.io.abinit.scheduler_error_parsers import get_parser\n            scheduler_parser = get_parser(self.manager.qadapter.QTYPE, err_file=self.qerr_file.path,\n                                          out_file=self.qout_file.path, run_err_file=self.stderr_file.path)\n\n            if scheduler_parser is None:\n                return self.set_status(self.S_QCRITICAL,\n                                       msg=\"Cannot find scheduler_parser for qtype %s\" % self.manager.qadapter.QTYPE)\n\n            scheduler_parser.parse()\n\n            if scheduler_parser.errors:\n                # Store the queue errors in the task\n                self.queue_errors = scheduler_parser.errors\n                # The job is killed or crashed and we know what happened\n                msg = \"scheduler errors found:\\n%s\" % str(scheduler_parser.errors)\n                return self.set_status(self.S_QCRITICAL, msg=msg)\n\n            elif lennone(qerr_info) > 0:\n                # if only qout_info, we are not necessarily in QCRITICAL state,\n                # since there will always be info in the qout file\n                self.history.info('Found unknown message in the queue qerr file: %s' % str(qerr_info))\n                #try:\n                #    rt = self.datetimes.get_runtime().seconds\n                #except:\n                #    rt = -1.0\n                #tl = self.manager.qadapter.timelimit\n                #if rt > tl:\n                #    msg += 'set to error : runtime (%s) exceded walltime (%s)' % (rt, tl)\n                #    print(msg)\n                #    return self.set_status(self.S_ERROR, msg=msg)\n                # The job may be killed or crashed but we don't know what happened\n                # It may also be that an innocent message was written to qerr, so we wait for a while\n                # it is set to QCritical, we will attempt to fix it by running on more resources\n\n        # 8) analyzing the err files and abinit output did not identify a problem\n        # but if the files are not empty we do have a problem but no way of solving it:\n        # The job is killed or crashed but we don't know what happend\n        # it is set to QCritical, we will attempt to fix it by running on more resources\n        if err_msg:\n            msg = 'Found error message:\\n %s' % str(err_msg)\n            self.history.warning(msg)\n            #return self.set_status(self.S_QCRITICAL, msg=msg)\n\n        # 9) if we still haven't returned there is no indication of any error and the job can only still be running\n        # but we should actually never land here, or we have delays in the file system ....\n        # print('the job still seems to be running maybe it is hanging without producing output... ')\n\n        # Check time of last modification.\n        if self.output_file.exists and \\\n           (time.time() - self.output_file.get_stat().st_mtime > self.manager.policy.frozen_timeout):\n            msg = \"Task seems to be frozen, last change more than %s [s] ago\" % self.manager.policy.frozen_timeout\n            return self.set_status(self.S_ERROR, msg=msg)\n\n        # Handle weird case in which either run.abo, or run.log have not been produced\n        #if self.status not in (self.S_INIT, self.S_READY) and (not self.output.file.exists or not self.log_file.exits):\n        #    msg = \"Task have been submitted but cannot find the log file or the output file\"\n        #    return self.set_status(self.S_ERROR, msg)\n\n        return self.set_status(self.S_RUN, msg='final option: nothing seems to be wrong, the job must still be running')", "response": "This function checks the status of the job and returns the status of the job."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef out_to_in(self, out_file):\n        in_file = os.path.basename(out_file).replace(\"out\", \"in\", 1)\n        dest = os.path.join(self.indir.path, in_file)\n\n        if os.path.exists(dest) and not os.path.islink(dest):\n            logger.warning(\"Will overwrite %s with %s\" % (dest, out_file))\n\n        os.rename(out_file, dest)\n        return dest", "response": "Move an output file to the output data directory of the Task and rename it so that ABINIT will read it as an input data file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nlinking the specified file to the destination file.", "response": "def inlink_file(self, filepath):\n        \"\"\"\n        Create a symbolic link to the specified file in the\n        directory containing the input files of the task.\n        \"\"\"\n        if not os.path.exists(filepath):\n            logger.debug(\"Creating symbolic link to not existent file %s\" % filepath)\n\n        # Extract the Abinit extension and add the prefix for input files.\n        root, abiext = abi_splitext(filepath)\n\n        infile = \"in_\" + abiext\n        infile = self.indir.path_in(infile)\n\n        # Link path to dest if dest link does not exist.\n        # else check that it points to the expected file.\n        self.history.info(\"Linking path %s --> %s\" % (filepath, infile))\n\n        if not os.path.exists(infile):\n            os.symlink(filepath, infile)\n        else:\n            if os.path.realpath(infile) != filepath:\n                raise self.Error(\"infile %s does not point to filepath %s\" % (infile, filepath))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating symbolic links to the output files produced by other tasks.", "response": "def make_links(self):\n        \"\"\"\n        Create symbolic links to the output files produced by the other tasks.\n\n        .. warning::\n\n            This method should be called only when the calculation is READY because\n            it uses a heuristic approach to find the file to link.\n        \"\"\"\n        for dep in self.deps:\n            filepaths, exts = dep.get_filepaths_and_exts()\n\n            for path, ext in zip(filepaths, exts):\n                logger.info(\"Need path %s with ext %s\" % (path, ext))\n                dest = self.ipath_from_ext(ext)\n\n                if not os.path.exists(path):\n                    # Try netcdf file.\n                    # TODO: this case should be treated in a cleaner way.\n                    path += \".nc\"\n                    if os.path.exists(path): dest += \".nc\"\n\n                if not os.path.exists(path):\n                    raise self.Error(\"%s: %s is needed by this task but it does not exist\" % (self, path))\n\n                if path.endswith(\".nc\") and not dest.endswith(\".nc\"): # NC --> NC file\n                    dest += \".nc\"\n\n                # Link path to dest if dest link does not exist.\n                # else check that it points to the expected file.\n                logger.debug(\"Linking path %s --> %s\" % (path, dest))\n                if not os.path.exists(dest):\n                    os.symlink(path, dest)\n                else:\n                    # check links but only if we haven't performed the restart.\n                    # in this case, indeed we may have replaced the file pointer with the\n                    # previous output file of the present task.\n                    if os.path.realpath(dest) != path and self.num_restarts == 0:\n                        raise self.Error(\"\\nDestination:\\n %s\\ndoes not point to path:\\n %s\" % (dest, path))"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the event report for the given source.", "response": "def get_event_report(self, source=\"log\"):\n        \"\"\"\n        Analyzes the main logfile of the calculation for possible Errors or Warnings.\n        If the ABINIT abort file is found, the error found in this file are added to\n        the output report.\n\n        Args:\n            source: \"output\" for the main output file,\"log\" for the log file.\n\n        Returns:\n            :class:`EventReport` instance or None if the source file file does not exist.\n        \"\"\"\n        # By default, we inspect the main log file.\n        ofile = {\n            \"output\": self.output_file,\n            \"log\": self.log_file}[source]\n\n        parser = events.EventsParser()\n\n        if not ofile.exists:\n            if not self.mpiabort_file.exists:\n                return None\n            else:\n                # ABINIT abort file without log!\n                abort_report = parser.parse(self.mpiabort_file.path)\n                return abort_report\n\n        try:\n            report = parser.parse(ofile.path)\n            #self._prev_reports[source] = report\n\n            # Add events found in the ABI_MPIABORTFILE.\n            if self.mpiabort_file.exists:\n                logger.critical(\"Found ABI_MPIABORTFILE!!!!!\")\n                abort_report = parser.parse(self.mpiabort_file.path)\n                if len(abort_report) != 1:\n                    logger.critical(\"Found more than one event in ABI_MPIABORTFILE\")\n\n                # Weird case: empty abort file, let's skip the part\n                # below and hope that the log file contains the error message.\n                #if not len(abort_report): return report\n\n                # Add it to the initial report only if it differs\n                # from the last one found in the main log file.\n                last_abort_event = abort_report[-1]\n                if report and last_abort_event != report[-1]:\n                    report.append(last_abort_event)\n                else:\n                    report.append(last_abort_event)\n\n            return report\n\n        #except parser.Error as exc:\n        except Exception as exc:\n            # Return a report with an error entry with info on the exception.\n            msg = \"%s: Exception while parsing ABINIT events:\\n %s\" % (ofile, str(exc))\n            self.set_status(self.S_ABICRITICAL, msg=msg)\n            return parser.report_exception(ofile.path, exc)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a NodeResults instance.", "response": "def get_results(self, **kwargs):\n        \"\"\"\n        Returns :class:`NodeResults` instance.\n        Subclasses should extend this method (if needed) by adding\n        specialized code that performs some kind of post-processing.\n        \"\"\"\n        # Check whether the process completed.\n        if self.returncode is None:\n            raise self.Error(\"return code is None, you should call wait, communicate or poll\")\n\n        if self.status is None or self.status < self.S_DONE:\n            raise self.Error(\"Task is not completed\")\n\n        return self.Results.from_node(self)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nrenaming a file located in datadir.", "response": "def rename(self, src_basename, dest_basename, datadir=\"outdir\"):\n        \"\"\"\n        Rename a file located in datadir.\n\n        src_basename and dest_basename are the basename of the source file\n        and of the destination file, respectively.\n        \"\"\"\n        directory = {\n            \"indir\": self.indir,\n            \"outdir\": self.outdir,\n            \"tmpdir\": self.tmpdir,\n        }[datadir]\n\n        src = directory.path_in(src_basename)\n        dest = directory.path_in(dest_basename)\n\n        os.rename(src, dest)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef build(self, *args, **kwargs):\n        # Create dirs for input, output and tmp data.\n        self.indir.makedirs()\n        self.outdir.makedirs()\n        self.tmpdir.makedirs()\n\n        # Write files file and input file.\n        if not self.files_file.exists:\n            self.files_file.write(self.filesfile_string)\n\n        self.input_file.write(self.make_input())\n        self.manager.write_jobfile(self)", "response": "Creates the working directory and the input files of the Task."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef remove_files(self, *filenames):\n        filenames = list_strings(filenames)\n\n        for dirpath, dirnames, fnames in os.walk(self.workdir):\n            for fname in fnames:\n                if fname in filenames:\n                    filepath = os.path.join(dirpath, fname)\n                    os.remove(filepath)", "response": "Remove all the files listed in filenames."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef clean_output_files(self, follow_parents=True):\n        paths = []\n        if self.status != self.S_OK:\n            logger.warning(\"Calling task.clean_output_files on a task whose status != S_OK\")\n\n        # Remove all files in tmpdir.\n        self.tmpdir.clean()\n\n        # Find the file extensions that should be preserved since these files are still\n        # needed by the children who haven't reached S_OK\n        except_exts = set()\n        for child in self.get_children():\n            if child.status == self.S_OK: continue\n            # Find the position of self in child.deps and add the extensions.\n            i = [dep.node for dep in child.deps].index(self)\n            except_exts.update(child.deps[i].exts)\n\n        # Remove the files in the outdir of the task but keep except_exts.\n        exts = self.gc.exts.difference(except_exts)\n        #print(\"Will remove its extensions: \", exts)\n        paths += self.outdir.remove_exts(exts)\n        if not follow_parents: return paths\n\n        # Remove the files in the outdir of my parents if all the possible dependencies have been fulfilled.\n        for parent in self.get_parents():\n\n            # Here we build a dictionary file extension --> list of child nodes requiring this file from parent\n            # e.g {\"WFK\": [node1, node2]}\n            ext2nodes = collections.defaultdict(list)\n            for child in parent.get_children():\n                if child.status == child.S_OK: continue\n                i = [d.node for d in child.deps].index(parent)\n                for ext in child.deps[i].exts:\n                    ext2nodes[ext].append(child)\n\n            # Remove extension only if no node depends on it!\n            except_exts = [k for k, lst in ext2nodes.items() if lst]\n            exts = self.gc.exts.difference(except_exts)\n            #print(\"%s removes extensions %s from parent node %s\" % (self, exts, parent))\n            paths += parent.outdir.remove_exts(exts)\n\n        self.history.info(\"Removed files: %s\" % paths)\n        return paths", "response": "This method removes all the output files that are needed by the task and all its children."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef start(self, **kwargs):\n        if self.status >= self.S_SUB:\n            raise self.Error(\"Task status: %s\" % str(self.status))\n\n        if self.start_lockfile.exists:\n            self.history.warning(\"Found lock file: %s\" % self.start_lockfile.path)\n            return 0\n\n        self.start_lockfile.write(\"Started on %s\" % time.asctime())\n\n        self.build()\n        self._setup()\n\n        # Add the variables needed to connect the node.\n        for d in self.deps:\n            cvars = d.connecting_vars()\n            self.history.info(\"Adding connecting vars %s\" % cvars)\n            self.set_vars(cvars)\n\n            # Get (python) data from other nodes\n            d.apply_getters(self)\n\n        # Automatic parallelization\n        if kwargs.pop(\"autoparal\", True) and hasattr(self, \"autoparal_run\"):\n            try:\n                self.autoparal_run()\n            #except QueueAdapterError as exc:\n            #    # If autoparal cannot find a qadapter to run the calculation raises an Exception\n            #    self.history.critical(exc)\n            #    msg = \"Error while trying to run autoparal in task:%s\\n%s\" % (repr(task), straceback())\n            #    cprint(msg, \"yellow\")\n            #    self.set_status(self.S_QCRITICAL, msg=msg)\n            #    return 0\n            except Exception as exc:\n                # Sometimes autoparal_run fails because Abinit aborts\n                # at the level of the parser e.g. cannot find the spacegroup\n                # due to some numerical noise in the structure.\n                # In this case we call fix_abicritical and then we try to run autoparal again.\n                self.history.critical(\"First call to autoparal failed with `%s`. Will try fix_abicritical\" % exc)\n                msg = \"autoparal_fake_run raised:\\n%s\" % straceback()\n                logger.critical(msg)\n\n                fixed = self.fix_abicritical()\n                if not fixed:\n                    self.set_status(self.S_ABICRITICAL, msg=\"fix_abicritical could not solve the problem\")\n                    return 0\n\n                try:\n                    self.autoparal_run()\n                    self.history.info(\"Second call to autoparal succeeded!\")\n                    #cprint(\"Second call to autoparal succeeded!\", \"green\")\n\n                except Exception as exc:\n                    self.history.critical(\"Second call to autoparal failed with %s. Cannot recover!\", exc)\n                    msg = \"Tried autoparal again but got:\\n%s\" % straceback()\n                    cprint(msg, \"red\")\n                    self.set_status(self.S_ABICRITICAL, msg=msg)\n                    return 0\n\n        # Start the calculation in a subprocess and return.\n        self._process = self.manager.launch(self, **kwargs)\n        return 1", "response": "Starts the calculation by performing the necessary steps."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef start_and_wait(self, *args, **kwargs):\n        self.start(*args, **kwargs)\n        retcode = self.wait()\n        return retcode", "response": "Start the task and wait for completion."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_graphviz(self, engine=\"automatic\", graph_attr=None, node_attr=None, edge_attr=None):\n        # https://www.graphviz.org/doc/info/\n        from graphviz import Digraph\n        fg = Digraph(\"task\", # filename=\"task_%s.gv\" % os.path.basename(self.workdir),\n            engine=\"dot\" if engine == \"automatic\" else engine)\n\n        # Set graph attributes.\n        #fg.attr(label=\"%s@%s\" % (self.__class__.__name__, self.relworkdir))\n        fg.attr(label=repr(self))\n        #fg.attr(fontcolor=\"white\", bgcolor='purple:pink')\n        #fg.attr(rankdir=\"LR\", pagedir=\"BL\")\n        #fg.attr(constraint=\"false\", pack=\"true\", packMode=\"clust\")\n        fg.node_attr.update(color='lightblue2', style='filled')\n\n        # Add input attributes.\n        if graph_attr is not None:\n            fg.graph_attr.update(**graph_attr)\n        if node_attr is not None:\n            fg.node_attr.update(**node_attr)\n        if edge_attr is not None:\n            fg.edge_attr.update(**edge_attr)\n\n        def node_kwargs(node):\n            return dict(\n                #shape=\"circle\",\n                color=node.color_hex,\n                label=(str(node) if not hasattr(node, \"pos_str\") else\n                    node.pos_str + \"\\n\" + node.__class__.__name__),\n            )\n\n        edge_kwargs = dict(arrowType=\"vee\", style=\"solid\")\n        cluster_kwargs = dict(rankdir=\"LR\", pagedir=\"BL\", style=\"rounded\", bgcolor=\"azure2\")\n\n        # Build cluster with tasks.\n        cluster_name = \"cluster%s\" % self.work.name\n        with fg.subgraph(name=cluster_name) as wg:\n            wg.attr(**cluster_kwargs)\n            wg.attr(label=\"%s (%s)\" % (self.__class__.__name__, self.name))\n            wg.node(self.name, **node_kwargs(self))\n\n            # Connect task to children.\n            for child in self.get_children():\n                # Test if child is in the same work.\n                myg = wg if child in self.work else fg\n                myg.node(child.name, **node_kwargs(child))\n                # Find file extensions required by this task\n                i = [dep.node for dep in child.deps].index(self)\n                edge_label = \"+\".join(child.deps[i].exts)\n                myg.edge(self.name, child.name, label=edge_label, color=self.color_hex,\n                         **edge_kwargs)\n\n            # Connect task to parents\n            for parent in self.get_parents():\n                # Test if parent is in the same work.\n                myg = wg if parent in self.work else fg\n                myg.node(parent.name, **node_kwargs(parent))\n                # Find file extensions required by self (task)\n                i = [dep.node for dep in self.deps].index(parent)\n                edge_label = \"+\".join(self.deps[i].exts)\n                myg.edge(parent.name, self.name, label=edge_label, color=parent.color_hex,\n                         **edge_kwargs)\n\n        # Treat the case in which we have a work producing output for other tasks.\n        #for work in self:\n        #    children = work.get_children()\n        #    if not children: continue\n        #    cluster_name = \"cluster%s\" % work.name\n        #    seen = set()\n        #    for child in children:\n        #        # This is not needed, too much confusing\n        #        #fg.edge(cluster_name, child.name, color=work.color_hex, **edge_kwargs)\n        #        # Find file extensions required by work\n        #        i = [dep.node for dep in child.deps].index(work)\n        #        for ext in child.deps[i].exts:\n        #            out = \"%s (%s)\" % (ext, work.name)\n        #            fg.node(out)\n        #            fg.edge(out, child.name, **edge_kwargs)\n        #            key = (cluster_name, out)\n        #            if key not in seen:\n        #                fg.edge(cluster_name, out, color=work.color_hex, **edge_kwargs)\n        #                seen.add(key)\n\n        return fg", "response": "Generate a task graph in the DOT language."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate an instance of AbinitTask from an input.", "response": "def from_input(cls, input, workdir=None, manager=None):\n        \"\"\"\n        Create an instance of `AbinitTask` from an ABINIT input.\n\n        Args:\n            ainput: `AbinitInput` object.\n            workdir: Path to the working directory.\n            manager: :class:`TaskManager` object.\n        \"\"\"\n        return cls(input, workdir=workdir, manager=manager)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nbuild a Task with a temporary workdir.", "response": "def temp_shell_task(cls, inp, mpi_procs=1, workdir=None, manager=None):\n        \"\"\"\n        Build a Task with a temporary workdir. The task is executed via the shell with 1 MPI proc.\n        Mainly used for invoking Abinit to get important parameters needed to prepare the real task.\n\n        Args:\n            mpi_procs: Number of MPI processes to use.\n        \"\"\"\n        # Build a simple manager to run the job in a shell subprocess\n        import tempfile\n        workdir = tempfile.mkdtemp() if workdir is None else workdir\n        if manager is None: manager = TaskManager.from_user_config()\n\n        # Construct the task and run it\n        task = cls.from_input(inp, workdir=workdir, manager=manager.to_shell_manager(mpi_procs=mpi_procs))\n        task.set_name('temp_shell_task')\n        return task"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef setup(self):\n        def rename_file(afile):\n            \"\"\"Helper function to rename :class:`File` objects. Return string for logging purpose.\"\"\"\n            # Find the index of the last file (if any).\n            # TODO: Maybe it's better to use run.abo --> run(1).abo\n            fnames = [f for f in os.listdir(self.workdir) if f.startswith(afile.basename)]\n            nums = [int(f) for f in [f.split(\"_\")[-1] for f in fnames] if f.isdigit()]\n            last = max(nums) if nums else 0\n            new_path = afile.path + \"_\" + str(last+1)\n\n            os.rename(afile.path, new_path)\n            return \"Will rename %s to %s\" % (afile.path, new_path)\n\n        logs = []\n        if self.output_file.exists: logs.append(rename_file(self.output_file))\n        if self.log_file.exists: logs.append(rename_file(self.log_file))\n\n        if logs:\n            self.history.info(\"\\n\".join(logs))", "response": "This function is called by Abinit when the application is ready to start the process."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef cycle_class(self):\n        if isinstance(self, RelaxTask):\n            return abiinspect.Relaxation\n        elif isinstance(self, GsTask):\n            return abiinspect.GroundStateScfCycle\n        elif self.is_dfpt_task:\n            return abiinspect.D2DEScfCycle\n\n        return None", "response": "Returns the subclass of ScfCycle associated to the task or None if no SCF algorithm is associated to the task."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a string with the list of files and prefixes needed to execute ABINIT.", "response": "def filesfile_string(self):\n        \"\"\"String with the list of files and prefixes needed to execute ABINIT.\"\"\"\n        lines = []\n        app = lines.append\n        pj = os.path.join\n\n        app(self.input_file.path)                 # Path to the input file\n        app(self.output_file.path)                # Path to the output file\n        app(pj(self.workdir, self.prefix.idata))  # Prefix for input data\n        app(pj(self.workdir, self.prefix.odata))  # Prefix for output data\n        app(pj(self.workdir, self.prefix.tdata))  # Prefix for temporary data\n\n        # Paths to the pseudopotential files.\n        # Note that here the pseudos **must** be sorted according to znucl.\n        # Here we reorder the pseudos if the order is wrong.\n        ord_pseudos = []\n\n        znucl = [specie.number for specie in\n                 self.input.structure.types_of_specie]\n\n        for z in znucl:\n            for p in self.pseudos:\n                if p.Z == z:\n                    ord_pseudos.append(p)\n                    break\n            else:\n                raise ValueError(\"Cannot find pseudo with znucl %s in pseudos:\\n%s\" % (z, self.pseudos))\n\n        for pseudo in ord_pseudos:\n            app(pseudo.path)\n\n        return \"\\n\".join(lines)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ntrue if the task is a GS Task and uses paral_kgb with the given value.", "response": "def uses_paral_kgb(self, value=1):\n        \"\"\"True if the task is a GS Task and uses paral_kgb with the given value.\"\"\"\n        paral_kgb = self.get_inpvar(\"paral_kgb\", 0)\n        # paral_kgb is used only in the GS part.\n        return paral_kgb == value and isinstance(self, GsTask)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nchanges the input structure.", "response": "def _change_structure(self, new_structure):\n        \"\"\"Change the input structure.\"\"\"\n        # Compare new and old structure for logging purpose.\n        # TODO: Write method of structure to compare self and other and return a dictionary\n        old_structure = self.input.structure\n        old_lattice = old_structure.lattice\n\n        abc_diff = np.array(new_structure.lattice.abc) - np.array(old_lattice.abc)\n        angles_diff = np.array(new_structure.lattice.angles) - np.array(old_lattice.angles)\n        cart_diff = new_structure.cart_coords - old_structure.cart_coords\n        displs = np.array([np.sqrt(np.dot(v, v)) for v in cart_diff])\n\n        recs, tol_angle, tol_length = [], 10**-2, 10**-5\n\n        if np.any(np.abs(angles_diff) > tol_angle):\n            recs.append(\"new_agles - old_angles = %s\" % angles_diff)\n\n        if np.any(np.abs(abc_diff) > tol_length):\n            recs.append(\"new_abc - old_abc = %s\" % abc_diff)\n\n        if np.any(np.abs(displs) > tol_length):\n            min_pos, max_pos = displs.argmin(), displs.argmax()\n            recs.append(\"Mean displ: %.2E, Max_displ: %.2E (site %d), min_displ: %.2E (site %d)\" %\n                (displs.mean(), displs[max_pos], max_pos, displs[min_pos], min_pos))\n\n        self.history.info(\"Changing structure (only significant diffs are shown):\")\n        if not recs:\n            self.history.info(\"Input and output structure seems to be equal within the given tolerances\")\n        else:\n            for rec in recs:\n                self.history.info(rec)\n\n        self.input.set_structure(new_structure)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nfind an optimal set of parameters for the execution of the task This method can change the ABINIT input variables and/or the submission parameters e.g. the number of CPUs for MPI and OpenMp. Set: self.pconfs where pconfs is a :class:`ParalHints` object with the configuration reported by autoparal and optimal is the optimal configuration selected. Returns 0 if success", "response": "def autoparal_run(self):\n        \"\"\"\n        Find an optimal set of parameters for the execution of the task\n        This method can change the ABINIT input variables and/or the\n        submission parameters e.g. the number of CPUs for MPI and OpenMp.\n\n        Set:\n           self.pconfs where pconfs is a :class:`ParalHints` object with the configuration reported by\n           autoparal and optimal is the optimal configuration selected.\n           Returns 0 if success\n        \"\"\"\n        policy = self.manager.policy\n\n        if policy.autoparal == 0: # or policy.max_ncpus in [None, 1]:\n            logger.info(\"Nothing to do in autoparal, returning (None, None)\")\n            return 0\n\n        if policy.autoparal != 1:\n            raise NotImplementedError(\"autoparal != 1\")\n\n        ############################################################################\n        # Run ABINIT in sequential to get the possible configurations with max_ncpus\n        ############################################################################\n\n        # Set the variables for automatic parallelization\n        # Will get all the possible configurations up to max_ncpus\n        # Return immediately if max_ncpus == 1\n        max_ncpus = self.manager.max_cores\n        if max_ncpus == 1: return 0\n\n        autoparal_vars = dict(autoparal=policy.autoparal, max_ncpus=max_ncpus, mem_test=0)\n        self.set_vars(autoparal_vars)\n\n        # Run the job in a shell subprocess with mpi_procs = 1\n        # we don't want to make a request to the queue manager for this simple job!\n        # Return code is always != 0\n        process = self.manager.to_shell_manager(mpi_procs=1).launch(self)\n        self.history.pop()\n        retcode = process.wait()\n        # To avoid: ResourceWarning: unclosed file <_io.BufferedReader name=87> in py3k\n        process.stderr.close()\n        #process.stdout.close()\n\n        # Remove the variables added for the automatic parallelization\n        self.input.remove_vars(list(autoparal_vars.keys()))\n\n        ##############################################################\n        # Parse the autoparal configurations from the main output file\n        ##############################################################\n        parser = ParalHintsParser()\n        try:\n            pconfs = parser.parse(self.output_file.path)\n        except parser.Error:\n            # In principle Abinit should have written a complete log file\n            # because we called .wait() but sometimes the Yaml doc is incomplete and\n            # the parser raises. Let's wait 5 secs and then try again.\n            time.sleep(5)\n            try:\n                pconfs = parser.parse(self.output_file.path)\n            except parser.Error:\n                logger.critical(\"Error while parsing Autoparal section:\\n%s\" % straceback())\n                return 2\n\n        ######################################################\n        # Select the optimal configuration according to policy\n        ######################################################\n        optconf = self.find_optconf(pconfs)\n\n        ####################################################\n        # Change the input file and/or the submission script\n        ####################################################\n        self.set_vars(optconf.vars)\n\n        # Write autoparal configurations to JSON file.\n        d = pconfs.as_dict()\n        d[\"optimal_conf\"] = optconf\n        json_pretty_dump(d, os.path.join(self.workdir, \"autoparal.json\"))\n\n        ##############\n        # Finalization\n        ##############\n        # Reset the status, remove garbage files ...\n        self.set_status(self.S_INIT, msg='finished autoparal run')\n\n        # Remove the output file since Abinit likes to create new files\n        # with extension .outA, .outB if the file already exists.\n        os.remove(self.output_file.path)\n        os.remove(self.log_file.path)\n        os.remove(self.stderr_file.path)\n\n        return 0"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nfind the optimal Parallel configuration.", "response": "def find_optconf(self, pconfs):\n        \"\"\"Find the optimal Parallel configuration.\"\"\"\n        # Save pconfs for future reference.\n        self.set_pconfs(pconfs)\n\n        # Select the partition on which we'll be running and set MPI/OMP cores.\n        optconf = self.manager.select_qadapter(pconfs)\n        return optconf"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef fix_abicritical(self):\n        event_handlers = self.event_handlers\n        if not event_handlers:\n            self.set_status(status=self.S_ERROR, msg='Empty list of event handlers. Cannot fix abi_critical errors')\n            return 0\n\n        count, done = 0, len(event_handlers) * [0]\n\n        report = self.get_event_report()\n        if report is None:\n            self.set_status(status=self.S_ERROR, msg='get_event_report returned None')\n            return 0\n\n        # Note we have loop over all possible events (slow, I know)\n        # because we can have handlers for Error, Bug or Warning\n        # (ideally only for CriticalWarnings but this is not done yet)\n        for event in report:\n            for i, handler in enumerate(self.event_handlers):\n\n                if handler.can_handle(event) and not done[i]:\n                    logger.info(\"handler %s will try to fix event %s\" % (handler, event))\n                    try:\n                        d = handler.handle_task_event(self, event)\n                        if d:\n                            done[i] += 1\n                            count += 1\n\n                    except Exception as exc:\n                        logger.critical(str(exc))\n\n        if count:\n            self.reset_from_scratch()\n            return 1\n\n        self.set_status(status=self.S_ERROR, msg='We encountered AbiCritical events that could not be fixed')\n        return 0", "response": "method to fix crashes and error caused by abinit\n            returns 1 if task has been fixed else 0"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nparse the timer data in the main output file of Abinit.", "response": "def parse_timing(self):\n        \"\"\"\n        Parse the timer data in the main output file of Abinit.\n        Requires timopt /= 0 in the input file (usually timopt = -1)\n\n        Return: :class:`AbinitTimerParser` instance, None if error.\n        \"\"\"\n        from .abitimer import AbinitTimerParser\n        parser = AbinitTimerParser()\n        read_ok = parser.parse(self.output_file.path)\n        if read_ok:\n            return parser\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nopening the HIST file located in the in self. outdir. Returns None if file could not be opened.", "response": "def open_hist(self):\n        \"\"\"\n        Open the HIST file located in the in self.outdir.\n        Returns :class:`HistFile` object, None if file could not be found or file is not readable.\n        \"\"\"\n        if not self.hist_path:\n            if self.status == self.S_OK:\n                logger.critical(\"%s reached S_OK but didn't produce a HIST file in %s\" % (self, self.outdir))\n            return None\n\n        # Open the HIST file\n        from abipy.dynamics.hist import HistFile\n        try:\n            return HistFile(self.hist_path)\n        except Exception as exc:\n            logger.critical(\"Exception while reading HIST file at %s:\\n%s\" % (self.hist_path, str(exc)))\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef open_gsr(self):\n        gsr_path = self.gsr_path\n        if not gsr_path:\n            if self.status == self.S_OK:\n                logger.critical(\"%s reached S_OK but didn't produce a GSR file in %s\" % (self, self.outdir))\n            return None\n\n        # Open the GSR file.\n        from abipy.electrons.gsr import GsrFile\n        try:\n            return GsrFile(gsr_path)\n        except Exception as exc:\n            logger.critical(\"Exception while reading GSR file at %s:\\n%s\" % (gsr_path, str(exc)))\n            return None", "response": "Open the GSR file located in the in self. outdir. Returns None if file could not be opened."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef inspect(self, **kwargs):\n        try:\n            scf_cycle = abiinspect.GroundStateScfCycle.from_file(self.output_file.path)\n        except IOError:\n            return None\n\n        if scf_cycle is not None:\n            if \"title\" not in kwargs: kwargs[\"title\"] = str(self)\n            return scf_cycle.plot(**kwargs)\n\n        return None", "response": "Plot the SCF cycle results with matplotlib."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset up the NSCF calculations for this task.", "response": "def setup(self):\n        \"\"\"\n        NSCF calculations should use the same FFT mesh as the one employed in the GS task\n        (in principle, it's possible to interpolate inside Abinit but tests revealed some numerical noise\n        Here we change the input file of the NSCF task to have the same FFT mesh.\n        \"\"\"\n        for dep in self.deps:\n            if \"DEN\" in dep.exts:\n                parent_task = dep.node\n                break\n        else:\n            raise RuntimeError(\"Cannot find parent node producing DEN file\")\n\n        with parent_task.open_gsr() as gsr:\n            den_mesh = 3 * [None]\n            den_mesh[0] = gsr.reader.read_dimvalue(\"number_of_grid_points_vector1\")\n            den_mesh[1] = gsr.reader.read_dimvalue(\"number_of_grid_points_vector2\")\n            den_mesh[2] = gsr.reader.read_dimvalue(\"number_of_grid_points_vector3\")\n            if self.ispaw:\n                self.set_vars(ngfftdg=den_mesh)\n            else:\n                self.set_vars(ngfft=den_mesh)\n\n        super().setup()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef restart(self):\n        restart_file = None\n\n        # Try to restart from the WFK file if possible.\n        # FIXME: This part has been disabled because WFK=IO is a mess if paral_kgb == 1\n        # This is also the reason why I wrote my own MPI-IO code for the GW part!\n        wfk_file = self.outdir.has_abiext(\"WFK\")\n        if False and wfk_file:\n            irdvars = irdvars_for_ext(\"WFK\")\n            restart_file = self.out_to_in(wfk_file)\n\n        # Fallback to DEN file. Note that here we look for out_DEN instead of out_TIM?_DEN\n        # This happens when the previous run completed and task.on_done has been performed.\n        # ********************************************************************************\n        # Note that it's possible to have an undetected error if we have multiple restarts\n        # and the last relax died badly. In this case indeed out_DEN is the file produced\n        # by the last run that has executed on_done.\n        # ********************************************************************************\n        if restart_file is None:\n            for ext in (\"\", \".nc\"):\n                out_den = self.outdir.path_in(\"out_DEN\" + ext)\n                if os.path.exists(out_den):\n                    irdvars = irdvars_for_ext(\"DEN\")\n                    restart_file = self.out_to_in(out_den)\n                    break\n\n        if restart_file is None:\n            # Try to restart from the last TIM?_DEN file.\n            # This should happen if the previous run didn't complete in clean way.\n            # Find the last TIM?_DEN file.\n            last_timden = self.outdir.find_last_timden_file()\n            if last_timden is not None:\n                if last_timden.path.endswith(\".nc\"):\n                    ofile = self.outdir.path_in(\"out_DEN.nc\")\n                else:\n                    ofile = self.outdir.path_in(\"out_DEN\")\n                os.rename(last_timden.path, ofile)\n                restart_file = self.out_to_in(ofile)\n                irdvars = irdvars_for_ext(\"DEN\")\n\n        if restart_file is None:\n            # Don't raise RestartError as we can still change the structure.\n            self.history.warning(\"Cannot find the WFK|DEN|TIM?_DEN file to restart from.\")\n        else:\n            # Add the appropriate variable for restarting.\n            self.set_vars(irdvars)\n            self.history.info(\"Will restart from %s\", restart_file)\n\n        # FIXME Here we should read the HIST file but restartxf if broken!\n        #self.set_vars({\"restartxf\": -1})\n\n        # Read the relaxed structure from the GSR file and change the input.\n        self._change_structure(self.get_final_structure())\n\n        # Now we can resubmit the job.\n        return self._restart()", "response": "Restart the structure relaxation for the current entry."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nplot the evolution of the structural relaxation with matplotlib.", "response": "def inspect(self, **kwargs):\n        \"\"\"\n        Plot the evolution of the structural relaxation with matplotlib.\n\n        Args:\n            what: Either \"hist\" or \"scf\". The first option (default) extracts data\n                from the HIST file and plot the evolution of the structural\n                parameters, forces, pressures and energies.\n                The second option, extracts data from the main output file and\n                plot the evolution of the SCF cycles (etotal, residuals, etc).\n\n        Returns:\n            `matplotlib` figure, None if some error occurred.\n        \"\"\"\n        what = kwargs.pop(\"what\", \"hist\")\n\n        if what == \"hist\":\n            # Read the hist file to get access to the structure.\n            with self.open_hist() as hist:\n                return hist.plot(**kwargs) if hist else None\n\n        elif what == \"scf\":\n            # Get info on the different SCF cycles\n            relaxation = abiinspect.Relaxation.from_file(self.output_file.path)\n            if \"title\" not in kwargs: kwargs[\"title\"] = str(self)\n            return relaxation.plot(**kwargs) if relaxation is not None else None\n\n        else:\n            raise ValueError(\"Wrong value for what %s\" % what)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef fix_ofiles(self):\n        super().fix_ofiles()\n\n        # Find the last TIM?_DEN file.\n        last_timden = self.outdir.find_last_timden_file()\n        if last_timden is None:\n            logger.warning(\"Cannot find TIM?_DEN files\")\n            return\n\n        # Rename last TIMDEN with out_DEN.\n        ofile = self.outdir.path_in(\"out_DEN\")\n        if last_timden.path.endswith(\".nc\"): ofile += \".nc\"\n        self.history.info(\"Renaming last_denfile %s --> %s\" % (last_timden.path, ofile))\n        os.rename(last_timden.path, ofile)", "response": "Fixes the file names in the out_DEN file and the TIM1_DEN file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef make_links(self):\n        for dep in self.deps:\n            for d in dep.exts:\n\n                if d == \"DDK\":\n                    ddk_task = dep.node\n                    out_ddk = ddk_task.outdir.has_abiext(\"DDK\")\n                    if not out_ddk:\n                        raise RuntimeError(\"%s didn't produce the DDK file\" % ddk_task)\n\n                    # Get (fortran) idir and costruct the name of the 1WF expected by Abinit\n                    rfdir = list(ddk_task.input[\"rfdir\"])\n                    if rfdir.count(1) != 1:\n                        raise RuntimeError(\"Only one direction should be specifned in rfdir but rfdir = %s\" % rfdir)\n\n                    idir = rfdir.index(1) + 1\n                    ddk_case = idir + 3 * len(ddk_task.input.structure)\n\n                    infile = self.indir.path_in(\"in_1WF%d\" % ddk_case)\n                    os.symlink(out_ddk, infile)\n\n                elif d in (\"WFK\", \"WFQ\"):\n                    gs_task = dep.node\n                    out_wfk = gs_task.outdir.has_abiext(d)\n                    if not out_wfk:\n                        raise RuntimeError(\"%s didn't produce the %s file\" % (gs_task, d))\n\n                    if d == \"WFK\":\n                        bname = \"in_WFK\"\n                    elif d == \"WFQ\":\n                        bname = \"in_WFQ\"\n                    else:\n                        raise ValueError(\"Don't know how to handle `%s`\" % d)\n\n                    if not os.path.exists(self.indir.path_in(bname)):\n                            os.symlink(out_wfk, self.indir.path_in(bname))\n\n                elif d == \"DEN\":\n                    gs_task = dep.node\n                    out_wfk = gs_task.outdir.has_abiext(\"DEN\")\n                    if not out_wfk:\n                        raise RuntimeError(\"%s didn't produce the DEN file\" % gs_task)\n                    if not os.path.exists(self.indir.path_in(\"in_DEN\")):\n                        os.symlink(out_wfk, self.indir.path_in(\"in_DEN\"))\n\n                elif d == \"1WF\":\n                    gs_task = dep.node\n                    out_wfk = gs_task.outdir.has_abiext(\"1WF\")\n                    if not out_wfk:\n                        raise RuntimeError(\"%s didn't produce the 1WF file\" % gs_task)\n                    dest = self.indir.path_in(\"in_\" + out_wfk.split(\"_\")[-1])\n                    if not os.path.exists(dest):\n                        os.symlink(out_wfk, dest)\n\n                elif d == \"1DEN\":\n                    gs_task = dep.node\n                    out_wfk = gs_task.outdir.has_abiext(\"DEN\")\n                    if not out_wfk:\n                        raise RuntimeError(\"%s didn't produce the 1DEN file\" % gs_task)\n                    dest = self.indir.path_in(\"in_\" + out_wfk.split(\"_\")[-1])\n                    if not os.path.exists(dest):\n                        os.symlink(out_wfk, dest)\n\n                else:\n                    raise ValueError(\"Don't know how to handle extension: %s\" % str(dep.exts))", "response": "Replace the default behaviour of make_links. More specifically this method is used to connect DFPT calculation to DDK files."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nrestarting the wavefunctions and density files.", "response": "def restart(self):\n        \"\"\"\n        DFPT calculations can be restarted only if we have the 1WF file or the 1DEN file.\n        from which we can read the first-order wavefunctions or the first order density.\n        Prefer 1WF over 1DEN since we can reuse the wavefunctions.\n        \"\"\"\n        # Abinit adds the idir-ipert index at the end of the file and this breaks the extension\n        # e.g. out_1WF4, out_DEN4. find_1wf_files and find_1den_files returns the list of files found\n        restart_file, irdvars = None, None\n\n        # Highest priority to the 1WF file because restart is more efficient.\n        wf_files = self.outdir.find_1wf_files()\n        if wf_files is not None:\n            restart_file = wf_files[0].path\n            irdvars = irdvars_for_ext(\"1WF\")\n            if len(wf_files) != 1:\n                restart_file = None\n                self.history.critical(\"Found more than one 1WF file in outdir. Restart is ambiguous!\")\n\n        if restart_file is None:\n            den_files = self.outdir.find_1den_files()\n            if den_files is not None:\n                restart_file = den_files[0].path\n                irdvars = {\"ird1den\": 1}\n                if len(den_files) != 1:\n                    restart_file = None\n                    self.history.critical(\"Found more than one 1DEN file in outdir. Restart is ambiguous!\")\n\n        if restart_file is None:\n            # Raise because otherwise restart is equivalent to a run from scratch --> infinite loop!\n            raise self.RestartError(\"%s: Cannot find the 1WF|1DEN file to restart from.\" % self)\n\n        # Move file.\n        self.history.info(\"Will restart from %s\", restart_file)\n        restart_file = self.out_to_in(restart_file)\n\n        # Add the appropriate variable for restarting.\n        self.set_vars(irdvars)\n\n        # Now we can resubmit the job.\n        return self._restart()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nplot the Phonon SCF cycle results with matplotlib.", "response": "def inspect(self, **kwargs):\n        \"\"\"\n        Plot the Phonon SCF cycle results with matplotlib.\n\n        Returns:\n            `matplotlib` figure, None if some error occurred.\n        \"\"\"\n        scf_cycle = abiinspect.PhononScfCycle.from_file(self.output_file.path)\n        if scf_cycle is not None:\n            if \"title\" not in kwargs: kwargs[\"title\"] = str(self)\n            return scf_cycle.plot(**kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef reduce_memory_demand(self):\n        # The first digit governs the storage of W(q), the second digit the storage of u(r)\n        # Try to avoid the storage of u(r) first since reading W(q) from file will lead to a drammatic slowdown.\n        prev_gwmem = int(self.get_inpvar(\"gwmem\", default=11))\n        first_dig, second_dig = prev_gwmem // 10, prev_gwmem % 10\n\n        if second_dig == 1:\n            self.set_vars(gwmem=\"%.2d\" % (10 * first_dig))\n            return True\n\n        if first_dig == 1:\n            self.set_vars(gwmem=\"%.2d\" % 00)\n            return True\n\n        # gwmem 00 d'oh!\n        return False", "response": "This method is used to reduce the memory demand of a specific task."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nopens the SIGRES file located in the in self. outdir. Returns None if file could not be opened.", "response": "def open_scr(self):\n        \"\"\"\n        Open the SIGRES file located in the in self.outdir.\n        Returns :class:`ScrFile` object, None if file could not be found or file is not readable.\n        \"\"\"\n        scr_path = self.scr_path\n\n        if not scr_path:\n            logger.critical(\"%s didn't produce a SCR.nc file in %s\" % (self, self.outdir))\n            return None\n\n        # Open the GSR file and add its data to results.out\n        from abipy.electrons.scr import ScrFile\n        try:\n            return ScrFile(scr_path)\n        except Exception as exc:\n            logger.critical(\"Exception while reading SCR file at %s:\\n%s\" % (scr_path, str(exc)))\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef open_sigres(self):\n        sigres_path = self.sigres_path\n\n        if not sigres_path:\n            logger.critical(\"%s didn't produce a SIGRES file in %s\" % (self, self.outdir))\n            return None\n\n        # Open the SIGRES file and add its data to results.out\n        from abipy.electrons.gw import SigresFile\n        try:\n            return SigresFile(sigres_path)\n        except Exception as exc:\n            logger.critical(\"Exception while reading SIGRES file at %s:\\n%s\" % (sigres_path, str(exc)))\n            return None", "response": "Open the SIGRES file located in the in self. outdir. Returns None if file could not be opened."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn an instance of : class : ScissorsBuilder from the SIGRES file.", "response": "def get_scissors_builder(self):\n        \"\"\"\n        Returns an instance of :class:`ScissorsBuilder` from the SIGRES file.\n\n        Raise:\n            `RuntimeError` if SIGRES file is not found.\n        \"\"\"\n        from abipy.electrons.scissors import ScissorsBuilder\n        if self.sigres_path:\n            return ScissorsBuilder.from_file(self.sigres_path)\n        else:\n            raise RuntimeError(\"Cannot find SIGRES file!\")"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nrestarting the current set of critical events for the current log file.", "response": "def restart(self):\n        \"\"\"\n        BSE calculations with Haydock can be restarted only if we have the\n        excitonic Hamiltonian and the HAYDR_SAVE file.\n        \"\"\"\n        # TODO: This version seems to work but the main output file is truncated\n        # TODO: Handle restart if CG method is used\n        # TODO: restart should receive a list of critical events\n        # the log file is complete though.\n        irdvars = {}\n\n        # Move the BSE blocks to indata.\n        # This is done only once at the end of the first run.\n        # Successive restarts will use the BSR|BSC files in the indir directory\n        # to initialize the excitonic Hamiltonian\n        count = 0\n        for ext in (\"BSR\", \"BSC\"):\n            ofile = self.outdir.has_abiext(ext)\n            if ofile:\n                count += 1\n                irdvars.update(irdvars_for_ext(ext))\n                self.out_to_in(ofile)\n\n        if not count:\n            # outdir does not contain the BSR|BSC file.\n            # This means that num_restart > 1 and the files should be in task.indir\n            count = 0\n            for ext in (\"BSR\", \"BSC\"):\n                ifile = self.indir.has_abiext(ext)\n                if ifile:\n                    count += 1\n\n            if not count:\n                raise self.RestartError(\"%s: Cannot find BSR|BSC files in %s\" % (self, self.indir))\n\n        # Rename HAYDR_SAVE files\n        count = 0\n        for ext in (\"HAYDR_SAVE\", \"HAYDC_SAVE\"):\n            ofile = self.outdir.has_abiext(ext)\n            if ofile:\n                count += 1\n                irdvars.update(irdvars_for_ext(ext))\n                self.out_to_in(ofile)\n\n        if not count:\n            raise self.RestartError(\"%s: Cannot find the HAYDR_SAVE file to restart from.\" % self)\n\n        # Add the appropriate variable for restarting.\n        self.set_vars(irdvars)\n\n        # Now we can resubmit the job.\n        #self.history.info(\"Will restart from %s\", restart_file)\n        return self._restart()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef mdf_path(self):\n        # Lazy property to avoid multiple calls to has_abiext.\n        try:\n            return self._mdf_path\n        except AttributeError:\n            path = self.outdir.has_abiext(\"MDF.nc\")\n            if path: self._mdf_path = path\n            return path", "response": "Absolute path of the MDF file. Empty string if file is not present."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef open_mdf(self):\n        mdf_path = self.mdf_path\n        if not mdf_path:\n            logger.critical(\"%s didn't produce a MDF file in %s\" % (self, self.outdir))\n            return None\n\n        # Open the DFF file and add its data to results.out\n        from abipy.electrons.bse import MdfFile\n        try:\n            return MdfFile(mdf_path)\n        except Exception as exc:\n            logger.critical(\"Exception while reading MDF file at %s:\\n%s\" % (mdf_path, str(exc)))\n            return None", "response": "Open the MDF file located in the in self. outdir. Returns None if file could not be opened."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_workdir(self, workdir, chroot=False):\n        super().set_workdir(workdir, chroot=chroot)\n        # Small hack: the log file of optics is actually the main output file.\n        self.output_file = self.log_file", "response": "Set the working directory of the task."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets variables for the current task.", "response": "def set_vars(self, *args, **kwargs):\n        \"\"\"\n        Optic does not use `get` or `ird` variables hence we should never try\n        to change the input when we connect this task\n        \"\"\"\n        kwargs.update(dict(*args))\n        self.history.info(\"OpticTask intercepted set_vars with args %s\" % kwargs)\n\n        if \"autoparal\" in kwargs: self.input.set_vars(autoparal=kwargs[\"autoparal\"])\n        if \"max_ncpus\" in kwargs: self.input.set_vars(max_ncpus=kwargs[\"max_ncpus\"])"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nstring with the list of files and prefixes needed to execute ABINIT.", "response": "def filesfile_string(self):\n        \"\"\"String with the list of files and prefixes needed to execute ABINIT.\"\"\"\n        lines = []\n        app = lines.append\n\n        #optic.in     ! Name of input file\n        #optic.out    ! Unused\n        #optic        ! Root name for all files that will be produced\n        app(self.input_file.path)                           # Path to the input file\n        app(os.path.join(self.workdir, \"unused\"))           # Path to the output file\n        app(os.path.join(self.workdir, self.prefix.odata))  # Prefix for output data\n\n        return \"\\n\".join(lines)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef ddk_filepaths(self):\n        # This to support new version of optic that used DDK.nc\n        paths = [ddk_task.outdir.has_abiext(\"DDK.nc\") for ddk_task in self.ddk_nodes]\n        if all(p for p in paths):\n            return paths\n\n        # This is deprecated and can be removed when new version of Abinit is released.\n        return [ddk_task.outdir.has_abiext(\"1WF\") for ddk_task in self.ddk_nodes]", "response": "Returns ( at runtime ) the absolute path of the DDK files produced by the DDK runs."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconstructs and write the input file of the calculation.", "response": "def make_input(self):\n        \"\"\"Construct and write the input file of the calculation.\"\"\"\n        # Set the file paths.\n        all_files ={\"ddkfile_\" + str(n + 1): ddk for n, ddk in enumerate(self.ddk_filepaths)}\n        all_files.update({\"wfkfile\": self.wfk_filepath})\n        files_nml = {\"FILES\": all_files}\n        files= nmltostring(files_nml)\n\n        # Get the input specified by the user\n        user_file = nmltostring(self.input.as_dict())\n\n        # Join them.\n        return files + user_file"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nrestarting the job from scratch.", "response": "def reset_from_scratch(self):\n        \"\"\"\n        restart from scratch, this is to be used if a job is restarted with more resources after a crash\n        \"\"\"\n        # Move output files produced in workdir to _reset otherwise check_status continues\n        # to see the task as crashed even if the job did not run\n        # Create reset directory if not already done.\n        reset_dir = os.path.join(self.workdir, \"_reset\")\n        reset_file = os.path.join(reset_dir, \"_counter\")\n        if not os.path.exists(reset_dir):\n            os.mkdir(reset_dir)\n            num_reset = 1\n        else:\n            with open(reset_file, \"rt\") as fh:\n                num_reset = 1 + int(fh.read())\n\n        # Move files to reset and append digit with reset index.\n        def move_file(f):\n            if not f.exists: return\n            try:\n                f.move(os.path.join(reset_dir, f.basename + \"_\" + str(num_reset)))\n            except OSError as exc:\n                logger.warning(\"Couldn't move file {}. exc: {}\".format(f, str(exc)))\n\n        for fname in (\"output_file\", \"log_file\", \"stderr_file\", \"qout_file\", \"qerr_file\", \"mpiabort_file\"):\n            move_file(getattr(self, fname))\n\n        with open(reset_file, \"wt\") as fh:\n            fh.write(str(num_reset))\n\n        self.start_lockfile.remove()\n\n        # Reset datetimes\n        self.datetimes.reset()\n\n        return self._restart(submit=False)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef temp_shell_task(cls, inp, ddb_node, mpi_procs=1,\n                        gkk_node=None, md_node=None, ddk_node=None, workdir=None, manager=None):\n        \"\"\"\n        Build a :class:`AnaddbTask` with a temporary workdir. The task is executed via\n        the shell with 1 MPI proc. Mainly used for post-processing the DDB files.\n\n        Args:\n            mpi_procs: Number of MPI processes to use.\n            anaddb_input: string with the anaddb variables.\n            ddb_node: The node that will produce the DDB file. Accept :class:`Task`, :class:`Work` or filepath.\n\n        See `AnaddbInit` for the meaning of the other arguments.\n        \"\"\"\n        # Build a simple manager to run the job in a shell subprocess\n        import tempfile\n        workdir = tempfile.mkdtemp() if workdir is None else workdir\n        if manager is None: manager = TaskManager.from_user_config()\n\n        # Construct the task and run it\n        return cls(inp, ddb_node,\n                   gkk_node=gkk_node, md_node=md_node, ddk_node=ddk_node,\n                   workdir=workdir, manager=manager.to_shell_manager(mpi_procs=mpi_procs))", "response": "Build a Task object with a temporary workdir."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef filesfile_string(self):\n        lines = []\n        app = lines.append\n\n        app(self.input_file.path)          # 1) Path of the input file\n        app(self.output_file.path)         # 2) Path of the output file\n        app(self.ddb_filepath)             # 3) Input derivative database e.g. t13.ddb.in\n        app(self.md_filepath)              # 4) Output molecular dynamics e.g. t13.md\n        app(self.gkk_filepath)             # 5) Input elphon matrix elements  (GKK file)\n        app(self.outdir.path_join(\"out\"))  # 6) Base name for elphon output files e.g. t13\n        app(self.ddk_filepath)             # 7) File containing ddk filenames for elphon/transport.\n\n        return \"\\n\".join(lines)", "response": "Returns a string with the list of files and prefixes needed to execute ABINIT."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn ( at runtime ) the absolute path of the input DDB file.", "response": "def ddb_filepath(self):\n        \"\"\"Returns (at runtime) the absolute path of the input DDB file.\"\"\"\n        # This is not very elegant! A possible approach could to be path self.ddb_node.outdir!\n        if isinstance(self.ddb_node, FileNode): return self.ddb_node.filepath\n        path = self.ddb_node.outdir.has_abiext(\"DDB\")\n        return path if path else \"DDB_FILE_DOES_NOT_EXIST\""}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef md_filepath(self):\n        if self.md_node is None: return \"MD_FILE_DOES_NOT_EXIST\"\n        if isinstance(self.md_node, FileNode): return self.md_node.filepath\n\n        path = self.md_node.outdir.has_abiext(\"MD\")\n        return path if path else \"MD_FILE_DOES_NOT_EXIST\"", "response": "Returns ( at runtime ) the absolute path of the input MD file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn ( at runtime ) the absolute path of the input GKK file.", "response": "def gkk_filepath(self):\n        \"\"\"Returns (at runtime) the absolute path of the input GKK file.\"\"\"\n        if self.gkk_node is None: return \"GKK_FILE_DOES_NOT_EXIST\"\n        if isinstance(self.gkk_node, FileNode): return self.gkk_node.filepath\n\n        path = self.gkk_node.outdir.has_abiext(\"GKK\")\n        return path if path else \"GKK_FILE_DOES_NOT_EXIST\""}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef ddk_filepath(self):\n        if self.ddk_node is None: return \"DDK_FILE_DOES_NOT_EXIST\"\n        if isinstance(self.ddk_node, FileNode): return self.ddk_node.filepath\n\n        path = self.ddk_node.outdir.has_abiext(\"DDK\")\n        return path if path else \"DDK_FILE_DOES_NOT_EXIST\"", "response": "Returns ( at runtime ) the absolute path of the input DKK file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nopening a PHBST file produced by Anaddb and returns a PhbstFile object.", "response": "def open_phbst(self):\n        \"\"\"Open PHBST file produced by Anaddb and returns :class:`PhbstFile` object.\"\"\"\n        from abipy.dfpt.phonons import PhbstFile\n        phbst_path = os.path.join(self.workdir, \"run.abo_PHBST.nc\")\n        if not phbst_path:\n            if self.status == self.S_OK:\n                logger.critical(\"%s reached S_OK but didn't produce a PHBST file in %s\" % (self, self.outdir))\n            return None\n\n        try:\n            return PhbstFile(phbst_path)\n        except Exception as exc:\n            logger.critical(\"Exception while reading GSR file at %s:\\n%s\" % (phbst_path, str(exc)))\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef open_phdos(self):\n        from abipy.dfpt.phonons import PhdosFile\n        phdos_path = os.path.join(self.workdir, \"run.abo_PHDOS.nc\")\n        if not phdos_path:\n            if self.status == self.S_OK:\n                logger.critical(\"%s reached S_OK but didn't produce a PHBST file in %s\" % (self, self.outdir))\n            return None\n\n        try:\n            return PhdosFile(phdos_path)\n        except Exception as exc:\n            logger.critical(\"Exception while reading GSR file at %s:\\n%s\" % (phdos_path, str(exc)))\n            return None", "response": "Open the PHDOS file produced by Anaddb and returns a PhdosFile object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef structure_from_ncdata(ncdata, site_properties=None, cls=Structure):\n    ncdata, closeit = as_ncreader(ncdata)\n\n    # TODO check whether atomic units are used\n    lattice = ArrayWithUnit(ncdata.read_value(\"primitive_vectors\"), \"bohr\").to(\"ang\")\n\n    red_coords = ncdata.read_value(\"reduced_atom_positions\")\n    natom = len(red_coords)\n\n    znucl_type = ncdata.read_value(\"atomic_numbers\")\n\n    # type_atom[0:natom] --> index Between 1 and number of atom species\n    type_atom = ncdata.read_value(\"atom_species\")\n\n    # Fortran to C index and float --> int conversion.\n    species = natom * [None]\n    for atom in range(natom):\n        type_idx = type_atom[atom] - 1\n        species[atom] = int(znucl_type[type_idx])\n\n    d = {}\n    if site_properties is not None:\n        for prop in site_properties:\n            d[property] = ncdata.read_value(prop)\n\n    structure = cls(lattice, species, red_coords, site_properties=d)\n\n    # Quick and dirty hack.\n    # I need an abipy structure since I need to_abivars and other methods.\n    try:\n        from abipy.core.structure import Structure as AbipyStructure\n        structure.__class__ = AbipyStructure\n    except ImportError:\n        pass\n\n    if closeit:\n        ncdata.close()\n\n    return structure", "response": "Reads and returns a pymatgen structure from a NetCDF file containing crystallographic data in the ETSF - IO format."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nwalks the tree of all the user - defined groups and their children.", "response": "def walk_tree(self, top=None):\n        \"\"\"\n        Navigate all the groups in the file starting from top.\n        If top is None, the root group is used.\n        \"\"\"\n        if top is None:\n            top = self.rootgrp\n\n        values = top.groups.values()\n        yield values\n        for value in top.groups.values():\n            for children in self.walk_tree(value):\n                yield children"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef read_dimvalue(self, dimname, path=\"/\", default=NO_DEFAULT):\n        try:\n            dim = self._read_dimensions(dimname, path=path)[0]\n            return len(dim)\n        except self.Error:\n            if default is NO_DEFAULT: raise\n            return default", "response": "Reads the value of a dimension."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef read_varnames(self, path=\"/\"):\n        if path == \"/\":\n            return self.rootgrp.variables.keys()\n        else:\n            group = self.path2group[path]\n            return group.variables.keys()", "response": "List of variable names stored in the group specified by path."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nread the value of a variable in the group specified by path.", "response": "def read_value(self, varname, path=\"/\", cmode=None, default=NO_DEFAULT):\n        \"\"\"\n        Returns the values of variable with name varname in the group specified by path.\n\n        Args:\n            varname: Name of the variable\n            path: path to the group.\n            cmode: if cmode==\"c\", a complex ndarrays is constructed and returned\n                (netcdf does not provide native support from complex datatype).\n            default: returns default if varname is not present.\n                self.Error is raised if default is default is NO_DEFAULT\n\n        Returns:\n            numpy array if varname represents an array, scalar otherwise.\n        \"\"\"\n        try:\n            var = self.read_variable(varname, path=path)\n        except self.Error:\n            if default is NO_DEFAULT: raise\n            return default\n\n        if cmode is None:\n            # scalar or array\n            # getValue is not portable!\n            try:\n                return var.getValue()[0] if not var.shape else var[:]\n            except IndexError:\n                return var.getValue() if not var.shape else var[:]\n\n        else:\n            assert var.shape[-1] == 2\n            if cmode == \"c\":\n                return var[...,0] + 1j*var[...,1]\n            else:\n                raise ValueError(\"Wrong value for cmode %s\" % cmode)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef read_keys(self, keys, dict_cls=AttrDict, path=\"/\"):\n        od = dict_cls()\n        for k in keys:\n            try:\n                # Try to read a variable.\n                od[k] = self.read_value(k, path=path)\n            except self.Error:\n                try:\n                    # Try to read a dimension.\n                    od[k] = self.read_dimvalue(k, path=path)\n                except self.Error:\n                    od[k] = None\n\n        return od", "response": "Read a list of variables and dimensions from file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef chemical_symbols(self):\n        charr = self.read_value(\"chemical_symbols\")\n        symbols = []\n        for v in charr:\n            s = \"\".join(c.decode(\"utf-8\") for c in v)\n            symbols.append(s.strip())\n\n        return symbols", "response": "Chemical symbols char [ number of atom species][symbol length ]."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the crystalline structure.", "response": "def read_structure(self, cls=Structure):\n        \"\"\"Returns the crystalline structure.\"\"\"\n        if self.ngroups != 1:\n            raise NotImplementedError(\"In file %s: ngroups != 1\" % self.path)\n\n        return structure_from_ncdata(self, cls=cls)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef read_abinit_hdr(self):\n        d = {}\n        for hvar in _HDR_VARIABLES.values():\n            ncname = hvar.etsf_name if hvar.etsf_name is not None else hvar.name\n            if ncname in self.rootgrp.variables:\n                d[hvar.name] = self.read_value(ncname)\n            elif ncname in self.rootgrp.dimensions:\n                d[hvar.name] = self.read_dimvalue(ncname)\n            else:\n                raise ValueError(\"Cannot find `%s` in `%s`\" % (ncname, self.path))\n            # Convert scalars to (well) scalars.\n            if hasattr(d[hvar.name], \"shape\") and not d[hvar.name].shape:\n                d[hvar.name] = np.asscalar(d[hvar.name])\n            if hvar.name in (\"title\", \"md5_pseudos\", \"codvsn\"):\n                # Convert array of numpy bytes to list of strings\n                if hvar.name == \"codvsn\":\n                    d[hvar.name] = \"\".join(bs.decode(\"utf-8\").strip() for bs in d[hvar.name])\n                else:\n                    d[hvar.name] = [\"\".join(bs.decode(\"utf-8\") for bs in astr).strip()\n                            for astr in d[hvar.name]]\n\n        return AbinitHeader(d)", "response": "Reads the variables associated to the Abinit header."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a string representation of the current object.", "response": "def to_string(self, verbose=0, title=None, **kwargs):\n        \"\"\"\n        String representation. kwargs are passed to `pprint.pformat`.\n\n        Args:\n            verbose: Verbosity level\n            title: Title string.\n        \"\"\"\n        from pprint import pformat\n        s = pformat(self, **kwargs)\n        if title is not None:\n            return \"\\n\".join([marquee(title, mark=\"=\"), s])\n        return s"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nadd an electrode to the plot.", "response": "def add_electrode(self, electrode, label=None):\n        \"\"\"\n        Add an electrode to the plot.\n\n        Args:\n            electrode: An electrode. All electrodes satisfying the\n                AbstractElectrode interface should work.\n            label: A label for the electrode. If None, defaults to a counting\n                system, i.e. 'Electrode 1', 'Electrode 2', ...\n        \"\"\"\n        if not label:\n            label = \"Electrode {}\".format(len(self._electrodes) + 1)\n        self._electrodes[label] = electrode"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a matplotlib plot object.", "response": "def get_plot(self, width=8, height=8):\n        \"\"\"\n        Returns a plot object.\n\n        Args:\n            width: Width of the plot. Defaults to 8 in.\n            height: Height of the plot. Defaults to 6 in.\n\n        Returns:\n            A matplotlib plot object.\n        \"\"\"\n        plt = pretty_plot(width, height)\n        for label, electrode in self._electrodes.items():\n            (x, y) = self.get_plot_data(electrode)\n            plt.plot(x, y, '-', linewidth=2, label=label)\n\n        plt.legend()\n        if self.xaxis == \"capacity\":\n            plt.xlabel('Capacity (mAh/g)')\n        else:\n            plt.xlabel('Fraction')\n        plt.ylabel('Voltage (V)')\n        plt.tight_layout()\n        return plt"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef save(self, filename, image_format=\"eps\", width=8, height=6):\n        self.get_plot(width, height).savefig(filename, format=image_format)", "response": "Save the plot to an image file."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the final structure from the previous run.", "response": "def get_structure_from_prev_run(vasprun, outcar=None, sym_prec=0.1,\n                                international_monoclinic=True):\n    \"\"\"\n    Process structure from previous run.\n\n    Args:\n        vasprun (Vasprun): Vasprun that contains the final structure\n            from previous run.\n        outcar (Outcar): Outcar that contains the magnetization info from\n            previous run.\n        sym_prec (float): Tolerance for symmetry finding for standardization. If\n            no standardization is desired, set to 0 or a False.\n        international_monoclinic (bool): Whether to use international\n            convention (vs Curtarolo) for monoclinic. Defaults True.\n\n    Returns:\n        Returns the magmom-decorated structure that can be passed to get\n        Vasp input files, e.g. get_kpoints.\n    \"\"\"\n    structure = vasprun.final_structure\n\n    site_properties = {}\n    # magmom\n    if vasprun.is_spin:\n        if outcar and outcar.magnetization:\n            site_properties.update({\"magmom\": [i['tot']\n                                               for i in outcar.magnetization]})\n        else:\n            site_properties.update({\"magmom\": vasprun.parameters['MAGMOM']})\n    # ldau\n    if vasprun.parameters.get(\"LDAU\", False):\n        for k in (\"LDAUU\", \"LDAUJ\", \"LDAUL\"):\n            vals = vasprun.incar[k]\n            m = {}\n            l = []\n            s = 0\n            for site in structure:\n                if site.specie.symbol not in m:\n                    m[site.specie.symbol] = vals[s]\n                    s += 1\n                l.append(m[site.specie.symbol])\n            if len(l) == len(structure):\n                site_properties.update({k.lower(): l})\n            else:\n                raise ValueError(\"length of list {} not the same as\"\n                                 \"structure\".format(l))\n\n    structure = structure.copy(site_properties=site_properties)\n\n    if sym_prec:\n        sym_finder = SpacegroupAnalyzer(structure, symprec=sym_prec)\n        new_structure = sym_finder.get_primitive_standard_structure(\n            international_monoclinic=international_monoclinic)\n        # the primitive structure finding has had several bugs in the past\n        # defend through validation\n        vpa_old = structure.volume / structure.num_sites\n        vpa_new = new_structure.volume / new_structure.num_sites\n        if abs(vpa_old - vpa_new) / vpa_old > 0.02:\n            raise ValueError(\n                \"Standardizing cell failed! VPA old: {}, VPA new: {}\".format(\n                    vpa_old, vpa_new))\n        sm = StructureMatcher()\n        if not sm.fit(structure, new_structure):\n            raise ValueError(\n                \"Standardizing cell failed! Old structure doesn't match new.\")\n        structure = new_structure\n\n    return structure"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nwrite a batch of VASP input files for a sequence of structures to a directory.", "response": "def batch_write_input(structures, vasp_input_set=MPRelaxSet, output_dir=\".\",\n                      make_dir_if_not_present=True, subfolder=None,\n                      sanitize=False, include_cif=False, **kwargs):\n    \"\"\"\n    Batch write vasp input for a sequence of structures to\n    output_dir, following the format output_dir/{group}/{formula}_{number}.\n\n    Args:\n        structures ([Structure]): Sequence of Structures.\n        vasp_input_set (VaspInputSet): VaspInputSet class that creates\n            vasp input files from structures. Note that a class should be\n            supplied. Defaults to MPRelaxSet.\n        output_dir (str): Directory to output files. Defaults to current\n            directory \".\".\n        make_dir_if_not_present (bool): Create the directory if not present.\n            Defaults to True.\n        subfolder (callable): Function to create subdirectory name from\n            structure. Defaults to simply \"formula_count\".\n        sanitize (bool): Boolean indicating whether to sanitize the\n            structure before writing the VASP input files. Sanitized output\n            are generally easier for viewing and certain forms of analysis.\n            Defaults to False.\n        include_cif (bool): Whether to output a CIF as well. CIF files are\n            generally better supported in visualization programs.\n        \\\\*\\\\*kwargs: Additional kwargs are passed to the vasp_input_set class\n            in addition to structure.\n    \"\"\"\n    output_dir = Path(output_dir)\n    for i, s in enumerate(structures):\n        formula = re.sub(r'\\s+', \"\", s.formula)\n        if subfolder is not None:\n            subdir = subfolder(s)\n            d = output_dir / subdir\n        else:\n            d = output_dir / '{}_{}'.format(formula, i)\n        if sanitize:\n            s = s.copy(sanitize=True)\n        v = vasp_input_set(s, **kwargs)\n        v.write_input(str(d), make_dir_if_not_present=make_dir_if_not_present,\n                      include_cif=include_cif)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a list of POTCAR symbols.", "response": "def potcar_symbols(self):\n        \"\"\"\n        List of POTCAR symbols.\n        \"\"\"\n        elements = self.poscar.site_symbols\n        potcar_symbols = []\n        settings = self._config_dict[\"POTCAR\"]\n\n        if isinstance(settings[elements[-1]], dict):\n            for el in elements:\n                potcar_symbols.append(settings[el]['symbol']\n                                      if el in settings else el)\n        else:\n            for el in elements:\n                potcar_symbols.append(settings.get(el, el))\n\n        return potcar_symbols"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef all_input(self):\n        return {'INCAR': self.incar,\n                'KPOINTS': self.kpoints,\n                'POSCAR': self.poscar,\n                'POTCAR': self.potcar}", "response": "Returns all input files as a dict of object names."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nwrites a set of VASP input files to a directory.", "response": "def write_input(self, output_dir,\n                    make_dir_if_not_present=True, include_cif=False):\n        \"\"\"\n        Writes a set of VASP input to a directory.\n\n        Args:\n            output_dir (str): Directory to output the VASP input files\n            make_dir_if_not_present (bool): Set to True if you want the\n                directory (and the whole path) to be created if it is not\n                present.\n            include_cif (bool): Whether to write a CIF file in the output\n                directory for easier opening by VESTA.\n        \"\"\"\n        vinput = self.get_vasp_input()\n        vinput.write_input(\n            output_dir, make_dir_if_not_present=make_dir_if_not_present)\n        if include_cif:\n            s = vinput[\"POSCAR\"].structure\n            fname = Path(output_dir) / (\"%s.cif\" % re.sub(r'\\s', \"\", s.formula))\n            s.to(filename=fname)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the default number of electrons for a given structure.", "response": "def nelect(self):\n        \"\"\"\n        Gets the default number of electrons for a given structure.\n        \"\"\"\n        # if structure is not sorted this can cause problems, so must take\n        # care to remove redundant symbols when counting electrons\n        site_symbols = list(set(self.poscar.site_symbols))\n        nelect = 0.\n        for ps in self.potcar:\n            if ps.element in site_symbols:\n                site_symbols.remove(ps.element)\n                nelect += self.structure.composition.element_composition[\n                              ps.element] * ps.ZVAL\n\n        if self.use_structure_charge:\n            return nelect - self.structure.charge\n        else:\n            return nelect"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef kpoints(self):\n        settings = self.user_kpoints_settings or self._config_dict[\"KPOINTS\"]\n\n        if isinstance(settings, Kpoints):\n            return settings\n\n        # If grid_density is in the kpoints_settings use\n        # Kpoints.automatic_density\n        if settings.get('grid_density'):\n            return Kpoints.automatic_density(\n                self.structure, int(settings['grid_density']),\n                self.force_gamma)\n\n        # If reciprocal_density is in the kpoints_settings use\n        # Kpoints.automatic_density_by_vol\n        elif settings.get('reciprocal_density'):\n            return Kpoints.automatic_density_by_vol(\n                self.structure, int(settings['reciprocal_density']),\n                self.force_gamma)\n\n        # If length is in the kpoints_settings use Kpoints.automatic\n        elif settings.get('length'):\n            return Kpoints.automatic(settings['length'])\n\n        # Raise error. Unsure of which kpoint generation to use\n        else:\n            raise ValueError(\n                \"Invalid KPoint Generation algo : Supported Keys are \"\n                \"grid_density: for Kpoints.automatic_density generation, \"\n                \"reciprocal_density: for KPoints.automatic_density_by_vol \"\n                \"generation, and length  : for Kpoints.automatic generation\")", "response": "Writes out a KPOINTS file using the fully automated grid method."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef from_prev_calc(cls, prev_calc_dir, standardize=False, sym_prec=0.1,\n                       international_monoclinic=True, reciprocal_density=100,\n                       small_gap_multiply=None, **kwargs):\n        \"\"\"\n        Generate a set of Vasp input files for static calculations from a\n        directory of previous Vasp run.\n\n        Args:\n            prev_calc_dir (str): Directory containing the outputs(\n                vasprun.xml and OUTCAR) of previous vasp run.\n            standardize (float): Whether to standardize to a primitive\n                standard cell. Defaults to False.\n            sym_prec (float): Tolerance for symmetry finding. If not 0,\n                the final structure from the previous run will be symmetrized\n                to get a primitive standard cell. Set to 0 if you don't want\n                that.\n            international_monoclinic (bool): Whether to use international\n                    convention (vs Curtarolo) for monoclinic. Defaults True.\n            reciprocal_density (int): density of k-mesh by reciprocal\n                                    volume (defaults to 100)\n            small_gap_multiply ([float, float]): If the gap is less than\n                1st index, multiply the default reciprocal_density by the 2nd\n                index.\n            \\\\*\\\\*kwargs: All kwargs supported by MPStaticSet,\n                other than prev_incar and prev_structure and prev_kpoints which\n                are determined from the prev_calc_dir.\n        \"\"\"\n        vasprun, outcar = get_vasprun_outcar(prev_calc_dir)\n\n        prev_incar = vasprun.incar\n        prev_kpoints = vasprun.kpoints\n\n        if standardize:\n            warnings.warn(\"Use of standardize=True with from_prev_run is not \"\n                          \"recommended as there is no guarantee the copied \"\n                          \"files will be appropriate for the standardized \"\n                          \"structure. copy_chgcar is enforced to be false.\")\n\n        # We will make a standard structure for the given symprec.\n        prev_structure = get_structure_from_prev_run(\n            vasprun, outcar, sym_prec=standardize and sym_prec,\n            international_monoclinic=international_monoclinic)\n\n        # multiply the reciprocal density if needed:\n        if small_gap_multiply:\n            gap = vasprun.eigenvalue_band_properties[0]\n            if gap <= small_gap_multiply[0]:\n                reciprocal_density = reciprocal_density * small_gap_multiply[1]\n\n        return cls(\n            structure=prev_structure, prev_incar=prev_incar,\n            prev_kpoints=prev_kpoints,\n            reciprocal_density=reciprocal_density, **kwargs)", "response": "Generate a set of Vasp input files for static calculations from the previous Vasp run."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef from_prev_calc(cls, prev_calc_dir, mode=\"gap\",\n                       reciprocal_density=50, copy_chgcar=True, **kwargs):\n        \"\"\"\n        Generate a set of Vasp input files for HSE calculations from a\n        directory of previous Vasp run. if mode==\"gap\", it explicitly adds VBM\n        and CBM of the prev run to the k-point list of this run.\n\n        Args:\n            prev_calc_dir (str): Directory containing the outputs\n                (vasprun.xml and OUTCAR) of previous vasp run.\n            mode (str): Either \"uniform\", \"gap\" or \"line\"\n            reciprocal_density (int): density of k-mesh\n            copy_chgcar (bool): whether to copy CHGCAR of previous run\n            \\\\*\\\\*kwargs: All kwargs supported by MPHSEBSStaticSet,\n                other than prev_structure which is determined from the previous\n                calc dir.\n        \"\"\"\n\n        vasprun, outcar = get_vasprun_outcar(prev_calc_dir)\n\n        # note: don't standardize the cell because we want to retain k-points\n        prev_structure = get_structure_from_prev_run(vasprun, outcar,\n                                                     sym_prec=0)\n\n        added_kpoints = []\n\n        if mode.lower() == \"gap\":\n            bs = vasprun.get_band_structure()\n            vbm, cbm = bs.get_vbm()[\"kpoint\"], bs.get_cbm()[\"kpoint\"]\n            if vbm:\n                added_kpoints.append(vbm.frac_coords)\n            if cbm:\n                added_kpoints.append(cbm.frac_coords)\n\n        files_to_transfer = {}\n        if copy_chgcar:\n            chgcars = sorted(glob.glob(str(Path(prev_calc_dir) / \"CHGCAR*\")))\n            if chgcars:\n                files_to_transfer[\"CHGCAR\"] = str(chgcars[-1])\n\n        return cls(\n            structure=prev_structure,\n            added_kpoints=added_kpoints, reciprocal_density=reciprocal_density,\n            mode=mode, files_to_transfer=files_to_transfer, **kwargs)", "response": "Generate a set of HSE input files for HSE calculations from a previous Vasp run."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngenerates a set of Vasp input files for NonSCF calculations from the previous Vasp run directory.", "response": "def from_prev_calc(cls, prev_calc_dir, copy_chgcar=True,\n                       nbands_factor=1.2, standardize=False, sym_prec=0.1,\n                       international_monoclinic=True, reciprocal_density=100,\n                       kpoints_line_density=20, small_gap_multiply=None,\n                       **kwargs):\n        \"\"\"\n        Generate a set of Vasp input files for NonSCF calculations from a\n        directory of previous static Vasp run.\n\n        Args:\n            prev_calc_dir (str): The directory contains the outputs(\n                vasprun.xml and OUTCAR) of previous vasp run.\n            copy_chgcar: Whether to copy the old CHGCAR. Defaults to True.\n            nbands_factor (float): Multiplicative factor for NBANDS. Choose a\n                higher number if you are doing an LOPTICS calculation.\n            standardize (float): Whether to standardize to a primitive\n                standard cell. Defaults to False.\n            sym_prec (float): Tolerance for symmetry finding. If not 0,\n                the final structure from the previous run will be symmetrized\n                to get a primitive standard cell. Set to 0 if you don't want\n                that.\n            international_monoclinic (bool): Whether to use international\n                convention (vs Curtarolo) for monoclinic. Defaults True.\n            reciprocal_density (int): density of k-mesh by reciprocal\n                volume in uniform mode (defaults to 100)\n            kpoints_line_density (int): density of k-mesh in line mode\n                (defaults to 20)\n            small_gap_multiply ([float, float]): If the gap is less than\n                1st index, multiply the default reciprocal_density by the 2nd\n                index.\n            \\\\*\\\\*kwargs: All kwargs supported by MPNonSCFSet,\n                other than structure, prev_incar and prev_chgcar which\n                are determined from the prev_calc_dir.\n        \"\"\"\n        vasprun, outcar = get_vasprun_outcar(prev_calc_dir)\n\n        incar = vasprun.incar\n        # Get a Magmom-decorated structure\n        structure = get_structure_from_prev_run(\n            vasprun, outcar, sym_prec=standardize and sym_prec,\n            international_monoclinic=international_monoclinic)\n        # Turn off spin when magmom for every site is smaller than 0.02.\n        if outcar and outcar.magnetization:\n            site_magmom = np.array([i['tot'] for i in outcar.magnetization])\n            ispin = 2 if np.any(site_magmom[np.abs(site_magmom) > 0.02]) else 1\n        elif vasprun.is_spin:\n            ispin = 2\n        else:\n            ispin = 1\n        nbands = int(np.ceil(vasprun.parameters[\"NBANDS\"] * nbands_factor))\n        incar.update({\"ISPIN\": ispin, \"NBANDS\": nbands})\n\n        files_to_transfer = {}\n\n        if standardize:\n            warnings.warn(\"Use of standardize=True with from_prev_run is not \"\n                          \"recommended as there is no guarantee the copied \"\n                          \"files will be appropriate for the standardized\"\n                          \" structure. copy_chgcar is enforced to be false.\")\n            copy_chgcar = False\n\n        if copy_chgcar:\n            chgcars = sorted(glob.glob(str(Path(prev_calc_dir) / \"CHGCAR*\")))\n            if chgcars:\n                files_to_transfer[\"CHGCAR\"] = str(chgcars[-1])\n\n        # multiply the reciprocal density if needed:\n        if small_gap_multiply:\n            gap = vasprun.eigenvalue_band_properties[0]\n            if gap <= small_gap_multiply[0]:\n                reciprocal_density = reciprocal_density * small_gap_multiply[1]\n                kpoints_line_density = kpoints_line_density * \\\n                    small_gap_multiply[1]\n\n        return cls(structure=structure, prev_incar=incar,\n                   reciprocal_density=reciprocal_density,\n                   kpoints_line_density=kpoints_line_density,\n                   files_to_transfer=files_to_transfer, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ngenerate a set of SOC input files for SOC calculations from the previous Vasp run.", "response": "def from_prev_calc(cls, prev_calc_dir, copy_chgcar=True,\n                       nbands_factor=1.2, standardize=False, sym_prec=0.1,\n                       international_monoclinic=True, reciprocal_density=100,\n                       small_gap_multiply=None, **kwargs):\n        \"\"\"\n        Generate a set of Vasp input files for SOC calculations from a\n        directory of previous static Vasp run. SOC calc requires all 3\n        components for MAGMOM for each atom in the structure.\n\n        Args:\n            prev_calc_dir (str): The directory contains the outputs(\n                vasprun.xml and OUTCAR) of previous vasp run.\n            copy_chgcar: Whether to copy the old CHGCAR. Defaults to True.\n            nbands_factor (float): Multiplicative factor for NBANDS. Choose a\n                higher number if you are doing an LOPTICS calculation.\n            standardize (float): Whether to standardize to a primitive\n                standard cell. Defaults to False.\n            sym_prec (float): Tolerance for symmetry finding. If not 0,\n                the final structure from the previous run will be symmetrized\n                to get a primitive standard cell. Set to 0 if you don't want\n                that.\n            international_monoclinic (bool): Whether to use international\n                convention (vs Curtarolo) for monoclinic. Defaults True.\n            reciprocal_density (int): density of k-mesh by reciprocal\n                volume (defaults to 100)\n            small_gap_multiply ([float, float]): If the gap is less than\n                1st index, multiply the default reciprocal_density by the 2nd\n                index.\n            \\\\*\\\\*kwargs: All kwargs supported by MPSOCSet,\n                other than structure, prev_incar and prev_chgcar which\n                are determined from the prev_calc_dir.\n        \"\"\"\n        vasprun, outcar = get_vasprun_outcar(prev_calc_dir)\n\n        incar = vasprun.incar\n      \n        # Remove magmoms from previous INCAR, since we will prefer\n        # the final calculated magmoms\n        # TODO: revisit in context of MPStaticSet incar logic\n        if 'MAGMOM' in incar:\n            del incar['magmom']\n      \n        # Get a magmom-decorated structure\n        structure = get_structure_from_prev_run(\n            vasprun, outcar, sym_prec=standardize and sym_prec,\n            international_monoclinic=international_monoclinic)\n        # override magmom if provided\n        if kwargs.get(\"magmom\", None):\n            structure = structure.copy(\n                site_properties={\"magmom\": kwargs[\"magmom\"]})\n            kwargs.pop(\"magmom\", None)\n        # magmom has to be 3D for SOC calculation.\n        if hasattr(structure[0], \"magmom\"):\n            if not isinstance(structure[0].magmom, list):\n                structure = structure.copy(site_properties={\n                    \"magmom\": [[0, 0, site.magmom] for site in structure]})\n        else:\n            raise ValueError(\"Neither the previous structure has mamgom \"\n                             \"property nor magmom provided\")\n\n        nbands = int(np.ceil(vasprun.parameters[\"NBANDS\"] * nbands_factor))\n        incar.update({\"NBANDS\": nbands})\n\n        if standardize:\n            warnings.warn(\"Use of standardize=True with from_prev_run is not \"\n                          \"recommended as there is no guarantee the copied \"\n                          \"files will be appropriate for the standardized\"\n                          \" structure. copy_chgcar is enforced to be false.\")\n            copy_chgcar = False\n\n        files_to_transfer = {}\n        if copy_chgcar:\n            chgcars = sorted(glob.glob(str(Path(prev_calc_dir) / \"CHGCAR*\")))\n            if chgcars:\n                files_to_transfer[\"CHGCAR\"] = str(chgcars[-1])\n\n        # multiply the reciprocal density if needed:\n        if small_gap_multiply:\n            gap = vasprun.eigenvalue_band_properties[0]\n            if gap <= small_gap_multiply[0]:\n                reciprocal_density = reciprocal_density * small_gap_multiply[1]\n\n        return cls(structure, prev_incar=incar,\n                   files_to_transfer=files_to_transfer,\n                   reciprocal_density=reciprocal_density, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ngenerate gamma center k - points mesh grid for GW calculation", "response": "def kpoints(self):\n        \"\"\"\n        Generate gamma center k-points mesh grid for GW calc,\n        which is requested by GW calculation.\n        \"\"\"\n        return Kpoints.automatic_density_by_vol(self.structure,\n                                                self.reciprocal_density,\n                                                force_gamma=True)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef from_prev_calc(cls, prev_calc_dir, copy_wavecar=True, mode=\"DIAG\",\n                       nbands_factor=5, ncores=16, **kwargs):\n        \"\"\"\n        Generate a set of Vasp input files for GW or BSE calculations from a\n        directory of previous Exact Diag Vasp run.\n\n        Args:\n            prev_calc_dir (str): The directory contains the outputs(\n                vasprun.xml of previous vasp run.\n            copy_wavecar: Whether to copy the old WAVECAR, WAVEDER and\n                associated files. Defaults to True.\n            mode (str): Supported modes are \"STATIC\", \"DIAG\" (default), \"GW\",\n                and \"BSE\".\n            nbands_factor (int): Multiplicative factor for NBANDS. Only applies\n                if mode==\"DIAG\". Need to be tested for convergence.\n            ncores (int): numbers of cores you do calculations. VASP will alter\n                NBANDS if it was not dividable by ncores. Only applies\n                if mode==\"DIAG\".\n            \\\\*\\\\*kwargs: All kwargs supported by MVLGWSet,\n                other than structure, prev_incar and mode, which\n                are determined from the prev_calc_dir.\n        \"\"\"\n        vasprun, outcar = get_vasprun_outcar(prev_calc_dir)\n        prev_incar = vasprun.incar\n        structure = vasprun.final_structure\n\n        nbands = int(vasprun.parameters[\"NBANDS\"])\n        if mode.upper() == \"DIAG\":\n            nbands = int(np.ceil(nbands * nbands_factor / ncores) * ncores)\n\n        # copy WAVECAR, WAVEDER (derivatives)\n        files_to_transfer = {}\n        if copy_wavecar:\n            for fname in (\"WAVECAR\", \"WAVEDER\", \"WFULL\"):\n                w = sorted(glob.glob(str(Path(prev_calc_dir) / (fname + \"*\"))))\n                if w:\n                    if fname == \"WFULL\":\n                        for f in w:\n                            fname = Path(f).name\n                            fname = fname.split(\".\")[0]\n                            files_to_transfer[fname] = f\n                    else:\n                        files_to_transfer[fname] = str(w[-1])\n\n        return cls(structure=structure, prev_incar=prev_incar,\n                   nbands=nbands, mode=mode,\n                   files_to_transfer=files_to_transfer, **kwargs)", "response": "Generate a set of Vasp input files for GW or BSE calculations from a directory containing the previous Exact Diag Vasp run."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef kpoints(self):\n\n        # To get input sets, the input structure has to has the same number\n        # of required parameters as a Structure object (ie. 4). Slab\n        # attributes aren't going to affect the VASP inputs anyways so\n        # converting the slab into a structure should not matter\n\n        kpt = super().kpoints\n        kpt.comment = \"Automatic mesh\"\n        kpt.style = 'Gamma'\n\n        # use k_product to calculate kpoints, k_product = kpts[0][0] * a\n        abc = self.structure.lattice.abc\n        kpt_calc = [int(self.k_product / abc[0] + 0.5),\n                    int(self.k_product / abc[1] + 0.5), 1]\n        self.kpt_calc = kpt_calc\n        # calculate kpts (c direction) for bulk. (for slab, set to 1)\n        if self.bulk:\n            kpt_calc[2] = int(self.k_product / abc[2] + 0.5)\n\n        kpt.kpts[0] = kpt_calc\n\n        return kpt", "response": "get the kpoints for the slab"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef kpoints(self):\n\n        # To get input sets, the input structure has to has the same number\n        # of required parameters as a Structure object.\n\n        kpt = super().kpoints\n        kpt.comment = \"Generated by pymatgen's MVLGBSet\"\n        kpt.style = 'Gamma'\n\n        # use k_product to calculate kpoints, k_product = kpts[0][0] * a\n        lengths = self.structure.lattice.abc\n        kpt_calc = [int(self.k_product / lengths[0] + 0.5),\n                    int(self.k_product / lengths[1] + 0.5),\n                    int(self.k_product / lengths[2] + 0.5)]\n\n        if self.slab_mode:\n            kpt_calc[2] = 1\n\n        kpt.kpts[0] = kpt_calc\n\n        return kpt", "response": "Return a kpoint set for the input structure."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nremoves any atom jumps across the cell", "response": "def _process_structures(structures):\n        \"\"\"\n        Remove any atom jumps across the cell\n        \"\"\"\n        input_structures = structures\n        structures = [input_structures[0]]\n        for s in input_structures[1:]:\n            prev = structures[-1]\n            for i in range(len(s)):\n                t = np.round(prev[i].frac_coords - s[i].frac_coords)\n                if np.any(np.abs(t) > 0.5):\n                    s.translate_sites([i], t, to_unit_cell=False)\n            structures.append(s)\n        return structures"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nwrite the input files for the NEB and returns the path to the output directory.", "response": "def write_input(self, output_dir, make_dir_if_not_present=True,\n                    write_cif=False, write_path_cif=False,\n                    write_endpoint_inputs=False):\n        \"\"\"\n        NEB inputs has a special directory structure where inputs are in 00,\n        01, 02, ....\n\n        Args:\n            output_dir (str): Directory to output the VASP input files\n            make_dir_if_not_present (bool): Set to True if you want the\n                directory (and the whole path) to be created if it is not\n                present.\n            write_cif (bool): If true, writes a cif along with each POSCAR.\n            write_path_cif (bool): If true, writes a cif for each image.\n            write_endpoint_inputs (bool): If true, writes input files for\n                running endpoint calculations.\n        \"\"\"\n        output_dir = Path(output_dir)\n        if make_dir_if_not_present and not output_dir.exists():\n            output_dir.mkdir(parents=True)\n        self.incar.write_file(str(output_dir / 'INCAR'))\n        self.kpoints.write_file(str(output_dir / 'KPOINTS'))\n        self.potcar.write_file(str(output_dir / 'POTCAR'))\n\n        for i, p in enumerate(self.poscars):\n            d = output_dir / str(i).zfill(2)\n            if not d.exists():\n                d.mkdir(parents=True)\n            p.write_file(str(d / 'POSCAR'))\n            if write_cif:\n                p.structure.to(filename=str(d / '{}.cif'.format(i)))\n        if write_endpoint_inputs:\n            end_point_param = MITRelaxSet(\n                self.structures[0],\n                user_incar_settings=self.user_incar_settings)\n\n            for image in ['00', str(len(self.structures) - 1).zfill(2)]:\n                end_point_param.incar.write_file(\n                    str(output_dir / image / 'INCAR'))\n                end_point_param.kpoints.write_file(\n                    str(output_dir / image / 'KPOINTS'))\n                end_point_param.potcar.write_file(\n                    str(output_dir / image / 'POTCAR'))\n        if write_path_cif:\n            sites = set()\n            l = self.structures[0].lattice\n            for site in chain(*(s.sites for s in self.structures)):\n                sites.add(\n                    PeriodicSite(site.species, site.frac_coords, l))\n            nebpath = Structure.from_sites(sorted(sites))\n            nebpath.to(filename=str(output_dir / 'path.cif'))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_uvec(vec):\n    l = np.linalg.norm(vec)\n    if l < 1e-8:\n        return vec\n    return vec / l", "response": "Gets a unit vector parallel to input vector"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nfunctioning that converts a list of tensors corresponding to a structure and returns a dictionary consisting of unique tensors with symmops corresponding to the remaining tensors.", "response": "def symmetry_reduce(tensors, structure, tol=1e-8, **kwargs):\n    \"\"\"\n    Function that converts a list of tensors corresponding to a structure\n    and returns a dictionary consisting of unique tensor keys with symmop\n    values corresponding to transformations that will result in derivative\n    tensors from the original list\n\n    Args:\n        tensors (list of tensors): list of Tensor objects to test for\n            symmetrically-equivalent duplicates\n        structure (Structure): structure from which to get symmetry\n        tol (float): tolerance for tensor equivalence\n        kwargs: keyword arguments for the SpacegroupAnalyzer\n\n    returns:\n        dictionary consisting of unique tensors with symmetry operations\n        corresponding to those which will reconstruct the remaining\n        tensors as values\n    \"\"\"\n    sga = SpacegroupAnalyzer(structure, **kwargs)\n    symmops = sga.get_symmetry_operations(cartesian=True)\n    unique_mapping = TensorMapping([tensors[0]], [[]], tol=tol)\n    for tensor in tensors[1:]:\n        is_unique = True\n        for unique_tensor, symmop in itertools.product(unique_mapping, symmops):\n            if np.allclose(unique_tensor.transform(symmop), tensor, atol=tol):\n                unique_mapping[unique_tensor].append(symmop)\n                is_unique = False\n                break\n        if is_unique:\n            unique_mapping[tensor] = []\n    return unique_mapping"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_tkd_value(tensor_keyed_dict, tensor, allclose_kwargs=None):\n    if allclose_kwargs is None:\n        allclose_kwargs = {}\n    for tkey, value in tensor_keyed_dict.items():\n        if np.allclose(tensor, tkey, **allclose_kwargs):\n            return value", "response": "Helper function to find a value in a tensor - keyed - dict using an approximation to the key."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a copy of the matrix with all entries below a certain threshold", "response": "def zeroed(self, tol=1e-3):\n        \"\"\"\n        returns the matrix with all entries below a certain threshold\n        (i.e. tol) set to zero\n        \"\"\"\n        new_tensor = self.copy()\n        new_tensor[abs(new_tensor) < tol] = 0\n        return new_tensor"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nrotate the object to the specified rotation matrix.", "response": "def rotate(self, matrix, tol=1e-3):\n        \"\"\"\n        Applies a rotation directly, and tests input matrix to ensure a valid\n        rotation.\n\n        Args:\n            matrix (3x3 array-like): rotation matrix to be applied to tensor\n            tol (float): tolerance for testing rotation matrix validity\n        \"\"\"\n        matrix = SquareTensor(matrix)\n        if not matrix.is_rotation(tol):\n            raise ValueError(\"Rotation matrix is not valid.\")\n        sop = SymmOp.from_rotation_and_translation(matrix,\n                                                   [0., 0., 0.])\n        return self.transform(sop)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncalculate the result of an einstein summation expression for the given set of other_arrays.", "response": "def einsum_sequence(self, other_arrays, einsum_string=None):\n        \"\"\"\n        Calculates the result of an einstein summation expression\n        \"\"\"\n        if not isinstance(other_arrays, list):\n            raise ValueError(\"other tensors must be list of \"\n                             \"tensors or tensor input\")\n\n        other_arrays = [np.array(a) for a in other_arrays]\n        if not einsum_string:\n            lc = string.ascii_lowercase\n            einsum_string = lc[:self.rank]\n            other_ranks = [len(a.shape) for a in other_arrays]\n            idx = self.rank - sum(other_ranks)\n            for length in other_ranks:\n                einsum_string += ',' + lc[idx:idx + length]\n                idx += length\n\n        einsum_args = [self] + list(other_arrays)\n        return np.einsum(einsum_string, *einsum_args)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the tensor dotted into a unit vector with the given n.", "response": "def project(self, n):\n        \"\"\"\n        Convenience method for projection of a tensor into a\n        vector.  Returns the tensor dotted into a unit vector\n        along the input n.\n\n        Args:\n            n (3x1 array-like): direction to project onto\n\n        Returns (float):\n            scalar value corresponding to the projection of\n            the tensor into the vector\n\n        \"\"\"\n        n = get_uvec(n)\n        return self.einsum_sequence([n] * self.rank)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_grouped_indices(self, voigt=False, **kwargs):\n        if voigt:\n            array = self.voigt\n        else:\n            array = self\n\n        indices = list(itertools.product(*[range(n) for n in array.shape]))\n        remaining = indices.copy()\n        # Start with everything near zero\n        grouped = [list(zip(*np.where(np.isclose(array, 0, **kwargs))))]\n        remaining = [i for i in remaining if i not in grouped[0]]\n        # Iteratively run through remaining indices\n        while remaining:\n            new = list(zip(*np.where(np.isclose(\n                array, array[remaining[0]], **kwargs))))\n            grouped.append(new)\n            remaining = [i for i in remaining if i not in new]\n        # Don't return any empty lists\n        return [g for g in grouped if g]", "response": "Returns a list of indices for equivalent tensor values."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a dictionary that associates the symbol with the corresponding key.", "response": "def get_symbol_dict(self, voigt=True, zero_index=False, **kwargs):\n        \"\"\"\n        Creates a summary dict for tensor with associated symbol\n\n        Args:\n            voigt (bool): whether to get symbol dict for voigt\n                notation tensor, as opposed to full notation,\n                defaults to true\n            zero_index (bool): whether to set initial index to zero,\n                defaults to false, since tensor notations tend to use\n                one-indexing, rather than zero indexing like python\n            **kwargs: keyword args for np.isclose.  Can take atol\n                and rtol for absolute and relative tolerance, e. g.\n\n                >>> tensor.get_symbol_dict(atol=1e-8)\n\n                or\n\n                >>> tensor.get_symbol_dict(rtol=1e-5)\n\n        Returns:\n            list of index groups where tensor values are equivalent to\n            within tolerances\n\n        Returns:\n\n        \"\"\"\n        d = {}\n        if voigt:\n            array = self.voigt\n        else:\n            array = self\n        grouped = self.get_grouped_indices(voigt=voigt, **kwargs)\n        if zero_index:\n            p = 0\n        else:\n            p = 1\n        for indices in grouped:\n            sym_string = self.symbol + '_'\n            sym_string += ''.join([str(i + p) for i in indices[0]])\n            value = array[indices[0]]\n            if not np.isclose(value, 0):\n                d[sym_string] = array[indices[0]]\n        return d"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef round(self, decimals=0):\n        return self.__class__(np.round(self, decimals=decimals))", "response": "Wrapper around numpy. round to ensure that object\n            is returned."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a generally symmetrized tensor calculated by taking the sum of the tensor and its transpose with respect to all possible permutations of indices", "response": "def symmetrized(self):\n        \"\"\"\n        Returns a generally symmetrized tensor, calculated by taking\n        the sum of the tensor and its transpose with respect to all\n        possible permutations of indices\n        \"\"\"\n        perms = list(itertools.permutations(range(self.rank)))\n        return sum([np.transpose(self, ind) for ind in perms]) / len(perms)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef voigt_symmetrized(self):\n        if not (self.rank % 2 == 0 and self.rank >= 2):\n            raise ValueError(\"V-symmetrization requires rank even and >= 2\")\n\n        v = self.voigt\n        perms = list(itertools.permutations(range(len(v.shape))))\n        new_v = sum([np.transpose(v, ind) for ind in perms]) / len(perms)\n        return self.__class__.from_voigt(new_v)", "response": "Returns a voigt - notation version of the current object."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef fit_to_structure(self, structure, symprec=0.1):\n        sga = SpacegroupAnalyzer(structure, symprec)\n        symm_ops = sga.get_symmetry_operations(cartesian=True)\n        return sum([self.transform(symm_op)\n                    for symm_op in symm_ops]) / len(symm_ops)", "response": "Fits the symmetry operations corresponding to a structure and returns a tensor that is invariant with respect to symmetry\nCOOKIE operations corresponding to a structure."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef is_fit_to_structure(self, structure, tol=1e-2):\n        return (self - self.fit_to_structure(structure) < tol).all()", "response": "Tests whether a tensor is invariant with respect to the symmetric portion of the structure."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef is_voigt_symmetric(self, tol=1e-6):\n        transpose_pieces = [[[0 for i in range(self.rank % 2)]]]\n        transpose_pieces += [[range(j, j + 2)] for j in\n                             range(self.rank % 2, self.rank, 2)]\n        for n in range(self.rank % 2, len(transpose_pieces)):\n            if len(transpose_pieces[n][0]) == 2:\n                transpose_pieces[n] += [transpose_pieces[n][0][::-1]]\n        for trans_seq in itertools.product(*transpose_pieces):\n            trans_seq = list(itertools.chain(*trans_seq))\n            if (self - self.transpose(trans_seq) > tol).any():\n                return False\n        return True", "response": "Tests symmetry of tensor to that necessary for voigt - conversion\n        by grouping indices into pairs and constructing a sequence of possible permutations to be used in a tensor transpose\n                            "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_voigt_dict(rank):\n        vdict = {}\n        for ind in itertools.product(*[range(3)] * rank):\n            v_ind = ind[:rank % 2]\n            for j in range(rank // 2):\n                pos = rank % 2 + 2 * j\n                v_ind += (reverse_voigt_map[ind[pos:pos + 2]],)\n            vdict[ind] = v_ind\n        return vdict", "response": "Returns a dictionary that maps indices in the tensor to those\n        in a voigt representation based on input rank"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef from_voigt(cls, voigt_input):\n        voigt_input = np.array(voigt_input)\n        rank = sum(voigt_input.shape) // 3\n        t = cls(np.zeros([3] * rank))\n        if voigt_input.shape != t._vscale.shape:\n            raise ValueError(\"Invalid shape for voigt matrix\")\n        voigt_input = voigt_input / t._vscale\n        this_voigt_map = t.get_voigt_dict(rank)\n        for ind in this_voigt_map:\n            t[ind] = voigt_input[this_voigt_map[ind]]\n        return cls(t)", "response": "Returns a new object from a voigt notation vector or matrix."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_ieee_rotation(structure, refine_rotation=True):\n        # Check conventional setting:\n        sga = SpacegroupAnalyzer(structure)\n        dataset = sga.get_symmetry_dataset()\n        trans_mat = dataset['transformation_matrix']\n        conv_latt = Lattice(np.transpose(np.dot(np.transpose(\n            structure.lattice.matrix), np.linalg.inv(trans_mat))))\n        xtal_sys = sga.get_crystal_system()\n\n        vecs = conv_latt.matrix\n        lengths = np.array(conv_latt.abc)\n        angles = np.array(conv_latt.angles)\n        rotation = np.zeros((3, 3))\n\n        # IEEE rules: a,b,c || x1,x2,x3\n        if xtal_sys == \"cubic\":\n            rotation = [vecs[i] / lengths[i] for i in range(3)]\n\n        # IEEE rules: a=b in length; c,a || x3, x1\n        elif xtal_sys == \"tetragonal\":\n            rotation = np.array([vec / mag for (mag, vec) in\n                                 sorted(zip(lengths, vecs),\n                                        key=lambda x: x[0])])\n            if abs(lengths[2] - lengths[1]) < abs(lengths[1] - lengths[0]):\n                rotation[0], rotation[2] = rotation[2], rotation[0].copy()\n            rotation[1] = get_uvec(np.cross(rotation[2], rotation[0]))\n\n        # IEEE rules: c<a<b; c,a || x3,x1\n        elif xtal_sys == \"orthorhombic\":\n            rotation = [vec / mag for (mag, vec) in sorted(zip(lengths, vecs))]\n            rotation = np.roll(rotation, 2, axis=0)\n\n        # IEEE rules: c,a || x3,x1, c is threefold axis\n        # Note this also includes rhombohedral crystal systems\n        elif xtal_sys in (\"trigonal\", \"hexagonal\"):\n            # find threefold axis:\n            tf_index = np.argmin(abs(angles - 120.))\n            non_tf_mask = np.logical_not(angles == angles[tf_index])\n            rotation[2] = get_uvec(vecs[tf_index])\n            rotation[0] = get_uvec(vecs[non_tf_mask][0])\n            rotation[1] = get_uvec(np.cross(rotation[2], rotation[0]))\n\n        # IEEE rules: b,c || x2,x3; alpha=beta=90, c<a\n        elif xtal_sys == \"monoclinic\":\n            # Find unique axis\n            u_index = np.argmax(abs(angles - 90.))\n            n_umask = np.logical_not(angles == angles[u_index])\n            rotation[1] = get_uvec(vecs[u_index])\n            # Shorter of remaining lattice vectors for c axis\n            c = [vec / mag for (mag, vec) in\n                 sorted(zip(lengths[n_umask], vecs[n_umask]))][0]\n            rotation[2] = np.array(c)\n            rotation[0] = np.cross(rotation[1], rotation[2])\n\n        # IEEE rules: c || x3, x2 normal to ac plane\n        elif xtal_sys == \"triclinic\":\n            rotation = [vec / mag for (mag, vec) in sorted(zip(lengths, vecs))]\n            rotation[1] = get_uvec(np.cross(rotation[2], rotation[0]))\n            rotation[0] = np.cross(rotation[1], rotation[2])\n\n        rotation = SquareTensor(rotation)\n        if refine_rotation:\n            rotation = rotation.refine_rotation()\n\n        return rotation", "response": "This function determines the rotation matrix for the IEEE conversion according to the 1987 IEEE standards."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconverts a structure to IEEE format.", "response": "def convert_to_ieee(self, structure, initial_fit=True,\n                        refine_rotation=True):\n        \"\"\"\n        Given a structure associated with a tensor, attempts a\n        calculation of the tensor in IEEE format according to\n        the 1987 IEEE standards.\n\n        Args:\n            structure (Structure): a structure associated with the\n                tensor to be converted to the IEEE standard\n            initial_fit (bool): flag to indicate whether initial\n                tensor is fit to the symmetry of the structure.\n                Defaults to true. Note that if false, inconsistent\n                results may be obtained due to symmetrically\n                equivalent, but distinct transformations\n                being used in different versions of spglib.\n            refine_rotation (bool): whether to refine the rotation\n                produced by the ieee transform generator, default True\n        \"\"\"\n        rotation = self.get_ieee_rotation(structure, refine_rotation)\n        result = self.copy()\n        if initial_fit:\n            result = result.fit_to_structure(structure)\n        return result.rotate(rotation, tol=1e-2)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ntransforming a tensor from one basis for an original structure into a new basis defined by a new structure.", "response": "def structure_transform(self, original_structure, new_structure,\n                            refine_rotation=True):\n        \"\"\"\n        Transforms a tensor from one basis for an original structure\n        into a new basis defined by a new structure.\n\n        Args:\n            original_structure (Structure): structure corresponding\n                to the basis of the current tensor\n            new_structure (Structure): structure corresponding to the\n                desired basis\n            refine_rotation (bool): whether to refine the rotations\n                generated in get_ieee_rotation\n\n        Returns:\n            Tensor that has been transformed such that its basis\n            corresponds to the new_structure's basis\n        \"\"\"\n        sm = StructureMatcher()\n        if not sm.fit(original_structure, new_structure):\n            warnings.warn(\"original and new structures do not match!\")\n        trans_1 = self.get_ieee_rotation(original_structure, refine_rotation)\n        trans_2 = self.get_ieee_rotation(new_structure, refine_rotation)\n        # Get the ieee format tensor\n        new = self.rotate(trans_1)\n        # Reverse the ieee format rotation for the second structure\n        new = new.rotate(np.transpose(trans_2))\n        return new"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating a tensor from values and indices.", "response": "def from_values_indices(cls, values, indices, populate=False,\n                            structure=None, voigt_rank=None,\n                            vsym=True, verbose=False):\n        \"\"\"\n        Creates a tensor from values and indices, with options\n        for populating the remainder of the tensor.\n\n        Args:\n            values (floats): numbers to place at indices\n            indices (array-likes): indices to place values at\n            populate (bool): whether to populate the tensor\n            structure (Structure): structure to base population\n                or fit_to_structure on\n            voigt_rank (int): full tensor rank to indicate the\n                shape of the resulting tensor.  This is necessary\n                if one provides a set of indices more minimal than\n                the shape of the tensor they want, e.g.\n                Tensor.from_values_indices((0, 0), 100)\n            vsym (bool): whether to voigt symmetrize during the\n                optimization procedure\n            verbose (bool): whether to populate verbosely\n        \"\"\"\n        # auto-detect voigt notation\n        # TODO: refactor rank inheritance to make this easier\n        indices = np.array(indices)\n        if voigt_rank:\n            shape = ([3]*(voigt_rank % 2) + [6]*(voigt_rank // 2))\n        else:\n            shape = np.ceil(np.max(indices+1, axis=0) / 3.) * 3\n        base = np.zeros(shape.astype(int))\n        for v, idx in zip(values, indices):\n            base[tuple(idx)] = v\n        if 6 in shape:\n            obj = cls.from_voigt(base)\n        else:\n            obj = cls(base)\n        if populate:\n            assert structure, \"Populate option must include structure input\"\n            obj = obj.populate(structure, vsym=vsym, verbose=verbose)\n        elif structure:\n            obj = obj.fit_to_structure(structure)\n        return obj"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\npopulate the non - zero entries of the current tensor with the values of the non - zero entries of the original tensor.", "response": "def populate(self, structure, prec=1e-5, maxiter=200, verbose=False,\n                 precond=True, vsym=True):\n        \"\"\"\n        Takes a partially populated tensor, and populates the non-zero\n        entries according to the following procedure, iterated until\n        the desired convergence (specified via prec) is achieved.\n\n        1. Find non-zero entries\n        2. Symmetrize the tensor with respect to crystal symmetry and\n           (optionally) voigt symmetry\n        3. Reset the non-zero entries of the original tensor\n\n        Args:\n            structure (structure object)\n            prec (float): precision for determining a non-zero value\n            maxiter (int): maximum iterations for populating the tensor\n            verbose (bool): whether to populate verbosely\n            precond (bool): whether to precondition by cycling through\n                all symmops and storing new nonzero values, default True\n            vsym (bool): whether to enforce voigt symmetry, defaults\n                to True\n        \"\"\"\n        if precond:\n            # Generate the guess from populated\n            sops = SpacegroupAnalyzer(structure).get_symmetry_operations()\n            guess = Tensor(np.zeros(self.shape))\n            mask = abs(self) > prec\n            guess[mask] = self[mask]\n\n            def merge(old, new):\n                gmask = np.abs(old) > prec\n                nmask = np.abs(new) > prec\n                new_mask = np.logical_not(gmask)*nmask\n                avg_mask = gmask*nmask\n                old[avg_mask] = (old[avg_mask] + new[avg_mask]) / 2.\n                old[new_mask] = new[new_mask]\n            if verbose:\n                print(\"Preconditioning for {} symmops\".format(len(sops)))\n            for sop in sops:\n                rot = guess.transform(sop)\n                # Store non-zero entries of new that weren't previously\n                # in the guess in the guess\n                merge(guess, rot)\n            if verbose:\n                print(\"Preconditioning for voigt symmetry\".format(len(sops)))\n            if vsym:\n                v = guess.voigt\n                perms = list(itertools.permutations(range(len(v.shape))))\n                for perm in perms:\n                    vtrans = np.transpose(v, perm)\n                    merge(v, vtrans)\n                guess = Tensor.from_voigt(v)\n        else:\n            guess = np.zeros(self.shape)\n\n        assert guess.shape == self.shape, \"Guess must have same shape\"\n        converged = False\n        test_new, test_old = [guess.copy()]*2\n        for i in range(maxiter):\n            test_new = test_old.fit_to_structure(structure)\n            if vsym:\n                test_new = test_new.voigt_symmetrized\n            diff = np.abs(test_old - test_new)\n            converged = (diff < prec).all()\n            if converged:\n                break\n            test_new[mask] = self[mask]\n            test_old = test_new\n            if verbose:\n                print(\"Iteration {}: {}\".format(i, np.max(diff)))\n        if not converged:\n            max_diff = np.max(np.abs(self - test_new))\n            warnings.warn(\"Warning, populated tensor is not converged \"\n                          \"with max diff of {}\".format(max_diff))\n        return self.__class__(test_new)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the object as a dictionary.", "response": "def as_dict(self, voigt=False):\n        \"\"\"\n        Serializes the tensor object\n\n        Args:\n            voigt (bool): flag for whether to store entries in\n                voigt-notation.  Defaults to false, as information\n                may be lost in conversion.\n\n        Returns (Dict):\n            serialized format tensor object\n\n        \"\"\"\n        input_array = self.voigt if voigt else self\n        d = {\"@module\": self.__class__.__module__,\n             \"@class\": self.__class__.__name__,\n             \"input_array\": input_array.tolist()}\n        if voigt:\n            d.update({\"voigt\": voigt})\n        return d"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef inv(self):\n        if self.det == 0:\n            raise ValueError(\"SquareTensor is non-invertible\")\n        return SquareTensor(np.linalg.inv(self))", "response": "shorthand for matrix inverse on SquareTensor"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ntests to see if the matrix is a valid rotation matrix.", "response": "def is_rotation(self, tol=1e-3, include_improper=True):\n        \"\"\"\n        Test to see if tensor is a valid rotation matrix, performs a\n        test to check whether the inverse is equal to the transpose\n        and if the determinant is equal to one within the specified\n        tolerance\n\n        Args:\n            tol (float): tolerance to both tests of whether the\n                the determinant is one and the inverse is equal\n                to the transpose\n            include_improper (bool): whether to include improper\n                rotations in the determination of validity\n        \"\"\"\n        det = np.abs(np.linalg.det(self))\n        if include_improper:\n            det = np.abs(det)\n        return (np.abs(self.inv - self.trans) < tol).all() \\\n            and (np.abs(det - 1.) < tol)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef refine_rotation(self):\n        new_x, y = get_uvec(self[0]), get_uvec(self[1])\n        # Get a projection on y\n        new_y = y - np.dot(new_x, y) * new_x\n        new_z = np.cross(new_x, new_y)\n        return SquareTensor([new_x, new_y, new_z])", "response": "Refines the rotation matrix by ensuring that the second and third rows are perpindicular to the first."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncalculate the average oxidation state of a site.", "response": "def compute_average_oxidation_state(site):\n    \"\"\"\n    Calculates the average oxidation state of a site\n\n    Args:\n        site: Site to compute average oxidation state\n\n    Returns:\n        Average oxidation state of site.\n    \"\"\"\n    try:\n        avg_oxi = sum([sp.oxi_state * occu\n                       for sp, occu in site.species.items()\n                       if sp is not None])\n        return avg_oxi\n    except AttributeError:\n        pass\n    try:\n        return site.charge\n    except AttributeError:\n        raise ValueError(\"Ewald summation can only be performed on structures \"\n                         \"that are either oxidation state decorated or have \"\n                         \"site charges.\")"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncomputing the total ewald energy for certain sites being removed.", "response": "def compute_partial_energy(self, removed_indices):\n        \"\"\"\n        Gives total ewald energy for certain sites being removed, i.e. zeroed\n        out.\n        \"\"\"\n        total_energy_matrix = self.total_energy_matrix.copy()\n        for i in removed_indices:\n            total_energy_matrix[i, :] = 0\n            total_energy_matrix[:, i] = 0\n        return sum(sum(total_energy_matrix))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncompute total ewald energy for a given sub - structure.", "response": "def compute_sub_structure(self, sub_structure, tol=1e-3):\n        \"\"\"\n        Gives total ewald energy for an sub structure in the same\n        lattice. The sub_structure must be a subset of the original\n        structure, with possible different charges.\n\n        Args:\n            substructure (Structure): Substructure to compute Ewald sum for.\n            tol (float): Tolerance for site matching in fractional coordinates.\n\n        Returns:\n            Ewald sum of substructure.\n        \"\"\"\n        total_energy_matrix = self.total_energy_matrix.copy()\n\n        def find_match(site):\n            for test_site in sub_structure:\n                frac_diff = abs(np.array(site.frac_coords)\n                                - np.array(test_site.frac_coords)) % 1\n                frac_diff = [abs(a) < tol or abs(a) > 1 - tol\n                             for a in frac_diff]\n                if all(frac_diff):\n                    return test_site\n            return None\n\n        matches = []\n        for i, site in enumerate(self._s):\n            matching_site = find_match(site)\n            if matching_site:\n                new_charge = compute_average_oxidation_state(matching_site)\n                old_charge = self._oxi_states[i]\n                scaling_factor = new_charge / old_charge\n                matches.append(matching_site)\n            else:\n                scaling_factor = 0\n            total_energy_matrix[i, :] *= scaling_factor\n            total_energy_matrix[:, i] *= scaling_factor\n\n        if len(matches) != len(sub_structure):\n            output = [\"Missing sites.\"]\n            for site in sub_structure:\n                if site not in matches:\n                    output.append(\"unmatched = {}\".format(site))\n            raise ValueError(\"\\n\".join(output))\n\n        return sum(sum(total_energy_matrix))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_site_energy(self, site_index):\n        if self._charged:\n            warn('Per atom energies for charged structures not supported in EwaldSummation')\n        return np.sum(self._recip[:,site_index]) + np.sum(self._real[:,site_index]) \\\n            + self._point[site_index]", "response": "Compute the energy of a single site in the structure\n        \n           "}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nperforming the reciprocal space summation. Calculates the quantity of the entries in the entry - set of the entry - set of the entry - set of the entry - set of the entry - set of the entry - set of the entry - set of the entry - set of the entry - set of the entry that is used to calculate the reciprocal space summation.", "response": "def _calc_recip(self):\n        \"\"\"\n        Perform the reciprocal space summation. Calculates the quantity\n        E_recip = 1/(2PiV) sum_{G < Gmax} exp(-(G.G/4/eta))/(G.G) S(G)S(-G)\n        where\n        S(G) = sum_{k=1,N} q_k exp(-i G.r_k)\n        S(G)S(-G) = |S(G)|**2\n\n        This method is heavily vectorized to utilize numpy's C backend for\n        speed.\n        \"\"\"\n        numsites = self._s.num_sites\n        prefactor = 2 * pi / self._vol\n        erecip = np.zeros((numsites, numsites), dtype=np.float)\n        forces = np.zeros((numsites, 3), dtype=np.float)\n        coords = self._coords\n        rcp_latt = self._s.lattice.reciprocal_lattice\n        recip_nn = rcp_latt.get_points_in_sphere([[0, 0, 0]], [0, 0, 0],\n                                                 self._gmax)\n\n        frac_coords = [fcoords for (fcoords, dist, i, img) in recip_nn if dist != 0]\n\n        gs = rcp_latt.get_cartesian_coords(frac_coords)\n        g2s = np.sum(gs ** 2, 1)\n        expvals = np.exp(-g2s / (4 * self._eta))\n        grs = np.sum(gs[:, None] * coords[None, :], 2)\n\n        oxistates = np.array(self._oxi_states)\n\n        # create array where q_2[i,j] is qi * qj\n        qiqj = oxistates[None, :] * oxistates[:, None]\n\n        # calculate the structure factor\n        sreals = np.sum(oxistates[None, :] * np.cos(grs), 1)\n        simags = np.sum(oxistates[None, :] * np.sin(grs), 1)\n\n        for g, g2, gr, expval, sreal, simag in zip(gs, g2s, grs, expvals,\n                                                   sreals, simags):\n\n            # Uses the identity sin(x)+cos(x) = 2**0.5 sin(x + pi/4)\n            m = (gr[None, :] + pi / 4) - gr[:, None]\n            np.sin(m, m)\n            m *= expval / g2\n\n            erecip += m\n\n            if self._compute_forces:\n                pref = 2 * expval / g2 * oxistates\n                factor = prefactor * pref * (\n                    sreal * np.sin(gr) - simag * np.cos(gr))\n\n                forces += factor[:, None] * g[None, :]\n\n        forces *= EwaldSummation.CONV_FACT\n        erecip *= prefactor * EwaldSummation.CONV_FACT * qiqj * 2 ** 0.5\n        return erecip, forces"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _calc_real_and_point(self):\n        fcoords = self._s.frac_coords\n        forcepf = 2.0 * self._sqrt_eta / sqrt(pi)\n        coords = self._coords\n        numsites = self._s.num_sites\n        ereal = np.empty((numsites, numsites), dtype=np.float)\n\n        forces = np.zeros((numsites, 3), dtype=np.float)\n\n        qs = np.array(self._oxi_states)\n\n        epoint = - qs ** 2 * sqrt(self._eta / pi)\n\n        for i in range(numsites):\n            nfcoords, rij, js, _ = self._s.lattice.get_points_in_sphere(fcoords,\n                                    coords[i], self._rmax, zip_results=False)\n\n            # remove the rii term\n            inds = rij > 1e-8\n            js = js[inds]\n            rij = rij[inds]\n            nfcoords = nfcoords[inds]\n\n            qi = qs[i]\n            qj = qs[js]\n\n            erfcval = erfc(self._sqrt_eta * rij)\n            new_ereals = erfcval * qi * qj / rij\n\n            # insert new_ereals\n            for k in range(numsites):\n                ereal[k, i] = np.sum(new_ereals[js == k])\n\n            if self._compute_forces:\n                nccoords = self._s.lattice.get_cartesian_coords(nfcoords)\n\n                fijpf = qj / rij ** 3 * (erfcval + forcepf * rij *\n                                         np.exp(-self._eta * rij ** 2))\n                forces[i] += np.sum(np.expand_dims(fijpf, 1) *\n                                    (np.array([coords[i]]) - nccoords) *\n                                    qi * EwaldSummation.CONV_FACT, axis=0)\n\n        ereal *= 0.5 * EwaldSummation.CONV_FACT\n        epoint *= EwaldSummation.CONV_FACT\n        return ereal, epoint, forces", "response": "Calculates the real and point of the resource in the system."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef minimize_matrix(self):\n        if self._algo == EwaldMinimizer.ALGO_FAST or \\\n                        self._algo == EwaldMinimizer.ALGO_BEST_FIRST:\n            return self._recurse(self._matrix, self._m_list,\n                                 set(range(len(self._matrix))))", "response": "This method returns the permutations that produce the lowest\n           "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef add_m_list(self, matrix_sum, m_list):\n        if self._output_lists is None:\n            self._output_lists = [[matrix_sum, m_list]]\n        else:\n            bisect.insort(self._output_lists, [matrix_sum, m_list])\n        if self._algo == EwaldMinimizer.ALGO_BEST_FIRST and \\\n                        len(self._output_lists) == self._num_to_return:\n            self._finished = True\n        if len(self._output_lists) > self._num_to_return:\n            self._output_lists.pop()\n        if len(self._output_lists) == self._num_to_return:\n            self._current_minimum = self._output_lists[-1][0]", "response": "Adds a list of entries to the output_lists and updates the current_minimum if the list is full."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef best_case(self, matrix, m_list, indices_left):\n        m_indices = []\n        fraction_list = []\n        for m in m_list:\n            m_indices.extend(m[2])\n            fraction_list.extend([m[0]] * m[1])\n\n        indices = list(indices_left.intersection(m_indices))\n\n        interaction_matrix = matrix[indices, :][:, indices]\n\n        fractions = np.zeros(len(interaction_matrix)) + 1\n        fractions[:len(fraction_list)] = fraction_list\n        fractions = np.sort(fractions)\n\n        # Sum associated with each index (disregarding interactions between\n        # indices)\n        sums = 2 * np.sum(matrix[indices], axis=1)\n        sums = np.sort(sums)\n\n        # Interaction corrections. Can be reduced to (1-x)(1-y) for x,y in\n        # fractions each element in a column gets multiplied by (1-x), and then\n        # the sum of the columns gets multiplied by (1-y) since fractions are\n        # less than 1, there is no effect of one choice on the other\n        step1 = np.sort(interaction_matrix) * (1 - fractions)\n        step2 = np.sort(np.sum(step1, axis=1))\n        step3 = step2 * (1 - fractions)\n        interaction_correction = np.sum(step3)\n\n        if self._algo == self.ALGO_TIME_LIMIT:\n            elapsed_time = datetime.utcnow() - self._start_time\n            speedup_parameter = elapsed_time.total_seconds() / 1800\n            avg_int = np.sum(interaction_matrix, axis=None)\n            avg_frac = np.average(np.outer(1 - fractions, 1 - fractions))\n            average_correction = avg_int * avg_frac\n\n            interaction_correction = average_correction * speedup_parameter \\\n                + interaction_correction * (1 - speedup_parameter)\n\n        best_case = np.sum(matrix) + np.inner(sums[::-1], fractions - 1) \\\n            + interaction_correction\n\n        return best_case", "response": "Computes a best case given a matrix and manipulation list."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_next_index(self, matrix, manipulation, indices_left):\n        f = manipulation[0]\n        indices = list(indices_left.intersection(manipulation[2]))\n        sums = np.sum(matrix[indices], axis=1)\n        if f < 1:\n            next_index = indices[sums.argmax(axis=0)]\n        else:\n            next_index = indices[sums.argmin(axis=0)]\n\n        return next_index", "response": "Returns an index that should have the most negative effect on the\n            matrix sum\n           "}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _recurse(self, matrix, m_list, indices, output_m_list=[]):\n        # check to see if we've found all the solutions that we need\n        if self._finished:\n            return\n\n        # if we're done with the current manipulation, pop it off.\n        while m_list[-1][1] == 0:\n            m_list = copy(m_list)\n            m_list.pop()\n            # if there are no more manipulations left to do check the value\n            if not m_list:\n                matrix_sum = np.sum(matrix)\n                if matrix_sum < self._current_minimum:\n                    self.add_m_list(matrix_sum, output_m_list)\n                return\n\n        # if we wont have enough indices left, return\n        if m_list[-1][1] > len(indices.intersection(m_list[-1][2])):\n            return\n\n        if len(m_list) == 1 or m_list[-1][1] > 1:\n            if self.best_case(matrix, m_list, indices) > self._current_minimum:\n                return\n\n        index = self.get_next_index(matrix, m_list[-1], indices)\n\n        m_list[-1][2].remove(index)\n\n        # Make the matrix and new m_list where we do the manipulation to the\n        # index that we just got\n        matrix2 = np.copy(matrix)\n        m_list2 = deepcopy(m_list)\n        output_m_list2 = copy(output_m_list)\n\n        matrix2[index, :] *= m_list[-1][0]\n        matrix2[:, index] *= m_list[-1][0]\n        output_m_list2.append([index, m_list[-1][3]])\n        indices2 = copy(indices)\n        indices2.remove(index)\n        m_list2[-1][1] -= 1\n\n        # recurse through both the modified and unmodified matrices\n\n        self._recurse(matrix2, m_list2, indices2, output_m_list2)\n        self._recurse(matrix, m_list, indices, output_m_list)", "response": "This method recursively finds the minimal permutations of the current set of entries in the matrix and adds them to the output_m_list."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncalculating the ensemble averaged Voronoi coordination numbers for a list of Structures.", "response": "def average_coordination_number(structures, freq=10):\n    \"\"\"\n    Calculates the ensemble averaged Voronoi coordination numbers\n    of a list of Structures using VoronoiNN.\n    Typically used for analyzing the output of a Molecular Dynamics run.\n    Args:\n        structures (list): list of Structures.\n        freq (int): sampling frequency of coordination number [every freq steps].\n    Returns:\n        Dictionary of elements as keys and average coordination numbers as values.\n    \"\"\"\n    coordination_numbers = {}\n    for spec in structures[0].composition.as_dict().keys():\n        coordination_numbers[spec] = 0.0\n    count = 0\n    for t in range(len(structures)):\n        if t % freq != 0:\n            continue\n        count += 1\n        vnn = VoronoiNN()\n        for atom in range(len(structures[0])):\n            cn = vnn.get_cn(structures[t], atom, use_weights=True)\n            coordination_numbers[structures[t][atom].species_string] += cn\n    elements = structures[0].composition.as_dict()\n    for el in coordination_numbers:\n        coordination_numbers[el] = coordination_numbers[el] / elements[\n            el] / count\n    return coordination_numbers"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef solid_angle(center, coords):\n    o = np.array(center)\n    r = [np.array(c) - o for c in coords]\n    r.append(r[0])\n    n = [np.cross(r[i + 1], r[i]) for i in range(len(r) - 1)]\n    n.append(np.cross(r[1], r[0]))\n    vals = []\n    for i in range(len(n) - 1):\n        v = -np.dot(n[i], n[i + 1]) \\\n            / (np.linalg.norm(n[i]) * np.linalg.norm(n[i + 1]))\n        vals.append(acos(abs_cap(v)))\n    phi = sum(vals)\n    return phi + (3 - len(r)) * pi", "response": "Calculates the solid angle of a set of coords from the center."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_max_bond_lengths(structure, el_radius_updates=None):\n    #jmc = JMolCoordFinder(el_radius_updates)\n    jmnn = JmolNN(el_radius_updates=el_radius_updates)\n\n    bonds_lens = {}\n    els = sorted(structure.composition.elements, key=lambda x: x.Z)\n\n    for i1 in range(len(els)):\n        for i2 in range(len(els) - i1):\n            bonds_lens[els[i1], els[i1 + i2]] = jmnn.get_max_bond_distance(\n                els[i1].symbol, els[i1 + i2].symbol)\n\n    return bonds_lens", "response": "Returns the maximum bond length estimates for a structure based on JMol\n    table and algorithms."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef contains_peroxide(structure, relative_cutoff=1.1):\n    ox_type = oxide_type(structure, relative_cutoff)\n    if ox_type == \"peroxide\":\n        return True\n    else:\n        return False", "response": "Determines if a structure contains a peroxide anion."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef oxide_type(structure, relative_cutoff=1.1, return_nbonds=False):\n\n    ox_obj = OxideType(structure, relative_cutoff)\n    if return_nbonds:\n        return ox_obj.oxide_type, ox_obj.nbonds\n    else:\n        return ox_obj.oxide_type", "response": "Determines if an oxide is a peroxide superoxide or ozonide or normal oxide."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef sulfide_type(structure):\n    structure = structure.copy()\n    structure.remove_oxidation_states()\n    s = Element(\"S\")\n    comp = structure.composition\n    if comp.is_element or s not in comp:\n        return None\n\n    finder = SpacegroupAnalyzer(structure, symprec=0.1)\n    symm_structure = finder.get_symmetrized_structure()\n    s_sites = [sites[0] for sites in symm_structure.equivalent_sites if\n               sites[0].specie == s]\n\n    def process_site(site):\n\n        # in an exceptionally rare number of structures, the search\n        # radius needs to be increased to find a neighbor atom\n        search_radius = 4\n        neighbors = []\n        while len(neighbors) == 0:\n            neighbors = structure.get_neighbors(site, search_radius)\n            search_radius *= 2\n            if search_radius > max(structure.lattice.abc)*2:\n                break\n\n        neighbors = sorted(neighbors, key=lambda n: n[1])\n        nn, dist = neighbors[0]\n        coord_elements = [site.specie for site, d in neighbors\n                          if d < dist + 0.4][:4]\n        avg_electroneg = np.mean([e.X for e in coord_elements])\n        if avg_electroneg > s.X:\n            return \"sulfate\"\n        elif avg_electroneg == s.X and s in coord_elements:\n            return \"polysulfide\"\n        else:\n            return \"sulfide\"\n\n    types = set([process_site(site) for site in s_sites])\n    if \"sulfate\" in types:\n        return None\n    elif \"polysulfide\" in types:\n        return \"polysulfide\"\n    else:\n        return \"sulfide\"", "response": "Determines if a structure is a sulfide or polysulfide."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nperforms Voronoi analysis and returns the polyhedra around the center atom n in Schlaefli notation.", "response": "def analyze(self, structure, n=0):\n        \"\"\"\n        Performs Voronoi analysis and returns the polyhedra around atom n\n        in Schlaefli notation.\n\n        Args:\n            structure (Structure): structure to analyze\n            n (int): index of the center atom in structure\n\n        Returns:\n            voronoi index of n: <c3,c4,c6,c6,c7,c8,c9,c10>\n                where c_i denotes number of facets with i vertices.\n        \"\"\"\n        center = structure[n]\n        neighbors = structure.get_sites_in_sphere(center.coords, self.cutoff)\n        neighbors = [i[0] for i in sorted(neighbors, key=lambda s: s[1])]\n        qvoronoi_input = np.array([s.coords for s in neighbors])\n        voro = Voronoi(qvoronoi_input, qhull_options=self.qhull_options)\n        vor_index = np.array([0, 0, 0, 0, 0, 0, 0, 0])\n\n        for key in voro.ridge_dict:\n            if 0 in key:  # This means if the center atom is in key\n                if -1 in key:  # This means if an infinity point is in key\n                    raise ValueError(\"Cutoff too short.\")\n                else:\n                    try:\n                        vor_index[len(voro.ridge_dict[key]) - 3] += 1\n                    except IndexError:\n                        # If a facet has more than 10 edges, it's skipped here.\n                        pass\n        return vor_index"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef analyze_structures(self, structures, step_freq=10,\n                           most_frequent_polyhedra=15):\n        \"\"\"\n        Perform Voronoi analysis on a list of Structures.\n        Note that this might take a significant amount of time depending on the\n        size and number of structures.\n\n        Args:\n            structures (list): list of Structures\n            cutoff (float: cutoff distance around an atom to search for\n                neighbors\n            step_freq (int): perform analysis every step_freq steps\n            qhull_options (str): options to pass to qhull\n            most_frequent_polyhedra (int): this many unique polyhedra with\n                highest frequences is stored.\n\n        Returns:\n            A list of tuples in the form (voronoi_index,frequency)\n        \"\"\"\n        voro_dict = {}\n        step = 0\n        for structure in structures:\n            step += 1\n            if step % step_freq != 0:\n                continue\n\n            v = []\n            for n in range(len(structure)):\n                v.append(str(self.analyze(structure, n=n).view()))\n            for voro in v:\n                if voro in voro_dict:\n                    voro_dict[voro] += 1\n                else:\n                    voro_dict[voro] = 1\n        return sorted(voro_dict.items(),\n                      key=lambda x: (x[1], x[0]),\n                      reverse=True)[:most_frequent_polyhedra]", "response": "Perform Voronoi analysis on a list of Structures."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the percentage volume change.", "response": "def get_percentage_volume_change(self):\n        \"\"\"\n        Returns the percentage volume change.\n\n        Returns:\n            Volume change in percentage, e.g., 0.055 implies a 5.5% increase.\n        \"\"\"\n        initial_vol = self.initial.lattice.volume\n        final_vol = self.final.lattice.volume\n        return final_vol / initial_vol - 1"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the percentage change in lattice parameter changes.", "response": "def get_percentage_lattice_parameter_changes(self):\n        \"\"\"\n        Returns the percentage lattice parameter changes.\n\n        Returns:\n            A dict of the percentage change in lattice parameter, e.g.,\n            {'a': 0.012, 'b': 0.021, 'c': -0.031} implies a change of 1.2%,\n            2.1% and -3.1% in the a, b and c lattice parameters respectively.\n        \"\"\"\n        initial_latt = self.initial.lattice\n        final_latt = self.final.lattice\n        d = {l: getattr(final_latt, l) / getattr(initial_latt, l) - 1\n             for l in [\"a\", \"b\", \"c\"]}\n        return d"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_percentage_bond_dist_changes(self, max_radius=3.0):\n        data = collections.defaultdict(dict)\n        for inds in itertools.combinations(list(range(len(self.initial))), 2):\n            (i, j) = sorted(inds)\n            initial_dist = self.initial[i].distance(self.initial[j])\n            if initial_dist < max_radius:\n                final_dist = self.final[i].distance(self.final[j])\n                data[i][j] = final_dist / initial_dist - 1\n        return data", "response": "Returns the percentage bond distance changes for each site up to max_radius for nearest neighbors."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nprovides connectivity array. Returns: connectivity: An array of shape [atomi, atomj, imagej]. atomi is the index of the atom in the input structure. Since the second atom can be outside of the unit cell, it must be described by both an atom index and an image index. Array data is the solid angle of polygon between atomi and imagej of atomj", "response": "def connectivity_array(self):\n        \"\"\"\n        Provides connectivity array.\n\n        Returns:\n            connectivity: An array of shape [atomi, atomj, imagej]. atomi is\n            the index of the atom in the input structure. Since the second\n            atom can be outside of the unit cell, it must be described\n            by both an atom index and an image index. Array data is the\n            solid angle of polygon between atomi and imagej of atomj\n        \"\"\"\n        # shape = [site, axis]\n        cart_coords = np.array(self.s.cart_coords)\n        # shape = [site, image, axis]\n        all_sites = cart_coords[:, None, :] + self.cart_offsets[None, :, :]\n        vt = Voronoi(all_sites.reshape((-1, 3)))\n        n_images = all_sites.shape[1]\n        cs = (len(self.s), len(self.s), len(self.cart_offsets))\n        connectivity = np.zeros(cs)\n        vts = np.array(vt.vertices)\n        for (ki, kj), v in vt.ridge_dict.items():\n            atomi = ki // n_images\n            atomj = kj // n_images\n\n            imagei = ki % n_images\n            imagej = kj % n_images\n\n            if imagei != n_images // 2 and imagej != n_images // 2:\n                continue\n\n            if imagei == n_images // 2:\n                # atomi is in original cell\n                val = solid_angle(vt.points[ki], vts[v])\n                connectivity[atomi, atomj, imagej] = val\n\n            if imagej == n_images // 2:\n                # atomj is in original cell\n                val = solid_angle(vt.points[kj], vts[v])\n                connectivity[atomj, atomi, imagei] = val\n\n            if -10.101 in vts[v]:\n                warn('Found connectivity with infinite vertex. '\n                     'Cutoff is too low, and results may be '\n                     'incorrect')\n        return connectivity"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a list of site pairs that are Voronoi Neighbors along the cluster with their real - space distances.", "response": "def get_connections(self):\n        \"\"\"\n        Returns a list of site pairs that are Voronoi Neighbors, along\n        with their real-space distances.\n        \"\"\"\n        con = []\n        maxconn = self.max_connectivity\n        for ii in range(0, maxconn.shape[0]):\n            for jj in range(0, maxconn.shape[1]):\n                if maxconn[ii][jj] != 0:\n                    dist = self.s.get_distance(ii, jj)\n                    con.append([ii, jj, dist])\n        return con"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_sitej(self, site_index, image_index):\n        atoms_n_occu = self.s[site_index].species\n        lattice = self.s.lattice\n        coords = self.s[site_index].frac_coords + self.offsets[image_index]\n        return PeriodicSite(atoms_n_occu, coords, lattice)", "response": "Returns the sitei and sitej for a given site and image."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nparsing an oxide structure and returns the type of oxide or hydroxide.", "response": "def parse_oxide(self):\n        \"\"\"\n        Determines if an oxide is a peroxide/superoxide/ozonide/normal oxide.\n\n        Returns:\n            oxide_type (str): Type of oxide\n            ozonide/peroxide/superoxide/hydroxide/None.\n            nbonds (int): Number of peroxide/superoxide/hydroxide bonds in\n            structure.\n        \"\"\"\n        structure = self.structure\n        relative_cutoff = self.relative_cutoff\n        o_sites_frac_coords = []\n        h_sites_frac_coords = []\n        lattice = structure.lattice\n\n        if isinstance(structure.composition.elements[0], Element):\n            comp = structure.composition\n        elif isinstance(structure.composition.elements[0], Specie):\n            elmap = collections.defaultdict(float)\n            for site in structure:\n                for species, occu in site.species.items():\n                    elmap[species.element] += occu\n            comp = Composition(elmap)\n        if Element(\"O\") not in comp or comp.is_element:\n            return \"None\", 0\n\n        for site in structure:\n            syms = [sp.symbol for sp in site.species.keys()]\n            if \"O\" in syms:\n                o_sites_frac_coords.append(site.frac_coords)\n            if \"H\" in syms:\n                h_sites_frac_coords.append(site.frac_coords)\n\n        if h_sites_frac_coords:\n            dist_matrix = lattice.get_all_distances(o_sites_frac_coords,\n                                                    h_sites_frac_coords)\n            if np.any(dist_matrix < relative_cutoff * 0.93):\n                return \"hydroxide\", len(\n                    np.where(dist_matrix < relative_cutoff * 0.93)[0]) / 2.0\n        dist_matrix = lattice.get_all_distances(o_sites_frac_coords,\n                                                o_sites_frac_coords)\n        np.fill_diagonal(dist_matrix, 1000)\n        is_superoxide = False\n        is_peroxide = False\n        is_ozonide = False\n        if np.any(dist_matrix < relative_cutoff * 1.35):\n            bond_atoms = np.where(dist_matrix < relative_cutoff * 1.35)[0]\n            is_superoxide = True\n        elif np.any(dist_matrix < relative_cutoff * 1.49):\n            is_peroxide = True\n            bond_atoms = np.where(dist_matrix < relative_cutoff * 1.49)[0]\n        if is_superoxide:\n            if len(bond_atoms) > len(set(bond_atoms)):\n                is_superoxide = False\n                is_ozonide = True\n        try:\n            nbonds = len(set(bond_atoms))\n        except UnboundLocalError:\n            nbonds = 0.0\n        if is_ozonide:\n            str_oxide = \"ozonide\"\n        elif is_superoxide:\n            str_oxide = \"superoxide\"\n        elif is_peroxide:\n            str_oxide = \"peroxide\"\n        else:\n            str_oxide = \"oxide\"\n        if str_oxide == \"oxide\":\n            nbonds = comp[\"O\"]\n        return str_oxide, nbonds"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nidentify non - H non - C atoms in the MoleculeGraph returning a list of ints representing node indices.", "response": "def get_heteroatoms(self, elements=None):\n        \"\"\"\n        Identify non-H, non-C atoms in the MoleculeGraph, returning a list of\n        their node indices.\n\n        :param elements: List of elements to identify (if only certain\n            functional groups are of interest).\n        :return: set of ints representing node indices\n        \"\"\"\n\n        heteroatoms = set()\n\n        for node in self.molgraph.graph.nodes():\n            if elements is not None:\n                if str(self.species[node]) in elements:\n                    heteroatoms.add(node)\n            else:\n                if str(self.species[node]) not in [\"C\", \"H\"]:\n                    heteroatoms.add(node)\n\n        return heteroatoms"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a set of ints representing the nodes that are special carbon atoms.", "response": "def get_special_carbon(self, elements=None):\n        \"\"\"\n        Identify Carbon atoms in the MoleculeGraph that fit the characteristics\n        defined Ertl (2017), returning a list of their node indices.\n\n        The conditions for marking carbon atoms are (quoted from Ertl):\n            \"- atoms connected by non-aromatic double or triple bond to any\n            heteroatom\n            - atoms in nonaromatic carbon\u2013carbon double or triple bonds\n            - acetal carbons, i.e. sp3 carbons connected to two or more oxygens,\n            nitrogens or sulfurs; these O, N or S atoms must have only single bonds\n            - all atoms in oxirane, aziridine and thiirane rings\"\n\n        :param elements: List of elements that will qualify a carbon as special\n            (if only certain functional groups are of interest).\n            Default None.\n        :return: set of ints representing node indices\n        \"\"\"\n\n        specials = set()\n\n        # For this function, only carbons are considered\n        carbons = [n for n in self.molgraph.graph.nodes if\n                 str(self.species[n]) == \"C\"]\n\n        # Condition one: double/triple bonds to heteroatoms\n        for node in carbons:\n            neighbors = self.molgraph.graph[node]\n\n            for neighbor, attributes in neighbors.items():\n                if elements is not None:\n                    if str(self.species[neighbor]) in elements and \\\n                            int(attributes[0][\"weight\"]) in [2, 3]:\n                        specials.add(node)\n                else:\n                    if str(self.species[neighbor]) not in [\"C\", \"H\"] and \\\n                            int(attributes[0][\"weight\"]) in [2, 3]:\n                        specials.add(node)\n\n        # Condition two: carbon-carbon double & triple bonds\n        for node in carbons:\n            neighbors = self.molgraph.graph[node]\n\n            for neighbor, attributes in neighbors.items():\n                if str(self.species[neighbor]) == \"C\"\\\n                        and int(attributes[0][\"weight\"]) in [2, 3]:\n                    specials.add(node)\n                    specials.add(neighbor)\n\n        # Condition three: Acetal carbons\n        for node in carbons:\n            neighbors = self.molgraph.graph[node]\n\n            neighbor_spec = [str(self.species[n]) for n in neighbors.keys()]\n\n            ons = len([n for n in neighbor_spec if n in [\"O\", \"N\", \"S\"]])\n\n            if len(neighbors.keys()) == 4 and ons >= 2:\n                specials.add(node)\n\n        # Condition four: oxirane/aziridine/thiirane rings\n        rings = self.molgraph.find_rings()\n        rings_indices = [set(sum(ring, ())) for ring in rings]\n\n        for ring in rings_indices:\n            ring_spec = sorted([str(self.species[node]) for node in ring])\n            # All rings of interest are three-member rings\n            if len(ring) == 3 and ring_spec in [[\"C\", \"C\", \"O\"],\n                                                [\"C\", \"C\", \"N\"],\n                                                [\"C\", \"C\", \"S\"]]:\n                for node in ring:\n                    if node in carbons:\n                        specials.add(node)\n\n        return specials"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngiving a set of marked atoms return a list of disjoint groups of those marked atoms.", "response": "def link_marked_atoms(self, atoms):\n        \"\"\"\n        Take a list of marked \"interesting\" atoms (heteroatoms, special carbons)\n        and attempt to connect them, returning a list of disjoint groups of\n        special atoms (and their connected hydrogens).\n\n        :param atoms: set of marked \"interesting\" atoms, presumably identified\n            using other functions in this class.\n        :return: list of sets of ints, representing groups of connected atoms\n        \"\"\"\n\n        # We will add hydrogens to functional groups\n        hydrogens = {n for n in self.molgraph.graph.nodes if\n                     str(self.species[n]) == \"H\"}\n\n        # Graph representation of only marked atoms\n        subgraph = self.molgraph.graph.subgraph(list(atoms)).to_undirected()\n\n        func_grps_no_h = [x for x in nx.connected_components(subgraph)]\n\n        func_grps = []\n        for func_grp in func_grps_no_h:\n            grp_hs = set()\n            for node in func_grp:\n                neighbors = self.molgraph.graph[node]\n                for neighbor in neighbors.keys():\n                    # Add all associated hydrogens into the functional group\n                    if neighbor in hydrogens:\n                        grp_hs.add(neighbor)\n            func_grp = func_grp.union(grp_hs)\n\n            func_grps.append(func_grp)\n\n        return func_grps"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_basic_functional_groups(self, func_groups=None):\n\n        strat = OpenBabelNN()\n\n        hydrogens = {n for n in self.molgraph.graph.nodes if\n                     str(self.species[n]) == \"H\"}\n\n        carbons = [n for n in self.molgraph.graph.nodes if\n                   str(self.species[n]) == \"C\"]\n\n        if func_groups is None:\n            func_groups = [\"methyl\", \"phenyl\"]\n\n        results = []\n\n        if \"methyl\" in func_groups:\n            for node in carbons:\n                neighbors = strat.get_nn_info(self.molecule, node)\n                hs = {n[\"site_index\"] for n in neighbors if n[\"site_index\"] in hydrogens}\n                # Methyl group is CH3, but this will also catch methane\n                if len(hs) >= 3:\n                    hs.add(node)\n                    results.append(hs)\n\n        if \"phenyl\" in func_groups:\n            rings_indices = [set(sum(ring, ())) for ring in\n                             self.molgraph.find_rings()]\n\n            possible_phenyl = [r for r in rings_indices if len(r) == 6]\n\n            for ring in possible_phenyl:\n                # Phenyl group should have only one (0 for benzene) member whose\n                # neighbors are not two carbons and one hydrogen\n                num_deviants = 0\n                for node in ring:\n                    neighbors = strat.get_nn_info(self.molecule, node)\n                    neighbor_spec = sorted([str(self.species[n[\"site_index\"]])\n                                            for n in neighbors])\n                    if neighbor_spec != [\"C\", \"C\", \"H\"]:\n                        num_deviants += 1\n\n                if num_deviants <= 1:\n                    for node in ring:\n                        ring_group = copy.deepcopy(ring)\n                        neighbors = self.molgraph.graph[node]\n\n                        # Add hydrogens to the functional group\n                        for neighbor in neighbors.keys():\n                            if neighbor in hydrogens:\n                                ring_group.add(neighbor)\n\n                    results.append(ring_group)\n\n        return results", "response": "Return a list of sets of ints representing the basic functional groups of the functional groups that can be identified by the Ertl method\n        of get_special_carbon and get_heteroatoms."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting all functional groups of a specific set of elements.", "response": "def get_all_functional_groups(self, elements=None, func_groups=None,\n                                  catch_basic=True):\n        \"\"\"\n        Identify all functional groups (or all within a certain subset) in the\n        molecule, combining the methods described above.\n\n        :param elements: List of elements that will qualify a carbon as special\n            (if only certain functional groups are of interest).\n            Default None.\n        :param func_groups: List of strs representing the functional groups of\n            interest. Default to None, meaning that all of the functional groups\n            defined in this function will be sought.\n        :param catch_basic: bool. If True, use get_basic_functional_groups and\n            other methods\n        :return: list of sets of ints, representing groups of connected atoms\n        \"\"\"\n\n        heteroatoms = self.get_heteroatoms(elements=elements)\n        special_cs = self.get_special_carbon(elements=elements)\n        groups = self.link_marked_atoms(heteroatoms.union(special_cs))\n\n        if catch_basic:\n            groups += self.get_basic_functional_groups(func_groups=func_groups)\n\n        return groups"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef categorize_functional_groups(self, groups):\n\n        categories = {}\n\n        em = iso.numerical_edge_match(\"weight\", 1)\n        nm = iso.categorical_node_match(\"specie\", \"C\")\n\n        for group in groups:\n            atoms = [self.molecule[a] for a in group]\n            species = [a.specie for a in atoms]\n            coords = [a.coords for a in atoms]\n\n            adaptor = BabelMolAdaptor(Molecule(species, coords))\n            # Use Canonical SMILES to ensure uniqueness\n            smiles = adaptor.pybel_mol.write(\"can\").strip()\n\n            if smiles in categories:\n                this_subgraph = self.molgraph.graph.subgraph(list(group)).to_undirected()\n                for other in categories[smiles][\"groups\"]:\n                    other_subgraph = self.molgraph.graph.subgraph(list(other)).to_undirected()\n\n                    if not nx.is_isomorphic(this_subgraph, other_subgraph,\n                                            edge_match=em, node_match=nm):\n                        break\n\n                    if group not in categories[smiles][\"groups\"]:\n                        categories[smiles][\"groups\"].append(group)\n                        categories[smiles][\"count\"] += 1\n\n            else:\n                categories[smiles] = {\"groups\": [group],\n                                      \"count\": 1}\n\n        return categories", "response": "Determines classes of functional groups present in a set of functional groups."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef raise_error_if_unphysical(f):\n    def wrapper(self, *args, **kwargs):\n        if self.k_vrh < 0 or self.g_vrh < 0:\n            raise ValueError(\"Bulk or shear modulus is negative, property \"\n                             \"cannot be determined\")\n        return f(self, *args, **kwargs)\n    return wrapper", "response": "A decorator that raises an error if the tensor is unphysical."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef diff_fit(strains, stresses, eq_stress=None, order=2, tol=1e-10):\n    strain_state_dict = get_strain_state_dict(\n        strains, stresses, eq_stress=eq_stress, tol=tol,\n        add_eq=True, sort=True)\n\n    # Collect derivative data\n    c_list = []\n    dei_dsi = np.zeros((order - 1, 6, len(strain_state_dict)))\n    for n, (strain_state, data) in enumerate(strain_state_dict.items()):\n        hvec = data[\"strains\"][:, strain_state.index(1)]\n        for i in range(1, order):\n            coef = get_diff_coeff(hvec, i)\n            dei_dsi[i - 1, :, n] = np.dot(coef, data[\"stresses\"])\n\n    m, absent = generate_pseudo(list(strain_state_dict.keys()), order)\n    for i in range(1, order):\n        cvec, carr = get_symbol_list(i+1)\n        svec = np.ravel(dei_dsi[i-1].T)\n        cmap = dict(zip(cvec, np.dot(m[i-1], svec)))\n        c_list.append(v_subs(carr, cmap))\n    return [Tensor.from_voigt(c) for c in c_list]", "response": "This function calculates the nth order elastic constant fitting function based on the given strains and stress."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nfinding stress corresponding to zero strain state in the order of strains and stresses.", "response": "def find_eq_stress(strains, stresses, tol=1e-10):\n    \"\"\"\n    Finds stress corresponding to zero strain state in stress-strain list\n\n    Args:\n        strains (Nx3x3 array-like): array corresponding to strains\n        stresses (Nx3x3 array-like): array corresponding to stresses\n        tol (float): tolerance to find zero strain state\n    \"\"\"\n    stress_array = np.array(stresses)\n    strain_array = np.array(strains)\n    eq_stress = stress_array[np.all(abs(strain_array)<tol, axis=(1,2))]\n\n    if eq_stress.size != 0:\n        all_same = (abs(eq_stress - eq_stress[0]) < 1e-8).all()\n        if len(eq_stress) > 1 and not all_same:\n            raise ValueError(\"Multiple stresses found for equilibrium strain\"\n                             \" state, please specify equilibrium stress or  \"\n                             \" remove extraneous stresses.\")\n        eq_stress = eq_stress[0]\n    else:\n        warnings.warn(\"No eq state found, returning zero voigt stress\")\n        eq_stress = Stress(np.zeros((3, 3)))\n    return eq_stress"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngenerating the pseudoinverse for a given set of strains.", "response": "def generate_pseudo(strain_states, order=3):\n    \"\"\"\n    Generates the pseudoinverse for a given set of strains.\n\n    Args:\n        strain_states (6xN array like): a list of voigt-notation\n            \"strain-states\", i. e. perturbed indices of the strain\n            as a function of the smallest strain e. g. (0, 1, 0, 0, 1, 0)\n        order (int): order of pseudoinverse to calculate\n\n    Returns:\n        mis: pseudo inverses for each order tensor, these can\n            be multiplied by the central difference derivative\n            of the stress with respect to the strain state\n        absent_syms: symbols of the tensor absent from the PI\n            expression\n    \"\"\"\n    s = sp.Symbol('s')\n    nstates = len(strain_states)\n    ni = np.array(strain_states)*s\n    mis, absent_syms = [], []\n    for degree in range(2, order + 1):\n        cvec, carr = get_symbol_list(degree)\n        sarr = np.zeros((nstates, 6), dtype=object)\n        for n, strain_v in enumerate(ni):\n            # Get expressions\n            exps = carr.copy()\n            for i in range(degree - 1):\n                exps = np.dot(exps, strain_v)\n            exps /= np.math.factorial(degree - 1)\n            sarr[n] = [sp.diff(exp, s, degree - 1) for exp in exps]\n        svec = sarr.ravel()\n        present_syms = set.union(*[exp.atoms(sp.Symbol) for exp in svec])\n        absent_syms += [set(cvec) - present_syms]\n        m = np.zeros((6*nstates, len(cvec)))\n        for n, c in enumerate(cvec):\n            m[:, n] = v_diff(svec, c)\n        mis.append(np.linalg.pinv(m))\n    return mis, absent_syms"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_symbol_list(rank, dim=6):\n    indices = list(\n        itertools.combinations_with_replacement(range(dim), r=rank))\n    c_vec = np.zeros(len(indices), dtype=object)\n    c_arr = np.zeros([dim]*rank, dtype=object)\n    for n, idx in enumerate(indices):\n        c_vec[n] = sp.Symbol('c_'+''.join([str(i) for i in idx]))\n        for perm in itertools.permutations(idx):\n            c_arr[perm] = c_vec[n]\n    return c_vec, c_arr", "response": "Returns a symbolic representation of the voigt - notation\n    tensor that places identical symbols for entries related to the entry relatedto the entry with index transposition i. e. C_1121 = C_1211 etc."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef calculate_stress(self, strain):\n        strain = np.array(strain)\n        if strain.shape == (6,):\n            strain = Strain.from_voigt(strain)\n        assert strain.shape == (3, 3), \"Strain must be 3x3 or voigt-notation\"\n        stress_matrix = self.einsum_sequence([strain]*(self.order - 1)) \\\n                / factorial(self.order - 1)\n        return Stress(stress_matrix)", "response": "Calculates a given elastic tensor s contribution to the\n           "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef energy_density(self, strain, convert_GPa_to_eV=True):\n        e_density = np.sum(self.calculate_stress(strain)*strain) / self.order\n        if convert_GPa_to_eV:\n            e_density *= self.GPa_to_eV_A3  # Conversion factor for GPa to eV/A^3\n        return e_density", "response": "Calculates the elastic energy density due to a strain"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef compliance_tensor(self):\n        s_voigt = np.linalg.inv(self.voigt)\n        return ComplianceTensor.from_voigt(s_voigt)", "response": "returns the Voigt - notation compliance tensor"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the G_v shear modulus", "response": "def g_voigt(self):\n        \"\"\"\n        returns the G_v shear modulus\n        \"\"\"\n        return (2. * self.voigt[:3, :3].trace() -\n                np.triu(self.voigt[:3, :3]).sum() +\n                3 * self.voigt[3:, 3:].trace()) / 15."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the G_r shear modulus", "response": "def g_reuss(self):\n        \"\"\"\n        returns the G_r shear modulus\n        \"\"\"\n        return 15. / (8. * self.compliance_tensor.voigt[:3, :3].trace() -\n                      4. * np.triu(self.compliance_tensor.voigt[:3, :3]).sum() +\n                      3. * self.compliance_tensor.voigt[3:, 3:].trace())"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncalculates the Young s modulus using the Voigt - Reuss - Hill averages of bulk and shear moduli", "response": "def y_mod(self):\n        \"\"\"\n        Calculates Young's modulus (in SI units) using the\n        Voigt-Reuss-Hill averages of bulk and shear moduli\n        \"\"\"\n        return 9.e9 * self.k_vrh * self.g_vrh / (3. * self.k_vrh + self.g_vrh)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncalculates the poisson ratio for a specific directional entry.", "response": "def directional_poisson_ratio(self, n, m, tol=1e-8):\n        \"\"\"\n        Calculates the poisson ratio for a specific direction\n        relative to a second, orthogonal direction\n\n        Args:\n            n (3-d vector): principal direction\n            m (3-d vector): secondary direction orthogonal to n\n            tol (float): tolerance for testing of orthogonality\n        \"\"\"\n        n, m = get_uvec(n), get_uvec(m)\n        if not np.abs(np.dot(n, m)) < tol:\n            raise ValueError(\"n and m must be orthogonal\")\n        v = self.compliance_tensor.einsum_sequence([n]*2 + [m]*2)\n        v *= -1 / self.compliance_tensor.einsum_sequence([n]*4)\n        return v"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef trans_v(self, structure):\n        nsites = structure.num_sites\n        volume = structure.volume\n        natoms = structure.composition.num_atoms\n        weight = float(structure.composition.weight)\n        mass_density = 1.6605e3 * nsites * weight / (natoms * volume)\n        if self.g_vrh < 0:\n            raise ValueError(\"k_vrh or g_vrh is negative, \"\n                             \"sound velocity is undefined\")\n        return (1e9 * self.g_vrh / mass_density) ** 0.5", "response": "Calculates the transverse sound velocity using the the\n            Voigt - Reuss - Hill average bulk modulus."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef snyder_ac(self, structure):\n        nsites = structure.num_sites\n        volume = structure.volume\n        natoms = structure.composition.num_atoms\n        num_density = 1e30 * nsites / volume\n        tot_mass = sum([e.atomic_mass for e in structure.species])\n        avg_mass = 1.6605e-27 * tot_mass / natoms\n        return 0.38483*avg_mass * \\\n            ((self.long_v(structure) + 2.*self.trans_v(structure))/3.) ** 3.\\\n            / (300.*num_density ** (-2./3.) * nsites ** (1./3.))", "response": "Calculates Snyder s acoustic sound velocity in SI units."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncalculating Snyder s optical sound velocity", "response": "def snyder_opt(self, structure):\n        \"\"\"\n        Calculates Snyder's optical sound velocity (in SI units)\n\n        Args:\n            structure: pymatgen structure object\n\n        Returns: Snyder's optical sound velocity (in SI units)\n\n        \"\"\"\n        nsites = structure.num_sites\n        volume = structure.volume\n        num_density = 1e30 * nsites / volume\n        return 1.66914e-23 * \\\n            (self.long_v(structure) + 2.*self.trans_v(structure))/3. \\\n            / num_density ** (-2./3.) * (1 - nsites ** (-1./3.))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef clarke_thermalcond(self, structure):\n        nsites = structure.num_sites\n        volume = structure.volume\n        tot_mass = sum([e.atomic_mass for e in structure.species])\n        natoms = structure.composition.num_atoms\n        weight = float(structure.composition.weight)\n        avg_mass = 1.6605e-27 * tot_mass / natoms\n        mass_density = 1.6605e3 * nsites * weight / (natoms * volume)\n        return 0.87 * 1.3806e-23 * avg_mass**(-2./3.) \\\n            * mass_density**(1./6.) * self.y_mod**0.5", "response": "Calculates the Clarke s thermal conductivity for a given structure object."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nestimates the debye temperature from longitudinal and transverse sound velocities", "response": "def debye_temperature(self, structure):\n        \"\"\"\n        Estimates the debye temperature from longitudinal and\n        transverse sound velocities\n\n        Args:\n            structure: pymatgen structure object\n\n        Returns: debye temperature (in SI units)\n\n        \"\"\"\n        v0 = (structure.volume * 1e-30 / structure.num_sites)\n        vl, vt = self.long_v(structure), self.trans_v(structure)\n        vm = 3**(1./3.) * (1 / vl**3 + 2 / vt**3)**(-1./3.)\n        td = 1.05457e-34 / 1.38065e-23 * vm * (6 * np.pi**2 / v0) ** (1./3.)\n        return td"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the universal anisotropy value", "response": "def universal_anisotropy(self):\n        \"\"\"\n        returns the universal anisotropy value\n        \"\"\"\n        return 5. * self.g_voigt / self.g_reuss + \\\n            self.k_voigt / self.k_reuss - 6."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the homogeneous poisson ratio of the current species.", "response": "def homogeneous_poisson(self):\n        \"\"\"\n        returns the homogeneous poisson ratio\n        \"\"\"\n        return (1. - 2. / 3. * self.g_vrh / self.k_vrh) / \\\n               (2. + 2. / 3. * self.g_vrh / self.k_vrh)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_structure_property_dict(self, structure, include_base_props=True,\n                                    ignore_errors=False):\n        \"\"\"\n        returns a dictionary of properties derived from the elastic tensor\n        and an associated structure\n\n        Args:\n            structure (Structure): structure object for which to calculate\n                associated properties\n            include_base_props (bool): whether to include base properties,\n                like k_vrh, etc.\n            ignore_errors (bool): if set to true, will set problem properties\n                that depend on a physical tensor to None, defaults to False\n        \"\"\"\n        s_props = [\"trans_v\", \"long_v\", \"snyder_ac\", \"snyder_opt\",\n                   \"snyder_total\", \"clarke_thermalcond\", \"cahill_thermalcond\",\n                   \"debye_temperature\"]\n        if ignore_errors and (self.k_vrh < 0 or self.g_vrh < 0):\n            sp_dict = {prop: None for prop in s_props}\n        else:\n            sp_dict = {prop: getattr(self, prop)(structure) for prop in s_props}\n        sp_dict[\"structure\"] = structure\n        if include_base_props:\n            sp_dict.update(self.property_dict)\n        return sp_dict", "response": "Returns a dictionary of properties derived from the elastic tensor\n            and an associated structure\n           "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nclass method to fit an elastic tensor from stress/strain data. Method uses Moore-Penrose pseudoinverse to invert the s = C*e equation with elastic tensor, stress, and strain in voigt notation Args: stresses (Nx3x3 array-like): list or array of stresses strains (Nx3x3 array-like): list or array of strains", "response": "def from_pseudoinverse(cls, strains, stresses):\n        \"\"\"\n        Class method to fit an elastic tensor from stress/strain\n        data.  Method uses Moore-Penrose pseudoinverse to invert\n        the s = C*e equation with elastic tensor, stress, and\n        strain in voigt notation\n\n        Args:\n            stresses (Nx3x3 array-like): list or array of stresses\n            strains (Nx3x3 array-like): list or array of strains\n        \"\"\"\n        # convert the stress/strain to Nx6 arrays of voigt-notation\n        warnings.warn(\"Pseudoinverse fitting of Strain/Stress lists may yield \"\n                      \"questionable results from vasp data, use with caution.\")\n        stresses = np.array([Stress(stress).voigt for stress in stresses])\n        with warnings.catch_warnings(record=True):\n            strains = np.array([Strain(strain).voigt for strain in strains])\n\n        voigt_fit = np.transpose(np.dot(np.linalg.pinv(strains), stresses))\n        return cls.from_voigt(voigt_fit)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef from_independent_strains(cls, strains, stresses, eq_stress=None,\n                                 vasp=False, tol=1e-10):\n        \"\"\"\n        Constructs the elastic tensor least-squares fit of independent strains\n        Args:\n            strains (list of Strains): list of strain objects to fit\n            stresses (list of Stresses): list of stress objects to use in fit\n                corresponding to the list of strains\n            eq_stress (Stress): equilibrium stress to use in fitting\n            vasp (boolean): flag for whether the stress tensor should be\n                converted based on vasp units/convention for stress\n            tol (float): tolerance for removing near-zero elements of the\n                resulting tensor\n        \"\"\"\n        strain_states = [tuple(ss) for ss in np.eye(6)]\n        ss_dict = get_strain_state_dict(strains, stresses, eq_stress=eq_stress)\n        if not set(strain_states) <= set(ss_dict.keys()):\n            raise ValueError(\"Missing independent strain states: \"\n                             \"{}\".format(set(strain_states) - set(ss_dict)))\n        if len(set(ss_dict.keys()) - set(strain_states)) > 0:\n            warnings.warn(\"Extra strain states in strain-stress pairs \"\n                          \"are neglected in independent strain fitting\")\n        c_ij = np.zeros((6, 6))\n        for i in range(6):\n            istrains = ss_dict[strain_states[i]][\"strains\"]\n            istresses = ss_dict[strain_states[i]][\"stresses\"]\n            for j in range(6):\n                c_ij[i, j] = np.polyfit(istrains[:, i], istresses[:, j], 1)[0]\n        if vasp:\n            c_ij *= -0.1  # Convert units/sign convention of vasp stress tensor\n        c = cls.from_voigt(c_ij)\n        c = c.zeroed(tol)\n        return c", "response": "Constructs the elastic tensor least - squares fit of independent strains and stress pairs."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngenerates an elastic tensor expansion from a diffusion fit.", "response": "def from_diff_fit(cls, strains, stresses, eq_stress=None,\n                      tol=1e-10, order=3):\n        \"\"\"\n        Generates an elastic tensor expansion via the fitting function\n        defined below in diff_fit\n        \"\"\"\n        c_list = diff_fit(strains, stresses, eq_stress, order, tol)\n        return cls(c_list)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncalculating the elastic energy density due to a strain", "response": "def energy_density(self, strain, convert_GPa_to_eV=True):\n        \"\"\"\n        Calculates the elastic energy density due to a strain\n        \"\"\"\n        return sum([c.energy_density(strain, convert_GPa_to_eV)\n                    for c in self])"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_ggt(self, n, u):\n        gk = self[0].einsum_sequence([n, u, n, u])\n        result = -(2*gk*np.outer(u, u) + self[0].einsum_sequence([n, n])\n                   + self[1].einsum_sequence([n, u, n, u])) / (2*gk)\n        return result", "response": "Gets the Generalized Gruneisen tensor for a given ArcGIS 3x1 array - like object."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the thermodynamic Gruneisen tensor by using an integration of the GGT and the directional heat capacity.", "response": "def get_tgt(self, temperature=None, structure=None, quad=None):\n        \"\"\"\n        Gets the thermodynamic Gruneisen tensor (TGT) by via an\n        integration of the GGT weighted by the directional heat\n        capacity.\n\n        See refs:\n            R. N. Thurston and K. Brugger, Phys. Rev. 113, A1604 (1964).\n            K. Brugger Phys. Rev. 137, A1826 (1965).\n\n        Args:\n            temperature (float): Temperature in kelvin, if not specified\n                will return non-cv-normalized value\n            structure (float): Structure to be used in directional heat\n                capacity determination, only necessary if temperature\n                is specified\n            quad (dict): quadrature for integration, should be\n                dictionary with \"points\" and \"weights\" keys defaults\n                to quadpy.sphere.Lebedev(19) as read from file\n        \"\"\"\n        if temperature and not structure:\n            raise ValueError(\"If using temperature input, you must also \"\n                             \"include structure\")\n\n        quad = quad if quad else DEFAULT_QUAD\n        points = quad['points']\n        weights = quad['weights']\n        num, denom, c = np.zeros((3, 3)), 0, 1\n        for p, w in zip(points, weights):\n            gk = ElasticTensor(self[0]).green_kristoffel(p)\n            rho_wsquareds, us = np.linalg.eigh(gk)\n            us = [u / np.linalg.norm(u) for u in np.transpose(us)]\n            for u in us:\n                # TODO: this should be benchmarked\n                if temperature:\n                    c = self.get_heat_capacity(temperature, structure, p, u)\n                num += c*self.get_ggt(p, u) * w\n                denom += c * w\n        return SquareTensor(num / denom)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the single average gruneisen parameter from the TGT.", "response": "def get_gruneisen_parameter(self, temperature=None, structure=None,\n                                quad=None):\n        \"\"\"\n        Gets the single average gruneisen parameter from the TGT.\n\n        Args:\n            temperature (float): Temperature in kelvin, if not specified\n                will return non-cv-normalized value\n            structure (float): Structure to be used in directional heat\n                capacity determination, only necessary if temperature\n                is specified\n            quad (dict): quadrature for integration, should be\n                dictionary with \"points\" and \"weights\" keys defaults\n                to quadpy.sphere.Lebedev(19) as read from file\n        \"\"\"\n        return np.trace(self.get_tgt(temperature, structure, quad)) / 3."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_heat_capacity(self, temperature, structure, n, u, cutoff=1e2):\n        k = 1.38065e-23\n        kt = k*temperature\n        hbar_w = 1.05457e-34*self.omega(structure, n, u)\n        if hbar_w > kt * cutoff:\n            return 0.0\n        c = k * (hbar_w / kt) ** 2\n        c *= np.exp(hbar_w / kt) / (np.exp(hbar_w / kt) - 1)**2\n        return c * 6.022e23", "response": "Gets the directional heat capacity for a higher order tensor in the degree of the modulation."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncalculating the directional frequency contribution to the heat Privileged class", "response": "def omega(self, structure, n, u):\n        \"\"\"\n        Finds directional frequency contribution to the heat\n        capacity from direction and polarization\n\n        Args:\n            structure (Structure): Structure to be used in directional heat\n                capacity determination\n            n (3x1 array-like): direction for Cv determination\n            u (3x1 array-like): polarization direction, note that\n                no attempt for verification of eigenvectors is made\n        \"\"\"\n        l0 = np.dot(np.sum(structure.lattice.matrix, axis=0), n)\n        l0 *= 1e-10 # in A\n        weight = float(structure.composition.weight) * 1.66054e-27 # in kg\n        vol = structure.volume * 1e-30 # in m^3\n        vel = (1e9 * self[0].einsum_sequence([n, u, n, u])\n               / (weight / vol)) ** 0.5\n        return vel / l0"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn thermal expansion coefficient from third - order constants.", "response": "def thermal_expansion_coeff(self, structure, temperature, mode=\"debye\"):\n        \"\"\"\n        Gets thermal expansion coefficient from third-order constants.\n\n        Args:\n            temperature (float): Temperature in kelvin, if not specified\n                will return non-cv-normalized value\n            structure (Structure): Structure to be used in directional heat\n                capacity determination, only necessary if temperature\n                is specified\n            mode (string): mode for finding average heat-capacity,\n                current supported modes are 'debye' and 'dulong-petit'\n        \"\"\"\n        soec = ElasticTensor(self[0])\n        v0 = (structure.volume * 1e-30 / structure.num_sites)\n        if mode == \"debye\":\n            td = soec.debye_temperature(structure)\n            t_ratio = temperature / td\n            integrand = lambda x: (x**4 * np.exp(x)) / (np.exp(x) - 1)**2\n            cv = 9 * 8.314 * t_ratio**3 * quad(integrand, 0, t_ratio**-1)[0]\n        elif mode == \"dulong-petit\":\n            cv = 3 * 8.314\n        else:\n            raise ValueError(\"Mode must be debye or dulong-petit\")\n        tgt = self.get_tgt(temperature, structure)\n        alpha = np.einsum('ijkl,ij', soec.compliance_tensor, tgt)\n        alpha *= cv / (1e9 * v0 * 6.022e23)\n        return SquareTensor(alpha)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets a compliance tensor expansion from the elastic entry.", "response": "def get_compliance_expansion(self):\n        \"\"\"\n        Gets a compliance tensor expansion from the elastic\n        tensor expansion.\n        \"\"\"\n        # TODO: this might have a general form\n        if not self.order <= 4:\n            raise ValueError(\"Compliance tensor expansion only \"\n                             \"supported for fourth-order and lower\")\n        ce_exp = [ElasticTensor(self[0]).compliance_tensor]\n        einstring = \"ijpq,pqrsuv,rskl,uvmn->ijklmn\"\n        ce_exp.append(np.einsum(einstring, -ce_exp[-1], self[1],\n                                ce_exp[-1], ce_exp[-1]))\n        if self.order == 4:\n            # Four terms in the Fourth-Order compliance tensor\n            einstring_1 = \"pqab,cdij,efkl,ghmn,abcdefgh\"\n            tensors_1 = [ce_exp[0]]*4 + [self[-1]]\n            temp = -np.einsum(einstring_1, *tensors_1)\n            einstring_2 = \"pqab,abcdef,cdijmn,efkl\"\n            einstring_3 = \"pqab,abcdef,efklmn,cdij\"\n            einstring_4 = \"pqab,abcdef,cdijkl,efmn\"\n            for es in [einstring_2, einstring_3, einstring_4]:\n                temp -= np.einsum(es, ce_exp[0], self[-2], ce_exp[1], ce_exp[0])\n            ce_exp.append(temp)\n        return TensorCollection(ce_exp)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the strain from a stress state according to the compliance expansion corresponding to the tensor expansion.", "response": "def get_strain_from_stress(self, stress):\n        \"\"\"\n        Gets the strain from a stress state according\n        to the compliance expansion corresponding to the\n        tensor expansion.\n        \"\"\"\n        compl_exp = self.get_compliance_expansion()\n        strain = 0\n        for n, compl in enumerate(compl_exp):\n            strain += compl.einsum_sequence([stress]*(n+1)) / factorial(n+1)\n        return strain"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_effective_ecs(self, strain, order=2):\n        ec_sum = 0\n        for n, ecs in enumerate(self[order-2:]):\n            ec_sum += ecs.einsum_sequence([strain] * n) / factorial(n)\n        return ec_sum", "response": "Returns the effective elastic constants for the elastic tensor expansion."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the Wallace Tensor for determining yield strength for the given time - step tau", "response": "def get_wallace_tensor(self, tau):\n        \"\"\"\n        Gets the Wallace Tensor for determining yield strength\n        criteria.\n\n        Args:\n            tau (3x3 array-like): stress at which to evaluate\n                the wallace tensor\n        \"\"\"\n        b = 0.5 * (np.einsum(\"ml,kn->klmn\", tau, np.eye(3)) +\n                   np.einsum(\"km,ln->klmn\", tau, np.eye(3)) +\n                   np.einsum(\"nl,km->klmn\", tau, np.eye(3)) +\n                   np.einsum(\"kn,lm->klmn\", tau, np.eye(3)) +\n                   -2*np.einsum(\"kl,mn->klmn\", tau, np.eye(3)))\n        strain = self.get_strain_from_stress(tau)\n        b += self.get_effective_ecs(strain)\n        return b"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the symmetrized wallace tensor for determining the yield strength criteria.", "response": "def get_symmetric_wallace_tensor(self, tau):\n        \"\"\"\n        Gets the symmetrized wallace tensor for determining\n        yield strength criteria.\n\n        Args:\n            tau (3x3 array-like): stress at which to evaluate\n                the wallace tensor.\n        \"\"\"\n        wallace = self.get_wallace_tensor(tau)\n        return Tensor(0.5 * (wallace + np.transpose(wallace, [2, 3, 0, 1])))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the stability criteria from the symmetric Wallace tensor from an input vector and stress value.", "response": "def get_stability_criteria(self, s, n):\n        \"\"\"\n        Gets the stability criteria from the symmetric\n        Wallace tensor from an input vector and stress\n        value.\n\n        Args:\n            s (float): Stress value at which to evaluate\n                the stability criteria\n            n (3x1 array-like): direction of the applied\n                stress\n        \"\"\"\n        n = get_uvec(n)\n        stress = s * np.outer(n, n)\n        sym_wallace = self.get_symmetric_wallace_tensor(stress)\n        return np.linalg.det(sym_wallace.voigt)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_yield_stress(self, n):\n        # TODO: root finding could be more robust\n        comp = root(self.get_stability_criteria, -1, args=n)\n        tens = root(self.get_stability_criteria, 1, args=n)\n        return (comp.x, tens.x)", "response": "Gets the yield stress for a given direction"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef symmetry_measure(points_distorted, points_perfect):\n    # When there is only one point, the symmetry measure is 0.0 by definition\n    if len(points_distorted) == 1:\n        return {'symmetry_measure': 0.0, 'scaling_factor': None, 'rotation_matrix': None}\n    # Find the rotation matrix that aligns the distorted points to the perfect points in a least-square sense.\n    rot = find_rotation(points_distorted=points_distorted,\n                           points_perfect=points_perfect)\n    # Find the scaling factor between the distorted points and the perfect points in a least-square sense.\n    scaling_factor, rotated_coords, points_perfect = find_scaling_factor(points_distorted=points_distorted,\n                                                                         points_perfect=points_perfect,\n                                                                         rot=rot)\n    # Compute the continuous symmetry measure [see Eq. 1 in Pinsky et al., Inorganic Chemistry 37, 5575 (1998)]\n    rotated_coords = scaling_factor * rotated_coords\n    diff = points_perfect - rotated_coords\n    num = np.tensordot(diff, diff)\n    denom = np.tensordot(points_perfect, points_perfect)\n    return {'symmetry_measure': num / denom * 100.0, 'scaling_factor': scaling_factor, 'rotation_matrix': rot}", "response": "Computes continuous symmetry measure of a set of points points_distorted and points_perfect."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef find_scaling_factor(points_distorted, points_perfect, rot):\n    rotated_coords = np.matmul(rot, points_distorted.T).T\n    num = np.tensordot(rotated_coords, points_perfect)\n    denom = np.tensordot(rotated_coords, rotated_coords)\n    return num / denom, rotated_coords, points_perfect", "response": "This function finds the scaling factor between two sets of points points_distorted and the set of points points_perfect and the rotation matrix rot."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef setup_structure(self, structure):\n        self.initial_structure = structure.copy()\n        if self.structure_refinement == self.STRUCTURE_REFINEMENT_NONE:\n            self.structure = structure.copy()\n            self.spg_analyzer = None\n            self.symmetrized_structure = None\n        else:\n            self.spg_analyzer = SpacegroupAnalyzer(self.initial_structure,\n                                                   symprec=\n                                                   self.spg_analyzer_options[\n                                                       'symprec'],\n                                                   angle_tolerance=\n                                                   self.spg_analyzer_options[\n                                                       'angle_tolerance'])\n            if self.structure_refinement == self.STRUCTURE_REFINEMENT_REFINED:\n                self.structure = self.spg_analyzer.get_refined_structure()\n                self.symmetrized_structure = None\n            elif self.structure_refinement == self.STRUCTURE_REFINEMENT_SYMMETRIZED:\n                self.structure = self.spg_analyzer.get_refined_structure()\n                self.spg_analyzer_refined = SpacegroupAnalyzer(self.structure,\n                                                               symprec=\n                                                               self.spg_analyzer_options[\n                                                                   'symprec'],\n                                                               angle_tolerance=\n                                                               self.spg_analyzer_options\n                                                               [\n                                                                   'angle_tolerance'])\n                self.symmetrized_structure = self.spg_analyzer_refined.get_symmetrized_structure()", "response": "Sets up the structure for which the coordination geometries have to be identified."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset up the pymatgen structure for which the coordination geometries have to be identified starting from the structure .", "response": "def set_structure(self, lattice, species, coords, coords_are_cartesian):\n        \"\"\"\n        Sets up the pymatgen structure for which the coordination geometries have to be identified starting from the\n        lattice, the species and the coordinates\n        :param lattice: The lattice of the structure\n        :param species: The species on the sites\n        :param coords: The coordinates of the sites\n        :param coords_are_cartesian: If set to True, the coordinates are given in cartesian coordinates\n        \"\"\"\n        self.setup_structure(\n            Structure(lattice, species, coords, coords_are_cartesian))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef compute_structure_environments(self,\n                                       excluded_atoms=None,\n                                       only_atoms=None,\n                                       only_cations=True,\n                                       only_indices=None,\n                                       maximum_distance_factor=PRESETS['DEFAULT']['maximum_distance_factor'],\n                                       minimum_angle_factor=PRESETS['DEFAULT']['minimum_angle_factor'],\n                                       max_cn=None,\n                                       min_cn=None,\n                                       only_symbols=None,\n                                       valences='undefined',\n                                       additional_conditions=None,\n                                       info=None,\n                                       timelimit=None,\n                                       initial_structure_environments=None,\n                                       get_from_hints=False,\n                                       voronoi_normalized_distance_tolerance=PRESETS['DEFAULT']\n                                       ['voronoi_normalized_distance_tolerance'],\n                                       voronoi_normalized_angle_tolerance=PRESETS['DEFAULT']\n                                       ['voronoi_normalized_angle_tolerance'],\n                                       recompute=None,\n                                       optimization=PRESETS['DEFAULT']['optimization']):\n        \"\"\"\n        Computes and returns the StructureEnvironments object containing all the information about the coordination\n        environments in the structure\n        :param excluded_atoms: Atoms for which the coordination geometries does not have to be identified\n        :param only_atoms: If not set to None, atoms for which the coordination geometries have to be identified\n        :param only_cations: If set to True, will only compute environments for cations\n        :param only_indices: If not set to None, will only compute environments the atoms of the given indices\n        :param maximum_distance_factor: If not set to None, neighbors beyond\n                                        maximum_distance_factor*closest_neighbor_distance are not considered\n        :param minimum_angle_factor: If not set to None, neighbors for which the angle is lower than\n                                     minimum_angle_factor*largest_angle_neighbor are not considered\n        :param max_cn: maximum coordination number to be considered\n        :param min_cn: minimum coordination number to be considered\n        :param only_symbols: if not set to None, consider only coordination environments with the given symbols\n        :param valences: valences of the atoms\n        :param additional_conditions: additional conditions to be considered in the bonds (example : only bonds\n                                      between cation and anion\n        :param info: additional info about the calculation\n        :param timelimit: time limit (in secs) after which the calculation of the StructureEnvironments object stops\n        :param initial_structure_environments: initial StructureEnvironments object (most probably incomplete)\n        :param get_from_hints: whether to add neighbors sets from \"hints\" (e.g. capped environment => test the\n                               neighbors without the cap)\n        :param voronoi_normalized_distance_tolerance: tolerance for the normalized distance used to distinguish\n                                                      neighbors sets\n        :param voronoi_normalized_angle_tolerance: tolerance for the normalized angle used to distinguish\n                                                   neighbors sets\n        :param recompute: whether to recompute the sites already computed (when initial_structure_environments\n                          is not None)\n        :param optimization: optimization algorithm\n        :return: The StructureEnvironments object containing all the information about the coordination\n        environments in the structure\n        \"\"\"\n        time_init = time.clock()\n        if info is None:\n            info = {}\n        info.update({'local_geometry_finder':\n                         {'parameters':\n                              {'centering_type': self.centering_type,\n                               'include_central_site_in_centroid': self.include_central_site_in_centroid,\n                               'structure_refinement': self.structure_refinement,\n                               'spg_analyzer_options': self.spg_analyzer_options\n                               }\n                          }\n                     })\n        if only_symbols is not None:\n            self.allcg = AllCoordinationGeometries(\n                permutations_safe_override=self.permutations_safe_override,\n                only_symbols=only_symbols)\n\n        self.valences = valences\n\n        # Get a list of indices of unequivalent sites from the initial structure\n        self.equivalent_sites = [[site] for site in self.structure]\n        self.struct_sites_to_irreducible_site_list_map = list(\n            range(len(self.structure)))\n        self.sites_map = list(range(len(self.structure)))\n        indices = list(range(len(self.structure)))\n\n        # Get list of unequivalent sites with valence >= 0\n        if only_cations and self.valences != 'undefined':\n            sites_indices = [isite for isite in indices if\n                             self.valences[isite] >= 0]\n        else:\n            sites_indices = [isite for isite in indices]\n\n        # Include atoms that are in the list of \"only_atoms\" if it is provided\n        if only_atoms is not None:\n            sites_indices = [isite for isite in sites_indices\n                             if any([at in [sp.symbol for sp in self.structure[\n                    isite].species]\n                                     for at in only_atoms])]\n\n        # Exclude atoms that are in the list of excluded atoms\n        if excluded_atoms:\n            sites_indices = [isite for isite in sites_indices\n                             if not any([at in [sp.symbol for sp in\n                                                self.structure[\n                                                    isite].species]\n                                         for at in excluded_atoms])]\n\n        if only_indices is not None:\n            sites_indices = [isite for isite in indices if\n                             isite in only_indices]\n\n        # Get the VoronoiContainer for the sites defined by their indices (sites_indices)\n        logging.info('Getting DetailedVoronoiContainer')\n        if voronoi_normalized_distance_tolerance is None:\n            normalized_distance_tolerance = DetailedVoronoiContainer.default_normalized_distance_tolerance\n        else:\n            normalized_distance_tolerance = voronoi_normalized_distance_tolerance\n        if voronoi_normalized_angle_tolerance is None:\n            normalized_angle_tolerance = DetailedVoronoiContainer.default_normalized_angle_tolerance\n        else:\n            normalized_angle_tolerance = voronoi_normalized_angle_tolerance\n        self.detailed_voronoi = DetailedVoronoiContainer(self.structure,\n                                                         isites=sites_indices,\n                                                         valences=self.valences,\n                                                         maximum_distance_factor=maximum_distance_factor,\n                                                         minimum_angle_factor=minimum_angle_factor,\n                                                         additional_conditions=additional_conditions,\n                                                         normalized_distance_tolerance=normalized_distance_tolerance,\n                                                         normalized_angle_tolerance=normalized_angle_tolerance)\n        logging.info('DetailedVoronoiContainer has been set up')\n\n        # Initialize the StructureEnvironments object (either from initial_structure_environments or from scratch)\n        if initial_structure_environments is not None:\n            se = initial_structure_environments\n            if se.structure != self.structure:\n                raise ValueError('Structure is not the same in initial_structure_environments')\n            if se.voronoi != self.detailed_voronoi:\n                if self.detailed_voronoi.is_close_to(se.voronoi):\n                    self.detailed_voronoi = se.voronoi\n                else:\n                    raise ValueError('Detailed Voronoi is not the same in initial_structure_environments')\n            se.info = info\n        else:\n            se = StructureEnvironments(voronoi=self.detailed_voronoi, valences=self.valences,\n                                       sites_map=self.sites_map, equivalent_sites=self.equivalent_sites,\n                                       ce_list=[None]*len(self.structure), structure=self.structure,\n                                       info=info)\n\n        # Set up the coordination numbers that have to be computed based on min_cn, max_cn and possibly the settings\n        # for an update (argument \"recompute\") of an existing StructureEnvironments\n        if min_cn is None:\n            min_cn = 1\n        if max_cn is None:\n            max_cn = 13\n        all_cns = range(min_cn, max_cn+1)\n        do_recompute = False\n        if recompute is not None:\n            if 'cns' in recompute:\n                cns_to_recompute = recompute['cns']\n                all_cns = list(set(all_cns).intersection(cns_to_recompute))\n            do_recompute = True\n\n        # Variables used for checking timelimit\n        max_time_one_site = 0.0\n        breakit = False\n\n        if optimization > 0:\n            self.detailed_voronoi.local_planes = [None]*len(self.structure)\n            self.detailed_voronoi.separations = [None]*len(self.structure)\n\n        # Loop on all the sites\n        for isite in range(len(self.structure)):\n            if isite not in sites_indices:\n                logging.info(' ... in site #{:d}/{:d} ({}) : '\n                             'skipped'.format(isite, len(self.structure),\n                                              self.structure[isite].species_string))\n                continue\n            if breakit:\n                logging.info(' ... in site #{:d}/{:d} ({}) : '\n                             'skipped (timelimit)'.format(isite, len(self.structure),\n                                                          self.structure[isite].species_string))\n                continue\n            logging.info(' ... in site #{:d}/{:d} ({})'.format(isite, len(self.structure),\n                                                               self.structure[isite].species_string))\n            t1 = time.clock()\n            if optimization > 0:\n                self.detailed_voronoi.local_planes[isite] = OrderedDict()\n                self.detailed_voronoi.separations[isite] = {}\n            se.init_neighbors_sets(isite=isite, additional_conditions=additional_conditions, valences=valences)\n\n            to_add_from_hints = []\n            nb_sets_info = {}\n\n            for cn, nb_sets in se.neighbors_sets[isite].items():\n                if cn not in all_cns:\n                    continue\n                for inb_set, nb_set in enumerate(nb_sets):\n                    logging.debug('    ... getting environments for nb_set ({:d}, {:d})'.format(cn, inb_set))\n                    tnbset1 = time.clock()\n                    ce = self.update_nb_set_environments(se=se, isite=isite, cn=cn, inb_set=inb_set, nb_set=nb_set,\n                                                         recompute=do_recompute, optimization=optimization)\n                    tnbset2 = time.clock()\n                    if cn not in nb_sets_info:\n                        nb_sets_info[cn] = {}\n                    nb_sets_info[cn][inb_set] = {'time': tnbset2 - tnbset1}\n                    if get_from_hints:\n                        for cg_symbol, cg_dict in ce:\n                            cg = self.allcg[cg_symbol]\n                            # Get possibly missing neighbors sets\n                            if cg.neighbors_sets_hints is None:\n                                continue\n                            logging.debug('       ... getting hints from cg with mp_symbol \"{}\" ...'.format(cg_symbol))\n                            hints_info = {'csm': cg_dict['symmetry_measure'],\n                                          'nb_set': nb_set,\n                                          'permutation': cg_dict['permutation']}\n                            for nb_sets_hints in cg.neighbors_sets_hints:\n                                suggested_nb_set_voronoi_indices = nb_sets_hints.hints(hints_info)\n                                for inew, new_nb_set_voronoi_indices in enumerate(suggested_nb_set_voronoi_indices):\n                                    logging.debug('           hint # {:d}'.format(inew))\n                                    new_nb_set = se.NeighborsSet(structure=se.structure, isite=isite,\n                                                                 detailed_voronoi=se.voronoi,\n                                                                 site_voronoi_indices=new_nb_set_voronoi_indices,\n                                                                 sources={'origin': 'nb_set_hints',\n                                                                          'hints_type': nb_sets_hints.hints_type,\n                                                                          'suggestion_index': inew,\n                                                                          'cn_map_source': [cn, inb_set],\n                                                                          'cg_source_symbol': cg_symbol})\n                                    cn_new_nb_set = len(new_nb_set)\n                                    if max_cn is not None and cn_new_nb_set > max_cn:\n                                        continue\n                                    if min_cn is not None and cn_new_nb_set < min_cn:\n                                        continue\n                                    if new_nb_set in [ta['new_nb_set'] for ta in to_add_from_hints]:\n                                        has_nb_set = True\n                                    elif not cn_new_nb_set in se.neighbors_sets[isite]:\n                                        has_nb_set = False\n                                    else:\n                                        has_nb_set = new_nb_set in se.neighbors_sets[isite][cn_new_nb_set]\n                                    if not has_nb_set:\n                                        to_add_from_hints.append({'isite': isite,\n                                                                  'new_nb_set': new_nb_set,\n                                                                  'cn_new_nb_set': cn_new_nb_set})\n                                        logging.debug('              => to be computed'.format(inew))\n                                    else:\n                                        logging.debug('              => already present'.format(inew))\n            logging.debug('    ... getting environments for nb_sets added from hints')\n            for missing_nb_set_to_add in to_add_from_hints:\n                se.add_neighbors_set(isite=isite, nb_set=missing_nb_set_to_add['new_nb_set'])\n            for missing_nb_set_to_add in to_add_from_hints:\n                isite_new_nb_set = missing_nb_set_to_add['isite']\n                cn_new_nb_set = missing_nb_set_to_add['cn_new_nb_set']\n                new_nb_set = missing_nb_set_to_add['new_nb_set']\n                inew_nb_set = se.neighbors_sets[isite_new_nb_set][cn_new_nb_set].index(new_nb_set)\n                logging.debug('    ... getting environments for nb_set ({:d}, {:d}) - '\n                              'from hints'.format(cn_new_nb_set, inew_nb_set))\n                tnbset1 = time.clock()\n                self.update_nb_set_environments(se=se,\n                                                isite=isite_new_nb_set,\n                                                cn=cn_new_nb_set,\n                                                inb_set=inew_nb_set,\n                                                nb_set=new_nb_set,\n                                                optimization=optimization)\n                tnbset2 = time.clock()\n                if cn not in nb_sets_info:\n                    nb_sets_info[cn] = {}\n                nb_sets_info[cn][inew_nb_set] = {'time': tnbset2 - tnbset1}\n            t2 = time.clock()\n            se.update_site_info(isite=isite, info_dict={'time': t2 - t1, 'nb_sets_info': nb_sets_info})\n            if timelimit is not None:\n                time_elapsed = t2 - time_init\n                time_left = timelimit - time_elapsed\n                if time_left < 2.0 * max_time_one_site:\n                    breakit = True\n            max_time_one_site = max(max_time_one_site, t2 - t1)\n            logging.info('    ... computed in {:.2f} seconds'.format(t2 - t1))\n        time_end = time.clock()\n        logging.info('    ... compute_structure_environments ended in {:.2f} seconds'.format(time_end-time_init))\n        return se", "response": "Computes and returns a StructureEnvironments object containing all the information about the coordination environments in the structure."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset up the AbstractGeometry for the local geometry of site with index isite.", "response": "def setup_local_geometry(self, isite, coords, optimization=None):\n        \"\"\"\n        Sets up the AbstractGeometry for the local geometry of site with index isite.\n        :param isite: Index of the site for which the local geometry has to be set up\n        :param coords: The coordinates of the (local) neighbors\n        \"\"\"\n        self.local_geometry = AbstractGeometry(\n            central_site=self.structure.cart_coords[isite],\n            bare_coords=coords,\n            centering_type=self.centering_type,\n            include_central_site_in_centroid=\n            self.include_central_site_in_centroid,\n            optimization=optimization)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset up a purely random structure with a given coordination number.", "response": "def setup_random_structure(self, coordination):\n        \"\"\"\n        Sets up a purely random structure with a given coordination.\n        :param coordination: coordination number for the random structure\n        \"\"\"\n        aa = 0.4\n        bb = -0.2\n        coords = list()\n        for ii in range(coordination + 1):\n            coords.append(aa * np.random.random_sample(3, ) + bb)\n        self.set_structure(\n            lattice=np.array([[10, 0, 0], [0, 10, 0], [0, 0, 10]], np.float),\n            species=[\"Si\"] * (coordination + 1),\n            coords=coords,\n            coords_are_cartesian=False)\n        self.setup_random_indices_local_geometry(coordination)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef setup_random_indices_local_geometry(self, coordination):\n        self.icentral_site = 0\n        self.indices = list(range(1, coordination + 1))\n        np.random.shuffle(self.indices)", "response": "Sets up random indices for the local geometry for testing purposes"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset up ordered indices for the local geometry for testing purposes", "response": "def setup_ordered_indices_local_geometry(self, coordination):\n        \"\"\"\n        Sets up ordered indices for the local geometry, for testing purposes\n        :param coordination: coordination of the local geometry\n        \"\"\"\n        self.icentral_site = 0\n        self.indices = list(range(1, coordination + 1))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef setup_explicit_indices_local_geometry(self, explicit_indices):\n        self.icentral_site = 0\n        self.indices = [ii + 1 for ii in explicit_indices]", "response": "Sets up explicit indices for the local geometry for testing purposes\n       "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the continuous symmetry measures of the current local geometry in a dictionary.", "response": "def get_coordination_symmetry_measures(self, only_minimum=True,\n                                           all_csms=True, optimization=None):\n        \"\"\"\n        Returns the continuous symmetry measures of the current local geometry in a dictionary.\n        :return: the continuous symmetry measures of the current local geometry in a dictionary.\n        \"\"\"\n        test_geometries = self.allcg.get_implemented_geometries(\n            len(self.local_geometry.coords))\n        if len(self.local_geometry.coords) == 1:\n            if len(test_geometries) == 0:\n                return {}\n            result_dict = {'S:1': {'csm': 0.0, 'indices': [0], 'algo': 'EXPLICIT',\n                                   'local2perfect_map': {0: 0}, 'perfect2local_map': {0: 0},\n                                   'scaling_factor': None, 'rotation_matrix': None, 'translation_vector': None}}\n            if all_csms:\n                for csmtype in ['wocs_ctwocc', 'wocs_ctwcc', 'wocs_csc', 'wcs_ctwocc', 'wcs_ctwcc', 'wcs_csc']:\n                    result_dict['S:1']['csm_{}'.format(csmtype)] = 0.0\n                    result_dict['S:1']['scaling_factor_{}'.format(csmtype)] = None\n                    result_dict['S:1']['rotation_matrix_{}'.format(csmtype)] = None\n                    result_dict['S:1']['translation_vector_{}'.format(csmtype)] = None\n            return result_dict\n        result_dict = {}\n        for geometry in test_geometries:\n            self.perfect_geometry = AbstractGeometry.from_cg(cg=geometry,\n                                                             centering_type=self.centering_type,\n                                                             include_central_site_in_centroid=\n                                                             self.include_central_site_in_centroid)\n            points_perfect = self.perfect_geometry.points_wcs_ctwcc()\n            cgsm = self.coordination_geometry_symmetry_measures(geometry,\n                                                                points_perfect=points_perfect,\n                                                                optimization=optimization)\n            result, permutations, algos, local2perfect_maps, perfect2local_maps = cgsm\n            if only_minimum:\n                if len(result) > 0:\n                    imin = np.argmin([rr['symmetry_measure'] for rr in result])\n                    if geometry.algorithms is not None:\n                        algo = algos[imin]\n                    else:\n                        algo = algos\n                    result_dict[geometry.mp_symbol] = {'csm': result[imin]['symmetry_measure'],\n                                                       'indices': permutations[\n                                                           imin],\n                                                       'algo': algo,\n                                                       'local2perfect_map':\n                                                           local2perfect_maps[\n                                                               imin],\n                                                       'perfect2local_map':\n                                                           perfect2local_maps[\n                                                               imin],\n                                                       'scaling_factor': 1.0 / result[imin]['scaling_factor'],\n                                                       'rotation_matrix':\n                                                           np.linalg.inv(result[imin]['rotation_matrix']),\n                                                       'translation_vector': result[imin]['translation_vector']}\n                    if all_csms:\n                        self._update_results_all_csms(result_dict, permutations, imin, geometry)\n            else:\n                result_dict[geometry.mp_symbol] = {'csm': result,\n                                                   'indices': permutations,\n                                                   'algo': algos,\n                                                   'local2perfect_map': local2perfect_maps,\n                                                   'perfect2local_map': perfect2local_maps}\n        return result_dict"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_coordination_symmetry_measures_optim(self, only_minimum=True,\n                                                 all_csms=True, nb_set=None, optimization=None):\n        \"\"\"\n        Returns the continuous symmetry measures of the current local geometry in a dictionary.\n        :return: the continuous symmetry measures of the current local geometry in a dictionary.\n        \"\"\"\n        cn = len(self.local_geometry.coords)\n        test_geometries = self.allcg.get_implemented_geometries(cn)\n        if all([cg.algorithms[0].algorithm_type == EXPLICIT_PERMUTATIONS for cg in test_geometries]):\n            return self.get_coordination_symmetry_measures(only_minimum=only_minimum, all_csms=all_csms,\n                                                           optimization=optimization)\n        if not all([all([algo.algorithm_type == SEPARATION_PLANE\n                         for algo in cg.algorithms]) for cg in test_geometries]):\n            raise ValueError('All algorithms should be EXPLICIT_PERMUTATIONS or SEPARATION_PLANE')\n\n        result_dict = {}\n        for geometry in test_geometries:\n            self.perfect_geometry = AbstractGeometry.from_cg(cg=geometry,\n                                                             centering_type=self.centering_type,\n                                                             include_central_site_in_centroid=\n                                                             self.include_central_site_in_centroid)\n            points_perfect = self.perfect_geometry.points_wcs_ctwcc()\n            cgsm = self.coordination_geometry_symmetry_measures_sepplane_optim(geometry,\n                                                                               points_perfect=points_perfect,\n                                                                               nb_set=nb_set,\n                                                                               optimization=optimization)\n            result, permutations, algos, local2perfect_maps, perfect2local_maps = cgsm\n            if only_minimum:\n                if len(result) > 0:\n                    imin = np.argmin([rr['symmetry_measure'] for rr in result])\n                    if geometry.algorithms is not None:\n                        algo = algos[imin]\n                    else:\n                        algo = algos\n                    result_dict[geometry.mp_symbol] = {'csm': result[imin]['symmetry_measure'],\n                                                       'indices': permutations[\n                                                           imin],\n                                                       'algo': algo,\n                                                       'local2perfect_map':\n                                                           local2perfect_maps[\n                                                               imin],\n                                                       'perfect2local_map':\n                                                           perfect2local_maps[\n                                                               imin],\n                                                       'scaling_factor': 1.0 / result[imin]['scaling_factor'],\n                                                       'rotation_matrix':\n                                                           np.linalg.inv(result[imin]['rotation_matrix']),\n                                                       'translation_vector': result[imin]['translation_vector']}\n                    if all_csms:\n                        self._update_results_all_csms(result_dict, permutations, imin, geometry)\n        return result_dict", "response": "This method returns the continuous symmetry measures of the current local geometry in a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the symmetry measures of a given coordination_geometry for a set of permutations depending on the permutation setup. Depending on the parameters of the LocalGeometryFinder and on the coordination geometry, different methods are called. :param coordination_geometry: Coordination geometry for which the symmetry measures are looked for :return: the symmetry measures of a given coordination_geometry for a set of permutations :raise: NotImplementedError if the permutation_setup does not exists", "response": "def coordination_geometry_symmetry_measures(self, coordination_geometry,\n                                                tested_permutations=False,\n                                                points_perfect=None,\n                                                optimization=None):\n        \"\"\"\n        Returns the symmetry measures of a given coordination_geometry for a set of permutations depending on\n        the permutation setup. Depending on the parameters of the LocalGeometryFinder and on the coordination\n         geometry, different methods are called.\n        :param coordination_geometry: Coordination geometry for which the symmetry measures are looked for\n        :return: the symmetry measures of a given coordination_geometry for a set of permutations\n        :raise: NotImplementedError if the permutation_setup does not exists\n        \"\"\"\n        if tested_permutations:\n            tested_permutations = set()\n        if self.permutations_safe_override:\n            raise ValueError('No permutations safe override anymore')\n        csms = []\n        permutations = []\n        algos = []\n        local2perfect_maps = []\n        perfect2local_maps = []\n        for algo in coordination_geometry.algorithms:\n            if algo.algorithm_type == EXPLICIT_PERMUTATIONS:\n                return self.coordination_geometry_symmetry_measures_standard(\n                    coordination_geometry, algo,\n                    points_perfect=points_perfect,\n                    optimization=optimization)\n            if algo.algorithm_type == SEPARATION_PLANE:\n                cgsm = self.coordination_geometry_symmetry_measures_separation_plane(\n                    coordination_geometry,\n                    algo,\n                    tested_permutations=tested_permutations,\n                    points_perfect=points_perfect)\n                csm, perm, algo, local2perfect_map, perfect2local_map = cgsm\n\n                csms.extend(csm)\n                permutations.extend(perm)\n                algos.extend(algo)\n                local2perfect_maps.extend(local2perfect_map)\n                perfect2local_maps.extend(perfect2local_map)\n        return csms, permutations, algos, local2perfect_maps, perfect2local_maps"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef coordination_geometry_symmetry_measures_sepplane_optim(self, coordination_geometry,\n                                                               points_perfect=None,\n                                                               nb_set=None, optimization=None):\n        \"\"\"\n        Returns the symmetry measures of a given coordination_geometry for a set of permutations depending on\n        the permutation setup. Depending on the parameters of the LocalGeometryFinder and on the coordination\n         geometry, different methods are called.\n        :param coordination_geometry: Coordination geometry for which the symmetry measures are looked for\n        :return: the symmetry measures of a given coordination_geometry for a set of permutations\n        :raise: NotImplementedError if the permutation_setup does not exists\n        \"\"\"\n        csms = []\n        permutations = []\n        algos = []\n        local2perfect_maps = []\n        perfect2local_maps = []\n        for algo in coordination_geometry.algorithms:\n            if algo.algorithm_type == SEPARATION_PLANE:\n                cgsm = self.coordination_geometry_symmetry_measures_separation_plane_optim(\n                    coordination_geometry,\n                    algo,\n                    points_perfect=points_perfect,\n                    nb_set=nb_set,\n                    optimization=optimization)\n                csm, perm, algo, local2perfect_map, perfect2local_map = cgsm\n\n                csms.extend(csm)\n                permutations.extend(perm)\n                algos.extend(algo)\n                local2perfect_maps.extend(local2perfect_map)\n                perfect2local_maps.extend(perfect2local_map)\n        return csms, permutations, algos, local2perfect_maps, perfect2local_maps", "response": "This method returns the symmetry measures of a given coordination geometry for a set of permutations and a set of local symmetry algorithms."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef coordination_geometry_symmetry_measures_standard(self,\n                                                         coordination_geometry,\n                                                         algo,\n                                                         points_perfect=None,\n                                                         optimization=None):\n        \"\"\"\n        Returns the symmetry measures for a set of permutations (whose setup depends on the coordination geometry)\n        for the coordination geometry \"coordination_geometry\". Standard implementation looking for the symmetry\n        measures of each permutation\n\n        :param coordination_geometry: The coordination geometry to be investigated\n        :return: The symmetry measures for the given coordination geometry for each permutation investigated\n        \"\"\"\n        # permutations_symmetry_measures = np.zeros(len(algo.permutations),\n        #                                           np.float)\n        if optimization == 2:\n            permutations_symmetry_measures = [None] * len(algo.permutations)\n            permutations = list()\n            algos = list()\n            local2perfect_maps = list()\n            perfect2local_maps = list()\n            for iperm, perm in enumerate(algo.permutations):\n\n                local2perfect_map = {}\n                perfect2local_map = {}\n                permutations.append(perm)\n                for iperfect, ii in enumerate(perm):\n                    perfect2local_map[iperfect] = ii\n                    local2perfect_map[ii] = iperfect\n                local2perfect_maps.append(local2perfect_map)\n                perfect2local_maps.append(perfect2local_map)\n\n                points_distorted = self.local_geometry.points_wcs_ctwcc(\n                    permutation=perm)\n\n                sm_info = symmetry_measure(points_distorted=points_distorted,\n                                              points_perfect=points_perfect)\n                sm_info['translation_vector'] = self.local_geometry.centroid_with_centre\n\n                permutations_symmetry_measures[iperm] = sm_info\n                algos.append(str(algo))\n            return permutations_symmetry_measures, permutations, algos, local2perfect_maps, perfect2local_maps\n        else:\n            permutations_symmetry_measures = [None] * len(algo.permutations)\n            permutations = list()\n            algos = list()\n            local2perfect_maps = list()\n            perfect2local_maps = list()\n            for iperm, perm in enumerate(algo.permutations):\n\n                local2perfect_map = {}\n                perfect2local_map = {}\n                permutations.append(perm)\n                for iperfect, ii in enumerate(perm):\n                    perfect2local_map[iperfect] = ii\n                    local2perfect_map[ii] = iperfect\n                local2perfect_maps.append(local2perfect_map)\n                perfect2local_maps.append(perfect2local_map)\n\n                points_distorted = self.local_geometry.points_wcs_ctwcc(\n                    permutation=perm)\n\n                sm_info = symmetry_measure(points_distorted=points_distorted,\n                                           points_perfect=points_perfect)\n                sm_info['translation_vector'] = self.local_geometry.centroid_with_centre\n\n                permutations_symmetry_measures[iperm] = sm_info\n                algos.append(str(algo))\n            return permutations_symmetry_measures, permutations, algos, local2perfect_maps, perfect2local_maps", "response": "This method returns the symmetry measures for a set of permutations and a set of algorithms that are in the coordination geometry."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the symmetry measures of the given coordination geometry \"coordination_geometry\" using separation facets to reduce the complexity of the system. Caller to the refined 2POINTS, 3POINTS and other ... :param coordination_geometry: The coordination geometry to be investigated :return: The symmetry measures for the given coordination geometry for each plane and permutation investigated", "response": "def coordination_geometry_symmetry_measures_separation_plane(self,\n                                                                 coordination_geometry,\n                                                                 separation_plane_algo,\n                                                                 testing=False,\n                                                                 tested_permutations=False,\n                                                                 points_perfect=None):\n\n        \"\"\"\n        Returns the symmetry measures of the given coordination geometry \"coordination_geometry\" using separation\n        facets to reduce the complexity of the system. Caller to the refined 2POINTS, 3POINTS and other ...\n        :param coordination_geometry: The coordination geometry to be investigated\n        :return: The symmetry measures for the given coordination geometry for each plane and permutation investigated\n        \"\"\"\n        permutations = list()\n        permutations_symmetry_measures = list()\n        plane_separations = list()\n        algos = list()\n        perfect2local_maps = list()\n        local2perfect_maps = list()\n        if testing:\n            separation_permutations = list()\n        nplanes = 0\n        for npoints in range(separation_plane_algo.minimum_number_of_points,\n                             min(separation_plane_algo.maximum_number_of_points,\n                                 4) + 1):\n            for points_combination in itertools.combinations(\n                    self.local_geometry.coords, npoints):\n                if npoints == 2:\n                    if collinear(points_combination[0], points_combination[1],\n                                 self.local_geometry.central_site,\n                                 tolerance=0.25):\n                        continue\n                    plane = Plane.from_3points(points_combination[0],\n                                               points_combination[1],\n                                               self.local_geometry.central_site)\n                elif npoints == 3:\n                    if collinear(points_combination[0], points_combination[1],\n                                 points_combination[2], tolerance=0.25):\n                        continue\n                    plane = Plane.from_3points(points_combination[0],\n                                               points_combination[1],\n                                               points_combination[2])\n                elif npoints > 3:\n                    plane = Plane.from_npoints(points_combination,\n                                               best_fit='least_square_distance')\n                else:\n                    raise ValueError(\n                        'Wrong number of points to initialize separation plane')\n                cgsm = self._cg_csm_separation_plane(\n                    coordination_geometry=coordination_geometry,\n                    sepplane=separation_plane_algo,\n                    local_plane=plane,\n                    plane_separations=plane_separations,\n                    dist_tolerances=DIST_TOLERANCES,\n                    testing=testing,\n                    tested_permutations=tested_permutations,\n                    points_perfect=points_perfect)\n                csm, perm, algo = cgsm[0], cgsm[1], cgsm[2]\n\n                if csm is not None:\n                    permutations_symmetry_measures.extend(csm)\n                    permutations.extend(perm)\n                    for thisperm in perm:\n                        p2l = {}\n                        l2p = {}\n                        for i_p, pp in enumerate(thisperm):\n                            p2l[i_p] = pp\n                            l2p[pp] = i_p\n                        perfect2local_maps.append(p2l)\n                        local2perfect_maps.append(l2p)\n                    algos.extend(algo)\n                    if testing:\n                        separation_permutations.extend(cgsm[3])\n                    nplanes += 1\n            if nplanes > 0:\n                break\n        if nplanes == 0:\n            return self.coordination_geometry_symmetry_measures_fallback_random(\n                coordination_geometry,\n                points_perfect=points_perfect)\n        if testing:\n            return permutations_symmetry_measures, permutations, separation_permutations\n        return permutations_symmetry_measures, permutations, algos, local2perfect_maps, perfect2local_maps"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef coordination_geometry_symmetry_measures_separation_plane_optim(self,\n                                                                       coordination_geometry,\n                                                                       separation_plane_algo,\n                                                                       points_perfect=None,\n                                                                       nb_set=None,\n                                                                       optimization=None):\n        \"\"\"\n        Returns the symmetry measures of the given coordination geometry \"coordination_geometry\" using separation\n        facets to reduce the complexity of the system. Caller to the refined 2POINTS, 3POINTS and other ...\n        :param coordination_geometry: The coordination geometry to be investigated\n        :return: The symmetry measures for the given coordination geometry for each plane and permutation investigated\n        \"\"\"\n        if optimization == 2:\n            cgcsmoptim = self._cg_csm_separation_plane_optim2\n        elif optimization == 1:\n            cgcsmoptim = self._cg_csm_separation_plane_optim1\n        else:\n            raise ValueError('Optimization should be 1 or 2')\n        cn = len(self.local_geometry.coords)\n\n        permutations = list()\n        permutations_symmetry_measures = list()\n        algos = list()\n        perfect2local_maps = list()\n        local2perfect_maps = list()\n\n        if separation_plane_algo.separation in nb_set.separations:\n            for sep_indices, (local_plane, npsep) in nb_set.separations[separation_plane_algo.separation].items():\n                cgsm = cgcsmoptim(coordination_geometry=coordination_geometry,\n                                  sepplane=separation_plane_algo,\n                                  local_plane=local_plane,\n                                  points_perfect=points_perfect,\n                                  separation_indices=npsep)\n                csm, perm, algo, cgsm_stop_search = cgsm[0], cgsm[1], cgsm[2], cgsm[3]\n                permutations_symmetry_measures.extend(csm)\n                permutations.extend(perm)\n                for thisperm in perm:\n                    p2l = {}\n                    l2p = {}\n                    for i_p, pp in enumerate(thisperm):\n                        p2l[i_p] = pp\n                        l2p[pp] = i_p\n                    perfect2local_maps.append(p2l)\n                    local2perfect_maps.append(l2p)\n                algos.extend(algo)\n\n        # Get the local planes and separations up to 3 points\n        for npoints in range(self.allcg.minpoints[cn], min(self.allcg.maxpoints[cn], 3) + 1):\n            for ipoints_combination in itertools.combinations(\n                    range(self.local_geometry.cn), npoints):\n                if ipoints_combination in nb_set.local_planes:\n                    continue\n                # Set up new plane\n                nb_set.local_planes[ipoints_combination] = None\n                points_combination = [self.local_geometry.coords[ip] for ip in ipoints_combination]\n                if npoints == 2:\n                    if collinear(points_combination[0], points_combination[1],\n                                 self.local_geometry.central_site,\n                                 tolerance=0.25):\n                        continue\n                    plane = Plane.from_3points(points_combination[0],\n                                               points_combination[1],\n                                               self.local_geometry.central_site)\n                elif npoints == 3:\n                    if collinear(points_combination[0], points_combination[1],\n                                 points_combination[2], tolerance=0.25):\n                        continue\n                    plane = Plane.from_3points(points_combination[0],\n                                               points_combination[1],\n                                               points_combination[2])\n                elif npoints > 3:\n                    plane = Plane.from_npoints(points_combination,\n                                               best_fit='least_square_distance')\n                else:\n                    raise ValueError(\n                        'Wrong number of points to initialize separation plane')\n                # Takes a lot of time and happens rarely ...\n                # if any([plane.is_same_plane_as(plane2) for comb2, plane2 in nb_set.local_planes.items() if plane2 is not None]):\n                #     continue\n                nb_set.local_planes[ipoints_combination] = plane\n                # Get the separations for this plane\n                # TODO: check sensitivity to delta/delta_factor parameter\n                dig = plane.distances_indices_groups(points=self.local_geometry._coords, delta_factor=0.1,\n                                                     sign=True)\n                grouped_indices = dig[2]\n                new_seps = []\n                for ng in range(1, len(grouped_indices) + 1):\n                    inplane = list(itertools.chain(*grouped_indices[:ng]))\n                    if len(inplane) > self.allcg.maxpoints_inplane[cn]:\n                        break\n                    inplane = [ii[0] for ii in inplane]\n                    outplane = list(itertools.chain(*grouped_indices[ng:]))\n                    s1 = [ii_sign[0] for ii_sign in outplane if ii_sign[1] < 0]\n                    s2 = [ii_sign[0] for ii_sign in outplane if ii_sign[1] > 0]\n                    separation = sort_separation_tuple([s1, inplane, s2])\n                    sep = tuple([len(gg) for gg in separation])\n                    if sep not in self.allcg.separations_cg[cn]:\n                        continue\n                    if sep not in nb_set.separations:\n                        nb_set.separations[sep] = {}\n                    mysep = [np.array(ss, dtype=np.int8) for ss in separation]\n                    nb_set.separations[sep][separation] = (plane, mysep)\n                    if sep == separation_plane_algo.separation:\n                        new_seps.append(mysep)\n\n                for separation_indices in new_seps:\n                    cgsm = cgcsmoptim(coordination_geometry=coordination_geometry,\n                                      sepplane=separation_plane_algo,\n                                      local_plane=plane,\n                                      points_perfect=points_perfect,\n                                      separation_indices=separation_indices)\n                    csm, perm, algo, cgsm_stop_search = cgsm[0], cgsm[1], cgsm[2], cgsm[3]\n                    permutations_symmetry_measures.extend(csm)\n                    permutations.extend(perm)\n                    for thisperm in perm:\n                        p2l = {}\n                        l2p = {}\n                        for i_p, pp in enumerate(thisperm):\n                            p2l[i_p] = pp\n                            l2p[pp] = i_p\n                        perfect2local_maps.append(p2l)\n                        local2perfect_maps.append(l2p)\n                    algos.extend(algo)\n\n        if len(permutations_symmetry_measures) == 0:\n            return self.coordination_geometry_symmetry_measures_fallback_random(\n                coordination_geometry,\n                points_perfect=points_perfect)\n        return permutations_symmetry_measures, permutations, algos, local2perfect_maps, perfect2local_maps", "response": "This method returns the symmetry measures for the given coordination geometry using separation_plane_algorithm."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the symmetry measures for a random set of permutations for the coordination geometry \"coordination_geometry\". Fallback implementation for the plane separation algorithms measures of each permutation :param coordination_geometry: The coordination geometry to be investigated :param NRANDOM: Number of random permutations to be tested :return: The symmetry measures for the given coordination geometry for each permutation investigated", "response": "def coordination_geometry_symmetry_measures_fallback_random(self,\n                                                                coordination_geometry,\n                                                                NRANDOM=10,\n                                                                points_perfect=None):\n        \"\"\"\n        Returns the symmetry measures for a random set of permutations for the coordination geometry\n        \"coordination_geometry\". Fallback implementation for the plane separation algorithms measures\n        of each permutation\n\n        :param coordination_geometry: The coordination geometry to be investigated\n        :param NRANDOM: Number of random permutations to be tested\n        :return: The symmetry measures for the given coordination geometry for each permutation investigated\n        \"\"\"\n        permutations_symmetry_measures = [None] * NRANDOM\n        permutations = list()\n        algos = list()\n        perfect2local_maps = list()\n        local2perfect_maps = list()\n        for iperm in range(NRANDOM):\n            perm = np.random.permutation(\n                coordination_geometry.coordination_number)\n            permutations.append(perm)\n            p2l = {}\n            l2p = {}\n            for i_p, pp in enumerate(perm):\n                p2l[i_p] = pp\n                l2p[pp] = i_p\n            perfect2local_maps.append(p2l)\n            local2perfect_maps.append(l2p)\n\n            points_distorted = self.local_geometry.points_wcs_ctwcc(\n                permutation=perm)\n            sm_info = symmetry_measure(points_distorted=points_distorted,\n                                       points_perfect=points_perfect)\n            sm_info['translation_vector'] = self.local_geometry.centroid_with_centre\n\n            permutations_symmetry_measures[iperm] = sm_info\n            algos.append('APPROXIMATE_FALLBACK')\n        return permutations_symmetry_measures, permutations, algos, local2perfect_maps, perfect2local_maps"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef plot_fermi_surface(data, structure, cbm, energy_levels=[],\n                       multiple_figure=True,\n                       mlab_figure=None, kpoints_dict={}, color=(0, 0, 1),\n                       transparency_factor=[], labels_scale_factor=0.05,\n                       points_scale_factor=0.02, interative=True):\n    \"\"\"\n    Plot the Fermi surface at specific energy value.\n\n    Args:\n        data: energy values in a 3D grid from a CUBE file \n              via read_cube_file function, or from a \n              BoltztrapAnalyzer.fermi_surface_data\n        structure: structure object of the material\n        energy_levels: list of energy value of the fermi surface. \n                       By default 0 eV correspond to the VBM, as in \n                       the plot of band structure along symmetry line.\n                       Default: max energy value + 0.01 eV\n        cbm: Boolean value to specify if the considered band is \n             a conduction band or not\n        multiple_figure: if True a figure for each energy level will be shown.\n                         If False all the surfaces will be shown in the same figure.\n                         In this las case, tune the transparency factor.\n        mlab_figure: provide a previous figure to plot a new surface on it.\n        kpoints_dict: dictionary of kpoints to show in the plot.\n                      example: {\"K\":[0.5,0.0,0.5]}, \n                      where the coords are fractional.\n        color: tuple (r,g,b) of integers to define the color of the surface.\n        transparency_factor: list of values in the range [0,1] to tune\n                             the opacity of the surfaces.\n        labels_scale_factor: factor to tune the size of the kpoint labels\n        points_scale_factor: factor to tune the size of the kpoint points\n        interative: if True an interactive figure will be shown.\n                    If False a non interactive figure will be shown, but\n                    it is possible to plot other surfaces on the same figure.\n                    To make it interactive, run mlab.show().\n        \n    Returns:\n        a Mayavi figure and a mlab module to control the plot.\n\n    Note: Experimental. \n          Please, double check the surface shown by using some \n          other software and report issues.\n    \"\"\"\n\n    try:\n        from mayavi import mlab\n    except ImportError:\n        raise BoltztrapError(\n            \"Mayavi package should be installed to use this function\")\n\n    bz = structure.lattice.reciprocal_lattice.get_wigner_seitz_cell()\n    cell = structure.lattice.reciprocal_lattice.matrix\n\n    fact = 1 if cbm == False else -1\n    en_min = np.min(fact * data.ravel())\n    en_max = np.max(fact * data.ravel())\n\n    if energy_levels == []:\n        energy_levels = [en_min + 0.01] if cbm == True else \\\n            [en_max - 0.01]\n        print(\"Energy level set to: \" + str(energy_levels[0]) + \" eV\")\n\n    else:\n        for e in energy_levels:\n            if e > en_max or e < en_min:\n                raise BoltztrapError(\"energy level \" + str(e) +\n                                     \" not in the range of possible energies: [\" +\n                                     str(en_min) + \", \" + str(en_max) + \"]\")\n\n    if transparency_factor == []:\n        transparency_factor = [1] * len(energy_levels)\n\n    if mlab_figure:\n        fig = mlab_figure\n\n    if mlab_figure == None and not multiple_figure:\n        fig = mlab.figure(size=(1024, 768), bgcolor=(1, 1, 1))\n        for iface in range(len(bz)):\n            for line in itertools.combinations(bz[iface], 2):\n                for jface in range(len(bz)):\n                    if iface < jface and any(np.all(line[0] == x)\n                                             for x in bz[jface]) and \\\n                            any(np.all(line[1] == x)\n                                for x in bz[jface]):\n                        mlab.plot3d(*zip(line[0], line[1]), color=(0, 0, 0),\n                                    tube_radius=None, figure=fig)\n        for label, coords in kpoints_dict.items():\n            label_coords = structure.lattice.reciprocal_lattice \\\n                .get_cartesian_coords(coords)\n            mlab.points3d(*label_coords, scale_factor=points_scale_factor,\n                          color=(0, 0, 0), figure=fig)\n            mlab.text3d(*label_coords, text=label, scale=labels_scale_factor,\n                        color=(0, 0, 0), figure=fig)\n\n    for isolevel, alpha in zip(energy_levels, transparency_factor):\n        if multiple_figure:\n            fig = mlab.figure(size=(1024, 768), bgcolor=(1, 1, 1))\n\n            for iface in range(len(bz)):\n                for line in itertools.combinations(bz[iface], 2):\n                    for jface in range(len(bz)):\n                        if iface < jface and any(np.all(line[0] == x)\n                                                 for x in bz[jface]) and \\\n                                any(np.all(line[1] == x)\n                                    for x in bz[jface]):\n                            mlab.plot3d(*zip(line[0], line[1]), color=(0, 0, 0),\n                                        tube_radius=None, figure=fig)\n\n            for label, coords in kpoints_dict.items():\n                label_coords = structure.lattice.reciprocal_lattice \\\n                    .get_cartesian_coords(coords)\n                mlab.points3d(*label_coords, scale_factor=points_scale_factor,\n                              color=(0, 0, 0), figure=fig)\n                mlab.text3d(*label_coords, text=label,\n                            scale=labels_scale_factor, color=(0, 0, 0),\n                            figure=fig)\n\n        cp = mlab.contour3d(fact * data, contours=[isolevel], transparent=True,\n                            colormap='hot', color=color, opacity=alpha,\n                            figure=fig)\n\n        polydata = cp.actor.actors[0].mapper.input\n        pts = np.array(polydata.points)  # - 1\n        polydata.points = np.dot(pts,\n                                 cell / np.array(data.shape)[:, np.newaxis])\n\n        cx, cy, cz = [np.mean(np.array(polydata.points)[:, i])\n                      for i in range(3)]\n\n        polydata.points = (np.array(polydata.points) - [cx, cy, cz]) * 2\n\n        #mlab.view(distance='auto')\n        fig.scene.isometric_view() \n    if interative == True:\n        mlab.show()\n\n    return fig, mlab", "response": "Function to plot the Fermi surface at specific energy level."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef plot_wigner_seitz(lattice, ax=None, **kwargs):\n    ax, fig, plt = get_ax3d_fig_plt(ax)\n\n    if \"color\" not in kwargs:\n        kwargs[\"color\"] = \"k\"\n    if \"linewidth\" not in kwargs:\n        kwargs[\"linewidth\"] = 1\n\n    bz = lattice.get_wigner_seitz_cell()\n    ax, fig, plt = get_ax3d_fig_plt(ax)\n    for iface in range(len(bz)):\n        for line in itertools.combinations(bz[iface], 2):\n            for jface in range(len(bz)):\n                if iface < jface and any(\n                        np.all(line[0] == x) for x in bz[jface]) \\\n                        and any(np.all(line[1] == x) for x in bz[jface]):\n                    ax.plot(*zip(line[0], line[1]), **kwargs)\n\n    return fig, ax", "response": "Plots the Wigner - Seitz cell of the lattice object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef plot_lattice_vectors(lattice, ax=None, **kwargs):\n    ax, fig, plt = get_ax3d_fig_plt(ax)\n\n    if \"color\" not in kwargs:\n        kwargs[\"color\"] = \"g\"\n    if \"linewidth\" not in kwargs:\n        kwargs[\"linewidth\"] = 3\n\n    vertex1 = lattice.get_cartesian_coords([0.0, 0.0, 0.0])\n    vertex2 = lattice.get_cartesian_coords([1.0, 0.0, 0.0])\n    ax.plot(*zip(vertex1, vertex2), **kwargs)\n    vertex2 = lattice.get_cartesian_coords([0.0, 1.0, 0.0])\n    ax.plot(*zip(vertex1, vertex2), **kwargs)\n    vertex2 = lattice.get_cartesian_coords([0.0, 0.0, 1.0])\n    ax.plot(*zip(vertex1, vertex2), **kwargs)\n\n    return fig, ax", "response": "Plots the basis vectors of the object lattice."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef plot_path(line, lattice=None, coords_are_cartesian=False, ax=None,\n              **kwargs):\n    \"\"\"\n    Adds a line passing through the coordinates listed in 'line' to a matplotlib Axes\n\n    Args:\n        line: list of coordinates.\n        lattice: Lattice object used to convert from reciprocal to cartesian coordinates\n        coords_are_cartesian: Set to True if you are providing\n            coordinates in cartesian coordinates. Defaults to False.\n            Requires lattice if False.\n        ax: matplotlib :class:`Axes` or None if a new figure should be created.\n        kwargs: kwargs passed to the matplotlib function 'plot'. Color defaults to red\n            and linewidth to 3.\n\n    Returns:\n        matplotlib figure and matplotlib ax\n    \"\"\"\n\n    ax, fig, plt = get_ax3d_fig_plt(ax)\n\n    if \"color\" not in kwargs:\n        kwargs[\"color\"] = \"r\"\n    if \"linewidth\" not in kwargs:\n        kwargs[\"linewidth\"] = 3\n\n    for k in range(1, len(line)):\n        vertex1 = line[k - 1]\n        vertex2 = line[k]\n        if not coords_are_cartesian:\n            if lattice is None:\n                raise ValueError(\n                    \"coords_are_cartesian False requires the lattice\")\n            vertex1 = lattice.get_cartesian_coords(vertex1)\n            vertex2 = lattice.get_cartesian_coords(vertex2)\n        ax.plot(*zip(vertex1, vertex2), **kwargs)\n\n    return fig, ax", "response": "Plots the path of the catalyzes in a single line of cartesometry."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef plot_labels(labels, lattice=None, coords_are_cartesian=False, ax=None,\n                **kwargs):\n    \"\"\"\n    Adds labels to a matplotlib Axes\n\n    Args:\n        labels: dict containing the label as a key and the coordinates as value.\n        lattice: Lattice object used to convert from reciprocal to cartesian coordinates\n        coords_are_cartesian: Set to True if you are providing.\n            coordinates in cartesian coordinates. Defaults to False.\n            Requires lattice if False.\n        ax: matplotlib :class:`Axes` or None if a new figure should be created.\n        kwargs: kwargs passed to the matplotlib function 'text'. Color defaults to blue\n            and size to 25.\n\n    Returns:\n        matplotlib figure and matplotlib ax\n    \"\"\"\n    ax, fig, plt = get_ax3d_fig_plt(ax)\n\n    if \"color\" not in kwargs:\n        kwargs[\"color\"] = \"b\"\n    if \"size\" not in kwargs:\n        kwargs[\"size\"] = 25\n\n    for k, coords in labels.items():\n        label = k\n        if k.startswith(\"\\\\\") or k.find(\"_\") != -1:\n            label = \"$\" + k + \"$\"\n        off = 0.01\n        if coords_are_cartesian:\n            coords = np.array(coords)\n        else:\n            if lattice is None:\n                raise ValueError(\n                    \"coords_are_cartesian False requires the lattice\")\n            coords = lattice.get_cartesian_coords(coords)\n        ax.text(*(coords + off), s=label, **kwargs)\n\n    return fig, ax", "response": "Plots the labels of the current object in a matplotlib Axes object."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef fold_point(p, lattice, coords_are_cartesian=False):\n\n    if coords_are_cartesian:\n        p = lattice.get_fractional_coords(p)\n    else:\n        p = np.array(p)\n\n    p = np.mod(p + 0.5 - 1e-10, 1) - 0.5 + 1e-10\n    p = lattice.get_cartesian_coords(p)\n\n    closest_lattice_point = None\n    smallest_distance = 10000\n    for i in (-1, 0, 1):\n        for j in (-1, 0, 1):\n            for k in (-1, 0, 1):\n                lattice_point = np.dot((i, j, k), lattice.matrix)\n                dist = np.linalg.norm(p - lattice_point)\n                if closest_lattice_point is None or dist < smallest_distance:\n                    closest_lattice_point = lattice_point\n                    smallest_distance = dist\n\n    if not np.allclose(closest_lattice_point, (0, 0, 0)):\n        p = p - closest_lattice_point\n\n    return p", "response": "Folds a point with coordinates p inside the first Brillouin zone of the lattice."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nplots the list of points in a single Brillouin Zone.", "response": "def plot_points(points, lattice=None, coords_are_cartesian=False, fold=False,\n                ax=None, **kwargs):\n    \"\"\"\n    Adds Points to a matplotlib Axes\n\n    Args:\n        points: list of coordinates\n        lattice: Lattice object used to convert from reciprocal to cartesian coordinates\n        coords_are_cartesian: Set to True if you are providing\n            coordinates in cartesian coordinates. Defaults to False.\n            Requires lattice if False.\n        fold: whether the points should be folded inside the first Brillouin Zone.\n            Defaults to False. Requires lattice if True.\n        ax: matplotlib :class:`Axes` or None if a new figure should be created.\n        kwargs: kwargs passed to the matplotlib function 'scatter'. Color defaults to blue\n\n    Returns:\n        matplotlib figure and matplotlib ax\n    \"\"\"\n    ax, fig, plt = get_ax3d_fig_plt(ax)\n\n    if \"color\" not in kwargs:\n        kwargs[\"color\"] = \"b\"\n\n    if (not coords_are_cartesian or fold) and lattice is None:\n        raise ValueError(\n            \"coords_are_cartesian False or fold True require the lattice\")\n\n    for p in points:\n\n        if fold:\n            p = fold_point(p, lattice,\n                           coords_are_cartesian=coords_are_cartesian)\n\n        elif not coords_are_cartesian:\n            p = lattice.get_cartesian_coords(p)\n\n        ax.scatter(*p, **kwargs)\n\n    return fig, ax"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef plot_brillouin_zone_from_kpath(kpath, ax=None, **kwargs):\n    lines = [[kpath.kpath['kpoints'][k] for k in p]\n             for p in kpath.kpath['path']]\n    return plot_brillouin_zone(bz_lattice=kpath.prim_rec, lines=lines, ax=ax,\n                               labels=kpath.kpath['kpoints'], **kwargs)", "response": "Plots the Brillouin Zone from a HighSymmKPath object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef plot_brillouin_zone(bz_lattice, lines=None, labels=None, kpoints=None,\n                        fold=False, coords_are_cartesian=False,\n                        ax=None, **kwargs):\n    \"\"\"\n    Plots a 3D representation of the Brillouin zone of the structure.\n    Can add to the plot paths, labels and kpoints\n\n    Args:\n        bz_lattice: Lattice object of the Brillouin zone\n        lines: list of lists of coordinates. Each list represent a different path\n        labels: dict containing the label as a key and the coordinates as value.\n        kpoints: list of coordinates\n        fold: whether the points should be folded inside the first Brillouin Zone.\n            Defaults to False. Requires lattice if True.\n        coords_are_cartesian: Set to True if you are providing\n            coordinates in cartesian coordinates. Defaults to False.\n        ax: matplotlib :class:`Axes` or None if a new figure should be created.\n        kwargs: provided by add_fig_kwargs decorator\n\n    Returns:\n        matplotlib figure\n    \"\"\"\n\n    fig, ax = plot_lattice_vectors(bz_lattice, ax=ax)\n    plot_wigner_seitz(bz_lattice, ax=ax)\n    if lines is not None:\n        for line in lines:\n            plot_path(line, bz_lattice,\n                      coords_are_cartesian=coords_are_cartesian, ax=ax)\n\n    if labels is not None:\n        plot_labels(labels, bz_lattice,\n                    coords_are_cartesian=coords_are_cartesian, ax=ax)\n        plot_points(labels.values(), bz_lattice,\n                    coords_are_cartesian=coords_are_cartesian,\n                    fold=False, ax=ax)\n\n    if kpoints is not None:\n        plot_points(kpoints, bz_lattice,\n                    coords_are_cartesian=coords_are_cartesian,\n                    ax=ax, fold=fold)\n\n    ax.set_xlim3d(-1, 1)\n    ax.set_ylim3d(-1, 1)\n    ax.set_zlim3d(-1, 1)\n\n    ax.set_aspect('equal')\n    ax.axis(\"off\")\n\n    return fig", "response": "Plots the structure of the Brillouin zone."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nplotting a 3D ellipsoid in input.", "response": "def plot_ellipsoid(hessian, center, lattice=None, rescale=1.0, ax=None,\n                   coords_are_cartesian=False, arrows=False, **kwargs):\n    \"\"\"\n    Plots a 3D ellipsoid rappresenting the Hessian matrix in input.\n    Useful to get a graphical visualization of the effective mass\n    of a band in a single k-point.\n    \n    Args:\n        hessian: the Hessian matrix\n        center: the center of the ellipsoid in reciprocal coords (Default)\n        lattice: Lattice object of the Brillouin zone\n        rescale: factor for size scaling of the ellipsoid\n        ax: matplotlib :class:`Axes` or None if a new figure should be created.\n        coords_are_cartesian: Set to True if you are providing a center in\n                              cartesian coordinates. Defaults to False.\n        kwargs: kwargs passed to the matplotlib function 'plot_wireframe'. \n                Color defaults to blue, rstride and cstride\n                default to 4, alpha defaults to 0.2.\n    Returns:\n        matplotlib figure and matplotlib ax\n    Example of use:\n        fig,ax=plot_wigner_seitz(struct.reciprocal_lattice)\n        plot_ellipsoid(hessian,[0.0,0.0,0.0], struct.reciprocal_lattice,ax=ax)\n    \"\"\"\n\n    if (not coords_are_cartesian) and lattice is None:\n        raise ValueError(\n            \"coords_are_cartesian False or fold True require the lattice\")\n\n    if not coords_are_cartesian:\n        center = lattice.get_cartesian_coords(center)\n\n    if \"color\" not in kwargs:\n        kwargs[\"color\"] = \"b\"\n    if \"rstride\" not in kwargs:\n        kwargs[\"rstride\"] = 4\n    if \"cstride\" not in kwargs:\n        kwargs[\"cstride\"] = 4\n    if \"alpha\" not in kwargs:\n        kwargs[\"alpha\"] = 0.2\n\n    # calculate the ellipsoid\n    # find the rotation matrix and radii of the axes\n    U, s, rotation = np.linalg.svd(hessian)\n    radii = 1.0 / np.sqrt(s)\n\n    # from polar coordinates\n    u = np.linspace(0.0, 2.0 * np.pi, 100)\n    v = np.linspace(0.0, np.pi, 100)\n    x = radii[0] * np.outer(np.cos(u), np.sin(v))\n    y = radii[1] * np.outer(np.sin(u), np.sin(v))\n    z = radii[2] * np.outer(np.ones_like(u), np.cos(v))\n    for i in range(len(x)):\n        for j in range(len(x)):\n            [x[i, j], y[i, j], z[i, j]] = np.dot([x[i, j], y[i, j], z[i, j]],\n                                                 rotation) * rescale + center\n\n    # add the ellipsoid to the current axes\n    ax, fig, plt = get_ax3d_fig_plt(ax)\n    ax.plot_wireframe(x, y, z, **kwargs)\n\n    if arrows:\n        color = ('b', 'g', 'r')\n        em = np.zeros((3, 3))\n        for i in range(3):\n            em[i, :] = rotation[i, :] / np.linalg.norm(rotation[i, :])\n        for i in range(3):\n            ax.quiver3D(center[0], center[1], center[2], em[i, 0], em[i, 1],\n                        em[i, 2], pivot='tail',\n                        arrow_length_ratio=0.2, length=radii[i] * rescale,\n                        color=color[i])\n\n    return fig, ax"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding a dos for plotting.", "response": "def add_dos(self, label, dos):\n        \"\"\"\n        Adds a dos for plotting.\n\n        Args:\n            label:\n                label for the DOS. Must be unique.\n            dos:\n                Dos object\n        \"\"\"\n        energies = dos.energies - dos.efermi if self.zero_at_efermi \\\n            else dos.energies\n        densities = dos.get_smeared_densities(self.sigma) if self.sigma \\\n            else dos.densities\n        efermi = dos.efermi\n        self._doses[label] = {'energies': energies, 'densities': densities,\n                              'efermi': efermi}"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a matplotlib plot showing the DOS.", "response": "def get_plot(self, xlim=None, ylim=None):\n        \"\"\"\n        Get a matplotlib plot showing the DOS.\n\n        Args:\n            xlim: Specifies the x-axis limits. Set to None for automatic\n                determination.\n            ylim: Specifies the y-axis limits.\n        \"\"\"\n\n        ncolors = max(3, len(self._doses))\n        ncolors = min(9, ncolors)\n\n        import palettable\n\n        colors = palettable.colorbrewer.qualitative.Set1_9.mpl_colors\n\n        y = None\n        alldensities = []\n        allenergies = []\n        plt = pretty_plot(12, 8)\n\n        # Note that this complicated processing of energies is to allow for\n        # stacked plots in matplotlib.\n        for key, dos in self._doses.items():\n            energies = dos['energies']\n            densities = dos['densities']\n            if not y:\n                y = {Spin.up: np.zeros(energies.shape),\n                     Spin.down: np.zeros(energies.shape)}\n            newdens = {}\n            for spin in [Spin.up, Spin.down]:\n                if spin in densities:\n                    if self.stack:\n                        y[spin] += densities[spin]\n                        newdens[spin] = y[spin].copy()\n                    else:\n                        newdens[spin] = densities[spin]\n            allenergies.append(energies)\n            alldensities.append(newdens)\n\n        keys = list(self._doses.keys())\n        keys.reverse()\n        alldensities.reverse()\n        allenergies.reverse()\n        allpts = []\n        for i, key in enumerate(keys):\n            x = []\n            y = []\n            for spin in [Spin.up, Spin.down]:\n                if spin in alldensities[i]:\n                    densities = list(int(spin) * alldensities[i][spin])\n                    energies = list(allenergies[i])\n                    if spin == Spin.down:\n                        energies.reverse()\n                        densities.reverse()\n                    x.extend(energies)\n                    y.extend(densities)\n            allpts.extend(list(zip(x, y)))\n            if self.stack:\n                plt.fill(x, y, color=colors[i % ncolors],\n                         label=str(key))\n            else:\n                plt.plot(x, y, color=colors[i % ncolors],\n                         label=str(key), linewidth=3)\n            if not self.zero_at_efermi:\n                ylim = plt.ylim()\n                plt.plot([self._doses[key]['efermi'],\n                          self._doses[key]['efermi']], ylim,\n                         color=colors[i % ncolors],\n                         linestyle='--', linewidth=2)\n\n        if xlim:\n            plt.xlim(xlim)\n        if ylim:\n            plt.ylim(ylim)\n        else:\n            xlim = plt.xlim()\n            relevanty = [p[1] for p in allpts\n                         if xlim[0] < p[0] < xlim[1]]\n            plt.ylim((min(relevanty), max(relevanty)))\n\n        if self.zero_at_efermi:\n            ylim = plt.ylim()\n            plt.plot([0, 0], ylim, 'k--', linewidth=2)\n\n        plt.xlabel('Energies (eV)')\n        plt.ylabel('Density of states')\n\n        plt.legend()\n        leg = plt.gca().get_legend()\n        ltext = leg.get_texts()  # all the text.Text instance in the legend\n        plt.setp(ltext, fontsize=30)\n        plt.tight_layout()\n        return plt"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the data nicely formatted for a plot.", "response": "def bs_plot_data(self, zero_to_efermi=True):\n\n        \"\"\"\n        Get the data nicely formatted for a plot\n\n        Args:\n            zero_to_efermi: Automatically subtract off the Fermi energy from the\n                eigenvalues and plot.\n\n        Returns:\n            dict: A dictionary of the following format:\n            ticks: A dict with the 'distances' at which there is a kpoint (the\n            x axis) and the labels (None if no label).\n            energy: A dict storing bands for spin up and spin down data\n            [{Spin:[band_index][k_point_index]}] as a list (one element\n            for each branch) of energy for each kpoint. The data is\n            stored by branch to facilitate the plotting.\n            vbm: A list of tuples (distance,energy) marking the vbms. The\n            energies are shifted with respect to the fermi level is the\n            option has been selected.\n            cbm: A list of tuples (distance,energy) marking the cbms. The\n            energies are shifted with respect to the fermi level is the\n            option has been selected.\n            lattice: The reciprocal lattice.\n            zero_energy: This is the energy used as zero for the plot.\n            band_gap:A string indicating the band gap and its nature (empty if\n            it's a metal).\n            is_metal: True if the band structure is metallic (i.e., there is at\n            least one band crossing the fermi level).\n        \"\"\"\n        distance = []\n        energy = []\n        if self._bs.is_metal():\n            zero_energy = self._bs.efermi\n        else:\n            zero_energy = self._bs.get_vbm()['energy']\n\n        if not zero_to_efermi:\n            zero_energy = 0.0\n\n        for b in self._bs.branches:\n\n            if self._bs.is_spin_polarized:\n                energy.append({str(Spin.up): [], str(Spin.down): []})\n            else:\n                energy.append({str(Spin.up): []})\n            distance.append([self._bs.distance[j]\n                             for j in range(b['start_index'],\n                                            b['end_index'] + 1)])\n            ticks = self.get_ticks()\n\n            for i in range(self._nb_bands):\n                energy[-1][str(Spin.up)].append(\n                    [self._bs.bands[Spin.up][i][j] - zero_energy\n                     for j in range(b['start_index'], b['end_index'] + 1)])\n            if self._bs.is_spin_polarized:\n                for i in range(self._nb_bands):\n                    energy[-1][str(Spin.down)].append(\n                        [self._bs.bands[Spin.down][i][j] - zero_energy\n                         for j in range(b['start_index'], b['end_index'] + 1)])\n\n        vbm = self._bs.get_vbm()\n        cbm = self._bs.get_cbm()\n\n        vbm_plot = []\n        cbm_plot = []\n\n        for index in cbm['kpoint_index']:\n            cbm_plot.append((self._bs.distance[index],\n                             cbm['energy'] - zero_energy if zero_to_efermi\n                             else cbm['energy']))\n\n        for index in vbm['kpoint_index']:\n            vbm_plot.append((self._bs.distance[index],\n                             vbm['energy'] - zero_energy if zero_to_efermi\n                             else vbm['energy']))\n\n        bg = self._bs.get_band_gap()\n        direct = \"Indirect\"\n        if bg['direct']:\n            direct = \"Direct\"\n\n        return {'ticks': ticks, 'distances': distance, 'energy': energy,\n                'vbm': vbm_plot, 'cbm': cbm_plot,\n                'lattice': self._bs.lattice_rec.as_dict(),\n                'zero_energy': zero_energy, 'is_metal': self._bs.is_metal(),\n                'band_gap': \"{} {} bandgap = {}\".format(direct,\n                                                        bg['transition'],\n                                                        bg['energy'])\n                if not self._bs.is_metal() else \"\"}"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_plot(self, zero_to_efermi=True, ylim=None, smooth=False,\n                 vbm_cbm_marker=False, smooth_tol=None):\n        \"\"\"\n        Get a matplotlib object for the bandstructure plot.\n        Blue lines are up spin, red lines are down\n        spin.\n\n        Args:\n            zero_to_efermi: Automatically subtract off the Fermi energy from\n                the eigenvalues and plot (E-Ef).\n            ylim: Specify the y-axis (energy) limits; by default None let\n                the code choose. It is vbm-4 and cbm+4 if insulator\n                efermi-10 and efermi+10 if metal\n            smooth: interpolates the bands by a spline cubic\n            smooth_tol (float) : tolerance for fitting spline to band data.\n                Default is None such that no tolerance will be used.\n        \"\"\"\n        plt = pretty_plot(12, 8)\n        from matplotlib import rc\n        import scipy.interpolate as scint\n\n        # main internal config options\n        e_min = -4\n        e_max = 4\n        if self._bs.is_metal():\n            e_min = -10\n            e_max = 10\n        # band_linewidth = 3\n        band_linewidth = 1\n\n        data = self.bs_plot_data(zero_to_efermi)\n        if not smooth:\n            for d in range(len(data['distances'])):\n                for i in range(self._nb_bands):\n                    plt.plot(data['distances'][d],\n                             [data['energy'][d][str(Spin.up)][i][j]\n                              for j in range(len(data['distances'][d]))], 'b-',\n                             linewidth=band_linewidth)\n                    if self._bs.is_spin_polarized:\n                        plt.plot(data['distances'][d],\n                                 [data['energy'][d][str(Spin.down)][i][j]\n                                  for j in range(len(data['distances'][d]))],\n                                 'r--', linewidth=band_linewidth)\n        else:\n            # Interpolation failure can be caused by trying to fit an entire\n            # band with one spline rather than fitting with piecewise splines\n            # (splines are ill-suited to fit discontinuities).\n            #\n            # The number of splines used to fit a band is determined by the \n            # number of branches (high symmetry lines) defined in the \n            # BandStructureSymmLine object (see BandStructureSymmLine._branches). \n\n            warning = \"WARNING! Distance / branch {d}, band {i} cannot be \" + \\\n                      \"interpolated.\\n\" + \\\n                      \"See full warning in source.\\n\" + \\\n                      \"If this is not a mistake, try increasing \" + \\\n                      \"smooth_tol.\\nCurrent smooth_tol is {s}.\"\n\n            for d in range(len(data['distances'])):\n                for i in range(self._nb_bands):\n                    tck = scint.splrep(\n                        data['distances'][d],\n                        [data['energy'][d][str(Spin.up)][i][j]\n                         for j in range(len(data['distances'][d]))],\n                        s=smooth_tol)\n                    step = (data['distances'][d][-1]\n                            - data['distances'][d][0]) / 1000\n\n                    xs = [x * step + data['distances'][d][0]\n                          for x in range(1000)]\n\n                    ys = [scint.splev(x * step + data['distances'][d][0],\n                                      tck, der=0)\n                          for x in range(1000)]\n\n                    for y in ys:\n                        if np.isnan(y):\n                            print(warning.format(d=str(d), i=str(i),\n                                                 s=str(smooth_tol)))\n                            break\n\n                    plt.plot(xs, ys, 'b-', linewidth=band_linewidth)\n\n                    if self._bs.is_spin_polarized:\n                        tck = scint.splrep(\n                            data['distances'][d],\n                            [data['energy'][d][str(Spin.down)][i][j]\n                             for j in range(len(data['distances'][d]))],\n                            s=smooth_tol)\n                        step = (data['distances'][d][-1]\n                                - data['distances'][d][0]) / 1000\n\n                        xs = [x * step + data['distances'][d][0]\n                              for x in range(1000)]\n\n                        ys = [scint.splev(\n                            x * step + data['distances'][d][0],\n                            tck, der=0)\n                            for x in range(1000)]\n\n                        for y in ys:\n                            if np.isnan(y):\n                                print(warning.format(d=str(d), i=str(i),\n                                                     s=str(smooth_tol)))\n                                break\n\n                        plt.plot(xs, ys, 'r--', linewidth=band_linewidth)\n\n        self._maketicks(plt)\n\n        # Main X and Y Labels\n        plt.xlabel(r'$\\mathrm{Wave\\ Vector}$', fontsize=30)\n        ylabel = r'$\\mathrm{E\\ -\\ E_f\\ (eV)}$' if zero_to_efermi \\\n            else r'$\\mathrm{Energy\\ (eV)}$'\n        plt.ylabel(ylabel, fontsize=30)\n\n        # Draw Fermi energy, only if not the zero\n        if not zero_to_efermi:\n            ef = self._bs.efermi\n            plt.axhline(ef, linewidth=2, color='k')\n\n        # X range (K)\n        # last distance point\n        x_max = data['distances'][-1][-1]\n        plt.xlim(0, x_max)\n\n        if ylim is None:\n            if self._bs.is_metal():\n                # Plot A Metal\n                if zero_to_efermi:\n                    plt.ylim(e_min, e_max)\n                else:\n                    plt.ylim(self._bs.efermi + e_min, self._bs.efermi + e_max)\n            else:\n                if vbm_cbm_marker:\n                    for cbm in data['cbm']:\n                        plt.scatter(cbm[0], cbm[1], color='r', marker='o',\n                                    s=100)\n                    for vbm in data['vbm']:\n                        plt.scatter(vbm[0], vbm[1], color='g', marker='o',\n                                    s=100)\n                plt.ylim(data['vbm'][0][1] + e_min,\n                         data['cbm'][0][1] + e_max)\n        else:\n            plt.ylim(ylim)\n            if not self._bs.is_metal() and vbm_cbm_marker:\n                for cbm in data['cbm']:\n                        plt.scatter(cbm[0], cbm[1], color='r', marker='o',\n                                    s=100)\n                for vbm in data['vbm']:\n                        plt.scatter(vbm[0], vbm[1], color='g', marker='o',\n                                    s=100)\n\n        plt.tight_layout()\n\n        return plt", "response": "Returns a matplotlib object for the bandstructure plot."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef show(self, zero_to_efermi=True, ylim=None, smooth=False,\n             smooth_tol=None):\n        \"\"\"\n        Show the plot using matplotlib.\n\n        Args:\n            zero_to_efermi: Automatically subtract off the Fermi energy from\n                the eigenvalues and plot (E-Ef).\n            ylim: Specify the y-axis (energy) limits; by default None let\n                the code choose. It is vbm-4 and cbm+4 if insulator\n                efermi-10 and efermi+10 if metal\n            smooth: interpolates the bands by a spline cubic\n            smooth_tol (float) : tolerance for fitting spline to band data.\n                Default is None such that no tolerance will be used.\n        \"\"\"\n        plt = self.get_plot(zero_to_efermi, ylim, smooth)\n        plt.show()", "response": "Show the plot of the metal\n            using matplotlib."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef save_plot(self, filename, img_format=\"eps\", ylim=None,\n                  zero_to_efermi=True, smooth=False):\n        \"\"\"\n        Save matplotlib plot to a file.\n\n        Args:\n            filename: Filename to write to.\n            img_format: Image format to use. Defaults to EPS.\n            ylim: Specifies the y-axis limits.\n        \"\"\"\n        plt = self.get_plot(ylim=ylim, zero_to_efermi=zero_to_efermi,\n                            smooth=smooth)\n        plt.savefig(filename, format=img_format)\n        plt.close()", "response": "Save matplotlib plot to a file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nplot two band structure for comparison. One is in red the other in blue (no difference in spins). The two band structures need to be defined on the same symmetry lines! and the distance between symmetry lines is the one of the band structure used to build the BSPlotter Args: another band structure object defined along the same symmetry lines Returns: a matplotlib object with both band structures", "response": "def plot_compare(self, other_plotter, legend=True):\n        \"\"\"\n        plot two band structure for comparison. One is in red the other in blue\n        (no difference in spins). The two band structures need to be defined\n        on the same symmetry lines! and the distance between symmetry lines is\n        the one of the band structure used to build the BSPlotter\n\n        Args:\n            another band structure object defined along the same symmetry lines\n\n        Returns:\n            a matplotlib object with both band structures\n\n        \"\"\"\n        # TODO: add exception if the band structures are not compatible\n        import matplotlib.lines as mlines\n        plt = self.get_plot()\n        data_orig = self.bs_plot_data()\n        data = other_plotter.bs_plot_data()\n        band_linewidth = 1\n        for i in range(other_plotter._nb_bands):\n            for d in range(len(data_orig['distances'])):\n                plt.plot(data_orig['distances'][d],\n                         [e[str(Spin.up)][i] for e in data['energy']][d],\n                         'c-', linewidth=band_linewidth)\n                if other_plotter._bs.is_spin_polarized:\n                    plt.plot(data_orig['distances'][d],\n                             [e[str(Spin.down)][i] for e in data['energy']][d],\n                             'm--', linewidth=band_linewidth)\n        if legend:\n            handles = [mlines.Line2D([], [], linewidth=2,\n                                     color='b', label='bs 1 up'),\n                       mlines.Line2D([], [], linewidth=2,\n                                     color='r', label='bs 1 down',\n                                     linestyle=\"--\"),\n                       mlines.Line2D([], [], linewidth=2,\n                                     color='c', label='bs 2 up'),\n                       mlines.Line2D([], [], linewidth=2,\n                                     color='m', linestyle=\"--\",\n                                     label='bs 2 down')]\n\n            plt.legend(handles=handles)\n        return plt"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef plot_brillouin(self):\n\n        # get labels and lines\n        labels = {}\n        for k in self._bs.kpoints:\n            if k.label:\n                labels[k.label] = k.frac_coords\n\n        lines = []\n        for b in self._bs.branches:\n            lines.append([self._bs.kpoints[b['start_index']].frac_coords,\n                          self._bs.kpoints[b['end_index']].frac_coords])\n\n        plot_brillouin_zone(self._bs.lattice_rec, lines=lines, labels=labels)", "response": "Plot the Brillouin zone."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_projected_plots_dots(self, dictio, zero_to_efermi=True, ylim=None,\n                                 vbm_cbm_marker=False):\n        \"\"\"\n        Method returning a plot composed of subplots along different elements\n        and orbitals.\n\n        Args:\n            dictio: The element and orbitals you want a projection on. The\n                format is {Element:[Orbitals]} for instance\n                {'Cu':['d','s'],'O':['p']} will give projections for Cu on\n                d and s orbitals and on oxygen p.\n                If you use this class to plot LobsterBandStructureSymmLine,\n                the orbitals are named as in the FATBAND filename, e.g.\n                \"2p\" or \"2p_x\"\n\n        Returns:\n            a pylab object with different subfigures for each projection\n            The blue and red colors are for spin up and spin down.\n            The bigger the red or blue dot in the band structure the higher\n            character for the corresponding element and orbital.\n        \"\"\"\n        band_linewidth = 1.0\n        fig_number = sum([len(v) for v in dictio.values()])\n        proj = self._get_projections_by_branches(dictio)\n        data = self.bs_plot_data(zero_to_efermi)\n        plt = pretty_plot(12, 8)\n        e_min = -4\n        e_max = 4\n        if self._bs.is_metal():\n            e_min = -10\n            e_max = 10\n        count = 1\n\n        for el in dictio:\n            for o in dictio[el]:\n                plt.subplot(100 * math.ceil(fig_number / 2) + 20 + count)\n                self._maketicks(plt)\n                for b in range(len(data['distances'])):\n                    for i in range(self._nb_bands):\n                        plt.plot(data['distances'][b],\n                                 [data['energy'][b][str(Spin.up)][i][j]\n                                  for j in range(len(data['distances'][b]))],\n                                 'b-',\n                                 linewidth=band_linewidth)\n                        if self._bs.is_spin_polarized:\n                            plt.plot(data['distances'][b],\n                                     [data['energy'][b][str(Spin.down)][i][j]\n                                      for j in\n                                      range(len(data['distances'][b]))],\n                                     'r--', linewidth=band_linewidth)\n                            for j in range(\n                                    len(data['energy'][b][str(Spin.up)][i])):\n                                plt.plot(data['distances'][b][j],\n                                         data['energy'][b][str(Spin.down)][i][\n                                             j], 'ro',\n                                         markersize=\n                                         proj[b][str(Spin.down)][i][j][str(el)][\n                                             o] * 15.0)\n                        for j in range(len(data['energy'][b][str(Spin.up)][i])):\n                            plt.plot(data['distances'][b][j],\n                                     data['energy'][b][str(Spin.up)][i][j],\n                                     'bo',\n                                     markersize=\n                                     proj[b][str(Spin.up)][i][j][str(el)][\n                                         o] * 15.0)\n                if ylim is None:\n                    if self._bs.is_metal():\n                        if zero_to_efermi:\n                            plt.ylim(e_min, e_max)\n                        else:\n                            plt.ylim(self._bs.efermi + e_min, self._bs.efermi\n                                     + e_max)\n                    else:\n                        if vbm_cbm_marker:\n                            for cbm in data['cbm']:\n                                plt.scatter(cbm[0], cbm[1], color='r',\n                                            marker='o',\n                                            s=100)\n\n                            for vbm in data['vbm']:\n                                plt.scatter(vbm[0], vbm[1], color='g',\n                                            marker='o',\n                                            s=100)\n\n                        plt.ylim(data['vbm'][0][1] + e_min, data['cbm'][0][1]\n                                 + e_max)\n                else:\n                    plt.ylim(ylim)\n                plt.title(str(el) + \" \" + str(o))\n                count += 1\n        return plt", "response": "Method returning a pylab object with the plotted data along different elements and orbitals."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_elt_projected_plots(self, zero_to_efermi=True, ylim=None,\n                                vbm_cbm_marker=False):\n        \"\"\"\n        Method returning a plot composed of subplots along different elements\n\n        Returns:\n            a pylab object with different subfigures for each projection\n            The blue and red colors are for spin up and spin down\n            The bigger the red or blue dot in the band structure the higher\n            character for the corresponding element and orbital\n        \"\"\"\n        band_linewidth = 1.0\n        proj = self._get_projections_by_branches({e.symbol: ['s', 'p', 'd']\n                                                  for e in\n                                                  self._bs.structure.composition.elements})\n        data = self.bs_plot_data(zero_to_efermi)\n        plt = pretty_plot(12, 8)\n        e_min = -4\n        e_max = 4\n        if self._bs.is_metal():\n            e_min = -10\n            e_max = 10\n        count = 1\n        for el in self._bs.structure.composition.elements:\n            plt.subplot(220 + count)\n            self._maketicks(plt)\n            for b in range(len(data['distances'])):\n                for i in range(self._nb_bands):\n                    plt.plot(data['distances'][b],\n                             [data['energy'][b][str(Spin.up)][i][j]\n                              for j in range(len(data['distances'][b]))], '-',\n                             color=[192 / 255, 192 / 255, 192 / 255],\n                             linewidth=band_linewidth)\n                    if self._bs.is_spin_polarized:\n                        plt.plot(data['distances'][b],\n                                 [data['energy'][b][str(Spin.down)][i][j]\n                                  for j in range(len(data['distances'][b]))],\n                                 '--', color=[128 / 255, 128 / 255, 128 / 255],\n                                 linewidth=band_linewidth)\n                        for j in range(len(data['energy'][b][str(Spin.up)][i])):\n                            markerscale = sum([proj[b][str(Spin.down)][i][\n                                                   j][str(el)][o] for o in\n                                               proj[b]\n                                               [str(Spin.down)][i][j][\n                                                   str(el)]])\n                            plt.plot(data['distances'][b][j],\n                                     data['energy'][b][str(Spin.down)][i][j],\n                                     'bo',\n                                     markersize=markerscale * 15.0,\n                                     color=[markerscale, 0.3 * markerscale,\n                                            0.4 * markerscale])\n                    for j in range(len(data['energy'][b][str(Spin.up)][i])):\n                        markerscale = sum(\n                            [proj[b][str(Spin.up)][i][j][str(el)][o]\n                             for o in proj[b]\n                             [str(Spin.up)][i][j][str(el)]])\n                        plt.plot(data['distances'][b][j],\n                                 data['energy'][b][str(Spin.up)][i][j], 'o',\n                                 markersize=markerscale * 15.0,\n                                 color=[markerscale, 0.3 * markerscale,\n                                        0.4 * markerscale])\n            if ylim is None:\n                if self._bs.is_metal():\n                    if zero_to_efermi:\n                        plt.ylim(e_min, e_max)\n                    else:\n                        plt.ylim(self._bs.efermi + e_min, self._bs.efermi\n                                 + e_max)\n                else:\n                    if vbm_cbm_marker:\n                        for cbm in data['cbm']:\n                            plt.scatter(cbm[0], cbm[1], color='r', marker='o',\n                                        s=100)\n\n                        for vbm in data['vbm']:\n                            plt.scatter(vbm[0], vbm[1], color='g', marker='o',\n                                        s=100)\n\n                    plt.ylim(data['vbm'][0][1] + e_min, data['cbm'][0][1]\n                             + e_max)\n            else:\n                plt.ylim(ylim)\n            plt.title(str(el))\n            count += 1\n\n        return plt", "response": "Method returning a pylab object with different subfigures for each element and orbital."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_elt_projected_plots_color(self, zero_to_efermi=True,\n                                      elt_ordered=None):\n        \"\"\"\n        returns a pylab plot object with one plot where the band structure\n        line color depends on the character of the band (along different\n        elements). Each element is associated with red, green or blue\n        and the corresponding rgb color depending on the character of the band\n        is used. The method can only deal with binary and ternary compounds\n\n        spin up and spin down are differientiated by a '-' and a '--' line\n\n        Args:\n            elt_ordered: A list of Element ordered. The first one is red,\n                second green, last blue\n\n        Returns:\n            a pylab object\n\n        \"\"\"\n        band_linewidth = 3.0\n        if len(self._bs.structure.composition.elements) > 3:\n            raise ValueError\n        if elt_ordered is None:\n            elt_ordered = self._bs.structure.composition.elements\n        proj = self._get_projections_by_branches(\n            {e.symbol: ['s', 'p', 'd']\n             for e in self._bs.structure.composition.elements})\n        data = self.bs_plot_data(zero_to_efermi)\n        plt = pretty_plot(12, 8)\n\n        spins = [Spin.up]\n        if self._bs.is_spin_polarized:\n            spins = [Spin.up, Spin.down]\n        self._maketicks(plt)\n        for s in spins:\n            for b in range(len(data['distances'])):\n                for i in range(self._nb_bands):\n                    for j in range(len(data['energy'][b][str(s)][i]) - 1):\n                        sum_e = 0.0\n                        for el in elt_ordered:\n                            sum_e = sum_e + \\\n                                    sum([proj[b][str(s)][i][j][str(el)][o]\n                                         for o\n                                         in proj[b][str(s)][i][j][str(el)]])\n                        if sum_e == 0.0:\n                            color = [0.0] * len(elt_ordered)\n                        else:\n                            color = [sum([proj[b][str(s)][i][j][str(el)][o]\n                                          for o\n                                          in proj[b][str(s)][i][j][str(el)]])\n                                     / sum_e\n                                     for el in elt_ordered]\n                        if len(color) == 2:\n                            color.append(0.0)\n                            color[2] = color[1]\n                            color[1] = 0.0\n                        sign = '-'\n                        if s == Spin.down:\n                            sign = '--'\n                        plt.plot([data['distances'][b][j],\n                                  data['distances'][b][j + 1]],\n                                 [data['energy'][b][str(s)][i][j],\n                                  data['energy'][b][str(s)][i][j + 1]], sign,\n                                 color=color, linewidth=band_linewidth)\n\n        if self._bs.is_metal():\n            if zero_to_efermi:\n                e_min = -10\n                e_max = 10\n                plt.ylim(e_min, e_max)\n                plt.ylim(self._bs.efermi + e_min, self._bs.efermi + e_max)\n        else:\n            plt.ylim(data['vbm'][0][1] - 4.0, data['cbm'][0][1] + 2.0)\n        return plt", "response": "Returns a pylab plot object with one plot where the band structure contains the color of each element."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_projected_plots_dots_patom_pmorb(self, dictio, dictpa,\n                                             sum_atoms=None, sum_morbs=None,\n                                             zero_to_efermi=True, ylim=None,\n                                             vbm_cbm_marker=False,\n                                             selected_branches=None,\n                                             w_h_size=(12, 8), num_column=None):\n        \"\"\"\n        Method returns a plot composed of subplots for different atoms and\n        orbitals (subshell orbitals such as 's', 'p', 'd' and 'f' defined by\n        azimuthal quantum numbers l = 0, 1, 2 and 3, respectively or\n        individual orbitals like 'px', 'py' and 'pz' defined by magnetic\n        quantum numbers m = -1, 1 and 0, respectively).\n        This is an extension of \"get_projected_plots_dots\" method.\n\n        Args:\n            dictio: The elements and the orbitals you need to project on. The\n                format is {Element:[Orbitals]}, for instance:\n                {'Cu':['dxy','s','px'],'O':['px','py','pz']} will give\n                projections for Cu on orbitals dxy, s, px and\n                for O on orbitals px, py, pz. If you want to sum over all\n                individual orbitals of subshell orbitals,\n                for example, 'px', 'py' and 'pz' of O, just simply set\n                {'Cu':['dxy','s','px'],'O':['p']} and set sum_morbs (see\n                explanations below) as {'O':[p],...}.\n                Otherwise, you will get an error.\n            dictpa: The elements and their sites (defined by site numbers) you\n                need to project on. The format is\n                {Element: [Site numbers]}, for instance: {'Cu':[1,5],'O':[3,4]}\n                will give projections for Cu on site-1\n                and on site-5, O on site-3 and on site-4 in the cell.\n                Attention:\n                The correct site numbers of atoms are consistent with\n                themselves in the structure computed. Normally,\n                the structure should be totally similar with POSCAR file,\n                however, sometimes VASP can rotate or\n                translate the cell. Thus, it would be safe if using Vasprun\n                class to get the final_structure and as a\n                result, correct index numbers of atoms.\n            sum_atoms: Sum projection of the similar atoms together (e.g.: Cu\n                on site-1 and Cu on site-5). The format is\n                {Element: [Site numbers]}, for instance:\n                 {'Cu': [1,5], 'O': [3,4]} means summing projections over Cu on\n                 site-1 and Cu on site-5 and O on site-3\n                 and on site-4. If you do not want to use this functional, just\n                 turn it off by setting sum_atoms = None.\n            sum_morbs: Sum projections of individual orbitals of similar atoms\n                together (e.g.: 'dxy' and 'dxz'). The\n                format is {Element: [individual orbitals]}, for instance:\n                {'Cu': ['dxy', 'dxz'], 'O': ['px', 'py']} means summing\n                projections over 'dxy' and 'dxz' of Cu and 'px'\n                and 'py' of O. If you do not want to use this functional, just\n                turn it off by setting sum_morbs = None.\n            selected_branches: The index of symmetry lines you chose for\n                plotting. This can be useful when the number of\n                symmetry lines (in KPOINTS file) are manny while you only want\n                to show for certain ones. The format is\n                [index of line], for instance:\n                [1, 3, 4] means you just need to do projection along lines\n                number 1, 3 and 4 while neglecting lines\n                number 2 and so on. By default, this is None type and all\n                symmetry lines will be plotted.\n            w_h_size: This variable help you to control the width and height\n                of figure. By default, width = 12 and\n                height = 8 (inches). The width/height ratio is kept the same\n                for subfigures and the size of each depends\n                on how many number of subfigures are plotted.\n            num_column: This variable help you to manage how the subfigures are\n                arranged in the figure by setting\n                up the number of columns of subfigures. The value should be an\n                int number. For example, num_column = 3\n                means you want to plot subfigures in 3 columns. By default,\n                num_column = None and subfigures are\n                aligned in 2 columns.\n\n        Returns:\n            A pylab object with different subfigures for different projections.\n            The blue and red colors lines are bands\n            for spin up and spin down. The green and cyan dots are projections\n            for spin up and spin down. The bigger\n            the green or cyan dots in the projected band structures, the higher\n            character for the corresponding elements\n            and orbitals. List of individual orbitals and their numbers (set up\n            by VASP and no special meaning):\n            s = 0; py = 1 pz = 2 px = 3; dxy = 4 dyz = 5 dz2 = 6 dxz = 7 dx2 = 8;\n            f_3 = 9 f_2 = 10 f_1 = 11 f0 = 12 f1 = 13 f2 = 14 f3 = 15\n        \"\"\"\n        dictio, sum_morbs = self._Orbitals_SumOrbitals(dictio, sum_morbs)\n        dictpa, sum_atoms, number_figs = self._number_of_subfigures(dictio,\n                                                                    dictpa,\n                                                                    sum_atoms,\n                                                                    sum_morbs)\n        print('Number of subfigures: %s' % str(number_figs))\n        if number_figs > 9:\n            print(\n                \"The number of sub-figures %s might be too manny and the implementation might take a long time.\\n\"\n                \"A smaller number or a plot with selected symmetry lines (selected_branches) might be better.\\n\"\n                % str(number_figs))\n        import math\n        from pymatgen.util.plotting import pretty_plot\n        band_linewidth = 0.5\n        plt = pretty_plot(w_h_size[0], w_h_size[1])\n        proj_br_d, dictio_d, dictpa_d, branches = self._get_projections_by_branches_patom_pmorb(\n            dictio, dictpa,\n            sum_atoms, sum_morbs, selected_branches)\n        data = self.bs_plot_data(zero_to_efermi)\n        e_min = -4\n        e_max = 4\n        if self._bs.is_metal():\n            e_min = -10\n            e_max = 10\n\n        count = 0\n        for elt in dictpa_d:\n            for numa in dictpa_d[elt]:\n                for o in dictio_d[elt]:\n\n                    count += 1\n                    if num_column is None:\n                        if number_figs == 1:\n                            plt.subplot(1, 1, 1)\n                        else:\n                            row = number_figs / 2\n                            if number_figs % 2 == 0:\n                                plt.subplot(row, 2, count)\n                            else:\n                                plt.subplot(row + 1, 2, count)\n                    elif isinstance(num_column, int):\n                        row = number_figs / num_column\n                        if number_figs % num_column == 0:\n                            plt.subplot(row, num_column, count)\n                        else:\n                            plt.subplot(row + 1, num_column, count)\n                    else:\n                        raise ValueError(\n                            \"The invalid 'num_column' is assigned. It should be an integer.\")\n\n                    plt, shift = self._maketicks_selected(plt, branches)\n                    br = -1\n                    for b in branches:\n                        br += 1\n                        for i in range(self._nb_bands):\n                            plt.plot(list(map(lambda x: x - shift[br], data['distances'][b])),\n                                     [data['energy'][b][str(Spin.up)][i][j]\n                                      for j in\n                                      range(len(data['distances'][b]))],\n                                     'b-', linewidth=band_linewidth)\n\n                            if self._bs.is_spin_polarized:\n                                plt.plot(list(map(lambda x: x - shift[br], data['distances'][b])),\n                                         [data['energy'][b][str(Spin.down)][i][\n                                              j]\n                                          for j in\n                                          range(len(data['distances'][b]))],\n                                         'r--', linewidth=band_linewidth)\n                                for j in range(len(\n                                        data['energy'][b][str(Spin.up)][i])):\n                                    plt.plot(\n                                        data['distances'][b][j] - shift[br],\n                                        data['energy'][b][str(Spin.down)][i][j],\n                                        'co', markersize= \\\n                                            proj_br_d[br][str(Spin.down)][i][j][\n                                                elt + numa][o] * 15.0)\n\n                            for j in range(\n                                    len(data['energy'][b][str(Spin.up)][i])):\n                                plt.plot(data['distances'][b][j] - shift[br],\n                                         data['energy'][b][str(Spin.up)][i][j],\n                                         'go', markersize= \\\n                                             proj_br_d[br][str(Spin.up)][i][j][\n                                                 elt + numa][o] * 15.0)\n\n                    if ylim is None:\n                        if self._bs.is_metal():\n                            if zero_to_efermi:\n                                plt.ylim(e_min, e_max)\n                            else:\n                                plt.ylim(self._bs.efermi + e_min,\n                                         self._bs._efermi\n                                         + e_max)\n                        else:\n                            if vbm_cbm_marker:\n                                for cbm in data['cbm']:\n                                    plt.scatter(cbm[0], cbm[1], color='r',\n                                                marker='o',\n                                                s=100)\n\n                                for vbm in data['vbm']:\n                                    plt.scatter(vbm[0], vbm[1], color='g',\n                                                marker='o',\n                                                s=100)\n\n                            plt.ylim(data['vbm'][0][1] + e_min,\n                                     data['cbm'][0][1]\n                                     + e_max)\n                    else:\n                        plt.ylim(ylim)\n                    plt.title(elt + \" \" + numa + \" \" + str(o))\n\n        return plt", "response": "Method returns a list of plot composed of subplots for different atoms and orbitals."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_plot(self, bs, dos=None):\n        import matplotlib.lines as mlines\n        from matplotlib.gridspec import GridSpec\n        import matplotlib.pyplot as mplt\n\n        # make sure the user-specified band structure projection is valid\n        bs_projection = self.bs_projection\n        if dos:\n            elements = [e.symbol for e in dos.structure.composition.elements]\n        elif bs_projection and bs.structure:\n            elements = [e.symbol for e in bs.structure.composition.elements]\n        else:\n            elements = []\n\n        rgb_legend = self.rgb_legend and bs_projection and \\\n                     bs_projection.lower() == \"elements\" and \\\n                     len(elements) in [2, 3]\n\n        if bs_projection and bs_projection.lower() == \"elements\" and \\\n                (len(elements) not in [2, 3] or\n                     not bs.get_projection_on_elements()):\n            warnings.warn(\n                \"Cannot get element projected data; either the projection data \"\n                \"doesn't exist, or you don't have a compound with exactly 2 \"\n                \"or 3 unique elements.\")\n            bs_projection = None\n\n        # specify energy range of plot\n        emin = -self.vb_energy_range\n        emax = self.cb_energy_range if self.fixed_cb_energy else \\\n            self.cb_energy_range + bs.get_band_gap()[\"energy\"]\n\n        # initialize all the k-point labels and k-point x-distances for bs plot\n        xlabels = []  # all symmetry point labels on x-axis\n        xlabel_distances = []  # positions of symmetry point x-labels\n        x_distances = []  # x positions of kpoint data\n        prev_right_klabel = None  # used to determine which branches require a midline separator\n\n        for idx, l in enumerate(bs.branches):\n            # get left and right kpoint labels of this branch\n            left_k, right_k = l[\"name\"].split(\"-\")\n\n            # add $ notation for LaTeX kpoint labels\n            if left_k[0] == \"\\\\\" or \"_\" in left_k:\n                left_k = \"$\" + left_k + \"$\"\n            if right_k[0] == \"\\\\\" or \"_\" in right_k:\n                right_k = \"$\" + right_k + \"$\"\n\n            # add left k label to list of labels\n            if prev_right_klabel is None:\n                xlabels.append(left_k)\n                xlabel_distances.append(0)\n            elif prev_right_klabel != left_k:  # used for pipe separator\n                xlabels[-1] = xlabels[-1] + \"$\\\\mid$ \" + left_k\n\n            # add right k label to list of labels\n            xlabels.append(right_k)\n            prev_right_klabel = right_k\n\n            # add x-coordinates for labels\n            left_kpoint = bs.kpoints[l[\"start_index\"]].cart_coords\n            right_kpoint = bs.kpoints[l[\"end_index\"]].cart_coords\n            distance = np.linalg.norm(right_kpoint - left_kpoint)\n            xlabel_distances.append(xlabel_distances[-1] + distance)\n\n            # add x-coordinates for kpoint data\n            npts = l[\"end_index\"] - l[\"start_index\"]\n            distance_interval = distance / npts\n            x_distances.append(xlabel_distances[-2])\n            for i in range(npts):\n                x_distances.append(x_distances[-1] + distance_interval)\n\n        # set up bs and dos plot\n        gs = GridSpec(1, 2, width_ratios=[2, 1]) if dos else GridSpec(1, 1)\n\n        fig = mplt.figure(figsize=self.fig_size)\n        fig.patch.set_facecolor('white')\n        bs_ax = mplt.subplot(gs[0])\n        if dos:\n            dos_ax = mplt.subplot(gs[1])\n\n        # set basic axes limits for the plot\n        bs_ax.set_xlim(0, x_distances[-1])\n        bs_ax.set_ylim(emin, emax)\n        if dos:\n            dos_ax.set_ylim(emin, emax)\n\n        # add BS xticks, labels, etc.\n        bs_ax.set_xticks(xlabel_distances)\n        bs_ax.set_xticklabels(xlabels, size=self.tick_fontsize)\n        bs_ax.set_xlabel('Wavevector $k$', fontsize=self.axis_fontsize,\n                         family=self.font)\n        bs_ax.set_ylabel('$E-E_F$ / eV', fontsize=self.axis_fontsize,\n                         family=self.font)\n\n        # add BS fermi level line at E=0 and gridlines\n        bs_ax.hlines(y=0, xmin=0, xmax=x_distances[-1], color=\"k\", lw=2)\n        bs_ax.set_yticks(np.arange(emin, emax + 1E-5, self.egrid_interval))\n        bs_ax.set_yticklabels(np.arange(emin, emax + 1E-5, self.egrid_interval),\n                              size=self.tick_fontsize)\n        bs_ax.set_axisbelow(True)\n        bs_ax.grid(color=[0.5, 0.5, 0.5], linestyle='dotted', linewidth=1)\n        if dos:\n            dos_ax.set_yticks(np.arange(emin, emax + 1E-5, self.egrid_interval))\n            dos_ax.set_yticklabels([])\n            dos_ax.grid(color=[0.5, 0.5, 0.5], linestyle='dotted', linewidth=1)\n\n        # renormalize the band energy to the Fermi level\n        band_energies = {}\n        for spin in (Spin.up, Spin.down):\n            if spin in bs.bands:\n                band_energies[spin] = []\n                for band in bs.bands[spin]:\n                    band_energies[spin].append([e - bs.efermi for e in band])\n\n        # renormalize the DOS energies to Fermi level\n        if dos:\n            dos_energies = [e - dos.efermi for e in dos.energies]\n\n        # get the projection data to set colors for the band structure\n        colordata = self._get_colordata(bs, elements, bs_projection)\n\n        # plot the colored band structure lines\n        for spin in (Spin.up, Spin.down):\n            if spin in band_energies:\n                linestyles = \"solid\" if spin == Spin.up else \"dotted\"\n                for band_idx, band in enumerate(band_energies[spin]):\n                    self._rgbline(bs_ax, x_distances, band,\n                                  colordata[spin][band_idx, :, 0],\n                                  colordata[spin][band_idx, :, 1],\n                                  colordata[spin][band_idx, :, 2],\n                                  linestyles=linestyles)\n\n        if dos:\n            # Plot the DOS and projected DOS\n            for spin in (Spin.up, Spin.down):\n                if spin in dos.densities:\n                    # plot the total DOS\n                    dos_densities = dos.densities[spin] * int(spin)\n                    label = \"total\" if spin == Spin.up else None\n                    dos_ax.plot(dos_densities, dos_energies,\n                                color=(0.6, 0.6, 0.6), label=label)\n                    dos_ax.fill_betweenx(dos_energies, 0,dos_densities,\n                                        color=(0.7, 0.7, 0.7),\n                                        facecolor=(0.7, 0.7, 0.7))\n\n                    if self.dos_projection is None:\n                        pass\n\n                    elif self.dos_projection.lower() == \"elements\":\n                        # plot the atom-projected DOS\n                        colors = ['b', 'r', 'g', 'm', 'y', 'c', 'k', 'w']\n                        el_dos = dos.get_element_dos()\n                        for idx, el in enumerate(elements):\n                            dos_densities = el_dos[Element(el)].densities[\n                                                spin] * int(spin)\n                            label = el if spin == Spin.up else None\n                            dos_ax.plot(dos_densities, dos_energies,\n                                        color=colors[idx], label=label)\n\n                    elif self.dos_projection.lower() == \"orbitals\":\n                        # plot each of the atomic projected DOS\n                        colors = ['b', 'r', 'g', 'm']\n                        spd_dos = dos.get_spd_dos()\n                        for idx, orb in enumerate([OrbitalType.s,\n                                                   OrbitalType.p,\n                                                   OrbitalType.d,\n                                                   OrbitalType.f]):\n                            if orb in spd_dos:\n                                dos_densities = spd_dos[orb].densities[spin] * \\\n                                                int(spin)\n                                label = orb if spin == Spin.up else None\n                                dos_ax.plot(dos_densities, dos_energies,\n                                            color=colors[idx], label=label)\n\n            # get index of lowest and highest energy being plotted, used to help auto-scale DOS x-axis\n            emin_idx = next(x[0] for x in enumerate(dos_energies) if\n                            x[1] >= emin)\n            emax_idx = len(dos_energies) - \\\n                       next(x[0] for x in enumerate(reversed(dos_energies))\n                            if x[1] <= emax)\n\n            # determine DOS x-axis range\n            dos_xmin = 0 if Spin.down not in dos.densities else -max(\n                dos.densities[Spin.down][emin_idx:emax_idx + 1] * 1.05)\n            dos_xmax = max([max(dos.densities[Spin.up][emin_idx:emax_idx]) *\n                            1.05, abs(dos_xmin)])\n\n            # set up the DOS x-axis and add Fermi level line\n            dos_ax.set_xlim(dos_xmin, dos_xmax)\n            dos_ax.set_xticklabels([])\n            dos_ax.hlines(y=0, xmin=dos_xmin, xmax=dos_xmax, color=\"k\", lw=2)\n            dos_ax.set_xlabel('DOS', fontsize=self.axis_fontsize,\n                              family=self.font)\n\n        # add legend for band structure\n        if self.bs_legend and not rgb_legend:\n            handles = []\n\n            if bs_projection is None:\n                handles = [mlines.Line2D([], [], linewidth=2,\n                                         color='k', label='spin up'),\n                           mlines.Line2D([], [], linewidth=2,\n                                         color='b', linestyle=\"dotted\",\n                                         label='spin down')]\n\n            elif bs_projection.lower() == \"elements\":\n                colors = ['b', 'r', 'g']\n                for idx, el in enumerate(elements):\n                    handles.append(mlines.Line2D([], [],\n                                                 linewidth=2,\n                                                 color=colors[idx], label=el))\n\n            bs_ax.legend(handles=handles, fancybox=True,\n                         prop={'size': self.legend_fontsize,\n                               'family': self.font}, loc=self.bs_legend)\n\n        elif self.bs_legend and rgb_legend:\n            if len(elements) == 2:\n                self._rb_line(bs_ax, elements[1], elements[0],\n                              loc=self.bs_legend)\n            elif len(elements) == 3:\n                self._rgb_triangle(bs_ax, elements[1], elements[2], elements[0],\n                                   loc=self.bs_legend)\n\n        # add legend for DOS\n        if dos and self.dos_legend:\n            dos_ax.legend(fancybox=True, prop={'size': self.legend_fontsize,\n                                               'family': self.font},\n                          loc=self.dos_legend)\n\n        mplt.subplots_adjust(wspace=0.1)\n        return mplt", "response": "Returns a matplotlib plot object for the specified bandstructure and dos."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate a RGB colored line for plotting.", "response": "def _rgbline(ax, k, e, red, green, blue, alpha=1, linestyles=\"solid\"):\n        \"\"\"\n        An RGB colored line for plotting.\n        creation of segments based on:\n        http://nbviewer.ipython.org/urls/raw.github.com/dpsanders/matplotlib-examples/master/colorline.ipynb\n        Args:\n            ax: matplotlib axis\n            k: x-axis data (k-points)\n            e: y-axis data (energies)\n            red: red data\n            green: green data\n            blue: blue data\n            alpha: alpha values data\n            linestyles: linestyle for plot (e.g., \"solid\" or \"dotted\")\n        \"\"\"\n        from matplotlib.collections import LineCollection\n\n        pts = np.array([k, e]).T.reshape(-1, 1, 2)\n        seg = np.concatenate([pts[:-1], pts[1:]], axis=1)\n\n        nseg = len(k) - 1\n        r = [0.5 * (red[i] + red[i + 1]) for i in range(nseg)]\n        g = [0.5 * (green[i] + green[i + 1]) for i in range(nseg)]\n        b = [0.5 * (blue[i] + blue[i + 1]) for i in range(nseg)]\n        a = np.ones(nseg, np.float) * alpha\n        lc = LineCollection(seg, colors=list(zip(r, g, b, a)),\n                            linewidth=2, linestyles=linestyles)\n        ax.add_collection(lc)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _get_colordata(bs, elements, bs_projection):\n        contribs = {}\n        if bs_projection and bs_projection.lower() == \"elements\":\n            projections = bs.get_projection_on_elements()\n\n        for spin in (Spin.up, Spin.down):\n            if spin in bs.bands:\n                contribs[spin] = []\n                for band_idx in range(bs.nb_bands):\n                    colors = []\n                    for k_idx in range(len(bs.kpoints)):\n                        if bs_projection and bs_projection.lower() == \"elements\":\n                            c = [0, 0, 0]\n                            projs = projections[spin][band_idx][k_idx]\n                            # note: squared color interpolations are smoother\n                            # see: https://youtu.be/LKnqECcg6Gw\n                            projs = dict(\n                                [(k, v ** 2) for k, v in projs.items()])\n                            total = sum(projs.values())\n                            if total > 0:\n                                for idx, e in enumerate(elements):\n                                    c[idx] = math.sqrt(projs[\n                                                           e] / total)  # min is to handle round errors\n\n                            c = [c[1], c[2],\n                                 c[0]]  # prefer blue, then red, then green\n\n                        else:\n                            c = [0, 0, 0] if spin == Spin.up \\\n                                else [0, 0,\n                                      1]  # black for spin up, blue for spin down\n\n                        colors.append(c)\n\n                    contribs[spin].append(colors)\n                contribs[spin] = np.array(contribs[spin])\n\n        return contribs", "response": "Get color data for the given bandstructure object and elements."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _rgb_triangle(ax, r_label, g_label, b_label, loc):\n        if not loc in range(1, 11):\n            loc = 2\n\n        from mpl_toolkits.axes_grid1.inset_locator import inset_axes\n        inset_ax = inset_axes(ax, width=1, height=1, loc=loc)\n        mesh = 35\n        x = []\n        y = []\n        color = []\n        for r in range(0, mesh):\n            for g in range(0, mesh):\n                for b in range(0, mesh):\n                    if not (r == 0 and b == 0 and g == 0):\n                        r1 = r / (r + g + b)\n                        g1 = g / (r + g + b)\n                        b1 = b / (r + g + b)\n                        x.append(0.33 * (2. * g1 + r1) / (r1 + b1 + g1))\n                        y.append(0.33 * np.sqrt(3) * r1 / (r1 + b1 + g1))\n                        rc = math.sqrt(r ** 2 / (r ** 2 + g ** 2 + b ** 2))\n                        gc = math.sqrt(g ** 2 / (r ** 2 + g ** 2 + b ** 2))\n                        bc = math.sqrt(b ** 2 / (r ** 2 + g ** 2 + b ** 2))\n                        color.append([rc, gc, bc])\n\n        # x = [n + 0.25 for n in x]  # nudge x coordinates\n        # y = [n + (max_y - 1) for n in y]  # shift y coordinates to top\n        # plot the triangle\n        inset_ax.scatter(x, y, s=7, marker='.', edgecolor=color)\n        inset_ax.set_xlim([-0.35, 1.00])\n        inset_ax.set_ylim([-0.35, 1.00])\n\n        # add the labels\n        inset_ax.text(0.70, -0.2, g_label, fontsize=13,\n                      family='Times New Roman', color=(0, 0, 0),\n                      horizontalalignment='left')\n        inset_ax.text(0.325, 0.70, r_label, fontsize=13,\n                      family='Times New Roman', color=(0, 0, 0),\n                      horizontalalignment='center')\n        inset_ax.text(-0.05, -0.2, b_label, fontsize=13,\n                      family='Times New Roman', color=(0, 0, 0),\n                      horizontalalignment='right')\n\n        inset_ax.get_xaxis().set_visible(False)\n        inset_ax.get_yaxis().set_visible(False)", "response": "Draw an RGB triangle on the desired axis."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef plot_seebeck_eff_mass_mu(self, temps=[300], output='average',\n                                 Lambda=0.5):\n        \"\"\"\n        Plot respect to the chemical potential of the Seebeck effective mass\n        calculated as explained in Ref.\n        Gibbs, Z. M. et al., Effective mass and fermi surface complexity factor \n        from ab initio band structure calculations. \n        npj Computational Materials 3, 8 (2017).\n\n        Args:\n            output: 'average' returns the seebeck effective mass calculated\n                using the average of the three diagonal components of the\n                seebeck tensor. 'tensor' returns the seebeck effective mass\n                respect to the three diagonal components of the seebeck tensor.\n            temps:  list of temperatures of calculated seebeck.\n            Lambda: fitting parameter used to model the scattering (0.5 means\n                constant relaxation time).\n        Returns:\n            a matplotlib object\n        \"\"\"\n\n        import matplotlib.pyplot as plt\n        plt.figure(figsize=(9, 7))\n        for T in temps:\n            sbk_mass = self._bz.get_seebeck_eff_mass(output=output, temp=T,\n                                                     Lambda=0.5)\n            # remove noise inside the gap\n            start = self._bz.mu_doping['p'][T][0]\n            stop = self._bz.mu_doping['n'][T][0]\n            mu_steps_1 = []\n            mu_steps_2 = []\n            sbk_mass_1 = []\n            sbk_mass_2 = []\n            for i, mu in enumerate(self._bz.mu_steps):\n                if mu <= start:\n                    mu_steps_1.append(mu)\n                    sbk_mass_1.append(sbk_mass[i])\n                elif mu >= stop:\n                    mu_steps_2.append(mu)\n                    sbk_mass_2.append(sbk_mass[i])\n\n            plt.plot(mu_steps_1, sbk_mass_1, label=str(T) + 'K', linewidth=3.0)\n            plt.plot(mu_steps_2, sbk_mass_2, linewidth=3.0)\n            if output == 'average':\n                plt.gca().get_lines()[1].set_c(plt.gca().get_lines()[0].get_c())\n            elif output == 'tensor':\n                plt.gca().get_lines()[3].set_c(plt.gca().get_lines()[0].get_c())\n                plt.gca().get_lines()[4].set_c(plt.gca().get_lines()[1].get_c())\n                plt.gca().get_lines()[5].set_c(plt.gca().get_lines()[2].get_c())\n\n        plt.xlabel(\"E-E$_f$ (eV)\", fontsize=30)\n        plt.ylabel(\"Seebeck effective mass\", fontsize=30)\n        plt.xticks(fontsize=25)\n        plt.yticks(fontsize=25)\n        if output == 'tensor':\n            plt.legend([str(i) + '_' + str(T) + 'K' for T in temps for i in\n                        ('x', 'y', 'z')], fontsize=20)\n        elif output == 'average':\n            plt.legend(fontsize=20)\n        plt.tight_layout()\n        return plt", "response": "Plots the seebeck effective mass for a specific temperature."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nplots the complexity factor of the Fermi surface and the real and real real", "response": "def plot_complexity_factor_mu(self, temps=[300], output='average',\n                                  Lambda=0.5):\n        \"\"\"\n        Plot respect to the chemical potential of the Fermi surface complexity \n        factor calculated as explained in Ref.\n        Gibbs, Z. M. et al., Effective mass and fermi surface complexity factor \n        from ab initio band structure calculations. \n        npj Computational Materials 3, 8 (2017).\n        \n        Args:\n            output: 'average' returns the complexity factor calculated using the average\n                    of the three diagonal components of the seebeck and conductivity tensors.\n                    'tensor' returns the complexity factor respect to the three\n                    diagonal components of seebeck and conductivity tensors.\n            temps:  list of temperatures of calculated seebeck and conductivity.\n            Lambda: fitting parameter used to model the scattering (0.5 means constant \n                    relaxation time).\n        Returns:\n            a matplotlib object\n        \"\"\"\n        import matplotlib.pyplot as plt\n        plt.figure(figsize=(9, 7))\n        for T in temps:\n            cmplx_fact = self._bz.get_complexity_factor(output=output, temp=T,\n                                                        Lambda=Lambda)\n            start = self._bz.mu_doping['p'][T][0]\n            stop = self._bz.mu_doping['n'][T][0]\n            mu_steps_1 = []\n            mu_steps_2 = []\n            cmplx_fact_1 = []\n            cmplx_fact_2 = []\n            for i, mu in enumerate(self._bz.mu_steps):\n                if mu <= start:\n                    mu_steps_1.append(mu)\n                    cmplx_fact_1.append(cmplx_fact[i])\n                elif mu >= stop:\n                    mu_steps_2.append(mu)\n                    cmplx_fact_2.append(cmplx_fact[i])\n\n            plt.plot(mu_steps_1, cmplx_fact_1, label=str(T) + 'K',\n                     linewidth=3.0)\n            plt.plot(mu_steps_2, cmplx_fact_2, linewidth=3.0)\n            if output == 'average':\n                plt.gca().get_lines()[1].set_c(plt.gca().get_lines()[0].get_c())\n            elif output == 'tensor':\n                plt.gca().get_lines()[3].set_c(plt.gca().get_lines()[0].get_c())\n                plt.gca().get_lines()[4].set_c(plt.gca().get_lines()[1].get_c())\n                plt.gca().get_lines()[5].set_c(plt.gca().get_lines()[2].get_c())\n\n        plt.xlabel(\"E-E$_f$ (eV)\", fontsize=30)\n        plt.ylabel(\"Complexity Factor\", fontsize=30)\n        plt.xticks(fontsize=25)\n        plt.yticks(fontsize=25)\n        if output == 'tensor':\n            plt.legend([str(i) + '_' + str(T) + 'K' for T in temps for i in\n                        ('x', 'y', 'z')], fontsize=20)\n        elif output == 'average':\n            plt.legend(fontsize=20)\n        plt.tight_layout()\n        return plt"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nplotting the seebeck coefficient in function of Fermi level", "response": "def plot_seebeck_mu(self, temp=600, output='eig', xlim=None):\n        \"\"\"\n        Plot the seebeck coefficient in function of Fermi level\n\n        Args:\n            temp:\n                the temperature\n            xlim:\n                a list of min and max fermi energy by default (0, and band gap)\n        Returns:\n            a matplotlib object\n        \"\"\"\n        import matplotlib.pyplot as plt\n        plt.figure(figsize=(9, 7))\n        seebeck = self._bz.get_seebeck(output=output, doping_levels=False)[\n            temp]\n        plt.plot(self._bz.mu_steps, seebeck,\n                 linewidth=3.0)\n\n        self._plot_bg_limits()\n        self._plot_doping(temp)\n        if output == 'eig':\n            plt.legend(['S$_1$', 'S$_2$', 'S$_3$'])\n        if xlim is None:\n            plt.xlim(-0.5, self._bz.gap + 0.5)\n        else:\n            plt.xlim(xlim[0], xlim[1])\n        plt.ylabel(\"Seebeck \\n coefficient  ($\\\\mu$V/K)\", fontsize=30.0)\n        plt.xlabel(\"E-E$_f$ (eV)\", fontsize=30)\n        plt.xticks(fontsize=25)\n        plt.yticks(fontsize=25)\n        plt.tight_layout()\n        return plt"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef plot_conductivity_mu(self, temp=600, output='eig',\n                             relaxation_time=1e-14, xlim=None):\n        \"\"\"\n        Plot the conductivity in function of Fermi level. Semi-log plot\n\n        Args:\n            temp: the temperature\n            xlim: a list of min and max fermi energy by default (0, and band\n                gap)\n            tau: A relaxation time in s. By default none and the plot is by\n               units of relaxation time\n\n        Returns:\n            a matplotlib object\n        \"\"\"\n        import matplotlib.pyplot as plt\n        cond = self._bz.get_conductivity(relaxation_time=relaxation_time,\n                                         output=output, doping_levels=False)[\n            temp]\n        plt.figure(figsize=(9, 7))\n        plt.semilogy(self._bz.mu_steps, cond, linewidth=3.0)\n        self._plot_bg_limits()\n        self._plot_doping(temp)\n        if output == 'eig':\n            plt.legend(['$\\\\Sigma_1$', '$\\\\Sigma_2$', '$\\\\Sigma_3$'])\n        if xlim is None:\n            plt.xlim(-0.5, self._bz.gap + 0.5)\n        else:\n            plt.xlim(xlim)\n        plt.ylim([1e13 * relaxation_time, 1e20 * relaxation_time])\n        plt.ylabel(\"conductivity,\\n $\\\\Sigma$ (1/($\\\\Omega$ m))\", fontsize=30.0)\n        plt.xlabel(\"E-E$_f$ (eV)\", fontsize=30.0)\n        plt.xticks(fontsize=25)\n        plt.yticks(fontsize=25)\n        plt.tight_layout()\n        return plt", "response": "Plot the conductivity in function of Fermi level."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef plot_power_factor_mu(self, temp=600, output='eig',\n                             relaxation_time=1e-14, xlim=None):\n        \"\"\"\n        Plot the power factor in function of Fermi level. Semi-log plot\n\n        Args:\n            temp: the temperature\n            xlim: a list of min and max fermi energy by default (0, and band\n                gap)\n            tau: A relaxation time in s. By default none and the plot is by\n               units of relaxation time\n\n        Returns:\n            a matplotlib object\n        \"\"\"\n        import matplotlib.pyplot as plt\n        plt.figure(figsize=(9, 7))\n        pf = self._bz.get_power_factor(relaxation_time=relaxation_time,\n                                       output=output, doping_levels=False)[\n            temp]\n        plt.semilogy(self._bz.mu_steps, pf, linewidth=3.0)\n        self._plot_bg_limits()\n        self._plot_doping(temp)\n        if output == 'eig':\n            plt.legend(['PF$_1$', 'PF$_2$', 'PF$_3$'])\n        if xlim is None:\n            plt.xlim(-0.5, self._bz.gap + 0.5)\n        else:\n            plt.xlim(xlim)\n        plt.ylabel(\"Power factor, ($\\\\mu$W/(mK$^2$))\", fontsize=30.0)\n        plt.xlabel(\"E-E$_f$ (eV)\", fontsize=30.0)\n        plt.xticks(fontsize=25)\n        plt.yticks(fontsize=25)\n        plt.tight_layout()\n        return plt", "response": "Plot the power factor in function of Fermi level."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef plot_zt_mu(self, temp=600, output='eig', relaxation_time=1e-14,\n                   xlim=None):\n        \"\"\"\n        Plot the ZT in function of Fermi level.\n\n        Args:\n            temp: the temperature\n            xlim: a list of min and max fermi energy by default (0, and band\n                gap)\n            tau: A relaxation time in s. By default none and the plot is by\n               units of relaxation time\n\n        Returns:\n            a matplotlib object\n        \"\"\"\n        import matplotlib.pyplot as plt\n        plt.figure(figsize=(9, 7))\n        zt = self._bz.get_zt(relaxation_time=relaxation_time, output=output,\n                             doping_levels=False)[temp]\n        plt.plot(self._bz.mu_steps, zt, linewidth=3.0)\n        self._plot_bg_limits()\n        self._plot_doping(temp)\n        if output == 'eig':\n            plt.legend(['ZT$_1$', 'ZT$_2$', 'ZT$_3$'])\n        if xlim is None:\n            plt.xlim(-0.5, self._bz.gap + 0.5)\n        else:\n            plt.xlim(xlim)\n        plt.ylabel(\"ZT\", fontsize=30.0)\n        plt.xlabel(\"E-E$_f$ (eV)\", fontsize=30.0)\n        plt.xticks(fontsize=25)\n        plt.yticks(fontsize=25)\n        plt.tight_layout()\n        return plt", "response": "Plot the ZT in function of Fermi level."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef plot_seebeck_temp(self, doping='all', output='average'):\n\n        import matplotlib.pyplot as plt\n        if output == 'average':\n            sbk = self._bz.get_seebeck(output='average')\n        elif output == 'eigs':\n            sbk = self._bz.get_seebeck(output='eigs')\n\n        plt.figure(figsize=(22, 14))\n        tlist = sorted(sbk['n'].keys())\n        doping = self._bz.doping['n'] if doping == 'all' else doping\n        for i, dt in enumerate(['n', 'p']):\n            plt.subplot(121 + i)\n            for dop in doping:\n                d = self._bz.doping[dt].index(dop)\n                sbk_temp = []\n                for temp in tlist:\n                    sbk_temp.append(sbk[dt][temp][d])\n                if output == 'average':\n                    plt.plot(tlist, sbk_temp, marker='s',\n                             label=str(dop) + ' $cm^{-3}$')\n                elif output == 'eigs':\n                    for xyz in range(3):\n                        plt.plot(tlist, zip(*sbk_temp)[xyz], marker='s',\n                                 label=str(xyz) + ' ' + str(dop) + ' $cm^{-3}$')\n            plt.title(dt + '-type', fontsize=20)\n            if i == 0:\n                plt.ylabel(\"Seebeck \\n coefficient  ($\\\\mu$V/K)\", fontsize=30.0)\n            plt.xlabel('Temperature (K)', fontsize=30.0)\n\n            p = 'lower right' if i == 0 else ''\n            plt.legend(loc=p, fontsize=15)\n            plt.grid()\n            plt.xticks(fontsize=25)\n            plt.yticks(fontsize=25)\n\n        plt.tight_layout()\n\n        return plt", "response": "Plots the Seebeck coefficient in function of temperature for different \n        doping levels."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nplots the Power Factor in function of doping levels for different temperatures.", "response": "def plot_power_factor_dop(self, temps='all', output='average',\n                              relaxation_time=1e-14):\n        \"\"\"\n        Plot the Power Factor in function of doping levels for different temperatures.\n\n        Args:\n            temps: the default 'all' plots all the temperatures in the analyzer.\n                   Specify a list of temperatures if you want to plot only some.\n            output: with 'average' you get an average of the three directions\n                    with 'eigs' you get all the three directions.\n            relaxation_time: specify a constant relaxation time value\n        \n        Returns:\n            a matplotlib object\n        \"\"\"\n        import matplotlib.pyplot as plt\n        if output == 'average':\n            pf = self._bz.get_power_factor(relaxation_time=relaxation_time,\n                                           output='average')\n        elif output == 'eigs':\n            pf = self._bz.get_power_factor(relaxation_time=relaxation_time,\n                                           output='eigs')\n\n        tlist = sorted(pf['n'].keys()) if temps == 'all' else temps\n        plt.figure(figsize=(22, 14))\n        for i, dt in enumerate(['n', 'p']):\n            plt.subplot(121 + i)\n            for temp in tlist:\n                if output == 'eigs':\n                    for xyz in range(3):\n                        plt.semilogx(self._bz.doping[dt],\n                                     zip(*pf[dt][temp])[xyz],\n                                     marker='s',\n                                     label=str(xyz) + ' ' + str(temp) + ' K')\n                elif output == 'average':\n                    plt.semilogx(self._bz.doping[dt], pf[dt][temp],\n                                 marker='s', label=str(temp) + ' K')\n            plt.title(dt + '-type', fontsize=20)\n            if i == 0:\n                plt.ylabel(\"Power Factor  ($\\\\mu$W/(mK$^2$))\", fontsize=30.0)\n            plt.xlabel('Doping concentration ($cm^{-3}$)', fontsize=30.0)\n            plt.ticklabel_format(style='sci', axis='y', scilimits=(0, 0))\n            p = ''  # 'lower right' if i == 0 else ''\n            plt.legend(loc=p, fontsize=15)\n            plt.grid()\n            plt.xticks(fontsize=25)\n            plt.yticks(fontsize=25)\n\n        plt.tight_layout()\n\n        return plt"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nplotting the figure of merit zT in function of doping levels for different temperatures.", "response": "def plot_zt_dop(self, temps='all', output='average', relaxation_time=1e-14):\n        \"\"\"\n        Plot the figure of merit zT in function of doping levels for different\n        temperatures.\n\n        Args:\n            temps: the default 'all' plots all the temperatures in the analyzer.\n                   Specify a list of temperatures if you want to plot only some.\n            output: with 'average' you get an average of the three directions\n                    with 'eigs' you get all the three directions.\n            relaxation_time: specify a constant relaxation time value\n        \n        Returns:\n            a matplotlib object\n        \"\"\"\n        import matplotlib.pyplot as plt\n        if output == 'average':\n            zt = self._bz.get_zt(relaxation_time=relaxation_time,\n                                 output='average')\n        elif output == 'eigs':\n            zt = self._bz.get_zt(relaxation_time=relaxation_time, output='eigs')\n\n        tlist = sorted(zt['n'].keys()) if temps == 'all' else temps\n        plt.figure(figsize=(22, 14))\n        for i, dt in enumerate(['n', 'p']):\n            plt.subplot(121 + i)\n            for temp in tlist:\n                if output == 'eigs':\n                    for xyz in range(3):\n                        plt.semilogx(self._bz.doping[dt],\n                                     zip(*zt[dt][temp])[xyz],\n                                     marker='s',\n                                     label=str(xyz) + ' ' + str(temp) + ' K')\n                elif output == 'average':\n                    plt.semilogx(self._bz.doping[dt], zt[dt][temp],\n                                 marker='s', label=str(temp) + ' K')\n            plt.title(dt + '-type', fontsize=20)\n            if i == 0:\n                plt.ylabel(\"zT\", fontsize=30.0)\n            plt.xlabel('Doping concentration ($cm^{-3}$)', fontsize=30.0)\n\n            p = 'lower right' if i == 0 else ''\n            plt.legend(loc=p, fontsize=15)\n            plt.grid()\n            plt.xticks(fontsize=25)\n            plt.yticks(fontsize=25)\n\n        plt.tight_layout()\n\n        return plt"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a matplotlib object containing the dos of the current object.", "response": "def plot_dos(self, sigma=0.05):\n        \"\"\"\n        plot dos\n\n        Args:\n            sigma: a smearing\n\n        Returns:\n            a matplotlib object\n        \"\"\"\n        plotter = DosPlotter(sigma=sigma)\n        plotter.add_dos(\"t\", self._bz.dos)\n        return plotter.get_plot()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef plot_carriers(self, temp=300):\n        import matplotlib.pyplot as plt\n        plt.semilogy(self._bz.mu_steps,\n                     abs(self._bz._carrier_conc[temp] / (self._bz.vol * 1e-24)),\n                     linewidth=3.0, color='r')\n        self._plot_bg_limits()\n        self._plot_doping(temp)\n        plt.xlim(-0.5, self._bz.gap + 0.5)\n        plt.ylim(1e14, 1e22)\n        plt.ylabel(\"carrier concentration (cm-3)\", fontsize=30.0)\n        plt.xlabel(\"E-E$_f$ (eV)\", fontsize=30)\n        plt.xticks(fontsize=25)\n        plt.yticks(fontsize=25)\n        return plt", "response": "Plot the carrier concentration in function of Fermi level"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nplot the Hall carrier concentration in function of Fermi level", "response": "def plot_hall_carriers(self, temp=300):\n        \"\"\"\n        Plot the Hall carrier concentration in function of Fermi level\n\n        Args:\n            temp: the temperature\n\n        Returns:\n            a matplotlib object\n        \"\"\"\n        import matplotlib.pyplot as plt\n        hall_carriers = [abs(i) for i in\n                         self._bz.get_hall_carrier_concentration()[temp]]\n        plt.semilogy(self._bz.mu_steps,\n                     hall_carriers,\n                     linewidth=3.0, color='r')\n        self._plot_bg_limits()\n        self._plot_doping(temp)\n        plt.xlim(-0.5, self._bz.gap + 0.5)\n        plt.ylim(1e14, 1e22)\n        plt.ylabel(\"Hall carrier concentration (cm-3)\", fontsize=30.0)\n        plt.xlabel(\"E-E$_f$ (eV)\", fontsize=30)\n        plt.xticks(fontsize=25)\n        plt.yticks(fontsize=25)\n        return plt"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds a COHP object to the dictionary.", "response": "def add_cohp(self, label, cohp):\n        \"\"\"\n        Adds a COHP for plotting.\n\n        Args:\n            label: Label for the COHP. Must be unique.\n\n            cohp: COHP object.\n        \"\"\"\n        energies = cohp.energies - cohp.efermi if self.zero_at_efermi \\\n            else cohp.energies\n        populations = cohp.get_cohp()\n        int_populations = cohp.get_icohp()\n        self._cohps[label] = {\"energies\": energies, \"COHP\": populations,\n                              \"ICOHP\": int_populations, \"efermi\": cohp.efermi}"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nadds a dictionary of COHPs with an optional sorting function for the keys.", "response": "def add_cohp_dict(self, cohp_dict, key_sort_func=None):\n        \"\"\"\n        Adds a dictionary of COHPs with an optional sorting function\n        for the keys.\n\n        Args:\n            cohp_dict: dict of the form {label: Cohp}\n\n            key_sort_func: function used to sort the cohp_dict keys.\n        \"\"\"\n        if key_sort_func:\n            keys = sorted(cohp_dict.keys(), key=key_sort_func)\n        else:\n            keys = cohp_dict.keys()\n        for label in keys:\n            self.add_cohp(label, cohp_dict[label])"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a matplotlib plot showing the COHPs and ICOHPs.", "response": "def get_plot(self, xlim=None, ylim=None, plot_negative=None,\n                 integrated=False, invert_axes=True):\n        \"\"\"\n        Get a matplotlib plot showing the COHP.\n\n        Args:\n            xlim: Specifies the x-axis limits. Defaults to None for\n                automatic determination.\n\n            ylim: Specifies the y-axis limits. Defaults to None for\n                automatic determination.\n\n            plot_negative: It is common to plot -COHP(E) so that the\n                sign means the same for COOPs and COHPs. Defaults to None\n                for automatic determination: If are_coops is True, this\n                will be set to False, else it will be set to True.\n\n            integrated: Switch to plot ICOHPs. Defaults to False.\n\n            invert_axes: Put the energies onto the y-axis, which is\n                common in chemistry.\n\n        Returns:\n            A matplotlib object.\n        \"\"\"\n        if self.are_coops:\n            cohp_label = \"COOP\"\n        else:\n            cohp_label = \"COHP\"\n\n        if plot_negative is None:\n            plot_negative = True if not self.are_coops else False\n\n        if integrated:\n            cohp_label = \"I\" + cohp_label + \" (eV)\"\n\n        if plot_negative:\n            cohp_label = \"-\" + cohp_label\n\n        if self.zero_at_efermi:\n            energy_label = \"$E - E_f$ (eV)\"\n        else:\n            energy_label = \"$E$ (eV)\"\n\n        ncolors = max(3, len(self._cohps))\n        ncolors = min(9, ncolors)\n\n        import palettable\n\n        colors = palettable.colorbrewer.qualitative.Set1_9.mpl_colors\n\n        plt = pretty_plot(12, 8)\n\n        allpts = []\n        keys = self._cohps.keys()\n        for i, key in enumerate(keys):\n            energies = self._cohps[key][\"energies\"]\n            if not integrated:\n                populations = self._cohps[key][\"COHP\"]\n            else:\n                populations = self._cohps[key][\"ICOHP\"]\n            for spin in [Spin.up, Spin.down]:\n                if spin in populations:\n                    if invert_axes:\n                        x = -populations[spin] if plot_negative \\\n                            else populations[spin]\n                        y = energies\n                    else:\n                        x = energies\n                        y = -populations[spin] if plot_negative \\\n                            else populations[spin]\n                    allpts.extend(list(zip(x, y)))\n                    if spin == Spin.up:\n                        plt.plot(x, y, color=colors[i % ncolors],\n                                 linestyle='-', label=str(key), linewidth=3)\n                    else:\n                        plt.plot(x, y, color=colors[i % ncolors],\n                                 linestyle='--', linewidth=3)\n\n        if xlim:\n            plt.xlim(xlim)\n        if ylim:\n            plt.ylim(ylim)\n        else:\n            xlim = plt.xlim()\n            relevanty = [p[1] for p in allpts if xlim[0] < p[0] < xlim[1]]\n            plt.ylim((min(relevanty), max(relevanty)))\n\n        xlim = plt.xlim()\n        ylim = plt.ylim()\n        if not invert_axes:\n            plt.plot(xlim, [0, 0], \"k-\", linewidth=2)\n            if self.zero_at_efermi:\n                plt.plot([0, 0], ylim, \"k--\", linewidth=2)\n            else:\n                plt.plot([self._cohps[key]['efermi'],\n                         self._cohps[key]['efermi']], ylim,\n                         color=colors[i % ncolors],\n                         linestyle='--', linewidth=2)\n        else:\n            plt.plot([0, 0], ylim, \"k-\", linewidth=2)\n            if self.zero_at_efermi:\n                plt.plot(xlim, [0, 0], \"k--\", linewidth=2)\n            else:\n                plt.plot(xlim, [self._cohps[key]['efermi'],\n                         self._cohps[key]['efermi']],\n                         color=colors[i % ncolors],\n                         linestyle='--', linewidth=2)\n\n        if invert_axes:\n            plt.xlabel(cohp_label)\n            plt.ylabel(energy_label)\n        else:\n            plt.xlabel(energy_label)\n            plt.ylabel(cohp_label)\n\n        plt.legend()\n        leg = plt.gca().get_legend()\n        ltext = leg.get_texts()\n        plt.setp(ltext, fontsize=30)\n        plt.tight_layout()\n        return plt"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a list of dopant suggestions for each doping type in the given structure.", "response": "def get_dopants_from_substitution_probabilities(structure, num_dopants=5,\n                                                threshold=0.001,\n                                                match_oxi_sign=False):\n    \"\"\"\n    Get dopant suggestions based on substitution probabilities.\n\n    Args:\n        structure (Structure): A pymatgen structure decorated with\n            oxidation states.\n        num_dopants (int): The number of suggestions to return for\n            n- and p-type dopants.\n        threshold (float): Probability threshold for substitutions.\n        match_oxi_sign (bool): Whether to force the dopant and original species\n            to have the same sign of oxidation state. E.g. If the original site\n            is in a negative charge state, then only negative dopants will be\n            returned.\n\n    Returns:\n        (dict): Dopant suggestions, given as a dictionary with keys \"n_type\" and\n        \"p_type\". The suggestions for each doping type are given as a list of\n        dictionaries, each with they keys:\n\n        - \"probability\": The probability of substitution.\n        - \"dopant_species\": The dopant species.\n        - \"original_species\": The substituted species.\n    \"\"\"\n    els_have_oxi_states = [hasattr(s, \"oxi_state\") for s in structure.species]\n\n    if not all(els_have_oxi_states):\n        raise ValueError(\"All sites in structure must have oxidation states to \"\n                         \"predict dopants.\")\n\n    sp = SubstitutionPredictor(threshold=threshold)\n\n    subs = [sp.list_prediction([s]) for s in set(structure.species)]\n    subs = [{'probability': pred['probability'],\n             'dopant_species': list(pred['substitutions'].keys())[0],\n             'original_species': list(pred['substitutions'].values())[0]}\n            for species_preds in subs for pred in species_preds]\n    subs.sort(key=lambda x: x['probability'], reverse=True)\n\n    return _get_dopants(subs, num_dopants, match_oxi_sign)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_dopants_from_shannon_radii(bonded_structure, num_dopants=5,\n                                   match_oxi_sign=False):\n    \"\"\"\n    Get dopant suggestions based on Shannon radii differences.\n\n    Args:\n        bonded_structure (StructureGraph): A pymatgen structure graph\n            decorated with oxidation states. For example, generated using the\n            CrystalNN.get_bonded_structure() method.\n        num_dopants (int): The nummber of suggestions to return for\n            n- and p-type dopants.\n        match_oxi_sign (bool): Whether to force the dopant and original species\n            to have the same sign of oxidation state. E.g. If the original site\n            is in a negative charge state, then only negative dopants will be\n            returned.\n\n    Returns:\n        (dict): Dopant suggestions, given as a dictionary with keys \"n_type\" and\n        \"p_type\". The suggestions for each doping type are given as a list of\n        dictionaries, each with they keys:\n\n        - \"radii_diff\": The difference between the Shannon radii of the species.\n        - \"dopant_spcies\": The dopant species.\n        - \"original_species\": The substituted species.\n    \"\"\"\n    # get a list of all Specie for all elements in all their common oxid states\n    all_species = [Specie(el, oxi) for el in Element\n                   for oxi in el.common_oxidation_states]\n\n    # get a series of tuples with (coordination number, specie)\n    cn_and_species = set((bonded_structure.get_coordination_of_site(i),\n                          bonded_structure.structure[i].specie)\n                         for i in range(bonded_structure.structure.num_sites))\n\n    cn_to_radii_map = {}\n    possible_dopants = []\n\n    for cn, species in cn_and_species:\n        cn_roman = _int_to_roman(cn)\n\n        try:\n            species_radius = species.get_shannon_radius(cn_roman)\n        except KeyError:\n            warnings.warn(\"Shannon radius not found for {} with coordination \"\n                          \"number {}.\\nSkipping...\".format(species, cn))\n            continue\n\n        if cn not in cn_to_radii_map:\n            cn_to_radii_map[cn] = _shannon_radii_from_cn(\n                all_species, cn_roman, radius_to_compare=species_radius)\n\n        shannon_radii = cn_to_radii_map[cn]\n\n        possible_dopants += [{'radii_diff': p['radii_diff'],\n                              'dopant_species': p['species'],\n                              'original_species': species}\n                             for p in shannon_radii]\n\n    possible_dopants.sort(key=lambda x: abs(x['radii_diff']))\n\n    return _get_dopants(possible_dopants, num_dopants, match_oxi_sign)", "response": "Returns a list of dopant suggestions for each element in the structure that are in the Shannon radii of the species."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncalculating the solid angle of a set of coords from the center.", "response": "def solid_angle(center, coords):\n    \"\"\"\n    Helper method to calculate the solid angle of a set of coords from the\n    center.\n\n    Args:\n        center (3x1 array): Center to measure solid angle from.\n        coords (Nx3 array): List of coords to determine solid angle.\n\n    Returns:\n        The solid angle.\n    \"\"\"\n\n    # Compute the displacement from the center\n    r = [np.subtract(c, center) for c in coords]\n\n    # Compute the magnitude of each vector\n    r_norm = [np.linalg.norm(i) for i in r]\n\n    # Compute the solid angle for each tetrahedron that makes up the facet\n    #  Following: https://en.wikipedia.org/wiki/Solid_angle#Tetrahedron\n    angle = 0\n    for i in range(1, len(r) - 1):\n        j = i + 1\n        tp = np.abs(np.dot(r[0], np.cross(r[i], r[j])))\n        de = r_norm[0] * r_norm[i] * r_norm[j] + \\\n             r_norm[j] * np.dot(r[0], r[i]) + \\\n             r_norm[i] * np.dot(r[0], r[j]) + \\\n             r_norm[0] * np.dot(r[i], r[j])\n        if de == 0:\n            my_angle = 0.5 * pi if tp > 0 else -0.5 * pi\n        else:\n            my_angle = np.arctan(tp / de)\n        angle += (my_angle if my_angle > 0 else my_angle + np.pi) * 2\n\n    return angle"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncalculates the volume of a tetrahedron given the four vertices of vt1 vt2 vt3 and vt4.", "response": "def vol_tetra(vt1, vt2, vt3, vt4):\n    \"\"\"\n    Calculate the volume of a tetrahedron, given the four vertices of vt1,\n    vt2, vt3 and vt4.\n    Args:\n        vt1 (array-like): coordinates of vertex 1.\n        vt2 (array-like): coordinates of vertex 2.\n        vt3 (array-like): coordinates of vertex 3.\n        vt4 (array-like): coordinates of vertex 4.\n    Returns:\n        (float): volume of the tetrahedron.\n    \"\"\"\n    vol_tetra = np.abs(np.dot((vt1 - vt4),\n                              np.cross((vt2 - vt4), (vt3 - vt4)))) / 6\n    return vol_tetra"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the elemental parameters related to the element and bond length of the specified element.", "response": "def get_okeeffe_params(el_symbol):\n    \"\"\"\n    Returns the elemental parameters related to atom size and\n    electronegativity which are used for estimating bond-valence\n    parameters (bond length) of pairs of atoms on the basis of data\n    provided in 'Atoms Sizes and Bond Lengths in Molecules and Crystals'\n    (O'Keeffe & Brese, 1991).\n\n    Args:\n        el_symbol (str): element symbol.\n    Returns:\n        (dict): atom-size ('r') and electronegativity-related ('c')\n                parameter.\n    \"\"\"\n\n    el = Element(el_symbol)\n    if el not in list(BV_PARAMS.keys()):\n        raise RuntimeError(\"Could not find O'Keeffe parameters for element\"\n                           \" \\\"{}\\\" in \\\"BV_PARAMS\\\"dictonary\"\n                           \" provided by pymatgen\".format(el_symbol))\n\n    return BV_PARAMS[el]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_okeeffe_distance_prediction(el1, el2):\n    el1_okeeffe_params = get_okeeffe_params(el1)\n    el2_okeeffe_params = get_okeeffe_params(el2)\n\n    r1 = el1_okeeffe_params['r']\n    r2 = el2_okeeffe_params['r']\n    c1 = el1_okeeffe_params['c']\n    c2 = el2_okeeffe_params['c']\n\n    return r1 + r2 - r1 * r2 * pow(\n        sqrt(c1) - sqrt(c2), 2) / (c1 * r1 + c2 * r2)", "response": "Returns an estimate of the bond valence parameter for the given element."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the neighbors of a given site using a specific neighbor - finding method.", "response": "def get_neighbors_of_site_with_index(struct, n, approach=\"min_dist\", delta=0.1, \\\n                                     cutoff=10.0):\n    \"\"\"\n    Returns the neighbors of a given site using a specific neighbor-finding\n    method.\n\n    Args:\n        struct (Structure): input structure.\n        n (int): index of site in Structure object for which motif type\n                is to be determined.\n        approach (str): type of neighbor-finding approach, where\n              \"min_dist\" will use the MinimumDistanceNN class,\n              \"voronoi\" the VoronoiNN class, \"min_OKeeffe\" the\n              MinimumOKeeffe class, and \"min_VIRE\" the MinimumVIRENN class.\n        delta (float): tolerance involved in neighbor finding.\n        cutoff (float): (large) radius to find tentative neighbors.\n\n    Returns: neighbor sites.\n    \"\"\"\n\n    if approach == \"min_dist\":\n        return MinimumDistanceNN(tol=delta, cutoff=cutoff).get_nn(\n            struct, n)\n    elif approach == \"voronoi\":\n        return VoronoiNN(tol=delta, cutoff=cutoff).get_nn(\n            struct, n)\n    elif approach == \"min_OKeeffe\":\n        return MinimumOKeeffeNN(tol=delta, cutoff=cutoff).get_nn(\n            struct, n)\n    elif approach == \"min_VIRE\":\n        return MinimumVIRENN(tol=delta, cutoff=cutoff).get_nn(\n            struct, n)\n    else:\n        raise RuntimeError(\"unsupported neighbor-finding method ({}).\".format(\n            approach))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the motif type of the site with index n in structure struct.", "response": "def site_is_of_motif_type(struct, n, approach=\"min_dist\", delta=0.1, \\\n                          cutoff=10.0, thresh=None):\n    \"\"\"\n    Returns the motif type of the site with index n in structure struct;\n    currently featuring \"tetrahedral\", \"octahedral\", \"bcc\", and \"cp\"\n    (close-packed: fcc and hcp) as well as \"square pyramidal\" and\n    \"trigonal bipyramidal\".  If the site is not recognized,\n    \"unrecognized\" is returned.  If a site should be assigned to two\n    different motifs, \"multiple assignments\" is returned.\n\n    Args:\n        struct (Structure): input structure.\n        n (int): index of site in Structure object for which motif type\n                is to be determined.\n        approach (str): type of neighbor-finding approach, where\n              \"min_dist\" will use the MinimumDistanceNN class,\n              \"voronoi\" the VoronoiNN class, \"min_OKeeffe\" the\n              MinimumOKeeffe class, and \"min_VIRE\" the MinimumVIRENN class.\n        delta (float): tolerance involved in neighbor finding.\n        cutoff (float): (large) radius to find tentative neighbors.\n        thresh (dict): thresholds for motif criteria (currently, required\n                keys and their default values are \"qtet\": 0.5,\n                \"qoct\": 0.5, \"qbcc\": 0.5, \"q6\": 0.4).\n\n    Returns: motif type (str).\n    \"\"\"\n\n    if thresh is None:\n        thresh = {\n            \"qtet\": 0.5, \"qoct\": 0.5, \"qbcc\": 0.5, \"q6\": 0.4,\n            \"qtribipyr\": 0.8, \"qsqpyr\": 0.8}\n\n    ops = LocalStructOrderParams([\n        \"cn\", \"tet\", \"oct\", \"bcc\", \"q6\", \"sq_pyr\", \"tri_bipyr\"])\n\n    neighs_cent = get_neighbors_of_site_with_index(\n        struct, n, approach=approach, delta=delta, cutoff=cutoff)\n    neighs_cent.append(struct.sites[n])\n    opvals = ops.get_order_parameters(\n        neighs_cent, len(neighs_cent) - 1, indices_neighs=[\n            i for i in range(len(neighs_cent) - 1)])\n    cn = int(opvals[0] + 0.5)\n    motif_type = \"unrecognized\"\n    nmotif = 0\n\n    if cn == 4 and opvals[1] > thresh[\"qtet\"]:\n        motif_type = \"tetrahedral\"\n        nmotif += 1\n    if cn == 5 and opvals[5] > thresh[\"qsqpyr\"]:\n        motif_type = \"square pyramidal\"\n        nmotif += 1\n    if cn == 5 and opvals[6] > thresh[\"qtribipyr\"]:\n        motif_type = \"trigonal bipyramidal\"\n        nmotif += 1\n    if cn == 6 and opvals[2] > thresh[\"qoct\"]:\n        motif_type = \"octahedral\"\n        nmotif += 1\n    if cn == 8 and (opvals[3] > thresh[\"qbcc\"] and opvals[1] < thresh[\"qtet\"]):\n        motif_type = \"bcc\"\n        nmotif += 1\n    if cn == 12 and (opvals[4] > thresh[\"q6\"] and opvals[1] < thresh[\"q6\"] and\n                     opvals[2] < thresh[\"q6\"] and opvals[3] < thresh[\"q6\"]):\n        motif_type = \"cp\"\n        nmotif += 1\n\n    if nmotif > 1:\n        motif_type = \"multiple assignments\"\n\n    return motif_type"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn that part of the first input vector that is orthogonal to the second input vector.", "response": "def gramschmidt(vin, uin):\n    \"\"\"\n    Returns that part of the first input vector\n    that is orthogonal to the second input vector.\n    The output vector is not normalized.\n\n    Args:\n        vin (numpy array):\n            first input vector\n        uin (numpy array):\n            second input vector\n    \"\"\"\n\n    vin_uin = np.inner(vin, uin)\n    uin_uin = np.inner(uin, uin)\n    if uin_uin <= 0.0:\n        raise ValueError(\"Zero or negative inner product!\")\n    return vin - (vin_uin / uin_uin) * uin"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef calculate_weighted_avg(bonds):\n    minimum_bond = min(bonds)\n    weighted_sum = 0.0\n    total_sum = 0.0\n    for entry in bonds:\n        weighted_sum += entry * exp(1 - (entry / minimum_bond) ** 6)\n        total_sum += exp(1 - (entry / minimum_bond) ** 6)\n    return weighted_sum / total_sum", "response": "Calculates the weighted average bond length given by\n    Hoppe s effective coordination number formula."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef radii(self):\n        el = [site.species_string for site in self._structure.sites]\n        radii_dict = dict(zip(el, self._ionic_radii))\n        # print radii_dict\n        return radii_dict", "response": "Returns a dictionary of ionic radii of elements in the order of sites."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef valences(self):\n        el = [site.species_string for site in self._structure.sites]\n        valence_dict = dict(zip(el, self._valences))\n        return valence_dict", "response": "A dictionary of oxidation states of elements in the order of sites."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncomputing ionic radii of elements in all sites in the structure.", "response": "def _get_ionic_radii(self):\n        \"\"\"\n        Computes ionic radii of elements for all sites in the structure.\n        If valence is zero, atomic radius is used.\n        \"\"\"\n        radii = []\n        vnn = VoronoiNN()\n\n        def nearest_key(sorted_vals, key):\n            i = bisect_left(sorted_vals, key)\n            if i == len(sorted_vals):\n                return sorted_vals[-1]\n            if i == 0:\n                return sorted_vals[0]\n            before = sorted_vals[i - 1]\n            after = sorted_vals[i]\n            if after - key < key - before:\n                return after\n            else:\n                return before\n\n        for i in range(len(self._structure.sites)):\n            site = self._structure.sites[i]\n            if isinstance(site.specie, Element):\n                radius = site.specie.atomic_radius\n                # Handle elements with no atomic_radius\n                # by using calculated values instead.\n                if radius is None:\n                    radius = site.specie.atomic_radius_calculated\n                if radius is None:\n                    raise ValueError(\n                        \"cannot assign radius to element {}\".format(\n                            site.specie))\n                radii.append(radius)\n                continue\n\n            el = site.specie.symbol\n            oxi_state = int(round(site.specie.oxi_state))\n            coord_no = int(round(vnn.get_cn(self._structure, i)))\n            try:\n                tab_oxi_states = sorted(map(int, _ion_radii[el].keys()))\n                oxi_state = nearest_key(tab_oxi_states, oxi_state)\n                radius = _ion_radii[el][str(oxi_state)][str(coord_no)]\n            except KeyError:\n                if vnn.get_cn(self._structure, i) - coord_no > 0:\n                    new_coord_no = coord_no + 1\n                else:\n                    new_coord_no = coord_no - 1\n                try:\n                    radius = _ion_radii[el][str(oxi_state)][str(new_coord_no)]\n                    coord_no = new_coord_no\n                except:\n                    tab_coords = sorted(\n                        map(int, _ion_radii[el][str(oxi_state)].keys()))\n                    new_coord_no = nearest_key(tab_coords, coord_no)\n                    i = 0\n                    for val in tab_coords:\n                        if val > coord_no:\n                            break\n                        i = i + 1\n                    if i == len(tab_coords):\n                        key = str(tab_coords[-1])\n                        radius = _ion_radii[el][str(oxi_state)][key]\n                    elif i == 0:\n                        key = str(tab_coords[0])\n                        radius = _ion_radii[el][str(oxi_state)][key]\n                    else:\n                        key = str(tab_coords[i - 1])\n                        radius1 = _ion_radii[el][str(oxi_state)][key]\n                        key = str(tab_coords[i])\n                        radius2 = _ion_radii[el][str(oxi_state)][key]\n                        radius = (radius1 + radius2) / 2\n\n            # implement complex checks later\n            radii.append(radius)\n        return radii"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _get_valences(self):\n        try:\n            bv = BVAnalyzer()\n            self._structure = bv.get_oxi_state_decorated_structure(\n                self._structure)\n            valences = bv.get_valences(self._structure)\n        except:\n            try:\n                bv = BVAnalyzer(symm_tol=0.0)\n                self._structure = bv.get_oxi_state_decorated_structure(\n                    self._structure)\n                valences = bv.get_valences(self._structure)\n            except:\n                valences = []\n                for site in self._structure.sites:\n                    if len(site.specie.common_oxidation_states) > 0:\n                        valences.append(site.specie.common_oxidation_states[0])\n                    # Handle noble gas species\n                    # which have no entries in common_oxidation_states.\n                    else:\n                        valences.append(0)\n                if sum(valences):\n                    valences = [0] * self._structure.num_sites\n                else:\n                    self._structure.add_oxidation_state_by_site(valences)\n                # raise\n\n        # el = [site.specie.symbol for site in self._structure.sites]\n        # el = [site.species_string for site in self._structure.sites]\n        # el = [site.specie for site in self._structure.sites]\n        # valence_dict = dict(zip(el, valences))\n        # print valence_dict\n        return valences", "response": "Compute ionic valences of elements in the structure."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget coordination number CN of site with index n in structure.", "response": "def get_cn(self, structure, n, use_weights=False):\n        \"\"\"\n        Get coordination number, CN, of site with index n in structure.\n\n        Args:\n            structure (Structure): input structure.\n            n (integer): index of site for which to determine CN.\n            use_weights (boolean): flag indicating whether (True)\n                to use weights for computing the coordination number\n                or not (False, default: each coordinated site has equal\n                weight).\n        Returns:\n            cn (integer or float): coordination number.\n        \"\"\"\n\n        siw = self.get_nn_info(structure, n)\n        return sum([e['weight'] for e in siw]) if use_weights else len(siw)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget coordination number CN of each element bonded to site with index n in structure.", "response": "def get_cn_dict(self, structure, n, use_weights=False):\n        \"\"\"\n        Get coordination number, CN, of each element bonded to site with index n in structure\n\n        Args:\n            structure (Structure): input structure\n            n (integer): index of site for which to determine CN.\n            use_weights (boolean): flag indicating whether (True)\n                to use weights for computing the coordination number\n                or not (False, default: each coordinated site has equal\n                weight).\n\n        Returns:\n            cn (dict): dictionary of CN of each element bonded to site\n        \"\"\"\n\n        siw = self.get_nn_info(structure, n)\n\n        cn_dict = {}\n        for i in siw:\n            site_element = i['site'].species_string\n            if site_element not in cn_dict:\n                if use_weights:\n                    cn_dict[site_element] = i['weight']\n                else:\n                    cn_dict[site_element] = 1\n            else:\n                if use_weights:\n                    cn_dict[site_element] += i['weight']\n                else:\n                    cn_dict[site_element] += 1\n        return cn_dict"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_nn(self, structure, n):\n\n        return [e['site'] for e in self.get_nn_info(structure, n)]", "response": "Returns the list of sites near neighbors of site with index n in structure."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the weight associated with each near - neighbor of site with index n in structure.", "response": "def get_weights_of_nn_sites(self, structure, n):\n        \"\"\"\n        Get weight associated with each near neighbor of site with\n        index n in structure.\n\n        Args:\n            structure (Structure): input structure.\n            n (integer): index of site for which to determine the weights.\n        Returns:\n            weights (list of floats): near-neighbor weights.\n        \"\"\"\n\n        return [e['weight'] for e in self.get_nn_info(structure, n)]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_nn_images(self, structure, n):\n\n        return [e['image'] for e in self.get_nn_info(structure, n)]", "response": "Returns the image locations of all near neighbors of site with index n in structure."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_all_nn_info(self, structure):\n\n        return [self.get_nn_info(structure, n) for n in range(len(structure))]", "response": "Get a listing of all neighbors for all sites in a structure."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets a certain nearest neighbor shell for a certain site.", "response": "def get_nn_shell_info(self, structure, site_idx, shell):\n        \"\"\"Get a certain nearest neighbor shell for a certain site.\n\n        Determines all non-backtracking paths through the neighbor network\n        computed by `get_nn_info`. The weight is determined by multiplying\n        the weight of the neighbor at each hop through the network. For\n        example, a 2nd-nearest-neighbor that has a weight of 1 from its\n        1st-nearest-neighbor and weight 0.5 from the original site will\n        be assigned a weight of 0.5.\n\n        As this calculation may involve computing the nearest neighbors of\n        atoms multiple times, the calculation starts by computing all of the\n        neighbor info and then calling `_get_nn_shell_info`. If you are likely\n        to call this method for more than one site, consider calling `get_all_nn`\n        first and then calling this protected method yourself.\n\n        Args:\n            structure (Structure): Input structure\n            site_idx (int): index of site for which to determine neighbor\n                information.\n            shell (int): Which neighbor shell to retrieve (1 == 1st NN shell)\n        Returns:\n            list of dictionaries. Each entry in the list is information about\n                a certain neighbor in the structure, in the same format as\n                `get_nn_info`.\n        \"\"\"\n\n        all_nn_info = self.get_all_nn_info(structure)\n        sites = self._get_nn_shell_info(structure, all_nn_info, site_idx, shell)\n\n        # Update the site positions\n        #   Did not do this during NN options because that can be slower\n        output = []\n        for info in sites:\n            orig_site = structure[info['site_index']]\n            info['site'] = PeriodicSite(orig_site.species,\n                                        np.add(orig_site.frac_coords,\n                                               info['image']),\n                                        structure.lattice,\n                                        properties=orig_site.properties)\n            output.append(info)\n        return output"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_bonded_structure(self, structure, decorate=False):\n\n        # requires optional dependency which is why it's not a top-level import\n        from pymatgen.analysis.graphs import StructureGraph\n\n        if decorate:\n            # Decorate all sites in the underlying structure\n            # with site properties that provides information on the\n            # coordination number and coordination pattern based\n            # on the (current) structure of this graph.\n            order_parameters = [self.get_local_order_parameters(structure, n)\n                                for n in range(len(structure))]\n            structure.add_site_property('order_parameters', order_parameters)\n\n        sg = StructureGraph.with_local_env_strategy(structure, self)\n\n        return sg", "response": "Returns a BondedStructure object using this NearNeighbor\n        class."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_voronoi_polyhedra(self, structure, n):\n\n        # Assemble the list of neighbors used in the tessellation\n        #   Gets all atoms within a certain radius\n        if self.targets is None:\n            targets = structure.composition.elements\n        else:\n            targets = self.targets\n        center = structure[n]\n\n        cutoff = self.cutoff\n\n        # max cutoff is the longest diagonal of the cell + room for noise\n        corners = [[1, 1, 1], [-1, 1, 1], [1, -1, 1], [1, 1, -1]]\n        d_corners = [np.linalg.norm(structure.lattice.get_cartesian_coords(c))\n                     for c in corners]\n        max_cutoff = max(d_corners) + 0.01\n\n        while True:\n            try:\n                neighbors = structure.get_sites_in_sphere(\n                    center.coords, cutoff)\n                neighbors = [i[0] for i in\n                             sorted(neighbors, key=lambda s: s[1])]\n\n                # Run the Voronoi tessellation\n                qvoronoi_input = [s.coords for s in neighbors]\n\n                voro = Voronoi(\n                    qvoronoi_input)  # can give seg fault if cutoff is too small\n\n                # Extract data about the site in question\n                cell_info = self._extract_cell_info(\n                    structure, 0, neighbors, targets, voro,\n                    self.compute_adj_neighbors)\n                break\n\n            except RuntimeError as e:\n                if cutoff >= max_cutoff:\n                    if e.args and \"vertex\" in e.args[0]:\n                        # pass through the error raised by _extract_cell_info\n                        raise e\n                    else:\n                        raise RuntimeError(\"Error in Voronoi neighbor finding; \"\n                                           \"max cutoff exceeded\")\n                cutoff = min(cutoff * 2, max_cutoff + 0.001)\n        return cell_info", "response": "Returns a dict of sites sharing a common Voronoi facet with the site n mapped to a directory containing statistics about the Voronoi cell."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_all_voronoi_polyhedra(self, structure):\n\n        # Special case: For atoms with 1 site, the atom in the root image is not included\n        #   in the get_all_neighbors output. Rather than creating logic to add that atom\n        #   to the neighbor list, which requires detecting whether it will be translated\n        #   to reside within the unit cell before neighbor detection, it is less complex\n        #   to just call the one-by-one operation\n        if len(structure) == 1:\n            return [self.get_voronoi_polyhedra(structure, 0)]\n\n        # Assemble the list of neighbors used in the tessellation\n        if self.targets is None:\n            targets = structure.composition.elements\n        else:\n            targets = self.targets\n\n        # Initialize the list of sites with the atoms in the origin unit cell\n        #  The `get_all_neighbors` function returns neighbors for each site's image in the\n        #   original unit cell. We start off with these central atoms to ensure they are\n        #   included in the tessellation\n\n        sites = [x.to_unit_cell() for x in structure]\n        indices = [(i, 0, 0, 0) for i, _ in enumerate(structure)]\n\n        # Get all neighbors within a certain cutoff\n        #   Record both the list of these neighbors, and the site indices\n        all_neighs = structure.get_all_neighbors(self.cutoff,\n                                                 include_index=True,\n                                                 include_image=True)\n        for neighs in all_neighs:\n            sites.extend([x[0] for x in neighs])\n            indices.extend([(x[2],) + x[3] for x in neighs])\n\n        # Get the non-duplicates (using the site indices for performance/numerical stability)\n        indices = np.array(indices, dtype=np.int)\n        indices, uniq_inds = np.unique(indices, return_index=True, axis=0)\n        sites = np.array(sites)[uniq_inds]\n\n        # Sort array such that atoms in the root image are first\n        #   Exploit the fact that the array is sorted by the unique operation such that\n        #   the images associated with atom 0 are first, followed by atom 1, etc.\n        root_images, = np.nonzero(np.abs(indices[:, 1:]).max(axis=1) == 0)\n\n        del indices  # Save memory (tessellations can be costly)\n\n        # Run the tessellation\n        qvoronoi_input = [s.coords for s in sites]\n        voro = Voronoi(qvoronoi_input)\n\n        # Get the information for each neighbor\n        return [self._extract_cell_info(structure, i, sites, targets,\n                                        voro, self.compute_adj_neighbors)\n                for i in root_images.tolist()]", "response": "Returns a dict of sites sharing a common Voronoi facet with the site n mapped to a directory containing statistics about the Voronoi facet."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _get_elements(self, site):\n        try:\n            if isinstance(site.specie, Element):\n                return [site.specie]\n            return [Element(site.specie)]\n        except:\n            return site.species.elements", "response": "Get the list of elements for a Site\n             site"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ntests whether a site contains elements in the target list", "response": "def _is_in_targets(self, site, targets):\n        \"\"\"\n        Test whether a site contains elements in the target list\n\n        Args:\n            site (Site): Site to assess\n            targets ([Element]) List of elements\n        Returns:\n             (boolean) Whether this site contains a certain list of elements\n        \"\"\"\n        elems = self._get_elements(site)\n        for elem in elems:\n            if elem not in targets:\n                return False\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _extract_cell_info(self, structure, site_idx, sites, targets, voro,\n                           compute_adj_neighbors=False):\n        \"\"\"Get the information about a certain atom from the results of a tessellation\n\n        Args:\n            structure (Structure) - Structure being assessed\n            site_idx (int) - Index of the atom in question\n            sites ([Site]) - List of all sites in the tessellation\n            targets ([Element]) - Target elements\n            voro - Output of qvoronoi\n            compute_adj_neighbors (boolean) - Whether to compute which neighbors are adjacent\n        Returns:\n            A dict of sites sharing a common Voronoi facet. Key is facet id\n             (not useful) and values are dictionaries containing statistics\n             about the facet:\n                - site: Pymatgen site\n                - solid_angle - Solid angle subtended by face\n                - angle_normalized - Solid angle normalized such that the\n                    faces with the largest\n                - area - Area of the facet\n                - face_dist - Distance between site n and the facet\n                - volume - Volume of Voronoi cell for this face\n                - n_verts - Number of vertices on the facet\n                - adj_neighbors - Facet id's for the adjacent neighbors\n        \"\"\"\n        # Get the coordinates of every vertex\n        all_vertices = voro.vertices\n\n        # Get the coordinates of the central site\n        center_coords = sites[site_idx].coords\n\n        # Iterate through all the faces in the tessellation\n        results = {}\n        for nn, vind in voro.ridge_dict.items():\n            # Get only those that include the cite in question\n            if site_idx in nn:\n                other_site = nn[0] if nn[1] == site_idx else nn[1]\n                if -1 in vind:\n                    # -1 indices correspond to the Voronoi cell\n                    #  missing a face\n                    if self.allow_pathological:\n                        continue\n                    else:\n                        raise RuntimeError(\"This structure is pathological,\"\n                                           \" infinite vertex in the voronoi \"\n                                           \"construction\")\n\n                # Get the solid angle of the face\n                facets = [all_vertices[i] for i in vind]\n                angle = solid_angle(center_coords, facets)\n\n                # Compute the volume of associated with this face\n                volume = 0\n                #  qvoronoi returns vertices in CCW order, so I can break\n                #   the face up in to segments (0,1,2), (0,2,3), ... to compute\n                #   its area where each number is a vertex size\n                for j, k in zip(vind[1:], vind[2:]):\n                    volume += vol_tetra(center_coords,\n                                        all_vertices[vind[0]],\n                                        all_vertices[j],\n                                        all_vertices[k])\n\n                # Compute the distance of the site to the face\n                face_dist = np.linalg.norm(\n                    center_coords - sites[other_site].coords) / 2\n\n                # Compute the area of the face (knowing V=Ad/3)\n                face_area = 3 * volume / face_dist\n\n                # Compute the normal of the facet\n                normal = np.subtract(sites[other_site].coords, center_coords)\n                normal /= np.linalg.norm(normal)\n\n                # Store by face index\n                results[other_site] = {\n                    'site': sites[other_site],\n                    'normal': normal,\n                    'solid_angle': angle,\n                    'volume': volume,\n                    'face_dist': face_dist,\n                    'area': face_area,\n                    'n_verts': len(vind)\n                }\n\n                # If we are computing which neighbors are adjacent, store the vertices\n                if compute_adj_neighbors:\n                    results[other_site]['verts'] = vind\n\n        # Get only target elements\n        resultweighted = {}\n        for nn_index, nstats in results.items():\n            # Check if this is a target site\n            nn = nstats['site']\n            if nn.is_ordered:\n                if nn.specie in targets:\n                    resultweighted[nn_index] = nstats\n            else:  # is nn site is disordered\n                for disordered_sp in nn.species.keys():\n                    if disordered_sp in targets:\n                        resultweighted[nn_index] = nstats\n\n        # If desired, determine which neighbors are adjacent\n        if compute_adj_neighbors:\n            # Initialize storage for the adjacent neighbors\n            adj_neighbors = dict((i, []) for i in resultweighted.keys())\n\n            # Find the neighbors that are adjacent by finding those\n            #  that contain exactly two vertices\n            for a_ind, a_nninfo in resultweighted.items():\n                # Get the indices for this site\n                a_verts = set(a_nninfo['verts'])\n\n                # Loop over all neighbors that have an index lower that this one\n                #  The goal here is to exploit the fact that neighbor adjacency is symmetric\n                #  (if A is adj to B, B is adj to A)\n                for b_ind, b_nninfo in resultweighted.items():\n                    if b_ind > a_ind:\n                        continue\n                    if len(a_verts.intersection(b_nninfo['verts'])) == 2:\n                        adj_neighbors[a_ind].append(b_ind)\n                        adj_neighbors[b_ind].append(a_ind)\n\n            # Store the results in the nn_info\n            for key, neighbors in adj_neighbors.items():\n                resultweighted[key]['adj_neighbors'] = neighbors\n\n        return resultweighted", "response": "Extract the information about a certain atom from the results of a tessellation of a Voronoi cell."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_nn_info(self, structure, n):\n\n        # Run the tessellation\n        nns = self.get_voronoi_polyhedra(structure, n)\n\n        # Extract the NN info\n        return self._extract_nn_info(structure, nns)", "response": "Get all near - neighbor sites as well as the associated image locations and weights of the site with index n in structure\n       ."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _extract_nn_info(self, structure, nns):\n\n        # Get the target information\n        if self.targets is None:\n            targets = structure.composition.elements\n        else:\n            targets = self.targets\n\n        # Extract the NN info\n        siw = []\n        max_weight = max(nn[self.weight] for nn in nns.values())\n        for nstats in nns.values():\n            site = nstats['site']\n            if nstats[self.weight] > self.tol * max_weight \\\n                    and self._is_in_targets(site, targets):\n                nn_info = {'site': site,\n                           'image': self._get_image(structure, site),\n                           'weight': nstats[self.weight] / max_weight,\n                           'site_index': self._get_original_site(\n                               structure, site)}\n\n                if self.extra_nn_info:\n                    # Add all the information about the site\n                    poly_info = nstats\n                    del poly_info['site']\n                    nn_info['poly_info'] = poly_info\n                siw.append(nn_info)\n        return siw", "response": "Given Voronoi NNs extract the NN info in the form needed by NearestNeighbors\n           ."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_max_bond_distance(self, el1_sym, el2_sym):\n        return sqrt(\n            (self.el_radius[el1_sym] + self.el_radius[el2_sym] + self.tol) ** 2)", "response": "This function returns the maximum bond length from the atomic parameters of the atom 1 and atom 2."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a list of tuples each site and image location and weight of the site with index n.", "response": "def get_nn_info(self, structure, n):\n        \"\"\"\n        Get all near-neighbor sites as well as the associated image locations\n        and weights of the site with index n using the bond identification\n        algorithm underlying Jmol.\n\n        Args:\n            structure (Structure): input structure.\n            n (integer): index of site for which to determine near\n                neighbors.\n \n        Returns:\n            siw (list of tuples (Site, array, float)): tuples, each one\n                of which represents a neighbor site, its image location,\n                and its weight.\n        \"\"\"\n\n        site = structure[n]\n\n        # Determine relevant bond lengths based on atomic radii table\n        bonds = {}\n        for el in structure.composition.elements:\n            bonds[site.specie, el] = self.get_max_bond_distance(\n                site.specie.symbol, el.symbol)\n\n        # Search for neighbors up to max bond length + tolerance\n        max_rad = max(bonds.values()) + self.tol\n        min_rad = min(bonds.values())\n\n        siw = []\n        for neighb, dist in structure.get_neighbors(site, max_rad):\n            # Confirm neighbor based on bond length specific to atom pair\n            if dist <= (bonds[(site.specie, neighb.specie)]) and (\n                    dist > self.min_bond_distance):\n                weight = min_rad / dist\n                siw.append({'site': neighb,\n                            'image': self._get_image(structure, neighb),\n                            'weight': weight,\n                            'site_index': self._get_original_site(structure,\n                                                                  neighb)})\n        return siw"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_nn_info(self, structure, n):\n\n        site = structure[n]\n        neighs_dists = structure.get_neighbors(site, self.cutoff)\n\n        siw = []\n        if self.get_all_sites == True:\n            for s, dist in neighs_dists:\n                    w = dist\n                    siw.append({'site': s,\n                                'image': self._get_image(structure, s),\n                                'weight': w,\n                                'site_index': self._get_original_site(structure,\n                                                                  s)})\n        else:\n            min_dist = min([dist for neigh, dist in neighs_dists])\n            for s, dist in neighs_dists:\n                if dist < (1.0 + self.tol) * min_dist:\n                    w = min_dist / dist\n                    siw.append({'site': s,\n                                'image': self._get_image(structure, s),\n                                'weight': w,\n                                'site_index': self._get_original_site(structure,\n                                                                  s)})\n        return siw", "response": "Get all near - neighbor sites as well as the associated image locations\n        and weights of the site with index n using the closest neighbor\nMimeType method."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_nn_info(self, structure, n):\n\n        from pymatgen.io.babel import BabelMolAdaptor\n\n        obmol = BabelMolAdaptor(structure).openbabel_mol\n\n        siw = []\n\n        # Get only the atom of interest\n        site_atom = [a for i, a in enumerate(ob.OBMolAtomDFSIter(obmol))\n                     if [a.GetX(), a.GetY(), a.GetZ()] == list(\n                structure[n].coords)][0]\n\n        for neighbor in ob.OBAtomAtomIter(site_atom):\n            coords = [neighbor.GetX(), neighbor.GetY(), neighbor.GetZ()]\n            site = [a for a in structure if list(a.coords) == coords][0]\n            index = structure.index(site)\n\n            bond = site_atom.GetBond(neighbor)\n\n            if self.order:\n                obmol.PerceiveBondOrders()\n                weight = bond.GetBondOrder()\n            else:\n                weight = bond.GetLength()\n\n            siw.append({\"site\": site,\n                        \"image\": (0, 0, 0),\n                        \"weight\": weight,\n                        \"site_index\": index})\n\n        return siw", "response": "Get all near - neighbor sites and weights of bonds for a given site n."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a MoleculeGraph object that is bonded by the given structure.", "response": "def get_bonded_structure(self, structure, decorate=False):\n        \"\"\"\n        Obtain a MoleculeGraph object using this NearNeighbor\n        class. Requires the optional dependency networkx\n        (pip install networkx).\n\n        Args:\n            structure: Molecule object.\n            decorate (bool): whether to annotate site properties\n            with order parameters using neighbors determined by\n            this NearNeighbor class\n\n        Returns: a pymatgen.analysis.graphs.MoleculeGraph object\n        \"\"\"\n\n        # requires optional dependency which is why it's not a top-level import\n        from pymatgen.analysis.graphs import MoleculeGraph\n\n        if decorate:\n            # Decorate all sites in the underlying structure\n            # with site properties that provides information on the\n            # coordination number and coordination pattern based\n            # on the (current) structure of this graph.\n            order_parameters = [self.get_local_order_parameters(structure, n)\n                                for n in range(len(structure))]\n            structure.add_site_property('order_parameters', order_parameters)\n\n        mg = MoleculeGraph.with_local_env_strategy(structure, self)\n\n        return mg"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_nn_shell_info(self, structure, site_idx, shell):\n\n        all_nn_info = self.get_all_nn_info(structure)\n        sites = self._get_nn_shell_info(structure, all_nn_info, site_idx, shell)\n\n        # Update the site positions\n        #   Did not do this during NN options because that can be slower\n        output = []\n        for info in sites:\n            orig_site = structure[info['site_index']]\n            info['site'] = Site(orig_site.species,\n                                orig_site._coords,\n                                properties=orig_site.properties)\n            output.append(info)\n        return output", "response": "Get a certain nearest neighbor shell for a certain site."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_nn_info(self, structure, n):\n\n        # This is unfortunately inefficient, but is the best way to fit the\n        # current NearNeighbors scheme\n        self.bonds = structure.get_covalent_bonds(tol=self.tol)\n\n        siw = []\n\n        for bond in self.bonds:\n            capture_bond = False\n            if bond.site1 == structure[n]:\n                site = bond.site2\n                capture_bond = True\n            elif bond.site2 == structure[n]:\n                site = bond.site1\n                capture_bond = True\n\n            if capture_bond:\n                index = structure.index(site)\n                if self.order:\n                    weight = bond.get_bond_order()\n                else:\n                    weight = bond.length\n\n                siw.append({\"site\": site,\n                            \"image\": (0, 0, 0),\n                            \"weight\": weight,\n                            \"site_index\": index})\n\n        return siw", "response": "Get all near - neighbor sites and weights of a given atom."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_nn_info(self, structure, n):\n\n        site = structure[n]\n        neighs_dists = structure.get_neighbors(site, self.cutoff)\n        try:\n            eln = site.specie.element\n        except:\n            eln = site.species_string\n\n        reldists_neighs = []\n        for neigh, dist in neighs_dists:\n            try:\n                el2 = neigh.specie.element\n            except:\n                el2 = neigh.species_string\n            reldists_neighs.append([dist / get_okeeffe_distance_prediction(\n                eln, el2), neigh])\n\n        siw = []\n        min_reldist = min([reldist for reldist, neigh in reldists_neighs])\n        for reldist, s in reldists_neighs:\n            if reldist < (1.0 + self.tol) * min_reldist:\n                w = min_reldist / reldist\n                siw.append({'site': s,\n                            'image': self._get_image(structure, s),\n                            'weight': w,\n                            'site_index': self._get_original_site(structure,\n                                                                  s)})\n\n        return siw", "response": "Returns a list of tuples each site and image location and weight of the site with index n."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_nn_info(self, structure, n):\n\n        vire = ValenceIonicRadiusEvaluator(structure)\n        site = vire.structure[n]\n        neighs_dists = vire.structure.get_neighbors(site, self.cutoff)\n        rn = vire.radii[vire.structure[n].species_string]\n\n        reldists_neighs = []\n        for neigh, dist in neighs_dists:\n            reldists_neighs.append([dist / (\n                    vire.radii[neigh.species_string] + rn), neigh])\n\n        siw = []\n        min_reldist = min([reldist for reldist, neigh in reldists_neighs])\n        for reldist, s in reldists_neighs:\n            if reldist < (1.0 + self.tol) * min_reldist:\n                w = min_reldist / reldist\n                siw.append({'site': s,\n                            'image': self._get_image(vire.structure, s),\n                            'weight': w,\n                            'site_index': self._get_original_site(\n                                vire.structure, s)})\n\n        return siw", "response": "Get all near - neighbor sites as well as the associated image locations and weights of the site with index n using the closest relative ionic radius - based method with VIRE atomic - radii."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef compute_trigonometric_terms(self, thetas, phis):\n\n        \"\"\"\"\n        Computes trigonometric terms that are required to\n        calculate bond orientational order parameters using\n        internal variables.\n\n        Args:\n            thetas ([float]): polar angles of all neighbors in radians.\n            phis ([float]): azimuth angles of all neighbors in radians.\n                The list of\n                azimuth angles of all neighbors in radians.  The list of\n                azimuth angles is expected to have the same size as the\n                list of polar angles; otherwise, a ValueError is raised.\n                Also, the two lists of angles have to be coherent in\n                order. That is, it is expected that the order in the list\n                of azimuth angles corresponds to a distinct sequence of\n                neighbors. And, this sequence has to equal the sequence\n                of neighbors in the list of polar angles.\n\n        \"\"\"\n\n        if len(thetas) != len(phis):\n            raise ValueError(\"List of polar and azimuthal angles have to be\"\n                             \" equal!\")\n\n        self._pow_sin_t.clear()\n        self._pow_cos_t.clear()\n        self._sin_n_p.clear()\n        self._cos_n_p.clear()\n\n        self._pow_sin_t[1] = [sin(float(t)) for t in thetas]\n        self._pow_cos_t[1] = [cos(float(t)) for t in thetas]\n        self._sin_n_p[1] = [sin(float(p)) for p in phis]\n        self._cos_n_p[1] = [cos(float(p)) for p in phis]\n\n        for i in range(2, self._max_trig_order + 1):\n            self._pow_sin_t[i] = [e[0] * e[1] for e in zip(\n                self._pow_sin_t[i - 1], self._pow_sin_t[1])]\n            self._pow_cos_t[i] = [e[0] * e[1] for e in zip(\n                self._pow_cos_t[i - 1], self._pow_cos_t[1])]\n            self._sin_n_p[i] = [sin(float(i) * float(p)) \\\n                                for p in phis]\n            self._cos_n_p[i] = [cos(float(i) * float(p)) \\\n                                for p in phis]", "response": "This function calculates the trigonometric terms that are required to be used to generate the bond orientational order parameters for the current object."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_q2(self, thetas=None, phis=None):\n\n        \"\"\"\n        Calculates the value of the bond orientational order parameter of\n        weight l=2.  If the function is called with non-empty lists of\n        polar and azimuthal angles the corresponding trigonometric terms\n        are computed afresh.  Otherwise, it is expected that the\n        compute_trigonometric_terms function has been just called.\n\n        Args:\n            thetas ([float]): polar angles of all neighbors in radians.\n            phis ([float]): azimuth angles of all neighbors in radians.\n\n        Returns:\n            float: bond orientational order parameter of weight l=2\n                corresponding to the input angles thetas and phis.\n        \"\"\"\n\n        if thetas is not None and phis is not None:\n            self.compute_trigonometric_terms(thetas, phis)\n        nnn = len(self._pow_sin_t[1])\n        nnn_range = range(nnn)\n\n        sqrt_15_2pi = sqrt(15.0 / (2.0 * pi))\n        sqrt_5_pi = sqrt(5.0 / pi)\n\n        pre_y_2_2 = [0.25 * sqrt_15_2pi * val for val in self._pow_sin_t[2]]\n        pre_y_2_1 = [0.5 * sqrt_15_2pi * val[0] * val[1]\n                     for val in zip(self._pow_sin_t[1], self._pow_cos_t[1])]\n\n        acc = 0.0\n\n        # Y_2_-2\n        real = imag = 0.0\n        for i in nnn_range:\n            real += pre_y_2_2[i] * self._cos_n_p[2][i]\n            imag -= pre_y_2_2[i] * self._sin_n_p[2][i]\n        acc += (real * real + imag * imag)\n\n        # Y_2_-1\n        real = imag = 0.0\n        for i in nnn_range:\n            real += pre_y_2_1[i] * self._cos_n_p[1][i]\n            imag -= pre_y_2_1[i] * self._sin_n_p[1][i]\n        acc += (real * real + imag * imag)\n\n        # Y_2_0\n        real = imag = 0.0\n        for i in nnn_range:\n            real += 0.25 * sqrt_5_pi * (3.0 * self._pow_cos_t[2][i] - 1.0)\n        acc += (real * real)\n\n        # Y_2_1\n        real = imag = 0.0\n        for i in nnn_range:\n            real -= pre_y_2_1[i] * self._cos_n_p[1][i]\n            imag -= pre_y_2_1[i] * self._sin_n_p[1][i]\n        acc += (real * real + imag * imag)\n\n        # Y_2_2\n        real = imag = 0.0\n        for i in nnn_range:\n            real += pre_y_2_2[i] * self._cos_n_p[2][i]\n            imag += pre_y_2_2[i] * self._sin_n_p[2][i]\n        acc += (real * real + imag * imag)\n\n        q2 = sqrt(4.0 * pi * acc / (5.0 * float(nnn * nnn)))\n        return q2", "response": "Calculates the value of the bond orientational order parameter of the entry of the class 2."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncalculating the value of the bond orientational order parameter of the internal system of the acquisition system.", "response": "def get_q4(self, thetas=None, phis=None):\n\n        \"\"\"\n        Calculates the value of the bond orientational order parameter of\n        weight l=4.  If the function is called with non-empty lists of\n        polar and azimuthal angles the corresponding trigonometric terms\n        are computed afresh.  Otherwise, it is expected that the\n        compute_trigonometric_terms function has been just called.\n\n        Args:\n            thetas ([float]): polar angles of all neighbors in radians.\n            phis ([float]): azimuth angles of all neighbors in radians.\n\n        Returns:\n            float: bond orientational order parameter of weight l=4\n                corresponding to the input angles thetas and phis.\n        \"\"\"\n\n        if thetas is not None and phis is not None:\n            self.compute_trigonometric_terms(thetas, phis)\n        nnn = len(self._pow_sin_t[1])\n        nnn_range = range(nnn)\n\n        i16_3 = 3.0 / 16.0\n        i8_3 = 3.0 / 8.0\n\n        sqrt_35_pi = sqrt(35.0 / pi)\n        sqrt_35_2pi = sqrt(35.0 / (2.0 * pi))\n        sqrt_5_pi = sqrt(5.0 / pi)\n        sqrt_5_2pi = sqrt(5.0 / (2.0 * pi))\n        sqrt_1_pi = sqrt(1.0 / pi)\n\n        pre_y_4_4 = [i16_3 * sqrt_35_2pi * val for val in self._pow_sin_t[4]]\n        pre_y_4_3 = [i8_3 * sqrt_35_pi * val[0] * val[1] \\\n                     for val in zip(self._pow_sin_t[3], self._pow_cos_t[1])]\n        pre_y_4_2 = [i8_3 * sqrt_5_2pi * val[0] * (7.0 * val[1] - 1.0) \\\n                     for val in zip(self._pow_sin_t[2], self._pow_cos_t[2])]\n        pre_y_4_1 = [i8_3 * sqrt_5_pi * val[0] * (7.0 * val[1] - 3.0 * val[2]) \\\n                     for val in zip(self._pow_sin_t[1], self._pow_cos_t[3], \\\n                                    self._pow_cos_t[1])]\n\n        acc = 0.0\n\n        # Y_4_-4\n        real = imag = 0.0\n        for i in nnn_range:\n            real += pre_y_4_4[i] * self._cos_n_p[4][i]\n            imag -= pre_y_4_4[i] * self._sin_n_p[4][i]\n        acc += (real * real + imag * imag)\n\n        # Y_4_-3\n        real = imag = 0.0\n        for i in nnn_range:\n            real += pre_y_4_3[i] * self._cos_n_p[3][i]\n            imag -= pre_y_4_3[i] * self._sin_n_p[3][i]\n        acc += (real * real + imag * imag)\n\n        # Y_4_-2\n        real = imag = 0.0\n        for i in nnn_range:\n            real += pre_y_4_2[i] * self._cos_n_p[2][i]\n            imag -= pre_y_4_2[i] * self._sin_n_p[2][i]\n        acc += (real * real + imag * imag)\n\n        # Y_4_-1\n        real = imag = 0.0\n        for i in nnn_range:\n            real += pre_y_4_1[i] * self._cos_n_p[1][i]\n            imag -= pre_y_4_1[i] * self._sin_n_p[1][i]\n        acc += (real * real + imag * imag)\n\n        # Y_4_0\n        real = imag = 0.0\n        for i in nnn_range:\n            real += i16_3 * sqrt_1_pi * (35.0 * self._pow_cos_t[4][i] - \\\n                                         30.0 * self._pow_cos_t[2][i] + 3.0)\n        acc += (real * real)\n\n        # Y_4_1\n        real = imag = 0.0\n        for i in nnn_range:\n            real -= pre_y_4_1[i] * self._cos_n_p[1][i]\n            imag -= pre_y_4_1[i] * self._sin_n_p[1][i]\n        acc += (real * real + imag * imag)\n\n        # Y_4_2\n        real = imag = 0.0\n        for i in nnn_range:\n            real += pre_y_4_2[i] * self._cos_n_p[2][i]\n            imag += pre_y_4_2[i] * self._sin_n_p[2][i]\n        acc += (real * real + imag * imag)\n\n        # Y_4_3\n        real = imag = 0.0\n        for i in nnn_range:\n            real -= pre_y_4_3[i] * self._cos_n_p[3][i]\n            imag -= pre_y_4_3[i] * self._sin_n_p[3][i]\n        acc += (real * real + imag * imag)\n\n        # Y_4_4\n        real = imag = 0.0\n        for i in nnn_range:\n            real += pre_y_4_4[i] * self._cos_n_p[4][i]\n            imag += pre_y_4_4[i] * self._sin_n_p[4][i]\n        acc += (real * real + imag * imag)\n\n        q4 = sqrt(4.0 * pi * acc / (9.0 * float(nnn * nnn)))\n        return q4"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_q6(self, thetas=None, phis=None):\n\n        \"\"\"\n        Calculates the value of the bond orientational order parameter of\n        weight l=6.  If the function is called with non-empty lists of\n        polar and azimuthal angles the corresponding trigonometric terms\n        are computed afresh.  Otherwise, it is expected that the\n        compute_trigonometric_terms function has been just called.\n\n        Args:\n            thetas ([float]): polar angles of all neighbors in radians.\n            phis ([float]): azimuth angles of all neighbors in radians.\n\n        Returns:\n            float: bond orientational order parameter of weight l=6\n                corresponding to the input angles thetas and phis.\n        \"\"\"\n\n        if thetas is not None and phis is not None:\n            self.compute_trigonometric_terms(thetas, phis)\n        nnn = len(self._pow_sin_t[1])\n        nnn_range = range(nnn)\n\n        i64 = 1.0 / 64.0\n        i32 = 1.0 / 32.0\n        i32_3 = 3.0 / 32.0\n        i16 = 1.0 / 16.0\n\n        sqrt_3003_pi = sqrt(3003.0 / pi)\n        sqrt_1001_pi = sqrt(1001.0 / pi)\n        sqrt_91_2pi = sqrt(91.0 / (2.0 * pi))\n        sqrt_1365_pi = sqrt(1365.0 / pi)\n        sqrt_273_2pi = sqrt(273.0 / (2.0 * pi))\n        sqrt_13_pi = sqrt(13.0 / pi)\n\n        pre_y_6_6 = [i64 * sqrt_3003_pi * val for val in self._pow_sin_t[6]]\n        pre_y_6_5 = [i32_3 * sqrt_1001_pi * val[0] * val[1]\n                     for val in zip(self._pow_sin_t[5], self._pow_cos_t[1])]\n        pre_y_6_4 = [i32_3 * sqrt_91_2pi * val[0] * (11.0 * val[1] - 1.0)\n                     for val in zip(self._pow_sin_t[4], self._pow_cos_t[2])]\n        pre_y_6_3 = [\n            i32 * sqrt_1365_pi * val[0] * (11.0 * val[1] - 3.0 * val[2])\n            for val in zip(self._pow_sin_t[3], self._pow_cos_t[3],\n                           self._pow_cos_t[1])]\n        pre_y_6_2 = [i64 * sqrt_1365_pi * val[0] * (33.0 * val[1] -\n                                                    18.0 * val[2] + 1.0) for val\n                     in zip(self._pow_sin_t[2],\n                            self._pow_cos_t[4], self._pow_cos_t[2])]\n        pre_y_6_1 = [i16 * sqrt_273_2pi * val[0] * (33.0 * val[1] -\n                                                    30.0 * val[2] + 5.0 * val[\n                                                        3]) for val in\n                     zip(self._pow_sin_t[1],\n                         self._pow_cos_t[5], self._pow_cos_t[3],\n                         self._pow_cos_t[1])]\n\n        acc = 0.0\n\n        # Y_6_-6\n        real = 0.0\n        imag = 0.0\n        for i in nnn_range:\n            real += pre_y_6_6[i] * self._cos_n_p[6][i]  # cos(x) =  cos(-x)\n            imag -= pre_y_6_6[i] * self._sin_n_p[6][i]  # sin(x) = -sin(-x)\n        acc += (real * real + imag * imag)\n\n        # Y_6_-5\n        real = 0.0\n        imag = 0.0\n        for i in nnn_range:\n            real += pre_y_6_5[i] * self._cos_n_p[5][i]\n            imag -= pre_y_6_5[i] * self._sin_n_p[5][i]\n        acc += (real * real + imag * imag)\n\n        # Y_6_-4\n        real = 0.0\n        imag = 0.0\n        for i in nnn_range:\n            real += pre_y_6_4[i] * self._cos_n_p[4][i]\n            imag -= pre_y_6_4[i] * self._sin_n_p[4][i]\n        acc += (real * real + imag * imag)\n\n        # Y_6_-3\n        real = 0.0\n        imag = 0.0\n        for i in nnn_range:\n            real += pre_y_6_3[i] * self._cos_n_p[3][i]\n            imag -= pre_y_6_3[i] * self._sin_n_p[3][i]\n        acc += (real * real + imag * imag)\n\n        # Y_6_-2\n        real = 0.0\n        imag = 0.0\n        for i in nnn_range:\n            real += pre_y_6_2[i] * self._cos_n_p[2][i]\n            imag -= pre_y_6_2[i] * self._sin_n_p[2][i]\n        acc += (real * real + imag * imag)\n\n        # Y_6_-1\n        real = 0.0\n        imag = 0.0\n        for i in nnn_range:\n            real += pre_y_6_1[i] * self._cos_n_p[1][i]\n            imag -= pre_y_6_1[i] * self._sin_n_p[1][i]\n        acc += (real * real + imag * imag)\n\n        # Y_6_0\n        real = 0.0\n        imag = 0.0\n        for i in nnn_range:\n            real += i32 * sqrt_13_pi * (231.0 * self._pow_cos_t[6][i] -\n                                        315.0 * self._pow_cos_t[4][i] + 105.0 *\n                                        self._pow_cos_t[2][i] - 5.0)\n        acc += (real * real)\n\n        # Y_6_1\n        real = 0.0\n        imag = 0.0\n        for i in nnn_range:\n            real -= pre_y_6_1[i] * self._cos_n_p[1][i]\n            imag -= pre_y_6_1[i] * self._sin_n_p[1][i]\n        acc += (real * real + imag * imag)\n\n        # Y_6_2\n        real = 0.0\n        imag = 0.0\n        for i in nnn_range:\n            real += pre_y_6_2[i] * self._cos_n_p[2][i]\n            imag += pre_y_6_2[i] * self._sin_n_p[2][i]\n        acc += (real * real + imag * imag)\n\n        # Y_6_3\n        real = 0.0\n        imag = 0.0\n        for i in nnn_range:\n            real -= pre_y_6_3[i] * self._cos_n_p[3][i]\n            imag -= pre_y_6_3[i] * self._sin_n_p[3][i]\n        acc += (real * real + imag * imag)\n\n        # Y_6_4\n        real = 0.0\n        imag = 0.0\n        for i in nnn_range:\n            real += pre_y_6_4[i] * self._cos_n_p[4][i]\n            imag += pre_y_6_4[i] * self._sin_n_p[4][i]\n        acc += (real * real + imag * imag)\n\n        # Y_6_5\n        real = 0.0\n        imag = 0.0\n        for i in nnn_range:\n            real -= pre_y_6_5[i] * self._cos_n_p[5][i]\n            imag -= pre_y_6_5[i] * self._sin_n_p[5][i]\n        acc += (real * real + imag * imag)\n\n        # Y_6_6\n        real = 0.0\n        imag = 0.0\n        for i in nnn_range:\n            real += pre_y_6_6[i] * self._cos_n_p[6][i]\n            imag += pre_y_6_6[i] * self._sin_n_p[6][i]\n        acc += (real * real + imag * imag)\n\n        q6 = sqrt(4.0 * pi * acc / (13.0 * float(nnn * nnn)))\n        return q6", "response": "Calculates the value of the bond orientational order parameter of the specified polar and azimuthal angles."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the type of order parameter at the index provided and represented by a short string.", "response": "def get_type(self, index):\n\n        \"\"\"\n        Return type of order parameter at the index provided and\n        represented by a short string.\n\n        Args:\n            index (int): index of order parameter for which type is\n                to be returned.\n        Returns:\n            str: OP type.\n        \"\"\"\n        if index < 0 or index >= len(self._types):\n            raise ValueError(\"Index for getting order parameter type\"\n                             \" out-of-bounds!\")\n        return self._types[index]"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the list of floats that represents the parameters associated with the order parameter calculation of the order parameter that was defined at the index.", "response": "def get_parameters(self, index):\n\n        \"\"\"\n        Returns list of floats that represents\n        the parameters associated\n        with calculation of the order\n        parameter that was defined at the index provided.\n        Attention: the parameters do not need to equal those originally\n        inputted because of processing out of efficiency reasons.\n\n        Args:\n            index (int):\n                index of order parameter for which associated parameters\n                are to be returned.\n        Returns:\n            [float]: parameters of a given OP.\n        \"\"\"\n        if index < 0 or index >= len(self._types):\n            raise ValueError(\"Index for getting parameters associated with\"\n                             \" order parameter calculation out-of-bounds!\")\n        return self._params[index]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_order_parameters(self, structure, n, indices_neighs=None, \\\n                             tol=0.0, target_spec=None):\n\n        \"\"\"\n        Compute all order parameters of site n.\n\n        Args:\n            structure (Structure): input structure.\n            n (int): index of site in input structure,\n                for which OPs are to be\n                calculated.  Note that we do not use the sites iterator\n                here, but directly access sites via struct[index].\n            indices_neighs ([int]): list of indices of those neighbors\n                in Structure object\n                structure that are to be considered for OP computation.\n                This optional argument overwrites the way neighbors are\n                to be determined as defined in the constructor (i.e.,\n                Voronoi coordination finder via negative cutoff radius\n                vs constant cutoff radius if cutoff was positive).\n                We do not use information about the underlying\n                structure lattice if the neighbor indices are explicitly\n                provided.  This has two important consequences.  First,\n                the input Structure object can, in fact, be a\n                simple list of Site objects.  Second, no nearest images\n                of neighbors are determined when providing an index list.\n                Note furthermore that this neighbor\n                determination type ignores the optional target_spec\n                argument.\n            tol (float): threshold of weight\n                (= solid angle / maximal solid angle)\n                to determine if a particular pair is\n                considered neighbors; this is relevant only in the case\n                when Voronoi polyhedra are used to determine coordination\n            target_spec (Specie): target species to be considered\n                when calculating the order\n                parameters of site n; None includes all species of input\n                structure.\n\n        Returns:\n            [floats]: representing order parameters.  Should it not be\n            possible to compute a given OP for a conceptual reason, the\n            corresponding entry is None instead of a float.  For Steinhardt\n            et al.'s bond orientational OPs and the other geometric OPs\n            (\"tet\", \"oct\", \"bcc\", etc.),\n            this can happen if there is a single\n            neighbor around site n in the structure because that\n            does not permit calculation of angles between multiple\n            neighbors.\n        \"\"\"\n\n        # Do error-checking and initialization.\n        if n < 0:\n            raise ValueError(\"Site index smaller zero!\")\n        if n >= len(structure):\n            raise ValueError(\"Site index beyond maximum!\")\n        if indices_neighs is not None:\n            for index in indices_neighs:\n                if index >= len(structure):\n                    raise ValueError(\"Neighbor site index beyond maximum!\")\n        if tol < 0.0:\n            raise ValueError(\"Negative tolerance for weighted solid angle!\")\n\n        left_of_unity = 1.0 - 1.0e-12\n        # The following threshold has to be adapted to non-Angstrom units.\n        very_small = 1.0e-12\n        fac_bcc = 1.0 / exp(-0.5)\n\n        # Find central site and its neighbors.\n        # Note that we adopt the same way of accessing sites here as in\n        # VoronoiNN; that is, not via the sites iterator.\n        centsite = structure[n]\n        if indices_neighs is not None:\n            neighsites = [structure[index] for index in indices_neighs]\n        elif self._voroneigh:\n            vnn = VoronoiNN(tol=tol, targets=target_spec)\n            neighsites = vnn.get_nn(structure, n)\n        else:\n            # Structure.get_sites_in_sphere --> also other periodic images\n            neighsitestmp = [i[0] for i in structure.get_sites_in_sphere(\n                centsite.coords, self._cutoff)]\n            neighsites = []\n            if centsite not in neighsitestmp:\n                raise ValueError(\"Could not find center site!\")\n            else:\n                neighsitestmp.remove(centsite)\n            if target_spec is None:\n                neighsites = list(neighsitestmp)\n            else:\n                neighsites[:] = [site for site in neighsitestmp \\\n                                 if site.specie.symbol == target_spec]\n        nneigh = len(neighsites)\n        self._last_nneigh = nneigh\n\n        # Prepare angle calculations, if applicable.\n        rij = []\n        rjk = []\n        rijnorm = []\n        rjknorm = []\n        dist = []\n        distjk_unique = []\n        distjk = []\n        centvec = centsite.coords\n        if self._computerijs:\n            for j, neigh in enumerate(neighsites):\n                rij.append((neigh.coords - centvec))\n                dist.append(np.linalg.norm(rij[j]))\n                rijnorm.append((rij[j] / dist[j]))\n        if self._computerjks:\n            for j, neigh in enumerate(neighsites):\n                rjk.append([])\n                rjknorm.append([])\n                distjk.append([])\n                kk = 0\n                for k in range(len(neighsites)):\n                    if j != k:\n                        rjk[j].append(neighsites[k].coords - neigh.coords)\n                        distjk[j].append(np.linalg.norm(rjk[j][kk]))\n                        if k > j:\n                            distjk_unique.append(distjk[j][kk])\n                        rjknorm[j].append(rjk[j][kk] / distjk[j][kk])\n                        kk = kk + 1\n        # Initialize OP list and, then, calculate OPs.\n        ops = [0.0 for t in self._types]\n        # norms = [[[] for j in range(nneigh)] for t in self._types]\n\n        # First, coordination number and distance-based OPs.\n        for i, t in enumerate(self._types):\n            if t == \"cn\":\n                ops[i] = nneigh / self._params[i]['norm']\n            elif t == \"sgl_bd\":\n                dist_sorted = sorted(dist)\n                if len(dist_sorted) == 1:\n                    ops[i] = 1.0\n                elif len(dist_sorted) > 1:\n                    ops[i] = 1.0 - dist_sorted[0] / dist_sorted[1]\n\n        # Then, bond orientational OPs based on spherical harmonics\n        # according to Steinhardt et al., Phys. Rev. B, 28, 784-805, 1983.\n        if self._boops:\n            thetas = []\n            phis = []\n            for j, vec in enumerate(rijnorm):\n\n                # z is North pole --> theta between vec and (0, 0, 1)^T.\n                # Because vec is normalized, dot product is simply vec[2].\n                thetas.append(acos(max(-1.0, min(vec[2], 1.0))))\n                tmpphi = 0.0\n\n                # Compute phi only if it is not (almost) perfectly\n                # aligned with z-axis.\n                if -left_of_unity < vec[2] < left_of_unity:\n                    # x is prime meridian --> phi between projection of vec\n                    # into x-y plane and (1, 0, 0)^T\n                    tmpphi = acos(max(-1.0, min(vec[0] / (sqrt(\n                        vec[0] * vec[0] + vec[1] * vec[1])), 1.0)))\n                    if vec[1] < 0.0:\n                        tmpphi = -tmpphi\n                phis.append(tmpphi)\n\n            # Note that None flags that we have too few neighbors\n            # for calculating BOOPS.\n            for i, t in enumerate(self._types):\n                if t == \"q2\":\n                    ops[i] = self.get_q2(thetas, phis) if len(\n                        thetas) > 0 else None\n                elif t == \"q4\":\n                    ops[i] = self.get_q4(thetas, phis) if len(\n                        thetas) > 0 else None\n                elif t == \"q6\":\n                    ops[i] = self.get_q6(thetas, phis) if len(\n                        thetas) > 0 else None\n\n        # Then, deal with the Peters-style OPs that are tailor-made\n        # to recognize common structural motifs\n        # (Peters, J. Chem. Phys., 131, 244103, 2009;\n        #  Zimmermann et al., J. Am. Chem. Soc., under revision, 2015).\n        if self._geomops:\n            gaussthetak = [0.0 for t in self._types]  # not used by all OPs\n            qsptheta = [[[] for j in range(nneigh)] for t in self._types]\n            norms = [[[] for j in range(nneigh)] for t in self._types]\n            ipi = 1.0 / pi\n            piover2 = pi / 2.0\n            tetangoverpi = acos(-1.0 / 3.0) * ipi  # xxx: delete\n            itetangminuspihalfoverpi = 1.0 / (tetangoverpi - 0.5)\n            onethird = 1.0 / 3.0\n            twothird = 2.0 / 3.0\n            for j in range(nneigh):  # Neighbor j is put to the North pole.\n                zaxis = rijnorm[j]\n                kc = 0\n                for k in range(nneigh):  # From neighbor k, we construct\n                    if j != k:  # the prime meridian.\n                        for i in range(len(self._types)):\n                            qsptheta[i][j].append(0.0)\n                            norms[i][j].append(0)\n                        tmp = max(\n                            -1.0, min(np.inner(zaxis, rijnorm[k]), 1.0))\n                        thetak = acos(tmp)\n                        xaxis = gramschmidt(rijnorm[k], zaxis)\n                        if np.linalg.norm(xaxis) < very_small:\n                            flag_xaxis = True\n                        else:\n                            xaxis = xaxis / np.linalg.norm(xaxis)\n                            flag_xaxis = False\n                        if self._comp_azi:\n                            flag_yaxis = True\n                            yaxis = np.cross(zaxis, xaxis)\n                            if np.linalg.norm(yaxis) > very_small:\n                                yaxis = yaxis / np.linalg.norm(yaxis)\n                                flag_yaxis = False\n\n                        # Contributions of j-i-k angles, where i represents the\n                        # central atom and j and k two of the neighbors.\n                        for i, t in enumerate(self._types):\n                            if t in [\"bent\", \"sq_pyr_legacy\"]:\n                                tmp = self._params[i]['IGW_TA'] * (\n                                        thetak * ipi - self._params[i]['TA'])\n                                qsptheta[i][j][kc] += exp(-0.5 * tmp * tmp)\n                                norms[i][j][kc] += 1\n                            elif t in [\"tri_plan\", \"tri_plan_max\", \"tet\",\n                                       \"tet_max\"]:\n                                tmp = self._params[i]['IGW_TA'] * (\n                                        thetak * ipi - self._params[i]['TA'])\n                                gaussthetak[i] = exp(-0.5 * tmp * tmp)\n                                if t in [\"tri_plan_max\", \"tet_max\"]:\n                                    qsptheta[i][j][kc] += gaussthetak[i]\n                                    norms[i][j][kc] += 1\n                            elif t in [\"T\", \"tri_pyr\", \"sq_pyr\", \"pent_pyr\",\n                                       \"hex_pyr\"]:\n                                tmp = self._params[i]['IGW_EP'] * (\n                                            thetak * ipi - 0.5)\n                                qsptheta[i][j][kc] += exp(-0.5 * tmp * tmp)\n                                norms[i][j][kc] += 1\n                            elif t in [\"sq_plan\", \"oct\", \"oct_legacy\",\n                                       \"cuboct\", \"cuboct_max\"]:\n                                if thetak >= self._params[i]['min_SPP']:\n                                    tmp = self._params[i]['IGW_SPP'] * (\n                                            thetak * ipi - 1.0)\n                                    qsptheta[i][j][kc] += (\n                                            self._params[i]['w_SPP'] *\n                                            exp(-0.5 * tmp * tmp))\n                                    norms[i][j][kc] += self._params[i]['w_SPP']\n                            elif t in [\"see_saw_rect\", \"tri_bipyr\", \"sq_bipyr\",\n                                       \"pent_bipyr\", \"hex_bipyr\", \"oct_max\",\n                                       \"sq_plan_max\", \"hex_plan_max\"]:\n                                if thetak < self._params[i]['min_SPP']:\n                                    tmp = self._params[i]['IGW_EP'] * (\n                                            thetak * ipi - 0.5) if t != \"hex_plan_max\" else \\\n                                        self._params[i]['IGW_TA'] * (\n                                                fabs(thetak * ipi - 0.5) -\n                                                self._params[i]['TA'])\n                                    qsptheta[i][j][kc] += exp(\n                                        -0.5 * tmp * tmp)\n                                    norms[i][j][kc] += 1\n                            elif t in [\"pent_plan\", \"pent_plan_max\"]:\n                                tmp = 0.4 if thetak <= self._params[i][\n                                    'TA'] * pi \\\n                                    else 0.8\n                                tmp2 = self._params[i]['IGW_TA'] * (\n                                        thetak * ipi - tmp)\n                                gaussthetak[i] = exp(-0.5 * tmp2 * tmp2)\n                                if t == \"pent_plan_max\":\n                                    qsptheta[i][j][kc] += gaussthetak[i]\n                                    norms[i][j][kc] += 1\n                            elif t == \"bcc\" and j < k:\n                                if thetak >= self._params[i]['min_SPP']:\n                                    tmp = self._params[i]['IGW_SPP'] * (\n                                            thetak * ipi - 1.0)\n                                    qsptheta[i][j][kc] += (\n                                                self._params[i]['w_SPP'] *\n                                                exp(-0.5 * tmp * tmp))\n                                    norms[i][j][kc] += self._params[i]['w_SPP']\n                            elif t == \"sq_face_cap_trig_pris\":\n                                if thetak < self._params[i]['TA3']:\n                                    tmp = self._params[i]['IGW_TA1'] * (\n                                            thetak * ipi - self._params[i][\n                                        'TA1'])\n                                    qsptheta[i][j][kc] += exp(-0.5 * tmp * tmp)\n                                    norms[i][j][kc] += 1\n\n                        for m in range(nneigh):\n                            if (m != j) and (m != k) and (not flag_xaxis):\n                                tmp = max(\n                                    -1.0, min(np.inner(zaxis, rijnorm[m]), 1.0))\n                                thetam = acos(tmp)\n                                xtwoaxistmp = gramschmidt(rijnorm[m], zaxis)\n                                l = np.linalg.norm(xtwoaxistmp)\n                                if l < very_small:\n                                    flag_xtwoaxis = True\n                                else:\n                                    xtwoaxis = xtwoaxistmp / l\n                                    phi = acos(max(\n                                        -1.0,\n                                        min(np.inner(xtwoaxis, xaxis), 1.0)))\n                                    flag_xtwoaxis = False\n                                    if self._comp_azi:\n                                        phi2 = atan2(\n                                            np.dot(xtwoaxis, yaxis),\n                                            np.dot(xtwoaxis, xaxis))\n                                        # print('{} {}'.format(180*phi/pi, 180*phi2/pi))\n                                # South pole contributions of m.\n                                if t in [\"tri_bipyr\", \"sq_bipyr\", \"pent_bipyr\",\n                                         \"hex_bipyr\", \"oct_max\", \"sq_plan_max\",\n                                         \"hex_plan_max\", \"see_saw_rect\"]:\n                                    if thetam >= self._params[i]['min_SPP']:\n                                        tmp = self._params[i]['IGW_SPP'] * (\n                                                thetam * ipi - 1.0)\n                                        qsptheta[i][j][kc] += exp(\n                                            -0.5 * tmp * tmp)\n                                        norms[i][j][kc] += 1\n\n                                # Contributions of j-i-m angle and\n                                # angles between plane j-i-k and i-m vector.\n                                if not flag_xaxis and not flag_xtwoaxis:\n                                    for i, t in enumerate(self._types):\n                                        if t in [\"tri_plan\", \"tri_plan_max\",\n                                                 \"tet\", \"tet_max\"]:\n                                            tmp = self._params[i]['IGW_TA'] * (\n                                                    thetam * ipi -\n                                                    self._params[i]['TA'])\n                                            tmp2 = cos(\n                                                self._params[i]['fac_AA'] *\n                                                phi) ** self._params[i][\n                                                       'exp_cos_AA']\n                                            tmp3 = 1 if t in [\"tri_plan_max\",\n                                                              \"tet_max\"] \\\n                                                else gaussthetak[i]\n                                            qsptheta[i][j][kc] += tmp3 * exp(\n                                                -0.5 * tmp * tmp) * tmp2\n                                            norms[i][j][kc] += 1\n                                        elif t in [\"pent_plan\",\n                                                   \"pent_plan_max\"]:\n                                            tmp = 0.4 if thetam <= \\\n                                                         self._params[i][\n                                                             'TA'] * pi \\\n                                                else 0.8\n                                            tmp2 = self._params[i]['IGW_TA'] * (\n                                                    thetam * ipi - tmp)\n                                            tmp3 = cos(phi)\n                                            tmp4 = 1 if t == \"pent_plan_max\" \\\n                                                else gaussthetak[i]\n                                            qsptheta[i][j][kc] += tmp4 * exp(\n                                                -0.5 * tmp2 * tmp2) * tmp3 * tmp3\n                                            norms[i][j][kc] += 1\n                                        elif t in [\"T\", \"tri_pyr\", \"sq_pyr\",\n                                                   \"pent_pyr\", \"hex_pyr\"]:\n                                            tmp = cos(\n                                                self._params[i]['fac_AA'] *\n                                                phi) ** self._params[i][\n                                                      'exp_cos_AA']\n                                            tmp3 = self._params[i]['IGW_EP'] * (\n                                                    thetam * ipi - 0.5)\n                                            qsptheta[i][j][kc] += tmp * exp(\n                                                -0.5 * tmp3 * tmp3)\n                                            norms[i][j][kc] += 1\n                                        elif t in [\"sq_plan\", \"oct\",\n                                                   \"oct_legacy\"]:\n                                            if thetak < self._params[i][\n                                                'min_SPP'] and \\\n                                                    thetam < self._params[i][\n                                                'min_SPP']:\n                                                tmp = cos(\n                                                    self._params[i]['fac_AA'] *\n                                                    phi) ** self._params[i][\n                                                          'exp_cos_AA']\n                                                tmp2 = self._params[i][\n                                                           'IGW_EP'] * (\n                                                               thetam * ipi - 0.5)\n                                                qsptheta[i][j][kc] += tmp * exp(\n                                                    -0.5 * tmp2 * tmp2)\n                                                if t == \"oct_legacy\":\n                                                    qsptheta[i][j][kc] -= tmp * \\\n                                                                          self._params[\n                                                                              i][\n                                                                              6] * \\\n                                                                          self._params[\n                                                                              i][\n                                                                              7]\n                                                norms[i][j][kc] += 1\n                                        elif t in [\"tri_bipyr\", \"sq_bipyr\",\n                                                   \"pent_bipyr\",\n                                                   \"hex_bipyr\", \"oct_max\",\n                                                   \"sq_plan_max\",\n                                                   \"hex_plan_max\"]:\n                                            if thetam < self._params[i][\n                                                'min_SPP']:\n                                                if thetak < self._params[i][\n                                                    'min_SPP']:\n                                                    tmp = cos(self._params[i][\n                                                                  'fac_AA'] *\n                                                              phi) ** \\\n                                                          self._params[i][\n                                                              'exp_cos_AA']\n                                                    tmp2 = self._params[i][\n                                                               'IGW_EP'] * (\n                                                                   thetam * ipi - 0.5) if t != \"hex_plan_max\" else \\\n                                                        self._params[i][\n                                                            'IGW_TA'] * (\n                                                                fabs(\n                                                                    thetam * ipi - 0.5) -\n                                                                self._params[i][\n                                                                    'TA'])\n                                                    qsptheta[i][j][\n                                                        kc] += tmp * exp(\n                                                        -0.5 * tmp2 * tmp2)\n                                                    norms[i][j][kc] += 1\n                                        elif t == \"bcc\" and j < k:\n                                            if thetak < self._params[i][\n                                                'min_SPP']:\n                                                if thetak > piover2:\n                                                    fac = 1.0\n                                                else:\n                                                    fac = -1.0\n                                                tmp = (thetam - piover2) / asin(\n                                                    1 / 3)\n                                                qsptheta[i][j][kc] += fac * cos(\n                                                    3.0 * phi) * fac_bcc * \\\n                                                                      tmp * exp(\n                                                    -0.5 * tmp * tmp)\n                                                norms[i][j][kc] += 1\n                                        elif t == \"see_saw_rect\":\n                                            if thetam < self._params[i][\n                                                'min_SPP']:\n                                                if thetak < self._params[i][\n                                                    'min_SPP'] and phi < 0.75 * pi:\n                                                    tmp = cos(self._params[i][\n                                                                  'fac_AA'] *\n                                                              phi) ** \\\n                                                          self._params[i][\n                                                              'exp_cos_AA']\n                                                    tmp2 = self._params[i][\n                                                               'IGW_EP'] * (\n                                                                   thetam * ipi - 0.5)\n                                                    qsptheta[i][j][kc] += tmp * \\\n                                                                          exp(\n                                                                              -0.5 * tmp2 * tmp2)\n                                                    norms[i][j][kc] += 1.0\n                                        elif t in [\"cuboct\", \"cuboct_max\"]:\n                                            if thetam < self._params[i][\n                                                'min_SPP'] and \\\n                                                    thetak > self._params[i][\n                                                4] and \\\n                                                    thetak < self._params[i][2]:\n                                                if thetam > self._params[i][\n                                                    4] and \\\n                                                        thetam < \\\n                                                        self._params[i][2]:\n                                                    tmp = cos(phi)\n                                                    tmp2 = self._params[i][\n                                                               5] * (\n                                                                       thetam * ipi - 0.5)\n                                                    qsptheta[i][j][\n                                                        kc] += tmp * tmp * exp(\n                                                        -0.5 * tmp2 * tmp2)\n                                                    norms[i][j][kc] += 1.0\n                                                elif thetam < self._params[i][\n                                                    4]:\n                                                    tmp = 0.0556 * (cos(\n                                                        phi - 0.5 * pi) - 0.81649658)\n                                                    tmp2 = self._params[i][\n                                                               6] * (\n                                                                   thetam * ipi - onethird)\n                                                    qsptheta[i][j][kc] += exp(\n                                                        -0.5 * tmp * tmp) * \\\n                                                                          exp(\n                                                                              -0.5 * tmp2 * tmp2)\n                                                    norms[i][j][kc] += 1.0\n                                                elif thetam > self._params[i][\n                                                    2]:\n                                                    tmp = 0.0556 * (cos(\n                                                        phi - 0.5 * pi) - \\\n                                                                    0.81649658)\n                                                    tmp2 = self._params[i][\n                                                               6] * (\n                                                                       thetam * ipi - \\\n                                                                       twothird)\n                                                    qsptheta[i][j][kc] += exp(\n                                                        -0.5 * tmp * tmp) * \\\n                                                                          exp(\n                                                                              -0.5 * tmp2 * tmp2)\n                                                    norms[i][j][kc] += 1.0\n                                        elif t == \"sq_face_cap_trig_pris\" and not flag_yaxis:\n                                            if thetak < self._params[i]['TA3']:\n                                                if thetam < self._params[i][\n                                                    'TA3']:\n                                                    tmp = cos(self._params[i][\n                                                                  'fac_AA1'] * \\\n                                                              phi2) ** \\\n                                                          self._params[i][\n                                                              'exp_cos_AA1']\n                                                    tmp2 = self._params[i][\n                                                               'IGW_TA1'] * (\n                                                                   thetam * ipi -\n                                                                   self._params[\n                                                                       i][\n                                                                       'TA1'])\n                                                else:\n                                                    tmp = cos(self._params[i][\n                                                                  'fac_AA2'] * \\\n                                                              (phi2 +\n                                                               self._params[i][\n                                                                   'shift_AA2'])) ** \\\n                                                          self._params[i][\n                                                              'exp_cos_AA2']\n                                                    tmp2 = self._params[i][\n                                                               'IGW_TA2'] * (\n                                                                   thetam * ipi -\n                                                                   self._params[\n                                                                       i][\n                                                                       'TA2'])\n                                                    # print(\"phi2 {}   phi2+shift {}   tmp {}  \".format(phi2*180/pi, 180*(phi2 + self._params[i]['shift_AA2'])/pi, tmp))\n                                                qsptheta[i][j][kc] += tmp * exp(\n                                                    -0.5 * tmp2 * tmp2)\n                                                norms[i][j][kc] += 1\n\n                        kc += 1\n\n            # Normalize Peters-style OPs.\n            for i, t in enumerate(self._types):\n                if t in [\"tri_plan\", \"tet\", \"bent\", \"sq_plan\",\n                         \"oct\", \"oct_legacy\", \"cuboct\", \"pent_plan\"]:\n                    ops[i] = tmp_norm = 0.0\n                    for j in range(nneigh):\n                        ops[i] += sum(qsptheta[i][j])\n                        tmp_norm += float(sum(norms[i][j]))\n                    ops[i] = ops[i] / tmp_norm if tmp_norm > 1.0e-12 else None\n                elif t in [\"T\", \"tri_pyr\", \"see_saw_rect\", \"sq_pyr\",\n                           \"tri_bipyr\",\n                           \"sq_bipyr\", \"pent_pyr\", \"hex_pyr\", \"pent_bipyr\",\n                           \"hex_bipyr\", \"oct_max\", \"tri_plan_max\", \"tet_max\",\n                           \"sq_plan_max\", \"pent_plan_max\", \"cuboct_max\",\n                           \"hex_plan_max\",\n                           \"sq_face_cap_trig_pris\"]:\n                    ops[i] = None\n                    if nneigh > 1:\n                        for j in range(nneigh):\n                            for k in range(len(qsptheta[i][j])):\n                                qsptheta[i][j][k] = qsptheta[i][j][k] / \\\n                                                    norms[i][j][k] \\\n                                    if norms[i][j][k] > 1.0e-12 else 0.0\n                            ops[i] = max(qsptheta[i][j]) if j == 0 \\\n                                else max(ops[i], max(qsptheta[i][j]))\n                elif t == \"bcc\":\n                    ops[i] = 0.0\n                    for j in range(nneigh):\n                        ops[i] += sum(qsptheta[i][j])\n                    ops[i] = ops[i] / float(0.5 * float(\n                        nneigh * (6 + (nneigh - 2) * (nneigh - 3)))) \\\n                        if nneigh > 3 else None\n                elif t == \"sq_pyr_legacy\":\n                    if nneigh > 1:\n                        dmean = np.mean(dist)\n                        acc = 0.0\n                        for d in dist:\n                            tmp = self._params[i][2] * (d - dmean)\n                            acc = acc + exp(-0.5 * tmp * tmp)\n                        for j in range(nneigh):\n                            ops[i] = max(qsptheta[i][j]) if j == 0 \\\n                                else max(ops[i], max(qsptheta[i][j]))\n                        ops[i] = acc * ops[i] / float(nneigh)\n                        # nneigh * (nneigh - 1))\n                    else:\n                        ops[i] = None\n\n        # Then, deal with the new-style OPs that require vectors between\n        # neighbors.\n        if self._geomops2:\n            # Compute all (unique) angles and sort the resulting list.\n            aij = []\n            for ir, r in enumerate(rijnorm):\n                for j in range(ir + 1, len(rijnorm)):\n                    aij.append(\n                        acos(max(-1.0, min(np.inner(r, rijnorm[j]), 1.0))))\n            aijs = sorted(aij)\n\n            # Compute height, side and diagonal length estimates.\n            neighscent = np.array([0.0, 0.0, 0.0])\n            for j, neigh in enumerate(neighsites):\n                neighscent = neighscent + neigh.coords\n            if nneigh > 0:\n                neighscent = (neighscent / float(nneigh))\n            h = np.linalg.norm(neighscent - centvec)\n            b = min(distjk_unique) if len(distjk_unique) > 0 else 0\n            dhalf = max(distjk_unique) / 2.0 if len(distjk_unique) > 0 else 0\n\n            for i, t in enumerate(self._types):\n                if t == \"reg_tri\" or t == \"sq\":\n                    if nneigh < 3:\n                        ops[i] = None\n                    else:\n                        ops[i] = 1.0\n                        if t == \"reg_tri\":\n                            a = 2.0 * asin(b / (2.0 * sqrt(h * h + (b / (\n                                    2.0 * cos(3.0 * pi / 18.0))) ** 2.0)))\n                            nmax = 3\n                        elif t == \"sq\":\n                            a = 2.0 * asin(\n                                b / (2.0 * sqrt(h * h + dhalf * dhalf)))\n                            nmax = 4\n                        for j in range(min([nneigh, nmax])):\n                            ops[i] = ops[i] * exp(-0.5 * ((\n                                                                  aijs[j] - a) *\n                                                          self._params[i][\n                                                              0]) ** 2)\n\n        return ops", "response": "This function calculates all order parameters of a given atom n in a structure."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_nn_info(self, structure, n):\n\n        nndata = self.get_nn_data(structure, n)\n\n        if not self.weighted_cn:\n            max_key = max(nndata.cn_weights, key=lambda k: nndata.cn_weights[k])\n            nn = nndata.cn_nninfo[max_key]\n            for entry in nn:\n                entry[\"weight\"] = 1\n            return nn\n\n        else:\n            for entry in nndata.all_nninfo:\n                weight = 0\n                for cn in nndata.cn_nninfo:\n                    for cn_entry in nndata.cn_nninfo[cn]:\n                        if entry[\"site\"] == cn_entry[\"site\"]:\n                            weight += nndata.cn_weights[cn]\n\n                entry[\"weight\"] = weight\n\n            return nndata.all_nninfo", "response": "Get all near - neighbor information."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_nn_data(self, structure, n, length=None):\n\n        length = length or self.fingerprint_length\n\n        # determine possible bond targets\n        target = None\n        if self.cation_anion:\n            target = []\n            m_oxi = structure[n].specie.oxi_state\n            for site in structure:\n                if site.specie.oxi_state * m_oxi <= 0:  # opposite charge\n                    target.append(site.specie)\n            if not target:\n                raise ValueError(\n                    \"No valid targets for site within cation_anion constraint!\")\n\n        # get base VoronoiNN targets\n        cutoff = self.search_cutoff\n        vnn = VoronoiNN(weight=\"solid_angle\", targets=target, cutoff=cutoff)\n        nn = vnn.get_nn_info(structure, n)\n\n        # solid angle weights can be misleading in open / porous structures\n        # adjust weights to correct for this behavior\n        if self.porous_adjustment:\n            for x in nn:\n                x[\"weight\"] *= x[\"poly_info\"][\n                                   \"solid_angle\"] / x[\"poly_info\"][\"area\"]\n\n        # adjust solid angle weight based on electronegativity difference\n        if self.x_diff_weight > 0:\n            for entry in nn:\n                X1 = structure[n].specie.X\n                X2 = entry[\"site\"].specie.X\n\n                if math.isnan(X1) or math.isnan(X2):\n                    chemical_weight = 1\n                else:\n                    # note: 3.3 is max deltaX between 2 elements\n                    chemical_weight = 1 + self.x_diff_weight * \\\n                                      math.sqrt(abs(X1 - X2) / 3.3)\n\n                entry[\"weight\"] = entry[\"weight\"] * chemical_weight\n\n        # sort nearest neighbors from highest to lowest weight\n        nn = sorted(nn, key=lambda x: x[\"weight\"], reverse=True)\n        if nn[0][\"weight\"] == 0:\n            return self.transform_to_length(self.NNData([], {0: 1.0}, {0: []}),\n                                            length)\n\n        # renormalize weights so the highest weight is 1.0\n        highest_weight = nn[0][\"weight\"]\n        for entry in nn:\n            entry[\"weight\"] = entry[\"weight\"] / highest_weight\n\n        # adjust solid angle weights based on distance\n        if self.distance_cutoffs:\n            r1 = self._get_radius(structure[n])\n            for entry in nn:\n                r2 = self._get_radius(entry[\"site\"])\n                if r1 > 0 and r2 > 0:\n                    d = r1 + r2\n                else:\n                    warnings.warn(\n                        \"CrystalNN: cannot locate an appropriate radius, \"\n                        \"covalent or atomic radii will be used, this can lead \"\n                        \"to non-optimal results.\")\n                    d = CrystalNN._get_default_radius(structure[n]) + \\\n                        CrystalNN._get_default_radius(entry[\"site\"])\n\n                dist = np.linalg.norm(\n                    structure[n].coords - entry[\"site\"].coords)\n                dist_weight = 0\n\n                cutoff_low = d + self.distance_cutoffs[0]\n                cutoff_high = d + self.distance_cutoffs[1]\n\n                if dist <= cutoff_low:\n                    dist_weight = 1\n                elif dist < cutoff_high:\n                    dist_weight = (math.cos((dist - cutoff_low) / (\n                            cutoff_high - cutoff_low) * math.pi) + 1) * 0.5\n                entry[\"weight\"] = entry[\"weight\"] * dist_weight\n\n        # sort nearest neighbors from highest to lowest weight\n        nn = sorted(nn, key=lambda x: x[\"weight\"], reverse=True)\n        if nn[0][\"weight\"] == 0:\n            return self.transform_to_length(self.NNData([], {0: 1.0}, {0: []}),\n                                            length)\n\n        for entry in nn:\n            entry[\"weight\"] = round(entry[\"weight\"], 3)\n            del entry[\"poly_info\"]  # trim\n\n        # remove entries with no weight\n        nn = [x for x in nn if x[\"weight\"] > 0]\n\n        # get the transition distances, i.e. all distinct weights\n        dist_bins = []\n        for entry in nn:\n            if not dist_bins or dist_bins[-1] != entry[\"weight\"]:\n                dist_bins.append(entry[\"weight\"])\n        dist_bins.append(0)\n\n        # main algorithm to determine fingerprint from bond weights\n        cn_weights = {}  # CN -> score for that CN\n        cn_nninfo = {}  # CN -> list of nearneighbor info for that CN\n        for idx, val in enumerate(dist_bins):\n            if val != 0:\n                nn_info = []\n                for entry in nn:\n                    if entry[\"weight\"] >= val:\n                        nn_info.append(entry)\n                cn = len(nn_info)\n                cn_nninfo[cn] = nn_info\n                cn_weights[cn] = self._semicircle_integral(dist_bins, idx)\n\n        # add zero coord\n        cn0_weight = 1.0 - sum(cn_weights.values())\n        if cn0_weight > 0:\n            cn_nninfo[0] = []\n            cn_weights[0] = cn0_weight\n\n        return self.transform_to_length(self.NNData(nn, cn_weights, cn_nninfo),\n                                        length)", "response": "This method computes the NN info for a specific target site."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_cn(self, structure, n, use_weights=False):\n        if self.weighted_cn != use_weights:\n            raise ValueError(\"The weighted_cn parameter and use_weights \"\n                             \"parameter should match!\")\n\n        return super().get_cn(structure, n, use_weights)", "response": "Get coordination number CN of site with index n in structure."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef transform_to_length(nndata, length):\n\n        if length is None:\n            return nndata\n\n        if length:\n            for cn in range(length):\n                if cn not in nndata.cn_weights:\n                    nndata.cn_weights[cn] = 0\n                    nndata.cn_nninfo[cn] = []\n\n        return nndata", "response": "Given a NNData and a length of a number returns a new NNData with the specified length."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ninitialises a CutOffDictNN according to a preset cut - offs.", "response": "def from_preset(preset):\n        \"\"\"\n        Initialise a CutOffDictNN according to a preset set of cut-offs.\n\n        Args:\n            preset (str): A preset name. The list of supported presets are:\n\n                - \"vesta_2019\": The distance cut-offs used by the VESTA\n                  visualisation program.\n\n        Returns:\n            A CutOffDictNN using the preset cut-off dictionary.\n        \"\"\"\n        if preset == 'vesta_2019':\n            cut_offs = loadfn(os.path.join(_directory, 'vesta_cutoffs.yaml'))\n            return CutOffDictNN(cut_off_dict=cut_offs)\n        else:\n            raise ValueError(\"Unrecognised preset: {}\".format(preset))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef to_string(self):\n        # define coord system, use Cartesian\n        output = [\"1.0 0.0 0.0\",\n                  \"0.0 1.0 0.0\",\n                  \"0.0 0.0 1.0\"]\n        # add lattice vectors\n        m = self.structure.lattice.matrix\n        output.append(\"{:6f} {:6f} {:6f}\".format(*m[0]))\n        output.append(\"{:6f} {:6f} {:6f}\".format(*m[1]))\n        output.append(\"{:6f} {:6f} {:6f}\".format(*m[2]))\n        # add species\n        for site in self.structure:\n            species_str = []\n            for sp, occu in sorted(site.species.items()):\n                if isinstance(sp, Specie):\n                    sp = sp.element\n                species_str.append(\"{}={}\".format(sp, occu))\n            species_str = \",\".join(species_str)\n            output.append(\"{:6f} {:6f} {:6f} {}\".format(site.frac_coords[0],\n                                                        site.frac_coords[1],\n                                                        site.frac_coords[2],\n                                                        species_str))\n\n        return \"\\n\".join(output)", "response": "Returns a structure in mcsqs rndstr. in format."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nparses a rndstr. in or lat. in file into a pymatgen Structure object.", "response": "def structure_from_string(data):\n        \"\"\"\n        Parses a rndstr.in or lat.in file into pymatgen's\n        Structure format.\n\n        :param data: contents of a rndstr.in or lat.in file\n        :return: Structure object\n        \"\"\"\n\n        data = data.splitlines()\n        data = [x.split() for x in data if x]  # remove empty lines\n\n        # following specification/terminology given in manual\n        if len(data[0]) == 6:  # lattice parameters\n            a, b, c, alpha, beta, gamma = map(float, data[0])\n            coord_system = Lattice.from_parameters(a, b, c,\n                                                   alpha, beta, gamma).matrix\n            lattice_vecs = np.array([\n                [data[1][0], data[1][1], data[1][2]],\n                [data[2][0], data[2][1], data[2][2]],\n                [data[3][0], data[3][1], data[3][2]]\n            ], dtype=float)\n            first_species_line = 4\n        else:\n            coord_system = np.array([\n                [data[0][0], data[0][1], data[0][2]],\n                [data[1][0], data[1][1], data[1][2]],\n                [data[2][0], data[2][1], data[2][2]]\n            ], dtype=float)\n            lattice_vecs = np.array([\n                [data[3][0], data[3][1], data[3][2]],\n                [data[4][0], data[4][1], data[4][2]],\n                [data[5][0], data[5][1], data[5][2]]\n            ], dtype=float)\n            first_species_line = 6\n\n        scaled_matrix = np.matmul(coord_system, lattice_vecs)\n        lattice = Lattice(scaled_matrix)\n\n        all_coords = []\n        all_species = []\n        for l in data[first_species_line:]:\n\n            all_coords.append(np.array([l[0], l[1], l[2]], dtype=float))\n\n            species_strs = \"\".join(l[3:])  # join multiple strings back together\n            species_strs = species_strs.replace(\" \", \"\")  # trim any white space\n            species_strs = species_strs.split(\",\")  # comma-delimited\n\n            species = {}\n\n            for species_str in species_strs:\n                species_str = species_str.split('=')\n                if len(species_str) == 1:\n                    # assume occupancy is 1.0\n                    species_str = [species_str[0], 1.0]\n                try:\n                    species[Specie(species_str[0])] = float(species_str[1])\n                except:\n                    species[DummySpecie(species_str[0])] = float(species_str[1])\n\n            all_species.append(species)\n\n        return Structure(lattice, all_species, all_coords)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the set of voronoi nodes in the structure.", "response": "def get_voronoi_nodes(structure, rad_dict=None, probe_rad=0.1):\n    \"\"\"\n    Analyze the void space in the input structure using voronoi decomposition\n    Calls Zeo++ for Voronoi decomposition.\n\n    Args:\n        structure: pymatgen.core.structure.Structure\n        rad_dict (optional): Dictionary of radii of elements in structure.\n            If not given, Zeo++ default values are used.\n            Note: Zeo++ uses atomic radii of elements.\n            For ionic structures, pass rad_dict with ionic radii\n        probe_rad (optional): Sampling probe radius in Angstroms. Default is\n            0.1 A\n\n    Returns:\n        voronoi nodes as pymatgen.core.structure.Strucutre within the\n        unit cell defined by the lattice of input structure\n        voronoi face centers as pymatgen.core.structure.Strucutre within the\n        unit cell defined by the lattice of input structure\n    \"\"\"\n\n    with ScratchDir('.'):\n        name = \"temp_zeo1\"\n        zeo_inp_filename = name + \".cssr\"\n        ZeoCssr(structure).write_file(zeo_inp_filename)\n        rad_file = None\n        rad_flag = False\n\n        if rad_dict:\n            rad_file = name + \".rad\"\n            rad_flag = True\n            with open(rad_file, 'w+') as fp:\n                for el in rad_dict.keys():\n                    fp.write(\"{} {}\\n\".format(el, rad_dict[el].real))\n\n        atmnet = AtomNetwork.read_from_CSSR(\n            zeo_inp_filename, rad_flag=rad_flag, rad_file=rad_file)\n        vornet, vor_edge_centers, vor_face_centers = \\\n            atmnet.perform_voronoi_decomposition()\n        vornet.analyze_writeto_XYZ(name, probe_rad, atmnet)\n        voro_out_filename = name + '_voro.xyz'\n        voro_node_mol = ZeoVoronoiXYZ.from_file(voro_out_filename).molecule\n\n    species = [\"X\"] * len(voro_node_mol.sites)\n    coords = []\n    prop = []\n    for site in voro_node_mol.sites:\n        coords.append(list(site.coords))\n        prop.append(site.properties['voronoi_radius'])\n\n    lattice = Lattice.from_lengths_and_angles(\n        structure.lattice.abc, structure.lattice.angles)\n    vor_node_struct = Structure(\n        lattice, species, coords, coords_are_cartesian=True,\n        to_unit_cell=True, site_properties={\"voronoi_radius\": prop})\n\n    # PMG-Zeo c<->a transformation for voronoi face centers\n    rot_face_centers = [(center[1], center[2], center[0]) for center in\n                        vor_face_centers]\n    rot_edge_centers = [(center[1], center[2], center[0]) for center in\n                        vor_edge_centers]\n\n    species = [\"X\"] * len(rot_face_centers)\n    prop = [0.0] * len(rot_face_centers)  # Vor radius not evaluated for fc\n    vor_facecenter_struct = Structure(\n        lattice, species, rot_face_centers, coords_are_cartesian=True,\n        to_unit_cell=True, site_properties={\"voronoi_radius\": prop})\n\n    species = [\"X\"] * len(rot_edge_centers)\n    prop = [0.0] * len(rot_edge_centers)  # Vor radius not evaluated for fc\n    vor_edgecenter_struct = Structure(\n        lattice, species, rot_edge_centers, coords_are_cartesian=True,\n        to_unit_cell=True, site_properties={\"voronoi_radius\": prop})\n\n    return vor_node_struct, vor_edgecenter_struct, vor_facecenter_struct"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nanalyzing the void space in the input structure using high accuracy voronoi decomposition. Calls Zeo++ for Voronoi decomposition. Args: structure: pymatgen.core.structure.Structure rad_dict (optional): Dictionary of radii of elements in structure. If not given, Zeo++ default values are used. Note: Zeo++ uses atomic radii of elements. For ionic structures, pass rad_dict with ionic radii probe_rad (optional): Sampling probe radius in Angstroms. Default is 0.1 A Returns: voronoi nodes as pymatgen.core.structure.Strucutre within the unit cell defined by the lattice of input structure voronoi face centers as pymatgen.core.structure.Strucutre within the unit cell defined by the lattice of input structure", "response": "def get_high_accuracy_voronoi_nodes(structure, rad_dict, probe_rad=0.1):\n    \"\"\"\n    Analyze the void space in the input structure using high accuracy\n    voronoi decomposition.\n    Calls Zeo++ for Voronoi decomposition.\n\n    Args:\n        structure: pymatgen.core.structure.Structure\n        rad_dict (optional): Dictionary of radii of elements in structure.\n            If not given, Zeo++ default values are used.\n            Note: Zeo++ uses atomic radii of elements.\n            For ionic structures, pass rad_dict with ionic radii\n        probe_rad (optional): Sampling probe radius in Angstroms.\n            Default is 0.1 A\n\n    Returns:\n        voronoi nodes as pymatgen.core.structure.Strucutre within the\n        unit cell defined by the lattice of input structure\n        voronoi face centers as pymatgen.core.structure.Strucutre within the\n        unit cell defined by the lattice of input structure\n    \"\"\"\n\n    with ScratchDir('.'):\n        name = \"temp_zeo1\"\n        zeo_inp_filename = name + \".cssr\"\n        ZeoCssr(structure).write_file(zeo_inp_filename)\n        rad_flag = True\n        rad_file = name + \".rad\"\n        with open(rad_file, 'w+') as fp:\n            for el in rad_dict.keys():\n                print(\"{} {}\".format(el, rad_dict[el].real), file=fp)\n\n        atmnet = AtomNetwork.read_from_CSSR(\n            zeo_inp_filename, rad_flag=rad_flag, rad_file=rad_file)\n        # vornet, vor_edge_centers, vor_face_centers = \\\n        #        atmnet.perform_voronoi_decomposition()\n        red_ha_vornet = \\\n            prune_voronoi_network_close_node(atmnet)\n        # generate_simplified_highaccuracy_voronoi_network(atmnet)\n        # get_nearest_largest_diameter_highaccuracy_vornode(atmnet)\n        red_ha_vornet.analyze_writeto_XYZ(name, probe_rad, atmnet)\n        voro_out_filename = name + '_voro.xyz'\n        voro_node_mol = ZeoVoronoiXYZ.from_file(voro_out_filename).molecule\n\n    species = [\"X\"] * len(voro_node_mol.sites)\n    coords = []\n    prop = []\n    for site in voro_node_mol.sites:\n        coords.append(list(site.coords))\n        prop.append(site.properties['voronoi_radius'])\n\n    lattice = Lattice.from_lengths_and_angles(\n        structure.lattice.abc, structure.lattice.angles)\n    vor_node_struct = Structure(\n        lattice, species, coords, coords_are_cartesian=True,\n        to_unit_cell=True, site_properties={\"voronoi_radius\": prop})\n\n    return vor_node_struct"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nanalyzing the void space in the input structure using voronoi decomposition Calls Zeo++ for Voronoi decomposition. Args: structure: pymatgen.core.structure.Structure rad_dict (optional): Dictionary of radii of elements in structure. If not given, Zeo++ default values are used. Note: Zeo++ uses atomic radii of elements. For ionic structures, pass rad_dict with ionic radii probe_rad (optional): Sampling probe radius in Angstroms. Default is 0.1 A Returns: voronoi nodes as pymatgen.core.structure.Strucutre within the unit cell defined by the lattice of input structure voronoi face centers as pymatgen.core.structure.Strucutre within the unit cell defined by the lattice of input structure", "response": "def get_free_sphere_params(structure, rad_dict=None, probe_rad=0.1):\n    \"\"\"\n    Analyze the void space in the input structure using voronoi decomposition\n    Calls Zeo++ for Voronoi decomposition.\n\n    Args:\n        structure: pymatgen.core.structure.Structure\n        rad_dict (optional): Dictionary of radii of elements in structure.\n            If not given, Zeo++ default values are used.\n            Note: Zeo++ uses atomic radii of elements.\n            For ionic structures, pass rad_dict with ionic radii\n        probe_rad (optional): Sampling probe radius in Angstroms. Default is\n            0.1 A\n\n    Returns:\n        voronoi nodes as pymatgen.core.structure.Strucutre within the\n        unit cell defined by the lattice of input structure\n        voronoi face centers as pymatgen.core.structure.Strucutre within the\n        unit cell defined by the lattice of input structure\n    \"\"\"\n\n    with ScratchDir('.'):\n        name = \"temp_zeo1\"\n        zeo_inp_filename = name + \".cssr\"\n        ZeoCssr(structure).write_file(zeo_inp_filename)\n        rad_file = None\n        rad_flag = False\n\n        if rad_dict:\n            rad_file = name + \".rad\"\n            rad_flag = True\n            with open(rad_file, 'w+') as fp:\n                for el in rad_dict.keys():\n                    fp.write(\"{} {}\\n\".format(el, rad_dict[el].real))\n\n        atmnet = AtomNetwork.read_from_CSSR(\n            zeo_inp_filename, rad_flag=rad_flag, rad_file=rad_file)\n        out_file = \"temp.res\"\n        atmnet.calculate_free_sphere_parameters(out_file)\n        if os.path.isfile(out_file) and os.path.getsize(out_file) > 0:\n            with open(out_file, \"rt\") as fp:\n                output = fp.readline()\n        else:\n            output = \"\"\n    fields = [val.strip() for val in output.split()][1:4]\n    if len(fields) == 3:\n        fields = [float(field) for field in fields]\n        free_sphere_params = {'inc_sph_max_dia': fields[0],\n                              'free_sph_max_dia': fields[1],\n                              'inc_sph_along_free_sph_path_max_dia': fields[2]}\n    return free_sphere_params"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncompute the volume and surface area of an isolated void using Zeo ++.", "response": "def get_void_volume_surfarea(structure, rad_dict=None, chan_rad=0.3,\n                             probe_rad=0.1):\n    \"\"\"\n    Computes the volume and surface area of isolated void using Zeo++.\n    Useful to compute the volume and surface area of vacant site.\n\n    Args:\n        structure: pymatgen Structure containing vacancy\n        rad_dict(optional): Dictionary with short name of elements and their\n            radii.\n        chan_rad(optional): Minimum channel Radius.\n        probe_rad(optional): Probe radius for Monte Carlo sampling.\n\n    Returns:\n        volume: floating number representing the volume of void\n    \"\"\"\n    with ScratchDir('.'):\n        name = \"temp_zeo\"\n        zeo_inp_filename = name + \".cssr\"\n        ZeoCssr(structure).write_file(zeo_inp_filename)\n\n        rad_file = None\n        if rad_dict:\n            rad_file = name + \".rad\"\n            with open(rad_file, 'w') as fp:\n                for el in rad_dict.keys():\n                    fp.write(\"{0}     {1}\".format(el, rad_dict[el]))\n\n        atmnet = AtomNetwork.read_from_CSSR(zeo_inp_filename, True, rad_file)\n        vol_str = volume(atmnet, 0.3, probe_rad, 10000)\n        sa_str = surface_area(atmnet, 0.3, probe_rad, 10000)\n        vol = None\n        sa = None\n        for line in vol_str.split(\"\\n\"):\n            if \"Number_of_pockets\" in line:\n                fields = line.split()\n                if float(fields[1]) > 1:\n                    vol = -1.0\n                    break\n                if float(fields[1]) == 0:\n                    vol = -1.0\n                    break\n                vol = float(fields[3])\n        for line in sa_str.split(\"\\n\"):\n            if \"Number_of_pockets\" in line:\n                fields = line.split()\n                if float(fields[1]) > 1:\n                    # raise ValueError(\"Too many voids\")\n                    sa = -1.0\n                    break\n                if float(fields[1]) == 0:\n                    sa = -1.0\n                    break\n                sa = float(fields[3])\n\n    if not vol or not sa:\n        raise ValueError(\"Error in zeo++ output stream\")\n    return vol, sa"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreading a string representation of a ZeoCSSR object.", "response": "def from_string(string):\n        \"\"\"\n        Reads a string representation to a ZeoCssr object.\n\n        Args:\n            string: A string representation of a ZeoCSSR.\n\n        Returns:\n            ZeoCssr object.\n        \"\"\"\n        lines = string.split(\"\\n\")\n        toks = lines[0].split()\n        lengths = [float(i) for i in toks]\n        toks = lines[1].split()\n        angles = [float(i) for i in toks[0:3]]\n        # Zeo++ takes x-axis along a and pymatgen takes z-axis along c\n        a = lengths.pop(-1)\n        lengths.insert(0, a)\n        alpha = angles.pop(-1)\n        angles.insert(0, alpha)\n        latt = Lattice.from_lengths_and_angles(lengths, angles)\n        sp = []\n        coords = []\n        chrg = []\n        for l in lines[4:]:\n            m = re.match(r'\\d+\\s+(\\w+)\\s+([0-9\\-\\.]+)\\s+([0-9\\-\\.]+)\\s+' +\n                         r'([0-9\\-\\.]+)\\s+(?:0\\s+){8}([0-9\\-\\.]+)', l.strip())\n            if m:\n                sp.append(m.group(1))\n                # coords.append([float(m.group(i)) for i in xrange(2, 5)])\n                # Zeo++ takes x-axis along a and pymatgen takes z-axis along c\n                coords.append([float(m.group(i)) for i in [3, 4, 2]])\n                chrg.append(m.group(5))\n        return ZeoCssr(\n            Structure(latt, sp, coords, site_properties={'charge': chrg})\n        )"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef from_string(contents):\n        lines = contents.split(\"\\n\")\n        num_sites = int(lines[0])\n        coords = []\n        sp = []\n        prop = []\n        coord_patt = re.compile(\n            r\"(\\w+)\\s+([0-9\\-\\.]+)\\s+([0-9\\-\\.]+)\\s+([0-9\\-\\.]+)\\s+\" +\n            r\"([0-9\\-\\.]+)\"\n        )\n        for i in range(2, 2 + num_sites):\n            m = coord_patt.search(lines[i])\n            if m:\n                sp.append(m.group(1))  # this is 1-indexed\n                # coords.append(map(float, m.groups()[1:4]))  # this is 0-indexed\n                coords.append([float(j)\n                               for j in [m.group(i) for i in [3, 4, 2]]])\n                prop.append(float(m.group(5)))\n        return ZeoVoronoiXYZ(\n            Molecule(sp, coords, site_properties={'voronoi_radius': prop})\n        )", "response": "Creates Zeo ++ Voronoi XYZ object from a string."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_velocities(self, velocities):\n        assert len(velocities) == len(self.mol)\n        self.params[\"velocity\"] = velocities", "response": ":param velocities (au): list of list of atom velocities \n        :return:"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_memory(self, total=None, static=None):\n        if total:\n            self.params[\"rem\"][\"mem_total\"] = total\n        if static:\n            self.params[\"rem\"][\"mem_static\"] = static", "response": "Set the maxium allowed memory."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_scf_algorithm_and_iterations(self, algorithm=\"diis\",\n                                         iterations=50):\n        \"\"\"\n        Set algorithm used for converging SCF and max number of SCF iterations.\n\n        Args:\n            algorithm: The algorithm used for converging SCF. (str)\n            iterations: The max number of SCF iterations. (Integer)\n        \"\"\"\n        available_algorithms = {\"diis\", \"dm\", \"diis_dm\", \"diis_gdm\", \"gdm\",\n                                \"rca\", \"rca_diis\", \"roothaan\"}\n        if algorithm.lower() not in available_algorithms:\n            raise ValueError(\"Algorithm \" + algorithm +\n                             \" is not available in QChem\")\n        self.params[\"rem\"][\"scf_algorithm\"] = algorithm.lower()\n        self.params[\"rem\"][\"max_scf_cycles\"] = iterations", "response": "Set the algorithm used for converging SCF and max number of SCF iterations."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset the grid for DFT numerical integrations.", "response": "def set_dft_grid(self, radical_points=128, angular_points=302,\n                     grid_type=\"Lebedev\"):\n        \"\"\"\n        Set the grid for DFT numerical integrations.\n\n        Args:\n            radical_points: Radical points. (Integer)\n            angular_points: Angular points. (Integer)\n            grid_type: The type of of the grid. There are two standard grids:\n                SG-1 and SG-0. The other two supported grids are \"Lebedev\" and\n                \"Gauss-Legendre\"\n        \"\"\"\n        available_lebedev_angular_points = {6, 18, 26, 38, 50, 74, 86, 110, 146,\n                                            170, 194, 230, 266, 302, 350, 434,\n                                            590, 770, 974, 1202, 1454, 1730,\n                                            2030, 2354, 2702, 3074, 3470, 3890,\n                                            4334, 4802, 5294}\n        if grid_type.lower() == \"sg-0\":\n            self.params[\"rem\"][\"xc_grid\"] = 0\n        elif grid_type.lower() == \"sg-1\":\n            self.params[\"rem\"][\"xc_grid\"] = 1\n        elif grid_type.lower() == \"lebedev\":\n            if angular_points not in available_lebedev_angular_points:\n                raise ValueError(str(angular_points) + \" is not a valid \"\n                                 \"Lebedev angular points number\")\n            self.params[\"rem\"][\"xc_grid\"] = \"{rp:06d}{ap:06d}\".format(\n                rp=radical_points, ap=angular_points)\n        elif grid_type.lower() == \"gauss-legendre\":\n            self.params[\"rem\"][\"xc_grid\"] = \"-{rp:06d}{ap:06d}\".format(\n                rp=radical_points, ap=angular_points)\n        else:\n            raise ValueError(\"Grid type \" + grid_type + \" is not supported \"\n                                                        \"currently\")"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset initial guess method to be used for SCF", "response": "def set_scf_initial_guess(self, guess=\"SAD\"):\n        \"\"\"\n        Set initial guess method to be used for SCF\n\n        Args:\n            guess: The initial guess method. (str)\n        \"\"\"\n        availabel_guesses = {\"core\", \"sad\", \"gwh\", \"read\", \"fragmo\"}\n        if guess.lower() not in availabel_guesses:\n            raise ValueError(\"The guess method \" + guess + \" is not supported \"\n                                                           \"yet\")\n        self.params[\"rem\"][\"scf_guess\"] = guess.lower()"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets the coordinates system used in geometry optimization.", "response": "def set_geom_opt_coords_type(self, coords_type=\"internal_switch\"):\n        \"\"\"\n        Set the coordinates system used in geometry optimization.\n        \"cartesian\"       --- always cartesian coordinates.\n        \"internal\"        --- always internal coordinates.\n        \"internal-switch\" --- try internal coordinates first, if fails, switch\n        to cartesian coordinates.\n        \"z-matrix\"        --- always z-matrix coordinates.\n        \"z-matrix-switch\" --- try z-matrix first, if fails, switch to\n        cartesian coordinates.\n\n        Args:\n            coords_type: The type of the coordinates. (str)\n        \"\"\"\n        coords_map = {\"cartesian\": 0, \"internal\": 1, \"internal-switch\": -1,\n                      \"z-matrix\": 2, \"z-matrix-switch\": -2}\n        if coords_type.lower() not in set(coords_map.keys()):\n            raise ValueError(\"Coodinate system \" + coords_type + \" is not \"\n                             \"supported yet\")\n        else:\n            self.params[\"rem\"][\"geom_opt_coords\"] = \\\n                coords_map[coords_type.lower()]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadjust the convergence criteria of geometry optimization.", "response": "def scale_geom_opt_threshold(self, gradient=0.1, displacement=0.1,\n                                 energy=0.1):\n        \"\"\"\n        Adjust the convergence criteria of geometry optimization.\n\n        Args:\n            gradient: the scale factor for gradient criteria. If less than\n                1.0, you are tightening the threshold. The base value is\n                300 \u00d7 10E\u22126\n            displacement: the scale factor for atomic displacement. If less\n                then 1.0, you are tightening the threshold. The base value is\n                1200 \u00d7 10E\u22126\n            energy: the scale factor for energy change between successive\n                iterations. If less than 1.0, you are tightening the\n                threshold. The base value is 100 \u00d7 10E\u22128.\n        \"\"\"\n        if gradient < 1.0/(300-1) or displacement < 1.0/(1200-1) or \\\n                energy < 1.0/(100-1):\n            raise ValueError(\"The geometry optimization convergence criteria \"\n                             \"is too tight\")\n        self.params[\"rem\"][\"geom_opt_tol_gradient\"] = int(gradient * 300)\n        self.params[\"rem\"][\"geom_opt_tol_displacement\"] = int(displacement *\n                                                              1200)\n        self.params[\"rem\"][\"geom_opt_tol_energy\"] = int(energy * 100)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef use_pcm(self, pcm_params=None, solvent_key=\"solvent\", solvent_params=None,\n                radii_force_field=None):\n        \"\"\"\n        Set the solvent model to PCM. Default parameters are trying to comply to\n        gaussian default value\n\n        Args:\n            pcm_params (dict): The parameters of \"$pcm\" section.\n            solvent_key (str): for versions < 4.2 the section name is \"pcm_solvent\"\n            solvent_params (dict): The parameters of solvent_key section\n            radii_force_field (str): The force fied used to set the solute\n                radii. Default to UFF.\n        \"\"\"\n        self.params[\"pcm\"] = dict()\n        self.params[solvent_key] = dict()\n        default_pcm_params = {\"Theory\": \"SSVPE\",\n                              \"vdwScale\": 1.1,\n                              \"Radii\": \"UFF\"}\n        if not solvent_params:\n            solvent_params = {\"Dielectric\": 78.3553}\n        if pcm_params:\n            for k, v in pcm_params.items():\n                self.params[\"pcm\"][k.lower()] = v.lower() \\\n                    if isinstance(v, str) else v\n\n        for k, v in default_pcm_params.items():\n            if k.lower() not in self.params[\"pcm\"].keys():\n                self.params[\"pcm\"][k.lower()] = v.lower() \\\n                    if isinstance(v, str) else v\n        for k, v in solvent_params.items():\n            self.params[solvent_key][k.lower()] = v.lower() \\\n                if isinstance(v, str) else copy.deepcopy(v)\n        self.params[\"rem\"][\"solvent_method\"] = \"pcm\"\n        if radii_force_field:\n            self.params[\"pcm\"][\"radii\"] = \"bondi\"\n            self.params[\"rem\"][\"force_fied\"] = radii_force_field.lower()", "response": "Sets the solvent model to PCM."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef from_string(cls, contents):\n        mol = None\n        charge = None\n        spin_multiplicity = None\n        params = dict()\n        lines = contents.split('\\n')\n        parse_section = False\n        section_name = None\n        section_text = []\n        ghost_atoms = None\n        for line_num, line in enumerate(lines):\n            l = line.strip().lower()\n\n            if len(l) == 0:\n                continue\n            if (not parse_section) and (l == \"$end\" or not l.startswith(\"$\")):\n                raise ValueError(\"Format error, parsing failed\")\n            if parse_section and l != \"$end\":\n                section_text.append(line)\n            if l.startswith(\"$\") and not parse_section:\n                parse_section = True\n                section_name = l[1:]\n                available_sections = [\"comment\", \"molecule\", \"rem\"] + \\\n                    sorted(list(cls.optional_keywords_list))\n                if section_name not in available_sections:\n                    raise ValueError(\"Unrecognized keyword \" + line.strip() +\n                                     \" at line \" + str(line_num))\n                if section_name in params:\n                    raise ValueError(\"duplicated keyword \" + line.strip() +\n                                     \"at line \" + str(line_num))\n            if parse_section and l == \"$end\":\n                func_name = \"_parse_\" + section_name\n                if func_name not in QcTask.__dict__:\n                    raise Exception(func_name + \" is not implemented yet, \"\n                                    \"please implement it\")\n                parse_func = QcTask.__dict__[func_name].__get__(None, QcTask)\n                if section_name == \"molecule\":\n                    mol, charge, spin_multiplicity, ghost_atoms = parse_func(section_text)\n                else:\n                    d = parse_func(section_text)\n                    params[section_name] = d\n                parse_section = False\n                section_name = None\n                section_text = []\n        if parse_section:\n            raise ValueError(\"Format error. \" + section_name + \" is not \"\n                             \"terminated\")\n        jobtype = params[\"rem\"][\"jobtype\"]\n        title = params.get(\"comment\", None)\n        exchange = params[\"rem\"].get(\"exchange\", \"hf\")\n        method = params[\"rem\"].get(\"method\", None)\n        correlation = params[\"rem\"].get(\"correlation\", None)\n        basis_set = params[\"rem\"][\"basis\"]\n        aux_basis_set = params[\"rem\"].get(\"aux_basis\", None)\n        ecp = params[\"rem\"].get(\"ecp\", None)\n        optional_params = None\n        op_keys = set(params.keys()) - {\"comment\", \"rem\"}\n        if len(op_keys) > 0:\n            optional_params = dict()\n            for k in op_keys:\n                optional_params[k] = params[k]\n        return QcTask(molecule=mol, charge=charge,\n                      spin_multiplicity=spin_multiplicity,\n                      jobtype=jobtype, title=title,\n                      exchange=exchange, correlation=correlation,\n                      basis_set=basis_set, aux_basis_set=aux_basis_set,\n                      ecp=ecp, rem_params=params[\"rem\"],\n                      optional_params=optional_params,\n                      ghost_atoms=ghost_atoms,\n                      method=method)", "response": "Creates a new object from a string."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef magnetic_deformation(structure_A, structure_B):\n\n    # retrieve orderings of both input structures\n    ordering_a = CollinearMagneticStructureAnalyzer(\n        structure_A, overwrite_magmom_mode=\"none\"\n    ).ordering\n    ordering_b = CollinearMagneticStructureAnalyzer(\n        structure_B, overwrite_magmom_mode=\"none\"\n    ).ordering\n\n    # get a type string, this is either 'NM-FM' for between non-magnetic\n    # and ferromagnetic, as in Bocarsly paper, or e.g. 'FM-AFM'\n    type_str = \"{}-{}\".format(ordering_a.value, ordering_b.value)\n\n    lattice_a = structure_A.lattice.matrix.T\n    lattice_b = structure_B.lattice.matrix.T\n    lattice_a_inv = np.linalg.inv(lattice_a)\n    p = np.dot(lattice_a_inv, lattice_b)\n    eta = 0.5 * (np.dot(p.T, p) - np.identity(3))\n    w, v = np.linalg.eig(eta)\n    deformation = 100 * (1.0 / 3.0) * np.sqrt(w[0] ** 2 + w[1] ** 2 + w[2] ** 2)\n\n    MagneticDeformation = namedtuple(\"MagneticDeformation\", \"type deformation\")\n\n    return MagneticDeformation(deformation=deformation, type=type_str)", "response": "Calculates the magnetic deformation between two structures."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _round_magmoms(magmoms, round_magmoms_mode: Union[int, float]):\n\n        if isinstance(round_magmoms_mode, int):\n\n            # simple rounding to number of decimal places\n            magmoms = np.around(magmoms, decimals=round_magmoms_mode)\n\n        elif isinstance(round_magmoms_mode, float):\n\n            try:\n\n                # get range of possible magmoms, pad by 50% just to be safe\n                range_m = max([max(magmoms), abs(min(magmoms))]) * 1.5\n\n                # construct kde, here \"round_magmoms_mode\" is the width of the kde\n                kernel = gaussian_kde(magmoms, bw_method=round_magmoms_mode)\n\n                # with a linearly spaced grid 1000x finer than width\n                xgrid = np.linspace(\n                    -range_m, range_m, 1000 * range_m / round_magmoms_mode\n                )\n\n                # and evaluate the kde on this grid, extracting the maxima of the kde peaks\n                kernel_m = kernel.evaluate(xgrid)\n                extrema = xgrid[argrelextrema(kernel_m, comparator=np.greater)]\n\n                # round magmoms to these extrema\n                magmoms = [extrema[(np.abs(extrema - m)).argmin()] for m in magmoms]\n\n            except Exception as e:\n\n                # TODO: typically a singular matrix warning, investigate this\n                warnings.warn(\n                    \"Failed to round magmoms intelligently, \"\n                    \"falling back to simple rounding.\"\n                )\n                warnings.warn(e)\n\n            # and finally round roughly to the number of significant figures in our kde width\n            num_decimals = len(str(round_magmoms_mode).split(\".\")[1]) + 1\n            magmoms = np.around(magmoms, decimals=num_decimals)\n\n        return magmoms", "response": "Round the magmoms in the current number of modulation of the kde."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a Structure with species decorated with spin values instead of using magmom site properties.", "response": "def get_structure_with_spin(self):\n        \"\"\"\n        Returns a Structure with species decorated with spin values instead\n        of using magmom site properties.\n        :return: Structure\n        \"\"\"\n\n        structure = self.structure.copy()\n        structure.add_spin_by_site(structure.site_properties[\"magmom\"])\n        structure.remove_site_property(\"magmom\")\n\n        return structure"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_structure_with_only_magnetic_atoms(self, make_primitive=True):\n\n        sites = [site for site in self.structure if abs(site.properties[\"magmom\"]) > 0]\n\n        structure = Structure.from_sites(sites)\n\n        if make_primitive:\n            structure = structure.get_primitive_structure(use_site_props=True)\n\n        return structure", "response": "Returns a Structure with only magnetic atoms present."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_nonmagnetic_structure(self, make_primitive=True):\n\n        structure = self.structure.copy()\n        structure.remove_site_property(\"magmom\")\n\n        if make_primitive:\n            structure = structure.get_primitive_structure()\n\n        return structure", "response": "Returns a Structure with no magnetic moments defined."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_ferromagnetic_structure(self, make_primitive=True):\n\n        structure = self.structure.copy()\n\n        structure.add_site_property(\"magmom\", [abs(m) for m in self.magmoms])\n\n        if make_primitive:\n            structure = structure.get_primitive_structure(use_site_props=True)\n\n        return structure", "response": "Returns a Structure with all magnetic moments positive\n        or zero."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef number_of_unique_magnetic_sites(self, symprec=1e-3, angle_tolerance=5):\n\n        structure = self.get_nonmagnetic_structure()\n\n        sga = SpacegroupAnalyzer(\n            structure, symprec=symprec, angle_tolerance=angle_tolerance\n        )\n\n        symm_structure = sga.get_symmetrized_structure()\n\n        num_unique_mag_sites = 0\n\n        for group_of_sites in symm_structure.equivalent_sites:\n            if group_of_sites[0].specie in self.types_of_magnetic_specie:\n                num_unique_mag_sites += 1\n\n        return num_unique_mag_sites", "response": "returns the number of unique magnetic sites present in the structure"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ndetermines the magnetic ordering for a collinear structure.", "response": "def ordering(self):\n        \"\"\"\n        Applies heuristics to return a magnetic ordering for a collinear\n        magnetic structure. Result is not guaranteed for correctness.\n        :return: Ordering Enum ('FiM' is used as the abbreviation for\n        ferrimagnetic)\n        \"\"\"\n\n        if not self.is_collinear:\n            warnings.warn(\n                \"Detecting ordering in non-collinear structures not yet implemented.\"\n            )\n            return Ordering.Unknown\n\n        if \"magmom\" not in self.structure.site_properties:\n            # maybe this was a non-spin-polarized calculation, or we've\n            # lost the magnetic moment information\n            return Ordering.Unknown\n\n        magmoms = self.magmoms\n\n        max_magmom = max(magmoms)\n\n        total_magnetization = abs(sum(magmoms))\n\n        is_potentially_ferromagnetic = np.all(magmoms >= 0) or np.all(magmoms <= 0)\n\n        if total_magnetization > 0 and is_potentially_ferromagnetic:\n            return Ordering.FM\n        elif total_magnetization > 0:\n            return Ordering.FiM\n        elif max_magmom > 0:\n            return Ordering.AFM\n        else:\n            return Ordering.NM"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the spacegroup symbol and international number of the exchange energy of the system.", "response": "def get_exchange_group_info(self, symprec=1e-2, angle_tolerance=5.0):\n        \"\"\"\n        Returns the information on the symmetry of the Hamiltonian\n        describing the exchange energy of the system, taking into\n        account relative direction of magnetic moments but not their\n        absolute direction.\n\n        This is not strictly accurate (e.g. some/many atoms will\n        have zero magnetic moments), but defining symmetry this\n        way is a useful way of keeping track of distinct magnetic\n        orderings within pymatgen.\n\n        :param symprec: same as SpacegroupAnalyzer\n        :param angle_tolerance: same as SpacegroupAnalyzer\n        :return: spacegroup_symbol, international_number\n        \"\"\"\n\n        structure = self.get_structure_with_spin()\n\n        return structure.get_space_group_info(\n            symprec=symprec, angle_tolerance=angle_tolerance\n        )"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncompares the magnetic orderings of one structure with another structure.", "response": "def matches_ordering(self, other):\n        \"\"\"\n        Compares the magnetic orderings of one structure with another.\n        :param other: Structure\n        :return (bool):\n        \"\"\"\n\n        a = CollinearMagneticStructureAnalyzer(\n            self.structure, overwrite_magmom_mode=\"normalize\"\n        ).get_structure_with_spin()\n\n        # sign of spins doesn't matter, so we're comparing both\n        # positive and negative versions of the structure\n        # this code is possibly redundant, but is included out of\n        # an abundance of caution\n        b_positive = CollinearMagneticStructureAnalyzer(\n            other, overwrite_magmom_mode=\"normalize\", make_primitive=False\n        )\n\n        b_negative = b_positive.structure.copy()\n        b_negative.add_site_property(\n            \"magmom\", np.multiply(-1, b_negative.site_properties[\"magmom\"])\n        )\n\n        b_negative = CollinearMagneticStructureAnalyzer(\n            b_negative, overwrite_magmom_mode=\"normalize\", make_primitive=False\n        )\n\n        b_positive = b_positive.get_structure_with_spin()\n        b_negative = b_negative.get_structure_with_spin()\n\n        if a.matches(b_positive) or a.matches(\n            b_negative\n        ):  # sometimes returns None (bug?)\n            return True\n        else:\n            return False"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _sanitize_input_structure(input_structure):\n\n        input_structure = input_structure.copy()\n\n        # remove any annotated spin\n        input_structure.remove_spin()\n\n        # sanitize input structure: first make primitive ...\n        input_structure = input_structure.get_primitive_structure(use_site_props=False)\n\n        # ... and strip out existing magmoms, which can cause conflicts\n        # with later transformations otherwise since sites would end up\n        # with both magmom site properties and Specie spins defined\n        if \"magmom\" in input_structure.site_properties:\n            input_structure.remove_site_property(\"magmom\")\n\n        return input_structure", "response": "Sanitize our input structure by removing magnetic information\n        and making primitive."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngenerates a dictionary of transformation class instances and names of the unique orderings that are used to generate the new magnetic orderings for the given structure.", "response": "def _generate_transformations(self, structure):\n        \"\"\"\n        The central problem with trying to enumerate magnetic orderings is\n        that we have to enumerate orderings that might plausibly be magnetic\n        ground states, while not enumerating orderings that are physically\n        implausible. The problem is that it is not always obvious by e.g.\n        symmetry arguments alone which orderings to prefer. Here, we use a\n        variety of strategies (heuristics) to enumerate plausible orderings,\n        and later discard any duplicates that might be found by multiple\n        strategies. This approach is not ideal, but has been found to be\n        relatively robust over a wide range of magnetic structures.\n\n        Args:\n            structure: A sanitized input structure (_sanitize_input_structure)\n\n        Returns: A dict of a transformation class instance (values) and name of\n        enumeration strategy (keys)\n        \"\"\"\n\n        formula = structure.composition.reduced_formula\n        transformations = {}\n\n        # analyzer is used to obtain information on sanitized input\n        analyzer = CollinearMagneticStructureAnalyzer(\n            structure,\n            default_magmoms=self.default_magmoms,\n            overwrite_magmom_mode=\"replace_all\",\n        )\n\n        if not analyzer.is_magnetic:\n            raise ValueError(\n                \"Not detected as magnetic, add a new default magmom for the \"\n                \"element you believe may be magnetic?\"\n            )\n\n        # now we can begin to generate our magnetic orderings\n        self.logger.info(\"Generating magnetic orderings for {}\".format(formula))\n\n        mag_species_spin = analyzer.magnetic_species_and_magmoms\n        types_mag_species = sorted(\n            analyzer.types_of_magnetic_specie,\n            key=lambda sp: analyzer.default_magmoms.get(str(sp), 0),\n            reverse=True,\n        )\n        num_mag_sites = analyzer.number_of_magnetic_sites\n        num_unique_sites = analyzer.number_of_unique_magnetic_sites()\n\n        # enumerations become too slow as number of unique sites (and thus\n        # permutations) increase, 8 is a soft limit, this can be increased\n        # but do so with care\n        if num_unique_sites > self.max_unique_sites:\n            raise ValueError(\"Too many magnetic sites to sensibly perform enumeration.\")\n\n        # maximum cell size to consider: as a rule of thumb, if the primitive cell\n        # contains a large number of magnetic sites, perhaps we only need to enumerate\n        # within one cell, whereas on the other extreme if the primitive cell only\n        # contains a single magnetic site, we have to create larger supercells\n        if \"max_cell_size\" not in self.transformation_kwargs:\n            # TODO: change to 8 / num_mag_sites ?\n            self.transformation_kwargs[\"max_cell_size\"] = max(1, int(4 / num_mag_sites))\n        self.logger.info(\n            \"Max cell size set to {}\".format(\n                self.transformation_kwargs[\"max_cell_size\"]\n            )\n        )\n\n        # when enumerating ferrimagnetic structures, it's useful to detect\n        # symmetrically distinct magnetic sites, since different\n        # local environments can result in different magnetic order\n        # (e.g. inverse spinels)\n        # initially, this was done by co-ordination number, but is\n        # now done by a full symmetry analysis\n        sga = SpacegroupAnalyzer(structure)\n        structure_sym = sga.get_symmetrized_structure()\n        wyckoff = [\"n/a\"] * len(structure)\n        for indices, symbol in zip(\n            structure_sym.equivalent_indices, structure_sym.wyckoff_symbols\n        ):\n            for index in indices:\n                wyckoff[index] = symbol\n        is_magnetic_sites = [\n            True if site.specie in types_mag_species else False for site in structure\n        ]\n        # we're not interested in sites that we don't think are magnetic,\n        # set these symbols to None to filter them out later\n        wyckoff = [\n            symbol if is_magnetic_site else \"n/a\"\n            for symbol, is_magnetic_site in zip(wyckoff, is_magnetic_sites)\n        ]\n        structure.add_site_property(\"wyckoff\", wyckoff)\n        wyckoff_symbols = set(wyckoff) - {\"n/a\"}\n\n        # if user doesn't specifically request ferrimagnetic_Cr2NiO4 orderings,\n        # we apply a heuristic as to whether to attempt them or not\n        if self.automatic:\n            if (\n                \"ferrimagnetic_by_motif\" not in self.strategies\n                and len(wyckoff_symbols) > 1\n                and len(types_mag_species) == 1\n            ):\n                self.strategies += (\"ferrimagnetic_by_motif\",)\n\n            if (\n                \"antiferromagnetic_by_motif\" not in self.strategies\n                and len(wyckoff_symbols) > 1\n                and len(types_mag_species) == 1\n            ):\n                self.strategies += (\"antiferromagnetic_by_motif\",)\n\n            if (\n                \"ferrimagnetic_by_species\" not in self.strategies\n                and len(types_mag_species) > 1\n            ):\n                self.strategies += (\"ferrimagnetic_by_species\",)\n\n        # we start with a ferromagnetic ordering\n        if \"ferromagnetic\" in self.strategies:\n\n            # TODO: remove 0 spins !\n\n            fm_structure = analyzer.get_ferromagnetic_structure()\n            # store magmom as spin property, to be consistent with output from\n            # other transformations\n            fm_structure.add_spin_by_site(fm_structure.site_properties[\"magmom\"])\n            fm_structure.remove_site_property(\"magmom\")\n\n            # we now have our first magnetic ordering...\n            self.ordered_structures.append(fm_structure)\n            self.ordered_structure_origins.append(\"fm\")\n\n        # we store constraint(s) for each strategy first,\n        # and then use each to perform a transformation later\n        all_constraints = {}\n\n        # ...to which we can add simple AFM cases first...\n        if \"antiferromagnetic\" in self.strategies:\n\n            constraint = MagOrderParameterConstraint(\n                0.5,\n                # TODO: update MagOrderParameterConstraint in pymatgen to take types_mag_species directly\n                species_constraints=list(map(str, types_mag_species)),\n            )\n            all_constraints[\"afm\"] = [constraint]\n\n            # allows for non-magnetic sublattices\n            if len(types_mag_species) > 1:\n                for sp in types_mag_species:\n\n                    constraints = [\n                        MagOrderParameterConstraint(0.5, species_constraints=str(sp))\n                    ]\n\n                    all_constraints[\"afm_by_{}\".format(sp)] = constraints\n\n        # ...and then we also try ferrimagnetic orderings by motif if a\n        # single magnetic species is present...\n        if \"ferrimagnetic_by_motif\" in self.strategies and len(wyckoff_symbols) > 1:\n\n            # these orderings are AFM on one local environment, and FM on the rest\n            for symbol in wyckoff_symbols:\n\n                constraints = [\n                    MagOrderParameterConstraint(\n                        0.5, site_constraint_name=\"wyckoff\", site_constraints=symbol\n                    ),\n                    MagOrderParameterConstraint(\n                        1.0,\n                        site_constraint_name=\"wyckoff\",\n                        site_constraints=list(wyckoff_symbols - {symbol}),\n                    ),\n                ]\n\n                all_constraints[\"ferri_by_motif_{}\".format(symbol)] = constraints\n\n        # and also try ferrimagnetic when there are multiple magnetic species\n        if \"ferrimagnetic_by_species\" in self.strategies:\n\n            sp_list = [str(site.specie) for site in structure]\n            num_sp = {sp: sp_list.count(str(sp)) for sp in types_mag_species}\n            total_mag_sites = sum(num_sp.values())\n\n            for sp in types_mag_species:\n\n                # attempt via a global order parameter\n                all_constraints[\"ferri_by_{}\".format(sp)] = num_sp[sp] / total_mag_sites\n\n                # attempt via afm on sp, fm on remaining species\n\n                constraints = [\n                    MagOrderParameterConstraint(0.5, species_constraints=str(sp)),\n                    MagOrderParameterConstraint(\n                        1.0,\n                        species_constraints=list(\n                            map(str, set(types_mag_species) - {sp})\n                        ),\n                    ),\n                ]\n\n                all_constraints[\"ferri_by_{}_afm\".format(sp)] = constraints\n\n        # ...and finally, we can try orderings that are AFM on one local\n        # environment, and non-magnetic on the rest -- this is less common\n        # but unless explicitly attempted, these states are unlikely to be found\n        if \"antiferromagnetic_by_motif\" in self.strategies:\n\n            for symbol in wyckoff_symbols:\n\n                constraints = [\n                    MagOrderParameterConstraint(\n                        0.5, site_constraint_name=\"wyckoff\", site_constraints=symbol\n                    )\n                ]\n\n                all_constraints[\"afm_by_motif_{}\".format(symbol)] = constraints\n\n        # and now construct all our transformations for each strategy\n        transformations = {}\n        for name, constraints in all_constraints.items():\n\n            trans = MagOrderingTransformation(\n                mag_species_spin,\n                order_parameter=constraints,\n                **self.transformation_kwargs\n            )\n\n            transformations[name] = trans\n\n        return transformations"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\napply our input structure to our list of transformations and output a list of ordered structures that have been pruned for duplicates and for those with low symmetry (optional). Args: sanitized_input_structure: A sanitized input structure (_sanitize_input_structure) transformations: A dict of transformations (values) and name of enumeration strategy (key), the enumeration strategy name is just for record keeping Returns: None (sets self.ordered_structures and self.ordered_structures_origins instance variables)", "response": "def _generate_ordered_structures(self, sanitized_input_structure, transformations):\n        \"\"\"\n        Apply our input structure to our list of transformations and output a list\n        of ordered structures that have been pruned for duplicates and for those\n        with low symmetry (optional).\n\n        Args:\n            sanitized_input_structure: A sanitized input structure\n            (_sanitize_input_structure)\n            transformations: A dict of transformations (values) and name of\n            enumeration strategy (key), the enumeration strategy name is just\n            for record keeping\n\n        Returns: None (sets self.ordered_structures\n        and self.ordered_structures_origins instance variables)\n\n        \"\"\"\n\n        ordered_structures = self.ordered_structures\n        ordered_structures_origins = self.ordered_structure_origins\n\n        # utility function to combine outputs from several transformations\n        def _add_structures(\n            ordered_structures, ordered_structures_origins, structures_to_add, origin=\"\"\n        ):\n            \"\"\"\n            Transformations with return_ranked_list can return either\n            just Structures or dicts (or sometimes lists!) -- until this\n            is fixed, we use this function to concat structures given\n            by the transformation.\n            \"\"\"\n            if structures_to_add:\n                # type conversion\n                if isinstance(structures_to_add, Structure):\n                    structures_to_add = [structures_to_add]\n                structures_to_add = [\n                    s[\"structure\"] if isinstance(s, dict) else s\n                    for s in structures_to_add\n                ]\n                # concatenation\n                ordered_structures += structures_to_add\n                ordered_structures_origins += [origin] * len(structures_to_add)\n                self.logger.info(\n                    \"Adding {} ordered structures: {}\".format(\n                        len(structures_to_add), origin\n                    )\n                )\n\n            return ordered_structures, ordered_structures_origins\n\n        for origin, trans in self.transformations.items():\n            structures_to_add = trans.apply_transformation(\n                self.sanitized_structure, return_ranked_list=self.num_orderings\n            )\n            ordered_structures, ordered_structures_origins = _add_structures(\n                ordered_structures,\n                ordered_structures_origins,\n                structures_to_add,\n                origin=origin,\n            )\n\n        # in case we've introduced duplicates, let's remove them\n        self.logger.info(\"Pruning duplicate structures.\")\n        structures_to_remove = []\n        for idx, ordered_structure in enumerate(ordered_structures):\n            if idx not in structures_to_remove:\n                duplicate_checker = CollinearMagneticStructureAnalyzer(\n                    ordered_structure, overwrite_magmom_mode=\"none\"\n                )\n                for check_idx, check_structure in enumerate(ordered_structures):\n                    if check_idx not in structures_to_remove and check_idx != idx:\n                        if duplicate_checker.matches_ordering(check_structure):\n                            structures_to_remove.append(check_idx)\n\n        if len(structures_to_remove):\n            self.logger.info(\n                \"Removing {} duplicate ordered structures\".format(\n                    len(structures_to_remove)\n                )\n            )\n            ordered_structures = [\n                s\n                for idx, s in enumerate(ordered_structures)\n                if idx not in structures_to_remove\n            ]\n            ordered_structures_origins = [\n                o\n                for idx, o in enumerate(ordered_structures_origins)\n                if idx not in structures_to_remove\n            ]\n\n        # also remove low symmetry structures\n        if self.truncate_by_symmetry:\n\n            # by default, keep structures with 5 most symmetric space groups\n            if not isinstance(self.truncate_by_symmetry, int):\n                self.truncate_by_symmetry = 5\n\n            self.logger.info(\"Pruning low symmetry structures.\")\n\n            # first get a list of symmetries present\n            symmetry_int_numbers = [\n                s.get_space_group_info()[1] for s in ordered_structures\n            ]\n\n            # then count the number of symmetry operations for that space group\n            num_sym_ops = [\n                len(SpaceGroup.from_int_number(n).symmetry_ops)\n                for n in symmetry_int_numbers\n            ]\n\n            # find the largest values...\n            max_symmetries = sorted(list(set(num_sym_ops)), reverse=True)\n\n            # ...and decide which ones to keep\n            if len(max_symmetries) > self.truncate_by_symmetry:\n                max_symmetries = max_symmetries[0:5]\n            structs_to_keep = [\n                (idx, num)\n                for idx, num in enumerate(num_sym_ops)\n                if num in max_symmetries\n            ]\n\n            # sort so that highest symmetry structs are first\n            structs_to_keep = sorted(\n                structs_to_keep, key=lambda x: (x[1], -x[0]), reverse=True\n            )\n\n            self.logger.info(\n                \"Removing {} low symmetry \"\n                \"ordered structures\".format(\n                    len(ordered_structures) - len(structs_to_keep)\n                )\n            )\n\n            ordered_structures = [ordered_structures[i] for i, _ in structs_to_keep]\n            ordered_structures_origins = [\n                ordered_structures_origins[i] for i, _ in structs_to_keep\n            ]\n\n            # and ensure fm is always at index 0\n            fm_index = ordered_structures_origins.index(\"fm\")\n            ordered_structures.insert(0, ordered_structures.pop(fm_index))\n            ordered_structures_origins.insert(\n                0, ordered_structures_origins.pop(fm_index)\n            )\n\n        # if our input structure isn't in our generated structures,\n        # let's add it manually and also keep a note of which structure\n        # is our input: this is mostly for book-keeping/benchmarking\n        self.input_index = None\n        self.input_origin = None\n        if self.input_analyzer.ordering != Ordering.NM:\n            matches = [\n                self.input_analyzer.matches_ordering(s) for s in ordered_structures\n            ]\n            if not any(matches):\n                ordered_structures.append(self.input_analyzer.structure)\n                ordered_structures_origins.append(\"input\")\n                self.logger.info(\n                    \"Input structure not present in enumerated structures, adding...\"\n                )\n            else:\n                self.logger.info(\n                    \"Input structure was found in enumerated \"\n                    \"structures at index {}\".format(matches.index(True))\n                )\n                self.input_index = matches.index(True)\n                self.input_origin = ordered_structures_origins[self.input_index]\n\n        self.ordered_structures = ordered_structures\n        self.ordered_structure_origins = ordered_structures_origins"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconverting a string to a float.", "response": "def str2float(text):\n    \"\"\"\n    Remove uncertainty brackets from strings and return the float.\n    \"\"\"\n\n    try:\n        # Note that the ending ) is sometimes missing. That is why the code has\n        # been modified to treat it as optional. Same logic applies to lists.\n        return float(re.sub(r\"\\(.+\\)*\", \"\", text))\n    except TypeError:\n        if isinstance(text, list) and len(text) == 1:\n            return float(re.sub(r\"\\(.+\\)*\", \"\", text[0]))\n    except ValueError as ex:\n        if text.strip() == \".\":\n            return 0\n        raise ex"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _sanitize_data(self, data):\n\n        \"\"\"\n        This part of the code deals with handling formats of data as found in\n        CIF files extracted from the Springer Materials/Pauling File\n        databases, and that are different from standard ICSD formats.\n        \"\"\"\n\n        # check for implicit hydrogens, warn if any present\n        if \"_atom_site_attached_hydrogens\" in data.data.keys():\n            attached_hydrogens = [str2float(x) for x in data.data['_atom_site_attached_hydrogens']\n                                  if str2float(x) != 0]\n            if len(attached_hydrogens) > 0:\n                self.errors.append(\"Structure has implicit hydrogens defined, \"\n                                   \"parsed structure unlikely to be suitable for use \"\n                                   \"in calculations unless hydrogens added.\")\n\n        # Check to see if \"_atom_site_type_symbol\" exists, as some test CIFs do\n        # not contain this key.\n        if \"_atom_site_type_symbol\" in data.data.keys():\n\n            # Keep a track of which data row needs to be removed.\n            # Example of a row: Nb,Zr '0.8Nb + 0.2Zr' .2a .m-3m 0 0 0 1 14\n            # 'rhombic dodecahedron, Nb<sub>14</sub>'\n            # Without this code, the above row in a structure would be parsed\n            # as an ordered site with only Nb (since\n            # CifParser would try to parse the first two characters of the\n            # label \"Nb,Zr\") and occupancy=1.\n            # However, this site is meant to be a disordered site with 0.8 of\n            # Nb and 0.2 of Zr.\n            idxs_to_remove = []\n\n            new_atom_site_label = []\n            new_atom_site_type_symbol = []\n            new_atom_site_occupancy = []\n            new_fract_x = []\n            new_fract_y = []\n            new_fract_z = []\n\n            for idx, el_row in enumerate(data[\"_atom_site_label\"]):\n\n                # CIF files from the Springer Materials/Pauling File have\n                # switched the label and symbol. Thus, in the\n                # above shown example row, '0.8Nb + 0.2Zr' is the symbol.\n                # Below, we split the strings on ' + ' to\n                # check if the length (or number of elements) in the label and\n                # symbol are equal.\n                if len(data[\"_atom_site_type_symbol\"][idx].split(' + ')) > \\\n                        len(data[\"_atom_site_label\"][idx].split(' + ')):\n\n                    # Dictionary to hold extracted elements and occupancies\n                    els_occu = {}\n\n                    # parse symbol to get element names and occupancy and store\n                    # in \"els_occu\"\n                    symbol_str = data[\"_atom_site_type_symbol\"][idx]\n                    symbol_str_lst = symbol_str.split(' + ')\n                    for elocc_idx in range(len(symbol_str_lst)):\n                        # Remove any bracketed items in the string\n                        symbol_str_lst[elocc_idx] = re.sub(\n                            r'\\([0-9]*\\)', '',\n                            symbol_str_lst[elocc_idx].strip())\n\n                        # Extract element name and its occupancy from the\n                        # string, and store it as a\n                        # key-value pair in \"els_occ\".\n                        els_occu[str(re.findall(r'\\D+', symbol_str_lst[\n                            elocc_idx].strip())[1]).replace('<sup>', '')] = \\\n                            float('0' + re.findall(r'\\.?\\d+', symbol_str_lst[\n                                elocc_idx].strip())[1])\n\n                    x = str2float(data[\"_atom_site_fract_x\"][idx])\n                    y = str2float(data[\"_atom_site_fract_y\"][idx])\n                    z = str2float(data[\"_atom_site_fract_z\"][idx])\n\n                    for et, occu in els_occu.items():\n                        # new atom site labels have 'fix' appended\n                        new_atom_site_label.append(\n                            et + '_fix' + str(len(new_atom_site_label)))\n                        new_atom_site_type_symbol.append(et)\n                        new_atom_site_occupancy.append(str(occu))\n                        new_fract_x.append(str(x))\n                        new_fract_y.append(str(y))\n                        new_fract_z.append(str(z))\n\n                    idxs_to_remove.append(idx)\n\n            # Remove the original row by iterating over all keys in the CIF\n            # data looking for lists, which indicates\n            # multiple data items, one for each row, and remove items from the\n            # list that corresponds to the removed row,\n            # so that it's not processed by the rest of this function (which\n            # would result in an error).\n            for original_key in data.data:\n                if isinstance(data.data[original_key], list):\n                    for id in sorted(idxs_to_remove, reverse=True):\n                        del data.data[original_key][id]\n\n            if len(idxs_to_remove) > 0:\n\n                self.errors.append(\"Pauling file corrections applied.\")\n\n                data.data[\"_atom_site_label\"] += new_atom_site_label\n                data.data[\"_atom_site_type_symbol\"] += new_atom_site_type_symbol\n                data.data[\"_atom_site_occupancy\"] += new_atom_site_occupancy\n                data.data[\"_atom_site_fract_x\"] += new_fract_x\n                data.data[\"_atom_site_fract_y\"] += new_fract_y\n                data.data[\"_atom_site_fract_z\"] += new_fract_z\n\n        \"\"\"\n        This fixes inconsistencies in naming of several magCIF tags\n        as a result of magCIF being in widespread use prior to\n        specification being finalized (on advice of Branton Campbell).\n        \"\"\"\n\n        if self.feature_flags[\"magcif\"]:\n\n            # CIF-1 style has all underscores, interim standard\n            # had period before magn instead of before the final\n            # component (e.g. xyz)\n            # we want to standardize on a specific key, to simplify\n            # parsing code\n            correct_keys = [\"_space_group_symop_magn_operation.xyz\",\n                            \"_space_group_symop_magn_centering.xyz\",\n                            \"_space_group_magn.name_BNS\",\n                            \"_space_group_magn.number_BNS\",\n                            \"_atom_site_moment_crystalaxis_x\",\n                            \"_atom_site_moment_crystalaxis_y\",\n                            \"_atom_site_moment_crystalaxis_z\",\n                            \"_atom_site_moment_label\"]\n\n            # cannot mutate OrderedDict during enumeration,\n            # so store changes we want to make\n            changes_to_make = {}\n\n            for original_key in data.data:\n                for correct_key in correct_keys:\n                    # convert to all underscore\n                    trial_key = \"_\".join(correct_key.split(\".\"))\n                    test_key = \"_\".join(original_key.split(\".\"))\n                    if trial_key == test_key:\n                        changes_to_make[correct_key] = original_key\n\n            # make changes\n            for correct_key, original_key in changes_to_make.items():\n                data.data[correct_key] = data.data[original_key]\n\n            # renamed_keys maps interim_keys to final_keys\n            renamed_keys = {\n                \"_magnetic_space_group.transform_to_standard_Pp_abc\":\n                    \"_space_group_magn.transform_BNS_Pp_abc\"}\n            changes_to_make = {}\n\n            for interim_key, final_key in renamed_keys.items():\n                if data.data.get(interim_key):\n                    changes_to_make[final_key] = interim_key\n\n            if len(changes_to_make) > 0:\n                self.errors.append(\"Keys changed to match new magCIF specification.\")\n\n            for final_key, interim_key in changes_to_make.items():\n                data.data[final_key] = data.data[interim_key]\n\n        # check for finite precision frac co-ordinates (e.g. 0.6667 instead of 0.6666666...7)\n        # this can sometimes cause serious issues when applying symmetry operations\n        important_fracs = (1/3., 2/3.)\n        fracs_to_change = {}\n        for label in ('_atom_site_fract_x', '_atom_site_fract_y', '_atom_site_fract_z'):\n            if label in data.data.keys():\n                for idx, frac in enumerate(data.data[label]):\n                    try:\n                        frac = str2float(frac)\n                    except:\n                        # co-ordinate might not be defined e.g. '?'\n                        continue\n                    for comparison_frac in important_fracs:\n                        if abs(1 - frac/comparison_frac) < 1e-4:\n                            fracs_to_change[(label, idx)] = str(comparison_frac)\n        if fracs_to_change:\n            self.errors.append(\"Some fractional co-ordinates rounded to ideal values to \"\n                               \"avoid finite precision errors.\")\n            for (label, idx), val in fracs_to_change.items():\n                data.data[label][idx] = val\n\n        return data", "response": "This function checks that the data for the CifBlock contains the correct CifEntry and returns the data."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ngenerate unique coordinates using coord and symmetry positions and also their corresponding magnetic moments.", "response": "def _unique_coords(self, coords_in, magmoms_in=None, lattice=None):\n        \"\"\"\n        Generate unique coordinates using coord and symmetry positions\n        and also their corresponding magnetic moments, if supplied.\n        \"\"\"\n        coords = []\n        if magmoms_in:\n            magmoms = []\n            if len(magmoms_in) != len(coords_in):\n                raise ValueError\n            for tmp_coord, tmp_magmom in zip(coords_in, magmoms_in):\n                for op in self.symmetry_operations:\n                    coord = op.operate(tmp_coord)\n                    coord = np.array([i - math.floor(i) for i in coord])\n                    if isinstance(op, MagSymmOp):\n                        # Up to this point, magmoms have been defined relative\n                        # to crystal axis. Now convert to Cartesian and into\n                        # a Magmom object.\n                        magmom = Magmom.from_moment_relative_to_crystal_axes(\n                            op.operate_magmom(tmp_magmom),\n                            lattice=lattice\n                        )\n                    else:\n                        magmom = Magmom(tmp_magmom)\n                    if not in_coord_list_pbc(coords, coord,\n                                             atol=self._site_tolerance):\n                        coords.append(coord)\n                        magmoms.append(magmom)\n            return coords, magmoms\n        else:\n            for tmp_coord in coords_in:\n                for op in self.symmetry_operations:\n                    coord = op.operate(tmp_coord)\n                    coord = np.array([i - math.floor(i) for i in coord])\n                    if not in_coord_list_pbc(coords, coord,\n                                             atol=self._site_tolerance):\n                        coords.append(coord)\n            return coords, [Magmom(0)] * len(coords)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_lattice(self, data, length_strings=(\"a\", \"b\", \"c\"),\n                    angle_strings=(\"alpha\", \"beta\", \"gamma\"),\n                    lattice_type=None):\n        \"\"\"\n        Generate the lattice from the provided lattice parameters. In\n        the absence of all six lattice parameters, the crystal system\n        and necessary parameters are parsed\n        \"\"\"\n        try:\n\n            lengths = [str2float(data[\"_cell_length_\" + i])\n                       for i in length_strings]\n            angles = [str2float(data[\"_cell_angle_\" + i])\n                      for i in angle_strings]\n            if not lattice_type:\n                return Lattice.from_lengths_and_angles(lengths, angles)\n\n            else:\n                return getattr(Lattice, lattice_type)(*(lengths + angles))\n\n        except KeyError:\n            # Missing Key search for cell setting\n            for lattice_lable in [\"_symmetry_cell_setting\",\n                                  \"_space_group_crystal_system\"]:\n                if data.data.get(lattice_lable):\n                    lattice_type = data.data.get(lattice_lable).lower()\n                    try:\n\n                        required_args = getargspec(\n                            getattr(Lattice, lattice_type)).args\n\n                        lengths = (l for l in length_strings\n                                   if l in required_args)\n                        angles = (a for a in angle_strings\n                                  if a in required_args)\n                        return self.get_lattice(data, lengths, angles,\n                                                lattice_type=lattice_type)\n                    except AttributeError as exc:\n                        self.errors.append(str(exc))\n                        warnings.warn(exc)\n\n                else:\n                    return None", "response": "Generate the crystal system lattice from the provided lattice parameters."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a list of symops for the equivalent positions of the space group and symmetry operations.", "response": "def get_symops(self, data):\n        \"\"\"\n        In order to generate symmetry equivalent positions, the symmetry\n        operations are parsed. If the symops are not present, the space\n        group symbol is parsed, and symops are generated.\n        \"\"\"\n        symops = []\n        for symmetry_label in [\"_symmetry_equiv_pos_as_xyz\",\n                               \"_symmetry_equiv_pos_as_xyz_\",\n                               \"_space_group_symop_operation_xyz\",\n                               \"_space_group_symop_operation_xyz_\"]:\n            if data.data.get(symmetry_label):\n                xyz = data.data.get(symmetry_label)\n                if isinstance(xyz, str):\n                    msg = \"A 1-line symmetry op P1 CIF is detected!\"\n                    warnings.warn(msg)\n                    self.errors.append(msg)\n                    xyz = [xyz]\n                try:\n                    symops = [SymmOp.from_xyz_string(s)\n                              for s in xyz]\n                    break\n                except ValueError:\n                    continue\n        if not symops:\n            # Try to parse symbol\n            for symmetry_label in [\"_symmetry_space_group_name_H-M\",\n                                   \"_symmetry_space_group_name_H_M\",\n                                   \"_symmetry_space_group_name_H-M_\",\n                                   \"_symmetry_space_group_name_H_M_\",\n                                   \"_space_group_name_Hall\",\n                                   \"_space_group_name_Hall_\",\n                                   \"_space_group_name_H-M_alt\",\n                                   \"_space_group_name_H-M_alt_\",\n                                   \"_symmetry_space_group_name_hall\",\n                                   \"_symmetry_space_group_name_hall_\",\n                                   \"_symmetry_space_group_name_h-m\",\n                                   \"_symmetry_space_group_name_h-m_\"]:\n                sg = data.data.get(symmetry_label)\n\n                if sg:\n                    sg = sub_spgrp(sg)\n                    try:\n                        spg = space_groups.get(sg)\n                        if spg:\n                            symops = SpaceGroup(spg).symmetry_ops\n                            msg = \"No _symmetry_equiv_pos_as_xyz type key found. \" \\\n                                    \"Spacegroup from %s used.\" % symmetry_label\n                            warnings.warn(msg)\n                            self.errors.append(msg)\n                            break\n                    except ValueError:\n                        # Ignore any errors\n                        pass\n\n                    try:\n                        for d in _get_cod_data():\n                            if sg == re.sub(r\"\\s+\", \"\",\n                                            d[\"hermann_mauguin\"]):\n                                xyz = d[\"symops\"]\n                                symops = [SymmOp.from_xyz_string(s)\n                                          for s in xyz]\n                                msg = \"No _symmetry_equiv_pos_as_xyz type key found. \" \\\n                                        \"Spacegroup from %s used.\" % symmetry_label\n                                warnings.warn(msg)\n                                self.errors.append(msg)\n                                break\n                    except Exception as ex:\n                        continue\n\n                    if symops:\n                        break\n        if not symops:\n            # Try to parse International number\n            for symmetry_label in [\"_space_group_IT_number\",\n                                   \"_space_group_IT_number_\",\n                                   \"_symmetry_Int_Tables_number\",\n                                   \"_symmetry_Int_Tables_number_\"]:\n                if data.data.get(symmetry_label):\n                    try:\n                        i = int(str2float(data.data.get(symmetry_label)))\n                        symops = SpaceGroup.from_int_number(i).symmetry_ops\n                        break\n                    except ValueError:\n                        continue\n\n        if not symops:\n            msg = \"No _symmetry_equiv_pos_as_xyz type key found. \" \\\n                  \"Defaulting to P1.\"\n            warnings.warn(msg)\n            self.errors.append(msg)\n            symops = [SymmOp.from_xyz_string(s) for s in ['x', 'y', 'z']]\n\n        return symops"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a list of all magnetic symmetry operations for the specified magnetic space group.", "response": "def get_magsymops(self, data):\n        \"\"\"\n        Equivalent to get_symops except for magnetic symmetry groups.\n        Separate function since additional operation for time reversal symmetry\n        (which changes magnetic moments on sites) needs to be returned.\n        \"\"\"\n        magsymmops = []\n\n        # check to see if magCIF file explicitly contains magnetic symmetry operations\n        if data.data.get(\"_space_group_symop_magn_operation.xyz\"):\n\n            xyzt = data.data.get(\"_space_group_symop_magn_operation.xyz\")\n            if isinstance(xyzt, str):\n                xyzt = [xyzt]\n            magsymmops = [MagSymmOp.from_xyzt_string(s) for s in xyzt]\n\n            if data.data.get(\"_space_group_symop_magn_centering.xyz\"):\n\n                xyzt = data.data.get(\"_space_group_symop_magn_centering.xyz\")\n                if isinstance(xyzt, str):\n                    xyzt = [xyzt]\n                centering_symops = [MagSymmOp.from_xyzt_string(s) for s in xyzt]\n\n                all_ops = []\n                for op in magsymmops:\n                    for centering_op in centering_symops:\n                        new_translation = [i - np.floor(i) for i\n                                           in\n                                           op.translation_vector + centering_op.translation_vector]\n                        new_time_reversal = op.time_reversal * centering_op.time_reversal\n                        all_ops.append(\n                            MagSymmOp.from_rotation_and_translation_and_time_reversal(\n                                rotation_matrix=op.rotation_matrix,\n                                translation_vec=new_translation,\n                                time_reversal=new_time_reversal))\n                magsymmops = all_ops\n\n        # else check to see if it specifies a magnetic space group\n        elif data.data.get(\"_space_group_magn.name_BNS\") or data.data.get(\n                \"_space_group_magn.number_BNS\"):\n\n            if data.data.get(\"_space_group_magn.name_BNS\"):\n                # get BNS label for MagneticSpaceGroup()\n                id = data.data.get(\"_space_group_magn.name_BNS\")\n            else:\n                # get BNS number for MagneticSpaceGroup()\n                # by converting string to list of ints\n                id = list(map(int, (\n                data.data.get(\"_space_group_magn.number_BNS\").split(\".\"))))\n\n            msg = MagneticSpaceGroup(id)\n\n            if data.data.get(\"_space_group_magn.transform_BNS_Pp_abc\"):\n                if data.data.get(\n                        \"_space_group_magn.transform_BNS_Pp_abc\") != \"a,b,c;0,0,0\":\n                    return NotImplementedError(\n                        \"Non-standard settings not currently supported.\")\n            elif data.data.get(\"_space_group_magn.transform_BNS_Pp\"):\n                return NotImplementedError(\n                    \"Incomplete specification to implement.\")\n\n            magsymmops = msg.symmetry_ops\n\n        if not magsymmops:\n            msg = \"No magnetic symmetry detected, using primitive symmetry.\"\n            warnings.warn(msg)\n            self.errors.append(msg)\n            magsymmops = [MagSymmOp.from_xyzt_string(\"x, y, z, 1\")]\n\n        return magsymmops"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef parse_oxi_states(self, data):\n        try:\n            oxi_states = {\n                data[\"_atom_type_symbol\"][i]:\n                    str2float(data[\"_atom_type_oxidation_number\"][i])\n                for i in range(len(data[\"_atom_type_symbol\"]))}\n            # attempt to strip oxidation state from _atom_type_symbol\n            # in case the label does not contain an oxidation state\n            for i, symbol in enumerate(data[\"_atom_type_symbol\"]):\n                oxi_states[re.sub(r\"\\d?[\\+,\\-]?$\", \"\", symbol)] = \\\n                    str2float(data[\"_atom_type_oxidation_number\"][i])\n\n        except (ValueError, KeyError):\n            oxi_states = None\n        return oxi_states", "response": "Parse oxidation states from data dictionary"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nparse atomic magnetic moments from data dictionary.", "response": "def parse_magmoms(self, data, lattice=None):\n        \"\"\"\n        Parse atomic magnetic moments from data dictionary\n        \"\"\"\n        if lattice is None:\n            raise Exception(\n                'Magmoms given in terms of crystal axes in magCIF spec.')\n        try:\n            magmoms = {\n                data[\"_atom_site_moment_label\"][i]:\n                    np.array(\n                        [str2float(data[\"_atom_site_moment_crystalaxis_x\"][i]),\n                         str2float(data[\"_atom_site_moment_crystalaxis_y\"][i]),\n                         str2float(data[\"_atom_site_moment_crystalaxis_z\"][i])]\n                    )\n                for i in range(len(data[\"_atom_site_moment_label\"]))\n            }\n        except (ValueError, KeyError):\n            return None\n        return magmoms"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _parse_symbol(self, sym):\n        # Common representations for elements/water in cif files\n        # TODO: fix inconsistent handling of water\n        special = {\"Hw\": \"H\", \"Ow\": \"O\", \"Wat\": \"O\",\n                   \"wat\": \"O\", \"OH\": \"\", \"OH2\": \"\", \"NO3\": \"N\"}\n\n        parsed_sym = None\n        # try with special symbols, otherwise check the first two letters,\n        # then the first letter alone. If everything fails try extracting the\n        # first letters.\n        m_sp = re.match(\"|\".join(special.keys()), sym)\n        if m_sp:\n            parsed_sym = special[m_sp.group()]\n        elif Element.is_valid_symbol(sym[:2].title()):\n            parsed_sym = sym[:2].title()\n        elif Element.is_valid_symbol(sym[0].upper()):\n            parsed_sym = sym[0].upper()\n        else:\n            m = re.match(r\"w?[A-Z][a-z]*\", sym)\n            if m:\n                parsed_sym = m.group()\n\n        if parsed_sym is not None and (m_sp or not re.match(r\"{}\\d*\".format(parsed_sym), sym)):\n            msg = \"{} parsed as {}\".format(sym, parsed_sym)\n            warnings.warn(msg)\n            self.errors.append(msg)\n\n        return parsed_sym", "response": "Parse a string with a symbol to extract a string representing an element."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _get_structure(self, data, primitive):\n\n        def get_num_implicit_hydrogens(sym):\n            num_h = {\"Wat\": 2, \"wat\": 2, \"O-H\": 1}\n            return num_h.get(sym[:3], 0)\n\n        lattice = self.get_lattice(data)\n\n        # if magCIF, get magnetic symmetry moments and magmoms\n        # else standard CIF, and use empty magmom dict\n        if self.feature_flags[\"magcif_incommensurate\"]:\n            raise NotImplementedError(\n                \"Incommensurate structures not currently supported.\")\n        elif self.feature_flags[\"magcif\"]:\n            self.symmetry_operations = self.get_magsymops(data)\n            magmoms = self.parse_magmoms(data, lattice=lattice)\n        else:\n            self.symmetry_operations = self.get_symops(data)\n            magmoms = {}\n\n        oxi_states = self.parse_oxi_states(data)\n\n        coord_to_species = OrderedDict()\n        coord_to_magmoms = OrderedDict()\n\n        def get_matching_coord(coord):\n            keys = list(coord_to_species.keys())\n            coords = np.array(keys)\n            for op in self.symmetry_operations:\n                c = op.operate(coord)\n                inds = find_in_coord_list_pbc(coords, c,\n                                              atol=self._site_tolerance)\n                # cant use if inds, because python is dumb and np.array([0]) evaluates\n                # to False\n                if len(inds):\n                    return keys[inds[0]]\n            return False\n\n        for i in range(len(data[\"_atom_site_label\"])):\n            try:\n                # If site type symbol exists, use it. Otherwise, we use the\n                # label.\n                symbol = self._parse_symbol(data[\"_atom_site_type_symbol\"][i])\n                num_h = get_num_implicit_hydrogens(\n                    data[\"_atom_site_type_symbol\"][i])\n            except KeyError:\n                symbol = self._parse_symbol(data[\"_atom_site_label\"][i])\n                num_h = get_num_implicit_hydrogens(data[\"_atom_site_label\"][i])\n            if not symbol:\n                continue\n\n            if oxi_states is not None:\n                o_s = oxi_states.get(symbol, 0)\n                # use _atom_site_type_symbol if possible for oxidation state\n                if \"_atom_site_type_symbol\" in data.data.keys():\n                    oxi_symbol = data[\"_atom_site_type_symbol\"][i]\n                    o_s = oxi_states.get(oxi_symbol, o_s)\n                try:\n                    el = Specie(symbol, o_s)\n                except:\n                    el = DummySpecie(symbol, o_s)\n            else:\n                el = get_el_sp(symbol)\n\n            x = str2float(data[\"_atom_site_fract_x\"][i])\n            y = str2float(data[\"_atom_site_fract_y\"][i])\n            z = str2float(data[\"_atom_site_fract_z\"][i])\n            magmom = magmoms.get(data[\"_atom_site_label\"][i],\n                                 np.array([0, 0, 0]))\n\n            try:\n                occu = str2float(data[\"_atom_site_occupancy\"][i])\n            except (KeyError, ValueError):\n                occu = 1\n\n            if occu > 0:\n                coord = (x, y, z)\n                match = get_matching_coord(coord)\n                comp_d = {el: occu}\n                if num_h > 0:\n                    comp_d[\"H\"] = num_h\n                    self.errors.append(\"Structure has implicit hydrogens defined, \"\n                                       \"parsed structure unlikely to be suitable for use \"\n                                       \"in calculations unless hydrogens added.\")\n                comp = Composition(comp_d)\n                if not match:\n                    coord_to_species[coord] = comp\n                    coord_to_magmoms[coord] = magmom\n                else:\n                    coord_to_species[match] += comp\n                    # disordered magnetic not currently supported\n                    coord_to_magmoms[match] = None\n\n        sum_occu = [sum(c.values()) for c in coord_to_species.values()\n                    if not set(c.elements) == {Element(\"O\"), Element(\"H\")}]\n        if any([o > 1 for o in sum_occu]):\n            msg = \"Some occupancies (%s) sum to > 1! If they are within \" \\\n                    \"the tolerance, they will be rescaled.\" % str(sum_occu)\n            warnings.warn(msg)\n            self.errors.append(msg)\n\n        allspecies = []\n        allcoords = []\n        allmagmoms = []\n        allhydrogens = []\n\n        # check to see if magCIF file is disordered\n        if self.feature_flags[\"magcif\"]:\n            for k, v in coord_to_magmoms.items():\n                if v is None:\n                    # Proposed solution to this is to instead store magnetic\n                    # moments as Specie 'spin' property, instead of site\n                    # property, but this introduces ambiguities for end user\n                    # (such as unintended use of `spin` and Specie will have\n                    # fictious oxidation state).\n                    raise NotImplementedError(\n                        'Disordered magnetic structures not currently supported.')\n\n        if coord_to_species.items():\n            for comp, group in groupby(\n                    sorted(list(coord_to_species.items()), key=lambda x: x[1]),\n                    key=lambda x: x[1]):\n                tmp_coords = [site[0] for site in group]\n                tmp_magmom = [coord_to_magmoms[tmp_coord] for tmp_coord in\n                              tmp_coords]\n\n                if self.feature_flags[\"magcif\"]:\n                    coords, magmoms = self._unique_coords(tmp_coords,\n                                                          magmoms_in=tmp_magmom,\n                                                          lattice=lattice)\n                else:\n                    coords, magmoms = self._unique_coords(tmp_coords)\n\n                if set(comp.elements) == {Element(\"O\"), Element(\"H\")}:\n                    # O with implicit hydrogens\n                    im_h = comp[\"H\"]\n                    species = Composition({\"O\": comp[\"O\"]})\n                else:\n                    im_h = 0\n                    species = comp\n\n                allhydrogens.extend(len(coords) * [im_h])\n                allcoords.extend(coords)\n                allspecies.extend(len(coords) * [species])\n                allmagmoms.extend(magmoms)\n\n            # rescale occupancies if necessary\n            for i, species in enumerate(allspecies):\n                totaloccu = sum(species.values())\n                if 1 < totaloccu <= self._occupancy_tolerance:\n                    allspecies[i] = species / totaloccu\n\n        if allspecies and len(allspecies) == len(allcoords) \\\n                and len(allspecies) == len(allmagmoms):\n            site_properties = dict()\n            if any(allhydrogens):\n                assert len(allhydrogens) == len(allcoords)\n                site_properties[\"implicit_hydrogens\"] = allhydrogens\n\n            if self.feature_flags[\"magcif\"]:\n                site_properties[\"magmom\"] = allmagmoms\n\n            if len(site_properties) == 0:\n                site_properties = None\n\n            struct = Structure(lattice, allspecies, allcoords,\n                               site_properties=site_properties)\n\n            struct = struct.get_sorted_structure()\n\n            if primitive and self.feature_flags['magcif']:\n                struct = struct.get_primitive_structure(use_site_props=True)\n            elif primitive:\n                struct = struct.get_primitive_structure()\n                struct = struct.get_reduced_structure()\n\n            return struct", "response": "Generate structure from part of the cif."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_structures(self, primitive=True):\n        structures = []\n        for d in self._cif.data.values():\n            try:\n                s = self._get_structure(d, primitive)\n                if s:\n                    structures.append(s)\n            except (KeyError, ValueError) as exc:\n                # Warn the user (Errors should never pass silently)\n                # A user reported a problem with cif files produced by Avogadro\n                # in which the atomic coordinates are in Cartesian coords.\n                self.errors.append(str(exc))\n                warnings.warn(str(exc))\n        if self.errors:\n            warnings.warn(\"Issues encountered while parsing CIF:\")\n            for error in self.errors:\n                warnings.warn(error)\n        if len(structures) == 0:\n            raise ValueError(\"Invalid cif file with no structures!\")\n        return structures", "response": "Returns a list of structures in CIF file."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_bibtex_string(self):\n\n        bibtex_keys = {'author': ('_publ_author_name', '_citation_author_name'),\n                       'title': ('_publ_section_title', '_citation_title'),\n                       'journal': ('_journal_name_full', '_journal_name_abbrev',\n                                   '_citation_journal_full', '_citation_journal_abbrev'),\n                       'volume': ('_journal_volume', '_citation_journal_volume'),\n                       'year': ('_journal_year', '_citation_year'),\n                       'number': ('_journal_number', '_citation_number'),\n                       'page_first': ('_journal_page_first', '_citation_page_first'),\n                       'page_last': ('_journal_page_last', '_citation_page_last'),\n                       'doi': ('_journal_DOI', '_citation_DOI')}\n\n        entries = {}\n\n        # TODO: parse '_publ_section_references' when it exists?\n        # TODO: CIF specification supports multiple citations.\n\n        for idx, data in enumerate(self._cif.data.values()):\n\n            # convert to lower-case keys, some cif files inconsistent\n            data = {k.lower(): v for k, v in data.data.items()}\n\n            bibtex_entry = {}\n\n            for field, tags in bibtex_keys.items():\n                for tag in tags:\n                    if tag in data:\n                        if isinstance(data[tag], list):\n                            bibtex_entry[field] = data[tag][0]\n                        else:\n                            bibtex_entry[field] = data[tag]\n\n            # convert to bibtex author format ('and' delimited)\n            if 'author' in bibtex_entry:\n                # separate out semicolon authors\n                if isinstance(bibtex_entry[\"author\"], str):\n                    if \";\" in bibtex_entry[\"author\"]:\n                        bibtex_entry[\"author\"] = bibtex_entry[\"author\"].split(\";\")\n\n                if isinstance(bibtex_entry['author'], list):\n                    bibtex_entry['author'] = ' and '.join(bibtex_entry['author'])\n\n            # convert to bibtex page range format, use empty string if not specified\n            if ('page_first' in bibtex_entry) or ('page_last' in bibtex_entry):\n                bibtex_entry['pages'] = '{0}--{1}'.format(bibtex_entry.get('page_first', ''),\n                                                          bibtex_entry.get('page_last', ''))\n                bibtex_entry.pop('page_first', None)  # and remove page_first, page_list if present\n                bibtex_entry.pop('page_last', None)\n\n\n            # cite keys are given as cif-reference-idx in order they are found\n            entries['cif-reference-{}'.format(idx)] = Entry('article', list(bibtex_entry.items()))\n\n        return BibliographyData(entries).to_string(bib_format='bibtex')", "response": "Get BibTeX string from CIF file."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconverts a list of SlabEntry objects to a dictionary.", "response": "def entry_dict_from_list(all_slab_entries):\n    \"\"\"\n    Converts a list of SlabEntry to an appropriate dictionary. It is\n    assumed that if there is no adsorbate, then it is a clean SlabEntry\n    and that adsorbed SlabEntry has the clean_entry parameter set.\n\n    Args:\n        all_slab_entries (list): List of SlabEntry objects\n\n    Returns:\n        (dict): Dictionary of SlabEntry with the Miller index as the main\n            key to a dictionary with a clean SlabEntry as the key to a\n            list of adsorbed SlabEntry.\n    \"\"\"\n\n    entry_dict = {}\n\n    for entry in all_slab_entries:\n        hkl = tuple(entry.miller_index)\n        if hkl not in entry_dict.keys():\n            entry_dict[hkl] = {}\n        if entry.clean_entry:\n            clean = entry.clean_entry\n        else:\n            clean = entry\n        if clean not in entry_dict[hkl].keys():\n            entry_dict[hkl][clean] = []\n        if entry.adsorbates:\n            entry_dict[hkl][clean].append(entry)\n\n    return entry_dict"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nusing dot product of numpy array to subchemical potentials into the surface grand potential. This is much faster than using the subs function in sympy.", "response": "def sub_chempots(gamma_dict, chempots):\n    \"\"\"\n    Uses dot product of numpy array to sub chemical potentials\n        into the surface grand potential. This is much faster\n        than using the subs function in sympy.\n    Args:\n        gamma_dict (dict): Surface grand potential equation\n            as a coefficient dictionary\n        chempots (dict): Dictionary assigning each chemical\n            potential (key) in gamma a value\n    Returns:\n        Surface energy as a float\n    \"\"\"\n\n    coeffs = [gamma_dict[k] for k in gamma_dict.keys()]\n    chempot_vals = []\n    for k in gamma_dict.keys():\n        if k not in chempots.keys():\n            chempot_vals.append(k)\n        elif k == 1:\n            chempot_vals.append(1)\n        else:\n            chempot_vals.append(chempots[k])\n\n    return np.dot(coeffs, chempot_vals)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef as_dict(self):\n\n        d = {\"@module\": self.__class__.__module__,\n             \"@class\": self.__class__.__name__}\n        d[\"structure\"] = self.structure\n        d[\"energy\"] = self.energy\n        d[\"miller_index\"] = self.miller_index\n        d[\"label\"] = self.label\n        d[\"coverage\"] = self.coverage\n        d[\"adsorbates\"] = self.adsorbates\n        d[\"clean_entry\"] = self.clean_entry\n\n        return d", "response": "Returns a dict which contains Slab Entry data."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef gibbs_binding_energy(self, eads=False):\n\n        n = self.get_unit_primitive_area\n        Nads = self.Nads_in_slab\n\n        BE = (self.energy - n * self.clean_entry.energy) / Nads - \\\n             sum([ads.energy_per_atom for ads in self.adsorbates])\n        return BE * Nads if eads else BE", "response": "Calculates the adsorption energy or Gibbs s binding energy of an adsorbate on a surface."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncalculate the surface energy of a bulk entry.", "response": "def surface_energy(self, ucell_entry, ref_entries=None):\n        \"\"\"\n        Calculates the surface energy of this SlabEntry.\n        Args:\n            ucell_entry (entry): An entry object for the bulk\n            ref_entries (list: [entry]): A list of entries for each type\n                of element to be used as a reservoir for nonstoichiometric\n                systems. The length of this list MUST be n-1 where n is the\n                number of different elements in the bulk entry. The chempot\n                of the element ref_entry that is not in the list will be\n                treated as a variable.\n\n        Returns (Add (Sympy class)): Surface energy\n        \"\"\"\n\n        # Set up\n        ref_entries = [] if not ref_entries else ref_entries\n\n        # Check if appropriate ref_entries are present if the slab is non-stoichiometric\n        # TODO: There should be a way to identify which specific species are\n        # non-stoichiometric relative to the others in systems with more than 2 species\n        slab_comp = self.composition.as_dict()\n        ucell_entry_comp = ucell_entry.composition.reduced_composition.as_dict()\n        slab_clean_comp = Composition({el: slab_comp[el] for el in ucell_entry_comp.keys()})\n        if slab_clean_comp.reduced_composition != ucell_entry.composition.reduced_composition:\n            list_els = [list(entry.composition.as_dict().keys())[0] for entry in ref_entries]\n            if not any([el in list_els for el in ucell_entry.composition.as_dict().keys()]):\n                warnings.warn(\"Elemental references missing for the non-dopant species.\")\n\n        gamma = (Symbol(\"E_surf\") - Symbol(\"Ebulk\")) / (2 * Symbol(\"A\"))\n        ucell_comp = ucell_entry.composition\n        ucell_reduced_comp = ucell_comp.reduced_composition\n        ref_entries_dict = {str(list(ref.composition.as_dict().keys())[0]): \\\n                                ref for ref in ref_entries}\n        ref_entries_dict.update(self.ads_entries_dict)\n\n        # Calculate Gibbs free energy of the bulk per unit formula\n        gbulk = ucell_entry.energy / \\\n                ucell_comp.get_integer_formula_and_factor()[1]\n\n        # First we get the contribution to the bulk energy\n        # from each element with an existing ref_entry.\n        bulk_energy, gbulk_eqn = 0, 0\n        for el, ref in ref_entries_dict.items():\n            N, delu = self.composition.as_dict()[el], Symbol(\"delu_\" + str(el))\n            if el in ucell_comp.as_dict().keys():\n                gbulk_eqn += ucell_reduced_comp[el] * (delu + ref.energy_per_atom)\n            bulk_energy += N * (Symbol(\"delu_\" + el) + ref.energy_per_atom)\n\n        # Next, we add the contribution to the bulk energy from\n        # the variable element (the element without a ref_entry),\n        # as a function of the other elements\n        for ref_el in ucell_comp.as_dict().keys():\n            if str(ref_el) not in ref_entries_dict.keys():\n                break\n        refEperA = (gbulk - gbulk_eqn) / ucell_reduced_comp.as_dict()[ref_el]\n        bulk_energy += self.composition.as_dict()[ref_el] * refEperA\n        se = gamma.subs({Symbol(\"E_surf\"): self.energy, Symbol(\"Ebulk\"): bulk_energy,\n                         Symbol(\"A\"): self.surface_area})\n\n\n        return float(se) if type(se).__name__ == \"Float\" else se"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_unit_primitive_area(self):\n\n        A_ads = self.surface_area\n        A_clean = self.clean_entry.surface_area\n        n = (A_ads / A_clean)\n        return n", "response": "Returns the unit area of the primitive slab system."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_monolayer(self):\n\n        unit_a = self.get_unit_primitive_area\n        Nsurfs = self.Nsurfs_ads_in_slab\n        Nads = self.Nads_in_slab\n        return Nads / (unit_a * Nsurfs)", "response": "Returns the monolayer of the object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef Nads_in_slab(self):\n        return sum([self.composition.as_dict()[a] for a \\\n                    in self.ads_entries_dict.keys()])", "response": "Returns the total number of adsorbates in the slab on BOTH sides"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef Nsurfs_ads_in_slab(self):\n\n        struct = self.structure\n        weights = [s.species.weight for s in struct]\n        center_of_mass = np.average(struct.frac_coords,\n                                    weights=weights, axis=0)\n\n        Nsurfs = 0\n        # Are there adsorbates on top surface?\n        if any([site.species_string in self.ads_entries_dict.keys() for \\\n                site in struct if site.frac_coords[2] > center_of_mass[2]]):\n            Nsurfs += 1\n        # Are there adsorbates on bottom surface?\n        if any([site.species_string in self.ads_entries_dict.keys() for \\\n                site in struct if site.frac_coords[2] < center_of_mass[2]]):\n            Nsurfs += 1\n\n        return Nsurfs", "response": "Returns the TOTAL number of adsorbed surfaces in the slab"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef from_dict(cls, d):\n\n        structure = SlabEntry.from_dict(d[\"structure\"])\n        energy = SlabEntry.from_dict(d[\"energy\"])\n        miller_index = d[\"miller_index\"]\n        label = d[\"label\"]\n        coverage = d[\"coverage\"]\n        adsorbates = d[\"adsorbates\"]\n        clean_entry = d[\"clean_entry\"] = self.clean_entry\n\n        return SlabEntry(structure, energy, miller_index, label=label,\n                         coverage=coverage, adsorbates=adsorbates,\n                         clean_entry=clean_entry)", "response": "Returns a SlabEntry by reading in a dictionary containing information about the entry."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a slab with the adsorbates removed", "response": "def cleaned_up_slab(self):\n        \"\"\"\n        Returns a slab with the adsorbates removed\n        \"\"\"\n        ads_strs = list(self.ads_entries_dict.keys())\n        cleaned = self.structure.copy()\n        cleaned.remove_species(ads_strs)\n        return cleaned"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a label for this particular slab based on composition coverage and Miller index.", "response": "def create_slab_label(self):\n        \"\"\"\n        Returns a label (str) for this particular slab based\n            on composition, coverage and Miller index.\n        \"\"\"\n\n        if \"label\" in self.data.keys():\n            return self.data[\"label\"]\n\n        label = str(self.miller_index)\n        ads_strs = list(self.ads_entries_dict.keys())\n\n        cleaned = self.cleaned_up_slab\n        label += \" %s\" % (cleaned.composition.reduced_composition)\n\n        if self.adsorbates:\n            for ads in ads_strs:\n                label += r\"+%s\" % (ads)\n            label += r\", %.3f ML\" % (self.get_monolayer)\n        return label"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef from_computed_structure_entry(entry, miller_index, label=None,\n                                      adsorbates=None, clean_entry=None, **kwargs):\n        \"\"\"\n        Returns SlabEntry from a ComputedStructureEntry\n        \"\"\"\n        return SlabEntry(entry.structure, entry.energy, miller_index, label=label,\n                         adsorbates=adsorbates, clean_entry=clean_entry, **kwargs)", "response": "Returns a SlabEntry object from a ComputedStructureEntry object"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the most stable entry corresponding to a particular chemical potential at a specific chemical potential.", "response": "def get_stable_entry_at_u(self, miller_index, delu_dict=None, delu_default=0,\n                              no_doped=False, no_clean=False):\n        \"\"\"\n        Returns the entry corresponding to the most stable slab for a particular\n            facet at a specific chempot. We assume that surface energy is constant\n            so all free variables must be set with delu_dict, otherwise they are\n            assumed to be equal to delu_default.\n\n        Args:\n            miller_index ((h,k,l)): The facet to find the most stable slab in\n            delu_dict (Dict): Dictionary of the chemical potentials to be set as\n                constant. Note the key should be a sympy Symbol object of the\n                format: Symbol(\"delu_el\") where el is the name of the element.\n            delu_default (float): Default value for all unset chemical potentials\n            no_doped (bool): Consider stability of clean slabs only.\n            no_clean (bool): Consider stability of doped slabs only.\n\n        Returns:\n            SlabEntry, surface_energy (float)\n        \"\"\"\n\n        all_delu_dict = self.set_all_variables(delu_dict, delu_default)\n        def get_coeffs(e):\n            coeffs = []\n            for du in all_delu_dict.keys():\n                if type(self.as_coeffs_dict[e]).__name__ == 'float':\n                    coeffs.append(self.as_coeffs_dict[e])\n                elif du in self.as_coeffs_dict[e].keys():\n                    coeffs.append(self.as_coeffs_dict[e][du])\n                else:\n                    coeffs.append(0)\n            return np.array(coeffs)\n\n        all_entries, all_coeffs = [], []\n        for entry in self.all_slab_entries[miller_index].keys():\n            if not no_clean:\n                all_entries.append(entry)\n                all_coeffs.append(get_coeffs(entry))\n            if not no_doped:\n                for ads_entry in self.all_slab_entries[miller_index][entry]:\n                    all_entries.append(ads_entry)\n                    all_coeffs.append(get_coeffs(ads_entry))\n\n        du_vals = np.array(list(all_delu_dict.values()))\n        all_gamma = list(np.dot(all_coeffs, du_vals.T))\n\n        return all_entries[all_gamma.index(min(all_gamma))], float(min(all_gamma))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef wulff_from_chempot(self, delu_dict=None, delu_default=0, symprec=1e-5,\n                           no_clean=False, no_doped=False):\n        \"\"\"\n        Method to get the Wulff shape at a specific chemical potential.\n\n        Args:\n            delu_dict (Dict): Dictionary of the chemical potentials to be set as\n                constant. Note the key should be a sympy Symbol object of the\n                format: Symbol(\"delu_el\") where el is the name of the element.\n            delu_default (float): Default value for all unset chemical potentials\n            symprec (float): See WulffShape.\n            no_doped (bool): Consider stability of clean slabs only.\n            no_clean (bool): Consider stability of doped slabs only.\n\n        Returns:\n            (WulffShape): The WulffShape at u_ref and u_ads.\n        \"\"\"\n\n        latt = SpacegroupAnalyzer(self.ucell_entry.structure). \\\n            get_conventional_standard_structure().lattice\n\n        miller_list = self.all_slab_entries.keys()\n        e_surf_list = []\n        for hkl in miller_list:\n            # For all configurations, calculate surface energy as a\n            # function of u. Use the lowest surface energy (corresponds\n            # to the most stable slab termination at that particular u)\n            gamma = self.get_stable_entry_at_u(hkl, delu_dict=delu_dict,\n                                               delu_default=delu_default,\n                                               no_clean=no_clean,\n                                               no_doped=no_doped)[1]\n            e_surf_list.append(gamma)\n\n        return WulffShape(latt, miller_list, e_surf_list, symprec=symprec)", "response": "Method to get the Wulff shape at a specific chemical potential."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nplot the area contribution of each facet vs chemical potential.", "response": "def area_frac_vs_chempot_plot(self, ref_delu, chempot_range, delu_dict=None,\n                                  delu_default=0, increments=10, no_clean=False, no_doped=False):\n        \"\"\"\n        1D plot. Plots the change in the area contribution\n        of each facet as a function of chemical potential.\n\n        Args:\n            ref_delu (sympy Symbol): The free variable chempot with the format:\n                Symbol(\"delu_el\") where el is the name of the element.\n            chempot_range (list): Min/max range of chemical potential to plot along\n            delu_dict (Dict): Dictionary of the chemical potentials to be set as\n                constant. Note the key should be a sympy Symbol object of the\n                format: Symbol(\"delu_el\") where el is the name of the element.\n            delu_default (float): Default value for all unset chemical potentials\n            increments (int): Number of data points between min/max or point\n                of intersection. Defaults to 10 points.\n\n        Returns:\n            (Pylab): Plot of area frac on the Wulff shape\n                for each facet vs chemical potential.\n        \"\"\"\n\n        delu_dict = delu_dict if delu_dict else {}\n        chempot_range = sorted(chempot_range)\n        all_chempots = np.linspace(min(chempot_range), max(chempot_range),\n                                   increments)\n\n        # initialize a dictionary of lists of fractional areas for each hkl\n        hkl_area_dict = {}\n        for hkl in self.all_slab_entries.keys():\n            hkl_area_dict[hkl] = []\n\n        # Get plot points for each Miller index\n        for u in all_chempots:\n            delu_dict[ref_delu] = u\n            wulffshape = self.wulff_from_chempot(delu_dict=delu_dict, no_clean=no_clean,\n                                                 no_doped=no_doped, delu_default=delu_default)\n\n            for hkl in wulffshape.area_fraction_dict.keys():\n                hkl_area_dict[hkl].append(wulffshape.area_fraction_dict[hkl])\n\n        # Plot the area fraction vs chemical potential for each facet\n        plt = pretty_plot(width=8, height=7)\n        axes = plt.gca()\n\n        for hkl in self.all_slab_entries.keys():\n            clean_entry = list(self.all_slab_entries[hkl].keys())[0]\n            # Ignore any facets that never show up on the\n            # Wulff shape regardless of chemical potential\n            if all([a == 0 for a in hkl_area_dict[hkl]]):\n                continue\n            else:\n                plt.plot(all_chempots, hkl_area_dict[hkl],\n                         '--', color=self.color_dict[clean_entry],\n                         label=str(hkl))\n\n        # Make the figure look nice\n        plt.ylabel(r\"Fractional area $A^{Wulff}_{hkl}/A^{Wulff}$\")\n        self.chempot_plot_addons(plt, chempot_range, str(ref_delu).split(\"_\")[1],\n                                 axes, rect=[-0.0, 0, 0.95, 1], pad=5, ylim=[0, 1])\n\n        return plt"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_surface_equilibrium(self, slab_entries, delu_dict=None):\n\n        \"\"\"\n        Takes in a list of SlabEntries and calculates the chemical potentials\n            at which all slabs in the list coexists simultaneously. Useful for\n            building surface phase diagrams. Note that to solve for x equations\n            (x slab_entries), there must be x free variables (chemical potentials).\n            Adjust delu_dict as need be to get the correct number of free variables.\n        Args:\n            slab_entries (array): The coefficients of the first equation\n            delu_dict (Dict): Dictionary of the chemical potentials to be set as\n                constant. Note the key should be a sympy Symbol object of the\n                format: Symbol(\"delu_el\") where el is the name of the element.\n\n        Returns:\n            (array): Array containing a solution to x equations with x\n                variables (x-1 chemical potential and 1 surface energy)\n        \"\"\"\n        # Generate all possible coefficients\n        all_parameters = []\n        all_eqns = []\n        for slab_entry in slab_entries:\n            se = self.surfe_dict[slab_entry]\n\n            # remove the free chempots we wish to keep constant and\n            # set the equation to 0 (subtract gamma from both sides)\n            if type(se).__name__ == \"float\":\n                all_eqns.append(se - Symbol(\"gamma\"))\n            else:\n\n                se = sub_chempots(se, delu_dict) if delu_dict else se\n                all_eqns.append(se - Symbol(\"gamma\"))\n                all_parameters.extend([p for p in list(se.free_symbols)\n                                       if p not in all_parameters])\n\n        all_parameters.append(Symbol(\"gamma\"))\n        # Now solve the system of linear eqns to find the chempot\n        # where the slabs are at equilibrium with each other\n\n        soln = linsolve(all_eqns, all_parameters)\n        if not soln:\n            warnings.warn(\"No solution\")\n            return soln\n        return {p: list(soln)[0][i] for i, p in enumerate(all_parameters)}", "response": "This function calculates the chemical potentials at which all slabs in the list coexists simultaneously."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef stable_u_range_dict(self, chempot_range, ref_delu, no_doped=True,\n                            no_clean=False, delu_dict={}, miller_index=(),\n                            dmu_at_0=False, return_se_dict=False):\n        \"\"\"\n        Creates a dictionary where each entry is a key pointing to a\n        chemical potential range where the surface of that entry is stable.\n        Does so by enumerating through all possible solutions (intersect)\n        for surface energies of a specific facet.\n\n        Args:\n            chempot_range ([max_chempot, min_chempot]): Range to consider the\n                stability of the slabs.\n            ref_delu (sympy Symbol): The range stability of each slab is based\n                on the chempot range of this chempot. Should be a sympy Symbol\n                object of the format: Symbol(\"delu_el\") where el is the name of\n                the element\n            no_doped (bool): Consider stability of clean slabs only.\n            no_clean (bool): Consider stability of doped slabs only.\n            delu_dict (Dict): Dictionary of the chemical potentials to be set as\n                constant. Note the key should be a sympy Symbol object of the\n                format: Symbol(\"delu_el\") where el is the name of the element.\n            miller_index (list): Miller index for a specific facet to get a\n                dictionary for.\n            dmu_at_0 (bool): If True, if the surface energies corresponding to\n                the chemical potential range is between a negative and positive\n                value, the value is a list of three chemical potentials with the\n                one in the center corresponding a surface energy of 0. Uselful\n                in identifying unphysical ranges of surface energies and their\n                chemical potential range.\n            return_se_dict (bool): Whether or not to return the corresponding\n                dictionary of surface energies\n        \"\"\"\n\n        chempot_range = sorted(chempot_range)\n        stable_urange_dict, se_dict = {}, {}\n\n        # Get all entries for a specific facet\n        for hkl in self.all_slab_entries.keys():\n            entries_in_hkl = []\n            # Skip this facet if this is not the facet we want\n            if miller_index and hkl != tuple(miller_index):\n                continue\n            if not no_clean:\n                entries_in_hkl.extend([clean for clean in self.all_slab_entries[hkl]])\n            if not no_doped:\n                for entry in self.all_slab_entries[hkl]:\n                    entries_in_hkl.extend([ads_entry for ads_entry in\n                                           self.all_slab_entries[hkl][entry]])\n\n            for entry in entries_in_hkl:\n                stable_urange_dict[entry] = []\n                se_dict[entry] = []\n            # if there is only one entry for this facet, then just give it the\n            # default urange, you can't make combinations with just 1 item\n            if len(entries_in_hkl) == 1:\n                stable_urange_dict[entries_in_hkl[0]] = chempot_range\n                u1, u2 = delu_dict.copy(), delu_dict.copy()\n                u1[ref_delu], u2[ref_delu] = chempot_range[0], chempot_range[1]\n                se = self.as_coeffs_dict[entries_in_hkl[0]]\n                se_dict[entries_in_hkl[0]] = [sub_chempots(se, u1), sub_chempots(se, u2)]\n                continue\n\n            for pair in itertools.combinations(entries_in_hkl, 2):\n                # I'm assuming ref_delu was not set in delu_dict,\n                # so the solution should be for ref_delu\n                solution = self.get_surface_equilibrium(pair, delu_dict=delu_dict)\n\n                # Check if this solution is stable\n                if not solution:\n                    continue\n                new_delu_dict = delu_dict.copy()\n                new_delu_dict[ref_delu] = solution[ref_delu]\n                stable_entry, gamma = self.get_stable_entry_at_u(hkl, new_delu_dict,\n                                                                 no_doped=no_doped,\n                                                                 no_clean=no_clean)\n                if stable_entry not in pair:\n                    continue\n\n                # Now check if the solution is within the chempot range\n                if not (chempot_range[0] <= solution[ref_delu] <= chempot_range[1]):\n                    continue\n\n                for entry in pair:\n                    stable_urange_dict[entry].append(solution[ref_delu])\n                    se_dict[entry].append(gamma)\n\n            # Now check if all entries have 2 chempot values. If only\n            # one, we need to set the other value as either the upper\n            # limit or lower limit of the user provided chempot_range\n            new_delu_dict = delu_dict.copy()\n            for u in chempot_range:\n                new_delu_dict[ref_delu] = u\n                entry, gamma = self.get_stable_entry_at_u(hkl, delu_dict=new_delu_dict,\n                                                          no_doped=no_doped,\n                                                          no_clean=no_clean)\n                stable_urange_dict[entry].append(u)\n                se_dict[entry].append(gamma)\n\n        if dmu_at_0:\n            for entry in se_dict.keys():\n                # if se are of opposite sign, determine chempot when se=0.\n                # Useful for finding a chempot range where se is unphysical\n                if not stable_urange_dict[entry]:\n                    continue\n                if se_dict[entry][0] * se_dict[entry][1] < 0:\n                    # solve for gamma=0\n                    se = self.as_coeffs_dict[entry]\n                    se_dict[entry].append(0)\n                    stable_urange_dict[entry].append(solve(sub_chempots(se, delu_dict),\n                                                           ref_delu)[0])\n\n        # sort the chempot ranges for each facet\n        for entry in stable_urange_dict.keys():\n            se_dict[entry] = [se for i, se in sorted(zip(stable_urange_dict[entry],\n                                                         se_dict[entry]))]\n            stable_urange_dict[entry] = sorted(stable_urange_dict[entry])\n\n        if return_se_dict:\n            return stable_urange_dict, se_dict\n        else:\n            return stable_urange_dict", "response": "Creates a dictionary that associates the values of the chemical potentials in the chemical potential range with the corresponding surface energies."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef color_palette_dict(self, alpha=0.35):\n\n        color_dict = {}\n        for hkl in self.all_slab_entries.keys():\n            rgb_indices = [0, 1, 2]\n            color = [0, 0, 0, 1]\n            random.shuffle(rgb_indices)\n            for i, ind in enumerate(rgb_indices):\n                if i == 2:\n                    break\n                color[ind] = np.random.uniform(0, 1)\n\n            # Get the clean (solid) colors first\n            clean_list = np.linspace(0, 1, len(self.all_slab_entries[hkl]))\n            for i, clean in enumerate(self.all_slab_entries[hkl].keys()):\n                c = copy.copy(color)\n                c[rgb_indices[2]] = clean_list[i]\n                color_dict[clean] = c\n\n                # Now get the adsorbed (transparent) colors\n                for ads_entry in self.all_slab_entries[hkl][clean]:\n                    c_ads = copy.copy(c)\n                    c_ads[3] = alpha\n                    color_dict[ads_entry] = c_ads\n\n        return color_dict", "response": "Function to assign each facet a unique color to a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef chempot_vs_gamma_plot_one(self, plt, entry, ref_delu, chempot_range,\n                                  delu_dict={}, delu_default=0, label='', JPERM2=False):\n        \"\"\"\n        Helper function to  help plot the surface energy of a\n        single SlabEntry as a function of chemical potential.\n\n        Args:\n            plt (Plot): A plot.\n            entry (SlabEntry): Entry of the slab whose surface energy we want\n                to plot\n            ref_delu (sympy Symbol): The range stability of each slab is based\n                on the chempot range of this chempot. Should be a sympy Symbol\n                object of the format: Symbol(\"delu_el\") where el is the name of\n                the element\n            chempot_range ([max_chempot, min_chempot]): Range to consider the\n                stability of the slabs.\n            delu_dict (Dict): Dictionary of the chemical potentials to be set as\n                constant. Note the key should be a sympy Symbol object of the\n                format: Symbol(\"delu_el\") where el is the name of the element.\n            delu_default (float): Default value for all unset chemical potentials\n            label (str): Label of the slab for the legend.\n            JPERM2 (bool): Whether to plot surface energy in /m^2 (True) or\n                eV/A^2 (False)\n\n        Returns:\n            (Plot): Plot of surface energy vs chemical potential for one entry.\n        \"\"\"\n\n        chempot_range = sorted(chempot_range)\n\n        # use dashed lines for slabs that are not stoichiometric\n        # wrt bulk. Label with formula if nonstoichiometric\n        ucell_comp = self.ucell_entry.composition.reduced_composition\n        if entry.adsorbates:\n            s = entry.cleaned_up_slab\n            clean_comp = s.composition.reduced_composition\n        else:\n            clean_comp = entry.composition.reduced_composition\n\n\n        mark = '--' if ucell_comp != clean_comp else '-'\n\n        delu_dict = self.set_all_variables(delu_dict, delu_default)\n        delu_dict[ref_delu] = chempot_range[0]\n        gamma_min = self.as_coeffs_dict[entry]\n        gamma_min = gamma_min if type(gamma_min).__name__ == \\\n                                 \"float\" else sub_chempots(gamma_min, delu_dict)\n        delu_dict[ref_delu] = chempot_range[1]\n        gamma_max = self.as_coeffs_dict[entry]\n        gamma_max = gamma_max if type(gamma_max).__name__ == \\\n                                 \"float\" else sub_chempots(gamma_max, delu_dict)\n        gamma_range = [gamma_min, gamma_max]\n\n        se_range = np.array(gamma_range) * EV_PER_ANG2_TO_JOULES_PER_M2 \\\n            if JPERM2 else gamma_range\n\n        mark = entry.mark if entry.mark else mark\n        c = entry.color if entry.color else self.color_dict[entry]\n        plt.plot(chempot_range, se_range, mark, color=c, label=label)\n\n        return plt", "response": "This function will help plot the surface energy vs the chemical potential of one entry."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nplots the surface energy of each element in the chemical potential.", "response": "def chempot_vs_gamma(self, ref_delu, chempot_range, miller_index=(),\n                         delu_dict={}, delu_default=0, JPERM2=False,\n                         show_unstable=False, ylim=[], plt=None,\n                         no_clean=False, no_doped=False,\n                         use_entry_labels=False, no_label=False):\n        \"\"\"\n        Plots the surface energy as a function of chemical potential.\n            Each facet will be associated with its own distinct colors.\n            Dashed lines will represent stoichiometries different from that\n            of the mpid's compound. Transparent lines indicates adsorption.\n\n        Args:\n            ref_delu (sympy Symbol): The range stability of each slab is based\n                on the chempot range of this chempot. Should be a sympy Symbol\n                object of the format: Symbol(\"delu_el\") where el is the name of\n                the element\n            chempot_range ([max_chempot, min_chempot]): Range to consider the\n                stability of the slabs.\n            miller_index (list): Miller index for a specific facet to get a\n                dictionary for.\n            delu_dict (Dict): Dictionary of the chemical potentials to be set as\n                constant. Note the key should be a sympy Symbol object of the\n                format: Symbol(\"delu_el\") where el is the name of the element.\n            delu_default (float): Default value for all unset chemical potentials\n            JPERM2 (bool): Whether to plot surface energy in /m^2 (True) or\n                eV/A^2 (False)\n            show_unstable (bool): Whether or not to show parts of the surface\n                energy plot outside the region of stability.\n            ylim ([ymax, ymin]): Range of y axis\n            no_doped (bool): Whether to plot for the clean slabs only.\n            no_clean (bool): Whether to plot for the doped slabs only.\n            use_entry_labels (bool): If True, will label each slab configuration\n                according to their given label in the SlabEntry object.\n            no_label (bool): Option to turn off labels.\n\n        Returns:\n            (Plot): Plot of surface energy vs chempot for all entries.\n        \"\"\"\n\n        chempot_range = sorted(chempot_range)\n\n        plt = pretty_plot(width=8, height=7) if not plt else plt\n        axes = plt.gca()\n\n        for hkl in self.all_slab_entries.keys():\n            if miller_index and hkl != tuple(miller_index):\n                continue\n            # Get the chempot range of each surface if we only\n            # want to show the region where each slab is stable\n            if not show_unstable:\n                stable_u_range_dict = self.stable_u_range_dict(chempot_range, ref_delu,\n                                                               no_doped=no_doped,\n                                                               delu_dict=delu_dict,\n                                                               miller_index=hkl)\n\n            already_labelled = []\n            label = ''\n            for clean_entry in self.all_slab_entries[hkl]:\n\n                urange = stable_u_range_dict[clean_entry] if \\\n                    not show_unstable else chempot_range\n                # Don't plot if the slab is unstable, plot if it is.\n                if urange != []:\n\n                    label = clean_entry.label\n                    if label in already_labelled:\n                        label = None\n                    else:\n                        already_labelled.append(label)\n                    if not no_clean:\n                        if use_entry_labels:\n                            label = clean_entry.label\n                        if no_label:\n                            label = \"\"\n                        plt = self.chempot_vs_gamma_plot_one(plt, clean_entry, ref_delu,\n                                                             urange, delu_dict=delu_dict,\n                                                             delu_default=delu_default,\n                                                             label=label, JPERM2=JPERM2)\n                if not no_doped:\n                    for ads_entry in self.all_slab_entries[hkl][clean_entry]:\n                        # Plot the adsorbed slabs\n                        # Generate a label for the type of slab\n                        urange = stable_u_range_dict[ads_entry] \\\n                            if not show_unstable else chempot_range\n                        if urange != []:\n                            if use_entry_labels:\n                                label = ads_entry.label\n                            if no_label:\n                                label = \"\"\n                            plt = self.chempot_vs_gamma_plot_one(plt, ads_entry,\n                                                                 ref_delu, urange,\n                                                                 delu_dict=delu_dict,\n                                                                 delu_default=delu_default,\n                                                                 label=label,\n                                                                 JPERM2=JPERM2)\n\n        # Make the figure look nice\n        plt.ylabel(r\"Surface energy (J/$m^{2}$)\") if JPERM2 \\\n            else plt.ylabel(r\"Surface energy (eV/$\\AA^{2}$)\")\n        plt = self.chempot_plot_addons(plt, chempot_range, str(ref_delu).split(\"_\")[1],\n                                       axes, ylim=ylim)\n\n        return plt"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nplotting the binding energy vs monolayer for all facets.", "response": "def monolayer_vs_BE(self, plot_eads=False):\n        \"\"\"\n        Plots the binding energy energy as a function of monolayers (ML), i.e.\n            the fractional area adsorbate density for all facets. For each\n            facet at a specific monlayer, only plot the lowest binding energy.\n\n        Args:\n            plot_eads (bool): Option to plot the adsorption energy (binding\n                 energy multiplied by number of adsorbates) instead.\n\n        Returns:\n            (Plot): Plot of binding energy vs monolayer for all facets.\n        \"\"\"\n\n        plt = pretty_plot(width=8, height=7)\n        for hkl in self.all_slab_entries.keys():\n            ml_be_dict = {}\n            for clean_entry in self.all_slab_entries[hkl].keys():\n                if self.all_slab_entries[hkl][clean_entry]:\n                    for ads_entry in self.all_slab_entries[hkl][clean_entry]:\n                        if ads_entry.get_monolayer not in ml_be_dict.keys():\n                            ml_be_dict[ads_entry.get_monolayer] = 1000\n                        be = ads_entry.gibbs_binding_energy(eads=plot_eads)\n                        if be < ml_be_dict[ads_entry.get_monolayer]:\n                            ml_be_dict[ads_entry.get_monolayer] = be\n            # sort the binding energies and monolayers\n            # in order to properly draw a line plot\n            vals = sorted(ml_be_dict.items())\n            monolayers, BEs = zip(*vals)\n            plt.plot(monolayers, BEs, '-o',\n                     c=self.color_dict[clean_entry], label=hkl)\n\n        adsorbates = tuple(ads_entry.ads_entries_dict.keys())\n        plt.xlabel(\" %s\" * len(adsorbates) % adsorbates + \" Coverage (ML)\")\n        plt.ylabel(\"Adsorption Energy (eV)\") if plot_eads \\\n            else plt.ylabel(\"Binding Energy (eV)\")\n        plt.legend()\n        plt.tight_layout()\n\n        return plt"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef BE_vs_clean_SE(self, delu_dict, delu_default=0, plot_eads=False,\n                       annotate_monolayer=True, JPERM2=False):\n        \"\"\"\n        For each facet, plot the clean surface energy against the most\n            stable binding energy.\n        Args:\n            delu_dict (Dict): Dictionary of the chemical potentials to be set as\n                constant. Note the key should be a sympy Symbol object of the\n                format: Symbol(\"delu_el\") where el is the name of the element.\n            delu_default (float): Default value for all unset chemical potentials\n            plot_eads (bool): Option to plot the adsorption energy (binding\n                energy multiplied by number of adsorbates) instead.\n            annotate_monolayer (bool): Whether or not to label each data point\n                with its monolayer (adsorbate density per unit primiitve area)\n            JPERM2 (bool): Whether to plot surface energy in /m^2 (True) or\n                eV/A^2 (False)\n\n        Returns:\n            (Plot): Plot of clean surface energy vs binding energy for\n                all facets.\n        \"\"\"\n\n        plt = pretty_plot(width=8, height=7)\n        for hkl in self.all_slab_entries.keys():\n            for clean_entry in self.all_slab_entries[hkl].keys():\n                all_delu_dict = self.set_all_variables(delu_dict, delu_default)\n                if self.all_slab_entries[hkl][clean_entry]:\n                    clean_se = self.as_coeffs_dict[clean_entry]\n                    se = sub_chempots(clean_se, all_delu_dict)\n                    for ads_entry in self.all_slab_entries[hkl][clean_entry]:\n                        ml = ads_entry.get_monolayer\n                        be = ads_entry.gibbs_binding_energy(eads=plot_eads)\n\n                        # Now plot the surface energy vs binding energy\n                        plt.scatter(se, be)\n                        if annotate_monolayer:\n                            plt.annotate(\"%.2f\" % (ml), xy=[se, be],\n                                         xytext=[se, be])\n\n        plt.xlabel(r\"Surface energy ($J/m^2$)\") if JPERM2 \\\n            else plt.xlabel(r\"Surface energy ($eV/\\AA^2$)\")\n        plt.ylabel(\"Adsorption Energy (eV)\") if plot_eads \\\n            else plt.ylabel(\"Binding Energy (eV)\")\n        plt.tight_layout()\n        plt.xticks(rotation=60)\n\n        return plt", "response": "Plots the clean surface energy vs the stable binding energy for each facet."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadapt from the get_chempot_range_map() method in the PhaseDiagram class. Plot the chemical potential range map based on surface energy stability. Currently works only for 2-component PDs. At the moment uses a brute force method by enumerating through the range of the first element chempot with a specified increment and determines the chempot rangeo fht e second element for each SlabEntry. Future implementation will determine the chempot range map first by solving systems of equations up to 3 instead of 2. Args: elements (list): Sequence of elements to be considered as independent variables. E.g., if you want to show the stability ranges of all Li-Co-O phases wrt to duLi and duO, you will supply [Element(\"Li\"), Element(\"O\")] miller_index ([h, k, l]): Miller index of the surface we are interested in ranges ([[range1], [range2]]): List of chempot ranges (max and min values) for the first and second element. incr (int): Number of points to sample along the range of the first chempot no_doped (bool): Whether or not to include doped systems. no_clean (bool): Whether or not to include clean systems. delu_dict (Dict): Dictionary of the chemical potentials to be set as constant. Note the key should be a sympy Symbol object of the format: Symbol(\"delu_el\") where el is the name of the element. annotate (bool): Whether to annotate each \"phase\" with the label of the entry. If no label, uses the reduced formula show_unphyiscal_only (bool): Whether to only show the shaded region where surface energy is negative. Useful for drawing other chempot range maps.", "response": "def surface_chempot_range_map(self, elements, miller_index, ranges,\n                                  incr=50, no_doped=False, no_clean=False,\n                                  delu_dict=None, plt=None, annotate=True,\n                                  show_unphyiscal_only=False, fontsize=10):\n        \"\"\"\n        Adapted from the get_chempot_range_map() method in the PhaseDiagram\n            class. Plot the chemical potential range map based on surface\n            energy stability. Currently works only for 2-component PDs. At\n            the moment uses a brute force method by enumerating through the\n            range of the first element chempot with a specified increment\n            and determines the chempot rangeo fht e second element for each\n            SlabEntry. Future implementation will determine the chempot range\n            map first by solving systems of equations up to 3 instead of 2.\n        Args:\n            elements (list): Sequence of elements to be considered as independent\n                variables. E.g., if you want to show the stability ranges of\n                all Li-Co-O phases wrt to duLi and duO, you will supply\n                [Element(\"Li\"), Element(\"O\")]\n            miller_index ([h, k, l]): Miller index of the surface we are interested in\n            ranges ([[range1], [range2]]): List of chempot ranges (max and min values)\n                for the first and second element.\n            incr (int): Number of points to sample along the range of the first chempot\n            no_doped (bool): Whether or not to include doped systems.\n            no_clean (bool): Whether or not to include clean systems.\n            delu_dict (Dict): Dictionary of the chemical potentials to be set as\n                constant. Note the key should be a sympy Symbol object of the\n                format: Symbol(\"delu_el\") where el is the name of the element.\n            annotate (bool): Whether to annotate each \"phase\" with the label of\n                the entry. If no label, uses the reduced formula\n            show_unphyiscal_only (bool): Whether to only show the shaded region where\n                surface energy is negative. Useful for drawing other chempot range maps.\n        \"\"\"\n\n        # Set up\n        delu_dict = delu_dict if delu_dict else {}\n        plt = pretty_plot(12, 8) if not plt else plt\n        el1, el2 = str(elements[0]), str(elements[1])\n        delu1 = Symbol(\"delu_%s\" % (str(elements[0])))\n        delu2 = Symbol(\"delu_%s\" % (str(elements[1])))\n        range1 = ranges[0]\n        range2 = ranges[1]\n\n        # Find a range map for each entry (surface). This part is very slow, will\n        # need to implement a more sophisticated method of getting the range map\n        vertices_dict = {}\n        for dmu1 in np.linspace(range1[0], range1[1], incr):\n            # Get chemical potential range of dmu2 for each increment of dmu1\n            new_delu_dict = delu_dict.copy()\n            new_delu_dict[delu1] = dmu1\n            range_dict, se_dict = self.stable_u_range_dict(range2, delu2, dmu_at_0=True,\n                                                           miller_index=miller_index,\n                                                           no_doped=no_doped,\n                                                           no_clean=no_clean,\n                                                           delu_dict=new_delu_dict,\n                                                           return_se_dict=True)\n\n            # Save the chempot range for dmu1 and dmu2\n            for entry in range_dict.keys():\n                if not range_dict[entry]:\n                    continue\n                if entry not in vertices_dict.keys():\n                    vertices_dict[entry] = []\n\n                selist = se_dict[entry]\n                vertices_dict[entry].append({delu1: dmu1, delu2: [range_dict[entry], selist]})\n\n        # Plot the edges of the phases\n        for entry in vertices_dict.keys():\n\n            xvals, yvals = [], []\n\n            # Plot each edge of a phase within the borders\n            for ii, pt1 in enumerate(vertices_dict[entry]):\n\n                # Determine if the surface energy at this lower range\n                # of dmu2 is negative. If so, shade this region.\n                if len(pt1[delu2][1]) == 3:\n                    if pt1[delu2][1][0] < 0:\n                        neg_dmu_range = [pt1[delu2][0][0], pt1[delu2][0][1]]\n                    else:\n                        neg_dmu_range = [pt1[delu2][0][1], pt1[delu2][0][2]]\n                    # Shade the threshold and region at which se<=0\n                    plt.plot([pt1[delu1], pt1[delu1]], neg_dmu_range, 'k--')\n                elif pt1[delu2][1][0] < 0 and pt1[delu2][1][1] < 0:\n                    # Any chempot at at this point will result\n                    # in se<0, shade the entire y range\n                    if not show_unphyiscal_only:\n                        plt.plot([pt1[delu1], pt1[delu1]], range2, 'k--')\n\n                if ii == len(vertices_dict[entry]) - 1:\n                    break\n                pt2 = vertices_dict[entry][ii + 1]\n                if not show_unphyiscal_only:\n                    plt.plot([pt1[delu1], pt2[delu1]], [pt1[delu2][0][0], pt2[delu2][0][0]], 'k')\n\n                # Need these values to get a good position for labelling phases\n                xvals.extend([pt1[delu1], pt2[delu1]])\n                yvals.extend([pt1[delu2][0][0], pt2[delu2][0][0]])\n\n            # Plot the edge along the max x value\n            pt = vertices_dict[entry][-1]\n            delu1, delu2 = pt.keys()\n            xvals.extend([pt[delu1], pt[delu1]])\n            yvals.extend(pt[delu2][0])\n            if not show_unphyiscal_only:\n                plt.plot([pt[delu1], pt[delu1]], [pt[delu2][0][0], pt[delu2][0][-1]], 'k')\n\n            if annotate:\n                # Label the phases\n                x = np.mean([max(xvals), min(xvals)])\n                y = np.mean([max(yvals), min(yvals)])\n                label = entry.label if entry.label else entry.composition.reduced_formula\n                plt.annotate(label, xy=[x, y], xytext=[x, y], fontsize=fontsize)\n\n        # Label plot\n        plt.xlim(range1)\n        plt.ylim(range2)\n        plt.xlabel(r\"$\\Delta\\mu_{%s} (eV)$\" % (el1), fontsize=25)\n        plt.ylabel(r\"$\\Delta\\mu_{%s} (eV)$\" % (el2), fontsize=25)\n        plt.xticks(rotation=60)\n\n        return plt"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_all_variables(self, delu_dict, delu_default):\n\n        # Set up the variables\n        all_delu_dict = {}\n        for du in self.list_of_chempots:\n            if delu_dict and du in delu_dict.keys():\n                all_delu_dict[du] = delu_dict[du]\n            elif du == 1:\n                all_delu_dict[du] = du\n            else:\n                all_delu_dict[du] = delu_default\n\n        return all_delu_dict", "response": "Sets all variables in the chemical potentials and returns a dictionary where the keys are sympy Symbols and the values are a float."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a plot of the locpot along the slab model.", "response": "def get_locpot_along_slab_plot(self, label_energies=True,\n                                   plt=None, label_fontsize=10):\n        \"\"\"\n        Returns a plot of the local potential (eV) vs the\n            position along the c axis of the slab model (Ang)\n\n        Args:\n            label_energies (bool): Whether to label relevant energy\n                quantities such as the work function, Fermi energy,\n                vacuum locpot, bulk-like locpot\n            plt (plt): Matplotlib pylab object\n            label_fontsize (float): Fontsize of labels\n\n        Returns plt of the locpot vs c axis\n        \"\"\"\n\n        plt = pretty_plot(width=6, height=4) if not plt else plt\n\n        # plot the raw locpot signal along c\n        plt.plot(self.along_c, self.locpot_along_c, 'b--')\n\n        # Get the local averaged signal of the locpot along c\n        xg, yg = [], []\n        for i, p in enumerate(self.locpot_along_c):\n            # average signal is just the bulk-like potential when in the slab region\n            in_slab = False\n            for r in self.slab_regions:\n                if r[0] <= self.along_c[i] <= r[1]:\n                    in_slab = True\n            if len(self.slab_regions) > 1:\n                if self.along_c[i] >= self.slab_regions[1][1]:\n                    in_slab = True\n                if self.along_c[i] <= self.slab_regions[0][0]:\n                    in_slab = True\n\n            if in_slab:\n                yg.append(self.ave_bulk_p)\n                xg.append(self.along_c[i])\n            elif p < self.ave_bulk_p:\n                yg.append(self.ave_bulk_p)\n                xg.append(self.along_c[i])\n            else:\n                yg.append(p)\n                xg.append(self.along_c[i])\n        xg, yg = zip(*sorted(zip(xg, yg)))\n        plt.plot(xg, yg, 'r', linewidth=2.5, zorder=-1)\n\n        # make it look nice\n        if label_energies:\n            plt = self.get_labels(plt, label_fontsize=label_fontsize)\n        plt.xlim([0, 1])\n        plt.ylim([min(self.locpot_along_c),\n                  self.vacuum_locpot+self.ave_locpot*0.2])\n        plt.xlabel(r\"Fractional coordinates ($\\hat{c}$)\", fontsize=25)\n        plt.xticks(fontsize=15, rotation=45)\n        plt.ylabel(r\"Potential (eV)\", fontsize=25)\n        plt.yticks(fontsize=15)\n\n        return plt"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a Labelled plot of the locpot vs c axis with relevant quantities.", "response": "def get_labels(self, plt, label_fontsize=10):\n        \"\"\"\n        Handles the optional labelling of the plot with relevant quantities\n        Args:\n            plt (plt): Plot of the locpot vs c axis\n            label_fontsize (float): Fontsize of labels\n        Returns Labelled plt\n        \"\"\"\n\n        # center of vacuum and bulk region\n        if len(self.slab_regions) > 1:\n            label_in_vac = (self.slab_regions[0][1] + self.slab_regions[1][0])/2\n            if abs(self.slab_regions[0][0]-self.slab_regions[0][1]) > \\\n                    abs(self.slab_regions[1][0]-self.slab_regions[1][1]):\n                label_in_bulk = self.slab_regions[0][1]/2\n            else:\n                label_in_bulk = (self.slab_regions[1][1] + self.slab_regions[1][0]) / 2\n        else:\n            label_in_bulk = (self.slab_regions[0][0] + self.slab_regions[0][1])/2\n            if self.slab_regions[0][0] > 1-self.slab_regions[0][1]:\n                label_in_vac = self.slab_regions[0][0] / 2\n            else:\n                label_in_vac = (1 + self.slab_regions[0][1]) / 2\n\n        plt.plot([0, 1], [self.vacuum_locpot]*2, 'b--', zorder=-5, linewidth=1)\n        xy = [label_in_bulk, self.vacuum_locpot+self.ave_locpot*0.05]\n        plt.annotate(r\"$V_{vac}=%.2f$\" %(self.vacuum_locpot), xy=xy,\n                     xytext=xy, color='b', fontsize=label_fontsize)\n\n        # label the fermi energy\n        plt.plot([0, 1], [self.efermi]*2, 'g--',\n                 zorder=-5, linewidth=3)\n        xy = [label_in_bulk, self.efermi+self.ave_locpot*0.05]\n        plt.annotate(r\"$E_F=%.2f$\" %(self.efermi), xytext=xy,\n                     xy=xy, fontsize=label_fontsize, color='g')\n\n        # label the bulk-like locpot\n        plt.plot([0, 1], [self.ave_bulk_p]*2, 'r--', linewidth=1., zorder=-1)\n        xy = [label_in_vac, self.ave_bulk_p + self.ave_locpot * 0.05]\n        plt.annotate(r\"$V^{interior}_{slab}=%.2f$\" % (self.ave_bulk_p),\n                     xy=xy, xytext=xy, color='r', fontsize=label_fontsize)\n\n        # label the work function as a barrier\n        plt.plot([label_in_vac]*2, [self.efermi, self.vacuum_locpot],\n                 'k--', zorder=-5, linewidth=2)\n        xy = [label_in_vac, self.efermi + self.ave_locpot * 0.05]\n        plt.annotate(r\"$\\Phi=%.2f$\" %(self.work_function),\n                     xy=xy, xytext=xy, fontsize=label_fontsize)\n\n        return plt"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef solve_equilibrium_point(self, analyzer1, analyzer2,\n                                delu_dict={}, delu_default=0, units=\"nanometers\"):\n        \"\"\"\n        Gives the radial size of two particles where equilibrium is reached\n            between both particles. NOTE: the solution here is not the same\n            as the solution visualized in the plot because solving for r\n            requires that both the total surface area and volume of the\n            particles are functions of r.\n\n        Args:\n            analyzer1 (SurfaceEnergyPlotter): Analyzer associated with the\n                first polymorph\n            analyzer2 (SurfaceEnergyPlotter): Analyzer associated with the\n                second polymorph\n            delu_dict (Dict): Dictionary of the chemical potentials to be set as\n                constant. Note the key should be a sympy Symbol object of the\n                format: Symbol(\"delu_el\") where el is the name of the element.\n            delu_default (float): Default value for all unset chemical potentials\n            units (str): Can be nanometers or Angstrom\n\n        Returns:\n            Particle radius in nm\n        \"\"\"\n\n        # Set up\n        wulff1 = analyzer1.wulff_from_chempot(delu_dict=delu_dict,\n                                              delu_default=delu_default,\n                                              symprec=self.symprec)\n        wulff2 = analyzer2.wulff_from_chempot(delu_dict=delu_dict,\n                                              delu_default=delu_default,\n                                              symprec=self.symprec)\n\n        # Now calculate r\n        delta_gamma = wulff1.weighted_surface_energy - wulff2.weighted_surface_energy\n        delta_E = self.bulk_gform(analyzer1.ucell_entry) - self.bulk_gform(analyzer2.ucell_entry)\n        r = ((-3 * delta_gamma) / (delta_E))\n\n        return r / 10 if units == \"nanometers\" else r", "response": "Solve the radial size of two particles where equilibrium is reached by calculating the radial size of the two particles."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef wulff_gform_and_r(self, wulffshape, bulk_entry, r, from_sphere_area=False,\n                          r_units=\"nanometers\", e_units=\"keV\", normalize=False,\n                          scale_per_atom=False):\n        \"\"\"\n        Calculates the formation energy of the particle with arbitrary radius r.\n\n        Args:\n            wulffshape (WulffShape): Initial, unscaled WulffShape\n            bulk_entry (ComputedStructureEntry): Entry of the corresponding bulk.\n            r (float (Ang)): Arbitrary effective radius of the WulffShape\n            from_sphere_area (bool): There are two ways to calculate the bulk\n                formation energy. Either by treating the volume and thus surface\n                area of the particle as a perfect sphere, or as a Wulff shape.\n            r_units (str): Can be nanometers or Angstrom\n            e_units (str): Can be keV or eV\n            normalize (bool): Whether or not to normalize energy by volume\n            scale_per_atom (True): Whether or not to normalize by number of\n                atoms in the particle\n\n        Returns:\n            particle formation energy (float in keV), effective radius\n        \"\"\"\n\n        # Set up\n        miller_se_dict = wulffshape.miller_energy_dict\n        new_wulff = self.scaled_wulff(wulffshape, r)\n        new_wulff_area = new_wulff.miller_area_dict\n\n        # calculate surface energy of the particle\n        if not from_sphere_area:\n            # By approximating the particle as a Wulff shape\n            w_vol = new_wulff.volume\n            tot_wulff_se = 0\n            for hkl in new_wulff_area.keys():\n                tot_wulff_se += miller_se_dict[hkl] * new_wulff_area[hkl]\n            Ebulk = self.bulk_gform(bulk_entry) * w_vol\n            new_r = new_wulff.effective_radius\n\n        else:\n            # By approximating the particle as a perfect sphere\n            w_vol = (4 / 3) * np.pi * r ** 3\n            sphere_sa = 4 * np.pi * r ** 2\n            tot_wulff_se = wulffshape.weighted_surface_energy * sphere_sa\n            Ebulk = self.bulk_gform(bulk_entry) * w_vol\n            new_r = r\n\n        new_r = new_r / 10 if r_units == \"nanometers\" else new_r\n        e = (Ebulk + tot_wulff_se)\n        e = e / 1000 if e_units == \"keV\" else e\n        e = e / ((4/3)*np.pi*new_r**3) if normalize else e\n        bulk_struct = bulk_entry.structure\n        density = len(bulk_struct)/bulk_struct.lattice.volume\n        e = e/(density*w_vol) if scale_per_atom else e\n\n        return e, new_r", "response": "Calculates the formation energy of the particle with arbitrary radius r."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a Wulff shape with an effective radius r.", "response": "def scaled_wulff(self, wulffshape, r):\n        \"\"\"\n        Scales the Wulff shape with an effective radius r. Note that the resulting\n            Wulff does not neccesarily have the same effective radius as the one\n            provided. The Wulff shape is scaled by its surface energies where first\n            the surface energies are scale by the minimum surface energy and then\n            multiplied by the given effective radius.\n\n        Args:\n            wulffshape (WulffShape): Initial, unscaled WulffShape\n            r (float): Arbitrary effective radius of the WulffShape\n\n        Returns:\n            WulffShape (scaled by r)\n        \"\"\"\n\n        # get the scaling ratio for the energies\n        r_ratio = r/wulffshape.effective_radius\n        miller_list = wulffshape.miller_energy_dict.keys()\n        # Normalize the magnitude of the facet normal vectors\n        # of the Wulff shape by the minimum surface energy.\n        se_list = np.array(list(wulffshape.miller_energy_dict.values()))\n        # Scale the magnitudes by r_ratio\n        scaled_se = se_list * r_ratio\n\n        return WulffShape(wulffshape.lattice, miller_list,\n                          scaled_se, symprec=self.symprec)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef plot_one_stability_map(self, analyzer, max_r, delu_dict=None, label=\"\",\n                               increments=50, delu_default=0, plt=None,\n                               from_sphere_area=False, e_units=\"keV\",\n                               r_units=\"nanometers\", normalize=False,\n                               scale_per_atom=False):\n        \"\"\"\n        Returns the plot of the formation energy of a particle against its\n            effect radius\n\n        Args:\n            analyzer (SurfaceEnergyPlotter): Analyzer associated with the\n                first polymorph\n            max_r (float): The maximum radius of the particle to plot up to.\n            delu_dict (Dict): Dictionary of the chemical potentials to be set as\n                constant. Note the key should be a sympy Symbol object of the\n                format: Symbol(\"delu_el\") where el is the name of the element.\n            label (str): Label of the plot for legend\n            increments (int): Number of plot points\n            delu_default (float): Default value for all unset chemical potentials\n            plt (pylab): Plot\n            from_sphere_area (bool): There are two ways to calculate the bulk\n                formation energy. Either by treating the volume and thus surface\n                area of the particle as a perfect sphere, or as a Wulff shape.\n            r_units (str): Can be nanometers or Angstrom\n            e_units (str): Can be keV or eV\n            normalize (str): Whether or not to normalize energy by volume\n        \"\"\"\n\n        plt = plt if plt else pretty_plot(width=8, height=7)\n\n        wulffshape = analyzer.wulff_from_chempot(delu_dict=delu_dict,\n                                                 delu_default=delu_default,\n                                                 symprec=self.symprec)\n\n        gform_list, r_list = [], []\n        for r in np.linspace(1e-6, max_r, increments):\n            gform, r = self.wulff_gform_and_r(wulffshape, analyzer.ucell_entry,\n                                              r, from_sphere_area=from_sphere_area,\n                                              r_units=r_units, e_units=e_units,\n                                              normalize=normalize,\n                                              scale_per_atom=scale_per_atom)\n            gform_list.append(gform)\n            r_list.append(r)\n\n        ru = \"nm\" if r_units == \"nanometers\" else \"\\AA\"\n        plt.xlabel(r\"Particle radius ($%s$)\" %(ru))\n        eu = \"$%s/%s^3$\" %(e_units, ru)\n        plt.ylabel(r\"$G_{form}$ (%s)\" %(eu))\n\n        plt.plot(r_list, gform_list, label=label)\n\n        return plt", "response": "Returns the plot of the formation energy of a particle against the one - stability map."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nplots all stability map of a single chemical potential in a single system.", "response": "def plot_all_stability_map(self, max_r, increments=50, delu_dict=None,\n                               delu_default=0, plt=None, labels=None,\n                               from_sphere_area=False, e_units=\"keV\",\n                               r_units=\"nanometers\", normalize=False,\n                               scale_per_atom=False):\n        \"\"\"\n        Returns the plot of the formation energy of a particles\n            of different polymorphs against its effect radius\n\n        Args:\n            max_r (float): The maximum radius of the particle to plot up to.\n            increments (int): Number of plot points\n            delu_dict (Dict): Dictionary of the chemical potentials to be set as\n                constant. Note the key should be a sympy Symbol object of the\n                format: Symbol(\"delu_el\") where el is the name of the element.\n            delu_default (float): Default value for all unset chemical potentials\n            plt (pylab): Plot\n            labels (list): List of labels for each plot, corresponds to the\n                list of se_analyzers\n            from_sphere_area (bool): There are two ways to calculate the bulk\n                formation energy. Either by treating the volume and thus surface\n                area of the particle as a perfect sphere, or as a Wulff shape.\n        \"\"\"\n\n        plt = plt if plt else pretty_plot(width=8, height=7)\n\n        for i, analyzer in enumerate(self.se_analyzers):\n            label = labels[i] if labels else \"\"\n            plt = self.plot_one_stability_map(analyzer, max_r, delu_dict,\n                                              label=label, plt=plt,\n                                              increments=increments,\n                                              delu_default=delu_default,\n                                              from_sphere_area=from_sphere_area,\n                                              e_units=e_units, r_units=r_units,\n                                              normalize=normalize,\n                                              scale_per_atom=scale_per_atom)\n\n        return plt"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef max_delta_volume(self):\n        vols = [v.vol_charge for v in self.voltage_pairs]\n        vols.extend([v.vol_discharge for v in self.voltage_pairs])\n        return max(vols) / min(vols) - 1", "response": "Maximum volume change along insertion\n       "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_average_voltage(self, min_voltage=None, max_voltage=None):\n        pairs_in_range = self._select_in_voltage_range(min_voltage,\n                                                       max_voltage)\n        if len(pairs_in_range) == 0:\n            return 0\n        total_cap_in_range = sum([p.mAh for p in pairs_in_range])\n        total_edens_in_range = sum([p.mAh * p.voltage for p in pairs_in_range])\n        return total_edens_in_range / total_cap_in_range", "response": "Returns the average voltage for the given aracite module."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the gravimetric capacity of the given electrode.", "response": "def get_capacity_grav(self, min_voltage=None, max_voltage=None,\n                          use_overall_normalization=True):\n        \"\"\"\n        Get the gravimetric capacity of the electrode.\n\n        Args:\n            min_voltage (float): The minimum allowable voltage for a given\n                step.\n            max_voltage (float): The maximum allowable voltage allowable for a\n                given step.\n            use_overall_normalization (booL): If False, normalize by the\n                discharged state of only the voltage pairs matching the voltage\n                criteria. if True, use default normalization of the full\n                electrode path.\n\n        Returns:\n            Gravimetric capacity in mAh/g across the insertion path (a subset\n            of the path can be chosen by the optional arguments).\n        \"\"\"\n        pairs_in_range = self._select_in_voltage_range(min_voltage,\n                                                       max_voltage)\n        normalization_mass = self.normalization_mass \\\n            if use_overall_normalization or len(pairs_in_range) == 0 \\\n            else pairs_in_range[-1].mass_discharge\n        return sum([pair.mAh for pair in pairs_in_range]) / normalization_mass"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_capacity_vol(self, min_voltage=None, max_voltage=None,\n                         use_overall_normalization=True):\n        \"\"\"\n        Get the volumetric capacity of the electrode.\n\n        Args:\n            min_voltage (float): The minimum allowable voltage for a given\n                step.\n            max_voltage (float): The maximum allowable voltage allowable for a\n                given step.\n            use_overall_normalization (booL): If False, normalize by the\n                discharged state of only the voltage pairs matching the voltage\n                criteria. if True, use default normalization of the full\n                electrode path.\n\n        Returns:\n            Volumetric capacity in mAh/cc across the insertion path (a subset\n            of the path can be chosen by the optional arguments)\n        \"\"\"\n        pairs_in_range = self._select_in_voltage_range(min_voltage,\n                                                       max_voltage)\n        normalization_vol = self.normalization_volume \\\n            if use_overall_normalization or len(pairs_in_range) == 0 \\\n            else pairs_in_range[-1].vol_discharge\n        return sum([pair.mAh for pair in pairs_in_range]) / normalization_vol \\\n            * 1e24 / N_A", "response": "Get the volumetric capacity of the electrode."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the specific energy of the battery in Wh/kg across the insertion path.", "response": "def get_specific_energy(self, min_voltage=None, max_voltage=None,\n                            use_overall_normalization=True):\n        \"\"\"\n        Returns the specific energy of the battery in mAh/g.\n\n        Args:\n            min_voltage (float): The minimum allowable voltage for a given\n                step.\n            max_voltage (float): The maximum allowable voltage allowable for a\n                given step.\n            use_overall_normalization (booL): If False, normalize by the\n                discharged state of only the voltage pairs matching the voltage\n                criteria. if True, use default normalization of the full\n                electrode path.\n\n        Returns:\n            Specific energy in Wh/kg across the insertion path (a subset of\n            the path can be chosen by the optional arguments)\n        \"\"\"\n        return self.get_capacity_grav(min_voltage, max_voltage,\n                                      use_overall_normalization) \\\n            * self.get_average_voltage(min_voltage, max_voltage)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_energy_density(self, min_voltage=None, max_voltage=None,\n                           use_overall_normalization=True):\n        \"\"\"\n        Args:\n            min_voltage (float): The minimum allowable voltage for a given\n                step.\n            max_voltage (float): The maximum allowable voltage allowable for a\n                given step.\n            use_overall_normalization (booL): If False, normalize by the\n                discharged state of only the voltage pairs matching the voltage\n                criteria. if True, use default normalization of the full\n                electrode path.\n\n        Returns:\n            Energy density in Wh/L across the insertion path (a subset of the\n            path can be chosen by the optional arguments).\n        \"\"\"\n        return self.get_capacity_vol(min_voltage, max_voltage,\n                                     use_overall_normalization) \\\n            * self.get_average_voltage(min_voltage, max_voltage)", "response": "Returns the energy density of the given aracite class."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _select_in_voltage_range(self, min_voltage=None, max_voltage=None):\n        min_voltage = min_voltage if min_voltage is not None \\\n            else self.min_voltage\n        max_voltage = max_voltage if max_voltage is not None \\\n            else self.max_voltage\n        return list(filter(lambda p: min_voltage <= p.voltage <= max_voltage,\n                           self.voltage_pairs))", "response": "Selects VoltagePairs within a certain voltage range."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns pymatgen Molecule object.", "response": "def pymatgen_mol(self):\n        \"\"\"\n        Returns pymatgen Molecule object.\n        \"\"\"\n        sp = []\n        coords = []\n        for atom in ob.OBMolAtomIter(self._obmol):\n            sp.append(atom.GetAtomicNum())\n            coords.append([atom.GetX(), atom.GetY(), atom.GetZ()])\n        return Molecule(sp, coords)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef make3d(self, forcefield=\"mmff94\", steps=50):\n        pbmol = pb.Molecule(self._obmol)\n        pbmol.make3D(forcefield=forcefield, steps=steps)\n        self._obmol = pbmol.OBMol", "response": "A wrapper to pybel s make3D method generate a 3D structure from the current object."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nremove a bond from an openbabel molecule", "response": "def remove_bond(self, idx1, idx2):\n        \"\"\"\n        Remove a bond from an openbabel molecule\n\n        Args:\n            idx1: The atom index of one of the atoms participating the in bond\n            idx2: The atom index of the other atom participating in the bond \n        \"\"\"\n        for obbond in ob.OBMolBondIter(self._obmol):\n            if (obbond.GetBeginAtomIdx() == idx1 and obbond.GetEndAtomIdx() == idx2) or (obbond.GetBeginAtomIdx() == idx2 and obbond.GetEndAtomIdx() == idx1):\n                self._obmol.DeleteBond(obbond)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngenerates all diverse low - energy conformers for all molecules.", "response": "def confab_conformers(self, forcefield=\"mmff94\", freeze_atoms=None,\n                          rmsd_cutoff=0.5, energy_cutoff=50.0,\n                          conf_cutoff=100000, verbose=False):\n        \"\"\"\n        Conformer generation based on Confab to generate all diverse low-energy\n        conformers for molecules. This is different from rotor_conformer or\n        gen3d_conformer as it aims to not simply to find a low energy\n        conformation but to generate several different conformations.\n\n        Args:\n            forcefield (str): Default is mmff94. Options are 'gaff', 'ghemical',\n                'mmff94', 'mmff94s', and 'uff'.\n            freeze_atoms ([int]): index of atoms to be freezed when performing\n                conformer search, default is None.\n            rmsd_cutoff (float): rmsd_cufoff, default is 0.5 Angstrom.\n            energy_cutoff (float): energy_cutoff, default is 50.0 kcal/mol.\n            conf_cutoff (float): max number of conformers to test,\n                default is 1 million.\n            verbose (bool): whether to display information on torsions found,\n                default is False.\n\n        Returns:\n             (list): list of pymatgen Molecule objects for generated conformers.\n        \"\"\"\n        if self._obmol.GetDimension() != 3:\n            self.make3d()\n        else:\n            self.add_hydrogen()\n\n        ff = ob.OBForceField_FindType(forcefield)\n        if ff == 0:\n            print(\"Could not find forcefield {} in openbabel, the forcefield \"\n                  \"will be reset as default 'mmff94'\".format(forcefield))\n            ff = ob.OBForceField_FindType(\"mmff94\")\n\n        if freeze_atoms:\n            print('{} atoms will be freezed'.format(len(freeze_atoms)))\n            constraints = ob.OBFFConstraints()\n\n            for atom in ob.OBMolAtomIter(self._obmol):\n                atom_id = atom.GetIndex() + 1\n                if id in freeze_atoms:\n                    constraints.AddAtomConstraint(atom_id)\n            ff.SetConstraints(constraints)\n\n        # Confab conformer generation\n        ff.DiverseConfGen(rmsd_cutoff, conf_cutoff, energy_cutoff,\n                          verbose)\n        ff.GetConformers(self._obmol)\n\n        # Number of conformers generated by Confab conformer generation\n        conformer_num = self._obmol.NumConformers()\n\n        conformers = []\n        for i in range(conformer_num):\n            self._obmol.SetConformer(i)\n            conformer = copy.deepcopy(BabelMolAdaptor(self._obmol).pymatgen_mol)\n            conformers.append(conformer)\n        self._obmol.SetConformer(0)\n        return conformers"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef write_file(self, filename, file_format=\"xyz\"):\n        mol = pb.Molecule(self._obmol)\n        return mol.write(file_format, filename, overwrite=True)", "response": "Writes the current object to a file."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nuse OpenBabel to read a molecule from a file in all supported formats.", "response": "def from_file(filename, file_format=\"xyz\"):\n        \"\"\"\n        Uses OpenBabel to read a molecule from a file in all supported formats.\n\n        Args:\n            filename: Filename of input file\n            file_format: String specifying any OpenBabel supported formats.\n\n        Returns:\n            BabelMolAdaptor object\n        \"\"\"\n        mols = list(pb.readfile(str(file_format), str(filename)))\n        return BabelMolAdaptor(mols[0].OBMol)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nuse OpenBabel to read a molecule from a string in all supported Babel Mol formats.", "response": "def from_string(string_data, file_format=\"xyz\"):\n        \"\"\"\n        Uses OpenBabel to read a molecule from a string in all supported\n        formats.\n\n        Args:\n            string_data: String containing molecule data.\n            file_format: String specifying any OpenBabel supported formats.\n\n        Returns:\n            BabelMolAdaptor object\n        \"\"\"\n        mols = pb.readstring(str(file_format), str(string_data))\n        return BabelMolAdaptor(mols.OBMol)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nfind the list of bonded atoms in a structure.", "response": "def find_connected_atoms(struct, tolerance=0.45, ldict=JmolNN().el_radius):\n    \"\"\"\n    Finds the list of bonded atoms.\n\n    Args:\n        struct (Structure): Input structure\n        tolerance: length in angstroms used in finding bonded atoms. Two atoms are considered bonded if (radius of atom 1) + (radius of atom 2) + (tolerance) < (distance between atoms 1 and 2). Default value = 0.45, the value used by JMol and Cheon et al.\n        ldict: dictionary of bond lengths used in finding bonded atoms. Values from JMol are used as default\n        standardize: works with conventional standard structures if True. It is recommended to keep this as True.\n\n    Returns:\n        connected_list: A numpy array of shape (number of bonded pairs, 2); each row of is of the form [atomi, atomj].\n        atomi and atomj are the indices of the atoms in the input structure.\n        If any image of atomj is bonded to atomi with periodic boundary conditions, [atomi, atomj] is included in the list.\n        If atomi is bonded to multiple images of atomj, it is only counted once.\n    \"\"\"\n    n_atoms = len(struct.species)\n    fc = np.array(struct.frac_coords)\n    species = list(map(str, struct.species))\n    #in case of charged species\n    for i,item in enumerate(species):\n        if not item in ldict.keys():\n            species[i]=str(Specie.from_string(item).element)\n    latmat = struct.lattice.matrix\n    connected_list = []\n\n    for i in range(n_atoms):\n        for j in range(i + 1, n_atoms):\n            max_bond_length = ldict[species[i]] + ldict[species[j]] + tolerance\n            add_ij = False\n            for move_cell in itertools.product([0, 1, -1], [0, 1, -1], [0, 1, -1]):\n                if not add_ij:\n                    frac_diff = fc[j] + move_cell - fc[i]\n                    distance_ij = np.dot(latmat.T, frac_diff)\n                    if np.linalg.norm(distance_ij) < max_bond_length:\n                        add_ij = True\n            if add_ij:\n                connected_list.append([i, j])\n    return np.array(connected_list)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nfind bonded clusters of atoms in the structure with periodic boundary conditions. If there are atoms that are not bonded to anything, returns [0,1,0].(For faster computation time in FindDimension()) Args: struct (Structure): Input structure connected_list: Must be made from the same structure with FindConnected() function. An array of shape (number of bonded pairs, 2); each row of is of the form [atomi, atomj]. Returns: max_cluster: the size of the largest cluster in the crystal structure min_cluster: the size of the smallest cluster in the crystal structure clusters: list of bonded clusters found here, clusters are formatted as sets of indices of atoms", "response": "def find_clusters(struct, connected_list):\n    \"\"\"\n    Finds bonded clusters of atoms in the structure with periodic boundary conditions.\n    If there are atoms that are not bonded to anything, returns [0,1,0].(For faster computation time in FindDimension())\n\n    Args:\n        struct (Structure): Input structure\n        connected_list: Must be made from the same structure with FindConnected() function.\n            An array of shape (number of bonded pairs, 2); each row of is of the form [atomi, atomj].\n\n    Returns:\n        max_cluster: the size of the largest cluster in the crystal structure\n        min_cluster: the size of the smallest cluster in the crystal structure\n        clusters: list of bonded clusters found here, clusters are formatted as sets of indices of atoms\n    \"\"\"\n    n_atoms = len(struct.species)\n    if len(np.unique(connected_list)) != n_atoms:\n        return [0, 1, 0]\n    if n_atoms == 0:\n        return [0, 0, 0]\n    cluster_sizes = []\n    clusters = []\n    for atom in range(n_atoms):\n        connected_inds = np.where(connected_list == atom)[0]\n        atom_cluster = np.unique(connected_list[connected_inds])\n        atom_cluster = set(atom_cluster)\n        if len(clusters) == 0:\n            new_clusters = [atom_cluster]\n            new_cluster_sizes = [len(atom_cluster)]\n        else:\n            clusters_w_atom = [atom_cluster]\n            clusters_noatom = []\n            clusters_noatom_sizes = []\n            for cluster in clusters:\n                if len(cluster.intersection(atom_cluster)) > 0:\n                    clusters_w_atom.append(cluster)\n                else:\n                    clusters_noatom.append(cluster)\n                    clusters_noatom_sizes.append(len(cluster))\n            if len(clusters_w_atom) > 1:\n                clusters_w_atom = [set.union(*clusters_w_atom)]\n            new_clusters = clusters_noatom + clusters_w_atom\n            new_cluster_sizes = clusters_noatom_sizes + [len(clusters_w_atom[0])]\n        clusters = list(new_clusters)\n        cluster_sizes = list(new_cluster_sizes)\n        if n_atoms in cluster_sizes:\n            break\n    max_cluster = max(cluster_sizes)\n    min_cluster = min(cluster_sizes)\n    return [max_cluster, min_cluster, clusters]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef find_dimension(structure_raw, tolerance=0.45, ldict=JmolNN().el_radius, standardize=True):\n    if standardize:\n        structure = SpacegroupAnalyzer(structure_raw).get_conventional_standard_structure()\n    structure_save = copy.copy(structure_raw)\n    connected_list1 = find_connected_atoms(structure, tolerance=tolerance, ldict=ldict)\n    max1, min1, clusters1 = find_clusters(structure, connected_list1)\n    structure.make_supercell([[2, 0, 0], [0, 2, 0], [0, 0, 2]])\n    connected_list2 = find_connected_atoms(structure, tolerance=tolerance, ldict=ldict)\n    max2, min2, clusters2 = find_clusters(structure, connected_list2)\n    if min2 == 1:\n        dim = 'intercalated ion'\n    elif min2 == min1:\n        if max2 == max1:\n            dim = '0D'\n        else:\n            dim = 'intercalated molecule'\n    else:\n        dim = np.log2(float(max2) / max1)\n        if dim == int(dim):\n            dim = str(int(dim)) + 'D'\n        else:\n            structure=copy.copy(structure_save)\n            structure.make_supercell([[3, 0, 0], [0, 3, 0], [0, 0, 3]])\n            connected_list3 = find_connected_atoms(structure, tolerance=tolerance, ldict=ldict)\n            max3, min3, clusters3 = find_clusters(structure, connected_list3)\n            if min3 == min2:\n                if max3 == max2:\n                    dim = '0D'\n                else:\n                    dim = 'intercalated molecule'\n            else:\n                dim = np.log2(float(max3) / max1) / np.log2(3)\n                if dim == int(dim):\n                    dim = str(int(dim)) + 'D'\n                else:\n                    return\n    return dim", "response": "This method finds the dimensionality of a crystal structure."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a string with the structure in XSF format", "response": "def to_string(self):\n        \"\"\"\n        Returns a string with the structure in XSF format\n        See http://www.xcrysden.org/doc/XSF.html\n        \"\"\"\n        lines = []\n        app = lines.append\n\n        app(\"CRYSTAL\")\n        app(\"# Primitive lattice vectors in Angstrom\")\n        app(\"PRIMVEC\")\n        cell = self.structure.lattice.matrix\n        for i in range(3):\n            app(' %.14f %.14f %.14f' % tuple(cell[i]))\n\n        cart_coords = self.structure.cart_coords\n        app(\"# Cartesian coordinates in Angstrom.\")\n        app(\"PRIMCOORD\")\n        app(\" %d 1\" % len(cart_coords))\n\n        for a in range(len(cart_coords)):\n            sp = \"%d\" % self.structure.atomic_numbers[a]\n            app(sp + ' %20.14f %20.14f %20.14f' % tuple(cart_coords[a]))\n\n        return \"\\n\".join(lines)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ninitialize a structure object from a string with the data in XSF format.", "response": "def from_string(cls, input_string, cls_=None):\n        \"\"\"\n        Initialize a `Structure` object from a string with data in XSF format.\n\n        Args:\n            input_string: String with the structure in XSF format.\n                See http://www.xcrysden.org/doc/XSF.html\n            cls_: Structure class to be created. default: pymatgen structure\n\n        \"\"\"\n        # CRYSTAL                                        see (1)\n        # these are primitive lattice vectors (in Angstroms)\n        # PRIMVEC\n        #    0.0000000    2.7100000    2.7100000         see (2)\n        #    2.7100000    0.0000000    2.7100000\n        #    2.7100000    2.7100000    0.0000000\n\n        # these are conventional lattice vectors (in Angstroms)\n        # CONVVEC\n        #    5.4200000    0.0000000    0.0000000         see (3)\n        #    0.0000000    5.4200000    0.0000000\n        #    0.0000000    0.0000000    5.4200000\n\n        # these are atomic coordinates in a primitive unit cell  (in Angstroms)\n        # PRIMCOORD\n        # 2 1                                            see (4)\n        # 16      0.0000000     0.0000000     0.0000000  see (5)\n        # 30      1.3550000    -1.3550000    -1.3550000\n\n        lattice, coords, species = [], [], []\n        lines = input_string.splitlines()\n\n        for i in range(len(lines)):\n            if \"PRIMVEC\" in lines[i]:\n                for j in range(i+1, i+4):\n                    lattice.append([float(c) for c in lines[j].split()])\n\n            if \"PRIMCOORD\" in lines[i]:\n                num_sites = int(lines[i+1].split()[0])\n\n                for j in range(i+2, i+2+num_sites):\n                    tokens = lines[j].split()\n                    species.append(int(tokens[0]))\n                    coords.append([float(j) for j in tokens[1:4]])\n                break\n        else:\n            raise ValueError(\"Invalid XSF data\")\n\n        if cls_ is None:\n            from pymatgen.core.structure import Structure\n            cls_ = Structure\n\n        s = cls_(lattice, species, coords, coords_are_cartesian=True)\n        return XSF(s)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_kpoints(self, line_density=20, coords_are_cartesian=True):\n        list_k_points = []\n        sym_point_labels = []\n        for b in self.kpath['path']:\n            for i in range(1, len(b)):\n                start = np.array(self.kpath['kpoints'][b[i - 1]])\n                end = np.array(self.kpath['kpoints'][b[i]])\n                distance = np.linalg.norm(\n                    self._prim_rec.get_cartesian_coords(start) -\n                    self._prim_rec.get_cartesian_coords(end))\n                nb = int(ceil(distance * line_density))\n                sym_point_labels.extend([b[i - 1]] + [''] * (nb - 1) + [b[i]])\n                list_k_points.extend(\n                    [self._prim_rec.get_cartesian_coords(start)\n                     + float(i) / float(nb) *\n                     (self._prim_rec.get_cartesian_coords(end)\n                      - self._prim_rec.get_cartesian_coords(start))\n                     for i in range(0, nb + 1)])\n        if coords_are_cartesian:\n            return list_k_points, sym_point_labels\n        else:\n            frac_k_points = [self._prim_rec.get_fractional_coords(k)\n                             for k in list_k_points]\n            return frac_k_points, sym_point_labels", "response": "Returns the kpoints along the paths in cartesian coordinates and the labels for symmetry points"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef from_node(cls, work):\n        new = super().from_node(work)\n\n        # Will put all files found in outdir in GridFs\n        # Warning: assuming binary files.\n        d = {os.path.basename(f): f for f in work.outdir.list_filepaths()}\n        new.register_gridfs_files(**d)\n\n        return new", "response": "Initialize an instance from a Work instance."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef ncores_reserved(self):\n        return sum(task.manager.num_cores for task in self if task.status == task.S_SUB)", "response": "Returns the number of cores reserved in this moment."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the number of CPUs allocated in this moment.", "response": "def ncores_allocated(self):\n        \"\"\"\n        Returns the number of CPUs allocated in this moment.\n        A core is allocated if it's running a task or if we have\n        submitted a task to the queue manager but the job is still pending.\n        \"\"\"\n        return sum(task.manager.num_cores for task in self if task.status in [task.S_SUB, task.S_RUN])"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef ncores_used(self):\n        return sum(task.manager.num_cores for task in self if task.status == task.S_RUN)", "response": "Returns the number of cores used in this moment."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the first task that is ready to run or None if no task can be submitted at present", "response": "def fetch_task_to_run(self):\n        \"\"\"\n        Returns the first task that is ready to run or\n        None if no task can be submitted at present\"\n\n        Raises:\n            `StopIteration` if all tasks are done.\n        \"\"\"\n        # All the tasks are done so raise an exception\n        # that will be handled by the client code.\n        if all(task.is_completed for task in self):\n            raise StopIteration(\"All tasks completed.\")\n\n        for task in self:\n            if task.can_run:\n                return task\n\n        # No task found, this usually happens when we have dependencies.\n        # Beware of possible deadlocks here!\n        logger.warning(\"Possible deadlock in fetch_task_to_run!\")\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconnects the signals within the work.", "response": "def connect_signals(self):\n        \"\"\"\n        Connect the signals within the work.\n        The :class:`Work` is responsible for catching the important signals raised from\n        its task and raise new signals when some particular condition occurs.\n        \"\"\"\n        for task in self:\n            dispatcher.connect(self.on_ok, signal=task.S_OK, sender=task)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef disconnect_signals(self):\n        for task in self:\n            try:\n                dispatcher.disconnect(self.on_ok, signal=task.S_OK, sender=task)\n            except dispatcher.errors.DispatcherKeyError as exc:\n                logger.debug(str(exc))", "response": "Disable the signals within the work."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef on_ok(self, sender):\n        logger.debug(\"in on_ok with sender %s\" % sender)\n\n        if self.all_ok:\n            if self.finalized:\n                return AttrDict(returncode=0, message=\"Work has been already finalized\")\n            else:\n                # Set finalized here, because on_all_ok might change it (e.g. Relax + EOS in a single work)\n                self.finalized = True\n                try:\n                    results = AttrDict(**self.on_all_ok())\n                except Exception as exc:\n                    self.history.critical(\"on_all_ok raises %s\" % str(exc))\n                    self.finalized = False\n                    raise\n\n                # Signal to possible observers that the `Work` reached S_OK\n                self.history.info(\"Work %s is finalized and broadcasts signal S_OK\" % str(self))\n                if self._finalized:\n                    self.send_signal(self.S_OK)\n\n                return results\n\n        return AttrDict(returncode=1, message=\"Not all tasks are OK!\")", "response": "This callback is called when one task reaches status S_OK. It executes on_all_ok and sends a signal to possible observers that the task is not all tasks are OK."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef register_scf_task(self, *args, **kwargs):\n        kwargs[\"task_class\"] = ScfTask\n        return self.register_task(*args, **kwargs)", "response": "Register a Scf task."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef register_collinear_then_noncollinear_scf_task(self, *args, **kwargs):\n        kwargs[\"task_class\"] = CollinearThenNonCollinearScfTask\n        return self.register_task(*args, **kwargs)", "response": "Register a CollinearThenNonCollinearScfTask that performs a SCF run first with nsppol = 2 and then nspinor = 2"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nregisters a nscf task.", "response": "def register_nscf_task(self, *args, **kwargs):\n        \"\"\"Register a nscf task.\"\"\"\n        kwargs[\"task_class\"] = NscfTask\n        return self.register_task(*args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef register_relax_task(self, *args, **kwargs):\n        kwargs[\"task_class\"] = RelaxTask\n        return self.register_task(*args, **kwargs)", "response": "Register a task for structural optimization."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nregister a phonon task.", "response": "def register_phonon_task(self, *args, **kwargs):\n        \"\"\"Register a phonon task.\"\"\"\n        kwargs[\"task_class\"] = PhononTask\n        return self.register_task(*args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nregisters an elastic task.", "response": "def register_elastic_task(self, *args, **kwargs):\n        \"\"\"Register an elastic task.\"\"\"\n        kwargs[\"task_class\"] = ElasticTask\n        return self.register_task(*args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nregisters a ddk task.", "response": "def register_ddk_task(self, *args, **kwargs):\n        \"\"\"Register a ddk task.\"\"\"\n        kwargs[\"task_class\"] = DdkTask\n        return self.register_task(*args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef register_scr_task(self, *args, **kwargs):\n        kwargs[\"task_class\"] = ScrTask\n        return self.register_task(*args, **kwargs)", "response": "Register a screening task."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nregister a sigma task.", "response": "def register_sigma_task(self, *args, **kwargs):\n        \"\"\"Register a sigma task.\"\"\"\n        kwargs[\"task_class\"] = SigmaTask\n        return self.register_task(*args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef register_dde_task(self, *args, **kwargs):\n        kwargs[\"task_class\"] = DdeTask\n        return self.register_task(*args, **kwargs)", "response": "Register a Dde task."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nregister a Dte task.", "response": "def register_dte_task(self, *args, **kwargs):\n        \"\"\"Register a Dte task.\"\"\"\n        kwargs[\"task_class\"] = DteTask\n        return self.register_task(*args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nregisters a BEC task.", "response": "def register_bec_task(self, *args, **kwargs):\n        \"\"\"Register a BEC task.\"\"\"\n        kwargs[\"task_class\"] = BecTask\n        return self.register_task(*args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nregisters a Bethe - Salpeter task.", "response": "def register_bse_task(self, *args, **kwargs):\n        \"\"\"Register a Bethe-Salpeter task.\"\"\"\n        kwargs[\"task_class\"] = BseTask\n        return self.register_task(*args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nregistering an electron - phonon task.", "response": "def register_eph_task(self, *args, **kwargs):\n        \"\"\"Register an electron-phonon task.\"\"\"\n        kwargs[\"task_class\"] = EphTask\n        return self.register_task(*args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets the values of the ABINIT variables in the input files of the nodes in this object.", "response": "def walknset_vars(self, task_class=None, *args, **kwargs):\n        \"\"\"\n        Set the values of the ABINIT variables in the input files of the nodes\n\n        Args:\n            task_class: If not None, only the input files of the tasks belonging\n                to class `task_class` are modified.\n\n        Example:\n\n            flow.walknset_vars(ecut=10, kptopt=4)\n        \"\"\"\n        def change_task(task):\n            if task_class is not None and task.__class__ is not task_class: return False\n            return True\n\n        if self.is_work:\n            for task in self:\n                if not change_task(task): continue\n                task.set_vars(*args, **kwargs)\n\n        elif self.is_flow:\n            for task in self.iflat_tasks():\n                if not change_task(task): continue\n                task.set_vars(*args, **kwargs)\n\n        else:\n            raise TypeError(\"Don't know how to set variables for object class %s\"  % self.__class__.__name__)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset the manager to use to launch the Task.", "response": "def set_manager(self, manager):\n        \"\"\"Set the :class:`TaskManager` to use to launch the :class:`Task`.\"\"\"\n        self.manager = manager.deepcopy()\n        for task in self:\n            task.set_manager(manager)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_flow(self, flow):\n        if not hasattr(self, \"_flow\"):\n            self._flow = flow\n        else:\n            if self._flow != flow:\n                raise ValueError(\"self._flow != flow\")", "response": "Set the flow associated to this : class : Work."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef status_counter(self):\n        counter = collections.Counter()\n\n        for task in self:\n            counter[str(task.status)] += 1\n\n        return counter", "response": "Returns a Counter object that counts the number of task with\n        given status."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef allocate(self, manager=None):\n        for i, task in enumerate(self):\n\n            if not hasattr(task, \"manager\"):\n                # Set the manager\n                # Use the one provided in input else the one of the work/flow.\n                if manager is not None:\n                    task.set_manager(manager)\n                else:\n                    # Look first in work and then in the flow.\n                    if hasattr(self, \"manager\"):\n                        task.set_manager(self.manager)\n                    else:\n                        task.set_manager(self.flow.manager)\n\n            task_workdir = os.path.join(self.workdir, \"t\" + str(i))\n\n            if not hasattr(task, \"workdir\"):\n                task.set_workdir(task_workdir)\n            else:\n                if task.workdir != task_workdir:\n                    raise ValueError(\"task.workdir != task_workdir: %s, %s\" % (task.workdir, task_workdir))", "response": "This function is called once we have completed the initialization of the work and the flow. It sets the manager of each task and defines the working directories of the tasks."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef register(self, obj, deps=None, required_files=None, manager=None, task_class=None):\n        task_workdir = None\n        if hasattr(self, \"workdir\"):\n            task_workdir = os.path.join(self.workdir, \"t\" + str(len(self)))\n\n        if isinstance(obj, Task):\n            task = obj\n\n        else:\n            # Set the class\n            if task_class is None:\n                task_class = AbinitTask\n\n            task = task_class.from_input(obj, task_workdir, manager)\n\n        self._tasks.append(task)\n\n        # Handle possible dependencies given either as dict or list.\n        if deps is not None:\n            if hasattr(deps, \"items\"):\n                deps = [Dependency(node, exts) for node, exts in deps.items()]\n            task.add_deps(deps)\n\n        # Handle possible dependencies.\n        if required_files is not None:\n            task.add_required_files(required_files)\n\n        return task", "response": "Registers a new Task object and adds it to the internal list."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating the top level directory and files of the work.", "response": "def build(self, *args, **kwargs):\n        \"\"\"Creates the top level directory.\"\"\"\n        # Create the directories of the work.\n        self.indir.makedirs()\n        self.outdir.makedirs()\n        self.tmpdir.makedirs()\n\n        # Build dirs and files of each task.\n        for task in self:\n            task.build(*args, **kwargs)\n\n        # Connect signals within the work.\n        self.connect_signals()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a list with the status of all the tasks in the current node.", "response": "def get_all_status(self, only_min=False):\n        \"\"\"\n        Returns a list with the status of the tasks in self.\n\n        Args:\n            only_min: If True, the minimum of the status is returned.\n        \"\"\"\n        if len(self) == 0:\n            # The work will be created in the future.\n            if only_min:\n                return self.S_INIT\n            else:\n                return [self.S_INIT]\n\n        self.check_status()\n        status_list = [task.status for task in self]\n\n        if only_min:\n            return min(status_list)\n        else:\n            return status_list"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nchecks the status of the tasks.", "response": "def check_status(self):\n        \"\"\"Check the status of the tasks.\"\"\"\n        # Recompute the status of the tasks\n        # Ignore OK and LOCKED tasks.\n        for task in self:\n            if task.status in (task.S_OK, task.S_LOCKED): continue\n            task.check_status()\n\n        # Take into account possible dependencies. Use a list instead of generators\n        for task in self:\n            if task.status == task.S_LOCKED: continue\n            if task.status < task.S_SUB and all(status == task.S_OK for status in task.deps_status):\n                task.set_status(task.S_READY, \"Status set to Ready\")"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nremoving all files and directories in the working directory.", "response": "def rmtree(self, exclude_wildcard=\"\"):\n        \"\"\"\n        Remove all files and directories in the working directory\n\n        Args:\n            exclude_wildcard: Optional string with regular expressions separated by `|`.\n                Files matching one of the regular expressions will be preserved.\n                example: exclude_wildard=\"*.nc|*.txt\" preserves all the files\n                whose extension is in [\"nc\", \"txt\"].\n        \"\"\"\n        if not exclude_wildcard:\n            shutil.rmtree(self.workdir)\n\n        else:\n            w = WildCard(exclude_wildcard)\n            for dirpath, dirnames, filenames in os.walk(self.workdir):\n                for fname in filenames:\n                    path = os.path.join(dirpath, fname)\n                    if not w.match(fname):\n                        os.remove(path)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nsubmit the tasks in self and wait.", "response": "def submit_tasks(self, wait=False):\n        \"\"\"\n        Submits the task in self and wait.\n        TODO: change name.\n        \"\"\"\n        for task in self:\n            task.start()\n\n        if wait:\n            for task in self: task.wait()"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nstarts the work. Calls build and _setup first then submit the tasks.", "response": "def start(self, *args, **kwargs):\n        \"\"\"\n        Start the work. Calls build and _setup first, then submit the tasks.\n        Non-blocking call unless wait is set to True\n        \"\"\"\n        wait = kwargs.pop(\"wait\", False)\n\n        # Initial setup\n        self._setup(*args, **kwargs)\n\n        # Build dirs and files.\n        self.build(*args, **kwargs)\n\n        # Submit tasks (does not block)\n        self.submit_tasks(wait=wait)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef read_etotals(self, unit=\"Ha\"):\n        if not self.all_done:\n            raise self.Error(\"Some task is still in running/submitted state\")\n\n        etotals = []\n        for task in self:\n            # Open the GSR file and read etotal (Hartree)\n            gsr_path = task.outdir.has_abiext(\"GSR\")\n            etot = np.inf\n            if gsr_path:\n                with ETSF_Reader(gsr_path) as r:\n                    etot = r.read_value(\"etotal\")\n\n            etotals.append(etot)\n\n        return EnergyArray(etotals, \"Ha\").to(unit)", "response": "Reads the total energy from the GSR file produced by the task."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nparses the TIMER section reported in the ABINIT output files.", "response": "def parse_timers(self):\n        \"\"\"\n        Parse the TIMER section reported in the ABINIT output files.\n\n        Returns:\n            :class:`AbinitTimerParser` object\n        \"\"\"\n        filenames = list(filter(os.path.exists, [task.output_file.path for task in self]))\n\n        parser = AbinitTimerParser()\n        parser.parse(filenames)\n\n        return parser"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nplot the band structure.", "response": "def plot_ebands(self, **kwargs):\n        \"\"\"\n        Plot the band structure. kwargs are passed to the plot method of :class:`ElectronBands`.\n\n        Returns:\n            `matplotlib` figure\n        \"\"\"\n        with self.nscf_task.open_gsr() as gsr:\n            return gsr.ebands.plot(**kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nplotting the band structure and the DOS.", "response": "def plot_ebands_with_edos(self, dos_pos=0, method=\"gaussian\", step=0.01, width=0.1, **kwargs):\n        \"\"\"\n        Plot the band structure and the DOS.\n\n        Args:\n            dos_pos: Index of the task from which the DOS should be obtained (note: 0 refers to the first DOS task).\n            method: String defining the method for the computation of the DOS.\n            step: Energy step (eV) of the linear mesh.\n            width: Standard deviation (eV) of the gaussian.\n            kwargs: Keyword arguments passed to `plot_with_edos` method to customize the plot.\n\n        Returns:\n            `matplotlib` figure.\n        \"\"\"\n        with self.nscf_task.open_gsr() as gsr:\n            gs_ebands = gsr.ebands\n\n        with self.dos_tasks[dos_pos].open_gsr() as gsr:\n            dos_ebands = gsr.ebands\n\n        edos = dos_ebands.get_edos(method=method, step=step, width=width)\n        return gs_ebands.plot_with_edos(edos, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nplots the band structure and the DOS.", "response": "def plot_edoses(self, dos_pos=None, method=\"gaussian\", step=0.01, width=0.1, **kwargs):\n        \"\"\"\n        Plot the band structure and the DOS.\n\n        Args:\n            dos_pos: Index of the task from which the DOS should be obtained.\n                     None is all DOSes should be displayed. Accepts integer or list of integers.\n            method: String defining the method for the computation of the DOS.\n            step: Energy step (eV) of the linear mesh.\n            width: Standard deviation (eV) of the gaussian.\n            kwargs: Keyword arguments passed to `plot` method to customize the plot.\n\n        Returns:\n            `matplotlib` figure.\n        \"\"\"\n        if dos_pos is not None and not isinstance(dos_pos, (list, tuple)): dos_pos = [dos_pos]\n\n        from abipy.electrons.ebands import ElectronDosPlotter\n        plotter = ElectronDosPlotter()\n        for i, task in enumerate(self.dos_tasks):\n            if dos_pos is not None and i not in dos_pos: continue\n            with task.open_gsr() as gsr:\n                edos = gsr.ebands.get_edos(method=method, step=step, width=width)\n                ngkpt = task.get_inpvar(\"ngkpt\")\n                plotter.add_edos(\"ngkpt %s\" % str(ngkpt), edos)\n\n        return plotter.combiplot(**kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef on_ok(self, sender):\n        logger.debug(\"in on_ok with sender %s\" % sender)\n\n        if sender == self.ion_task and not self.transfer_done:\n            # Get the relaxed structure from ion_task\n            ion_structure = self.ion_task.get_final_structure()\n\n            # Transfer it to the ioncell task (we do it only once).\n            self.ioncell_task._change_structure(ion_structure)\n            self.transfer_done = True\n\n            # Unlock ioncell_task so that we can submit it.\n            self.ioncell_task.unlock(source_node=self)\n\n        elif sender == self.ioncell_task and self.target_dilatmx:\n            actual_dilatmx = self.ioncell_task.get_inpvar('dilatmx', 1.)\n            if self.target_dilatmx < actual_dilatmx:\n                self.ioncell_task.reduce_dilatmx(target=self.target_dilatmx)\n                self.history.info('Converging dilatmx. Value reduce from {} to {}.'\n                            .format(actual_dilatmx, self.ioncell_task.get_inpvar('dilatmx')))\n                self.ioncell_task.reset_from_scratch()\n\n        return super().on_ok(sender)", "response": "This callback is called when one task reaches status S_OK."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef plot_ion_relaxation(self, **kwargs):\n        with self.ion_task.open_hist() as hist:\n            return hist.plot(**kwargs) if hist else None", "response": "Plot the history of the ion - cell relaxation."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nplotting the history of the ion - cell relaxation.", "response": "def plot_ioncell_relaxation(self, **kwargs):\n        \"\"\"\n        Plot the history of the ion-cell relaxation.\n        kwargs are passed to the plot method of :class:`HistFile`\n\n        Return `matplotlib` figure or None if hist file is not found.\n        \"\"\"\n        with self.ioncell_task.open_hist() as hist:\n            return hist.plot(**kwargs) if hist else None"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_mdf_robot(self):\n        from abilab.robots import MdfRobot\n        robot = MdfRobot()\n        for task in self[2:]:\n            mdf_path = task.outdir.has_abiext(robot.EXT)\n            if mdf_path:\n                robot.add_file(str(task), mdf_path)\n        return robot", "response": "Builds and returns a MdfRobot for analyzing the results in the MDF files."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates the SCR tasks and register them in self.", "response": "def create_tasks(self, wfk_file, scr_input):\n        \"\"\"\n        Create the SCR tasks and register them in self.\n\n        Args:\n            wfk_file: Path to the ABINIT WFK file to use for the computation of the screening.\n            scr_input: Input for the screening calculation.\n        \"\"\"\n        assert len(self) == 0\n        wfk_file = self.wfk_file = os.path.abspath(wfk_file)\n\n        # Build a temporary work in the tmpdir that will use a shell manager\n        # to run ABINIT in order to get the list of q-points for the screening.\n        shell_manager = self.manager.to_shell_manager(mpi_procs=1)\n\n        w = Work(workdir=self.tmpdir.path_join(\"_qptdm_run\"), manager=shell_manager)\n\n        fake_input = scr_input.deepcopy()\n        fake_task = w.register(fake_input)\n        w.allocate()\n        w.build()\n\n        # Create the symbolic link and add the magic value\n        # nqpdm = -1 to the input to get the list of q-points.\n        fake_task.inlink_file(wfk_file)\n        fake_task.set_vars({\"nqptdm\": -1})\n        fake_task.start_and_wait()\n\n        # Parse the section with the q-points\n        with NetcdfReader(fake_task.outdir.has_abiext(\"qptdms.nc\")) as reader:\n            qpoints = reader.read_value(\"reduced_coordinates_of_kpoints\")\n        #print(\"qpoints)\n\n        # Now we can register the task for the different q-points\n        for qpoint in qpoints:\n            qptdm_input = scr_input.deepcopy()\n            qptdm_input.set_vars(nqptdm=1, qptdm=qpoint)\n            new_task = self.register_scr_task(qptdm_input, manager=self.manager)\n            # Add the garbage collector.\n            if self.flow.gc is not None:\n                new_task.set_gc(self.flow.gc)\n\n        self.allocate()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef merge_scrfiles(self, remove_scrfiles=True):\n        scr_files = list(filter(None, [task.outdir.has_abiext(\"SCR\") for task in self]))\n\n        self.history.info(\"Will call mrgscr to merge %s SCR files:\\n\" % len(scr_files))\n        assert len(scr_files) == len(self)\n\n        mrgscr = wrappers.Mrgscr(manager=self[0].manager, verbose=1)\n        final_scr = mrgscr.merge_qpoints(self.outdir.path, scr_files, out_prefix=\"out\")\n\n        if remove_scrfiles:\n            for scr_file in scr_files:\n                try:\n                    os.remove(scr_file)\n                except IOError:\n                    pass\n\n        return final_scr", "response": "This method merges the SCR files in the outdir of the Work."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nbuilding tasks for the computation of Born effective charges and add them to the work. Args: scf_task: ScfTask object. ddk_tolerance: dict {\"varname\": value} with the tolerance used in the DDK run. None to use AbiPy default. ph_tolerance: dict {\"varname\": value} with the tolerance used in the phonon run. None to use AbiPy default. Return: (ddk_tasks, bec_tasks)", "response": "def add_becs_from_scf_task(self, scf_task, ddk_tolerance, ph_tolerance):\n        \"\"\"\n        Build tasks for the computation of Born effective charges and add them to the work.\n\n        Args:\n            scf_task: ScfTask object.\n            ddk_tolerance: dict {\"varname\": value} with the tolerance used in the DDK run.\n                None to use AbiPy default.\n            ph_tolerance: dict {\"varname\": value} with the tolerance used in the phonon run.\n                None to use AbiPy default.\n\n\tReturn:\n\t    (ddk_tasks, bec_tasks)\n\t\"\"\"\n        if not isinstance(scf_task, ScfTask):\n            raise TypeError(\"task `%s` does not inherit from ScfTask\" % scf_task)\n\n\t# DDK calculations (self-consistent to get electric field).\n        multi_ddk = scf_task.input.make_ddk_inputs(tolerance=ddk_tolerance)\n\n        ddk_tasks = []\n        for ddk_inp in multi_ddk:\n            ddk_task = self.register_ddk_task(ddk_inp, deps={scf_task: \"WFK\"})\n            ddk_tasks.append(ddk_task)\n\n        # Build the list of inputs for electric field perturbation and phonons\n        # Each BEC task is connected to all the previous DDK task and to the scf_task.\n        bec_deps = {ddk_task: \"DDK\" for ddk_task in ddk_tasks}\n        bec_deps.update({scf_task: \"WFK\"})\n\n        bec_inputs = scf_task.input.make_bec_inputs(tolerance=ph_tolerance)\n        bec_tasks = []\n        for bec_inp in bec_inputs:\n             bec_task = self.register_bec_task(bec_inp, deps=bec_deps)\n             bec_tasks.append(bec_task)\n\n        return ddk_tasks, bec_tasks"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef merge_ddb_files(self, delete_source_ddbs=True, only_dfpt_tasks=True,\n                        exclude_tasks=None, include_tasks=None):\n        \"\"\"\n        This method is called when all the q-points have been computed.\n        It runs `mrgddb` in sequential on the local machine to produce\n        the final DDB file in the outdir of the `Work`.\n\n        Args:\n            delete_source_ddbs: True if input DDB should be removed once final DDB is created.\n            only_dfpt_tasks: False to merge all DDB files produced by the tasks of the work\n                Useful e.g. for finite stress corrections in which the stress in the\n                initial configuration should be merged in the final DDB.\n            exclude_tasks: List of tasks that should be excluded when merging the partial DDB files.\n            include_tasks: List of tasks that should be included when merging the partial DDB files.\n                Mutually exclusive with exclude_tasks.\n\n        Returns:\n            path to the output DDB file\n        \"\"\"\n        if exclude_tasks:\n            my_tasks = [task for task in self if task not in exclude_tasks]\n        elif include_tasks:\n            my_tasks = [task for task in self if task in include_tasks]\n        else:\n            my_tasks = [task for task in self]\n\n        if only_dfpt_tasks:\n            ddb_files = list(filter(None, [task.outdir.has_abiext(\"DDB\") for task in my_tasks \\\n                                       if isinstance(task, DfptTask)]))\n        else:\n            ddb_files = list(filter(None, [task.outdir.has_abiext(\"DDB\") for task in my_tasks]))\n\n        self.history.info(\"Will call mrgddb to merge %s DDB files:\" % len(ddb_files))\n        # DDB files are always produces so this should never happen!\n        if not ddb_files:\n            raise RuntimeError(\"Cannot find any DDB file to merge by the task of \" % self)\n\n        # Final DDB file will be produced in the outdir of the work.\n        out_ddb = self.outdir.path_in(\"out_DDB\")\n\n        if len(ddb_files) == 1:\n            # Avoid the merge. Just copy the DDB file to the outdir of the work.\n            shutil.copy(ddb_files[0], out_ddb)\n        else:\n            # Call mrgddb\n            desc = \"DDB file merged by %s on %s\" % (self.__class__.__name__, time.asctime())\n            mrgddb = wrappers.Mrgddb(manager=self[0].manager, verbose=0)\n            mrgddb.merge(self.outdir.path, ddb_files, out_ddb=out_ddb, description=desc,\n                         delete_source_ddbs=delete_source_ddbs)\n\n        return out_ddb", "response": "This method merges the DDB files produced by the tasks of the work."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconstructing a PhononWork object from a ScfTask object.", "response": "def from_scf_task(cls, scf_task, qpoints, is_ngqpt=False, tolerance=None, with_becs=False,\n                      ddk_tolerance=None, manager=None):\n        \"\"\"\n        Construct a `PhononWork` from a :class:`ScfTask` object.\n        The input file for phonons is automatically generated from the input of the ScfTask.\n        Each phonon task depends on the WFK file produced by the `scf_task`.\n\n        Args:\n            scf_task: ScfTask object.\n            qpoints: q-points in reduced coordinates. Accepts single q-point, list of q-points\n                or three integers defining the q-mesh if `is_ngqpt`.\n            is_ngqpt: True if `qpoints` should be interpreted as divisions instead of q-points.\n            tolerance: dict {\"varname\": value} with the tolerance to be used in the phonon run.\n                None to use AbiPy default.\n            with_becs: Activate calculation of Electric field and Born effective charges.\n            ddk_tolerance: dict {\"varname\": value} with the tolerance used in the DDK run if with_becs.\n                None to use AbiPy default.\n            manager: :class:`TaskManager` object.\n        \"\"\"\n        if not isinstance(scf_task, ScfTask):\n            raise TypeError(\"task `%s` does not inherit from ScfTask\" % scf_task)\n\n        if is_ngqpt:\n            qpoints = scf_task.input.abiget_ibz(ngkpt=qpoints, shiftk=[0, 0, 0], kptopt=1).points\n        qpoints = np.reshape(qpoints, (-1, 3))\n\n        new = cls(manager=manager)\n        if with_becs:\n            new.add_becs_from_scf_task(scf_task, ddk_tolerance, ph_tolerance=tolerance)\n\n        for qpt in qpoints:\n            if with_becs and np.sum(qpt ** 2) < 1e-12: continue\n            multi = scf_task.input.make_ph_inputs_qpoint(qpt, tolerance=tolerance)\n            for ph_inp in multi:\n                new.register_phonon_task(ph_inp, deps={scf_task: \"WFK\"})\n\n        return new"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate a new instance of a Task from a SCF input and a list of QPoints.", "response": "def from_scf_input(cls, scf_input, qpoints, is_ngqpt=False, tolerance=None,\n                       with_becs=False, ddk_tolerance=None, manager=None):\n        \"\"\"\n        Similar to `from_scf_task`, the difference is that this method requires\n        an input for SCF calculation. A new ScfTask is created and added to the Work.\n        This API should be used if the DDB of the GS task should be merged.\n        \"\"\"\n        if is_ngqpt:\n            qpoints = scf_input.abiget_ibz(ngkpt=qpoints, shiftk=[0, 0, 0], kptopt=1).points\n\n        qpoints = np.reshape(qpoints, (-1, 3))\n\n        new = cls(manager=manager)\n        # Create ScfTask\n        scf_task = new.register_scf_task(scf_input)\n\n        if with_becs:\n            new.add_becs_from_scf_task(scf_task, ddk_tolerance, ph_tolerance=tolerance)\n\n        for qpt in qpoints:\n            if with_becs and np.sum(qpt ** 2) < 1e-12: continue\n            multi = scf_task.input.make_ph_inputs_qpoint(qpt, tolerance=tolerance)\n            for ph_inp in multi:\n                new.register_phonon_task(ph_inp, deps={scf_task: \"WFK\"})\n\n        return new"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef from_scf_task(cls, scf_task, ngqpt, ph_tolerance=None, tolwfr=1.0e-22, nband=None,\n                      with_becs=False, ddk_tolerance=None, shiftq=(0, 0, 0), is_ngqpt=True, remove_wfkq=True,\n                      manager=None):\n        \"\"\"\n        Construct a `PhononWfkqWork` from a :class:`ScfTask` object.\n        The input files for WFQ and phonons are automatically generated from the input of the ScfTask.\n        Each phonon task depends on the WFK file produced by scf_task and the associated WFQ file.\n\n        Args:\n            scf_task: ScfTask object.\n            ngqpt: three integers defining the q-mesh\n            with_becs: Activate calculation of Electric field and Born effective charges.\n            ph_tolerance: dict {\"varname\": value} with the tolerance for the phonon run.\n                None to use AbiPy default.\n            tolwfr: tolerance used to compute WFQ.\n            ddk_tolerance: dict {\"varname\": value} with the tolerance used in the DDK run if with_becs.\n                None to use AbiPy default.\n            shiftq: Q-mesh shift. Multiple shifts are not supported.\n            is_ngqpt: the ngqpt is interpreted as a set of integers defining the q-mesh, otherwise\n                      is an explicit list of q-points\n            remove_wfkq: Remove WKQ files when the children are completed.\n            manager: :class:`TaskManager` object.\n\n        .. note:\n\n            Use k-meshes with one shift and q-meshes that are multiple of ngkpt\n            to decrease the number of WFQ files to be computed.\n        \"\"\"\n        if not isinstance(scf_task, ScfTask):\n            raise TypeError(\"task `%s` does not inherit from ScfTask\" % scf_task)\n\n        shiftq = np.reshape(shiftq, (3,))\n        if is_ngqpt:\n            qpoints = scf_task.input.abiget_ibz(ngkpt=ngqpt, shiftk=shiftq, kptopt=1).points\n        else:\n            qpoints = ngqpt\n\n        new = cls(manager=manager)\n        new.remove_wfkq = remove_wfkq\n        new.wfkq_tasks = []\n        new.wfkq_task_children = collections.defaultdict(list)\n\n        if with_becs:\n            # Add DDK and BECS.\n            new.add_becs_from_scf_task(scf_task, ddk_tolerance, ph_tolerance)\n\n        # Get ngkpt, shift for electrons from input.\n        # Won't try to skip WFQ if multiple shifts or off-diagonal kptrlatt\n        ngkpt, shiftk = scf_task.input.get_ngkpt_shiftk()\n        try_to_skip_wfkq = True\n        if ngkpt is None or len(shiftk) > 1 and is_ngqpt:\n            try_to_skip_wfkq = True\n\n        # TODO: One could avoid kptopt 3 by computing WFK in the IBZ and then rotating.\n        # but this has to be done inside Abinit.\n        for qpt in qpoints:\n            is_gamma = np.sum(qpt ** 2) < 1e-12\n            if with_becs and is_gamma: continue\n\n            # Avoid WFQ if k + q = k (requires ngkpt, multiple shifts are not supported)\n            need_wfkq = True\n            if is_gamma:\n                need_wfkq = False\n            elif try_to_skip_wfkq:\n                # k = (i + shiftk) / ngkpt\n                qinds = np.rint(qpt * ngqpt - shiftq)\n                f = (qinds * ngkpt) % ngqpt\n                need_wfkq = np.any(f != 0)\n\n            if need_wfkq:\n                nscf_inp = scf_task.input.new_with_vars(qpt=qpt, nqpt=1, iscf=-2, kptopt=3, tolwfr=tolwfr)\n                if nband:\n                    nbdbuf = max(2,nband*0.1)\n                    nscf_inp.set_vars(nband=nband+nbdbuf, nbdbuf=nbdbuf)\n                wfkq_task = new.register_nscf_task(nscf_inp, deps={scf_task: [\"DEN\", \"WFK\"]})\n                new.wfkq_tasks.append(wfkq_task)\n\n            multi = scf_task.input.make_ph_inputs_qpoint(qpt, tolerance=ph_tolerance)\n            for ph_inp in multi:\n                deps = {scf_task: \"WFK\", wfkq_task: \"WFQ\"} if need_wfkq else {scf_task: \"WFK\"}\n                #ph_inp[\"prtwf\"] = -1\n                t = new.register_phonon_task(ph_inp, deps=deps)\n                if need_wfkq:\n                    new.wfkq_task_children[wfkq_task].append(t)\n\n        return new", "response": "Constructs a PhononWfkqWork object from a ScfTask object."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef on_ok(self, sender):\n        if self.remove_wfkq:\n            for task in self.wfkq_tasks:\n                if task.status != task.S_OK: continue\n                children = self.wfkq_task_children[task]\n                if all(child.status == child.S_OK for child in children):\n                   path = task.outdir.has_abiext(\"WFQ\")\n                   if path:\n                       self.history.info(\"Removing WFQ: %s\" % path)\n                       os.remove(path)\n\n        return super().on_ok(sender)", "response": "This callback is called when one task reaches status S_OK. It removes the WFKQ file if all its children have reached S_OK."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconstruct a PhononWfkqWork from a DDB and DVDB file.", "response": "def from_den_ddb_dvdb(cls, inp, den_path, ddb_path, dvdb_path, mpiprocs=1, remove_wfkq=True,\n                          qpath=None, with_ddk=True, expand=True, manager=None):\n        \"\"\"\n        Construct a `PhononWfkqWork` from a DDB and DVDB file.\n        For each q found, a WFQ task and an EPH task computing the matrix elements are created.\n        \"\"\"\n        import abipy.abilab as abilab\n\n        # Create file nodes\n        den_file = FileNode(den_path)\n        ddb_file = FileNode(ddb_path)\n        dvdb_file = FileNode(dvdb_path)\n\n        # Create new work\n        new = cls(manager=manager)\n        new.remove_wfkq = remove_wfkq\n        new.wfkq_tasks = []\n        new.wfkq_task_children = collections.defaultdict(list)\n        if manager is None: manager = TaskManager.from_user_config()\n        tm = manager.new_with_fixed_mpi_omp(mpiprocs, 1)\n\n        # Create a WFK task\n        kptopt = 1 if expand else 3\n        nscf_inp = inp.new_with_vars(iscf=-2, kptopt=kptopt)\n        wfk_task = new.register_nscf_task(nscf_inp, deps={den_file: \"DEN\"},manager=tm)\n        new.wfkq_tasks.append(wfk_task)\n        new.wfk_task = wfk_task\n\n        # Read path and regular grid from DDB file\n        with abilab.abiopen(ddb_path) as ddb:\n            q_frac_coords = np.array([k.frac_coords for k in ddb.qpoints])\n            ddb_ngqpt = ddb.guessed_ngqpt\n\n        # If qpath is set, we read the list of q-points to be used to interpolate the DVDB file.\n        # The DVDB and DDB file have to correspond to a regular grid.\n        dvdb = dvdb_file\n        if qpath is None:\n            qpath = q_frac_coords\n        else:\n            interp_inp = inp.new_with_vars(optdriver=7, eph_task=-5, ddb_ngqpt=ddb_ngqpt,\n                                           ph_nqpath=len(qpath), ph_qpath=qpath, prtphdos=0)\n            dvdb = new.register_eph_task(interp_inp, deps={wfk_task: \"WFK\", ddb_file: \"DDB\", dvdb_file: \"DVDB\"},\n                                          manager=tm)\n\n        # Create a WFK expansion task\n        if expand:\n            fbz_nscf_inp = inp.new_with_vars(optdriver=8)\n            fbz_nscf_inp.set_spell_check(False)\n            fbz_nscf_inp.set_vars(wfk_task=\"wfk_fullbz\")\n            tm_serial = manager.new_with_fixed_mpi_omp(1,1)\n            wfk_task = new.register_nscf_task(fbz_nscf_inp, deps={wfk_task: \"WFK\", den_file: \"DEN\"},\n                                              manager=tm_serial)\n            new.wfkq_tasks.append(wfk_task)\n            new.wfk_task = wfk_task\n\n        if with_ddk:\n            kptopt = 3 if expand else 1\n            ddk_inp = inp.new_with_vars(optdriver=8,kptopt=kptopt)\n            ddk_inp.set_spell_check(False)\n            ddk_inp.set_vars(wfk_task=\"wfk_ddk\")\n            ddk_task = new.register_nscf_task(ddk_inp, deps={wfk_task: \"WFK\", den_file: \"DEN\"}, manager=tm)\n            new.wfkq_tasks.append(ddk_task)\n\n        # For each qpoint\n        for qpt in qpath:\n            is_gamma = np.sum(qpt ** 2) < 1e-12\n            if is_gamma:\n                # Create a link from WFK to WFQ on_ok\n                wfkq_task = wfk_task\n                deps = {wfk_task: [\"WFK\",\"WFQ\"], ddb_file: \"DDB\", dvdb: \"DVDB\" }\n            else:\n                # Create a WFQ task\n                nscf_inp = nscf_inp.new_with_vars(kptopt=3, qpt=qpt, nqpt=1)\n                wfkq_task = new.register_nscf_task(nscf_inp, deps={den_file: \"DEN\"}, manager=tm)\n                new.wfkq_tasks.append(wfkq_task)\n                deps = {wfk_task: \"WFK\", wfkq_task: \"WFQ\", ddb_file: \"DDB\", dvdb: \"DVDB\" }\n\n            # Create a EPH task\n            eph_inp = inp.new_with_vars(optdriver=7, prtphdos=0, eph_task=-2, kptopt=3,\n                                        ddb_ngqpt=[1,1,1], nqpt=1, qpt=qpt)\n            t = new.register_eph_task(eph_inp, deps=deps, manager=tm)\n            new.wfkq_task_children[wfkq_task].append(t)\n\n        return new"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef from_phononwfkq_work(cls, phononwfkq_work, nscf_vars={}, remove_wfkq=True, with_ddk=True, manager=None):\n        # Get list of qpoints from the the phonon tasks in this work\n        qpoints = []\n        qpoints_deps = []\n        for task in phononwfkq_work:\n            if isinstance(task,PhononTask):\n                # Store qpoints\n                qpt = task.input.get(\"qpt\", [0,0,0])\n                qpoints.append(qpt)\n                # Store dependencies\n                qpoints_deps.append(task.deps)\n\n        # Create file nodes\n        ddb_path  = phononwfkq_work.outdir.has_abiext(\"DDB\")\n        dvdb_path = phononwfkq_work.outdir.has_abiext(\"DVDB\")\n        ddb_file = FileNode(ddb_path)\n        dvdb_file = FileNode(dvdb_path)\n\n        # Get scf_task from first q-point\n        for dep in qpoints_deps[0]:\n            if isinstance(dep.node,ScfTask) and dep.exts[0] == 'WFK':\n                scf_task = dep.node\n\n        # Create new work\n        new = cls(manager=manager)\n        new.remove_wfkq = remove_wfkq\n        new.wfkq_tasks = []\n        new.wfk_task = []\n\n        # Add one eph task per qpoint\n        for qpt,qpoint_deps in zip(qpoints,qpoints_deps):\n            # Create eph task\n            eph_input = scf_task.input.new_with_vars(optdriver=7, prtphdos=0, eph_task=-2,\n                                                     ddb_ngqpt=[1,1,1], nqpt=1, qpt=qpt)\n            deps = {ddb_file: \"DDB\", dvdb_file: \"DVDB\" }\n            for dep in qpoint_deps:\n                deps[dep.node] = dep.exts[0]\n            # If no WFQ in deps link the WFK with WFQ extension\n            if 'WFQ' not in deps.values():\n                inv_deps = dict((v, k) for k, v in deps.items())\n                wfk_task = inv_deps['WFK']\n                wfk_path = wfk_task.outdir.has_abiext(\"WFK\")\n                # Check if netcdf\n                filename, extension = os.path.splitext(wfk_path)\n                infile = 'out_WFQ' + extension\n                wfq_path = os.path.join(os.path.dirname(wfk_path), infile)\n                if not os.path.isfile(wfq_path): os.symlink(wfk_path, wfq_path)\n                deps[FileNode(wfq_path)] = 'WFQ'\n            new.register_eph_task(eph_input, deps=deps)\n\n        return new", "response": "Construct a GKKPWork object from a PhononWfkqWork object."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nbuilds a new TaskManager object from a ground - state task.", "response": "def from_scf_task(cls, scf_task, ddk_tolerance=None, ph_tolerance=None, manager=None):\n        \"\"\"\n        Build tasks for the computation of Born effective charges from a ground-state task.\n\n        Args:\n            scf_task: ScfTask object.\n            ddk_tolerance: tolerance used in the DDK run if with_becs. None to use AbiPy default.\n            ph_tolerance: dict {\"varname\": value} with the tolerance used in the phonon run.\n                None to use AbiPy default.\n            manager: :class:`TaskManager` object.\n\t\"\"\"\n        new = cls(manager=manager)\n        new.add_becs_from_scf_task(scf_task, ddk_tolerance, ph_tolerance)\n        return new"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nbuilds a DteWork object from a ground - state task.", "response": "def from_scf_task(cls, scf_task, ddk_tolerance=None, manager=None):\n        \"\"\"\n\tBuild a DteWork from a ground-state task.\n\n        Args:\n            scf_task: ScfTask object.\n            ddk_tolerance: tolerance used in the DDK run if with_becs. None to use AbiPy default.\n            manager: :class:`TaskManager` object.\n\t\"\"\"\n        if not isinstance(scf_task, ScfTask):\n            raise TypeError(\"task `%s` does not inherit from ScfTask\" % scf_task)\n\n        new = cls(manager=manager)\n\n        # DDK calculations\n        multi_ddk = scf_task.input.make_ddk_inputs(tolerance=ddk_tolerance)\n\n        ddk_tasks = []\n        for ddk_inp in multi_ddk:\n            ddk_task = new.register_ddk_task(ddk_inp, deps={scf_task: \"WFK\"})\n            ddk_tasks.append(ddk_task)\n\n        # Build the list of inputs for electric field perturbation\n        # Each task is connected to all the previous DDK, DDE task and to the scf_task.\n        multi_dde = scf_task.input.make_dde_inputs(use_symmetries=False)\n\n        # To compute the nonlinear coefficients all the directions of the perturbation\n        # have to be taken in consideration\n        # DDE calculations\n        dde_tasks = []\n        dde_deps = {ddk_task: \"DDK\" for ddk_task in ddk_tasks}\n        dde_deps.update({scf_task: \"WFK\"})\n        for dde_inp in multi_dde:\n            dde_task = new.register_dde_task(dde_inp, deps=dde_deps)\n            dde_tasks.append(dde_task)\n\n        # DTE calculations\n        dte_deps = {scf_task: \"WFK DEN\"}\n        dte_deps.update({dde_task: \"1WF 1DEN\" for dde_task in dde_tasks})\n\n        multi_dte = scf_task.input.make_dte_inputs()\n        dte_tasks = []\n        for dte_inp in multi_dte:\n             dte_task = new.register_dte_task(dte_inp, deps=dte_deps)\n             dte_tasks.append(dte_task)\n\n        return new"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef create_saturated_interstitial_structure( interstitial_def, dist_tol=0.1):\n    sga = SpacegroupAnalyzer( interstitial_def.bulk_structure.copy())\n    sg_ops = sga.get_symmetry_operations( cartesian=True)\n\n    # copy bulk structure to make saturated interstitial structure out of\n    # artificially lower distance_tolerance to allow for distinct interstitials\n    # with lower symmetry to be replicated - This is OK because one would never\n    # actually use this structure for a practical calcualtion...\n    saturated_defect_struct = interstitial_def.bulk_structure.copy()\n    saturated_defect_struct.DISTANCE_TOLERANCE = dist_tol\n\n    for sgo in sg_ops:\n        new_interstit_coords = sgo.operate( interstitial_def.site.coords[:])\n        poss_new_site = PeriodicSite(\n                interstitial_def.site.specie,\n                new_interstit_coords,\n                saturated_defect_struct.lattice,\n                to_unit_cell=True,\n                coords_are_cartesian=True)\n        try:\n            #will raise value error if site already exists in structure\n            saturated_defect_struct.append(\n                        poss_new_site.specie, poss_new_site.coords,\n                        coords_are_cartesian=True, validate_proximity=True)\n        except ValueError:\n            pass\n\n    # do final space group analysis to make sure symmetry not lowered by saturating defect structure\n    saturated_sga = SpacegroupAnalyzer( saturated_defect_struct)\n    if saturated_sga.get_space_group_number() != sga.get_space_group_number():\n        raise ValueError(\"Warning! Interstitial sublattice generation \"\n                         \"has changed space group symmetry. I recommend \"\n                         \"reducing dist_tol and trying again...\")\n\n    return saturated_defect_struct", "response": "This function creates a saturated interstitial structure from an interstitial structure."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef generate_defect_structure(self, supercell=(1, 1, 1)):\n        defect_structure = self.bulk_structure.copy()\n        defect_structure.make_supercell(supercell)\n\n        #create a trivial defect structure to find where supercell transformation moves the lattice\n        struct_for_defect_site = Structure( self.bulk_structure.copy().lattice,\n                                             [self.site.specie],\n                                             [self.site.frac_coords],\n                                             to_unit_cell=True)\n        struct_for_defect_site.make_supercell(supercell)\n        defect_site = struct_for_defect_site[0]\n\n        poss_deflist = sorted(\n            defect_structure.get_sites_in_sphere(defect_site.coords, 2, include_index=True), key=lambda x: x[1])\n        defindex = poss_deflist[0][2]\n        defect_structure.remove_sites([defindex])\n        defect_structure.set_charge(self.charge)\n        return defect_structure", "response": "Generate a Defective Vacancy structure with supercell transformation"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the multiplicity of a defect site within the structure", "response": "def multiplicity(self):\n        \"\"\"\n        Returns the multiplicity of a defect site within the structure (needed for concentration analysis)\n        \"\"\"\n        sga = SpacegroupAnalyzer(self.bulk_structure)\n        periodic_struc = sga.get_symmetrized_structure()\n        poss_deflist = sorted(\n            periodic_struc.get_sites_in_sphere(self.site.coords, 2, include_index=True), key=lambda x: x[1])\n        defindex = poss_deflist[0][2]\n\n        equivalent_sites = periodic_struc.find_equivalent_sites(self.bulk_structure[defindex])\n        return len(equivalent_sites)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef generate_defect_structure(self, supercell=(1, 1, 1)):\n        defect_structure = self.bulk_structure.copy()\n        defect_structure.make_supercell(supercell)\n\n        # consider modifying velocity property to make sure defect site is decorated\n        # consistently with bulk structure for final defect_structure\n        defect_properties = self.site.properties.copy()\n        if ('velocities' in self.bulk_structure.site_properties) and \\\n            'velocities' not in defect_properties:\n            if all( vel == self.bulk_structure.site_properties['velocities'][0]\n                    for vel in self.bulk_structure.site_properties['velocities']):\n                defect_properties['velocities'] = self.bulk_structure.site_properties['velocities'][0]\n            else:\n                raise ValueError(\"No velocity property specified for defect site and \"\n                                 \"bulk_structure velocities are not homogeneous. Please specify this \"\n                                 \"property within the initialized defect_site object.\")\n\n        #create a trivial defect structure to find where supercell transformation moves the lattice\n        site_properties_for_fake_struct = {prop: [val] for prop,val in defect_properties.items()}\n        struct_for_defect_site = Structure( self.bulk_structure.copy().lattice,\n                                             [self.site.specie],\n                                             [self.site.frac_coords],\n                                             to_unit_cell=True,\n                                             site_properties = site_properties_for_fake_struct)\n        struct_for_defect_site.make_supercell(supercell)\n        defect_site = struct_for_defect_site[0]\n\n        poss_deflist = sorted(\n            defect_structure.get_sites_in_sphere(defect_site.coords, 2, include_index=True), key=lambda x: x[1])\n        defindex = poss_deflist[0][2]\n\n        subsite = defect_structure.pop(defindex)\n        defect_structure.append(self.site.specie.symbol, subsite.coords, coords_are_cartesian=True,\n                                properties = defect_site.properties)\n        defect_structure.set_charge(self.charge)\n        return defect_structure", "response": "Generate a defect structure for the given supercell."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a name for this defect", "response": "def name(self):\n        \"\"\"\n        Returns a name for this defect\n        \"\"\"\n        poss_deflist = sorted(\n            self.bulk_structure.get_sites_in_sphere(self.site.coords, 2, include_index=True), key=lambda x: x[1])\n        defindex = poss_deflist[0][2]\n        return \"Sub_{}_on_{}_mult{}\".format(self.site.specie, self.bulk_structure[defindex].specie, self.multiplicity)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ngenerate a defect structure for the given supercell.", "response": "def generate_defect_structure(self, supercell=(1, 1, 1)):\n        \"\"\"\n        Returns Defective Interstitial structure, decorated with charge\n        Args:\n            supercell (int, [3x1], or [[]] (3x3)): supercell integer, vector, or scaling matrix\n        \"\"\"\n        defect_structure = self.bulk_structure.copy()\n        defect_structure.make_supercell(supercell)\n\n        # consider modifying velocity property to make sure defect site is decorated\n        # consistently with bulk structure for final defect_structure\n        defect_properties = self.site.properties.copy()\n        if ('velocities' in self.bulk_structure.site_properties) and \\\n            'velocities' not in defect_properties:\n            if all( vel == self.bulk_structure.site_properties['velocities'][0]\n                    for vel in self.bulk_structure.site_properties['velocities']):\n                defect_properties['velocities'] = self.bulk_structure.site_properties['velocities'][0]\n            else:\n                raise ValueError(\"No velocity property specified for defect site and \"\n                                 \"bulk_structure velocities are not homogeneous. Please specify this \"\n                                 \"property within the initialized defect_site object.\")\n\n        #create a trivial defect structure to find where supercell transformation moves the defect site\n        site_properties_for_fake_struct = {prop: [val] for prop,val in defect_properties.items()}\n        struct_for_defect_site = Structure( self.bulk_structure.copy().lattice,\n                                             [self.site.specie],\n                                             [self.site.frac_coords],\n                                             to_unit_cell=True,\n                                             site_properties = site_properties_for_fake_struct)\n        struct_for_defect_site.make_supercell(supercell)\n        defect_site = struct_for_defect_site[0]\n\n        defect_structure.append(self.site.specie.symbol, defect_site.coords, coords_are_cartesian=True,\n                                properties = defect_site.properties)\n        defect_structure.set_charge(self.charge)\n        return defect_structure"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef multiplicity(self):\n        if self._multiplicity is None:\n            # generate multiplicity based on space group symmetry operations performed on defect coordinates\n            try:\n                d_structure = create_saturated_interstitial_structure(self)\n            except ValueError:\n                logger.debug('WARNING! Multiplicity was not able to be calculated adequately '\n                             'for interstitials...setting this to 1 and skipping for now...')\n                return 1\n\n            sga = SpacegroupAnalyzer(d_structure)\n            periodic_struc = sga.get_symmetrized_structure()\n            poss_deflist = sorted(\n                periodic_struc.get_sites_in_sphere(self.site.coords, 2, include_index=True),\n                key=lambda x: x[1])\n            defindex = poss_deflist[0][2]\n\n            equivalent_sites = periodic_struc.find_equivalent_sites(periodic_struc[defindex])\n            return len(equivalent_sites)\n\n        else:\n            return self._multiplicity", "response": "Returns the multiplicity of a defect site within the structure"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a name for this defect.", "response": "def name(self):\n        \"\"\"\n        Returns a name for this defect\n        \"\"\"\n        if self.site_name:\n            return \"Int_{}_{}_mult{}\".format(self.site.specie, self.site_name, self.multiplicity)\n        else:\n            return \"Int_{}_mult{}\".format(self.site.specie, self.multiplicity)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreconstituting a DefectEntry object from a dict representation created using as_dict().", "response": "def from_dict(cls, d):\n        \"\"\"\n        Reconstitute a DefectEntry object from a dict representation created using\n        as_dict().\n         Args:\n            d (dict): dict representation of DefectEntry.\n         Returns:\n            DefectEntry object\n        \"\"\"\n        defect = MontyDecoder().process_decoded( d[\"defect\"])\n        uncorrected_energy = d[\"uncorrected_energy\"]\n        corrections = d.get(\"corrections\", None)\n        parameters = d.get(\"parameters\", None)\n        entry_id = d.get(\"entry_id\", None)\n\n        return cls(defect, uncorrected_energy, corrections=corrections,\n                   parameters=parameters, entry_id=entry_id)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the total energy of the entry in the entry.", "response": "def energy(self):\n        \"\"\"\n        Returns the *corrected* energy of the entry\n        \"\"\"\n        return self.uncorrected_energy + np.sum(list(self.corrections.values()))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef formation_energy(self, chemical_potentials=None, fermi_level=0):\n        chemical_potentials = chemical_potentials if chemical_potentials else {}\n\n        chempot_correction = sum([\n            chem_pot * (self.bulk_structure.composition[el] - self.defect.defect_composition[el])\n            for el, chem_pot in chemical_potentials.items()\n        ])\n\n        formation_energy = self.energy + chempot_correction\n\n        if \"vbm\" in self.parameters:\n            formation_energy += self.charge * (self.parameters[\"vbm\"] + fermi_level)\n        else:\n            formation_energy += self.charge * fermi_level\n\n        return formation_energy", "response": "Computes the formation energy for a defect taking into account a given chemical potential and fermi_level."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the defect concentration for a temperature and Fermi level.", "response": "def defect_concentration(self, chemical_potentials, temperature=300, fermi_level=0.0):\n        \"\"\"\n        Get the defect concentration for a temperature and Fermi level.\n        Args:\n            temperature:\n                the temperature in K\n            fermi_level:\n                the fermi level in eV (with respect to the VBM)\n        Returns:\n            defects concentration in cm^-3\n        \"\"\"\n        n = self.multiplicity * 1e24 / self.defect.bulk_structure.volume\n        conc = n * np.exp(-1.0 * self.formation_energy(chemical_potentials, fermi_level=fermi_level) /\n                          (kb * temperature))\n\n        return conc"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef correct_entry(self, entry):\n        entry.correction.update(self.get_correction(entry))\n        return entry", "response": "Corrects a single entry."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_charge_transfer(self, atom_index):\n        if self.potcar is None:\n            raise ValueError(\"POTCAR must be supplied in order to calculate \"\n                             \"charge transfer!\")\n        potcar_indices = []\n        for i, v in enumerate(self.natoms):\n            potcar_indices += [i] * v\n        nelect = self.potcar[potcar_indices[atom_index]].nelectrons\n        return self.data[atom_index][\"charge\"] - nelect", "response": "Returns the charge transferred for a particular atom. Requires POTCAR to be supplied."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn an oxidation state decorated structure. Requires POTCAR to be supplied.", "response": "def get_oxidation_state_decorated_structure(self):\n        \"\"\"\n        Returns an oxidation state decorated structure.\n\n        Returns:\n            Returns an oxidation state decorated structure. Requires POTCAR\n            to be supplied.\n        \"\"\"\n        structure = self.chgcar.structure\n        charges = [-self.get_charge_transfer(i)\n                   for i in range(len(structure))]\n        structure.add_oxidation_state_by_site(charges)\n        return structure"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a new instance of the class AECC from a path name.", "response": "def from_path(cls, path, suffix=\"\"):\n        \"\"\"\n        Convenient constructor that takes in the path name of VASP run\n        to perform Bader analysis.\n\n        Args:\n            path (str): Name of directory where VASP output files are\n                stored.\n            suffix (str): specific suffix to look for (e.g. '.relax1'\n                for 'CHGCAR.relax1.gz').\n\n        \"\"\"\n\n        def _get_filepath(filename):\n            name_pattern = filename + suffix + '*' if filename != 'POTCAR' \\\n                else filename + '*'\n            paths = glob.glob(os.path.join(path, name_pattern))\n            fpath = None\n            if len(paths) >= 1:\n                # using reverse=True because, if multiple files are present,\n                # they likely have suffixes 'static', 'relax', 'relax2', etc.\n                # and this would give 'static' over 'relax2' over 'relax'\n                # however, better to use 'suffix' kwarg to avoid this!\n                paths.sort(reverse=True)\n                warning_msg = \"Multiple files detected, using %s\" \\\n                              % os.path.basename(paths[0]) if len(paths) > 1 \\\n                    else None\n                fpath = paths[0]\n            else:\n                warning_msg = \"Could not find %s\" % filename\n                if filename in ['AECCAR0', 'AECCAR2']:\n                    warning_msg += \", cannot calculate charge transfer.\"\n                elif filename == \"POTCAR\":\n                    warning_msg += \", interpret Bader results with caution.\"\n            if warning_msg:\n                warnings.warn(warning_msg)\n            return fpath\n\n        chgcar_filename = _get_filepath(\"CHGCAR\")\n        if chgcar_filename is None:\n            raise IOError(\"Could not find CHGCAR!\")\n        potcar_filename = _get_filepath(\"POTCAR\")\n        aeccar0 = _get_filepath(\"AECCAR0\")\n        aeccar2 = _get_filepath(\"AECCAR2\")\n        if (aeccar0 and aeccar2):\n            # `chgsum.pl AECCAR0 AECCAR2` equivalent to obtain chgref_file\n            chgref = Chgcar.from_file(aeccar0) + Chgcar.from_file(aeccar2)\n            chgref_filename = \"CHGREF\"\n            chgref.write_file(chgref_filename)\n        else:\n            chgref_filename = None\n        return cls(chgcar_filename, potcar_filename=potcar_filename,\n                   chgref_filename=chgref_filename)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the derivatives of y at the points xs ys", "response": "def get_derivatives(xs, ys, fd=False):\n    \"\"\"\n    return the derivatives of y(x) at the points x\n    if scipy is available a spline is generated to calculate the derivatives\n    if scipy is not available the left and right slopes are calculated, if both exist the average is returned\n    putting fd to zero always returns the finite difference slopes\n    \"\"\"\n    try:\n        if fd:\n            raise SplineInputError('no spline wanted')\n        if len(xs) < 4:\n            er = SplineInputError('too few data points')\n            raise er\n        from scipy.interpolate import UnivariateSpline\n        spline = UnivariateSpline(xs, ys)\n        d = spline.derivative(1)(xs)\n    except (ImportError, SplineInputError):\n        d = []\n        m, left, right = 0, 0, 0\n        for n in range(0, len(xs), 1):\n            try:\n                left = (ys[n] - ys[n-1]) / (xs[n] - xs[n-1])\n                m += 1\n            except IndexError:\n                pass\n            try:\n                right = (ys[n+1] - ys[n]) / (xs[n+1] - xs[n])\n                m += 1\n            except IndexError:\n                pass\n            d.append(left + right / m)\n    return d"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef reciprocal(x, a, b, n):\n    if n < 1:\n        n = 1\n    elif n > 5:\n        n = 5\n    if isinstance(x, list):\n        y_l = []\n        for x_v in x:\n            y_l.append(a + b / x_v ** n)\n        y = np.array(y_l)\n    else:\n        y = a + b / x ** n\n    return y", "response": "reciprocal function to fit convergence data"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef p0_reciprocal(xs, ys):\n    a0 = ys[len(ys) - 1]\n    b0 = ys[0]*xs[0] - a0*xs[0]\n    return [a0, b0, 1]", "response": "predictor for first guess for reciprocal\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef single_reciprocal(x, a, b, c):\n    if isinstance(x, list):\n        y_l = []\n        for x_v in x:\n            y_l.append(a + b / (x_v - c))\n        y = np.array(y_l)\n    else:\n        y = a + b / (x - c)\n    return y", "response": "reciprocal function to fit convergence data"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef simple_reciprocal(x, a, b):\n    if isinstance(x, list):\n        y_l = []\n        for x_v in x:\n            y_l.append(a + b / x_v)\n        y = np.array(y_l)\n    else:\n        y = a + b / x\n    return y", "response": "simple reciprocal function to fit convergence data"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef extrapolate_reciprocal(xs, ys, n, noise):\n    if len(xs) > 4 and noise:\n        y1 = (ys[-3] + ys[-4]) / 2\n        y2 = (ys[-1] + ys[-2]) / 2\n        x1 = (xs[-3] + xs[-4]) / 2\n        x2 = (xs[-1] + xs[-2]) / 2\n        try:\n            b = (y1 - y2) / (1/x1**n - 1/x2**n)\n            a = y2 - b / x2**n\n        except IndexError:\n            print_and_raise_error(xs, ys, 'extrapolate_reciprocal')\n    else:\n        try:\n            b = (ys[-2] - ys[-1]) / (1/(xs[-2])**n - 1/(xs[-1])**n)\n            a = ys[-1] - b / (xs[-1])**n\n        except IndexError:\n            print_and_raise_error(xs, ys, 'extrapolate_reciprocal')\n    return [a, b, n]", "response": "extrapolate_reciprocal returns the parameters such that a + b / x^n hits the last two data points\n            a + b n hits the last two data points\n            b = n - 1"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nmeasure the quality of a fit", "response": "def measure(function, xs, ys, popt, weights):\n    \"\"\"\n    measure the quality of a fit\n    \"\"\"\n    m = 0\n    n = 0\n    for x in xs:\n        try:\n            if len(popt) == 2:\n                m += (ys[n] - function(x, popt[0], popt[1]))**2 * weights[n]\n            elif len(popt) == 3:\n                m += (ys[n] - function(x, popt[0], popt[1], popt[2]))**2 * weights[n]\n            else:\n                raise NotImplementedError\n            n += 1\n        except IndexError:\n            raise RuntimeError('y does not exist for x = ', x, ' this should not happen')\n\n    return m"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef multi_curve_fit(xs, ys, verbose):\n    #functions = {exponential: p0_exponential, reciprocal: p0_reciprocal, single_reciprocal: p0_single_reciprocal}\n    functions = {\n        exponential: p0_exponential,\n        reciprocal: p0_reciprocal,\n        #single_reciprocal: p0_single_reciprocal,\n        simple_reciprocal: p0_simple_reciprocal,\n        simple_2reciprocal: p0_simple_2reciprocal,\n        simple_4reciprocal: p0_simple_4reciprocal,\n        simple_5reciprocal: p0_simple_5reciprocal\n    }\n    from scipy.optimize import curve_fit\n    fit_results = {}\n    best = ['', np.inf]\n    for function in functions:\n        try:\n            weights = get_weights(xs, ys)\n            popt, pcov = curve_fit(function, xs, ys, functions[function](xs, ys), maxfev=8000, sigma=weights)\n            pcov = []\n            m = measure(function, xs, ys, popt, weights)\n            fit_results.update({function: {'measure': m, 'popt': popt, 'pcov': pcov}})\n            for f in fit_results:\n                if fit_results[f]['measure'] <= best[1]:\n                    best = f, fit_results[f]['measure']\n            if verbose:\n                print(str(function), m)\n        except RuntimeError:\n            print('no fit found for ', function)\n\n    return fit_results[best[0]]['popt'], fit_results[best[0]]['pcov'], best", "response": "fit multiple functions to the x y data return the best fit\n   "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef multi_reciprocal_extra(xs, ys, noise=False):\n    ns = np.linspace(0.5, 6.0, num=56)\n    best = ['', np.inf]\n    fit_results = {}\n    weights = get_weights(xs, ys)\n    for n in ns:\n        popt = extrapolate_reciprocal(xs, ys, n, noise)\n        m = measure(reciprocal, xs, ys, popt, weights)\n        pcov = []\n        fit_results.update({n: {'measure': m, 'popt': popt, 'pcov': pcov}})\n    for n in fit_results:\n        if fit_results[n]['measure'] <= best[1]:\n            best = reciprocal, fit_results[n]['measure'], n\n    return fit_results[best[2]]['popt'], fit_results[best[2]]['pcov'], best", "response": "Calculates for a series of powers ns the parameters for which the last two points are at the curve. Returns the best fit."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef print_plot_line(function, popt, xs, ys, name, tol=0.05, extra=''):\n    idp = id_generator()\n    f = open('convdat.'+str(idp), mode='w')\n    for n in range(0, len(ys), 1):\n        f.write(str(xs[n]) + ' ' + str(ys[n]) + '\\n')\n    f.close()\n    tol = abs(tol)\n    line = \"plot 'convdat.%s' pointsize 4 lt 0, \" % idp\n    line += '%s lt 3, %s lt 4, %s lt 4, ' % (popt[0], popt[0] - tol, popt[0] + tol)\n    if function is exponential:\n        line += \"%s + %s * %s ** -x\" % (popt[0], popt[1], min(max(1.00001, popt[2]), 1.2))\n    elif function is reciprocal:\n        line += \"%s + %s / x**%s\" % (popt[0], popt[1], min(max(0.5, popt[2]), 6))\n    elif function is single_reciprocal:\n        line += \"%s + %s / (x - %s)\" % (popt[0], popt[1], popt[2])\n    elif function is simple_reciprocal:\n        line += \"%s + %s / x\" % (popt[0], popt[1])\n    elif function is simple_2reciprocal:\n        line += \"%s + %s / x**2\" % (popt[0], popt[1])\n    elif function is simple_4reciprocal:\n        line += \"%s + %s / x**4\" % (popt[0], popt[1])\n    elif function is simple_5reciprocal:\n        line += \"%s + %s / x**0.5\" % (popt[0], popt[1])\n    else:\n        print(function, ' no plot ')\n\n    with open('plot-fits', mode='a') as f:\n        f.write('set title \"' + name + ' - ' + extra + '\"\\n')\n        f.write(\"set output '\" + name + '-' + idp + \".gif'\" + '\\n')\n        f.write(\"set yrange [\" + str(popt[0] - 5 * tol) + ':' + str(popt[0] + 5 * tol)+']\\n')\n        f.write(line + '\\n')\n        f.write('pause -1 \\n')", "response": "print the line to plot the x y data with the fitted function"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ntest it and at which dy ( x ) / dx < tol for all x < x_value dy ( x ) < tol for all x < x_value dy < tol for all x < x_value dy < tol for all x < x_value dy < tol for all x < x_value dy < tol for all x < x_value dy < tol for all x < x_value dy < tol for all x < x_value dy < tol for all x < x_value", "response": "def determine_convergence(xs, ys, name, tol=0.0001, extra='', verbose=False, mode='extra', plots=True):\n    \"\"\"\n    test it and at which x_value dy(x)/dx < tol for all x >= x_value, conv is true is such a x_value exists.\n    \"\"\"\n    if len(xs) != len(ys):\n        raise RuntimeError('the range of x and y are not equal')\n    conv = False\n    x_value = float('inf')\n    y_value = None\n    n_value = None\n    popt = [None, None, None]\n    if len(xs) > 2:\n        ds = get_derivatives(xs[0:len(ys)], ys)\n        try:\n            if None not in ys:\n                if mode == 'fit':\n                    popt, pcov, func = multi_curve_fit(xs, ys, verbose)\n                elif mode == 'extra':\n                    res = multi_reciprocal_extra(xs, ys)\n                    if res is not None:\n                        popt, pcov, func = multi_reciprocal_extra(xs, ys)\n                    else:\n                        print(xs, ys)\n                        popt, pcov = None, None\n                elif mode == 'extra_noise':\n                    popt, pcov, func = multi_reciprocal_extra(xs, ys, noise=True)\n                else:\n                    raise NotImplementedError('unknown mode for test conv')\n                if func[1] > abs(tol):\n                    print('warning function ', func[0], ' as the best fit but not a good fit: ', func[1])\n                # todo print this to file via a method in helper, as dict\n                if plots:\n                    with open(name+'.fitdat', mode='a') as f:\n                        f.write('{')\n                        f.write('\"popt\": ' + str(popt) + ', ')\n                        f.write('\"pcov\": ' + str(pcov) + ', ')\n                        f.write('\"data\": [')\n                        for n in range(0, len(ys), 1):\n                            f.write('[' + str(xs[n]) + ' ' + str(ys[n]) + ']')\n                        f.write(']}\\n')\n\n                    print_plot_line(func[0], popt, xs, ys, name, tol=tol, extra=extra)\n\n        except ImportError:\n            popt, pcov = None, None\n        for n in range(0, len(ds), 1):\n            if verbose:\n                print(n, ys[n])\n                print(ys)\n            if tol < 0:\n                if popt[0] is not None:\n                    test = abs(popt[0] - ys[n])\n                else:\n                    test = float('inf')\n            else:\n                test = abs(ds[n])\n            if verbose:\n                print(test)\n            if test < abs(tol):\n                if verbose:\n                    print('converged')\n                conv = True\n                if xs[n] < x_value:\n                    x_value = xs[n]\n                    y_value = ys[n]\n                    n_value = n\n            else:\n                if verbose:\n                    print('not converged')\n                conv = False\n                x_value = float('inf')\n        if n_value is None:\n            return [conv, x_value, y_value, n_value, popt[0], None]\n        else:\n            return [conv, x_value, y_value, n_value, popt[0], ds[n_value]]\n    else:\n        return [conv, x_value, y_value, n_value, popt[0], None]"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nlisting all prime factors of a given natural integer from greatest to smallest", "response": "def prime_factors(n):\n    \"\"\"Lists prime factors of a given natural integer, from greatest to smallest\n    :param n: Natural integer\n    :rtype : list of all prime factors of the given natural n\n    \"\"\"\n    i = 2\n    while i <= sqrt(n):\n        if n % i == 0:\n            l = prime_factors(n/i)\n            l.append(i)\n            return l\n        i += 1\n    return [n]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _factor_generator(n):\n    p = prime_factors(n)\n    factors = {}\n    for p1 in p:\n        try:\n            factors[p1] += 1\n        except KeyError:\n            factors[p1] = 1\n    return factors", "response": "Returns the prime factors and their multiplicity of a natural integer."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the list of divisors of n in ascending order", "response": "def divisors(n):\n    \"\"\"\n    From a given natural integer, returns the list of divisors in ascending order\n    :param n: Natural integer\n    :return: List of divisors of n in ascending order\n    \"\"\"\n    factors = _factor_generator(n)\n    _divisors = []\n    listexponents = [[k**x for x in range(0, factors[k]+1)] for k in list(factors.keys())]\n    listfactors = _cartesian_product(listexponents)\n    for f in listfactors:\n        _divisors.append(reduce(lambda x, y: x*y, f, 1))\n    _divisors.sort()\n    return _divisors"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ngive a tuple of tuples generate a delimited string form.", "response": "def str_delimited(results, header=None, delimiter=\"\\t\"):\n    \"\"\"\n    Given a tuple of tuples, generate a delimited string form.\n    >>> results = [[\"a\",\"b\",\"c\"],[\"d\",\"e\",\"f\"],[1,2,3]]\n    >>> print(str_delimited(results,delimiter=\",\"))\n    a,b,c\n    d,e,f\n    1,2,3\n\n    Args:\n        result: 2d sequence of arbitrary types.\n        header: optional header\n\n    Returns:\n        Aligned string output in a table-like format.\n    \"\"\"\n    returnstr = \"\"\n    if header is not None:\n        returnstr += delimiter.join(header) + \"\\n\"\n    return returnstr + \"\\n\".join([delimiter.join([str(m) for m in result])\n                                  for result in results])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef formula_double_format(afloat, ignore_ones=True, tol=1e-8):\n    if ignore_ones and afloat == 1:\n        return \"\"\n    elif abs(afloat - int(afloat)) < tol:\n        return str(int(afloat))\n    else:\n        return str(round(afloat, 8))", "response": "This function is used to format the amount of a single formula."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconverts a formula with unicode subscripts to Fe2O3.", "response": "def unicodeify(formula):\n    \"\"\"\n    Generates a formula with unicode subscripts, e.g. Fe2O3 is transformed\n    to Fe\u2082O\u2083. Does not support formulae with decimal points.\n\n    :param formula:\n    :return:\n    \"\"\"\n\n    if '.' in formula:\n        raise ValueError('No unicode character exists for subscript period.')\n\n    subscript_unicode_map = {0: '\u2080', 1: '\u2081', 2: '\u2082', 3: '\u2083', 4: '\u2084',\n                             5: '\u2085', 6: '\u2086', 7: '\u2087', 8: '\u2088', 9: '\u2089'}\n\n    for original_subscript, subscript_unicode in subscript_unicode_map.items():\n        formula = formula.replace(str(original_subscript), subscript_unicode)\n\n    return formula"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef stream_has_colours(stream):\n    if not hasattr(stream, \"isatty\"):\n        return False\n\n    if not stream.isatty():\n        return False  # auto color only on TTYs\n    try:\n        import curses\n        curses.setupterm()\n        return curses.tigetnum(\"colors\") > 2\n    except:\n        return False", "response": "Returns True if the given stream supports colours."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a disordered formula for a single structure.", "response": "def disordered_formula(disordered_struct, symbols=('x', 'y', 'z'), fmt='plain'):\n    \"\"\"\n    Returns a formula of a form like AxB1-x (x=0.5)\n    for disordered structures. Will only return a\n    formula for disordered structures with one\n    kind of disordered site at present.\n\n    Args:\n        disordered_struct: a disordered structure\n        symbols: a tuple of characters to use for\n        subscripts, by default this is ('x', 'y', 'z')\n        but if you have more than three disordered\n        species more symbols will need to be added\n        fmt (str): 'plain', 'HTML' or 'LaTeX'\n\n    Returns (str): a disordered formula string\n    \"\"\"\n\n    # this is in string utils and not in\n    # Composition because we need to have access\n    # to site occupancies to calculate this, so\n    # have to pass the full structure as an argument\n    # (alternatively this could be made a method on\n    # Structure)\n    from pymatgen.core.composition import Composition\n    from pymatgen.core.periodic_table import get_el_sp\n\n    if disordered_struct.is_ordered:\n        raise ValueError(\"Structure is not disordered, \"\n                         \"so disordered formula not defined.\")\n\n    disordered_site_compositions = {site.species\n                                    for site in disordered_struct if not site.is_ordered}\n\n    if len(disordered_site_compositions) > 1:\n        # this probably won't happen too often\n        raise ValueError(\"Ambiguous how to define disordered \"\n                         \"formula when more than one type of disordered \"\n                         \"site is present.\")\n    disordered_site_composition = disordered_site_compositions.pop()\n\n    disordered_species = {str(sp) for sp, occu in disordered_site_composition.items()}\n\n    if len(disordered_species) > len(symbols):\n        # this probably won't happen too often either\n        raise ValueError(\"Not enough symbols to describe disordered composition: \"\n                         \"{}\".format(symbols))\n    symbols = list(symbols)[0:len(disordered_species) - 1]\n\n    comp = disordered_struct.composition.get_el_amt_dict().items()\n    # sort by electronegativity, as per composition\n    comp = sorted(comp, key=lambda x: get_el_sp(x[0]).X)\n\n    disordered_comp = []\n    variable_map = {}\n\n    total_disordered_occu = sum([occu for sp, occu in comp\n                                 if str(sp) in disordered_species])\n\n    # composition to get common factor\n    factor_comp = disordered_struct.composition.as_dict()\n    factor_comp['X'] = total_disordered_occu\n    for sp in disordered_species:\n        del factor_comp[str(sp)]\n    factor_comp = Composition.from_dict(factor_comp)\n    factor = factor_comp.get_reduced_formula_and_factor()[1]\n\n    total_disordered_occu /= factor\n    remainder = \"{}-{}\".format(formula_double_format(total_disordered_occu, ignore_ones=False),\n                               '-'.join(symbols))\n\n    for sp, occu in comp:\n        sp = str(sp)\n        if sp not in disordered_species:\n            disordered_comp.append((sp, formula_double_format(occu/factor)))\n        else:\n            if len(symbols) > 0:\n                symbol = symbols.pop(0)\n                disordered_comp.append((sp, symbol))\n                variable_map[symbol] = occu / total_disordered_occu / factor\n            else:\n                disordered_comp.append((sp, remainder))\n\n    if fmt == 'LaTeX':\n        sub_start = \"_{\"\n        sub_end = \"}\"\n    elif fmt == 'HTML':\n        sub_start = \"<sub>\"\n        sub_end = \"</sub>\"\n    elif fmt != 'plain':\n        raise ValueError(\"Unsupported output format, \"\n                         \"choose from: LaTeX, HTML, plain\")\n\n    disordered_formula = []\n    for sp, occu in disordered_comp:\n        disordered_formula.append(sp)\n        if occu:  # can be empty string if 1\n            if fmt != 'plain':\n                disordered_formula.append(sub_start)\n            disordered_formula.append(occu)\n            if fmt != 'plain':\n                disordered_formula.append(sub_end)\n    disordered_formula.append(\" \")\n    disordered_formula += [\"{}={} \".format(k, formula_double_format(v))\n                           for k, v in variable_map.items()]\n\n    comp = disordered_struct.composition\n\n    return \"\".join(map(str, disordered_formula))[0:-1]"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncomparing the bond table of the two molecules.", "response": "def are_equal(self, mol1, mol2):\n        \"\"\"\n        Compare the bond table of the two molecules.\n\n        Args:\n            mol1: first molecule. pymatgen Molecule object.\n            mol2: second moleculs. pymatgen Molecule objec.\n        \"\"\"\n        b1 = set(self._get_bonds(mol1))\n        b2 = set(self._get_bonds(mol2))\n        return b1 == b2"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _get_bonds(self, mol):\n        num_atoms = len(mol)\n        # index starting from 0\n        if self.ignore_ionic_bond:\n            covalent_atoms = [i for i in range(num_atoms) if mol.species[i].symbol not in self.ionic_element_list]\n        else:\n            covalent_atoms = list(range(num_atoms))\n        all_pairs = list(itertools.combinations(covalent_atoms, 2))\n        pair_dists = [mol.get_distance(*p) for p in all_pairs]\n        elements = mol.composition.as_dict().keys()\n        unavailable_elements = list(set(elements) -\n                                    set(self.covalent_radius.keys()))\n        if len(unavailable_elements) > 0:\n            raise ValueError(\"The covalent radius for element {} is not \"\n                             \"available\".format(unavailable_elements))\n        bond_13 = self.get_13_bonds(self.priority_bonds)\n        max_length = [(self.covalent_radius[mol.sites[p[0]].specie.symbol] +\n                       self.covalent_radius[mol.sites[p[1]].specie.symbol]) *\n                      (1 + (self.priority_cap if p in self.priority_bonds\n                            else (self.bond_length_cap if p not in bond_13\n                                  else self.bond_13_cap))) *\n                      (0.1 if (self.ignore_halogen_self_bond and p not in self.priority_bonds and\n                               mol.sites[p[0]].specie.symbol in self.halogen_list and\n                               mol.sites[p[1]].specie.symbol in self.halogen_list)\n                       else 1.0)\n                      for p in all_pairs]\n\n        bonds = [bond\n                 for bond, dist, cap in zip(all_pairs, pair_dists, max_length)\n                 if dist <= cap]\n        return bonds", "response": "Find all the bonds in a molecule."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef compare_sym_bands(bands_obj, bands_ref_obj, nb=None):\n\n    nkpt = len(bands_obj.kpoints)\n    if bands_ref_obj.is_spin_polarized:\n        nbands = min(bands_obj.nb_bands, 2 * bands_ref_obj.nb_bands)\n    else:\n        # TODO: why is this needed? Shouldn't pmg take care of nb_bands?\n        nbands = min(len(bands_obj.bands[Spin.up]),\n                     len(bands_ref_obj.bands[Spin.up]))\n    # print(nbands)\n    arr_bands = np.array(bands_obj.bands[Spin.up][:nbands])\n    # arr_bands_lavg = (arr_bands-np.mean(arr_bands,axis=1).reshape(nbands,1))\n\n    if bands_ref_obj.is_spin_polarized:\n        arr_bands_ref_up = np.array(bands_ref_obj.bands[Spin.up])\n        arr_bands_ref_dw = np.array(bands_ref_obj.bands[Spin.down])\n        # print(arr_bands_ref_up.shape)\n        arr_bands_ref = np.vstack((arr_bands_ref_up, arr_bands_ref_dw))\n        arr_bands_ref = np.sort(arr_bands_ref, axis=0)[:nbands]\n        # print(arr_bands_ref.shape)\n    else:\n        arr_bands_ref = np.array(bands_ref_obj.bands[Spin.up][:nbands])\n\n    # arr_bands_ref_lavg =\n    # (arr_bands_ref-np.mean(arr_bands_ref,axis=1).reshape(nbands,1))\n\n    # err = np.sum((arr_bands_lavg-arr_bands_ref_lavg)**2,axis=1)/nkpt\n    corr = np.array(\n        [distance.correlation(arr_bands[idx], arr_bands_ref[idx]) for idx in\n         range(nbands)])\n\n    if type(nb) == int: nb = [nb]\n\n    bcheck = {}\n\n    if max(nb) < nbands:\n        branches = [[s['start_index'], s['end_index'], s['name']] for s in\n                    bands_ref_obj.branches]\n\n        if not bands_obj.is_metal() and not bands_ref_obj.is_metal():\n            zero_ref = bands_ref_obj.get_vbm()['energy']\n            zero = bands_obj.get_vbm()['energy']\n            if not zero:\n                vbm = bands_ref_obj.get_vbm()['band_index'][Spin.up][-1]\n                zero = max(arr_bands[vbm])\n        else:\n            zero_ref = 0  # bands_ref_obj.efermi\n            zero = 0  # bands_obj.efermi\n            print(zero, zero_ref)\n\n        for nbi in nb:\n            bcheck[nbi] = {}\n\n            bcheck[nbi]['Dist'] = np.mean(abs(arr_bands[nbi] - zero\n                                              - arr_bands_ref[nbi] + zero_ref))\n            bcheck[nbi]['Corr'] = corr[nbi]\n\n            for start, end, name in branches:\n                # werr.append((sum((arr_bands_corr[nb][start:end+1] -\n                # arr_bands_ref_corr[nb][start:end+1])**2)/(end+1-start)*100,name))\n                bcheck[nbi][name] = np.mean(abs(arr_bands[nbi][start:end + 1]\n                                                - zero\n                                                - arr_bands_ref[nbi][\n                                                  start:end + 1] + zero_ref))\n    else:\n        bcheck = \"No nb given\"\n\n    return bcheck", "response": "Compare two bands and return the mean of correlation between bzt and vasp bandstructure on the symmetric band structure."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the seebeck analytic formula in the single parabolic model", "response": "def seebeck_spb(eta,Lambda=0.5):\n    \"\"\"\n        Seebeck analytic formula in the single parabolic model\n    \"\"\"\n    from fdint import fdk\n    \n    return constants.k/constants.e * ((2. + Lambda) * fdk( 1.+ Lambda, eta)/ \n                 ((1.+Lambda)*fdk(Lambda, eta))- eta) * 1e+6"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef eta_from_seebeck(seeb,Lambda):\n    from scipy.optimize import fsolve\n    out = fsolve(lambda x: (seebeck_spb(x,Lambda) - abs(seeb)) ** 2, 1.,full_output=True)\n    return out[0][0]", "response": "This function takes a value of seebeck and adjusts the analytic seebeck until it s equal \n       "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef seebeck_eff_mass_from_carr(eta, n, T, Lambda):\n    from fdint import fdk\n\n    return (2 * np.pi**2 * abs(n) * 10 ** 6 / (fdk(0.5,eta))) ** (2. / 3)\\\n            / (2 * constants.m_e * constants.k * T / (constants.h/2/np.pi) ** 2)", "response": "Calculate the seebeck effective mass at a certain carrier concentration"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncalculates the seebeck effective mass at a certain carrier concentration", "response": "def seebeck_eff_mass_from_seebeck_carr(seeb, n, T, Lambda):\n    \"\"\"\n        Find the chemical potential where analytic and calculated seebeck are identical\n        and then calculate the seebeck effective mass at that chemical potential and \n        a certain carrier concentration n\n    \"\"\"\n    try:\n        from fdint import fdk\n    except ImportError:\n        raise BoltztrapError(\"fdint module not found. Please, install it.\\n\"+\n                            \"It is needed to calculate Fermi integral quickly.\")\n\n    eta = eta_from_seebeck(seeb,Lambda)\n    mass = seebeck_eff_mass_from_carr(eta, n, T, Lambda)\n    return mass"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _auto_set_energy_range(self):\n        emins = [min([e_k[0] for e_k in self._bs.bands[Spin.up]])]\n        emaxs = [max([e_k[0] for e_k in self._bs.bands[Spin.up]])]\n\n        if self._bs.is_spin_polarized:\n            emins.append(min([e_k[0] for e_k in\n                              self._bs.bands[Spin.down]]))\n\n            emaxs.append(max([e_k[0] for e_k in\n                              self._bs.bands[Spin.down]]))\n\n        min_eigenval = Energy(min(emins) - self._bs.efermi, \"eV\"). \\\n            to(\"Ry\")\n        max_eigenval = Energy(max(emaxs) - self._bs.efermi, \"eV\"). \\\n            to(\"Ry\")\n\n        # set energy range to buffer around min/max EV\n        # buffer does not increase CPU time but will help get equal\n        # energies for spin up/down for band structure\n        const = Energy(2, \"eV\").to(\"Ry\")\n        self._ll = min_eigenval - const\n        self._hl = max_eigenval + const\n\n        en_range = Energy(max((abs(self._ll), abs(self._hl))),\n                          \"Ry\").to(\"eV\")\n\n        self.energy_span_around_fermi = en_range * 1.01\n        print(\"energy_span_around_fermi = \",\n              self.energy_span_around_fermi)", "response": "Auto - determine the energy range for the current entry."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nrun the BoltzTraP and ensure that the current state of the current node is consistent with the current state of the current node.", "response": "def run(self, path_dir=None, convergence=True, write_input=True,\n            clear_dir=False, max_lpfac=150, min_egrid=0.00005):\n        \"\"\"\n        Write inputs (optional), run BoltzTraP, and ensure\n        convergence (optional)\n        Args:\n            path_dir (str): directory in which to run BoltzTraP\n            convergence (bool): whether to check convergence and make\n                corrections if needed\n            write_input: (bool) whether to write input files before the run\n                (required for convergence mode)\n            clear_dir: (bool) whether to remove all files in the path_dir\n                before starting\n            max_lpfac: (float) maximum lpfac value to try before reducing egrid\n                in convergence mode\n            min_egrid: (float) minimum egrid value to try before giving up in\n                convergence mode\n\n        Returns:\n\n        \"\"\"\n\n        # TODO: consider making this a part of custodian rather than pymatgen\n        # A lot of this functionality (scratch dirs, handlers, monitors)\n        # is built into custodian framework\n\n        if convergence and not write_input:\n            raise ValueError(\"Convergence mode requires write_input to be \"\n                             \"true\")\n\n        if self.run_type in (\"BANDS\", \"DOS\", \"FERMI\"):\n            convergence = False\n            if self.lpfac > max_lpfac:\n                max_lpfac = self.lpfac\n\n        if self.run_type == \"BANDS\" and self.bs.is_spin_polarized:\n            print(\"Reminder: for run_type \" + str(\n                self.run_type) + \", spin component are not separated! \"\n                                 \"(you have a spin polarized band structure)\")\n\n        if self.run_type in (\"FERMI\", \"DOS\") and self.spin is None:\n            if self.bs.is_spin_polarized:\n                raise BoltztrapError(\n                    \"Spin parameter must be specified for spin polarized \"\n                    \"band structures!\")\n            else:\n                self.spin = 1\n\n        dir_bz_name = \"boltztrap\"\n        if path_dir is None:\n            temp_dir = tempfile.mkdtemp()\n            path_dir = os.path.join(temp_dir, dir_bz_name)\n        else:\n            path_dir = os.path.abspath(\n                os.path.join(path_dir, dir_bz_name))\n\n        if not os.path.exists(path_dir):\n            os.mkdir(path_dir)\n        elif clear_dir:\n            for c in os.listdir(path_dir):\n                os.remove(os.path.join(path_dir, c))\n\n        FORMAT = \"%(message)s\"\n        logging.basicConfig(level=logging.INFO, format=FORMAT,\n                            filename=os.path.join(path_dir, \"../boltztrap.out\"))\n\n        with cd(path_dir):\n            lpfac_start = self.lpfac\n            converged = False\n\n            while self.energy_grid >= min_egrid and not converged:\n                self.lpfac = lpfac_start\n                if time.time() - self.start_time > self.timeout:\n                    raise BoltztrapError(\"no doping convergence after timeout \"\n                                         \"of {} s\".format(self.timeout))\n\n                logging.info(\"lpfac, energy_grid: {} {}\".format(self.lpfac, self.energy_grid))\n\n                while self.lpfac <= max_lpfac and not converged:\n                    if time.time() - self.start_time > self.timeout:\n                        raise BoltztrapError(\"no doping convergence after \"\n                                        \"timeout of {} s\".format(self.timeout))\n\n                    if write_input:\n                        self.write_input(path_dir)\n\n                    bt_exe = [\"x_trans\", \"BoltzTraP\"]\n                    if self._bs.is_spin_polarized or self.soc:\n                        bt_exe.append(\"-so\")\n\n                    p = subprocess.Popen(bt_exe, stdout=subprocess.PIPE,\n                                         stdin=subprocess.PIPE,\n                                         stderr=subprocess.PIPE)\n                    p.wait()\n\n                    for c in p.communicate():\n                        logging.info(c.decode())\n                        if \"error in factorization\" in c.decode():\n                            raise BoltztrapError(\"error in factorization\")\n\n                    warning = \"\"\n\n                    with open(os.path.join(path_dir,\n                                           dir_bz_name + \".outputtrans\")) as f:\n                        for l in f:\n                            if \"Option unknown\" in l:\n                                raise BoltztrapError(\n                                    \"DOS mode needs a custom version of \"\n                                    \"BoltzTraP code is needed\")\n                            if \"WARNING\" in l:\n                                warning = l\n                                break\n                            if \"Error - Fermi level was not found\" in l:\n                                warning = l\n                                break\n\n                    if not warning and convergence:\n                        # check convergence for warning\n                        analyzer = BoltztrapAnalyzer.from_files(path_dir)\n                        for doping in ['n', 'p']:\n                            for c in analyzer.mu_doping[doping]:\n                                if len(analyzer.mu_doping[doping][c]) != len(\n                                        analyzer.doping[doping]):\n                                    warning = \"length of mu_doping array is \" \\\n                                              \"incorrect\"\n                                    break\n\n                                if doping == 'p' and \\\n                                                sorted(\n                                                    analyzer.mu_doping[doping][\n                                                        c], reverse=True) != \\\n                                                analyzer.mu_doping[doping][c]:\n                                    warning = \"sorting of mu_doping array \" \\\n                                              \"incorrect for p-type\"\n                                    break\n\n                                # ensure n-type doping sorted correctly\n                                if doping == 'n' and sorted(\n                                        analyzer.mu_doping[doping][c]) != \\\n                                        analyzer.mu_doping[doping][c]:\n                                    warning = \"sorting of mu_doping array \" \\\n                                              \"incorrect for n-type\"\n                                    break\n\n                    if warning:\n                        self.lpfac += 10\n                        logging.warn(\"Warning detected: {}! Increase lpfac to \"\n                                     \"{}\".format(warning, self.lpfac))\n\n                    else:\n                        converged = True\n\n                if not converged:\n                    self.energy_grid /= 10\n                    logging.info(\"Could not converge with max lpfac; \"\n                                 \"Decrease egrid to {}\".format(self.energy_grid))\n\n            if not converged:\n                raise BoltztrapError(\n                    \"Doping convergence not reached with lpfac=\" + str(\n                        self.lpfac) + \", energy_grid=\" + str(self.energy_grid))\n\n            return path_dir"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nfunction used to read bands from Boltztrap output and get them comparable with that one from a DFT calculation.", "response": "def get_symm_bands(self, structure, efermi, kpt_line=None,\n                       labels_dict=None):\n        \"\"\"\n            Function useful to read bands from Boltztrap output and get a\n            BandStructureSymmLine object comparable with that one from a DFT\n            calculation (if the same kpt_line is provided). Default kpt_line\n            and labels_dict is the standard path of high symmetry k-point for\n            the specified structure. They could be extracted from the\n            BandStructureSymmLine object that you want to compare with. efermi\n            variable must be specified to create the BandStructureSymmLine\n            object (usually it comes from DFT or Boltztrap calc)\n        \"\"\"\n        try:\n            if kpt_line is None:\n                kpath = HighSymmKpath(structure)\n                kpt_line = [Kpoint(k, structure.lattice.reciprocal_lattice) for\n                            k in\n                            kpath.get_kpoints(coords_are_cartesian=False)[0]]\n                labels_dict = {l: k for k, l in zip(\n                    *kpath.get_kpoints(coords_are_cartesian=False)) if l}\n                kpt_line = [kp.frac_coords for kp in kpt_line]\n            elif type(kpt_line[0]) == Kpoint:\n                kpt_line = [kp.frac_coords for kp in kpt_line]\n                labels_dict = {k: labels_dict[k].frac_coords for k in\n                               labels_dict}\n\n            idx_list = []\n            #       kpt_dense=np.array([kp for kp in self._bz_kpoints])\n            for i, kp in enumerate(kpt_line):\n                w = []\n                prec = 1e-05\n                while len(w) == 0:\n                    w = np.where(np.all(\n                        np.abs(kp - self._bz_kpoints) < [prec] * 3,\n                        axis=1))[0]\n                    prec *= 10\n\n                # print( prec )\n                idx_list.append([i, w[0]])\n\n                # if len(w)>0:\n                #     idx_list.append([i,w[0]])\n                # else:\n                #     w=np.where(np.all(np.abs(kp.frac_coords-self._bz_kpoints)\n                # <[1e-04,1e-04,1e-04],axis=1))[0]\n                #     idx_list.append([i,w[0]])\n\n            idx_list = np.array(idx_list)\n            # print( idx_list.shape )\n\n            bands_dict = {Spin.up: (self._bz_bands * Energy(1, \"Ry\").to(\n                \"eV\") + efermi).T[:, idx_list[:, 1]].tolist()}\n            # bz_kpoints = bz_kpoints[idx_list[:,1]].tolist()\n\n            sbs = BandStructureSymmLine(kpt_line, bands_dict,\n                                        structure.lattice.reciprocal_lattice,\n                                        efermi,\n                                        labels_dict=labels_dict)\n\n            return sbs\n\n        except:\n            raise BoltztrapError(\n                \"Bands are not in output of BoltzTraP.\\nBolztrapRunner must \"\n                \"be run with run_type=BANDS\")"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncompare the two - dimensional BandStructureSymmLine with the two - dimensional BandStructureSymmLine as reference and return a dictionary with these keys as keys and values as values.", "response": "def check_acc_bzt_bands(sbs_bz, sbs_ref, warn_thr=(0.03, 0.03)):\n        \"\"\"\n            Compare sbs_bz BandStructureSymmLine calculated with boltztrap with\n            the sbs_ref BandStructureSymmLine as reference (from MP for\n            instance), computing correlation and energy difference for eight bands\n            around the gap (semiconductors) or fermi level (metals).\n            warn_thr is a threshold to get a warning in the accuracy of Boltztap\n            interpolated bands.\n            Return a dictionary with these keys:\n            - \"N\": the index of the band compared; inside each there are:\n                - \"Corr\": correlation coefficient for the 8 compared bands\n                - \"Dist\": energy distance for the 8 compared bands\n                - \"branch_name\": energy distance for that branch\n            - \"avg_corr\": average of correlation coefficient over the 8 bands\n            - \"avg_dist\": average of energy distance over the 8 bands\n            - \"nb_list\": list of indexes of the 8 compared bands\n            - \"acc_thr\": list of two float corresponing to the two warning\n                         thresholds in input\n            - \"acc_err\": list of two bools:\n                         True if the avg_corr > warn_thr[0], and\n                         True if the avg_dist > warn_thr[1]\n            See also compare_sym_bands function doc\n        \"\"\"\n        if not sbs_ref.is_metal() and not sbs_bz.is_metal():\n            vbm_idx = sbs_bz.get_vbm()['band_index'][Spin.up][-1]\n            cbm_idx = sbs_bz.get_cbm()['band_index'][Spin.up][0]\n            nb_list = range(vbm_idx - 3, cbm_idx + 4)\n\n        else:\n            bnd_around_efermi = []\n            delta = 0\n            spin = list(sbs_bz.bands.keys())[0]\n            while len(bnd_around_efermi) < 8 and delta < 100:\n                delta += 0.1\n                bnd_around_efermi = []\n                for nb in range(len(sbs_bz.bands[spin])):\n                    for kp in range(len(sbs_bz.bands[spin][nb])):\n                        if abs(sbs_bz.bands[spin][nb][\n                                   kp] - sbs_bz.efermi) < delta:\n                            bnd_around_efermi.append(nb)\n                            break\n            if len(bnd_around_efermi) < 8:\n                print(\"Warning! check performed on \" + str(\n                    len(bnd_around_efermi)))\n                nb_list = bnd_around_efermi\n            else:\n                nb_list = bnd_around_efermi[:8]\n\n        # print(nb_list)\n        bcheck = compare_sym_bands(sbs_bz, sbs_ref, nb_list)\n        # print(bcheck)\n        acc_err = [False, False]\n        avg_corr = sum([item[1]['Corr'] for item in bcheck.iteritems()]) / 8\n        avg_distance = sum([item[1]['Dist'] for item in bcheck.iteritems()]) / 8\n\n        if avg_corr > warn_thr[0]: acc_err[0] = True\n        if avg_distance > warn_thr[0]: acc_err[1] = True\n\n        bcheck['avg_corr'] = avg_corr\n        bcheck['avg_distance'] = avg_distance\n        bcheck['acc_err'] = acc_err\n        bcheck['acc_thr'] = warn_thr\n        bcheck['nb_list'] = nb_list\n\n        if True in acc_err:\n            print(\"Warning! some bands around gap are not accurate\")\n\n        return bcheck"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_seebeck(self, output='eigs', doping_levels=True):\n        return BoltztrapAnalyzer._format_to_output(self._seebeck,\n                                                   self._seebeck_doping,\n                                                   output,\n                                                   doping_levels, 1e6)", "response": "Returns the Seebeck coefficient of the given base - level a\n           ."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_conductivity(self, output='eigs', doping_levels=True,\n                         relaxation_time=1e-14):\n        \"\"\"\n            Gives the conductivity (1/Ohm*m) in either a full 3x3 tensor\n            form, as 3 eigenvalues, or as the average value\n            (trace/3.0) If doping_levels=True, the results are given at\n            different p and n doping\n            levels (given by self.doping), otherwise it is given as a series\n            of electron chemical potential values\n\n            Args:\n                output (string): the type of output. 'tensor' give the full\n                3x3 tensor, 'eigs' its 3 eigenvalues and\n                'average' the average of the three eigenvalues\n                doping_levels (boolean): True for the results to be given at\n                different doping levels, False for results\n                at different electron chemical potentials\n                relaxation_time (float): constant relaxation time in secs\n\n            Returns:\n                If doping_levels=True, a dictionary {temp:{'p':[],'n':[]}}.\n                The 'p' links to conductivity\n                at p-type doping and 'n' to the conductivity at n-type\n                doping. Otherwise,\n                returns a {temp:[]} dictionary. The result contains either\n                the sorted three eigenvalues of the symmetric\n                conductivity tensor (format='eigs') or a full tensor (3x3\n                array) (output='tensor') or as an average\n                (output='average').\n                The result includes a given constant relaxation time\n\n                units are 1/Ohm*m\n        \"\"\"\n        return BoltztrapAnalyzer._format_to_output(self._cond,\n                                                   self._cond_doping, output,\n                                                   doping_levels,\n                                                   relaxation_time)", "response": "Returns the conductivity of the current object."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the power factor of the current state of the entry in the system.", "response": "def get_power_factor(self, output='eigs', doping_levels=True,\n                         relaxation_time=1e-14):\n        \"\"\"\n        Gives the power factor (Seebeck^2 * conductivity) in units\n        microW/(m*K^2) in either a full 3x3 tensor form,\n        as 3 eigenvalues, or as the average value (trace/3.0) If\n        doping_levels=True, the results are given at\n        different p and n doping levels (given by self.doping), otherwise it\n        is given as a series of\n        electron chemical potential values\n\n        Args:\n            output (string): the type of output. 'tensor' give the full 3x3\n            tensor, 'eigs' its 3 eigenvalues and\n            'average' the average of the three eigenvalues\n            doping_levels (boolean): True for the results to be given at\n            different doping levels, False for results\n            at different electron chemical potentials\n            relaxation_time (float): constant relaxation time in secs\n\n        Returns:\n            If doping_levels=True, a dictionnary {temp:{'p':[],'n':[]}}. The\n            'p' links to power factor\n            at p-type doping and 'n' to the conductivity at n-type doping.\n            Otherwise,\n            returns a {temp:[]} dictionary. The result contains either the\n            sorted three eigenvalues of the symmetric\n            power factor tensor (format='eigs') or a full tensor (3x3 array) (\n            output='tensor') or as an average\n            (output='average').\n            The result includes a given constant relaxation time\n\n            units are microW/(m K^2)\n        \"\"\"\n        result = None\n        result_doping = None\n        if doping_levels:\n            result_doping = {doping: {t: [] for t in\n                                      self._seebeck_doping[doping]} for\n                             doping in self._seebeck_doping}\n\n            for doping in result_doping:\n                for t in result_doping[doping]:\n                    for i in range(len(self.doping[doping])):\n                        full_tensor = np.dot(self._cond_doping[doping][t][i],\n                                             np.dot(\n                                                 self._seebeck_doping[doping][\n                                                     t][i],\n                                                 self._seebeck_doping[doping][\n                                                     t][i]))\n                        result_doping[doping][t].append(full_tensor)\n\n        else:\n            result = {t: [] for t in self._seebeck}\n            for t in result:\n                for i in range(len(self.mu_steps)):\n                    full_tensor = np.dot(self._cond[t][i],\n                                         np.dot(self._seebeck[t][i],\n                                                self._seebeck[t][i]))\n                    result[t].append(full_tensor)\n\n        return BoltztrapAnalyzer._format_to_output(result, result_doping,\n                                                   output, doping_levels,\n                                                   multi=1e6 * relaxation_time)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_thermal_conductivity(self, output='eigs', doping_levels=True,\n                                 k_el=True, relaxation_time=1e-14):\n        \"\"\"\n        Gives the electronic part of the thermal conductivity in either a\n        full 3x3 tensor form,\n        as 3 eigenvalues, or as the average value (trace/3.0) If\n        doping_levels=True, the results are given at\n        different p and n doping levels (given by self.doping), otherwise it\n        is given as a series of\n        electron chemical potential values\n\n        Args:\n            output (string): the type of output. 'tensor' give the full 3x3\n            tensor, 'eigs' its 3 eigenvalues and\n            'average' the average of the three eigenvalues\n            doping_levels (boolean): True for the results to be given at\n            different doping levels, False for results\n            at different electron chemical potentials\n            k_el (boolean): True for k_0-PF*T, False for k_0\n            relaxation_time (float): constant relaxation time in secs\n\n        Returns:\n            If doping_levels=True, a dictionary {temp:{'p':[],'n':[]}}. The\n            'p' links to thermal conductivity\n            at p-type doping and 'n' to the thermal conductivity at n-type\n            doping. Otherwise,\n            returns a {temp:[]} dictionary. The result contains either the\n            sorted three eigenvalues of the symmetric\n            conductivity tensor (format='eigs') or a full tensor (3x3 array) (\n            output='tensor') or as an average\n            (output='average').\n            The result includes a given constant relaxation time\n\n            units are W/mK\n        \"\"\"\n        result = None\n        result_doping = None\n        if doping_levels:\n            result_doping = {doping: {t: [] for t in\n                                      self._seebeck_doping[doping]} for\n                             doping in self._seebeck_doping}\n            for doping in result_doping:\n                for t in result_doping[doping]:\n                    for i in range(len(self.doping[doping])):\n                        if k_el:\n                            pf_tensor = np.dot(self._cond_doping[doping][t][i],\n                                               np.dot(\n                                                   self._seebeck_doping[doping][\n                                                       t][i],\n                                                   self._seebeck_doping[doping][\n                                                       t][i]))\n                            result_doping[doping][t].append((\n                                self._kappa_doping[doping][t][\n                                    i] - pf_tensor * t))\n                        else:\n                            result_doping[doping][t].append((\n                                self._kappa_doping[doping][t][i]))\n        else:\n            result = {t: [] for t in self._seebeck}\n            for t in result:\n                for i in range(len(self.mu_steps)):\n                    if k_el:\n                        pf_tensor = np.dot(self._cond[t][i],\n                                           np.dot(self._seebeck[t][i],\n                                                  self._seebeck[t][i]))\n                        result[t].append((self._kappa[t][i] - pf_tensor * t))\n                    else:\n                        result[t].append((self._kappa[t][i]))\n\n        return BoltztrapAnalyzer._format_to_output(result, result_doping,\n                                                   output, doping_levels,\n                                                   multi=relaxation_time)", "response": "Returns the thermal conductivity of the entry in the system."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_zt(self, output='eigs', doping_levels=True, relaxation_time=1e-14,\n               kl=1.0):\n        \"\"\"\n        Gives the ZT coefficient (S^2*cond*T/thermal cond) in either a full\n        3x3 tensor form,\n        as 3 eigenvalues, or as the average value (trace/3.0) If\n        doping_levels=True, the results are given at\n        different p and n doping levels (given by self.doping), otherwise it\n        is given as a series of\n        electron chemical potential values. We assume a constant relaxation\n        time and a constant\n        lattice thermal conductivity\n\n        Args:\n            output (string): the type of output. 'tensor' give the full 3x3\n            tensor, 'eigs' its 3 eigenvalues and\n            'average' the average of the three eigenvalues\n            doping_levels (boolean): True for the results to be given at\n            different doping levels, False for results\n            at different electron chemical potentials\n            relaxation_time (float): constant relaxation time in secs\n            k_l (float): lattice thermal cond in W/(m*K)\n\n        Returns:\n            If doping_levels=True, a dictionary {temp:{'p':[],'n':[]}}. The\n            'p' links to ZT\n            at p-type doping and 'n' to the ZT at n-type doping. Otherwise,\n            returns a {temp:[]} dictionary. The result contains either the\n            sorted three eigenvalues of the symmetric\n            ZT tensor (format='eigs') or a full tensor (3x3 array) (\n            output='tensor') or as an average\n            (output='average').\n            The result includes a given constant relaxation time and lattice\n            thermal conductivity\n        \"\"\"\n        result = None\n        result_doping = None\n        if doping_levels:\n            result_doping = {doping: {t: [] for t in\n                                      self._seebeck_doping[doping]} for\n                             doping in self._seebeck_doping}\n\n            for doping in result_doping:\n                for t in result_doping[doping]:\n                    for i in range(len(self.doping[doping])):\n                        pf_tensor = np.dot(self._cond_doping[doping][t][i],\n                                           np.dot(\n                                               self._seebeck_doping[doping][t][\n                                                   i],\n                                               self._seebeck_doping[doping][t][\n                                                   i]))\n                        thermal_conduct = (self._kappa_doping[doping][t][i]\n                                           - pf_tensor * t) * relaxation_time\n                        result_doping[doping][t].append(\n                            np.dot(pf_tensor * relaxation_time * t,\n                                   np.linalg.inv(\n                                       thermal_conduct + kl * np.eye(3, 3))))\n        else:\n            result = {t: [] for t in self._seebeck}\n            for t in result:\n                for i in range(len(self.mu_steps)):\n                    pf_tensor = np.dot(self._cond[t][i],\n                                       np.dot(self._seebeck[t][i],\n                                              self._seebeck[t][i]))\n                    thermal_conduct = (self._kappa[t][i]\n                                       - pf_tensor * t) * relaxation_time\n                    result[t].append(np.dot(pf_tensor * relaxation_time * t,\n                                            np.linalg.inv(\n                                                thermal_conduct + kl *\n                                                np.eye(3, 3))))\n\n        return BoltztrapAnalyzer._format_to_output(result, result_doping,\n                                                   output, doping_levels)", "response": "Returns the ZT coefficient of the symmetric entry of the current object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ngive the average effective mass tensor. We call it average because it takes into account all the bands and regions in the Brillouin zone. This is different than the standard textbook effective mass which relates often to only one (parabolic) band. The average effective mass tensor is defined as the integrated average of the second derivative of E(k) This effective mass tensor takes into account: -non-parabolicity -multiple extrema -multiple bands For more information about it. See: Hautier, G., Miglio, A., Waroquiers, D., Rignanese, G., & Gonze, X. (2014). How Does Chemistry Influence Electron Effective Mass in Oxides? A High-Throughput Computational Analysis. Chemistry of Materials, 26(19), 5447\u20135458. doi:10.1021/cm404079a or Hautier, G., Miglio, A., Ceder, G., Rignanese, G.-M., & Gonze, X. (2013). Identification and design principles of low hole effective mass p-type transparent conducting oxides. Nature Communications, 4, 2292. doi:10.1038/ncomms3292 Depending on the value of output, we have either the full 3x3 effective mass tensor, its 3 eigenvalues or an average Args: output (string): 'eigs' for eigenvalues, 'tensor' for the full tensor and 'average' for an average (trace/3) doping_levels (boolean): True for the results to be given at different doping levels, False for results at different electron chemical potentials Returns: If doping_levels=True,a dictionary {'p':{temp:[]},'n':{temp:[]}} with an array of effective mass tensor, eigenvalues of average value (depending on output) for each temperature and for each doping level. The 'p' links to hole effective mass tensor and 'n' to electron effective mass tensor.", "response": "def get_average_eff_mass(self, output='eigs', doping_levels=True):\n        \"\"\"\n        Gives the average effective mass tensor. We call it average because\n        it takes into account all the bands\n        and regions in the Brillouin zone. This is different than the standard\n        textbook effective mass which relates\n        often to only one (parabolic) band.\n        The average effective mass tensor is defined as the integrated\n        average of the second derivative of E(k)\n        This effective mass tensor takes into account:\n        -non-parabolicity\n        -multiple extrema\n        -multiple bands\n\n        For more information about it. See:\n\n        Hautier, G., Miglio, A., Waroquiers, D., Rignanese, G., & Gonze,\n        X. (2014).\n        How Does Chemistry Influence Electron Effective Mass in Oxides?\n        A High-Throughput Computational Analysis. Chemistry of Materials,\n        26(19), 5447\u20135458. doi:10.1021/cm404079a\n\n        or\n\n        Hautier, G., Miglio, A., Ceder, G., Rignanese, G.-M., & Gonze,\n        X. (2013).\n        Identification and design principles of low hole effective mass\n        p-type transparent conducting oxides.\n        Nature Communications, 4, 2292. doi:10.1038/ncomms3292\n\n        Depending on the value of output, we have either the full 3x3\n        effective mass tensor,\n        its 3 eigenvalues or an average\n\n        Args:\n            output (string): 'eigs' for eigenvalues, 'tensor' for the full\n            tensor and 'average' for an average (trace/3)\n            doping_levels (boolean): True for the results to be given at\n            different doping levels, False for results\n            at different electron chemical potentials\n        Returns:\n            If doping_levels=True,a dictionary {'p':{temp:[]},'n':{temp:[]}}\n            with an array of effective mass tensor, eigenvalues of average\n            value (depending on output) for each temperature and for each\n            doping level.\n            The 'p' links to hole effective mass tensor and 'n' to electron\n            effective mass tensor.\n        \"\"\"\n        result = None\n        result_doping = None\n        conc = self.get_carrier_concentration()\n        if doping_levels:\n            result_doping = {doping: {t: [] for t in self._cond_doping[doping]}\n                             for\n                             doping in self.doping}\n            for doping in result_doping:\n                for temp in result_doping[doping]:\n                    for i in range(len(self.doping[doping])):\n                        try:\n                            result_doping[doping][temp].append(np.linalg.inv(\n                                np.array(self._cond_doping[doping][temp][i])) * \\\n                                                               self.doping[doping][\n                                                                   i] * 10 ** 6 * \n                                                                    constants.e ** 2 / \n                                                                    constants.m_e)\n                        except np.linalg.LinAlgError:\n                            pass\n        else:\n            result = {t: [] for t in self._seebeck}\n            for temp in result:\n                for i in range(len(self.mu_steps)):\n                    try:\n                        cond_inv = np.linalg.inv(np.array(self._cond[temp][i]))\n                    except np.linalg.LinAlgError:\n                        pass\n                    result[temp].append(cond_inv * \\\n                                        conc[temp][i] * 10 ** 6 * \n                                                constants.e ** 2 / \n                                                constants.m_e)\n\n        return BoltztrapAnalyzer._format_to_output(result, result_doping,\n                                                   output, doping_levels)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_seebeck_eff_mass(self, output='average', temp=300, doping_levels=False,\n                                Lambda=0.5):\n        \"\"\"\n        Seebeck effective mass calculated as explained in Ref.\n        Gibbs, Z. M. et al., Effective mass and fermi surface complexity factor \n        from ab initio band structure calculations. \n        npj Computational Materials 3, 8 (2017).\n\n        Args:\n            output: 'average' returns the seebeck effective mass calculated using \n                    the average of the three diagonal components of the seebeck tensor.\n                    'tensor' returns the seebeck effective mass respect to the three \n                    diagonal components of the seebeck tensor.\n            doping_levels: False means that the seebeck effective mass is calculated\n                           for every value of the chemical potential\n                           True means that the seebeck effective mass is calculated\n                           for every value of the doping levels for both n and p types\n            temp:   temperature of calculated seebeck.\n            Lambda: fitting parameter used to model the scattering (0.5 means constant \n                    relaxation time).\n        Returns:\n            a list of values for the seebeck effective mass w.r.t the chemical potential,\n            if doping_levels is set at False;\n            a dict with n an p keys that contain a list of values for the seebeck effective\n            mass w.r.t the doping levels, if doping_levels is set at True;\n            if 'tensor' is selected, each element of the lists is a list containing \n            the three components of the seebeck effective mass.\n        \"\"\"\n                \n        if doping_levels:\n            sbk_mass = {}\n            for dt in ('n','p'):\n                conc = self.doping[dt]\n                seebeck = self.get_seebeck(output=output, doping_levels=True)[dt][temp]\n                sbk_mass[dt] = []\n                for i in range(len(conc)):\n                    if output == 'average':\n                        sbk_mass[dt].append(\n                            seebeck_eff_mass_from_seebeck_carr(abs(seebeck[i]), \n                                                                conc[i], temp, Lambda))\n                    elif output == 'tensor':\n                        sbk_mass[dt].append([])\n                        for j in range(3):\n                            sbk_mass[dt][-1].append(\n                                seebeck_eff_mass_from_seebeck_carr(abs(seebeck[i][j][j]),\n                                                                    conc[i], temp, Lambda))\n                \n        else:\n            seebeck = self.get_seebeck(output=output, doping_levels=False)[temp]\n            conc = self.get_carrier_concentration()[temp]\n            sbk_mass = []\n            for i in range(len(conc)):\n                if output == 'average':\n                    sbk_mass.append(\n                        seebeck_eff_mass_from_seebeck_carr(abs(seebeck[i]), \n                                                            conc[i], temp, Lambda))\n                elif output == 'tensor':\n                    sbk_mass.append([])\n                    for j in range(3):\n                        sbk_mass[-1].append(\n                            seebeck_eff_mass_from_seebeck_carr(abs(seebeck[i][j][j]),\n                                                                conc[i], temp, Lambda))\n        return sbk_mass", "response": "Returns the seebeck effective mass for a given temperature and doping level."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the complexity factor for a given set of parameters.", "response": "def get_complexity_factor(self, output='average', temp=300, doping_levels=False,\n                              Lambda=0.5):\n        \"\"\"\n        Fermi surface complexity factor respect to calculated as explained in Ref.\n        Gibbs, Z. M. et al., Effective mass and fermi surface complexity factor \n        from ab initio band structure calculations. \n        npj Computational Materials 3, 8 (2017).\n        \n        Args:\n            output: 'average' returns the complexity factor calculated using the average\n                    of the three diagonal components of the seebeck and conductivity tensors.\n                    'tensor' returns the complexity factor respect to the three\n                    diagonal components of seebeck and conductivity tensors.\n            doping_levels: False means that the complexity factor is calculated\n                           for every value of the chemical potential\n                           True means that the complexity factor is calculated\n                           for every value of the doping levels for both n and p types\n            temp:   temperature of calculated seebeck and conductivity.\n            Lambda: fitting parameter used to model the scattering (0.5 means constant \n                    relaxation time).\n        Returns:\n            a list of values for the complexity factor w.r.t the chemical potential,\n            if doping_levels is set at False;\n            a dict with n an p keys that contain a list of values for the complexity factor\n            w.r.t the doping levels, if doping_levels is set at True;\n            if 'tensor' is selected, each element of the lists is a list containing \n            the three components of the complexity factor.\n        \"\"\"\n        \n        if doping_levels:\n            cmplx_fact = {}\n            for dt in ('n','p'):\n                sbk_mass = self.get_seebeck_eff_mass(output, temp, True, Lambda)[dt]\n                cond_mass = self.get_average_eff_mass(output=output, doping_levels=True)[dt][temp]\n                \n                if output == 'average':\n                    cmplx_fact[dt] = [ (m_s/abs(m_c))**1.5 for m_s,m_c in zip(sbk_mass,cond_mass)]\n                elif output == 'tensor':\n                    cmplx_fact[dt] = []\n                    for i in range(len(sbk_mass)):\n                        cmplx_fact[dt].append([])\n                        for j in range(3):\n                            cmplx_fact[dt][-1].append((sbk_mass[i][j]/abs(cond_mass[i][j][j]))**1.5)\n                \n        else:\n            sbk_mass = self.get_seebeck_eff_mass(output, temp, False, Lambda)\n            cond_mass = self.get_average_eff_mass(output=output, doping_levels=False)[temp]\n            \n            if output == 'average':\n                cmplx_fact = [ (m_s/abs(m_c))**1.5 for m_s,m_c in zip(sbk_mass,cond_mass)]\n            elif output == 'tensor':\n                cmplx_fact = []\n                for i in range(len(sbk_mass)):\n                    cmplx_fact.append([])\n                    for j in range(3):\n                        cmplx_fact[-1].append((sbk_mass[i][j]/abs(cond_mass[i][j][j]))**1.5)\n            \n        return cmplx_fact"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a CompleteDos object with the DOS from the interpolated structure and spin components.", "response": "def get_complete_dos(self, structure, analyzer_for_second_spin=None):\n        \"\"\"\n            Gives a CompleteDos object with the DOS from the interpolated\n            projected band structure\n            Args:\n                the structure (necessary to identify sites for projection)\n                analyzer_for_second_spin must be specified to have a\n                CompleteDos with both Spin components\n            Returns:\n                a CompleteDos object\n            Example of use in case of spin polarized case:\n\n                BoltztrapRunner(bs=bs,nelec=10,run_type=\"DOS\",spin=1).run(path_dir='dos_up/')\n                an_up=BoltztrapAnalyzer.from_files(\"dos_up/boltztrap/\",dos_spin=1)\n\n                BoltztrapRunner(bs=bs,nelec=10,run_type=\"DOS\",spin=-1).run(path_dir='dos_dw/')\n                an_dw=BoltztrapAnalyzer.from_files(\"dos_dw/boltztrap/\",dos_spin=-1)\n\n                cdos=an_up.get_complete_dos(bs.structure,an_dw)\n\n        \"\"\"\n        pdoss = {}\n        spin_1 = list(self.dos.densities.keys())[0]\n\n        if analyzer_for_second_spin:\n            if not np.all(self.dos.energies ==\n                                  analyzer_for_second_spin.dos.energies):\n                raise BoltztrapError(\n                    \"Dos merging error: energies of the two dos are different\")\n\n            spin_2 = list(analyzer_for_second_spin.dos.densities.keys())[0]\n            if spin_1 == spin_2:\n                raise BoltztrapError(\n                    \"Dos merging error: spin component are the same\")\n\n        for s in self._dos_partial:\n            if structure.sites[int(s)] not in pdoss:\n                pdoss[structure.sites[int(s)]] = {}\n            for o in self._dos_partial[s]:\n                if Orbital[o] not in pdoss[structure.sites[int(s)]]:\n                    pdoss[structure.sites[int(s)]][Orbital[o]] = {}\n                pdoss[structure.sites[int(s)]][Orbital[o]][\n                    spin_1] = self._dos_partial[s][o]\n                if analyzer_for_second_spin:\n                    pdoss[structure.sites[int(s)]][Orbital[o]][\n                        spin_2] = analyzer_for_second_spin._dos_partial[s][o]\n        if analyzer_for_second_spin:\n            tdos = Dos(self.dos.efermi, self.dos.energies,\n                       {spin_1: self.dos.densities[spin_1],\n                        spin_2: analyzer_for_second_spin.dos.densities[\n                            spin_2]})\n        else:\n            tdos = self.dos\n\n        return CompleteDos(structure, total_dos=tdos, pdoss=pdoss)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the carrier concentration at each temperature", "response": "def get_carrier_concentration(self):\n        \"\"\"\n        gives the carrier concentration (in cm^-3)\n\n        Returns\n            a dictionary {temp:[]} with an array of carrier concentration\n            (in cm^-3) at each temperature\n            The array relates to each step of electron chemical potential\n        \"\"\"\n\n        return {temp: [1e24 * i / self.vol for i in self._carrier_conc[temp]]\n                for temp in self._carrier_conc}"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_hall_carrier_concentration(self):\n        result = {temp: [] for temp in self._hall}\n        for temp in self._hall:\n            for i in self._hall[temp]:\n                trace = (i[1][2][0] + i[2][0][1] + i[0][1][2]) / 3.0\n                if trace != 0.0:\n                    result[temp].append(1e-6 / (trace * constants.e))\n                else:\n                    result[temp].append(0.0)\n        return result", "response": "Returns the Hall carrier concentration for the current temperature"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef parse_outputtrans(path_dir):\n        run_type = None\n        warning = None\n        efermi = None\n        gap = None\n        doping_levels = []\n\n        with open(os.path.join(path_dir, \"boltztrap.outputtrans\"), 'r') \\\n                as f:\n            for line in f:\n                if \"WARNING\" in line:\n                    warning = line\n                elif \"Calc type:\" in line:\n                    run_type = line.split()[-1]\n                elif line.startswith(\"VBM\"):\n                    efermi = Energy(line.split()[1], \"Ry\").to(\"eV\")\n                elif line.startswith(\"Egap:\"):\n                    gap = Energy(float(line.split()[1]), \"Ry\").to(\"eV\")\n                elif line.startswith(\"Doping level number\"):\n                    doping_levels.append(float(line.split()[6]))\n\n        return run_type, warning, efermi, gap, doping_levels", "response": "Parses boltztrap. outputtrans file and returns tuple of run type warning efermi gap and doping levels"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef parse_transdos(path_dir, efermi, dos_spin=1, trim_dos=False):\n\n        \"\"\"\n        Parses .transdos (total DOS) and .transdos_x_y (partial DOS) files\n        Args:\n            path_dir: (str) dir containing DOS files\n            efermi: (float) Fermi energy\n            dos_spin: (int) -1 for spin down, +1 for spin up\n            trim_dos: (bool) whether to post-process / trim DOS\n\n        Returns:\n            tuple - (DOS, dict of partial DOS)\n        \"\"\"\n\n        data_dos = {'total': [], 'partial': {}}\n        # parse the total DOS data\n        ## format is energy, DOS, integrated DOS\n        with open(os.path.join(path_dir, \"boltztrap.transdos\"), 'r') as f:\n            count_series = 0  # TODO: why is count_series needed?\n            for line in f:\n                if line.lstrip().startswith(\"#\"):\n                    count_series += 1\n                    if count_series > 1:\n                        break\n                else:\n                    data_dos['total'].append(\n                        [Energy(float(line.split()[0]), \"Ry\").to(\"eV\"),\n                         float(line.split()[1])])\n                    total_elec = float(line.split()[2])\n\n        lw_l = 0\n        hg_l = -len(data_dos['total'])\n        if trim_dos:\n            # Francesco knows what this does\n            # It has something to do with a trick of adding fake energies\n            # at the endpoints of the DOS, and then re-trimming it. This is\n            # to get the same energy scale for up and down spin DOS.\n            tmp_data = np.array(data_dos['total'])\n            tmp_den = np.trim_zeros(tmp_data[:, 1], 'f')[1:]\n            lw_l = len(tmp_data[:, 1]) - len(tmp_den)\n            tmp_ene = tmp_data[lw_l:, 0]\n            tmp_den = np.trim_zeros(tmp_den, 'b')[:-1]\n            hg_l = len(tmp_ene) - len(tmp_den)\n            tmp_ene = tmp_ene[:-hg_l]\n            tmp_data = np.vstack((tmp_ene, tmp_den)).T\n            data_dos['total'] = tmp_data.tolist()\n\n        # parse partial DOS data\n        for file_name in os.listdir(path_dir):\n            if file_name.endswith(\n                    \"transdos\") and file_name != 'boltztrap.transdos':\n                tokens = file_name.split(\".\")[1].split(\"_\")\n                site = tokens[1]\n                orb = '_'.join(tokens[2:])\n                with open(os.path.join(path_dir, file_name), 'r') as f:\n                    for line in f:\n                        if not line.lstrip().startswith(\" #\"):\n                            if site not in data_dos['partial']:\n                                data_dos['partial'][site] = {}\n                            if orb not in data_dos['partial'][site]:\n                                data_dos['partial'][site][orb] = []\n                            data_dos['partial'][site][orb].append(\n                                float(line.split()[1]))\n                data_dos['partial'][site][orb] = data_dos['partial'][site][\n                                                     orb][lw_l:-hg_l]\n\n        dos_full = {'energy': [], 'density': []}\n\n        for t in data_dos['total']:\n            dos_full['energy'].append(t[0])\n            dos_full['density'].append(t[1])\n\n        dos = Dos(efermi, dos_full['energy'],\n                  {Spin(dos_spin): dos_full['density']})\n        dos_partial = data_dos['partial']  # TODO: make this real DOS object?\n\n        return dos, dos_partial", "response": "Parses the. transdos file and returns a dictionary of DOS and partial DOS."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nparsing boltztrap. intrans file and returns a dictionary containing the value of scissor applied to bands or other inputs that had been used in the Boltztrap run.", "response": "def parse_intrans(path_dir):\n        \"\"\"\n        Parses boltztrap.intrans mainly to extract the value of scissor applied to the bands or some other inputs\n        Args:\n            path_dir: (str) dir containing the boltztrap.intrans file\n        Returns:\n            intrans (dict): a dictionary containing various inputs that had been used in the Boltztrap run.\n        \"\"\"\n        intrans = {}\n        with open(os.path.join(path_dir, \"boltztrap.intrans\"), 'r') as f:\n            for line in f:\n                if \"iskip\" in line:\n                    intrans[\"scissor\"] = Energy(float(line.split(\" \")[3]),\n                                                \"Ry\").to(\"eV\")\n                if \"HISTO\" in line or \"TETRA\" in line:\n                    intrans[\"dos_type\"] = line[:-1]\n        return intrans"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef parse_struct(path_dir):\n        with open(os.path.join(path_dir, \"boltztrap.struct\"), 'r') as f:\n            tokens = f.readlines()\n            return Lattice([[Length(float(tokens[i].split()[j]), \"bohr\").\n                           to(\"ang\") for j in range(3)] for i in\n                            range(1, 4)]).volume", "response": "Parses boltztrap. struct file and returns a volume"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nparses the conductivity and Hall tensors and returns the set of mu_steps and mu_doping and hall_doping for the current base level and carrier.", "response": "def parse_cond_and_hall(path_dir, doping_levels=None):\n        \"\"\"\n        Parses the conductivity and Hall tensors\n        Args:\n            path_dir: Path containing .condtens / .halltens files\n            doping_levels: ([float]) - doping lvls, parse outtrans to get this\n\n        Returns:\n            mu_steps, cond, seebeck, kappa, hall, pn_doping_levels,\n            mu_doping, seebeck_doping, cond_doping, kappa_doping,\n            hall_doping, carrier_conc\n        \"\"\"\n\n        # Step 1: parse raw data but do not convert to final format\n        t_steps = set()\n        mu_steps = set()\n        data_full = []\n        data_hall = []\n        data_doping_full = []\n        data_doping_hall = []\n        doping_levels = doping_levels or []\n\n        # parse the full conductivity/Seebeck/kappa0/etc data\n        ## also initialize t_steps and mu_steps\n        with open(os.path.join(path_dir, \"boltztrap.condtens\"), 'r') as f:\n            for line in f:\n                if not line.startswith(\"#\"):\n                    mu_steps.add(float(line.split()[0]))\n                    t_steps.add(int(float(line.split()[1])))\n                    data_full.append([float(c) for c in line.split()])\n\n        # parse the full Hall tensor\n        with open(os.path.join(path_dir, \"boltztrap.halltens\"), 'r') as f:\n            for line in f:\n                if not line.startswith(\"#\"):\n                    data_hall.append([float(c) for c in line.split()])\n\n        if len(doping_levels) != 0:\n            # parse doping levels version of full cond. tensor, etc.\n            with open(\n                    os.path.join(path_dir, \"boltztrap.condtens_fixdoping\"),\n                    'r') as f:\n                for line in f:\n                    if not line.startswith(\"#\") and len(line) > 2:\n                        data_doping_full.append([float(c)\n                                                 for c in line.split()])\n\n            # parse doping levels version of full hall tensor\n            with open(\n                    os.path.join(path_dir, \"boltztrap.halltens_fixdoping\"),\n                    'r') as f:\n                for line in f:\n                    if not line.startswith(\"#\") and len(line) > 2:\n                        data_doping_hall.append(\n                            [float(c) for c in line.split()])\n\n        # Step 2: convert raw data to final format\n\n        # sort t and mu_steps (b/c they are sets not lists)\n        # and convert to correct energy\n        t_steps = sorted([t for t in t_steps])\n        mu_steps = sorted([Energy(m, \"Ry\").to(\"eV\") for m in mu_steps])\n\n        # initialize output variables - could use defaultdict instead\n        # I am leaving things like this for clarity\n        cond = {t: [] for t in t_steps}\n        seebeck = {t: [] for t in t_steps}\n        kappa = {t: [] for t in t_steps}\n        hall = {t: [] for t in t_steps}\n        carrier_conc = {t: [] for t in t_steps}\n        dos_full = {'energy': [], 'density': []}\n\n        mu_doping = {'p': {t: [] for t in t_steps},\n                     'n': {t: [] for t in t_steps}}\n        seebeck_doping = {'p': {t: [] for t in t_steps},\n                          'n': {t: [] for t in t_steps}}\n        cond_doping = {'p': {t: [] for t in t_steps},\n                       'n': {t: [] for t in t_steps}}\n        kappa_doping = {'p': {t: [] for t in t_steps},\n                        'n': {t: [] for t in t_steps}}\n        hall_doping = {'p': {t: [] for t in t_steps},\n                       'n': {t: [] for t in t_steps}}\n\n        # process doping levels\n        pn_doping_levels = {'p': [], 'n': []}\n        for d in doping_levels:\n            if d > 0:\n                pn_doping_levels['p'].append(d)\n            else:\n                pn_doping_levels['n'].append(-d)\n\n        # process raw conductivity data, etc.\n        for d in data_full:\n            temp, doping = d[1], d[2]\n            carrier_conc[temp].append(doping)\n\n            cond[temp].append(np.reshape(d[3:12], (3, 3)).tolist())\n            seebeck[temp].append(np.reshape(d[12:21], (3, 3)).tolist())\n            kappa[temp].append(np.reshape(d[21:30], (3, 3)).tolist())\n\n        # process raw Hall data\n        for d in data_hall:\n            temp, doping = d[1], d[2]\n            hall_tens = [np.reshape(d[3:12], (3, 3)).tolist(),\n                         np.reshape(d[12:21], (3, 3)).tolist(),\n                         np.reshape(d[21:30], (3, 3)).tolist()]\n            hall[temp].append(hall_tens)\n\n        # process doping conductivity data, etc.\n        for d in data_doping_full:\n            temp, doping, mu = d[0], d[1], d[-1]\n            pn = 'p' if doping > 0 else 'n'\n            mu_doping[pn][temp].append(Energy(mu, \"Ry\").to(\"eV\"))\n            cond_doping[pn][temp].append(\n                np.reshape(d[2:11], (3, 3)).tolist())\n            seebeck_doping[pn][temp].append(\n                np.reshape(d[11:20], (3, 3)).tolist())\n            kappa_doping[pn][temp].append(\n                np.reshape(d[20:29], (3, 3)).tolist())\n\n        # process doping Hall data\n        for d in data_doping_hall:\n            temp, doping, mu = d[0], d[1], d[-1]\n            pn = 'p' if doping > 0 else 'n'\n            hall_tens = [np.reshape(d[2:11], (3, 3)).tolist(),\n                         np.reshape(d[11:20], (3, 3)).tolist(),\n                         np.reshape(d[20:29], (3, 3)).tolist()]\n            hall_doping[pn][temp].append(hall_tens)\n\n        return mu_steps, cond, seebeck, kappa, hall, pn_doping_levels, \\\n               mu_doping, seebeck_doping, cond_doping, kappa_doping, \\\n               hall_doping, carrier_conc"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef from_files(path_dir, dos_spin=1):\n        run_type, warning, efermi, gap, doping_levels = \\\n            BoltztrapAnalyzer.parse_outputtrans(path_dir)\n\n        vol = BoltztrapAnalyzer.parse_struct(path_dir)\n\n        intrans = BoltztrapAnalyzer.parse_intrans(path_dir)\n\n        if run_type == \"BOLTZ\":\n            dos, pdos = BoltztrapAnalyzer.parse_transdos(\n                path_dir, efermi, dos_spin=dos_spin, trim_dos=False)\n\n            mu_steps, cond, seebeck, kappa, hall, pn_doping_levels, mu_doping, \\\n            seebeck_doping, cond_doping, kappa_doping, hall_doping, \\\n            carrier_conc = BoltztrapAnalyzer. \\\n                parse_cond_and_hall(path_dir, doping_levels)\n\n            return BoltztrapAnalyzer(\n                gap, mu_steps, cond, seebeck, kappa, hall, pn_doping_levels,\n                mu_doping, seebeck_doping, cond_doping, kappa_doping,\n                hall_doping, intrans, dos, pdos, carrier_conc, vol, warning)\n\n        elif run_type == \"DOS\":\n            trim = True if intrans[\"dos_type\"] == \"HISTO\" else False\n            dos, pdos = BoltztrapAnalyzer.parse_transdos(\n                path_dir, efermi, dos_spin=dos_spin, trim_dos=trim)\n\n            return BoltztrapAnalyzer(gap=gap, dos=dos, dos_partial=pdos,\n                                     warning=warning, vol=vol)\n\n        elif run_type == \"BANDS\":\n            bz_kpoints = np.loadtxt(\n                os.path.join(path_dir, \"boltztrap_band.dat\"))[:, -3:]\n            bz_bands = np.loadtxt(\n                os.path.join(path_dir, \"boltztrap_band.dat\"))[:, 1:-6]\n            return BoltztrapAnalyzer(bz_bands=bz_bands, bz_kpoints=bz_kpoints,\n                                     warning=warning, vol=vol)\n\n        elif run_type == \"FERMI\":\n            \"\"\"\n            \"\"\"\n\n            if os.path.exists(os.path.join(path_dir, 'boltztrap_BZ.cube')):\n                fs_data = read_cube_file(\n                    os.path.join(path_dir, 'boltztrap_BZ.cube'))\n            elif os.path.exists(os.path.join(path_dir, 'fort.30')):\n                fs_data = read_cube_file(os.path.join(path_dir, 'fort.30'))\n            else:\n                raise BoltztrapError(\"No data file found for fermi surface\")\n            return BoltztrapAnalyzer(fermi_surface_data=fs_data)\n\n        else:\n            raise ValueError(\"Run type: {} not recognized!\".format(run_type))", "response": "This function takes a set of files and returns a BoltztrapAnalyzer object from the set of files."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nchecks for the defined errors and put all found errors in self. errors", "response": "def check(self):\n        \"\"\"\n        Check for the defined errors, put all found errors in self.errors, return True if any were found False if no\n        errors were found\n        \"\"\"\n        parser = get_parser(self.scheduler_adapter.name, err_file=self.err_file, out_file=self.out_file,\n                            run_err_file=self.run_err_file, batch_err_file=self.batch_err_file)\n        parser.parse()\n        self.errors = parser.errors\n        if len(self.errors) == 0:\n            return False\n        else:\n            return True"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef apply_corrections(self):\n        for error in self.errors:\n            for solution in error.scheduler_adapter_solutions:\n                if self.scheduler_adapter is not None:\n                    if self.scheduler_adapter.__getattribut__(solution[0].__name__)(solution[1]):\n                        return True\n            for solution in error.application_adapter_solutions:\n                if self.application_adapter is not None:\n                    if self.application_adapter.__getattribut__(solution[0].__name__)(solution[1]):\n                        return True\n        return False", "response": "Method to directly apply the corrections."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nparsing LAMMPS log file with focus on thermo data.", "response": "def parse_lammps_log(filename=\"log.lammps\"):\n    \"\"\"\n    Parses log file with focus on thermo data. Both one and multi line\n    formats are supported. Any incomplete runs (no \"Loop time\" marker)\n    will not be parsed.\n\n    Notes:\n        SHAKE stats printed with thermo data are not supported yet.\n        They are ignored in multi line format, while they may cause\n        issues with dataframe parsing in one line format.\n\n    Args:\n        filename (str): Filename to parse.\n\n    Returns:\n        [pd.DataFrame] containing thermo data for each completed run.\n\n    \"\"\"\n    with open(filename) as f:\n        lines = f.readlines()\n    begin_flag = (\"Memory usage per processor =\",\n                  \"Per MPI rank memory allocation (min/avg/max) =\")\n    end_flag = \"Loop time of\"\n    begins, ends = [], []\n    for i, l in enumerate(lines):\n        if l.startswith(begin_flag):\n            begins.append(i)\n        elif l.startswith(end_flag):\n            ends.append(i)\n\n    def _parse_thermo(lines):\n        multi_pattern = r\"-+\\s+Step\\s+([0-9]+)\\s+-+\"\n        # multi line thermo data\n        if re.match(multi_pattern, lines[0]):\n            timestep_marks = [i for i, l in enumerate(lines)\n                              if re.match(multi_pattern, l)]\n            timesteps = np.split(lines, timestep_marks)[1:]\n            dicts = []\n            kv_pattern = r\"([0-9A-Za-z_\\[\\]]+)\\s+=\\s+([0-9eE\\.+-]+)\"\n            for ts in timesteps:\n                data = {}\n                data[\"Step\"] = int(re.match(multi_pattern, ts[0]).group(1))\n                data.update({k: float(v) for k, v\n                             in re.findall(kv_pattern, \"\".join(ts[1:]))})\n                dicts.append(data)\n            df = pd.DataFrame(dicts)\n            # rearrange the sequence of columns\n            columns = [\"Step\"] + [k for k, v in\n                                  re.findall(kv_pattern,\n                                             \"\".join(timesteps[0][1:]))]\n            df = df[columns]\n        # one line thermo data\n        else:\n            df = pd.read_csv(StringIO(\"\".join(lines)), delim_whitespace=True)\n        return df\n\n    runs = []\n    for b, e in zip(begins, ends):\n        runs.append(_parse_thermo(lines[b + 1:e]))\n    return runs"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef from_string(cls, string):\n        lines = string.split(\"\\n\")\n        timestep = int(lines[1])\n        natoms = int(lines[3])\n        box_arr = np.loadtxt(StringIO(\"\\n\".join(lines[5:8])))\n        bounds = box_arr[:, :2]\n        tilt = None\n        if \"xy xz yz\" in lines[4]:\n            tilt = box_arr[:, 2]\n            x = (0, tilt[0], tilt[1], tilt[0] + tilt[1])\n            y = (0, tilt[2])\n            bounds -= np.array([[min(x), max(x)], [min(y), max(y)], [0, 0]])\n        box = LammpsBox(bounds, tilt)\n        data_head = lines[8].replace(\"ITEM: ATOMS\", \"\").split()\n        data = pd.read_csv(StringIO(\"\\n\".join(lines[9:])), names=data_head,\n                           delim_whitespace=True)\n        return cls(timestep, natoms, box, data)", "response": "Constructor from string parsing."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the number of k - point divisions for a given k - point density per reciprocal - atom and a given structure", "response": "def get_num_division_kpoints(structure, kppa):\n    \"\"\"\n    Get kpoint divisions for a given k-point density (per reciprocal-atom):\n    kppa and a given structure\n    \"\"\"\n    output = run_aconvasp_command([\"aconvasp\", \"--kpoints\", str(kppa)],\n                                  structure)\n    tmp = output[0].rsplit(\"\\n\")[6].rsplit(\" \")\n    return [int(tmp[5]), int(tmp[6]), int(tmp[7])]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_minkowski_red(structure):\n    output = run_aconvasp_command([\"aconvasp\", \"--kpath\"], structure)\n    started = False\n    poscar_string = \"\"\n    if \"ERROR\" in output[1]:\n        raise AconvaspError(output[1])\n    for line in output[0].split(\"\\n\"):\n        if started or line.find(\"KPOINTS TO RUN\") != -1:\n            poscar_string = poscar_string + line + \"\\n\"\n        if line.find(\"STRUCTURE TO RUN\") != -1:\n            started = True\n        if line.find(\"KPOINTS TO RUN\") != -1:\n            started = False\n    return Poscar.from_string(poscar_string).structure", "response": "Get a minkowski reduced structure"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget a minkowski reduced structure", "response": "def get_conv_struct(structure):\n    \"\"\"\n    Get a minkowski reduced structure\n    \"\"\"\n    output = run_aconvasp_command([\"aconvasp\", \"--std_conv\"], structure)\n    if \"ERROR\" in output[1]:\n        raise AconvaspError(output[1])\n    tmp = Poscar.from_string(output[0])\n    return {'struct': tmp.structure, 'comm': tmp.comment}"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting a kpoint file ready to be ran in VASP along the symmetry lines of the Brillouin Zone", "response": "def get_vasp_kpoint_file_sym(structure):\n    \"\"\"\n    get a kpoint file ready to be ran in VASP along the symmetry lines of the\n    Brillouin Zone\n    \"\"\"\n    output = run_aconvasp_command([\"aconvasp\", \"--kpath\"], structure)\n    if \"ERROR\" in output[1]:\n        raise AconvaspError(output[1])\n    started = False\n    kpoints_string = \"\"\n    for line in output[0].split(\"\\n\"):\n        #print line\n        if started or line.find(\"END\") != -1:\n            kpoints_string = kpoints_string + line + \"\\n\"\n        if line.find(\"KPOINTS TO RUN\") != -1:\n            started = True\n        if line.find(\"END\") != -1:\n            started = False\n    return kpoints_string"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _my_partial(func, *args, **kwargs):\n    newobj = partial(func, *args, **kwargs)\n    # monkey patch\n    newobj.from_string = FloatWithUnit.from_string\n    return newobj", "response": "Partial returns a partial object and therefore we cannot inherit it from FloatWithUnit"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a FloatWithUnit instance if obj is scalar a dictionary of objects with units if obj is a dict else an array of objects with units if obj is a dict else an instance of .", "response": "def obj_with_unit(obj, unit):\n    \"\"\"\n    Returns a `FloatWithUnit` instance if obj is scalar, a dictionary of\n    objects with units if obj is a dict, else an instance of\n    `ArrayWithFloatWithUnit`.\n\n    Args:\n        unit: Specific units (eV, Ha, m, ang, etc.).\n    \"\"\"\n    unit_type = _UNAME2UTYPE[unit]\n\n    if isinstance(obj, numbers.Number):\n        return FloatWithUnit(obj, unit=unit, unit_type=unit_type)\n    elif isinstance(obj, collections.Mapping):\n        return {k: obj_with_unit(v, unit) for k,v in obj.items()}\n    else:\n        return ArrayWithUnit(obj, unit=unit, unit_type=unit_type)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef unitized(unit):\n    def wrap(f):\n        def wrapped_f(*args, **kwargs):\n            val = f(*args, **kwargs)\n            unit_type = _UNAME2UTYPE[unit]\n\n            if isinstance(val, FloatWithUnit) or isinstance(val, ArrayWithUnit):\n                return val.to(unit)\n\n            elif isinstance(val, collections.abc.Sequence):\n                # TODO: why don't we return a ArrayWithUnit?\n                # This complicated way is to ensure the sequence type is\n                # preserved (list or tuple).\n                return val.__class__([FloatWithUnit(i, unit_type=unit_type,\n                                                    unit=unit) for i in val])\n            elif isinstance(val, collections.Mapping):\n                for k, v in val.items():\n                    val[k] = FloatWithUnit(v, unit_type=unit_type, unit=unit)\n            elif isinstance(val, numbers.Number):\n                return FloatWithUnit(val, unit_type=unit_type, unit=unit)\n            elif val is None:\n                pass\n            else:\n                raise TypeError(\"Don't know how to assign units to %s\" % str(val))\n            return val\n        return wrapped_f\n    return wrap", "response": "Decorator to assign units to the output of a function."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconvert all units to base SI units including derived units.", "response": "def as_base_units(self):\n        \"\"\"\n        Converts all units to base SI units, including derived units.\n\n        Returns:\n            (base_units_dict, scaling factor). base_units_dict will not\n            contain any constants, which are gathered in the scaling factor.\n        \"\"\"\n        b = collections.defaultdict(int)\n        factor = 1\n        for k, v in self.items():\n            derived = False\n            for d in DERIVED_UNITS.values():\n                if k in d:\n                    for k2, v2 in d[k].items():\n                        if isinstance(k2, Number):\n                            factor *= k2 ** (v2 * v)\n                        else:\n                            b[k2] += v2 * v\n                    derived = True\n                    break\n            if not derived:\n                si, f = _get_si_unit(k)\n                b[si] += v\n                factor *= f ** v\n        return {k: v for k, v in b.items() if v != 0}, factor"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_conversion_factor(self, new_unit):\n        uo_base, ofactor = self.as_base_units\n        un_base, nfactor = Unit(new_unit).as_base_units\n        units_new = sorted(un_base.items(),\n                           key=lambda d: _UNAME2UTYPE[d[0]])\n        units_old = sorted(uo_base.items(),\n                           key=lambda d: _UNAME2UTYPE[d[0]])\n        factor = ofactor / nfactor\n        for uo, un in zip(units_old, units_new):\n            if uo[1] != un[1]:\n                raise UnitError(\"Units %s and %s are not compatible!\" % (uo, un))\n            c = ALL_UNITS[_UNAME2UTYPE[uo[0]]]\n            factor *= (c[uo[0]] / c[un[0]]) ** uo[1]\n        return factor", "response": "Returns a conversion factor between this unit and a new unit."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef from_string(cls, s):\n        # Extract num and unit string.\n        s = s.strip()\n        for i, char in enumerate(s):\n            if char.isalpha() or char.isspace():\n                break\n        else:\n            raise Exception(\"Unit is missing in string %s\" % s)\n        num, unit = float(s[:i]), s[i:]\n\n        # Find unit type (set it to None if it cannot be detected)\n        for unit_type, d in BASE_UNITS.items():\n            if unit in d:\n                break\n        else:\n            unit_type = None\n\n        return cls(num, unit, unit_type=unit_type)", "response": "Initialize a FloatWithUnit from a string. Example Memory. from_string"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef to(self, new_unit):\n        return FloatWithUnit(\n            self * self.unit.get_conversion_factor(new_unit),\n            unit_type=self._unit_type,\n            unit=new_unit)", "response": "Returns a new object with the current value converted to the given new unit."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef to(self, new_unit):\n        return self.__class__(\n            np.array(self) * self.unit.get_conversion_factor(new_unit),\n            unit_type=self.unit_type, unit=new_unit)", "response": "Returns a new object with the same units as this one."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a string showing the available conversions. Useful tool in interactive mode.", "response": "def conversions(self):\n        \"\"\"\n        Returns a string showing the available conversions.\n        Useful tool in interactive mode.\n        \"\"\"\n        return \"\\n\".join(str(self.to(unit)) for unit in self.supported_units)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nattempt to convert a vector of floats to whole numbers.", "response": "def get_integer_index(\n    miller_index: bool, round_dp: int = 4, verbose: bool = True\n) -> Tuple[int, int, int]:\n    \"\"\"\n    Attempt to convert a vector of floats to whole numbers.\n\n    Args:\n        miller_index (list of float): A list miller indexes.\n        round_dp (int, optional): The number of decimal places to round the\n            miller index to.\n        verbose (bool, optional): Whether to print warnings.\n\n    Returns:\n        (tuple): The Miller index.\n    \"\"\"\n    miller_index = np.asarray(miller_index)\n\n    # deal with the case we have small irregular floats\n    # that are all equal or factors of each other\n    miller_index /= min([m for m in miller_index if m != 0])\n    miller_index /= np.max(np.abs(miller_index))\n\n    # deal with the case we have nice fractions\n    md = [Fraction(n).limit_denominator(12).denominator for n in miller_index]\n    miller_index *= reduce(lambda x, y: x * y, md)\n    int_miller_index = np.int_(np.round(miller_index, 1))\n    miller_index /= np.abs(reduce(gcd, int_miller_index))\n\n    # round to a reasonable precision\n    miller_index = np.array([round(h, round_dp) for h in miller_index])\n\n    # need to recalculate this after rounding as values may have changed\n    int_miller_index = np.int_(np.round(miller_index, 1))\n    if np.any(np.abs(miller_index - int_miller_index) > 1e-6) and verbose:\n        warnings.warn(\"Non-integer encountered in Miller index\")\n    else:\n        miller_index = int_miller_index\n\n    # minimise the number of negative indexes\n    miller_index += 0  # converts -0 to 0\n\n    def n_minus(index):\n        return len([h for h in index if h < 0])\n\n    if n_minus(miller_index) > n_minus(miller_index * -1):\n        miller_index *= -1\n\n    # if only one index is negative, make sure it is the smallest\n    # e.g. (-2 1 0) -> (2 -1 0)\n    if (\n        sum(miller_index != 0) == 2\n        and n_minus(miller_index) == 1\n        and abs(min(miller_index)) > max(miller_index)\n    ):\n        miller_index *= -1\n\n    return tuple(miller_index)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef angles(self) -> Tuple[float]:\n        m = self._matrix\n        lengths = self.lengths\n        angles = np.zeros(3)\n        for i in range(3):\n            j = (i + 1) % 3\n            k = (i + 2) % 3\n            angles[i] = abs_cap(dot(m[j], m[k]) / (lengths[j] * lengths[k]))\n        angles = np.arccos(angles) * 180.0 / pi\n        return tuple(angles.tolist())", "response": "Returns the angles of the current set of all the elements in the system."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef inv_matrix(self) -> np.ndarray:\n        if self._inv_matrix is None:\n            self._inv_matrix = inv(self._matrix)\n            self._inv_matrix.setflags(write=False)\n        return self._inv_matrix", "response": "Inverse of lattice matrix."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the cartesian coordinates given fractional coordinates.", "response": "def get_cartesian_coords(self, fractional_coords: Vector3Like) -> np.ndarray:\n        \"\"\"\n        Returns the cartesian coordinates given fractional coordinates.\n\n        Args:\n            fractional_coords (3x1 array): Fractional coords.\n\n        Returns:\n            Cartesian coordinates\n        \"\"\"\n        return dot(fractional_coords, self._matrix)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the fractional coordinates given cartesian coordinates.", "response": "def get_fractional_coords(self, cart_coords: Vector3Like) -> np.ndarray:\n        \"\"\"\n        Returns the fractional coordinates given cartesian coordinates.\n\n        Args:\n            cart_coords (3x1 array): Cartesian coords.\n\n        Returns:\n            Fractional coordinates.\n        \"\"\"\n        return dot(cart_coords, self.inv_matrix)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef d_hkl(self, miller_index: Vector3Like) -> float:\n\n        gstar = self.reciprocal_lattice_crystallographic.metric_tensor\n        hkl = np.array(miller_index)\n        return 1 / ((dot(dot(hkl, gstar), hkl.T)) ** (1 / 2))", "response": "Returns the distance between the hkl plane and the origin"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef tetragonal(a: float, c: float):\n        return Lattice.from_parameters(a, a, c, 90, 90, 90)", "response": "Convenience constructor for a tetragonal lattice."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef monoclinic(a: float, b: float, c: float, beta: float):\n        return Lattice.from_parameters(a, b, c, 90, beta, 90)", "response": "Returns a Monoclinic lattice with the given parameters."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef hexagonal(a: float, c: float):\n        return Lattice.from_parameters(a, a, c, 90, 90, 120)", "response": "Convenience constructor for a hexagonal lattice."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef rhombohedral(a: float, alpha: float):\n        return Lattice.from_parameters(a, a, a, alpha, alpha, alpha)", "response": "Returns a rhombohedral lattice."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef from_lengths_and_angles(abc: List[float], ang: List[float]):\n        return Lattice.from_parameters(abc[0], abc[1], abc[2], ang[0], ang[1], ang[2])", "response": "Create a Lattice from the specified lattice lengths and angles."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates a new Lattice object from the specified parameters.", "response": "def from_parameters(\n        cls,\n        a: float,\n        b: float,\n        c: float,\n        alpha: float,\n        beta: float,\n        gamma: float,\n        vesta: bool = False,\n    ):\n        \"\"\"\n        Create a Lattice using unit cell lengths and angles (in degrees).\n\n        Args:\n            a (float): *a* lattice parameter.\n            b (float): *b* lattice parameter.\n            c (float): *c* lattice parameter.\n            alpha (float): *alpha* angle in degrees.\n            beta (float): *beta* angle in degrees.\n            gamma (float): *gamma* angle in degrees.\n            vesta: True if you import Cartesian coordinates from VESTA.\n\n        Returns:\n            Lattice with the specified lattice parameters.\n        \"\"\"\n\n        angles_r = np.radians([alpha, beta, gamma])\n        cos_alpha, cos_beta, cos_gamma = np.cos(angles_r)\n        sin_alpha, sin_beta, sin_gamma = np.sin(angles_r)\n\n        if vesta:\n            c1 = c * cos_beta\n            c2 = (c * (cos_alpha - (cos_beta * cos_gamma))) / sin_gamma\n\n            vector_a = [float(a), 0.0, 0.0]\n            vector_b = [b * cos_gamma, b * sin_gamma, 0]\n            vector_c = [c1, c2, math.sqrt(c ** 2 - c1 ** 2 - c2 ** 2)]\n\n        else:\n            val = (cos_alpha * cos_beta - cos_gamma) / (sin_alpha * sin_beta)\n            # Sometimes rounding errors result in values slightly > 1.\n            val = abs_cap(val)\n            gamma_star = np.arccos(val)\n\n            vector_a = [a * sin_beta, 0.0, a * cos_beta]\n            vector_b = [\n                -b * sin_alpha * np.cos(gamma_star),\n                b * sin_alpha * np.sin(gamma_star),\n                b * cos_alpha,\n            ]\n            vector_c = [0.0, 0.0, float(c)]\n\n        return Lattice([vector_a, vector_b, vector_c])"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef from_dict(cls, d: Dict, fmt: str = None, **kwargs):\n        if fmt == \"abivars\":\n            from pymatgen.io.abinit.abiobjects import lattice_from_abivars\n\n            kwargs.update(d)\n            return lattice_from_abivars(cls=cls, **kwargs)\n\n        if \"matrix\" in d:\n            return cls(d[\"matrix\"])\n        else:\n            return cls.from_parameters(\n                d[\"a\"], d[\"b\"], d[\"c\"], d[\"alpha\"], d[\"beta\"], d[\"gamma\"]\n            )", "response": "Create a Lattice object from a dictionary containing the a b c alpha beta and gamma parameters."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef volume(self) -> float:\n        m = self._matrix\n        return float(abs(dot(np.cross(m[0], m[1]), m[2])))", "response": "The volume of the unit cell."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns lengths and angles of the current set of lattice elements.", "response": "def lengths_and_angles(self) -> Tuple[Tuple[float, float, float], Tuple[float, float, float]]:\n        \"\"\"\n        Returns (lattice lengths, lattice angles).\n        \"\"\"\n        return self.lengths, self.angles"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the reciprocal lattice of the current state.", "response": "def reciprocal_lattice(self) -> \"Lattice\":\n        \"\"\"\n        Return the reciprocal lattice. Note that this is the standard\n        reciprocal lattice used for solid state physics with a factor of 2 *\n        pi. If you are looking for the crystallographic reciprocal lattice,\n        use the reciprocal_lattice_crystallographic property.\n        The property is lazily generated for efficiency.\n        \"\"\"\n        v = np.linalg.inv(self._matrix).T\n        return Lattice(v * 2 * np.pi)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef as_dict(self, verbosity: int = 0) -> Dict:\n\n        d = {\n            \"@module\": self.__class__.__module__,\n            \"@class\": self.__class__.__name__,\n            \"matrix\": self._matrix.tolist(),\n        }\n        (a, b, c), (alpha, beta, gamma) = self.lengths_and_angles\n        if verbosity > 0:\n            d.update(\n                {\n                    \"a\": a,\n                    \"b\": b,\n                    \"c\": c,\n                    \"alpha\": alpha,\n                    \"beta\": beta,\n                    \"gamma\": gamma,\n                    \"volume\": self.volume,\n                }\n            )\n\n        return d", "response": "Returns a dict representation of the Lattice."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef find_all_mappings(\n        self,\n        other_lattice: \"Lattice\",\n        ltol: float = 1e-5,\n        atol: float = 1,\n        skip_rotation_matrix: bool = False,\n    ) -> Iterator[Tuple[\"Lattice\", Optional[np.ndarray], np.ndarray]]:\n        \"\"\"\n        Finds all mappings between current lattice and another lattice.\n\n        Args:\n            other_lattice (Lattice): Another lattice that is equivalent to\n                this one.\n            ltol (float): Tolerance for matching lengths. Defaults to 1e-5.\n            atol (float): Tolerance for matching angles. Defaults to 1.\n            skip_rotation_matrix (bool): Whether to skip calculation of the\n                rotation matrix\n\n        Yields:\n            (aligned_lattice, rotation_matrix, scale_matrix) if a mapping is\n            found. aligned_lattice is a rotated version of other_lattice that\n            has the same lattice parameters, but which is aligned in the\n            coordinate system of this lattice so that translational points\n            match up in 3D. rotation_matrix is the rotation that has to be\n            applied to other_lattice to obtain aligned_lattice, i.e.,\n            aligned_matrix = np.inner(other_lattice, rotation_matrix) and\n            op = SymmOp.from_rotation_and_translation(rotation_matrix)\n            aligned_matrix = op.operate_multi(latt.matrix)\n            Finally, scale_matrix is the integer matrix that expresses\n            aligned_matrix as a linear combination of this\n            lattice, i.e., aligned_matrix = np.dot(scale_matrix, self.matrix)\n\n            None is returned if no matches are found.\n        \"\"\"\n        (lengths, angles) = other_lattice.lengths_and_angles\n        (alpha, beta, gamma) = angles\n\n        frac, dist, _, _ = self.get_points_in_sphere(\n            [[0, 0, 0]], [0, 0, 0], max(lengths) * (1 + ltol), zip_results=False\n        )\n        cart = self.get_cartesian_coords(frac)\n        # this can't be broadcast because they're different lengths\n        inds = [\n            np.logical_and(dist / l < 1 + ltol, dist / l > 1 / (1 + ltol))\n            for l in lengths\n        ]\n        c_a, c_b, c_c = (cart[i] for i in inds)\n        f_a, f_b, f_c = (frac[i] for i in inds)\n        l_a, l_b, l_c = (np.sum(c ** 2, axis=-1) ** 0.5 for c in (c_a, c_b, c_c))\n\n        def get_angles(v1, v2, l1, l2):\n            x = np.inner(v1, v2) / l1[:, None] / l2\n            x[x > 1] = 1\n            x[x < -1] = -1\n            angles = np.arccos(x) * 180.0 / pi\n            return angles\n\n        alphab = np.abs(get_angles(c_b, c_c, l_b, l_c) - alpha) < atol\n        betab = np.abs(get_angles(c_a, c_c, l_a, l_c) - beta) < atol\n        gammab = np.abs(get_angles(c_a, c_b, l_a, l_b) - gamma) < atol\n\n        for i, all_j in enumerate(gammab):\n            inds = np.logical_and(\n                all_j[:, None], np.logical_and(alphab, betab[i][None, :])\n            )\n            for j, k in np.argwhere(inds):\n                scale_m = np.array((f_a[i], f_b[j], f_c[k]), dtype=np.int)\n                if abs(np.linalg.det(scale_m)) < 1e-8:\n                    continue\n\n                aligned_m = np.array((c_a[i], c_b[j], c_c[k]))\n\n                if skip_rotation_matrix:\n                    rotation_m = None\n                else:\n                    rotation_m = np.linalg.solve(aligned_m, other_lattice.matrix)\n\n                yield Lattice(aligned_m), rotation_m, scale_m", "response": "Find all mappings between two lattice objects."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef find_mapping(\n        self,\n        other_lattice: \"Lattice\",\n        ltol: float = 1e-5,\n        atol: float = 1,\n        skip_rotation_matrix: bool = False,\n    ) -> Optional[Tuple[\"Lattice\", Optional[np.ndarray], np.ndarray]]:\n        \"\"\"\n        Finds a mapping between current lattice and another lattice. There\n        are an infinite number of choices of basis vectors for two entirely\n        equivalent lattices. This method returns a mapping that maps\n        other_lattice to this lattice.\n\n        Args:\n            other_lattice (Lattice): Another lattice that is equivalent to\n                this one.\n            ltol (float): Tolerance for matching lengths. Defaults to 1e-5.\n            atol (float): Tolerance for matching angles. Defaults to 1.\n\n        Returns:\n            (aligned_lattice, rotation_matrix, scale_matrix) if a mapping is\n            found. aligned_lattice is a rotated version of other_lattice that\n            has the same lattice parameters, but which is aligned in the\n            coordinate system of this lattice so that translational points\n            match up in 3D. rotation_matrix is the rotation that has to be\n            applied to other_lattice to obtain aligned_lattice, i.e.,\n            aligned_matrix = np.inner(other_lattice, rotation_matrix) and\n            op = SymmOp.from_rotation_and_translation(rotation_matrix)\n            aligned_matrix = op.operate_multi(latt.matrix)\n            Finally, scale_matrix is the integer matrix that expresses\n            aligned_matrix as a linear combination of this\n            lattice, i.e., aligned_matrix = np.dot(scale_matrix, self.matrix)\n\n            None is returned if no matches are found.\n        \"\"\"\n        for x in self.find_all_mappings(\n            other_lattice, ltol, atol, skip_rotation_matrix=skip_rotation_matrix\n        ):\n            return x", "response": "This method finds a mapping between two sets of lattice vectors and returns the corresponding lattice vectors."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _calculate_lll(self, delta: float = 0.75) -> Tuple[np.ndarray, np.ndarray]:\n        # Transpose the lattice matrix first so that basis vectors are columns.\n        # Makes life easier.\n        a = self._matrix.copy().T\n\n        b = np.zeros((3, 3))  # Vectors after the Gram-Schmidt process\n        u = np.zeros((3, 3))  # Gram-Schmidt coeffieicnts\n        m = np.zeros(3)  # These are the norm squared of each vec.\n\n        b[:, 0] = a[:, 0]\n        m[0] = dot(b[:, 0], b[:, 0])\n        for i in range(1, 3):\n            u[i, 0:i] = dot(a[:, i].T, b[:, 0:i]) / m[0:i]\n            b[:, i] = a[:, i] - dot(b[:, 0:i], u[i, 0:i].T)\n            m[i] = dot(b[:, i], b[:, i])\n\n        k = 2\n\n        mapping = np.identity(3, dtype=np.double)\n        while k <= 3:\n            # Size reduction.\n            for i in range(k - 1, 0, -1):\n                q = round(u[k - 1, i - 1])\n                if q != 0:\n                    # Reduce the k-th basis vector.\n                    a[:, k - 1] = a[:, k - 1] - q * a[:, i - 1]\n                    mapping[:, k - 1] = mapping[:, k - 1] - q * mapping[:, i - 1]\n                    uu = list(u[i - 1, 0 : (i - 1)])\n                    uu.append(1)\n                    # Update the GS coefficients.\n                    u[k - 1, 0:i] = u[k - 1, 0:i] - q * np.array(uu)\n\n            # Check the Lovasz condition.\n            if dot(b[:, k - 1], b[:, k - 1]) >= (\n                delta - abs(u[k - 1, k - 2]) ** 2\n            ) * dot(b[:, (k - 2)], b[:, (k - 2)]):\n                # Increment k if the Lovasz condition holds.\n                k += 1\n            else:\n                # If the Lovasz condition fails,\n                # swap the k-th and (k-1)-th basis vector\n                v = a[:, k - 1].copy()\n                a[:, k - 1] = a[:, k - 2].copy()\n                a[:, k - 2] = v\n\n                v_m = mapping[:, k - 1].copy()\n                mapping[:, k - 1] = mapping[:, k - 2].copy()\n                mapping[:, k - 2] = v_m\n\n                # Update the Gram-Schmidt coefficients\n                for s in range(k - 1, k + 1):\n                    u[s - 1, 0 : (s - 1)] = (\n                        dot(a[:, s - 1].T, b[:, 0 : (s - 1)]) / m[0 : (s - 1)]\n                    )\n                    b[:, s - 1] = a[:, s - 1] - dot(\n                        b[:, 0 : (s - 1)], u[s - 1, 0 : (s - 1)].T\n                    )\n                    m[s - 1] = dot(b[:, s - 1], b[:, s - 1])\n\n                if k > 2:\n                    k -= 1\n                else:\n                    # We have to do p/q, so do lstsq(q.T, p.T).T instead.\n                    p = dot(a[:, k:3].T, b[:, (k - 2) : k])\n                    q = np.diag(m[(k - 2) : k])\n                    result = np.linalg.lstsq(q.T, p.T, rcond=None)[0].T\n                    u[k:3, (k - 2) : k] = result\n\n        return a.T, mapping.T", "response": "Calculates the Llll of the avec."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_lll_frac_coords(self, frac_coords: Vector3Like) -> np.ndarray:\n        return dot(frac_coords, self.lll_inverse)", "response": "Given fractional coordinates in the lattice basis returns corresponding\n        fractional coordinates in the lll basis."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ngive fractional coordinates in the lll basis returns corresponding fractional coordinates in the lattice basis.", "response": "def get_frac_coords_from_lll(self, lll_frac_coords: Vector3Like) -> np.ndarray:\n        \"\"\"\n        Given fractional coordinates in the lll basis, returns corresponding\n        fractional coordinates in the lattice basis.\n        \"\"\"\n        return dot(lll_frac_coords, self.lll_mapping)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the Niggli reduced lattice.", "response": "def get_niggli_reduced_lattice(self, tol: float = 1e-5) -> \"Lattice\":\n        \"\"\"\n        Get the Niggli reduced lattice using the numerically stable algo\n        proposed by R. W. Grosse-Kunstleve, N. K. Sauter, & P. D. Adams,\n        Acta Crystallographica Section A Foundations of Crystallography, 2003,\n        60(1), 1-6. doi:10.1107/S010876730302186X\n\n        Args:\n            tol (float): The numerical tolerance. The default of 1e-5 should\n                result in stable behavior for most cases.\n\n        Returns:\n            Niggli-reduced lattice.\n        \"\"\"\n        # lll reduction is more stable for skewed cells\n        matrix = self.lll_matrix\n        a = matrix[0]\n        b = matrix[1]\n        c = matrix[2]\n        e = tol * self.volume ** (1 / 3)\n\n        # Define metric tensor\n        G = [\n            [dot(a, a), dot(a, b), dot(a, c)],\n            [dot(a, b), dot(b, b), dot(b, c)],\n            [dot(a, c), dot(b, c), dot(c, c)],\n        ]\n        G = np.array(G)\n\n        # This sets an upper limit on the number of iterations.\n        for count in range(100):\n            # The steps are labelled as Ax as per the labelling scheme in the\n            # paper.\n            (A, B, C, E, N, Y) = (\n                G[0, 0],\n                G[1, 1],\n                G[2, 2],\n                2 * G[1, 2],\n                2 * G[0, 2],\n                2 * G[0, 1],\n            )\n\n            if A > B + e or (abs(A - B) < e and abs(E) > abs(N) + e):\n                # A1\n                M = [[0, -1, 0], [-1, 0, 0], [0, 0, -1]]\n                G = dot(transpose(M), dot(G, M))\n            if (B > C + e) or (abs(B - C) < e and abs(N) > abs(Y) + e):\n                # A2\n                M = [[-1, 0, 0], [0, 0, -1], [0, -1, 0]]\n                G = dot(transpose(M), dot(G, M))\n                continue\n\n            l = 0 if abs(E) < e else E / abs(E)\n            m = 0 if abs(N) < e else N / abs(N)\n            n = 0 if abs(Y) < e else Y / abs(Y)\n            if l * m * n == 1:\n                # A3\n                i = -1 if l == -1 else 1\n                j = -1 if m == -1 else 1\n                k = -1 if n == -1 else 1\n                M = [[i, 0, 0], [0, j, 0], [0, 0, k]]\n                G = dot(transpose(M), dot(G, M))\n            elif l * m * n == 0 or l * m * n == -1:\n                # A4\n                i = -1 if l == 1 else 1\n                j = -1 if m == 1 else 1\n                k = -1 if n == 1 else 1\n\n                if i * j * k == -1:\n                    if n == 0:\n                        k = -1\n                    elif m == 0:\n                        j = -1\n                    elif l == 0:\n                        i = -1\n                M = [[i, 0, 0], [0, j, 0], [0, 0, k]]\n                G = dot(transpose(M), dot(G, M))\n\n            (A, B, C, E, N, Y) = (\n                G[0, 0],\n                G[1, 1],\n                G[2, 2],\n                2 * G[1, 2],\n                2 * G[0, 2],\n                2 * G[0, 1],\n            )\n\n            # A5\n            if (\n                abs(E) > B + e\n                or (abs(E - B) < e and 2 * N < Y - e)\n                or (abs(E + B) < e and Y < -e)\n            ):\n                M = [[1, 0, 0], [0, 1, -E / abs(E)], [0, 0, 1]]\n                G = dot(transpose(M), dot(G, M))\n                continue\n\n            # A6\n            if (\n                abs(N) > A + e\n                or (abs(A - N) < e and 2 * E < Y - e)\n                or (abs(A + N) < e and Y < -e)\n            ):\n                M = [[1, 0, -N / abs(N)], [0, 1, 0], [0, 0, 1]]\n                G = dot(transpose(M), dot(G, M))\n                continue\n\n            # A7\n            if (\n                abs(Y) > A + e\n                or (abs(A - Y) < e and 2 * E < N - e)\n                or (abs(A + Y) < e and N < -e)\n            ):\n                M = [[1, -Y / abs(Y), 0], [0, 1, 0], [0, 0, 1]]\n                G = dot(transpose(M), dot(G, M))\n                continue\n\n            # A8\n            if E + N + Y + A + B < -e or (abs(E + N + Y + A + B) < e < Y + (A + N) * 2):\n                M = [[1, 0, 1], [0, 1, 1], [0, 0, 1]]\n                G = dot(transpose(M), dot(G, M))\n                continue\n\n            break\n\n        A = G[0, 0]\n        B = G[1, 1]\n        C = G[2, 2]\n        E = 2 * G[1, 2]\n        N = 2 * G[0, 2]\n        Y = 2 * G[0, 1]\n        a = math.sqrt(A)\n        b = math.sqrt(B)\n        c = math.sqrt(C)\n        alpha = math.acos(E / 2 / b / c) / math.pi * 180\n        beta = math.acos(N / 2 / a / c) / math.pi * 180\n        gamma = math.acos(Y / 2 / a / b) / math.pi * 180\n\n        latt = Lattice.from_parameters(a, b, c, alpha, beta, gamma)\n\n        mapped = self.find_mapping(latt, e, skip_rotation_matrix=True)\n        if mapped is not None:\n            if np.linalg.det(mapped[0].matrix) > 0:\n                return mapped[0]\n            else:\n                return Lattice(-mapped[0].matrix)\n\n        raise ValueError(\"can't find niggli\")"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef scale(self, new_volume: float) -> \"Lattice\":\n        versors = self.matrix / self.abc\n\n        geo_factor = abs(dot(np.cross(versors[0], versors[1]), versors[2]))\n\n        ratios = np.array(self.abc) / self.c\n\n        new_c = (new_volume / (geo_factor * np.prod(ratios))) ** (1 / 3.0)\n\n        return Lattice(versors * (new_c * ratios))", "response": "Returns a new Lattice with volume new_volume by performing a\n            scaling of the lattice vectors so that length proportions and angles are preserved."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the Wigner - Seitz cell for the given lattice.", "response": "def get_wigner_seitz_cell(self) -> List[List[np.ndarray]]:\n        \"\"\"\n        Returns the Wigner-Seitz cell for the given lattice.\n\n        Returns:\n            A list of list of coordinates.\n            Each element in the list is a \"facet\" of the boundary of the\n            Wigner Seitz cell. For instance, a list of four coordinates will\n            represent a square facet.\n        \"\"\"\n        vec1 = self._matrix[0]\n        vec2 = self._matrix[1]\n        vec3 = self._matrix[2]\n\n        list_k_points = []\n        for i, j, k in itertools.product([-1, 0, 1], [-1, 0, 1], [-1, 0, 1]):\n            list_k_points.append(i * vec1 + j * vec2 + k * vec3)\n        from scipy.spatial import Voronoi\n\n        tess = Voronoi(list_k_points)\n        to_return = []\n        for r in tess.ridge_dict:\n            if r[0] == 13 or r[1] == 13:\n                to_return.append([tess.vertices[i] for i in tess.ridge_dict[r]])\n\n        return to_return"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef dot(\n        self, coords_a: Vector3Like, coords_b: Vector3Like, frac_coords: bool = False\n    ) -> np.ndarray:\n        \"\"\"\n        Compute the scalar product of vector(s).\n\n        Args:\n            coords_a, coords_b: Array-like objects with the coordinates.\n            frac_coords (bool): Boolean stating whether the vector\n                corresponds to fractional or cartesian coordinates.\n\n        Returns:\n            one-dimensional `numpy` array.\n        \"\"\"\n        coords_a, coords_b = (\n            np.reshape(coords_a, (-1, 3)),\n            np.reshape(coords_b, (-1, 3)),\n        )\n\n        if len(coords_a) != len(coords_b):\n            raise ValueError(\"\")\n\n        if np.iscomplexobj(coords_a) or np.iscomplexobj(coords_b):\n            raise TypeError(\"Complex array!\")\n\n        if not frac_coords:\n            cart_a, cart_b = coords_a, coords_b\n        else:\n            cart_a = np.reshape(\n                [self.get_cartesian_coords(vec) for vec in coords_a], (-1, 3)\n            )\n            cart_b = np.reshape(\n                [self.get_cartesian_coords(vec) for vec in coords_b], (-1, 3)\n            )\n\n        return np.array([dot(a, b) for a, b in zip(cart_a, cart_b)])", "response": "Compute the scalar product of vectors with the coordinates."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncompute the norm of vector ( s ).", "response": "def norm(self, coords: Vector3Like, frac_coords: bool = True) -> float:\n        \"\"\"\n        Compute the norm of vector(s).\n\n        Args:\n            coords:\n                Array-like object with the coordinates.\n            frac_coords:\n                Boolean stating whether the vector corresponds to fractional or\n                cartesian coordinates.\n\n        Returns:\n            one-dimensional `numpy` array.\n        \"\"\"\n        return np.sqrt(self.dot(coords, coords, frac_coords=frac_coords))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nfinding all points within a sphere from the point taking into account periodic boundary conditions. This includes sites in other periodic images. Algorithm: 1. place sphere of radius r in crystal and determine minimum supercell (parallelpiped) which would contain a sphere of radius r. for this we need the projection of a_1 on a unit vector perpendicular to a_2 & a_3 (i.e. the unit vector in the direction b_1) to determine how many a_1\"s it will take to contain the sphere. Nxmax = r * length_of_b_1 / (2 Pi) 2. keep points falling within r. Args: frac_points: All points in the lattice in fractional coordinates. center: Cartesian coordinates of center of sphere. r: radius of sphere. zip_results (bool): Whether to zip the results together to group by point, or return the raw fcoord, dist, index arrays Returns: if zip_results: [(fcoord, dist, index, supercell_image) ...] since most of the time, subsequent processing requires the distance, index number of the atom, or index of the image else: fcoords, dists, inds, image", "response": "def get_points_in_sphere(\n        self,\n        frac_points: List[Vector3Like],\n        center: Vector3Like,\n        r: float,\n        zip_results=True,\n    ) -> Union[\n        List[Tuple[np.ndarray, float, int, np.ndarray]],\n        Tuple[List[np.ndarray], List[float], List[int], List[np.ndarray]],\n    ]:\n        \"\"\"\n        Find all points within a sphere from the point taking into account\n        periodic boundary conditions. This includes sites in other periodic\n        images.\n\n        Algorithm:\n\n        1. place sphere of radius r in crystal and determine minimum supercell\n           (parallelpiped) which would contain a sphere of radius r. for this\n           we need the projection of a_1 on a unit vector perpendicular\n           to a_2 & a_3 (i.e. the unit vector in the direction b_1) to\n           determine how many a_1\"s it will take to contain the sphere.\n\n           Nxmax = r * length_of_b_1 / (2 Pi)\n\n        2. keep points falling within r.\n\n        Args:\n            frac_points: All points in the lattice in fractional coordinates.\n            center: Cartesian coordinates of center of sphere.\n            r: radius of sphere.\n            zip_results (bool): Whether to zip the results together to group by\n                 point, or return the raw fcoord, dist, index arrays\n\n        Returns:\n            if zip_results:\n                [(fcoord, dist, index, supercell_image) ...] since most of the time, subsequent\n                processing requires the distance, index number of the atom, or index of the image\n            else:\n                fcoords, dists, inds, image\n        \"\"\"\n        # TODO: refactor to use lll matrix (nmax will be smaller)\n        # Determine the maximum number of supercells in each direction\n        #  required to contain a sphere of radius n\n        recp_len = np.array(self.reciprocal_lattice.abc) / (2 * pi)\n        nmax = float(r) * recp_len + 0.01\n\n        # Get the fractional coordinates of the center of the sphere\n        pcoords = self.get_fractional_coords(center)\n        center = np.array(center)\n\n        # Prepare the list of output atoms\n        n = len(frac_points)\n        fcoords = np.array(frac_points) % 1\n        indices = np.arange(n)\n\n        # Generate all possible images that could be within `r` of `center`\n        mins = np.floor(pcoords - nmax)\n        maxes = np.ceil(pcoords + nmax)\n        arange = np.arange(start=mins[0], stop=maxes[0], dtype=np.int)\n        brange = np.arange(start=mins[1], stop=maxes[1], dtype=np.int)\n        crange = np.arange(start=mins[2], stop=maxes[2], dtype=np.int)\n        arange = arange[:, None] * np.array([1, 0, 0], dtype=np.int)[None, :]\n        brange = brange[:, None] * np.array([0, 1, 0], dtype=np.int)[None, :]\n        crange = crange[:, None] * np.array([0, 0, 1], dtype=np.int)[None, :]\n        images = arange[:, None, None] + brange[None, :, None] + crange[None, None, :]\n\n        # Generate the coordinates of all atoms within these images\n        shifted_coords = fcoords[:, None, None, None, :] + images[None, :, :, :, :]\n\n        # Determine distance from `center`\n        cart_coords = self.get_cartesian_coords(fcoords)\n        cart_images = self.get_cartesian_coords(images)\n        coords = cart_coords[:, None, None, None, :] + cart_images[None, :, :, :, :]\n        coords -= center[None, None, None, None, :]\n        coords **= 2\n        d_2 = np.sum(coords, axis=4)\n\n        # Determine which points are within `r` of `center`\n        within_r = np.where(d_2 <= r ** 2)\n        #  `within_r` now contains the coordinates of each image that is\n        #    inside of the cutoff distance. It has 4 coordinates:\n        #   0 - index of the image within `frac_points`\n        #   1,2,3 - index of the supercell which holds the images in the x, y, z directions\n\n        if zip_results:\n            return list(\n                zip(\n                    shifted_coords[within_r],\n                    np.sqrt(d_2[within_r]),\n                    indices[within_r[0]],\n                    images[within_r[1:]],\n                )\n            )\n        else:\n            return (\n                shifted_coords[within_r],\n                np.sqrt(d_2[within_r]),\n                indices[within_r[0]],\n                images[within_r[1:]],\n            )"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_all_distances(\n        self,\n        fcoords1: Union[Vector3Like, List[Vector3Like]],\n        fcoords2: Union[Vector3Like, List[Vector3Like]],\n    ) -> np.ndarray:\n        \"\"\"\n        Returns the distances between two lists of coordinates taking into\n        account periodic boundary conditions and the lattice. Note that this\n        computes an MxN array of distances (i.e. the distance between each\n        point in fcoords1 and every coordinate in fcoords2). This is\n        different functionality from pbc_diff.\n\n        Args:\n            fcoords1: First set of fractional coordinates. e.g., [0.5, 0.6,\n                0.7] or [[1.1, 1.2, 4.3], [0.5, 0.6, 0.7]]. It can be a single\n                coord or any array of coords.\n            fcoords2: Second set of fractional coordinates.\n\n        Returns:\n            2d array of cartesian distances. E.g the distance between\n            fcoords1[i] and fcoords2[j] is distances[i,j]\n        \"\"\"\n        v, d2 = pbc_shortest_vectors(self, fcoords1, fcoords2, return_d2=True)\n        return np.sqrt(d2)", "response": "This function calculates the distances between two lists of coordinates taking into\n            account periodic boundary conditions and the lattice."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_distance_and_image(\n        self,\n        frac_coords1: Vector3Like,\n        frac_coords2: Vector3Like,\n        jimage: Optional[Union[List[int], np.ndarray]] = None,\n    ) -> Tuple[float, np.ndarray]:\n        \"\"\"\n        Gets distance between two frac_coords assuming periodic boundary\n        conditions. If the index jimage is not specified it selects the j\n        image nearest to the i atom and returns the distance and jimage\n        indices in terms of lattice vector translations. If the index jimage\n        is specified it returns the distance between the frac_coords1 and\n        the specified jimage of frac_coords2, and the given jimage is also\n        returned.\n\n        Args:\n            fcoords1 (3x1 array): Reference fcoords to get distance from.\n            fcoords2 (3x1 array): fcoords to get distance from.\n            jimage (3x1 array): Specific periodic image in terms of\n                lattice translations, e.g., [1,0,0] implies to take periodic\n                image that is one a-lattice vector away. If jimage is None,\n                the image that is nearest to the site is found.\n\n        Returns:\n            (distance, jimage): distance and periodic lattice translations\n            of the other site for which the distance applies. This means that\n            the distance between frac_coords1 and (jimage + frac_coords2) is\n            equal to distance.\n        \"\"\"\n        if jimage is None:\n            v, d2 = pbc_shortest_vectors(\n                self, frac_coords1, frac_coords2, return_d2=True\n            )\n            fc = self.get_fractional_coords(v[0][0]) + frac_coords1 - frac_coords2\n            fc = np.array(np.round(fc), dtype=np.int)\n            return np.sqrt(d2[0, 0]), fc\n\n        jimage = np.array(jimage)\n        mapped_vec = self.get_cartesian_coords(jimage + frac_coords2 - frac_coords1)\n        return np.linalg.norm(mapped_vec), jimage", "response": "Gets the distance between two frac_coords assuming periodic boundary conditions."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_miller_index_from_coords(\n        self,\n        coords: Vector3Like,\n        coords_are_cartesian: bool = True,\n        round_dp: int = 4,\n        verbose: bool = True,\n    ) -> Tuple[int, int, int]:\n        \"\"\"\n        Get the Miller index of a plane from a list of site coordinates.\n\n        A minimum of 3 sets of coordinates are required. If more than 3 sets of\n        coordinates are given, the best plane that minimises the distance to all\n        points will be calculated.\n\n        Args:\n            coords (iterable): A list or numpy array of coordinates. Can be\n                cartesian or fractional coordinates. If more than three sets of\n                coordinates are provided, the best plane that minimises the\n                distance to all sites will be calculated.\n            coords_are_cartesian (bool, optional): Whether the coordinates are\n                in cartesian space. If using fractional coordinates set to\n                False.\n            round_dp (int, optional): The number of decimal places to round the\n                miller index to.\n            verbose (bool, optional): Whether to print warnings.\n\n        Returns:\n            (tuple): The Miller index.\n        \"\"\"\n        if coords_are_cartesian:\n            coords = [self.get_fractional_coords(c) for c in coords]\n\n        coords = np.asarray(coords)\n        g = coords.sum(axis=0) / coords.shape[0]\n\n        # run singular value decomposition\n        _, _, vh = np.linalg.svd(coords - g)\n\n        # get unitary normal vector\n        u_norm = vh[2, :]\n        return get_integer_index(u_norm, round_dp=round_dp, verbose=verbose)", "response": "This function returns the Miller index of a plane from a list of site coordinates."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef read_route_line(route):\n    scrf_patt = re.compile(r\"^([sS][cC][rR][fF])\\s*=\\s*(.+)\")\n    multi_params_patt = re.compile(r\"^([A-z]+[0-9]*)[\\s=]+\\((.*)\\)$\")\n    functional = None\n    basis_set = None\n    route_params = {}\n    dieze_tag = None\n    if route:\n        if \"/\" in route:\n            tok = route.split(\"/\")\n            functional = tok[0].split()[-1]\n            basis_set = tok[1].split()[0]\n            for tok in [functional, basis_set, \"/\"]:\n                route = route.replace(tok, \"\")\n\n        for tok in route.split():\n            if scrf_patt.match(tok):\n                m = scrf_patt.match(tok)\n                route_params[m.group(1)] = m.group(2)\n            elif tok.upper() in [\"#\", \"#N\", \"#P\", \"#T\"]:\n                # does not store # in route to avoid error in input\n                if tok == \"#\":\n                    dieze_tag = \"#N\"\n                else:\n                    dieze_tag = tok\n                continue\n            else:\n                m = re.match(multi_params_patt, tok.strip(\"#\"))\n                if m:\n                    pars = {}\n                    for par in m.group(2).split(\",\"):\n                        p = par.split(\"=\")\n                        pars[p[0]] = None if len(p) == 1 else p[1]\n                    route_params[m.group(1)] = pars\n                else:\n                    d = tok.strip(\"#\").split(\"=\")\n                    route_params[d[0]] = None if len(d) == 1 else d[1]\n\n    return functional, basis_set, route_params, dieze_tag", "response": "Reads a route line in gaussian input and returns functional basis set and a dictionary of other route parameters"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _parse_coords(coord_lines):\n        paras = {}\n        var_pattern = re.compile(r\"^([A-Za-z]+\\S*)[\\s=,]+([\\d\\-\\.]+)$\")\n        for l in coord_lines:\n            m = var_pattern.match(l.strip())\n            if m:\n                paras[m.group(1).strip(\"=\")] = float(m.group(2))\n\n        species = []\n        coords = []\n        # Stores whether a Zmatrix format is detected. Once a zmatrix format\n        # is detected, it is assumed for the remaining of the parsing.\n        zmode = False\n        for l in coord_lines:\n            l = l.strip()\n            if not l:\n                break\n            if (not zmode) and GaussianInput._xyz_patt.match(l):\n                m = GaussianInput._xyz_patt.match(l)\n                species.append(m.group(1))\n                toks = re.split(r\"[,\\s]+\", l.strip())\n                if len(toks) > 4:\n                    coords.append([float(i) for i in toks[2:5]])\n                else:\n                    coords.append([float(i) for i in toks[1:4]])\n            elif GaussianInput._zmat_patt.match(l):\n                zmode = True\n                toks = re.split(r\"[,\\s]+\", l.strip())\n                species.append(toks[0])\n                toks.pop(0)\n                if len(toks) == 0:\n                    coords.append(np.array([0, 0, 0]))\n                else:\n                    nn = []\n                    parameters = []\n                    while len(toks) > 1:\n                        ind = toks.pop(0)\n                        data = toks.pop(0)\n                        try:\n                            nn.append(int(ind))\n                        except ValueError:\n                            nn.append(species.index(ind) + 1)\n                        try:\n                            val = float(data)\n                            parameters.append(val)\n                        except ValueError:\n                            if data.startswith(\"-\"):\n                                parameters.append(-paras[data[1:]])\n                            else:\n                                parameters.append(paras[data])\n                    if len(nn) == 1:\n                        coords.append(np.array([0, 0, parameters[0]]))\n                    elif len(nn) == 2:\n                        coords1 = coords[nn[0] - 1]\n                        coords2 = coords[nn[1] - 1]\n                        bl = parameters[0]\n                        angle = parameters[1]\n                        axis = [0, 1, 0]\n                        op = SymmOp.from_origin_axis_angle(coords1, axis,\n                                                           angle, False)\n                        coord = op.operate(coords2)\n                        vec = coord - coords1\n                        coord = vec * bl / np.linalg.norm(vec) + coords1\n                        coords.append(coord)\n                    elif len(nn) == 3:\n                        coords1 = coords[nn[0] - 1]\n                        coords2 = coords[nn[1] - 1]\n                        coords3 = coords[nn[2] - 1]\n                        bl = parameters[0]\n                        angle = parameters[1]\n                        dih = parameters[2]\n                        v1 = coords3 - coords2\n                        v2 = coords1 - coords2\n                        axis = np.cross(v1, v2)\n                        op = SymmOp.from_origin_axis_angle(\n                            coords1, axis, angle, False)\n                        coord = op.operate(coords2)\n                        v1 = coord - coords1\n                        v2 = coords1 - coords2\n                        v3 = np.cross(v1, v2)\n                        adj = get_angle(v3, axis)\n                        axis = coords1 - coords2\n                        op = SymmOp.from_origin_axis_angle(\n                            coords1, axis, dih - adj, False)\n                        coord = op.operate(coord)\n                        vec = coord - coords1\n                        coord = vec * bl / np.linalg.norm(vec) + coords1\n                        coords.append(coord)\n\n        def _parse_species(sp_str):\n            \"\"\"\n            The species specification can take many forms. E.g.,\n            simple integers representing atomic numbers (\"8\"),\n            actual species string (\"C\") or a labelled species (\"C1\").\n            Sometimes, the species string is also not properly capitalized,\n            e.g, (\"c1\"). This method should take care of these known formats.\n            \"\"\"\n            try:\n                return int(sp_str)\n            except ValueError:\n                sp = re.sub(r\"\\d\", \"\", sp_str)\n                return sp.capitalize()\n\n        species = [_parse_species(sp) for sp in species]\n\n        return Molecule(species, coords)", "response": "Parses the coordinates of the current log entry."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef from_string(contents):\n        lines = [l.strip() for l in contents.split(\"\\n\")]\n\n        link0_patt = re.compile(r\"^(%.+)\\s*=\\s*(.+)\")\n        link0_dict = {}\n        for i, l in enumerate(lines):\n            if link0_patt.match(l):\n                m = link0_patt.match(l)\n                link0_dict[m.group(1).strip(\"=\")] = m.group(2)\n\n        route_patt = re.compile(r\"^#[sSpPnN]*.*\")\n        route = \"\"\n        route_index = None\n        for i, l in enumerate(lines):\n            if route_patt.match(l):\n                route += \" \" + l\n                route_index = i\n            # This condition allows for route cards spanning multiple lines\n            elif (l == \"\" or l.isspace()) and route_index:\n                break\n        functional, basis_set, route_paras, dieze_tag = read_route_line(route)\n        ind = 2\n        title = []\n        while lines[route_index + ind].strip():\n            title.append(lines[route_index + ind].strip())\n            ind += 1\n        title = ' '.join(title)\n        ind += 1\n        toks = re.split(r\"[,\\s]+\", lines[route_index + ind])\n        charge = int(toks[0])\n        spin_mult = int(toks[1])\n        coord_lines = []\n        spaces = 0\n        input_paras = {}\n        ind += 1\n        for i in range(route_index + ind, len(lines)):\n            if lines[i].strip() == \"\":\n                spaces += 1\n            if spaces >= 2:\n                d = lines[i].split(\"=\")\n                if len(d) == 2:\n                    input_paras[d[0]] = d[1]\n            else:\n                coord_lines.append(lines[i].strip())\n        mol = GaussianInput._parse_coords(coord_lines)\n        mol.set_charge_and_spin(charge, spin_mult)\n\n        return GaussianInput(mol, charge=charge, spin_multiplicity=spin_mult,\n                             title=title, functional=functional,\n                             basis_set=basis_set,\n                             route_parameters=route_paras,\n                             input_parameters=input_paras,\n                             link0_parameters=link0_dict,\n                             dieze_tag=dieze_tag)", "response": "Creates a GaussianInput object from a string."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _find_nn_pos_before_site(self, siteindex):\n        alldist = [(self._mol.get_distance(siteindex, i), i)\n                   for i in range(siteindex)]\n        alldist = sorted(alldist, key=lambda x: x[0])\n        return [d[1] for d in alldist]", "response": "Returns index of nearest neighbor atoms."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a z - matrix representation of the molecule.", "response": "def get_zmatrix(self):\n        \"\"\"\n        Returns a z-matrix representation of the molecule.\n        \"\"\"\n        output = []\n        outputvar = []\n        for i, site in enumerate(self._mol):\n            if i == 0:\n                output.append(\"{}\".format(site.specie))\n            elif i == 1:\n                nn = self._find_nn_pos_before_site(i)\n                bondlength = self._mol.get_distance(i, nn[0])\n                output.append(\"{} {} B{}\".format(self._mol[i].specie,\n                                                 nn[0] + 1, i))\n                outputvar.append(\"B{}={:.6f}\".format(i, bondlength))\n            elif i == 2:\n                nn = self._find_nn_pos_before_site(i)\n                bondlength = self._mol.get_distance(i, nn[0])\n                angle = self._mol.get_angle(i, nn[0], nn[1])\n                output.append(\"{} {} B{} {} A{}\".format(self._mol[i].specie,\n                                                        nn[0] + 1, i,\n                                                        nn[1] + 1, i))\n                outputvar.append(\"B{}={:.6f}\".format(i, bondlength))\n                outputvar.append(\"A{}={:.6f}\".format(i, angle))\n            else:\n                nn = self._find_nn_pos_before_site(i)\n                bondlength = self._mol.get_distance(i, nn[0])\n                angle = self._mol.get_angle(i, nn[0], nn[1])\n                dih = self._mol.get_dihedral(i, nn[0], nn[1], nn[2])\n                output.append(\"{} {} B{} {} A{} {} D{}\"\n                              .format(self._mol[i].specie, nn[0] + 1, i,\n                                      nn[1] + 1, i, nn[2] + 1, i))\n                outputvar.append(\"B{}={:.6f}\".format(i, bondlength))\n                outputvar.append(\"A{}={:.6f}\".format(i, angle))\n                outputvar.append(\"D{}={:.6f}\".format(i, dih))\n        return \"\\n\".join(output) + \"\\n\\n\" + \"\\n\".join(outputvar)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_cart_coords(self):\n        def to_s(x):\n            return \"%0.6f\" % x\n\n        outs = []\n        for i, site in enumerate(self._mol):\n            outs.append(\" \".join([site.species_string,\n                                  \" \".join([to_s(j) for j in site.coords])]))\n        return \"\\n\".join(outs)", "response": "Return the cartesian coordinates of the molecule"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a string representation of the current GaussianInput object.", "response": "def to_string(self, cart_coords=False):\n        \"\"\"\n        Return GaussianInput string\n\n        Option: whe cart_coords sets to True return the cartesian coordinates\n                instead of the z-matrix\n\n        \"\"\"\n        def para_dict_to_string(para, joiner=\" \"):\n            para_str = []\n            # sorted is only done to make unittests work reliably\n            for par, val in sorted(para.items()):\n                if val is None or val == \"\":\n                    para_str.append(par)\n                elif isinstance(val, dict):\n                    val_str = para_dict_to_string(val, joiner=\",\")\n                    para_str.append(\"{}=({})\".format(par, val_str))\n                else:\n                    para_str.append(\"{}={}\".format(par, val))\n            return joiner.join(para_str)\n\n        output = []\n        if self.link0_parameters:\n            output.append(para_dict_to_string(self.link0_parameters, \"\\n\"))\n        output.append(\"{diez} {func}/{bset} {route}\"\n                      .format(diez=self.dieze_tag, func=self.functional,\n                              bset=self.basis_set,\n                              route=para_dict_to_string(self.route_parameters))\n                      )\n        output.append(\"\")\n        output.append(self.title)\n        output.append(\"\")\n        output.append(\"{} {}\".format(self.charge, self.spin_multiplicity))\n        if isinstance(self._mol, Molecule):\n            if cart_coords is True:\n                output.append(self.get_cart_coords())\n            else:\n                output.append(self.get_zmatrix())\n        else:\n            output.append(str(self._mol))\n        output.append(\"\")\n        if self.gen_basis is not None:\n            output.append(\"{:s}\\n\".format(self.gen_basis))\n        output.append(para_dict_to_string(self.input_parameters, \"\\n\"))\n        output.append(\"\\n\")\n        return \"\\n\".join(output)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef write_file(self, filename, cart_coords=False):\n        with zopen(filename, \"w\") as f:\n            f.write(self.to_string(cart_coords))", "response": "Write the input string into a file"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef read_scan(self):\n\n        def floatList(l):\n            \"\"\" return a list of float from a list of string \"\"\"\n            return [float(v) for v in l]\n\n        scan_patt = re.compile(r\"^\\sSummary of the potential surface scan:\")\n        optscan_patt = re.compile(r\"^\\sSummary of Optimized Potential Surface Scan\")\n\n        # data dict return\n        data = {\"energies\": list(), \"coords\": dict()}\n\n        # read in file\n        with zopen(self.filename, \"r\") as f:\n            line = f.readline()\n\n            while line != \"\":\n                if optscan_patt.match(line):\n                    f.readline()\n                    line = f.readline()\n                    endScan = False\n                    while not endScan:\n                        data[\"energies\"] += floatList(float_patt.findall(line))\n                        line = f.readline()\n                        while not re.search(r\"(^\\s+(\\d+)|^\\s-+)\", line):\n                            icname = line.split()[0].strip()\n                            if icname in data[\"coords\"]:\n                                data[\"coords\"][icname] += floatList(float_patt.findall(line))\n                            else:\n                                data[\"coords\"][icname] = floatList(float_patt.findall(line))\n                            line = f.readline()\n                        if re.search(r\"^\\s-+\", line):\n                            endScan = True\n                        else:\n                            line = f.readline()\n\n                elif scan_patt.match(line):\n                    line = f.readline()\n                    data[\"coords\"] = {icname: list()\n                                      for icname in line.split()[1:-1]}\n                    f.readline()\n                    line = f.readline()\n                    while not re.search(r\"^\\s-+\", line):\n                        values = floatList(line.split())\n                        data[\"energies\"].append(values[-1])\n                        for i, icname in enumerate(data[\"coords\"]):\n                            data[\"coords\"][icname].append(values[i+1])\n                        line = f.readline()\n                else:\n                    line = f.readline()\n\n        return data", "response": "Reads a potential energy surface from a gaussian scan calculation."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget a matplotlib plot of the potential energy surface.", "response": "def get_scan_plot(self, coords=None):\n        \"\"\"\n        Get a matplotlib plot of the potential energy surface.\n\n        Args:\n            coords: internal coordinate name to use as abcissa.\n        \"\"\"\n        from pymatgen.util.plotting import pretty_plot\n\n        plt = pretty_plot(12, 8)\n\n        d = self.read_scan()\n\n        if coords and coords in d[\"coords\"]:\n            x = d[\"coords\"][coords]\n            plt.xlabel(coords)\n        else:\n            x = range(len(d[\"energies\"]))\n            plt.xlabel(\"points\")\n\n        plt.ylabel(\"Energy (eV)\")\n\n        e_min = min(d[\"energies\"])\n        y = [(e - e_min) * Ha_to_eV for e in d[\"energies\"]]\n\n        plt.plot(x, y, \"ro--\")\n        return plt"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsaves matplotlib plot of the potential energy surface to a file.", "response": "def save_scan_plot(self, filename=\"scan.pdf\",\n                       img_format=\"pdf\", coords=None):\n        \"\"\"\n        Save matplotlib plot of the potential energy surface to a file.\n\n        Args:\n            filename: Filename to write to.\n            img_format: Image format to use. Defaults to EPS.\n            coords: internal coordinate name to use as abcissa.\n        \"\"\"\n        plt = self.get_scan_plot(coords)\n        plt.savefig(filename, format=img_format)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef read_excitation_energies(self):\n\n        transitions = list()\n\n        # read in file\n        with zopen(self.filename, \"r\") as f:\n            line = f.readline()\n            td = False\n            while line != \"\":\n                if re.search(r\"^\\sExcitation energies and oscillator strengths:\", line):\n                    td = True\n\n                if td:\n                    if re.search(r\"^\\sExcited State\\s*\\d\", line):\n                        val = [float(v) for v in float_patt.findall(line)]\n                        transitions.append(tuple(val[0:3]))\n                line = f.readline()\n        return transitions", "response": "Reads a list of excitation energies from the file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting a matplotlib plot of the UV - visible xas.", "response": "def get_spectre_plot(self, sigma=0.05, step=0.01):\n        \"\"\"\n        Get a matplotlib plot of the UV-visible xas. Transition are plotted\n        as vertical lines and as a sum of normal functions with sigma with. The\n        broadening is applied in energy and the xas is plotted as a function\n        of the wavelength.\n\n        Args:\n            sigma: Full width at half maximum in eV for normal functions.\n            step: bin interval in eV\n\n        Returns:\n            A dict: {\"energies\": values, \"lambda\": values, \"xas\": values}\n                    where values are lists of abscissa (energies, lamba) and\n                    the sum of gaussian functions (xas).\n            A matplotlib plot.\n        \"\"\"\n        from pymatgen.util.plotting import pretty_plot\n        from matplotlib.mlab import normpdf\n        plt = pretty_plot(12, 8)\n\n        transitions = self.read_excitation_energies()\n\n        minval = min([val[0] for val in transitions]) - 5.0 * sigma\n        maxval = max([val[0] for val in transitions]) + 5.0 * sigma\n        npts = int((maxval - minval) / step) + 1\n\n        eneval = np.linspace(minval, maxval, npts)  # in eV\n        lambdaval = [cst.h * cst.c / (val * cst.e) * 1.e9\n                     for val in eneval]  # in nm\n\n        # sum of gaussian functions\n        spectre = np.zeros(npts)\n        for trans in transitions:\n            spectre += trans[2] * normpdf(eneval, trans[0], sigma)\n        spectre /= spectre.max()\n        plt.plot(lambdaval, spectre, \"r-\", label=\"spectre\")\n\n        data = {\"energies\": eneval, \"lambda\": lambdaval, \"xas\": spectre}\n\n        # plot transitions as vlines\n        plt.vlines([val[1] for val in transitions],\n                   0.,\n                   [val[2] for val in transitions],\n                   color=\"blue\",\n                   label=\"transitions\",\n                   linewidth=2)\n\n        plt.xlabel(\"$\\\\lambda$ (nm)\")\n        plt.ylabel(\"Arbitrary unit\")\n        plt.legend()\n\n        return data, plt"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsaving matplotlib plot of the spectre.", "response": "def save_spectre_plot(self, filename=\"spectre.pdf\", img_format=\"pdf\",\n                          sigma=0.05, step=0.01):\n        \"\"\"\n        Save matplotlib plot of the spectre to a file.\n\n        Args:\n            filename: Filename to write to.\n            img_format: Image format to use. Defaults to EPS.\n            sigma: Full width at half maximum in eV for normal functions.\n            step: bin interval in eV\n        \"\"\"\n        d, plt = self.get_spectre_plot(sigma, step)\n        plt.savefig(filename, format=img_format)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating a new GaussianInput object from the current object.", "response": "def to_input(self, mol=None,  charge=None,\n                 spin_multiplicity=None, title=None, functional=None,\n                 basis_set=None, route_parameters=None, input_parameters=None,\n                 link0_parameters=None, dieze_tag=None, cart_coords=False):\n        \"\"\"\n        Create a new input object using by default the last geometry read in\n        the output file and with the same calculation parameters. Arguments\n        are the same as GaussianInput class.\n\n        Returns\n            gaunip (GaussianInput) : the gaussian input object\n        \"\"\"\n        if not mol:\n            mol = self.final_structure\n\n        if charge is None:\n            charge = self.charge\n\n        if spin_multiplicity is None:\n            spin_multiplicity = self.spin_multiplicity\n\n        if not title:\n            title = self.title\n\n        if not functional:\n            functional = self.functional\n\n        if not basis_set:\n            basis_set = self.basis_set\n\n        if not route_parameters:\n            route_parameters = self.route_parameters\n\n        if not link0_parameters:\n            link0_parameters = self.link0\n\n        if not dieze_tag:\n            dieze_tag = self.dieze_tag\n\n        return GaussianInput(mol=mol,\n                             charge=charge,\n                             spin_multiplicity=spin_multiplicity,\n                             title=title,\n                             functional=functional,\n                             basis_set=basis_set,\n                             route_parameters=route_parameters,\n                             input_parameters=input_parameters,\n                             link0_parameters=link0_parameters,\n                             dieze_tag=dieze_tag)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a list of predictions for the given species.", "response": "def list_prediction(self, species, to_this_composition=True):\n        \"\"\"\n        Args:\n            species:\n                list of species\n            to_this_composition:\n                If true, substitutions with this as a final composition\n                will be found. If false, substitutions with this as a\n                starting composition will be found (these are slightly\n                different)\n        Returns:\n            List of predictions in the form of dictionaries.\n            If to_this_composition is true, the values of the dictionary\n            will be from the list species. If false, the keys will be\n            from that list.\n        \"\"\"\n        for sp in species:\n            if get_el_sp(sp) not in self.p.species:\n                raise ValueError(\"the species {} is not allowed for the\"\n                                 \"probability model you are using\".format(sp))\n        max_probabilities = []\n        for s1 in species:\n            if to_this_composition:\n                max_p = max([self.p.cond_prob(s2, s1) for s2 in self.p.species])\n            else:\n                max_p = max([self.p.cond_prob(s1, s2) for s2 in self.p.species])\n            max_probabilities.append(max_p)\n\n        output = []\n\n        def _recurse(output_prob, output_species):\n            best_case_prob = list(max_probabilities)\n            best_case_prob[:len(output_prob)] = output_prob\n            if functools.reduce(mul, best_case_prob) > self.threshold:\n                if len(output_species) == len(species):\n                    odict = {\n                        'probability': functools.reduce(mul, best_case_prob)}\n                    if to_this_composition:\n                        odict['substitutions'] = dict(\n                            zip(output_species, species))\n                    else:\n                        odict['substitutions'] = dict(\n                            zip(species, output_species))\n                    if len(output_species) == len(set(output_species)):\n                        output.append(odict)\n                    return\n                for sp in self.p.species:\n                    i = len(output_prob)\n                    if to_this_composition:\n                        prob = self.p.cond_prob(sp, species[i])\n                    else:\n                        prob = self.p.cond_prob(species[i], sp)\n                    _recurse(output_prob + [prob], output_species + [sp])\n\n        _recurse([], [])\n        logging.info('{} substitutions found'.format(len(output)))\n        return output"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the charged balanced substitutions from a starting or ending composition.", "response": "def composition_prediction(self, composition, to_this_composition=True):\n        \"\"\"\n        Returns charged balanced substitutions from a starting or ending\n        composition.\n\n        Args:\n            composition:\n                starting or ending composition\n            to_this_composition:\n                If true, substitutions with this as a final composition\n                will be found. If false, substitutions with this as a\n                starting composition will be found (these are slightly\n                different)\n\n        Returns:\n            List of predictions in the form of dictionaries.\n            If to_this_composition is true, the values of the dictionary\n            will be from the list species. If false, the keys will be\n            from that list.\n        \"\"\"\n        preds = self.list_prediction(list(composition.keys()),\n                                     to_this_composition)\n        output = []\n        for p in preds:\n            if to_this_composition:\n                subs = {v: k for k, v in p['substitutions'].items()}\n            else:\n                subs = p['substitutions']\n            charge = 0\n            for k, v in composition.items():\n                charge += subs[k].oxi_state * v\n            if abs(charge) < 1e-8:\n                output.append(p)\n        logging.info('{} charge balanced substitutions found'\n                     .format(len(output)))\n        return output"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_parser(scheduler, err_file, out_file=None, run_err_file=None, batch_err_file=None):\n    cls = ALL_PARSERS.get(scheduler)\n    return cls if cls is None else cls(err_file, out_file, run_err_file, batch_err_file)", "response": "Returns a parser for the scheduler."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef parse_single(self, errmsg):\n        found = False\n        message = None\n        metadata = None\n        for k in errmsg.keys():\n            if self.files[k] is not None:\n                #print('parsing ', self.files[k], ' for ', errmsg[k]['string'])\n                try:\n                    with open(self.files[k], mode='r') as f:\n                        lines = f.read().split('\\n')\n                    for line in lines:\n                        if errmsg[k]['string'] in line:\n                            message = line\n                            found = True\n                    if found:\n                        metadata = self.extract_metadata(lines, errmsg[k]['meta_filter'])\n                except (IOError, OSError):\n                    print(self.files[k], 'not found')\n                    pass\n                except TypeError:\n                    print('type error', self.files[k], ' has type ', self.files[k].cls(), ' should be string.')\n                    pass\n\n        return found, message, metadata", "response": "Parse the provided files for the corresponding strings."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nparses for the occurens of all errors defined in ERRORS", "response": "def parse(self):\n        \"\"\"\n        Parse for the occurens of all errors defined in ERRORS\n        \"\"\"\n        errors_tested = 0\n        for error in self.error_definitions:\n            errors_tested += 1\n            result = self.parse_single(self.error_definitions[error])\n            if result[0]:\n                self.errors.append(error(result[1], result[2]))\n        if len(self.errors) > 0:\n            print('QUEUE_ERROR FOUND')\n            for error in self.errors:\n                print(error)\n\n        return errors_tested"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a symmetrized molecule The equivalent atoms obtained via :meth:`~pymatgen.symmetry.analyzer.PointGroupAnalyzer.get_equivalent_atoms` are rotated, mirrored... unto one position. Then the average position is calculated. The average position is rotated, mirrored... back with the inverse of the previous symmetry operations, which gives the symmetrized molecule Args: mol (Molecule): A pymatgen Molecule instance. max_n (int): Maximum number of iterations. tolerance (float): Tolerance for detecting symmetry. Gets passed as Argument into :class:`~pymatgen.analyzer.symmetry.PointGroupAnalyzer`. epsilon (float): If the elementwise absolute difference of two subsequently symmetrized structures is smaller epsilon, the iteration stops before ``max_n`` is reached. Returns: dict: The returned dictionary has three possible keys: ``sym_mol``: A symmetrized molecule instance. ``eq_sets``: A dictionary of indices mapping to sets of indices, each key maps to indices of all equivalent atoms. The keys are guaranteed to be not equivalent. ``sym_ops``: Twofold nested dictionary. ``operations[i][j]`` gives the symmetry operation that maps atom ``i`` unto ``j``.", "response": "def iterative_symmetrize(mol, max_n=10, tolerance=0.3, epsilon=1e-2):\n    \"\"\"Returns a symmetrized molecule\n\n    The equivalent atoms obtained via\n    :meth:`~pymatgen.symmetry.analyzer.PointGroupAnalyzer.get_equivalent_atoms`\n    are rotated, mirrored... unto one position.\n    Then the average position is calculated.\n    The average position is rotated, mirrored... back with the inverse\n    of the previous symmetry operations, which gives the\n    symmetrized molecule\n\n    Args:\n        mol (Molecule): A pymatgen Molecule instance.\n        max_n (int): Maximum number of iterations.\n        tolerance (float): Tolerance for detecting symmetry.\n            Gets passed as Argument into\n            :class:`~pymatgen.analyzer.symmetry.PointGroupAnalyzer`.\n        epsilon (float): If the elementwise absolute difference of two\n            subsequently symmetrized structures is smaller epsilon,\n            the iteration stops before ``max_n`` is reached.\n\n\n    Returns:\n        dict: The returned dictionary has three possible keys:\n\n        ``sym_mol``:\n        A symmetrized molecule instance.\n\n        ``eq_sets``:\n        A dictionary of indices mapping to sets of indices,\n        each key maps to indices of all equivalent atoms.\n        The keys are guaranteed to be not equivalent.\n\n        ``sym_ops``:\n        Twofold nested dictionary.\n        ``operations[i][j]`` gives the symmetry operation\n        that maps atom ``i`` unto ``j``.\n    \"\"\"\n    new = mol\n    n = 0\n    finished = False\n    while not finished and n <= max_n:\n        previous = new\n        PA = PointGroupAnalyzer(previous, tolerance=tolerance)\n        eq = PA.symmetrize_molecule()\n        new = eq['sym_mol']\n        finished = np.allclose(new.cart_coords, previous.cart_coords,\n                               atol=epsilon)\n        n += 1\n    return eq"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nclustering sites based on distance and species type.", "response": "def cluster_sites(mol, tol, give_only_index=False):\n    \"\"\"\n    Cluster sites based on distance and species type.\n\n    Args:\n        mol (Molecule): Molecule **with origin at center of mass**.\n        tol (float): Tolerance to use.\n\n    Returns:\n        (origin_site, clustered_sites): origin_site is a site at the center\n        of mass (None if there are no origin atoms). clustered_sites is a\n        dict of {(avg_dist, species_and_occu): [list of sites]}\n    \"\"\"\n    # Cluster works for dim > 2 data. We just add a dummy 0 for second\n    # coordinate.\n    dists = [[np.linalg.norm(site.coords), 0] for site in mol]\n    import scipy.cluster as spcluster\n    f = spcluster.hierarchy.fclusterdata(dists, tol, criterion='distance')\n    clustered_dists = defaultdict(list)\n    for i, site in enumerate(mol):\n        clustered_dists[f[i]].append(dists[i])\n    avg_dist = {label: np.mean(val) for label, val in clustered_dists.items()}\n    clustered_sites = defaultdict(list)\n    origin_site = None\n    for i, site in enumerate(mol):\n        if avg_dist[f[i]] < tol:\n            if give_only_index:\n                origin_site = i\n            else:\n                origin_site = site\n        else:\n            if give_only_index:\n                clustered_sites[\n                    (avg_dist[f[i]], site.species)].append(i)\n            else:\n                clustered_sites[\n                    (avg_dist[f[i]], site.species)].append(site)\n    return origin_site, clustered_sites"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_point_group_symbol(self):\n        rotations = self._space_group_data[\"rotations\"]\n        # passing a 0-length rotations list to spglib can segfault\n        if len(rotations) == 0:\n            return '1'\n        return spglib.get_pointgroup(rotations)[0].strip()", "response": "Get the point group symbol associated with the structure."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_crystal_system(self):\n        n = self._space_group_data[\"number\"]\n\n        f = lambda i, j: i <= n <= j\n        cs = {\"triclinic\": (1, 2), \"monoclinic\": (3, 15),\n              \"orthorhombic\": (16, 74), \"tetragonal\": (75, 142),\n              \"trigonal\": (143, 167), \"hexagonal\": (168, 194),\n              \"cubic\": (195, 230)}\n\n        crystal_sytem = None\n\n        for k, v in cs.items():\n            if f(*v):\n                crystal_sytem = k\n                break\n        return crystal_sytem", "response": "Get the crystal system for the structure."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the type of the structure in the crystal system.", "response": "def get_lattice_type(self):\n        \"\"\"\n        Get the lattice for the structure, e.g., (triclinic,\n        orthorhombic, cubic, etc.).This is the same than the\n        crystal system with the exception of the hexagonal/rhombohedral\n        lattice\n\n        Returns:\n            (str): Lattice type for structure or None if type cannot be detected.\n        \"\"\"\n        n = self._space_group_data[\"number\"]\n        system = self.get_crystal_system()\n        if n in [146, 148, 155, 160, 161, 166, 167]:\n            return \"rhombohedral\"\n        elif system == \"trigonal\":\n            return \"hexagonal\"\n        else:\n            return system"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the symmetry operations associated with the structure.", "response": "def _get_symmetry(self):\n        \"\"\"\n        Get the symmetry operations associated with the structure.\n\n        Returns:\n            Symmetry operations as a tuple of two equal length sequences.\n            (rotations, translations). \"rotations\" is the numpy integer array\n            of the rotation matrices for scaled positions\n            \"translations\" gives the numpy float64 array of the translation\n            vectors in scaled positions.\n        \"\"\"\n        d = spglib.get_symmetry(self._cell, symprec=self._symprec,\n                                angle_tolerance=self._angle_tol)\n        # Sometimes spglib returns small translation vectors, e.g.\n        # [1e-4, 2e-4, 1e-4]\n        # (these are in fractional coordinates, so should be small denominator\n        # fractions)\n        trans = []\n        for t in d[\"translations\"]:\n            trans.append([float(Fraction.from_float(c).limit_denominator(1000))\n                          for c in t])\n        trans = np.array(trans)\n\n        # fractional translations of 1 are more simply 0\n        trans[np.abs(trans) == 1] = 0\n        return d[\"rotations\"], trans"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_symmetry_operations(self, cartesian=False):\n        rotation, translation = self._get_symmetry()\n        symmops = []\n        mat = self._structure.lattice.matrix.T\n        invmat = np.linalg.inv(mat)\n        for rot, trans in zip(rotation, translation):\n            if cartesian:\n                rot = np.dot(mat, np.dot(rot, invmat))\n                trans = np.dot(trans, self._structure.lattice.matrix)\n            op = SymmOp.from_rotation_and_translation(rot, trans)\n            symmops.append(op)\n        return symmops", "response": "Returns a list of symmetry operations."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the refined structure based on detected symmetry.", "response": "def get_refined_structure(self):\n        \"\"\"\n        Get the refined structure based on detected symmetry. The refined\n        structure is a *conventional* cell setting with atoms moved to the\n        expected symmetry positions.\n\n        Returns:\n            Refined structure.\n        \"\"\"\n        # Atomic positions have to be specified by scaled positions for spglib.\n        lattice, scaled_positions, numbers \\\n            = spglib.refine_cell(self._cell, self._symprec, self._angle_tol)\n\n        species = [self._unique_species[i - 1] for i in numbers]\n        s = Structure(lattice, species, scaled_positions)\n        return s.get_sorted_structure()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef find_primitive(self):\n        lattice, scaled_positions, numbers = spglib.find_primitive(\n            self._cell, symprec=self._symprec)\n\n        species = [self._unique_species[i - 1] for i in numbers]\n\n        return Structure(lattice, species, scaled_positions,\n                         to_unit_cell=True).get_reduced_structure()", "response": "Find a primitive version of the unit cell."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_conventional_to_primitive_transformation_matrix(self, international_monoclinic=True):\n        conv = self.get_conventional_standard_structure(\n            international_monoclinic=international_monoclinic)\n        lattice = self.get_lattice_type()\n\n        if \"P\" in self.get_space_group_symbol() or lattice == \"hexagonal\":\n            return np.eye(3)\n\n        if lattice == \"rhombohedral\":\n            # check if the conventional representation is hexagonal or\n            # rhombohedral\n            lengths, angles = conv.lattice.lengths_and_angles\n            if abs(lengths[0]-lengths[2]) < 0.0001:\n                transf = np.eye\n            else:\n                transf = np.array([[-1, 1, 1], [2, 1, 1], [-1, -2, 1]],\n                                  dtype=np.float) / 3\n\n        elif \"I\" in self.get_space_group_symbol():\n            transf = np.array([[-1, 1, 1], [1, -1, 1], [1, 1, -1]],\n                              dtype=np.float) / 2\n        elif \"F\" in self.get_space_group_symbol():\n            transf = np.array([[0, 1, 1], [1, 0, 1], [1, 1, 0]],\n                              dtype=np.float) / 2\n        elif \"C\" in self.get_space_group_symbol() or \"A\" in self.get_space_group_symbol():\n            if self.get_crystal_system() == \"monoclinic\":\n                transf = np.array([[1, 1, 0], [-1, 1, 0], [0, 0, 2]],\n                                  dtype=np.float) / 2\n            else:\n                transf = np.array([[1, -1, 0], [1, 1, 0], [0, 0, 2]],\n                                  dtype=np.float) / 2\n        else:\n            transf = np.eye(3)\n\n        return transf", "response": "Returns the transformation matrix to transform a conventional unit cell to a primitive cell according to certain standards."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a structure with a primitive cell according to certain standards.", "response": "def get_primitive_standard_structure(self, international_monoclinic=True):\n        \"\"\"\n        Gives a structure with a primitive cell according to certain standards\n        the standards are defined in Setyawan, W., & Curtarolo, S. (2010).\n        High-throughput electronic band structure calculations:\n        Challenges and tools. Computational Materials Science,\n        49(2), 299-312. doi:10.1016/j.commatsci.2010.05.010\n\n        Returns:\n            The structure in a primitive standardized cell\n        \"\"\"\n        conv = self.get_conventional_standard_structure(\n            international_monoclinic=international_monoclinic)\n        lattice = self.get_lattice_type()\n\n        if \"P\" in self.get_space_group_symbol() or lattice == \"hexagonal\":\n            return conv\n\n        transf = self.get_conventional_to_primitive_transformation_matrix(\\\n            international_monoclinic=international_monoclinic)\n\n        new_sites = []\n        latt = Lattice(np.dot(transf, conv.lattice.matrix))\n        for s in conv:\n            new_s = PeriodicSite(\n                s.specie, s.coords, latt,\n                to_unit_cell=True, coords_are_cartesian=True,\n                properties=s.properties)\n            if not any(map(new_s.is_periodic_image, new_sites)):\n                new_sites.append(new_s)\n\n        if lattice == \"rhombohedral\":\n            prim = Structure.from_sites(new_sites)\n            lengths, angles = prim.lattice.lengths_and_angles\n            a = lengths[0]\n            alpha = math.pi * angles[0] / 180\n            new_matrix = [\n                [a * cos(alpha / 2), -a * sin(alpha / 2), 0],\n                [a * cos(alpha / 2), a * sin(alpha / 2), 0],\n                [a * cos(alpha) / cos(alpha / 2), 0,\n                 a * math.sqrt(1 - (cos(alpha) ** 2 / (cos(alpha / 2) ** 2)))]]\n            new_sites = []\n            latt = Lattice(new_matrix)\n            for s in prim:\n                new_s = PeriodicSite(\n                    s.specie, s.frac_coords, latt,\n                    to_unit_cell=True, properties=s.properties)\n                if not any(map(new_s.is_periodic_image, new_sites)):\n                    new_sites.append(new_s)\n            return Structure.from_sites(new_sites)\n\n        return Structure.from_sites(new_sites)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_conventional_standard_structure(\n            self, international_monoclinic=True):\n        \"\"\"\n        Gives a structure with a conventional cell according to certain\n        standards. The standards are defined in Setyawan, W., & Curtarolo,\n        S. (2010). High-throughput electronic band structure calculations:\n        Challenges and tools. Computational Materials Science,\n        49(2), 299-312. doi:10.1016/j.commatsci.2010.05.010\n        They basically enforce as much as possible\n        norm(a1)<norm(a2)<norm(a3)\n\n        Returns:\n            The structure in a conventional standardized cell\n        \"\"\"\n        tol = 1e-5\n        struct = self.get_refined_structure()\n        latt = struct.lattice\n        latt_type = self.get_lattice_type()\n        sorted_lengths = sorted(latt.abc)\n        sorted_dic = sorted([{'vec': latt.matrix[i],\n                              'length': latt.abc[i],\n                              'orig_index': i} for i in [0, 1, 2]],\n                            key=lambda k: k['length'])\n\n        if latt_type in (\"orthorhombic\", \"cubic\"):\n            # you want to keep the c axis where it is\n            # to keep the C- settings\n            transf = np.zeros(shape=(3, 3))\n            if self.get_space_group_symbol().startswith(\"C\"):\n                transf[2] = [0, 0, 1]\n                a, b = sorted(latt.abc[:2])\n                sorted_dic = sorted([{'vec': latt.matrix[i],\n                                      'length': latt.abc[i],\n                                      'orig_index': i} for i in [0, 1]],\n                                    key=lambda k: k['length'])\n                for i in range(2):\n                    transf[i][sorted_dic[i]['orig_index']] = 1\n                c = latt.abc[2]\n            elif self.get_space_group_symbol().startswith(\"A\"): #change to C-centering to match Setyawan/Curtarolo convention\n                transf[2] = [1, 0, 0]\n                a, b = sorted(latt.abc[1:])\n                sorted_dic = sorted([{'vec': latt.matrix[i],\n                                      'length': latt.abc[i],\n                                      'orig_index': i} for i in [1, 2]],\n                                    key=lambda k: k['length'])\n                for i in range(2):\n                    transf[i][sorted_dic[i]['orig_index']] = 1\n                c = latt.abc[0]\n            else:\n                for i in range(len(sorted_dic)):\n                    transf[i][sorted_dic[i]['orig_index']] = 1\n                a, b, c = sorted_lengths\n            latt = Lattice.orthorhombic(a, b, c)\n\n        elif latt_type == \"tetragonal\":\n            # find the \"a\" vectors\n            # it is basically the vector repeated two times\n            transf = np.zeros(shape=(3, 3))\n            a, b, c = sorted_lengths\n            for d in range(len(sorted_dic)):\n                transf[d][sorted_dic[d]['orig_index']] = 1\n\n            if abs(b - c) < tol and abs(a - c) > tol:\n                a, c = c, a\n                transf = np.dot([[0, 0, 1], [0, 1, 0], [1, 0, 0]], transf)\n            latt = Lattice.tetragonal(a, c)\n        elif latt_type in (\"hexagonal\", \"rhombohedral\"):\n            # for the conventional cell representation,\n            # we allways show the rhombohedral lattices as hexagonal\n\n            # check first if we have the refined structure shows a rhombohedral\n            # cell\n            # if so, make a supercell\n            a, b, c = latt.abc\n            if np.all(np.abs([a - b, c - b, a - c]) < 0.001):\n                struct.make_supercell(((1, -1, 0), (0, 1, -1), (1, 1, 1)))\n                a, b, c = sorted(struct.lattice.abc)\n\n            if abs(b - c) < 0.001:\n                a, c = c, a\n            new_matrix = [[a / 2, -a * math.sqrt(3) / 2, 0],\n                          [a / 2, a * math.sqrt(3) / 2, 0],\n                          [0, 0, c]]\n            latt = Lattice(new_matrix)\n            transf = np.eye(3, 3)\n\n        elif latt_type == \"monoclinic\":\n            # You want to keep the c axis where it is to keep the C- settings\n\n            if self.get_space_group_operations().int_symbol.startswith(\"C\"):\n                transf = np.zeros(shape=(3, 3))\n                transf[2] = [0, 0, 1]\n                sorted_dic = sorted([{'vec': latt.matrix[i],\n                                      'length': latt.abc[i],\n                                      'orig_index': i} for i in [0, 1]],\n                                    key=lambda k: k['length'])\n                a = sorted_dic[0]['length']\n                b = sorted_dic[1]['length']\n                c = latt.abc[2]\n                new_matrix = None\n                for t in itertools.permutations(list(range(2)), 2):\n                    m = latt.matrix\n                    landang = Lattice(\n                        [m[t[0]], m[t[1]], m[2]]).lengths_and_angles\n                    if landang[1][0] > 90:\n                        # if the angle is > 90 we invert a and b to get\n                        # an angle < 90\n                        landang = Lattice(\n                            [-m[t[0]], -m[t[1]], m[2]]).lengths_and_angles\n                        transf = np.zeros(shape=(3, 3))\n                        transf[0][t[0]] = -1\n                        transf[1][t[1]] = -1\n                        transf[2][2] = 1\n                        a, b, c = landang[0]\n                        alpha = math.pi * landang[1][0] / 180\n                        new_matrix = [[a, 0, 0],\n                                      [0, b, 0],\n                                      [0, c * cos(alpha), c * sin(alpha)]]\n                        continue\n\n                    elif landang[1][0] < 90:\n                        transf = np.zeros(shape=(3, 3))\n                        transf[0][t[0]] = 1\n                        transf[1][t[1]] = 1\n                        transf[2][2] = 1\n                        a, b, c = landang[0]\n                        alpha = math.pi * landang[1][0] / 180\n                        new_matrix = [[a, 0, 0],\n                                      [0, b, 0],\n                                      [0, c * cos(alpha), c * sin(alpha)]]\n\n                if new_matrix is None:\n                    # this if is to treat the case\n                    # where alpha==90 (but we still have a monoclinic sg\n                    new_matrix = [[a, 0, 0],\n                                  [0, b, 0],\n                                  [0, 0, c]]\n                    transf = np.zeros(shape=(3, 3))\n                    for c in range(len(sorted_dic)):\n                        transf[c][sorted_dic[c]['orig_index']] = 1\n            #if not C-setting\n            else:\n                # try all permutations of the axis\n                # keep the ones with the non-90 angle=alpha\n                # and b<c\n                new_matrix = None\n                for t in itertools.permutations(list(range(3)), 3):\n                    m = latt.matrix\n                    landang = Lattice(\n                        [m[t[0]], m[t[1]], m[t[2]]]).lengths_and_angles\n                    if landang[1][0] > 90 and landang[0][1] < landang[0][2]:\n                        landang = Lattice(\n                            [-m[t[0]], -m[t[1]], m[t[2]]]).lengths_and_angles\n                        transf = np.zeros(shape=(3, 3))\n                        transf[0][t[0]] = -1\n                        transf[1][t[1]] = -1\n                        transf[2][t[2]] = 1\n                        a, b, c = landang[0]\n                        alpha = math.pi * landang[1][0] / 180\n                        new_matrix = [[a, 0, 0],\n                                      [0, b, 0],\n                                      [0, c * cos(alpha), c * sin(alpha)]]\n                        continue\n                    elif landang[1][0] < 90 and landang[0][1] < landang[0][2]:\n                        transf = np.zeros(shape=(3, 3))\n                        transf[0][t[0]] = 1\n                        transf[1][t[1]] = 1\n                        transf[2][t[2]] = 1\n                        a, b, c = landang[0]\n                        alpha = math.pi * landang[1][0] / 180\n                        new_matrix = [[a, 0, 0],\n                                      [0, b, 0],\n                                      [0, c * cos(alpha), c * sin(alpha)]]\n                if new_matrix is None:\n                    # this if is to treat the case\n                    # where alpha==90 (but we still have a monoclinic sg\n                    new_matrix = [[sorted_lengths[0], 0, 0],\n                                  [0, sorted_lengths[1], 0],\n                                  [0, 0, sorted_lengths[2]]]\n                    transf = np.zeros(shape=(3, 3))\n                    for c in range(len(sorted_dic)):\n                        transf[c][sorted_dic[c]['orig_index']] = 1\n\n            if international_monoclinic:\n                # The above code makes alpha the non-right angle.\n                # The following will convert to proper international convention\n                # that beta is the non-right angle.\n                op = [[0, 1, 0], [1, 0, 0], [0, 0, -1]]\n                transf = np.dot(op, transf)\n                new_matrix = np.dot(op, new_matrix)\n                beta = Lattice(new_matrix).beta\n                if beta < 90:\n                    op = [[-1, 0, 0], [0, -1, 0], [0, 0, 1]]\n                    transf = np.dot(op, transf)\n                    new_matrix = np.dot(op, new_matrix)\n\n            latt = Lattice(new_matrix)\n\n        elif latt_type == \"triclinic\":\n            #we use a LLL Minkowski-like reduction for the triclinic cells\n            struct = struct.get_reduced_structure(\"LLL\")\n\n            a, b, c = latt.lengths_and_angles[0]\n            alpha, beta, gamma = [math.pi * i / 180\n                                  for i in latt.lengths_and_angles[1]]\n            new_matrix = None\n            test_matrix = [[a, 0, 0],\n                          [b * cos(gamma), b * sin(gamma), 0.0],\n                          [c * cos(beta),\n                           c * (cos(alpha) - cos(beta) * cos(gamma)) /\n                           sin(gamma),\n                           c * math.sqrt(sin(gamma) ** 2 - cos(alpha) ** 2\n                                         - cos(beta) ** 2\n                                         + 2 * cos(alpha) * cos(beta)\n                                         * cos(gamma)) / sin(gamma)]]\n\n            def is_all_acute_or_obtuse(m):\n                recp_angles = np.array(Lattice(m).reciprocal_lattice.angles)\n                return np.all(recp_angles <= 90) or np.all(recp_angles > 90)\n\n            if is_all_acute_or_obtuse(test_matrix):\n                transf = np.eye(3)\n                new_matrix = test_matrix\n\n            test_matrix = [[-a, 0, 0],\n                           [b * cos(gamma), b * sin(gamma), 0.0],\n                           [-c * cos(beta),\n                            -c * (cos(alpha) - cos(beta) * cos(gamma)) /\n                            sin(gamma),\n                            -c * math.sqrt(sin(gamma) ** 2 - cos(alpha) ** 2\n                                           - cos(beta) ** 2\n                                           + 2 * cos(alpha) * cos(beta)\n                                           * cos(gamma)) / sin(gamma)]]\n\n            if is_all_acute_or_obtuse(test_matrix):\n                transf = [[-1, 0, 0],\n                          [0, 1, 0],\n                          [0, 0, -1]]\n                new_matrix = test_matrix\n\n            test_matrix = [[-a, 0, 0],\n                           [-b * cos(gamma), -b * sin(gamma), 0.0],\n                           [c * cos(beta),\n                            c * (cos(alpha) - cos(beta) * cos(gamma)) /\n                            sin(gamma),\n                            c * math.sqrt(sin(gamma) ** 2 - cos(alpha) ** 2\n                                          - cos(beta) ** 2\n                                          + 2 * cos(alpha) * cos(beta)\n                                          * cos(gamma)) / sin(gamma)]]\n\n            if is_all_acute_or_obtuse(test_matrix):\n                transf = [[-1, 0, 0],\n                          [0, -1, 0],\n                          [0, 0, 1]]\n                new_matrix = test_matrix\n\n            test_matrix = [[a, 0, 0],\n                           [-b * cos(gamma), -b * sin(gamma), 0.0],\n                           [-c * cos(beta),\n                            -c * (cos(alpha) - cos(beta) * cos(gamma)) /\n                            sin(gamma),\n                            -c * math.sqrt(sin(gamma) ** 2 - cos(alpha) ** 2\n                                           - cos(beta) ** 2\n                                           + 2 * cos(alpha) * cos(beta)\n                                           * cos(gamma)) / sin(gamma)]]\n            if is_all_acute_or_obtuse(test_matrix):\n                transf = [[1, 0, 0],\n                          [0, -1, 0],\n                          [0, 0, -1]]\n                new_matrix = test_matrix\n\n            latt = Lattice(new_matrix)\n\n        new_coords = np.dot(transf, np.transpose(struct.frac_coords)).T\n        new_struct = Structure(latt, struct.species_and_occu, new_coords,\n                               site_properties=struct.site_properties,\n                               to_unit_cell=True)\n        return new_struct.get_sorted_structure()", "response": "Returns a structure in a conventional standardized cell according to certain standards."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncalculating the weights for a list of kpoints.", "response": "def get_kpoint_weights(self, kpoints, atol=1e-5):\n        \"\"\"\n        Calculate the weights for a list of kpoints.\n\n        Args:\n            kpoints (Sequence): Sequence of kpoints. np.arrays is fine. Note\n                that the code does not check that the list of kpoints\n                provided does not contain duplicates.\n            atol (float): Tolerance for fractional coordinates comparisons.\n\n        Returns:\n            List of weights, in the SAME order as kpoints.\n        \"\"\"\n        kpts = np.array(kpoints)\n        shift = []\n        mesh = []\n        for i in range(3):\n            nonzero = [i for i in kpts[:, i] if abs(i) > 1e-5]\n            if len(nonzero) != len(kpts):\n                # gamma centered\n                if not nonzero:\n                    mesh.append(1)\n                else:\n                    m = np.abs(np.round(1/np.array(nonzero)))\n                    mesh.append(int(max(m)))\n                shift.append(0)\n            else:\n                # Monk\n                m = np.abs(np.round(0.5/np.array(nonzero)))\n                mesh.append(int(max(m)))\n                shift.append(1)\n\n        mapping, grid = spglib.get_ir_reciprocal_mesh(\n            np.array(mesh), self._cell, is_shift=shift, symprec=self._symprec)\n        mapping = list(mapping)\n        grid = (np.array(grid) + np.array(shift) * (0.5, 0.5, 0.5)) / mesh\n        weights = []\n        mapped = defaultdict(int)\n        for k in kpoints:\n            for i, g in enumerate(grid):\n                if np.allclose(pbc_diff(k, g), (0, 0, 0), atol=atol):\n                    mapped[tuple(g)] += 1\n                    weights.append(mapping.count(mapping[i]))\n                    break\n        if (len(mapped) != len(set(mapping))) or (\n                not all([v == 1 for v in mapped.values()])):\n            raise ValueError(\"Unable to find 1:1 corresponding between input \"\n                             \"kpoints and irreducible grid!\")\n        return [w/sum(weights) for w in weights]"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nhandle assymetric top molecules which cannot contain rotational molecules which cannot contain rotational molecules which cannot contain rotational molecules which cannot contain rotational molecules larger than 2.", "response": "def _proc_asym_top(self):\n        \"\"\"\n        Handles assymetric top molecules, which cannot contain rotational\n        symmetry larger than 2.\n        \"\"\"\n        self._check_R2_axes_asym()\n        if len(self.rot_sym) == 0:\n            logger.debug(\"No rotation symmetries detected.\")\n            self._proc_no_rot_sym()\n        elif len(self.rot_sym) == 3:\n            logger.debug(\"Dihedral group detected.\")\n            self._proc_dihedral()\n        else:\n            logger.debug(\"Cyclic group detected.\")\n            self._proc_cyclic()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _proc_sym_top(self):\n        if abs(self.eigvals[0] - self.eigvals[1]) < self.eig_tol:\n            ind = 2\n        elif abs(self.eigvals[1] - self.eigvals[2]) < self.eig_tol:\n            ind = 0\n        else:\n            ind = 1\n        logger.debug(\"Eigenvalues = %s.\" % self.eigvals)\n        unique_axis = self.principal_axes[ind]\n        self._check_rot_sym(unique_axis)\n        logger.debug(\"Rotation symmetries = %s\" % self.rot_sym)\n        if len(self.rot_sym) > 0:\n            self._check_perpendicular_r2_axis(unique_axis)\n\n        if len(self.rot_sym) >= 2:\n            self._proc_dihedral()\n        elif len(self.rot_sym) == 1:\n            self._proc_cyclic()\n        else:\n            self._proc_no_rot_sym()", "response": "Handles symetric top molecules which have one unique eigenvalue whose\n            corresponding principal axis is a unique rotational axis."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nhandle no rotational symmetry.", "response": "def _proc_no_rot_sym(self):\n        \"\"\"\n        Handles molecules with no rotational symmetry. Only possible point\n        groups are C1, Cs and Ci.\n        \"\"\"\n        self.sch_symbol = \"C1\"\n        if self.is_valid_op(PointGroupAnalyzer.inversion_op):\n            self.sch_symbol = \"Ci\"\n            self.symmops.append(PointGroupAnalyzer.inversion_op)\n        else:\n            for v in self.principal_axes:\n                mirror_type = self._find_mirror(v)\n                if not mirror_type == \"\":\n                    self.sch_symbol = \"Cs\"\n                    break"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _proc_cyclic(self):\n        main_axis, rot = max(self.rot_sym, key=lambda v: v[1])\n        self.sch_symbol = \"C{}\".format(rot)\n        mirror_type = self._find_mirror(main_axis)\n        if mirror_type == \"h\":\n            self.sch_symbol += \"h\"\n        elif mirror_type == \"v\":\n            self.sch_symbol += \"v\"\n        elif mirror_type == \"\":\n            if self.is_valid_op(SymmOp.rotoreflection(main_axis,\n                                                      angle=180 / rot)):\n                self.sch_symbol = \"S{}\".format(2 * rot)", "response": "Handles cyclic group molecules."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _proc_dihedral(self):\n        main_axis, rot = max(self.rot_sym, key=lambda v: v[1])\n        self.sch_symbol = \"D{}\".format(rot)\n        mirror_type = self._find_mirror(main_axis)\n        if mirror_type == \"h\":\n            self.sch_symbol += \"h\"\n        elif not mirror_type == \"\":\n            self.sch_symbol += \"d\"", "response": "Handles dihedral group molecules i. e those with intersecting R2 axes\n        and a main axis."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ntest for 2 - fold rotation along the principal axes. Used to handle asymetric top molecules.", "response": "def _check_R2_axes_asym(self):\n        \"\"\"\n        Test for 2-fold rotation along the principal axes. Used to handle\n        asymetric top molecules.\n        \"\"\"\n        for v in self.principal_axes:\n            op = SymmOp.from_axis_angle_and_translation(v, 180)\n            if self.is_valid_op(op):\n                self.symmops.append(op)\n                self.rot_sym.append((v, 2))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nfind the mirror type of the specified axis.", "response": "def _find_mirror(self, axis):\n        \"\"\"\n        Looks for mirror symmetry of specified type about axis.  Possible\n        types are \"h\" or \"vd\".  Horizontal (h) mirrors are perpendicular to\n        the axis while vertical (v) or diagonal (d) mirrors are parallel.  v\n        mirrors has atoms lying on the mirror plane while d mirrors do\n        not.\n        \"\"\"\n        mirror_type = \"\"\n\n        # First test whether the axis itself is the normal to a mirror plane.\n        if self.is_valid_op(SymmOp.reflection(axis)):\n            self.symmops.append(SymmOp.reflection(axis))\n            mirror_type = \"h\"\n        else:\n            # Iterate through all pairs of atoms to find mirror\n            for s1, s2 in itertools.combinations(self.centered_mol, 2):\n                if s1.species == s2.species:\n                    normal = s1.coords - s2.coords\n                    if np.dot(normal, axis) < self.tol:\n                        op = SymmOp.reflection(normal)\n                        if self.is_valid_op(op):\n                            self.symmops.append(op)\n                            if len(self.rot_sym) > 1:\n                                mirror_type = \"d\"\n                                for v, r in self.rot_sym:\n                                    if not np.linalg.norm(v - axis) < self.tol:\n                                        if np.dot(v, normal) < self.tol:\n                                            mirror_type = \"v\"\n                                            break\n                            else:\n                                mirror_type = \"v\"\n                            break\n\n        return mirror_type"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _check_rot_sym(self, axis):\n        min_set = self._get_smallest_set_not_on_axis(axis)\n        max_sym = len(min_set)\n        for i in range(max_sym, 0, -1):\n            if max_sym % i != 0:\n                continue\n            op = SymmOp.from_axis_angle_and_translation(axis, 360 / i)\n            rotvalid = self.is_valid_op(op)\n            if rotvalid:\n                self.symmops.append(op)\n                self.rot_sym.append((axis, i))\n                return i\n        return 1", "response": "Checks if the rotational symmetry about supplied axis is valid."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncheck if R2 axes perpendicular to unique axis.", "response": "def _check_perpendicular_r2_axis(self, axis):\n        \"\"\"\n        Checks for R2 axes perpendicular to unique axis.  For handling\n        symmetric top molecules.\n        \"\"\"\n        min_set = self._get_smallest_set_not_on_axis(axis)\n        for s1, s2 in itertools.combinations(min_set, 2):\n            test_axis = np.cross(s1.coords - s2.coords, axis)\n            if np.linalg.norm(test_axis) > self.tol:\n                op = SymmOp.from_axis_angle_and_translation(test_axis, 180)\n                r2present = self.is_valid_op(op)\n                if r2present:\n                    self.symmops.append(op)\n                    self.rot_sym.append((test_axis, 2))\n                    return True"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nhandle Sperhical Top Molecules.", "response": "def _proc_sph_top(self):\n        \"\"\"\n        Handles Sperhical Top Molecules, which belongs to the T, O or I point\n        groups.\n        \"\"\"\n        self._find_spherical_axes()\n        if len(self.rot_sym) == 0:\n            logger.debug(\"Accidental speherical top!\")\n            self._proc_sym_top()\n        main_axis, rot = max(self.rot_sym, key=lambda v: v[1])\n        if rot < 3:\n            logger.debug(\"Accidental speherical top!\")\n            self._proc_sym_top()\n        elif rot == 3:\n            mirror_type = self._find_mirror(main_axis)\n            if mirror_type != \"\":\n                if self.is_valid_op(PointGroupAnalyzer.inversion_op):\n                    self.symmops.append(PointGroupAnalyzer.inversion_op)\n                    self.sch_symbol = \"Th\"\n                else:\n                    self.sch_symbol = \"Td\"\n            else:\n                self.sch_symbol = \"T\"\n        elif rot == 4:\n            if self.is_valid_op(PointGroupAnalyzer.inversion_op):\n                self.symmops.append(PointGroupAnalyzer.inversion_op)\n                self.sch_symbol = \"Oh\"\n            else:\n                self.sch_symbol = \"O\"\n        elif rot == 5:\n            if self.is_valid_op(PointGroupAnalyzer.inversion_op):\n                self.symmops.append(PointGroupAnalyzer.inversion_op)\n                self.sch_symbol = \"Ih\"\n            else:\n                self.sch_symbol = \"I\""}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nfind spherical top molecules.", "response": "def _find_spherical_axes(self):\n        \"\"\"\n        Looks for R5, R4, R3 and R2 axes in spherical top molecules.  Point\n        group T molecules have only one unique 3-fold and one unique 2-fold\n        axis. O molecules have one unique 4, 3 and 2-fold axes. I molecules\n        have a unique 5-fold axis.\n        \"\"\"\n        rot_present = defaultdict(bool)\n        origin_site, dist_el_sites = cluster_sites(self.centered_mol, self.tol)\n        test_set = min(dist_el_sites.values(), key=lambda s: len(s))\n        coords = [s.coords for s in test_set]\n        for c1, c2, c3 in itertools.combinations(coords, 3):\n            for cc1, cc2 in itertools.combinations([c1, c2, c3], 2):\n                if not rot_present[2]:\n                    test_axis = cc1 + cc2\n                    if np.linalg.norm(test_axis) > self.tol:\n                        op = SymmOp.from_axis_angle_and_translation(test_axis,\n                                                                    180)\n                        rot_present[2] = self.is_valid_op(op)\n                        if rot_present[2]:\n                            self.symmops.append(op)\n                            self.rot_sym.append((test_axis, 2))\n\n            test_axis = np.cross(c2 - c1, c3 - c1)\n            if np.linalg.norm(test_axis) > self.tol:\n                for r in (3, 4, 5):\n                    if not rot_present[r]:\n                        op = SymmOp.from_axis_angle_and_translation(\n                            test_axis, 360 / r)\n                        rot_present[r] = self.is_valid_op(op)\n                        if rot_present[r]:\n                            self.symmops.append(op)\n                            self.rot_sym.append((test_axis, r))\n                            break\n            if rot_present[2] and rot_present[3] and (\n                        rot_present[4] or rot_present[5]):\n                break"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nchecks if a particular symmetry operation is a valid symmetry operation for a molecule.", "response": "def is_valid_op(self, symmop):\n        \"\"\"\n        Check if a particular symmetry operation is a valid symmetry operation\n        for a molecule, i.e., the operation maps all atoms to another\n        equivalent atom.\n\n        Args:\n            symmop (SymmOp): Symmetry operation to test.\n\n        Returns:\n            (bool): Whether SymmOp is valid for Molecule.\n        \"\"\"\n        coords = self.centered_mol.cart_coords\n        for site in self.centered_mol:\n            coord = symmop.operate(site.coords)\n            ind = find_in_coord_list(coords, coord, self.tol)\n            if not (len(ind) == 1\n                    and self.centered_mol[ind[0]].species\n                    == site.species):\n                return False\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncalculating the dictionary of indices mapping equivalent atoms onto each other.", "response": "def _get_eq_sets(self):\n        \"\"\"\n        Calculates the dictionary for mapping equivalent atoms onto each other.\n\n        Args:\n            None\n\n        Returns:\n            dict: The returned dictionary has two possible keys:\n\n            ``eq_sets``:\n            A dictionary of indices mapping to sets of indices,\n            each key maps to indices of all equivalent atoms.\n            The keys are guaranteed to be not equivalent.\n\n            ``sym_ops``:\n            Twofold nested dictionary.\n            ``operations[i][j]`` gives the symmetry operation\n            that maps atom ``i`` unto ``j``.\n        \"\"\"\n        UNIT = np.eye(3)\n        eq_sets, operations = defaultdict(set), defaultdict(dict)\n        symm_ops = [op.rotation_matrix\n                    for op in generate_full_symmops(self.symmops, self.tol)]\n\n        def get_clustered_indices():\n            indices = cluster_sites(self.centered_mol, self.tol,\n                                    give_only_index=True)\n            out = list(indices[1].values())\n            if indices[0] is not None:\n                out.append([indices[0]])\n            return out\n\n        for index in get_clustered_indices():\n            sites = self.centered_mol.cart_coords[index]\n            for i, reference in zip(index, sites):\n                for op in symm_ops:\n                    rotated = np.dot(op, sites.T).T\n                    matched_indices = find_in_coord_list(rotated, reference,\n                                                         self.tol)\n                    matched_indices = {\n                        dict(enumerate(index))[i] for i in matched_indices}\n                    eq_sets[i] |= matched_indices\n\n                    if i not in operations:\n                        operations[i] = {j: op.T if j != i else UNIT\n                                         for j in matched_indices}\n                    else:\n                        for j in matched_indices:\n                            if j not in operations[i]:\n                                operations[i][j] = op.T if j != i else UNIT\n                    for j in matched_indices:\n                        if j not in operations:\n                            operations[j] = {i: op if j != i else UNIT}\n                        elif i not in operations[j]:\n                            operations[j][i] = op if j != i else UNIT\n\n        return {'eq_sets': eq_sets,\n                'sym_ops': operations}"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncombine the dicts of _get_equivalent_atom_dicts into one.", "response": "def _combine_eq_sets(eq_sets, operations):\n        \"\"\"Combines the dicts of _get_equivalent_atom_dicts into one\n\n        Args:\n            eq_sets (dict)\n            operations (dict)\n\n        Returns:\n            dict: The returned dictionary has two possible keys:\n\n            ``eq_sets``:\n            A dictionary of indices mapping to sets of indices,\n            each key maps to indices of all equivalent atoms.\n            The keys are guaranteed to be not equivalent.\n\n            ``sym_ops``:\n            Twofold nested dictionary.\n            ``operations[i][j]`` gives the symmetry operation\n            that maps atom ``i`` unto ``j``.\n        \"\"\"\n        UNIT = np.eye(3)\n\n        def all_equivalent_atoms_of_i(i, eq_sets, ops):\n            \"\"\"WORKS INPLACE on operations\n            \"\"\"\n            visited = set([i])\n            tmp_eq_sets = {j: (eq_sets[j] - visited) for j in eq_sets[i]}\n\n            while tmp_eq_sets:\n                new_tmp_eq_sets = {}\n                for j in tmp_eq_sets:\n                    if j in visited:\n                        continue\n                    visited.add(j)\n                    for k in tmp_eq_sets[j]:\n                        new_tmp_eq_sets[k] = eq_sets[k] - visited\n                        if i not in ops[k]:\n                            ops[k][i] = (np.dot(ops[j][i], ops[k][j])\n                                         if k != i else UNIT)\n                        ops[i][k] = ops[k][i].T\n                tmp_eq_sets = new_tmp_eq_sets\n            return visited, ops\n\n        eq_sets = copy.deepcopy(eq_sets)\n        new_eq_sets = {}\n        ops = copy.deepcopy(operations)\n        to_be_deleted = set()\n        for i in eq_sets:\n            if i in to_be_deleted:\n                continue\n            visited, ops = all_equivalent_atoms_of_i(i, eq_sets, ops)\n            to_be_deleted |= visited - {i}\n\n        for k in to_be_deleted:\n            eq_sets.pop(k, None)\n        return {'eq_sets': eq_sets,\n                'sym_ops': ops}"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef symmetrize_molecule(self):\n        eq = self.get_equivalent_atoms()\n        eq_sets, ops = eq['eq_sets'], eq['sym_ops']\n        coords = self.centered_mol.cart_coords.copy()\n        for i, eq_indices in eq_sets.items():\n            for j in eq_indices:\n                coords[j] = np.dot(ops[j][i], coords[j])\n            coords[i] = np.mean(coords[list(eq_indices)], axis=0)\n            for j in eq_indices:\n                if j == i:\n                    continue\n                coords[j] = np.dot(ops[i][j], coords[i])\n                coords[j] = np.dot(ops[i][j], coords[i])\n        molecule = Molecule(species=self.centered_mol.species_and_occu,\n                            coords=coords)\n        return {'sym_mol': molecule,\n                'eq_sets': eq_sets,\n                'sym_ops': ops}", "response": "Returns a symmetrized molecule with equivalent atoms obtained via get_equivalent_atoms."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef are_symmetrically_equivalent(self, sites1, sites2, symm_prec=1e-3):\n        def in_sites(site):\n            for test_site in sites1:\n                if test_site.is_periodic_image(site, symm_prec, False):\n                    return True\n            return False\n\n        for op in self:\n            newsites2 = [PeriodicSite(site.species,\n                                      op.operate(site.frac_coords),\n                                      site.lattice) for site in sites2]\n            for site in newsites2:\n                if not in_sites(site):\n                    break\n            else:\n                return True\n        return False", "response": "Test if two sets of PeriodicSites are actually symmetrically equivalent under this space group."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nfinding the indices of matches of a particular coord in a coord_list.", "response": "def find_in_coord_list(coord_list, coord, atol=1e-8):\n    \"\"\"\n    Find the indices of matches of a particular coord in a coord_list.\n\n    Args:\n        coord_list: List of coords to test\n        coord: Specific coordinates\n        atol: Absolute tolerance. Defaults to 1e-8. Accepts both scalar and\n            array.\n\n    Returns:\n        Indices of matches, e.g., [0, 1, 2, 3]. Empty list if not found.\n    \"\"\"\n    if len(coord_list) == 0:\n        return []\n    diff = np.array(coord_list) - np.array(coord)[None, :]\n    return np.where(np.all(np.abs(diff) < atol, axis=1))[0]"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef in_coord_list(coord_list, coord, atol=1e-8):\n    return len(find_in_coord_list(coord_list, coord, atol=atol)) > 0", "response": "Tests if a particular coord is within a coord_list."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ntest if all coords in subset are contained in superset.", "response": "def is_coord_subset(subset, superset, atol=1e-8):\n    \"\"\"\n    Tests if all coords in subset are contained in superset.\n    Doesn't use periodic boundary conditions\n\n    Args:\n        subset, superset: List of coords\n\n    Returns:\n        True if all of subset is in superset.\n    \"\"\"\n    c1 = np.array(subset)\n    c2 = np.array(superset)\n    is_close = np.all(np.abs(c1[:, None, :] - c2[None, :, :]) < atol, axis=-1)\n    any_close = np.any(is_close, axis=-1)\n    return np.all(any_close)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef coord_list_mapping(subset, superset, atol=1e-8):\n    c1 = np.array(subset)\n    c2 = np.array(superset)\n    inds = np.where(np.all(np.isclose(c1[:, None, :], c2[None, :, :], atol=atol),\n                           axis=2))[1]\n    result = c2[inds]\n    if not np.allclose(c1, result, atol=atol):\n        if not is_coord_subset(subset, superset):\n            raise ValueError(\"subset is not a subset of superset\")\n    if not result.shape == c1.shape:\n        raise ValueError(\"Something wrong with the inputs, likely duplicates \"\n                         \"in superset\")\n    return inds", "response": "Gives the index mapping from a subset to a superset."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef coord_list_mapping_pbc(subset, superset, atol=1e-8):\n    atol = np.array([1., 1. ,1.]) * atol\n    return cuc.coord_list_mapping_pbc(subset, superset, atol)", "response": "Returns the index mapping from a subset to a superset."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_linear_interpolated_value(x_values, y_values, x):\n    a = np.array(sorted(zip(x_values, y_values), key=lambda d: d[0]))\n\n    ind = np.where(a[:, 0] >= x)[0]\n\n    if len(ind) == 0 or ind[0] == 0:\n        raise ValueError(\"x is out of range of provided x_values\")\n\n    i = ind[0]\n    x1, x2 = a[i - 1][0], a[i][0]\n    y1, y2 = a[i - 1][1], a[i][1]\n\n    return y1 + (y2 - y1) / (x2 - x1) * (x - x1)", "response": "Returns an interpolated value by linear interpolation between two values."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef all_distances(coords1, coords2):\n    c1 = np.array(coords1)\n    c2 = np.array(coords2)\n    z = (c1[:, None, :] - c2[None, :, :]) ** 2\n    return np.sum(z, axis=-1) ** 0.5", "response": "Returns the distances between two lists of coordinates coords1 and coords2."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef pbc_diff(fcoords1, fcoords2):\n    fdist = np.subtract(fcoords1, fcoords2)\n    return fdist - np.round(fdist)", "response": "Returns the fractional distance between two fractional coordinates taking into\n    account periodic boundary conditions."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nfind the indices of all points in a fractional coord list that are equal to a specific fractional coord.", "response": "def find_in_coord_list_pbc(fcoord_list, fcoord, atol=1e-8):\n    \"\"\"\n    Get the indices of all points in a fractional coord list that are\n    equal to a fractional coord (with a tolerance), taking into account\n    periodic boundary conditions.\n\n    Args:\n        fcoord_list: List of fractional coords\n        fcoord: A specific fractional coord to test.\n        atol: Absolute tolerance. Defaults to 1e-8.\n\n    Returns:\n        Indices of matches, e.g., [0, 1, 2, 3]. Empty list if not found.\n    \"\"\"\n    if len(fcoord_list) == 0:\n        return []\n    fcoords = np.tile(fcoord, (len(fcoord_list), 1))\n    fdist = fcoord_list - fcoords\n    fdist -= np.round(fdist)\n    return np.where(np.all(np.abs(fdist) < atol, axis=1))[0]"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef in_coord_list_pbc(fcoord_list, fcoord, atol=1e-8):\n    return len(find_in_coord_list_pbc(fcoord_list, fcoord, atol=atol)) > 0", "response": "Tests if a particular fractional coord is within a fractional coord_list."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef is_coord_subset_pbc(subset, superset, atol=1e-8, mask=None):\n    c1 = np.array(subset, dtype=np.float64)\n    c2 = np.array(superset, dtype=np.float64)\n    if mask is not None:\n        m = np.array(mask, dtype=np.int)\n    else:\n        m = np.zeros((len(subset), len(superset)), dtype=np.int)\n    atol = np.zeros(3, dtype=np.float64) + atol\n    return cuc.is_coord_subset_pbc(c1, c2, atol, m)", "response": "Tests if all fractional coords in subset are contained in superset."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the list of points on the original lattice contained in the supercell in fractional coordinates.", "response": "def lattice_points_in_supercell(supercell_matrix):\n    \"\"\"\n    Returns the list of points on the original lattice contained in the\n    supercell in fractional coordinates (with the supercell basis).\n    e.g. [[2,0,0],[0,1,0],[0,0,1]] returns [[0,0,0],[0.5,0,0]]\n\n    Args:\n        supercell_matrix: 3x3 matrix describing the supercell\n\n    Returns:\n        numpy array of the fractional coordinates\n    \"\"\"\n    diagonals = np.array(\n        [[0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 1, 1], [1, 0, 0], [1, 0, 1],\n         [1, 1, 0], [1, 1, 1]])\n    d_points = np.dot(diagonals, supercell_matrix)\n\n    mins = np.min(d_points, axis=0)\n    maxes = np.max(d_points, axis=0) + 1\n\n    ar = np.arange(mins[0], maxes[0])[:, None] * \\\n         np.array([1, 0, 0])[None, :]\n    br = np.arange(mins[1], maxes[1])[:, None] * \\\n         np.array([0, 1, 0])[None, :]\n    cr = np.arange(mins[2], maxes[2])[:, None] * \\\n         np.array([0, 0, 1])[None, :]\n\n    all_points = ar[:, None, None] + br[None, :, None] + cr[None, None, :]\n    all_points = all_points.reshape((-1, 3))\n\n    frac_points = np.dot(all_points, np.linalg.inv(supercell_matrix))\n\n    tvects = frac_points[np.all(frac_points < 1 - 1e-10, axis=1)\n                         & np.all(frac_points >= -1e-10, axis=1)]\n    assert len(tvects) == round(abs(np.linalg.det(supercell_matrix)))\n    return tvects"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef barycentric_coords(coords, simplex):\n    coords = np.atleast_2d(coords)\n\n    t = np.transpose(simplex[:-1, :]) - np.transpose(simplex[-1, :])[:, None]\n    all_but_one = np.transpose(\n        np.linalg.solve(t, np.transpose(coords - simplex[-1])))\n    last_coord = 1 - np.sum(all_but_one, axis=-1)[:, None]\n    return np.append(all_but_one, last_coord, axis=-1)", "response": "Converts a list of coordinates to barycentric coordinates given a\n    simplex with d + 1 points. Only works for d > = 2."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncalculating the angle between two vectors.", "response": "def get_angle(v1, v2, units=\"degrees\"):\n    \"\"\"\n    Calculates the angle between two vectors.\n\n    Args:\n        v1: Vector 1\n        v2: Vector 2\n        units: \"degrees\" or \"radians\". Defaults to \"degrees\".\n\n    Returns:\n        Angle between them in degrees.\n    \"\"\"\n    d = np.dot(v1, v2) / np.linalg.norm(v1) / np.linalg.norm(v2)\n    d = min(d, 1)\n    d = max(d, -1)\n    angle = math.acos(d)\n    if units == \"degrees\":\n        return math.degrees(angle)\n    elif units == \"radians\":\n        return angle\n    else:\n        raise ValueError(\"Invalid units {}\".format(units))"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nvolume of the simplex.", "response": "def volume(self):\n        \"\"\"\n        Volume of the simplex.\n        \"\"\"\n        return abs(np.linalg.det(self._aug)) / math.factorial(self.simplex_dim)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncomputing the intersection points of a line with a simplex.", "response": "def line_intersection(self, point1, point2, tolerance=1e-8):\n        \"\"\"\n        Computes the intersection points of a line with a simplex\n        Args:\n            point1, point2 ([float]): Points that determine the line\n        Returns:\n            points where the line intersects the simplex (0, 1, or 2)\n        \"\"\"\n        b1 = self.bary_coords(point1)\n        b2 = self.bary_coords(point2)\n        l = b1 - b2\n        # don't use barycentric dimension where line is parallel to face\n        valid = np.abs(l) > 1e-10\n        # array of all the barycentric coordinates on the line where\n        # one of the values is 0\n        possible = b1 - (b1[valid] / l[valid])[:, None] * l\n        barys = []\n        for p in possible:\n            # it's only an intersection if its in the simplex\n            if (p >= -tolerance).all():\n                found = False\n                # don't return duplicate points\n                for b in barys:\n                    if np.all(np.abs(b - p) < tolerance):\n                        found = True\n                        break\n                if not found:\n                    barys.append(p)\n        assert len(barys) < 3\n        return [self.point_from_bary_coords(b) for b in barys]"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef is_valid_bibtex(reference):\n    # str is necessary since pybtex seems to have an issue with unicode. The\n    # filter expression removes all non-ASCII characters.\n    sio = StringIO(remove_non_ascii(reference))\n    parser = bibtex.Parser()\n    errors.set_strict_mode(False)\n    bib_data = parser.parse_stream(sio)\n    return len(bib_data.entries) > 0", "response": "Use pybtex to validate that a reference is in proper BibTeX format."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef parse_history_node(h_node):\n        if isinstance(h_node, dict):\n            return HistoryNode.from_dict(h_node)\n\n        else:\n            if len(h_node) != 3:\n                raise ValueError(\"Invalid History node, \"\n                                 \"should be dict or (name, version, \"\n                                 \"description) tuple: {}\".format(h_node))\n            return HistoryNode(h_node[0], h_node[1], h_node[2])", "response": "Parses a History Node object from either a dict or a 3 - element tuple."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nparse an Author object from either a String dict or tuple.", "response": "def parse_author(author):\n        \"\"\"\n        Parses an Author object from either a String, dict, or tuple\n\n        Args:\n            author: A String formatted as \"NAME <email@domain.com>\",\n                (name, email) tuple, or a dict with name and email keys.\n\n        Returns:\n            An Author object.\n        \"\"\"\n        if isinstance(author, str):\n            # Regex looks for whitespace, (any name), whitespace, <, (email),\n            # >, whitespace\n            m = re.match(r'\\s*(.*?)\\s*<(.*?@.*?)>\\s*', author)\n            if not m or m.start() != 0 or m.end() != len(author):\n                raise ValueError(\"Invalid author format! {}\".format(author))\n            return Author(m.groups()[0], m.groups()[1])\n        elif isinstance(author, dict):\n            return Author.from_dict(author)\n        else:\n            if len(author) != 2:\n                raise ValueError(\"Invalid author, should be String or (name, \"\n                                 \"email) tuple: {}\".format(author))\n            return Author(author[0], author[1])"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef from_structures(cls, structures, authors, projects=None,\n                        references='', remarks=None, data=None,\n                        histories=None, created_at=None):\n        \"\"\"\n        A convenience method for getting a list of StructureNL objects by\n        specifying structures and metadata separately. Some of the metadata\n        is applied to all of the structures for ease of use.\n\n        Args:\n            structures: A list of Structure objects\n            authors: *List* of {\"name\":'', \"email\":''} dicts,\n                *list* of Strings as 'John Doe <johndoe@gmail.com>',\n                or a single String with commas separating authors\n            projects: List of Strings ['Project A', 'Project B']. This\n                applies to all structures.\n            references: A String in BibTeX format. Again, this applies to all\n                structures.\n            remarks: List of Strings ['Remark A', 'Remark B']\n            data: A list of free form dict. Namespaced at the root level\n                with an underscore, e.g. {\"_materialsproject\":<custom data>}\n                . The length of data should be the same as the list of\n                structures if not None.\n            histories: List of list of dicts - [[{'name':'', 'url':'',\n                'description':{}}], ...] The length of histories should be the\n                same as the list of structures if not None.\n            created_at: A datetime object\n        \"\"\"\n        data = [{}] * len(structures) if data is None else data\n        histories = [[]] * len(structures) if histories is None else \\\n            histories\n\n        snl_list = []\n        for i, struct in enumerate(structures):\n            snl = StructureNL(struct, authors, projects=projects,\n                              references=references,\n                              remarks=remarks, data=data[i],\n                              history=histories[i],\n                              created_at=created_at)\n            snl_list.append(snl)\n\n        return snl_list", "response": "This method creates a list of StructureNL objects from a list of structures and metadata."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_perturbed_indices(self, tol=1e-8):\n        indices = list(zip(*np.where(abs(self - np.eye(3)) > tol)))\n        return indices", "response": "Gets indices of perturbed elements of the deformation gradient i. e. those that differ from the identity ArcGIS - 2."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\napply the deformation gradient to a structure.", "response": "def apply_to_structure(self, structure):\n        \"\"\"\n        Apply the deformation gradient to a structure.\n\n        Args:\n            structure (Structure object): the structure object to\n                be modified by the deformation\n        \"\"\"\n        def_struct = structure.copy()\n        old_latt = def_struct.lattice.matrix\n        new_latt = np.transpose(np.dot(self, np.transpose(old_latt)))\n        def_struct.lattice = Lattice(new_latt)\n        return def_struct"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef from_index_amount(cls, matrixpos, amt):\n        f = np.identity(3)\n        f[matrixpos] += amt\n        return cls(f)", "response": "Returns a new object from a matrix position and amount"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef from_deformation(cls, deformation):\n        dfm = Deformation(deformation)\n        return cls(0.5 * (np.dot(dfm.trans, dfm) - np.eye(3)))", "response": "Returns a Strain object from a deformation matrix"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a new instance of the class from the index location and amount.", "response": "def from_index_amount(cls, idx, amount):\n        \"\"\"\n        Like Deformation.from_index_amount, except generates\n        a strain from the zero 3x3 tensor or voigt vector with\n        the amount specified in the index location.  Ensures\n        symmetric strain.\n\n        Args:\n            idx (tuple or integer): index to be perturbed, can be voigt or\n                full-tensor notation\n            amount (float): amount to perturb selected index\n        \"\"\"\n        if np.array(idx).ndim == 0:\n            v = np.zeros(6)\n            v[idx] = amount\n            return cls.from_voigt(v)\n        elif np.array(idx).ndim == 1:\n            v = np.zeros((3, 3))\n            for i in itertools.permutations(idx):\n                v[i] = amount\n            return cls(v)\n        else:\n            raise ValueError(\"Index must either be 2-tuple or integer \"\n                             \"corresponding to full-tensor or voigt index\")"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconvert a tuple to a string that can be used in the template for the Agrs object.", "response": "def hkl_tuple_to_str(hkl):\n    \"\"\"\n    Prepare for display on plots\n    \"(hkl)\" for surfaces\n    Agrs:\n        hkl: in the form of [h, k, l] or (h, k, l)\n    \"\"\"\n    str_format = '($'\n    for x in hkl:\n        if x < 0:\n            str_format += '\\\\overline{' + str(-x) + '}'\n        else:\n            str_format += str(x)\n    str_format += '$)'\n    return str_format"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_tri_area(pts):\n    a, b, c = pts[0], pts[1], pts[2]\n    v1 = np.array(b) - np.array(a)\n    v2 = np.array(c) - np.array(a)\n    area_tri = abs(sp.linalg.norm(sp.cross(v1, v2)) / 2)\n    return area_tri", "response": "Given a list of coords for 3 points compute the area of this triangle."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _get_all_miller_e(self):\n        all_hkl = []\n        color_ind = self.color_ind\n        planes = []\n        recp = self.structure.lattice.reciprocal_lattice_crystallographic\n        recp_symmops = get_recp_symmetry_operation(self.structure, self.symprec)\n\n        for i, (hkl, energy) in enumerate(zip(self.hkl_list,\n                                              self.e_surf_list)):\n            for op in recp_symmops:\n                miller = tuple([int(x) for x in op.operate(hkl)])\n                if miller not in all_hkl:\n                    all_hkl.append(miller)\n                    normal = recp.get_cartesian_coords(miller)\n                    normal /= sp.linalg.norm(normal)\n                    normal_pt = [x * energy for x in normal]\n                    dual_pt = [x / energy for x in normal]\n                    color_plane = color_ind[divmod(i, len(color_ind))[1]]\n                    planes.append(WulffFacet(normal, energy, normal_pt,\n                                             dual_pt, color_plane, i, hkl))\n\n        # sort by e_surf\n        planes.sort(key=lambda x: x.e_surf)\n        return planes", "response": "get all the miller in the system"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _get_cross_pt_dual_simp(self, dual_simp):\n        matrix_surfs = [self.facets[dual_simp[i]].normal for i in range(3)]\n        matrix_e = [self.facets[dual_simp[i]].e_surf for i in range(3)]\n        cross_pt = sp.dot(sp.linalg.inv(matrix_surfs), matrix_e)\n        return cross_pt", "response": "Get the cross - vector for a dual triangulation of the current set of simplices."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _get_simpx_plane(self):\n        on_wulff = [False] * len(self.miller_list)\n        surface_area = [0.0] * len(self.miller_list)\n        for simpx in self.wulff_cv_simp:\n            pts = [self.wulff_pt_list[simpx[i]] for i in range(3)]\n            center = np.sum(pts, 0) / 3.0\n            # check whether the center of the simplices is on one plane\n            for plane in self.facets:\n                abs_diff = abs(np.dot(plane.normal, center) - plane.e_surf)\n                if abs_diff < 1e-5:\n                    on_wulff[plane.index] = True\n                    surface_area[plane.index] += get_tri_area(pts)\n\n                    plane.points.append(pts)\n                    plane.outer_lines.append([simpx[0], simpx[1]])\n                    plane.outer_lines.append([simpx[1], simpx[2]])\n                    plane.outer_lines.append([simpx[0], simpx[2]])\n                    # already find the plane, move to the next simplices\n                    break\n        for plane in self.facets:\n            plane.outer_lines.sort()\n            plane.outer_lines = [line for line in plane.outer_lines\n                                 if plane.outer_lines.count(line) != 2]\n        return on_wulff, surface_area", "response": "Locate the plane for the simpx of on wulff_cv."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the colors for the current set of on_wulff facets.", "response": "def _get_colors(self, color_set, alpha, off_color, custom_colors={}):\n        \"\"\"\n        assign colors according to the surface energies of on_wulff facets.\n\n        return:\n            (color_list, color_proxy, color_proxy_on_wulff, miller_on_wulff,\n            e_surf_on_wulff_list)\n        \"\"\"\n        import matplotlib as mpl\n        import matplotlib.pyplot as plt\n        color_list = [off_color] * len(self.hkl_list)\n        color_proxy_on_wulff = []\n        miller_on_wulff = []\n        e_surf_on_wulff = [(i, e_surf)\n                           for i, e_surf in enumerate(self.e_surf_list)\n                           if self.on_wulff[i]]\n\n        c_map = plt.get_cmap(color_set)\n        e_surf_on_wulff.sort(key=lambda x: x[1], reverse=False)\n        e_surf_on_wulff_list = [x[1] for x in e_surf_on_wulff]\n        if len(e_surf_on_wulff) > 1:\n            cnorm = mpl.colors.Normalize(vmin=min(e_surf_on_wulff_list),\n                                         vmax=max(e_surf_on_wulff_list))\n        else:\n            # if there is only one hkl on wulff, choose the color of the median\n            cnorm = mpl.colors.Normalize(vmin=min(e_surf_on_wulff_list) - 0.1,\n                                         vmax=max(e_surf_on_wulff_list) + 0.1)\n        scalar_map = mpl.cm.ScalarMappable(norm=cnorm, cmap=c_map)\n\n        for i, e_surf in e_surf_on_wulff:\n            color_list[i] = scalar_map.to_rgba(e_surf, alpha=alpha)\n            if tuple(self.miller_list[i]) in custom_colors.keys():\n                color_list[i] = custom_colors[tuple(self.miller_list[i])]\n            color_proxy_on_wulff.append(\n                plt.Rectangle((2, 2), 1, 1, fc=color_list[i], alpha=alpha))\n            miller_on_wulff.append(self.input_miller_fig[i])\n        scalar_map.set_array([x[1] for x in e_surf_on_wulff])\n        color_proxy = [plt.Rectangle((2, 2), 1, 1, fc=x, alpha=alpha)\n                       for x in color_list]\n\n        return color_list, color_proxy, color_proxy_on_wulff, miller_on_wulff, \\\n            e_surf_on_wulff_list"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the sorted pts in a facet used to draw a line in a facet", "response": "def get_line_in_facet(self, facet):\n        \"\"\"\n        Returns the sorted pts in a facet used to draw a line\n        \"\"\"\n\n        lines = list(facet.outer_lines)\n        pt = []\n        prev = None\n        while len(lines) > 0:\n            if prev is None:\n                l = lines.pop(0)\n            else:\n                for i, l in enumerate(lines):\n                    if prev in l:\n                        l = lines.pop(i)\n                        if l[1] == prev:\n                            l.reverse()\n                        break\n            # make sure the lines are connected one by one.\n            # find the way covering all pts and facets\n            pt.append(self.wulff_pt_list[l[0]].tolist())\n            pt.append(self.wulff_pt_list[l[1]].tolist())\n            prev = l[1]\n\n        return pt"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a matplotlib. pyplot object for the Wulff shape plot.", "response": "def get_plot(self, color_set='PuBu', grid_off=True, axis_off=True,\n                 show_area=False, alpha=1, off_color='red', direction=None,\n                 bar_pos=(0.75, 0.15, 0.05, 0.65), bar_on=False, units_in_JPERM2=True,\n                 legend_on=True, aspect_ratio=(8, 8), custom_colors={}):\n        \"\"\"\n        Get the Wulff shape plot.\n\n        Args:\n            color_set: default is 'PuBu'\n            grid_off (bool): default is True\n            axis_off (bool): default is Ture\n            show_area (bool): default is False\n            alpha (float): chosen from 0 to 1 (float), default is 1\n            off_color: Default color for facets not present on the Wulff shape.\n            direction: default is (1, 1, 1)\n            bar_pos: default is [0.75, 0.15, 0.05, 0.65]\n            bar_on (bool): default is False\n            legend_on (bool): default is True\n            aspect_ratio: default is (8, 8)\n            custom_colors ({(h,k,l}: [r,g,b,alpha}): Customize color of each\n                facet with a dictionary. The key is the corresponding Miller\n                index and value is the color. Undefined facets will use default\n                color site. Note: If you decide to set your own colors, it\n                probably won't make any sense to have the color bar on.\n\n        Return:\n            (matplotlib.pyplot)\n        \"\"\"\n        import matplotlib as mpl\n        import matplotlib.pyplot as plt\n        import mpl_toolkits.mplot3d as mpl3\n        color_list, color_proxy, color_proxy_on_wulff, \\\n            miller_on_wulff, e_surf_on_wulff = self._get_colors(\n                color_set, alpha, off_color, custom_colors=custom_colors)\n\n        if not direction:\n            # If direction is not specified, use the miller indices of\n            # maximum area.\n            direction = max(self.area_fraction_dict.items(),\n                            key=lambda x: x[1])[0]\n\n        fig = plt.figure()\n        fig.set_size_inches(aspect_ratio[0], aspect_ratio[1])\n        azim, elev = self._get_azimuth_elev([direction[0], direction[1],\n                                             direction[-1]])\n\n        wulff_pt_list = self.wulff_pt_list\n\n        ax = mpl3.Axes3D(fig, azim=azim, elev=elev)\n\n        for plane in self.facets:\n            # check whether [pts] is empty\n            if len(plane.points) < 1:\n                # empty, plane is not on_wulff.\n                continue\n            # assign the color for on_wulff facets according to its\n            # index and the color_list for on_wulff\n            plane_color = color_list[plane.index]\n            pt = self.get_line_in_facet(plane)\n            # plot from the sorted pts from [simpx]\n            tri = mpl3.art3d.Poly3DCollection([pt])\n            tri.set_color(plane_color)\n            tri.set_edgecolor(\"#808080\")\n            ax.add_collection3d(tri)\n\n        # set ranges of x, y, z\n        # find the largest distance between on_wulff pts and the origin,\n        # to ensure complete and consistent display for all directions\n        r_range = max([np.linalg.norm(x) for x in wulff_pt_list])\n        ax.set_xlim([-r_range * 1.1, r_range * 1.1])\n        ax.set_ylim([-r_range * 1.1, r_range * 1.1])\n        ax.set_zlim([-r_range * 1.1, r_range * 1.1])\n        # add legend\n        if legend_on:\n            color_proxy = color_proxy\n            if show_area:\n                ax.legend(color_proxy, self.miller_area, loc='upper left',\n                          bbox_to_anchor=(0, 1), fancybox=True, shadow=False)\n            else:\n                ax.legend(color_proxy_on_wulff, miller_on_wulff,\n                          loc='upper center',\n                          bbox_to_anchor=(0.5, 1), ncol=3, fancybox=True,\n                          shadow=False)\n        ax.set_xlabel('x')\n        ax.set_ylabel('y')\n        ax.set_zlabel('z')\n\n        # Add colorbar\n        if bar_on:\n            cmap = plt.get_cmap(color_set)\n            cmap.set_over('0.25')\n            cmap.set_under('0.75')\n            bounds = [round(e, 2) for e in e_surf_on_wulff]\n            bounds.append(1.2 * bounds[-1])\n            norm = mpl.colors.BoundaryNorm(bounds, cmap.N)\n            # display surface energies\n            ax1 = fig.add_axes(bar_pos)\n            cbar = mpl.colorbar.ColorbarBase(\n                ax1, cmap=cmap, norm=norm, boundaries=[0] + bounds + [10],\n                extend='both', ticks=bounds[:-1], spacing='proportional',\n                orientation='vertical')\n            units = \"$J/m^2$\" if units_in_JPERM2 else \"$eV/\\AA^2$\"\n            cbar.set_label('Surface Energies (%s)' %(units), fontsize=100)\n\n        if grid_off:\n            ax.grid('off')\n        if axis_off:\n            ax.axis('off')\n        return plt"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _get_azimuth_elev(self, miller_index):\n        if miller_index == (0, 0, 1) or miller_index == (0, 0, 0, 1):\n            return 0, 90\n        else:\n            cart = self.lattice.get_cartesian_coords(miller_index)\n            azim = get_angle([cart[0], cart[1], 0], (1, 0, 0))\n            v = [cart[0], cart[1], 0]\n            elev = get_angle(cart, v)\n            return azim, elev", "response": "Returns the azimuth and elevation of a centric miller in the current species."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a dictionary of area fractions for all the resource classes in the Miller area.", "response": "def area_fraction_dict(self):\n        \"\"\"\n        Returns:\n            (dict): {hkl: area_hkl/total area on wulff}\n        \"\"\"\n        return {hkl: self.miller_area_dict[hkl] / self.surface_area\n                for hkl in self.miller_area_dict.keys()}"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the anisotropy of the resource entry.", "response": "def anisotropy(self):\n        \"\"\"\n        Returns:\n            (float) Coefficient of Variation from weighted surface energy\n            The ideal sphere is 0.\n        \"\"\"\n        square_diff_energy = 0\n        weighted_energy = self.weighted_surface_energy\n        area_frac_dict = self.area_fraction_dict\n        miller_energy_dict = self.miller_energy_dict\n\n        for hkl in miller_energy_dict.keys():\n            square_diff_energy += (miller_energy_dict[hkl] - weighted_energy)\\\n                                  ** 2 * area_frac_dict[hkl]\n        return np.sqrt(square_diff_energy) / weighted_energy"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the total surface energy of the Wulff shape.", "response": "def total_surface_energy(self):\n        \"\"\"\n        Total surface energy of the Wulff shape.\n\n        Returns:\n            (float) sum(surface_energy_hkl * area_hkl)\n        \"\"\"\n        tot_surface_energy = 0\n        for hkl in self.miller_energy_dict.keys():\n            tot_surface_energy += self.miller_energy_dict[hkl] * \\\n                                  self.miller_area_dict[hkl]\n        return tot_surface_energy"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the number of edges in the convex hull.", "response": "def tot_edges(self):\n        \"\"\"\n        Returns the number of edges in the convex hull.\n            Useful for identifying catalytically active sites.\n        \"\"\"\n        all_edges = []\n        for facet in self.facets:\n            edges = []\n            pt = self.get_line_in_facet(facet)\n\n            lines = []\n            for i, p in enumerate(pt):\n                if i == len(pt) / 2:\n                    break\n                lines.append(tuple(sorted(tuple([tuple(pt[i*2]), tuple(pt[i*2+1])]))))\n\n            for i, p in enumerate(lines):\n                if p not in all_edges:\n                    edges.append(p)\n\n            all_edges.extend(edges)\n\n        return len(all_edges)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconstructing a SpaceGroupTransformation from its transformation string.", "response": "def from_transformation_string(cls, transformation_string=\"a,b,c;0,0,0\"):\n        \"\"\"\n        Construct SpaceGroupTransformation from its transformation string.\n        :param P: matrix\n        :param p: origin shift vector\n        :return:\n        \"\"\"\n        P, p = JonesFaithfulTransformation.parse_transformation_string(\n            transformation_string)\n        return cls(P, p)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the inverse of the system", "response": "def inverse(self):\n        # type: () -> JonesFaithfulTransformation\n        \"\"\"\n        \n        :return: JonesFaithfulTransformation\n        \"\"\"\n        Q = np.linalg.inv(self.P)\n        return JonesFaithfulTransformation(Q, -np.matmul(Q, self.p))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ntaking a symmetry operation and transforms it.", "response": "def transform_symmop(self, symmop):\n        # type: (Union[SymmOp, MagSymmOp]) -> Union[SymmOp, MagSymmOp]\n        \"\"\"\n        Takes a symmetry operation and transforms it.\n        :param symmop: SymmOp or MagSymmOp\n        :return: \n        \"\"\"\n        W = symmop.rotation_matrix\n        w = symmop.translation_vector\n        Q = np.linalg.inv(self.P)\n        W_ = np.matmul(np.matmul(Q, W), self.P)\n        I = np.identity(3)\n        w_ = np.matmul(Q, (w + np.matmul(W - I, self.p)))\n        if isinstance(symmop, MagSymmOp):\n            return MagSymmOp.from_rotation_and_translation_and_time_reversal(\n                rotation_matrix=W_, translation_vec=w_,\n                time_reversal=symmop.time_reversal, tol=symmop.tol)\n        elif isinstance(symmop, SymmOp):\n            return SymmOp.from_rotation_and_translation(\n                rotation_matrix=W_, translation_vec=w_, tol=symmop.tol)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef transform_coords(self, coords):\n        # type: (List[List[float]]) -> List[List[float]]\n        \"\"\"\n        Takes a list of co-ordinates and transforms them.\n        :param coords: List of coords\n        :return: \n        \"\"\"\n        new_coords = []\n        for x in coords:\n            x = np.array(x)\n            Q = np.linalg.inv(self.P)\n            x_ = np.matmul(Q, (x - self.p))\n            new_coords.append(x_.tolist())\n        return new_coords", "response": "Takes a list of co -ordinates and transforms them."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef transform_lattice(self, lattice):\n        # type: (Lattice) -> Lattice\n        \"\"\"\n        Takes a Lattice object and transforms it.\n        :param lattice: Lattice\n        :return: \n        \"\"\"\n        return Lattice(np.matmul(lattice.matrix, self.P))", "response": "Takes a Lattice object and transforms it."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _find_codopant(target, oxidation_state, allowed_elements=None):\n    ref_radius = target.ionic_radius\n    candidates = []\n    symbols = allowed_elements or [el.symbol for el in Element]\n    for sym in symbols:\n        try:\n            with warnings.catch_warnings():\n                warnings.simplefilter(\"ignore\")\n                sp = Specie(sym, oxidation_state)\n                r = sp.ionic_radius\n                if r is not None:\n                    candidates.append((r, sp))\n        except:\n            pass\n    return min(candidates, key=lambda l: abs(l[0] / ref_radius - 1))[1]", "response": "Find the element from the allowed elements that possesses the desired oxidation state and returns the closest in ionic radius to the target."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\napply the transformation to the structure.", "response": "def apply_transformation(self, structure, return_ranked_list=False):\n        \"\"\"\n        Return either a single ordered structure or a sequence of all ordered\n        structures.\n\n        Args:\n            structure: Structure to order.\n            return_ranked_list (bool): Whether or not multiple structures are\n                returned. If return_ranked_list is a number, that number of\n                structures is returned.\n\n        Returns:\n            Depending on returned_ranked list, either a transformed structure\n            or a list of dictionaries, where each dictionary is of the form\n            {\"structure\" = .... , \"other_arguments\"}\n\n            The list of ordered structures is ranked by ewald energy / atom, if\n            the input structure is an oxidation state decorated structure.\n            Otherwise, it is ranked by number of sites, with smallest number of\n            sites first.\n        \"\"\"\n        try:\n            num_to_return = int(return_ranked_list)\n        except ValueError:\n            num_to_return = 1\n\n        if self.refine_structure:\n            finder = SpacegroupAnalyzer(structure, self.symm_prec)\n            structure = finder.get_refined_structure()\n\n        contains_oxidation_state = all(\n            [hasattr(sp, \"oxi_state\") and sp.oxi_state != 0 for sp in\n             structure.composition.elements]\n        )\n\n        structures = None\n\n        if structure.is_ordered:\n            warn(\"Enumeration skipped for structure with composition {} \"\n                 \"because it is ordered\".format(structure.composition))\n            structures = [structure.copy()]\n\n        if self.max_disordered_sites:\n            ndisordered = sum([1 for site in structure if not site.is_ordered])\n            if ndisordered > self.max_disordered_sites:\n                raise ValueError(\n                    \"Too many disordered sites! ({} > {})\".format(\n                        ndisordered, self.max_disordered_sites))\n            max_cell_sizes = range(self.min_cell_size, int(\n                math.floor(self.max_disordered_sites / ndisordered)) + 1)\n        else:\n            max_cell_sizes = [self.max_cell_size]\n\n        for max_cell_size in max_cell_sizes:\n            adaptor = EnumlibAdaptor(\n                structure, min_cell_size=self.min_cell_size,\n                max_cell_size=max_cell_size,\n                symm_prec=self.symm_prec, refine_structure=False,\n                enum_precision_parameter=self.enum_precision_parameter,\n                check_ordered_symmetry=self.check_ordered_symmetry,\n                timeout=self.timeout)\n            try:\n                adaptor.run()\n            except EnumError:\n                warn(\"Unable to enumerate for max_cell_size = %d\".format(\n                    max_cell_size))\n            structures = adaptor.structures\n            if structures:\n                break\n\n        if structures is None:\n            raise ValueError(\"Unable to enumerate\")\n\n        original_latt = structure.lattice\n        inv_latt = np.linalg.inv(original_latt.matrix)\n        ewald_matrices = {}\n        all_structures = []\n        for s in structures:\n            new_latt = s.lattice\n            transformation = np.dot(new_latt.matrix, inv_latt)\n            transformation = tuple([tuple([int(round(cell)) for cell in row])\n                                    for row in transformation])\n            if contains_oxidation_state and self.sort_criteria == \"ewald\":\n                if transformation not in ewald_matrices:\n                    s_supercell = structure * transformation\n                    ewald = EwaldSummation(s_supercell)\n                    ewald_matrices[transformation] = ewald\n                else:\n                    ewald = ewald_matrices[transformation]\n                energy = ewald.compute_sub_structure(s)\n                all_structures.append({\"num_sites\": len(s), \"energy\": energy,\n                                       \"structure\": s})\n            else:\n                all_structures.append({\"num_sites\": len(s), \"structure\": s})\n\n        def sort_func(s):\n            return s[\"energy\"] / s[\"num_sites\"] \\\n                if contains_oxidation_state and self.sort_criteria == \"ewald\" \\\n                else s[\"num_sites\"]\n\n        self._all_structures = sorted(all_structures, key=sort_func)\n\n        if return_ranked_list:\n            return self._all_structures[0:num_to_return]\n        else:\n            return self._all_structures[0][\"structure\"]"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nchecks if a periodic site satisfies the constraint.", "response": "def satisfies_constraint(self, site):\n        \"\"\"\n        Checks if a periodic site satisfies the constraint.\n        \"\"\"\n        if not site.is_ordered:\n            return False\n\n        if self.species_constraints \\\n                and str(site.specie) in self.species_constraints:\n            satisfies_constraints = True\n        else:\n            satisfies_constraints = False\n\n        if self.site_constraint_name \\\n                and self.site_constraint_name in site.properties:\n            prop = site.properties[self.site_constraint_name]\n            if prop in self.site_constraints:\n                satisfies_constraints = True\n            else:\n                satisfies_constraints = False\n\n        return satisfies_constraints"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef determine_min_cell(disordered_structure):\n\n        def lcm(n1, n2):\n            \"\"\"\n            Find least common multiple of two numbers\n            \"\"\"\n            return n1 * n2 / gcd(n1, n2)\n\n        # assumes all order parameters for a given species are the same\n        mag_species_order_parameter = {}\n        mag_species_occurrences = {}\n        for idx, site in enumerate(disordered_structure):\n            if not site.is_ordered:\n                op = max(site.species.values())\n                # this very hacky bit of code only works because we know\n                # that on disordered sites in this class, all species are the same\n                # but have different spins, and this is comma-delimited\n                sp = str(list(site.species.keys())[0]).split(\",\")[0]\n                if sp in mag_species_order_parameter:\n                    mag_species_occurrences[sp] += 1\n                else:\n                    mag_species_order_parameter[sp] = op\n                    mag_species_occurrences[sp] = 1\n\n        smallest_n = []\n\n        for sp, order_parameter in mag_species_order_parameter.items():\n            denom = Fraction(order_parameter).limit_denominator(100).denominator\n            num_atom_per_specie = mag_species_occurrences[sp]\n            n_gcd = gcd(denom, num_atom_per_specie)\n            smallest_n.append(lcm(int(n_gcd), denom) / n_gcd)\n\n        return max(smallest_n)", "response": "Determines the smallest supercell that is able to enumerate the given structure with the given order parameter."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _remove_dummy_species(structure):\n        if not structure.is_ordered:\n            raise Exception(\"Something went wrong with enumeration.\")\n\n        sites_to_remove = []\n        logger.debug('Dummy species structure:\\n{}'.format(str(structure)))\n        for idx, site in enumerate(structure):\n            if isinstance(site.specie, DummySpecie):\n                sites_to_remove.append(idx)\n                spin = site.specie._properties.get('spin', None)\n                neighbors = structure.get_neighbors(\n                    site,\n                    0.05,  # arbitrary threshold, needs to be << any bond length\n                    # but >> floating point precision issues\n                    include_index=True\n                )\n                if len(neighbors) != 1:\n                    raise Exception(\"This shouldn't happen, found neighbors: {}\"\n                                    .format(neighbors))\n                orig_site_idx = neighbors[0][2]\n                orig_specie = structure[orig_site_idx].specie\n                new_specie = Specie(orig_specie.symbol,\n                                    getattr(orig_specie, 'oxi_state', None),\n                                    properties={'spin': spin})\n                structure.replace(orig_site_idx,\n                                  new_specie,\n                                  properties=structure[orig_site_idx].properties)\n        structure.remove_sites(sites_to_remove)\n        logger.debug('Structure with dummy species removed:\\n{}'.format(str(structure)))\n        return structure", "response": "Removes dummy species from a structure. Used after performing enumeration."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreplace Spin. up and Spin. down with spin magnitudes specified by mag_species_spin.", "response": "def _add_spin_magnitudes(self, structure):\n        \"\"\"\n        Replaces Spin.up/Spin.down with spin magnitudes specified\n        by mag_species_spin.\n        :param structure:\n        :return:\n        \"\"\"\n        for idx, site in enumerate(structure):\n            if getattr(site.specie, '_properties', None):\n                spin = site.specie._properties.get('spin', None)\n                sign = int(spin) if spin else 0\n                if spin:\n                    new_properties = site.specie._properties.copy()\n                    # this very hacky bit of code only works because we know\n                    # that on disordered sites in this class, all species are the same\n                    # but have different spins, and this is comma-delimited\n                    sp = str(site.specie).split(\",\")[0]\n                    new_properties.update({\n                        'spin': sign * self.mag_species_spin.get(sp, 0)\n                    })\n                    new_specie = Specie(site.specie.symbol,\n                                        getattr(site.specie, 'oxi_state', None),\n                                        new_properties)\n                    structure.replace(idx, new_specie,\n                                      properties=site.properties)\n        logger.debug('Structure with spin magnitudes:\\n{}'.format(str(structure)))\n        return structure"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\napplies the transformation to an input structure.", "response": "def apply_transformation(self, structure, return_ranked_list=False):\n        \"\"\"\n        Apply MagOrderTransformation to an input structure.\n        :param structure: Any ordered structure.\n        :param return_ranked_list: As in other Transformations.\n        :return:\n        \"\"\"\n\n        if not structure.is_ordered:\n            raise ValueError(\"Create an ordered approximation of \"\n                             \"your  input structure first.\")\n\n        # retrieve order parameters\n        order_parameters = [MagOrderParameterConstraint.from_dict(op_dict)\n                            for op_dict in self.order_parameter]\n        # add dummy species on which to perform enumeration\n        structure = self._add_dummy_species(structure, order_parameters)\n\n        # trivial case\n        if structure.is_ordered:\n            structure = self._remove_dummy_species(structure)\n            return [structure] if return_ranked_list > 1 else structure\n\n        enum_kwargs = self.enum_kwargs.copy()\n\n        enum_kwargs[\"min_cell_size\"] = max(\n            int(self.determine_min_cell(structure)),\n            enum_kwargs.get(\"min_cell_size\", 1)\n        )\n\n        if enum_kwargs.get(\"max_cell_size\", None):\n            if enum_kwargs[\"min_cell_size\"] > enum_kwargs[\"max_cell_size\"]:\n                warnings.warn(\"Specified max cell size ({}) is smaller \"\n                              \"than the minimum enumerable cell size ({}), \"\n                              \"changing max cell size to {}\".format(enum_kwargs[\"max_cell_size\"],\n                                                                    enum_kwargs[\"min_cell_size\"],\n                                                                    enum_kwargs[\"min_cell_size\"]))\n                enum_kwargs[\"max_cell_size\"] = enum_kwargs[\"min_cell_size\"]\n        else:\n            enum_kwargs[\"max_cell_size\"] = enum_kwargs[\"min_cell_size\"]\n\n        t = EnumerateStructureTransformation(**enum_kwargs)\n\n        alls = t.apply_transformation(structure,\n                                      return_ranked_list=return_ranked_list)\n\n        # handle the fact that EnumerateStructureTransformation can either\n        # return a single Structure or a list\n        if isinstance(alls, Structure):\n            # remove dummy species and replace Spin.up or Spin.down\n            # with spin magnitudes given in mag_species_spin arg\n            alls = self._remove_dummy_species(alls)\n            alls = self._add_spin_magnitudes(alls)\n        else:\n            for idx, _ in enumerate(alls):\n                alls[idx][\"structure\"] = self._remove_dummy_species(alls[idx][\"structure\"])\n                alls[idx][\"structure\"] = self._add_spin_magnitudes(alls[idx][\"structure\"])\n\n        try:\n            num_to_return = int(return_ranked_list)\n        except ValueError:\n            num_to_return = 1\n\n        if num_to_return == 1 or not return_ranked_list:\n            return alls[0][\"structure\"] if num_to_return else alls\n\n        # remove duplicate structures and group according to energy model\n        m = StructureMatcher(comparator=SpinComparator())\n        key = lambda x: SpacegroupAnalyzer(x, 0.1).get_space_group_number()\n        out = []\n        for _, g in groupby(sorted([d[\"structure\"] for d in alls],\n                                   key=key), key):\n            g = list(g)\n            grouped = m.group_structures(g)\n            out.extend([{\"structure\": g[0],\n                         \"energy\": self.energy_model.get_energy(g[0])}\n                        for g in grouped])\n\n        self._all_structures = sorted(out, key=lambda d: d[\"energy\"])\n\n        return self._all_structures[0:num_to_return]"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef apply_transformation(self, structure, return_ranked_list=False):\n        comp = structure.composition\n        logger.info(\"Composition: %s\" % comp)\n\n        for sp in comp:\n            try:\n                sp.oxi_state\n            except AttributeError:\n                analyzer = BVAnalyzer()\n                structure = analyzer.get_oxi_state_decorated_structure(\n                    structure)\n                comp = structure.composition\n                break\n\n        ox = self.dopant.oxi_state\n        radius = self.dopant.ionic_radius\n\n        compatible_species = [\n            sp for sp in comp if sp.oxi_state == ox and\n            abs(sp.ionic_radius / radius - 1) < self.ionic_radius_tol]\n\n        if (not compatible_species) and self.alio_tol:\n            # We only consider aliovalent doping if there are no compatible\n            # isovalent species.\n            compatible_species = [\n                sp for sp in comp\n                if abs(sp.oxi_state - ox) <= self.alio_tol and\n                abs(sp.ionic_radius / radius - 1) < self.ionic_radius_tol and\n                sp.oxi_state * ox >= 0]\n\n        if self.allowed_doping_species is not None:\n            # Only keep allowed doping species.\n            compatible_species = [\n                sp for sp in compatible_species\n                if sp in [get_el_sp(s) for s in self.allowed_doping_species]]\n\n        logger.info(\"Compatible species: %s\" % compatible_species)\n\n        lengths = structure.lattice.abc\n        scaling = [max(1, int(round(math.ceil(self.min_length / x))))\n                   for x in lengths]\n        logger.info(\"Lengths are %s\" % str(lengths))\n        logger.info(\"Scaling = %s\" % str(scaling))\n\n        all_structures = []\n        t = EnumerateStructureTransformation(**self.kwargs)\n\n        for sp in compatible_species:\n            supercell = structure * scaling\n            nsp = supercell.composition[sp]\n            if sp.oxi_state == ox:\n                supercell.replace_species({sp: {sp: (nsp - 1) / nsp,\n                                                self.dopant: 1 / nsp}})\n                logger.info(\"Doping %s for %s at level %.3f\" % (\n                    sp, self.dopant, 1 / nsp))\n            elif self.codopant:\n                codopant = _find_codopant(sp, 2 * sp.oxi_state - ox)\n                supercell.replace_species({sp: {sp: (nsp - 2) / nsp,\n                                                self.dopant: 1 / nsp,\n                                                codopant: 1 / nsp}})\n                logger.info(\"Doping %s for %s + %s at level %.3f\" % (\n                    sp, self.dopant, codopant, 1 / nsp))\n            elif abs(sp.oxi_state) < abs(ox):\n                # Strategy: replace the target species with a\n                # combination of dopant and vacancy.\n                # We will choose the lowest oxidation state species as a\n                # vacancy compensation species as it is likely to be lower in\n                # energy\n                sp_to_remove = min([s for s in comp if s.oxi_state * ox > 0],\n                                   key=lambda ss: abs(ss.oxi_state))\n\n                if sp_to_remove == sp:\n                    common_charge = lcm(int(abs(sp.oxi_state)), int(abs(ox)))\n                    ndopant = common_charge / abs(ox)\n                    nsp_to_remove = common_charge / abs(sp.oxi_state)\n                    logger.info(\"Doping %d %s with %d %s.\" %\n                                (nsp_to_remove, sp, ndopant, self.dopant))\n                    supercell.replace_species(\n                        {sp: {sp: (nsp - nsp_to_remove) / nsp,\n                              self.dopant: ndopant / nsp}})\n                else:\n                    ox_diff = int(abs(round(sp.oxi_state - ox)))\n                    vac_ox = int(abs(sp_to_remove.oxi_state))\n                    common_charge = lcm(vac_ox, ox_diff)\n                    ndopant = common_charge / ox_diff\n                    nx_to_remove = common_charge / vac_ox\n                    nx = supercell.composition[sp_to_remove]\n                    logger.info(\"Doping %d %s with %s and removing %d %s.\" %\n                                (ndopant, sp, self.dopant,\n                                 nx_to_remove, sp_to_remove))\n                    supercell.replace_species(\n                        {sp: {sp: (nsp - ndopant) / nsp,\n                              self.dopant: ndopant / nsp},\n                         sp_to_remove: {\n                             sp_to_remove: (nx - nx_to_remove) / nx}})\n            elif abs(sp.oxi_state) > abs(ox):\n                # Strategy: replace the target species with dopant and also\n                # remove some opposite charged species for charge neutrality\n                if ox > 0:\n                    sp_to_remove = max(supercell.composition.keys(),\n                                       key=lambda el: el.X)\n                else:\n                    sp_to_remove = min(supercell.composition.keys(),\n                                       key=lambda el: el.X)\n                # Confirm species are of opposite oxidation states.\n                assert sp_to_remove.oxi_state * sp.oxi_state < 0\n\n                ox_diff = int(abs(round(sp.oxi_state - ox)))\n                anion_ox = int(abs(sp_to_remove.oxi_state))\n                nx = supercell.composition[sp_to_remove]\n                common_charge = lcm(anion_ox, ox_diff)\n                ndopant = common_charge / ox_diff\n                nx_to_remove = common_charge / anion_ox\n                logger.info(\"Doping %d %s with %s and removing %d %s.\" %\n                            (ndopant, sp, self.dopant,\n                             nx_to_remove, sp_to_remove))\n                supercell.replace_species(\n                    {sp: {sp: (nsp - ndopant) / nsp,\n                          self.dopant: ndopant / nsp},\n                     sp_to_remove: {sp_to_remove: (nx - nx_to_remove) / nx}})\n\n            ss = t.apply_transformation(\n                supercell, return_ranked_list=self.max_structures_per_enum)\n            logger.info(\"%s distinct structures\" % len(ss))\n            all_structures.extend(ss)\n\n        logger.info(\"Total %s doped structures\" % len(all_structures))\n        if return_ranked_list:\n            return all_structures[:return_ranked_list]\n\n        return all_structures[0][\"structure\"]", "response": "Applies the transformation to a structure."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef apply_transformation(self, structure, return_ranked_list=False):\n\n        if not structure.is_ordered:\n            raise ValueError(\"This transformation is for disordered structures only.\")\n\n        partitions = self._partition_species(structure.composition,\n                                             max_components=self.max_sites_to_merge)\n        disorder_mappings = self._get_disorder_mappings(structure.composition, partitions)\n\n        disordered_structures = []\n        for mapping in disorder_mappings:\n            disordered_structure = structure.copy()\n            disordered_structure.replace_species(mapping)\n            disordered_structures.append({'structure': disordered_structure,\n                                          'mapping': mapping})\n\n        if len(disordered_structures) == 0:\n            return None\n        elif not return_ranked_list:\n            return disordered_structures[0]['structure']\n        else:\n            if len(disordered_structures) > return_ranked_list:\n                disordered_structures = disordered_structures[0:return_ranked_list]\n            return disordered_structures", "response": "Applies the transformation to a single structure."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef read_grid_from_file(filename):\n    try:\n        f = open(filename, mode='r')\n        full_res = ast.literal_eval(f.read())\n        f.close()\n    except SyntaxError:\n        print('Problems reading ', filename)\n        full_res = {'grid': 0, 'all_done': False}\n    except (OSError, IOError):\n        full_res = {'grid': 0, 'all_done': False}\n    return full_res", "response": "Read the results of a full set of calculations from a file."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef pred_from_structures(self, target_species, structures_list,\n                             remove_duplicates=True, remove_existing=False):\n        \"\"\"\n        performs a structure prediction targeting compounds containing all of\n        the target_species, based on a list of structure (those structures\n        can for instance come from a database like the ICSD). It will return\n        all the structures formed by ionic substitutions with a probability\n        higher than the threshold\n\n        Notes:\n        If the default probability model is used, input structures must\n        be oxidation state decorated. See AutoOxiStateDecorationTransformation\n\n        This method does not change the number of species in a structure. i.e\n        if the number of target species is 3, only input structures containing\n        3 species will be considered.\n\n        Args:\n            target_species:\n                a list of species with oxidation states\n                e.g., [Specie('Li',1),Specie('Ni',2), Specie('O',-2)]\n\n            structures_list:\n                a list of dictionnary of the form {'structure':Structure object\n                ,'id':some id where it comes from}\n                the id can for instance refer to an ICSD id.\n\n            remove_duplicates:\n                if True, the duplicates in the predicted structures will\n                be removed\n\n            remove_existing:\n                if True, the predicted structures that already exist in the\n                structures_list will be removed\n\n        Returns:\n            a list of TransformedStructure objects.\n        \"\"\"\n        target_species = get_el_sp(target_species)\n        result = []\n        transmuter = StandardTransmuter([])\n        if len(list(set(target_species) & set(self.get_allowed_species()))) \\\n                != len(target_species):\n            raise ValueError(\"the species in target_species are not allowed \"\n                             + \"for the probability model you are using\")\n\n        for permut in itertools.permutations(target_species):\n            for s in structures_list:\n                # check if: species are in the domain,\n                # and the probability of subst. is above the threshold\n                els = s['structure'].composition.elements\n                if len(els) == len(permut) and \\\n                                len(list(set(els) & set(\n                                    self.get_allowed_species()))) == \\\n                                len(els) and self._sp.cond_prob_list(permut,\n                                                                     els) > \\\n                        self._threshold:\n\n                    clean_subst = {els[i]: permut[i]\n                                   for i in range(0, len(els))\n                                   if els[i] != permut[i]}\n\n                    if len(clean_subst) == 0:\n                        continue\n\n                    transf = SubstitutionTransformation(clean_subst)\n\n                    if Substitutor._is_charge_balanced(\n                            transf.apply_transformation(s['structure'])):\n                        ts = TransformedStructure(\n                            s['structure'], [transf],\n                            history=[{\"source\": s['id']}],\n                            other_parameters={\n                                'type': 'structure_prediction',\n                                'proba': self._sp.cond_prob_list(permut, els)}\n                        )\n                        result.append(ts)\n                        transmuter.append_transformed_structures([ts])\n\n        if remove_duplicates:\n            transmuter.apply_filter(RemoveDuplicatesFilter(\n                symprec=self._symprec))\n        if remove_existing:\n            # Make the list of structures from structures_list that corresponds to the\n            # target species\n            chemsys = list(set([sp.symbol for sp in target_species]))\n            structures_list_target = [st['structure'] for st in structures_list\n                                      if Substitutor._is_from_chemical_system(\n                    chemsys,\n                    st['structure'])]\n            transmuter.apply_filter(RemoveExistingFilter(structures_list_target,\n                                                         symprec=self._symprec))\n        return transmuter.transformed_structures", "response": "This method performs a structure prediction targeting compounds containing all of the target_species and returns a list of TransformedStructure objects."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nchecking if the structure object is charge balanced", "response": "def _is_charge_balanced(struct):\n        \"\"\"\n        checks if the structure object is charge balanced\n        \"\"\"\n        if sum([s.specie.oxi_state for s in struct.sites]) == 0.0:\n            return True\n        else:\n            return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _is_from_chemical_system(chemical_system, struct):\n        chemsys = list(set([sp.symbol for sp in struct.composition]))\n        if len(chemsys) != len(chemical_system):\n            return False\n        for el in chemsys:\n            if not el in chemical_system:\n                return False\n        return True", "response": "Checks if the structure object is from the given chemical system"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef pred_from_list(self, species_list):\n        species_list = get_el_sp(species_list)\n        # calculate the highest probabilities to help us stop the recursion\n        max_probabilities = []\n        for s2 in species_list:\n            max_p = 0\n            for s1 in self._sp.species:\n                max_p = max([self._sp.cond_prob(s1, s2), max_p])\n            max_probabilities.append(max_p)\n        output = []\n\n        def _recurse(output_prob, output_species):\n            best_case_prob = list(max_probabilities)\n            best_case_prob[:len(output_prob)] = output_prob\n            if functools.reduce(mul, best_case_prob) > self._threshold:\n                if len(output_species) == len(species_list):\n                    odict = {\n                        'substitutions':\n                            dict(zip(species_list, output_species)),\n                        'probability': functools.reduce(mul, best_case_prob)}\n                    output.append(odict)\n                    return\n                for sp in self._sp.species:\n                    i = len(output_prob)\n                    prob = self._sp.cond_prob(sp, species_list[i])\n                    _recurse(output_prob + [prob], output_species + [sp])\n\n        _recurse([], [])\n        logging.info('{} substitutions found'.format(len(output)))\n        return output", "response": "Given a list of species and a probability value return a list of dictionaries each including a substitutions dictionary and a probability value."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef pred_from_comp(self, composition):\n        output = []\n        predictions = self.pred_from_list(composition.elements)\n        for p in predictions:\n            subs = p['substitutions']\n            charge = 0\n            for i_el in composition.elements:\n                f_el = subs[i_el]\n                charge += f_el.oxi_state * composition[i_el]\n            if charge == 0:\n                output.append(p)\n        logging.info('{} charge balanced '\n                     'compositions found'.format(len(output)))\n        return output", "response": "Returns a list of dicts representing the set of compositions that are charge balanced."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef pretty_plot(width=8, height=None, plt=None, dpi=None,\n                color_cycle=(\"qualitative\", \"Set1_9\")):\n    \"\"\"\n    Provides a publication quality plot, with nice defaults for font sizes etc.\n\n    Args:\n        width (float): Width of plot in inches. Defaults to 8in.\n        height (float): Height of plot in inches. Defaults to width * golden\n            ratio.\n        plt (matplotlib.pyplot): If plt is supplied, changes will be made to an\n            existing plot. Otherwise, a new plot will be created.\n        dpi (int): Sets dot per inch for figure. Defaults to 300.\n        color_cycle (tuple): Set the color cycle for new plots to one of the\n            color sets in palettable. Defaults to a qualitative Set1_9.\n\n    Returns:\n        Matplotlib plot object with properly sized fonts.\n    \"\"\"\n    ticksize = int(width * 2.5)\n\n    golden_ratio = (math.sqrt(5) - 1) / 2\n\n    if not height:\n        height = int(width * golden_ratio)\n\n    if plt is None:\n        import matplotlib.pyplot as plt\n        import importlib\n        mod = importlib.import_module(\"palettable.colorbrewer.%s\" %\n                                      color_cycle[0])\n        colors = getattr(mod, color_cycle[1]).mpl_colors\n        from cycler import cycler\n\n        plt.figure(figsize=(width, height), facecolor=\"w\", dpi=dpi)\n        ax = plt.gca()\n        ax.set_prop_cycle(cycler('color', colors))\n    else:\n        fig = plt.gcf()\n        fig.set_size_inches(width, height)\n    plt.xticks(fontsize=ticksize)\n    plt.yticks(fontsize=ticksize)\n\n    ax = plt.gca()\n    ax.set_title(ax.get_title(), size=width * 4)\n\n    labelsize = int(width * 3)\n\n    ax.set_xlabel(ax.get_xlabel(), size=labelsize)\n    ax.set_ylabel(ax.get_ylabel(), size=labelsize)\n\n    return plt", "response": "Returns a matplotlib. pyplot object with properly sized fonts."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef pretty_plot_two_axis(x, y1, y2, xlabel=None, y1label=None, y2label=None,\n                         width=8, height=None, dpi=300):\n    \"\"\"\n    Variant of pretty_plot that does a dual axis plot. Adapted from matplotlib\n    examples. Makes it easier to create plots with different axes.\n\n    Args:\n        x (np.ndarray/list): Data for x-axis.\n        y1 (dict/np.ndarray/list): Data for y1 axis (left). If a dict, it will\n            be interpreted as a {label: sequence}.\n        y2 (dict/np.ndarray/list): Data for y2 axis (right). If a dict, it will\n            be interpreted as a {label: sequence}.\n        xlabel (str): If not None, this will be the label for the x-axis.\n        y1label (str): If not None, this will be the label for the y1-axis.\n        y2label (str): If not None, this will be the label for the y2-axis.\n        width (float): Width of plot in inches. Defaults to 8in.\n        height (float): Height of plot in inches. Defaults to width * golden\n            ratio.\n        dpi (int): Sets dot per inch for figure. Defaults to 300.\n\n    Returns:\n        matplotlib.pyplot\n    \"\"\"\n\n    import palettable.colorbrewer.diverging\n\n    colors = palettable.colorbrewer.diverging.RdYlBu_4.mpl_colors\n    c1 = colors[0]\n    c2 = colors[-1]\n\n    golden_ratio = (math.sqrt(5) - 1) / 2\n\n    if not height:\n        height = int(width * golden_ratio)\n\n    import matplotlib.pyplot as plt\n    width = 12\n    labelsize = int(width * 3)\n    ticksize = int(width * 2.5)\n    styles = [\"-\", \"--\", \"-.\", \".\"]\n\n    fig, ax1 = plt.subplots()\n    fig.set_size_inches((width, height))\n    if dpi:\n        fig.set_dpi(dpi)\n    if isinstance(y1, dict):\n        for i, (k, v) in enumerate(y1.items()):\n            ax1.plot(x, v, c=c1, marker='s', ls=styles[i % len(styles)],\n                     label=k)\n        ax1.legend(fontsize=labelsize)\n    else:\n        ax1.plot(x, y1, c=c1, marker='s', ls='-')\n\n    if xlabel:\n        ax1.set_xlabel(xlabel, fontsize=labelsize)\n\n    if y1label:\n        # Make the y-axis label, ticks and tick labels match the line color.\n        ax1.set_ylabel(y1label, color=c1, fontsize=labelsize)\n\n    ax1.tick_params('x', labelsize=ticksize)\n    ax1.tick_params('y', colors=c1, labelsize=ticksize)\n\n    ax2 = ax1.twinx()\n    if isinstance(y2, dict):\n        for i, (k, v) in enumerate(y2.items()):\n            ax2.plot(x, v, c=c2, marker='o', ls=styles[i % len(styles)],\n                     label=k)\n        ax2.legend(fontsize=labelsize)\n    else:\n        ax2.plot(x, y2, c=c2, marker='o', ls='-')\n\n    if y2label:\n        # Make the y-axis label, ticks and tick labels match the line color.\n        ax2.set_ylabel(y2label, color=c2, fontsize=labelsize)\n\n    ax2.tick_params('y', colors=c2, labelsize=ticksize)\n    return plt", "response": "Pretty plot of two - axis data."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a matplotlib. pyplot object that will plot data based on polynomial fit.", "response": "def pretty_polyfit_plot(x, y, deg=1, xlabel=None, ylabel=None, **kwargs):\n    \"\"\"\n    Convenience method to plot data with trend lines based on polynomial fit.\n\n    Args:\n        x: Sequence of x data.\n        y: Sequence of y data.\n        deg (int): Degree of polynomial. Defaults to 1.\n        xlabel (str): Label for x-axis.\n        ylabel (str): Label for y-axis.\n        \\\\*\\\\*kwargs: Keyword args passed to pretty_plot.\n\n    Returns:\n        matplotlib.pyplot object.\n    \"\"\"\n    plt = pretty_plot(**kwargs)\n    pp = np.polyfit(x, y, deg)\n    xp = np.linspace(min(x), max(x), 200)\n    plt.plot(xp, np.polyval(pp, xp), 'k--', x, y, 'o')\n    if xlabel:\n        plt.xlabel(xlabel)\n    if ylabel:\n        plt.ylabel(ylabel)\n    return plt"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nconvert str of chemical formula into latex format for labelling purposes", "response": "def format_formula(formula):\n    \"\"\"\n    Converts str of chemical formula into\n    latex format for labelling purposes\n\n    Args:\n        formula (str): Chemical formula\n    \"\"\"\n\n    formatted_formula = \"\"\n    number_format = \"\"\n    for i, s in enumerate(formula):\n        if s.isdigit():\n            if not number_format:\n                number_format = \"_{\"\n            number_format += s\n            if i == len(formula) - 1:\n                number_format += \"}\"\n                formatted_formula += number_format\n        else:\n            if number_format:\n                number_format += \"}\"\n                formatted_formula += number_format\n                number_format = \"\"\n            formatted_formula += s\n\n    return r\"$%s$\" % (formatted_formula)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef van_arkel_triangle(list_of_materials, annotate=True):\n\n    # F-Fr has the largest X difference. We set this\n    # as our top corner of the triangle (most ionic)\n    pt1 = np.array([(Element(\"F\").X + Element(\"Fr\").X) / 2,\n                    abs(Element(\"F\").X - Element(\"Fr\").X)])\n    # Cs-Fr has the lowest average X. We set this as our\n    # bottom left corner of the triangle (most metallic)\n    pt2 = np.array([(Element(\"Cs\").X + Element(\"Fr\").X) / 2,\n                    abs(Element(\"Cs\").X - Element(\"Fr\").X)])\n    # O-F has the highest average X. We set this as our\n    # bottom right corner of the triangle (most covalent)\n    pt3 = np.array([(Element(\"O\").X + Element(\"F\").X) / 2,\n                    abs(Element(\"O\").X - Element(\"F\").X)])\n\n    # get the parameters for the lines of the triangle\n    d = np.array(pt1) - np.array(pt2)\n    slope1 = d[1] / d[0]\n    b1 = pt1[1] - slope1 * pt1[0]\n    d = pt3 - pt1\n    slope2 = d[1] / d[0]\n    b2 = pt3[1] - slope2 * pt3[0]\n\n    # Initialize the plt object\n    import matplotlib.pyplot as plt\n\n    # set labels and appropriate limits for plot\n    plt.xlim(pt2[0] - 0.45, -b2 / slope2 + 0.45)\n    plt.ylim(-0.45, pt1[1] + 0.45)\n    plt.annotate(\"Ionic\", xy=[pt1[0] - 0.3, pt1[1] + 0.05], fontsize=20)\n    plt.annotate(\"Covalent\", xy=[-b2 / slope2 - 0.65, -0.4], fontsize=20)\n    plt.annotate(\"Metallic\", xy=[pt2[0] - 0.4, -0.4], fontsize=20)\n    plt.xlabel(r\"$\\frac{\\chi_{A}+\\chi_{B}}{2}$\", fontsize=25)\n    plt.ylabel(r\"$|\\chi_{A}-\\chi_{B}|$\", fontsize=25)\n\n    # Set the lines of the triangle\n    chi_list = [el.X for el in Element]\n    plt.plot([min(chi_list), pt1[0]], [slope1 * min(chi_list) + b1, pt1[1]], 'k-', linewidth=3)\n    plt.plot([pt1[0], -b2 / slope2], [pt1[1], 0], 'k-', linewidth=3)\n    plt.plot([min(chi_list), -b2 / slope2], [0, 0], 'k-', linewidth=3)\n    plt.xticks(fontsize=15)\n    plt.yticks(fontsize=15)\n\n    # Shade with appropriate colors corresponding to ionic, metallci and covalent\n    ax = plt.gca()\n    # ionic filling\n    ax.fill_between([min(chi_list), pt1[0]],\n                    [slope1 * min(chi_list) + b1, pt1[1]], facecolor=[1, 1, 0],\n                    zorder=-5, edgecolor=[1, 1, 0])\n    ax.fill_between([pt1[0], -b2 / slope2],\n                    [pt1[1], slope2 * min(chi_list) - b1], facecolor=[1, 1, 0],\n                    zorder=-5, edgecolor=[1, 1, 0])\n    # metal filling\n    XPt = Element(\"Pt\").X\n    ax.fill_between([min(chi_list), (XPt + min(chi_list)) / 2],\n                    [0, slope1 * (XPt + min(chi_list)) / 2 + b1],\n                    facecolor=[1, 0, 0], zorder=-3, alpha=0.8)\n    ax.fill_between([(XPt + min(chi_list)) / 2, XPt],\n                    [slope1 * ((XPt + min(chi_list)) / 2) + b1, 0],\n                    facecolor=[1, 0, 0], zorder=-3, alpha=0.8)\n    # covalent filling\n    ax.fill_between([(XPt + min(chi_list)) / 2, ((XPt + min(chi_list)) / 2 + -b2 / slope2) / 2],\n                    [0, slope2 * (((XPt + min(chi_list)) / 2 + -b2 / slope2) / 2) + b2],\n                    facecolor=[0, 1, 0], zorder=-4, alpha=0.8)\n    ax.fill_between([((XPt + min(chi_list)) / 2 + -b2 / slope2) / 2, -b2 / slope2],\n                    [slope2 * (((XPt + min(chi_list)) / 2 + -b2 / slope2) / 2) + b2, 0],\n                    facecolor=[0, 1, 0], zorder=-4, alpha=0.8)\n\n    # Label the triangle with datapoints\n    for entry in list_of_materials:\n        if type(entry).__name__ not in ['ComputedEntry', 'ComputedStructureEntry']:\n            X_pair = [Element(el).X for el in entry]\n            formatted_formula = \"%s-%s\" % tuple(entry)\n        else:\n            X_pair = [Element(el).X for el in entry.composition.as_dict().keys()]\n            formatted_formula = format_formula(entry.composition.reduced_formula)\n        plt.scatter(np.mean(X_pair), abs(X_pair[0] - X_pair[1]), c='b', s=100)\n        if annotate:\n            plt.annotate(formatted_formula, fontsize=15,\n                         xy=[np.mean(X_pair) + 0.005, abs(X_pair[0] - X_pair[1])])\n\n    plt.tight_layout()\n    return plt", "response": "This method generates a binary van Arkel - Ketelaar triangle to generate a single compound\n           ."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_fig_kwargs(func):\n    from functools import wraps\n\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        # pop the kwds used by the decorator.\n        title = kwargs.pop(\"title\", None)\n        size_kwargs = kwargs.pop(\"size_kwargs\", None)\n        show = kwargs.pop(\"show\", True)\n        savefig = kwargs.pop(\"savefig\", None)\n        tight_layout = kwargs.pop(\"tight_layout\", False)\n        ax_grid = kwargs.pop(\"ax_grid\", None)\n        ax_annotate = kwargs.pop(\"ax_annotate\", None)\n\n        # Call func and return immediately if None is returned.\n        fig = func(*args, **kwargs)\n        if fig is None:\n            return fig\n\n        # Operate on matplotlib figure.\n        if title is not None:\n            fig.suptitle(title)\n\n        if size_kwargs is not None:\n            fig.set_size_inches(size_kwargs.pop(\"w\"), size_kwargs.pop(\"h\"),\n                                **size_kwargs)\n\n        if ax_grid is not None:\n            for ax in fig.axes:\n                ax.grid(bool(ax_grid))\n\n        if ax_annotate:\n            from string import ascii_letters\n            tags = ascii_letters\n            if len(fig.axes) > len(tags):\n                tags = (1 + len(ascii_letters) // len(fig.axes)) * ascii_letters\n            for ax, tag in zip(fig.axes, tags):\n                ax.annotate(\"(%s)\" % tag, xy=(0.05, 0.95), xycoords=\"axes fraction\")\n\n        if tight_layout:\n            try:\n                fig.tight_layout()\n            except Exception as exc:\n                # For some unknown reason, this problem shows up only on travis.\n                # https://stackoverflow.com/questions/22708888/valueerror-when-using-matplotlib-tight-layout\n                print(\"Ignoring Exception raised by fig.tight_layout\\n\", str(exc))\n\n        if savefig:\n            fig.savefig(savefig)\n\n        if show:\n            import matplotlib.pyplot as plt\n            plt.show()\n\n        return fig\n\n    # Add docstring to the decorated method.\n    s = \"\\n\\n\" + \"\"\"\\\n        Keyword arguments controlling the display of the figure:\n\n        ================  ====================================================\n        kwargs            Meaning\n        ================  ====================================================\n        title             Title of the plot (Default: None).\n        show              True to show the figure (default: True).\n        savefig           \"abc.png\" or \"abc.eps\" to save the figure to a file.\n        size_kwargs       Dictionary with options passed to fig.set_size_inches\n                          e.g. size_kwargs=dict(w=3, h=4)\n        tight_layout      True to call fig.tight_layout (default: False)\n        ax_grid           True (False) to add (remove) grid from all axes in fig.\n                          Default: None i.e. fig is left unchanged.\n        ax_annotate       Add labels to  subplots e.g. (a), (b).\n                          Default: False\n        ================  ====================================================\n\n\"\"\"\n\n    if wrapper.__doc__ is not None:\n        # Add s at the end of the docstring.\n        wrapper.__doc__ += \"\\n\" + s\n    else:\n        # Use s\n        wrapper.__doc__ = s\n\n    return wrapper", "response": "Decorator that adds keyword arguments for functions returning matplotlib."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef f0(E, fermi, T):\n    return 1. / (1. + np.exp((E - fermi) / (_cd(\"Boltzmann constant in eV/K\") * T)))", "response": "Returns the equilibrium fermi - dirac."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _get_orb_type_lobster(orb):\n    orb_labs = [\"s\", \"p_y\", \"p_z\", \"p_x\", \"d_xy\", \"d_yz\", \"d_z^2\",\n                \"d_xz\", \"d_x^2-y^2\", \"f_y(3x^2-y^2)\", \"f_xyz\",\n                \"f_yz^2\", \"f_z^3\", \"f_xz^2\", \"f_z(x^2-y^2)\", \"f_x(x^2-3y^2)\"]\n\n    try:\n        orbital = Orbital(orb_labs.index(orb[1:]))\n        return orbital.orbital_type\n    except AttributeError:\n        print(\"Orb not in list\")", "response": "Returns the OrbitalType of the orbital in the lobster."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _get_orb_lobster(orb):\n    orb_labs = [\"s\", \"p_y\", \"p_z\", \"p_x\", \"d_xy\", \"d_yz\", \"d_z^2\",\n                \"d_xz\", \"d_x^2-y^2\", \"f_y(3x^2-y^2)\", \"f_xyz\",\n                \"f_yz^2\", \"f_z^3\", \"f_xz^2\", \"f_z(x^2-y^2)\", \"f_x(x^2-3y^2)\"]\n\n    try:\n        orbital = Orbital(orb_labs.index(orb[1:]))\n        return orbital\n    except AttributeError:\n        print(\"Orb not in list\")", "response": "Returns the Orbital object for the given Orbital object"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_interpolated_gap(self, tol=0.001, abs_tol=False, spin=None):\n\n        tdos = self.y if len(self.ydim) == 1 else np.sum(self.y, axis=1)\n        if not abs_tol:\n            tol = tol * tdos.sum() / tdos.shape[0]\n        energies = self.x\n        below_fermi = [i for i in range(len(energies))\n                       if energies[i] < self.efermi and tdos[i] > tol]\n        above_fermi = [i for i in range(len(energies))\n                       if energies[i] > self.efermi and tdos[i] > tol]\n        vbm_start = max(below_fermi)\n        cbm_start = min(above_fermi)\n        if vbm_start == cbm_start:\n            return 0.0, self.efermi, self.efermi\n        else:\n            # Interpolate between adjacent values\n            terminal_dens = tdos[vbm_start:vbm_start + 2][::-1]\n            terminal_energies = energies[vbm_start:vbm_start + 2][::-1]\n            start = get_linear_interpolated_value(terminal_dens,\n                                                  terminal_energies, tol)\n            terminal_dens = tdos[cbm_start - 1:cbm_start + 1]\n            terminal_energies = energies[cbm_start - 1:cbm_start + 1]\n            end = get_linear_interpolated_value(terminal_dens,\n                                                terminal_energies, tol)\n            return end - start, end, start", "response": "Returns the interpolated gap in the DOS object and the BMM and BMM."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_cbm_vbm(self, tol=0.001, abs_tol=False, spin=None):\n        # determine tolerance\n        if spin is None:\n            tdos = self.y if len(self.ydim) == 1 else np.sum(self.y, axis=1)\n        elif spin == Spin.up:\n            tdos = self.y[:, 0]\n        else:\n            tdos = self.y[:, 1]\n\n        if not abs_tol:\n            tol = tol * tdos.sum() / tdos.shape[0]\n\n        # find index of fermi energy\n        i_fermi = 0\n        while self.x[i_fermi] <= self.efermi:\n            i_fermi += 1\n\n        # work backwards until tolerance is reached\n        i_gap_start = i_fermi\n        while i_gap_start - 1 >= 0 and tdos[i_gap_start - 1] <= tol:\n            i_gap_start -= 1\n\n        # work forwards until tolerance is reached\n        i_gap_end = i_gap_start\n        while i_gap_end < tdos.shape[0] and tdos[i_gap_end] <= tol:\n            i_gap_end += 1\n        i_gap_end -= 1\n        return self.x[i_gap_end], self.x[i_gap_start]", "response": "Returns the cbm and vbm of the entry in the DOS object."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_gap(self, tol=0.001, abs_tol=False, spin=None):\n        (cbm, vbm) = self.get_cbm_vbm(tol, abs_tol, spin)\n        return max(cbm - vbm, 0.0)", "response": "Returns the gap in the sequence of cbm and vbm in the sequence of n - 1s."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_densities(self, spin=None):\n        if self.densities is None:\n            result = None\n        elif spin is None:\n            if Spin.down in self.densities:\n                result = self.densities[Spin.up] + self.densities[Spin.down]\n            else:\n                result = self.densities[Spin.up]\n        else:\n            result = self.densities[spin]\n        return result", "response": "Returns the density of states for a particular spin."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_smeared_densities(self, sigma):\n        from scipy.ndimage.filters import gaussian_filter1d\n        smeared_dens = {}\n        diff = [self.energies[i + 1] - self.energies[i]\n                for i in range(len(self.energies) - 1)]\n        avgdiff = sum(diff) / len(diff)\n        for spin, dens in self.densities.items():\n            smeared_dens[spin] = gaussian_filter1d(dens, sigma / avgdiff)\n        return smeared_dens", "response": "Returns the densities of the energy of the current entry in the n - level tree with Gaussian smearing applied about the fermi\n        level."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the interpolated value for a particular energy.", "response": "def get_interpolated_value(self, energy):\n        \"\"\"\n        Returns interpolated density for a particular energy.\n\n        Args:\n            energy: Energy to return the density for.\n        \"\"\"\n        f = {}\n        for spin in self.densities.keys():\n            f[spin] = get_linear_interpolated_value(self.energies,\n                                                    self.densities[spin],\n                                                    energy)\n        return f"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the cbm and vbm of the entry in the tree.", "response": "def get_cbm_vbm(self, tol=0.001, abs_tol=False, spin=None):\n        \"\"\"\n        Expects a DOS object and finds the cbm and vbm.\n\n        Args:\n            tol: tolerance in occupations for determining the gap\n            abs_tol: An absolute tolerance (True) and a relative one (False)\n            spin: Possible values are None - finds the gap in the summed\n                densities, Up - finds the gap in the up spin channel,\n                Down - finds the gap in the down spin channel.\n\n        Returns:\n            (cbm, vbm): float in eV corresponding to the gap\n        \"\"\"\n        # determine tolerance\n        tdos = self.get_densities(spin)\n        if not abs_tol:\n            tol = tol * tdos.sum() / tdos.shape[0]\n\n        # find index of fermi energy\n        i_fermi = 0\n        while self.energies[i_fermi] <= self.efermi:\n            i_fermi += 1\n\n        # work backwards until tolerance is reached\n        i_gap_start = i_fermi\n        while i_gap_start - 1 >= 0 and tdos[i_gap_start - 1] <= tol:\n            i_gap_start -= 1\n\n        # work forwards until tolerance is reached\n        i_gap_end = i_gap_start\n        while i_gap_end < tdos.shape[0] and tdos[i_gap_end] <= tol:\n            i_gap_end += 1\n        i_gap_end -= 1\n        return self.energies[i_gap_end], self.energies[i_gap_start]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a new Dos object from dict representation of Dos.", "response": "def from_dict(cls, d):\n        \"\"\"\n        Returns Dos object from dict representation of Dos.\n        \"\"\"\n        return Dos(d[\"efermi\"], d[\"energies\"],\n                   {Spin(int(k)): v\n                    for k, v in d[\"densities\"].items()})"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef as_dict(self):\n        return {\"@module\": self.__class__.__module__,\n                \"@class\": self.__class__.__name__, \"efermi\": self.efermi,\n                \"energies\": list(self.energies),\n                \"densities\": {str(spin): list(dens)\n                              for spin, dens in self.densities.items()}}", "response": "Json - serializable dict representation of Dos."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncalculating the doping of the majority carrier concentration at a given fermi level and temperature.", "response": "def get_doping(self, fermi, T):\n        \"\"\"\n        Calculate the doping (majority carrier concentration) at a given fermi\n        level and temperature. A simple Left Riemann sum is used for integrating\n        the density of states over energy & equilibrium Fermi-Dirac distribution\n\n        Args:\n            fermi (float): the fermi level in eV\n            T (float): the temperature in Kelvin\n\n        Returns (float): in units 1/cm3. If negative it means that the majority\n            carriers are electrons (n-type doping) and if positive holes/p-type\n        \"\"\"\n        cb_integral = np.sum(self.tdos[self.idx_cbm:]\n                             * f0(self.energies[self.idx_cbm:], fermi, T)\n                             * self.de[self.idx_cbm:], axis=0)\n        vb_integral = np.sum(self.tdos[:self.idx_vbm + 1]\n                             * (1 - f0(self.energies[:self.idx_vbm + 1], fermi, T))\n                             * self.de[:self.idx_vbm + 1], axis=0)\n        return (vb_integral - cb_integral) / (self.volume * self.A_to_cm ** 3)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_fermi(self, c, T, rtol=0.01, nstep=50, step=0.1, precision=8):\n        fermi = self.efermi  # initialize target fermi\n        for _ in range(precision):\n            frange = np.arange(-nstep, nstep + 1) * step + fermi\n            calc_doping = np.array([self.get_doping(f, T) for f in frange])\n            relative_error = abs(calc_doping / c - 1.0)\n            fermi = frange[np.argmin(relative_error)]\n            step /= 10.0\n        if min(relative_error) > rtol:\n            raise ValueError('Could not find fermi within {}% of c={}'.format(\n                rtol * 100, c))\n        return fermi", "response": "This function returns the fermi level at which the doping concentration at the given temperature is equal to c."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_site_orbital_dos(self, site, orbital):\n        return Dos(self.efermi, self.energies, self.pdos[site][orbital])", "response": "Returns the Dos for a particular orbital of a particular site."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the total Dos for a specific site.", "response": "def get_site_dos(self, site):\n        \"\"\"\n        Get the total Dos for a site (all orbitals).\n\n        Args:\n            site: Site in Structure associated with CompleteDos.\n\n        Returns:\n            Dos containing summed orbital densities for site.\n        \"\"\"\n        site_dos = functools.reduce(add_densities, self.pdos[site].values())\n        return Dos(self.efermi, self.energies, site_dos)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_site_spd_dos(self, site):\n        spd_dos = dict()\n        for orb, pdos in self.pdos[site].items():\n            orbital_type = _get_orb_type(orb)\n            if orbital_type in spd_dos:\n                spd_dos[orbital_type] = add_densities(spd_dos[orbital_type], pdos)\n            else:\n                spd_dos[orbital_type] = pdos\n        return {orb: Dos(self.efermi, self.energies, densities)\n                for orb, densities in spd_dos.items()}", "response": "Get orbital projected Dos of a particular site in Structure associated with CompleteDos."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_site_t2g_eg_resolved_dos(self, site):\n        t2g_dos = []\n        eg_dos = []\n        for s, atom_dos in self.pdos.items():\n            if s == site:\n                for orb, pdos in atom_dos.items():\n                    if orb in (Orbital.dxy, Orbital.dxz, Orbital.dyz):\n                        t2g_dos.append(pdos)\n                    elif orb in (Orbital.dx2, Orbital.dz2):\n                        eg_dos.append(pdos)\n        return {\"t2g\": Dos(self.efermi, self.energies,\n                           functools.reduce(add_densities, t2g_dos)),\n                \"e_g\": Dos(self.efermi, self.energies,\n                           functools.reduce(add_densities, eg_dos))}", "response": "Get the t2g eg projected DOS for a particular site."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting orbital projected Dos.", "response": "def get_spd_dos(self):\n        \"\"\"\n        Get orbital projected Dos.\n\n        Returns:\n            dict of {orbital: Dos}, e.g. {\"s\": Dos object, ...}\n        \"\"\"\n        spd_dos = {}\n        for atom_dos in self.pdos.values():\n            for orb, pdos in atom_dos.items():\n                orbital_type = _get_orb_type(orb)\n                if orbital_type not in spd_dos:\n                    spd_dos[orbital_type] = pdos\n                else:\n                    spd_dos[orbital_type] = \\\n                        add_densities(spd_dos[orbital_type], pdos)\n        return {orb: Dos(self.efermi, self.energies, densities)\n                for orb, densities in spd_dos.items()}"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_element_dos(self):\n\n        el_dos = {}\n        for site, atom_dos in self.pdos.items():\n            el = site.specie\n            for pdos in atom_dos.values():\n                if el not in el_dos:\n                    el_dos[el] = pdos\n                else:\n                    el_dos[el] = add_densities(el_dos[el], pdos)\n        return {el: Dos(self.efermi, self.energies, densities)\n                for el, densities in el_dos.items()}", "response": "Get element projected Dos."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef spin_polarization(self):\n        n_F = self.get_interpolated_value(self.efermi)\n\n        n_F_up = n_F[Spin.up]\n        n_F_down = n_F[Spin.down]\n\n        if (n_F_up + n_F_down) == 0:\n            # only well defined for metals or half-mteals\n            return float('NaN')\n\n        spin_polarization = (n_F_up - n_F_down) / (n_F_up + n_F_down)\n\n        return abs(spin_polarization)", "response": "Calculates the spin polarization at Fermi level."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_element_spd_dos(self, el):\n        el = get_el_sp(el)\n        el_dos = {}\n        for site, atom_dos in self.pdos.items():\n            if site.specie == el:\n                for orb, pdos in atom_dos.items():\n                    orbital_type = _get_orb_type_lobster(orb)\n                    if orbital_type not in el_dos:\n                        el_dos[orbital_type] = pdos\n                    else:\n                        el_dos[orbital_type] = \\\n                            add_densities(el_dos[orbital_type], pdos)\n\n        return {orb: Dos(self.efermi, self.energies, densities)\n                for orb, densities in el_dos.items()}", "response": "Get element and spd projected Dos."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a CompleteDos object from dict representation.", "response": "def from_dict(cls, d):\n        \"\"\"\n        Returns: CompleteDos object from dict representation.\n        \"\"\"\n        tdos = Dos.from_dict(d)\n        struct = Structure.from_dict(d[\"structure\"])\n        pdoss = {}\n        for i in range(len(d[\"pdos\"])):\n            at = struct[i]\n            orb_dos = {}\n            for orb_str, odos in d[\"pdos\"][i].items():\n                orb = orb_str\n                orb_dos[orb] = {Spin(int(k)): v\n                                for k, v in odos[\"densities\"].items()}\n            pdoss[at] = orb_dos\n        return LobsterCompleteDos(struct, tdos, pdoss)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_prototypes(self, structure):\n\n        tags = self._match_single_prototype(structure)\n\n        if len(tags) == 0:\n            return None\n        else:\n            return tags", "response": "Returns a list of dicts with keys\n        snl and tags for that prototype and a list of tags for that prototype and None if there is no match."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nparse the input string for a specific pattern in a specific table.", "response": "def read_table_pattern(text_str,\n                       header_pattern,\n                       row_pattern,\n                       footer_pattern,\n                       postprocess=str,\n                       attribute_name=None,\n                       last_one_only=False):\n    \"\"\"\n    Parse table-like data. A table composes of three parts: header,\n    main body, footer. All the data matches \"row pattern\" in the main body\n    will be returned.\n\n    Args:\n        text_str (str): the input string to search for patterns\n        header_pattern (str): The regular expression pattern matches the\n            table header. This pattern should match all the text\n            immediately before the main body of the table. For multiple\n            sections table match the text until the section of\n            interest. MULTILINE and DOTALL options are enforced, as a\n            result, the \".\" meta-character will also match \"\\n\" in this\n            section.\n        row_pattern (str): The regular expression matches a single line in\n            the table. Capture interested field using regular expression\n            groups.\n        footer_pattern (str): The regular expression matches the end of the\n            table. E.g. a long dash line.\n        postprocess (callable): A post processing function to convert all\n            matches. Defaults to str, i.e., no change.\n        attribute_name (str): Name of this table. If present the parsed data\n            will be attached to \"data. e.g. self.data[\"efg\"] = [...]\n        last_one_only (bool): All the tables will be parsed, if this option\n            is set to True, only the last table will be returned. The\n            enclosing list will be removed. i.e. Only a single table will\n            be returned. Default to be True.\n\n    Returns:\n        List of tables. 1) A table is a list of rows. 2) A row if either a list of\n        attribute values in case the the capturing group is defined without name in\n        row_pattern, or a dict in case that named capturing groups are defined by\n        row_pattern.\n    \"\"\"\n\n    table_pattern_text = header_pattern + \\\n        r\"\\s*(?P<table_body>(?:\" + row_pattern + r\")+)\\s*\" + footer_pattern\n    table_pattern = re.compile(table_pattern_text, re.MULTILINE | re.DOTALL)\n    rp = re.compile(row_pattern)\n    data = {}\n    tables = []\n    for mt in table_pattern.finditer(text_str):\n        table_body_text = mt.group(\"table_body\")\n        table_contents = []\n        for ml in rp.finditer(table_body_text):\n            d = ml.groupdict()\n            if len(d) > 0:\n                processed_line = {k: postprocess(v) for k, v in d.items()}\n            else:\n                processed_line = [postprocess(v) for v in ml.groups()]\n            table_contents.append(processed_line)\n        tables.append(table_contents)\n    if last_one_only:\n        retained_data = tables[-1]\n    else:\n        retained_data = tables\n    if attribute_name is not None:\n        data[attribute_name] = retained_data\n        return data\n    return retained_data"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ntake a dictionary and makes all the keys lower case and checks that all the keys are unique.", "response": "def lower_and_check_unique(dict_to_check):\n    \"\"\"\n    Takes a dictionary and makes all the keys lower case. Also replaces\n    \"jobtype\" with \"job_type\" just so that key specifically can be called\n    elsewhere without ambiguity. Finally, ensures that multiple identical\n    keys, that differed only due to different capitalizations, are not\n    present. If there are multiple equivalent keys, an Exception is raised.\n\n    Args:\n        dict_to_check (dict): The dictionary to check and standardize\n\n    Returns:\n        to_return (dict): An identical dictionary but with all keys made\n            lower case and no identical keys present.\n    \"\"\"\n    if dict_to_check == None:\n        return None\n    else:\n        to_return = {}\n        for key in dict_to_check:\n            new_key = key.lower()\n            if new_key == \"jobtype\":\n                new_key = \"job_type\"\n            if new_key in to_return:\n                raise Exception(\n                    \"Multiple instances of key \" + new_key + \" found!\")\n            else:\n                try:\n                    to_return[new_key] = dict_to_check.get(key).lower()\n                except AttributeError:\n                    to_return[new_key] = dict_to_check.get(key)\n        return to_return"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ntakes a set of parsed coordinates which come as an array of strings and returns a numpy array of floats.", "response": "def process_parsed_coords(coords):\n    \"\"\"\n    Takes a set of parsed coordinates, which come as an array of strings,\n    and returns a numpy array of floats.\n    \"\"\"\n    geometry = np.zeros(shape=(len(coords), 3), dtype=float)\n    for ii, entry in enumerate(coords):\n        for jj in range(3):\n            geometry[ii, jj] = float(entry[jj])\n    return geometry"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef gen_sl_transform_matricies(area_multiple):\n    return [np.array(((i, j), (0, area_multiple / i)))\n            for i in get_factors(area_multiple)\n            for j in range(area_multiple // i)]", "response": "Generates the list of transformation matricies that covert unit vectors to super lattice vectors."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncalculates angle between two vectors a and b", "response": "def vec_angle(a, b):\n    \"\"\"\n    Calculate angle between two vectors\n    \"\"\"\n    cosang = np.dot(a, b)\n    sinang = fast_norm(np.cross(a, b))\n    return np.arctan2(sinang, cosang)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngenerating independent and unique basis vectors based on the Zur and McGill methodology of Zur and McGill", "response": "def reduce_vectors(a, b):\n    \"\"\"\n    Generate independent and unique basis vectors based on the\n    methodology of Zur and McGill\n    \"\"\"\n    if np.dot(a, b) < 0:\n        return reduce_vectors(a, -b)\n\n    if fast_norm(a) > fast_norm(b):\n        return reduce_vectors(b, a)\n\n    if fast_norm(b) > fast_norm(np.add(b, a)):\n        return reduce_vectors(a, np.add(b, a))\n\n    if fast_norm(b) > fast_norm(np.subtract(b, a)):\n        return reduce_vectors(a, np.subtract(b, a))\n\n    return [a, b]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn True if two sets of vectors are the same within length and angle of the current session.", "response": "def is_same_vectors(self, vec_set1, vec_set2):\n        \"\"\"\n        Determine if two sets of vectors are the same within length and angle\n        tolerances\n\n        Args:\n            vec_set1(array[array]): an array of two vectors\n            vec_set2(array[array]): second array of two vectors\n        \"\"\"\n        if (np.absolute(rel_strain(vec_set1[0], vec_set2[0])) >\n                self.max_length_tol):\n            return False\n        elif (np.absolute(rel_strain(vec_set1[1], vec_set2[1])) >\n                  self.max_length_tol):\n            return False\n        elif (np.absolute(rel_angle(vec_set1, vec_set2)) >\n                  self.max_angle_tol):\n            return False\n        else:\n            return True"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngenerates the list of all the SL transformation sets for the film and substrate pair.", "response": "def generate_sl_transformation_sets(self, film_area, substrate_area):\n        \"\"\"\n        Generates transformation sets for film/substrate pair given the\n        area of the unit cell area for the film and substrate. The\n        transformation sets map the film and substrate unit cells to super\n        lattices with a maximum area\n\n        Args:\n            film_area(int): the unit cell area for the film\n            substrate_area(int): the unit cell area for the substrate\n\n        Returns:\n            transformation_sets: a set of transformation_sets defined as:\n                1.) the transformation matricies for the film to create a\n                super lattice of area i*film area\n                2.) the tranformation matricies for the substrate to create\n                a super lattice of area j*film area\n        \"\"\"\n        transformation_indicies = [(i, j)\n                                   for i in range(1, int(self.max_area / film_area))\n                                   for j in range(1, int(self.max_area / substrate_area))\n                                   if np.absolute(film_area / substrate_area - float(j) / i) < self.max_area_ratio_tol]\n\n        # Sort sets by the square of the matching area and yield in order\n        # from smallest to largest\n        for x in sorted(transformation_indicies, key=lambda x: x[0] * x[1]):\n            yield (gen_sl_transform_matricies(x[0]),\n                   gen_sl_transform_matricies(x[1]))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning all possible transformation sets that are equivalent to the film and substrate vectors.", "response": "def get_equiv_transformations(self, transformation_sets, film_vectors,\n                                  substrate_vectors):\n        \"\"\"\n        Applies the transformation_sets to the film and substrate vectors\n        to generate super-lattices and checks if they matches.\n        Returns all matching vectors sets.\n\n        Args:\n            transformation_sets(array): an array of transformation sets:\n                each transformation set is an array with the (i,j)\n                indicating the area multipes of the film and subtrate it\n                corresponds to, an array with all possible transformations\n                for the film area multiple i and another array for the\n                substrate area multiple j.\n\n            film_vectors(array): film vectors to generate super lattices\n            substrate_vectors(array): substrate vectors to generate super\n                lattices\n        \"\"\"\n\n        for (film_transformations, substrate_transformations) in \\\n                transformation_sets:\n            # Apply transformations and reduce using Zur reduce methodology\n            films = [reduce_vectors(*np.dot(f, film_vectors)) for f in film_transformations]\n\n            substrates = [reduce_vectors(*np.dot(s, substrate_vectors)) for s in substrate_transformations]\n\n            # Check if equivelant super lattices\n            for f, s in product(films, substrates):\n                if self.is_same_vectors(f, s):\n                    yield [f, s]"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a dictionary which contains ZSL match.", "response": "def match_as_dict(self, film_sl_vectors, substrate_sl_vectors, film_vectors, substrate_vectors, match_area):\n        \"\"\"\n        Returns dict which contains ZSL match\n\n        Args:\n            film_miller(array)\n            substrate_miller(array)\n        \"\"\"\n        d = {}\n        d[\"film_sl_vecs\"] = np.asarray(film_sl_vectors)\n        d[\"sub_sl_vecs\"] = np.asarray(substrate_sl_vectors)\n        d[\"match_area\"] = match_area\n        d[\"film_vecs\"] = np.asarray(film_vectors)\n        d[\"sub_vecs\"] = np.asarray(substrate_vectors)\n\n        return d"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef calculate(self, film, substrate, elasticity_tensor=None,\n                  film_millers=None, substrate_millers=None,\n                  ground_state_energy=0, lowest=False):\n        \"\"\"\n        Finds all topological matches for the substrate and calculates elastic\n        strain energy and total energy for the film if elasticity tensor and\n        ground state energy are provided:\n\n        Args:\n            film(Structure): conventional standard structure for the film\n            substrate(Structure): conventional standard structure for the\n                substrate\n            elasticity_tensor(ElasticTensor): elasticity tensor for the film\n                in the IEEE orientation\n            film_millers(array): film facets to consider in search as defined by\n                miller indicies\n            substrate_millers(array): substrate facets to consider in search as\n                defined by miller indicies\n            ground_state_energy(float): ground state energy for the film\n            lowest(bool): only consider lowest matching area for each surface\n        \"\"\"\n        self.film = film\n        self.substrate = substrate\n\n        # Generate miller indicies if none specified for film\n        if film_millers is None:\n            film_millers = sorted(get_symmetrically_distinct_miller_indices(\n                self.film, self.film_max_miller))\n\n        # Generate miller indicies if none specified for substrate\n        if substrate_millers is None:\n            substrate_millers = sorted(\n                get_symmetrically_distinct_miller_indices(self.substrate,\n                                                          self.substrate_max_miller))\n\n        # Check each miller index combination\n        surface_vector_sets = self.generate_surface_vectors(film_millers, substrate_millers)\n        for [film_vectors, substrate_vectors, film_miller, substrate_miller] in surface_vector_sets:\n            for match in self.zsl(film_vectors, substrate_vectors, lowest):\n                match['film_miller'] = film_miller\n                match['sub_miller'] = substrate_miller\n                if (elasticity_tensor is not None):\n                    energy, strain = self.calculate_3D_elastic_energy(\n                        film, match, elasticity_tensor, include_strain=True)\n                    match[\"elastic_energy\"] = energy\n                    match[\"strain\"] = strain\n                if (ground_state_energy is not 0):\n                    match['total_energy'] = match.get('elastic_energy', 0) + ground_state_energy\n\n                yield match", "response": "Calculates the topological matches for the given film and substrate."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncalculating the multi - plane elastic energy for a single - plane film.", "response": "def calculate_3D_elastic_energy(self, film, match, elasticity_tensor=None,\n                                    include_strain=False):\n        \"\"\"\n        Calculates the multi-plane elastic energy. Returns 999 if no elastic\n        tensor was given on init\n\n        Args:\n            film(Structure): conventional standard structure for the film\n            match(dictionary) : match dictionary from substrate analyzer\n            elasticity_tensor(ElasticTensor): elasticity tensor for the film\n            include_strain(bool): include strain in the output or not; changes\n             return from just the energy to a tuple with the energy and strain\n             in voigt notation\n        \"\"\"\n        if elasticity_tensor is None:\n            return 9999\n\n        # Get the appropriate surface structure\n        struc = SlabGenerator(self.film, match['film_miller'], 20, 15,\n                              primitive=False).get_slab().oriented_unit_cell\n\n        # Generate 3D lattice vectors for film super lattice\n        film_matrix = list(match['film_sl_vecs'])\n        film_matrix.append(np.cross(film_matrix[0], film_matrix[1]))\n\n        # Generate 3D lattice vectors for substrate super lattice\n        # Out of plane substrate super lattice has to be same length as\n        # Film out of plane vector to ensure no extra deformation in that\n        # direction\n        substrate_matrix = list(match['sub_sl_vecs'])\n        temp_sub = np.cross(substrate_matrix[0], substrate_matrix[1])\n        temp_sub = temp_sub * fast_norm(film_matrix[2]) / fast_norm(temp_sub)\n        substrate_matrix.append(temp_sub)\n\n        transform_matrix = np.transpose(np.linalg.solve(film_matrix,\n                                                        substrate_matrix))\n\n        dfm = Deformation(transform_matrix)\n\n        strain = dfm.green_lagrange_strain.convert_to_ieee(struc, initial_fit=False)\n\n        energy_density = elasticity_tensor.energy_density(\n            strain)\n\n        if include_strain:\n            return (film.volume * energy_density / len(film.sites), strain.von_mises_strain)\n        else:\n            return film.volume * energy_density / len(film.sites)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _from_frame_string(contents):\n        lines = contents.split(\"\\n\")\n        num_sites = int(lines[0])\n        coords = []\n        sp = []\n        coord_patt = re.compile(\n            r\"(\\w+)\\s+([0-9\\-\\+\\.eEdD]+)\\s+([0-9\\-\\+\\.eEdD]+)\\s+([0-9\\-\\+\\.eEdD]+)\"\n        )\n        for i in range(2, 2 + num_sites):\n            m = coord_patt.search(lines[i])\n            if m:\n                sp.append(m.group(1))  # this is 1-indexed\n                # this is 0-indexed\n                # in case of 0.0D+00 or 0.00d+01 old double precision writing\n                # replace d or D by e for ten power exponent\n                xyz = [val.lower().replace(\"d\", \"e\") for val in m.groups()[1:4]]\n                coords.append([float(val) for val in xyz])\n        return Molecule(sp, coords)", "response": "Convert a single frame XYZ string to a molecule"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef from_string(contents):\n        if contents[-1] != \"\\n\":\n            contents += \"\\n\"\n        white_space = r\"[ \\t\\r\\f\\v]\"\n        natoms_line = white_space + r\"*\\d+\" + white_space + r\"*\\n\"\n        comment_line = r\"[^\\n]*\\n\"\n        coord_lines = r\"(\\s*\\w+\\s+[0-9\\-\\+\\.eEdD]+\\s+[0-9\\-\\+\\.eEdD]+\\s+[0-9\\-\\+\\.eEdD]+\\s*\\n)+\"\n        frame_pattern_text = natoms_line + comment_line + coord_lines\n        pat = re.compile(frame_pattern_text, re.MULTILINE)\n        mols = []\n        for xyz_match in pat.finditer(contents):\n            xyz_text = xyz_match.group(0)\n            mols.append(XYZ._from_frame_string(xyz_text))\n        return XYZ(mols)", "response": "Creates an XYZ object from a string."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a chemical shielding tensor aligned to the principle axis system", "response": "def principal_axis_system(self):\n        \"\"\"\n        Returns a chemical shielding tensor aligned to the principle axis system\n        so that only the 3 diagnol components are non-zero\n        \"\"\"\n        return ChemicalShielding(np.diag(np.sort(np.linalg.eigvals(self))))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef haeberlen_values(self):\n        pas=self.principal_axis_system\n        sigma_iso=pas.trace() / 3\n        sigmas=np.diag(pas)\n        sigmas=sorted(sigmas, key=lambda x: np.abs(x - sigma_iso))\n        sigma_yy, sigma_xx, sigma_zz=sigmas\n        delta_sigma=sigma_zz - 0.5 * (sigma_xx + sigma_yy)\n        zeta=sigma_zz - sigma_iso\n        eta=(sigma_yy - sigma_xx) / zeta\n        return self.HaeberlenNotation(sigma_iso, delta_sigma, zeta, eta)", "response": "Returns the Chemical shielding tensor in Haeberlen Notation\n       "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef mehring_values(self):\n        pas=self.principal_axis_system\n        sigma_iso=pas.trace() / 3\n        sigma_11, sigma_22, sigma_33=np.diag(pas)\n        return self.MehringNotation(sigma_iso, sigma_11, sigma_22, sigma_33)", "response": "Returns the Chemical shielding tensor in Mehring Notation"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the Chemical shielding tensor in Maryland Notation", "response": "def maryland_values(self):\n        \"\"\"\n        Returns: the Chemical shielding tensor in Maryland Notation\n        \"\"\"\n        pas=self.principal_axis_system\n        sigma_iso=pas.trace() / 3\n        omega=np.diag(pas)[2] - np.diag(pas)[0]\n        # There is a typo in equation 20 from Magn. Reson. Chem. 2008, 46, 582\u2013598, the sign is wrong.\n        # There correct order is presented in Solid State Nucl. Magn. Reson. 1993, 2, 285-288.\n        kappa=3.0 * (np.diag(pas)[1] - sigma_iso) / omega\n        return self.MarylandNotation(sigma_iso, omega, kappa)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef principal_axis_system(self):\n        return ElectricFieldGradient(np.diag(np.sort(np.linalg.eigvals(self))))", "response": "Returns a electric field gradient tensor aligned to the principle axis system."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef asymmetry(self):\n        diags=np.diag(self.principal_axis_system)\n        V=sorted(diags, key=np.abs)\n        return np.abs((V[1] - V[0]) / V[2])", "response": "Asymmetry of the electric field tensor defined as :"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef coupling_constant(self, specie):\n        planks_constant=FloatWithUnit(6.62607004E-34, \"m^2 kg s^-1\")\n        Vzz=FloatWithUnit(self.V_zz, \"V ang^-2\")\n        e=FloatWithUnit(-1.60217662E-19, \"C\")\n\n        # Convert from string to Specie object\n        if isinstance(specie, str):\n            # isotope was provided in string format\n            if len(specie.split(\"-\")) > 1:\n                isotope=str(specie)\n                specie=Specie(specie.split(\"-\")[0])\n                Q=specie.get_nmr_quadrupole_moment(isotope)\n            else:\n                specie=Specie(specie)\n                Q=specie.get_nmr_quadrupole_moment()\n        elif isinstance(specie, Site):\n            specie=specie.specie\n            Q=specie.get_nmr_quadrupole_moment()\n        elif isinstance(specie, Specie):\n            Q=specie.get_nmr_quadrupole_moment()\n        else:\n            raise ValueError(\"Invalid speciie provided for quadrupolar coupling constant calcuations\")\n\n        return (e * Q * Vzz / planks_constant).to(\"MHz\")", "response": "This function calculates the coupling constant for a specific species at a specific site."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn an analysis of a given structure and the structure with the key strength which may be strong weak or unknown.", "response": "def get_analysis_and_structure(self,\n                                   structure,\n                                   calculate_valences=True,\n                                   guesstimate_spin=False,\n                                   op_threshold=0.1):\n        \"\"\"\n        Obtain an analysis of a given structure and if it may be Jahn-Teller\n        active or not. This is a heuristic, and may give false positives and\n        false negatives (false positives are preferred).\n\n        :param structure: input structure\n        :param calculate_valences (bool): whether to attempt to calculate valences or not, structure\n        should have oxidation states to perform analysis\n        :param guesstimate_spin (bool): whether to guesstimate spin state from magnetic moments\n        or not, use with caution\n        :param op_threshold (float): threshold for order parameter above which to consider site\n        to match an octahedral or tetrahedral motif, since Jahn-Teller structures can often be\n        quite distorted, this threshold is smaller than one might expect\n        :return (dict): analysis of structure, with key 'strength' which may be 'none', 'strong',\n        'weak', or 'unknown'\n        \"\"\"\n\n        structure = structure.get_primitive_structure()\n\n        if calculate_valences:\n            bva = BVAnalyzer()\n            structure = bva.get_oxi_state_decorated_structure(structure)\n\n        # no point testing multiple equivalent sites, doesn't make any difference to analysis\n        # but makes returned\n        symmetrized_structure = SpacegroupAnalyzer(structure).get_symmetrized_structure()\n\n        # to detect structural motifs of a given site\n        op = LocalStructOrderParams(['oct', 'tet'])\n\n        # dict of site index to the Jahn-Teller analysis of that site\n        jt_sites = []\n        non_jt_sites = []\n\n        for indices in symmetrized_structure.equivalent_indices:\n\n            idx = indices[0]\n            site = symmetrized_structure[idx]\n\n            # only interested in sites with oxidation states\n            if isinstance(site.specie, Specie) and site.specie.element.is_transition_metal:\n\n                # get motif around site\n                order_params = op.get_order_parameters(symmetrized_structure, idx)\n\n                if order_params[0] > order_params[1] and order_params[0] > op_threshold:\n                    motif = 'oct'\n                    motif_order_parameter = order_params[0]\n                elif order_params[1] > op_threshold:\n                    motif = 'tet'\n                    motif_order_parameter = order_params[1]\n                else:\n                    motif = 'unknown'\n                    motif_order_parameter = None\n\n                if motif == \"oct\" or motif == \"tet\":\n\n                    # guess spin of metal ion\n                    if guesstimate_spin and 'magmom' in site.properties:\n\n                        # estimate if high spin or low spin\n                        magmom = site.properties['magmom']\n                        spin_state = self._estimate_spin_state(site.specie, motif, magmom)\n                    else:\n                        spin_state = \"unknown\"\n\n                    magnitude = self.get_magnitude_of_effect_from_species(site.specie,\n                                                                          spin_state,\n                                                                          motif)\n\n                    if magnitude != \"none\":\n\n                        ligands = get_neighbors_of_site_with_index(structure, idx,\n                                                                   approach=\"min_dist\",\n                                                                   delta=0.15)\n                        ligand_bond_lengths = [ligand.distance(structure[idx])\n                                               for ligand in ligands]\n                        ligands_species = list(set([str(ligand.specie) for ligand in ligands]))\n                        ligand_bond_length_spread = max(ligand_bond_lengths) - \\\n                                                    min(ligand_bond_lengths)\n\n                        def trim(f):\n                            # avoid storing to unreasonable precision, hurts readability\n                            return float(\"{:.4f}\".format(f))\n\n                        # to be Jahn-Teller active, all ligands have to be the same\n                        if len(ligands_species) == 1:\n                            jt_sites.append({'strength': magnitude,\n                                             'motif': motif,\n                                             'motif_order_parameter': trim(motif_order_parameter),\n                                             'spin_state': spin_state,\n                                             'species': str(site.specie),\n                                             'ligand': ligands_species[0],\n                                             'ligand_bond_lengths': [trim(length) for length in\n                                                                     ligand_bond_lengths],\n                                             'ligand_bond_length_spread':\n                                                 trim(ligand_bond_length_spread),\n                                             'site_indices': indices})\n\n                    # store reasons for not being J-T active\n                    else:\n                        non_jt_sites.append({'site_indices': indices,\n                                             'strength': \"none\",\n                                             'reason': \"Not Jahn-Teller active for this \"\n                                                       \"electronic configuration.\"})\n                else:\n                    non_jt_sites.append({'site_indices': indices,\n                                         'strength': \"none\",\n                                         'reason': \"motif is {}\".format(motif)})\n\n        # perform aggregation of all sites\n        if jt_sites:\n            analysis = {'active': True}\n            # if any site could exhibit 'strong' Jahn-Teller effect\n            # then mark whole structure as strong\n            strong_magnitudes = [site['strength'] == \"strong\" for site in jt_sites]\n            if any(strong_magnitudes):\n                analysis['strength'] = \"strong\"\n            else:\n                analysis['strength'] = \"weak\"\n            analysis['sites'] = jt_sites\n            return analysis, structure\n        else:\n            return {'active': False, 'sites': non_jt_sites}, structure"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget magnitude of Jahn - Teller effect from provided species spin state and motife.", "response": "def get_magnitude_of_effect_from_species(self, species, spin_state, motif):\n        \"\"\"\n        Get magnitude of Jahn-Teller effect from provided species, spin state and motife.\n\n        :param species: e.g. Fe2+\n        :param spin_state (str): \"high\" or \"low\"\n        :param motif (str): \"oct\" or \"tet\"\n\n        :return (str):\n        \"\"\"\n\n        magnitude = \"none\"\n\n        sp = get_el_sp(species)\n\n        # has to be Specie; we need to know the oxidation state\n        if isinstance(sp, Specie) and sp.element.is_transition_metal:\n\n            d_electrons = self._get_number_of_d_electrons(sp)\n\n            if motif in self.spin_configs:\n                if spin_state not in self.spin_configs[motif][d_electrons]:\n                    spin_state = self.spin_configs[motif][d_electrons]['default']\n                spin_config = self.spin_configs[motif][d_electrons][spin_state]\n                magnitude = JahnTellerAnalyzer.get_magnitude_of_effect_from_spin_config(motif,\n                                                                                        spin_config)\n        else:\n            warnings.warn(\"No data for this species.\")\n\n        return magnitude"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the magnitude of effect from the given spin configuration.", "response": "def get_magnitude_of_effect_from_spin_config(motif, spin_config):\n        \"\"\"\n        Roughly, the magnitude of Jahn-Teller distortion will be:\n        * in octahedral environments, strong if e_g orbitals\n        unevenly occupied but weak if t_2g orbitals unevenly\n        occupied\n        * in tetrahedral environments always weaker\n        :param motif (str): \"oct\" or \"tet\"\n        :param spin_config (dict): dict of 'e' (e_g) and 't' (t2_g)\n        with number of electrons in each state\n        \"\"\"\n        magnitude = \"none\"\n        if motif == \"oct\":\n            e_g = spin_config[\"e_g\"]\n            t_2g = spin_config[\"t_2g\"]\n            if (e_g % 2 != 0) or (t_2g % 3 != 0):\n                magnitude = \"weak\"\n                if e_g % 2 == 1:\n                    magnitude = \"strong\"\n        elif motif == \"tet\":\n            e = spin_config[\"e\"]\n            t_2 = spin_config[\"t_2\"]\n            if (e % 3 != 0) or (t_2 % 2 != 0):\n                magnitude = \"weak\"\n        return magnitude"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _estimate_spin_state(species, motif, known_magmom):\n        mu_so_high = JahnTellerAnalyzer.mu_so(species, motif=motif, spin_state=\"high\")\n        mu_so_low = JahnTellerAnalyzer.mu_so(species, motif=motif, spin_state=\"low\")\n        if mu_so_high == mu_so_low:\n            return \"undefined\"  # undefined or only one spin state possible\n        elif mu_so_high is None:\n            return \"low\"\n        elif mu_so_low is None:\n            return \"high\"\n        else:\n            diff = mu_so_high - mu_so_low\n            # WARNING! this heuristic has not been robustly tested or benchmarked\n            # using 'diff*0.25' as arbitrary measure, if known magmom is\n            # too far away from expected value, we don't try to classify it\n            if known_magmom > mu_so_high or abs(mu_so_high - known_magmom) < diff * 0.25:\n                return \"high\"\n            elif known_magmom < mu_so_low or abs(mu_so_low - known_magmom) < diff * 0.25:\n                return \"low\"\n            else:\n                return \"unknown\"", "response": "Simple heuristic to estimate spin state for a given species and motif."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef mu_so(species, motif, spin_state):\n        try:\n            sp = get_el_sp(species)\n            n = sp.get_crystal_field_spin(coordination=motif, spin_config=spin_state)\n            # calculation spin-only magnetic moment for this number of unpaired spins\n            return np.sqrt(n * (n + 2))\n        except AttributeError:\n            return None", "response": "Calculates the spin - only magnetic moment for a specific species. Only supports transition metals."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_conversion_factor(structure, species, temperature):\n    df_sp = get_el_sp(species)\n    if hasattr(df_sp, \"oxi_state\"):\n        z = df_sp.oxi_state\n    else:\n        z = df_sp.full_electronic_structure[-1][2]\n\n    n = structure.composition[species]\n\n    vol = structure.volume * 1e-24  # units cm^3\n    return 1000 * n / (vol * const.N_A) * z ** 2 * (const.N_A * const.e) ** 2 \\\n        / (const.R * temperature)", "response": "Returns the conversion factor for a diffusion run in Kelvin."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nfits the Arrhenius model to obtain the standard error of Ea from the Arrhenius fit.", "response": "def fit_arrhenius(temps, diffusivities):\n    \"\"\"\n    Returns Ea, c, standard error of Ea from the Arrhenius fit:\n        D = c * exp(-Ea/kT)\n\n    Args:\n        temps ([float]): A sequence of temperatures. units: K\n        diffusivities ([float]): A sequence of diffusivities (e.g.,\n            from DiffusionAnalyzer.diffusivity). units: cm^2/s\n    \"\"\"\n    t_1 = 1 / np.array(temps)\n    logd = np.log(diffusivities)\n    # Do a least squares regression of log(D) vs 1/T\n    a = np.array([t_1, np.ones(len(temps))]).T\n    w, res, _, _ = np.linalg.lstsq(a, logd, rcond=None)\n    w = np.array(w)\n    n = len(temps)\n    if n > 2:\n        std_Ea = (res[0] / (n - 2) / (\n        n * np.var(t_1))) ** 0.5 * const.k / const.e\n    else:\n        std_Ea = None\n    return -w[0] * const.k / const.e, np.exp(w[1]), std_Ea"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the extrapolated diffusivity at new_temp", "response": "def get_extrapolated_diffusivity(temps, diffusivities, new_temp):\n    \"\"\"\n    Returns (Arrhenius) extrapolated diffusivity at new_temp\n\n    Args:\n        temps ([float]): A sequence of temperatures. units: K\n        diffusivities ([float]): A sequence of diffusivities (e.g.,\n            from DiffusionAnalyzer.diffusivity). units: cm^2/s\n        new_temp (float): desired temperature. units: K\n\n    Returns:\n        (float) Diffusivity at extrapolated temp in mS/cm.\n    \"\"\"\n    Ea, c, _ = fit_arrhenius(temps, diffusivities)\n    return c * np.exp(-Ea / (const.k / const.e * new_temp))"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the extrapolated mS and cm conductivity at a given temperature.", "response": "def get_extrapolated_conductivity(temps, diffusivities, new_temp, structure,\n                                  species):\n    \"\"\"\n    Returns extrapolated mS/cm conductivity.\n\n    Args:\n        temps ([float]): A sequence of temperatures. units: K\n        diffusivities ([float]): A sequence of diffusivities (e.g.,\n            from DiffusionAnalyzer.diffusivity). units: cm^2/s\n        new_temp (float): desired temperature. units: K\n        structure (structure): Structure used for the diffusivity calculation\n        species (string/Specie): conducting species\n\n    Returns:\n        (float) Conductivity at extrapolated temp in mS/cm.\n    \"\"\"\n    return get_extrapolated_diffusivity(temps, diffusivities, new_temp) \\\n        * get_conversion_factor(structure, species, new_temp)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_arrhenius_plot(temps, diffusivities, diffusivity_errors=None,\n                       **kwargs):\n    \"\"\"\n    Returns an Arrhenius plot.\n\n    Args:\n        temps ([float]): A sequence of temperatures.\n        diffusivities ([float]): A sequence of diffusivities (e.g.,\n            from DiffusionAnalyzer.diffusivity).\n        diffusivity_errors ([float]): A sequence of errors for the\n            diffusivities. If None, no error bar is plotted.\n        \\\\*\\\\*kwargs:\n            Any keyword args supported by matplotlib.pyplot.plot.\n\n    Returns:\n        A matplotlib.pyplot object. Do plt.show() to show the plot.\n    \"\"\"\n    Ea, c, _ = fit_arrhenius(temps, diffusivities)\n\n    from pymatgen.util.plotting import pretty_plot\n    plt = pretty_plot(12, 8)\n\n    # log10 of the arrhenius fit\n    arr = c * np.exp(-Ea / (const.k / const.e * np.array(temps)))\n\n    t_1 = 1000 / np.array(temps)\n\n    plt.plot(t_1, diffusivities, 'ko', t_1, arr, 'k--', markersize=10,\n             **kwargs)\n    if diffusivity_errors is not None:\n        n = len(diffusivity_errors)\n        plt.errorbar(t_1[0:n], diffusivities[0:n], yerr=diffusivity_errors,\n                     fmt='ko', ecolor='k', capthick=2, linewidth=2)\n    ax = plt.axes()\n    ax.set_yscale('log')\n    plt.text(0.6, 0.85, \"E$_a$ = {:.0f} meV\".format(Ea * 1000),\n             fontsize=30, transform=plt.axes().transAxes)\n    plt.ylabel(\"D (cm$^2$/s)\")\n    plt.xlabel(\"1000/T (K$^{-1}$)\")\n    plt.tight_layout()\n    return plt", "response": "Returns an Arrhenius plot for the given temperatures and diffusivities."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning an iterator for the drift - corrected structures in the MD.", "response": "def get_drift_corrected_structures(self, start=None, stop=None, step=None):\n        \"\"\"\n        Returns an iterator for the drift-corrected structures. Use of\n        iterator is to reduce memory usage as # of structures in MD can be\n        huge. You don't often need all the structures all at once.\n\n        Args:\n            start, stop, step (int): applies a start/stop/step to the iterator.\n                Faster than applying it after generation, as it reduces the\n                number of structures created.\n        \"\"\"\n        coords = np.array(self.structure.cart_coords)\n        species = self.structure.species_and_occu\n        lattices = self.lattices\n        nsites, nsteps, dim = self.corrected_displacements.shape\n\n        for i in range(start or 0, stop or nsteps, step or 1):\n            latt = lattices[0] if len(lattices) == 1 else lattices[i]\n            yield Structure(\n                latt, species,\n                coords + self.corrected_displacements[:, i, :],\n                coords_are_cartesian=True)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a dictionary containing the diffusion and conductivity information.", "response": "def get_summary_dict(self, include_msd_t=False, include_mscd_t=False):\n        \"\"\"\n        Provides a summary of diffusion information.\n\n        Args:\n            include_msd_t (bool): Whether to include mean square displace and\n                time data with the data.\n            include_msd_t (bool): Whether to include mean square charge displace and\n                time data with the data.\n\n        Returns:\n            (dict) of diffusion and conductivity data.\n        \"\"\"\n        d = {\n            \"D\": self.diffusivity,\n            \"D_sigma\": self.diffusivity_std_dev,\n            \"D_charge\": self.chg_diffusivity,\n            \"D_charge_sigma\": self.chg_diffusivity_std_dev,\n            \"S\": self.conductivity,\n            \"S_sigma\": self.conductivity_std_dev,\n            \"S_charge\": self.chg_conductivity,\n            \"D_components\": self.diffusivity_components.tolist(),\n            \"S_components\": self.conductivity_components.tolist(),\n            \"D_components_sigma\": self.diffusivity_components_std_dev.tolist(),\n            \"S_components_sigma\": self.conductivity_components_std_dev.tolist(),\n            \"specie\": str(self.specie),\n            \"step_skip\": self.step_skip,\n            \"time_step\": self.time_step,\n            \"temperature\": self.temperature,\n            \"max_framework_displacement\": self.max_framework_displacement,\n            \"Haven_ratio\": self.haven_ratio\n        }\n        if include_msd_t:\n            d[\"msd\"] = self.msd.tolist()\n            d[\"msd_components\"] = self.msd_components.tolist()\n            d[\"dt\"] = self.dt.tolist()\n        if include_mscd_t:\n            d[\"mscd\"] = self.mscd.tolist()\n        return d"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_framework_rms_plot(self, plt=None, granularity=200,\n                               matching_s=None):\n        \"\"\"\n        Get the plot of rms framework displacement vs time. Useful for checking\n        for melting, especially if framework atoms can move via paddle-wheel\n        or similar mechanism (which would show up in max framework displacement\n        but doesn't constitute melting).\n\n        Args:\n            plt (matplotlib.pyplot): If plt is supplied, changes will be made \n                to an existing plot. Otherwise, a new plot will be created.\n            granularity (int): Number of structures to match\n            matching_s (Structure): Optionally match to a disordered structure\n                instead of the first structure in the analyzer. Required when\n                a secondary mobile ion is present.\n        Notes:\n            The method doesn't apply to NPT-AIMD simulation analysis.\n        \"\"\"\n        from pymatgen.util.plotting import pretty_plot\n        if self.lattices is not None and len(self.lattices) > 1:\n            warnings.warn(\"Note the method doesn't apply to NPT-AIMD \"\n                          \"simulation analysis!\")\n\n        plt = pretty_plot(12, 8, plt=plt)\n        step = (self.corrected_displacements.shape[1] - 1) // (granularity - 1)\n        f = (matching_s or self.structure).copy()\n        f.remove_species([self.specie])\n        sm = StructureMatcher(primitive_cell=False, stol=0.6,\n                              comparator=OrderDisorderElementComparator(),\n                              allow_subset=True)\n        rms = []\n        for s in self.get_drift_corrected_structures(step=step):\n            s.remove_species([self.specie])\n            d = sm.get_rms_dist(f, s)\n            if d:\n                rms.append(d)\n            else:\n                rms.append((1, 1))\n        max_dt = (len(rms) - 1) * step * self.step_skip * self.time_step\n        if max_dt > 100000:\n            plot_dt = np.linspace(0, max_dt / 1000, len(rms))\n            unit = 'ps'\n        else:\n            plot_dt = np.linspace(0, max_dt, len(rms))\n            unit = 'fs'\n        rms = np.array(rms)\n        plt.plot(plot_dt, rms[:, 0], label='RMS')\n        plt.plot(plot_dt, rms[:, 1], label='max')\n        plt.legend(loc='best')\n        plt.xlabel(\"Timestep ({})\".format(unit))\n        plt.ylabel(\"normalized distance\")\n        plt.tight_layout()\n        return plt", "response": "Returns a matplotlib. pyplot object for the framework displacement vs time."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a plot of the smoothed msd vs time graph.", "response": "def get_msd_plot(self, plt=None, mode=\"specie\"):\n        \"\"\"\n        Get the plot of the smoothed msd vs time graph. Useful for\n        checking convergence. This can be written to an image file.\n\n        Args:\n            plt: A plot object. Defaults to None, which means one will be\n                generated.\n            mode (str): Determines type of msd plot. By \"species\", \"sites\",\n                or direction (default). If mode = \"mscd\", the smoothed mscd vs.\n                time will be plotted.\n        \"\"\"\n        from pymatgen.util.plotting import pretty_plot\n        plt = pretty_plot(12, 8, plt=plt)\n        if np.max(self.dt) > 100000:\n            plot_dt = self.dt / 1000\n            unit = 'ps'\n        else:\n            plot_dt = self.dt\n            unit = 'fs'\n\n        if mode == \"species\":\n            for sp in sorted(self.structure.composition.keys()):\n                indices = [i for i, site in enumerate(self.structure) if\n                           site.specie == sp]\n                sd = np.average(self.sq_disp_ions[indices, :], axis=0)\n                plt.plot(plot_dt, sd, label=sp.__str__())\n            plt.legend(loc=2, prop={\"size\": 20})\n        elif mode == \"sites\":\n            for i, site in enumerate(self.structure):\n                sd = self.sq_disp_ions[i, :]\n                plt.plot(plot_dt, sd, label=\"%s - %d\" % (\n                    site.specie.__str__(), i))\n            plt.legend(loc=2, prop={\"size\": 20})\n        elif mode == \"mscd\":\n            plt.plot(plot_dt, self.mscd, 'r')\n            plt.legend([\"Overall\"], loc=2, prop={\"size\": 20})\n        else:\n            # Handle default / invalid mode case\n            plt.plot(plot_dt, self.msd, 'k')\n            plt.plot(plot_dt, self.msd_components[:, 0], 'r')\n            plt.plot(plot_dt, self.msd_components[:, 1], 'g')\n            plt.plot(plot_dt, self.msd_components[:, 2], 'b')\n            plt.legend([\"Overall\", \"a\", \"b\", \"c\"], loc=2, prop={\"size\": 20})\n\n        plt.xlabel(\"Timestep ({})\".format(unit))\n        if mode == \"mscd\":\n            plt.ylabel(\"MSCD ($\\\\AA^2$)\")\n        else:\n            plt.ylabel(\"MSD ($\\\\AA^2$)\")\n        plt.tight_layout()\n        return plt"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nexporting MSD data to a csv file.", "response": "def export_msdt(self, filename):\n        \"\"\"\n        Writes MSD data to a csv file that can be easily plotted in other\n        software.\n\n        Args:\n            filename (str): Filename. Supported formats are csv and dat. If\n                the extension is csv, a csv file is written. Otherwise,\n                a dat format is assumed.\n        \"\"\"\n        fmt = \"csv\" if filename.lower().endswith(\".csv\") else \"dat\"\n        delimiter = \", \" if fmt == \"csv\" else \" \"\n        with open(filename, \"wt\") as f:\n            if fmt == \"dat\":\n                f.write(\"# \")\n            f.write(delimiter.join([\"t\", \"MSD\", \"MSD_a\", \"MSD_b\", \"MSD_c\",\n                                    \"MSCD\"]))\n            f.write(\"\\n\")\n            for dt, msd, msdc, mscd in zip(self.dt, self.msd,\n                                           self.msd_components, self.mscd):\n                f.write(delimiter.join([\"%s\" % v for v in [dt, msd] + list(\n                    msdc) + [mscd]]))\n                f.write(\"\\n\")"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a new instance of the class _DiffusionAnalyzer_ with the given vasprun and specie.", "response": "def from_vaspruns(cls, vaspruns, specie, initial_disp=None,\n                      initial_structure=None, **kwargs):\n        \"\"\"\n        Convenient constructor that takes in a list of Vasprun objects to\n        perform diffusion analysis.\n\n        Args:\n            vaspruns ([Vasprun]): List of Vaspruns (must be ordered  in\n                sequence of MD simulation). E.g., you may have performed\n                sequential VASP runs to obtain sufficient statistics.\n            specie (Element/Specie): Specie to calculate diffusivity for as a\n                String. E.g., \"Li\".\n            initial_disp (np.ndarray): Sometimes, you need to iteratively\n                compute estimates of the diffusivity. This supplies an\n                initial displacement that will be added on to the initial\n                displacements. Note that this makes sense only when\n                smoothed=False.\n            initial_structure (Structure): Like initial_disp, this is used\n                for iterative computations of estimates of the diffusivity. You\n                typically need to supply both variables. This stipulates the\n                initial stricture from which the current set of displacements\n                are computed.\n            \\\\*\\\\*kwargs: kwargs supported by the :class:`DiffusionAnalyzer`_. \n                Examples include smoothed, min_obs, avg_nsteps.\n        \"\"\"\n\n        def get_structures(vaspruns):\n            for i, vr in enumerate(vaspruns):\n                if i == 0:\n                    step_skip = vr.ionic_step_skip or 1\n                    final_structure = vr.initial_structure\n                    temperature = vr.parameters['TEEND']\n                    time_step = vr.parameters['POTIM']\n                    yield step_skip, temperature, time_step\n                # check that the runs are continuous\n                fdist = pbc_diff(vr.initial_structure.frac_coords,\n                                 final_structure.frac_coords)\n                if np.any(fdist > 0.001):\n                    raise ValueError('initial and final structures do not '\n                                     'match.')\n                final_structure = vr.final_structure\n\n                assert (vr.ionic_step_skip or 1) == step_skip\n                for s in vr.ionic_steps:\n                    yield s['structure']\n\n        s = get_structures(vaspruns)\n        step_skip, temperature, time_step = next(s)\n\n        return cls.from_structures(\n            structures=list(s), specie=specie, temperature=temperature,\n            time_step=time_step, step_skip=step_skip,\n            initial_disp=initial_disp, initial_structure=initial_structure,\n            **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef from_files(cls, filepaths, specie, step_skip=10, ncores=None,\n                   initial_disp=None, initial_structure=None, **kwargs):\n        \"\"\"\n        Convenient constructor that takes in a list of vasprun.xml paths to\n        perform diffusion analysis.\n\n        Args:\n            filepaths ([str]): List of paths to vasprun.xml files of runs. (\n                must be ordered in sequence of MD simulation). For example,\n                you may have done sequential VASP runs and they are in run1,\n                run2, run3, etc. You should then pass in\n                [\"run1/vasprun.xml\", \"run2/vasprun.xml\", ...].\n            specie (Element/Specie): Specie to calculate diffusivity for as a\n                String. E.g., \"Li\".\n            step_skip (int): Sampling frequency of the displacements (\n                time_step is multiplied by this number to get the real time\n                between measurements)\n            ncores (int): Numbers of cores to use for multiprocessing. Can\n                speed up vasprun parsing considerably. Defaults to None,\n                which means serial. It should be noted that if you want to\n                use multiprocessing, the number of ionic steps in all vasprun\n                .xml files should be a multiple of the ionic_step_skip.\n                Otherwise, inconsistent results may arise. Serial mode has no\n                such restrictions.\n            initial_disp (np.ndarray): Sometimes, you need to iteratively\n                compute estimates of the diffusivity. This supplies an\n                initial displacement that will be added on to the initial\n                displacements. Note that this makes sense only when\n                smoothed=False.\n            initial_structure (Structure): Like initial_disp, this is used\n                for iterative computations of estimates of the diffusivity. You\n                typically need to supply both variables. This stipulates the\n                initial structure from which the current set of displacements\n                are computed.\n            \\\\*\\\\*kwargs: kwargs supported by the :class:`DiffusionAnalyzer`_. \n                Examples include smoothed, min_obs, avg_nsteps.\n        \"\"\"\n        if ncores is not None and len(filepaths) > 1:\n            import multiprocessing\n            p = multiprocessing.Pool(ncores)\n            vaspruns = p.imap(_get_vasprun,\n                              [(fp, step_skip) for fp in filepaths])\n            analyzer = cls.from_vaspruns(\n                vaspruns, specie=specie, initial_disp=initial_disp,\n                initial_structure=initial_structure, **kwargs)\n            p.close()\n            p.join()\n            return analyzer\n        else:\n            def vr(filepaths):\n                offset = 0\n                for p in filepaths:\n                    v = Vasprun(p, ionic_step_offset=offset,\n                                ionic_step_skip=step_skip)\n                    yield v\n                    # Recompute offset.\n                    offset = (-(v.nionic_steps - offset)) % step_skip\n\n            return cls.from_vaspruns(\n                vr(filepaths), specie=specie, initial_disp=initial_disp,\n                initial_structure=initial_structure, **kwargs)", "response": "This is a convenience method that takes in a list of filepaths and specie and returns a new instance of the class I_n_iterations and I_n_displacements."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\napply the strategy to the structure_environments object in order to define the coordination environment of a given site. :param site: Site for which the coordination environment is looked for :return: The coordination environment of the site. For complex strategies, where one allows multiple solutions, this can return a list of coordination environments for the site", "response": "def get_site_coordination_environments_fractions(self, site, isite=None, dequivsite=None, dthissite=None,\n                                                     mysym=None, ordered=True, min_fraction=0.0, return_maps=True,\n                                                     return_strategy_dict_info=False):\n        \"\"\"\n        Applies the strategy to the structure_environments object in order to define the coordination environment of\n        a given site.\n        :param site: Site for which the coordination environment is looked for\n        :return: The coordination environment of the site. For complex strategies, where one allows multiple\n        solutions, this can return a list of coordination environments for the site\n        \"\"\"\n        raise NotImplementedError()"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\napplies the strategy to the structure_environments object to get the coordination environments fraction csm geometry_info and neighbors of the site.", "response": "def get_site_ce_fractions_and_neighbors(self, site, full_ce_info=False, strategy_info=False):\n        \"\"\"\n        Applies the strategy to the structure_environments object in order to get coordination environments, their\n        fraction, csm, geometry_info, and neighbors\n        :param site: Site for which the above information is seeked\n        :return: The list of neighbors of the site. For complex strategies, where one allows multiple solutions, this\n        can return a list of list of neighbors\n        \"\"\"\n        [isite, dequivsite, dthissite, mysym] = self.equivalent_site_index_and_transform(site)\n        geoms_and_maps_list = self.get_site_coordination_environments_fractions(site=site, isite=isite,\n                                                                                dequivsite=dequivsite,\n                                                                                dthissite=dthissite, mysym=mysym,\n                                                                                return_maps=True,\n                                                                                return_strategy_dict_info=True)\n        if geoms_and_maps_list is None:\n            return None\n        site_nbs_sets = self.structure_environments.neighbors_sets[isite]\n        ce_and_neighbors = []\n        for fractions_dict in geoms_and_maps_list:\n            ce_map = fractions_dict['ce_map']\n            ce_nb_set = site_nbs_sets[ce_map[0]][ce_map[1]]\n            neighbors = [{'site': nb_site_and_index['site'],\n                          'index': nb_site_and_index['index']}\n                         for nb_site_and_index in ce_nb_set.neighb_sites_and_indices]\n            fractions_dict['neighbors'] = neighbors\n            ce_and_neighbors.append(fractions_dict)\n        return ce_and_neighbors"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef as_dict(self):\n        return {\"@module\": self.__class__.__module__,\n                \"@class\": self.__class__.__name__,\n                \"distance_cutoff\": float(self._distance_cutoff),\n                \"angle_cutoff\": float(self._angle_cutoff),\n                \"additional_condition\": int(self._additional_condition),\n                \"continuous_symmetry_measure_cutoff\": float(self._continuous_symmetry_measure_cutoff),\n                \"symmetry_measure_type\": self._symmetry_measure_type}", "response": "Returns a dict representation of the SimplestChemenvStrategy object."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreconstructing the SimplestChemenvStrategy object from a dict representation of the SimplestChemenvStrategy object.", "response": "def from_dict(cls, d):\n        \"\"\"\n        Reconstructs the SimplestChemenvStrategy object from a dict representation of the SimplestChemenvStrategy object\n        created using the as_dict method.\n        :param d: dict representation of the SimplestChemenvStrategy object\n        :return: StructureEnvironments object\n        \"\"\"\n        return cls(distance_cutoff=d[\"distance_cutoff\"], angle_cutoff=d[\"angle_cutoff\"],\n                   additional_condition=d[\"additional_condition\"],\n                   continuous_symmetry_measure_cutoff=d[\"continuous_symmetry_measure_cutoff\"],\n                   symmetry_measure_type=d[\"symmetry_measure_type\"])"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a dict representation of the SimpleAbundanceChemenvStrategy object.", "response": "def as_dict(self):\n        \"\"\"\n        Bson-serializable dict representation of the SimpleAbundanceChemenvStrategy object.\n        :return: Bson-serializable dict representation of the SimpleAbundanceChemenvStrategy object.\n        \"\"\"\n        return {\"@module\": self.__class__.__module__,\n                \"@class\": self.__class__.__name__,\n                \"additional_condition\": self._additional_condition}"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef as_dict(self):\n        return {\"@module\": self.__class__.__module__,\n                \"@class\": self.__class__.__name__,\n                \"additional_condition\": self._additional_condition,\n                \"max_nabundant\": self.max_nabundant,\n                \"target_environments\": self.target_environments,\n                \"target_penalty_type\": self.target_penalty_type,\n                \"max_csm\": self.max_csm}", "response": "Return a dict representation of the TargettedPenaltiedAbundanceChemenvStrategy object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreconstructing the TargettedPenaltiedAbundanceChemenvStrategy object from a dictionary representation of the targetted penaltied abundance chemical hierarchy.", "response": "def from_dict(cls, d):\n        \"\"\"\n        Reconstructs the TargettedPenaltiedAbundanceChemenvStrategy object from a dict representation of the\n        TargettedPenaltiedAbundanceChemenvStrategy object created using the as_dict method.\n        :param d: dict representation of the TargettedPenaltiedAbundanceChemenvStrategy object\n        :return: TargettedPenaltiedAbundanceChemenvStrategy object\n        \"\"\"\n        return cls(additional_condition=d[\"additional_condition\"],\n                   max_nabundant=d[\"max_nabundant\"],\n                   target_environments=d[\"target_environments\"],\n                   target_penalty_type=d[\"target_penalty_type\"],\n                   max_csm=d[\"max_csm\"])"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a dictionary representation of the WeightedNbSetChemenvStrategy object.", "response": "def as_dict(self):\n        \"\"\"\n        Bson-serializable dict representation of the WeightedNbSetChemenvStrategy object.\n        :return: Bson-serializable dict representation of the WeightedNbSetChemenvStrategy object.\n        \"\"\"\n        return {\"@module\": self.__class__.__module__,\n                \"@class\": self.__class__.__name__,\n                \"additional_condition\": self._additional_condition,\n                \"symmetry_measure_type\": self.symmetry_measure_type,\n                \"nb_set_weights\": [nb_set_weight.as_dict() for nb_set_weight in self.nb_set_weights],\n                \"ce_estimator\": self.ce_estimator,\n                }"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreconstruct the WeightedNbSetChemenvStrategy object from a dict representation of the WeightedNbSetChemenvStrategy object created using the as_dict method.", "response": "def from_dict(cls, d):\n        \"\"\"\n        Reconstructs the WeightedNbSetChemenvStrategy object from a dict representation of the\n        WeightedNbSetChemenvStrategy object created using the as_dict method.\n        :param d: dict representation of the WeightedNbSetChemenvStrategy object\n        :return: WeightedNbSetChemenvStrategy object\n        \"\"\"\n        return cls(additional_condition=d[\"additional_condition\"],\n                   symmetry_measure_type=d[\"symmetry_measure_type\"],\n                   nb_set_weights=d[\"nb_set_weights\"],\n                   ce_estimator=d[\"ce_estimator\"])"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a dict representation of the MultiWeightsChemenvStrategy object.", "response": "def as_dict(self):\n        \"\"\"\n        Bson-serializable dict representation of the MultiWeightsChemenvStrategy object.\n        :return: Bson-serializable dict representation of the MultiWeightsChemenvStrategy object.\n        \"\"\"\n        return {\"@module\": self.__class__.__module__,\n                \"@class\": self.__class__.__name__,\n                \"additional_condition\": self._additional_condition,\n                \"symmetry_measure_type\": self.symmetry_measure_type,\n                \"dist_ang_area_weight\": self.dist_ang_area_weight.as_dict()\n                if self.dist_ang_area_weight is not None else None,\n                \"self_csm_weight\": self.self_csm_weight.as_dict()\n                if self.self_csm_weight is not None else None,\n                \"delta_csm_weight\": self.delta_csm_weight.as_dict()\n                if self.delta_csm_weight is not None else None,\n                \"cn_bias_weight\": self.cn_bias_weight.as_dict()\n                if self.cn_bias_weight is not None else None,\n                \"angle_weight\": self.angle_weight.as_dict()\n                if self.angle_weight is not None else None,\n                \"normalized_angle_distance_weight\": self.normalized_angle_distance_weight.as_dict()\n                if self.normalized_angle_distance_weight is not None else None,\n                \"ce_estimator\": self.ce_estimator,\n                }"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef from_dict(cls, d):\n        if d[\"normalized_angle_distance_weight\"] is not None:\n            nad_w = NormalizedAngleDistanceNbSetWeight.from_dict(d[\"normalized_angle_distance_weight\"])\n        else:\n            nad_w = None\n        return cls(additional_condition=d[\"additional_condition\"],\n                   symmetry_measure_type=d[\"symmetry_measure_type\"],\n                   dist_ang_area_weight=DistanceAngleAreaNbSetWeight.from_dict(d[\"dist_ang_area_weight\"])\n                   if d[\"dist_ang_area_weight\"] is not None else None,\n                   self_csm_weight=SelfCSMNbSetWeight.from_dict(d[\"self_csm_weight\"])\n                   if d[\"self_csm_weight\"] is not None else None,\n                   delta_csm_weight=DeltaCSMNbSetWeight.from_dict(d[\"delta_csm_weight\"])\n                   if d[\"delta_csm_weight\"] is not None else None,\n                   cn_bias_weight=CNBiasNbSetWeight.from_dict(d[\"cn_bias_weight\"])\n                   if d[\"cn_bias_weight\"] is not None else None,\n                   angle_weight=AngleNbSetWeight.from_dict(d[\"angle_weight\"])\n                   if d[\"angle_weight\"] is not None else None,\n                   normalized_angle_distance_weight=nad_w,\n                   ce_estimator=d[\"ce_estimator\"])", "response": "Reconstructs the MultiWeightsChemenvStrategy object from a dictionary representation of the MultiWeightsChemenvStrategy object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef pauling_stability_ratio(self):\n        if self._pauling_stability_ratio is None:\n            if self.ce_symbol in ['S:1', 'L:2']:\n                self._pauling_stability_ratio = 0.0\n            else:\n                mindist_anions = 1000000.0\n                mindist_cation_anion = 1000000.0\n                for ipt1 in range(len(self.points)):\n                    pt1 = np.array(self.points[ipt1])\n                    mindist_cation_anion = min(mindist_cation_anion,\n                                               np.linalg.norm(pt1-self.central_site))\n                    for ipt2 in range(ipt1+1, len(self.points)):\n                        pt2 = np.array(self.points[ipt2])\n                        mindist_anions = min(mindist_anions,\n                                             np.linalg.norm(pt1-pt2))\n                anion_radius = mindist_anions / 2.0\n                cation_radius = mindist_cation_anion - anion_radius\n                self._pauling_stability_ratio = cation_radius / anion_radius\n        return self._pauling_stability_ratio", "response": "Returns the theoretical Pauling stability ratio for this environment."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef number_of_permutations(self):\n        if self.permutations_safe_override:\n            return factorial(self.coordination)\n        elif self.permutations is None:\n            return factorial(self.coordination)\n        return len(self.permutations)", "response": "Returns the number of permutations of this coordination geometry."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the list of faces of this coordination geometry. Each face is given as a list of its vertices coordinates.", "response": "def faces(self, sites, permutation=None):\n        \"\"\"\n        Returns the list of faces of this coordination geometry. Each face is given as a\n        list of its vertices coordinates.\n        \"\"\"\n        if permutation is None:\n            coords = [site.coords for site in sites]\n        else:\n            coords = [sites[ii].coords for ii in permutation]\n        return [[coords[ii] for ii in f] for f in self._faces]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef edges(self, sites, permutation=None, input='sites'):\n        if input == 'sites':\n            coords = [site.coords for site in sites]\n        elif input == 'coords':\n            coords = sites\n        # if permutation is None:\n        #     coords = [site.coords for site in sites]\n        # else:\n        #     coords = [sites[ii].coords for ii in permutation]\n        if permutation is not None:\n            coords = [coords[ii] for ii in permutation]\n        return [[coords[ii] for ii in e] for e in self._edges]", "response": "Returns the list of edges of this coordination geometry. Each edge is given as a\n        list of its end vertices coordinates."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef solid_angles(self, permutation=None):\n        if permutation is None:\n            return self._solid_angles\n        else:\n            return [self._solid_angles[ii] for ii in permutation]", "response": "Returns the list of perfect solid angles."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_pmeshes(self, sites, permutation=None):\n        pmeshes = []\n        # _vertices = [site.coords for site in sites]\n        if permutation is None:\n            _vertices = [site.coords for site in sites]\n        else:\n            _vertices = [sites[ii].coords for ii in permutation]\n        _face_centers = []\n        number_of_faces = 0\n        for face in self._faces:\n            if len(face) in [3, 4]:\n                number_of_faces += 1\n            else:\n                number_of_faces += len(face)\n\n            _face_centers.append(np.array([np.mean([_vertices[face_vertex][ii]\n                                                    for face_vertex in face])\n                                           for ii in range(3)]))\n\n        out = '{}\\n'.format(len(_vertices) + len(_face_centers))\n        for vv in _vertices:\n            out += '{:15.8f} {:15.8f} {:15.8f}\\n'.format(vv[0], vv[1], vv[2])\n        for fc in _face_centers:\n            out += '{:15.8f} {:15.8f} {:15.8f}\\n'.format(fc[0], fc[1], fc[2])\n        out += '{:d}\\n'.format(number_of_faces)\n        for iface, face in enumerate(self._faces):\n            if len(face) == 3:\n                out += '4\\n'\n            elif len(face) == 4:\n                out += '5\\n'\n            else:\n                for ii in range(len(face)):\n                    out += '4\\n'\n                    out += '{:d}\\n'.format(len(_vertices) + iface)\n                    out += '{:d}\\n'.format(face[ii])\n                    out += '{:d}\\n'.format(face[np.mod(ii + 1, len(face))])\n                    out += '{:d}\\n'.format(len(_vertices) + iface)\n            if len(face) in [3, 4]:\n                for face_vertex in face:\n                    out += '{:d}\\n'.format(face_vertex)\n                out += '{:d}\\n'.format(face[0])\n        pmeshes.append({\"pmesh_string\": out})\n        return pmeshes", "response": "Returns the pmesh strings used for jmol to show this geometry."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a list of coordination geometries with the given coordination number.", "response": "def get_geometries(self, coordination=None, returned='cg'):\n        \"\"\"\n        Returns a list of coordination geometries with the given coordination number.\n        :param coordination: The coordination number of which the list of coordination geometries are returned.\n        \"\"\"\n        geom = list()\n        if coordination is None:\n            for gg in self.cg_list:\n                if returned == 'cg':\n                    geom.append(gg)\n                elif returned == 'mp_symbol':\n                    geom.append(gg.mp_symbol)\n        else:\n            for gg in self.cg_list:\n                if gg.get_coordination_number() == coordination:\n                    if returned == 'cg':\n                        geom.append(gg)\n                    elif returned == 'mp_symbol':\n                        geom.append(gg.mp_symbol)\n        return geom"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_implemented_geometries(self, coordination=None, returned='cg',\n                                   include_deactivated=False):\n        \"\"\"\n        Returns a list of the implemented coordination geometries with the given coordination number.\n        :param coordination: The coordination number of which the list of implemented coordination geometries\n        are returned.\n        \"\"\"\n        geom = list()\n        if coordination is None:\n            for gg in self.cg_list:\n                if gg.points is not None and (\n                            (not gg.deactivate) or include_deactivated):\n                    if returned == 'cg':\n                        geom.append(gg)\n                    elif returned == 'mp_symbol':\n                        geom.append(gg.mp_symbol)\n        else:\n            for gg in self.cg_list:\n                if gg.get_coordination_number() == coordination and gg.points is not None and \\\n                        ((not gg.deactivate) or include_deactivated):\n                    if returned == 'cg':\n                        geom.append(gg)\n                    elif returned == 'mp_symbol':\n                        geom.append(gg.mp_symbol)\n        return geom", "response": "Returns a list of the implemented coordination geometries with the given coordination number."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_not_implemented_geometries(self, coordination=None,\n                                       returned='mp_symbol'):\n        \"\"\"\n        Returns a list of the implemented coordination geometries with the given coordination number.\n        :param coordination: The coordination number of which the list of implemented coordination geometries\n        are returned.\n        \"\"\"\n        geom = list()\n        if coordination is None:\n            for gg in self.cg_list:\n                if gg.points is None:\n                    if returned == 'cg':\n                        geom.append(gg)\n                    elif returned == 'mp_symbol':\n                        geom.append(gg.mp_symbol)\n        else:\n            for gg in self.cg_list:\n                if gg.get_coordination_number() == coordination and gg.points is None:\n                    if returned == 'cg':\n                        geom.append(gg)\n                    elif returned == 'mp_symbol':\n                        geom.append(gg.mp_symbol)\n        return geom", "response": "Returns a list of the implemented coordination geometries with the given coordination number."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_geometry_from_name(self, name):\n        for gg in self.cg_list:\n            if gg.name == name or name in gg.alternative_names:\n                return gg\n        raise LookupError(\n            'No coordination geometry found with name \"{name}\"'.format(\n                name=name))", "response": "Returns the coordination geometry of the given name."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_geometry_from_IUPAC_symbol(self, IUPAC_symbol):\n        for gg in self.cg_list:\n            if gg.IUPAC_symbol == IUPAC_symbol:\n                return gg\n        raise LookupError(\n            'No coordination geometry found with IUPAC symbol \"{symbol}\"'.format(\n                symbol=IUPAC_symbol))", "response": "Returns the coordination geometry of the given IUPAC symbol."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_geometry_from_IUCr_symbol(self, IUCr_symbol):\n        for gg in self.cg_list:\n            if gg.IUCr_symbol == IUCr_symbol:\n                return gg\n        raise LookupError(\n            'No coordination geometry found with IUCr symbol \"{symbol}\"'.format(\n                symbol=IUCr_symbol))", "response": "Returns the coordination geometry of the given IUCr symbol."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the coordination geometry of the given mp_symbol.", "response": "def get_geometry_from_mp_symbol(self, mp_symbol):\n        \"\"\"\n        Returns the coordination geometry of the given mp_symbol.\n        :param mp_symbol: The mp_symbol of the coordination geometry.\n        \"\"\"\n        for gg in self.cg_list:\n            if gg.mp_symbol == mp_symbol:\n                return gg\n        raise LookupError(\n            'No coordination geometry found with mp_symbol \"{symbol}\"'.format(\n                symbol=mp_symbol))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef is_a_valid_coordination_geometry(self, mp_symbol=None,\n                                         IUPAC_symbol=None, IUCr_symbol=None,\n                                         name=None, cn=None):\n        \"\"\"\n        Checks whether a given coordination geometry is valid (exists) and whether the parameters are coherent with\n        each other.\n        :param IUPAC_symbol:\n        :param IUCr_symbol:\n        :param name:\n        :param cn:\n        :param mp_symbol: The mp_symbol of the coordination geometry.\n        \"\"\"\n        if name is not None:\n            raise NotImplementedError(\n                'is_a_valid_coordination_geometry not implemented for the name')\n        if mp_symbol is None and IUPAC_symbol is None and IUCr_symbol is None:\n            raise SyntaxError(\n                'missing argument for is_a_valid_coordination_geometry : at least one of mp_symbol, '\n                'IUPAC_symbol and IUCr_symbol must be passed to the function')\n        if mp_symbol is not None:\n            try:\n                cg = self.get_geometry_from_mp_symbol(mp_symbol)\n                if IUPAC_symbol is not None:\n                    if IUPAC_symbol != cg.IUPAC_symbol:\n                        return False\n                if IUCr_symbol is not None:\n                    if IUCr_symbol != cg.IUCr_symbol:\n                        return False\n                if cn is not None:\n                    if int(cn) != int(cg.coordination_number):\n                        return False\n                return True\n            except LookupError:\n                return False\n        elif IUPAC_symbol is not None:\n            try:\n                cg = self.get_geometry_from_IUPAC_symbol(IUPAC_symbol)\n                if IUCr_symbol is not None:\n                    if IUCr_symbol != cg.IUCr_symbol:\n                        return False\n                if cn is not None:\n                    if cn != cg.coordination_number:\n                        return False\n                return True\n            except LookupError:\n                return False\n        elif IUCr_symbol is not None:\n            try:\n                cg = self.get_geometry_from_IUCr_symbol(IUCr_symbol)\n                if cn is not None:\n                    if cn != cg.coordination_number:\n                        return False\n                return True\n            except LookupError:\n                return True\n        raise Exception('Should not be here !')", "response": "Checks whether a given coordination geometry is valid."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ntest whether two species are exactly the same.", "response": "def are_equal(self, sp1, sp2):\n        \"\"\"\n        True if species are exactly the same, i.e., Fe2+ == Fe2+ but not\n        Fe3+. and the spins are reversed. i.e., spin up maps to spin down,\n        and vice versa.\n\n        Args:\n            sp1: First species. A dict of {specie/element: amt} as per the\n                definition in Site and PeriodicSite.\n            sp2: Second species. A dict of {specie/element: amt} as per the\n                definition in Site and PeriodicSite.\n\n        Returns:\n            Boolean indicating whether species are equal.\n        \"\"\"\n        for s1 in sp1.keys():\n            spin1 = getattr(s1, \"spin\", 0)\n            oxi1 = getattr(s1, \"oxi_state\", 0)\n            for s2 in sp2.keys():\n                spin2 = getattr(s2, \"spin\", 0)\n                oxi2 = getattr(s2, \"oxi_state\", 0)\n                if (s1.symbol == s2.symbol and oxi1 == oxi2 and\n                        spin2 == -spin1):\n                    break\n            else:\n                return False\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef are_equal(self, sp1, sp2):\n        comp1 = Composition(sp1)\n        comp2 = Composition(sp2)\n        return comp1.get_el_amt_dict() == comp2.get_el_amt_dict()", "response": "Returns True if element : amounts are exactly the same i. e. element : amounts are not considered."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef are_equal(self, sp1, sp2):\n        set1 = set(sp1.elements)\n        set2 = set(sp2.elements)\n        return set1.issubset(set2) or set2.issubset(set1)", "response": "Returns True if there is some overlap in composition between the species\n           "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef are_equal(self, sp1, sp2):\n        set1 = set(sp1.element_composition.values())\n        set2 = set(sp2.element_composition.values())\n        if set1 == set2:\n            return True\n        else:\n            return False", "response": "Returns True if sets of occupancies ( amt ) are equal on both sites."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _get_supercell_size(self, s1, s2):\n        if self._supercell_size == 'num_sites':\n            fu = s2.num_sites / s1.num_sites\n        elif self._supercell_size == 'num_atoms':\n            fu = s2.composition.num_atoms / s1.composition.num_atoms\n        elif self._supercell_size == 'volume':\n            fu = s2.volume / s1.volume\n        else:\n            try:\n                el = get_el_sp(self._supercell_size)\n                fu = s2.composition[el] / s1.composition[el]\n            except:\n                raise ValueError('Invalid argument for supercell_size.')\n\n        if fu < 2/3:\n            return int(round(1/fu)), False\n        else:\n            return int(round(fu)), True", "response": "Returns the supercell size and whether the supercell should\n        be applied to s1."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nyielding lattices for s with lengths and angles close to the lattice of target_s.", "response": "def _get_lattices(self, target_lattice, s, supercell_size=1):\n        \"\"\"\n        Yields lattices for s with lengths and angles close to the\n        lattice of target_s. If supercell_size is specified, the\n        returned lattice will have that number of primitive cells\n        in it\n\n        Args:\n            s, target_s: Structure objects\n        \"\"\"\n        lattices = s.lattice.find_all_mappings(\n            target_lattice, ltol=self.ltol, atol=self.angle_tol,\n            skip_rotation_matrix=True)\n        for l, _, scale_m in lattices:\n            if abs(abs(np.linalg.det(scale_m)) - supercell_size) < 0.5:\n                yield l, scale_m"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _get_supercells(self, struct1, struct2, fu, s1_supercell):\n        def av_lat(l1, l2):\n            params = (np.array(l1.lengths_and_angles) +\n                      np.array(l2.lengths_and_angles)) / 2\n            return Lattice.from_lengths_and_angles(*params)\n\n        def sc_generator(s1, s2):\n            s2_fc = np.array(s2.frac_coords)\n            if fu == 1:\n                cc = np.array(s1.cart_coords)\n                for l, sc_m in self._get_lattices(s2.lattice, s1, fu):\n                    fc = l.get_fractional_coords(cc)\n                    fc -= np.floor(fc)\n                    yield fc, s2_fc, av_lat(l, s2.lattice), sc_m\n            else:\n                fc_init = np.array(s1.frac_coords)\n                for l, sc_m in self._get_lattices(s2.lattice, s1, fu):\n                    fc = np.dot(fc_init, np.linalg.inv(sc_m))\n                    lp = lattice_points_in_supercell(sc_m)\n                    fc = (fc[:, None, :] + lp[None, :, :]).reshape((-1, 3))\n                    fc -= np.floor(fc)\n                    yield fc, s2_fc, av_lat(l, s2.lattice), sc_m\n        if s1_supercell:\n            for x in sc_generator(struct1, struct2):\n                yield x\n        else:\n            for x in sc_generator(struct2, struct1):\n                # reorder generator output so s1 is still first\n                yield x[1], x[0], x[2], x[3]", "response": "Returns all supercells of two structures."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _cmp_fstruct(self, s1, s2, frac_tol, mask):\n        if len(s2) > len(s1):\n            raise ValueError(\"s1 must be larger than s2\")\n        if mask.shape != (len(s2), len(s1)):\n            raise ValueError(\"mask has incorrect shape\")\n\n        return is_coord_subset_pbc(s2, s1, frac_tol, mask)", "response": "Compare two sets of time fields."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _cart_dists(self, s1, s2, avg_lattice, mask, normalization, lll_frac_tol=None):\n        if len(s2) > len(s1):\n            raise ValueError(\"s1 must be larger than s2\")\n        if mask.shape != (len(s2), len(s1)):\n            raise ValueError(\"mask has incorrect shape\")\n\n        # vectors are from s2 to s1\n        vecs, d_2 = pbc_shortest_vectors(avg_lattice, s2, s1, mask,\n                                         return_d2=True,\n                                         lll_frac_tol=lll_frac_tol)\n        lin = LinearAssignment(d_2)\n        s = lin.solution\n        short_vecs = vecs[np.arange(len(s)), s]\n        translation = np.average(short_vecs, axis=0)\n        f_translation = avg_lattice.get_fractional_coords(translation)\n        new_d2 = np.sum((short_vecs - translation) ** 2, axis=-1)\n\n        return new_d2 ** 0.5 * normalization, f_translation, s", "response": "Returns the set of dissimilarities between two sets of species s1 and s2."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _get_mask(self, struct1, struct2, fu, s1_supercell):\n        mask = np.zeros((len(struct2), len(struct1), fu), dtype=np.bool)\n\n        inner = []\n        for sp2, i in itertools.groupby(enumerate(struct2.species_and_occu),\n                                        key=lambda x: x[1]):\n            i = list(i)\n            inner.append((sp2, slice(i[0][0], i[-1][0]+1)))\n\n        for sp1, j in itertools.groupby(enumerate(struct1.species_and_occu),\n                                        key=lambda x: x[1]):\n            j = list(j)\n            j = slice(j[0][0], j[-1][0]+1)\n            for sp2, i in inner:\n                mask[i, j, :] = not self._comparator.are_equal(sp1, sp2)\n\n        if s1_supercell:\n            mask = mask.reshape((len(struct2), -1))\n        else:\n            # supercell is of struct2, roll fu axis back to preserve\n            # correct ordering\n            mask = np.rollaxis(mask, 2, 1)\n            mask = mask.reshape((-1, len(struct1)))\n\n        # find the best translation indices\n        i = np.argmax(np.sum(mask, axis=-1))\n        inds = np.where(np.invert(mask[i]))[0]\n        if s1_supercell:\n            # remove the symmetrically equivalent s1 indices\n            inds = inds[::fu]\n        return np.array(mask, dtype=np.int_), inds, i", "response": "Returns a mask for matching struct1 to struct2."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef fit(self, struct1, struct2):\n        struct1, struct2 = self._process_species([struct1, struct2])\n\n        if not self._subset and self._comparator.get_hash(struct1.composition) \\\n                != self._comparator.get_hash(struct2.composition):\n            return None\n\n        struct1, struct2, fu, s1_supercell = self._preprocess(struct1, struct2)\n        match = self._match(struct1, struct2, fu, s1_supercell,\n                            break_on_match=True)\n\n        if match is None:\n            return False\n        else:\n            return match[0] <= self.stol", "response": "Fit two structures.\n\n        Args:\n            struct1 (Structure): 1st structure\n            struct2 (Structure): 2nd structure\n\n        Returns:\n            True or False."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_rms_dist(self, struct1, struct2):\n        struct1, struct2 = self._process_species([struct1, struct2])\n        struct1, struct2, fu, s1_supercell = self._preprocess(struct1, struct2)\n        match = self._match(struct1, struct2, fu, s1_supercell, use_rms=True,\n                            break_on_match=False)\n\n        if match is None:\n            return None\n        else:\n            return match[0], max(match[1])", "response": "Calculates the RMS displacement between two structures."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _preprocess(self, struct1, struct2, niggli=True):\n        struct1 = struct1.copy()\n        struct2 = struct2.copy()\n\n        if niggli:\n            struct1 = struct1.get_reduced_structure(reduction_algo=\"niggli\")\n            struct2 = struct2.get_reduced_structure(reduction_algo=\"niggli\")\n\n        # primitive cell transformation\n        if self._primitive_cell:\n            struct1 = struct1.get_primitive_structure()\n            struct2 = struct2.get_primitive_structure()\n\n        if self._supercell:\n            fu, s1_supercell = self._get_supercell_size(struct1, struct2)\n        else:\n            fu, s1_supercell = 1, True\n        mult = fu if s1_supercell else 1/fu\n\n        # rescale lattice to same volume\n        if self._scale:\n            ratio = (struct2.volume / (struct1.volume * mult)) ** (1 / 6)\n            nl1 = Lattice(struct1.lattice.matrix * ratio)\n            struct1.lattice = nl1\n            nl2 = Lattice(struct2.lattice.matrix / ratio)\n            struct2.lattice = nl2\n\n        return struct1, struct2, fu, s1_supercell", "response": "Preprocess the structure1 and structure2 for the new structure."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nmatching one struct onto the other.", "response": "def _match(self, struct1, struct2, fu, s1_supercell=True, use_rms=False,\n               break_on_match=False):\n        \"\"\"\n        Matches one struct onto the other\n        \"\"\"\n        ratio = fu if s1_supercell else 1/fu\n        if len(struct1) * ratio >= len(struct2):\n            return self._strict_match(\n                struct1, struct2, fu, s1_supercell=s1_supercell,\n                break_on_match=break_on_match, use_rms=use_rms)\n        else:\n            return self._strict_match(\n                struct2, struct1, fu, s1_supercell=(not s1_supercell),\n                break_on_match=break_on_match, use_rms=use_rms)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the best match for the structure1 and structure2.", "response": "def _strict_match(self, struct1, struct2, fu, s1_supercell=True,\n                      use_rms=False, break_on_match=False):\n        \"\"\"\n        Matches struct2 onto struct1 (which should contain all sites in\n        struct2).\n\n        Args:\n            struct1, struct2 (Structure): structures to be matched\n            fu (int): size of supercell to create\n            s1_supercell (bool): whether to create the supercell of\n                struct1 (vs struct2)\n            use_rms (bool): whether to minimize the rms of the matching\n            break_on_match (bool): whether to stop search at first\n                valid match\n        \"\"\"\n        if fu < 1:\n            raise ValueError(\"fu cannot be less than 1\")\n\n        mask, s1_t_inds, s2_t_ind = self._get_mask(struct1, struct2,\n                                                   fu, s1_supercell)\n\n        if mask.shape[0] > mask.shape[1]:\n            raise ValueError('after supercell creation, struct1 must '\n                             'have more sites than struct2')\n\n        # check that a valid mapping exists\n        if (not self._subset) and mask.shape[1] != mask.shape[0]:\n            return None\n\n        if LinearAssignment(mask).min_cost > 0:\n            return None\n\n        best_match = None\n        # loop over all lattices\n        for s1fc, s2fc, avg_l, sc_m in \\\n                self._get_supercells(struct1, struct2, fu, s1_supercell):\n            # compute fractional tolerance\n            normalization = (len(s1fc) / avg_l.volume) ** (1/3)\n            inv_abc = np.array(avg_l.reciprocal_lattice.abc)\n            frac_tol = inv_abc * self.stol / (np.pi * normalization)\n            # loop over all translations\n            for s1i in s1_t_inds:\n                t = s1fc[s1i] - s2fc[s2_t_ind]\n                t_s2fc = s2fc + t\n                if self._cmp_fstruct(s1fc, t_s2fc, frac_tol, mask):\n                    inv_lll_abc = np.array(avg_l.get_lll_reduced_lattice().reciprocal_lattice.abc)\n                    lll_frac_tol = inv_lll_abc * self.stol / (np.pi * normalization)\n                    dist, t_adj, mapping = self._cart_dists(\n                        s1fc, t_s2fc, avg_l, mask, normalization, lll_frac_tol)\n                    if use_rms:\n                        val = np.linalg.norm(dist) / len(dist) ** 0.5\n                    else:\n                        val = max(dist)\n                    if best_match is None or val < best_match[0]:\n                        total_t = t + t_adj\n                        total_t -= np.round(total_t)\n                        best_match = val, dist, sc_m, total_t, mapping\n                        if (break_on_match or val < 1e-5) and val < self.stol:\n                            return best_match\n\n        if best_match and best_match[0] < self.stol:\n            return best_match"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngiving a list of structures use fit to group them by structural equality.", "response": "def group_structures(self, s_list, anonymous=False):\n        \"\"\"\n        Given a list of structures, use fit to group\n        them by structural equality.\n\n        Args:\n            s_list ([Structure]): List of structures to be grouped\n            anonymous (bool): Wheher to use anonymous mode.\n\n        Returns:\n            A list of lists of matched structures\n            Assumption: if s1 == s2 but s1 != s3, than s2 and s3 will be put\n            in different groups without comparison.\n        \"\"\"\n        if self._subset:\n            raise ValueError(\"allow_subset cannot be used with\"\n                             \" group_structures\")\n\n        original_s_list = list(s_list)\n        s_list = self._process_species(s_list)\n\n        # Use structure hash to pre-group structures\n        if anonymous:\n            c_hash = lambda c: c.anonymized_formula\n        else:\n            c_hash = self._comparator.get_hash\n        s_hash = lambda s: c_hash(s[1].composition)\n        sorted_s_list = sorted(enumerate(s_list), key=s_hash)\n        all_groups = []\n\n        # For each pre-grouped list of structures, perform actual matching.\n        for k, g in itertools.groupby(sorted_s_list, key=s_hash):\n            unmatched = list(g)\n            while len(unmatched) > 0:\n                i, refs = unmatched.pop(0)\n                matches = [i]\n                if anonymous:\n                    inds = filter(lambda i: self.fit_anonymous(refs,\n                            unmatched[i][1]), list(range(len(unmatched))))\n                else:\n                    inds = filter(lambda i: self.fit(refs, unmatched[i][1]),\n                                  list(range(len(unmatched))))\n                inds = list(inds)\n                matches.extend([unmatched[i][0] for i in inds])\n                unmatched = [unmatched[i] for i in range(len(unmatched))\n                             if i not in inds]\n                all_groups.append([original_s_list[i] for i in matches])\n\n        return all_groups"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a list of mappings and matches for the anonymous structure.", "response": "def _anonymous_match(self, struct1, struct2, fu, s1_supercell=True,\n                         use_rms=False, break_on_match=False, single_match=False):\n        \"\"\"\n        Tries all permutations of matching struct1 to struct2.\n        Args:\n            struct1, struct2 (Structure): Preprocessed input structures\n        Returns:\n            List of (mapping, match)\n        \"\"\"\n        if not isinstance(self._comparator, SpeciesComparator):\n            raise ValueError('Anonymous fitting currently requires SpeciesComparator')\n\n        # check that species lists are comparable\n        sp1 = struct1.composition.elements\n        sp2 = struct2.composition.elements\n        if len(sp1) != len(sp2):\n            return None\n\n        ratio = fu if s1_supercell else 1/fu\n        swapped = len(struct1) * ratio < len(struct2)\n\n        s1_comp = struct1.composition\n        s2_comp = struct2.composition\n        matches = []\n        for perm in itertools.permutations(sp2):\n            sp_mapping = dict(zip(sp1, perm))\n\n            # do quick check that compositions are compatible\n            mapped_comp = Composition({sp_mapping[k]: v\n                                       for k, v in s1_comp.items()})\n            if (not self._subset) and (\n                    self._comparator.get_hash(mapped_comp) !=\n                    self._comparator.get_hash(s2_comp)):\n                continue\n\n            mapped_struct = struct1.copy()\n            mapped_struct.replace_species(sp_mapping)\n            if swapped:\n                m = self._strict_match(struct2, mapped_struct, fu,\n                                       (not s1_supercell), use_rms,\n                                       break_on_match)\n            else:\n                m = self._strict_match(mapped_struct, struct2, fu, s1_supercell,\n                                       use_rms, break_on_match)\n            if m:\n                matches.append((sp_mapping, m))\n                if single_match:\n                    break\n        return matches"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_rms_anonymous(self, struct1, struct2):\n        struct1, struct2 = self._process_species([struct1, struct2])\n        struct1, struct2, fu, s1_supercell = self._preprocess(struct1, struct2)\n\n        matches = self._anonymous_match(struct1, struct2, fu, s1_supercell,\n                                        use_rms=True, break_on_match=False)\n        if matches:\n            best = sorted(matches, key=lambda x: x[1][0])[0]\n            return best[1][0], best[0]\n        else:\n            return None, None", "response": "Returns the RMS distance between two structures."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the electronegativity of the species in one structure to the species in another.", "response": "def get_best_electronegativity_anonymous_mapping(self, struct1, struct2):\n        \"\"\"\n        Performs an anonymous fitting, which allows distinct species in one\n        structure to map to another. E.g., to compare if the Li2O and Na2O\n        structures are similar. If multiple substitutions are within tolerance\n        this will return the one which minimizes the difference in\n        electronegativity between the matches species.\n\n        Args:\n            struct1 (Structure): 1st structure\n            struct2 (Structure): 2nd structure\n\n        Returns:\n            min_mapping (Dict): Mapping of struct1 species to struct2 species\n        \"\"\"\n        struct1, struct2 = self._process_species([struct1, struct2])\n        struct1, struct2, fu, s1_supercell = self._preprocess(struct1, struct2)\n\n        matches = self._anonymous_match(struct1, struct2, fu, s1_supercell,\n                                        use_rms=True, break_on_match=True)\n\n        if matches:\n            min_X_diff = np.inf\n            for m in matches:\n                X_diff = 0\n                for k, v in m[0].items():\n                    X_diff += struct1.composition[k] * (k.X - v.X) ** 2\n                if X_diff < min_X_diff:\n                    min_X_diff = X_diff\n                    best = m[0]\n            return best"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a list of species mappings that are anonymously applied to one structure.", "response": "def get_all_anonymous_mappings(self, struct1, struct2, niggli=True,\n                                   include_dist=False):\n        \"\"\"\n        Performs an anonymous fitting, which allows distinct species in one\n        structure to map to another. Returns a dictionary of species\n        substitutions that are within tolerance\n\n        Args:\n            struct1 (Structure): 1st structure\n            struct2 (Structure): 2nd structure\n            niggli (bool): Find niggli cell in preprocessing\n            include_dist (bool): Return the maximin distance with each mapping\n\n        Returns:\n            list of species mappings that map struct1 to struct2.\n        \"\"\"\n        struct1, struct2 = self._process_species([struct1, struct2])\n        struct1, struct2, fu, s1_supercell = self._preprocess(struct1, struct2,\n                                                              niggli)\n\n        matches = self._anonymous_match(struct1, struct2, fu, s1_supercell,\n                                        break_on_match=not include_dist)\n        if matches:\n            if include_dist:\n                return [(m[0], m[1][0]) for m in matches]\n            else:\n                return [m[0] for m in matches]"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef fit_anonymous(self, struct1, struct2, niggli=True):\n        struct1, struct2 = self._process_species([struct1, struct2])\n        struct1, struct2, fu, s1_supercell = self._preprocess(struct1, struct2,\n                                                              niggli)\n\n        matches = self._anonymous_match(struct1, struct2, fu, s1_supercell,\n                                        break_on_match=True, single_match=True)\n\n        if matches:\n            return True\n        else:\n            return False", "response": "Performs an anonymous fitting of the structures in one object to another object."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the matrix for transforming struct to supercell.", "response": "def get_supercell_matrix(self, supercell, struct):\n        \"\"\"\n        Returns the matrix for transforming struct to supercell. This\n        can be used for very distorted 'supercells' where the primitive cell\n        is impossible to find\n        \"\"\"\n        if self._primitive_cell:\n            raise ValueError(\"get_supercell_matrix cannot be used with the \"\n                             \"primitive cell option\")\n        struct, supercell, fu, s1_supercell = self._preprocess(struct,\n                                                               supercell, False)\n\n        if not s1_supercell:\n            raise ValueError(\"The non-supercell must be put onto the basis\"\n                             \" of the supercell, not the other way around\")\n\n        match = self._match(struct, supercell, fu, s1_supercell, use_rms=True,\n                            break_on_match=False)\n\n        if match is None:\n            return None\n\n        return match[2]"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_transformation(self, struct1, struct2):\n        if self._primitive_cell:\n            raise ValueError(\"get_transformation cannot be used with the \"\n                             \"primitive cell option\")\n\n        struct1, struct2 = self._process_species((struct1, struct2))\n\n        s1, s2, fu, s1_supercell = self._preprocess(struct1, struct2, False)\n        ratio = fu if s1_supercell else 1/fu\n        if s1_supercell and fu > 1:\n            raise ValueError(\"Struct1 must be the supercell, \"\n                             \"not the other way around\")\n\n        if len(s1) * ratio >= len(s2):\n            # s1 is superset\n            match = self._strict_match(s1, s2, fu=fu, s1_supercell=False,\n                                       use_rms=True, break_on_match=False)\n            if match is None:\n                return None\n            # invert the mapping, since it needs to be from s1 to s2\n            mapping = [list(match[4]).index(i) if i in match[4] else None\n                       for i in range(len(s1))]\n            return match[2], match[3], mapping\n        else:\n            # s2 is superset\n            match = self._strict_match(s2, s1, fu=fu, s1_supercell=True,\n                                       use_rms=True, break_on_match=False)\n            if match is None:\n                return None\n            # add sites not included in the mapping\n            not_included = list(range(len(s2) * fu))\n            for i in match[4]:\n                not_included.remove(i)\n            mapping = list(match[4]) + not_included\n            return match[2], -match[3], mapping", "response": "Returns the supercell transformation fractional translation vector and a mapping to transform struct1 to be similar to struct2."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a structure object similar to struct1 but with the same structure as struct2.", "response": "def get_s2_like_s1(self, struct1, struct2, include_ignored_species=True):\n        \"\"\"\n        Performs transformations on struct2 to put it in a basis similar to\n        struct1 (without changing any of the inter-site distances)\n\n        Args:\n            struct1 (Structure): Reference structure\n            struct2 (Structure): Structure to transform.\n            include_ignored_species (bool): Defaults to True,\n                the ignored_species is also transformed to the struct1\n                lattice orientation, though obviously there is no direct\n                matching to existing sites.\n\n        Returns:\n            A structure object similar to struct1, obtained by making a\n            supercell, sorting, and translating struct2.\n        \"\"\"\n        s1, s2 = self._process_species([struct1, struct2])\n        trans = self.get_transformation(s1, s2)\n        if trans is None:\n            return None\n        sc, t, mapping = trans\n        sites = [site for site in s2]\n        # Append the ignored sites at the end.\n        sites.extend([site for site in struct2 if site not in s2])\n        temp = Structure.from_sites(sites)\n\n        temp.make_supercell(sc)\n        temp.translate_sites(list(range(len(temp))), t)\n        # translate sites to correct unit cell\n        for i, j in enumerate(mapping[:len(s1)]):\n            if j is not None:\n                vec = np.round(struct1[i].frac_coords - temp[j].frac_coords)\n                temp.translate_sites(j, vec, to_unit_cell=False)\n\n        sites = [temp.sites[i] for i in mapping if i is not None]\n\n        if include_ignored_species:\n            start = int(round(len(temp) / len(struct2) * len(s2)))\n            sites.extend(temp.sites[start:])\n\n        return Structure.from_sites(sites)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncalculating the mapping from superset to subset.", "response": "def get_mapping(self, superset, subset):\n        \"\"\"\n        Calculate the mapping from superset to subset.\n\n        Args:\n            superset (Structure): Structure containing at least the sites in\n                subset (within the structure matching tolerance)\n            subset (Structure): Structure containing some of the sites in\n                superset (within the structure matching tolerance)\n\n        Returns:\n            numpy array such that superset.sites[mapping] is within matching\n            tolerance of subset.sites or None if no such mapping is possible\n        \"\"\"\n        if self._supercell:\n            raise ValueError(\"cannot compute mapping to supercell\")\n        if self._primitive_cell:\n            raise ValueError(\"cannot compute mapping with primitive cell \"\n                             \"option\")\n        if len(subset) > len(superset):\n            raise ValueError(\"subset is larger than superset\")\n\n        superset, subset, _, _ = self._preprocess(superset, subset, True)\n        match = self._strict_match(superset, subset, 1, break_on_match=False)\n\n        if match is None or match[0] > self.stol:\n            return None\n\n        return match[4]"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncompares two defects and return True if they are identical.", "response": "def are_equal(self, d1, d2):\n        \"\"\"\n        Args:\n            d1: First defect. A pymatgen Defect object.\n            d2: Second defect. A pymatgen Defect object.\n\n        Returns:\n            True if defects are identical in type and sublattice.\n        \"\"\"\n        possible_defect_types = (Defect, Vacancy, Substitution, Interstitial)\n\n        if not isinstance(d1, possible_defect_types) or \\\n            not isinstance(d2, possible_defect_types):\n            raise ValueError(\"Cannot use PointDefectComparator to\" + \\\n                             \" compare non-defect objects...\")\n\n        if not isinstance(d1, d2.__class__):\n            return False\n        elif d1.site.specie != d2.site.specie:\n            return False\n        elif self.check_charge and (d1.charge != d2.charge):\n            return False\n\n        sm = StructureMatcher( ltol=0.01,\n                               primitive_cell=self.check_primitive_cell,\n                               scale=self.check_lattice_scale)\n\n        if not sm.fit(d1.bulk_structure, d2.bulk_structure):\n            return False\n\n        d1 = d1.copy()\n        d2 = d2.copy()\n        if self.check_primitive_cell or self.check_lattice_scale:\n            # if allowing for base structure volume or supercell modifications,\n            # then need to preprocess defect objects to allow for matching\n            d1_mod_bulk_structure, d2_mod_bulk_structure, _, _ = sm._preprocess(\n                d1.bulk_structure, d2.bulk_structure)\n            d1_defect_site = PeriodicSite(d1.site.specie, d1.site.coords,\n                                          d1_mod_bulk_structure.lattice,\n                                          to_unit_cell=True,\n                                          coords_are_cartesian=True)\n            d2_defect_site = PeriodicSite( d2.site.specie, d2.site.coords,\n                                           d2_mod_bulk_structure.lattice,\n                                           to_unit_cell=True,\n                                           coords_are_cartesian=True)\n\n            d1._structure = d1_mod_bulk_structure\n            d2._structure = d2_mod_bulk_structure\n            d1._defect_site = d1_defect_site\n            d2._defect_site = d2_defect_site\n\n        return sm.fit(d1.generate_defect_structure(),\n                      d2.generate_defect_structure())"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef from_composition_and_pd(comp, pd, working_ion_symbol=\"Li\"):\n        working_ion = Element(working_ion_symbol)\n        entry = None\n        working_ion_entry = None\n        for e in pd.stable_entries:\n            if e.composition.reduced_formula == comp.reduced_formula:\n                entry = e\n            elif e.is_element and \\\n                    e.composition.reduced_formula == working_ion_symbol:\n                working_ion_entry = e\n\n        if not entry:\n            raise ValueError(\"Not stable compound found at composition {}.\"\n                             .format(comp))\n\n        profile = pd.get_element_profile(working_ion, comp)\n        # Need to reverse because voltage goes form most charged to most\n        # discharged.\n        profile.reverse()\n        if len(profile) < 2:\n            return None\n        working_ion_entry = working_ion_entry\n        working_ion = working_ion_entry.composition.elements[0].symbol\n        normalization_els = {}\n        for el, amt in comp.items():\n            if el != Element(working_ion):\n                normalization_els[el] = amt\n        vpairs = [ConversionVoltagePair.from_steps(profile[i], profile[i + 1],\n                                                   normalization_els)\n                  for i in range(len(profile) - 1)]\n        return ConversionElectrode(vpairs, working_ion_entry, comp)", "response": "Convenience constructor to make a ConversionElectrode from a composition and a PhaseDiagram."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_sub_electrodes(self, adjacent_only=True):\n\n        if adjacent_only:\n            return [self.__class__(self._vpairs[i:i + 1],\n                                   self._working_ion_entry, self._composition)\n                    for i in range(len(self._vpairs))]\n        sub_electrodes = []\n        for i in range(len(self._vpairs)):\n            for j in range(i, len(self._vpairs)):\n                sub_electrodes.append(self.__class__(self._vpairs[i:j + 1],\n                                                     self._working_ion_entry,\n                                                     self._composition))\n        return sub_electrodes", "response": "Returns a list of ConversionElectrodes that are subelectrodes of this one."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef is_super_electrode(self, conversion_electrode):\n        for pair1 in conversion_electrode:\n            rxn1 = pair1.rxn\n            all_formulas1 = set([rxn1.all_comp[i].reduced_formula\n                                 for i in range(len(rxn1.all_comp))\n                                 if abs(rxn1.coeffs[i]) > 1e-5])\n            for pair2 in self:\n                rxn2 = pair2.rxn\n                all_formulas2 = set([rxn2.all_comp[i].reduced_formula\n                                     for i in range(len(rxn2.all_comp))\n                                     if abs(rxn2.coeffs[i]) > 1e-5])\n                if all_formulas1 == all_formulas2:\n                    break\n            else:\n                return False\n        return True", "response": "Checks if a particular conversion electrode is a super electrode of the current one."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_summary_dict(self, print_subelectrodes=True):\n\n        d = {}\n        framework_comp = Composition({k: v\n                                      for k, v in self._composition.items()\n                                      if k.symbol != self.working_ion.symbol})\n\n        d[\"framework\"] = framework_comp.to_data_dict\n        d[\"framework_pretty\"] = framework_comp.reduced_formula\n        d[\"average_voltage\"] = self.get_average_voltage()\n        d[\"max_voltage\"] = self.max_voltage\n        d[\"min_voltage\"] = self.min_voltage\n        d[\"max_delta_volume\"] = self.max_delta_volume\n        d[\"max_instability\"] = 0\n        d[\"max_voltage_step\"] = self.max_voltage_step\n        d[\"nsteps\"] = self.num_steps\n        d[\"capacity_grav\"] = self.get_capacity_grav()\n        d[\"capacity_vol\"] = self.get_capacity_vol()\n        d[\"energy_grav\"] = self.get_specific_energy()\n        d[\"energy_vol\"] = self.get_energy_density()\n        d[\"working_ion\"] = self.working_ion.symbol\n        d[\"reactions\"] = []\n        d[\"reactant_compositions\"] = []\n        comps = []\n        frac = []\n        for pair in self._vpairs:\n            rxn = pair.rxn\n            frac.append(pair.frac_charge)\n            frac.append(pair.frac_discharge)\n            d[\"reactions\"].append(str(rxn))\n            for i in range(len(rxn.coeffs)):\n                if abs(rxn.coeffs[i]) > 1e-5 and rxn.all_comp[i] not in comps:\n                    comps.append(rxn.all_comp[i])\n                if abs(rxn.coeffs[i]) > 1e-5 and \\\n                        rxn.all_comp[i].reduced_formula != d[\"working_ion\"]:\n                    reduced_comp = rxn.all_comp[i].reduced_composition\n                    comp_dict = reduced_comp.as_dict()\n                    d[\"reactant_compositions\"].append(comp_dict)\n        d[\"fracA_charge\"] = min(frac)\n        d[\"fracA_discharge\"] = max(frac)\n        d[\"nsteps\"] = self.num_steps\n        if print_subelectrodes:\n            f_dict = lambda c: c.get_summary_dict(print_subelectrodes=False)\n            d[\"adj_pairs\"] = map(f_dict,\n                                 self.get_sub_electrodes(adjacent_only=True))\n            d[\"all_pairs\"] = map(f_dict,\n                                 self.get_sub_electrodes(adjacent_only=False))\n        return d", "response": "Returns a dictionary of all the electrodes properties in the format that can be used to generate the summary of this electrode."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef from_steps(step1, step2, normalization_els):\n        working_ion_entry = step1[\"element_reference\"]\n        working_ion = working_ion_entry.composition.elements[0].symbol\n        working_ion_valence = max(Element(working_ion).oxidation_states)\n        voltage = (-step1[\"chempot\"] + working_ion_entry.energy_per_atom)/working_ion_valence\n        mAh = (step2[\"evolution\"] - step1[\"evolution\"]) \\\n            * Charge(1, \"e\").to(\"C\") * Time(1, \"s\").to(\"h\") * N_A * 1000*working_ion_valence\n        licomp = Composition(working_ion)\n        prev_rxn = step1[\"reaction\"]\n        reactants = {comp: abs(prev_rxn.get_coeff(comp))\n                     for comp in prev_rxn.products if comp != licomp}\n\n        curr_rxn = step2[\"reaction\"]\n        products = {comp: abs(curr_rxn.get_coeff(comp))\n                    for comp in curr_rxn.products if comp != licomp}\n\n        reactants[licomp] = (step2[\"evolution\"] - step1[\"evolution\"])\n\n        rxn = BalancedReaction(reactants, products)\n\n        for el, amt in normalization_els.items():\n            if rxn.get_el_amount(el) > 1e-6:\n                rxn.normalize_to_element(el, amt)\n                break\n\n        prev_mass_dischg = sum([prev_rxn.all_comp[i].weight\n                                * abs(prev_rxn.coeffs[i])\n                                for i in range(len(prev_rxn.all_comp))]) / 2\n        vol_charge = sum([abs(prev_rxn.get_coeff(e.composition))\n                          * e.structure.volume\n                          for e in step1[\"entries\"]\n                          if e.composition.reduced_formula != working_ion])\n        mass_discharge = sum([curr_rxn.all_comp[i].weight\n                              * abs(curr_rxn.coeffs[i])\n                              for i in range(len(curr_rxn.all_comp))]) / 2\n        mass_charge = prev_mass_dischg\n        mass_discharge = mass_discharge\n        vol_discharge = sum([abs(curr_rxn.get_coeff(e.composition))\n                             * e.structure.volume\n                             for e in step2[\"entries\"]\n                             if e.composition.reduced_formula != working_ion])\n\n        totalcomp = Composition({})\n        for comp in prev_rxn.products:\n            if comp.reduced_formula != working_ion:\n                totalcomp += comp * abs(prev_rxn.get_coeff(comp))\n        frac_charge = totalcomp.get_atomic_fraction(Element(working_ion))\n\n        totalcomp = Composition({})\n        for comp in curr_rxn.products:\n            if comp.reduced_formula != working_ion:\n                totalcomp += comp * abs(curr_rxn.get_coeff(comp))\n        frac_discharge = totalcomp.get_atomic_fraction(Element(working_ion))\n\n        rxn = rxn\n        entries_charge = step2[\"entries\"]\n        entries_discharge = step1[\"entries\"]\n\n        return ConversionVoltagePair(rxn, voltage, mAh, vol_charge,\n                                     vol_discharge, mass_charge,\n                                     mass_discharge,\n                                     frac_charge, frac_discharge,\n                                     entries_charge, entries_discharge,\n                                     working_ion_entry)", "response": "Creates a ConversionVoltagePair from two steps in the element profile."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate an Xr object from a string representation of an ISO - 8601 file.", "response": "def from_string(string, use_cores=True, thresh=1.e-4):\n        \"\"\"\n        Creates an Xr object from a string representation.\n\n        Args:\n            string (str): string representation of an Xr object.\n            use_cores (bool): use core positions and discard shell\n                    positions if set to True (default).  Otherwise,\n                    use shell positions and discard core positions.\n            thresh (float): relative threshold for consistency check\n                    between cell parameters (lengths and angles) from\n                    header information and cell vectors, respectively.\n\n        Returns:\n            xr (Xr): Xr object corresponding to the input\n                    string representation.\n        \"\"\"\n        lines = string.split(\"\\n\")\n        toks = lines[0].split()\n        lengths = [float(toks[i]) for i in range(1, len(toks))]\n        toks = lines[1].split()\n        angles = [float(i) for i in toks[0:3]]\n        toks = lines[2].split()\n        nsites = int(toks[0])\n        mat = np.zeros((3,3), dtype=float)\n        for i in range(3):\n            toks = lines[4+nsites+i].split()\n            toks2 = lines[4+nsites+i+3].split()\n            for j, item in enumerate(toks):\n                if item != toks2[j]:\n                    raise RuntimeError(\"expected both matrices\"\n                            \" to be the same in xr file\")\n            mat[i] = np.array([float(w) for w in toks])\n        lat = Lattice(mat)\n        if fabs(lat.a-lengths[0])/fabs(lat.a) > thresh or \\\n                fabs(lat.b-lengths[1])/fabs(lat.b) > thresh or \\\n                fabs(lat.c-lengths[2])/fabs(lat.c) > thresh or \\\n                fabs(lat.alpha-angles[0])/fabs(lat.alpha) > thresh or \\\n                fabs(lat.beta-angles[1])/fabs(lat.beta) > thresh or \\\n                fabs(lat.gamma-angles[2])/fabs(lat.gamma) > thresh:\n            raise RuntimeError(\"cell parameters in header (\"+str(lengths)+\\\n                    \", \"+str(angles)+\") are not consistent with Cartesian\"+\\\n                    \" lattice vectors (\"+str(lat.abc)+\", \"+\\\n                    str(lat.angles)+\")\")\n        # Ignore line w/ index 3.\n        sp = []\n        coords = []\n        for j in range(nsites):\n            m = re.match(r\"\\d+\\s+(\\w+)\\s+([0-9\\-\\.]+)\\s+([0-9\\-\\.]+)\\s+\" +\n                         r\"([0-9\\-\\.]+)\", lines[4+j].strip())\n            if m:\n                tmp_sp = m.group(1)\n                if use_cores and tmp_sp[len(tmp_sp)-2:] == \"_s\":\n                    continue\n                if not use_cores and tmp_sp[len(tmp_sp)-2:] == \"_c\":\n                    continue\n                if tmp_sp[len(tmp_sp)-2] == \"_\":\n                    sp.append(tmp_sp[0:len(tmp_sp)-2])\n                else:\n                    sp.append(tmp_sp)\n                coords.append([float(m.group(i)) for i in range(2, 5)])\n        return Xr(Structure(lat, sp, coords, coords_are_cartesian=True))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef from_file(filename, use_cores=True, thresh=1.e-4):\n        with zopen(filename, \"rt\") as f:\n            return Xr.from_string(\n                    f.read(), use_cores=use_cores,\n                    thresh=thresh)", "response": "Reads an xr - formatted file and returns an Xr object corresponding to the input\n            file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nframing a signal into overlapping frames.", "response": "def framesig(sig, frame_len, frame_step, winfunc=lambda x: numpy.ones((x,)), stride_trick=True):\n    \"\"\"Frame a signal into overlapping frames.\n\n    :param sig: the audio signal to frame.\n    :param frame_len: length of each frame measured in samples.\n    :param frame_step: number of samples after the start of the previous frame that the next frame should begin.\n    :param winfunc: the analysis window to apply to each frame. By default no window is applied.\n    :param stride_trick: use stride trick to compute the rolling window and window multiplication faster\n    :returns: an array of frames. Size is NUMFRAMES by frame_len.\n    \"\"\"\n    slen = len(sig)\n    frame_len = int(round_half_up(frame_len))\n    frame_step = int(round_half_up(frame_step))\n    if slen <= frame_len:\n        numframes = 1\n    else:\n        numframes = 1 + int(math.ceil((1.0 * slen - frame_len) / frame_step))\n\n    padlen = int((numframes - 1) * frame_step + frame_len)\n\n    zeros = numpy.zeros((padlen - slen,))\n    padsignal = numpy.concatenate((sig, zeros))\n    if stride_trick:\n        win = winfunc(frame_len)\n        frames = rolling_window(padsignal, window=frame_len, step=frame_step)\n    else:\n        indices = numpy.tile(numpy.arange(0, frame_len), (numframes, 1)) + numpy.tile(\n            numpy.arange(0, numframes * frame_step, frame_step), (frame_len, 1)).T\n        indices = numpy.array(indices, dtype=numpy.int32)\n        frames = padsignal[indices]\n        win = numpy.tile(winfunc(frame_len), (numframes, 1))\n\n    return frames * win"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndoes overlap-add procedure to undo the action of framesig. :param frames: the array of frames. :param siglen: the length of the desired signal, use 0 if unknown. Output will be truncated to siglen samples. :param frame_len: length of each frame measured in samples. :param frame_step: number of samples after the start of the previous frame that the next frame should begin. :param winfunc: the analysis window to apply to each frame. By default no window is applied. :returns: a 1-D signal.", "response": "def deframesig(frames, siglen, frame_len, frame_step, winfunc=lambda x: numpy.ones((x,))):\n    \"\"\"Does overlap-add procedure to undo the action of framesig.\n\n    :param frames: the array of frames.\n    :param siglen: the length of the desired signal, use 0 if unknown. Output will be truncated to siglen samples.\n    :param frame_len: length of each frame measured in samples.\n    :param frame_step: number of samples after the start of the previous frame that the next frame should begin.\n    :param winfunc: the analysis window to apply to each frame. By default no window is applied.\n    :returns: a 1-D signal.\n    \"\"\"\n    frame_len = round_half_up(frame_len)\n    frame_step = round_half_up(frame_step)\n    numframes = numpy.shape(frames)[0]\n    assert numpy.shape(frames)[1] == frame_len, '\"frames\" matrix is wrong size, 2nd dim is not equal to frame_len'\n\n    indices = numpy.tile(numpy.arange(0, frame_len), (numframes, 1)) + numpy.tile(\n        numpy.arange(0, numframes * frame_step, frame_step), (frame_len, 1)).T\n    indices = numpy.array(indices, dtype=numpy.int32)\n    padlen = (numframes - 1) * frame_step + frame_len\n\n    if siglen <= 0: siglen = padlen\n\n    rec_signal = numpy.zeros((padlen,))\n    window_correction = numpy.zeros((padlen,))\n    win = winfunc(frame_len)\n\n    for i in range(0, numframes):\n        window_correction[indices[i, :]] = window_correction[\n                                               indices[i, :]] + win + 1e-15  # add a little bit so it is never zero\n        rec_signal[indices[i, :]] = rec_signal[indices[i, :]] + frames[i, :]\n\n    rec_signal = rec_signal / window_correction\n    return rec_signal[0:siglen]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef magspec(frames, NFFT):\n    if numpy.shape(frames)[1] > NFFT:\n        logging.warn(\n            'frame length (%d) is greater than FFT size (%d), frame will be truncated. Increase NFFT to avoid.',\n            numpy.shape(frames)[1], NFFT)\n    complex_spec = numpy.fft.rfft(frames, NFFT)\n    return numpy.absolute(complex_spec)", "response": "Compute the magnitude spectrum of each frame in frames."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncomputes the log power spectrum of each frame in frames.", "response": "def logpowspec(frames, NFFT, norm=1):\n    \"\"\"Compute the log power spectrum of each frame in frames. If frames is an NxD matrix, output will be Nx(NFFT/2+1).\n\n    :param frames: the array of frames. Each row is a frame.\n    :param NFFT: the FFT length to use. If NFFT > frame_len, the frames are zero-padded.\n    :param norm: If norm=1, the log power spectrum is normalised so that the max value (across all frames) is 0.\n    :returns: If frames is an NxD matrix, output will be Nx(NFFT/2+1). Each row will be the log power spectrum of the corresponding frame.\n    \"\"\"\n    ps = powspec(frames, NFFT);\n    ps[ps <= 1e-30] = 1e-30\n    lps = 10 * numpy.log10(ps)\n    if norm:\n        return lps - numpy.max(lps)\n    else:\n        return lps"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncalculate the FFT size of the current window.", "response": "def calculate_nfft(samplerate, winlen):\n    \"\"\"Calculates the FFT size as a power of two greater than or equal to\n    the number of samples in a single window length.\n    \n    Having an FFT less than the window length loses precision by dropping\n    many of the samples; a longer FFT than the window allows zero-padding\n    of the FFT buffer which is neutral in terms of frequency domain conversion.\n\n    :param samplerate: The sample rate of the signal we are working with, in Hz.\n    :param winlen: The length of the analysis window in seconds.\n    \"\"\"\n    window_length_samples = winlen * samplerate\n    nfft = 1\n    while nfft < window_length_samples:\n        nfft *= 2\n    return nfft"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncompute MFCC features from an audio signal.", "response": "def mfcc(signal,samplerate=16000,winlen=0.025,winstep=0.01,numcep=13,\n         nfilt=26,nfft=None,lowfreq=0,highfreq=None,preemph=0.97,ceplifter=22,appendEnergy=True,\n         winfunc=lambda x:numpy.ones((x,))):\n    \"\"\"Compute MFCC features from an audio signal.\n\n    :param signal: the audio signal from which to compute features. Should be an N*1 array\n    :param samplerate: the sample rate of the signal we are working with, in Hz.\n    :param winlen: the length of the analysis window in seconds. Default is 0.025s (25 milliseconds)\n    :param winstep: the step between successive windows in seconds. Default is 0.01s (10 milliseconds)\n    :param numcep: the number of cepstrum to return, default 13\n    :param nfilt: the number of filters in the filterbank, default 26.\n    :param nfft: the FFT size. Default is None, which uses the calculate_nfft function to choose the smallest size that does not drop sample data.\n    :param lowfreq: lowest band edge of mel filters. In Hz, default is 0.\n    :param highfreq: highest band edge of mel filters. In Hz, default is samplerate/2\n    :param preemph: apply preemphasis filter with preemph as coefficient. 0 is no filter. Default is 0.97.\n    :param ceplifter: apply a lifter to final cepstral coefficients. 0 is no lifter. Default is 22.\n    :param appendEnergy: if this is true, the zeroth cepstral coefficient is replaced with the log of the total frame energy.\n    :param winfunc: the analysis window to apply to each frame. By default no window is applied. You can use numpy window functions here e.g. winfunc=numpy.hamming\n    :returns: A numpy array of size (NUMFRAMES by numcep) containing features. Each row holds 1 feature vector.\n    \"\"\"\n    nfft = nfft or calculate_nfft(samplerate, winlen)\n    feat,energy = fbank(signal,samplerate,winlen,winstep,nfilt,nfft,lowfreq,highfreq,preemph,winfunc)\n    feat = numpy.log(feat)\n    feat = dct(feat, type=2, axis=1, norm='ortho')[:,:numcep]\n    feat = lifter(feat,ceplifter)\n    if appendEnergy: feat[:,0] = numpy.log(energy) # replace first cepstral coefficient with log of frame energy\n    return feat"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncomputes Mel - filterbank energy features from an audio signal.", "response": "def fbank(signal,samplerate=16000,winlen=0.025,winstep=0.01,\n          nfilt=26,nfft=512,lowfreq=0,highfreq=None,preemph=0.97,\n          winfunc=lambda x:numpy.ones((x,))):\n    \"\"\"Compute Mel-filterbank energy features from an audio signal.\n\n    :param signal: the audio signal from which to compute features. Should be an N*1 array\n    :param samplerate: the sample rate of the signal we are working with, in Hz.\n    :param winlen: the length of the analysis window in seconds. Default is 0.025s (25 milliseconds)\n    :param winstep: the step between successive windows in seconds. Default is 0.01s (10 milliseconds)\n    :param nfilt: the number of filters in the filterbank, default 26.\n    :param nfft: the FFT size. Default is 512.\n    :param lowfreq: lowest band edge of mel filters. In Hz, default is 0.\n    :param highfreq: highest band edge of mel filters. In Hz, default is samplerate/2\n    :param preemph: apply preemphasis filter with preemph as coefficient. 0 is no filter. Default is 0.97.\n    :param winfunc: the analysis window to apply to each frame. By default no window is applied. You can use numpy window functions here e.g. winfunc=numpy.hamming\n    :returns: 2 values. The first is a numpy array of size (NUMFRAMES by nfilt) containing features. Each row holds 1 feature vector. The\n        second return value is the energy in each frame (total energy, unwindowed)\n    \"\"\"\n    highfreq= highfreq or samplerate/2\n    signal = sigproc.preemphasis(signal,preemph)\n    frames = sigproc.framesig(signal, winlen*samplerate, winstep*samplerate, winfunc)\n    pspec = sigproc.powspec(frames,nfft)\n    energy = numpy.sum(pspec,1) # this stores the total energy in each frame\n    energy = numpy.where(energy == 0,numpy.finfo(float).eps,energy) # if energy is zero, we get problems with log\n\n    fb = get_filterbanks(nfilt,nfft,samplerate,lowfreq,highfreq)\n    feat = numpy.dot(pspec,fb.T) # compute the filterbank energies\n    feat = numpy.where(feat == 0,numpy.finfo(float).eps,feat) # if feat is zero, we get problems with log\n\n    return feat,energy"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncomputing log Mel - filterbank energy features from an audio signal.", "response": "def logfbank(signal,samplerate=16000,winlen=0.025,winstep=0.01,\n             nfilt=26,nfft=512,lowfreq=0,highfreq=None,preemph=0.97,\n             winfunc=lambda x:numpy.ones((x,))):\n    \"\"\"Compute log Mel-filterbank energy features from an audio signal.\n\n    :param signal: the audio signal from which to compute features. Should be an N*1 array\n    :param samplerate: the sample rate of the signal we are working with, in Hz.\n    :param winlen: the length of the analysis window in seconds. Default is 0.025s (25 milliseconds)\n    :param winstep: the step between successive windows in seconds. Default is 0.01s (10 milliseconds)\n    :param nfilt: the number of filters in the filterbank, default 26.\n    :param nfft: the FFT size. Default is 512.\n    :param lowfreq: lowest band edge of mel filters. In Hz, default is 0.\n    :param highfreq: highest band edge of mel filters. In Hz, default is samplerate/2\n    :param preemph: apply preemphasis filter with preemph as coefficient. 0 is no filter. Default is 0.97.\n    :param winfunc: the analysis window to apply to each frame. By default no window is applied. You can use numpy window functions here e.g. winfunc=numpy.hamming\n    :returns: A numpy array of size (NUMFRAMES by nfilt) containing features. Each row holds 1 feature vector.\n    \"\"\"\n    feat,energy = fbank(signal,samplerate,winlen,winstep,nfilt,nfft,lowfreq,highfreq,preemph,winfunc)\n    return numpy.log(feat)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncomputes Spectral Subband Centroid features from an audio signal.", "response": "def ssc(signal,samplerate=16000,winlen=0.025,winstep=0.01,\n        nfilt=26,nfft=512,lowfreq=0,highfreq=None,preemph=0.97,\n        winfunc=lambda x:numpy.ones((x,))):\n    \"\"\"Compute Spectral Subband Centroid features from an audio signal.\n\n    :param signal: the audio signal from which to compute features. Should be an N*1 array\n    :param samplerate: the sample rate of the signal we are working with, in Hz.\n    :param winlen: the length of the analysis window in seconds. Default is 0.025s (25 milliseconds)\n    :param winstep: the step between successive windows in seconds. Default is 0.01s (10 milliseconds)\n    :param nfilt: the number of filters in the filterbank, default 26.\n    :param nfft: the FFT size. Default is 512.\n    :param lowfreq: lowest band edge of mel filters. In Hz, default is 0.\n    :param highfreq: highest band edge of mel filters. In Hz, default is samplerate/2\n    :param preemph: apply preemphasis filter with preemph as coefficient. 0 is no filter. Default is 0.97.\n    :param winfunc: the analysis window to apply to each frame. By default no window is applied. You can use numpy window functions here e.g. winfunc=numpy.hamming\n    :returns: A numpy array of size (NUMFRAMES by nfilt) containing features. Each row holds 1 feature vector.\n    \"\"\"\n    highfreq= highfreq or samplerate/2\n    signal = sigproc.preemphasis(signal,preemph)\n    frames = sigproc.framesig(signal, winlen*samplerate, winstep*samplerate, winfunc)\n    pspec = sigproc.powspec(frames,nfft)\n    pspec = numpy.where(pspec == 0,numpy.finfo(float).eps,pspec) # if things are all zeros we get problems\n\n    fb = get_filterbanks(nfilt,nfft,samplerate,lowfreq,highfreq)\n    feat = numpy.dot(pspec,fb.T) # compute the filterbank energies\n    R = numpy.tile(numpy.linspace(1,samplerate/2,numpy.size(pspec,1)),(numpy.size(pspec,0),1))\n\n    return numpy.dot(pspec*R,fb.T) / feat"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncomputing a Mel - filterbank.", "response": "def get_filterbanks(nfilt=20,nfft=512,samplerate=16000,lowfreq=0,highfreq=None):\n    \"\"\"Compute a Mel-filterbank. The filters are stored in the rows, the columns correspond\n    to fft bins. The filters are returned as an array of size nfilt * (nfft/2 + 1)\n\n    :param nfilt: the number of filters in the filterbank, default 20.\n    :param nfft: the FFT size. Default is 512.\n    :param samplerate: the sample rate of the signal we are working with, in Hz. Affects mel spacing.\n    :param lowfreq: lowest band edge of mel filters, default 0 Hz\n    :param highfreq: highest band edge of mel filters, default samplerate/2\n    :returns: A numpy array of size nfilt * (nfft/2 + 1) containing filterbank. Each row holds 1 filter.\n    \"\"\"\n    highfreq= highfreq or samplerate/2\n    assert highfreq <= samplerate/2, \"highfreq is greater than samplerate/2\"\n\n    # compute points evenly spaced in mels\n    lowmel = hz2mel(lowfreq)\n    highmel = hz2mel(highfreq)\n    melpoints = numpy.linspace(lowmel,highmel,nfilt+2)\n    # our points are in Hz, but we use fft bins, so we have to convert\n    #  from Hz to fft bin number\n    bin = numpy.floor((nfft+1)*mel2hz(melpoints)/samplerate)\n\n    fbank = numpy.zeros([nfilt,nfft//2+1])\n    for j in range(0,nfilt):\n        for i in range(int(bin[j]), int(bin[j+1])):\n            fbank[j,i] = (i - bin[j]) / (bin[j+1]-bin[j])\n        for i in range(int(bin[j+1]), int(bin[j+2])):\n            fbank[j,i] = (bin[j+2]-i) / (bin[j+2]-bin[j+1])\n    return fbank"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef lifter(cepstra, L=22):\n    if L > 0:\n        nframes,ncoeff = numpy.shape(cepstra)\n        n = numpy.arange(ncoeff)\n        lift = 1 + (L/2.)*numpy.sin(numpy.pi*n/L)\n        return lift*cepstra\n    else:\n        # values of L <= 0, do nothing\n        return cepstra", "response": "Apply a cepstral lifter to the matrix of cepstra."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef delta(feat, N):\n    if N < 1:\n        raise ValueError('N must be an integer >= 1')\n    NUMFRAMES = len(feat)\n    denominator = 2 * sum([i**2 for i in range(1, N+1)])\n    delta_feat = numpy.empty_like(feat)\n    padded = numpy.pad(feat, ((N, N), (0, 0)), mode='edge')   # padded version of feat\n    for t in range(NUMFRAMES):\n        delta_feat[t] = numpy.dot(numpy.arange(-N, N+1), padded[t : t+2*N+1]) / denominator   # [t : t+2*N+1] == [(N+t)-N : (N+t)+N+1]\n    return delta_feat", "response": "Compute delta features from a feature vector sequence."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nopen a CAN connection using the standard DLL interface.", "response": "def open(self, configuration, flags):\n        \"\"\"\n        Opens a CAN connection using `CanalOpen()`.\n\n        :param str configuration: the configuration: \"device_id; baudrate\"\n        :param int flags: the flags to be set\n\n        :raises can.CanError: if any error occurred\n        :returns: Valid handle for CANAL API functions on success\n        \"\"\"\n        try:\n            # we need to convert this into bytes, since the underlying DLL cannot\n            # handle non-ASCII configuration strings\n            config_ascii = configuration.encode('ascii', 'ignore')\n            result = self.__m_dllBasic.CanalOpen(config_ascii, flags)\n        except Exception as ex:\n            # catch any errors thrown by this call and re-raise\n            raise can.CanError('CanalOpen() failed, configuration: \"{}\", error: {}'\n                               .format(configuration, ex))\n        else:\n            # any greater-than-zero return value indicates a success\n            # (see https://grodansparadis.gitbooks.io/the-vscp-daemon/canal_interface_specification.html)\n            # raise an error if the return code is <= 0\n            if result <= 0:\n                raise can.CanError('CanalOpen() failed, configuration: \"{}\", return code: {}'\n                                   .format(configuration, result))\n            else:\n                return result"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef read_all(self):\n        result = self._cursor.execute(\"SELECT * FROM {}\".format(self.table_name)).fetchall()\n        return (SqliteReader._assemble_message(frame) for frame in result)", "response": "Fetches all messages in the database."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a new sqlite3 database and creates a table structure.", "response": "def _create_db(self):\n        \"\"\"Creates a new databae or opens a connection to an existing one.\n\n        .. note::\n            You can't share sqlite3 connections between threads (by default)\n            hence we setup the db here. It has the upside of running async.\n        \"\"\"\n        log.debug(\"Creating sqlite database\")\n        self._conn = sqlite3.connect(self._db_filename)\n\n        # create table structure\n        self._conn.cursor().execute(\"\"\"\n        CREATE TABLE IF NOT EXISTS {}\n        (\n          ts REAL,\n          arbitration_id INTEGER,\n          extended INTEGER,\n          remote INTEGER,\n          error INTEGER,\n          dlc INTEGER,\n          data BLOB\n        )\n        \"\"\".format(self.table_name))\n        self._conn.commit()\n\n        self._insert_template = \"INSERT INTO {} VALUES (?, ?, ?, ?, ?, ?, ?)\".format(self.table_name)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef stop(self):\n        BufferedReader.stop(self)\n        self._stop_running_event.set()\n        self._writer_thread.join()\n        BaseIOHandler.stop(self)", "response": "Stops the reader an writes all remaining messages to the database."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nchecking if the message parameters are valid.", "response": "def _check(self):\n        \"\"\"Checks if the message parameters are valid.\n        Assumes that the types are already correct.\n\n        :raises ValueError: iff one or more attributes are invalid\n        \"\"\"\n\n        if self.timestamp < 0.0:\n            raise ValueError(\"the timestamp may not be negative\")\n        if isinf(self.timestamp):\n            raise ValueError(\"the timestamp may not be infinite\")\n        if isnan(self.timestamp):\n            raise ValueError(\"the timestamp may not be NaN\")\n\n        if self.is_remote_frame and self.is_error_frame:\n            raise ValueError(\"a message cannot be a remote and an error frame at the sane time\")\n\n        if self.arbitration_id < 0:\n            raise ValueError(\"arbitration IDs may not be negative\")\n\n        if self.is_extended_id:\n            if 0x20000000 <= self.arbitration_id:\n                raise ValueError(\"Extended arbitration IDs must be less than 2^29\")\n        elif 0x800 <= self.arbitration_id:\n            raise ValueError(\"Normal arbitration IDs must be less than 2^11\")\n\n        if self.dlc < 0:\n            raise ValueError(\"DLC may not be negative\")\n        if self.is_fd:\n            if 64 < self.dlc:\n                raise ValueError(\"DLC was {} but it should be <= 64 for CAN FD frames\".format(self.dlc))\n        elif 8 < self.dlc:\n            raise ValueError(\"DLC was {} but it should be <= 8 for normal CAN frames\".format(self.dlc))\n\n        if self.is_remote_frame:\n            if self.data is not None and len(self.data) != 0:\n                raise ValueError(\"remote frames may not carry any data\")\n        elif self.dlc != len(self.data):\n            raise ValueError(\"the DLC and the length of the data must match up for non remote frames\")\n\n        if not self.is_fd:\n            if self.bitrate_switch:\n                raise ValueError(\"bitrate switch is only allowed for CAN FD frames\")\n            if self.error_state_indicator:\n                raise ValueError(\"error state indicator is only allowed for CAN FD frames\")"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncomparing a given message with this one.", "response": "def equals(self, other, timestamp_delta=1.0e-6):\n        \"\"\"\n        Compares a given message with this one.\n\n        :param can.Message other: the message to compare with\n\n        :type timestamp_delta: float or int or None\n        :param timestamp_delta: the maximum difference at which two timestamps are\n                                still considered equal or None to not compare timestamps\n\n        :rtype: bool\n        :return: True iff the given message equals this one\n        \"\"\"\n        # see https://github.com/hardbyte/python-can/pull/413 for a discussion\n        # on why a delta of 1.0e-6 was chosen\n        return (\n            # check for identity first and finish fast\n            self is other or\n            # then check for equality by value\n            (\n                (\n                    timestamp_delta is None or\n                    abs(self.timestamp - other.timestamp) <= timestamp_delta\n                ) and\n                self.arbitration_id == other.arbitration_id and\n                self.is_extended_id == other.is_extended_id and\n                self.dlc == other.dlc and\n                self.data == other.data and\n                self.is_remote_frame == other.is_remote_frame and\n                self.is_error_frame == other.is_error_frame and\n                self.channel == other.channel and\n                self.is_fd == other.is_fd and\n                self.bitrate_switch == other.bitrate_switch and\n                self.error_state_indicator == other.error_state_indicator\n            )\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nmap and return a symbol from a C library.", "response": "def map_symbol(self, func_name, restype=None, argtypes=(), errcheck=None):\n        \"\"\"\n        Map and return a symbol (function) from a C library. A reference to the\n        mapped symbol is also held in the instance\n\n        :param str func_name:\n            symbol_name\n        :param ctypes.c_* restype:\n            function result type (i.e. ctypes.c_ulong...), defaults to void\n        :param tuple(ctypes.c_* ... ) argtypes:\n            argument types, defaults to no args\n        :param callable errcheck:\n            optional error checking function, see ctypes docs for _FuncPtr\n        \"\"\"\n        if (argtypes):\n            prototype = self.function_type(restype, *argtypes)\n        else:\n            prototype = self.function_type(restype)\n        try:\n            symbol = prototype((func_name, self))\n        except AttributeError:\n            raise ImportError(\"Could not map function '{}' from library {}\".format(func_name, self._name))\n\n        setattr(symbol, \"_name\", func_name)\n        log.debug('Wrapped function \"{}\", result type: {}, error_check {}'.format(func_name, type(restype), errcheck))\n\n        if (errcheck):\n            symbol.errcheck = errcheck\n\n        setattr(self, func_name, symbol)\n        return symbol"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndecoding the serial number and return the ICS device serial string.", "response": "def get_serial_number(device):\n        \"\"\"Decode (if needed) and return the ICS device serial string\n\n        :param device: ics device\n        :return: ics device serial string\n        :rtype: str\n        \"\"\"\n        a0000 = 604661760\n        if device.SerialNumber >= a0000:\n            return ics.base36enc(device.SerialNumber)\n        return str(device.SerialNumber)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndetect all configurations that this interface could have available for use in the bus constructor.", "response": "def _detect_available_configs():\n        \"\"\"Detect all configurations/channels that this interface could\n        currently connect with.\n\n        :rtype: Iterator[dict]\n        :return: an iterable of dicts, each being a configuration suitable\n                 for usage in the interface's bus constructor.\n        \"\"\"\n        if ics is None:\n            return []\n\n        try:\n            devices = ics.find_devices()\n        except Exception as e:\n            logger.debug(\"Failed to detect configs: %s\", e)\n            return []\n\n        # TODO: add the channel(s)\n        return [{\n            'interface': 'neovi',\n            'serial': NeoViBus.get_serial_number(device)\n        } for device in devices]"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nbuilding a CAN frame structure from a message.", "response": "def build_can_frame(msg):\n    \"\"\" CAN frame packing/unpacking (see 'struct can_frame' in <linux/can.h>)\n    /**\n     * struct can_frame - basic CAN frame structure\n     * @can_id:  the CAN ID of the frame and CAN_*_FLAG flags, see above.\n     * @can_dlc: the data length field of the CAN frame\n     * @data:    the CAN frame payload.\n     */\n    struct can_frame {\n        canid_t can_id;  /* 32 bit CAN_ID + EFF/RTR/ERR flags */\n        __u8    can_dlc; /* data length code: 0 .. 8 */\n        __u8    data[8] __attribute__((aligned(8)));\n    };\n\n    /**\n    * struct canfd_frame - CAN flexible data rate frame structure\n    * @can_id: CAN ID of the frame and CAN_*_FLAG flags, see canid_t definition\n    * @len:    frame payload length in byte (0 .. CANFD_MAX_DLEN)\n    * @flags:  additional flags for CAN FD\n    * @__res0: reserved / padding\n    * @__res1: reserved / padding\n    * @data:   CAN FD frame payload (up to CANFD_MAX_DLEN byte)\n    */\n    struct canfd_frame {\n        canid_t can_id;  /* 32 bit CAN_ID + EFF/RTR/ERR flags */\n        __u8    len;     /* frame payload length in byte */\n        __u8    flags;   /* additional flags for CAN FD */\n        __u8    __res0;  /* reserved / padding */\n        __u8    __res1;  /* reserved / padding */\n        __u8    data[CANFD_MAX_DLEN] __attribute__((aligned(8)));\n    };\n    \"\"\"\n    can_id = _add_flags_to_can_id(msg)\n    flags = 0\n    if msg.bitrate_switch:\n        flags |= CANFD_BRS\n    if msg.error_state_indicator:\n        flags |= CANFD_ESI\n    max_len = 64 if msg.is_fd else 8\n    data = bytes(msg.data).ljust(max_len, b'\\x00')\n    return CAN_FRAME_HEADER_STRUCT.pack(can_id, msg.dlc, flags) + data"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates a broadcast manager socket and connect to the given interface", "response": "def create_bcm_socket(channel):\n    \"\"\"create a broadcast manager socket and connect to the given interface\"\"\"\n    s = socket.socket(PF_CAN, socket.SOCK_DGRAM, CAN_BCM)\n    if HAS_NATIVE_SUPPORT:\n        s.connect((channel,))\n    else:\n        addr = get_addr(s, channel)\n        libc.connect(s.fileno(), addr, len(addr))\n    return s"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsends raw frame to a BCM socket and handle errors.", "response": "def send_bcm(bcm_socket, data):\n    \"\"\"\n    Send raw frame to a BCM socket and handle errors.\n    \"\"\"\n    try:\n        return bcm_socket.send(data)\n    except OSError as e:\n        base = \"Couldn't send CAN BCM frame. OS Error {}: {}\\n\".format(e.errno, e.strerror)\n\n        if e.errno == errno.EINVAL:\n            raise can.CanError(base + \"You are probably referring to a non-existing frame.\")\n\n        elif e.errno == errno.ENETDOWN:\n            raise can.CanError(base + \"The CAN interface appears to be down.\")\n\n        elif e.errno == errno.EBADF:\n            raise can.CanError(base + \"The CAN socket appears to be closed.\")\n\n        else:\n            raise e"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate a raw CAN socket.", "response": "def create_socket():\n    \"\"\"Creates a raw CAN socket. The socket will\n    be returned unbound to any interface.\n    \"\"\"\n    sock = socket.socket(PF_CAN, socket.SOCK_RAW, CAN_RAW)\n\n    log.info('Created a socket')\n\n    return sock"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nbinding the given socket to the specified interface.", "response": "def bind_socket(sock, channel='can0'):\n    \"\"\"\n    Binds the given socket to the given interface.\n\n    :param socket.socket sock:\n        The socket to be bound\n    :raises OSError:\n        If the specified interface isn't found.\n    \"\"\"\n    log.debug('Binding socket to channel=%s', channel)\n    if HAS_NATIVE_SUPPORT:\n        sock.bind((channel,))\n    else:\n        # For Python 2.7\n        addr = get_addr(sock, channel)\n        libc.bind(sock.fileno(), addr, len(addr))\n    log.debug('Bound socket.')"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef capture_message(sock, get_channel=False):\n    # Fetching the Arb ID, DLC and Data\n    try:\n        if get_channel:\n            if HAS_NATIVE_SUPPORT:\n                cf, addr = sock.recvfrom(CANFD_MTU)\n                channel = addr[0] if isinstance(addr, tuple) else addr\n            else:\n                data = ctypes.create_string_buffer(CANFD_MTU)\n                addr = ctypes.create_string_buffer(32)\n                addrlen = ctypes.c_int(len(addr))\n                received = libc.recvfrom(sock.fileno(), data, len(data), 0,\n                                         addr, ctypes.byref(addrlen))\n                cf = data.raw[:received]\n                # Figure out the channel name\n                family, ifindex = struct.unpack_from(\"Hi\", addr.raw)\n                assert family == AF_CAN\n                data = struct.pack(\"16xi\", ifindex)\n                res = fcntl.ioctl(sock, SIOCGIFNAME, data)\n                channel = ctypes.create_string_buffer(res).value.decode()\n        else:\n            cf = sock.recv(CANFD_MTU)\n            channel = None\n    except socket.error as exc:\n        raise can.CanError(\"Error receiving: %s\" % exc)\n\n    can_id, can_dlc, flags, data = dissect_can_frame(cf)\n    #log.debug('Received: can_id=%x, can_dlc=%x, data=%s', can_id, can_dlc, data)\n\n    # Fetching the timestamp\n    binary_structure = \"@LL\"\n    res = fcntl.ioctl(sock, SIOCGSTAMP, struct.pack(binary_structure, 0, 0))\n\n    seconds, microseconds = struct.unpack(binary_structure, res)\n    timestamp = seconds + microseconds * 1e-6\n\n    # EXT, RTR, ERR flags -> boolean attributes\n    #   /* special address description flags for the CAN_ID */\n    #   #define CAN_EFF_FLAG 0x80000000U /* EFF/SFF is set in the MSB */\n    #   #define CAN_RTR_FLAG 0x40000000U /* remote transmission request */\n    #   #define CAN_ERR_FLAG 0x20000000U /* error frame */\n    is_extended_frame_format = bool(can_id & CAN_EFF_FLAG)\n    is_remote_transmission_request = bool(can_id & CAN_RTR_FLAG)\n    is_error_frame = bool(can_id & CAN_ERR_FLAG)\n    is_fd = len(cf) == CANFD_MTU\n    bitrate_switch = bool(flags & CANFD_BRS)\n    error_state_indicator = bool(flags & CANFD_ESI)\n\n    if is_extended_frame_format:\n        #log.debug(\"CAN: Extended\")\n        # TODO does this depend on SFF or EFF?\n        arbitration_id = can_id & 0x1FFFFFFF\n    else:\n        #log.debug(\"CAN: Standard\")\n        arbitration_id = can_id & 0x000007FF\n\n    msg = Message(timestamp=timestamp,\n                  channel=channel,\n                  arbitration_id=arbitration_id,\n                  is_extended_id=is_extended_frame_format,\n                  is_remote_frame=is_remote_transmission_request,\n                  is_error_frame=is_error_frame,\n                  is_fd=is_fd,\n                  bitrate_switch=bitrate_switch,\n                  error_state_indicator=error_state_indicator,\n                  dlc=can_dlc,\n                  data=data)\n\n    #log_rx.debug('Received: %s', msg)\n\n    return msg", "response": "Captures a message from given socket."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef stop(self):\n        log.debug(\"Stopping periodic task\")\n\n        stopframe = build_bcm_tx_delete_header(self.can_id_with_flags, self.flags)\n        send_bcm(self.bcm_socket, stopframe)", "response": "Send a TX_DELETE message to cancel this task."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nupdate the contents of this message.", "response": "def modify_data(self, message):\n        \"\"\"Update the contents of this periodically sent message.\n\n        Note the Message must have the same :attr:`~can.Message.arbitration_id`\n        like the first message.\n        \"\"\"\n        assert message.arbitration_id == self.can_id, \"You cannot modify the can identifier\"\n        self.message = message\n        header = build_bcm_update_header(self.can_id_with_flags, self.flags)\n        frame = build_can_frame(message)\n        send_bcm(self.bcm_socket, header + frame)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nstopping all active periodic tasks and closes the socket.", "response": "def shutdown(self):\n        \"\"\"Stops all active periodic tasks and closes the socket.\"\"\"\n        self.stop_all_periodic_tasks()\n        for channel in self._bcm_sockets:\n            log.debug(\"Closing bcm socket for channel {}\".format(channel))\n            bcm_socket = self._bcm_sockets[channel]\n            bcm_socket.close()\n        log.debug(\"Closing raw can socket\")\n        self.socket.close()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ntransmit a message to the CAN bus.", "response": "def send(self, msg, timeout=None):\n        \"\"\"Transmit a message to the CAN bus.\n\n        :param can.Message msg: A message object.\n        :param float timeout:\n            Wait up to this many seconds for the transmit queue to be ready.\n            If not given, the call may fail immediately.\n\n        :raises can.CanError:\n            if the message could not be written.\n        \"\"\"\n        log.debug(\"We've been asked to write a message to the bus\")\n        logger_tx = log.getChild(\"tx\")\n        logger_tx.debug(\"sending: %s\", msg)\n\n        started = time.time()\n        # If no timeout is given, poll for availability\n        if timeout is None:\n            timeout = 0\n        time_left = timeout\n        data = build_can_frame(msg)\n\n        while time_left >= 0:\n            # Wait for write availability\n            ready = select.select([], [self.socket], [], time_left)[1]\n            if not ready:\n                # Timeout\n                break\n            sent = self._send_once(data, msg.channel)\n            if sent == len(data):\n                return\n            # Not all data were sent, try again with remaining data\n            data = data[sent:]\n            time_left = timeout - (time.time() - started)\n\n        raise can.CanError(\"Transmit buffer full\")"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nstart sending a message at a given period on this bus. The kernel's broadcast manager will be used. :param can.Message msg: Message to transmit :param float period: Period in seconds between each message :param float duration: The duration to keep sending this message at given rate. If no duration is provided, the task will continue indefinitely. :return: A started task instance. This can be used to modify the data, pause/resume the transmission and to stop the transmission. :rtype: can.interfaces.socketcan.CyclicSendTask .. note:: Note the duration before the message stops being sent may not be exactly the same as the duration specified by the user. In general the message will be sent at the given rate until at least *duration* seconds.", "response": "def _send_periodic_internal(self, msg, period, duration=None):\n        \"\"\"Start sending a message at a given period on this bus.\n\n        The kernel's broadcast manager will be used.\n\n        :param can.Message msg:\n            Message to transmit\n        :param float period:\n            Period in seconds between each message\n        :param float duration:\n            The duration to keep sending this message at given rate. If\n            no duration is provided, the task will continue indefinitely.\n\n        :return:\n            A started task instance. This can be used to modify the data,\n            pause/resume the transmission and to stop the transmission.\n        :rtype: can.interfaces.socketcan.CyclicSendTask\n\n        .. note::\n\n            Note the duration before the message stops being sent may not\n            be exactly the same as the duration specified by the user. In\n            general the message will be sent at the given rate until at\n            least *duration* seconds.\n\n        \"\"\"\n        bcm_socket = self._get_bcm_socket(msg.channel or self.channel)\n        task = CyclicSendTask(bcm_socket, msg, period, duration)\n        return task"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef find_serial_devices(serial_matcher=\"ED\"):\n    objWMIService = win32com.client.Dispatch(\"WbemScripting.SWbemLocator\")\n    objSWbemServices = objWMIService.ConnectServer(\".\", \"root\\cimv2\")\n    items = objSWbemServices.ExecQuery(\"SELECT * FROM Win32_USBControllerDevice\")\n    ids = (item.Dependent.strip('\"')[-8:] for item in items)\n    return [e for e in ids if e.startswith(serial_matcher)]", "response": "Find USB devices that start with the given serial number."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the names of all open can interfaces using ip link list.", "response": "def find_available_interfaces():\n    \"\"\"Returns the names of all open can/vcan interfaces using\n    the ``ip link list`` command. If the lookup fails, an error\n    is logged to the console and an empty list is returned.\n\n    :rtype: an iterable of :class:`str`\n    \"\"\"\n\n    try:\n        # it might be good to add \"type vcan\", but that might (?) exclude physical can devices\n        command = [\"ip\", \"-o\", \"link\", \"list\", \"up\"]\n        output = subprocess.check_output(command, universal_newlines=True)\n\n    except Exception as e: # subprocess.CalledProcessError was too specific\n        log.error(\"failed to fetch opened can devices: %s\", e)\n        return []\n\n    else:\n        #log.debug(\"find_available_interfaces(): output=\\n%s\", output)\n        # output contains some lines like \"1: vcan42: <NOARP,UP,LOWER_UP> ...\"\n        # extract the \"vcan42\" of each line\n        interface_names = [line.split(\": \", 3)[1] for line in output.splitlines()]\n        log.debug(\"find_available_interfaces(): detected: %s\", interface_names)\n        return filter(_PATTERN_CAN_INTERFACE.match, interface_names)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconvert an error code to a useful and human readable string.", "response": "def error_code_to_str(code):\n    \"\"\"\n    Converts a given error code (errno) to a useful and human readable string.\n\n    :param int code: a possibly invalid/unknown error code\n    :rtype: str\n    :returns: a string explaining and containing the given error code, or a string\n              explaining that the errorcode is unknown if that is the case\n    \"\"\"\n\n    try:\n        name = errno.errorcode[code]\n    except KeyError:\n        name = \"UNKNOWN\"\n\n    try:\n        description = os.strerror(code)\n    except ValueError:\n        description = \"no description available\"\n\n    return \"{} (errno {}): {}\".format(name, code, description)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef producer(id, message_count=16):\n\n    with can.Bus(bustype='socketcan', channel='vcan0') as bus:\n        for i in range(message_count):\n            msg = can.Message(arbitration_id=0x0cf02200+id, data=[id, i, 0, 1, 3, 1, 4, 1])\n            bus.send(msg)\n        sleep(1.0)\n\n    print(\"Producer #{} finished sending {} messages\".format(id, message_count))", "response": "Spam the bus with messages including the data id."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nappend a message to the buffer.", "response": "def on_message_received(self, msg):\n        \"\"\"Append a message to the buffer.\n\n        :raises: BufferError\n            if the reader has already been stopped\n        \"\"\"\n        if self.is_stopped:\n            raise RuntimeError(\"reader has already been stopped\")\n        else:\n            self.buffer.put(msg)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_message(self, timeout=0.5):\n        try:\n            return self.buffer.get(block=not self.is_stopped, timeout=timeout)\n        except Empty:\n            return None", "response": "Retrieves the latest message from the buffer."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the error text from the GetErrorText API call.", "response": "def _get_formatted_error(self, error):\n        \"\"\"\n        Gets the text using the GetErrorText API function.\n        If the function call succeeds, the translated error is returned. If it fails,\n        a text describing the current error is returned. Multiple errors may\n        be present in which case their individual messages are included in the\n        return string, one line per error.\n        \"\"\"\n\n        def bits(n):\n            \"\"\"TODO: document\"\"\"\n            while n:\n                b = n & (~n+1)\n                yield b\n                n ^= b\n\n        stsReturn = self.m_objPCANBasic.GetErrorText(error, 0)\n        if stsReturn[0] != PCAN_ERROR_OK:\n            strings = []\n\n            for b in bits(error):\n                stsReturn = self.m_objPCANBasic.GetErrorText(b, 0)\n                if stsReturn[0] != PCAN_ERROR_OK:\n                    text = \"An error occurred. Error-code's text ({0:X}h) couldn't be retrieved\".format(error)\n                else:\n                    text = stsReturn[1].decode('utf-8', errors='replace')\n\n                strings.append(text)\n\n            complete_text = '\\n'.join(strings)\n        else:\n            complete_text = stsReturn[1].decode('utf-8', errors='replace')\n\n        return complete_text"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef reset(self):\n        status = self.m_objPCANBasic.Reset(self.m_PcanHandle)\n        return status == PCAN_ERROR_OK", "response": "Reset the PCAN bus after an error."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nturning on or off flashing of the device s LED for physical identification purposes.", "response": "def flash(self, flash):\n        \"\"\"\n        Turn on or off flashing of the device's LED for physical\n        identification purposes.\n        \"\"\"\n        self.m_objPCANBasic.SetValue(self.m_PcanHandle, PCAN_CHANNEL_IDENTIFYING, bool(flash))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconverting status code to descriptive string.", "response": "def get_error_message(status_code):\n    \"\"\"Convert status code to descriptive string.\"\"\"\n    errmsg = ctypes.create_string_buffer(1024)\n    nican.ncStatusToString(status_code, len(errmsg), errmsg)\n    return errmsg.value.decode(\"ascii\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _recv_internal(self, timeout):\n        if timeout is None:\n            timeout = NC_DURATION_INFINITE\n        else:\n            timeout = int(timeout * 1000)\n\n        state = ctypes.c_ulong()\n        try:\n            nican.ncWaitForState(\n                self.handle, NC_ST_READ_AVAIL, timeout, ctypes.byref(state))\n        except NicanError as e:\n            if e.error_code == TIMEOUT_ERROR_CODE:\n                return None, True\n            else:\n                raise\n\n        raw_msg = RxMessageStruct()\n        nican.ncRead(self.handle, ctypes.sizeof(raw_msg), ctypes.byref(raw_msg))\n        # http://stackoverflow.com/questions/6161776/convert-windows-filetime-to-second-in-unix-linux\n        timestamp = raw_msg.timestamp / 10000000.0 - 11644473600\n        is_remote_frame = raw_msg.frame_type == NC_FRMTYPE_REMOTE\n        is_error_frame = raw_msg.frame_type == NC_FRMTYPE_COMM_ERR\n        is_extended = bool(raw_msg.arb_id & NC_FL_CAN_ARBID_XTD)\n        arb_id = raw_msg.arb_id\n        if not is_error_frame:\n            arb_id &= 0x1FFFFFFF\n        dlc = raw_msg.dlc\n        msg = Message(timestamp=timestamp,\n                      channel=self.channel,\n                      is_remote_frame=is_remote_frame,\n                      is_error_frame=is_error_frame,\n                      is_extended_id=is_extended,\n                      arbitration_id=arb_id,\n                      dlc=dlc,\n                      data=raw_msg.data[:dlc])\n        return msg, True", "response": "Internal method to read a message from a NI - CAN bus."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsends a message to the NI - CAN controller.", "response": "def send(self, msg, timeout=None):\n        \"\"\"\n        Send a message to NI-CAN.\n\n        :param can.Message msg:\n            Message to send\n\n        :raises can.interfaces.nican.NicanError:\n            If writing to transmit buffer fails.\n            It does not wait for message to be ACKed currently.\n        \"\"\"\n        arb_id = msg.arbitration_id\n        if msg.is_extended_id:\n            arb_id |= NC_FL_CAN_ARBID_XTD\n        raw_msg = TxMessageStruct(arb_id,\n                                  bool(msg.is_remote_frame),\n                                  msg.dlc,\n                                  CanData(*msg.data))\n        nican.ncWrite(\n            self.handle, ctypes.sizeof(raw_msg), ctypes.byref(raw_msg))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_filters(self, can_filers=None):\n        if self.__set_filters_has_been_called:\n            logger.warn(\"using filters is not supported like this, see note on NicanBus\")\n        else:\n            # allow the constructor to call this without causing a warning\n            self.__set_filters_has_been_called = True", "response": "Set the filters for this object."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef send_periodic(bus, message, period, *args, **kwargs):\n    warnings.warn(\"The function `can.send_periodic` is deprecated and will \" +\n                  \"be removed in an upcoming version. Please use `can.Bus.send_periodic` instead.\", DeprecationWarning)\n    return bus.send_periodic(message, period, *args, **kwargs)", "response": "Send a message periodically on the given bus."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _recv_internal(self, timeout=None):\n        arb_id = ctypes.c_long(0)\n        data = ctypes.create_string_buffer(64)\n        dlc = ctypes.c_uint(0)\n        flags = ctypes.c_uint(0)\n        timestamp = ctypes.c_ulong(0)\n\n        if timeout is None:\n            # Set infinite timeout\n            # http://www.kvaser.com/canlib-webhelp/group___c_a_n.html#ga2edd785a87cc16b49ece8969cad71e5b\n            timeout = 0xFFFFFFFF\n        else:\n            timeout = int(timeout * 1000)\n\n        #log.log(9, 'Reading for %d ms on handle: %s' % (timeout, self._read_handle))\n        status = canReadWait(\n            self._read_handle,\n            ctypes.byref(arb_id),\n            ctypes.byref(data),\n            ctypes.byref(dlc),\n            ctypes.byref(flags),\n            ctypes.byref(timestamp),\n            timeout  # This is an X ms blocking read\n        )\n\n        if status == canstat.canOK:\n            #log.debug('read complete -> status OK')\n            data_array = data.raw\n            flags = flags.value\n            is_extended = bool(flags & canstat.canMSG_EXT)\n            is_remote_frame = bool(flags & canstat.canMSG_RTR)\n            is_error_frame = bool(flags & canstat.canMSG_ERROR_FRAME)\n            is_fd = bool(flags & canstat.canFDMSG_FDF)\n            bitrate_switch = bool(flags & canstat.canFDMSG_BRS)\n            error_state_indicator = bool(flags & canstat.canFDMSG_ESI)\n            msg_timestamp = timestamp.value * TIMESTAMP_FACTOR\n            rx_msg = Message(arbitration_id=arb_id.value,\n                             data=data_array[:dlc.value],\n                             dlc=dlc.value,\n                             is_extended_id=is_extended,\n                             is_error_frame=is_error_frame,\n                             is_remote_frame=is_remote_frame,\n                             is_fd=is_fd,\n                             bitrate_switch=bitrate_switch,\n                             error_state_indicator=error_state_indicator,\n                             channel=self.channel,\n                             timestamp=msg_timestamp + self._timestamp_offset)\n            #log.debug('Got message: %s' % rx_msg)\n            return rx_msg, self._is_filtered\n        else:\n            #log.debug('read complete -> status not okay')\n            return None, self._is_filtered", "response": "Read a message from the kvaser device and return whether filtering has taken place."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef flash(self, flash=True):\n        if flash:\n            action = canstat.kvLED_ACTION_ALL_LEDS_ON\n        else:\n            action = canstat.kvLED_ACTION_ALL_LEDS_OFF\n\n        try:\n            kvFlashLeds(self._read_handle, action, 30000)\n        except (CANLIBError, NotImplementedError) as e:\n            log.error('Could not flash LEDs (%s)', e)", "response": "Flash the LEDs of the device."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nretrieves the bus statistics.", "response": "def get_stats(self):\n        \"\"\"Retrieves the bus statistics.\n\n        Use like so:\n\n        >>> stats = bus.get_stats()\n        >>> print(stats)\n        std_data: 0, std_remote: 0, ext_data: 0, ext_remote: 0, err_frame: 0, bus_load: 0.0%, overruns: 0\n\n        :returns: bus statistics.\n        :rtype: can.interfaces.kvaser.structures.BusStatistics\n         \"\"\"\n        canRequestBusStatistics(self._write_handle)\n        stats = structures.BusStatistics()\n        canGetBusStatistics(self._write_handle,\n                            ctypes.pointer(stats),\n                            ctypes.sizeof(stats))\n        return stats"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nformatting a VCI error and attach failed function decoded HRESULT and arguments tuple", "response": "def __vciFormatErrorExtended(library_instance, function, HRESULT, arguments):\n    \"\"\" Format a VCI error and attach failed function, decoded HRESULT and arguments\n        :param CLibrary library_instance:\n            Mapped instance of IXXAT vcinpl library\n        :param callable function:\n            Failed function\n        :param HRESULT HRESULT:\n            HRESULT returned by vcinpl call\n        :param arguments:\n            Arbitrary arguments tuple\n        :return:\n            Formatted string\n    \"\"\"\n    #TODO: make sure we don't generate another exception\n    return \"{} - arguments were {}\".format(\n        __vciFormatError(library_instance, function, HRESULT),\n        arguments\n    )"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nformat a VCI error and attach failed function and decoded HRESULT to the result of the call to the caller.", "response": "def __vciFormatError(library_instance, function, HRESULT):\n    \"\"\" Format a VCI error and attach failed function and decoded HRESULT\n        :param CLibrary library_instance:\n            Mapped instance of IXXAT vcinpl library\n        :param callable function:\n            Failed function\n        :param HRESULT HRESULT:\n            HRESULT returned by vcinpl call\n        :return:\n            Formatted string\n    \"\"\"\n    buf = ctypes.create_string_buffer(constants.VCI_MAX_ERRSTRLEN)\n    ctypes.memset(buf, 0, constants.VCI_MAX_ERRSTRLEN)\n    library_instance.vciFormatError(HRESULT, buf, constants.VCI_MAX_ERRSTRLEN)\n    return \"function {} failed ({})\".format(function._name, buf.value.decode('utf-8', 'replace'))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef __check_status(result, function, arguments):\n    if isinstance(result, int):\n        # Real return value is an unsigned long\n        result = ctypes.c_ulong(result).value\n\n    if result == constants.VCI_E_TIMEOUT:\n        raise VCITimeout(\"Function {} timed out\".format(function._name))\n    elif result == constants.VCI_E_RXQUEUE_EMPTY:\n        raise VCIRxQueueEmptyError()\n    elif result == constants.VCI_E_NO_MORE_ITEMS:\n        raise StopIteration()\n    elif result == constants.VCI_E_ACCESSDENIED:\n        pass # not a real error, might happen if another program has initialized the bus\n    elif result != constants.VCI_OK:\n        raise VCIError(vciFormatError(function, result))\n\n    return result", "response": "Check the result of a vcinpl function call and raise appropriate exception\n            in case of an error."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreads a message from the device.", "response": "def _recv_internal(self, timeout):\n        \"\"\" Read a message from IXXAT device. \"\"\"\n\n        # TODO: handling CAN error messages?\n        data_received = False\n\n        if timeout == 0:\n            # Peek without waiting\n            try:\n                _canlib.canChannelPeekMessage(self._channel_handle, ctypes.byref(self._message))\n            except (VCITimeout, VCIRxQueueEmptyError):\n                return None, True\n            else:\n                if self._message.uMsgInfo.Bits.type == constants.CAN_MSGTYPE_DATA:\n                    data_received = True\n        else:\n            # Wait if no message available\n            if timeout is None or timeout < 0:\n                remaining_ms = constants.INFINITE\n                t0 = None\n            else:\n                timeout_ms = int(timeout * 1000)\n                remaining_ms = timeout_ms\n                t0 = _timer_function()\n\n            while True:\n                try:\n                    _canlib.canChannelReadMessage(self._channel_handle, remaining_ms, ctypes.byref(self._message))\n                except (VCITimeout, VCIRxQueueEmptyError):\n                    # Ignore the 2 errors, the timeout is handled manually with the _timer_function()\n                    pass\n                else:\n                    # See if we got a data or info/error messages\n                    if self._message.uMsgInfo.Bits.type == constants.CAN_MSGTYPE_DATA:\n                        data_received = True\n                        break\n\n                    elif self._message.uMsgInfo.Bits.type == constants.CAN_MSGTYPE_INFO:\n                        log.info(CAN_INFO_MESSAGES.get(self._message.abData[0], \"Unknown CAN info message code {}\".format(self._message.abData[0])))\n\n                    elif self._message.uMsgInfo.Bits.type == constants.CAN_MSGTYPE_ERROR:\n                        log.warning(CAN_ERROR_MESSAGES.get(self._message.abData[0], \"Unknown CAN error message code {}\".format(self._message.abData[0])))\n\n                    elif self._message.uMsgInfo.Bits.type == constants.CAN_MSGTYPE_TIMEOVR:\n                        pass\n                    else:\n                        log.warn(\"Unexpected message info type\")\n\n                if t0 is not None:\n                    remaining_ms = timeout_ms - int((_timer_function() - t0) * 1000)\n                    if remaining_ms < 0:\n                        break\n\n        if not data_received:\n            # Timed out / can message type is not DATA\n            return None, True\n\n        # The _message.dwTime is a 32bit tick value and will overrun,\n        # so expect to see the value restarting from 0\n        rx_msg = Message(\n            timestamp=self._message.dwTime / self._tick_resolution,  # Relative time in s\n            is_remote_frame=True if self._message.uMsgInfo.Bits.rtr else False,\n            is_extended_id=True if self._message.uMsgInfo.Bits.ext else False,\n            arbitration_id=self._message.dwMsgId,\n            dlc=self._message.uMsgInfo.Bits.dlc,\n            data=self._message.abData[:self._message.uMsgInfo.Bits.dlc],\n            channel=self.channel\n        )\n\n        return rx_msg, True"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsend a message using built - in cyclic transmit list functionality.", "response": "def _send_periodic_internal(self, msg, period, duration=None):\n        \"\"\"Send a message using built-in cyclic transmit list functionality.\"\"\"\n        if self._scheduler is None:\n            self._scheduler = HANDLE()\n            _canlib.canSchedulerOpen(self._device_handle, self.channel,\n                                     self._scheduler)\n            caps = structures.CANCAPABILITIES()\n            _canlib.canSchedulerGetCaps(self._scheduler, caps)\n            self._scheduler_resolution = float(caps.dwClockFreq) / caps.dwCmsDivisor\n            _canlib.canSchedulerActivate(self._scheduler, constants.TRUE)\n        return CyclicSendTask(self._scheduler, msg, period, duration,\n                              self._scheduler_resolution)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting the filters for this object.", "response": "def set_filters(self, can_filers=None):\n        \"\"\"Unsupported. See note on :class:`~can.interfaces.ixxat.IXXATBus`.\n        \"\"\"\n        if self.__set_filters_has_been_called:\n            log.warn(\"using filters is not supported like this, see note on IXXATBus\")\n        else:\n            # allow the constructor to call this without causing a warning\n            self.__set_filters_has_been_called = True"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nstart transmitting a message.", "response": "def start(self):\n        \"\"\"Start transmitting message (add to list if needed).\"\"\"\n        if self._index is None:\n            self._index = ctypes.c_uint32()\n            _canlib.canSchedulerAddMessage(self._scheduler,\n                                           self._msg,\n                                           self._index)\n        _canlib.canSchedulerStartMessage(self._scheduler,\n                                         self._index,\n                                         self._count)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef stop(self):\n        # Remove it completely instead of just stopping it to avoid filling up\n        # the list with permanently stopped messages\n        _canlib.canSchedulerRemMessage(self._scheduler, self._index)\n        self._index = None", "response": "Stop transmitting a message from the scheduler."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef log_event(self, text, timestamp=None):\n        try:\n            # Only works on Windows\n            text = text.encode(\"mbcs\")\n        except LookupError:\n            text = text.encode(\"ascii\")\n        comment = b\"Added by python-can\"\n        marker = b\"python-can\"\n        data = GLOBAL_MARKER_STRUCT.pack(\n            0, 0xFFFFFF, 0xFF3300, 0, len(text), len(marker), len(comment))\n        self._add_object(GLOBAL_MARKER, data + text + marker + comment, timestamp)", "response": "Add an arbitrary message to the log file as a global marker."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncompress and writes data in the cache to file.", "response": "def _flush(self):\n        \"\"\"Compresses and writes data in the cache to file.\"\"\"\n        if self.file.closed:\n            return\n        cache = b\"\".join(self.cache)\n        if not cache:\n            # Nothing to write\n            return\n        uncompressed_data = cache[:self.MAX_CACHE_SIZE]\n        # Save data that comes after max size to next round\n        tail = cache[self.MAX_CACHE_SIZE:]\n        self.cache = [tail]\n        self.cache_size = len(tail)\n        compressed_data = zlib.compress(uncompressed_data,\n                                        self.COMPRESSION_LEVEL)\n        obj_size = (OBJ_HEADER_V1_STRUCT.size + LOG_CONTAINER_STRUCT.size +\n                    len(compressed_data))\n        base_header = OBJ_HEADER_BASE_STRUCT.pack(\n            b\"LOBJ\", OBJ_HEADER_BASE_STRUCT.size, 1, obj_size, LOG_CONTAINER)\n        container_header = LOG_CONTAINER_STRUCT.pack(\n            ZLIB_DEFLATE, len(uncompressed_data))\n        self.file.write(base_header)\n        self.file.write(container_header)\n        self.file.write(compressed_data)\n        # Write padding bytes\n        self.file.write(b\"\\x00\" * (obj_size % 4))\n        self.uncompressed_size += OBJ_HEADER_V1_STRUCT.size + LOG_CONTAINER_STRUCT.size\n        self.uncompressed_size += len(uncompressed_data)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef stop(self):\n        self._flush()\n        filesize = self.file.tell()\n        super(BLFWriter, self).stop()\n\n        # Write header in the beginning of the file\n        header = [b\"LOGG\", FILE_HEADER_SIZE,\n                  APPLICATION_ID, 0, 0, 0, 2, 6, 8, 1]\n        # The meaning of \"count of objects read\" is unknown\n        header.extend([filesize, self.uncompressed_size,\n                       self.count_of_objects, 0])\n        header.extend(timestamp_to_systemtime(self.start_timestamp))\n        header.extend(timestamp_to_systemtime(self.stop_timestamp))\n        with open(self.file.name, \"r+b\") as f:\n            f.write(FILE_HEADER_STRUCT.pack(*header))", "response": "Stops logging and closes the file."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ninitializes a PCAN Channel and return a TPCANStatus object.", "response": "def Initialize(\n        self,\n        Channel,\n        Btr0Btr1,\n        HwType = TPCANType(0),\n        IOPort = c_uint(0),\n        Interrupt = c_ushort(0)):\n\n        \"\"\"\n          Initializes a PCAN Channel\n\n        Parameters:\n          Channel  : A TPCANHandle representing a PCAN Channel\n          Btr0Btr1 : The speed for the communication (BTR0BTR1 code)\n          HwType   : NON PLUG&PLAY: The type of hardware and operation mode\n          IOPort   : NON PLUG&PLAY: The I/O address for the parallel port\n          Interrupt: NON PLUG&PLAY: Interrupt number of the parallel port\n\n        Returns:\n          A TPCANStatus error code\n        \"\"\"\n        try:\n            res = self.__m_dllBasic.CAN_Initialize(Channel,Btr0Btr1,HwType,IOPort,Interrupt)\n            return TPCANStatus(res)\n        except:\n            logger.error(\"Exception on PCANBasic.Initialize\")\n            raise"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef InitializeFD(\n        self,\n        Channel,\n        BitrateFD):\n\n        \"\"\"\n          Initializes a FD capable PCAN Channel\n\n        Parameters:\n          Channel  : The handle of a FD capable PCAN Channel\n          BitrateFD : The speed for the communication (FD bit rate string)\n\n    Remarks:\n      See PCAN_BR_* values.\n          * parameter and values must be separated by '='\n          * Couples of Parameter/value must be separated by ','\n          * Following Parameter must be filled out: f_clock, data_brp, data_sjw, data_tseg1, data_tseg2,\n            nom_brp, nom_sjw, nom_tseg1, nom_tseg2.\n          * Following Parameters are optional (not used yet): data_ssp_offset, nom_samp\n\n        Example:\n          f_clock=80000000,nom_brp=10,nom_tseg1=5,nom_tseg2=2,nom_sjw=1,data_brp=4,data_tseg1=7,data_tseg2=2,data_sjw=1\n\n        Returns:\n          A TPCANStatus error code\n        \"\"\"\n        try:\n            res = self.__m_dllBasic.CAN_InitializeFD(Channel,BitrateFD)\n            return TPCANStatus(res)\n        except:\n            logger.error(\"Exception on PCANBasic.InitializeFD\")\n            raise", "response": "This method initializes a FD capable PCAN Channel and returns a TPCANStatus object."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nresets the receive and transmit queues of a PCAN Channel.", "response": "def Reset(\n        self,\n        Channel):\n\n        \"\"\"\n          Resets the receive and transmit queues of the PCAN Channel\n\n        Remarks:\n          A reset of the CAN controller is not performed\n\n        Parameters:\n          Channel  : A TPCANHandle representing a PCAN Channel\n\n        Returns:\n          A TPCANStatus error code\n        \"\"\"\n        try:\n            res = self.__m_dllBasic.CAN_Reset(Channel)\n            return TPCANStatus(res)\n        except:\n            logger.error(\"Exception on PCANBasic.Reset\")\n            raise"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef GetStatus(\n        self,\n        Channel):\n\n        \"\"\"\n          Gets the current status of a PCAN Channel\n\n        Parameters:\n          Channel  : A TPCANHandle representing a PCAN Channel\n\n        Returns:\n          A TPCANStatus error code\n        \"\"\"\n        try:\n            res = self.__m_dllBasic.CAN_GetStatus(Channel)\n            return TPCANStatus(res)\n        except:\n            logger.error(\"Exception on PCANBasic.GetStatus\")\n            raise", "response": "Returns the current status of a PCAN Channel."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef Read(\n        self,\n        Channel):\n\n        \"\"\"\n          Reads a CAN message from the receive queue of a PCAN Channel\n\n        Remarks:\n          The return value of this method is a 3-touple, where\n          the first value is the result (TPCANStatus) of the method.\n          The order of the values are:\n          [0]: A TPCANStatus error code\n          [1]: A TPCANMsg structure with the CAN message read\n          [2]: A TPCANTimestamp structure with the time when a message was read\n\n        Parameters:\n          Channel  : A TPCANHandle representing a PCAN Channel\n\n        Returns:\n          A touple with three values\n        \"\"\"\n        try:\n            if platform.system() == 'Darwin':\n                msg = TPCANMsgMac()\n                timestamp = TPCANTimestampMac()\n            else:\n                msg = TPCANMsg()\n                timestamp = TPCANTimestamp()\n            res = self.__m_dllBasic.CAN_Read(Channel,byref(msg),byref(timestamp))\n            return TPCANStatus(res),msg,timestamp\n        except:\n            logger.error(\"Exception on PCANBasic.Read\")\n            raise", "response": "Reads a CAN message from the receive queue of a PCAN Channel."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nread a CAN message from the receive queue of a FD capable PCAN Channel.", "response": "def ReadFD(\n        self,\n        Channel):\n\n        \"\"\"\n          Reads a CAN message from the receive queue of a FD capable PCAN Channel\n\n        Remarks:\n          The return value of this method is a 3-touple, where\n          the first value is the result (TPCANStatus) of the method.\n          The order of the values are:\n          [0]: A TPCANStatus error code\n          [1]: A TPCANMsgFD structure with the CAN message read\n          [2]: A TPCANTimestampFD that is the time when a message was read\n\n        Parameters:\n          Channel  : The handle of a FD capable PCAN Channel\n\n        Returns:\n          A touple with three values\n        \"\"\"\n        try:\n            if platform.system() == 'Darwin':\n                msg = TPCANMsgFDMac()\n            else:\n                msg = TPCANMsgFD()\n            timestamp = TPCANTimestampFD()\n            res = self.__m_dllBasic.CAN_ReadFD(Channel,byref(msg),byref(timestamp))\n            return TPCANStatus(res),msg,timestamp\n        except:\n            logger.error(\"Exception on PCANBasic.ReadFD\")\n            raise"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ntransmit a CAN message to a PCAN Channel and returns a TPCANStatus object.", "response": "def Write(\n        self,\n        Channel,\n        MessageBuffer):\n\n        \"\"\"\n          Transmits a CAN message\n\n        Parameters:\n          Channel      : A TPCANHandle representing a PCAN Channel\n          MessageBuffer: A TPCANMsg representing the CAN message to be sent\n\n        Returns:\n          A TPCANStatus error code\n        \"\"\"\n        try:\n            res = self.__m_dllBasic.CAN_Write(Channel,byref(MessageBuffer))\n            return TPCANStatus(res)\n        except:\n            logger.error(\"Exception on PCANBasic.Write\")\n            raise"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef WriteFD(\n        self,\n        Channel,\n        MessageBuffer):\n\n        \"\"\"\n          Transmits a CAN message over a FD capable PCAN Channel\n\n        Parameters:\n          Channel      : The handle of a FD capable PCAN Channel\n          MessageBuffer: A TPCANMsgFD buffer with the message to be sent\n\n        Returns:\n          A TPCANStatus error code\n        \"\"\"\n        try:\n            res = self.__m_dllBasic.CAN_WriteFD(Channel,byref(MessageBuffer))\n            return TPCANStatus(res)\n        except:\n            logger.error(\"Exception on PCANBasic.WriteFD\")\n            raise", "response": "Transmits a CAN message over a FD capable PCAN Channel and returns a TPCANStatus object."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef FilterMessages(\n        self,\n        Channel,\n        FromID,\n        ToID,\n        Mode):\n\n        \"\"\"\n          Configures the reception filter\n\n        Remarks:\n          The message filter will be expanded with every call to this function.\n          If it is desired to reset the filter, please use the 'SetValue' function.\n\n        Parameters:\n          Channel : A TPCANHandle representing a PCAN Channel\n          FromID  : A c_uint value with the lowest CAN ID to be received\n          ToID    : A c_uint value with the highest CAN ID to be received\n          Mode    : A TPCANMode representing the message type (Standard, 11-bit\n                    identifier, or Extended, 29-bit identifier)\n\n        Returns:\n          A TPCANStatus error code\n        \"\"\"\n        try:\n            res = self.__m_dllBasic.CAN_FilterMessages(Channel,FromID,ToID,Mode)\n            return TPCANStatus(res)\n        except:\n            logger.error(\"Exception on PCANBasic.FilterMessages\")\n            raise", "response": "This function filters out the messages from a PCAN Channel from a given from ID to ID and mode."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nretrieve a PCAN Channel value Remarks: Parameters can be present or not according with the kind of Hardware (PCAN Channel) being used. If a parameter is not available, a PCAN_ERROR_ILLPARAMTYPE error will be returned. The return value of this method is a 2-touple, where the first value is the result (TPCANStatus) of the method and the second one, the asked value Parameters: Channel : A TPCANHandle representing a PCAN Channel Parameter : The TPCANParameter parameter to get Returns: A touple with 2 values", "response": "def GetValue(\n        self,\n        Channel,\n        Parameter):\n\n        \"\"\"\n          Retrieves a PCAN Channel value\n\n        Remarks:\n          Parameters can be present or not according with the kind\n          of Hardware (PCAN Channel) being used. If a parameter is not available,\n          a PCAN_ERROR_ILLPARAMTYPE error will be returned.\n\n          The return value of this method is a 2-touple, where\n          the first value is the result (TPCANStatus) of the method and\n          the second one, the asked value\n\n        Parameters:\n          Channel   : A TPCANHandle representing a PCAN Channel\n          Parameter : The TPCANParameter parameter to get\n\n        Returns:\n          A touple with 2 values\n        \"\"\"\n        try:\n            if Parameter == PCAN_API_VERSION or Parameter == PCAN_HARDWARE_NAME or Parameter == PCAN_CHANNEL_VERSION or Parameter == PCAN_LOG_LOCATION or Parameter == PCAN_TRACE_LOCATION or Parameter == PCAN_BITRATE_INFO_FD or Parameter == PCAN_IP_ADDRESS:\n                mybuffer = create_string_buffer(256)\n            else:\n                mybuffer = c_int(0)\n\n            res = self.__m_dllBasic.CAN_GetValue(Channel,Parameter,byref(mybuffer),sizeof(mybuffer))\n            return TPCANStatus(res),mybuffer.value\n        except:\n            logger.error(\"Exception on PCANBasic.GetValue\")\n            raise"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef SetValue(\n        self,\n        Channel,\n        Parameter,\n        Buffer):\n\n        \"\"\"\n          Returns a descriptive text of a given TPCANStatus error\n          code, in any desired language\n\n        Remarks:\n          Parameters can be present or not according with the kind\n          of Hardware (PCAN Channel) being used. If a parameter is not available,\n          a PCAN_ERROR_ILLPARAMTYPE error will be returned.\n\n        Parameters:\n          Channel      : A TPCANHandle representing a PCAN Channel\n          Parameter    : The TPCANParameter parameter to set\n          Buffer       : Buffer with the value to be set\n          BufferLength : Size in bytes of the buffer\n\n        Returns:\n          A TPCANStatus error code\n        \"\"\"\n        try:\n            if Parameter == PCAN_LOG_LOCATION or Parameter == PCAN_LOG_TEXT or Parameter == PCAN_TRACE_LOCATION:\n                mybuffer = create_string_buffer(256)\n            else:\n                mybuffer = c_int(0)\n\n            mybuffer.value = Buffer\n            res = self.__m_dllBasic.CAN_SetValue(Channel,Parameter,byref(mybuffer),sizeof(mybuffer))\n            return TPCANStatus(res)\n        except:\n            logger.error(\"Exception on PCANBasic.SetValue\")\n            raise", "response": "This function sets the value of a given channel in any desired language."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef GetErrorText(\n        self,\n        Error,\n        Language = 0):\n\n        \"\"\"\n          Configures or sets a PCAN Channel value\n\n        Remarks:\n\n          The current languages available for translation are:\n          Neutral (0x00), German (0x07), English (0x09), Spanish (0x0A),\n          Italian (0x10) and French (0x0C)\n\n          The return value of this method is a 2-touple, where\n          the first value is the result (TPCANStatus) of the method and\n          the second one, the error text\n\n        Parameters:\n          Error    : A TPCANStatus error code\n          Language : Indicates a 'Primary language ID' (Default is Neutral(0))\n\n        Returns:\n          A touple with 2 values\n        \"\"\"\n        try:\n            mybuffer = create_string_buffer(256)\n            res = self.__m_dllBasic.CAN_GetErrorText(Error,Language,byref(mybuffer))\n            return TPCANStatus(res),mybuffer.value\n        except:\n            logger.error(\"Exception on PCANBasic.GetErrorText\")\n            raise", "response": "This method returns the error text of a PCAN Channel."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef log_event(self, message, timestamp=None):\n\n        if not message: # if empty or None\n            logger.debug(\"ASCWriter: ignoring empty message\")\n            return\n\n        # this is the case for the very first message:\n        if not self.header_written:\n            self.last_timestamp = (timestamp or 0.0)\n            self.started = self.last_timestamp\n            mlsec = repr(self.last_timestamp).split('.')[1][:3]\n            formatted_date = time.strftime(self.FORMAT_DATE.format(mlsec), time.localtime(self.last_timestamp))\n            self.file.write(\"Begin Triggerblock %s\\n\" % formatted_date)\n            self.header_written = True\n            self.log_event(\"Start of measurement\") # caution: this is a recursive call!\n\n        # Use last known timestamp if unknown\n        if timestamp is None:\n            timestamp = self.last_timestamp\n\n        # turn into relative timestamps if necessary\n        if timestamp >= self.started:\n            timestamp -= self.started\n\n        line = self.FORMAT_EVENT.format(timestamp=timestamp, message=message)\n        self.file.write(line)", "response": "Add a message to the log file."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _detect_available_configs():\n        with channels_lock:\n            available_channels = list(channels.keys())\n\n        # find a currently unused channel\n        get_extra = lambda: \"channel-{}\".format(randint(0, 9999))\n        extra = get_extra()\n        while extra in available_channels:\n            extra = get_extra()\n\n        available_channels += [extra]\n\n        return [\n            {'interface': 'virtual', 'channel': channel}\n            for channel in available_channels\n        ]", "response": "Detects all currently used channels as well as one other currently unused channel."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef message_convert_rx(message_rx):\n    is_extended_id = bool(message_rx.flags & IS_ID_TYPE)\n    is_remote_frame = bool(message_rx.flags & IS_REMOTE_FRAME)\n    is_error_frame = bool(message_rx.flags & IS_ERROR_FRAME)\n\n    return Message(timestamp=message_rx.timestamp,\n                   is_remote_frame=is_remote_frame,\n                   is_extended_id=is_extended_id,\n                   is_error_frame=is_error_frame,\n                   arbitration_id=message_rx.id,\n                   dlc=message_rx.sizeData,\n                   data=message_rx.data[:message_rx.sizeData])", "response": "convert the message from the CANAL type to pythoncan type"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nshutting down the connection to the device safely.", "response": "def shutdown(self):\n        \"\"\"\n        Shuts down connection to the device safely.\n\n        :raise cam.CanError: is closing the connection did not work\n        \"\"\"\n        status = self.can.close(self.handle)\n\n        if status != CANAL_ERROR_SUCCESS:\n            raise CanError(\"could not shut down bus: status == {}\".format(status))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndetect available USB2 CAN channels.", "response": "def _detect_available_configs(serial_matcher=None):\n        \"\"\"\n        Uses the Windows Management Instrumentation to identify serial devices.\n\n        :param str serial_matcher (optional):\n            search string for automatic detection of the device serial\n        \"\"\"\n        if serial_matcher:\n            channels = find_serial_devices(serial_matcher)\n        else:\n            channels = find_serial_devices()\n\n        return [{'interface': 'usb2can', 'channel': c} for c in channels]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _get_class_for_interface(interface):\n    # Find the correct backend\n    try:\n        module_name, class_name = BACKENDS[interface]\n    except KeyError:\n        raise NotImplementedError(\"CAN interface '{}' not supported\".format(interface))\n\n    # Import the correct interface module\n    try:\n        module = importlib.import_module(module_name)\n    except Exception as e:\n        raise ImportError(\n            \"Cannot import module {} for CAN interface '{}': {}\".format(module_name, interface, e)\n        )\n\n    # Get the correct class\n    try:\n        bus_class = getattr(module, class_name)\n    except Exception as e:\n        raise ImportError(\n            \"Cannot import class {} from module {} for CAN interface '{}': {}\"\n                .format(class_name, module_name, interface, e)\n        )\n\n    return bus_class", "response": "Returns the main bus class for the given interface."}
