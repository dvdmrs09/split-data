{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nfind the sought key in the given dictionary regardless of case", "response": "def get_caselessly(dictionary, sought):\n    \"\"\"Find the sought key in the given dictionary regardless of case\n\n    >>> things = {'Fred' : 9}\n    >>> print(get_caselessly(things, 'fred'))\n    9\n    \"\"\"\n    try:\n        return dictionary[sought]\n    except KeyError:\n        caseless_keys = {k.lower(): k for k in dictionary.keys()}\n        real_key = caseless_keys[sought.lower()]  # allow any KeyError here\n        return dictionary[real_key]"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nappending those items to the values for that key", "response": "def append_value(dictionary, key, item):\n    \"\"\"Append those items to the values for that key\"\"\"\n    items = dictionary.get(key, [])\n    items.append(item)\n    dictionary[key] = items"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nextending the values for that key with the items", "response": "def extend_values(dictionary, key, items):\n    \"\"\"Extend the values for that key with the items\"\"\"\n    values = dictionary.get(key, [])\n    try:\n        values.extend(items)\n    except TypeError:\n        raise TypeError('Expected a list, got: %r' % items)\n    dictionary[key] = values"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef group_list(items):\n    groups = defaultdict(list)\n    for key, value in items:\n        groups[key].append(value)\n    return groups", "response": "Groups the items in the list into a dictionary"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef group_list_by(items, key_from_item):\n    groups = defaultdict(list)\n    for item in items:\n        key = key_from_item(item)\n        groups[key].append(item)\n    return groups", "response": "Groups the items in the list into a dictionary where the keys are the key of the item and the values are the items in the list."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nbridges function to run a worker under multiprocessing.", "response": "def run_worker(worker_class, *args, **kwargs):\n    '''Bridge function to run a worker under :mod:`multiprocessing`.\n\n    The :mod:`multiprocessing` module cannot\n    :meth:`~multiprocessing.Pool.apply_async` to a class constructor,\n    even if the ``__init__`` calls ``.run()``, so this simple wrapper\n    calls ``worker_class(*args, **kwargs)`` and logs any exceptions\n    before re-raising them.\n\n    This is usually only used to create a :class:`HeadlessWorker`, but\n    it does run through the complete\n    :meth:`~rejester.Worker.register`, :meth:`~rejester.Worker.run`,\n    :meth:`~rejester.Worker.unregister` sequence with some logging\n    on worker-level failures.\n\n    '''\n    try:\n        worker = worker_class(*args, **kwargs)\n    except Exception:\n        logger.critical('failed to create worker {0!r}'.format(worker_class),\n                        exc_info=True)\n        raise\n    # A note on style here:\n    #\n    # If this runs ForkWorker, ForkWorker will os.fork() LoopWorker\n    # (or SingleWorker) children, and the child will have this in its\n    # call stack.  Eventually the child will sys.exit(), which raises\n    # SystemExit, which is an exception that will trickle back through\n    # here.  If there is a try:...finally: block, the finally: block\n    # will execute on every child exit.  except Exception: won't run\n    # on SystemExit.\n    try:\n        worker.register()\n        worker.run()\n        worker.unregister()\n    except Exception:\n        logger.error('worker {0!r} died'.format(worker_class), exc_info=True)\n        try:\n            worker.unregister()\n        except:\n            pass\n        raise"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _get_and_start_work(self):\n        \"return (async_result, work_unit) or (None, None)\"\n        worker_id = nice_identifier()\n        work_unit = self.task_master.get_work(worker_id, available_gb=self.available_gb())\n        if work_unit is None:\n            return None, None\n        async_result = self.pool.apply_async(\n            run_worker,\n            (HeadlessWorker, self.task_master.registry.config,\n             worker_id,\n             work_unit.work_spec_name,\n             work_unit.key),\n            callback=self._finish_callback)\n        return async_result, work_unit", "response": "return ( async_result work_unit ) or ( None None"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef run(self):\n        '''Fetch and dispatch jobs as long as the system is running.\n\n        This periodically checks the :class:`rejester.TaskMaster` mode\n        and asks it for more work.  It will normally run forever in a\n        loop until the mode becomes\n        :attr:`~rejester.TaskMaster.TERMINATE`, at which point it\n        waits for all outstanding jobs to finish and exits.\n\n        This will :func:`~rejester.Worker.heartbeat` and check for new\n        work whenever a job finishes, or otherwise on a random\n        interval between 1 and 5 seconds.\n\n        '''\n\n        tm = self.task_master\n        num_workers = multiprocessing.cpu_count()\n        if 'tasks_per_cpu' in self.config:\n            num_workers *= self.config.get('tasks_per_cpu') or 1\n        if self.pool is None:\n            self.pool = multiprocessing.Pool(num_workers, maxtasksperchild=1)\n        ## slots is a fixed-length list of [AsyncRsults, WorkUnit]\n        slots = [[None, None]] * num_workers\n        logger.info('MultiWorker starting with %s workers', num_workers)\n        min_loop_time = 2.0\n        lastFullPoll = time.time()\n        while True:\n            mode = self.heartbeat()\n            if mode != self._mode:\n                logger.info('worker {0} changed to mode {1}'\n                            .format(self.worker_id, mode))\n                self._mode = mode\n            now = time.time()\n            should_update = (now - lastFullPoll) > min_loop_time\n            self._poll_slots(slots, mode=mode, do_update=should_update)\n            if should_update:\n                lastFullPoll = now\n\n            if mode == tm.TERMINATE:\n                num_waiting = sum(map(int, map(bool, map(itemgetter(0), slots))))\n                if num_waiting == 0:\n                    logger.info('MultiWorker all children finished')\n                    break\n                else:\n                    logger.info('MultiWorker waiting for %d children to finish', num_waiting)\n\n            sleepsecs = random.uniform(1,5)\n            sleepstart = time.time()\n            try:\n                self._event_queue.get(block=True, timeout=sleepsecs)\n                logger.debug('woken by event looptime=%s sleeptime=%s', sleepstart - now, time.time() - sleepstart)\n            except Queue.Empty, empty:\n                logger.debug('queue timed out. be exhausting, looptime=%s sleeptime=%s', sleepstart - now, time.time() - sleepstart)\n                # it's cool, timed out, do the loop of checks and stuff.\n\n        logger.info('MultiWorker exiting')", "response": "This method is called by the worker thread to check if the system is running."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget exactly one job run it and return.", "response": "def run_one(self, set_title=False):\n        '''Get exactly one job, run it, and return.\n\n        Does nothing (but returns :const:`False`) if there is no work\n        to do.  Ignores the global mode; this will do work even\n        if :func:`rejester.TaskMaster.get_mode` returns\n        :attr:`~rejester.TaskMaster.TERMINATE`.\n\n        :param set_title: if true, set the process's title with the\n          work unit name\n        :return: :const:`True` if there was a job (even if it failed)\n\n        '''\n        available_gb = MultiWorker.available_gb()\n        unit = self.task_master.get_work(self.worker_id, available_gb, work_spec_names=self.work_spec_names, max_jobs=self.max_jobs)\n        if not unit:\n            logger.info('No work to do; stopping.')\n            return False\n        if isinstance(unit, (list, tuple)):\n            ok = True\n            for xunit in unit:\n                if not ok:\n                    try:\n                        xunit.update(-1)\n                    except LostLease as e:\n                        pass\n                    except Exception as bad:\n                        # we're already quitting everything, but this is weirdly bad.\n                        logger.error('failed to release lease on %r %r', xunit.work_spec_name, xunit.key, exc_info=True)\n                else:\n                    ok = self._run_unit(xunit, set_title)\n            return ok\n        return self._run_unit(unit)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nruns a single job in a child process.", "response": "def as_child(cls, global_config, parent=None):\n        '''Run a single job in a child process.\n\n        This method never returns; it always calls :func:`sys.exit`\n        with an error code that says what it did.\n\n        '''\n        try:\n            setproctitle('rejester worker')\n            random.seed()  # otherwise everyone inherits the same seed\n            yakonfig.set_default_config([yakonfig, dblogger, rejester],\n                                        config=global_config)\n            worker = cls(yakonfig.get_global_config(rejester.config_name))\n            worker.register(parent=parent)\n            did_work = worker.run(set_title=True)\n            worker.unregister()\n            if did_work:\n                sys.exit(cls.EXIT_SUCCESS)\n            else:\n                sys.exit(cls.EXIT_BORED)\n        except Exception, e:\n            # There's some off chance we have logging.\n            # You will be here if redis is down, for instance,\n            # and the yakonfig dblogger setup runs but then\n            # the get_work call fails with an exception.\n            if len(logging.root.handlers) > 0:\n                logger.critical('failed to do any work', exc_info=e)\n            sys.exit(cls.EXIT_EXCEPTION)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting some signal handlers. These react reasonably to shutdown requests and keep the log child alive.", "response": "def set_signal_handlers(self):\n        '''Set some signal handlers.\n\n        These react reasonably to shutdown requests, and keep the\n        logging child alive.\n\n        '''\n        def handler(f):\n            def wrapper(signum, backtrace):\n                return f()\n            return wrapper\n\n        self.old_sigabrt = signal.signal(signal.SIGABRT,\n                                         handler(self.scram))\n        self.old_sigint = signal.signal(signal.SIGINT,\n                                        handler(self.stop_gracefully))\n        self.old_sigpipe = signal.signal(signal.SIGPIPE,\n                                         handler(self.live_log_child))\n        signal.siginterrupt(signal.SIGPIPE, False)\n        self.old_sigterm = signal.signal(signal.SIGTERM,\n                                         handler(self.stop_gracefully))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nundo :meth : set_signal_handlers.", "response": "def clear_signal_handlers(self):\n        '''Undo :meth:`set_signal_handlers`.\n\n        Not only must this be done on shutdown, but after every fork\n        call too.\n\n        '''\n        signal.signal(signal.SIGABRT, self.old_sigabrt)\n        signal.signal(signal.SIGINT, self.old_sigint)\n        signal.signal(signal.SIGPIPE, self.old_sigpipe)\n        signal.signal(signal.SIGTERM, self.old_sigterm)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nwrite a log message via the child process.", "response": "def log(self, level, message):\n        '''Write a log message via the child process.\n\n        The child process must already exist; call :meth:`live_log_child`\n        to make sure.  If it has died in a way we don't expect then\n        this will raise :const:`signal.SIGPIPE`.\n\n        '''\n        if self.log_fd is not None:\n            prefix = struct.pack('ii', level, len(message))\n            os.write(self.log_fd, prefix)\n            os.write(self.log_fd, message)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nwriting a debug - level log message.", "response": "def debug(self, group, message):\n        '''Maybe write a debug-level log message.\n\n        In particular, this gets written if the hidden `debug_worker`\n        option contains `group`.\n\n        '''\n        if group in self.debug_worker:\n            if 'stdout' in self.debug_worker:\n                print message\n            self.log(logging.DEBUG, message)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nstart the logging child process.", "response": "def start_log_child(self):\n        '''Start the logging child process.'''\n        self.stop_log_child()\n        gconfig = yakonfig.get_global_config()\n        read_end, write_end = os.pipe()\n        pid = os.fork()\n        if pid == 0:\n            # We are the child\n            self.clear_signal_handlers()\n            os.close(write_end)\n            yakonfig.clear_global_config()\n            self.log_spewer(gconfig, read_end)\n            sys.exit(0)\n        else:\n            # We are the parent\n            self.debug('children', 'new log child with pid {0}'.format(pid))\n            self.log_child = pid\n            os.close(read_end)\n            self.log_fd = write_end"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef stop_log_child(self):\n        '''Stop the logging child process.'''\n        if self.log_fd:\n            os.close(self.log_fd)\n            self.log_fd = None\n        if self.log_child:\n            try:\n                self.debug('children', 'stopping log child with pid {0}'\n                           .format(self.log_child))\n                os.kill(self.log_child, signal.SIGTERM)\n                os.waitpid(self.log_child, 0)\n            except OSError, e:\n                if e.errno == errno.ESRCH or e.errno == errno.ECHILD:\n                    # already gone\n                    pass\n                else:\n                    raise\n            self.log_child = None", "response": "Stop the logging child process."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef live_log_child(self):\n        '''Start the logging child process if it died.'''\n        if not (self.log_child and self.pid_is_alive(self.log_child)):\n            self.start_log_child()", "response": "Start the logging child process if it died."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef do_some_work(self, can_start_more):\n        '''Run one cycle of the main loop.\n\n        If the log child has died, restart it.  If any of the worker\n        children have died, collect their status codes and remove them\n        from the child set.  If there is a worker slot available, start\n        exactly one child.\n\n        :param bool can_start_more: Allowed to start a child?\n        :return:  Time to wait before calling this function again\n\n        '''\n        any_happy_children = False\n        any_sad_children = False\n        any_bored_children = False\n\n        self.debug('loop', 'starting work loop, can_start_more={0!r}'\n                   .format(can_start_more))\n\n        # See if anyone has died\n        while True:\n            try:\n                pid, status = os.waitpid(-1, os.WNOHANG)\n            except OSError, e:\n                if e.errno == errno.ECHILD:\n                    # No children at all\n                    pid = 0\n                else:\n                    raise\n            if pid == 0:\n                break\n            elif pid == self.log_child:\n                self.debug('children',\n                           'log child with pid {0} exited'.format(pid))\n                self.start_log_child()\n            elif pid in self.children:\n                self.children.remove(pid)\n                if os.WIFEXITED(status):\n                    code = os.WEXITSTATUS(status)\n                    self.debug('children',\n                               'worker {0} exited with code {1}'\n                               .format(pid, code))\n                    if code == SingleWorker.EXIT_SUCCESS:\n                        any_happy_children = True\n                    elif code == SingleWorker.EXIT_EXCEPTION:\n                        self.log(logging.WARNING,\n                                 'child {0} reported failure'.format(pid))\n                        any_sad_children = True\n                    elif code == SingleWorker.EXIT_BORED:\n                        any_bored_children = True\n                    else:\n                        self.log(logging.WARNING,\n                                 'child {0} had odd exit code {1}'\n                                 .format(pid, code))\n                elif os.WIFSIGNALED(status):\n                    self.log(logging.WARNING,\n                             'child {0} exited with signal {1}'\n                             .format(pid, os.WTERMSIG(status)))\n                    any_sad_children = True\n                else:\n                    self.log(logging.WARNING,\n                             'child {0} went away with unknown status {1}'\n                             .format(pid, status))\n                    any_sad_children = True\n            else:\n                self.log(logging.WARNING,\n                         'child {0} exited, but we don\\'t recognize it'\n                         .format(pid))\n\n        # ...what next?\n        # (Don't log anything here; either we logged a WARNING message\n        # above when things went badly, or we're in a very normal flow\n        # and don't want to spam the log)\n        if any_sad_children:\n            self.debug('loop', 'exit work loop with sad child')\n            return self.poll_interval\n\n        if any_bored_children:\n            self.debug('loop', 'exit work loop with no work')\n            return self.poll_interval\n\n        # This means we get to start a child, maybe.\n        if can_start_more and len(self.children) < self.num_workers:\n            pid = os.fork()\n            if pid == 0:\n                # We are the child\n                self.clear_signal_handlers()\n                if self.log_fd:\n                    os.close(self.log_fd)\n                LoopWorker.as_child(yakonfig.get_global_config(),\n                                    parent=self.worker_id)\n                # This should never return, but just in case\n                sys.exit(SingleWorker.EXIT_EXCEPTION)\n            else:\n                # We are the parent\n                self.debug('children', 'new worker with pid {0}'.format(pid))\n                self.children.add(pid)\n                self.debug('loop', 'exit work loop with a new worker')\n                return self.spawn_interval\n\n        # Absolutely nothing is happening; which means we have all\n        # of our potential workers and they're doing work\n        self.debug('loop', 'exit work loop with full system')\n        return self.poll_interval", "response": "This function runs one cycle of the main loop."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nstops children that are working on overdue jobs.", "response": "def check_spinning_children(self):\n        '''Stop children that are working on overdue jobs.'''\n        child_jobs = self.task_master.get_child_work_units(self.worker_id)\n        # We will kill off any jobs that are due before \"now\".  This\n        # isn't really now now, but now plus a grace period to make\n        # sure spinning jobs don't get retried.\n        now = time.time() + self.stop_jobs_early\n        for child, wul in child_jobs.iteritems():\n            if not isinstance(wul, (list, tuple)):\n                # Support old style get_child_work_units which returns\n                # single WorkUnit objects instead of list of them.\n                wul = [wul]\n            if not wul:\n                # This worker is idle, but oddly, still present; it should\n                # clean up after itself\n                continue\n            # filter on those actually assigned to the child worker\n            wul = filter(lambda wu: wu.worker_id == child, wul)\n            # check for any still active not-overdue job\n            if any(filter(lambda wu: wu.expires > now, wul)):\n                continue\n            # So either someone else is doing its work or it's just overdue\n            environment = self.task_master.get_heartbeat(child)\n            if not environment:\n                continue  # derp\n            if 'pid' not in environment:\n                continue  # derp\n            if environment['pid'] not in self.children:\n                continue  # derp\n            os.kill(environment['pid'], signal.SIGTERM)\n            # This will cause the child to die, and do_some_work will\n            # reap it; but we'd also like the job to fail if possible\n            for wu in wul:\n                if wu.data is None:\n                    logger.critical('how did wu.data become: %r' % wu.data)\n                else:\n                    wu.data['traceback'] = 'job expired'\n                wu.fail(exc=Exception('job expired'))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef stop_gracefully(self):\n        '''Refuse to start more processes.\n\n        This runs in response to SIGINT or SIGTERM; if this isn't a\n        background process, control-C and a normal ``kill`` command\n        cause this.\n\n        '''\n        if self.shutting_down:\n            self.log(logging.INFO,\n                     'second shutdown request, shutting down now')\n            self.scram()\n        else:\n            self.log(logging.INFO, 'shutting down after current jobs finish')\n            self.shutting_down = True", "response": "Refuse to start more processes."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nkill all workers and die ourselves.", "response": "def scram(self):\n        '''Kill all workers and die ourselves.\n\n        This runs in response to SIGABRT, from a specific invocation\n        of the ``kill`` command.  It also runs if\n        :meth:`stop_gracefully` is called more than once.\n\n        '''\n        self.stop_all_children()\n        signal.signal(signal.SIGTERM, signal.SIG_DFL)\n        sys.exit(2)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef run(self):\n        '''Run the main loop.\n\n        This is fairly invasive: it sets a bunch of signal handlers\n        and spawns off a bunch of child processes.\n\n        '''\n        setproctitle('rejester fork_worker for namespace {0}'\n                     .format(self.config.get('namespace', None)))\n        self.set_signal_handlers()\n        try:\n            self.start_log_child()\n            while True:\n                can_start_more = not self.shutting_down\n                if time.time() >= self.heartbeat_deadline:\n                    mode = self.heartbeat()\n                    if mode != self.last_mode:\n                        self.log(logging.INFO,\n                                 'rejester global mode is {0!r}'.format(mode))\n                        self.last_mode = mode\n                    self.heartbeat_deadline = (time.time() +\n                                               self.heartbeat_interval)\n                    self.check_spinning_children()\n                else:\n                    mode = self.last_mode\n                if mode != self.task_master.RUN:\n                    can_start_more = False\n                interval = self.do_some_work(can_start_more)\n                # Normal shutdown case\n                if len(self.children) == 0:\n                    if mode == self.task_master.TERMINATE:\n                        self.log(logging.INFO,\n                                 'stopping for rejester global shutdown')\n                        break\n                    if self.shutting_down:\n                        self.log(logging.INFO,\n                                 'stopping in response to signal')\n                        break\n                time.sleep(interval)\n        except Exception:\n            self.log(logging.CRITICAL,\n                     'uncaught exception in worker: ' + traceback.format_exc())\n        finally:\n            # See the note in run_workers() above.  clear_signal_handlers()\n            # calls signal.signal() which explicitly affects the current\n            # process, parent or child.\n            self.clear_signal_handlers()", "response": "This is fairly invasive. It sets a bunch of signal handlers and spawns off a bunch of child processes. This is fairly invasive. It is invasive : it sets a bunch of signal handlers and spawns off a bunch of child processes. This is fairly invasive : it sets a bunch of signal handlers and spawns off a bunch of child processes."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates an EC2 instance from an AMI and configures it as a Django server", "response": "def instance():\n    \"\"\"\n    Creates an EC2 instance from an Ubuntu AMI and configures it as a Django server\n    with nginx + gunicorn\n    \"\"\"\n    # Record the starting time and print a starting message\n    start_time = time.time()\n    print(_green(\"Started...\"))\n\n    # Use boto to create an EC2 instance\n    env.host_string = _create_ec2_instance()\n    print(_green(\"Waiting 30 seconds for server to boot...\"))\n    time.sleep(30)\n    \n    # Configure the instance that was just created\n    for item in tasks.configure_instance:\n        try:\n            print(_yellow(item['message']))\n        except KeyError:\n            pass\n        globals()[\"_\" + item['action']](item['params'])\n    \n    # Print out the final runtime and the public dns of the new instance\n    end_time = time.time()\n    print(_green(\"Runtime: %f minutes\" % ((end_time - start_time) / 60)))\n    print(_green(\"\\nPLEASE ADD ADDRESS THIS TO YOUR \")),\n    print(_yellow(\"project_conf.py\")),\n    print(_green(\" FILE UNDER \")),\n    print(_yellow(\"fabconf['EC2_INSTANCES'] : \")),\n    print(_green(env.host_string))"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ntasks a task from tasks. py and runs through the commands on the server", "response": "def _run_task(task, start_message, finished_message):\n    \"\"\"\n    Tasks a task from tasks.py and runs through the commands on the server\n    \"\"\"\n\n    # Get the hosts and record the start time\n    env.hosts = fabconf['EC2_INSTANCES']\n    start = time.time()\n\n    # Check if any hosts exist\n    if env.hosts == []:\n        print(\"There are EC2 instances defined in project_conf.py, please add some instances and try again\")\n        print(\"or run 'fab spawn_instance' to create an instance\")\n        return\n\n    # Print the starting message\n    print(_yellow(start_message))\n\n    # Run the task items\n    for item in task:\n        try:\n            print(_yellow(item['message']))\n        except KeyError:\n            pass\n        globals()[\"_\" + item['action']](item['params'])\n\n    # Print the final message and the elapsed time\n    print(_yellow(\"%s in %.2fs\" % (finished_message, time.time() - start)))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _put_template(params):\n    f = open(_render(params['template']), 'r')\n    template = f.read()\n\n    run(_write_to(_render(template), _render(params['destination'])))", "response": "This is a wrapper for _put that loads a file and does variable replacement\n   "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nmap a function f to a dictionary.", "response": "def dict_map(f, primitive, dic):\n    \"\"\"Map a function f:{primitive} -> B to a dictionary.\"\"\"\n\n    if primitive(dic):\n        return f(dic)\n    if isinstance(dic, Mapping):\n        return {dict_map(f, primitive, key): dict_map(f, primitive, value)\n                for key, value in dic.items()}\n    if isinstance(dic, str):\n        return dic\n    if isinstance(dic, Sequence):\n        return [dict_map(f, primitive, value) for value in dic]\n    return dic"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn information about the setuptools project.", "response": "def pkg_info():\n    \"\"\"Return project information for setuptools.\"\"\"\n    try:\n        doc = __doc__.decode(\"UTF-8\")\n    except (AttributeError, UnicodeError):\n        doc = __doc__ # Python3, or some strangeness\n\n    return dict(\n        # project data & layout\n        name = __name__.split('.')[0],\n        ## TODO: version = re.search(r\"(?<=\\()[^)]+(?=\\))\", changelog).group(),\n        package_dir = {\"\": \"src\"},\n        ## TODO: packages = find_packages(projectdir / \"src\", exclude=[\"tests\"]),\n        test_suite = \"nose.collector\",\n        zip_safe = True,\n        include_package_data = True,\n        data_files = [\n            (\"EGG-INFO\", [\n                \"README.md\", \"LICENSE\", \"debian/changelog\",\n            ]),\n        ],\n        entry_points = {\n            \"console_scripts\": [\n                \"infrascope = infrascope.cli:run\",\n            ],\n            \"infrascope.cli\": [\n                \"repo versions = infrascope.repositories:Versions\",\n            ],\n        },\n\n        # dependency management\n        install_requires = [\n        ],\n        setup_requires = [\n            \"docutils\",\n            \"Sphinx\",\n        ],\n        extras_require = {\n        },\n\n        # PyPI\n        url = \"https://github.com/1and1/infrascope\",\n        license = \"Apache License Version 2.0\",\n        keywords = \"python tool automation continuous.integration continuous.delivery devops reporting visualops\",\n        author = u\"J\u00fcrgen Hermann\",\n        author_email = \"jh@web.de\",\n        description = doc.split('.')[0].strip(),\n        long_description = doc.split('.', 1)[1].strip(),\n        classifiers = [\n            # values at http://pypi.python.org/pypi?:action=list_classifiers\n            \"Development Status :: 3 - Alpha\",\n            #\"Development Status :: 4 - Beta\",\n            #\"Development Status :: 5 - Production/Stable\",\n            \"Operating System :: OS Independent\",\n            \"Environment :: Console\",\n            \"Intended Audience :: Developers\",\n            \"Intended Audience :: Information Technology\",\n            \"Intended Audience :: System Administrators\",\n            \"License :: OSI Approved :: Apache Software License\",\n            \"Natural Language :: English\",\n            \"Operating System :: OS Independent\",\n            \"Programming Language :: Python :: 2.7\",\n            \"Topic :: Documentation\",\n            \"Topic :: System :: Software Distribution\",\n            \"Topic :: Utilities\",\n        ],\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create(self, configurable, config=None, **kwargs):\n        '''Create a sub-object of this factory.\n\n        Instantiates the `configurable` object with the current saved\n        :attr:`config`.  This essentially translates to\n        ``configurable(**config)``, except services defined in the\n        parent and requested by `configurable` (by setting the\n        ``services`` attribute) are injected. If a service is not\n        defined on this factory object, then a\n        :exc:`yakonfig.ProgrammerError` is raised.\n\n        If `config` is provided, it is a local configuration for\n        `configurable`, and it overrides the saved local configuration\n        (if any).  If not provided, then :attr:`config` must already be\n        set, possibly by passing this object into the :mod:`yakonfig`\n        top-level setup sequence.\n\n        :param callable configurable: object to create\n        :param dict config: local configuration for `configurable`\n        :param kwargs: additional keyword parameters\n        :return: ``configurable(**config)``\n\n        '''\n        # If we got passed a string, find the thing to make.\n        if isinstance(configurable, string_types):\n            candidates = [ac for ac in self.sub_modules\n                          if ac.config_name == configurable]\n            if len(candidates) == 0:\n                raise KeyError(configurable)\n            configurable = candidates[0]\n\n        # Regenerate the configuration if need be.\n        if not isinstance(configurable, AutoConfigured):\n            configurable = AutoConfigured.from_obj(configurable)\n\n        if config is None:\n            config = self.config.get(configurable.config_name, {})\n\n        # Iteratively build up the argument list.  If you explicitly\n        # called this function with a config dictionary with extra\n        # parameters, those will be lost.\n        params = {}\n        for other, default in iteritems(configurable.default_config):\n            params[other] = kwargs.get(other, config.get(other, default))\n        for other in getattr(configurable, 'services', []):\n            # AutoConfigured.check_config() validates that this key\n            # wasn't in the global config, so this must have come from\n            # either our own config parameter, a keyword arg, or the\n            # caller setting factory.config; trust those paths.\n            if other == 'config':\n                params[other] = dict(config, **kwargs)\n            elif other in kwargs:\n                params[other] = kwargs[other]\n            elif other in config:\n                params[other] = config[other]\n            else:\n                # We're not catching an `AttributeError` exception\n                # here because it may case a net too wide which makes\n                # debugging underlying errors more difficult.\n                params[other] = getattr(self, other)\n        return configurable(**params)", "response": "Create a sub - object of this factory."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates a proxy object from a callable.", "response": "def from_obj(cls, obj, any_configurable=False):\n        '''Create a proxy object from a callable.\n\n        If `any_configurable` is true, `obj` takes a parameter named\n        ``config``, and `obj` smells like it implements\n        :class:`yakonfig.Configurable` (it has a\n        :attr:`~yakonfig.Configurable.config_name`), then return it\n        directly.\n\n        '''\n        discovered = cls.inspect_obj(obj)\n        if ((any_configurable and\n             'config' in discovered['required'] and\n             hasattr(obj, 'config_name'))):\n            return obj\n        return cls(obj, discovered['name'], discovered['required'],\n                   discovered['defaults'])"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef check_config(self, config, name=''):\n        '''Check that the configuration for this object is valid.\n\n        This is a more restrictive check than for most :mod:`yakonfig`\n        objects.  It will raise :exc:`yakonfig.ConfigurationError` if\n        `config` contains any keys that are not in the underlying\n        callable's parameter list (that is, extra unused configuration\n        options).  This will also raise an exception if `config`\n        contains keys that duplicate parameters that should be\n        provided by the factory.\n\n        .. note:: This last behavior is subject to change; future\n                  versions of the library may allow configuration to\n                  provide local configuration for a factory-provided\n                  object.\n\n        :param dict config: the parent configuration dictionary,\n          probably contains :attr:`config_name` as a key\n        :param str name: qualified name of this object in the configuration\n        :raise: :exc:`yakonfig.ConfigurationError` if excess parameters exist\n\n        '''\n        # This is assuming that `config` is the config dictionary of\n        # the *config parent*. That is, `config[self.config_name]`\n        # exists.\n        config = config.get(self.config_name, {})\n\n        # Complain about additional parameters, unless this is an\n        # older object that's expecting a config dictionary.\n        extras = set(config.keys()).difference(self.default_config)\n        if 'config' not in self.services and extras:\n            raise ConfigurationError(\n                'Unsupported config options for \"%s\": %s'\n                % (self.config_name, ', '.join(extras)))\n\n        # This only happens if you went out of your way to\n        # circumvent the configuration and delete a parameter.\n        missing = set(self.default_config).difference(config)\n        if missing:\n            raise ConfigurationError(\n                'Missing config options for \"%s\": %s'\n                % (self.config_name, ', '.join(missing)))\n\n        # Did caller try to provide parameter(s) that we also expect\n        # the factory to provide?\n        duplicates = set(config.keys()).intersection(set(self.services))\n        if duplicates:\n            # N.B. I don't think the parameter can come from the\n            # default config because Python will not let you have\n            # `arg` and `arg=val` in the same parameter\n            # list. (`discover_config`, below, guarantees that\n            # positional and named parameters are disjoint.)\n            raise ConfigurationError(\n                'Disallowed config options for \"%s\": %s'\n                % (self.config_name, ', '.join(duplicates)))", "response": "Checks that the configuration for this object is valid."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a dictionary that contains the name of the object that is learned from the name of the object at obj.", "response": "def inspect_obj(obj):\n        '''Learn what there is to be learned from our target.\n\n        Given an object at `obj`, which must be a function, method or\n        class, return a configuration *discovered* from the name of\n        the object and its parameter list. This function is\n        responsible for doing runtime reflection and providing\n        understandable failure modes.\n\n        The return value is a dictionary with three keys: ``name``,\n        ``required`` and ``defaults``. ``name`` is the name of the\n        function/method/class. ``required`` is a list of parameters\n        *without* default values. ``defaults`` is a dictionary mapping\n        parameter names to default values. The sets of parameter names in\n        ``required`` and ``defaults`` are disjoint.\n\n        When given a class, the parameters are taken from its ``__init__``\n        method.\n\n        Note that this function is purposefully conservative in the things\n        that is will auto-configure. All of the following things will result\n        in a :exc:`yakonfig.ProgrammerError` exception being raised:\n\n        1. A parameter list that contains tuple unpacking. (This is invalid\n           syntax in Python 3.)\n        2. A parameter list that contains variable arguments (``*args``) or\n           variable keyword words (``**kwargs``). This restriction forces\n           an auto-configurable to explicitly state all configuration.\n\n        Similarly, if given an object that isn't a function/method/class, a\n        :exc:`yakonfig.ProgrammerError` will be raised.\n\n        If reflection cannot be performed on ``obj``, then a ``TypeError``\n        is raised.\n\n        '''\n        skip_params = 0\n        if inspect.isfunction(obj):\n            name = obj.__name__\n            inspect_obj = obj\n            skip_params = 0\n        elif inspect.ismethod(obj):\n            name = obj.im_func.__name__\n            inspect_obj = obj\n            skip_params = 1  # self\n        elif inspect.isclass(obj):\n            inspect_obj = None\n            if hasattr(obj, '__dict__') and '__new__' in obj.__dict__:\n                inspect_obj = obj.__new__\n            elif hasattr(obj, '__init__'):\n                inspect_obj = obj.__init__\n            else:\n                raise ProgrammerError(\n                    'Class \"%s\" does not have a \"__new__\" or \"__init__\" '\n                    'method, so it cannot be auto configured.' % str(obj))\n            name = obj.__name__\n            if hasattr(obj, 'config_name'):\n                name = obj.config_name\n            if not inspect.ismethod(inspect_obj) \\\n                    and not inspect.isfunction(inspect_obj):\n                raise ProgrammerError(\n                    '\"%s.%s\" is not a method/function (it is a \"%s\").'\n                    % (str(obj), inspect_obj.__name__, type(inspect_obj)))\n            skip_params = 1  # self\n        else:\n            raise ProgrammerError(\n                'Expected a function, method or class to '\n                'automatically configure, but got a \"%s\" '\n                '(type: \"%s\").' % (repr(obj), type(obj)))\n\n        argspec = inspect.getargspec(inspect_obj)\n        if argspec.varargs is not None or argspec.keywords is not None:\n            raise ProgrammerError(\n                'The auto-configurable \"%s\" cannot contain '\n                '\"*args\" or \"**kwargs\" in its list of '\n                'parameters.' % repr(obj))\n        if not all(isinstance(arg, string_types) for arg in argspec.args):\n            raise ProgrammerError(\n                'Expected an auto-configurable with no nested '\n                'parameters, but \"%s\" seems to contain some '\n                'tuple unpacking: \"%s\"'\n                % (repr(obj), argspec.args))\n\n        defaults = argspec.defaults or []\n        # The index into `argspec.args` at which keyword arguments with default\n        # values starts.\n        i_defaults = len(argspec.args) - len(defaults)\n        return {\n            'name': name,\n            'required': argspec.args[skip_params:i_defaults],\n            'defaults': dict([(k, defaults[i])\n                              for i, k in enumerate(argspec.args[i_defaults:])]),\n        }"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nfinding the relative path to its module of a python file.", "response": "def modulepath(filename):\n    \"\"\"\n    Find the relative path to its module of a python file if existing.\n\n    filename\n      string, name of a python file\n    \"\"\"\n    filepath = os.path.abspath(filename)\n    prepath = filepath[:filepath.rindex('/')]\n    postpath = '/'\n    if prepath.count('/') == 0 or not os.path.exists(prepath + '/__init__.py'):\n        flag = False\n    else:\n        flag = True\n    while True:\n        if prepath.endswith('/lib') or prepath.endswith('/bin') or prepath.endswith('/site-packages'):\n            break\n        elif flag and (prepath.count('/') == 0 or not os.path.exists(prepath + '/__init__.py')):\n            break\n        else:\n            for f in os.listdir(prepath):\n                if '.py' in f:\n                    break\n            else:\n                break\n            postpath = prepath[prepath.rindex('/'):].split('-')[0].split('_')[0] + postpath\n            prepath = prepath[:prepath.rindex('/')]\n    return postpath.lstrip('/') + filename.split('/')[-1].replace('.pyc', '').replace('.py', '') + '/'"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a printable version for a message type.", "response": "def format_message_type(message_type):\n    \"\"\"\n    Get printable version for message type\n\n    :param message_type: Message type\n    :type message_type: int\n    :return: Printable version\n    :rtype: str\n    \"\"\"\n    if message_type == MsgType.NOT_SET:\n        return \"NOT_SET\"\n    elif message_type == MsgType.ACK:\n        return \"ACK\"\n    elif message_type == MsgType.JOIN:\n        return \"JOIN\"\n    elif message_type == MsgType.UNJOIN:\n        return \"UNJOIN\"\n    elif message_type == MsgType.CONFIG:\n        return \"CONFIG\"\n    elif message_type == MsgType.UPDATE:\n        return \"UPDATE\"\n    elif message_type == MsgType.DATA:\n        return \"DATA\"\n    else:\n        return u\"{}\".format(message_type)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nformatting bytes for printing", "response": "def format_data(data):\n    \"\"\"\n    Format bytes for printing\n\n    :param data: Bytes\n    :type data: None | bytearray | str\n    :return: Printable version\n    :rtype: unicode\n    \"\"\"\n    if data is None:\n        return None\n    return u\":\".join([u\"{:02x}\".format(ord(c)) for c in data])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nguessing the message type based on the class of message.", "response": "def guess_message_type(message):\n    \"\"\"\n    Guess the message type based on the class of message\n\n    :param message: Message to guess the type for\n    :type message: APPMessage\n    :return: The corresponding message  type (MsgType) or None if not found\n    :rtype: None | int\n    \"\"\"\n    if isinstance(message, APPConfigMessage):\n        return MsgType.CONFIG\n    elif isinstance(message, APPJoinMessage):\n        return MsgType.JOIN\n    elif isinstance(message, APPDataMessage):\n        # All inheriting from this first !!\n        return MsgType.DATA\n    elif isinstance(message, APPUpdateMessage):\n        return MsgType.UPDATE\n    elif isinstance(message, APPUnjoinMessage):\n        return MsgType.UNJOIN\n    # APPMessage -> ACK?\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nlocalizes a timestamp in UTC or with tz_info", "response": "def timestamp_localize(value):\n        \"\"\"\n        Save timestamp as utc\n\n        :param value: Timestamp (in UTC or with tz_info)\n        :type value: float | datetime.datetime\n        :return: Localized timestamp\n        :rtype: float\n        \"\"\"\n        if isinstance(value, datetime.datetime):\n            if not value.tzinfo:\n                value = pytz.UTC.localize(value)\n            else:\n                value = value.astimezone(pytz.UTC)\n            # Assumes utc (and add the microsecond part)\n            value = calendar.timegm(value.timetuple()) + \\\n                value.microsecond / 1e6\n        return value"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_timestamp_to_current(self):\n        # Good form to add tzinfo\n        self.timestamp = pytz.UTC.localize(datetime.datetime.utcnow())", "response": "Set timestamp to current time"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\npack this object into a transmittable format.", "response": "def pack(self, update_timestamp=False):\n        \"\"\"\n        Pack this object into a transmittable format\n\n        :param update_timestamp:\n            Should the timestamp be updated to current (default: False)\n        :type update_timestamp: bool\n        :return: Packed data\n        :rtype: bytearray\n        :raises ValueError: Invalid device id/message type\n        \"\"\"\n        if self.device_id <= Id.NOT_SET or not isinstance(self.device_id, int):\n            raise ValueError(\"Invalid device id\")\n        if self.message_type <= MsgType.NOT_SET \\\n                or not isinstance(self.message_type, int) \\\n                or self.message_type not in list(MsgType):\n            raise ValueError(\"Invalid message type\")\n        if update_timestamp or not self._timestamp:\n            self.set_timestamp_to_current()\n        append = b\"\"\n\n        if self.sequence_number is not None:\n            self.flags |= Flag.SEQ\n            append += struct.pack(self.fmt_seq, self.sequence_number)\n        if self.ack_sequence_number is not None:\n            self.flags |= Flag.ACKSEQ\n            append += struct.pack(self.fmt_seq_ack, self.ack_sequence_number)\n\n        packed = struct.pack(\n            self.fmt_header,\n            (self.version_major << 4) + self.version_minor,\n            self.message_type,\n            self.payload_length,\n            self._timestamp,\n            self.device_id,\n            self.flags\n        )\n        return packed + append"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef unpack(cls, data):\n        size = struct.calcsize(APPHeader.fmt_header)\n        (\n            version, msg_type, payload_len,\n            timestamp, device_id, flags,\n        ), payload = struct.unpack(\n            APPHeader.fmt_header, data[:size]\n        ), data[size:]\n        ack_sequence_number = None\n        sequence_number = None\n\n        if flags & Flag.ACKSEQ:\n            size = struct.calcsize(APPHeader.fmt_seq_ack)\n            (ack_sequence_number,), payload = struct.unpack(\n                APPHeader.fmt_seq_ack, payload[:size]\n            ), payload[size:]\n        if flags & Flag.SEQ:\n            size = struct.calcsize(APPHeader.fmt_seq)\n            (sequence_number,), payload = struct.unpack(\n                APPHeader.fmt_seq, payload[:size]\n            ), payload[size:]\n        return cls(\n            message_type=msg_type,\n            version_major=version >> 4,\n            version_minor=version & 0xf,\n            payload_length=payload_len,\n            device_id=device_id,\n            sequence_number=sequence_number,\n            flags=flags,\n            timestamp=timestamp,\n            ack_sequence_number=ack_sequence_number\n        ), payload", "response": "Unpack packed data into an instance of the class"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nupdates this instance based on another instance of APPMessage.", "response": "def update(self, obj):\n        \"\"\"\n        Set this instance up based on another instance\n\n        :param obj: Instance to copy from\n        :type obj: APPMessage\n        :rtype: None\n        \"\"\"\n        if isinstance(obj, APPMessage):\n            self._header = obj._header\n            self._payload = obj._payload"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef payload_set(self, value):\n        self._payload = value\n        self._header.payload_length = len(self._payload)", "response": "Set the message payload and update header."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef pack(self, update_timestamp=False, insert_before_payload=\"\"):\n        return self._header.pack(update_timestamp) \\\n            + insert_before_payload \\\n            + self._payload", "response": "Pack this object into a transmittable format"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nunpack packed data into an instance of the class", "response": "def unpack(cls, data):\n        \"\"\"\n        Unpack packed data into an instance\n\n        :param data: Packed data\n        :type data: str\n        :return: Object instance and remaining data\n        :rtype: (APPMessage, str)\n        :raises ProtocolViolation: Data length smaller than payload length\n        \"\"\"\n        header, data = APPHeader.unpack(data)\n\n        if len(data) < header.payload_length:\n            raise ProtocolViolation(\"Payload too small\")\n        payload = data[:header.payload_length]\n        body = cls()\n        body._header = header\n        body._payload = payload\n        return body, data[header.payload_length:]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the message payload and update header", "response": "def payload_set(self, value):\n        \"\"\"\n        Set the message payload (and update header)\n\n        :param value: New payload value\n        :type value: str\n        :rtype: None\n        \"\"\"\n        payload = saveJSON(value, pretty=False)\n        super(APPDataMessage, self).payload_set(payload)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _pack_people(people):\n        res = bytearray()\n        bits = bytearray([1])\n\n        for person in people:\n            bits.extend(person.to_bits())\n        aByte = 0\n\n        for i, bit in enumerate(bits[::-1]):\n            mod = i % 8\n            aByte |= bit << mod\n            if mod == 7 or i == len(bits) - 1:\n                res.append(aByte)\n                aByte = 0\n        return struct.pack(APPUpdateMessage.fmt.format(len(res)), *res[::-1])", "response": "Packs a list of people into a network transmittable format"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef people(self):\n        people = []\n        bits = bytearray()\n        byts = struct.unpack(\n            APPUpdateMessage.fmt.format(len(self.payload)), self.payload\n        )[::-1]\n        # indices = range(7, -1, -1)\n        indices = range(8)\n        for aByte in byts[:-1]:\n            for i in indices:\n                bit = aByte >> i & 1\n                bits.append(bit)\n        # find marker\n        mark = 7\n        aByte = byts[-1]\n        while aByte >> mark == 0 and mark > 0:\n            mark -= 1\n        if aByte >> mark != 1:\n            raise ProtocolViolation(u\"Failed to find marker ({})\".format(\n                format_data(self.payload)\n            ))\n        # remove marker and add the rest\n        for i in range(mark):\n            bit = aByte >> i & 1\n            bits.append(bit)\n\n        if len(bits) % Person.BITS_PER_PERSON != 0:\n            raise ProtocolViolation(\n                u\"Payload seems to be malformed\"\n                u\" - Can not decode into people ({})\".format(\n                    format_data(self.payload)\n                )\n            )\n        # reverse\n        i = len(bits)\n        while i > 0:\n            p = Person()\n            # select the bits for this person and bring them in the right order\n            # bits is currently in reverse order\n            p.from_bits(bits[i - Person.BITS_PER_PERSON:i][::-1])\n            people.append(p)\n            i -= Person.BITS_PER_PERSON\n        return people", "response": "Returns the list of people stored in payload."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef from_dynacRepr(cls, pynacRepr):\n        L = float(pynacRepr[1][0][0])\n        B = float(pynacRepr[1][0][1])\n        aperRadius = float(pynacRepr[1][0][2])\n        return cls(L, B, aperRadius)", "response": "Construct a new instance from a Pynac lattice element."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef scaleField(self, scalingFactor):\n        self.B = self.B._replace(val=self.B.val * scalingFactor)", "response": "Adjust the field of the magnet by the value of scalingFactor."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef setField(self, new_value):\n        self.B = self.B._replace(val=new_value)", "response": "Adjust the field of the magnet by the value of new_value."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef dynacRepresentation(self):\n        return ['QUADRUPO', [[self.L.val, self.B.val, self.aperRadius.val]]]", "response": "Returns the Pynac representation of this quadrupole instance."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconstruct a CavityAnalytic instance from a Pynac lattice element.", "response": "def from_dynacRepr(cls, pynacRepr):\n        \"\"\"\n        Construct a ``CavityAnalytic`` instance from the Pynac lattice element\n        \"\"\"\n        cavID = int(pynacRepr[1][0][0])\n        xesln = float(pynacRepr[1][1][0])\n        phase = float(pynacRepr[1][1][1])\n        fieldReduction = float(pynacRepr[1][1][2])\n        isec = int(pynacRepr[1][1][3])\n        return cls(phase, fieldReduction, cavID, xesln, isec)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef adjustPhase(self, adjustment):\n        self.phase = self.phase._replace(val = self.phase.val + adjustment)", "response": "Adjust the accelerating phase of the cavity of the current entry."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef scaleField(self, scalingFactor):\n        oldField = self.fieldReduction.val\n        newField = 100.0 * (scalingFactor * (1.0 + oldField/100.0) - 1.0)\n        self.fieldReduction = self.fieldReduction._replace(val = newField)", "response": "Adjust the accelerating field of the cavity by the value of scalingFactor."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the Dynac representation of this cavity instance.", "response": "def dynacRepresentation(self):\n        \"\"\"\n        Return the Dynac representation of this cavity instance.\n        \"\"\"\n        return ['CAVMC', [\n            [self.cavID.val],\n            [self.xesln.val, self.phase.val, self.fieldReduction.val, self.isec.val, 1],\n            ]]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconstruct an AccGap instance from a Pynac lattice element.", "response": "def from_dynacRepr(cls, pynacRepr):\n        \"\"\"\n        Construct a ``AccGap`` instance from the Pynac lattice element\n        \"\"\"\n        pynacList = pynacRepr[1][0]\n\n        L = float(pynacList[3])\n        TTF = float(pynacList[4])\n        TTFprime = float(pynacList[5])\n        TTFprimeprime = float(pynacList[13])\n        EField = float(pynacList[10])\n        phase = float(pynacList[11])\n        F = float(pynacList[14])\n        atten = float(pynacList[15])\n\n        gap = cls(L, TTF, TTFprime, TTFprimeprime, EField, phase, F, atten)\n        gap.gapID = Param(val = int(pynacList[0]), unit = None)\n        gap.energy = Param(val = float(pynacList[1]), unit = 'MeV')\n        gap.beta = Param(val = float(pynacList[2]), unit = None)\n        gap.S = Param(val = float(pynacList[6]), unit = None)\n        gap.SP = Param(val = float(pynacList[7]), unit = None)\n        gap.quadLength = Param(val = float(pynacList[8]), unit = 'cm')\n        gap.quadStrength = Param(val = float(pynacList[9]), unit = 'kG/cm')\n        gap.accumLen = Param(val = float(pynacList[12]), unit = 'cm')\n\n        return gap"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef dynacRepresentation(self):\n        details = [\n            self.gapID.val,\n            self.energy.val,\n            self.beta.val,\n            self.L.val,\n            self.TTF.val,\n            self.TTFprime.val,\n            self.S.val,\n            self.SP.val,\n            self.quadLength.val,\n            self.quadStrength.val,\n            self.EField.val,\n            self.phase.val,\n            self.accumLen.val,\n            self.TTFprimeprime.val,\n            self.F.val,\n            self.atten.val,\n        ]\n        return ['CAVSC', [details]]", "response": "Return the Dynac representation of this accelerating gap instance."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef from_dynacRepr(cls, pynacRepr):\n        energyDefnFlag = int(pynacRepr[1][0][0])\n        energy = float(pynacRepr[1][0][1])\n        phase = float(pynacRepr[1][0][2])\n        x = float(pynacRepr[1][0][3])\n        y = float(pynacRepr[1][0][4])\n        radius = float(pynacRepr[1][0][5])\n\n        return cls(energy, phase, x, y, radius, energyDefnFlag)", "response": "Construct a set4DAperture instance from a Pynac lattice element."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef dynacRepresentation(self):\n        details = [\n            self.energyDefnFlag.val,\n            self.energy.val,\n            self.phase.val,\n            self.x.val,\n            self.y.val,\n            self.radius.val,\n        ]\n        return ['REJECT', [details]]", "response": "Returns the Pynac representation of this Set4DAperture instance."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the Pynac representation of this Set4DAperture instance.", "response": "def dynacRepresentation(self):\n        \"\"\"\n        Return the Pynac representation of this Set4DAperture instance.\n        \"\"\"\n        details = [\n            self.voltage.val,\n            self.phase.val,\n            self.harmonicNum.val,\n            self.apertureRadius.val,\n        ]\n        return ['BUNCHER', [details]]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef from_dynacRepr(cls, pynacRepr):\n        f = float(pynacRepr[1][0][0])\n        p = 'HV'[int(pynacRepr[1][0][1])]\n        return cls(f, p)", "response": "Construct a Steerer instance from a Pynac lattice element."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef dynacRepresentation(self):\n        if self.plane.val == 'H':\n            p = 0\n        elif self.plane.val == 'V':\n            p = 1\n        return ['STEER', [[self.field_strength.val], [p]]]", "response": "Returns the Dynac representation of this steerer instance."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadjust the field of the magnet by the value of scalingFactor.", "response": "def scaleField(self, scalingFactor):\n        \"\"\"\n        Adjust the field of the magnet by the value of ``scalingFactor``.  The adjustment\n        is multiplicative, so a value of ``scalingFactor = 1.0`` will result in no change\n        of the field.\n        \"\"\"\n        self.field_strength = self.field_strength._replace(\n            val=self.field_strength.val * scalingFactor\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef setField(self, new_value):\n        self.field_strength = self.field_strength._replace(\n            val=new_value\n        )", "response": "Adjust the field of the magnet by the value of new_value."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nparse command line opts and run a skeleton file when called from the command line, ligament looks in the current working directory for a file called `skeleton.py`. Tasks specified from the command line are then executed in order, and if the -w flag was specified, ligament then watches the filesystem for changes to prompt task re-execution;", "response": "def main():\n    \"\"\" parse command line opts and run a skeleton file\n\n        when called from the command line, ligament looks in the current \n        working directory for a file called `skeleton.py`. Tasks specified from\n        the command line are then executed in order, and if the -w flag was\n        specified, ligament then watches the filesystem for changes to\n        prompt task re-execution;\n    \"\"\"\n\n    options = None\n    try:\n        options, args = getopt.gnu_getopt(\n            sys.argv[1:],\n            \"whqv\",\n            [\"watch\", \"help\", \"query\", \"verbose\"])\n    except getopt.GetoptError as e:\n        print e\n        print_helptext()\n        exit(1)\n\n    should_watch = False\n    query_skeleton = False\n    verbose = False\n\n    for opt, arg in options:\n        if opt == \"--watch\" or opt == '-w':\n            should_watch = True\n        elif opt == \"--query\" or opt == '-q':\n            query_skeleton = True\n        elif opt == \"--help\" or opt == '-h':\n            print_helptext()\n            exit(0)\n        elif opt == \"--verbose\" or opt == '-v':\n            verbose = True\n        else:\n            print \"option '%s' not recognized\" % opt\n            print_helptext()\n            exit(1)\n\n    if verbose:\n        helpers.set_verbosity(\".*\")\n\n    if query_skeleton:\n        print \" \".join(ligament.query_skeleton(\"./skeleton.py\"))\n        helpers.set_verbosity()\n\n    else:\n        helpers.add_verbosity_groups(\"build_task\")\n        ligament.run_skeleton(\n            \"./skeleton.py\",\n            [\"default\"] if len(args) == 0 else args,\n            watch=should_watch)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _getter(self, obj):\n        result = None\n\n        if self._fget_ is not None:\n            result = self._fget_(obj)\n\n        if result is None:\n            result = getattr(obj, self._attrname(), self._default_)\n\n        # notify parent schema about returned value\n        if isinstance(obj, Schema):\n            obj._getvalue(self, result)\n\n        return result", "response": "Called when the parent element tries to get this property value."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _setter(self, obj, value):\n        if isinstance(value, DynamicValue):  # execute lambda values.\n            fvalue = value()\n\n        else:\n            fvalue = value\n\n        self._validate(data=fvalue, owner=obj)\n\n        if self._fset_ is not None:\n            self._fset_(obj, fvalue)\n\n        else:\n            setattr(obj, self._attrname(), value)\n\n        # notify obj about the new value.\n        if isinstance(obj, Schema):\n            obj._setvalue(self, fvalue)", "response": "Called when the parent element tries to set this property value."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncall when the parent element tries to delete this property value.", "response": "def _deleter(self, obj):\n        \"\"\"Called when the parent element tries to delete this property value.\n\n        :param obj: parent object.\n        \"\"\"\n        if self._fdel_ is not None:\n            self._fdel_(obj)\n\n        else:\n            delattr(obj, self._attrname())\n\n        # notify parent schema about value deletion.\n        if isinstance(obj, Schema):\n            obj._delvalue(self)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _validate(self, data, owner=None):\n        if isinstance(data, DynamicValue):\n            data = data()\n\n        if data is None and not self.nullable:\n            raise ValueError('Value can not be null')\n\n        elif data is not None:\n\n            isdict = isinstance(data, dict)\n\n            for name, schema in iteritems(self.getschemas()):\n\n                if name == 'default':\n                    continue\n\n                if name in self.required:\n                    if (\n                        (isdict and name not in data) or\n                        (not isdict and not hasattr(data, name))\n                    ):\n                        part1 = (\n                            'Mandatory property {0} by {1} is missing in {2}.'.\n                            format(name, self, data)\n                        )\n                        part2 = '{0} expected.'.format(schema)\n                        error = '{0} {1}'.format(part1, part2)\n\n                        raise ValueError(error)\n\n                elif (isdict and name in data) or hasattr(data, name):\n\n                    value = data[name] if isdict else getattr(data, name)\n                    schema._validate(data=value, owner=self)", "response": "Validate input data in returning an empty list if true."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets inner schemas by name.", "response": "def getschemas(cls):\n        \"\"\"Get inner schemas by name.\n\n        :return: ordered dict by name.\n        :rtype: OrderedDict\n        \"\"\"\n        members = getmembers(cls, lambda member: isinstance(member, Schema))\n\n        result = OrderedDict()\n\n        for name, member in members:\n            result[name] = member\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef description(pokemon):\n    r = requests.get('http://pokeapi.co/' + (pokemon.descriptions.values()[0]))\n    desc = eval(r.text)['description'].replace('Pokmon', 'Pok\u00e9mon')\n    return desc", "response": "Return a description of the given Pokemon."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_ability_desc(ability):\n    srcpath = path.dirname(__file__)\n    try:\n        f = open(path.join(srcpath, 'abilities.json'), 'r')\n    except IOError:\n        get_abilities()\n        f = open(path.join(srcpath, 'abilities.json'), 'r')\n    finally:\n        with f:\n            return json.load(f)[ability].encode('utf-8')", "response": "Return the description matching the given ability name. Check abilities. json in the same directory."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_move_data(move):\n    srcpath = path.dirname(__file__)\n    try:\n        f = open(path.join(srcpath, 'moves.json'), 'r')\n    except IOError:\n        get_moves()\n        f = open(path.join(srcpath, 'moves.json'), 'r')\n    finally:\n        with f:\n            return json.load(f)[move]", "response": "Return the index number for the given move name. Check moves. json in the same directory."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef register(self):\n        log.info('Installing ssh key, %s' % self.name)\n        self.consul.create_ssh_pub_key(self.name, self.key)", "response": "Registers SSH key with provider."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef find_existing(self):\n        instances = self.consul.find_servers(self.tags)\n        maxnames = len(instances)\n        while instances:\n            i = instances.pop(0)\n            server_id = i[A.server.ID]\n            if self.namespace.add_if_unique(server_id):\n                log.info('Found existing server, %s' % server_id)\n                self.server_attrs = i\n                break\n            if len(self.namespace.names) >= maxnames:\n                break\n            instances.append(i)", "response": "Searches for existing server instances with matching tags. To match the existing instances must also be running."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef wait_for_running(self):\n        self.server_attrs = self.consul.find_running(\n                self.server_attrs,\n                self.launch_timeout_s,\n                )", "response": "Waits for found servers to be operational"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef create(self):\n        self.server_attrs = self.consul.create_server(\n                \"%s-%s\" % (self.stack.name, self.name),\n                self.disk_image_id,\n                self.instance_type,\n                self.ssh_key_name,\n                tags=self.tags,\n                availability_zone=self.availability_zone,\n                timeout_s=self.launch_timeout_s,\n                security_groups=self.security_groups,\n                **self.provider_extras\n                )\n        log.debug('Post launch delay: %d s' % self.post_launch_delay_s)\n        time.sleep(self.post_launch_delay_s)", "response": "Launches a new server instance."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add_to_inventory(self):\n        if not self.server_attrs:\n            return\n        for addy in self.server_attrs[A.server.PUBLIC_IPS]:\n            self.stack.add_host(addy, self.groups, self.hostvars)", "response": "Adds host to stack inventory"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef define(self):\n        self.server_def = self.consul.define_server(\n                self.name,\n                self.server_tpl,\n                self.server_tpl_rev,\n                self.instance_type,\n                self.ssh_key_name,\n                tags=self.tags,\n                availability_zone=self.availability_zone,\n                security_groups=self.security_groups,\n                **self.provider_extras\n                )\n        log.debug('Defined server %s' % self.server_def)", "response": "Defines a new server."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nfinds existing rule in secgroup.", "response": "def find_existing(self):\n        \"\"\"\n        Finds existing rule in secgroup.\n\n        Populates ``self.create_these_rules`` and ``self.delete_these_rules``.\n\n        \"\"\"\n        sg = self.consul.find_secgroup(self.name)\n\n        current = sg.rules\n        log.debug('Current rules: %s' % current)\n        log.debug('Intended rules: %s' % self.rules)\n        exp_rules = []\n        for rule in self.rules:\n            exp = (\n                    rule[A.secgroup.PROTOCOL],\n                    rule[A.secgroup.FROM],\n                    rule[A.secgroup.TO],\n                    rule[A.secgroup.SOURCE],\n                    )\n            exp_rules.append(exp)\n            if exp in current:\n                del current[exp]\n            else:\n                self.create_these_rules.append(exp)\n\n        self.delete_these_rules.extend(current.itervalues())\n\n        log.debug('Create these rules: %s' % self.create_these_rules)\n        log.debug('Delete these rules: %s' % self.delete_these_rules)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef apply_rule_changes(self):\n        # TODO: add error handling\n        for rule in self.delete_these_rules:\n            self.consul.delete_secgroup_rule(rule)\n            log.info(\"Revoked: %s\" % rule)\n        for rule in self.create_these_rules:\n            args = rule + (self.name, )\n            self.consul.create_secgroup_rule(*args)\n            log.info(\"Authorized: %s\" % str(rule))", "response": "Applies the rules that are defined in the Bang\n        config file to the security group."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef create(self):\n        self.consul.create_bucket(\"%s-%s\" % (self.stack.name, self.name))", "response": "Creates a new bucket"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create(self):\n        self.db_attrs = self.consul.create_db(\n                self.instance_name,\n                self.instance_type,\n                self.admin_username,\n                self.admin_password,\n                db_name=self.db_name,\n                storage_size_gb=self.storage_size,\n                timeout_s=self.launch_timeout_s,\n                )", "response": "Creates a new database"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding db host to stack inventory", "response": "def add_to_inventory(self):\n        \"\"\"Adds db host to stack inventory\"\"\"\n        host = self.db_attrs.pop(A.database.HOST)\n        self.stack.add_host(\n                host,\n                self.groups,\n                self.db_attrs\n                )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate a new load balancer", "response": "def create(self):\n        \"\"\"Creates a new load balancer\"\"\"\n        required_nodes = self._get_required_nodes()\n        self.lb_attrs = self.consul.create_lb(\n                self.instance_name,\n                protocol=self.protocol,\n                port=self.port,\n                nodes=required_nodes,\n                node_port=str(self.backend_port),\n                algorithm=getattr(self, 'algorithm', None)\n                )"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nensures that the LB s nodes match the stack", "response": "def configure_nodes(self):\n        \"\"\"Ensure that the LB's nodes matches the stack\"\"\"\n        # Since load balancing runs after server provisioning,\n        # the servers should already be created regardless of\n        # whether this was a preexisting load balancer or not.\n        # We also have the existing nodes, because add_to_inventory\n        # has been called already\n        required_nodes = self._get_required_nodes()\n\n        log.debug(\n                \"Matching existing lb nodes to required %s (port %s)\"\n                % (\", \".join(required_nodes), self.backend_port)\n                )\n\n        self.consul.match_lb_nodes(\n            self.lb_attrs[A.loadbalancer.ID],\n            self.lb_attrs[A.loadbalancer.NODES_KEY],\n            required_nodes,\n            self.backend_port)\n\n        self.lb_attrs = self.consul.lb_details(\n                self.lb_attrs[A.loadbalancer.ID]\n                )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding lb IPs to stack inventory", "response": "def add_to_inventory(self):\n        \"\"\"Adds lb IPs to stack inventory\"\"\"\n        if self.lb_attrs:\n            self.lb_attrs = self.consul.lb_details(\n                    self.lb_attrs[A.loadbalancer.ID]\n                    )\n            host = self.lb_attrs['virtualIps'][0]['address']\n            self.stack.add_lb_secgroup(self.name, [host], self.backend_port)\n            self.stack.add_host(\n                    host,\n                    [self.name],\n                    self.lb_attrs\n                    )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef register_with_context(self, myname, context):\n\n        if self.context is not None:\n            raise Exception(\"attempted to register BuildTarget with multiple \"\n                            \"BuildContexts\")\n\n        context.register_task(myname, self)\n        self._name = myname\n        self.context = context\n\n        for key in self.data_dependencies:\n            if type(self.data_dependencies[key]) is DeferredDependency:\n                self.data_dependencies[key].parent  = myname\n                self.data_dependencies[key].context = context\n                for tnmame in self.data_dependencies[key].target_names:\n                    context.register_dependency(tnmame, myname)", "response": "registers this build target with a given context"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nevaluate each of the data dependencies of this build target returns the resulting dict", "response": "def resolve_dependencies(self):\n        \"\"\" evaluate each of the data dependencies of this build target,\n            returns the resulting dict\"\"\"\n        return dict(\n            [((key, self.data_dependencies[key])\n                if type(self.data_dependencies[key]) != DeferredDependency\n                else (key, self.data_dependencies[key].resolve()))\n             for key in self.data_dependencies])"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef resolve_and_build(self):\n        pdebug(\"resolving and building task '%s'\" % self.name,\n                groups=[\"build_task\"])\n        indent_text(indent=\"++2\")\n        toret = self.build(**self.resolve_dependencies())\n        indent_text(indent=\"--2\")\n        return toret", "response": "Resolves the dependencies of this build target and builds it"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef process_request(self, request):\n\n        celery_task = getattr(request, '_cache_update_cache', False)\n        if not request.method in ('GET', 'HEAD'):\n            request._cache_update_cache = False\n            return None # Don't bother checking the cache.\n\n        request._cache_update_cache = True\n        if self.should_bypass_cache(request):\n            return None\n\n        response, expired = self.get_cache(request)\n\n        if response is None:\n            return None # No cache information available, need to rebuild.\n\n        # TODO: this logic should be in the task not here but it needs the per_request_middleware\n        if celery_task:\n            if self.should_regenerate(response):\n                return None\n        elif expired:\n            self.send_task(request, response)\n        # don't update right since we're serving from cache\n        request._cache_update_cache = False\n\n        return response", "response": "Checks whether the page is already cached and returns the cached\n        version if available."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef process_response(self, request, response):\n        if not self.should_cache(request, response):\n            # We don't need to update the cache, just return\n            return response \n\n        response = self.patch_headers(response)\n        self.set_cache(request, response)\n\n        return response", "response": "Sets the cache and deals with caching headers if needed"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating an ordered dict of the names and values of key fields.", "response": "def keys(self):\n        \"\"\"Create an ordered dict of the names and values of key fields.\"\"\"\n\n        keys = OrderedDict()\n\n        def order_key(_):\n            (k, v) = _\n            cache_key = getattr(type(self), k)\n            return cache_key.order\n\n        items = [(k, getattr(type(self), k)) for k\n            in dir(type(self))\n        ]\n        items = [(k, v) for (k, v)\n            in items\n            if isinstance(v, Key)\n        ]\n\n        for k, v in sorted(items, key=order_key):\n            keys[k] = getattr(self, k)\n        return keys"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef serialize(self):\n\n        keys = self._all_keys()\n        serdata = {}\n        for fieldname, value in self._data.items():\n            serdata[fieldname] = getattr(type(self), fieldname).python_to_cache(value)\n        return json.dumps(serdata)", "response": "Serialize all the fields into one string."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreconstructing a previously serialized string back into an instance of a CacheModel.", "response": "def deserialize(cls, string):\n        \"\"\"Reconstruct a previously serialized string back into an instance of a ``CacheModel``.\"\"\"\n\n        data = json.loads(string)\n        for fieldname, value in data.items():\n            data[fieldname] = getattr(cls, fieldname).cache_to_python(value)\n        return cls(**data)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef save(self, expires=None):\n\n        if expires is None:\n            expires = self.expires\n        s = self.serialize()\n        key = self._key(self._all_keys())\n        _cache.set(key, s, expires)", "response": "Save a copy of the object into the cache."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget a copy of the type from the cache and reconstruct it.", "response": "def get(cls, **kwargs):\n        \"\"\"Get a copy of the type from the cache and reconstruct it.\"\"\"\n\n        data = cls._get(**kwargs)\n        if data is None:\n            new = cls()\n            new.from_miss(**kwargs)\n            return new\n        return cls.deserialize(data)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting a copy of the type from the cache or create a new one.", "response": "def get_or_create(cls, **kwargs):\n        \"\"\"Get a copy of the type from the cache, or create a new one.\"\"\"\n\n        data = cls._get(**kwargs)\n        if data is None:\n            return cls(**kwargs), True\n        return cls.deserialize(data), False"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef from_miss(self, **kwargs):\n\n        raise type(self).Missing(type(self)(**kwargs).key())", "response": "Called to initialize an instance when it is not found in the cache."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ndelete any existing copy of this object from the cache.", "response": "def delete(self):\n        \"\"\"Deleting any existing copy of this object from the cache.\"\"\"\n\n        key = self._key(self._all_keys())\n        _cache.delete(key)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn distinct chambers. You probably want to prefetch documents__chamber before calling that.", "response": "def chambers(self):\n        \"\"\"\n        Return distinct chambers. You probably want to prefetch\n        documents__chamber before calling that.\n        \"\"\"\n\n        # Use sorted() because using order_by will hit the database no matter\n        # what was prefetched\n        return set(sorted([d.chamber for d in self.documents.all()]))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef encode(password, algorithm, salt, iterations):\n    hash = hashlib.pbkdf2_hmac(digest().name, password.encode(), salt.encode(), iterations)\n    encoded = base64.b64encode(hash).decode('ascii').strip()\n    return \"%s$%d$%s$%s\" % (algorithm, iterations, salt, encoded)", "response": "Encode a password with PBKDF2 algorithm and salt"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef verify(password, encoded):\n    algorithm, iterations, salt, h = split(encoded)\n\n    to_verify = encode(password, algorithm, salt, int(iterations))\n    return hmac.compare_digest(to_verify.encode(), encoded.encode())", "response": "Verify a password with a hashed version of the object."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef split(encoded):\n    algorithm, iterations, salt, h = encoded.split('$', 3)\n    return algorithm, iterations, salt, h", "response": "Split a PBKDF2 hashed Password into algorithm iterations salt and hash\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreplaces the given function with a defer that can be cancelled.", "response": "def yieldefer(function):\n    \"\"\"\n    Replacement for :func:`defer.inlineCallbacks` that supports cancellation.\n    \"\"\"\n    defer.inlineCallbacks\n    return lambda *args, **kwargs: _yielddefer(function, *args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _yielddefer(function, *args, **kwargs):\n    try:\n        retval = function(*args, **kwargs)\n    except:\n        return defer.fail()\n    \n    if isinstance(retval, defer.Deferred):\n        return retval\n    \n    if not (hasattr(retval, '__iter__') and \n            hasattr(retval, 'next') and \n            hasattr(retval, 'send') and \n            hasattr(retval, 'throw')):\n        return defer.succeed(retval)\n    \n    iterator = retval\n    \n    \n    def maybe_deferred(val):\n        # We don't want exceptions to become twisted failures\n        # because exceptions thrown by the generator methods\n        # indicate exceptions thrown by the code _between_ the\n        # yield statements or it indicates the end of the \n        # iteration.\n        if isinstance(val, defer.Deferred):\n            return val\n        else:\n            return defer.succeed(val)\n    \n    def success(value):\n        try:\n            d = maybe_deferred(iterator.send(value))\n            d.addCallbacks(success, fail)\n            return d\n        except StopIteration:\n            return None\n        except defer._DefGen_Return as e:\n            return e.value\n    \n    def fail(failure):\n        try:\n            d = maybe_deferred(failure.throwExceptionIntoGenerator(iterator))\n            #d = iterator.throw(failure.value)\n            d.addCallbacks(success, fail)\n            return d\n        except StopIteration:\n            return None\n        except defer._DefGen_Return as e:\n            return e.value\n        \n    try:\n        d = maybe_deferred(iterator.next())\n        d.addCallbacks(success, fail)\n    except StopIteration:\n        d = defer.succeed(None)\n    except defer._DefGen_Return as e:\n        d = defer.succeed(e.value)\n    except:\n        d = defer.fail()\n        \n    return d", "response": "A generator function that returns a Deferred that resolves the result of the given function."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\noverlay one configuration over another.", "response": "def overlay_config(base, overlay):\n    '''Overlay one configuration over another.\n\n    This overlays `overlay` on top of `base` as follows:\n\n    * If either isn't a dictionary, returns `overlay`.\n    * Any key in `base` not present in `overlay` is present in the\n      result with its original value.\n    * Any key in `overlay` with value :const:`None` is not present in\n      the result, unless it also is :const:`None` in `base`.\n    * Any key in `overlay` not present in `base` and not :const:`None`\n      is present in the result with its new value.\n    * Any key in both `overlay` and `base` with a non-:const:`None` value\n      is recursively overlaid.\n\n    >>> overlay_config({'a': 'b'}, {'a': 'c'})\n    {'a': 'c'}\n    >>> overlay_config({'a': 'b'}, {'c': 'd'})\n    {'a': 'b', 'c': 'd'}\n    >>> overlay_config({'a': {'b': 'c'}},\n    ...                {'a': {'b': 'd', 'e': 'f'}})\n    {'a': {'b': 'd', 'e': 'f'}}\n    >>> overlay_config({'a': 'b', 'c': 'd'}, {'a': None})\n    {'c': 'd'}\n\n    :param dict base: original configuration\n    :param dict overlay: overlay configuration\n    :return: new overlaid configuration\n    :returntype dict:\n\n    '''\n    if not isinstance(base, collections.Mapping):\n        return overlay\n    if not isinstance(overlay, collections.Mapping):\n        return overlay\n    result = dict()\n    for k in iterkeys(base):\n        if k not in overlay:\n            result[k] = base[k]\n    for k, v in iteritems(overlay):\n        if v is not None or (k in base and base[k] is None):\n            if k in base:\n                v = overlay_config(base[k], v)\n            result[k] = v\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef diff_config(base, target):\n    '''Find the differences between two configurations.\n\n    This finds a delta configuration from `base` to `target`, such that\n    calling :func:`overlay_config` with `base` and the result of this\n    function yields `target`.  This works as follows:\n\n    * If both are identical (of any type), returns an empty dictionary.\n    * If either isn't a dictionary, returns `target`.\n    * Any key in `target` not present in `base` is included in the output\n      with its value from `target`.\n    * Any key in `base` not present in `target` is included in the output\n      with value :const:`None`.\n    * Any keys present in both dictionaries are recursively merged.\n\n    >>> diff_config({'a': 'b'}, {})\n    {'a': None}\n    >>> diff_config({'a': 'b'}, {'a': 'b', 'c': 'd'})\n    {'c': 'd'}\n\n    :param dict base: original configuration\n    :param dict target: new configuration\n    :return: overlay configuration\n    :returntype dict:\n\n    '''\n    if not isinstance(base, collections.Mapping):\n        if base == target:\n            return {}\n        return target\n    if not isinstance(target, collections.Mapping):\n        return target\n    result = dict()\n    for k in iterkeys(base):\n        if k not in target:\n            result[k] = None\n    for k, v in iteritems(target):\n        if k in base:\n            merged = diff_config(base[k], v)\n            if merged != {}:\n                result[k] = merged\n        else:\n            result[k] = v\n    return result", "response": "Find the differences between two configurations."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\npopulating the message with the values in msg.", "response": "def populate_instance(msg, inst):\n    \"\"\"\n    :param msg: contains the values to use to populate inst.\n    :param inst: message class instance to populate.\n    :return: an instance of the provided message class, with its fields populated according to the values in msg\n    \"\"\"\n    return _to_inst(msg, type(inst).__name__, type(inst).__name__, inst)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get(self, request, *args, **kwargs):\n        kwargs['pk'] = request.user.id\n        self.kwargs['pk'] = request.user.id\n        return super().get(request, *args, **kwargs)", "response": "Add user id to kwargs"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nadd user id to kwargs", "response": "def post(self, request, *args, **kwargs):\n        \"\"\"Add user id to kwargs\"\"\"\n        kwargs['pk'] = request.user.id\n        self.kwargs['pk'] = request.user.id\n        return super().post(request, *args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef pformat(tree):\n    if tree.empty():\n        return ''\n    buf = six.StringIO()\n    for line in _pformat(tree.root, 0):\n        buf.write(line + \"\\n\")\n    return buf.getvalue().strip()", "response": "Recursively formats a tree into a nice string representation."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef path_iter(self, include_self=True):\n        if include_self:\n            node = self\n        else:\n            node = self.parent\n        while node is not None:\n            yield node\n            node = node.parent", "response": "Yields back the path from this node to the root node."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn how many children of this node have.", "response": "def child_count(self, only_direct=True):\n        \"\"\"Returns how many children this node has, either only the direct\n        children of this node or inclusive of all children nodes of this node.\n        \"\"\"\n        if not only_direct:\n            count = 0\n            for _node in self.dfs_iter():\n                count += 1\n            return count\n        return len(self._children)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nfind the child index of a given item searchs in added order.", "response": "def index(self, item):\n        \"\"\"Finds the child index of a given item, searchs in added order.\"\"\"\n        index_at = None\n        for (i, child) in enumerate(self._children):\n            if child.item == item:\n                index_at = i\n                break\n        if index_at is None:\n            raise ValueError(\"%s is not contained in any child\" % (item))\n        return index_at"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef publish_state(self, state):\n        message = json.dumps({'state': {'reported': state}})\n        self.client.publish(self.topic, message)\n        self._state = state", "response": "Publishes the state of the object to the IoT."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nam this line the start of a new k - point block?", "response": "def _is_kpoint(line):\n    \"\"\"Is this line the start of a new k-point block\"\"\"\n    # Try to parse the k-point; false otherwise\n    toks = line.split()\n    # k-point header lines have 4 tokens\n    if len(toks) != 4:\n        return False\n\n    try:\n        # K-points are centered at the origin\n        xs = [float(x) for x in toks[:3]]\n        # Weights are in [0,1]\n        w = float(toks[3])\n        return all(abs(x) <= 0.5 for x in xs) and w >= 0.0 and w <= 1.0\n    except ValueError:\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _parse_kpoint(line, lines):\n    toks = line.split()\n    kpoint = [float(x) for x in toks[:3]]\n    weight = float(toks[-1])\n    newline = next(lines)\n\n    bands_up = []\n    occ_up = []\n    bands_down = []\n    occ_down = []\n    ispin = None\n\n    while len(newline.split()) > 0:\n        toks = newline.split()\n        if ispin is None:\n            # there are two spins if there are 5 columns (two spin energies and occupancies) or\n            # very probably if there are 3 columns and the last column's first value isn't 1.0\n            # (which would be the occupancy of the lowest energy level)\n            ispin = (len(toks) == 5) or (len(toks) == 3 and abs(float(toks[2]) - 1.0) > 1.0e-4)\n\n        if len(toks) == 2:\n            bands_up.append(float(toks[1]))\n        elif len(toks) == 3 and not ispin:\n            bands_up.append(float(toks[1]))\n            occ_up.append(float(toks[2]))\n        elif len(toks) == 3 and ispin:\n            bands_up.append(float(toks[1]))\n            bands_down.append(float(toks[2]))\n        elif len(toks) == 5 and ispin:\n            bands_up.append(float(toks[1]))\n            bands_down.append(float(toks[2]))\n            occ_up.append(float(toks[3]))\n            occ_down.append(float(toks[4]))\n        else:\n            raise ValueError(\"Encountered {} when parsing k-point\".format(newline))\n        newline = next(lines)\n\n    res = {\"kpoint\": kpoint, \"weight\": weight}\n    if len(bands_down) > 0:\n        res[\"energies\"] = list(zip(bands_up, bands_down))\n    else:\n        res[\"energies\"] = list(zip(bands_up))\n\n    if len(occ_down) > 0:\n        res[\"occupancies\"] = list(zip(occ_up, occ_down))\n    elif len(occ_up) > 0:\n        res[\"occupancies\"] = list(zip(occ_up))\n      \n    return res", "response": "Parse the k - point and then continue to iterate over the band energies and occupations"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating a pseudo connection to the iRODS baton binaries directory.", "response": "def connect_to_irods_with_baton(baton_binaries_directory: str, skip_baton_binaries_validation: bool=False) \\\n        -> Connection:\n    \"\"\"\n    Convenience method to create a pseudo connection to iRODS.\n    :param baton_binaries_directory: see `Connection.__init__`\n    :param skip_baton_binaries_validation: see `Connection.__init__`\n    :return: pseudo connection to iRODS\n    \"\"\"\n    return Connection(baton_binaries_directory, skip_baton_binaries_validation)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the enum that matches the op code", "response": "def parse(cls, op):\n        \"\"\"Gets the enum for the op code\n\n        Args:\n            op: value of the op code (will be casted to int)\n\n        Returns:\n            The enum that matches the op code\n        \"\"\"\n        for event in cls:\n            if event.value == int(op):\n                return event\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nrunning the thread This method handles sending the heartbeat to the Discord websocket server, so the connection can remain open and the bot remain online for those commands that require it to be. Args: None", "response": "def run(self):\n        \"\"\"Runs the thread\n\n        This method handles sending the heartbeat to the Discord websocket server, so the connection\n        can remain open and the bot remain online for those commands that require it to be.\n\n        Args:\n            None\n        \"\"\"\n        while self.should_run:\n            try:\n                self.logger.debug('Sending heartbeat, seq ' + last_sequence)\n                self.ws.send(json.dumps({\n                    'op': 1,\n                    'd': last_sequence\n                }))\n            except Exception as e:\n                self.logger.error(f'Got error in heartbeat: {str(e)}')\n            finally:\n                elapsed = 0.0\n                while elapsed < self.interval and self.should_run:\n                    time.sleep(self.TICK_INTERVAL)\n                    elapsed += self.TICK_INTERVAL"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting up the internal logger object.", "response": "def _setup_logger(self, logging_level: int, log_to_console: bool):\n        \"\"\"Sets up the internal logger\n\n        Args:\n            logging_level: what logging level to use\n            log_to_console: whether or not to log to the console\n        \"\"\"\n        self.logger = logging.getLogger('discord')\n        self.logger.handlers = []\n        self.logger.setLevel(logging_level)\n        formatter = logging.Formatter(style='{', fmt='{asctime} [{levelname}] {message}', datefmt='%Y-%m-%d %H:%M:%S')\n        file_handler = logging.FileHandler('pycord.log')\n        file_handler.setFormatter(formatter)\n        file_handler.setLevel(logging_level)\n        self.logger.addHandler(file_handler)\n        if log_to_console:\n            stream_handler = logging.StreamHandler(sys.stdout)\n            stream_handler.setFormatter(formatter)\n            stream_handler.setLevel(logging_level)\n            self.logger.addHandler(stream_handler)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _query(self, path: str, method: str, data: Dict[str, Any]=None, expected_status: int = 200) \\\n            -> Union[List[Dict[str, Any]], Dict[str, Any], None]:\n        \"\"\"Make an HTTP request\n\n        Args:\n            path: the URI path (not including the base url, start with\n                the first uri segment, like 'users/...')\n            method: the HTTP method to use (GET, POST, PATCH, ...)\n            data: the data to send as JSON data\n            expected_status: expected HTTP status; other statuses\n                received will raise an Exception\n\n        Returns:\n            Data from the endpoint's response\n        \"\"\"\n        url = Pycord.url_base + path\n        self.logger.debug(f'Making {method} request to \"{url}\"')\n        if method == 'GET':\n            r = requests.get(url, headers=self._build_headers())\n        elif method == 'POST':\n            r = requests.post(url, headers=self._build_headers(), json=data)\n            r = requests.get(url, headers=self._build_headers())\n        elif method == 'PATCH':\n            r = requests.patch(url, headers=self._build_headers(), json=data)\n        else:\n            raise ValueError(f'Unknown HTTP method {method}')\n        self.logger.debug(f'{method} response from \"{url}\" was \"{r.status_code}\"')\n        if r.status_code != expected_status:\n            raise ValueError(f'Non-{expected_status} {method} response from Discord API ({r.status_code}): {r.text}')\n        if expected_status == 200:\n            return r.json()\n        return None", "response": "Make an HTTP request to the Discord API."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _ws_on_close(self, ws: websocket.WebSocketApp):\n        self.connected = False\n        self.logger.error('Websocket closed')\n        self._reconnect_websocket()", "response": "Callback for closing the websocket connection"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncalls this method to make the connection to the Discord websocket This method is not blocking, so you'll probably want to call it after initializating your Pycord object, and then move on with your code. When you want to block on just maintaining the websocket connection, then call ``keep_running``, and it'll block until your application is interrupted. Args: None", "response": "def connect_to_websocket(self):\n        \"\"\"Call this method to make the connection to the Discord websocket\n\n        This method is not blocking, so you'll probably want to call it after\n        initializating your Pycord object, and then move on with your code. When\n        you want to block on just maintaining the websocket connection, then call\n        ``keep_running``, and it'll block until your application is interrupted.\n\n        Args:\n            None\n        \"\"\"\n        self.logger.info('Making websocket connection')\n        try:\n            if hasattr(self, '_ws'):\n                self._ws.close()\n        except:\n            self.logger.debug('Couldn\\'t terminate previous websocket connection')\n        self._ws = websocket.WebSocketApp(\n            self._get_websocket_address() + '?v=6&encoding=json',\n            on_message=self._ws_on_message,\n            on_error=self._ws_on_error,\n            on_close=self._ws_on_close\n        )\n        self._ws.on_open = self._ws_on_open\n        self._ws_run_forever_wrapper = WebSocketRunForeverWrapper(self.logger, self._ws)\n        self._ws_run_forever_wrapper.start()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndisconnect from the websocket", "response": "def disconnect_from_websocket(self):\n        \"\"\"Disconnects from the websocket\n\n        Args:\n            None\n        \"\"\"\n        self.logger.warning('Disconnecting from websocket')\n        self.logger.info('Stopping keep alive thread')\n        self._ws_keep_alive.stop()\n        self._ws_keep_alive.join()\n        self.logger.info('Stopped keep alive thread')\n        try:\n            self.logger.warning('Disconnecting from websocket')\n            self._ws.close()\n            self.logger.info('Closed websocket connection')\n        except:\n            self.logger.debug('Couldn\\'t terminate previous websocket connection')"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_status(self, name: str = None):\n        game = None\n        if name:\n            game = {\n                'name': name\n            }\n        payload = {\n            'op': WebSocketEvent.STATUS_UPDATE.value,\n            'd': {\n                'game': game,\n                'status': 'online',\n                'afk': False,\n                'since': 0.0\n            }\n        }\n        data = json.dumps(payload, indent=2)\n        self.logger.debug(f'Sending status update payload: {data}')\n        self._ws.send(data)", "response": "Updates the bot s status with the given game name."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets a guild s information by its id.", "response": "def get_guild_info(self, id: str) -> Dict[str, Any]:\n        \"\"\"Get a guild's information by its id\n\n        Args:\n            id: snowflake id of the guild\n\n        Returns:\n            Dictionary data for the guild API object\n\n            Example:\n                {\n                    \"id\": \"41771983423143937\",\n                    \"name\": \"Discord Developers\",\n                    \"icon\": \"SEkgTU9NIElUUyBBTkRSRUkhISEhISEh\",\n                    \"splash\": null,\n                    \"owner_id\": \"80351110224678912\",\n                    \"region\": \"us-east\",\n                    \"afk_channel_id\": \"42072017402331136\",\n                    \"afk_timeout\": 300,\n                    \"embed_enabled\": true,\n                    \"embed_channel_id\": \"41771983444115456\",\n                    \"verification_level\": 1,\n                    \"roles\": [],\n                    \"emojis\": [],\n                    \"features\": [\"INVITE_SPLASH\"],\n                    \"unavailable\": false\n                }\n        \"\"\"\n        return self._query(f'guilds/{id}', 'GET')"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_channels_in(self, guild_id: str) -> List[Dict[str, Any]]:\n        return self._query(f'guilds/{guild_id}/channels', 'GET')", "response": "Get a list of channels in a guild."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget a chanel s information by its id", "response": "def get_channel_info(self, id: str) -> Dict[str, Any]:\n        \"\"\"Get a chanel's information by its id\n\n        Args:\n            id: snowflake id of the chanel\n\n        Returns:\n            Dictionary data for the chanel API object\n\n            Example:\n                {\n                    \"id\": \"41771983423143937\",\n                    \"guild_id\": \"41771983423143937\",\n                    \"name\": \"general\",\n                    \"type\": 0,\n                    \"position\": 6,\n                    \"permission_overwrites\": [],\n                    \"topic\": \"24/7 chat about how to gank Mike #2\",\n                    \"last_message_id\": \"155117677105512449\"\n                }\n        \"\"\"\n        return self._query(f'channels/{id}', 'GET')"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_guild_members(self, guild_id: int) -> List[Dict[str, Any]]:\n        return self._query(f'guilds/{guild_id}/members', 'GET')", "response": "Get a list of members in a guild."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget a guild member by their id.", "response": "def get_guild_member_by_id(self, guild_id: int, member_id: int) -> Dict[str, Any]:\n        \"\"\"Get a guild member by their id\n\n        Args:\n            guild_id: snowflake id of the guild\n            member_id: snowflake id of the member\n\n        Returns:\n            Dictionary data for the guild member.\n\n            Example:\n                {\n                    \"id\": \"41771983423143937\",\n                    \"name\": \"Discord Developers\",\n                    \"icon\": \"SEkgTU9NIElUUyBBTkRSRUkhISEhISEh\",\n                    \"splash\": null,\n                    \"owner_id\": \"80351110224678912\",\n                    \"region\": \"us-east\",\n                    \"afk_channel_id\": \"42072017402331136\",\n                    \"afk_timeout\": 300,\n                    \"embed_enabled\": true,\n                    \"embed_channel_id\": \"41771983444115456\",\n                    \"verification_level\": 1,\n                    \"roles\": [\n                        \"41771983423143936\",\n                        \"41771983423143937\",\n                        \"41771983423143938\"\n                    ],\n                    \"emojis\": [],\n                    \"features\": [\"INVITE_SPLASH\"],\n                    \"unavailable\": false\n                }\n        \"\"\"\n        return self._query(f'guilds/{guild_id}/members/{member_id}', 'GET')"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_all_guild_roles(self, guild_id: int) -> List[Dict[str, Any]]:\n        return self._query(f'guilds/{guild_id}/roles', 'GET')", "response": "Gets all the roles in a guild."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting the roles of a member in a guild.", "response": "def set_member_roles(self, guild_id: int, member_id: int, roles: List[int]):\n        \"\"\"Set the member's roles\n\n        This method takes a list of **role ids** that you want the user to have. This\n        method will **overwrite** all of the user's current roles with the roles in\n        the passed list of roles.\n\n        When calling this method, be sure that the list of roles that you're setting\n        for this user is complete, not just the roles that you want to add or remove.\n        For assistance in just adding or just removing roles, set the ``add_member_roles``\n        and ``remove_member_roles`` methods.\n\n        Args:\n            guild_id: snowflake id of the guild\n            member_id: snowflake id of the member\n            roles: list of snowflake ids of roles to set\n        \"\"\"\n        self._query(f'guilds/{guild_id}/members/{member_id}', 'PATCH', {'roles': roles}, expected_status=204)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadd roles to a member s internal role list", "response": "def add_member_roles(self, guild_id: int, member_id: int, roles: List[int]):\n        \"\"\"Add roles to a member\n\n        This method takes a list of **role ids** that you want to give to the user,\n        on top of whatever roles they may already have. This method will fetch\n        the user's current roles, and add to that list the roles passed in. The\n        user's resulting list of roles will not contain duplicates, so you don't have\n        to filter role ids to this method (as long as they're still roles for this guild).\n\n        This method differs from ``set_member_roles`` in that this method ADDS roles\n        to the user's current role list. ``set_member_roles`` is used by this method.\n\n        Args:\n            guild_id: snowflake id of the guild\n            member_id: snowflake id of the member\n            roles: list of snowflake ids of roles to add\n        \"\"\"\n        current_roles = [role for role in self.get_guild_member_by_id(guild_id, member_id)['roles']]\n        roles.extend(current_roles)\n        new_list = list(set(roles))\n        self.set_member_roles(guild_id, member_id, new_list)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nadds roles to a member This method takes a list of **role ids** that you want to strip from the user, subtracting from whatever roles they may already have. This method will fetch the user's current roles, and add to that list the roles passed in. This method will only remove roles from the user that they have at the time of execution, so you don't need to check that the user has the roles you're trying to remove from them (as long as those roles are valid roles for this guild). This method differs from ``set_member_roles`` in that this method REMOVES roles from the user's current role list. ``set_member_roles`` is used by this method. Args: guild_id: snowflake id of the guild member_id: snowflake id of the member roles: list of snowflake ids of roles to remove", "response": "def remove_member_roles(self, guild_id: int, member_id: int, roles: List[int]):\n        \"\"\"Add roles to a member\n\n        This method takes a list of **role ids** that you want to strip from the user,\n        subtracting from whatever roles they may already have. This method will fetch\n        the user's current roles, and add to that list the roles passed in. This method\n        will only remove roles from the user that they have at the time of execution,\n        so you don't need to check that the user has the roles you're trying to remove\n        from them (as long as those roles are valid roles for this guild).\n\n        This method differs from ``set_member_roles`` in that this method REMOVES roles\n        from the user's current role list. ``set_member_roles`` is used by this method.\n\n        Args:\n            guild_id: snowflake id of the guild\n            member_id: snowflake id of the member\n            roles: list of snowflake ids of roles to remove\n        \"\"\"\n        current_roles = [role for role in self.get_guild_member_by_id(guild_id, member_id)['roles']]\n        new_list = [role for role in current_roles if role not in roles]\n        self.set_member_roles(guild_id, member_id, new_list)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsending a message to a channel", "response": "def send_message(self, id: str, message: str) -> Dict[str, Any]:\n        \"\"\"Send a message to a channel\n\n        For formatting options, see the documentation:\n            https://discordapp.com/developers/docs/resources/channel#create-message\n\n        Args:\n            id: channel snowflake id\n            message: your message (string)\n\n        Returns:\n            Dictionary object of the new message\n        \"\"\"\n        if not self.connected:\n            raise ValueError('Websocket not connected')\n        return self._query(f'channels/{id}/messages', 'POST', {'content': message})"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef command(self, name: str) -> Callable:\n        def inner(f: Callable):\n            self._commands.append((name, f))\n        return inner", "response": "Decorator to register a command to be called when someone does not want to send a message to the Celeo."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef register_command(self, name: str, f: Callable):\n        self._commands.append((name, f))", "response": "Registers an existing callable object as a command callback"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nparse the given data file and returns a pandas DataFrame.", "response": "def prepare_csv_to_dataframe(data_file, config, use_target=True):\n    \"\"\"\n    Parses the given data file following the data model of the given configuration.\n    @return: pandas DataFrame\n    \"\"\"\n    names, dtypes = [], []\n    model = config.get_data_model()\n    for feature in model:\n        assert feature.get_name() not in names, \"Two features can't have the same name.\"\n        if not use_target and feature.is_target():\n            continue\n        names.append(feature.get_name())\n    data = pd.read_csv(data_file, names=names)\n\n    transform_categorical_features(config, data, use_target)\n\n    return data"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef forwards(self, orm):\n        \"Write your forwards methods here.\"\n        for tag in orm['tagging.Tag'].objects.all():\n            if tag.tagtitle_set.all().count() == 0:\n                orm['tagging_translated.TagTitle'].objects.create(\n                    trans_name=tag.name, tag=tag, language='en')", "response": "Write your forwards methods here."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef resolve_model(model, fields):\n    for (f, v) in fields:\n        if v is not None:\n            try:\n                kwargs = {f: v}\n                obj = model.objects.get(**kwargs)\n                return obj\n            except model.DoesNotExist:\n                pass\n            except model.MultipleObjectsReturned:\n                pass\n    raise model.DoesNotExist()", "response": "Resolves the model class with the given fields."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef kps_callback(sender, instance, created, raw, **kwargs):\n    ''' create KeyPublicationStatus object for Keys/Apis '''\n    if created and not raw:\n        if sender == Api:\n            for key in Key.objects.all():\n                KeyPublicationStatus.objects.create(key=key, api=instance)\n        elif isinstance(instance, Key):\n            for api in Api.objects.all():\n                KeyPublicationStatus.objects.create(key=instance, api=api)", "response": "Callback function for creating KeyPublicationStatus objects for Keys and Apis"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nmark all the items in the cache as updating", "response": "def mark_for_update(self):\n        '''\n            Note that a change has been made so all Statuses need update\n        '''\n        self.pub_statuses.exclude(status=UNPUBLISHED).update(status=NEEDS_UPDATE)\n        push_key.delay(self)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_cookie(self, key, value, domain=None, path='/', secure=False,\n                   httponly=True):\n        \"\"\"Set a cookie.\n\n        Args:\n            key (:obj:`str`): Cookie name\n            value (:obj:`str`): Cookie value\n            domain (:obj:`str`): Cookie domain\n            path (:obj:`str`): Cookie value\n            secure (:obj:`bool`): True if secure, False otherwise\n            httponly (:obj:`bool`): True if it's a HTTP only cookie, False\n                otherwise\n        \"\"\"\n        self._cookies[key] = value\n        if domain:\n            self._cookies[key]['domain'] = domain\n        if path:\n            self._cookies[key]['path'] = path\n        if secure:\n            self._cookies[key]['secure'] = secure\n        if httponly:\n            self._cookies[key]['httponly'] = httponly", "response": "Set a cookie.\n\n        Args:\n            key (:obj:`str`): Cookie name\n            value (:obj:`str`): Cookie value\n            domain (:obj:`str`): Cookie domain\n            path (:obj:`str`): Cookie value\n            secure (:obj:`bool`): True if secure, False otherwise\n            httponly (:obj:`bool`): True if it's a HTTP only cookie, False\n                otherwise"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting the content for the response.", "response": "def set_content(self, content, content_length=None):\n        \"\"\"Set content for the response.\n\n        Args:\n            content (:obj:`str` or :obj:`iterable`): Response content. Can be\n                either unicode or raw bytes. When returning large content,\n                an iterable (or a generator) can be used to avoid loading\n                entire content into the memory.\n            content_length (:obj:`int`, optional): Content length. Length will\n                be determined if not set. If content is an iterable, it's a\n                good practise to set the content length.\n        \"\"\"\n        if content_length is not None:\n            self._content_length = content_length\n        self._content = content"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nbakes the response and returns the content.", "response": "def bake(self, start_response):\n        \"\"\"Bakes the response and returns the content.\n\n        Args:\n            start_response (:obj:`callable`): Callback method that accepts\n                status code and a list of tuples (pairs) containing headers'\n                key and value respectively.\n        \"\"\"\n        if isinstance(self._content, six.text_type):\n            self._content = self._content.encode('utf8')\n\n        if self._content_length is None:\n            self._content_length = len(self._content)\n\n        self._headers[HttpResponseHeaders.CONTENT_LENGTH] = \\\n            str(self._content_length)\n        headers = list(self._headers.items())\n        cookies = [(HttpResponseHeaders.SET_COOKIE, v.OutputString())\n                   for _, v in self._cookies.items()]\n\n        if len(cookies):\n            headers = list(headers) + cookies\n        start_response(self._status_code, headers)\n\n        if isinstance(self._content, six.binary_type):\n            return [self._content]\n\n        return self._content"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset a redirect response.", "response": "def set_redirect(self, url, status=HttpStatusCodes.HTTP_303):\n        \"\"\"Helper method to set a redirect response.\n\n        Args:\n            url (:obj:`str`): URL to redirect to\n            status (:obj:`str`, optional): Status code of the response\n        \"\"\"\n        self.set_status(status)\n        self.set_content('')\n        self.set_header(HttpResponseHeaders.LOCATION, url)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef copy_func(f, name=None):\n    '''\n    return a function with same code, globals, defaults, closure, and \n    name (or provide a new name)\n    '''\n    fn = types.FunctionType(f.__code__, f.__globals__, name or f.__name__,\n                            f.__defaults__, f.__closure__)\n    # in case f was given attrs (note this dict is a shallow copy):\n    fn.__dict__.update(f.__dict__)\n    return fn", "response": "Returns a copy of a function f."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef find_rak():\n    if hasattr(current_app, 'rak'):\n        return getattr(current_app, 'rak')\n    else:\n        if hasattr(current_app, 'blueprints'):\n            blueprints = getattr(current_app, 'blueprints')\n            for blueprint_name in blueprints:\n                if hasattr(blueprints[blueprint_name], 'rak'):\n                    return getattr(blueprints[blueprint_name], 'rak')", "response": "Find our instance of Rak navigating Local s and possible blueprints."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef init_app(self, app):\n        if self._route is None:\n            raise TypeError(\n                \"route is a required argument when app is not None\")\n\n        app.rak = self\n        app.add_url_rule(self._route, view_func=getattr(self, self._view_name), methods=['POST'])", "response": "Initializes Ask app by setting configuration variables and maps RAK route to a flask view."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef init_blueprint(self, blueprint):\n        if self._route is not None:\n            raise TypeError(\"route cannot be set when using blueprints!\")\n\n        blueprint.rak = self\n        blueprint.add_url_rule(\"\", view_func=getattr(self, self._view_name), methods=['POST'])", "response": "Initialize a Flask Blueprint instance with the access\n        from the application config."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nprovides appropiate parameters to the intent functions.", "response": "def _map_intent_to_view_func(self, intent):\n        \"\"\"Provides appropiate parameters to the intent functions.\"\"\"\n        if intent.label in self._intent_view_funcs:\n            view_func = self._intent_view_funcs[intent.label]\n        elif self._default_intent_view_func is not None:\n            view_func = self._default_intent_view_func\n        else:\n            raise NotImplementedError(\n                'Intent \"{}\" not found and no default intent specified.'.format(intent.name))\n\n        argspec = inspect.getargspec(view_func)\n        arg_names = argspec.args\n        arg_values = self._map_params_to_view_args(intent.label, arg_names)\n\n        return partial(view_func, *arg_values)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nwraps around popen that handles encoding and encoding of arguments and passing them to subprocess. Popen", "response": "def popen(fn, *args, **kwargs) -> subprocess.Popen:\n    \"\"\"\n    Please ensure you're not killing the process before it had started properly\n    :param fn:\n    :param args:\n    :param kwargs:\n    :return:\n    \"\"\"\n\n    args = popen_encode(fn, *args, **kwargs)\n\n    logging.getLogger(__name__).debug('Start %s', args)\n\n    p = subprocess.Popen(args)\n    return p"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef make_anchor_id(self):\n        result = re.sub(\n            '[^a-zA-Z0-9_]', '_', self.user + '_' + self.timestamp)\n        return result", "response": "Return string to use as URL anchor for this comment."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nmakes URL to this comment. :arg my_request: The request object where this comment is seen from. :arg anchor_id=None: Optional anchor id. If None, we use self.make_anchor_id() ~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~- :returns: String URL to this comment. ~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~- PURPOSE: Be able to create links to this comment.", "response": "def make_url(self, my_request, anchor_id=None):\n        \"\"\"Make URL to this comment.\n\n        :arg my_request:  The request object where this comment is seen from.\n\n        :arg anchor_id=None:    Optional anchor id. If None, we use\n                                self.make_anchor_id()\n\n        ~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-\n\n        :returns:       String URL to this comment.\n\n        ~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-\n\n        PURPOSE:        Be able to create links to this comment.\n\n        \"\"\"\n        if anchor_id is None:\n            anchor_id = self.make_anchor_id()\n        result = '{}?{}#{}'.format(\n            my_request.path, urllib.parse.urlencode(my_request.args),\n            anchor_id)\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef to_dict(self):\n        jdict = {\n            'user': self.user,\n            'summary': self.summary,\n            'body': self.body,\n            'markup': self.markup,\n            'url': self.url,\n            'timestamp': self.timestamp\n            }\n        return jdict", "response": "Return description of self in dict format."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the display mode for the given object.", "response": "def set_display_mode(self, mytz, fmt):\n        \"\"\"Set the display mode for self.\n\n        :arg mytz:        A pytz.timezone object.\n\n        :arg fmt:         A format string for strftime.\n\n        ~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-\n\n        PURPOSE:        Modifies self.display_timestamp to first parse\n                        self.timestamp and then format according to given\n                        timezone and format string.\n\n        \"\"\"\n        my_stamp = dateutil.parser.parse(self.timestamp)\n        tz_stamp = my_stamp.astimezone(\n            mytz) if my_stamp.tzinfo is not None else my_stamp\n        self.display_timestamp = tz_stamp.strftime(fmt)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting the display mode of the items in the object with given args.", "response": "def set_display_mode(self, mytz, fmt=\"%Y-%m-%d %H:%M:%S %Z%z\"):\n        \"\"\"Call set_display_mode on items in self.comments with given args.\n\n        :arg mytz:      A pytz.timezone object.\n\n        :arg fmt=\"%Y-%m-%d%H:%M:%S%Z%z\":   Optional format string.\n\n        ~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-\n\n        PURPOSE:        Call set_display_mode(mytz, fmt) for everything in\n                        self.comments.\n\n        \"\"\"\n        for item in self.comments:\n            item.set_display_mode(mytz, fmt)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_comment_section(self, force_reload=False, reverse=False):\n        if self.content is not None and not force_reload:\n            return self.content\n        if self.thread_id is None:\n            self.thread_id = self.lookup_thread_id()\n        self.content = self.lookup_comments(reverse=reverse)\n\n        return self.content", "response": "Get the CommentSection instance for the current thread."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nvalidates a proposed attachment location.", "response": "def validate_attachment_location(self, location):\n        \"\"\"Validate a proposed attachment location.\n\n        :arg location:     String representing location to put attachment.\n\n        ~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-\n\n        PURPOSE:   Raises an exception if attachment location is bad.\n                   By default, this just forces reasonable characters.\n                   Sub-classes can override as desired.\n\n        \"\"\"\n        if not re.compile(self.valid_attachment_loc_re).match(location):\n            raise ValueError(\n                'Bad chars in attachment location. Must match %s' % (\n                    self.valid_attachment_loc_re))"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nimplements as required by parent to lookup comments in file system.", "response": "def lookup_comments(self, reverse=False):\n        \"Implement as required by parent to lookup comments in file system.\"\n\n        comments = []\n        if self.thread_id is None:\n            self.thread_id = self.lookup_thread_id()\n        path = self.thread_id\n        with open(self.thread_id, 'r', newline='') as fdesc:\n            reader = csv.reader(fdesc)\n            header = reader.__next__()\n            assert header == self.header\n            for num, line in enumerate(reader):\n                if not line:\n                    continue\n                assert len(line) == len(header), (\n                    'Line %i in path %s misformatted' % (num+1, path))\n                line_kw = dict(zip(header, line))\n                comments.append(SingleComment(**line_kw))\n        if reverse:\n            comments = list(reversed(comments))\n\n        return CommentSection(comments)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nimplements create_thread as required by parent.", "response": "def create_thread(self, body):\n        \"\"\"Implement create_thread as required by parent.\n\n        This basically just calls add_comment with allow_create=True\n        and then builds a response object to indicate everything is fine.\n        \"\"\"\n        self.add_comment(body, allow_create=True)\n        the_response = Response()\n        the_response.code = \"OK\"\n        the_response.status_code = 200"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nimplements as required by parent to store comment in CSV file.", "response": "def add_comment(self, body, allow_create=False, allow_hashes=False,\n                    summary=None):\n        \"Implement as required by parent to store comment in CSV file.\"\n\n        if allow_hashes:\n            raise ValueError('allow_hashes not implemented for %s yet' % (\n                self.__class__.__name__))\n        if self.thread_id is None:\n            self.thread_id = self.lookup_thread_id()\n        if not os.path.exists(self.thread_id):\n            if not allow_create:\n                raise KeyError(self.topic)\n            with open(self.thread_id, 'a', newline='') as fdesc:\n                csv.writer(fdesc).writerow(self.header)\n\n        with open(self.thread_id, 'a', newline='') as fdesc:\n            writer = csv.writer(fdesc)\n            writer.writerow([self.user, datetime.datetime.utcnow(), summary,\n                             body, ''])"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef pascal_row(n):\n    result = [1]\n    x, numerator = 1, n\n    for denominator in range(1, n // 2 + 1):\n        x *= numerator\n        x /= denominator\n        result.append(x)\n        numerator -= 1\n    if n & 1 == 0:\n        result.extend(reversed(result[:-1]))\n    else:\n        result.extend(reversed(result))\n    return result", "response": "Returns n - th row of Pascal s triangle\n   "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nmake a list of all beziers of the given number of times.", "response": "def make_bezier(n):\n    \"\"\" Bezier curves:\n        http://en.wikipedia.org/wiki/B%C3%A9zier_curve#Generalization\n    \"\"\"\n    try:\n        return beziers[n]\n    except KeyError:\n        combinations = pascal_row(n - 1)\n        result = []\n        for t in tsequence:\n            tpowers = (t ** i for i in range(n))\n            upowers = ((1 - t) ** i for i in range(n - 1, -1, -1))\n            coefs = [c * a * b for c, a, b in zip(combinations,\n                                                  tpowers, upowers)]\n            result.append(coefs)\n        beziers[n] = result\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create_salt(length: int=128) -> bytes:\n    return b''.join(bytes([SystemRandom().randint(0, 255)]) for _ in range(length))", "response": "Create a new salt"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets a Redis connection instance", "response": "def __get_connection(self) -> redis.Redis:\n        \"\"\"\n        Get a Redis connection\n\n        :return: Redis connection instance\n        :rtype: redis.Redis\n        \"\"\"\n\n        if self.__redis_use_socket:\n            r = redis.from_url(\n                'unix://{:s}?db={:d}'.format(\n                    self.__redis_host,\n                    self.__redis_db\n                )\n            )\n        else:\n            r = redis.from_url(\n                'redis://{:s}:{:d}/{:d}'.format(\n                    self.__redis_host,\n                    self.__redis_port,\n                    self.__redis_db\n                )\n            )\n\n        if BlackRed.Settings.REDIS_AUTH is not None:\n            r.execute_command('AUTH {:s}'.format(BlackRed.Settings.REDIS_AUTH))\n        return r"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _encode_item(self, item: str) -> str:\n        assert item is not None\n        if not self.__redis_conf['anonymization']:\n            return item\n        connection = self.__get_connection()\n        salt = connection.get(self.__redis_conf['salt_key'])\n        if salt is None:\n            salt = create_salt()\n            connection.set(self.__redis_conf['salt_key'], salt)\n        BlackRed.__release_connection(connection)\n        return sha512(salt + item.encode()).hexdigest()", "response": "Encode an item to a hash if anonymization is on."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the amount of time a specific item will remain in the database. Returns None if the item does not exist.", "response": "def __get_ttl(self, item: str) -> int:\n        \"\"\"\n        Get the amount of time a specific item will remain in the database.\n\n        :param str item: The item to get the TTL for\n        :return: Time in seconds. Returns None for a non-existing element.\n        :rtype: int\n        \"\"\"\n        connection = self.__get_connection()\n        ttl = connection.ttl(item)\n        BlackRed.__release_connection(connection)\n        return ttl"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the amount of time a specific item will remain on the watchlist. Returns None if the item is not in the watchlist", "response": "def get_watchlist_ttl(self, item: str) -> int:\n        \"\"\"\n        Get the amount of time a specific item will remain on the watchlist.\n\n        :param str item: The item to get the TTL for on the watchlist\n        :return: Time in seconds. Returns None for a non-existing element\n        :rtype: int\n        \"\"\"\n        assert item is not None\n        item = self._encode_item(item)\n        return self.__get_ttl(self.__redis_conf['watchlist_template'].format(item))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef is_not_blocked(self, item: str) -> bool:\n        assert item is not None\n        item = self._encode_item(item)\n        connection = self.__get_connection()\n        key = self.__redis_conf['blacklist_template'].format(item)\n        value = connection.get(key)\n        if value is None:\n            BlackRed.__release_connection(connection)\n            return True\n        if self.__redis_conf['blacklist_refresh_ttl']:\n            connection.expire(key, self.__redis_conf['blacklist_ttl'])\n        BlackRed.__release_connection(connection)\n        return False", "response": "Check if an item is not already on the blacklist"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef log_fail(self, item: str) -> None:\n        assert item is not None\n        item = self._encode_item(item)\n        if self.is_blocked(item):\n            return\n        connection = self.__get_connection()\n        key = self.__redis_conf['watchlist_template'].format(item)\n        value = connection.get(key)\n        if value is None:\n            connection.set(key, 1, ex=self.__redis_conf['watchlist_ttl'])\n            BlackRed.__release_connection(connection)\n            return\n        value = int(value) + 1\n        if value < self.__redis_conf['watchlist_to_blacklist']:\n            connection.set(key, value, ex=self.__redis_conf['watchlist_ttl'])\n            BlackRed.__release_connection(connection)\n            return\n        blacklist_key = self.__redis_conf['blacklist_template'].format(item)\n        connection.set(blacklist_key, time.time(), ex=self.__redis_conf['blacklist_ttl'])\n        connection.delete(key)\n        BlackRed.__release_connection(connection)", "response": "Log a failed action for an item."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nunblocking an item and reset it s fail count", "response": "def unblock(self, item: str) -> None:\n        \"\"\"\n        Unblock an item and/or reset it's fail count\n\n        :param str item: The item to unblock\n        \"\"\"\n        assert item is not None\n        item = self._encode_item(item)\n        watchlist_key = self.__redis_conf['watchlist_template'].format(item)\n        blacklist_key = self.__redis_conf['blacklist_template'].format(item)\n        connection = self.__get_connection()\n        connection.delete(watchlist_key)\n        connection.delete(blacklist_key)\n        BlackRed.__release_connection(connection)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nhandling the command line for the current state of the current user.", "response": "def cmd_line(line, ctrl):\n    clients = ctrl.modules\n    \"\"\" :type: list[WrapperClient] \"\"\"\n    if line == \"update start\":\n        for client in clients:\n            client.updating_start()\n    elif line == \"update stop\":\n        for client in clients:\n            client.updating_stop()\n    return line"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nstart up a task", "response": "def start_task(self, func):\n        \"\"\"Start up a task\"\"\"\n        task = self.loop.create_task(func(self))\n        self._started_tasks.append(task)\n\n        def done_callback(done_task):\n            self._started_tasks.remove(done_task)\n\n        task.add_done_callback(done_callback)\n        return task"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef run(self, loop=None):\n        if loop is None:\n            loop = asyncio.get_event_loop()\n\n        self.loop = loop\n\n        loop.run_until_complete(self.startup())\n\n        for func in self.tasks:\n            self.start_task(func)\n\n        try:\n            task = self.start_task(self.main_task)\n            loop.run_until_complete(task)\n        except (KeyboardInterrupt, SystemError):\n            print(\"Attempting graceful shutdown, press Ctrl-C again to exit\", flush=True)\n\n            def shutdown_exception_handler(_loop, context):\n                if \"exception\" not in context or not isinstance(context[\"exception\"], asyncio.CancelledError):\n                    _loop.default_exception_handler(context)\n            loop.set_exception_handler(shutdown_exception_handler)\n\n            tasks = asyncio.gather(*self._started_tasks, loop=loop, return_exceptions=True)\n            tasks.add_done_callback(lambda _: loop.stop())\n            tasks.cancel()\n\n            while not tasks.done() and not loop.is_closed():\n                loop.run_forever()\n        finally:\n            loop.run_until_complete(self.shutdown())\n            loop.run_until_complete(self.cleanup())\n            loop.close()", "response": "Actually run the application"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef read_git_blob(commit_ref, path, repo_dir='.'):\n    repo = git.Repo(repo_dir)\n    tree = repo.tree(commit_ref)\n    dirname, fname = os.path.split(path)\n    text = None\n    if dirname == '':\n        text = _read_blob(tree, fname)\n    else:\n        components = path.split(os.sep)\n        text = _read_blob_in_tree(tree, components)\n    return text", "response": "Get text from a git blob."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _read_blob_in_tree(tree, components):\n    if len(components) == 1:\n        # Tree is direct parent of blob\n        return _read_blob(tree, components[0])\n    else:\n        # Still trees to open\n        dirname = components.pop(0)\n        for t in tree.traverse():\n            if t.name == dirname:\n                return _read_blob_in_tree(t, components)", "response": "Recursively open trees to ultimately read a blob"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef absolute_git_root_dir(fpath=\"\"):\n    if len(fpath) == 0:\n        dirname_str = os.getcwd()\n    else:\n        dirname_str = os.path.dirname(fpath)\n    dirname_str = os.path.abspath(dirname_str)\n    dirnames = dirname_str.split(os.sep)\n    n = len(dirnames)\n    for i in xrange(n):\n        # is there a .git directory at this level?\n        # FIXME hack\n        basedir = \"/\" + os.path.join(*dirnames[0:n - i])\n        gitdir = os.path.join(basedir, \".git\")\n        if os.path.exists(gitdir):\n            return basedir", "response": "Absolute path to the git root directory containing a given file or\n    directory."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef clean(self):\n        cleaned_data = super(DatasetUploadForm, self).clean()\n        date_begin = self.cleaned_data.get('date_begin')\n        date_end = self.cleaned_data.get('date_end')\n        if date_end < date_begin:\n            msg = u'End date should be after start date.'\n            self.add_error('date_begin', msg)\n            self.add_error('date_end', msg)\n        return cleaned_data", "response": "Verifies that beginning date is before ending date."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nputs keys from kwargs to self", "response": "def _kwargs_to_attributes(self, kwargs):\n        \"\"\"\n        Put keys from `kwargs` to `self`, if the keys are already there.\n        \"\"\"\n        for key, val in kwargs.iteritems():\n            if key not in self.__dict__:\n                raise ValueError(\n                    \"Can't set %s parameter - it is not defined here!\" % key\n                )\n\n            self.__dict__[key] = val"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns completion match and list of completion proposals", "response": "def assist(self, project_path, source, position, filename):\n        \"\"\"Return completion match and list of completion proposals\n\n        :param project_path: absolute project path\n        :param source: unicode or byte string code source\n        :param position: character or byte cursor position\n        :param filename: absolute path of file with source code\n        :returns: tuple (completion match, sorted list of proposals)\n        \"\"\"\n        return self._call('assist', project_path, source, position, filename)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget line number and file path where name under cursor is defined.", "response": "def get_location(self, project_path, source, position, filename):\n        \"\"\"Return line number and file path where name under cursor is defined\n\n        If line is None location wasn't finded. If file path is None, defenition is located in\n        the same source.\n\n        :param project_path: absolute project path\n        :param source: unicode or byte string code source\n        :param position: character or byte cursor position\n        :param filename: absolute path of file with source code\n        :returns: tuple (lineno, file path)\n        \"\"\"\n        return self._call('get_location', project_path, source, position, filename)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_docstring(self, project_path, source, position, filename):\n        return self._call('get_docstring', project_path, source, position, filename)", "response": "Get signature and docstring for current cursor"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_scope(self, project_path, source, lineno, filename, continous=True):\n        return self._call('get_scope', project_path, source, lineno, filename, continous=continous)", "response": "Get scope name at cursor position"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef remove_hairs(inp, hairs=HAIRS):\n    while inp and inp[-1] in hairs:\n        inp = inp[:-1]\n\n    while inp and inp[0] in hairs:\n        inp = inp[1:]\n\n    return inp", "response": "Removes special characters from beginning and end of the input string."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nbuilds a URL such that the origin has all of the mappings to new defined by map", "response": "def _masquerade(origin: str, orig: ServiceDefn, new: ServiceDefn, **map: str) -> str:\n    \"\"\"build an origin URL such that the orig has all of the mappings to new defined by map\"\"\"\n\n    origin: ParseResult = urlparse(origin)\n\n    prev_maps = {}\n\n    if origin.query:\n        prev_maps = {k: v for k, v in parse_qsl(origin.query)}\n\n    r_args = {}\n\n    for new_k, orig_k in map.items():\n\n        assert new_k in new.rpcs, [new_k, new.rpcs]\n        assert orig_k in orig.rpcs, [orig_k, orig.rpcs]\n\n        # todo: check if the definitions are the same\n\n        new_v = new.rpcs[new_k]\n        orig_v = orig.rpcs[orig_k]\n\n        if orig_k in prev_maps:\n            orig_k = prev_maps[orig_k]\n\n        assert new_v.res == orig_v.res, [new_v.res, orig_v.res]\n        assert new_v.req == orig_v.req, [new_v.req, orig_v.req]\n\n        r_args[new_k] = orig_k\n\n    return urlunparse(origin._replace(query=urlencode(r_args)))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef masquerade(origin: str, orig: Type[TA], new: Type[TB], **map: str) -> str:\n\n    return _masquerade(origin, cache_get(orig), cache_get(new), **map)", "response": "Make orig appear as new"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ngive a spanish NIF, CIF or NIE, it returns: 1 for a valid NIF 2 for a valid CIF 3 for a valid NIE -1 for an invalid NIF (it looks like NIF but it doesn't validate the CRC) -2 for an invalid CIF (it looks like CIF but it doesn't validate the CRC) -3 for an invalid NIE (it looks like NIE but id doesn't validate the CRC) -4 not a valid NIF/NIE/CIF because it is too long -5 not a valid NIF/NIE/CIF because it doesn't have a valid format -6 it can not recognize if it is NIF, CIF or NIE, conclusion: the given CID is incorrect.", "response": "def spanishNIFNIECIFhelper(cid):\n    '''\n    Given a spanish NIF, CIF or NIE, it returns:\n\n    1 for a valid NIF\n    2 for a valid CIF\n    3 for a valid NIE\n    -1 for an invalid NIF (it looks like NIF but it doesn't validate the CRC)\n    -2 for an invalid CIF (it looks like CIF but it doesn't validate the CRC)\n    -3 for an invalid NIE (it looks like NIE but id doesn't validate the CRC)\n    -4 not a valid NIF/NIE/CIF because it is too long\n    -5 not a valid NIF/NIE/CIF because it doesn't have a valid format\n    -6 it can not recognize if it is NIF, CIF or NIE, conclusion: the given CID is incorrect.\n    '''\n\n    # Set upper case\n    cid = cid.upper()\n\n    # Already too long?\n    if len(cid) > 9:\n        # Incorrect CID\n        return -4\n\n    # Check the format\n    compiled = re.compile('((^[A-Z]{1}[0-9]{7}[A-Z0-9]{1}$|^[T]{1}[A-Z0-9]{8}$)|^[0-9]{8}[A-Z]{1}$)')\n    if not compiled.match(cid):\n        # It doesn't have a valid format, incorrect CID\n        return -5\n\n    # Build a string with digits for NIF checks\n    num = ''\n    for i in range(0, len(cid)):\n        num += cid[i]\n\n    # Standar NIF checks\n    compiled = re.compile('(^[0-9]{8}[A-Z]{1}$)')\n    if compiled.match(cid):\n        # It looks like NIF\n        index = int(cid[0:8]) % 23\n        string = 'TRWAGMYFPDXBNJZSQVHLCKE'\n        if (num[8] == string[index]):\n            # Valid NIF\n            return 1\n        else:\n            # Invalid NIF\n            return -1\n\n    # Build a string for CIF checks\n    suma = int(num[2]) + int(num[4]) + int(num[6])\n    for i in range(1, len(num), 2):\n        codigo = str(2 * int(num[i]))\n        a = int(codigo[0])\n        if len(codigo) == 2:\n            b = int(codigo[1])\n        else:\n            b = 0\n        suma += (a+b)\n    n = 10 - int(str(suma)[-1])\n\n    # Special NIFs (they are checked as CIFs)\n    compiled = re.compile('^[KLM]{1}')\n    if compiled.match(cid):\n        # It looks like a Special NIF\n        if num[8] == chr(64 + n):\n            # Valid NIF\n            return 1\n        else:\n            # Invalid NIF\n            return -1\n\n    # Standar CIF checks\n    compiled = re.compile('^[ABCDEFGHJNPQRSUVW]{1}')\n    if compiled.match(cid):\n        # It looks like CIF\n        if (num[8] == chr(64 + n)) or (num[8] == str(n)[-1]):\n            # Valid CIF\n            return 2\n        else:\n            # Invalid CIF\n            return -2\n\n    # Standard NIE checks, T kind\n    compiled = re.compile('^[T]{1}')\n    if compiled.match(cid):\n        # It looks like NIE\n        if num[8] == len(re.split('^[T]{1}[A-Z0-9]{8}$', cid)[0]):\n            # Valid NIE\n            return 3\n        else:\n            # Invalid NIE\n            return -3\n\n    # Standard NIE checks, XYZ kind\n    compiled = re.compile('^[XYZ]{1}')\n    if compiled.match(cid):\n        # It looks like NIE\n        string = 'TRWAGMYFPDXBNJZSQVHLCKE'\n        cid = cid.replace('X', '0')\n        cid = cid.replace('Y', '1')\n        cid = cid.replace('Z', '2')\n        if num[8] == string[int(cid[0:8]) % 23]:\n            # Valid NIE\n            return 3\n        else:\n            # Invaid NIE\n            return -3\n\n    # Default fall out is unrecogniced CID, so it is incorrect\n    return -6"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nsend a status ping to Redunda with the instance key specified while constructing the object.", "response": "def sendStatusPing(self):\n        \"\"\"\n        Sends a status ping to Redunda with the instance key specified while constructing the object.\n        \"\"\"\n        data = parse.urlencode({\"key\": self.key, \"version\": self.version}).encode()\n        req = request.Request(\"https://redunda.sobotics.org/status.json\", data)\n\n        response = request.urlopen(req)\n\n        jsonReturned = json.loads(response.read().decode(\"utf-8\"))\n\n        self.location = jsonReturned[\"location\"]\n        self.shouldStandby = jsonReturned[\"should_standby\"]\n        self.eventCount = jsonReturned[\"event_count\"]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef uploadFile(self, filename, ispickle=False, athome=False):\n        print(\"Uploading file {} to Redunda.\".format(filename))\n\n        _, tail = os.path.split(filename)\n        \n        url = \"https://redunda.sobotics.org/bots/data/{}?key={}\".format(tail, self.key)\n        \n        #Set the content type to 'application/octet-stream'\n        header = {\"Content-type\": \"application/octet-stream\"}\n        \n        filedata = \"\"\n\n        if athome:\n            filename = str(os.path.expanduser(\"~\")) + filename\n\n        #Read the data from a file to a string.\n        if filename.endswith(\".pickle\") or ispickle:\n            try:\n                with open(filename, \"rb\") as fileToRead:\n                    data = pickle.load(fileToRead)\n            except pickle.PickleError as perr:\n                print(\"Pickling error occurred: {}\".format(perr))\n                return\n            filedata = json.dumps(data)\n        else:\n            try:\n                with open(filename, \"r\") as fileToRead:\n                    filedata = fileToRead.read()\n            except IOError as ioerr:\n                print(\"IOError occurred: {}\".format(ioerr))\n                return\n\n        requestToMake = request.Request(url, data=filedata.encode(\"utf-8\"), headers=header)\n\n        #Make the request.\n        response = request.urlopen(requestToMake)\n\n        if response.code >= 400:\n            print(\"Error occurred while uploading file '{}' with error code {}.\".format(filename,response.code))", "response": "Uploads a single file to Redunda."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef downloadFile(self, filename, ispickle=False, athome=False):\n        print(\"Downloading file {} from Redunda.\".format(filename))\n\n        _, tail = os.path.split(filename)\n        url = \"https://redunda.sobotics.org/bots/data/{}?key={}\".format(tail, self.key)\n\n        requestToMake = request.Request(url)\n\n        #Make the request.\n        response = request.urlopen(requestToMake)\n\n        if response.code != 200:\n            print(\"Error occured while downloading file '{}' with error code {}.\".format(filename,response.code))\n\n        if athome:\n            filename = str(os.path.expanduser(\"~\")) + filename\n\n\n        filedata = response.read().decode(\"utf-8\")\n\n        try:\n            if filename.endswith (\".pickle\") or ispickle:\n                data = json.loads(filedata)\n                try:\n                    with open(filename, \"wb\") as fileToWrite:\n                        pickle.dump (data, fileToWrite)\n                except pickle.PickleError as perr:\n                    print(\"Pickling error occurred: {}\".format(perr))\n                    return\n            else:\n                with open (filename, \"w\") as fileToWrite:\n                    fileToWrite.write(filedata)\n        except IOError as ioerr:\n            print(\"IOError occurred: {}\".format(ioerr))\n            return", "response": "Downloads a single file from Redunda."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef uploadFiles(self):\n        for each_file in self.filesToSync:\n            self.uploadFile(each_file[\"name\"], each_file[\"ispickle\"], each_file[\"at_home\"])", "response": "Uploads all the files in filesToSync to the local system."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndownloading all the files in filesToSync", "response": "def downloadFiles(self):\n        \"\"\"\n        Downloads all the files in 'filesToSync'\n        \"\"\"\n        for each_file in self.filesToSync:\n            self.downloadFile(each_file[\"name\"], each_file[\"ispickle\"], each_file[\"at_home\"])"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef getEvents(self):\n\n        url = \"https://redunda.sobotics.org/events.json\"\n        data = parse.urlencode({\"key\": self.key}).encode()\n\n        req = request.Request(url, data)\n        \n        response = request.urlopen(req)\n\n        return json.loads(response.read().decode(\"utf-8\"))", "response": "Gets all events from Redunda and returns them."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef saved_searches_factory_helper(splunk_connection_info):\n    if not ISplunkConnectionInfo.providedBy(splunk_connection_info):\n        DoesNotImplement('argument did not provide expected interface')\n    service = connect(**splunk_connection_info)\n    saved_searches = service.saved_searches\n    for s in saved_searches:\n        logger.debug(\"Found Splunk saved search with name %s\" % s.name)\n    return saved_searches", "response": "Create a valid splunklib. client. SavedSearches object"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconfiguring a Memcached client.", "response": "def configure_client(cls, host: str = 'localhost', port: int = 11211, **client_args):\n        \"\"\"\n        Configure a Memcached client.\n\n        :param host: host name or ip address to connect to\n        :param port: port number to connect to\n        :param client_args: extra keyword arguments passed to :class:`aiomcache.Client`\n\n        \"\"\"\n        assert check_argument_types()\n        client = Client(host, port, **client_args)\n        return client"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nextract and sets the feature data from the log file necessary for a reduction.", "response": "def _extract_features(self):\n        \"\"\"\n        Extracts and sets the feature data from the log file necessary for a reduction\n        \"\"\"\n        for parsed_line in self.parsed_lines:\n\n            # If it's ssh, we can handle it\n            if parsed_line.get('program') == 'sshd':\n                result = self._parse_auth_message(parsed_line['message'])\n\n                # Add the ip if we have it\n                if 'ip' in result:\n                    self.features['ips'].append(result['ip'])\n\n                    # If we haven't seen the ip, add it\n                    if result['ip'] not in self.ips_to_pids:\n                        # Make the value a list of pids\n                        self.ips_to_pids[result['ip']] = [parsed_line['processid']]\n                    else:\n                        # If we have seen the ip before, add the pid if it's a new one\n                        if parsed_line['processid'] not in self.ips_to_pids[result['ip']]:\n                            self.ips_to_pids[result['ip']].append(parsed_line['processid'])"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nparsing the raw log lines and convert it to a dictionary with extracted features.", "response": "def _extract_line_features(self):\n        \"\"\"\n        Parse raw log lines and convert it to a dictionary with extracted features.\n        \"\"\"\n        for line in self.line_iterator:\n            m = COMPILED_AUTH_LOG_REGEX.match(line)\n\n            data = {\n                'raw': line\n            }\n\n            if m:\n                data.update({\n                    'timestamp': self._to_epoch(m.group(1)),\n                    'hostname': m.group(2),\n                    'program': m.group(3),\n                    'processid': m.group(4),\n                    'message': m.group(5),\n                })\n\n            self.parsed_lines.append(data)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nanalyze the log file and add the lines to the list of log files that should be filtered out.", "response": "def _analyze(self):\n        \"\"\"\n        Decide which lines should be filtered out\n        \"\"\"\n        pids = []\n\n        for ip in self.filter['ips']:\n            if ip in self.ips_to_pids:\n                for pid in self.ips_to_pids[ip]:\n                    pids.append(pid)\n\n        for line in self.parsed_lines:\n            if 'processid' in line and line['processid'] in pids:\n                self.noisy_logs.append(line)\n            else:\n                self.quiet_logs.append(line)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _to_epoch(self, ts):\n\n        year = self.year\n        tmpts = \"%s %s\" % (ts, str(self.year))\n        new_time = int(calendar.timegm(time.strptime(tmpts, \"%b %d %H:%M:%S %Y\")))\n\n        # If adding the year puts it in the future, this log must be from last year\n        if new_time > int(time.time()):\n            year -= 1\n            tmpts = \"%s %s\" % (ts, str(year))\n            new_time = int(calendar.timegm(time.strptime(tmpts, \"%b %d %H:%M:%S %Y\")))\n\n        return new_time", "response": "Convert a timestamp to a date and time string that includes a year."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nparse an auth message to see if we have ip addresses or users that we care about.", "response": "def _parse_auth_message(self, auth_message):\n        \"\"\"\n        Parse a message to see if we have ip addresses or users that we care about\n\n        :param auth_message: The auth message to parse\n        :return: Result\n        \"\"\"\n        result = {}\n\n        has_matched = False\n\n        for regex in REGEXES_INVALID_USER:\n            # Check for the invalid user/ip messages\n            m = re.search(regex, auth_message)\n\n            if m and not has_matched:\n                has_matched = True\n\n                # Save the username and IP\n                result['username'] = m.group('user')\n                result['ip'] = m.group('ip')\n\n        for regex in REGEXES_INVALID_IP:\n            # Check for the invalid ip messages\n            m = re.search(regex, auth_message)\n\n            if m and not has_matched:\n                has_matched = True\n\n                # Save the IP\n                result['ip'] = m.group('ip')                        \n\n        for regex in REGEXES_IGNORE:\n            # Check for messages we want to ignore\n            m = re.search(regex, auth_message)\n\n            if m and not has_matched:\n                has_matched = True\n\n        # If it's an ssh log and we don't know what it is, handle that\n        if not has_matched:\n            sys.stderr.write(\"Unhandled auth message: %s\\n\" % auth_message)\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef read_until(data: bytes, *, return_tail: bool = True, from_=None) -> bytes:\n    return (yield (Traps._read_until, data, return_tail, from_))", "response": "Read a chunk of data from the end of the sequence."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreads some bytes as integer.", "response": "def read_int(nbytes: int, *, byteorder: str = \"big\", from_=None) -> int:\n    \"\"\"\n    read some bytes as integer\n    \"\"\"\n    return (yield (Traps._read_int, nbytes, byteorder, from_))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsend data for parsing", "response": "def send(self, data: bytes = b\"\"):\n        \"\"\"\n        send data for parsing\n        \"\"\"\n        self.input.extend(data)\n        self._process()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nread at most nbytes bytes from the log file.", "response": "def read(self, nbytes: int = 0) -> bytes:\n        \"\"\"\n        read *at most* ``nbytes``\n        \"\"\"\n        if nbytes == 0 or len(self.output) <= nbytes:\n            data = bytes(self.output)\n            del self.output[:]\n            return data\n        data = bytes(self.output[:nbytes])\n        del self.output[:nbytes]\n        return data"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_result(self):\n        self._process()\n        if not self.has_result:\n            raise NoResult\n        return self.res_queue.popleft()", "response": "Returns the next result from the queue."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate a bokeh server with applications paths", "response": "def create_bokeh_server(io_loop, files, argvs, host, port):\n    '''Start bokeh server with applications paths'''\n    from bokeh.server.server import Server\n    from bokeh.command.util import build_single_handler_applications\n\n    # Turn file paths into bokeh apps\n    apps = build_single_handler_applications(files, argvs)\n\n    # kwargs lifted from bokeh serve call to Server, with created io_loop\n    kwargs = {\n        'io_loop':io_loop,\n        'generate_session_ids':True,\n        'redirect_root':True,\n        'use_x_headers':False,\n        'secret_key':None,\n        'num_procs':1,\n        'host': host,\n        'sign_sessions':False,\n        'develop':False,\n        'port':port,\n        'use_index':True\n    }\n    server = Server(apps,**kwargs)\n\n    return server"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_version():\n    local_results = {}\n    version_file_path = os.path.join('pytextql', 'version.py')\n\n    # This is compatible with py3k which removed execfile.\n    with open(version_file_path, 'rb') as fin:\n        # Compiling instead of passing the text straight to exec\n        # associates any errors with the correct file name.\n        code = compile(fin.read(), version_file_path, 'exec')\n        exec(code, {}, local_results)\n\n    return local_results['__version__']", "response": "Loads the current module version from version. py and returns\n    it."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef show_menu(context, slug, level=2, **kwargs):\n    try:\n        menu = Menu.objects.published().get(slug=slug)\n        menus = menu.get_descendants().all()\n        mark_current_menus(menus, context['request'].path_info)\n        max_level = menu.level + level\n        return {'menus': menus, 'max_level': max_level, 'data': kwargs}\n    except Menu.DoesNotExist:\n        return None", "response": "\u041f\u0440\u0438\u043c\u0435\u0440 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f \u043f\u043e\u043b\u044c\u0437"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef show_gallery(slug, size=\"100x100\", crop=\"center\", **kwargs):\n\n    try:\n        album = PhotoAlbum.objects.published().get(slug=slug)\n        photos = album.photo_set.published().order_by('sort').all()\n        return {'album': album, 'photos': photos, 'size': size, 'crop': crop, 'data': kwargs}\n    except PhotoAlbum.DoesNotExist:\n        return None", "response": "\u041f\u0435\u0433 \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u044f \u0441\u0438\u043c\u0432\u043e\u043b\u044c\u043d\u044b\u0439 \u043a\u043e\u0434 \u0441\u0438\u043c\u0432\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u044e\u0449\u0435\u0433\u043e \u0442\u0435\u0433\u043e "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef show_area(slug):\n    try:\n        area = IncludeArea.objects.published().get(slug=slug)\n        return area.text\n    except IncludeArea.DoesNotExist:\n        return \"\"", "response": "\u041f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435 \u0432\u043a\u043b\u044e\u0447\u0430\u0435\u043c\u043e\u0439 \u043a\u043e\u0434 \u043e\u0431\u043b\u0430\u0441\u0442\u0438\n    \u041f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435 \u0432\u043a\u043b\ufffd"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef ajax_form(cls_name, view_name, modal=False, tag_id=None):\n    if tag_id is None:\n        tag_id = uuid.uuid4().hex[:6].lower()\n    form = import_string(cls_name)()\n    url = reverse(view_name)\n    return {'form': form, 'url': url, 'modal': modal, 'id': tag_id}", "response": "\u041f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435 Ajax \u0444\u043e\u0440\u043c\u044b \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 \u043f\u0440\u043e\u0432\u0435\u0440"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef update(self, **args):\n        # JSONify our data.\n        data = json.dumps(args)\n        r = requests.put(\n            \"https://kippt.com/api/clips/%s\" % (self.id),\n            headers=self.kippt.header,\n            data=data)\n        return (r.json())", "response": "Updates a Clip.\n\n        Parameters:\n        - args Dictionary of other fields\n\n        Accepted fields can be found here:\n            https://github.com/kippt/api-documentation/blob/master/objects/clip.md"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncommenting on a clip.", "response": "def comment(self, body):\n        \"\"\" Comment on a clip.\n\n        Parameters:\n        - body (Required)\n        \"\"\"\n        # Merge our url as a parameter and JSONify it.\n        data = json.dumps({'body': body})\n        r = requests.post(\n            \"https://kippt.com/api/clips/%s/comments\" (self.id),\n            headers=self.kippt.header,\n            data=data\n        )\n        return (r.json())"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef unlike(self):\n        r = requests.delete(\n            \"https://kippt.com/api/clips/%s/likes\" % (self.id),\n            headers=self.kippt.header)\n        return (r.json())", "response": "Like a clip.\n getTaxID"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef to_json(value, pretty=False):\n\n    options = {\n        'sort_keys': False,\n        'cls': BasicJSONEncoder,\n    }\n    if pretty:\n        options['indent'] = 2\n        options['separators'] = (',', ': ')\n\n    return json.dumps(value, **options)", "response": "Serializes the given value to JSON."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef from_json(value, native_datetimes=True):\n\n    hook = BasicJsonDecoder(native_datetimes=native_datetimes)\n    result = json.loads(value, object_hook=hook)\n    if native_datetimes and isinstance(result, string_types):\n        return get_date_or_string(result)\n    return result", "response": "Deserializes the given value from JSON."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef to_yaml(value, pretty=False):\n\n    if not yaml:\n        raise NotImplementedError('No supported YAML library available')\n\n    options = {\n        'Dumper': BasicYamlDumper,\n        'allow_unicode': True,\n    }\n    options['default_flow_style'] = not pretty\n\n    return yaml.dump(value, **options).rstrip()", "response": "Serializes the given value to YAML."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nserializing the given value to TOML.", "response": "def to_toml(value, pretty=False):  # noqa: unused-argument\n    \"\"\"\n    Serializes the given value to TOML.\n\n    :param value: the value to serialize\n    :param pretty:\n        this argument is ignored, as no TOML libraries support this type of\n        operation\n    :type pretty: bool\n    :rtype: str\n    \"\"\"\n\n    if not toml:\n        raise NotImplementedError('No supported TOML library available')\n\n    return toml.dumps(make_toml_friendly(value)).rstrip()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef from_toml(value, native_datetimes=True):\n\n    if not toml:\n        raise NotImplementedError('No supported TOML library available')\n\n    result = toml.loads(value)\n\n    if native_datetimes:\n        result = convert_datetimes(result)\n\n    return result", "response": "Deserializes the given value from TOML."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef export_true_table():\n    tester_list = [\n        (\"inspect.isroutine\", lambda v: inspect.isroutine(v)),\n        (\"inspect.isfunction\", lambda v: inspect.isfunction(v)),\n        (\"inspect.ismethod\", lambda v: inspect.ismethod(v)),\n        (\"isinstance.property\", lambda v: isinstance(v, property)),\n        (\"isinstance.staticmethod\", lambda v: isinstance(v, staticmethod)),\n        (\"isinstance.classmethod\", lambda v: isinstance(v, classmethod)),\n    ]\n\n    class_attr_value_paris = [\n        (\"attribute\", MyClass.attribute),\n        (\"property_method\", MyClass.property_method),\n        (\"regular_method\", MyClass.regular_method),\n        (\"static_method\", MyClass.static_method),\n        (\"class_method\", MyClass.class_method),\n        (\"__dict__['static_method']\", Base.__dict__[\"static_method\"]),\n        (\"__dict__['class_method']\", Base.__dict__[\"class_method\"]),\n    ]\n\n    myclass = MyClass()\n    instance_attr_value_paris = [\n        (\"attribute\", myclass.attribute),\n        (\"property_method\", myclass.property_method),\n        (\"regular_method\", myclass.regular_method),\n        (\"static_method\", myclass.static_method),\n        (\"class_method\", MyClass.class_method),\n        #         (\"__dict__['static_method']\", myclass.__dict__[\"static_method\"]),\n        #         (\"__dict__['class_method']\", myclass.__dict__[\"class_method\"]),\n    ]\n\n    print(inspect.getargspec(MyClass.regular_method))\n    print(inspect.getargspec(MyClass.static_method))\n    print(inspect.getargspec(MyClass.class_method))\n\n    print(inspect.getargspec(myclass.regular_method))\n    print(inspect.getargspec(myclass.static_method))\n    print(inspect.getargspec(myclass.class_method))\n\n    # index\u662f\u65b9\u6cd5\u540d, column\u662f\u5c5e\u6027\u540d\n    def create_true_table_dataframe(index_tester, column_attr):\n        df = pd.DataFrame()\n        for attr, value in column_attr:\n            col = list()\n            for name, tester in index_tester:\n                try:\n                    if tester(value):\n                        flag = 1\n                    else:\n                        flag = 0\n                except:\n                    flag = -99\n                col.append(flag)\n            df[attr] = col\n        df.index = [name for name, _ in index_tester]\n        return df\n\n    version = \"%s.%s\" % (sys.version_info.major, sys.version_info.minor)\n\n    df = create_true_table_dataframe(tester_list, class_attr_value_paris)\n    df.to_csv(\"%s_class.csv\" % version, index=True)\n\n    df = create_true_table_dataframe(tester_list, instance_attr_value_paris)\n    df.to_csv(\"%s_instance.csv\" % version, index=True)", "response": "Export value checker function output true table."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nmerge all true table into single excel file.", "response": "def merge_true_table():\n    \"\"\"Merge all true table into single excel file.\n    \"\"\"\n    writer = pd.ExcelWriter(\"True Table.xlsx\")\n    for p in Path(__file__).parent.select_by_ext(\".csv\"):\n        df = pd.read_csv(p.abspath, index_col=0)\n        df.to_excel(writer, p.fname, index=True)\n    writer.save()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\nasync def send(self, *args, **kwargs):\n        for callback in self:\n            res = callback(*args, **kwargs)\n            if asyncio.iscoroutine(res) or isinstance(res, asyncio.Future):\n                await res", "response": "Send args and kwargs to all registered callbacks"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the value of a given parameter value", "response": "def param_value(param_values, slug):\n    \"\"\"\n    \u041e\u0442\u043e\u0431\u0440\u0430\u0436\u0430\u0435\u0442 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u0430 \u0442\u043e\u0432\u0430\u0440\u0430\n\n    \u041f\u0440\u0438\u043c\u0435\u0440 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u044f::\n\n        {% param_value item.paramvalue_set.all \"producer\" %}\n\n    :param param_values: \u0441\u043f\u0438\u0441\u043e\u043a \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0439 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432\n    :param slug: \u0441\u0438\u043c\u0432\u043e\u043b\u044c\u043d\u044b\u0439 \u043a\u043e\u0434 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u0430\n    :return:\n    \"\"\"\n    for val in param_values:\n        if val.param.slug == slug:\n            return val.value\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the title of the given parameter value", "response": "def param_title(param_values, slug):\n    \"\"\"\n    \u041e\u0442\u043e\u0431\u0440\u0430\u0436\u0430\u0435\u0442 \u043d\u0430\u0438\u043c\u0435\u043d\u043e\u0432\u0430\u043d\u0438\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u0430 \u0442\u043e\u0432\u0430\u0440\u0430\n\n    \u041f\u0440\u0438\u043c\u0435\u0440 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u044f::\n\n        {% param_title item.paramvalue_set.all \"producer\" %}\n\n    :param param_values: \u0441\u043f\u0438\u0441\u043e\u043a \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0439 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432\n    :param slug: \u0441\u0438\u043c\u0432\u043e\u043b\u044c\u043d\u044b\u0439 \u043a\u043e\u0434 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u0430\n    :return:\n    \"\"\"\n    for val in param_values:\n        if val.param.slug == slug:\n            return val.param.title\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a string that can be used to display a money in the order of the current locale.", "response": "def currency(money):\n    \"\"\"\n    \u0424\u0438\u043b\u044c\u0442\u0440 \u0432\u0430\u043b\u044e\u0442\u044b. \u0424\u043e\u0440\u043c\u0430\u0442\u0438\u0440\u0443\u0435\u0442 \u0446\u0435\u043d\u0443 \u0432 \u0441\u043e\u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0438\u0438 \u0441 \u0443\u0441\u0442\u0430\u043d\u043e\u0432\u043b\u0435\u043d\u043d\u044b\u043c \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e\u043c \u0437\u043d\u0430\u043a\u043e\u0432 \u043f\u043e\u0441\u043b\u0435 \u0437\u0430\u043f\u044f\u0442\u043e\u0439,\n    \u0430 \u0442\u0430\u043a\u0436\u0435 \u0434\u043e\u0431\u0430\u0432\u043b\u0435\u044f\u0442 \u0441\u0438\u043c\u0432\u043e\u043b \u0432\u0430\u043b\u044e\u0442\u044b.\n    :param money:\n    :return:\n    \"\"\"\n    decimals = getattr(settings, 'MIDNIGHT_CATALOG_DECIMALS', 2)\n    money = round(float(money), decimals)\n    symbol = getattr(settings, 'MIDNIGHT_CATALOG_CURRENCY', '\u0440\u0443\u0431')\n    if decimals > 0:\n        formatted = (str(\"%0.\"+str(decimals)+\"f\") % money)[-decimals-1:]\n    else:\n        formatted = \"\"\n    return \"%s%s %s\" % (intcomma(int(money)), formatted, symbol)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a list of sections in a context.", "response": "def catalog_sections(context, slug=None, level=3, **kwargs):\n    \"\"\"\n    \u041e\u0442\u043e\u0431\u0440\u0430\u0436\u0430\u0435\u0442 \u0438\u0435\u0440\u0435\u0440\u0445\u0438\u0447\u0435\u0441\u043a\u0438\u0439 \u0441\u043f\u0438\u0441\u043e\u043a \u043a\u0430\u0442\u0435\u0433\u043e\u0440\u0438\u0439 \u043a\u0430\u0442\u0430\u043b\u043e\u0433\u0430.\n    \u0414\u043b\u044f \u043a\u0430\u0436\u0434\u043e\u0439 \u043a\u0430\u0442\u0435\u0433\u043e\u0440\u0438\u0438 \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0430\u0435\u0442\u0441\u044f \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0449\u0435\u0433\u043e\u0441\u044f \u0432 \u043d\u0435\u0439 \u0442\u043e\u0432\u0430\u0440\u0430.\n\n    \u041f\u0440\u0438\u043c\u0435\u0440 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u044f::\n\n        {% catalog_sections 'section_slug' 2 class='catalog-class' %}\n\n    :param context: \u043a\u043e\u043d\u0442\u0435\u043a\u0441\u0442\n    :param slug: \u0441\u0438\u043c\u0432\u043e\u043b\u044c\u043d\u044b\u0439 \u043a\u043e\u0434 \u0440\u043e\u0434\u0438\u0442\u0435\u043b\u044c\u0441\u043a\u043e\u0439 \u043a\u0430\u0442\u0435\u0433\u043e\u0440\u0438\u0438, \u0435\u0441\u043b\u0438 \u043d\u0435 \u0437\u0430\u0434\u0430\u043d, \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0430\u0435\u0442\u0441\u044f \u0432\u0441\u044f \u0438\u0435\u0440\u0430\u0440\u0445\u0438\u044f\n    :param level: \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0430\u0435\u043c\u044b\u0439 \u0443\u0440\u043e\u0432\u0435\u043d\u044c \u0432\u043b\u043e\u0436\u0435\u043d\u043d\u043e\u0441\u0442\u0438\n    :param kwargs: html \u0430\u0442\u0440\u0438\u0431\u0443\u0442\u044b \u043e\u0431\u043e\u0440\u0430\u0447\u0438\u0432\u0430\u044e\u0449\u0435\u0433\u043e \u0442\u0435\u0433\u0430\n    :return:\n    \"\"\"\n    count_products = Count(Case(When(product__active=True, then=Value(1)), output_field=IntegerField()))\n    if slug is None:\n        sections = Section.objects.annotate(product__count=count_products).all()\n        max_level = level - 1\n    else:\n        section = Section.objects.get(slug=slug)\n        sections = section.get_descendants().annotate(product__count=count_products).all()\n        max_level = section.level + level\n    mark_current_menus(sections, context['request'].path_info)\n    return {'sections': sections, 'max_level': max_level, 'data': kwargs}"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_config(config_path='/etc/record_recommender.yml', sentry=False):\n    config = {}\n    if os.path.exists(config_path):\n        with open(config_path, 'rt') as f:\n            config = yaml.safe_load(f.read())\n    else:\n        # TODO: Auto create config file.\n        print(\"No config file at {}\".format(config_path))\n\n    es_password = os.environ.get('RECOMMENDER_ES_PASSWORD')\n    if es_password:\n        config.get('elasticsearch', {})['es_password'] = es_password\n\n    sentry_os = os.environ.get('RECOMMENDER_SENTRY')\n    if sentry_os:\n        config['logging']['handlers']['sentry']['dsn'] = sentry_os\n    elif config.get('sentry'):\n        config['logging']['handlers']['sentry']['dsn'] = config.get('sentry')\n    else:\n        if config.get('logging.handlers.sentry'):\n            config['logging']['handlers'].pop('sentry')\n\n    return config", "response": "Load the configuration file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _create_all_recommendations(cores, ip_views=False, config=None):\n    global _reco, _store\n\n    _reco = GraphRecommender(_store)\n    _reco.load_profile('Profiles')\n    if ip_views:\n        _reco.load_profile('Profiles_IP')\n\n    manager = Manager()\n    record_list = manager.list(_reco.all_records.keys())\n    # record_list = manager.list(list(_reco.all_records.keys())[:10])\n    num_records = len(_reco.all_records.keys())\n    logger.info(\"Recommendations to build: {}\".format(num_records))\n\n    start = time.time()\n    reco_version = config.get('recommendation_version', 0)\n    done_records = num_records\n    if cores <= 1:\n        _create_recommendations(0, record_list, reco_version)\n    else:\n        try:\n            pool = Pool(cores)\n            multiple_results = [pool.apply_async(_create_recommendations,\n                                (i, record_list, reco_version))\n                                for i in range(cores)]\n            # Wait for all processes to exit\n            [res.get() for res in multiple_results]\n        except KeyboardInterrupt:\n            print(\"Caught KeyboardInterrupt, terminating workers\")\n            # TODO: Update done_records.\n            pool.terminate()\n            pool.join()\n\n    duration = time.time() - start\n    logger.info(\"Time {} for {} recommendations\".format(duration,\n                                                        done_records))", "response": "Calculate all recommendations in multiple processes."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef fetch_weeks(self, weeks, overwrite=False):\n        esf = ElasticsearchFetcher(self.store, self.config)\n        for year, week in weeks:\n            print(\"Fetch {}-{}\".format(year, week))\n            esf.fetch(year, week, overwrite)", "response": "Fetch and cache the requested weeks."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create_all_recommendations(self, cores, ip_views=False):\n        global _store\n        _store = self.store\n        _create_all_recommendations(cores, ip_views, self.config)", "response": "Calculate the recommendations for all records."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef table_dataset_database_table(\n    table              = None,\n    include_attributes = None,\n    rows_limit         = None,\n    print_progress     = False,\n    ):\n\n    \"\"\"\n    Create a pyprel table contents list from a database table of the module\n    dataset. Attributes to be included in the table can be specified; by\n    default, all attributes are included. A limit on the number of rows included\n    can be specified. Progress on building the table can be reported.\n    \"\"\"\n\n    if print_progress:\n        import shijian\n        progress = shijian.Progress()\n        progress.engage_quick_calculation_mode()\n        number_of_rows = len(table)\n\n    if include_attributes:\n        columns = include_attributes\n    else:\n        columns = table.columns\n    table_contents = [columns]\n    for index_row, row in enumerate(table):\n        if rows_limit is not None:\n            if index_row >= rows_limit:\n                break\n        row_contents = []\n        for column in columns:\n            try:\n                string_representation = str(row[column])\n            except:\n                string_representation = str(row[column].encode(\"utf-8\"))\n            row_contents.append(string_representation)\n        table_contents.append(row_contents)\n        if print_progress:\n            print(progress.add_datum(\n                fraction = float(index_row) / float(number_of_rows))\n            )\n\n    return table_contents", "response": "Create a pyprel table contents list from a database table of the module\n    dataset."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef read_variables(config_location: str) -> Dict[str, str]:\n    with open(config_location, \"r\") as config_file:\n        config_lines = config_file.readlines()\n    try:\n        return json.loads(\"\".join(config_lines), parse_int=lambda num_str: str(num_str),\n                          parse_float=lambda float_str: str(float_str))\n    except JSONDecodeError:\n        pass\n    config_lines = _shell_to_ini(config_lines)\n    return _read_ini_config(\"\\n\".join(config_lines))", "response": "Reads variables out of a config file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _read_ini_config(ini_file_contents: str) -> Dict[str, str]:\n    config = configparser.ConfigParser()\n    config.optionxform = str\n    config.read_string(_FAKE_SECTION + ini_file_contents)\n\n    items = {}\n    for section in config.sections():\n        items.update(dict(config[section].items()))\n\n    return items", "response": "Parses the given ini file contents and converts to a dictionary of key - value pairs."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _shell_to_ini(shell_file_contents: List[str]) -> List[str]:\n    line_number = 0\n    while line_number < len(shell_file_contents):\n        line = shell_file_contents[line_number].strip()\n        if \"=\" not in line:\n            del shell_file_contents[line_number]\n        else:\n            if line.strip().startswith(_EXPORT_COMMAND):\n                shell_file_contents[line_number] = line.replace(_EXPORT_COMMAND, \"\").strip()\n            line_number += 1\n    return shell_file_contents", "response": "Converts a shell file which just contains comments and export * statements into an ini file."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef nearest_indices(xs, XS):\n    '''\n    Returns indices that perform nearest interpolation given a\n    set of points. Similar to scipy.interpolate.griddata with\n    method set to \"nearest\". In fact, it's construction is based\n    on that function and related types.\n\n    Parameters:\n    -----------\n\n    xs -- ndarray of floats, shape (n,D)\n          Data point coordinates. Can either be an array of\n          shape (n,D), or a tuple of `ndim` arrays.\n    XS -- ndarray of floats, shape (M, D)\n          Points at which to interpolate/sample data.\n    '''\n    xs=_ndim_coords_from_arrays(xs);\n    XS = _ndim_coords_from_arrays(XS, ndim=xs.shape[1])\n    if XS.shape[-1] != xs.shape[1]:\n        raise ValueError(\"dimensions of the points don't the sample points\")\n    #the magical kd-tree\n    _,i = cKDTree(xs).query(XS)\n    return i;", "response": "Returns indices that perform nearest interpolation given a\n    set of points."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get(self) -> Dict[str, str]:\n        variables = self._project.variables.list(all=True)\n        return {variable.key: variable.value for variable in variables}", "response": "Gets the build variables for the project."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nclearing all build variables.", "response": "def clear(self):\n        \"\"\"\n        Clears all of the build variables.\n        \"\"\"\n        for variable in self._project.variables.list(all=True):\n            variable.delete()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef remove(self, variables: Union[Iterable[str], Dict[str, str]]=None):\n        keys = list(variables.keys()) if isinstance(variables, Dict) else variables     # type: Iterable[str]\n        for key in keys:\n            variable = self._project.variables.get(key)\n            if isinstance(variables, Dict):\n                if variables[key] != variable.value:\n                    continue\n            variable.delete()", "response": "Removes the given variables from the current object. Will only remove a key if it has the given value. Will only remove a key if it has the given value. Will only remove a key if it has the given value. Will only remove a key if it has the given value."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set(self, variables: Dict[str, str]):\n        current_variables = self.get()\n        difference = DictDiffer(variables, current_variables)\n\n        removed_keys = difference.removed()\n        self.remove(removed_keys)\n\n        changed_keys = difference.added() | difference.changed()\n        changed = {key: variables[key] for key in changed_keys}\n        self.add(changed, overwrite=True)", "response": "Sets the build variables for the current locale."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nadd the given build variables to those that already exist.", "response": "def add(self, variables: Dict[str, str], overwrite: bool=False):\n        \"\"\"\n        Adds the given build variables to those that already exist.\n        :param variables: the build variables to add\n        :param overwrite: whether the old variable should be overwritten in the case of a redefinition\n        \"\"\"\n        preset_variables = self._project.variables.list()\n        preset_variable_keys = [variable.key for variable in preset_variables]\n\n        for key, value in variables.items():\n            if key in preset_variable_keys:\n                if overwrite:\n                    variable = preset_variables[preset_variable_keys.index(key)]\n                    variable.value = value\n                    variable.save()\n            else:\n                variable = self._project.variables.create({\n                    _VARIABLE_KEY_PROPERTY: key, _VARIABLE_VALUE_PROPERTY: value})\n                variable.save()"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the type for the columns and a flag to indicate that the the column has codes.", "response": "def _resolved_type(self):\n        \"\"\"Return the type for the columns, and a flag to indicate that the\n        column has codes.\"\"\"\n        import datetime\n\n        self.type_ratios = {test: (float(self.type_counts[test]) / float(self.count)) if self.count else None\n                            for test, testf in tests + [(None, None)]}\n\n        # If it is more than 5% str, it's a str\n\n        try:\n            if self.type_ratios.get(text_type,0) + self.type_ratios.get(binary_type,0) > .05:\n                if self.type_counts[text_type] > 0:\n                    return text_type, False\n\n                elif self.type_counts[binary_type] > 0:\n                    return binary_type, False\n        except TypeError as e:\n            # This is probably the result of the type being unknown\n            pass\n\n\n        if self.type_counts[datetime.datetime] > 0:\n            num_type = datetime.datetime\n\n        elif self.type_counts[datetime.date] > 0:\n            num_type = datetime.date\n\n        elif self.type_counts[datetime.time] > 0:\n            num_type = datetime.time\n\n        elif self.type_counts[float] > 0:\n            num_type = float\n\n        elif self.type_counts[int] > 0:\n            num_type = int\n\n        elif self.type_counts[text_type] > 0:\n            num_type = text_type\n\n        elif self.type_counts[binary_type] > 0:\n            num_type = binary_type\n\n        else:\n            num_type = unknown\n\n        if self.type_counts[binary_type] > 0 and num_type != binary_type:\n            has_codes = True\n        else:\n            has_codes = False\n\n        return num_type, has_codes"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef promote_type(orig_type, new_type):\n\n        if not new_type:\n            return orig_type\n\n        if not orig_type:\n            return new_type\n\n        try:\n            orig_type = orig_type.__name__\n        except AttributeError:\n            pass\n\n        try:\n            new_type = new_type.__name__\n        except AttributeError:\n            pass\n\n        type_precidence = ['unknown', 'int', 'float', 'date', 'time', 'datetime', 'str', 'bytes', 'unicode']\n\n        # TODO This will fail for dates and times.\n\n        if type_precidence.index(new_type) > type_precidence.index(orig_type):\n            return new_type\n        else:\n            return orig_type", "response": "Given a table with an original type decide whether a new determination of a new applicable type is overide the existing one."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef filter_duplicate(self, url):\n        if self.filterDuplicate:\n            if url in self.historys: \n                raise Exception('duplicate excepiton: %s is duplicate' % url)\n            else:\n                self.historys.add(url)\n        else:\n            pass", "response": "add url to history if not already in history"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef __select(self, method, url, headers=None, cookies=None, timeout=60, verify=False, proxies=None,\n                 allow_redirects=True, encoding='utf-8', params=None, form_data=None, stream=False):\n        \"\"\"\n        \u5bf9http\u52a8\u4f5c\u7684\u5c01\u88c5\uff0c\u5f53\u4f20\u9012get\uff0c\u5219\u6a21\u62dfhttp get\u8bf7\u6c42\uff0c\n        \u5f53\u4f20\u9012post, \u5219\u6a21\u62dfhttp post\u8bf7\u6c42\n        :param method: 'get' or 'post'\n        :param url: \u8bbf\u95eeUrl\n        :param headers: \u8bf7\u6c42\u5934\n        :param cookies: \u8bf7\u6c42cookies\n        :param timeout: \u8d85\u65f6\u65f6\u95f4\n        :param verify: ssl\u9a8c\u8bc1\n        :param proxies: \u4ee3\u7406\n        :param allow_redirects: \u662f\u5426\u5141\u8bb8\u91cd\u5b9a\u5411\n        :param encoding: \u8fd4\u56de\u7684html\u7f16\u7801\n        :param params: \u67e5\u8be2\u8bf7\u6c42\u53c2\u6570\n        :param form_data: \u5982\u679c\u662fpost\u8bf7\u6c42\u5219\u9700\u8981\u63d0\u4f9b\u6709\u8868\u5355\u63d0\u4ea4\u5219\u9700\u8981\u6709\u8fd9\u4e2a\n        :param stream: \u662f\u5426\u4e3a\u6d41\u6570\u636e\n        :return: (html, \u54cd\u5e94\u5934\uff0c\u54cd\u5e94cookie\uff0c\u8bbf\u95ee\u5386\u53f2\uff0c\u54cd\u5e94\u65f6\u95f4\uff08\u79d2\uff09) \u6216\u8005 \u6d41\u6570\u636e\n        \"\"\"\n        # \u589e\u52a0\u53bb\u91cd\u529f\u80fd\uff0c\u5f00\u542f\u540e\uff0c\u5982\u82e5\u4e0d\u5728history\u4e2d\u5219\uff0c\u5219\u5141\u8bb8\u8bbf\u95ee\uff0c\u5e76\u8bb0\u4f4f\u8bbf\u95ee\u8fc7\u6b64url\n        # \u4e0b\u6b21\u91cd\u590d\u8bbf\u95ee\u65f6\u5219\u629b\u51fa\u5f02\u5e38\n        self.filter_duplicate(url) \n        r = None\n        if method == 'get':\n            if self.session:\n                r = self.session.get(url, headers=odict(headers), cookies=cookies, timeout=timeout,\n                                     verify=verify, proxies=proxies, allow_redirects=allow_redirects, params=params)\n            else:\n                r = requests.get(url, headers=odict(headers), cookies=cookies, timeout=timeout, verify=verify,\n                                 proxies=proxies, allow_redirects=allow_redirects, params=params)\n        elif method == 'post':\n            if self.session:\n                r = self.session.post(url, headers=odict(headers), cookies=cookies, timeout=timeout,\n                                      data=form_data, verify=verify, proxies=proxies, allow_redirects=allow_redirects,\n                                      params=params)\n            else:\n                r = requests.post(url, headers=odict(headers), cookies=cookies, timeout=timeout, data=form_data,\n                                  verify=verify, proxies=proxies, allow_redirects=allow_redirects, params=params)\n        else:\n            raise Exception('unsupported http method')\n\n        # \u82e5http\u72b6\u6001\u7801\u5982\u679c\u4e0d\u6b63\u5e38\u5219\u629b\u51fa\u5f02\u5e38\n        r.raise_for_status()\n        r.encoding = encoding  # \u8bbe\u7f6ehtml\u7f16\u7801\n        if stream:\n            # \u5982\u679c\u4e3a\u6d41\u5f0f\u6570\u636e\n            return r\n        return r.text, r.headers, dict_from_cookiejar(r.cookies), r.history, r.elapsed.microseconds / 1000000", "response": "\u5bf9http\u52a8\u4f5c\u7684\u5c01\u88c5\uff0c\u5f53\u4f20\u9012get\uff0c\u5219\u6a21\u62dfhttp get\u8bf7\u6c42\uff0c\n        \u5f53\u4f20\u9012post, \u5219\u6a21\u62dfhttp post\u8bf7\u6c42\n        :param method: 'get' or 'post'\n        :param url: \u8bbf\u95eeUrl\n        :param headers: \u8bf7\u6c42\u5934\n        :param cookies: \u8bf7\u6c42cookies\n        :param timeout: \u8d85\u65f6\u65f6\u95f4\n        :param verify: ssl\u9a8c\u8bc1\n        :param proxies: \u4ee3\u7406\n        :param allow_redirects: \u662f\u5426\u5141\u8bb8\u91cd\u5b9a\u5411\n        :param encoding: \u8fd4\u56de\u7684html\u7f16\u7801\n        :param params: \u67e5\u8be2\u8bf7\u6c42\u53c2\u6570\n        :param form_data: \u5982\u679c\u662fpost\u8bf7\u6c42\u5219\u9700\u8981\u63d0\u4f9b\u6709\u8868\u5355\u63d0\u4ea4\u5219\u9700\u8981\u6709\u8fd9\u4e2a\n        :param stream: \u662f\u5426\u4e3a\u6d41\u6570\u636e\n        :return: (html, \u54cd\u5e94\u5934\uff0c\u54cd\u5e94cookie\uff0c\u8bbf\u95ee\u5386\u53f2\uff0c\u54cd\u5e94\u65f6\u95f4\uff08\u79d2\uff09) \u6216\u8005 \u6d41\u6570\u636e"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget data from repaircafe_org.", "response": "def data_from_repaircafe_org():\n    \"\"\"Gets data from repaircafe_org.\"\"\"\n\n    # Use Chrome as a browser\n    browser = webdriver.Chrome()\n    # Use PhantomJS as a browser\n    #\u00a0browser = webdriver.PhantomJS('phantomjs')\n    browser.get(\"https://repaircafe.org/en/?s=Contact+the+local+organisers\")\n    browser.maximize_window()\n\n    # Iterate over results (the #viewmore_link button)\n    viewmore_button = True\n    while viewmore_button:\n        try:\n            viewmore = browser.find_element_by_id(\"viewmore_link\")\n            # Scroll to the link in order to make it visible\n            browser.execute_script(\"arguments[0].scrollIntoView();\", viewmore)\n            # Keep searching\n            viewmore.click()\n        except:\n            # If there's an error, we have reached the end of the search\n            viewmore_button = False\n        # Give a bit of time for loading the search results\n        sleep(2)\n\n    # Load the source code\n    page_source = BeautifulSoup(browser.page_source, \"lxml\")\n    # Close the browser\n    browser.quit()\n    # Parse the source code in order to find all the links under H4s\n    data = []\n    for h4 in page_source.find_all(\"h4\"):\n        for a in h4.find_all('a', href=True):\n            data.append({\"name\": a.contents[0], \"url\": a['href']})\n\n    return data"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_labs(format):\n\n    data = data_from_repaircafe_org()\n\n    repaircafes = {}\n\n    # Load all the Repair Cafes\n    for i in data:\n        # Create a lab\n        current_lab = RepairCafe()\n        # Add existing data from first scraping\n        current_lab.name = i[\"name\"]\n        slug = i[\"url\"].replace(\"https://repaircafe.org/locations/\", \"\")\n        if slug.endswith(\"/\"):\n            slug.replace(\"/\", \"\")\n        current_lab.slug = slug\n        current_lab.url = i[\"url\"]\n        # Scrape for more data\n        page_request = requests.get(i[\"url\"])\n        if page_request.status_code == 200:\n            page_source = BeautifulSoup(page_request.text, \"lxml\")\n        else:\n            output = \"There was an error while accessing data on repaircafe.org.\"\n\n        # Find Facebook and Twitter links, add also the other ones\n        current_lab.links = {\"facebook\": \"\", \"twitter\": \"\"}\n        column = page_source.find_all(\"div\", class_=\"sc_column_item_2\")\n        for j in column:\n            for p in j.find_all('p'):\n                for a in p.find_all('a', href=True):\n                    if \"facebook\" in a['href']:\n                        current_lab.links[\"facebook\"] = a['href']\n                    elif \"twitter\" in a['href']:\n                        current_lab.links[\"twitter\"] = a['href']\n                    else:\n                        current_lab.links[a['href']] = a['href']\n\n        # Find address\n        column = page_source.find_all(\"div\", class_=\"sc_column_item_1\")\n        for x in column:\n            if x.string:\n                print x.string.strip()\n\n        exit()\n        # current_lab.address_1 = i[\"address_1\"]\n        # current_lab.address_2 = i[\"address_2\"]\n        # current_lab.address_notes = i[\"address_notes\"]\n        # current_lab.blurb = i[\"blurb\"]\n        # current_lab.city = i[\"city\"]\n        # current_lab.country_code = i[\"country_code\"]\n        # current_lab.county = i[\"county\"]\n        # current_lab.description = i[\"description\"]\n        # current_lab.email = i[\"email\"]\n        # current_lab.id = i[\"id\"]\n        # current_lab.phone = i[\"phone\"]\n        # current_lab.postal_code = i[\"postal_code\"]\n        #\n        #\n        # current_lab.continent = country_alpha2_to_continent_code(i[\n        #     \"country_code\"].upper())\n        # current_country = pycountry.countries.get(\n        #     alpha_2=i[\"country_code\"].upper())\n        # current_lab.country_code = current_country.alpha_3\n        # current_lab.country = current_country.name\n\n        # if i[\"longitude\"] is None or i[\"latitude\"] is None:\n        #     # Be nice with the geocoder API limit\n        #     errorsb += 1\n        #     # sleep(10)\n        #     # location = geolocator.geocode(\n        #     #     {\"city\": i[\"city\"],\n        #     #      \"country\": i[\"country_code\"].upper()},\n        #     #     addressdetails=True,\n        #     #     language=\"en\")\n        #     # if location is not None:\n        #     #     current_lab.latitude = location.latitude\n        #     #     current_lab.longitude = location.longitude\n        #     #     if \"county\" in location.raw[\"address\"]:\n        #     #         current_lab.county = location.raw[\"address\"][\n        #     #             \"county\"].encode('utf-8')\n        #     #     if \"state\" in location.raw[\"address\"]:\n        #     #         current_lab.state = location.raw[\"address\"][\n        #     #             \"state\"].encode('utf-8')\n        # else:\n        #     # Be nice with the geocoder API limit\n        #     sleep(10)\n        #     errorsa += 1\n        #     # location = geolocator.reverse((i[\"latitude\"], i[\"longitude\"]))\n        #     # if location is not None:\n        #     #     if \"county\" in location.raw[\"address\"]:\n        #     #         current_lab.county = location.raw[\"address\"][\n        #     #             \"county\"].encode('utf-8')\n        #     #     if \"state\" in location.raw[\"address\"]:\n        #     #         current_lab.state = location.raw[\"address\"][\n        #     #             \"state\"].encode('utf-8')\n\n        # Add the lab to the list\n        repaircafes[slug] = current_lab\n    # Return a dictiornary / json\n    if format.lower() == \"dict\" or format.lower() == \"json\":\n        output = {}\n        for j in repaircafes:\n            output[j] = repaircafes[j].__dict__\n    # Return a geojson\n    elif format.lower() == \"geojson\" or format.lower() == \"geo\":\n        labs_list = []\n        for l in repaircafes:\n            single = repaircafes[l].__dict__\n            single_lab = Feature(\n                type=\"Feature\",\n                geometry=Point((single[\"latitude\"], single[\"longitude\"])),\n                properties=single)\n            labs_list.append(single_lab)\n        output = dumps(FeatureCollection(labs_list))\n    # Return a Pandas DataFrame\n    elif format.lower() == \"pandas\" or format.lower() == \"dataframe\":\n        output = {}\n        for j in repaircafes:\n            output[j] = repaircafes[j].__dict__\n        # Transform the dict into a Pandas DataFrame\n        output = pd.DataFrame.from_dict(output)\n        output = output.transpose()\n    # Return an object\n    elif format.lower() == \"object\" or format.lower() == \"obj\":\n        output = repaircafes\n    # Default: return an oject\n    else:\n        output = repaircafes\n    # Return a proper json\n    if format.lower() == \"json\":\n        output = json.dumps(output)\n    return output", "response": "Gets Repair Cafe data from repairecafe. org."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nmove filename out of the way archiving it by appending the current datetime", "response": "def archive_if_exists(filename):\n    \"\"\"\n    Move `filename` out of the way, archiving it by appending the current datetime\n    Can be a file or a directory\n    \"\"\"\n    if os.path.exists(filename):\n        current_time = datetime.datetime.now()\n        dt_format = '%Y-%m-%dT%H:%M:%S%z'\n        timestamp = current_time.strftime(dt_format)\n        dst = filename + '_' + timestamp\n        shutil.move(filename, dst)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nensuring the existence of the parent directory of f", "response": "def ensure_dir_exists(f, fullpath=False):\n    \"\"\"\n    Ensure the existence of the (parent) directory of f\n    \"\"\"\n    if fullpath is False:\n        # Get parent directory\n        d = os.path.dirname(f)\n    else:\n        # Create the full path\n        d = f\n    if not os.path.exists(d):\n        os.makedirs(d)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nlists all files in directory dirname option to filter on file extension", "response": "def list_files(dirname, extension=None):\n    \"\"\"\n    List all files in directory `dirname`, option to filter on file extension\n    \"\"\"\n    f = []\n    for (dirpath, dirnames, filenames) in os.walk(dirname):\n        f.extend(filenames)\n        break\n    if extension is not None:\n        # Filter on extension\n        filtered = []\n        for filename in f:\n            fn, ext = os.path.splitext(filename)\n            if ext.lower() == '.' + extension.lower():\n                filtered.append(filename)\n        f = filtered\n    return f"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding text to filename keeping the extension in place", "response": "def filename_addstring(filename, text):\n    \"\"\"\n    Add `text` to filename, keeping the extension in place\n    For example when adding a timestamp to the filename\n    \"\"\"\n    fn, ext = os.path.splitext(filename)\n    return fn + text + ext"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_file_contents(filename):\n    data = None\n    try:\n        with open(filename) as pf:\n            data = pf.read()\n    except IOError:\n        # File not found, return None\n        pass\n    return data", "response": "Read file contents from filename"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef parse_name(cls, name):\n        parse_dict = dict.fromkeys(cls.PARSABLE, None)\n        parse_dict['date'] = cls.get_date(name)\n        parse_dict['version'] = cls.get_version(name)\n        parse_dict['udim'] = cls.get_udim(name)\n        parse_dict['side'] = cls.get_side(name)\n        parse_dict['basename'] = cls.get_base_naive(cls._reduce_name(name, parse_dict))\n        return parse_dict", "response": "Parses a name into a dictionary of identified subsections with accompanying information to\n            correctly identify and replace if necessary"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nchecks a string for a possible side string token and returns the first possible side string token.", "response": "def get_side(cls, name, ignore=''):\n        \"\"\" Checks a string for a possible side string token, this assumes its on its own\n            and is not part of or camel cased and combined with a word.  Returns first found side to reduce duplicates.\n            We can be safe to assume the abbreviation for the side does not have camel casing within its own word.\n\n        :param name: str, string that represents a possible name of an object\n        :param name: str, string that represents a possible name of an object\n        :return: (None, str), either the found permutation of the side found in name or None\n        \"\"\"\n        for side in cls.CONFIG_SIDES:\n            \"\"\" Tried using a regex, however it would've taken too long to debug\n            side_regex = cls._build_abbreviation_regex(side)\n            result = cls._generic_search(name, side_regex, metadata={'side': side}, ignore=ignore)\n            if result:\n                return result\n            \"\"\"\n            for permutations in cls.get_string_camel_patterns(side):\n                for permutation in permutations:\n                    result = cls._generic_search(name, permutation, metadata={'side': side}, ignore=ignore)\n                    if result:\n                        return result\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_discipline(cls, name, ignore='', min_length=3):\n        for discipline in cls.CONFIG_DISCIPLINES:\n            re_abbr = '({RECURSE}(?=[0-9]|[A-Z]|{SEPARATORS}))'.format(\n                RECURSE=cls._build_abbreviation_regex(discipline),\n                SEPARATORS=cls.REGEX_SEPARATORS)\n            matches = cls._get_regex_search(name, re_abbr, ignore=ignore)\n            if matches:\n                matches = [m for m in matches if\n                           re.findall('([a-z]{%d,})' % min_length, m['match'], flags=re.IGNORECASE)]\n                if matches:\n                    return matches[-1]\n        return None", "response": "Checks a string for a possible discipline string token and returns the first found match to reduce duplicates."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_base_naive(cls, name, ignore=''):\n        return cls._get_regex_search(name, cls.REGEX_BASENAME, match_index=0, ignore=ignore)", "response": "Checks a string for a possible base name of an object."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_version(cls, name):\n        # Dates can confuse th\n        # is stuff, so we'll check for that first and remove it from the string if found\n        try:\n            date = cls.get_date(name)\n            date = date['datetime'].strftime(date['format'])\n        except TypeError:\n            pass\n        return cls.get_version_naive(name, ignore=date or '')", "response": "Checks a string for a possible version of an object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_version_naive(cls, name, ignore=''):\n        match = cls._get_regex_search(name, cls.REGEX_VERSION.format(SEP=cls.REGEX_SEPARATORS), ignore=ignore)\n\n        if match is not None:\n            if len(match) > 1:\n                for m in match:\n                    m.update({'version': int(m['match'].upper().replace('V', ''))})\n                compound_version = '.'.join([str(m['version']) for m in match])\n                compound_version = float(compound_version) if compound_version.count('.') == 1 else compound_version\n                return {'compound_matches': match,\n                        'compound_version': compound_version,\n                        'pattern': match[0]['pattern'],\n                        'input': match[0]['input']}\n\n            elif len(match) == 1:\n                match = match[0]\n                match.update({'version': int(match['match'].upper().replace('V', ''))})\n                return match\n\n        return None", "response": "Checks a string for a possible version of an object and returns the version number and the string matches\n           "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_udim(cls, name):\n        match = cls._get_regex_search(name, cls.REGEX_UDIM, match_index=-1)\n        if match:\n            match.update({'match_int': int(match['match'])})\n            return match\n        return None", "response": "Checks a string for a possible base name of an object and returns the last found match."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_date(cls, name):\n        time_formats = ['%Y-%m-%d_%H-%M-%S',\n                        '%Y-%m-%d-%H-%M-%S',\n                        '%Y-%m-%d--%H-%M-%S',\n                        '%y_%m_%dT%H_%M_%S',\n                        '%Y-%m-%d%H-%M-%S',\n                        '%Y%m%d-%H%M%S',\n                        '%Y%m%d-%H%M',\n                        '%Y-%m-%d',\n                        '%Y%m%d',\n                        '%m_%d_%Y',\n                        '%m_%d_%y',\n                        '%m%d%y',\n                        '%m%d%Y',\n                        '%d_%m_%Y',\n                        '%Y',\n                        '%m-%d-%yy',\n                        '%m%d%Y']\n\n        mapping = [('%yy', '(([01]\\d{1}))'), ('%Y', '((19|20)\\d{2})'), ('%y', '(\\d{2})'), ('%d', '(\\d{2})'),\n                   ('%m', '(\\d{2})'),\n                   ('%H', '(\\d{2})'), ('%M', '(\\d{2})'), ('%S', '(\\d{2})')]\n        time_regexes = []\n        for time_format in time_formats:\n            for k, v in mapping:\n                time_format = time_format.replace(k, v)\n            time_regexes.append(time_format)\n\n        for time_regex, time_format in zip(time_regexes, time_formats):\n            match = cls._get_regex_search(name,\n                                          cls.REGEX_DATE % time_regex,\n                                          metadata={'format': time_format},\n                                          match_index=0)\n            if match:\n                try:\n                    match.update({\n                        'datetime': datetime.datetime.strptime(match['match'], time_format.replace('%yy', '%y'))\n                    })\n                    return match\n                except ValueError:\n                    pass\n        return None", "response": "Checks a string for a possible date formatted into the name."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a list of possible camel casing patterns for the given name.", "response": "def get_string_camel_patterns(cls, name, min_length=0):\n        \"\"\" Finds all permutations of possible camel casing of the given name\n\n        :param name: str, the name we need to get all possible permutations and abbreviations for\n        :param min_length: int, minimum length we want for abbreviations\n        :return: list(list(str)), list casing permutations of list of abbreviations\n        \"\"\"\n        # Have to check for longest first and remove duplicates\n        patterns = []\n        abbreviations = list(set(cls._get_abbreviations(name, output_length=min_length)))\n        abbreviations.sort(key=len, reverse=True)\n\n        for abbr in abbreviations:\n            # We won't check for abbreviations that are stupid eg something with apparent camel casing within\n            # the word itself like LeF, sorting from:\n            # http://stackoverflow.com/questions/13954841/python-sort-upper-case-and-lower-case\n            casing_permutations = list(set(cls._get_casing_permutations(abbr)))\n            casing_permutations.sort(key=lambda v: (v.upper(), v[0].islower(), len(v)))\n            permutations = [permutation for permutation in casing_permutations if\n                            cls.is_valid_camel(permutation) or len(permutation) <= 2]\n            if permutations:\n                patterns.append(permutations)\n\n        return patterns"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _reduce_name(cls, name, parse_dict):\n        # Now remove all found entries to make basename regex have an easier time\n        removal_indices = []\n        for section, match in iteritems(parse_dict):\n            try:\n                matches = []\n                if isinstance(match, dict) and 'compound_matches' in match:\n                    matches = match.get('compound_matches')\n                elif not isinstance(match, list) and match is not None:\n                    matches = [match]\n\n                for m in matches:\n                    valid_slice = True\n                    slice_a, slice_b = m.get('position')\n                    # Adjust slice positions from previous slices\n                    if removal_indices is []:\n                        removal_indices.append((slice_a, slice_b))\n\n                    for r_slice_a, r_slice_b in removal_indices:\n                        if slice_a == r_slice_a and slice_b == r_slice_b:\n                            valid_slice = False\n                        if slice_a > r_slice_a or slice_a > r_slice_b or slice_b > r_slice_b or slice_b > r_slice_a:\n                            slice_delta = r_slice_b - r_slice_a\n                            slice_a -= slice_delta\n                            slice_b -= slice_delta\n\n                    if valid_slice:\n                        name = cls._string_remove_slice(name, slice_a, slice_b)\n                        removal_indices.append((slice_a, slice_b))\n            except (IndexError, TypeError):\n                pass\n        return name", "response": "Reduces a name against matches found in a parse dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nuse this so that all results from the functions return similar results :param input_string: str, input string to be checked :param regex: str, input regex to be compiled and searched with :param match_index: (int, None), whether to get a specific match, if None returns all matches as list :param metadata: dict, dictionary of extra meta tags needed to identify information :return: list(dict), list of dictionaries if multiple hits or a specific entry or None", "response": "def _get_regex_search(input_string, regex, metadata={}, match_index=None, ignore='', flags=0):\n        \"\"\" Using this so that all results from the functions return similar results\n\n        :param input_string: str, input string to be checked\n        :param regex: str, input regex to be compiled and searched with\n        :param match_index: (int, None), whether to get a specific match, if None returns all matches as list\n        :param metadata: dict, dictionary of extra meta tags needed to identify information\n        :return: list(dict), list of dictionaries if multiple hits or a specific entry or None\n        \"\"\"\n        generator = re.compile(regex, flags=flags).finditer(input_string)\n        matches = []\n        for obj in generator:\n            try:\n                span_a = obj.span(1)\n                group_a = obj.group(1)\n            except IndexError:\n                span_a = obj.span()\n                group_a = obj.group()\n\n            if obj.groups() == ('',):\n                # Not sure how to account for this situation yet, weird regex.\n                return True\n\n            if group_a not in ignore:\n                matches.append({'pattern': regex,\n                                'input': input_string,\n                                'position': span_a,\n                                'position_full': obj.span(),\n                                'match': group_a,\n                                'match_full': obj.group()})\n\n        if matches:\n            for match in matches:\n                match.update(metadata)\n            if match_index is not None:\n                return matches[match_index]\n            return matches\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsearch for a specific string given three types of regex search types. Also auto-checks for camel casing. :param name: str, name of object in question :param search_string: str, string to find and insert into the search regexes :param metadata: dict, metadata to add to the result if we find a match :param ignore: str, ignore specific string for the search :return: dict, dictionary of search results", "response": "def _generic_search(cls, name, search_string, metadata={}, ignore=''):\n        \"\"\" Searches for a specific string given three types of regex search types.  Also auto-checks for camel casing.\n\n        :param name: str, name of object in question\n        :param search_string: str, string to find and insert into the search regexes\n        :param metadata: dict, metadata to add to the result if we find a match\n        :param ignore: str, ignore specific string for the search\n        :return: dict, dictionary of search results\n        \"\"\"\n        patterns = [cls.REGEX_ABBR_SEOS,\n                    cls.REGEX_ABBR_ISLAND,\n                    cls.REGEX_ABBR_CAMEL]\n\n        if not search_string[0].isupper():\n            patterns.remove(cls.REGEX_ABBR_CAMEL)\n\n        for pattern in patterns:\n            search_result = cls._get_regex_search(name,\n                                                  pattern.format(ABBR=search_string, SEP=cls.REGEX_SEPARATORS),\n                                                  metadata=metadata,\n                                                  match_index=0,\n                                                  ignore=ignore)\n            if search_result is not None:\n                if cls.is_valid_camel(search_result.get('match_full'), strcmp=search_result.get('match')):\n                    return search_result\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _get_abbreviations(input_string, output_length=0):\n        for i, j in itertools.combinations(range(len(input_string[1:]) + 1), 2):\n            abbr = input_string[0] + input_string[1:][i:j]\n            if len(abbr) >= output_length:\n                yield abbr\n            elif output_length == 0:\n                yield abbr\n        # Have to add the solitary letter as well\n        if not output_length or output_length == 1:\n            yield input_string[0]", "response": "Generates a list of possible abbreviations for the object_name in the input_string."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef is_valid_camel(cls, input_string, strcmp=None, ignore=''):\n        # clear any non chars from the string\n        if not input_string:\n            return False\n\n        input_string = ''.join([c for c in input_string if c.isalpha()])\n        matches = cls._get_regex_search(input_string,\n                                        cls.REGEX_CAMEL.format(SEP=cls.REGEX_SEPARATORS),\n                                        match_index=0,\n                                        ignore=ignore)\n        if matches or input_string == strcmp:\n            if strcmp:\n                index = input_string.find(strcmp) - 1\n                is_camel = strcmp[0].isupper() and input_string[index].islower()\n                is_input = strcmp == input_string\n                is_start = index + 1 == 0\n                return is_camel or is_input or is_start\n            return True\n        elif len(input_string) == 1:\n            return True\n        return False", "response": "Checks to see if an input string is valid for use in camel casing\n           "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _get_casing_permutations(cls, input_string):\n        if not input_string:\n            yield \"\"\n        else:\n            first = input_string[:1]\n            for sub_casing in cls._get_casing_permutations(input_string[1:]):\n                yield first.lower() + sub_casing\n                yield first.upper() + sub_casing", "response": "Takes a string and gives all possible permutations of casing for comparative purposes\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nremoves the slice from a string", "response": "def _string_remove_slice(input_str, start, end):\n        \"\"\" Removes portions of a string\n\n        :param input_str: str, input string\n        :param start: int, end search index\n        :param end: int, start search index\n        :return: str, the cut string\n        \"\"\"\n        if 0 <= start < end <= len(input_str):\n            return input_str[:start] + input_str[end:]\n        return input_str"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _build_abbreviation_regex(input_string):\n        result=''\n        for char in input_string:\n            result += '[%s%s]?' % (char.upper(), char.lower())\n        return '(%s)' % result", "response": "Builds a recursive regex based on an input string to find possible abbreviations more simply."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nparse the given CLI arguments to get a run configuration.", "response": "def _parse_args(args: List[str]) -> _SetArgumentsRunConfig:\n    \"\"\"\n    Parses the given CLI arguments to get a run configuration.\n    :param args: CLI arguments\n    :return: run configuration derived from the given CLI arguments\n    \"\"\"\n    parser = argparse.ArgumentParser(\n        prog=\"gitlab-set-variables\", description=\"Tool for setting a GitLab project's build variables\")\n    add_common_arguments(parser, project=True)\n    parser.add_argument(\"source\", nargs=\"+\", type=str,\n                        help=\"File to source build variables from. Can be a ini file, JSON file or a shell script \"\n                             \"containing 'export' statements\")\n\n    arguments = parser.parse_args(args)\n    return _SetArgumentsRunConfig(arguments.source, arguments.project, arguments.url, arguments.token, arguments.debug)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_url(url, catch_exception=False):\n    return _get_url(url, catch_exception, urlopen=urllib2.urlopen)", "response": "Get a URL from the NCBI base."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\njoin a list of segments into a URL - like string", "response": "def join_url_parts(*args):\n    \"\"\"\n    Joins a list of segments into a URL-like string\n    :type args: List<string>\n    \"\"\"\n    # check for edge case\n    if len(args) == 1:\n        return args[0]\n\n    return_val = clean_url_segment(args[0])\n\n    for i in range(1, len(args)):\n        arg = args[i]\n\n        if i == len(args) - 1:\n            # no need to remove a trailing slash if this is the last segment\n            return_val += '/' + arg\n        else:\n            # remove a trailing slash so it won't be duplicated\n            return_val += '/' + clean_url_segment(arg)\n\n    return return_val"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting a vector field for a single key.", "response": "def getvector(d,s):\n    '''\n    Get a vector flds data.\n\n    Parameters:\n    -----------\n\n    d -- flds data.\n    s -- key for the data.\n    '''\n    return np.array([d[s+\"x\"],d[s+\"y\"],d[s+\"z\"]]);"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef read_indexed(i,flds=None,sclr=None,\n                 gzip='guess', dir='.', vector_norms=True,\n                 keep_xs=False,gettime=False):\n    '''\n    A smart indexing reader that reads files by names. Looks for files\n    like \"<dir>/flds<i>.p4<compression>\" where dir and the index are\n    passed, as well as stuff from sclrs and saves them into one\n    dictionary. Essentially useful for reading by timestep instead\n    of by file. Assumes that both the flds and sclr are in the same\n    direction.\n\n    Parameters:\n    -----------\n\n    i -- index of file\n\n    Required Keywords:\n    ------------------\n\n    flds  -- list of var's to load from the flds file\n    sclr  -- list of var's to load from the sclr file\n    \n    Either one or both are required.\n\n    Keywords:\n    ---------\n\n    gzip         -- files are gzipped. If gzip is \"guess\",\n                    find a matching file.\n    dir          -- Directory to look for files. Default is .\n    vector_norms -- save the norm of the flds vectors under the\n                    the name of the quantity. Default is True.\n    keep_xs      -- Keep the edges. By default, False.\n    gettime      -- Get the timestamp.\n    '''\n    fldsp4  = '{}/flds{}.p4'.format(dir,i);\n    sclrp4  = '{}/sclr{}.p4'.format(dir,i);\n    fldsgz  = fldsp4 + '.gz';\n    sclrgz  = sclrp4 + '.gz';\n    if gzip == 'guess':\n        fldsname = fldsp4 if os.path.exists(fldsp4) else fldsgz\n        sclrname = sclrp4 if os.path.exists(sclrp4) else sclrgz\n    else:\n        fldsname = fldsgz if gzip else fldsp4;\n        sclrname = sclrgz if gzip else sclrp4;\n    if not (flds or sclr):\n        raise ValueError(\"Must specify flds or sclr to read.\");\n    elif flds is not None and sclr is not None:\n        sd,srt=read(sclrname,\n                    var=sclr,first_sort=True, gzip='guess',\n                    keep_xs=keep_xs);\n        fd=read(fldsname,\n                var=flds, sort=srt, gzip='guess',\n                keep_xs=keep_xs);\n        ret = dict(sd=sd,fd=fd);\n        ret.update({k:sd[k] for k in sd});\n        ret.update({k:fd[k] for k in fd});\n        if vector_norms:\n            ret.update({k:vector_norm(ret,k) for k in flds})\n        if gettime:\n            ret['t'] = get_header(sclrname,gzip='guess')['timestamp'];\n    else:\n        if flds:\n            var = flds;\n            name= fldsname;\n        else:\n            var = sclr;\n            name= sclrname;\n        ret,_ = read(name,var=var,first_sort=True,gzip='guess');\n        if flds and vector_norms:\n            ret.update({k:vector_norm(ret,k) for k in flds})\n        if gettime:\n            ret['t'] = get_header(name,gzip='guess')['timestamp'];\n    return ret;", "response": "A smart indexing reader that reads files by name."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nrestricts data by indices.", "response": "def restrict(d,restrict):\n    '''\n    Restrict data by indices.\n\n    Parameters:\n    ----------\n\n    d         -- the flds/sclr data\n    restrict  -- a tuple of [xmin,xmax,...] etx\n    '''\n    notqs = ['t','xs','ys','zs','fd','sd']\n    keys  = [k for k in d if k not in notqs];\n    if len(restrict) == 2:\n        for k in keys:\n            d[k] = d[k][restrict[0]:restrict[1]]\n    elif len(restrict) == 4:\n        for k in keys:\n            d[k] = d[k][\n                restrict[0]:restrict[1],\n                restrict[2]:restrict[3]\n            ];\n    elif len(restrict) == 6:\n        for k in keys:\n            d[k] = d[k][\n                restrict[0]:restrict[1],\n                restrict[2]:restrict[3],\n                restrict[4]:restrict[5]\n            ];\n    else:\n        raise ValueError(\"restrict of length {} is not valid\".format(\n            len(restrict)));"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a url that can be used to serve a single object at a specific dot_path.", "response": "def djurl(dot_path):\n    \"\"\" \n        DEBUG == True ? Compiles and serves file at dot_path\n        DEBUG == False ? Serves pre-compiled file path\n    \n        Usage:  {% djurl 'path.to.file' %}\n    \"\"\"\n    try:\n        http_path = os.path.join(getattr(settings, 'STATIC_URL', ''), djurls[dot_path])\n        if settings.DEBUG:\n            source_path = \"%s.pyj\" % os.path.join(getattr(settings, 'PROJECT_HOME'), *dot_path.split('.'))\n            target_path = os.path.join(getattr(settings, 'STATIC_ROOT'), djurls[dot_path])\n\n            # 1) Parse any templatetags\n            temp_file = open(source_path + \".temp\", 'w')\n            temp_path = temp_file.name\n            fake_response = render_to_response(source_path)\n            temp_file.write(fake_response.content)\n            temp_file.close()\n\n            # 2) Compile to javascript\n            cmd = ['rapydscript', temp_path, '-p' if prettify else '']\n            \n            if djglobals:\n                javascript = \"if(%s === undefined){var %s = {};}\" % (djglobals, djglobals)\n                cmd.insert(0, \"echo '%s' &&\" % javascript)\n\n            output = subprocess.check_output([' '.join(cmd)], shell=True)\n\n            with open(target_path, 'w') as fd:\n                fd.write(output)\n\n        return http_path\n    except Exception as exception:\n        logger.exception(exception)\n        return \"djscript-djurl-exception.500\""}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate a new logger.", "response": "def create_logger(name, level='INFO'):\n    \"\"\"\n    Creates a new ready-to-use logger.\n\n    :param name: new logger's name\n    :type name: str\n    :param level: default logging level.\n    :type level: :class:`str` or :class:`int`\n    :return: new logger.\n    :rtype: :class:`logging.Logger`\n    \"\"\"\n    formatter = ColorFormatter(LOG_FORMAT, DATE_FORMAT)\n    if not isinstance(logging.getLevelName(level), int):\n        level = 'INFO'\n    handler = logging.StreamHandler()\n    handler.setFormatter(formatter)\n    logger = logging.getLogger(name)\n    logger.setLevel(level)\n    logger.addHandler(handler)\n    return logger"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef format(self, record):\n        level_length = len(record.levelname)\n        if record.levelname in self._colors_map:\n            record.msg = '{0}{1}\\033[0;0m'.format(\n                self._colors_map[record.levelname],\n                record.msg\n            )\n            record.levelname = '{0}{1}\\033[0;0m'.format(\n                self._colors_map[record.levelname],\n                record.levelname\n            )\n        record.levelname += ' ' * (8 - level_length)\n        record.name = '\\033[37m\\033[1m{0}\\033[0;0m'.format(record.name)\n        return super(ColorFormatter, self).format(record)", "response": "Override the default format method to add colors to the log level and name attributes."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ntest if the given key - value pairs are instances of the given type.", "response": "def instance_of(target_type: Optional[type] = None, raise_ex: bool = False,\n                    summary: bool = True, **items: Any) -> ValidationReturn:\n        \"\"\"\n        Tests if the given key-value pairs (items) are instances of the given ``target_type``.\n        Per default this function yields whether ``True`` or ``False`` depending on the fact if all\n        items withstand the validation or not. Per default the validation / evaluation is\n        short-circuit and will return as soon an item evaluates to ``False``.\n\n        When ``raise_ex`` is set to ``True`` the function will raise a meaningful error message\n        after the first item evaluates to ``False`` (short-circuit).\n\n        When ``summary`` is set to ``False`` a dictionary is returned containing the individual\n        evaluation result of each item (non short-circuit).\n\n        Examples:\n\n\n            >>> Validator.instance_of(my_str='str', my_str2='str2', target_type=str)\n            True\n            >>> Validator.instance_of(my_str1='str', target_type=int)\n            False\n            >>> Validator.instance_of(my_str=None, raise_ex=True, target_type=str)\n            Traceback (most recent call last):\n                ...\n            ValueError: 'my_str' (NoneType) is not an instance of type 'str'\n            >>> Validator.instance_of(my_str='a', my_str2=1, raise_ex=True, target_type=str)\n            Traceback (most recent call last):\n                ...\n            ValueError: 'my_str2' (int) is not an instance of type 'str'\n            >>> (Validator.instance_of(\n            ...     my_str='str', my_str2='str2', non_str=5, target_type=str, summary=False\n            ... )\n            ... == {'my_str': True, 'my_str2': True, 'non_str': False})\n            True\n\n        Args:\n            raise_ex (bool, optional): If set to ``True`` an exception is raised if at least one\n            item is validated to ``False`` (works short-circuit and will abort the validation when\n            the first item is evaluated to ``False``).\n\n            summary (bool, optional): If set to ``False`` instead of returning just a single\n            `bool` the validation will return a dictionary containing the individual evaluation\n            result of each item.\n\n            target_type (type): The target type to test the values against.\n\n        Returns:\n            (boolean or dictionary): ``True`` when the value was successfully validated; ``False``\n                otherwise.\n            If ``summary`` is set to ``False`` a dictionary containing the individual evaluation\n            result of each item will be returned.\n            If ``raise_ex`` is set to True, instead of returning False a meaningful error will be\n            raised.\n        \"\"\"\n        if not target_type:\n            raise ValueError(\"Argument 'target_type' is None\")\n\n        return Validator.__test_all(\n            condition=lambda _, val: isinstance(val, cast(type, target_type)),\n            formatter=(\n                lambda name, val:\n                \"'{varname}' ({actual}) is not an instance of type '{ttype}'\".format(\n                    varname=name,\n                    actual=type(val).__name__,\n                    ttype=cast(type, target_type).__name__\n                )\n            ),\n            raise_ex=raise_ex,\n            summary=summary,\n            **items\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ntest if the given key - value pairs are all streams.", "response": "def is_stream(raise_ex: bool = False, summary: bool = True,\n                  **items: Any) -> ValidationReturn:\n        \"\"\"\n        Tests if the given key-value pairs (items) are all streams. Basically checks if the item\n        provides a read(...) method.\n        Per default this function yields whether ``True`` or ``False`` depending on the fact if all\n        items withstand the validation or not. Per default the validation / evaluation is\n        short-circuit and will return as soon an item evaluates to ``False``.\n\n        When ``raise_ex`` is set to ``True`` the function will raise a meaningful error message\n        after the first item evaluates to ``False`` (short-circuit).\n\n        When ``summary`` is set to ``False`` a dictionary is returned containing the individual\n        evaluation result of each item (non short-circuit).\n\n        Examples:\n\n            >>> class MyStream():\n            ...     def read(self):\n            ...         pass\n            >>> Validator.is_stream(stream=MyStream())\n            True\n            >>> Validator.is_stream(nonstream='abc')\n            False\n            >>> Validator.is_stream(stream=MyStream(), nonstream='abc', summary=True)\n            False\n            >>> (Validator.is_stream(stream=MyStream(), nonstream='abc', summary=False)\n            ... == {'stream': True, 'nonstream': False})\n            True\n            >>> Validator.is_stream(nonstream='abc', raise_ex=True)\n            Traceback (most recent call last):\n                ...\n            ValueError: 'nonstream' is not a stream\n\n        Args:\n\n            raise_ex (bool, optional): If set to ``True`` an exception is raised if at least one\n            item is validated to ``False`` (works short-circuit and will abort the validation when\n            the first item is evaluated to ``False``).\n\n            summary (bool, optional): If set to ``False`` instead of returning just a single\n            ``bool`` the validation will return a dictionary containing the individual evaluation\n            result of each item.\n\n        Returns:\n            (boolean or dictionary): ``True`` when the value was successfully validated; ``False``\n                otherwise.\n            If ``summary`` is set to ``False`` a dictionary containing the individual evaluation\n            result of each item will be returned.\n            If ``raise_ex`` is set to True, instead of returning False a meaningful error will be\n            raised.\n\n        \"\"\"\n        return Validator.__test_all(\n            condition=lambda _, val: getattr(val, 'read', None) is not None,\n            formatter=lambda name, _: \"'{varname}' is not a stream\".format(varname=name),\n            raise_ex=raise_ex,\n            summary=summary,\n            **items\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef is_file(raise_ex: bool = False, summary: bool = True,\n                **items: Any) -> ValidationReturn:\n        \"\"\"\n        Tests if the given key-value pairs (items) are physical existent files or links to regular\n        files.\n        Per default this function yields whether ``True`` or ``False`` depending on the fact if all\n        items withstand the validation or not. Per default the validation / evaluation is\n        short-circuit and will return as soon an item evaluates to ``False``.\n\n        When ``raise_ex`` is set to ``True`` the function will raise a meaningful error message\n        after the first item evaluates to ``False`` (short-circuit).\n\n        When ``summary`` is set to ``False`` a dictionary is returned containing the individual\n        evaluation result ofeach item (non short-circuit).\n\n        Examples:\n\n            >>> import tempfile\n            >>> tmp = tempfile.NamedTemporaryFile()\n            >>> Validator.is_file(file=tmp.name)\n            True\n            >>> Validator.is_file(nonfile=\"iamsurethatthisdontexist\")\n            False\n            >>> Validator.is_file(file=tmp.name, nonfile=\"iamsurethatthisdontexist\")\n            False\n            >>> (Validator.is_file(file=tmp.name, nonfile=\"iamsurethatthisdontexist\", summary=False)\n            ... == {'file': True, 'nonfile': False})\n            True\n            >>> Validator.is_file(file=tmp.name, nonfile=\"iamsurethatthisdontexist\", raise_ex=True)\n            Traceback (most recent call last):\n                ...\n            ValueError: 'nonfile' is not a file\n            >>> with open(tmp.name) as fp:\n            ...     Validator.is_file(nonfile=fp)\n            False\n\n\n        Args:\n\n            raise_ex (bool, optional): If set to ``True`` an exception is raised if at least one i\n            tem is validated to ``False`` (works short-circuit and will abort the validation when\n            the first item is evaluated to ``False``).\n\n            summary (bool, optional): If set to ``False`` instead of returning just a single\n            ``bool`` the validation will return a dictionary containing the individual evaluation\n            result of each item.\n\n        Returns:\n            (boolean or dictionary): ``True`` when the value was successfully validated; ``False``\n                otherwise.\n            If ``summary`` is set to ``False`` a dictionary containing the individual evaluation\n            result of each item will be returned.\n            If ``raise_ex`` is set to True, instead of returning False a meaningful error will be\n            raised.\n\n        \"\"\"\n        return Validator.__test_all(\n            condition=lambda _, val: Path(val).is_file(),\n            formatter=lambda name, _: \"'{varname}' is not a file\".format(varname=name),\n            validators=[partial(Validator.instance_of, target_type=str)],\n            raise_ex=raise_ex,\n            summary=summary,\n            **items\n        )", "response": "Tests if the given key - value pairs are physical existent files or links to regular files."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef is_real_iterable(raise_ex: bool = False, summary: bool = True,\n                         **items: Any) -> ValidationReturn:\n        \"\"\"\n        Tests if the given items are iterables (collections) but no strings.\n        Per default this function yields whether ``True`` or ``False`` depending on the fact if all\n        items withstand the validation or not. Per default the validation / evaluation is\n        short-circuit and will return as soon an item evaluates to ``False``.\n\n        When ``raise_ex`` is set to ``True`` the function will raise a meaningful error message\n        after the first item evaluates to ``False`` (short-circuit).\n\n        When ``summary`` is set to ``False`` a dictionary is returned containing the individual\n        evaluation result of each item (non short-circuit).\n\n        Examples:\n\n            >>> l = ['i', 'am', 'an', 'iterable']\n            >>> Validator.is_real_iterable(l=l)\n            True\n\n            >>> d = {'i': 'am', 'a': 'dict'}\n            >>> Validator.is_real_iterable(d=d)\n            True\n\n            >>> s = \"i am a string\"\n            >>> Validator.is_real_iterable(s=s)\n            False\n\n            >>> Validator.is_real_iterable(raise_ex=True, s=s)\n            Traceback (most recent call last):\n                ...\n            ValueError: 's' is not an iterable\n\n        Args:\n\n            raise_ex (bool, optional): If set to ``True`` an exception is raised if at least one\n            item is validated to ``False`` (works short-circuit and will abort the validation when\n            the first item is evaluated to ``False``).\n\n            summary (bool, optional): If set to ``False`` instead of returning just a single\n            ``bool`` the validation will return a dictionary containing the individual evaluation\n            result of each item.\n\n        Returns:\n            (boolean or dictionary): ``True`` when the value was successfully validated; ``False``\n                otherwise.\n            If ``summary`` is set to ``False`` a dictionary containing the individual evaluation\n            result of each item will be returned.\n            If ``raise_ex`` is set to True, instead of returning False a meaningful error will be\n            raised.\n\n        \"\"\"\n\n        return Validator.__test_all(\n            condition=lambda _, val: hasattr(val, '__iter__') and not isinstance(val, str),\n            formatter=lambda name, _: \"'{varname}' is not an iterable\".format(varname=name),\n            raise_ex=raise_ex,\n            summary=summary,\n            **items\n        )", "response": "Tests if the given items are iterables and returns whether they are valid real - length."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ngive a list of authors from the parser instantiate contributors objects and build them", "response": "def build_contributors(authors, contrib_type, competing_interests=None):\n    \"\"\"\n    Given a list of authors from the parser, instantiate contributors\n    objects and build them\n    \"\"\"\n\n    contributors = []\n\n    for author in authors:\n        contributor = None\n        author_contrib_type = contrib_type\n\n        surname = author.get(\"surname\")\n        given_name = author.get(\"given-names\")\n        collab = author.get(\"collab\")\n\n        # Small hack for on-behalf-of type when building authors\n        #  use on-behalf-of as the contrib_type\n        if author.get(\"type\") and author.get(\"type\") == \"on-behalf-of\":\n            collab = author.get(\"on-behalf-of\")\n            author_contrib_type = \"on-behalf-of\"\n\n        if surname or collab:\n            contributor = ea.Contributor(author_contrib_type, surname, given_name, collab)\n\n        utils.set_attr_if_value(contributor, 'suffix', author.get('suffix'))\n\n        contributor.group_author_key = author.get(\"group-author-key\")\n        contributor.orcid = author.get(\"orcid\")\n        contributor.corresp = bool(author.get(\"corresp\"))\n        if author.get(\"equal-contrib\") == \"yes\":\n            contributor.equal_contrib = True\n\n        # Add contributor affiliations\n        for aff in author.get(\"affiliations\", []):\n            affiliation = ea.Affiliation()\n            affiliation.text = utils.text_from_affiliation_elements(\n                aff.get(\"dept\"),\n                aff.get(\"institution\"),\n                aff.get(\"city\"),\n                aff.get(\"country\"))\n            # fall back if no other fields are set take the text content\n            if affiliation.text == '':\n                affiliation.text = aff.get(\"text\")\n            contributor.set_affiliation(affiliation)\n\n        # competing interests / conflicts\n        if (competing_interests and author.get(\"references\")\n            and \"competing-interest\" in author.get(\"references\")):\n            for ref_id in author[\"references\"][\"competing-interest\"]:\n                for competing_interest in competing_interests:\n                    if competing_interest.get(\"text\") and competing_interest.get(\"id\") == ref_id:\n                        clean_text = utils.remove_tag('p', competing_interest.get(\"text\"))\n                        contributor.set_conflict(clean_text)\n\n        # Finally add the contributor to the list\n        if contributor:\n            contributors.append(contributor)\n\n    return contributors"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef build_funding(award_groups):\n    if not award_groups:\n        return []\n\n    funding_awards = []\n\n    for award_groups_item in award_groups:\n        for award_group_id, award_group in iteritems(award_groups_item):\n            award = ea.FundingAward()\n            award.award_group_id = award_group_id\n            if award_group.get('id-type') == \"FundRef\":\n                award.institution_id = award_group.get('id')\n\n            award.institution_name = award_group.get('institution')\n\n            # TODO !!! Check for multiple award_id, if exists\n            if award_group.get('award-id'):\n                award.add_award_id(award_group.get('award-id'))\n\n            funding_awards.append(award)\n\n    return funding_awards", "response": "Given a funding data build a list of award awards."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef build_datasets(datasets_json):\n    if not datasets_json:\n        return []\n\n    datasets = []\n    dataset_type_map = OrderedDict([\n        ('generated', 'datasets'),\n        ('used', 'prev_published_datasets')\n    ])\n    dataset_type_map_found = []\n    # First look for the types of datasets present\n    for dataset_key, dataset_type in iteritems(dataset_type_map):\n        if datasets_json.get(dataset_key):\n            dataset_type_map_found.append(dataset_key)\n    # Continue with the found dataset types\n    for dataset_key in dataset_type_map_found:\n        dataset_type = dataset_type_map.get(dataset_key)\n        for dataset_values in datasets_json.get(dataset_key):\n            dataset = ea.Dataset()\n            utils.set_attr_if_value(dataset, 'dataset_type', dataset_type)\n            utils.set_attr_if_value(dataset, 'year', dataset_values.get('date'))\n            utils.set_attr_if_value(dataset, 'title', dataset_values.get('title'))\n            utils.set_attr_if_value(dataset, 'comment', dataset_values.get('details'))\n            utils.set_attr_if_value(dataset, 'doi', dataset_values.get('doi'))\n            utils.set_attr_if_value(dataset, 'uri', dataset_values.get('uri'))\n            utils.set_attr_if_value(dataset, 'accession_id', dataset_values.get('dataId'))\n            utils.set_attr_if_value(dataset, 'assigning_authority', \n                                    dataset_values.get('assigningAuthority'))\n            # authors\n            if dataset_values.get('authors'):\n                # parse JSON format authors into author objects\n                for author_json in dataset_values.get('authors'):\n                    if utils.author_name_from_json(author_json):\n                        dataset.add_author(utils.author_name_from_json(author_json))\n            # Try to populate the doi attribute if the uri is a doi\n            if not dataset.doi and dataset.uri:\n                if dataset.uri != eautils.doi_uri_to_doi(dataset.uri):\n                    dataset.doi = eautils.doi_uri_to_doi(dataset.uri)\n            datasets.append(dataset)\n    return datasets", "response": "Given a JSON format datasets in JSON format build and return a list of datasets"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngiving a datasets in JSON format get the data availability from it if present", "response": "def build_data_availability(datasets_json):\n    \"\"\"\n    Given datasets in JSON format, get the data availability from it if present\n    \"\"\"\n    data_availability = None\n    if 'availability' in datasets_json and datasets_json.get('availability'):\n        # only expect one paragraph of text\n        data_availability = datasets_json.get('availability')[0].get('text')\n    return data_availability"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef build_ref_list(refs):\n    ref_list = []\n    for reference in refs:\n        ref = ea.Citation()\n        # Publcation Type\n        utils.set_attr_if_value(ref, 'publication_type', reference.get('publication-type'))\n        # id\n        utils.set_attr_if_value(ref, 'id', reference.get('id'))\n        # Article title\n        utils.set_attr_if_value(ref, 'article_title', reference.get('full_article_title'))\n        # Source\n        utils.set_attr_if_value(ref, 'source', reference.get('source'))\n        # Volume\n        utils.set_attr_if_value(ref, 'volume', reference.get('volume'))\n        # Issue\n        utils.set_attr_if_value(ref, 'issue', reference.get('issue'))\n        # First page\n        utils.set_attr_if_value(ref, 'fpage', reference.get('fpage'))\n        # Last page\n        utils.set_attr_if_value(ref, 'lpage', reference.get('lpage'))\n        # DOI\n        utils.set_attr_if_value(ref, 'doi', reference.get('doi'))\n        # Year\n        utils.set_attr_if_value(ref, 'year', reference.get('year'))\n        # Year date in iso 8601 format\n        utils.set_attr_if_value(ref, 'year_iso_8601_date', reference.get('year-iso-8601-date'))\n        # Can set the year_numeric now\n        if ref.year_iso_8601_date is not None:\n            # First preference take it from the iso 8601 date, if available\n            try:\n                ref.year_numeric = int(ref.year_iso_8601_date.split('-')[0])\n            except ValueError:\n                ref.year_numeric = None\n        if ref.year_numeric is None:\n            # Second preference, use the year value if it is entirely numeric\n            if utils.is_year_numeric(ref.year):\n                ref.year_numeric = ref.year\n        # date-in-citation\n        utils.set_attr_if_value(ref, 'date_in_citation', reference.get('date-in-citation'))\n        # elocation-id\n        utils.set_attr_if_value(ref, 'elocation_id', reference.get('elocation-id'))\n        # uri\n        utils.set_attr_if_value(ref, 'uri', reference.get('uri'))\n        if not ref.uri:\n            # take uri value from uri_text\n            utils.set_attr_if_value(ref, 'uri', reference.get('uri_text'))\n        # pmid\n        utils.set_attr_if_value(ref, 'pmid', reference.get('pmid'))\n        # isbn\n        utils.set_attr_if_value(ref, 'isbn', reference.get('isbn'))\n        # accession\n        utils.set_attr_if_value(ref, 'accession', reference.get('accession'))\n        # patent\n        utils.set_attr_if_value(ref, 'patent', reference.get('patent'))\n        # patent country\n        utils.set_attr_if_value(ref, 'country', reference.get('country'))\n        # publisher-loc\n        utils.set_attr_if_value(ref, 'publisher_loc', reference.get('publisher_loc'))\n        # publisher-name\n        utils.set_attr_if_value(ref, 'publisher_name', reference.get('publisher_name'))\n        # edition\n        utils.set_attr_if_value(ref, 'edition', reference.get('edition'))\n        # version\n        utils.set_attr_if_value(ref, 'version', reference.get('version'))\n        # chapter-title\n        utils.set_attr_if_value(ref, 'chapter_title', reference.get('chapter-title'))\n        # comment\n        utils.set_attr_if_value(ref, 'comment', reference.get('comment'))\n        # data-title\n        utils.set_attr_if_value(ref, 'data_title', reference.get('data-title'))\n        # conf-name\n        utils.set_attr_if_value(ref, 'conf_name', reference.get('conf-name'))\n        # Authors\n        if reference.get('authors'):\n            for author in reference.get('authors'):\n                ref_author = {}\n                eautils.set_if_value(ref_author, 'group-type', author.get('group-type'))\n                eautils.set_if_value(ref_author, 'surname', author.get('surname'))\n                eautils.set_if_value(ref_author, 'given-names', author.get('given-names'))\n                eautils.set_if_value(ref_author, 'collab', author.get('collab'))\n                if ref_author:\n                    ref.add_author(ref_author)\n        # Try to populate the doi attribute if the uri is a doi\n        if not ref.doi and ref.uri:\n            if ref.uri != eautils.doi_uri_to_doi(ref.uri):\n                ref.doi = eautils.doi_uri_to_doi(ref.uri)\n        # Append the reference to the list\n        ref_list.append(ref)\n    return ref_list", "response": "Given parsed references build a list of ref objects\n   "}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the component title", "response": "def component_title(component):\n    \"\"\"\n    Label, title and caption\n    Title is the label text plus the title text\n    Title may contain italic tag, etc.\n    \"\"\"\n\n    title = u''\n\n    label_text = u''\n    title_text = u''\n    if component.get('label'):\n        label_text = component.get('label')\n\n    if component.get('title'):\n        title_text = component.get('title')\n\n    title = unicode_value(label_text)\n    if label_text != '' and title_text != '':\n        title += ' '\n    title += unicode_value(title_text)\n\n    if component.get('type') == 'abstract' and title == '':\n        title = 'Abstract'\n\n    return title"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngiving a list of parsed components build a list of component objects", "response": "def build_components(components):\n    \"\"\"\n    Given parsed components build a list of component objects\n    \"\"\"\n    component_list = []\n\n    for comp in components:\n        component = ea.Component()\n\n        # id\n        component.id = comp.get('id')\n\n        # type\n        component.type = comp.get('type')\n\n        # asset, if available\n        component.asset = comp.get('asset')\n\n        # DOI\n        component.doi = comp.get('doi')\n\n        if component_title(comp) != '':\n            component.title = component_title(comp)\n\n        # Subtitle\n        if comp.get('type') in ['supplementary-material', 'fig']:\n\n            if comp.get('full_caption'):\n                subtitle = comp.get('full_caption')\n                subtitle = clean_abstract(subtitle)\n                component.subtitle = subtitle\n\n        # Mime type\n        if comp.get('type') in ['abstract', 'table-wrap', 'sub-article',\n                                'chem-struct-wrap', 'boxed-text']:\n            component.mime_type = 'text/plain'\n        if comp.get('type') in ['fig']:\n            component.mime_type = 'image/tiff'\n        elif comp.get('type') in ['media', 'supplementary-material']:\n            if comp.get('mimetype') and comp.get('mime-subtype'):\n                component.mime_type = (comp.get('mimetype') + '/'\n                                       + comp.get('mime-subtype'))\n\n        # Permissions\n        component.permissions = comp.get('permissions')\n\n        # Append it to our list of components\n        component_list.append(component)\n\n    return component_list"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngiving parsed data build a list of related article objects", "response": "def build_related_articles(related_articles):\n    \"\"\"\n    Given parsed data build a list of related article objects\n    \"\"\"\n    article_list = []\n\n    for related_article in related_articles:\n        article = ea.RelatedArticle()\n        if related_article.get('xlink_href'):\n            article.xlink_href = related_article.get('xlink_href')\n        if related_article.get('related_article_type'):\n            article.related_article_type = related_article.get('related_article_type')\n        if related_article.get('ext_link_type'):\n            article.ext_link_type = related_article.get('ext_link_type')\n\n        # Append it to our list\n        article_list.append(article)\n\n    return article_list"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconverts pub_dates into ArticleDate objects and add them to article", "response": "def build_pub_dates(article, pub_dates):\n    \"convert pub_dates into ArticleDate objects and add them to article\"\n    for pub_date in pub_dates:\n        # always want a date type, take it from pub-type if must\n        if pub_date.get('date-type'):\n            date_instance = ea.ArticleDate(pub_date.get('date-type'),\n                                           pub_date.get('date'))\n        elif pub_date.get('pub-type'):\n            date_instance = ea.ArticleDate(pub_date.get('pub-type'),\n                                           pub_date.get('date'))\n        # Set more values\n        utils.set_attr_if_value(date_instance, 'pub_type', pub_date.get('pub-type'))\n        utils.set_attr_if_value(date_instance, 'publication_format',\n                                pub_date.get('publication-format'))\n        utils.set_attr_if_value(date_instance, 'day', pub_date.get('day'))\n        utils.set_attr_if_value(date_instance, 'month', pub_date.get('month'))\n        utils.set_attr_if_value(date_instance, 'year', pub_date.get('year'))\n        article.add_date(date_instance)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nparse the self - uri tags build Uri objects", "response": "def build_self_uri_list(self_uri_list):\n    \"parse the self-uri tags, build Uri objects\"\n    uri_list = []\n    for self_uri in self_uri_list:\n        uri = ea.Uri()\n        utils.set_attr_if_value(uri, 'xlink_href', self_uri.get('xlink_href'))\n        utils.set_attr_if_value(uri, 'content_type', self_uri.get('content-type'))\n        uri_list.append(uri)\n    return uri_list"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nremoves unwanted tags from an abstract string", "response": "def clean_abstract(abstract, remove_tags=['xref', 'ext-link', 'inline-formula', 'mml:*']):\n    \"\"\"\n    Remove unwanted tags from abstract string,\n    parsing it as HTML, then only keep the body paragraph contents\n    \"\"\"\n    if remove_tags:\n        for tag_name in remove_tags:\n            abstract = utils.remove_tag(tag_name, abstract)\n    return abstract"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nbuild an eLifePOA article object from an XML file.", "response": "def build_article_from_xml(article_xml_filename, detail=\"brief\",\n                           build_parts=None, remove_tags=None):\n    \"\"\"\n    Parse JATS XML with elifetools parser, and populate an\n    eLifePOA article object\n    Basic data crossref needs: article_id, doi, title, contributors with names set\n    detail=\"brief\" is normally enough,\n    detail=\"full\" will populate all the contributor affiliations that are linked by xref tags\n    \"\"\"\n    build_part = lambda part: build_part_check(part, build_parts)\n\n    error_count = 0\n\n    soup = parser.parse_document(article_xml_filename)\n\n    # Get DOI\n    doi = parser.doi(soup)\n\n    # Create the article object\n    article = ea.Article(doi, title=None)\n\n    # article version from the filename if possible\n    utils.set_attr_if_value(article, 'version',\n                            utils.version_from_xml_filename(article_xml_filename))\n\n    # journal title\n    if build_part('basic'):\n        article.journal_title = parser.journal_title(soup)\n\n    # issn\n    if build_part('basic'):\n        article.journal_issn = parser.journal_issn(soup, \"electronic\")\n        if article.journal_issn is None:\n            article.journal_issn = parser.journal_issn(soup)\n\n    # Related articles\n    if build_part('related_articles'):\n        article.related_articles = build_related_articles(parser.related_article(soup))\n\n    # Get publisher_id pii\n    if build_part('basic'):\n        article.pii = parser.publisher_id(soup)\n\n    # set object manuscript value\n    if build_part('basic'):\n        manuscript = parser.publisher_id(soup)\n        if not manuscript and doi:\n            # try to get it from the DOI\n            manuscript = doi.split('.')[-1]\n        article.manuscript = manuscript\n\n    # Set the articleType\n    if build_part('basic'):\n        article_type = parser.article_type(soup)\n        if article_type:\n            article.article_type = article_type\n\n    # title\n    if build_part('basic'):\n        article.title = parser.full_title(soup)\n    #print article.title\n\n    # publisher_name\n    if build_part('basic'):\n        article.publisher_name = parser.publisher(soup)\n\n    # abstract\n    if build_part('abstract'):\n        article.abstract = clean_abstract(parser.full_abstract(soup), remove_tags)\n\n    # digest\n    if build_part('abstract'):\n        article.digest = clean_abstract(parser.full_digest(soup), remove_tags)\n\n    # elocation-id\n    if build_part('basic'):\n        article.elocation_id = parser.elocation_id(soup)\n\n    # issue\n    if build_part('basic'):\n        article.issue = parser.issue(soup)\n\n    # self-uri\n    if build_part('basic'):\n        article.self_uri_list = build_self_uri_list(parser.self_uri(soup))\n\n    # contributors\n    if build_part('contributors'):\n        # get the competing interests if available\n        competing_interests = parser.competing_interests(soup, None)\n        all_contributors = parser.contributors(soup, detail)\n        author_contributors = [con for con in all_contributors\n                               if con.get('type') in ['author', 'on-behalf-of']]\n        contrib_type = \"author\"\n        contributors = build_contributors(author_contributors, contrib_type, competing_interests)\n\n        contrib_type = \"author non-byline\"\n        authors = parser.authors_non_byline(soup, detail)\n        contributors_non_byline = build_contributors(authors, contrib_type, competing_interests)\n        article.contributors = contributors + contributors_non_byline\n\n    # license href\n    if build_part('license'):\n        license_object = ea.License()\n        license_object.href = parser.license_url(soup)\n        license_object.copyright_statement = parser.copyright_statement(soup)\n        article.license = license_object\n\n    # article_category\n    if build_part('categories'):\n        article.article_categories = parser.category(soup)\n\n    # keywords\n    if build_part('keywords'):\n        article.author_keywords = parser.keywords(soup)\n\n    # research organisms\n    if build_part('research_organisms'):\n        article.research_organisms = parser.research_organism(soup)\n\n    # funding awards\n    if build_part('funding'):\n        article.funding_awards = build_funding(parser.full_award_groups(soup))\n\n    # datasets\n    if build_part('datasets'):\n        datasets_json = parser.datasets_json(soup)\n        article.datasets = build_datasets(datasets_json)\n        article.data_availability = build_data_availability(datasets_json)\n\n    # references or citations\n    if build_part('references'):\n        article.ref_list = build_ref_list(parser.refs(soup))\n\n    # components with component DOI\n    if build_part('components'):\n        article.component_list = build_components(parser.components(soup))\n\n    # History dates\n    if build_part('history'):\n        date_types = [\"received\", \"accepted\"]\n        for date_type in date_types:\n            history_date = parser.history_date(soup, date_type)\n            if history_date:\n                date_instance = ea.ArticleDate(date_type, history_date)\n                article.add_date(date_instance)\n\n    # Pub date\n    if build_part('pub_dates'):\n        build_pub_dates(article, parser.pub_dates(soup))\n\n    # Set the volume if present\n    if build_part('volume'):\n        volume = parser.volume(soup)\n        if volume:\n            article.volume = volume\n\n    if build_part('is_poa'):\n        article.is_poa = parser.is_poa(soup)\n\n    return article, error_count"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef build_articles_from_article_xmls(article_xmls, detail=\"full\",\n                                     build_parts=None, remove_tags=None):\n    \"\"\"\n    Given a list of article XML filenames, convert to article objects\n    \"\"\"\n\n    poa_articles = []\n\n    for article_xml in article_xmls:\n        print(\"working on \", article_xml)\n        article, error_count = build_article_from_xml(article_xml, detail,\n                                                      build_parts, remove_tags)\n        if error_count == 0:\n            poa_articles.append(article)\n\n    return poa_articles", "response": "Given a list of article XML filenames convert to article objects"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef accounts():\n    import yaml\n\n    for path in account_files:\n        try:\n\n            c_dir = os.path.dirname(path)\n\n            if not os.path.exists(c_dir):\n                os.makedirs(c_dir)\n\n            with open(path, 'rb') as f:\n                return yaml.load(f)['accounts']\n\n        except (OSError, IOError) as e:\n            pass\n\n    return {}", "response": "Load the accounts YAML file and return a dict"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a new cache object with the given configuration.", "response": "def new_cache(config, root_dir='no_root_dir'):\n    \"\"\"Return a new :class:`FsCache` built on the configured cache directory\n    \"\"\"\n\n    if isinstance(config, basestring):\n        config = parse_cache_string(config, root_dir)\n\n    if 'size' in config:\n        from filesystem import FsLimitedCache\n        fsclass = FsLimitedCache\n\n    elif 'bucket' in config:\n        from s3 import S3Cache\n        fsclass = S3Cache\n\n    elif 'url' in config:\n        from http import HttpCache\n        fsclass = HttpCache\n\n    elif 'dir' in config:\n        from filesystem import FsCache\n        fsclass = FsCache\n\n    else:\n        raise ConfigurationError(\n            \"Can't determine cache type: {} \".format(config))\n\n    # Re-write account to get login credentials, if the run_config is available\n    if 'account' in config and isinstance(config['account'], basestring):\n\n        acts = accounts()\n\n        if not config['account'] in acts:\n            raise ConfigurationError(\n                \"Accounts dict does not include account '{}': {} \" .format(\n                    config['account'],\n                    acts))\n\n        config['account'] = acts[config['account']]\n\n    if 'upstream' in config:\n        config['upstream'] = new_cache(config['upstream'], root_dir=root_dir)\n\n    if 'options' in config:\n        options = config['options']\n    else:\n        options = []\n\n    cache = fsclass(**dict(config))\n\n    if 'compress' in options:\n        from filesystem import FsCompressionCache\n        cache = FsCompressionCache(upstream=cache)\n\n    if 'async' in options:\n        from async import ThreadedWriteCache\n        cache = ThreadedWriteCache(upstream=cache)\n\n    if 'log' in options:\n        from async import LoggingCache\n        cache = LoggingCache(upstream=cache)\n\n    return cache"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_logger(\n        name, file_name=None, stream=None, template=None, propagate=False):\n    \"\"\"Get a logger by name\n\n    if file_name is specified, and the dirname() of the file_name exists, it will\n    write to that file. If the dirname dies not exist, it will silently ignre it. \"\"\"\n\n    logger = logging.getLogger(name)\n\n    if propagate is not None:\n        logger.propagate = propagate\n\n    for handler in logger.handlers:\n        logger.removeHandler(handler)\n\n    if not template:\n        template = \"%(name)s %(process)s %(levelname)s %(message)s\"\n\n    formatter = logging.Formatter(template)\n\n    if not file_name and not stream:\n        stream = sys.stdout\n\n    handlers = []\n\n    if stream is not None:\n\n        handlers.append(logging.StreamHandler(stream=stream))\n\n    if file_name is not None:\n\n        if os.path.isdir(os.path.dirname(file_name)):\n            handlers.append(logging.FileHandler(file_name))\n        else:\n            print(\"ERROR: Can't open log file {}\".format(file_name))\n\n    for ch in handlers:\n        ch.setFormatter(formatter)\n        logger.addHandler(ch)\n\n    logger.setLevel(logging.INFO)\n\n    return logger", "response": "Get a logger by name."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef md5_for_file(f, block_size=2 ** 20):\n    import hashlib\n\n    md5 = hashlib.md5()\n    try:\n        # Guess that f is a FLO.\n        f.seek(0)\n\n        while True:\n            data = f.read(block_size)\n            if not data:\n                break\n            md5.update(data)\n        return md5.hexdigest()\n\n    except AttributeError as e:\n        # Nope, not a FLO. Maybe string?\n\n        file_name = f\n        with open(file_name, 'rb') as f:\n            return md5_for_file(f, block_size)", "response": "Generate an MD5 for a possibly large file"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nclone this case and extend the prefix", "response": "def subcache(self, path):\n        \"\"\"Clone this case, and extend the prefix\"\"\"\n\n        cache = self.clone()\n        cache.prefix = os.path.join(cache.prefix if cache.prefix else '', path)\n\n        return cache"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nlists the cache and store it as metadata.", "response": "def store_list(self, cb=None):\n        \"\"\"List the cache and store it as metadata. This allows for getting the list from HTTP caches\n        and other types where it is not possible to traverse the tree\"\"\"\n\n        from StringIO import StringIO\n        import json\n\n        d = {}\n\n        for k, v in self.list().items():\n\n            if 'caches' in v:\n                del v['caches']\n\n            d[k] = v\n\n        strio = StringIO(json.dumps(d))\n\n        sink = self.put_stream('meta/_list.json')\n\n        copy_file_or_flo(strio, sink, cb=cb)\n        sink.close()"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nattach an upstream to the last upstream.", "response": "def attach(self, upstream):\n        \"\"\"Attach an upstream to the last upstream. Can be removed with detach\"\"\"\n\n        if upstream == self.last_upstream():\n            raise Exception(\"Can't attach a cache to itself\")\n\n        self._prior_upstreams.append(self.last_upstream())\n\n        self.last_upstream().upstream = upstream"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns self or an upstream that has the given class type.", "response": "def get_upstream(self, type_):\n        '''Return self, or an upstream, that has the given class type.\n        This is typically used to find upstream s that impoement the RemoteInterface\n        '''\n\n        if isinstance(self, type_):\n            return self\n        elif self.upstream and isinstance(self.upstream, type_):\n            return self.upstream\n        elif self.upstream:\n            return self.upstream.get_upstream(type_)\n        else:\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ndecode the bytes into a single object.", "response": "def decode(self, a_bytes, encoding):\n        \"\"\"A 'try as much as we can' strategy decoding method.\n\n        'try as much as we can' feature:\n\n        Some time most of byte are encoded correctly. So chardet is able to\n        detect the encoding. But, sometime some bytes in the middle are not\n        encoded correctly. So it is still unable to apply\n        bytes.decode(\"encoding-method\")\n\n        Example::\n\n            b\"82347912350898143059043958290345\" # 3059 is not right.\n            # [-----Good----][-Bad][---Good---]\n\n        What we do is to drop those bad encoded bytes, and try to recovery text\n        as much as possible. So this method is to recursively call it self, and\n        try to decode good bytes chunk, and finally concatenate them together.\n\n        :param a_bytes: the bytes that encoding is unknown.\n        :type a_bytes: bytes\n        :param encoding: how you gonna decode a_bytes\n        :type encoding: str\n        \"\"\"\n        try:\n            return (a_bytes.decode(encoding), encoding)\n        except Exception as e:\n            ind = self.catch_position_in_UnicodeDecodeError_message(str(e))\n            return (a_bytes[:ind].decode(encoding) + self.decode(a_bytes[(ind + 2):], encoding)[0],\n                    encoding)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef autodecode(self, a_bytes):\n        try:  # \u5982\u679c\u88c5\u4e86chardet\n            analysis = chardet.detect(a_bytes)\n            if analysis[\"confidence\"] >= 0.75:  # \u5982\u679c\u53ef\u4fe1\n                return (self.decode(a_bytes, analysis[\"encoding\"])[0],\n                        analysis[\"encoding\"])\n            else:  # \u5982\u679c\u4e0d\u53ef\u4fe1, \u6253\u5370\u5f02\u5e38\n                raise Exception(\"Failed to detect encoding. (%s, %s)\" % (\n                    analysis[\"confidence\"],\n                    analysis[\"encoding\"]))\n        except NameError:  # \u5982\u679c\u6ca1\u6709\u88c5chardet\n            print(\n                \"Warning! chardet not found. Use utf-8 as default encoding instead.\")\n            return (a_bytes.decode(\"utf-8\")[0],\n                    \"utf-8\")", "response": "Automatically detect encoding and decode bytes."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef login(self, url, payload):\n        self.auth = requests.Session()\n        try:\n            self.auth.post(url, data=payload, timeout=self.default_timeout)\n            print(\"successfully logged in to %s\" % url)\n            return True\n        except:\n            return False", "response": "Performe log in to url."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget http request response.", "response": "def get_response(self, url, timeout=None):\n        \"\"\"Return http request response.\n        \"\"\"\n        if not timeout:\n            timeout = self.default_timeout\n\n        if self.default_sleeptime:\n            time.sleep(self.default_sleeptime)\n\n        try:\n            return self.auth.get(url, headers=self.default_header, timeout=self.default_timeout)\n        except:\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef html_with_encoding(self, url, timeout=None, encoding=\"utf-8\"):\n        response = self.get_response(url, timeout=timeout)\n        if response:\n            return self.decoder.decode(response.content, encoding)[0]\n        else:\n            return None", "response": "Manually get html with user encoding setting."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef html(self, url, timeout=None):\n        response = self.get_response(url, timeout=timeout)\n        if response:\n            domain = self.get_domain(url)\n            if domain in self.domain_encoding_map:  # domain have been visited\n                try:  # apply extreme decoding\n                    html = self.decoder.decode(response.content,\n                                               self.domain_encoding_map[domain])[0]\n                    return html\n                except Exception as e:\n                    print(e)\n                    return None\n            else:  # never visit this domain\n                try:\n                    html, encoding = self.decoder.autodecode(response.content)\n                    # save chardet analysis result\n                    self.domain_encoding_map[domain] = encoding\n                    return html\n                except Exception as e:\n                    print(e)\n                    return None\n        else:\n            return None", "response": "High level method to get http request response in text."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndownloading the binary file at url to distination path.", "response": "def download(self, url, dst, timeout=None):\n        \"\"\"Download the binary file at url to distination path.\n        \"\"\"\n        response = self.get_response(url, timeout=timeout)\n        if response:\n            with open(dst, \"wb\") as f:\n                for block in response.iter_content(1024):\n                    if not block:\n                        break\n                    f.write(block)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef handles(self, src, path):\n        if not pathtools.patterns.match_path(path, self.patterns,\n                                             self.ignore_patterns):\n            return None\n\n        return self._outputs(src, path)", "response": "Returns a list of files that this handler will produce after\n        successfully processing path."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef changed(self, src, path, dest):\n        try:\n            mtime = os.path.getmtime(os.path.join(src, path))\n            self._build(src, path, dest, mtime)\n        except EnvironmentError as e:\n            logging.error(\"{0} is inaccessible: {1}\".format(\n                termcolor.colored(path, \"yellow\", attrs=[\"bold\"]),\n                e.args[0]\n            ))", "response": "Called whenever a file or folder is changed in the source folder src. dest is the output folder."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncalling build on all outputs of the file at the given path and dest.", "response": "def _build(self, src, path, dest, mtime):\n        \"\"\"Calls `build` after testing that at least one output file (as\n        returned by `_outputs()` does not exist or is older than `mtime`. If\n        the build fails, the build time is recorded and no other builds will be\n        attempted on `input` until this method is called with a larger mtime.\n        \"\"\"\n        input_path = os.path.join(src, path)\n        output_paths = [os.path.join(dest, output) for output in\n                        self._outputs(src, path)]\n\n        if path in self.failures and mtime <= self.failures[path]:\n            # the input file was not modified since the last recorded failure\n            # as such, assume that the task will fail again and skip it\n            return\n\n        for output in output_paths:\n            try:\n                if \\\n                        os.path.exists(output) and \\\n                        mtime <= os.path.getmtime(output):\n                    # output file exists and is up to date; no need to trigger\n                    # build on this file's expense\n                    continue\n            except EnvironmentError:\n                # usually happens when the output file has been deleted in\n                # between the call to exists and the call to getmtime\n                pass\n\n            start = time.time()\n            try:\n                self.build(input_path, output_paths)\n            except Exception as e:\n                if isinstance(e, EnvironmentError):\n                    # non-zero return code in sub-process; only show message\n                    logging.error(\"{0} failed after {1:.2f}s: {2}\".format(\n                        termcolor.colored(path, \"red\", attrs=[\"bold\"]),\n                        time.time() - start, e.args[0]\n                    ))\n                else:\n                    # probably a bug in the handler; show full trace\n                    logging.exception(\"{0} failed after {1:.2f}s\".format(\n                        termcolor.colored(path, \"red\", attrs=[\"bold\"]),\n                        time.time() - start\n                    ))\n                self.failures[path] = start\n            else:\n                logging.info(\"{0} completed in {1:.2f}s\".format(\n                    termcolor.colored(path, \"green\", attrs=[\"bold\"]),\n                    time.time() - start\n                ))\n                self.failures.pop(path, None)\n            break"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef rebuild_references(self, src, path, reject=None):\n        if reject is None:\n            reject = set()\n        reject.add(path)\n\n        try:\n            filename = os.path.join(src, path)\n            mtime = os.path.getmtime(filename)\n            contents = open(filename)\n        except EnvironmentError:\n            raise ValueError(\"Unable to open '{0}'\".format(path))\n\n        if \\\n                path in self.parents and \\\n                self.parents[path].updated == mtime:\n            # cache hit; no need to update\n            return\n\n        # drop existing references\n        if path in self.parents:\n            self.deleted(src, path)\n\n        # build a list of parents\n        parents = TimedSet(mtime)\n        current = os.path.dirname(path)\n\n        for line in contents:\n            match = self.line_regex.search(line)\n            if match:\n                parent = match.group(1)\n                relative = os.path.normpath(os.path.join(current, parent))\n                if relative.startswith(\"..\"):\n                    raise ValueError(\"Parent reference '{0}' outside of \"\n                                     \"watched folder in '{1}'\".format(parent,\n                                                                      path))\n                parent = os.path.normcase(relative)\n                if parent in reject:\n                    raise ValueError(\"Circular reference to '{0}' \"\n                                     \"detected in '{1}'\".format(parent,\n                                                                path))\n                parents.add(parent)\n\n        for parent in parents:\n            # recursively build references for all parents; this will\n            # usually be a cache hit and no-op\n            self.rebuild_references(src, parent, reject)\n\n        self.parents[path] = parents\n        for parent in parents:\n            # add this node to each of its parents' children\n            if parent not in self.children:\n                self.children[parent] = set()\n            self.children[parent].add(path)", "response": "Rebuilds the list of references for the specified source and path."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nupdates the reference tree when a handled file is deleted.", "response": "def deleted(self, src, path):\n        \"\"\"Update the reference tree when a handled file is deleted.\"\"\"\n        if self.parents[path] is not None:\n            for parent in self.parents[path]:\n                self.children[parent].remove(path)\n                if not self.children[parent]:\n                    del self.children[parent]\n        del self.parents[path]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef changed(self, src, path, dest):\n        modified = {path: self.parents[path].updated}\n\n        while True:\n            for path in modified:\n                if self.parents[path]:\n                    mtime = modified.pop(path)\n                    for parent in self.parents[path]:\n                        modified[parent] = max(mtime,\n                                               self.parents[parent].updated)\n                    break\n            else:\n                break\n\n        for path in modified:\n            self._build(src, path, dest, modified[path])", "response": "This method is called when a file or directory has changed."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a banner string", "response": "def banner(cls, content_=\"Well Come\"):\n        \"\"\"\u751f\u6210\u53603\u884c\u7684\u5b57\u7b26\u4e32\"\"\"\n        # char def\n        sp_char = \"#\"\n        # length calc\n        itsays = content_.strip()\n        effective_length = int(len(itsays))\n        # gen contents\n        side_space = ' ' * int(effective_length * ((1 - 0.618) / 0.618) / 2)\n        content_line = sp_char + side_space + itsays + side_space + sp_char\n        content_line_length = len(content_line)\n        banner_border = sp_char * content_line_length\n        return banner_border + '\\n' + content_line + '\\n' + banner_border"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nclearing the screen for the current platform", "response": "def clearScreen(cls):\n        \"\"\"Clear the screen\"\"\"\n        if \"win32\" in sys.platform:\n            os.system('cls')\n        elif \"linux\" in sys.platform:\n            os.system('clear')\n        elif 'darwin' in sys.platform:\n            os.system('clear')\n        else:\n            cit.err(\"No clearScreen for \" + sys.platform)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef getPyCmd(cls):\n        if \"win32\" in sys.platform:\n            return 'py'\n        elif \"linux\" in sys.platform:\n            return 'python3'\n        elif 'darwin' in sys.platform:\n            return 'python3'\n        else:\n            cit.err(\"No python3 command for \" + sys.platform)", "response": "get OS s python command"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nruns command and show if success or failed", "response": "def runCmd(cls, cmd):\n        \"\"\"run command and show if success or failed\n\n        Args:\n            cmd: string\n        Returns:\n            bool: if this command run successfully\n        \"\"\"\n        cit.echo(cmd, \"command\")\n        result = os.system(cmd)\n        cls.checkResult(result)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nrunning command and return the str format stdout", "response": "def readCmd(cls, cmd):\n        \"\"\"run command and return the str format stdout\n\n        Args:\n            cmd: string\n        Returns:\n            str: what the command's echo\n        \"\"\"\n        args = shlex.split(cmd)\n        proc = subprocess.Popen(args, stdout=subprocess.PIPE)\n        (proc_stdout, proc_stderr) = proc.communicate(input=None)  # proc_stdin\n        return proc_stdout.decode()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nchecking and update file with remote url and return updated file or not", "response": "def updateFile(cls, file_, url):\n        \"\"\"Check and update file compares with remote_url\n\n        Args:\n            file_: str. Local filename. Normally it's __file__\n            url: str. Remote url of raw file content. Normally it's https://raw.github.com/...\n        Returns:\n            bool: file updated or not\n        \"\"\"\n        def compare(s1, s2):\n            return s1 == s2, len(s2) - len(s1)\n\n        if not url or not file_:\n            return False\n        try:\n            req = urllib.request.urlopen(url)\n            raw_codes = req.read()\n            with open(file_, 'rb') as f:\n                current_codes = f.read().replace(b'\\r', b'')\n            is_same, diff = compare(current_codes, raw_codes)\n            if is_same:\n                cit.info(\"{} is already up-to-date.\".format(file_))\n                return False\n            else:\n                cit.ask(\"A new version is available. Update? (Diff: {})\".format(diff))\n                if cit.get_choice(['Yes', 'No']) == 'Yes':\n                    with open(file_, 'wb') as f:\n                        f.write(raw_codes)\n                    cit.info(\"Update Success.\")\n                    return True\n                else:\n                    cit.warn(\"Update Canceled\")\n                    return False\n        except Exception as e:\n            cit.err(\"{f} update failed: {e}\".format(f=file_, e=e))\n            return False"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef ajax(cls, url, param={}, method='get'):\n        param = urllib.parse.urlencode(param)\n        if method.lower() == 'get':\n            req = urllib.request.Request(url + '?' + param)\n        elif method.lower() == 'post':\n            param = param.encode('utf-8')\n            req = urllib.request.Request(url, data=param)\n        else:\n            raise Exception(\"invalid method '{}' (GET/POST)\".format(method))\n        rsp = urllib.request.urlopen(req)\n        if rsp:\n            rsp_json = rsp.read().decode('utf-8')\n            rsp_dict = json.loads(rsp_json)\n            return rsp_dict\n        return None", "response": "Get info by ajax"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ntries different encoding to open a file in readonly mode", "response": "def readFile(cls, filepath):\n        \"\"\"Try different encoding to open a file in readonly mode\"\"\"\n        for mode in (\"utf-8\", 'gbk', 'cp1252', 'windows-1252', 'latin-1'):\n            try:\n                with open(filepath, mode='r', encoding=mode) as f:\n                    content = f.read()\n                    cit.info('\u4ee5 {} \u683c\u5f0f\u6253\u5f00\u6587\u4ef6'.format(mode))\n                    return content\n            except UnicodeDecodeError:\n                cit.warn('\u6253\u5f00\u6587\u4ef6\uff1a\u5c1d\u8bd5 {} \u683c\u5f0f\u5931\u8d25'.format(mode))\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_dir_meta(fp, atts):\n\n    # Attibutes are popped from deepest directory first\n    atts.reverse()\n\n    dirname = os.path.split(fp)[0]\n    meta = dirname.split('/')\n\n    res = {}\n\n    try:\n        for key in atts:\n            res[key] = meta.pop()\n    except IndexError:\n        raise PathError(dirname)\n\n    return res", "response": "Pop path information and map to supplied atts\n   "}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding trionyx context data", "response": "def trionyx(request):\n    \"\"\"Add trionyx context data\"\"\"\n    return {\n        'TX_APP_NAME': settings.TX_APP_NAME,\n        'TX_LOGO_NAME_START': settings.TX_LOGO_NAME_START,\n        'TX_LOGO_NAME_END': settings.TX_LOGO_NAME_END,\n        'TX_LOGO_NAME_SMALL_START': settings.TX_LOGO_NAME_SMALL_START,\n        'TX_LOGO_NAME_SMALL_END': settings.TX_LOGO_NAME_SMALL_END,\n\n        'trionyx_menu_items': app_menu.get_menu_items(),\n    }"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nallows decorator - style construction of URL pattern lists.", "response": "def register(self, pattern, view=None):\n        '''Allow decorator-style construction of URL pattern lists.'''\n        if view is None:\n            return partial(self.register, pattern)\n        self.patterns.append(self._make_url((pattern, view)))\n        return view"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef parse(self):\n\n        if self.type == TOKEN_TYPE[0][1]:\n            try:\n                return Item(\n                    item_id=self._link(None, None)[1],\n                    links=self._link(None, None)[0],\n                    assets=self._asset(None),\n                    properties=self._properties(None)[0],\n                    geometry=self._properties(None)[2]\n                )\n            except ValidationError as e:\n                raise\n        elif self.type == TOKEN_TYPE[1][1]:\n            try:\n                # parallelize item computation\n                items = [self._features_iterator(\n                    feature['id'],\n                    self._link(feature, data.ASSET_TYPE_IMAGE_COLL)[0],\n                    self._asset(\n                        feature['properties']['system:index']\n                    ),\n                    self._properties(feature)[0],\n                    self._properties(feature)[2]\n                ) for feature in self._get_full_info()['features']]\n                res_list = dask.compute(items)[0]\n\n                return Collection(\n                    collection_id=self._get_info()['id'],\n                    features=res_list\n                )\n            except ValidationError as e:\n                raise\n        else:\n            raise TypeError(\"Unrecognized Stac type found.\")", "response": "Parse an asset from Earth Engine to STAC item\n\n       "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nhelp docstring for default shorts", "response": "def clized_default_shorts(p1, p2,\n                          first_option='default_value',\n                          second_option=5,\n                          third_option=[4, 3],\n                          last_option=False):\n    \"\"\"Help docstring\n    \"\"\"\n    print('%s %s %s %s %s %s' % (p1, p2, first_option, second_option, third_option, last_option))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef CourseOfDept(request):\n\tdept = request.GET['dept']\n\tschool = request.GET['school']\n\tc = Course(school=school)\n\treturn JsonResponse(c.getByDept(dept=dept, grade=request.GET['grade'] if 'grade' in request.GET else None), safe=False)", "response": "Generate list of obligatory and optional course of specific Dept."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef CourseOfTime(request):\n\tday = request.GET['day']\n\ttime = request.GET['time']\n\tschool = request.GET['school']\n\tdept = request.GET['dept'].split()\n\tc = Course(school=school)\n\treturn JsonResponse(c.getByTime(day=day, time=time, deptArr=dept), safe=False)", "response": "Generate list of obligatory and optional course of specific Dept."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngenerates dict of Dept and its grade.", "response": "def Genra(request):\n\t\"\"\"\n\t\tGenerate dict of Dept and its grade.\n\t\"\"\"\n\tschool = request.GET['school']\n\tc = Course(school=school)\n\treturn JsonResponse(c.getGenra(), safe=False)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nestablishing the actual TCP connection to the Flickr API", "response": "def _connectToWP(self):\n        \"\"\"Establish the actual TCP connection to Flickr\"\"\"\n\n        if self.connected_to_wp:\n            logger.debug(\"Already connected to wp\")\n            return True\n\n        # Load config from file\n        info=json.load(open(WP_LOGIN_FILE,'r'))\n        self.wp = Client(info['url'],\\\n                info['username'],\\\n                info['password'])\n\n        logger.debug(\"Connecting to wp\")\n\n        self.connected_to_wp=True\n\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef Upload(self,directory,filename):\n\n        db = self._loadDB(directory)\n\n        logger.debug(\"wp: Attempting upload of %s\"%(filename))\n\n        # See if this already exists in our DB\n        if db.has_key(filename):\n            pid=db[filename]\n            logger.debug('wp: Found %s in DB with post id %s'%(filename,pid))\n        else:\n            pid=None\n\n        fullfile=os.path.join(directory,filename)\n\n        fid=open(fullfile,'r');\n\n        # Read meta data and content into dictionary\n        post=self._readMetaAndContent(fid)\n\n        #Connect to WP\n        self._connectToWP()\n\n        # If no pid, it means post is fresh off the press\n        # and not uploaded yet!\n        if not pid:\n            # Get a PID by uploading\n            pid=self.wp.call(NewPost(post))\n            if pid:\n                logger.debug(\"wp: Uploaded post with pid %s\",pid)\n                db[filename]=pid\n                self._saveDB(directory,db)\n                return True\n            else:\n                logger.error(\"wp: Couldn't upload post\")\n                return False\n        else:\n            # Already has PID, replace post\n            logger.debug(\"wp: Replacing post with pid %s\",pid)\n            #FIXME: Check return value?!\n            self.wp.call(EditPost(pid,post))\n            return True\n\n        return False", "response": "Uploads a file to the wp server."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _readMetaAndContent(self,fid):\n        found_meta_separator=False\n\n        d={}\n        # Read lines until we find the meta separator\n        while found_meta_separator is False:\n            line = fid.readline()\n            # Did we find the --- separator it?\n            if line[0:len(self.META_SEPARATOR)]==self.META_SEPARATOR:\n                found_meta_separator=True\n            else:\n                key=line.split(':')[0].strip().lower()\n                if key in self.WP_META_KEYS:\n                    d[key]=line.split(':')[1].strip()\n                else:\n                    logger.error(\"wp: Token '%s' not in list of known tokens %s\"\\\n                            %(key,self.WP_META_KEYS))\n                    return None\n\n        if not d.has_key('title'):\n            print(\"wp: A title: keyword is required!\")\n\n        d['content']=fid.readlines()\n        d['content']=''.join(d['content'])\n\n        \n        # Let's transfer over to a wordpress post class\n        post = WordPressPost()\n        post.title=d['title']\n        post.content=d['content']\n        post.post_status='publish'\n\n        post.terms_names={}\n        if d.has_key('tags'):\n            post.terms_names['post_tag']=d['tags'].split(',')\n        if d.has_key('category'):\n            post.terms_names['category']=d['category'].split(',')\n\n        return post", "response": "Reads meta data and content from file into WordPressPost class."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef Remove(self,directory,filename):\n\n        db = self._loadDB(directory)\n\n        logger.debug(\"wp: Attempting to remove %s from wp\"%(filename))\n\n        # See if this already exists in our DB\n        if db.has_key(filename):\n            pid=db[filename]\n            logger.debug('wp: Found %s in DB with post id %s'%(filename,pid))\n        else:\n            print(\"wp: %s not in our local DB file [%s]\"\\\n                    %(filename,self.DB_FILE))\n            return False\n\n        self._connectToWP()\n        self.wp.call(DeletePost(pid))\n\n        del db[filename]\n        self._saveDB(directory,db)\n\n        return True", "response": "Removes a post from wordpress"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef ne(self, event_property, value):\n        c = self.copy()\n        c.filters.append(filters.NE(event_property, value))\n        return c", "response": "A not - equal filter chain."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef lt(self, event_property, value):\n        c = self.copy()\n        c.filters.append(filters.LT(event_property, value))\n        return c", "response": "A less - than filter chain."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef re(self, event_property, value):\n        c = self.copy()\n        c.filters.append(filters.RE(event_property, value))\n        return c", "response": "A regular expression filter chain."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef startswith(self, event_property, value):\n        c = self.copy()\n        c.filters.append(filters.RE(event_property, \"^{value}\".format(\n            value=value)))\n        return c", "response": "A starts - with filter chain."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget data from all the platforms listed in makerlabs.", "response": "def get_multiple_data():\n    \"\"\"Get data from all the platforms listed in makerlabs.\"\"\"\n\n    # Get data from all the mapped platforms\n    all_labs = {}\n    all_labs[\"diybio_org\"] = diybio_org.get_labs(format=\"dict\")\n    all_labs[\"fablabs_io\"] = fablabs_io.get_labs(format=\"dict\")\n    all_labs[\"makeinitaly_foundation\"] = makeinitaly_foundation.get_labs(\n        format=\"dict\")\n    all_labs[\"hackaday_io\"] = hackaday_io.get_labs(format=\"dict\")\n    all_labs[\"hackerspaces_org\"] = hackerspaces_org.get_labs(format=\"dict\")\n    all_labs[\"makery_info\"] = makery_info.get_labs(format=\"dict\")\n    all_labs[\"nesta\"] = nesta.get_labs(format=\"dict\")\n    # all_labs[\"techshop_ws\"] = techshop_ws.get_labs(format=\"dict\")\n\n    return all_labs"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nrebuilds a dataframe of the history of makerlabs.", "response": "def get_timeline(source):\n    \"\"\"Rebuild a timeline of the history of makerlabs.\"\"\"\n\n    # Set up the pandas timeseries dataframe\n    timeline_format = [\"name\", \"type\", \"source\", \"country\", \"city\", \"latitude\",\n                       \"longitude\", \"website_url\", \"twitter_url\",\n                       \"facebook_page_url\", \"facebook_group_url\",\n                       \"whois_start\", \"whois_end\", \"wayback_start\",\n                       \"wayback_end\", \"twitter_start\", \"twitter_end\",\n                       \"facebook_start\", \"facebook_end\"]\n    timeline = pd.DataFrame(timeline_format)\n\n    # Getdata from all the mapped platforms\n    if source.lower() == \"diybio.org\":\n        data = diybio_org.get_labs(format=\"dict\")\n    elif source.lower() == \"fablabs_io\":\n        data = fablabs_io.get_labs(format=\"dict\")\n    elif source.lower() == \"makeinitaly_foundation\":\n        data = makeinitaly_foundation.get_labs(format=\"dict\")\n    elif source.lower() == \"hackaday_io\":\n        data = hackaday_io.get_labs(format=\"dict\")\n    elif source.lower() == \"hackerspaces_org\":\n        data = hackerspaces_org.get_labs(format=\"dict\")\n    elif source.lower() == \"makery_info\":\n        data = makery_info.get_labs(format=\"dict\")\n    elif source.lower() == \"nesta\":\n        data = nesta.get_labs(format=\"dict\")\n    elif source.lower() == \"all\":\n        pass\n\n    # Fill the dataframe with basic details\n    for lab in labs_data:\n        for link in lab.links:\n            print link\n            if \"twitter\" in link:\n                print link\n            if \"facebook\" in link:\n                print link\n        lab_dataframe_dict = {\"name\": lab.name,\n                              \"type\": lab.lab_type,\n                              \"source\": lab.source,\n                              \"country\": lab.country,\n                              \"city\": lab.city,\n                              \"latitude\": lab.latitude,\n                              \"longitude\": lab.longitude,\n                              \"website_url\": lab.url}\n        timeline.append(lab_dataframe_dict)\n        [\"name\", \"type\", \"source\", \"country\", \"city\", \"lat\", \"long\",\n         \"website_url\", \"twitter_url\", \"facebook_page_url\",\n         \"facebook_group_url\", \"whois_start\", \"whois_end\", \"wayback_start\",\n         \"wayback_end\", \"twitter_start\", \"twitter_end\", \"facebook_start\",\n         \"facebook_end\"]\n\n    # Get time data from platforms, whenever possible\n\n    # Get domain data (whois)\n\n    # Get subdomain data (Internet Archive)\n\n    # Get social media data (Twitter)\n\n    # Get social media data (Facebook)\n\n    return timeline"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef load_genotypes(self):\n\n        if DataParser.compressed_pedigree:\n            self.genotype_file = gzip.open(\"%s.gz\" % self.tped_file, 'rb')\n        else:\n            self.genotype_file = open(self.tped_file)\n        self.filter_missing()", "response": "This method loads the genotypes from the file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef process_genotypes(self, data):\n        # Get a list of uniq entries in the data, except for missing\n        alleles = list(set(data[4:]) - set(DataParser.missing_representation))\n        if len(alleles) > 2:\n            raise TooManyAlleles(chr=self.chr, rsid=self.rsid, alleles=alleles)\n\n        # We don't have a way to know this in advance, so we want to just iterate onward\n        # if we encounter one of these\n        if len(alleles) == 1:\n            raise TooFewAlleles(chr=self.chr, rsid=self.rsid, alleles=alleles)\n\n        # Strip out any excluded individuals\n        allelic_data = numpy.ma.MaskedArray(numpy.array(data[4:], dtype=\"S2\"), self.ind_mask).compressed().reshape(-1, 2)\n\n        maj_allele_count = numpy.sum(allelic_data==alleles[0])\n\n        min_allele_count = numpy.sum(allelic_data==alleles[1])\n\n        effect_allele_count = min_allele_count\n        if min_allele_count > maj_allele_count:\n            alleles = [alleles[1], alleles[0]]\n            allele_count = maj_allele_count\n            maj_allele_count = min_allele_count\n            min_allele_count = allele_count\n\n        #genotypes = []\n        major_allele       = alleles[0]\n        minor_allele       = alleles[1]\n\n        # Genotypes represent the sum of minor alleles at each sample\n        genotype_data = numpy.sum(allelic_data==minor_allele, axis=1)\n        missing_alleles = allelic_data[:, 0]==DataParser.missing_representation\n        genotype_data[missing_alleles] = DataParser.missing_storage\n        hetero_count = numpy.sum(genotype_data==1)\n\n        return (genotype_data,\n                major_allele,\n                minor_allele,\n                hetero_count,\n                maj_allele_count,\n                min_allele_count,\n                numpy.sum(missing_alleles),\n                effect_allele_count)", "response": "Parse the pedigree line and remove excluded individuals from geno\n        Raises TooFewAlleles If there are not 2 distinct alleles in the data and a TooFewAlleles is raised"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef filter_missing(self):\n\n        missing             = None\n        locus_count         = 0\n\n        # Filter out individuals according to missingness\n        self.genotype_file.seek(0)\n        for genotypes in self.genotype_file:\n            genotypes = genotypes.split()\n            chr, rsid, junk, pos = genotypes[0:4]\n            if DataParser.boundary.TestBoundary(chr, pos, rsid):\n                locus_count += 1\n                allelic_data = numpy.array(genotypes[4:], dtype=\"S2\").reshape(-1, 2)\n                if missing is None:\n                    missing             = numpy.zeros(allelic_data.shape[0], dtype='int8')\n                missing += (numpy.sum(0+(allelic_data==DataParser.missing_representation), axis=1)/2)\n\n        max_missing = DataParser.ind_miss_tol * locus_count\n        dropped_individuals = 0+(max_missing<missing)\n\n        self.ind_mask[:,0] = self.ind_mask[:,0]|dropped_individuals\n        self.ind_mask[:,1] = self.ind_mask[:,1]|dropped_individuals\n\n        valid_individuals = numpy.sum(self.ind_mask==0)\n        max_missing = DataParser.snp_miss_tol * valid_individuals\n\n        self.locus_count = 0\n        # We can't merge these two iterations since we need to know which individuals\n        # to consider for filtering on MAF\n        dropped_snps = []\n        self.genotype_file.seek(0)\n        for genotypes in self.genotype_file:\n            genotypes = genotypes.split()\n            chr, rsid, junk, pos = genotypes[0:4]\n            chr = int(chr)\n            pos = int(pos)\n            if DataParser.boundary.TestBoundary(chr, pos, rsid):\n                allelic_data = numpy.ma.MaskedArray(numpy.array(genotypes[4:], dtype=\"S2\").reshape(-1, 2), self.ind_mask).compressed()\n                missing = numpy.sum(0+(allelic_data==DataParser.missing_representation))\n                if missing > max_missing:\n                    DataParser.boundary.dropped_snps[int(chr)].add(int(pos))\n                    dropped_snps.append(rsid)\n                else:\n                    self.locus_count += 1", "response": "Filter out individuals that have too many missing to be considered"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef populate_iteration(self, iteration):\n\n        cur_idx = iteration.cur_idx\n        genotypes = self.genotype_file.next().split()\n        iteration.chr, iteration.rsid, junk, iteration.pos = genotypes[0:4]\n        iteration.chr = int(iteration.chr)\n        iteration.pos = int(iteration.pos)\n\n        if DataParser.boundary.TestBoundary(iteration.chr, iteration.pos, iteration.rsid):\n            try:\n                [iteration.genotype_data,\n                    iteration.major_allele,\n                    iteration.minor_allele,\n                    iteration.hetero_count,\n                    iteration.maj_allele_count,\n                    iteration.min_allele_count,\n                    iteration.missing_allele_count,\n                    iteration.allele_count2] = self.process_genotypes(genotypes)\n                return iteration.maf >= DataParser.min_maf and iteration.maf <= DataParser.max_maf\n            except TooFewAlleles:\n                print \"\\n\\n\\nSkipping %s:%s %s %s\" % (iteration.chr, iteration.pos, iteration.rsid, cur_idx)\n\n        return False", "response": "Populate the iteration object with the current data from the file."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_labs(format):\n\n    ukmakerspaces_data = data_from_nesta()\n    ukmakerspaces = {}\n\n    # Iterate over csv rows\n    for index, row in ukmakerspaces_data.iterrows():\n        current_lab = UKMakerspace()\n        current_lab.address_1 = row[\"Address\"].replace(\"\\r\", \" \")\n        current_lab.address_2 = row[\"Region\"].replace(\"\\r\", \" \") + \" - \" + row[\"Area\"].replace(\"\\r\", \" \")\n        current_lab.city = \"\"\n        current_lab.county = \"\"\n        current_lab.email = row[\"Email address\"]\n        current_lab.latitude = \"\"\n        current_lab.longitude = \"\"\n        current_lab.links = \"\"\n        current_lab.name = row[\"Name of makerspace\"]\n        current_lab.phone = row[\"Phone number\"]\n        current_lab.postal_code = row[\"Postcode\"]\n        current_lab.url = row[\"Website / URL\"]\n\n        # Add the lab, with a slug from the name\n        ukmakerspaces[current_lab.name] = current_lab\n\n    # Return a dictiornary / json\n    if format.lower() == \"dict\" or format.lower() == \"json\":\n        output = {}\n        for j in ukmakerspaces:\n            output[j] = ukmakerspaces[j].__dict__\n    # Return a geojson\n    elif format.lower() == \"geojson\" or format.lower() == \"geo\":\n        labs_list = []\n        for l in ukmakerspaces:\n            single = ukmakerspaces[l].__dict__\n            single_lab = Feature(\n                type=\"Feature\",\n                geometry=Point((single[\"latitude\"], single[\"longitude\"])),\n                properties=single)\n            labs_list.append(single_lab)\n        output = dumps(FeatureCollection(labs_list))\n    # Return a Pandas DataFrame\n    elif format.lower() == \"pandas\" or format.lower() == \"dataframe\":\n        output = {}\n        for j in ukmakerspaces:\n            output[j] = ukmakerspaces[j].__dict__\n        # Transform the dict into a Pandas DataFrame\n        output = pd.DataFrame.from_dict(output)\n        output = output.transpose()\n    # Return an object\n    elif format.lower() == \"object\" or format.lower() == \"obj\":\n        output = ukmakerspaces\n    # Default: return an oject\n    else:\n        output = ukmakerspaces\n    # Return a proper json\n    if format.lower() == \"json\":\n        output = json.dumps(output)\n    return output", "response": "Gets current UK Makerspaces data as listed by NESTA."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef pfindall(path, *fnames):\n    wd = os.path.abspath(path)\n    assert os.path.isdir(wd)\n\n    def parents():\n        \"\"\"yield successive parent directories\n        \"\"\"\n        parent = wd\n        yield parent\n        while 1:\n            parent, dirname = os.path.split(parent)\n            if not dirname:\n                return\n            yield parent\n\n    for d in parents():\n        curdirlist = os.listdir(d)\n        for fname in fnames:\n            if fname in curdirlist:\n                yield fname, os.path.normcase(os.path.join(d, fname))", "response": "Find all files in the closest ancestor directory."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_function_params(self, scope_path, pyfunc):\n\n        pyclass = pyfunc.parent\n        scope_path = get_attribute_scope_path(pyclass)\n        glade_file = self.get_glade_file_for_class(scope_path, pyclass)\n\n        if glade_file:\n            self.process_glade(scope_path, glade_file)\n            return self.get_params_for_handler(scope_path, pyfunc)\n        else:\n            return {}", "response": "returns a dict of parameters for the given function"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the list of parameters that are needed for the given handler.", "response": "def get_params_for_handler(self, class_scope, pyfunc):\n        \"\"\":type pyfunc: rope.base.pyobjectsdef.PyFunction\"\"\"\n        try:\n            cls, signal = self.handlers[class_scope][pyfunc.get_name()]\n        except KeyError:\n            return {}\n\n        attrs = {}\n\n        idx = 0\n        names = pyfunc.get_param_names(False)\n        if pyfunc.get_kind() in ('method', 'classmethod'):\n            names = names[1:]\n            idx += 1\n\n        if names:\n            attrs[idx] = self.get_type(self.get_pygtk_class_name(cls)).get_object()\n            names = names[1:]\n            idx += 1\n\n        if names:\n            for t in gobject.signal_query(signal, str(cls))[-1]:\n                try:\n                    tname = self.get_type(self.get_pygtk_class_name(t.name))\n                    if tname:\n                        attrs[idx] = tname.get_object()\n                except ModuleNotFoundError:\n                    pass\n\n                idx += 1\n\n        return attrs"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef datafield(*path, **kwargs):\n    if len(path) == 1 and isinstance(path[0], types.FunctionType):\n        return DataField(**kwargs)(*path)\n    else:\n        return DataField(*path, **kwargs)", "response": "A decorator that defines a field for data within a data structure."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef init_self(self, cls, name):\n        # the class the descriptor is defined on\n        self.this_class = cls\n        # the attribute name of this descriptor\n        self.this_name = name", "response": "Initialize this descriptor instance with the class cls and the attribute name name."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd new data fields to this struct instance", "response": "def add_fields(self, **fields):\n        \"\"\"Add new data fields to this struct instance\"\"\"\n        self.__class__ = type(self.__class__.__name__,\n                            (self.__class__,), fields)\n        for k, v in fields.items():\n            v.init_inst(self)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndelete data fields from this struct instance", "response": "def del_fields(self, *names):\n        \"\"\"Delete data fields from this struct instance\"\"\"\n        cls = type(self)\n        self.__class__ = cls\n        for n in names:\n            # don't raise error if a field is absent\n            if isinstance(getattr(cls, n, None), DataField):\n                if n in self._field_values:\n                    del self._field_values[n]\n                delattr(cls, n)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nensures the user - originating redirection URL is safe.", "response": "def get_success_url(self):\n        \"\"\"Ensure the user-originating redirection URL is safe.\"\"\"\n        redirect_to = self.request.POST.get(\n            self.redirect_field_name,\n            self.request.GET.get(self.redirect_field_name, '')\n        )\n        url_is_safe = is_safe_url(\n            url=redirect_to,\n            # allowed_hosts=self.get_success_url_allowed_hosts(),\n            # require_https=self.request.is_secure(),\n        )\n        if not url_is_safe:\n            return resolve_url(settings.LOGIN_REDIRECT_URL)\n        return redirect_to"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate a base class for the exception.", "response": "def declare_base(erroName=True):\n    \"\"\"Create a Exception with default message.\n    \n    :param errorName: boolean, True if you want the Exception name in the \n      error message body.\n    \"\"\"\n    if erroName:\n        class Base(Exception):\n            def __str__(self):\n                if len(self.args):\n                    return \"%s: %s\" % (self.__class__.__name__, self.args[0])\n                else:\n                    return \"%s: %s\" % (self.__class__.__name__, self.default)\n    else:\n        class Base(Exception):\n            def __str__(self):\n                if len(self.args):\n                    return \"%s\" % self.args[0]\n                else:\n                    return \"%s\" % self.default\n    return Base"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nwraps utils. requests. request adding user and password.", "response": "def _request(self, method, url, **kwargs):\n        ''' Wrap `utils.requests.request` adding user and password. '''\n        self._ask_for_password()\n        return request(method, url, user=self._user, password=self._password,\n                       **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef create(self, weeks):\n        user_pageviews = self.create_profiles('Pageviews', weeks)\n        user_downloads = self.create_profiles('Downloads', weeks)\n\n        self._export_profiles('Profiles', user_pageviews, user_downloads)\n\n        user_pageviews = self.create_profiles('Pageviews_IP', weeks, True)\n        user_downloads = self.create_profiles('Downloads_IP', weeks, True)\n\n        self._export_profiles('Profiles_IP', user_pageviews, user_downloads,\n                              ip_user=True)", "response": "Create the user and ip profiles for the given weeks."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _export_profiles(self, profile_name, user_pageviews, user_downloads,\n                         ip_user=False):\n        \"\"\"Filter and export the user profiles.\"\"\"\n        views_min = self.config.get('user_views_min')\n        views_max = self.config.get('user_views_max')\n        ip_user_id = 500000000000\n        add_user_id = 100000000000\n        stat_records = 0\n        with self.storage.get_user_profiles(profile_name) as store:\n            store.clear()\n            for user in user_pageviews:\n                # Only users with unique pageviews.\n                unique_views = len(set(user_pageviews[user]))\n                if views_max > unique_views >= views_min:\n                    nodes, weight = self._calculate_user_record_weights(\n                            record_list=user_pageviews[user],\n                            download_list=user_downloads.get(user))\n                    if ip_user:\n                        store.add_user(ip_user_id, nodes, weight)\n                        ip_user_id += 1\n                    else:\n                        user = str(add_user_id + int(user))\n                        store.add_user(user, nodes, weight)\n                    self.stat_long['User_num_records'].append(len(nodes))\n                    stat_records += len(nodes)\n\n                elif unique_views >= views_min:\n                    # TODO: Add stat for to many views.\n                    print(\"Drop user {} with {} views\".format(user,\n                                                              unique_views))\n        self.stat['user_profiles'] = len(self.stat_long.get(\n                                                        'User_num_records'))\n        self.stat['user_profiles_records'] = stat_records\n\n        print(\"Stats: {}\".format(self.stat))", "response": "Filter and export the user profiles."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates the user profiles for the given weeks.", "response": "def create_profiles(self, prefix, weeks, ip_user=False):\n        \"\"\"Create the user profiles for the given weeks.\"\"\"\n        # Future: Add a time range in weeks for how long a user is considered\n        #         as the same user.\n\n        # Count accessed records\n        record_counter = {}\n        for year, week in weeks:\n            file = self.storage.get(prefix, year, week)\n            self.count_records(record_counter, file)\n\n        # TODO: Statistics, count records\n        print(\"Records read all: {}\".format(self.stat))\n\n        # Filter records with to less/much views.\n        records_valid = self.filter_counter(record_counter)\n\n        # Create user profiles\n        profiles = defaultdict(list)\n        for year, week in weeks:\n            file = self.storage.get(prefix, year, week)\n            self._create_user_profiles(profiles, file, records_valid, ip_user,\n                                       year, week)\n\n        return profiles"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef count_records(self, record_counter, file):\n        counter = record_counter\n        events_counter = 0\n        for record in file.get_records():\n            recid = record[2]\n            counter[recid] = counter.get(recid, 0) + 1\n            events_counter += 1\n\n        self.stat['user_record_events'] = events_counter\n        return counter", "response": "Count the number of viewed records."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfilters the counted records.", "response": "def filter_counter(self, counter, min=2, max=100000000):\n        \"\"\"\n        Filter the counted records.\n\n        Returns: List with record numbers.\n        \"\"\"\n        records_filterd = {}\n        counter_all_records = 0\n        for item in counter:\n            counter_all_records += 1\n            if max > counter[item] >= min:\n                records_filterd[item] = counter[item]\n\n        self.stat['user_record_events'] = counter_all_records\n        self.stat['records_filtered'] = len(records_filterd)\n        return records_filterd"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates user profiles with all the records visited or downloaded.", "response": "def _create_user_profiles(self, profiles, file, valid_records,\n                              ip_user=False, year=None, week=None):\n        \"\"\"\n        Create user profiles with all the records visited or downloaded.\n\n        Returns: Dictionary with the user id and a record list.\n        {'2323': [1, 2, 4]}\n        \"\"\"\n        for record in file.get_records():\n            recid = record[2]\n            if not valid_records.get(recid, None):\n                # Record not valid\n                continue\n\n            if ip_user:\n                ip = record[4]\n                user_agent = record[5]\n                # Generate unique user id\n                user_id = \"{0}-{1}_{2}_{3}\".format(year, week, ip, user_agent)\n                try:\n                    uid = hashlib.md5(user_id.encode('utf-8')).hexdigest()\n                except UnicodeDecodeError:\n                    logger.info(\"UnicodeDecodeError {}\".format(user_id))\n            else:\n                uid = record[1]\n\n            profiles[uid].append(recid)\n\n        return profiles"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_filename(file):\n    if not os.path.exists(file):\n        return None\n    return \"%s%s\" % os.path.splitext(file)", "response": "Returns the name of the file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nregister a plugin or plugins to be managed by the plugin manager.", "response": "def register(self, plugin=None, plugin_file=None, directory=None, skip_types=None, override=False, activate=True):\n        \"\"\"\n        Register a plugin, or plugins to be managed and recognized by the plugin manager.\n        Will take a plugin instance, file where a plugin / plugin(s) reside, parent directory\n        that holds plugin(s), or sub-folders with plugin(s).\n\n        Will optionally \"activate\" the plugins, and perform any operations defined in their \"activate\" method.\n\n        :param plugin: Plugin Instance to register.\n        :param plugin_file: str: File (full path) to scan for Plugins.\n        :param directory: str: Directory to perform a recursive scan on for Plugins.\n        :param skip_types: list: Types of plugins to skip when found, during a scan / search.\n        :param override: bool: Whether or not to override registered plugin when it's being registered again.\n        :param activate: bool: Whether or not to activate the plugins upon registration.\n        :return: Does not Return.\n        \"\"\"\n        # Double verify that there's types to skip. We don't want to register \"Base\" types (Plugin)\n\n        if not isinstance(skip_types, list):\n            skip_types = [skip_types]\n            logger.debug(\"Skip Types must be a list. Created list with values passed.\")\n\n        if skip_types is None:\n            skip_types = [Plugin]\n        else:\n            skip_types.append(Plugin)\n\n        # Check if they've passed a method of registration!\n        if plugin is None and plugin_file is None and directory is None:\n            raise PluginException(\"Unable to perform registration without a plugin, module, or directory.\")\n\n        # First we'll check if they're registering via directory (Scanning)\n        # as it might be best for bigger applications / apps with many plugins to register them via\n        # a folder, where plugins are expected!\n        if directory is not None:\n            plugins_in_dir = PluginManager.scan_for_plugins(directory)\n            # Loop through all the plugins in the directory, associated by file -> list[] (or none)\n            for file, plugins in plugins_in_dir.items():\n                # If there's no plugins in that file then just continue.\n                if plugins is None:\n                    continue\n\n                for plugin in plugins:\n                    # If there's a duplicate plugin and we're not overriding, then we'll skip it.\n                    if plugin.name in self.plugins:\n                        if not override:\n                            logger.warn(\"Failed to register %s: Duplicate plugin found!\" % plugin.name)\n                            continue\n\n                    # Now verify if we're supposed to skip the type of the plugin that's being attempted to register.\n                    # Useful when plugins classes extend a base-class (Plugin, for example)\n                    # but you don't want to register the base class.\n                    if type(plugin) in skip_types:\n                        logger.warn(\n                            \"Skipping registration of %s, as it's not to be registered.\" % plugin.__class__.__name__)\n                        continue\n\n                    # Assign the plugin (via name) to the dictionary of registered plugins\n                    self.plugins[plugin.name] = plugin\n                    # Give a little output of the plugin!\n                    logger.debug(\"Registered plugin %s from %s in %s\" % (plugin.name, file, directory))\n\n                    # Then if we're going to activate the plugin, do so!\n                    if activate:\n                        self.plugins[plugin.name].activate()\n\n        # Now we're going to check if they're registering the plugins\n        # either by file, or module\n        if plugin_file is not None:\n            # If the plugin_file is not a module, then we're going to verify the file actually exists!\n            if not inspect.ismodule(plugin_file):\n                # Verify if there's a ~ (Home dir call) inside the path, and if so then expand it.\n                plugin_file = os.path.expanduser(plugin_file)\n                # Then verify if the path of the plugin exists, raising an exception if not!\n                if not os.path.exists(plugin_file):\n                    raise FileNotFoundError(\"Unable to locate file %s\" % plugin_file)\n\n            # Next after verifying, we get all the plugins inside the file or module.`\n            plugins_in_file = PluginManager.get_plugins_in_module(plugin_file)\n            # If there's no plugins inside, then we're going to throw an exception. There's nothing to register in here.\n            if plugins_in_file is None or len(plugins_in_file) == 0:\n                raise PluginException(\"Unable to locate plugins inside %s\" % plugin_file)\n\n            # Loop through every plugin inside the file/module and attempt to register it.\n            for fplugin in plugins_in_file:\n                # If there's a duplicate plugin and we're not overriding, then we'll skip it.\n                if fplugin.name in self.plugins:\n                    if not override:\n                        logger.warn(\"Failed to register %s: Duplicate plugin found!\" % fplugin.name)\n                        continue\n\n                # Now verify if we're supposed to skip the type of the plugin that's being attempted to register.\n                # Useful when plugins classes extend a base-class (Plugin, for example)\n                # but you don't want to register the base class.\n                if type(fplugin) in skip_types:\n                    logger.warn(\n                        \"Skipping registration of %s, as it's not to be registered.\" % fplugin.__class__.__name__)\n                    continue\n\n                # Assign the plugin (via name) to the dictionary of registered plugins\n                self.plugins[fplugin.name] = fplugin\n                # Give a little output of the plugin!\n                logger.debug(\"Registered plugin %s from %s %s\" % (\n                    fplugin.name, \"module\" if inspect.ismodule(plugin_file) else \"file\",\n                    get_filename(plugin_file) if not inspect.ismodule(plugin_file) else plugin_file.__name__)\n                             )\n\n                # Then if we're going to activate the plugin, do so!\n                if activate:\n                    self.plugins[fplugin.name].activate()\n\n        # Now we're checking if they actually passed a plugin instance to register.\n        if plugin is not None:\n            # If it's already in the plugins and we're not overriding, then we'll skip it.\n            if plugin.name in self.plugins:\n                if override is False:\n                    return\n\n            # Otherwise register the plugin, and (potentially) activate it!\n            self.plugins[plugin.name] = plugin\n            logger.debug(\"Registered plugin %s\" % plugin.name)\n            if activate:\n                self.plugins[plugin.name].activate()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef unregister(self, plugin=None, plugin_file=None):\n        if plugin is None and plugin_file is None:\n            for name, plugin in self.plugins.items():\n                plugin.deactivate()\n                del self.plugins[name]\n\n            return\n\n        if plugin is not None:\n            if plugin.name in self.plugins:\n                plugin.deactivate()\n                del self.plugins[plugin.name]\n\n        if plugin_file is not None:\n            plugs_in_file = PluginManager.get_plugins_in_module(plugin_file)\n            if plugs_in_file is None:\n                return\n\n            for classPlugin in plugs_in_file:\n                if not self.has_plugin(classPlugin.name, classPlugin):\n                    continue\n\n                self.get_plugin(classPlugin.name).deactivate()\n                del self.plugins[classPlugin.name]", "response": "Unregisters all plugins or a specific plugin via an instance or file containing plugin ( s )."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_plugins(self, plugin_type=None):\n        if plugin_type is None:\n            return self.plugins.values()\n\n        plugin_list = []\n        for name, plugin in self.plugins.items():\n            if isinstance(plugin, plugin_type if inspect.isclass(plugin_type) else type(plugin_type)):\n                plugin_list.append(plugin)\n\n        return plugin_list", "response": "Retrieve a list of plugins in the PluginManager."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nchecks if the manager has a given plugin or by its name type and type.", "response": "def has_plugin(self, name=None, plugin_type=None):\n        \"\"\"\n        Check if the manager has a plugin / plugin(s), either by its name, type, or simply checking if the\n        manager has any plugins registered in it.\n\n        Utilizing the name argument will check if a plugin with that name exists in the manager.\n        Using both the name and plugin_type arguments will check if a plugin with that name, and type, exists.\n\n        Using only the plugin_type argument will check if any plugins matching the type specified are registered\n        in the plugin manager.\n        :param name: Name of the plugin to check for.\n        :param plugin_type: Plugin Type to check for.\n        :return:\n        \"\"\"\n        # If there's no arguments passed to this, then we check if there's simply any plugins\n        # Registered in the plugin manager.\n        if name is None and plugin_type is None:\n            return len(self.plugins) > 0\n\n        # If there's a name and plugin type, we just want to verify the manager\n        # Has a plugin with that name, and that plugin is of the given type!\n        if name is not None and plugin_type is not None:\n            return name in self.plugins and isinstance(self.plugins[name],\n                                                       plugin_type if inspect.isclass(plugin_type) else type(\n                                                           plugin_type))\n\n        # If only the type is given, then just assure we have atleast one plugin with the\n        # desired type registered in the manager\n        if plugin_type is not None:\n            return len(\n                self.get_plugins(plugin_type=plugin_type if inspect.isclass(plugin_type) else type(plugin_type))) > 0\n\n        # Lastly, however, we're doing a simple name check; Assuring the manager\n        # has a plugin registered with the given name!\n        return name in self.plugins"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nscanning a directory for plugins and return a dictionary of file and plugins.", "response": "def scan_for_plugins(directory):\n        \"\"\"\n        Scan a directory for modules that contains plugin(s).\n        :param directory: Path of the folder/directory to scan.\n        :return: Dictionary of file (key) and plugins (value), where the key is the path of the module and value is a list of plugins inside that module.\n        :rtype: dict\n        \"\"\"\n        if not os.path.exists(os.path.expanduser(directory)):\n            raise FileNotFoundError(\"Unable to locate directory %s\" % directory)\n\n        files_in_dir = get_files_recursive(directory)\n        plugins = {}\n        for file in files_in_dir:\n            plugins_in_module = PluginManager.get_plugins_in_module(file, suppress=True)\n\n            if plugins_in_module is None:\n                continue\n\n            plugins[file] = plugins_in_module\n\n        return plugins"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ninspect a module via its path and retrieve a list of the plugins inside the module.", "response": "def get_plugins_in_module(module_path, suppress=False):\n        \"\"\"\n        Inspect a module, via its path, and retrieve a list of the plugins inside the module.\n        :param module_path: Path of the module to inspect.\n        :param suppress: Whether or not to suppresss exceptions.\n        :raises: PluginException\n        :return: A list of all the plugins inside the specified module.\n        :rtype: list\n        \"\"\"\n        module = module_path if inspect.ismodule(module_path) else import_module_from_file(module_path)\n        if module is None:\n            # CHeck if we're repressing errors.. Sometimes, such in the case of scanning a dir,\n            # This is BOUND to return none.\n            if suppress is False:\n                raise PluginException(\"Unable to find plugins inside module at %s\" % module)\n            return None\n\n        plugin_list = []\n        for name, obj in inspect.getmembers(module):\n            attr = getattr(module, name)\n            if isinstance(attr, Plugin):\n                plugin_list.append(attr)\n\n        return plugin_list"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _process(compressor, input_filename, output_filename):\n    compressor(input_filename, output_filename)\n    result_size = os.path.getsize(output_filename)\n\n    return _CompressorResult(result_size, output_filename, compressor.__name__)", "response": "Helper function to compress an image."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _compress_with(input_filename, output_filename, compressors):\n    with _temporary_filenames(len(compressors)) as temp_filenames:\n        results = []\n        for compressor, temp_filename in zip(compressors, temp_filenames):\n            results.append(_process(compressor, input_filename, temp_filename))\n        best_result = min(results)\n        os.rename(best_result.filename, output_filename)\n\n        best_compressor = best_result.compressor\n        if best_result.size >= os.path.getsize(input_filename):\n            best_compressor = None\n\n        if (best_compressor is not None and\n                not _images_are_equal(input_filename, output_filename)):\n            logging.info('Compressor \"%s\" generated an invalid image for \"%s\"',\n                         best_compressor, input_filename)\n            best_compressor = None\n\n        if best_compressor is None:\n            shutil.copy(input_filename, output_filename)\n\n    logging.info('%s: best compressor for \"%s\"', best_compressor,\n                 input_filename)", "response": "Helper function to compress an image with several compressors."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nbuilding a ProjectVariablesUpdater instance using the given arguments.", "response": "def build(self, project: str, groups: Iterable[str], gitlab_config: GitLabConfig) \\\n            -> ProjectVariablesUpdaterType:\n        \"\"\"\n        Builds a `ProjectVariablesUpdater` instance using the given arguments.\n        :param project: the project that variables are to be updated for\n        :param groups: the groups of settings that should be set for the project\n        :param gitlab_config: the configuration required to access GitLab\n        :return: the project variable updater\n        \"\"\""}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_map(self, create_html=True):\n        strike_data = self.df\n        num_rows = len(self.df)\n        if num_rows > 1000:\n            print(\"Warning, you have requested lots of data be mapped.\" /\n                  \" Limiting your request to the first 1,000 rows\" /\n                  \" as this is currently only a preview feature.\")\n            strike_data = self.df[0:1000]\n        m = folium.Map(location=[0.0, 0.01], zoom_start=2)\n        marker_cluster = folium.MarkerCluster().add_to(m)\n        for event in strike_data.index:\n            self.add_to_map(map_obj=m,\n                            date_time=strike_data.dt[event],\n                            cluster_obj=marker_cluster,\n                            lat=strike_data.geometry[event].y,\n                            lon=strike_data.geometry[event].x,\n                            key=event)\n        if create_html:\n            data_date = strike_data.dt[0].split()[0]\n            m.save('map_{0}.html'.format(data_date))\n        return m", "response": "Returns a map object for the current strike data."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef read_blitzorg_csv(f=None):\n        factor = 1000000000  # don't change this magic number! Its from Bzorg.\n        if f:\n            tmp = pd.read_csv(f)\n        else:\n            f = pkg.resource_filename('stormstats', \"egdata/archive_2_raw.txt\")\n            tmp = pd.read_csv(f)\n        dt_list = [dt.datetime.fromtimestamp(ts/factor).strftime(\n            '%Y-%m-%d %H:%M:%S:%f') for ts in tmp.time]\n        tmp_list = [[Point(lon, lat), ts] for lon, lat, ts in\n                    zip(tmp.lon, tmp.lat, dt_list)]\n        df = gpd.GeoDataFrame(tmp_list, columns=['geometry', 'dt'])\n        return df", "response": "Function to read csv data downloaded from Blitzorgs historical data\n        section."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nadd individual elements to a foilum map in a cluster object", "response": "def add_to_map(map_obj, lat, lon, date_time, key, cluster_obj):\n        \"\"\"Add individual elements to a foilum map in a cluster object\"\"\"\n        text = \"Event {0} at {1}\".format(key, date_time.split()[1])\n        folium.Marker([lat, lon], popup=text).add_to(cluster_obj)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_version():\r\n    # Other OS check\r\n    if not 'win' in sys.platform:\r\n        return NO_WIN\r\n    # Get infos\r\n    win_ver = sys.getwindowsversion()\r\n    try:\r\n        # Python 3.6.x or upper -> Use 'platform_version' attribute\r\n        major, minor, build = win_ver.platform_version\r\n    except AttributeError:\r\n        if sys.version_info < (3, 0):\r\n            # Python 2.7.x -> Use 'platform' module to ensure the correct values (seems that Win 10 is not correctly detected)\r\n            from platform import _get_real_winver\r\n            major, minor, build = _get_real_winver(win_ver.major, win_ver.minor, win_ver.build)\r\n            major, minor, build = int(major), int(minor), int(build) # 'long' to 'int'\r\n        else:\r\n            # Python 3.0.x - 3.5.x -> Keep 'sys.getwindowsversion()'' values\r\n            major, minor, build = win_ver.major, win_ver.minor, win_ver.build\r\n    # Check is is server or not (it works only on Python 2.7.x or newer)\r\n    try:\r\n        is_server = 1 if win_ver.product_type == 3 else 0\r\n    except AttributeError:\r\n        is_server = 0\r\n    # Parse Service Pack version (or Build number)\r\n    try:\r\n        if major == 10:\r\n            # The OS is Windows 10 or Windows Server 2016,\r\n            # so the service pack version is instead the Build number\r\n            sp_ver = build\r\n        else:\r\n            sp_ver = win_ver.service_pack_major or 0\r\n    except AttributeError:\r\n        try:\r\n            sp_ver = int(win_ver.service_pack.rsplit(' ', 1))\r\n        except (IndexError, ValueError):\r\n            sp_ver = 0\r\n    # Return the final version data\r\n    return (major, minor, sp_ver, is_server)", "response": "Returns a new version of the Windows OS version running on the machine."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a DER - encoded signature from a input of a hash and private key and optionally a K value.", "response": "def sign(hash,priv,k=0):\n    '''\n    Returns a DER-encoded signature from a input of a hash and private\n    key, and optionally a K value.\n\n    Hash and private key inputs must be 64-char hex strings,\n    k input is an int/long.\n\n    >>> h = 'f7011e94125b5bba7f62eb25efe23339eb1637539206c87df3ee61b5ec6b023e'\n    >>> p = 'c05694a7af0e01dceb63e5912a415c28d3fc823ca1fd3fa34d41afde03740466'\n    >>> k = 4 # chosen by fair dice roll, guaranteed to be random\n    >>> sign(h,p,k)\n    '3045022100e493dbf1c10d80f3581e4904930b1404cc6c13900ee0758474fa94abe8c4cd130220598e37e2e66277ef4d0caf0e32d095debb3c744219508cd394b9747e548662b7'\n    '''\n\n    if k == 0:\n        k = generate_k(priv, hash)\n\n    hash = int(hash,16)\n    priv = int(priv,16)\n\n    r = int(privtopub(dechex(k,32),True)[2:],16) % N\n    s = ((hash + (r*priv)) * modinv(k,N)) % N\n\n    # High S value is non-standard (soon to be invalid)\n    if s > (N / 2):\n        s = N - s\n\n    r, s = inttoDER(r), inttoDER(s)\n    olen = dechex(len(r+s)//2,1)\n    return '30' + olen + r + s"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef verify(hash,sig,pub,exceptonhighS=False):\n    '''\n    Verify a DER-encoded signature against a given hash and public key\n\n    No checking of format is done in this function, so the signature\n    format (and other inputs) should be verified as being the correct\n    format prior to using this method.\n\n    Hash is just 64-char hex string\n    Public key format can be verified with validatepubkey() which is\n      found in .bitcoin\n    Signature format can be validated with checksigformat() which is\n      the next function after this\n\n    'exceptonhighS' is available because many Bitcoin implementations\n    will soon be invalidating high S values in signatures, in order\n    to reduce transaction malleability issues. I decided an exception\n    was preferable to returning False, so as to be distinct from a bad\n    signature.\n\n    >>> h = 'f7011e94125b5bba7f62eb25efe23339eb1637539206c87df3ee61b5ec6b023e'\n    >>> sig = '3045022100e493dbf1c10d80f3581e4904930b1404cc6c13900ee0758474fa94abe8c4cd130220598e37e2e66277ef4d0caf0e32d095debb3c744219508cd394b9747e548662b7'\n    >>> pub = '022587327dabe23ee608d8504d8bc3a341397db1c577370389f94ccd96bb59a077'\n    >>> verify(h,sig,pub)\n    True\n    >>> sig = '3046022100e493dbf1c10d80f3581e4904930b1404cc6c13900ee0758474fa94abe8c4cd13022100a671c81d199d8810b2f350f1cd2f6a1fff7268a495f813682b18ea0e7bafde8a'\n    >>> verify(h,sig,pub)\n    True\n    >>> verify(h,sig,uncompress(pub))\n    True\n    >>> verify(h,sig,pub,True)\n    Traceback (most recent call last):\n    ...\n    TypeError: High S value.\n    '''\n\n    rlen = 2*int(sig[6:8],16)\n    r = int(sig[8:8+(rlen)],16)\n    s = int(sig[(12+rlen):],16) # Ignoring s-len; format dictates it\n                                #   will be to the end of string\n    assert r < N\n\n    if exceptonhighS:\n        if s > (N / 2):\n            raise TypeError(\"High S value.\")\n\n    w = modinv(s,N)\n    x = int(addpubs(\n              privtopub(dechex((int(hash,16) * w) % N,32),False),\n              multiplypub(pub,dechex((r*w) % N,32),False),\n            False)[2:66],16)\n    return x==r", "response": "Verify a DER - encoded signature against a given hash and public key."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef checksigformat(a,invalidatehighS=False):\n    '''\n    Checks input to see if it's a correctly formatted DER Bitcoin\n    signature in hex string format.\n\n    Returns True/False.  If it excepts, there's a different problem\n    unrelated to the signature...\n\n    This does NOT valid the signature in any way, it ONLY checks that\n    it is formatted properly.\n\n    If invalidatehighS is True, this function will return False on an\n    otherwise valid signature format if it has a high S value.\n    '''\n\n    try:\n        a = hexstrlify(unhexlify(a))\n    except:\n        return False\n\n    try:\n        rlen = 2*int(a[6:8],16)\n        slen = 2*int(a[(10+rlen):(12+rlen)],16)\n        r = a[8:8+(rlen)]\n        s1 = a[(12+rlen):]\n        s2 = a[(12+rlen):(12+rlen+slen)]\n\n        assert s1 == s2\n        s1 = int(s1,16)\n        assert s1 < N\n        assert a[:2] == '30'\n        assert len(a) == ((2*int(a[2:4],16)) + 4)\n        assert a[4:6] == '02'\n        assert a[(8+rlen):(10+rlen)] == '02'\n\n        if int(dechex(int(r,16))[:2],16) > 127:\n            assert r[:2] == '00'\n            assert r[2:4] != '00'\n        else:\n            assert r[:2] != '00'\n\n        if int(dechex(s1)[:2],16) > 127:\n            assert s2[:2] == '00'\n            assert s2[2:4] != '00'\n        else:\n            assert s2[:2] != '00'\n\n        assert len(r) < 67\n        assert len(s2) < 67\n\n    except AssertionError:\n        return False\n\n    except Exception as e:\n        raise Exception(str(e))\n\n    if invalidatehighS:\n        if s1 > (N / 2):\n            return False\n\n    return True", "response": "Checks if the input is a correctly formatted DER Bitcoin\n    signature in hex string format. Returns True or False."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsign a message with a given private key.", "response": "def signmsg(msg,priv,iscompressed,k=0):\n    '''\n    Sign a message -- the message itself, not a hash -- with a given\n    private key.\n\n    Input private key must be hex, NOT WIF.  Use wiftohex() found in\n    .bitcoin in order to get the hex private key and whether it is\n    (or rather, its public key is) compressed.\n\n    'iscompressed' is True/False bool for whether or not to indicate\n    compression on the public key that corresponds to the input\n    private key hex.\n\n    'iscompressed' is not defaulted to True like it is in most other\n    functions, because it really matters whether you use it. All\n    software implementations treat uncompressed and compressed keys as\n    entirely different, and a valid message signature will NOT\n    validate if the public key compression is not correct. Whereas for\n    transaction signatures, only the r-value is checked, message\n    signature validation additionally checks/verifies public key\n    compression. So you must manually set it!\n\n    Also, note that message signatures are an entirely different\n    format from DER-encoded transaction signatures.\n\n    Sample message, which includes the quotation marks, and has a new\n    line and 4 spaces after the new line:\n\n    \"You miss 100% of the shots you don't take.  -- Wayne Gretzky\"\n        -- Michael Scott\n\n    >>> msg = '\"You miss 100% of the shots you don\\\\'t take.  -- Wayne Gretzky\"\\\\n    -- Michael Scott'\n    >>> p = 'c05694a7af0e01dceb63e5912a415c28d3fc823ca1fd3fa34d41afde03740466'\n    >>> k = 4 # chosen by fair dice roll, guaranteed to be random\n    >>> signmsg(msg,p,True,k)\n    'H+ST2/HBDYDzWB5JBJMLFATMbBOQDuB1hHT6lKvoxM0TBxoLMWsgrFmA3CGam/poUZPl/PukXCrYBzuwMW3Tyyo='\n\n    Your software should then translate that data set into something akin to:\n\n    -----BEGIN BITCOIN SIGNED MESSAGE-----\n    \"You miss 100% of the shots you don't take.  -- Wayne Gretzky\"\n        -- Michael Scott\n    -----BEGIN BITCOIN SIGNATURE-----\n    Address: 1AuZ7wby1rUVzwFvFgySeTFS7JcHN2TeGs\n\n    H+ST2/HBDYDzWB5JBJMLFATMbBOQDuB1hHT6lKvoxM0TBxoLMWsgrFmA3CGam/poUZPl/PukXCrYBzuwMW3Tyyo=\n    -----END BITCOIN SIGNATURE-----\n    '''\n\n    omsg = msg\n\n    # Stripping carraige returns is standard practice in every\n    # implementation I found, including Bitcoin Core\n    msg = msg.replace(\"\\r\\n\",\"\\n\")\n\n    msg1 = hexstrlify(bytearray(\"\\x18Bitcoin Signed Message:\\n\",'utf-8'))\n    msg2 = tovarint(len(msg))\n    msg3 = hexstrlify(bytearray(msg,'utf-8'))\n    msg = hash256(msg1 + msg2 + msg3)\n\n\n    sig = sign(msg,priv,k)\n\n    # Bitcoin message signature format doesn't use DER leading '00's\n    # Although, r/s must be 64-char, so they are zfilled to that\n    rlen = 2*int(sig[6:8],16)\n    r = sig[8:8+(rlen)].lstrip(\"0\").zfill(64)\n    slen = 2*int(sig[10+(rlen):12+(rlen)],16)\n    s = sig[12+(rlen):(12+(rlen)+(slen))].lstrip(\"0\").zfill(64)\n\n    pubkey = privtopub(priv,iscompressed)\n    for i in range(4):\n        prefix = 27 + i\n        if iscompressed:\n            prefix = prefix + 4\n        o = base64.b64encode(unhexlify(dechex(prefix,1) + r + s))\n        if str(o)[:2] == \"b'\": # Fuck you, Python 3\n            o = str(o)[2:-1]\n        if verifymsg(omsg,o) == pubkey:\n            return o\n\n    raise Exception(\"Unknown failure. This method should never reach the end.\")"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef verifymsg(msg,sig):\n    '''\n    Compares the message and input signature, and outputs what the\n    corresponding public key is that would make that message/signature\n    pair valid.\n\n    I didn't set it to take in a pubkey and output True/False because\n    sometimes it is useful to have the resulting key, even if the\n    msg/sig pair is invalid.\n    (And not just in the signmsg() function above.)\n\n    Also, worth remembering that message signatures are an entirely\n    different format than DER-encoded transaction signatures.\n\n    >>> msg = '\"You miss 100% of the shots you don\\\\'t take.  -- Wayne Gretzky\"\\\\n    -- Michael Scott'\n    >>> sig = 'H+ST2/HBDYDzWB5JBJMLFATMbBOQDuB1hHT6lKvoxM0TBxoLMWsgrFmA3CGam/poUZPl/PukXCrYBzuwMW3Tyyo='\n    >>> x = verifymsg(msg,sig)\n    >>> pub = '022587327dabe23ee608d8504d8bc3a341397db1c577370389f94ccd96bb59a077'\n    >>> x == pub\n    True\n    '''\n\n    msg = msg.replace(\"\\r\\n\",\"\\n\")\n    # Again, standard convention to remove returns\n\n    msg1 = hexstrlify(bytearray(\"\\x18Bitcoin Signed Message:\\n\",'utf-8'))\n    msg2 = tovarint(len(msg))\n    msg3 = hexstrlify(bytearray(msg,'utf-8'))\n    msg = hash256(msg1 + msg2 + msg3)\n\n    sig = hexstrlify(base64.b64decode(sig))\n\n    r = int(sig[2:66],16)\n    s = int(sig[66:],16)\n\n    prefix = int(sig[:2],16)\n    if prefix > 30:\n        out_compressed = True\n        prefix = prefix - 4\n    else:\n        out_compressed = False\n    prefix = prefix - 27\n\n    m = int(N*prefix) if prefix > 1 else 0\n    x = (r + int(m//2)) % N\n    a = (pow_mod(x, 3, P) + 7) % P\n    b = pow_mod(a, ((P+1)//4), P)\n    if (b % 2) != prefix:\n        y = (-b % P)\n    else:\n        y = b\n\n    x, y = dechex(x,32), dechex(y,32)\n    pubkey = \"04\" + x + y\n\n    negative_msg = dechex((N - int(msg,16)),32)\n    modinv_r = dechex(modinv(r, N),32)\n    pubkey = multiplypub(\n                   addpubs(\n                     multiplypub(pubkey,dechex(s,32),False),\n                     privtopub(negative_msg,False),False),\n                   modinv_r,False)\n\n    if out_compressed:\n        pubkey = compress(pubkey)\n    return strlify(pubkey)", "response": "Verify that a message and input signature are valid."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef prepare_files(self, finder, force_root_egg_info=False, bundle=False):\n        unnamed = list(self.unnamed_requirements)\n        reqs = list(self.requirements.values())\n        while reqs or unnamed:\n            if unnamed:\n                req_to_install = unnamed.pop(0)\n            else:\n                req_to_install = reqs.pop(0)\n            req_version = None\n            install = True\n            best_installed = False\n            if not self.ignore_installed and not req_to_install.editable:\n                req_to_install.check_if_exists()\n                if req_to_install.satisfied_by:\n                    if self.upgrade:\n                        if not self.force_reinstall:\n                            try:\n                                url, req_version = finder.find_requirement(\n                                    req_to_install, self.upgrade)\n                            except BestVersionAlreadyInstalled:\n                                best_installed = True\n                                install = False\n                            else:\n                                # Avoid the need to call find_requirement again\n                                req_to_install.url = url.url\n\n                        if not best_installed:\n                            req_to_install.conflicts_with = req_to_install.satisfied_by\n                            req_to_install.satisfied_by = None\n                    else:\n                        install = False\n                if req_to_install.satisfied_by:\n                    if best_installed:\n                        logger.notify('Requirement already up-to-date: %s'\n                                      % req_to_install)\n                    else:\n                        logger.notify('Requirement already satisfied '\n                                      '(use --upgrade to upgrade): %s'\n                                      % req_to_install)\n            if req_to_install.editable:\n                logger.notify('Obtaining %s' % req_to_install)\n            elif install:\n                if req_to_install.url and req_to_install.url.lower().startswith('file:'):\n                    logger.notify('Unpacking %s' % display_path(url_to_path(req_to_install.url)))\n                else:\n                    logger.notify('Downloading/unpacking %s' % req_to_install)\n            logger.indent += 2\n            try:\n                is_bundle = False\n                if req_to_install.editable:\n                    if req_to_install.source_dir is None:\n                        location = req_to_install.build_location(self.src_dir)\n                        req_to_install.source_dir = location\n                    else:\n                        location = req_to_install.source_dir\n                    if not os.path.exists(self.build_dir):\n                        _make_build_dir(self.build_dir)\n                    req_to_install.update_editable(not self.is_download)\n                    if self.is_download:\n                        req_to_install.run_egg_info()\n                        req_to_install.archive(self.download_dir)\n                    else:\n                        req_to_install.run_egg_info()\n                elif install:\n                    ##@@ if filesystem packages are not marked\n                    ##editable in a req, a non deterministic error\n                    ##occurs when the script attempts to unpack the\n                    ##build directory\n\n                    location = req_to_install.build_location(self.build_dir, not self.is_download)\n                    ## FIXME: is the existance of the checkout good enough to use it?  I don't think so.\n                    unpack = True\n                    if not os.path.exists(os.path.join(location, 'setup.py')):\n                        ## FIXME: this won't upgrade when there's an existing package unpacked in `location`\n                        if req_to_install.url is None:\n                            url, req_version = finder.find_requirement(req_to_install, upgrade=self.upgrade)\n                        else:\n                            ## FIXME: should req_to_install.url already be a link?\n                            url = Link(req_to_install.url)\n                            assert url\n                        if url:\n                            try:\n                                self.unpack_url(req_to_install, req_version, url, location, self.is_download)\n                            except HTTPError:\n                                e = sys.exc_info()[1]\n                                logger.fatal('Could not install requirement %s because of error %s'\n                                             % (req_to_install, e))\n                                raise InstallationError(\n                                    'Could not install requirement %s because of HTTP error %s for URL %s'\n                                    % (req_to_install, e, url))\n                        else:\n                            unpack = False\n                    if unpack:\n                        is_bundle = req_to_install.is_bundle\n                        url = None\n                        if is_bundle:\n                            req_to_install.move_bundle_files(self.build_dir, self.src_dir)\n                            for subreq in req_to_install.bundle_requirements():\n                                reqs.append(subreq)\n                                self.add_requirement(subreq)\n                        elif self.is_download:\n                            req_to_install.source_dir = location\n                            if url and url.scheme in vcs.all_schemes:\n                                req_to_install.run_egg_info()\n                                req_to_install.archive(self.download_dir)\n                        else:\n                            req_to_install.source_dir = location\n                            req_to_install.run_egg_info()\n                            if force_root_egg_info:\n                                # We need to run this to make sure that the .egg-info/\n                                # directory is created for packing in the bundle\n                                req_to_install.run_egg_info(force_root_egg_info=True)\n                            req_to_install.assert_source_matches_version()\n                            #@@ sketchy way of identifying packages not grabbed from an index\n                            if bundle and req_to_install.url:\n                                self.copy_to_build_dir(req_to_install)\n                                install = False\n                        # req_to_install.req is only avail after unpack for URL pkgs\n                        # repeat check_if_exists to uninstall-on-upgrade (#14)\n                        req_to_install.check_if_exists()\n                        if req_to_install.satisfied_by:\n                            if self.upgrade or self.ignore_installed:\n                                req_to_install.conflicts_with = req_to_install.satisfied_by\n                                req_to_install.satisfied_by = None\n                            else:\n                                install = False\n                if not is_bundle and not self.is_download:\n                    ## FIXME: shouldn't be globally added:\n                    finder.add_dependency_links(req_to_install.dependency_links)\n                    if (req_to_install.extras):\n                        logger.notify(\"Installing extra requirements: %r\" % ','.join(req_to_install.extras))\n                    if not self.ignore_dependencies:\n                        for req in req_to_install.requirements(req_to_install.extras):\n                            try:\n                                name = pkg_resources.Requirement.parse(req).project_name\n                            except ValueError:\n                                e = sys.exc_info()[1]\n                                ## FIXME: proper warning\n                                logger.error('Invalid requirement: %r (%s) in requirement %s' % (req, e, req_to_install))\n                                continue\n                            if self.has_requirement(name):\n                                ## FIXME: check for conflict\n                                continue\n                            subreq = InstallRequirement(req, req_to_install)\n                            reqs.append(subreq)\n                            self.add_requirement(subreq)\n                    if req_to_install.name not in self.requirements:\n                        self.requirements[req_to_install.name] = req_to_install\n                else:\n                    self.reqs_to_cleanup.append(req_to_install)\n                if install:\n                    self.successfully_downloaded.append(req_to_install)\n                    if bundle and (req_to_install.url and req_to_install.url.startswith('file:///')):\n                        self.copy_to_build_dir(req_to_install)\n            finally:\n                logger.indent -= 2", "response": "Prepare process. Create temp directories download and unpack files."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nsplit a dataframe into training cv and test sets", "response": "def split_dataframe(df, train_percentage=0.6, cv_percentage=0.2, test_percentage=0.2):\n    \"\"\"\n    @return training, cv, test\n            (as pandas dataframes)\n\n    @param df: pandas dataframe\n    @param train_percentage: float | percentage of data for training set (default=0.6)\n    @param cv_percentage:    float | percentage of data for cross validation set (default=0.2)\n    @param test_percentage:  float | percentage of data for test set (default=0.2)\n    \"\"\"\n    assert train_percentage + cv_percentage + test_percentage == 1.0\n\n    N = len(df)\n    l = range(N)\n    shuffle(l)\n\n    # get splitting indices\n    train_len = int(N * train_percentage)\n    cv_len = int(N * cv_percentage)\n    test_len = int(N * test_percentage)\n\n    # get training, cv, and test sets\n    training = df.ix[l[:train_len]]\n    cv = df.ix[l[train_len:train_len + cv_len]]\n    test = df.ix[l[train_len + cv_len:]]\n\n    #print len(cl), len(training), len(cv), len(test)\n\n    return training, cv, test"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add_watermark(pdf_file_in, pdf_file_mark, pdf_file_out):\n    pdf_output = PdfFileWriter()\n    input_stream = open(pdf_file_in, 'rb')\n    pdf_input = PdfFileReader(input_stream)\n\n    # PDF\u6587\u4ef6\u88ab\u52a0\u5bc6\u4e86\n    if pdf_input.getIsEncrypted():\n        print('\u8be5PDF\u6587\u4ef6\u88ab\u52a0\u5bc6\u4e86.')\n        # \u5c1d\u8bd5\u7528\u7a7a\u5bc6\u7801\u89e3\u5bc6\n        try:\n            pdf_input.decrypt('')\n        except Exception as e:\n            print('\u5c1d\u8bd5\u7528\u7a7a\u5bc6\u7801\u89e3\u5bc6\u5931\u8d25.')\n            return False\n        else:\n            print('\u7528\u7a7a\u5bc6\u7801\u89e3\u5bc6\u6210\u529f.')\n    # \u83b7\u53d6PDF\u6587\u4ef6\u7684\u9875\u6570\n    page_num = pdf_input.getNumPages()\n    # \u8bfb\u5165\u6c34\u5370pdf\u6587\u4ef6\n    pdf_watermark_input_stream = open(pdf_file_mark, 'rb')\n    pdf_watermark = PdfFileReader(pdf_watermark_input_stream)\n    # \u7ed9\u6bcf\u4e00\u9875\u6253\u6c34\u5370\n    for i in range(page_num):\n        page = pdf_input.getPage(i)\n        page.mergePage(pdf_watermark.getPage(0))\n        page.compressContentStreams()  # \u538b\u7f29\u5185\u5bb9\n        pdf_output.addPage(page)\n    output_stream = open(pdf_file_out, \"wb\")\n    pdf_output.write(output_stream)\n    input_stream.close()\n    pdf_watermark_input_stream.close()\n    output_stream.close()", "response": "Adds a watermark to the current page of the PDF."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef compress(pdf_in, pdf_output):\n    cmd = 'gs -dNOPAUSE -dBATCH -sDEVICE=pdfwrite -dCompatibilityLevel=1.4 -dPDFSETTINGS=/screen -sOutputFile=%s %s'\n    cmd = cmd % (pdf_output, pdf_in)\n    os.system(cmd)", "response": "Compress a PDF file into a new PDF file."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef param_converter(*decorator_args, **decorator_kwargs):\n    def wrapped(fn):\n        @wraps(fn)\n        def decorated(*view_args, **view_kwargs):\n            view_kwargs = _convert_models(view_kwargs, decorator_kwargs)\n            view_kwargs = _convert_query_params(view_kwargs, decorator_kwargs)\n            return fn(*view_args, **view_kwargs)\n        return decorated\n\n    if decorator_args and callable(decorator_args[0]):\n        return wrapped(decorator_args[0])\n    return wrapped", "response": "A decorator that converts url parameter names to model names."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef load(name, filepath, separator=\"---\"):\n    current_app.logger.info(\n        \">>> Going to load knowledge base {0} into '{1}'...\".format(\n            filepath, name\n        )\n    )\n    if not os.path.isfile(filepath):\n        current_app.logger.error(\n            \"Path to non-existing file\\n\",\n            file=sys.stderr\n        )\n        sys.exit(1)\n    try:\n        get_kb_by_name(name)\n    except NoResultFound:\n        current_app.logger.error(\n            \"KB does not exist\\n\",\n            file=sys.stderr\n        )\n        sys.exit(1)\n    num_added = load_kb_mappings_file(name, filepath, separator)\n    current_app.logger.info(\n        \">>> Knowledge '{0}' updated successfully with {1} entries.\".format(\n            name, num_added\n        )\n    )", "response": "Load given file into a new knowledge base."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef command(func):\n    func.parser = SUB_PARSER.add_parser(func.__name__, help=func.__doc__)\n    func.parser.set_defaults(func=func)\n    return func", "response": "Decorator for CLI exposed functions"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nserves a rueckenwind application", "response": "def serv(args):\n    \"\"\"Serve a rueckenwind application\"\"\"\n    if not args.no_debug:\n        tornado.autoreload.start()\n\n    extra = []\n\n    if sys.stdout.isatty():\n        # set terminal title\n        sys.stdout.write('\\x1b]2;rw: {}\\x07'.format(' '.join(sys.argv[2:])))\n\n    if args.cfg:\n        extra.append(os.path.abspath(args.cfg))\n\n    listen = (int(args.port), args.address)\n    ioloop = tornado.ioloop.IOLoop.instance()\n    setup_app(app=args.MODULE, extra_configs=extra,\n              ioloop=ioloop, listen=listen)\n    ioloop.start()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef main():\n    # check logging\n    log_level = os.environ.get('LOG_LEVEL', 'INFO')\n    logging.basicConfig(level=getattr(logging, log_level),\n                        format='%(asctime)s %(name)s[%(levelname)s] %(message)s',\n                        datefmt='%Y-%m-%d %H:%M:%S')\n\n    current_path = os.path.abspath('.')\n    if current_path not in sys.path:\n        sys.path.insert(0, current_path)\n    argcomplete.autocomplete(ARG_PARSER)\n    args = ARG_PARSER.parse_args()\n    args.func(args)", "response": "Entry point of rw cli"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngenerating a checker which tests a given value does not start with keywords.", "response": "def _checker(keywords):\n    \"\"\"Generate a checker which tests a given value not starts with keywords.\"\"\"\n    def _(v):\n        \"\"\"Check a given value matches to keywords.\"\"\"\n        for k in keywords:\n            if k in v:\n                return False\n        return True\n    return _"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nparse a docstring and extract three components ; headline description and argmap of arguments to help texts.", "response": "def _parse_doc(doc):\n    \"\"\"Parse a docstring.\n\n    Parse a docstring and extract three components; headline, description,\n    and map of arguments to help texts.\n\n    Args:\n      doc: docstring.\n\n    Returns:\n      a dictionary.\n    \"\"\"\n    lines = doc.split(\"\\n\")\n    descriptions = list(itertools.takewhile(_checker(_KEYWORDS), lines))\n\n    if len(descriptions) < 3:\n        description = lines[0]\n    else:\n        description = \"{0}\\n\\n{1}\".format(\n            lines[0], textwrap.dedent(\"\\n\".join(descriptions[2:])))\n\n    args = list(itertools.takewhile(\n        _checker(_KEYWORDS_OTHERS),\n        itertools.dropwhile(_checker(_KEYWORDS_ARGS), lines)))\n    argmap = {}\n    if len(args) > 1:\n        for pair in args[1:]:\n            kv = [v.strip() for v in pair.split(\":\")]\n            if len(kv) >= 2:\n                argmap[kv[0]] = \":\".join(kv[1:])\n\n    return dict(headline=descriptions[0], description=description, args=argmap)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding parser. This method makes a new sub command parser. It takes same arguments as add_parser() of the action class made by argparse.ArgumentParser.add_subparsers. In addition to, it takes one positional argument `func`, which is the function implements process of this sub command. The `func` will be used to determine the name, help, and description of this sub command. The function `func` will also be set as a default value of `cmd` attribute. If you want to choose name of this sub command, use keyword argument `name`. Args: func: function implements the process of this command. name: name of this command. If not give, the function name is used. Returns: new ArgumentParser object. Raises: ValueError: if the given function does not have docstrings.", "response": "def add_parser(self, func=None, name=None, **kwargs):\n        \"\"\"Add parser.\n\n        This method makes a new sub command parser. It takes same arguments\n        as add_parser() of the action class made by\n        argparse.ArgumentParser.add_subparsers.\n\n        In addition to, it takes one positional argument `func`, which is the\n        function implements process of this sub command. The `func` will be used\n        to determine the name, help, and description of this sub command. The\n        function `func` will also be set as a default value of `cmd` attribute.\n\n        If you want to choose name of this sub command, use keyword argument\n        `name`.\n\n        Args:\n          func: function implements the process of this command.\n          name: name of this command. If not give, the function name is used.\n\n        Returns:\n          new ArgumentParser object.\n\n        Raises:\n          ValueError: if the given function does not have docstrings.\n        \"\"\"\n        if func:\n            if not func.__doc__:\n                raise ValueError(\n                    \"No docstrings given in {0}\".format(func.__name__))\n\n            info = _parse_doc(func.__doc__)\n            if _HELP not in kwargs or not kwargs[_HELP]:\n                kwargs[_HELP] = info[\"headline\"]\n            if _DESCRIPTION not in kwargs or not kwargs[_DESCRIPTION]:\n                kwargs[_DESCRIPTION] = info[\"description\"]\n            if _FORMAT_CLASS not in kwargs or not kwargs[_FORMAT_CLASS]:\n                kwargs[_FORMAT_CLASS] = argparse.RawTextHelpFormatter\n\n            if not name:\n                name = func.__name__ if hasattr(func, \"__name__\") else func\n\n            res = self.__delegate.add_parser(name, argmap=info[\"args\"], **kwargs)\n            res.set_defaults(cmd=func)\n\n        else:\n            res = self.__delegate.add_parser(name, **kwargs)\n\n        return res"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds an argument to the current parser.", "response": "def add_argument(self, *args, **kwargs):\n        \"\"\"Add an argument.\n\n        This method adds a new argument to the current parser. The function is\n        same as ``argparse.ArgumentParser.add_argument``. However, this method\n        tries to determine help messages for the adding argument from some\n        docstrings.\n\n        If the new arguments belong to some sub commands, the docstring\n        of a function implements behavior of the sub command has ``Args:`` section,\n        and defines same name variable, this function sets such\n        definition to the help message.\n\n        Positional Args:\n          same positional arguments as argparse.ArgumentParser.add_argument.\n\n        Keyword Args:\n          same keywards arguments as argparse.ArgumentParser.add_argument.\n        \"\"\"\n        if _HELP not in kwargs:\n            for name in args:\n                name = name.replace(\"-\", \"\")\n                if name in self.__argmap:\n                    kwargs[_HELP] = self.__argmap[name]\n                    break\n        return super(ArgumentParser, self).add_argument(*args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngenerating a radio input for the given name and choices and labels.", "response": "def input_ratio(self, name, choices, labels, multi_line=False):\n        \"\"\"        \n        {% for value, label in [('choice1', '\u9009\u98791'), ('choice2', '\u9009\u98792')] %}\n            {% if ratio == value %}\n                {% set checked = \"checked\" %}\n            {% else %}\n                {% set checked = \"\" %}\n            {% endif %}\n            <input type=\"radio\" name=\"ratio\" value=\"{{value}}\" {{checked}} /> {{label}}\n        {% endfor %}\n        \"\"\"\n        if len(choices) != len(labels):\n            raise ValueError(\"The size of 'choices' and 'labels' doesn't match!\")\n        \n        choice_label = list(zip(choices, labels))\n        \n        lines = list()\n        lines.append('{%% for value, label in %s %%}' % repr(choice_label))\n        lines.append(self.tab + '{%% if %s == value %%}' % name)\n        lines.append(self.tab * 2 + '{% set checked = \"checked\" %}')\n        lines.append(self.tab + '{% else %}')\n        lines.append(self.tab * 2 + '{% set checked = \"\" %}')\n        lines.append(self.tab + '{% endif %}')\n        if multi_line:\n            line_break = \"<br>\"\n        else:\n            line_break = \"\"\n        lines.append(self.tab + '<input type=\"radio\" name=\"%s\" value=\"{{value}}\" {{checked}} /> {{label}} %s' % (name, line_break))\n        lines.append('{% endfor %}')\n        return \"\\n\".join(lines)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef input_check(self, name, label, multi_line=False):\n        lines = list()\n        lines.append('{%% if %s %%}' % name)\n        lines.append(self.tab + '{% set checked = \"checked\" %}')\n        lines.append('{% else %}')\n        lines.append(self.tab  + '{% set checked = \"\" %}')\n        lines.append('{% endif %}')\n        if multi_line:\n            line_break = \"<br>\"\n        else:\n            line_break = \"\"\n        lines.append('<input type=\"checkbox\" name=\"%s\" value=\"%s\" {{checked}}> %s %s' % (name, name, label, line_break))        \n        return \"\\n\".join(lines)", "response": "Returns a checkbox input for the current locale."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_configs(__pkg: str, __name: str = 'config') -> List[str]:\n    dirs = [user_config(__pkg), ]\n    dirs.extend(path.expanduser(path.sep.join([d, __pkg]))\n                for d in getenv('XDG_CONFIG_DIRS', '/etc/xdg').split(':'))\n    configs = []\n    for dname in reversed(dirs):\n        test_path = path.join(dname, __name)\n        if path.exists(test_path):\n            configs.append(test_path)\n    return configs", "response": "Return all configs for given package."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_data(__pkg: str, __name: str) -> str:\n    for dname in get_data_dirs(__pkg):\n        test_path = path.join(dname, __name)\n        if path.exists(test_path):\n            return test_path\n    raise FileNotFoundError('No data file {!r} for {!r}'.format(__name, __pkg))", "response": "Return the top - most data file for given package."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning all data directories for given package.", "response": "def get_data_dirs(__pkg: str) -> List[str]:\n    \"\"\"Return all data directories for given package.\n\n    Args:\n        __pkg: Package name\n    \"\"\"\n    dirs = [user_data(__pkg), ]\n    dirs.extend(path.expanduser(path.sep.join([d, __pkg]))\n                for d in getenv('XDG_DATA_DIRS',\n                                '/usr/local/share/:/usr/share/').split(':'))\n    return [d for d in dirs if path.isdir(d)]"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef create_consumer(user, password, config_file_path, process_message, *args, **kwargs):\n    '''Create a pulse consumer. Call listen() to start listening.'''\n    queue_config = _read_json_file(filepath=config_file_path)\n\n    exchanges = map(lambda x: queue_config['sources'][x]['exchange'], queue_config['sources'].keys())\n    topics = map(lambda x: queue_config['sources'][x]['topic'], queue_config['sources'].keys())\n\n    for i in range(0, len(exchanges)):\n        LOG.info('Listening to (%s, %s)' % (exchanges[i], topics[i]))\n\n    pulse_args = {\n        # If the queue exists and is durable it should match\n        'durable': queue_config['durable'] in ('true', 'True'),\n        'password': password,\n        'topic': topics,\n        'user': user\n    }\n\n    if queue_config.get('applabel') is not None:\n        pulse_args['applabel'] = queue_config['applabel']\n\n    return PulseReplayConsumer(\n        # A list with the exchanges of each element under 'sources'\n        exchanges=exchanges,\n        callback=process_message,\n        **pulse_args\n    )\n    return consumer", "response": "Create a pulse consumer. Call listen to start listening."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef replay_messages(filepath, process_message, *args, **kwargs):\n    ''' Take pulse messages from a file and process each with process_message.\n\n    :param filepath: File containing dumped pulse messages\n    :type filepath: str\n    :param process_message: Function to process each pulse message with\n    :type process_message: function\n    :param *args: Arguments to be passed to process_message()\n    :type *args: tuple\n    :param **kwargs: Keyword argument to be passed to process_message()\n    :type **kwargs: dict\n\n    :returns: Nothing\n    :rtype: None\n\n    '''\n    message = Mock()\n\n    file_contents = _read_file(filepath)\n    for line in file_contents.splitlines():\n        # Using ast.literal_eval to turn pulse message strings into dicts\n        process_message(ast.literal_eval(line), message, *args, **kwargs)", "response": "Take pulse messages from a file and process each with process_message."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconvert a dot - separated path to a directory path.", "response": "def normalize_path(path, filetype=None, has_filetype=True):\n    \"\"\" Convert dot-separated paths to directory paths\n\n    Allows non-python files to be placed in the PYTHONPATH and be referenced\n    using dot-notation instead of absolute or relative file-system paths.\n\n    If a text file, named test.txt was placed in a python repo named myprog in\n    the module named util, then:\n\n        normalize_path('myprog.util.test.txt')\n\n    would return the file-system's path to the file 'test.txt'.\n\n    Parameters:\n\n        path         - path to convert\n        filetype     - don't include as part of path if present as last token\n        has_filetype - if True, treat last dot-delimited token as filetype\n\n    Notes:\n        1. Paths are relative to PYTHONPATH.\n        2. If the specified path is not a string, it is returned without\n           change.\n        3. If the specified path contains os-specific path separator\n           characters, the path is returned without change.\n        4. If has_filetype is True, filetype does not have to be specified.\n           If filetype is specified, has_filetype is ignored, and filetype\n           must match the last dot-delimited token exactly.\n    \"\"\"\n    if not isinstance(path, str):\n        return path\n    if '.' in path and os.path.sep not in path:  # path is dot separated\n        parts = path.split('.')\n        extension = ''\n        if len(parts) > 1:\n            if filetype and has_filetype:\n                has_filetype = False  # filetype is more specific\n            if (filetype and parts[-1] == filetype) or has_filetype:\n                extension = '.' + parts[-1]\n                parts = parts[:-1]\n            if len(parts) > 1:\n                if PY3:\n                    spec = importlib.util.find_spec(parts[0])\n                    path = list(spec.submodule_search_locations)[0]\n                else:\n                    _, path, _ = imp.find_module(parts[0])\n\n                path = os.path.join(path, *parts[1:]) + extension\n    return path"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef dict_find_pattern(_dict: Dict[Any, Any], pattern: str, search_in_keys: bool = True,\n                      search_in_values: bool = True) -> PatternGenerator:\n    \"\"\"\n    Find keys and values in a (nested) dictionary with regular expression pattern.\n    Examples:\n        >>> from collections import OrderedDict\n        >>> d = OrderedDict((\n        ...     ('foo', 'bar'),\n        ...     ('bar', 'baz'),\n        ...     ('nested', dict(p1=1, p2=2)),\n        ...     ('lst', ['bar', 'foo', dict(p3=3, p4=4)])\n        ... ))\n        >>> f = dict_find_pattern(d, '.*a.*', search_in_keys=True, search_in_values=False)\n        >>> def print_findings(f):\n        ...     for _, key, value in f:\n        ...         print(key, value)\n        >>> print_findings(f)\n        bar baz\n        >>> f = dict_find_pattern(d, '.*a.*', search_in_keys=False, search_in_values=True)\n        >>> print_findings(f)\n        foo bar\n        bar baz\n\n    Args:\n        _dict: Dictionary to scan for the specified pattern.\n        pattern: The pattern to scan for.\n        search_in_keys: If True keys will be probed for the pattern; otherwise not.\n        search_in_values: If True values will be probed for the pattern; otherwise not.\n\n    Returns:\n        Generator to iterate over the findings.\n    \"\"\"\n\n    def find(dic: Dict[Any, Any], regex: Pattern[str]) -> PatternGenerator:\n        Validator.instance_of(target_type=dict, raise_ex=True, dic=dic)\n\n        for k, val in dic.items():\n            if search_in_keys and isinstance(k, str) and regex.match(k):\n                yield dic, k, val\n            if search_in_values and isinstance(val, str) and regex.match(val):\n                yield dic, k, val\n            if isinstance(val, list):\n                for litem in val:\n                    if isinstance(litem, dict):\n                        for j in find(litem, regex):\n                            yield j\n            if isinstance(val, dict):\n                for j in find(val, regex):\n                    yield j\n\n    regex = re.compile(pattern)\n    return find(_dict, regex)", "response": "Find keys and values in a nested dictionary with regular expression pattern."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef modified_environ(*remove: str, **update: str) -> Iterator[None]:\n    env = os.environ\n    update = update or {}\n    remove = remove or ()\n\n    # List of environment variables being updated or removed.\n    stomped = (set(update.keys()) | set(remove)) & set(env.keys())\n    # Environment variables and values to restore on exit.\n    update_after = {k: env[k] for k in stomped}\n    # Environment variables and values to remove on exit.\n    remove_after = frozenset(k for k in update if k not in env)\n\n    try:\n        env.update(update)\n        [env.pop(k, None) for k in remove]  # pylint: disable=expression-not-assigned\n        yield\n    finally:\n        env.update(update_after)\n        [env.pop(k) for k in remove_after]", "response": "Returns an iterator over the environment variables that have been modified in - place."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef eval_first_non_none(eval_list: Iterable[Callable[..., Any]], **kwargs: Any) -> Any:\n    Validator.is_real_iterable(raise_ex=True, eval_list=eval_list)\n\n    for eval_fun in eval_list:\n        res = eval_fun(**kwargs)\n        if res is not None:\n            return res\n    return None", "response": "Executes a list of functions and returns the first non - none result."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef on_person_new(self, people):\n        self.debug(\"()\")\n        changed = []\n        with self._people_lock:\n            for p in people:\n                person = Person.from_person(p)\n                if person.id in self._people:\n                    self.warning(\n                        u\"{} already in audience\".format(person.id)\n                    )\n                self._people[person.id] = person\n                changed.append(person)\n        for plugin in self.plugins:\n            try:\n                plugin.on_person_new(changed)\n            except:\n                self.exception(\n                    u\"Failed to send new people to {}\".format(plugin.name)\n                )", "response": "Called by the audience when a new person is added to the audience."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncalls by the Audience when a person has changed.", "response": "def on_person_update(self, people):\n        \"\"\"\n        People have changed (e.g. a sensor value)\n\n        :param people: People whos state changed (may include unchanged)\n        :type people: list[paps.person.Person]\n        :rtype: None\n        \"\"\"\n        self.debug(\"()\")\n        changed = []\n        with self._people_lock:\n            for p in people:\n                person = Person.from_person(p)\n                if person.id not in self._people:\n                    self.warning(u\"{} not in audience\".format(person.id))\n                self._people[person.id] = person\n                # Check if really changed? - trust source for now\n                changed.append(person)\n        for plugin in self.plugins:\n            try:\n                plugin.on_person_update(changed)\n            except:\n                self.exception(\n                    u\"Failed to send updated people to {}\".format(plugin.name)\n                )"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nstarting the interface and all the plugins.", "response": "def start(self, blocking=False):\n        \"\"\"\n        Start the interface\n\n        :param blocking: Should the call block until stop() is called\n            (default: False)\n        :type blocking: bool\n        :rtype: None\n        \"\"\"\n        self.debug(\"()\")\n        # Start the plugins\n        for plugin in self.plugins:\n            try:\n                # Inject self into plugin\n                plugin.controller = self\n                plugin.start(blocking=False)\n            except:\n                self.exception(\n                    u\"Failed to start plugin {}\".format(plugin.name)\n                )\n                raise PluginStartException(\n                    \"Starting one or more plugins failed\"\n                )\n        super(CrowdController, self).start(blocking=blocking)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nstopping the internal state of the internal state of the internal state.", "response": "def stop(self):\n        \"\"\"\n        Stop the interface\n\n        :rtype: None\n        \"\"\"\n        self.debug(\"()\")\n        # Stop the plugins\n        for plugin in self.plugins:\n            try:\n                plugin.stop()\n            except:\n                self.exception(u\"Failed to stop plugin {}\".format(plugin.name))\n        super(CrowdController, self).stop()"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nnormalizes the column name to make it Python - compatible.", "response": "def normalize_col_name(self, col_name, used_column_names, is_relation):\n        \"\"\"\n        Modify the column name to make it Python-compatible as a field name\n        \"\"\"\n        field_params = {}\n        field_notes = []\n\n        new_name = col_name.lower()\n        if new_name != col_name:\n            field_notes.append('Field name made lowercase.')\n\n        if is_relation:\n            if new_name.endswith('_id'):\n                new_name = new_name[:-3]\n            else:\n                field_params['db_column'] = col_name\n\n        new_name, num_repl = re.subn(r'\\W', '_', new_name)\n        if num_repl > 0:\n            field_notes.append('Field renamed to remove unsuitable characters.')\n\n        if new_name.find('__') >= 0:\n            while new_name.find('__') >= 0:\n                new_name = new_name.replace('__', '_')\n            if col_name.lower().find('__') >= 0:\n                # Only add the comment if the double underscore was in the original name\n                field_notes.append(\"Field renamed because it contained more than one '_' in a row.\")\n\n        if new_name.startswith('_'):\n            new_name = 'field%s' % new_name\n            field_notes.append(\"Field renamed because it started with '_'.\")\n\n        if new_name.endswith('_'):\n            new_name = '%sfield' % new_name\n            field_notes.append(\"Field renamed because it ended with '_'.\")\n\n        if keyword.iskeyword(new_name):\n            new_name += '_field'\n            field_notes.append('Field renamed because it was a Python reserved word.')\n\n        if new_name[0].isdigit():\n            new_name = 'number_%s' % new_name\n            field_notes.append(\"Field renamed because it wasn't a valid Python identifier.\")\n\n        if new_name in used_column_names:\n            num = 0\n            while '%s_%d' % (new_name, num) in used_column_names:\n                num += 1\n            new_name = '%s_%d' % (new_name, num)\n            field_notes.append('Field renamed because of name conflict.')\n\n        if col_name != new_name and field_notes:\n            field_params['db_column'] = col_name\n\n        return new_name, field_params, field_notes"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngiving the database connection, the table name, and the cursor row description, this routine will return the given field type name, as well as any additional keyword parameters and notes for the field.", "response": "def get_field_type(self, connection, table_name, row):\n        \"\"\"\n        Given the database connection, the table name, and the cursor row\n        description, this routine will return the given field type name, as\n        well as any additional keyword parameters and notes for the field.\n        \"\"\"\n        field_params = {}\n        field_notes = []\n\n        try:\n            field_type = connection.introspection.get_field_type(row[1], row)\n        except KeyError:\n            field_type = 'TextField'\n            field_notes.append('This field type is a guess.')\n\n        # This is a hook for DATA_TYPES_REVERSE to return a tuple of\n        # (field_type, field_params_dict).\n        if type(field_type) is tuple:\n            field_type, new_params = field_type\n            field_params.update(new_params)\n\n        # Add max_length for all CharFields.\n        if field_type == 'CharField' and row[3]:\n            field_params['max_length'] = row[3]\n\n        if field_type == 'DecimalField':\n            field_params['max_digits'] = row[4]\n            field_params['decimal_places'] = row[5]\n\n        return field_type, field_params, field_notes"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef MonSQL(host=None, port=None, username=None, password=None, dbname=None, dbpath=None, dbtype=None):\n\tif dbtype is None:\n\t\traise MonSQLException('Database type must be specified')\n\n\tif dbtype == DB_TYPES.MYSQL:\n\t\treturn MySQLDatabase(host, port, username, password, dbname)\n\telif dbtype == DB_TYPES.SQLITE3:\n\t\treturn SQLite3Database(dbpath)\n\telif dbtype == DB_TYPES.POSTGRESQL:\n\t\treturn PostgreSQLDatabase(host, port, username, password, dbname)\n\telse:\n\t\traise MonSQLException('Database type %s not supported' %dbtype)", "response": "Initialize and return a Database instance."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef check_password(self, raw_password):\n        def setter(raw_password):\n            self.set_password(raw_password)\n            self.save(update_fields=[self.PASSWORD_FIELD])\n        return check_password(raw_password, getattr(self, self.PASSWORD_FIELD), setter)", "response": "Checks if the raw_password is correct for the current user."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_form(self, key, form_class=None):\n        if form_class is None:\n            form_class = self.get_form_class(key)\n        return form_class(**self.get_form_kwargs(key))", "response": "Returns an instance of the form to be used in this view."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the keyword arguments for instantiating the form.", "response": "def get_form_kwargs(self, key):\n        \"\"\"\n        Returns the keyword arguments for instantiating the form.\n        \"\"\"\n        kwargs = {\n            'initial': self.get_initial(key),\n            'prefix': self.get_prefix(key),\n        }\n\n        if self.request.method in ('POST', 'PUT'):\n            kwargs.update({\n                'data': self.request.POST,\n                'files': self.request.FILES,\n            })\n        return kwargs"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_context_data(self, **kwargs):\n        for key in self.get_form_class_keys():\n            kwargs['{}_form'.format(key)] = self.get_form(key)\n        return super(FormMixin, self).get_context_data(**kwargs)", "response": "Insert the form into the context dict."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_form_kwargs(self, key):\n        kwargs = super(MultipleModelFormMixin, self).get_form_kwargs(key)\n        if hasattr(self, '{}_object'.format(key)):\n            kwargs.update({'instance': getattr(self, '{}_object'.format(key))})\n        return kwargs", "response": "Returns the keyword arguments for instantiating the form."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nsave the associated model.", "response": "def form_valid(self, forms):\n        \"\"\"\n        If the form is valid, save the associated model.\n        \"\"\"\n        for key, form in forms.items():\n            setattr(self, '{}_object'.format(key), form.save())\n        return super(MultipleModelFormMixin, self).form_valid(forms)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a new QuerySet with points within a given radius.", "response": "def within(self, lat, lon, radius):\n\t\t'''Convenience method to apply a $loc/$within/$center filter. Radius is in meters.'''\n\t\treturn self.filter(filter_helpers.within_(lat, lon, radius))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nredirect to an object s page based on a content - type ID and an object ID.", "response": "def view_on_site(self, request, content_type_id, object_id):\n        \"\"\"\n        Redirect to an object's page based on a content-type ID and an object ID.\n        \"\"\"\n        # Look up the object, making sure it's got a get_absolute_url() function.\n        try:\n            content_type = ContentType.objects.get(pk=content_type_id)\n            if not content_type.model_class():\n                raise Http404(_(\"Content type %(ct_id)s object has no associated model\") % {\n                    'ct_id': content_type_id,\n                })\n            obj = content_type.get_object_for_this_type(pk=object_id)\n        except (ObjectDoesNotExist, ValueError):\n            raise Http404(_(\"Content type %(ct_id)s object %(obj_id)s doesn't exist\") % {\n                'ct_id': content_type_id,\n                'obj_id': object_id,\n            })\n\n        try:\n            get_absolute_url = obj.get_absolute_url\n        except AttributeError:\n            raise Http404(_(\"%(ct_name)s objects don't have a get_absolute_url() method\") % {\n                'ct_name': content_type.name,\n            })\n        absurl = get_absolute_url()\n\n        return HttpResponseRedirect(absurl)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_graderoster(section, instructor, requestor):\n    label = GradeRoster(section=section,\n                        instructor=instructor).graderoster_label()\n    url = \"{}/{}\".format(graderoster_url, encode_section_label(label))\n    headers = {\"Accept\": \"text/xhtml\",\n               \"Connection\": \"keep-alive\",\n               \"X-UW-Act-as\": requestor.uwnetid}\n\n    response = SWS_GradeRoster_DAO().getURL(url, headers)\n\n    if response.status != 200:\n        root = etree.fromstring(response.data)\n        msg = root.find(\".//*[@class='status_description']\").text.strip()\n        raise DataFailureException(url, response.status, msg)\n\n    return GradeRoster(data=etree.fromstring(response.data.strip()),\n                       section=section,\n                       instructor=instructor)", "response": "Returns a GradeRoster for the passed Section model and\n                        instructor Person."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef update_graderoster(graderoster, requestor):\n    label = graderoster.graderoster_label()\n    url = \"{}/{}\".format(graderoster_url, encode_section_label(label))\n    headers = {\"Content-Type\": \"application/xhtml+xml\",\n               \"Connection\": \"keep-alive\",\n               \"X-UW-Act-as\": requestor.uwnetid}\n    body = graderoster.xhtml()\n\n    response = SWS_GradeRoster_DAO().putURL(url, headers, body)\n\n    if response.status != 200:\n        root = etree.fromstring(response.data)\n        msg = root.find(\".//*[@class='status_description']\").text.strip()\n        raise DataFailureException(url, response.status, msg)\n\n    return GradeRoster(data=etree.fromstring(response.data.strip()),\n                       section=graderoster.section,\n                       instructor=graderoster.instructor)", "response": "Updates the graderoster resource for the passed requestor."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef cpuinfo():\n    ''' Return the information in /proc/cpuinfo\n    as a dictionary in the following format:\n    cpu_info['proc0']={...}\n    cpu_info['proc1']={...}\n\n    '''\n\n    cpuinfo=OrderedDict()\n    procinfo=OrderedDict()\n\n    nprocs = 0\n    with open('/proc/cpuinfo') as f:\n        for line in f:\n            if not line.strip():\n                # end of one processor\n                cpuinfo['proc%s' % nprocs] = procinfo\n                nprocs=nprocs+1\n                # Reset\n                procinfo=OrderedDict()\n            else:\n                if len(line.split(':')) == 2:\n                    procinfo[line.split(':')[0].strip()] = line.split(':')[1].strip()\n                else:\n                    procinfo[line.split(':')[0].strip()] = ''\n            \n    return cpuinfo", "response": "Return the information in the system as a dictionary in the following format."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the information in / proc / meminfo as a dictionary", "response": "def meminfo():\n    ''' Return the information in /proc/meminfo\n    as a dictionary '''\n    meminfo=OrderedDict()\n\n    with open('/proc/meminfo') as f:\n        for line in f:\n            meminfo[line.split(':')[0]] = line.split(':')[1].strip()\n    return meminfo"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a namedtuple containing the RX and TX bytes for each of the network devices.", "response": "def netdevs():\n    ''' RX and TX bytes for each of the network devices '''\n\n    with open('/proc/net/dev') as f:\n        net_dump = f.readlines()\n    \n    device_data={}\n    data = namedtuple('data',['rx','tx'])\n    for line in net_dump[2:]:\n        line = line.split(':')\n        if line[0].strip() != 'lo':\n            device_data[line[0].strip()] = data(float(line[1].split()[0])/(1024.0*1024.0), \n                                                float(line[1].split()[8])/(1024.0*1024.0))\n    \n    return device_data"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef create_content_item(access_token, payload):\n\t'''\n\tName: create_content_item\n\tParameters: access_token, payload (dict)\n\tReturn: dictionary\n\t'''\n\n\theaders = {\n\t\t'Content-Type': 'application/json',\n\t\t'Authorization': 'Bearer ' + str(access_token)\n\t}\n\n\trequest = requests.post(enrichment_url, json=payload, headers=headers)\n\tif request.status_code == 201:\n\n\t\tcontent_item = request.json()\n\t\treturn content_item\n\n\treturn {'status': request.status_code, \"message\": request.text}", "response": "Function to create a content item."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nnames get_content_item Parameters: access_token, content_item_id Return: dictionary", "response": "def get_content_item(access_token, content_item_id):\n\t'''\n\tName: get_content_item\n\tParameters: access_token, content_item_id\n\tReturn: dictionary\n\t'''\n\n\theaders = {'Authorization': 'Bearer ' + str(access_token)}\n\tcontent_item_url =\\\n\t\tconstruct_content_item_url(enrichment_url, content_item_id)\n\n\trequest = requests.get(content_item_url, headers=headers)\n\tif request.status_code == 200:\n\n\t\tcontent_item = request.json()\n\t\treturn content_item\n\n\treturn {'status': request.status_code, \"message\": request.text}"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef update_content_item(access_token, content_item_id, payload):\n\t'''\n\tName: update_content_item\n\tParameters: access_token, content_item_id, payload (dict)\n\tReturn: dictionary\n\t'''\n\n\theaders = {'Authorization': 'Bearer ' + str(access_token)}\n\tcontent_item_url =\\\n\t\tconstruct_content_item_url(enrichment_url, content_item_id)\n\n\tpayload = create_random_payload(payload)\n\trequest = requests.put(content_item_url, json=payload, headers=headers)\n\n\tif request.status_code == 200:\n\n\t\tcontent_item = request.json()\n\t\treturn content_item\n\n\treturn {'status': request.status_code, \"message\": request.text}", "response": "This function is used to update a content item. It is used to update a content item."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nnaming delete_content_item Parameters: access_token, content_item_id Return: dictionary", "response": "def delete_content_item(access_token, content_item_id):\n\t'''\n\tName: delete_content_item\n\tParameters: access_token, content_item_id\n\tReturn: dictionary\n\t'''\n\n\theaders = {'Authorization': 'Bearer ' + str(access_token)}\n\tcontent_item_url =\\\n\t\tconstruct_content_item_url(enrichment_url, content_item_id)\n\n\trequest = requests.delete(content_item_url, headers=headers)\n\treturn {'status': request.status_code, 'message': request.text}"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nnames metadata_only Parameters: access_token, text (string) Return: dictionary", "response": "def metadata(access_token, text): # (Legacy)\n    '''\n\tName: metadata_only\n\tParameters: access_token, text (string)\n\tReturn: dictionary\n\t'''\n\n    headers = {\n        'Content-Type': 'application/json',\n        'Authorization': 'Bearer ' + str(access_token)\n\t}\n\n    payload = {'text': text}\n    request = requests.post(metadata_url, json=payload, headers=headers)\n    if request.status_code == 201:\n        metadata = request.json()\n        return metadata\n\n    return {'status': request.status_code, \"message\": request.text}"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_model(self, model, model_id):\n        return self._store.find_record(self._get_model_class(model), int(model_id))", "response": "Get a single model from the server."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_models(self, model, page=None):\n        if page is not None:\n            return self._store.find_all(self._get_model_class(model), params={'page': int(page)})\n        else:\n            return self._store.find_all(self._get_model_class(model))", "response": "Get all the models from the server."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a figure from an image file", "response": "def makeFigFromFile(filename,*args,**kwargs):\n    \"\"\"\n    Renders an image in a matplotlib figure, so it can be added to reports \n    args and kwargs are passed to plt.subplots\n    \"\"\"\n    import matplotlib.pyplot as plt\n    img = plt.imread(filename)\n    fig,ax = plt.subplots(*args,**kwargs)\n    ax.axis('off')\n    ax.imshow(img)\n    return fig"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nlisting the installed executables by this project.", "response": "def list_exes(self):\n        \"\"\"List the installed executables by this project.\"\"\"\n        return [path.join(self.env_bin, f)\n                for f\n                in os.listdir(self.env_bin)]"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate a virtual environment.", "response": "def create_env(self):\n        \"\"\"Create a virtual environment.\"\"\"\n        virtualenv(self.env, _err=sys.stderr)\n        os.mkdir(self.env_bin)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef install_program(self, extra_args):\n        pip = Command(path.join(self.env, 'bin', 'pip'))\n        args = ['install', self.raw_name,\n                '--install-option', '--install-scripts={}'\n                .format(self.env_bin)] + list(extra_args)\n        print_pretty(\"<BOLD>pip {}<END>\\n\".format(' '.join(args)))\n        pip(args, _out=sys.stdout, _err=sys.stderr)\n        print('')", "response": "Install the app to the virtualenv"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef create_links(self):\n        for link in self.list_exes():\n            print_pretty(\"<FG_BLUE>Creating link for {}...<END>\".format(link))\n            os.symlink(link, path.join(ENV_BIN, path.basename(link)))", "response": "Create links to installed scripts in the virtualenv s\n        bin directory to our bin directory."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef remove_links(self):\n        for link in self.list_exes():\n            link = path.join(ENV_BIN, path.basename(link))\n            print_pretty(\"<FG_BLUE>Removing link {}...<END>\".format(link))\n            os.remove(link)", "response": "Remove links from our bin."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef uninstall(self):\n        if path.isdir(self.env_bin):\n            self.remove_links()\n        if path.isdir(self.env):\n            print_pretty(\"<FG_BLUE>Removing env {}...<END>\".format(self.env))\n            shutil.rmtree(self.env)", "response": "Uninstall the environment and links."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ninstalling the program and put links in place.", "response": "def install(self, pip_args=None):\n        \"\"\"Install the program and put links in place.\"\"\"\n        if path.isdir(self.env):\n            print_pretty(\"<FG_RED>This seems to already be installed.<END>\")\n        else:\n            print_pretty(\"<FG_BLUE>Creating environment {}...<END>\\n\".format(self.env))\n            self.create_env()\n            self.install_program(pip_args)\n            self.create_links()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef update(self, repo_dir, **kwargs):\n        del kwargs\n        rev = self._args.get(\"revision\")\n        if rev:\n            return [{\"args\": [\"git\", \"checkout\", rev], \"cwd\": repo_dir}] + _ff_command(\n                rev, repo_dir\n            )\n        return None", "response": "This function updates an existing checkout of source code."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nparsing Energy Re sigma xx Re sigma zz absorp xx absorp zz", "response": "def _parse_absorption(line, lines):\n    \"\"\"Parse Energy, Re sigma xx, Re sigma zz, absorp xx, absorp zz\"\"\"\n\n    split_line = line.split()\n\n    energy = float(split_line[0])\n    re_sigma_xx = float(split_line[1])\n    re_sigma_zz = float(split_line[2])\n    absorp_xx = float(split_line[3])\n    absorp_zz = float(split_line[4])\n\n    return {\"energy\": energy, \"re_sigma_xx\": re_sigma_xx, \"re_sigma_zz\": re_sigma_zz,\n            \"absorp_xx\": absorp_xx, \"absorp_zz\": absorp_zz}"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef parse_args():\n    parser = arguments.parser(__doc__)\n    parser.args('streams', help='streams to use')\n    parser.opt('-p', '--paste', 'paste text from clipboard')\n    parser.opt('-i', '--stdin', 'wait for text from stdin')\n    return parser.parse_args()", "response": "Parse out command line arguments"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ninterpreting parsed args to streams", "response": "def args(parsed_args, name=None):\n    \"\"\"Interpret parsed args to streams\"\"\"\n    strings = parsed_args.arg_strings(name)\n    files = [s for s in strings if os.path.isfile(s)]\n    if files:\n        streams = [open(f) for f in files]\n    else:\n        streams = []\n    if getattr(parsed_args, 'paste', not files):\n        streams.append(clipboard_stream())\n    if getattr(parsed_args, 'stdin', False):\n        streams.append(sys.stdin)\n    elif not streams:\n        streams = [sys.stdin]\n    return streams"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef use(self, algorithm):\n        algorithm = algorithm.lower()\n        if algorithm == \"md5\":\n            self.default_hash_method = hashlib.md5\n        elif algorithm == \"sha1\":\n            self.default_hash_method = hashlib.sha1\n        elif algorithm == \"sha224\":\n            self.default_hash_method = hashlib.sha224\n        elif algorithm == \"sha256\":\n            self.default_hash_method = hashlib.sha256\n        elif algorithm == \"sha384\":\n            self.default_hash_method = hashlib.sha384\n        elif algorithm == \"sha512\":\n            self.default_hash_method = hashlib.sha512\n        else:\n            raise WrongHashAlgorithmError(\"There's no algorithm names '%s'! \"\n                                          \"use one of 'md5', 'sha1', 'sha224', \"\n                                          \"'sha256', 'sha384', 'sha512'.\" % algorithm)", "response": "Change the hash algorithm you gonna use."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef of_file(self, abspath, nbytes=0):\n        if not os.path.exists(abspath):\n            raise FileNotFoundError(\n                \"[Errno 2] No such file or directory: '%s'\" % abspath)\n\n        m = self.default_hash_method()\n        with open(abspath, \"rb\") as f:\n            if nbytes:\n                data = f.read(nbytes)\n                if data:\n                    m.update(data)\n            else:\n                while True:\n                    data = f.read(self._chunk_size)\n                    if not data:\n                        break\n                    m.update(data)\n        if self.return_int:\n            return int(m.hexdigest(), 16)\n        else:\n            return m.hexdigest()", "response": "Return the hash value of a piece of a file."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef try_until_succeed(_warning_period, func, *argv, **kwarg):\n    if (not isinstance(_warning_period, int)) or (_warning_period < 1):\n        raise Exception(\"'_warning_period' argument has to be int \"\n                        \"and greater than 0\")\n        \n    counter = 1\n    while 1:\n        try:\n            return func(*argv, **kwarg)\n        except Exception as e:\n            current_exception = e\n            counter += 1\n            if (counter % _warning_period) == 0:\n                print(\"Warning: this is %sth try, current error is \"\n                      \"%s\" % (counter, repr(current_exception)))", "response": "Try a function until it successfully returns."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef try_ntimes(_howmany, func, *argv, **kwarg):\n    if (not isinstance(_howmany, int)) or (_howmany < 1):\n        raise Exception(\"'_howmany' argument has to be int and greater than 0\")\n    \n    counter = 1\n    while counter <= _howmany:\n        try:\n            return func(*argv, **kwarg)\n        except Exception as e:\n            current_exception = e\n            counter += 1\n    raise current_exception", "response": "Try a function n times."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef main(argv=None):\n    if argv is None:\n        argv = sys.argv[1:]\n    args = _get_parser().parse_args(argv)\n    mand(args.module_seq)", "response": "Execute each module in the same interpreter."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef call_multiple_modules(module_gen):\n    for args_seq in module_gen:\n        module_name_or_path = args_seq[0]\n        with replace_sys_args(args_seq):\n            if re.match(VALID_PACKAGE_RE, module_name_or_path):\n                runpy.run_module(module_name_or_path,\n                                 run_name='__main__')\n            else:\n                runpy.run_path(module_name_or_path,\n                               run_name='__main__')", "response": "Call each module in module_gen"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nprints the report configuration for logging purposes.", "response": "def ReportConfiguration(self, file):\n        \"\"\" Report configuration for logging purposes.\n\n        :param file: Destination for report details\n        :return: None\n        \"\"\"\n\n        print >> file, BuildReportLine(\"BED_FILE\", self.bed_file)\n        print >> file, BuildReportLine(\"BIM_FILE\", self.bim_file)\n        print >> file, BuildReportLine(\"FAMFILE\", self.fam_file)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef load_fam(self, pheno_covar=None):\n        logging.info(\"Loading file: %s\" % (self.fam_file))\n        pheno_col = 5\n        if not DataParser.has_sex:\n            pheno_col -= 1\n        if not DataParser.has_parents:\n            pheno_col -= 2\n        if not DataParser.has_fid:\n            pheno_col -= 1\n\n        sex_col = pheno_col - 1\n        mask_components = []\n        for line in open(self.fam_file):\n            words = line.strip().split()\n            if len(words) > 1:\n                indid = \":\".join(words[0:2])\n                if DataParser.valid_indid(indid):\n                    mask_components.append(0)\n\n                    sex = None\n                    pheno = None\n                    if DataParser.has_sex:\n                        sex = int(words[sex_col])\n                    if DataParser.has_pheno:\n                        pheno = float(words[pheno_col])\n                    if pheno_covar is not None:\n                        pheno_covar.add_subject(indid, sex, pheno)\n                    if len(words) > 0:\n                        self.families.append(words)\n                else:\n                    mask_components.append(1)\n        mask_components = numpy.array(mask_components)\n        self.ind_mask = numpy.zeros(len(mask_components), dtype=numpy.int8)\n        self.ind_mask = mask_components\n        self.ind_count = self.ind_mask.shape[0]\n        if pheno_covar is not None:\n            pheno_covar.freeze_subjects()", "response": "Load the contents from the. fam file and update the pheno_covar with the corresponding object."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef load_bim(self, map3=False):\n        cols = [0, 1, 3, 4, 5]\n        if map3:\n            cols = [0, 1, 2, 3, 4]\n        logging.info(\"Loading file: %s\" % self.bim_file)\n        val = sys_call('wc -l %s' % (self.bim_file))[0][0].split()[0]\n        marker_count = int(val)\n        self.markers = numpy.zeros((marker_count, 2), dtype=int)\n        self.rsids = []\n        self.alleles = []\n\n        with open(self.bim_file) as file:\n            index = 0\n            for line in file:\n                if map3:\n                    chr, rsid, pos, al1, al2 = line.strip().split()\n                else:\n                    chr, rsid, gd, pos, al1, al2 = line.strip().split()\n                self.markers[index, 0] = int(chr)\n                self.markers[index, 1] = int(pos)\n                self.alleles.append([al1, al2])\n                self.rsids.append(rsid)\n                index += 1\n        self.locus_count = self.markers.shape[0]", "response": "Basic marker details loading."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreset the bed file and preps it for starting at the start of the \\ genotype data structures Returns the magic number and the data format of the \\ genotype data structures", "response": "def init_genotype_file(self):\n        \"\"\"Resets the bed file and preps it for starting at the start of the \\\n            genotype data\n\n        Returns to beginning of file and reads the version so that it points \\\n        to first marker's info\n\n        :return: None\n        \"\"\"\n        self.genotype_file.seek(0)\n\n        buff = self.genotype_file.read(3)\n        version = 0\n        magic, data_format = buff.unpack(\"HB\", version)\n        return magic, data_format"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef extract_genotypes(self, bytes):\n        genotypes = []\n        for b in bytes:\n            for i in range(0, 4):\n                v = ((b>>(i*2)) & 3)\n                genotypes.append(self.geno_conversions[v])\n        return genotypes[0:self.ind_count]", "response": "Extracts encoded genotype data from binary formatted file."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef filter_missing(self):\n        missing             = None\n        locus_count         = 0\n        logging.info(\"Sorting out missing data from genotype data\")\n        # Filter out individuals according to missingness\n        self.genotype_file.seek(0)\n        magic, data_format = struct.unpack(\"<HB\", self.genotype_file.read(3))\n\n        if data_format != 1:\n            Exit((\"MVTEST is currently unable to read data formatted as \" +\n                 \"individual major. You must regenerate your data in SNP major\"+\n                 \" format. \"))\n\n        self.bytes_per_read = self.ind_count / 4\n        if self.ind_count % 4 > 0:\n            self.bytes_per_read += 1\n        self.fmt_string = \"<\" + \"B\"*self.bytes_per_read\n        last_chr = -1\n        for index in range(self.locus_count):\n            buffer = struct.unpack(self.fmt_string,\n                                   self.genotype_file.read(self.bytes_per_read))\n\n            chr, pos = self.markers[index]\n\n            rsid = self.rsids[index]\n\n            if DataParser.boundary.TestBoundary(chr, pos, rsid):\n                if last_chr != chr:\n                    sys.stdout.flush()\n                    last_chr = chr\n                genotypes = numpy.array(self.extract_genotypes(buffer),\n                                        dtype=numpy.int8)\n                locus_count += 1\n\n                if missing is None:\n                    missing = numpy.zeros(genotypes.shape[0], dtype='int8')\n                missing +=  0+(genotypes==DataParser.missing_storage)\n\n        max_missing = DataParser.ind_miss_tol * locus_count\n        dropped_individuals = 0+(max_missing<missing)\n\n        self.ind_mask = self.ind_mask|dropped_individuals\n\n        valid_individuals = numpy.sum(self.ind_mask==0)\n        max_missing = DataParser.snp_miss_tol * valid_individuals\n\n        # We can't merge these two iterations since we need to know which\n        # individuals to consider for filtering on MAF\n        dropped_snps = []\n        self.genotype_file.seek(0)\n        self.genotype_file.read(3)\n        self.total_locus_count = self.locus_count\n        self.locus_count = 0\n        last_chr = -1\n        for index in range(self.total_locus_count):\n            buffer = struct.unpack(self.fmt_string,\n                                   self.genotype_file.read(self.bytes_per_read))\n\n            genotypes = numpy.ma.MaskedArray(self.extract_genotypes(buffer),\n                                             self.ind_mask).compressed()\n            chr, pos = self.markers[index]\n\n            rsid = self.rsids[index]\n            if DataParser.boundary.TestBoundary(chr, pos, rsid):\n                if last_chr != chr:\n                    sys.stdout.flush()\n                    last_chr = chr\n                missing = numpy.sum(0+(genotypes==DataParser.missing_storage))\n                if missing > max_missing:\n                    DataParser.boundary.dropped_snps[int(chr)].add(int(pos))\n                    dropped_snps.append(rsid)\n                else:\n                    self.locus_count += 1", "response": "Filter out individuals that have too many missing to be \\ considered\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef populate_iteration(self, iteration):\n\n        cur_idx = iteration.cur_idx\n\n        if cur_idx < self.total_locus_count:\n            buffer = struct.unpack(self.fmt_string,\n                                   self.genotype_file.read(self.bytes_per_read))\n            genotypes = numpy.ma.MaskedArray(self.extract_genotypes(buffer),\n                                             self.ind_mask).compressed()\n\n            iteration.chr, iteration.pos = self.markers[cur_idx]\n            iteration.rsid = self.rsids[cur_idx]\n\n\n            if DataParser.boundary.TestBoundary(iteration.chr,\n                                                iteration.pos,\n                                                iteration.rsid):\n                hz_count = numpy.sum(genotypes==1)\n                allele_count1 = numpy.sum(genotypes==0)*2 + hz_count\n                allele_count2 = numpy.sum(genotypes==2)*2 + hz_count\n                iteration.minor_allele, \\\n                    iteration.major_allele = self.alleles[cur_idx]\n\n                if allele_count2 > allele_count1:\n                    iteration.maj_allele_count = allele_count2\n                    iteration.min_allele_count = allele_count1\n                else:\n                    iteration.maj_allele_count = allele_count1\n                    iteration.min_allele_count = allele_count2\n                iteration.allele_count2 = allele_count2\n                iteration.genotype_data = genotypes\n                maf = iteration.maf\n                iteration.hetero_count = hz_count\n                return maf >= DataParser.min_maf and \\\n                       maf <= DataParser.max_maf\n        else:\n            raise StopIteration\n        return False", "response": "Populate the iteration with the current locus and genotypes."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _get_path():\n    if _path:\n        return _path[0]\n    environ_paths = set(os.environ['PATH'].split(':'))\n    environ_paths.add('/usr/local/bin')\n    environ_paths.add('/usr/bin')\n    _path.append(':'.join(environ_paths))\n    logger.debug('PATH = %s', _path[-1])\n    return _path[0]", "response": "Guarantee that local and bin are in PATH"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the full path of a file", "response": "def full_path(path):\n    \"\"\"Get the real path, expanding links and bashisms\"\"\"\n    return os.path.realpath(os.path.expanduser(os.path.expandvars(path)))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nparses an iterable source of strings into a generator", "response": "def parse(self, generator):\n        \"\"\"Parse an iterable source of strings into a generator\"\"\"\n        gen = iter(generator)\n        for line in gen:\n            block = {}\n            for rule in self.rules:\n                if rule[0](line):\n                    block = rule[1](line, gen)\n                    break\n            yield block"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef ReportConfiguration(self, file):\n        global encodingpar\n        print >> file, libgwas.BuildReportLine(\"MACH_ARCHIVES\", \"\")\n        if self.chrpos_encoding:\n            print >> file, libgwas.BuildReportLine(\"MACH_CHRPOS\",\n                                    (\"IDS expected to be in format chr:pos\" +\n                                    \" SNP boundary filters might not work \" +\n                                    \"(see manual for details)\"))\n        else:\n            print >> file, libgwas.BuildReportLine(\"MACH_CHRPOS\",\n                                    \"IDs are treated like RSIDs\")\n        idx = 0\n        for arch in self.archives[0:]:\n            print >> file, libgwas.BuildReportLine(\"\", \"%s:%s\" % (self.archives[idx], self.info_files[idx]))\n            idx += 1\n        print >> file, libgwas.BuildReportLine(\"ENCODING\", [\"Dosage\", \"Genotype\"][encoding])", "response": "Report the configuration details for logging purposes."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef load_family_details(self, pheno_covar):\n        self.file_index = 0\n        # 1s indicate an individual is to be masked out\n        mask_components = []\n\n        file = self.family_details\n        if DataParser.compressed_pedigree:\n            data, serr = sys_call('gunzip -c %s | wc -l' % (file))\n            self.line_count = int(data[0].strip().split(\" \")[0])\n            iddata, serr = sys_call('gunzip -c %s | cut -f 1' % (file))\n        else:\n            data, serr = sys_call('wc -l %s' % (file))\n            self.line_count = int(data[0].strip().split(\" \")[0])\n            iddata, serr = sys_call('cat %s | cut -f 1' % (file))\n\n        ids_observed = set()\n        for line in iddata:\n            indid = line.strip().split()[0]\n            indid = \":\".join(indid.split(\"->\"))\n\n            ExitIf(\"Duplicate ID found in dose file: %s\" % (indid), indid in ids_observed)\n            ids_observed.add(indid)\n\n            if DataParser.valid_indid(indid):\n                mask_components.append(0)\n                pheno_covar.add_subject(indid, PhenoCovar.missing_encoding, PhenoCovar.missing_encoding)\n            else:\n                mask_components.append(1)\n\n        self.ind_mask = numpy.array(mask_components) == 1\n        self.ind_count = self.ind_mask.shape[0]\n        pheno_covar.freeze_subjects()", "response": "Loads contents from the. fam file updating the pheno_covar with the family ids found."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nextract a fraction of the file loading the genotypes into memoery.", "response": "def parse_genotypes(self, lb, ub):\n        \"\"\"Extracts a fraction of the file (current chunk of loci) loading\n        the genotypes into memoery.\n\n        :param lb: Lower bound of the current chunk\n        :param ub: Upper bound of the current chunk\n        :return: Dosage dosages for current chunk\n\n        \"\"\"\n        file = self.openfile(self.current_file)\n        words = file.readline().strip().split()[lb:ub]\n        word_count = len(words)\n        idx =0\n\n        if word_count > 0:\n            dosages = numpy.empty((self.ind_count, word_count), dtype='|S5')\n            while word_count > 1:\n                dosages[idx] = numpy.array(words)\n                idx += 1\n                line = file.readline()\n                words = line.strip().split()[lb:ub]\n                word_count = len(words)\n        else:\n            raise EOFError\n\n        return dosages"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef load_genotypes(self):\n\n        lb = self.chunk * Parser.chunk_stride + 2\n        ub = (self.chunk + 1) * Parser.chunk_stride + 2\n\n        buff = None\n\n        self.current_file = self.archives[self.file_index]\n        self.info_file = self.info_files[self.file_index]\n\n        while buff is None:\n            try:\n                buff = self.parse_genotypes(lb, ub)\n            except EOFError:\n                buff = None\n                if self.file_index < (len(self.archives) - 1):\n                    self.file_index += 1\n                    self.chunk = 0\n                    lb = self.chunk * Parser.chunk_stride + 2\n                    ub = (self.chunk + 1) * Parser.chunk_stride + 2\n                    self.current_file = self.archives[self.file_index]\n                    self.info_file = self.info_files[self.file_index]\n                else:\n                    raise StopIteration\n\n        # Numpy's usecols don't prevent it from loading entire file, which is\n        # too big considering ours are 60+ gigs\n        self.dosages = numpy.transpose(buff)\n\n        file = self.openfile(self.info_file)\n        file.readline()     # drop header\n\n        lindex = 0\n        while lindex < lb - 2:\n            file.readline()\n            lindex += 1\n\n        self.markers = []\n        self.rsids = []\n        self.locus_count= 0\n        self.maf = []\n        self.alleles = []\n        self.rsquared = []\n\n        while lindex < (ub - 2):\n            words = file.readline().strip().split()\n            if len(words) > 0:\n                loc, al2, al1, freq1, maf, avgcall,rsq = words[0:7]\n                marker = [-1, lindex]\n                if self.chrpos_encoding:\n                    marker = [int(x) for x in loc.split(\":\")[0:2]]\n                    if len(marker) < 2:\n                        raise libgwas.exceptions.MalformedInputFile(\"MACH .info\"+\n                                \" file IDs must be in the format chrom:rsid\")\n                    if len(marker) > 2:\n                        self.rsids.append(marker[2])\n                    self.markers.append(marker[0:2])\n                else:\n                    self.markers.append(lindex)\n                    self.rsids.append(loc)\n                self.maf.append(float(maf))\n                self.alleles.append([al1, al2])\n                self.rsquared.append(float(rsq))\n                lindex += 1\n            else:\n                break\n\n        if self.dosages.shape[0] != len(self.markers):\n            print >> sys.stderr, \"What is going on? I have \", \\\n                    self.dosages.shape[0], \"dosages per individual and \", \\\n                    len(self.markers), self.markers\n\n        self.chunk += 1\n        self.marker_count = len(self.markers)", "response": "Load the first chunk of genotype data into memory."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef populate_iteration(self, iteration):\n        global encoding\n\n        # We never have to worry about iteration exceptions...that is taken\n        # care of in load_genotypes\n        cur_idx = iteration.cur_idx\n        if cur_idx < 0 or cur_idx >= self.marker_count:\n            self.load_genotypes()\n            iteration.cur_idx = 0\n            cur_idx = 0\n\n        if self.chrpos_encoding:\n            iteration.chr, iteration.pos = self.markers[cur_idx]\n        else:\n            iteration.chr = \"NA\"\n            iteration.pos = \"NA\"\n            iteration.rsid = self.rsids[cur_idx]\n\n        if cur_idx < len(self.markers) and DataParser.boundary.TestBoundary(iteration.chr, iteration.pos, iteration.rsid) and self.rsquared[cur_idx] >= Parser.min_rsquared:\n            iteration.major_allele, iteration.minor_allele = self.alleles[cur_idx]\n            iteration.genotype_data = numpy.ma.masked_array(self.dosages[cur_idx].astype(numpy.float), self.ind_mask).compressed()\n            iteration._maf = numpy.mean(iteration.genotype_data/2)\n            iteration.allele_count2 = (iteration.genotype_data.shape[0] * 4.0 - numpy.sum(iteration.genotype_data))\n\n            return iteration.maf >= DataParser.min_maf and iteration.maf <= DataParser.max_maf\n        return False", "response": "Populate the iteration with the current locus information."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nzip all files and items in a directory.", "response": "def zip_dir(path, zip_handler, include_dir=True, use_arc_name=False):\n    \"\"\"\n    zip all files and items in dir\n    :param only_init:\n    :param path:\n    :param zip_handler: zip file handler\n    :param boolean include_dir: specify if we want the archive with or without the directory\n    \"\"\"\n\n    for root, dirs, files in os.walk(path):\n        for file_to_zip in files:\n            filename = os.path.join(root, file_to_zip)\n            zip_con = filename.replace('\\\\', '/')\n\n            if zip_con in zip_handler.namelist():\n                continue\n\n            add_file(filename, zip_handler, include_dir, use_arc_name)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding init files to the included folder", "response": "def add_init_files(path, zip_handler):\n    \"\"\"\n    adds init files to the included folder\n    :param path: str\n\n    \"\"\"\n    paths = path.split('\\\\')\n    paths = paths[:len(paths) - 1]\n    for sub_path in paths:\n        for root, dirs, files in os.walk(sub_path):\n            for file_to_zip in [x for x in files if '__init__.py' in x]:\n                filename = os.path.join(root, file_to_zip)\n                zip_con = filename.replace('\\\\', '/')\n\n                if zip_con in zip_handler.namelist():\n                    continue\n\n                add_file(filename, zip_handler, False)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef singleton(cls):\n    '''\n    \u5355\u4f8b\u5b9e\u73b0\n    @singleton\n    class test():\n        pass\n    '''\n\n    cls.__new_original__ = cls.__new__\n\n    @wraps(cls.__new__)\n    def singleton_new(cls, *args, **kw):\n        it = cls.__dict__.get('__it__')\n        if it is not None:\n            return it\n\n        cls.__it__ = it = cls.__new_original__(cls, *args, **kw)\n        it.__init_original__(*args, **kw)\n        return it\n\n    cls.__new__ = singleton_new\n    cls.__init_original__ = cls.__init__\n    cls.__init__ = object.__init__\n\n    return cls", "response": "A singleton version of the base class."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _empty_value(self, formattype):\n        '''\n            returns default empty value \n        :param formattype:\n        :param buff:\n        :param start:\n        :param end:\n        '''\n        if formattype.value.idx <= FormatType.BIN_32.value.idx:  # @UndefinedVariable\n            return b''\n        elif formattype.value.idx <= FormatType.FIXSTR.value.idx:  # @UndefinedVariable  \n            return ''\n        elif formattype.value.idx <= FormatType.INT_64.value.idx:  # @UndefinedVariable\n            return 0\n        elif formattype.value.idx <= FormatType.UINT_64.value.idx:  # @UndefinedVariable\n            return 0\n        elif(formattype is FormatType.FLOAT_32):\n            return float(0)\n        elif(formattype is FormatType.FLOAT_64):\n            return float(0)", "response": "returns default empty value \n       "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef cancel(\n            self,\n            identifier: typing.Any,\n            exc_type: typing.Optional[type]=None,\n    ) -> bool:\n        \"\"\"Cancel an active coroutine and remove it from the schedule.\n\n        Args:\n            identifier (typing.Any): The identifier returned from add.\n            exc_type (typing.Optional[type]): The exception type to throw into\n                the coroutine on cancel. No exception is thrown if nothing is\n                given. Instead the coroutine is no longer processed.\n\n        Returns:\n            bool: True if the coroutine is cancelled. False if the identifier\n                is invalid or if the coroutine is complete.\n        \"\"\"\n        raise NotImplementedError()", "response": "Cancel an active coroutine and remove it from the schedule."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nbinds an environment variable to an argument action.", "response": "def bind_env(self, action, env):\n        \"\"\" Bind an environment variable to an argument action.  The env\n        value will traditionally be something uppercase like `MYAPP_FOO_ARG`.\n\n        Note that the ENV value is assigned using `set_defaults()` and as such\n        it will be overridden if the argument is set via `parse_args()` \"\"\"\n        if env in self._env_actions:\n            raise ValueError('Duplicate ENV variable: %s' % env)\n        self._env_actions[env] = action\n        action.env = env"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef print_help(self, *args, **kwargs):\n        if self._command is not None and self._command.session.allow_pager:\n            desc = 'Help\\: %s' % '-'.join(self.prog.split())\n            pager_kwargs = self._command.get_pager_spec()\n            with paging.pager_redirect(desc, **pager_kwargs):\n                return super().print_help(*args, **kwargs)\n        else:\n                return super().print_help(*args, **kwargs)", "response": "Add pager support to help output."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef add_subparsers(self, prog=None, **kwargs):\n        if prog is None:\n            # Use a non-shellish help formatter to avoid vt100 codes.\n            f = argparse.HelpFormatter(prog=self.prog)\n            f.add_usage(self.usage, self._get_positional_actions(),\n                        self._mutually_exclusive_groups, '')\n            prog = f.format_help().strip()\n        return super().add_subparsers(prog=prog, **kwargs)", "response": "Add subcommands to the ArgumentParser."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nanalyze the log file and add the parsed lines to the list of log files that are noisy or quiet.", "response": "def _analyze(self):\n        \"\"\"\n        Apply the filter to the log file\n        \"\"\"\n        for parsed_line in self.parsed_lines:\n            if 'ip' in parsed_line:\n                if parsed_line['ip'] in self.filter['ips']:\n                    self.noisy_logs.append(parsed_line)\n                else:\n                    self.quiet_logs.append(parsed_line)\n            else:\n                self.quiet_logs.append(parsed_line)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nparse raw log lines and convert it to a dictionary with extracted features.", "response": "def _extract_line_features(self):\n        \"\"\"\n        Parse raw log lines and convert it to a dictionary with extracted features.\n        \"\"\"\n        for line in self.line_iterator:\n            m = re.search(GENERIC_IPV4_REGEX, line)\n\n            data = {\n                'raw': line\n            }\n\n            if m:\n                data['ip'] = m.group('ip')\n\n            self.parsed_lines.append(data)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _extract_features(self):\n        for parsed_line in self.parsed_lines:\n            result = {'raw': parsed_line}\n\n            if 'ip' in parsed_line:\n                result['ip'] = parsed_line['ip']\n                if result['ip'] not in self.features['ips']:\n                    self.features['ips'].append(result['ip'])", "response": "Extract the features from the log file necessary for a reduction"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the local ip of this device", "response": "def _get_local_ip():\n        \"\"\"\n        Get the local ip of this device\n\n        :return: Ip of this computer\n        :rtype: str\n        \"\"\"\n        return set([x[4][0] for x in socket.getaddrinfo(\n            socket.gethostname(),\n            80,\n            socket.AF_INET\n        )]).pop()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _init_listen_socket(self):\n        self.debug(\"()\")\n        self._listen_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        self._listen_socket.setsockopt(\n            socket.SOL_SOCKET,\n            socket.SO_REUSEADDR,\n            1\n        )\n        self._listen_socket.bind((self._listen_ip, self._listen_port))\n        self._listening.append(self._listen_socket)", "response": "Initialize the listen socket."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _shutdown_listen_socket(self):\n        self.debug(\"()\")\n        if self._listen_socket in self._listening:\n            self._listening.remove(self._listen_socket)\n        if self._listen_socket:\n            self._listen_socket.close()\n        self._listen_socket = None", "response": "Shutdown the listen socket."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsend an UDP message to the listen socket.", "response": "def _send(self, ip, port, data):\n        \"\"\"\n        Send an UDP message\n\n        :param ip: Ip to send to\n        :type ip: str\n        :param port: Port to send to\n        :type port: int\n        :return: Number of bytes sent\n        :rtype: int\n        \"\"\"\n        return self._listen_socket.sendto(data, (ip, port))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _send_packet(\n            self, ip, port, packet,\n            update_timestamp=True, acknowledge_packet=True\n    ):\n        \"\"\"\n        Send a packet\n\n        :param ip: Ip to send to\n        :type ip: str\n        :param port: Port to send to\n        :type port: int\n        :param packet: Packet to be transmitted\n        :type packet: APPMessage\n        :param update_timestamp: Should update timestamp to current\n        :type update_timestamp: bool\n        :param acknowledge_packet: Should packet get acknowledged\n        :type acknowledge_packet: bool\n        :rtype: None\n        \"\"\"\n        if acknowledge_packet:\n            packet.header.sequence_number = self._send_seq_num\n            self._send_seq_num += 1\n        packet.header.device_id = self._device_id\n        try:\n            packed = packet.pack(update_timestamp=update_timestamp)\n        except ValueError:\n            self.exception(\"Failed to pack packet\")\n            return\n        self._send(ip, port, packed)\n        # TODO: add to wait for ack list\n        if acknowledge_packet:\n            with self._seq_ack_lock:\n                self._seq_ack.add(packet.header.sequence_number)\n            self._to_ack.put(\n                (time.time() + self._retransmit_timeout, 1, (ip, port), packet)\n            )\n        self.debug(u\"Send: {}\".format(packet))", "response": "Send a packet to the current node."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsending an ack packet to the current node.", "response": "def _send_ack(self, ip, port, packet, update_timestamp=True):\n        \"\"\"\n        Send an ack packet\n\n        :param ip: Ip to send to\n        :type ip: str\n        :param port: Port to send to\n        :type port: int\n        :param packet: Packet to be acknowledged\n        :type packet: APPMessage\n        :param update_timestamp: Should update timestamp to current\n        :type update_timestamp: bool\n        :rtype: None\n        \"\"\"\n        # TODO: maybe wait a bit, so the ack could get attached to another\n        # packet\n        ack = APPMessage(message_type=MsgType.ACK)\n        ack.header.ack_sequence_number = packet.header.sequence_number\n        self._send_packet(\n            ip, port, ack,\n            update_timestamp=update_timestamp, acknowledge_packet=False\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _get_packet(self, socket):\n        data, (ip, port) = socket.recvfrom(self._buffer_size)\n        packet, remainder = self._unpack(data)\n        self.inbox.put((ip, port, packet))\n        self.new_packet.set()\n        self.debug(u\"RX: {}\".format(packet))\n\n        if packet.header.sequence_number is not None:\n            # Packet needs to be acknowledged\n            self._send_ack(ip, port, packet)\n        ack_seq = packet.header.ack_sequence_number\n        if ack_seq is not None:\n            # Packet got acknowledged\n            with self._seq_ack_lock:\n                if ack_seq in self._seq_ack:\n                    self.debug(u\"Seq {} got acked\".format(ack_seq))\n                    self._seq_ack.remove(ack_seq)\n        return packet", "response": "Read packet and put it into inbox\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _receiving(self):\n        while self._is_running:\n            try:\n                rlist, wlist, xlist = select.select(\n                    self._listening, [], [],\n                    self._select_timeout\n                )\n            except:\n                self.exception(\"Failed to select socket\")\n                continue\n            for sock in rlist:\n                try:\n                    self._get_packet(sock)\n                except:\n                    self.exception(\"Failed to receive packet\")", "response": "Loop over the sockets and receive packets."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _acking(self, params=None):\n        while self._is_running:\n            try:\n                t, num_try, (ip, port), packet = self._to_ack.get(\n                    timeout=self._select_timeout\n                )\n            except queue.Empty:\n                # Timed out\n                continue\n\n            diff = t - time.time()\n            if diff > 0:\n                time.sleep(diff)\n\n            with self._seq_ack_lock:\n                if packet.header.sequence_number not in self._seq_ack:\n                    # Not waiting for this?\n                    continue\n\n            if num_try <= self._retransmit_max_tries:\n                # Try again\n                self._send(ip, port, packet.pack(True))\n                self._to_ack.put(\n                    (\n                        time.time() + self._retransmit_timeout,\n                        num_try + 1,\n                        (ip, port),\n                        packet\n                    )\n                )\n            else:\n                # Failed to ack\n                with self._seq_ack_lock:\n                    try:\n                        self._seq_ack.remove(packet.header.sequence_number)\n                    except KeyError:\n                        pass\n                self.warning(\"Exceeded max tries\")", "response": "Loop until the acking packet is received and retry the loop if the packet is not acknowledged."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef start(self, blocking=False):\n        try:\n            self._init_listen_socket()\n        except:\n            self.exception(u\"Failed to init listen socket ({}:{})\".format(\n                self._listen_ip, self._listen_port\n            ))\n            self._shutdown_listen_socket()\n            raise SensorStartException(\"Listen socket init failed\")\n        self.info(u\"Listening on {}:{}\".format(\n            self._listen_ip, self._listen_port\n        ))\n\n        super(Sensor, self).start(False)\n        try:\n            a_thread = threading.Thread(\n                target=self._thread_wrapper,\n                args=(self._receiving,)\n            )\n            a_thread.daemon = True\n            a_thread.start()\n        except:\n            self.exception(\"Failed to run receive loop\")\n            raise SensorStartException(\"Packet loop failed\")\n        super(Sensor, self).start(blocking)", "response": "Start the interface with the specified parameters."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef stop(self):\n        should_sleep = self._is_running\n        super(Sensor, self).stop()\n        if should_sleep:\n            # Make sure everything has enough time to exit\n            time.sleep(max(self._select_timeout, self._retransmit_timeout) + 1)\n        if self._listen_socket is not None:\n            self._shutdown_listen_socket()", "response": "Stop the interface\n\n        :rtype: None"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef gencode(data, output=None, tab=\"    \", indent=0, overwrite=False):\n    codegen = CodeGenerator(tab=tab, indent=indent)\n    \n    if isinstance(data, list):\n        for class_data in data:\n            codegen.pre_process(class_data)\n            codegen.sort_metadata()\n            codegen.repr_class_data(class_data)\n            \n        for class_data in data:            \n            codegen.lines.append(\"\")\n            codegen.lines.append(\"%s\" % codegen.repr_new_instance(class_data))\n    elif isinstance(data, dict):\n        codegen.pre_process(data)\n        codegen.repr_class_data(data)\n        codegen.lines.append(\"\")\n        codegen.lines.append(\"%s\" % codegen.repr_new_instance(data))\n\n    if output:\n        if not overwrite:\n            if os.path.exists(output):\n                raise FileExistsError(\"%r\" % output)\n        with open(output, \"wb\") as f:\n            f.write(codegen.code.encode(\"utf-8\"))\n    else:\n        print(codegen.code)", "response": "Generate code for a single object in a list of class data."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef repr_def_class(self, class_data):\n        classname = self.formatted_classname(class_data[\"classname\"])\n        if classname not in self.classes:\n            self.lines.append(\"\")\n            self.lines.append(\"class %s(%s):\" % (classname, self.basename))\n            \n            kwargs = list()\n            setattr_arguments = list()\n            for attr in self._classes[classname]:\n                kwargs.append(\"%s=None\" % attr)\n                setattr_arguments.append(\n                    self.Tab2 + \"self.%s = %s\" % (attr, attr))\n            if len(kwargs):\n                line = self.Tab + \"def __init__(self, %s):\" % \", \".join(kwargs)\n            else:\n                line = self.Tab + \"def __init__(self):\"\n            self.lines.append(line)\n            for setattr_argument in setattr_arguments:\n                self.lines.append(setattr_argument)\n            if len(setattr_arguments):\n                self.lines.append(\"\")\n            self.classes.add(classname)", "response": "Create code like this ::\n ArcGIS class"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating code like this ::", "response": "def repr_new_instance(self, class_data):\n        \"\"\"Create code like this::\n        \n            person = Person(name='Jack', person_id=1)\n        \"\"\"\n        classname = self.formatted_classname(class_data[\"classname\"])\n        instancename = self.formatted_instancename(class_data[\"classname\"])\n        arguments = list()\n        for key, value in self.sorted_dict(class_data.get(\"metadata\", dict())):\n            arguments.append(\"%s=%r\" % (key, value))\n        return \"%s = %s(%s)\" % (\n            instancename, classname, \", \".join(arguments))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef repr_setattr(self, class_data):\n        def get_indexable_attributes(class_data):\n            def isvalid(text):\n                for char in r\"\"\"~`!#%^&*()+=[]{}|\\:;\"'/.,<> \"\"\":\n                    if char in text:\n                        return False\n                return True\n            \n            indexable_attributes = list()\n            for key, value in class_data.get(\"metadata\", dict()).items():\n                if isinstance(value, _int_type):\n                    indexable_attributes.append(key)\n                elif isinstance(value, _str_type):\n                    if isvalid(value):\n                         indexable_attributes.append(key)\n                        \n            return indexable_attributes\n        \n        if \"subclass\" in class_data:\n            for subclass_data in class_data[\"subclass\"]:\n                instancename = self.formatted_instancename(subclass_data[\"classname\"])\n                self.lines.append(self.Tab2 + self.repr_new_instance(subclass_data))\n                indexable_attributes = get_indexable_attributes(subclass_data)\n                for key, value in self.sorted_dict(subclass_data.get(\"metadata\", dict())):\n                    if key in indexable_attributes:\n                        if isinstance(value, _int_type):\n                            if value < 0:\n                                self.lines.append(self.Tab2 + \"self.%s____neg%s = %s\" % (\n                                    key, -value, instancename))\n                            else:\n                                self.lines.append(self.Tab2 + \"self.%s____%s = %s\" % (\n                                    key, value, instancename))\n                        else:\n                            self.lines.append(self.Tab2 + \"self.%s____%s = %s\" % (\n                                key, value, instancename))\n                self.lines.append(self.Tab2)", "response": "Create code like this ::\n 69."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating code like this:: ArcGIS class data.", "response": "def repr_class_data(self, class_data):\n        \"\"\"Create code like this::\n        \n            class Person(classtree.Base):\n                def __init__(self, name=None, person_id=None):\n                    self.name = name\n                    self.person_id = person_id\n            \n            \n            class PersonCollection(classtree.Base):\n                def __init__(self, collection_id=None, create_date=None, name=None):\n                    self.collection_id = collection_id\n                    self.create_date = create_date\n                    self.name = name\n            \n                    person = Person(name='Jack', person_id=1)\n                    self.name____Jack = person\n                    self.person_id____1 = person\n                    \n                    person = Person(name='Paul', person_id=2)\n                    self.name____Paul = person\n                    self.person_id____2 = person\n        \"\"\"\n        if \"subclass\" in class_data:\n            for subclass_data in class_data[\"subclass\"]:\n                self.repr_class_data(subclass_data)\n        self.repr_def_class(class_data)\n        self.repr_setattr(class_data)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreads the config file from CONFIG_PATH and set the global variable api_key and api_secret", "response": "def read_config():\n    \"\"\"Read the config from CONFIG_PATH(Default: ~/.grabflickr.conf)\n    This will prompt for API key and secret if it not exists.\n    After, it sets the global variable `api_key` and `api_secret`.\n    \"\"\"\n    parser = SafeConfigParser()\n    parser.read(CONFIG_PATH)\n    if not parser.has_section('flickr'):\n        logger.info('Seems you don\\'t set API key, please enter the following informations: ')\n        enter_api_key(parser)\n    global api_key, api_secret\n    api_key = parser.get('flickr', 'API_KEY')\n    api_secret = parser.get('flickr', 'API_SECRET')"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nprompts for API key and secret then write them to CONFIG_PATH", "response": "def enter_api_key(parser=None):\n    \"\"\"Prompt for API key and secret\n    Then write them to CONFIG_PATH(Default: ~/.grabflickr.conf)\n\n    :param parser: Config parser\n    :type parser: SafeConfigParser\n    \"\"\"\n    if parser is None:\n        parser = SafeConfigParser()\n    parser.add_section('flickr')\n    global api_key, api_secret\n    api_key = raw_input('Enter your API key: ')\n    api_secret = raw_input('Enter your API secret: ')\n    parser.set('flickr', 'API_KEY', api_key)\n    parser.set('flickr', 'API_SECRET', api_secret)\n    with open(CONFIG_PATH, 'wb') as f:\n        parser.write(f)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nuse method and kwargs to produce a flickr API arguments.", "response": "def _get_request_args(method, **kwargs):\n    \"\"\"Use `method` and other settings to produce a flickr API arguments.\n    Here also use json as the return type.\n\n    :param method: The method provided by flickr,\n            ex: flickr.photosets.getPhotos\n    :type method: str\n    :param kwargs: Other settings\n    :type kwargs: dict\n    :return: An argument list used for post request\n    :rtype: list of sets\n    \"\"\"\n    args = [\n        ('api_key', api_key),\n        ('format', 'json'),\n        ('method', method),\n        ('nojsoncallback', '1'),\n    ]\n    if kwargs:\n        for key, value in kwargs.iteritems():\n            args.append((key, value))\n    args.sort(key=lambda tup: tup[0])\n    api_sig = _get_api_sig(args)\n    args.append(api_sig)\n    return args"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create_dir(path):\n    if os.path.exists(path):\n        if not os.path.isdir(path):\n            logger.error('%s is not a directory', path)\n            sys.exit(1)\n        else:  # ignore\n            pass\n    else:\n        os.makedirs(path)\n        logger.info('Create dir: %s', path)", "response": "Create the path\nAttributeNames."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_photos_info(photoset_id):\n    args = _get_request_args(\n        'flickr.photosets.getPhotos',\n        photoset_id=photoset_id\n    )\n    resp = requests.post(API_URL, data=args)\n    resp_json = json.loads(resp.text.encode('utf-8'))\n    logger.debug(resp_json)\n    photos = resp_json['photoset']['photo']\n    return photos", "response": "Request the photos information with the photoset id\n   "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nrequest the photo download url with the photo id", "response": "def get_photo_url(photo_id):\n    \"\"\"Request the photo download url with the photo id\n    :param photo_id: The photo id of flickr\n    :type photo_id: str\n    :return: Photo download url\n    :rtype: str\n    \"\"\"\n    args = _get_request_args(\n        'flickr.photos.getSizes',\n        photo_id=photo_id\n    )\n    resp = requests.post(API_URL, data=args)\n    resp_json = json.loads(resp.text.encode('utf-8'))\n    logger.debug(json.dumps(resp_json, indent=2))\n    size_list = resp_json['sizes']['size']\n    size_list_len = len(size_list)\n    global image_size_mode\n    image_size_mode = size_list_len if size_list_len < image_size_mode \\\n        else image_size_mode\n    download_url = resp_json['sizes']['size'][-image_size_mode]['source']\n    return download_url"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndownloading a photo to the path", "response": "def download_photo_async(photo):\n    \"\"\"Download a photo to the the path(global varialbe `directory`)\n\n    :param photo: The photo information include id and title\n    :type photo: dict\n    \"\"\"\n    photo_id = photo['id']\n    photo_title = photo['title']\n    download_url = get_photo_url(photo_id)\n    photo_format = download_url.split('.')[-1]\n    photo_title = photo_title + '.' + photo_format\n    file_path = directory + os.sep + photo_title\n    logger.info('Download %s...', photo_title.encode('utf-8'))\n    req = [grequests.get(download_url)]\n    counter_lock = multiprocessing.Lock()\n    for resp in grequests.map(req):\n        with open(file_path, 'w') as f:\n            f.write(resp.content)\n            with counter_lock:\n                global counter\n                counter -= 1\n        logger.info(\n            'The number of pictures remaining: %s', counter\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef single_download_photos(photos):\n    global counter\n    counter = len(photos)\n    for photo in photos:\n        download_photo(photo)", "response": "Use single process to download photos in the\n   "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nuse asynchronous I / O to download photos", "response": "def event_download_photos(photos):\n    \"\"\"Use asynchronous I/O to download photos\n\n    :param photos: The photos to be downloaded\n    :type photos: list of dicts\n    \"\"\"\n    try:\n        assert gevent\n        assert grequests\n    except NameError:\n        logger.error('You need install gevent module. Aborting...')\n        sys.exit(1)\n    global counter\n    counter = len(photos)\n    from gevent.pool import Pool\n    pool = Pool(multiprocessing.cpu_count())\n    jobs = [pool.spawn(download_photo_async, photo) for photo in photos]\n    pool.join()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef multithread_download_photos(photos):\n    from concurrent import futures\n    global counter\n    counter = len(photos)\n    cpu_num = multiprocessing.cpu_count()\n    with futures.ThreadPoolExecutor(max_workers=cpu_num) as executor:\n        for photo in photos:\n            executor.submit(download_photo, photo)", "response": "Use multiple threads to download photos in a\n   "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ninitialize the logger and set its format", "response": "def init_logger():\n    \"\"\"Initialize the logger and set its format\n    \"\"\"\n    formatter = logging.Formatter('%(levelname)s: %(message)s')\n    console = logging.StreamHandler(stream=sys.stdout)\n    console.setLevel(logging.INFO)\n    console.setFormatter(formatter)\n    logger.addHandler(console)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nparse the arguments from the CLI using ArgumentParser", "response": "def _parse_cli_args():\n    \"\"\"Parse the arguments from CLI using ArgumentParser\n    :return: The arguments parsed by ArgumentParser\n    :rtype: Namespace\n    \"\"\"\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\n        '-g',\n        help='The photoset id to be downloaded',\n        metavar='<photoset_id>'\n    )\n    parser.add_argument(\n        '-s',\n        default=1,\n        help=(\n            'Image size. 12 is smallest, 1 is original size. '\n            'Default: 1'\n        ),\n        type=int,\n        choices=xrange(0, 10),\n        metavar='<num>'\n    )\n    parser.add_argument(\n        '-d',\n        default=None,\n        help=(\n            'The path to store the downloaded images. '\n            'Automatically create it if not exist. '\n            'Default use the photoset id as folder name under current path'\n        ),\n        metavar='<path>'\n    )\n    parser.add_argument(\n        '-O',\n        default=1,\n        help=(\n            '0 for single process, '\n            '1 for multithread. '\n            '2 for event driven. '\n            'Default: 1'\n        ),\n        type=int,\n        choices=xrange(0, 3),\n        metavar='<num>'\n    )\n    parser.add_argument(\n        '-u',\n        help=(\n            'Set your API key'\n        ),\n        action='store_true'\n    )\n    args = parser.parse_args()\n    logger.debug(args)\n    return args"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _gevent_patch():\n    try:\n        assert gevent\n        assert grequests\n    except NameError:\n        logger.warn('gevent not exist, fallback to multiprocess...')\n        return MULTITHREAD\n    else:\n        monkey.patch_all()  # Must patch before get_photos_info\n        return GEVENT", "response": "Patch the modules with gevent."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef main():\n\n    init_logger()\n    args = _parse_cli_args()\n\n    if args.u:\n        enter_api_key()\n        return\n\n    if args.O == GEVENT:\n        args.O = _gevent_patch()\n\n    set_image_size_mode(args.s)\n    photoset_id = args.g\n    global directory\n    directory = args.d if args.d else photoset_id\n\n    read_config()\n    photos = get_photos_info(photoset_id)\n    create_dir(directory)\n\n    if args.O == SINGLE_PROCESS:\n        single_download_photos(photos)\n    elif args.O == GEVENT:\n        event_download_photos(photos)\n    elif args.O == MULTITHREAD:\n        multithread_download_photos(photos)\n    else:\n        logger.error('Unknown Error')", "response": "The main procedure for the base class."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning true if char is a punctuation mark in a CJK language.", "response": "def is_cjk_punctuation(char):\n    \"\"\"Returns true if char is a punctuation mark in a CJK language.\"\"\"\n    lower = int('0x3000', 16)\n    higher = int('0x300F', 16)\n    return ord(char) >= lower and ord(char) <= higher"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef parser_factory(lang):\n\n    class_ = {\n            'zh-Hans' : ChineseSimplifiedParser,\n            'zh-Hant' : ChineseTraditionalParser,\n            'zh' : ChineseParser,\n            'yue-Hans' : CantoneseSimplifiedParser,\n            'yue-Hant' : CantoneseTraditionalParser,\n            'yue' : CantoneseParser,\n            'thai' : ThaiParser,\n            'th' : ThaiParser,\n            }.get(lang)\n    return class_()", "response": "Returns a Parser object specific to the language specified by lang."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a list of words created from segmenting string.", "response": "def parse(self, string, all_combos=False):\n        \"\"\"Returns a list of words created from segmenting :arg:`string`.\n\n        ..note:  When a series of characters could match a shorter dictionary entry or\n        longer entry, the longer one is always selected.\n        \"\"\"\n        if not all_combos:\n            return self.default_parse(string)\n        else:\n            return self.all_combinations(string)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a list of words created from segmenting string.", "response": "def default_parse(self, string):\n        \"\"\"Returns a list of words created from segmenting :arg:`string`.\n\n        ..note:  When a series of characters could match a shorter dictionary entry or\n        longer entry, the longer one is always selected.\n        \"\"\"\n        results = list()\n        while(string):\n            token = self.longest(string)\n            results.append(token)\n            string = string[len(token):]\n        return results"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef force_populate(self):\n        if not os.path.exists(self.ref):\n            raise FileNotFoundError(\"The reference file path '{}' does not exists.\".format(self.ref))\n        with open(self.ref, 'r') as f:\n            for word in f:\n                word = word.strip('\\n')\n                self.db.add(word)\n        self.populated = True", "response": "Populates the parser with the entire contents of the the\nTaxonomy word reference file."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef leveled(self):\n        \n        # Compatibility support for Django<1.6\n        safe_get_queryset = (self.get_query_set if hasattr(self, 'get_query_set') else self.get_queryset)\n        \n        return safe_get_queryset.exclude(level=0)", "response": "Return all countries with a level set"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\npush the current working directory onto a stack and returns it.", "response": "def pushd(dir=None, throw_if_dir_invalid=True):\n    \"\"\"Push the current working directory (CWD) onto a stack, set CWD to 'dir'\n\n    Save the CWD onto a global stack so that we can return to it later. If dir\n    is None, the function simply stores the CWD onto the stack and returns.\n    Use :py:meth:`popd()` to restore the original directory.\n\n    Parameters\n    ----------\n        dir : str, optional\n            The directory to switch to or None. If None, the default if it\n            is not passed, this function will simply push the current working\n            directory onto the global stack and return.\n        throw_if_dir_invalid : bool, optional\n            Whether or not to pass back up any exception raised by chdir().\n            Default is True.\n\n    Returns\n    -------\n        True : bool\n            Success\n        False : bool\n            Failure\n\n    Raises\n    ------\n        OSError\n            If `throw_if_dir_invalid` is True and chdir raises an exception,\n            this function will chain the same exception as chdir, typically \n            OSError\n\n        TypeError\n            If the type of ``dir`` is not an instance of `str`\n\n    Notes\n    -----\n    This method and its counterpart :py:meth:`popd` are `not` thread safe!\n    \"\"\"\n    global _pushdstack\n    from os import getcwd, chdir\n\n    if dir is None:\n        dir = getcwd()\n\n    if not isinstance(dir,type('')):\n        raise TypeError(\"pushd() expected string object, but got {}\".format(type(dir)))\n\n    _pushdstack.append(getcwd())\n    \n    if not dir:\n        return\n\n    try:\n        chdir(dir)\n        err = 0\n    except OSError:\n        _pushdstack.pop()\n        if throw_if_dir_invalid:\n            raise\n        err = 1\n\n    return True if err == 0 else False"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef popd(pop_all=False, throw_if_dir_invalid=True):\n    global _pushdstack\n    from os import chdir\n\n    if len(_pushdstack) == 0:\n        raise ValueError(\"popd() called on an empty stack.\")\n\n    if pop_all:\n        while( len(_pushdstack) > 1):\n            _pushdstack.pop()\n\n    try:\n        chdir(_pushdstack.pop())\n        err = 0\n    except OSError:\n        if throw_if_dir_invalid:\n            raise\n        err = 1\n\n    return err == 0", "response": "Restores the current working directory to the previous directory."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef pyVersionStr(self):\n        from sys import version_info\n\n        return \"Python Interpreter Version: {}.{}.{}\".format(version_info.major,\n                                                             version_info.minor,\n                                                             version_info.micro)", "response": "Returns a string containing the version of Python running the current script."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a tuple containing all elements of the object.", "response": "def all(self):\n        \"\"\"Returns a tuple containing all elements of the object\n\n        This method returns all elements of the path in the form of a tuple.\n         e.g.: `(abs_path, drive_letter, path_only, rootname, extension, \n         filesize, time_in_seconds)`.\n\n        Returns\n        -------\n        tuple\n            All elements of the path associated with this object as a tuple.\n\n        Notes\n        -----\n        If path points to a non-existant file, the size and datetime will\n        be returned as None (NoneType).\n        \"\"\"\n\n        return (self._full, self._driv, self._path, self._name, self._ext, self._size, self._time)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef format(self, fmt):\n\n        val = ''\n        for x in fmt:\n            if x == 'd':\n                val += self._driv\n\n            elif x == 'p':\n                val += self._path\n\n            elif x == 'n':\n                val += self._name\n\n            elif x == 'x':\n                val += self._ext\n\n            elif x == 'z':\n                if self._size != None: val += str(self._size)\n\n            elif x == 't':\n                if self._time != None: val += str(self._time)\n\n        return val", "response": "Returns the string representing the items specified in the format string fmt."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncalls from form_valid. @form: it is form of form_valid (type: form) @field: name of the form field referring to the brigde (type: string) @model: form's model (type class) @related_field: name of the related_name of the brigde (type: string) @error_message: list of message errors (type list) two items, example: [\"The selected entry is already a storage, select another entry!\", \"The selected entry is not available anymore, please, try again!\"]", "response": "def form_valid_bridge(self, form, field, model, related_field, error_message):\n        \"\"\"\n        call from form_valid.\n        @form: it is form of form_valid (type: form)\n        @field: name of the form field referring to the brigde (type: string)\n        @model: form's model (type class)\n        @related_field: name of the related_name of the brigde (type: string)\n        @error_message: list of message errors (type list)\n            two items, example:\n            [\"The selected entry is already a storage, select another entry!\",\n            \"The selected entry is not available anymore, please, try again!\"]\n        \"\"\"\n        # get instance of selected external object\n        external = form.cleaned_data[field]\n        related_object = get_external_model(model).objects.filter(pk=external.pk).first()\n        if related_object:\n            # form valid\n            try:\n                with transaction.atomic():\n                    result = super(GenCreateBridge, self).form_valid(form)\n                    if get_external_model(model).objects.filter(**{\n                            \"pk\": external.pk,\n                            \"{}__isnull\".format(related_field): False\n                            }).exists():\n                        errors = form._errors.setdefault(field, ErrorList())\n                        errors.append(error_message[0])\n                        raise CodenerixException()\n                    else:\n                        setattr(related_object, related_field, form.instance)\n                        related_object.save()\n                        if hasattr(self.object, 'CDNX_refresh_permissions_CDNX'):\n                            self.object.CDNX_refresh_permissions_CDNX()\n                # Return the object already saved properly\n                answer = HttpResponseRedirect(self.get_success_url())\n            except CodenerixException:\n                answer = super(GenCreateBridge, self).form_invalid(form)\n            except IOError as e:\n                errors = form._errors.setdefault(\"codenerix_external_field\", ErrorList())\n                errors.append(e)\n                answer = super(GenCreateBridge, self).form_invalid(form)\n        else:\n            errors = form._errors.setdefault(field, ErrorList())\n            errors.append(error_message[1])\n            answer = super(GenCreateBridge, self).form_invalid(form)\n\n        # Return\n        return answer"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef form_valid_bridge(self, form, field, model, related_field, error_message):\n        # get instance of selected external object\n        external = form.cleaned_data[field]\n        object_edit = model.objects.get(pk=form.instance.pk)\n        if object_edit.external == external:\n            answer = super(GenUpdateBridge, self).form_valid(form)\n        else:\n            related_object = get_external_model(model).objects.filter(**{\n                \"pk\": external.pk,\n                \"{}__isnull\".format(related_field): False\n            }).exclude(**{\n                \"{}\".format(related_field): form.instance,\n            }).first()\n            if not related_object:\n                # form valid\n                try:\n                    with transaction.atomic():\n                        result = super(GenUpdateBridge, self).form_valid(form)\n                        field = object_edit.external\n                        setattr(field, related_field, None)\n                        field.save()\n                        setattr(external, related_field, form.instance)\n                        external.save()\n                    # Return success url\n                    answer = HttpResponseRedirect(self.get_success_url())\n                except CodenerixException:\n                    answer = super(GenUpdateBridge, self).form_invalid(form)\n            else:\n                errors = form._errors.setdefault(field, ErrorList())\n                errors.append(error_message[0])\n                answer = super(GenUpdateBridge, self).form_invalid(form)\n\n        # Return result\n        return answer", "response": "call from form_valid.\n        @form: it is form of form_valid (type: form)\n        @field: name of the form field referring to the brigde (type: string)\n        @model: form's model (type class)\n        @related_field: name of the related_name of the brigde (type: string)\n        @error_message: list of message errors (type list)\n            one item, example:\n            [\"The selected entry is not available anymore, please, try again!\", ]"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_cell_type(cell):\n    '''\n    Returns a type to be used in table cell analysis. This is either\n    'basestring' or '(int, float)'.\n    '''\n    cell_type = None\n    if isinstance(cell, basestring) and cell:\n        cell_type = basestring\n    elif isinstance(cell, (int, float)):\n        cell_type = (int, float)\n\n    return cell_type", "response": "Returns a type to be used in table cell analysis. This is either\n    basestring or int or float."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef check_cell_type(cell, cell_type):\n    '''\n    Checks the cell type to see if it represents the cell_type passed in.\n\n    Args:\n        cell_type: The type id for a cell match or None for empty match.\n    '''\n    if cell_type == None or cell_type == type(None):\n        return cell == None or (isinstance(cell, basestring) and not cell)\n    else:\n        return isinstance(cell, cell_type)", "response": "Checks the cell type to see if it represents the cell_type passed in."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nperforms a first step conversion of the cell to check it's type or try to convert if a valid conversion exists. This version of conversion doesn't flag changes nor store cell units. Args: units: The dictionary holder for cell units. parens_as_neg: Converts numerics surrounded by parens to negative values", "response": "def auto_convert_cell_no_flags(cell, units=None, parens_as_neg=True):\n    '''\n    Performs a first step conversion of the cell to check\n    it's type or try to convert if a valid conversion exists.\n    This version of conversion doesn't flag changes nor store\n    cell units.\n\n    Args:\n        units: The dictionary holder for cell units.\n        parens_as_neg: Converts numerics surrounded by parens to\n            negative values\n    '''\n    units = units if units != None else {}\n    return auto_convert_cell(flagable=Flagable(), cell=cell, position=None, worksheet=0,\n                             flags={}, units=units, parens_as_neg=parens_as_neg)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef auto_convert_cell(flagable, cell, position, worksheet, flags, units, parens_as_neg=True):\n    '''\n    Performs a first step conversion of the cell to check\n    it's type or try to convert if a valid conversion exists.\n\n    Args:\n        parens_as_neg: Converts numerics surrounded by parens to negative values\n    '''\n    conversion = cell\n\n    # Is an numeric?\n    if isinstance(cell, (int, float)):\n        pass\n    # Is a string?\n    elif isinstance(cell, basestring):\n        # Blank cell?\n        if not cell:\n            conversion = None\n        else:\n            conversion = auto_convert_string_cell(flagable, cell, position, worksheet,\n                                                  flags, units, parens_as_neg=parens_as_neg)\n    # Is something else?? Convert to string\n    elif cell != None:\n        # Since we shouldn't get this event from most file types,\n        # make this a warning level conversion flag\n        flagable.flag_change(flags, 'warning', position, worksheet,\n                             flagable.FLAGS['unknown-to-string'])\n        conversion = str(cell)\n        # Empty cell?\n        if not conversion:\n            conversion = None\n    else:\n        # Otherwise we have an empty cell\n        pass\n\n    return conversion", "response": "A function that converts a cell to check\n    if a valid conversion exists."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef auto_convert_string_cell(flagable, cell_str, position, worksheet, flags,\n                             units, parens_as_neg=True):\n    '''\n    Handles the string case of cell and attempts auto-conversion\n    for auto_convert_cell.\n\n    Args:\n        parens_as_neg: Converts numerics surrounded by parens to negative values\n    '''\n    conversion = cell_str.strip()\n\n    # Wrapped?\n    if re.search(allregex.control_wrapping_regex, cell_str):\n        # Drop the wrapping characters\n        stripped_cell = cell_str.strip()\n        mod_cell_str = stripped_cell[1:][:-1].strip()\n        neg_mult = False\n        # If the wrapping characters are '(' and ')' and the interior is a number,\n        # then the number should be interpreted as a negative value\n        if (stripped_cell[0] == '(' and stripped_cell[-1] == ')' and\n                re.search(allregex.contains_numerical_regex, mod_cell_str)):\n            # Flag for conversion to negative\n            neg_mult = True\n        flagable.flag_change(flags, 'interpreted', position, worksheet,\n                            flagable.FLAGS['removed-wrapping'])\n        # Try again without wrapping\n        converted_value = auto_convert_cell(flagable, mod_cell_str, position,\n                                            worksheet, flags, units)\n        neg_mult = neg_mult and check_cell_type(converted_value, get_cell_type(0))\n        if neg_mult and parens_as_neg:\n            flagable.flag_change(flags, 'interpreted', position, worksheet,\n                                 flagable.FLAGS['converted-wrapping-to-neg'])\n        return -converted_value if neg_mult else converted_value\n    # Is a string containing numbers?\n    elif re.search(allregex.contains_numerical_regex, cell_str):\n        conversion = auto_convert_numeric_string_cell(flagable, conversion, position,\n                                                      worksheet, flags, units)\n    elif re.search(allregex.bool_regex, cell_str):\n        flagable.flag_change(flags, 'interpreted', position, worksheet,\n                             flagable.FLAGS['bool-to-int'])\n        conversion = 1 if re.search(allregex.true_bool_regex, cell_str) else 0\n\n    return conversion", "response": "Handles the string case of a cell and attempts to convert it to the correct value."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef auto_convert_numeric_string_cell(flagable, cell_str, position, worksheet, flags, units):\n    '''\n    Handles the string containing numeric case of cell and attempts\n    auto-conversion for auto_convert_cell.\n    '''\n    def numerify_str(cell_str, flag_level='minor', flag_text=\"\"):\n        '''\n        Differentiates between int and float strings. Expects a numeric string.\n        '''\n        if re.search(allregex.integer_regex, cell_str):\n            flagable.flag_change(flags, flag_level, position, worksheet)\n            return int(cell_str)\n        else:\n            flagable.flag_change(flags, flag_level, worksheet, position)\n            return float(cell_str)\n    def numerify_percentage_str(cell_str, flag_level='minor', flag_text=\"\"):\n        flagable.flag_change(flags, flag_level, position, worksheet)\n        return float(cell_str) / 100\n\n    def convert_to_int_or_float(cell_str, flag_level='minor', flag_text=\"\"):\n        if not cell_str:\n            conversion = 0\n            flagable.flag_change(flags, 'warning', position, worksheet,\n                                 flagable.FLAGS['empty-to-zero-string'])\n        if re.search(allregex.numerical_regex, cell_str):\n            conversion = numerify_str(cell_str, flag_level, flag_text)\n        # Comma separated?\n        elif re.search(allregex.comma_sep_numerical_regex, cell_str):\n            smashed_cell = ''.join(cell_str.split(','))\n            conversion = numerify_str(smashed_cell, flag_level, flag_text)\n        # Ends in percentage sign\n        elif re.search(allregex.percent_numerical_regex, cell_str):\n            cell_str = allregex.percent_numerical_regex.search(cell_str).group(1)\n            conversion = numerify_percentage_str(cell_str, flag_level, flag_text)\n        # Ends in + or - sign (estimate)?\n        elif re.search(allregex.estimate_numerical_regex, cell_str):\n\n            cell_str = cell_str[:-1].replace(\",\",\"\")\n            conversion = numerify_str(cell_str, flag_level, flag_text)\n        # Begins with money symbol?\n        elif re.search(allregex.begins_with_monetary_symbol_regex, cell_str):\n            symbol = cell_str[0]\n            cell_str = cell_str[1:]\n            try:\n                conversion = convert_to_int_or_float(cell_str, 'interpreted',\n                        flagable.FLAGS['monetary-removal'])\n                if re.search(allregex.contains_dollar_symbol_regex, symbol):\n                    units[position] = UNITS_DOLLAR\n                elif re.search(allregex.contains_pound_symbol_regex, symbol):\n                    units[position] = UNITS_POUND\n                elif re.search(allregex.contains_euro_symbol_regex, symbol):\n                    units[position] = UNITS_EURO\n            except ValueError:\n                conversion = cell_str\n                flagable.flag_change(flags, 'warning', position, worksheet,\n                                    flagable.FLAGS['failed-monetary-convert'])\n        # Number ending in 'k'?\n        elif re.search(allregex.ends_with_thousands_scaling_regex, cell_str):\n            cell_str = cell_str.rstrip()[:-1]\n            try:\n                conversion = 1000*convert_to_int_or_float(cell_str, 'interpreted',\n                                  flagable.FLAGS['thousands-convert'])\n            except ValueError:\n                flagable.flag_change(flags, 'warning', position, worksheet,\n                                    flagable.FLAGS['failed-thousands-convert'])\n        # Number ending in 'M' or 'MM'?\n        elif re.search(allregex.ends_with_millions_scaling_regex, cell_str):\n            if cell_str[-2] == \"M\":\n                cell_str = cell_str[:-2]\n            else:\n                cell_str = cell_str[:-1]\n            try:\n                conversion = 1000000*convert_to_int_or_float(cell_str, 'interpreted',\n                        flagable.FLAGS['millions-convert'])\n            except ValueError:\n                flagable.flag_change(flags, 'warning', position, worksheet,\n                                     flagable.FLAGS['failed-millions-convert'])\n        else:\n            raise ValueError(\"Cannot convert cell\")\n        return conversion\n\n\n    # Try converting\n    try:\n        return convert_to_int_or_float(cell_str)\n    # Couldn't convert?\n    except ValueError:\n        flagable.flag_change(flags, 'minor', position, worksheet,\n                             flagable.FLAGS['failed-convert-numeric-string'])\n        return cell_str", "response": "Auto - converts a string containing numeric case of cell and attempts to convert it to int or float."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set(self, field, value):\n        if field == 'uuid':\n            raise ValueError('uuid cannot be set')\n        elif field == 'key':\n            raise ValueError(\n                'key cannot be set. Use \\'reset_key\\' method')\n        else:\n            self.data[field] = value", "response": "Sets the value of an immutable app field."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreset the app s key on the unicore. hub server.", "response": "def reset_key(self):\n        \"\"\"\n        Resets the app's key on the `unicore.hub` server.\n\n        :returns: str -- the new key\n        \"\"\"\n        new_key = self.client.reset_app_key(self.get('uuid'))\n        self.data['key'] = new_key\n        return new_key"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef trip_name_to_directory_name(name):\n    out = name.lower()\n    out = re.sub('[:/\\ ]', '-', out)\n    out = re.sub('[.,]', '', out)\n    out = re.sub('--+', '-', out)\n    out = out[:30]\n    return out", "response": "Convert a name like Mt. Tam Ridgecrest Blvd to Alpine Lake via... to\n    something like mt - tam - ridgecrest - blvd - to - alpi."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef raise_exception(self, original_exception=None):\n        if self._executed_retries < self._max_retries:\n            curr_backoff = self._ms_backoff\n            self._executed_retries += 1\n            self._ms_backoff = self._ms_backoff * 2\n            raise ActionRetryException(curr_backoff)\n        else:\n            raise original_exception or Exception()", "response": "Raise an exception if under the max retries. After raise the original_exception or a generic Exception."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreads the. skipfile file and returns a list of the names of the files that should be skipped by the user.", "response": "def read_skipfile(dirname='.', defaults=None):\n    \"\"\"The .skipfile should contain one entry per line,\n       listing files/directories that should be skipped by\n       :func:`list_files`.\n    \"\"\"\n    if defaults is None:\n        defaults = ['Makefile', 'make.bat', 'atlassian-ide-plugin.xml']\n    try:\n        return defaults + open(\n            os.path.join(dirname, SKIPFILE_NAME)\n        ).read().splitlines()\n    except IOError:\n        return defaults"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nyields all interesting files in a directory.", "response": "def list_files(dirname='.', digest=True):\n    \"\"\"Yield (digest, fname) tuples for all interesting files\n       in `dirname`.\n    \"\"\"\n    skipdirs = ['__pycache__', '.git', '.svn', 'htmlcov', 'dist', 'build',\n                '.idea', 'tasks', 'static', 'media', 'data', 'migrations',\n                '.doctrees', '_static', 'node_modules', 'external',\n                'jobs', 'tryout', 'tmp', '_coverage',\n               ]\n    skipexts = ['.pyc', '~', '.svg', '.txt', '.TTF', '.tmp', '.errmail',\n                '.email', '.bat', '.dll', '.exe', '.Dll', '.jpg', '.gif',\n                '.png', '.ico', '.db', '.md5']\n    dirname = str(dirname)\n    skipfiles = read_skipfile(dirname)\n\n    def clean_dirs(directories):\n        \"\"\"Remove directories that should be skipped.\n        \"\"\"\n        for d in directories:\n            if d.endswith('.egg-info'):\n                directories.remove(d)\n        for d in skipdirs:\n            if d in directories:\n                directories.remove(d)\n\n    def keep_file(filename, filepath):\n        \"\"\"Returns False if the file should be skipped.\n        \"\"\"\n        if filename.startswith('.'):\n            return False\n        if filepath in skipfiles:\n            return False\n        for ext in skipexts:\n            if filename.endswith(ext):\n                return False\n        return True\n\n    for root, dirs, files in os.walk(os.path.abspath(dirname)):\n        clean_dirs(dirs)\n        for fname in files:\n            relpth = os.path.relpath(\n                os.path.join(root, fname),\n                dirname\n            ).replace('\\\\', '/')\n\n            parts = Path(relpth).parts()\n            if not keep_file(fname, relpth) or \\\n                    any(p.startswith('.') for p in parts):\n                continue\n\n            pth = os.path.join(dirname, relpth)\n            if digest:\n                yield md5(open(pth, 'rb').read()).hexdigest(), relpth\n            else:\n                yield relpth"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef main():  # pragma: nocover\n    p = argparse.ArgumentParser(add_help=\"Recursively list interesting files.\")\n    p.add_argument(\n        'directory', nargs=\"?\", default=\"\",\n        help=\"The directory to process (current dir if omitted).\"\n    )\n    p.add_argument(\n        '--verbose', '-v', action='store_true',\n        help=\"Increase verbosity.\"\n    )\n\n    args = p.parse_args()\n    args.curdir = os.getcwd()\n    if not args.directory:\n        args.direcotry = args.curdir\n    if args.verbose:\n        print(args)\n\n    for chsm, fname in list_files(args.directory):\n        print(chsm, fname)", "response": "Print checksum and file name for all files in the directory."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef process_exists(pid=None):\n    if not pid:\n        pid = current_pid()\n    elif callable(pid):\n        pid = pid()\n\n    if pid and psutil.pid_exists(pid):\n        pname = psutil.Process(pid).name()\n        if os.name == 'nt':\n            return os.path.splitext(pname)[0], pid\n        return pname, pid\n    return None, None", "response": "Evaluate a Pid Value returns the process name and pid if it exists returns None None"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef move_active_window(x, y):\n    window_id = get_window_id()\n    cmd=['xdotool','windowmove', window_id, str(x), str(y)]\n    subprocess.Popen(cmd, stdout = subprocess.PIPE, stderr= subprocess.PIPE).communicate()", "response": "Moves the active window to a given position given the window_id and absolute co ordinates"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the current position of the active window", "response": "def get_active_window_pos():\n    '''screen coordinates massaged so that movewindow command works to\n    restore the window to the same position\n    returns x, y\n    '''\n    # http://stackoverflow.com/questions/26050788/in-bash-on-ubuntu-14-04-unity-how-can-i-get-the-total-size-of-an-open-window-i/26060527#26060527\n    cmd = ['xdotool','getactivewindow', 'getwindowgeometry']\n    res = subprocess.Popen(cmd, stdout = subprocess.PIPE, stderr= subprocess.PIPE).communicate()\n    stdout = res[0].decode('utf-8').splitlines()\n    pos = stdout[1].split(':')[1].split(',')\n    geo = stdout[2].split(':')[1].split('x')\n    x, y = int(pos[0].strip()), int(pos[1].split('(')[0].strip())\n    w, h = int(geo[0].strip()), int(geo[1].strip())\n\n    # get the window decorations\n    window_id = get_window_id()\n    cmd = ['xprop', '_NET_FRAME_EXTENTS', '-id', window_id]\n    res = subprocess.Popen(cmd, stdout = subprocess.PIPE, stderr= subprocess.PIPE).communicate()\n    decos = res[0].decode('utf-8').split('=')[1].split(',')\n    l, r = int(decos[0].strip()), int(decos[1].strip())\n    t, b = int(decos[2].strip()), int(decos[3].strip())\n\n    return x-l, y-t"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nlist all processes in the system.", "response": "def listpid(toggle='basic'): # Add method to exclude elements from list\n    '''list pids'''\n    proc=psutil.process_iter()# evalute if its better to keep one instance of this or generate here?\n    if toggle=='basic':\n        host=gethostname()\n        host2=os.getenv('HOME').split(sep='/'   )[-1]\n        for row in proc:\n            #~ DPRINT([row.ppid(),row.name(),host],'username,row.name,host')\n            if row.username() in host or row.username() in host2:   #new psutil using grabing timeyyy and not alfa for username so host 2 is getting the timeyyy on UBUNTU  \n                yield row.name(), row.ppid()\n    elif toggle=='all':\n        for row in proc:\n            \n            yield row.name(), row.ppid()\n    elif toggle =='windows-basic':\n        for row in proc:\n            try:\n                pname = psutil.Process(row.pid).name()\n                pname = pname[:-4]#removiing .exe from end\n                yield pname, row.pid\n            except:\n                pass"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the window title of the active window", "response": "def get_active_title():\n    '''returns the window title of the active window'''\n    if os.name == 'posix':\n        cmd = ['xdotool','getactivewindow','getwindowname']\n        proc = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n        title = proc.communicate()[0].decode('utf-8')\n    else:\n        raise NotImplementedError\n    return title"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn process names owned by the user", "response": "def get_processes():\n    '''returns process names owned by the user'''\n    user = getpass.getuser()\n    for proc in  psutil.process_iter():\n        if proc.username() != user:\n            continue\n        pname = psutil.Process(proc.pid).name()\n        if os.name == 'nt':\n            pname = pname[:-4]          # removiing .exe from end\n        yield pname"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn titles of all open windows", "response": "def get_titles():\n    '''returns titles of all open windows'''\n    if os.name == 'posix':\n        for proc in get_processes():\n            cmd = ['xdotool','search','--name', proc]\n            proc = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            window_ids = proc.communicate()[0].decode('utf-8')\n            if window_ids:\n                for window_id in window_ids.split('\\n'):\n                    cmd = ['xdotool','getwindowname',window_id]\n                    proc = subprocess.Popen(cmd,\n                                        stdout=subprocess.PIPE,\n                                        stderr=subprocess.PIPE)\n                    title = proc.communicate()[0].decode('utf-8')\n                    try:\n                        if title[-1] == '\\n':\n                            title = title[:-1]\n                        yield title\n                    except IndexError:\n                        pass\n    else:\n        raise NotImplementedError"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_gcd(a, b):\n    \"Return greatest common divisor for a and b.\"\n    while a:\n        a, b = b % a, a\n    return b", "response": "Return greatest common divisor for a and b."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning an integer ratio tuple like ( 16 9 ).", "response": "def as_int(width, height):\n    \"Return an integer ratio tuple like (16, 9).\"\n    gcd = get_gcd(width, height)\n    return int(width / gcd), int(height / gcd)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef auto_tweet(sender, instance, *args, **kwargs):\n\n    if not twitter or getattr(settings, 'TWITTER_SETTINGS') is False:\n        #print 'WARNING: Twitter account not configured.'\n        return False\n\n    if not kwargs.get('created'):\n        return False\n\n    twitter_key = settings.TWITTER_SETTINGS\n\n    try:\n        api = twitter.Api(\n            consumer_key        = twitter_key['consumer_key'],\n            consumer_secret     = twitter_key['consumer_secret'],\n            access_token_key    = twitter_key['access_token_key'],\n            access_token_secret = twitter_key['access_token_secret']\n        )\n    except Exception as error:\n        print(\"failed to authenticate: {}\".format(error))\n\n    text = instance.text\n\n    if instance.link:\n        link = instance.link\n    else:\n        link = instance.get_absolute_url()\n\n    text = '{} {}'.format(text, link)\n\n    try:\n        api.PostUpdate(text)\n    except Exception as error:\n        print(\"Error posting to twitter: {}\".format(error))", "response": "Auto - tweeting of newly created object to twitter."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a Deferred that resolves with the entries for the given country and postal code.", "response": "def postalCodeLookup(self, countryCode, postalCode):\n        \"\"\"\n        Looks up locations for this country and postal code.\n        \"\"\"\n        params = {\"country\": countryCode, \"postalcode\": postalCode}\n        d = self._call(\"postalCodeLookupJSON\", params)\n        d.addCallback(operator.itemgetter(\"postalcodes\"))\n        return d"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nprinting txt by coding GBK.", "response": "def _print(*args):\n    \"\"\"\n        Print txt by coding GBK.\n\n        *args\n          list, list of printing contents\n        \n    \"\"\"\n    if not CFG.debug:\n        return\n    if not args:\n        return\n    encoding = 'gbk'\n    args = [_cs(a, encoding) for a in args]\n    f_back = None\n    try:\n        raise Exception\n    except:\n        f_back = sys.exc_traceback.tb_frame.f_back\n    f_name = f_back.f_code.co_name\n    filename = os.path.basename(f_back.f_code.co_filename)\n    m_name = os.path.splitext(filename)[0]\n    prefix = ('[%s.%s]'%(m_name, f_name)).ljust(20, ' ')\n    if os.name == 'nt':\n        for i in range(len(args)):\n            v = args [i]\n            if isinstance(v, str):\n                args[i] = v #v.decode('utf8').encode('gbk')\n            elif isinstance(v, unicode):\n                args[i] = v.encode('gbk')\n    print '[%s]'%str(datetime.datetime.now()), prefix, ' '.join(args)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _print_err(*args):\n    if not CFG.debug:\n        return\n    if not args:\n        return\n    encoding = 'utf8' if os.name == 'posix' else 'gbk'\n    args = [_cs(a, encoding) for a in args]\n    f_back = None\n    try:\n        raise Exception\n    except:\n        f_back = sys.exc_traceback.tb_frame.f_back\n    f_name = f_back.f_code.co_name\n    filename = os.path.basename(f_back.f_code.co_filename)\n    m_name = os.path.splitext(filename)[0]\n    prefix = ('[%s.%s]'%(m_name, f_name)).ljust(20, ' ')\n    print bcolors.FAIL+'[%s]'%str(datetime.datetime.now()), prefix, ' '.join(args) + bcolors.ENDC", "response": "Print the error message for the current locale."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef logprint(logname, category, level='INFO', backupCount=15):\n    path = os.path.join(CFG.dir, category.strip('/'), logname.strip('/') + '.log')\n    print \"log path:\", path\n    if not os.path.exists(path[:path.rindex('/')]):\n        os.makedirs(path[:path.rindex('/')])\n    # Initialize logger\n    logger = logging.getLogger(logname)\n    frt = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')\n\n    hdr = logging.StreamHandler(sys.stdout)\n    hdr.setFormatter(frt)\n    hdr._name = '##_sh_##'\n    if not hdr._name in CFG.exist:\n        logger.addHandler(hdr)\n        CFG.exist.append(hdr._name)\n\n    hdr = TimedRotatingFileHandler(path, 'D', 1, backupCount)\n    hdr.setFormatter(frt)\n    hdr._name = '##_rfh_##'\n    if not hdr._name in CFG.exist:\n        logger.addHandler(hdr)\n        CFG.exist.append(hdr._name)\n\n\n    if level.upper() == 'NOTEST':\n        level == logging.NOTSET\n    elif level.upper() == 'DEBUG':\n        level == logging.DEBUG\n    elif level.upper() == 'WARNING':\n        level == logging.WARNING\n    elif level.upper() == 'ERROR':\n        level == logging.ERROR\n    elif level.upper() == 'CRITICAL':\n        level == logging.CRITICAL\n    else:\n        level == logging.INFO\n    logger.setLevel(level)\n\n    def _wraper(*args, **kwargs):\n        if not CFG.debug:\n            return\n        if not args:\n            return\n            \n        for hdr in CFG.handlers:\n            if not hdr._name in CFG.exist:\n                logger.addHandler(hdr)\n                CFG.exist.append(hdr._name)\n\n        encoding = 'utf8' if os.name == 'posix' else 'gbk'\n        args = [_cu(a, encoding) for a in args]\n\n        prefix = ''\n\n        pl = kwargs.get('printlevel', 'info').upper()\n        if pl == 'DEBUG':\n            try:\n                logger.debug(*args, **kwargs)\n            except:\n                t, v, b = sys.exc_info()\n                err_messages = traceback.format_exception(t, v, b)\n                print 'Error: %s' % ','.join(err_messages)\n        elif pl == 'WARNING':\n            try:\n                logger.warning(*args, **kwargs)\n            except:\n                t, v, b = sys.exc_info()\n                err_messages = traceback.format_exception(t, v, b)\n                print 'Error: %s' % ','.join(err_messages)\n        elif pl == 'ERROR':\n            try:\n                logger.error(*args, **kwargs)\n            except:\n                t, v, b = sys.exc_info()\n                err_messages = traceback.format_exception(t, v, b)\n                print 'Error: %s' % ','.join(err_messages)\n        elif pl == 'CRITICAL':\n            try:\n                logger.critical(*args, **kwargs)\n            except:\n                t, v, b = sys.exc_info()\n                err_messages = traceback.format_exception(t, v, b)\n                print 'Error: %s' % ','.join(err_messages)\n        else:\n            try:\n                logger.info(*args, **kwargs)\n            except:\n                t, v, b = sys.exc_info()\n                err_messages = traceback.format_exception(t, v, b)\n                print 'Error: %s' % ','.join(err_messages)\n    return _wraper, logger", "response": "Print logs by datetime. logname category level level"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef fileprint(filename, category, level=logging.DEBUG, maxBytes=1024*10124*100,\n             backupCount=0):\n    \"\"\"\n        Print files by file size.\n\n        filename\n          string, file name\n        category\n          string, category path of logs file in log directory\n        level\n          enumerated type of logging module, restrict whether logs to be printed or not\n        maxBytes\n          int, max limit of file size\n        backupCount\n          int, allowed numbers of file copys\n        \n    \"\"\"\n    path = os.path.join(CFG.filedir, category, filename)\n\n    # Initialize filer\n    filer = logging.getLogger(filename)\n    frt = logging.Formatter('%(message)s')\n\n    hdr = RotatingFileHandler(path, 'a', maxBytes, backupCount, 'utf-8')\n    hdr.setFormatter(frt)\n    hdr._name = '##_rfh_##'\n    already_in = False\n    for _hdr in filer.handlers:\n        if _hdr._name == '##_rfh_##':\n            already_in = True\n            break\n    if not already_in:\n        filer.addHandler(hdr)\n\n    hdr = logging.StreamHandler(sys.stdout)\n    hdr.setFormatter(frt)\n    hdr._name = '##_sh_##'\n    already_in = False\n    for _hdr in filer.handlers:\n        if _hdr._name == '##_sh_##':\n            already_in = True\n    if not already_in:\n        filer.addHandler(hdr)\n\n    filer.setLevel(level)\n    def _wraper(*args):\n        if not args:\n            return\n        encoding = 'utf8' if os.name == 'posix' else 'gbk'\n        args = [_cu(a, encoding) for a in args]\n        filer.info(' '.join(args))\n    return _wraper, filer", "response": "Print a file by size."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef explain(code, signals=SIGNALS):\n    if code not in signals:\n        raise NoSuchSignal(code)\n    signal, action, description = signals[code]\n    return {\n        'id': code,\n        'signal': signal,\n        'action': action,\n        'description': description,\n        }", "response": "Return a dictionary of information about a given signal code."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef search(signal='', action='', signals=SIGNALS):\n    sig_re = re.compile(signal, re.IGNORECASE)\n    act_re = re.compile(action, re.IGNORECASE)\n    res = []\n    for code in signals:\n        sig, act, _ = signals[code]\n        if sig_re.match(sig) and act_re.match(act):\n            res.append(explain(code, signals=signals))\n    return res", "response": "Search the signals DB for signal named signal and which action matches action."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef pt_on_bezier_curve(P=[(0.0, 0.0)], t=0.5):\n    '''Return point at t on bezier curve defined by control points P.\n    '''\n    assert isinstance(P, list)\n    assert len(P) > 0\n    for p in P:\n        assert isinstance(p, tuple)\n        for i in p:\n            assert len(p) > 1\n            assert isinstance(i, float)\n    assert isinstance(t, float)\n    assert 0 <= t <= 1\n    \n    O = len(P) - 1 # Order of curve\n\n    # Recurse down the orders calculating the next set of control points until\n    #   there is only one left, which is the point we want.\n    Q = P\n    while O > 0:\n        Q = [pt_between_pts(Q[l], Q[l+1], t) for l in range(O)]\n        O -= 1\n    \n    assert len(Q) == 1\n    return Q[0]", "response": "Return point at t on bezier curve defined by control points P."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn list N + 1 points representing N line segments on bezier curve.", "response": "def pts_on_bezier_curve(P=[(0.0, 0.0)], n_seg=0):\n    '''Return list N+1 points representing N line segments on bezier curve\n  defined by control points P.\n    '''\n    assert isinstance(P, list)\n    assert len(P) > 0\n    for p in P:\n        assert isinstance(p, tuple)\n        for i in p:\n            assert len(p) > 1\n            assert isinstance(i, float)\n    assert isinstance(n_seg, int)\n    assert n_seg >= 0\n    \n    return [pt_on_bezier_curve(P, float(i)/n_seg) for i in range(n_seg)] + [P[-1]]"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning approximate length of a bezier curve defined by control points P. Segment curve into N lines where N is the order of the curve and accumulate the length of the segments.", "response": "def bezier_curve_approx_len(P=[(0.0, 0.0)]):\n    '''Return approximate length of a bezier curve defined by control points P.\nSegment curve into N lines where N is the order of the curve, and accumulate\n  the length of the segments.\n    '''\n    assert isinstance(P, list)\n    assert len(P) > 0\n    for p in P:\n        assert isinstance(p, tuple)\n        for i in p:\n            assert len(p) > 1\n            assert isinstance(i, float)\n    \n    n_seg = len(P) - 1\n    pts = pts_on_bezier_curve(P, n_seg)\n    return sum([distance_between_pts(pts[i], pts[i+1]) for i in range(n_seg)])"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns direction at t on bezier curve defined by control points P.", "response": "def dir_on_bezier_curve(P=[(0.0, 0.0)], t=0.5):\n    '''Return direction at t on bezier curve defined by control points P.\nList of vectors per pair of dimensions are returned in radians.\nE.g. Where X is \"right\", Y is \"up\", Z is \"in\" on a computer screen, and\n  returned value is [pi/4, -pi/4], then the vector will be coming out the\n  screen over the viewer's right shoulder.\n    '''\n    assert isinstance(P, list)\n    assert len(P) > 0\n    if not len(P) > 1:\n        return None # Points have no gradient.\n    for p in P:\n        assert isinstance(p, tuple)\n        for i in p:\n            assert len(p) > 1\n            assert isinstance(i, float)\n    assert isinstance(t, float)\n    assert 0 <= t <= 1\n    \n    O = len(P) - 1 # Order of curve\n    \n    # Recurse down the orders calculating the next set of control points until\n    #   there are only two left, which is the points on the gradient we want.\n    Q = P\n    while O > 1:\n        Q = [pt_between_pts(Q[l], Q[l+1], t) for l in range(O)]\n        O -= 1\n    \n    assert len(Q) == 2\n    # Now that we have the two points in N dimensions, we can reduce to the\n    #   gradients on N-1 planes.\n    q0 = Q[0]\n    q1 = Q[1]\n    \n    return dir_between_pts(q0, q1)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nenter the payload and POSTs to Red October", "response": "def engage(args, password):\n    \"\"\"\n    Construct payloads and POST to Red October\n    \"\"\"\n    if args['create']:\n        payload = {'Name': args['--user'], 'Password': password}\n        goodquit_json(api_call('create', args, payload))\n\n    elif args['delegate']:\n        payload = {\n            'Name': args['--user'], 'Password': password,\n            'Time': args['--time'], 'Uses': args['--uses']\n        }\n        goodquit_json(api_call('delegate', args, payload))\n\n    elif args['encrypt']:\n        payload = {\n            'Name': args['--user'], 'Password': password,\n            'Minimum': args['--min'], 'Owners': args['--owners'].split(','),\n            'Data': (args['--str'] if args['--file'] is None\n                     else read_file(args['--file']))\n        }\n        goodquit_json(api_call('encrypt', args, payload))\n\n    elif args['decrypt']:\n        payload = {\n            'Name': args['--user'], 'Password': password,\n            'Data': (args['--str'] if args['--file'] is None\n                     else read_file(args['--file']))\n        }\n        goodquit_json(api_call('decrypt', args, payload))\n\n    elif args['summary']:\n        payload = {'Name': args['--user'], 'Password': password}\n        goodquit_json(api_call('summary', args, payload))\n\n    elif args['change-password']:\n        args['newpass'] = getpass.getpass('New Password: ')\n        payload = {\n            'Name': args['--user'], 'Password': password,\n            'NewPassword': args['newpass']\n        }\n        goodquit_json(api_call('password', args, payload))\n\n    elif args['modify']:\n        payload = {\n            'Name': args['--user'], 'Password': password,\n            'Command': args['--action'], 'ToModify': args['--target']\n        }\n        goodquit_json(api_call('modify', args, payload))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nbuilding the parser object for the current locale.", "response": "def build(self):\n        \"\"\"\n        Build/rebuild the parser object\n        \"\"\"\n        self.logger = logging.getLogger('ply_parser')\n\n        self.lexer = PynspectFilterLexer()\n        self.lexer.build()\n\n        # Skip the first item in self.lexer.tokens, which is the 'EXP_ALL' token\n        # to get rid of following message:\n        # ... Token 'EXP_ALL' defined, but not used\n        # ... There is 1 unused token\n        #\n        self.tokens = self.lexer.tokens[1:]\n\n        self.parser = ply.yacc.yacc(\n            module=self,\n            #debuglog=self.logger,\n            errorlog=self.logger\n            #start='statements',\n            #debug=yacc_debug,\n            #optimize=yacc_optimize,\n            #tabmodule=yacctab\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef parse(self, data, filename='', debuglevel=0):\n        self.lexer.filename = filename\n        self.lexer.reset_lineno()\n        if not data or data.isspace():\n            return []\n        return self.parser.parse(data, lexer=self.lexer, debug=debuglevel)", "response": "Parse given data.\n\n            data:\n                A string containing the filter definition\n            filename:\n                Name of the file being parsed (for meaningful\n                error messages)\n            debuglevel:\n                Debug level to yacc"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef p_expression(tok):\n        if len(tok) == 4:\n            tok[0] = LogicalBinOpRule(tok[2], tok[1], tok[3])\n        else:\n            tok[0] = tok[1]", "response": "expression : xor_expression OP_OR expression\n                      | xor_expression"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef p_xor_expression(tok):\n        if len(tok) == 4:\n            tok[0] = LogicalBinOpRule(tok[2], tok[1], tok[3])\n        else:\n            tok[0] = tok[1]", "response": "xor_expression : and_expression OP_XOR xor_expression\n                          | and_expression"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef p_xor_p_expression(tok):\n        if len(tok) == 4:\n            tok[0] = LogicalBinOpRule(tok[2], tok[1], tok[3])\n        else:\n            tok[0] = tok[1]", "response": "xor_p_expression : and_p_expression | xor_p_expression\n                          | and_p_expression"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef p_cmp_expression(tok):\n        if len(tok) == 4:\n            tok[0] = ComparisonBinOpRule(tok[2], tok[1], tok[3])\n        else:\n            tok[0] = tok[1]", "response": "p_cmp_expression - Handles comparison expression."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nprocess a term in the binary table.", "response": "def p_term(tok):\n        \"\"\"term : factor OP_PLUS term\n                | factor OP_MINUS term\n                | factor OP_TIMES term\n                | factor OP_DIVIDE term\n                | factor OP_MODULO term\n                | factor\"\"\"\n        if len(tok) == 4:\n            tok[0] = MathBinOpRule(tok[2], tok[1], tok[3])\n        else:\n            tok[0] = tok[1]"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nfactoring : IPV4 | IPV6 | DATETIME | TIMEDELTA | INTEGER | FLOAT | VARIABLE | CONSTANT | FUNCTION RPAREN | FUNCTION expression RPAREN | LBRACK list RBRACK | LPAREN expression RPAREN", "response": "def p_factor(self, tok):\n        \"\"\"factor : IPV4\n                  | IPV6\n                  | DATETIME\n                  | TIMEDELTA\n                  | INTEGER\n                  | FLOAT\n                  | VARIABLE\n                  | CONSTANT\n                  | FUNCTION RPAREN\n                  | FUNCTION expression RPAREN\n                  | LBRACK list RBRACK\n                  | LPAREN expression RPAREN\"\"\"\n        if len(tok) == 2:\n            tok[0] = self._create_factor_rule(tok[1])\n        elif len(tok) == 3:\n            tok[0] = self._create_function_rule(tok[1])\n        elif tok[1][0] == 'FUNCTION':\n            tok[0] = self._create_function_rule(tok[1], tok[2])\n        else:\n            tok[0] = tok[2]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef p_list(self, tok):\n        node = self._create_factor_rule(tok[1])\n        if len(tok) == 2:\n            tok[0] = ListRule([node])\n        else:\n            tok[0] = ListRule([node], tok[3])", "response": "p_list - Handles list tokens"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef unshorten_url(short_url):\n    short_url = short_url.strip()\n    if not short_url.startswith('http'):\n        short_url = 'http://{0}'.format(short_url)\n\n    try:\n        cached_url = UnshortenURL.objects.get(short_url=short_url)\n    except UnshortenURL.DoesNotExist:\n        cached_url = UnshortenURL(short_url=short_url)\n    else:\n        return cached_url.long_url\n\n    try:\n        resp = urllib2.urlopen(short_url)\n    except (\n            urllib2.HTTPError, urllib2.URLError,\n            httplib.HTTPException):\n        return None\n\n    if resp.code == 200:\n        cached_url.long_url = resp.url\n        cached_url.save()\n        return resp.url", "response": "Unshortens the short_url or returns None if not possible."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef stop(self, spider_name=None):\n        if spider_name is None:\n            spider_name = self.spider_name\n        else:\n            self.spider_name = spider_name\n        if self.spider_name is None:\n            self.spider_name = self.list_running()[0].split(':')[-1]\n        self.jsonrpc_call('crawler/engine', 'close_spider', self.spider_name)", "response": "Stop the named running spider or the first running spider."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_spider_stats(self, spider_name):\n        if spider_name is None:\n            spider_name = self.spider_name\n        else:\n            self.spider_name = spider_name\n        if self.spider_name is None:\n            self.spider_name = self.list_running()[0].split(':')[-1]\n        return(self.jsonrpc_call('stats', 'get_stats', self.spider_name))", "response": "get - spider - stats <spider > - get stats of a running spider"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef coroutine(func, replace_callback=True):\n    re = tornado.gen._make_coroutine_wrapper(func, replace_callback=True)\n    re._rw_wrapped_function = func\n    return re", "response": "Decorator for asynchronous generators."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef gswrite(self, fn=None, device='jpeg', res=600, alpha=4, quality=90, gs=None):\n        \"use ghostscript to create output file(s) from the PDF\"\n        gs = (gs or self.gs or os.environ.get('gs') or 'gs')\n        # count the number of pages\n        if fn is None: \n            fn = os.path.splitext(self.fn)[0] + DEVICE_EXTENSIONS[device]\n        fn = File(fn=fn).fn     # normalize path\n        if not os.path.exists(os.path.dirname(fn)):\n            os.makedirs(os.path.dirname(fn))\n        log.debug(\"PDF.gswrite():\\n\\tself.fn = %s\\n\\tout fn = %s\" % (self.fn, fn))\n        if os.path.splitext(self.fn)[-1].lower()=='.pdf':\n            cmd = [gs, '-q', '-dNODISPLAY', '-c', \n                    \"(%s) (r) file runpdfbegin pdfpagecount = quit\" % self.fn]\n            log.debug(cmd)\n            out = subprocess.check_output(cmd).decode('utf-8').strip()\n            if out=='': out = '1'\n            pages = int(out)\n            log.debug(\"%d page(s)\" % pages)\n        else:\n            pages = 1\n        if pages > 1:\n            # add a counter to the filename, which tells gs to create a file for every page in the input\n            fb, ext = os.path.splitext(fn)\n            n = len(re.split('.', str(pages))) - 1\n            counter = \"-%%0%dd\" % n\n            fn = fb + counter + ext\n\n            # remove any existing output filenames that match the pattern\n            for existingfn in glob(fb+'*'+ext):\n                log.debug(\"REMOVING %s\" % existingfn)\n                os.remove(existingfn)\n\n        callargs = [gs, '-q', '-dSAFER', '-dBATCH', '-dNOPAUSE', '-dUseCropBox',\n                    '-sDEVICE=%s' % device, '-r%d' % res]\n        if device=='jpeg': \n            callargs += ['-dJPEGQ=%d' % quality]\n        if 'png' in device or 'jpeg' in device or 'tiff' in device: \n            callargs += [\n                '-dTextAlphaBits=%d' % alpha,\n                '-dGraphicsAlphaBits=%d' % alpha]\n        callargs += ['-sOutputFile=%s' % fn, self.fn]\n        try:\n            log.debug(callargs)\n            subprocess.check_output(callargs)\n        except subprocess.CalledProcessError as e:\n            log.error(callargs)\n            log.error(str(e.output, 'utf-8'))\n        fns = sorted(glob(re.sub('%\\d+d','*', fn)))\n        log.debug('\\n\\t'+'\\n\\t'.join(fns))\n        return fns", "response": "use ghostscript to create output file ( s ) from the PDF"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nmaking a clone of the object.", "response": "def copy(self):\n        '''\n         makes a clone copy of the mapper. It won't clone the serializers or deserializers and it won't copy the events\n        '''\n        try:\n            tmp = self.__class__()\n        except Exception:\n            tmp = self.__class__(self._pdict)\n            \n        tmp._serializers = self._serializers\n        tmp.__deserializers = self.__deserializers\n\n        return tmp"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _get_required_fn(fn, root_path):\n    if not fn.startswith(root_path):\n        raise ValueError(\"Both paths have to be absolute or local!\")\n\n    replacer = \"/\" if root_path.endswith(\"/\") else \"\"\n\n    return fn.replace(root_path, replacer, 1)", "response": "Returns the path to the MD5 file required for the MD5 file."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngenerates checksums for each file in directory.", "response": "def generate_checksums(directory, blacklist=_BLACKLIST):\n    \"\"\"\n    Compute checksum for each file in `directory`, with exception of files\n    specified in `blacklist`.\n\n    Args:\n        directory (str): Absolute or relative path to the directory.\n        blacklist (list/set/tuple): List of blacklisted filenames. Only\n                  filenames are checked, not paths!\n\n    Returns:\n        dict: Dict in format ``{fn: md5_hash}``.\n\n    Note:\n        File paths are returned as absolute paths from package root.\n\n    Raises:\n        UserWarning: When `directory` doesn't exists.\n    \"\"\"\n    if not os.path.exists(directory):\n        raise UserWarning(\"'%s' doesn't exists!\" % directory)\n\n    hashes = {}\n    for root, dirs, files in os.walk(directory):\n        for fn in sorted(files):\n            # skip files on blacklist\n            if fn in blacklist:\n                continue\n\n            fn = os.path.join(root, fn)\n\n            # compute hash of the file\n            with open(fn) as f:\n                checksum = hashlib.md5(f.read())\n\n            fn = _get_required_fn(fn, directory)\n\n            hashes[fn] = checksum.hexdigest()\n\n    return hashes"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef generate_hashfile(directory, blacklist=_BLACKLIST):\n    checksums = generate_checksums(directory, blacklist)\n\n    out = \"\"\n    for fn, checksum in sorted(checksums.items()):\n        out += \"%s %s\\n\" % (checksum, fn)\n\n    return out", "response": "Generate a hashfile for each file in directory with exception of files\n    specified in blacklist."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _extract_id_from_batch_response(r, name='id'):\n        names = name + 's'\n        if names in r:\n            # soon-to-be deprecated batch reponse\n            if 'errors' in r and r['errors']:\n                raise GeneralException(r['errors'][0]['desc'])\n            id = r[names][0]\n        else:\n            # new-style simplified api response\n            id = r[name]\n        return int(id)", "response": "Unholy forward - compatible mess for extraction of id / oid from a\n            soon - to - be ( deprecated ) batch response."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef kvpath(self, base, *pa, **kw):\n        def fmt(vtuple):\n            typ, val = vtuple\n            if not val is None:\n                return safeformat(\"{:%s}\"%typ, val)\n            return None\n        parts = [base]\n        for v in pa:\n            fv = fmt(v)\n            if not fv is None:\n                parts.append(quote(fv))\n        for k,v in kw.items():\n            fv = fmt(v)\n            if not fv is None:\n                parts.append(quote(k+\"=\"+fv))\n        return \"/\".join(parts)", "response": "Return a key - value query url for the given base and pa and kw."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef create_object(self, name, url):\n        r = self.request('post', 'registry/objects/', json.dumps({\n            'description': {\n                'name': name,\n                'url': url\n            }\n        }))\n        return self._extract_id_from_batch_response(r, 'oid')", "response": "Creates a single object in Vingd Object registry."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncommitting a purchase and returns a dict containing the successful response.", "response": "def commit_purchase(self, purchaseid, transferid):\n        \"\"\"\n        DECLARES a purchase defined with ``purchaseid`` (bound to vingd transfer\n        referenced by ``transferid``) as finished, with user being granted the\n        access to the service or goods.\n        \n        If seller fails to commit the purchase, the user (buyer) shall be\n        refunded full amount paid (reserved).\n        \n        :type purchaseid: ``bigint``\n        :param purchaseid:\n            Purchase ID, as returned in purchase description, upon\n            token/purchase verification.\n        :type transferid: ``bigint``\n        :param transferid:\n            Transfer ID, as returned in purchase description, upon\n            token/purchase verification.\n        \n        :rtype: ``dict``\n        :returns:\n            ``{'ok': <boolean>}``.\n        :raises InvalidData: invalid format of input parameters\n        :raises NotFound: non-existing order/purchase/transfer\n        :raises GeneralException: depends on details of error\n        :raises InternalError: Vingd internal error (network, server, app)\n        \n        :see: `verify_purchase`.\n        :resource: ``purchases/<purchaseid>``\n        :access: authorized users (ACL flag: ``type.business``)\n        \"\"\"\n        return self.request(\n            'put',\n            safeformat('purchases/{:int}', purchaseid),\n            json.dumps({'transferid': transferid})\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create_order(self, oid, price, context=None, expires=None):\n        expires = absdatetime(expires, default=self.EXP_ORDER)\n        orders = self.request(\n            'post',\n            safeformat('objects/{:int}/orders/', oid),\n            json.dumps({\n                'price': price,\n                'order_expires': expires.isoformat(),\n                'context': context\n            }))\n        orderid = self._extract_id_from_batch_response(orders)\n        return {\n            'id': orderid,\n            'expires': expires,\n            'context': context,\n            'object': {\n                'id': oid,\n                'price': price\n            },\n            'urls': {\n                'redirect': urljoin(self.usr_frontend, '/orders/%d/add/' % orderid),\n                'popup': urljoin(self.usr_frontend, '/popup/orders/%d/add/' % orderid)\n            }\n        }", "response": "Creates a single order for the object with the given object ID price and context and expiration timestamp."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_orders(self, oid=None, include_expired=False, orderid=None):\n        return self.request(\n            'get',\n            '%sorders/%s%s' % (\n                safeformat('objects/{:int}/', oid) if oid else \"\",\n                \"all/\" if include_expired else \"\",\n                safeformat('{:int}', orderid) if orderid else \"\"\n            )\n        )", "response": "Fetches a list of order objects for the object with the specified ID."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nupdating a single object in Vingd Object registry.", "response": "def update_object(self, oid, name, url):\n        \"\"\"\n        UPDATES a single object in Vingd Object registry.\n        \n        :type oid: ``bigint``\n        :param oid:\n            Object ID of the object being updated.\n        :type name: ``string``\n        :param name:\n            New object's name.\n        :type url: ``string``\n        :param url:\n            New callback URL (object's resource location).\n        \n        :rtype: `bigint`\n        :returns: Object ID of the updated object.\n        :raises GeneralException:\n        \n        :resource: ``registry/objects/<oid>/``\n        :access: authorized user MUST be the object owner\n        \"\"\"\n        r = self.request(\n            'put',\n            safeformat('registry/objects/{:int}/', oid),\n            json.dumps({\n                'description': {\n                    'name': name,\n                    'url': url\n                }\n            })\n        )\n        return self._extract_id_from_batch_response(r, 'oid')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_objects(self, oid=None,\n                    since=None, until=None, last=None, first=None):\n        \"\"\"\n        FETCHES a filtered collection of objects created by the authenticated\n        user.\n        \n        :type oid: ``bigint``\n        :param oid:\n            Object ID\n        :type since: ``datetime``/``dict``\n        :param since:\n            Object has to be newer than this timestamp (absolute ``datetime``,\n            or relative ``dict``). Valid keys for relative `since` timestamp\n            dictionary are same as keyword arguments for `datetime.timedelta`\n            (``days``, ``seconds``, ``minutes``, ``hours``, ``weeks``).\n        :type until: ``datetime``/``dict``\n        :param until:\n            Object has to be older than this timestamp (for format, see the\n            `since` parameter above).\n        :type last: ``bigint``\n        :param last:\n            The number of newest objects (that satisfy all other criteria) to\n            return.\n        :type first: ``bigint``\n        :param first:\n            The number of oldest objects (that satisfy all other criteria) to\n            return.\n        \n        :rtype: ``list``/``dict``\n        :returns:\n            A list of object description dictionaries. If ``oid`` is specified,\n            a single dictionary is returned instead of a list.\n        :raises GeneralException:\n        \n        :resource:\n            ``registry/objects[/<oid>]``\n            ``[/since=<since>][/until=<until>][/last=<last>][/first=<first>]``\n        :access: authorized users (only objects owned by the authenticated user\n            are returned)\n        \"\"\"\n        resource = self.kvpath('registry/objects', ('int', oid),\n                               since=('isobasic', absdatetime(since)),\n                               until=('isobasic', absdatetime(until)),\n                               first=('int', first), last=('int', last))\n        return self.request('get', resource)", "response": "FETCHES a filtered collection of objects owned by the authenticated user."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef authorized_get_account_balance(self, huid):\n        acc = self.request('get', safeformat('fort/accounts/{:hex}', huid))\n        return int(acc['balance'])", "response": "Gets the account balance for the user defined with huid."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef authorized_purchase_object(self, oid, price, huid):\n        return self.request(\n            'post',\n            safeformat('objects/{:int}/purchases', oid),\n            json.dumps({\n                'price': price,\n                'huid': huid,\n                'autocommit': True\n            }))", "response": "Does delegated ( pre - authorized ) purchase of oid in the name of\n        huid at price price."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef authorized_create_user(self, identities=None, primary=None, permissions=None):\n        return self.request('post', 'id/users/', json.dumps({\n            'identities': identities,\n            'primary_identity': primary,\n            'delegate_permissions': permissions\n        }))", "response": "This method creates a Vingd user and links it with the provided identities and primary identities and sets the delegate - user\n        permissions."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nperform a single reward. User defined with `huid_to` is rewarded with `amount` cents, transfered from the account of the authenticated user. :type huid_to: ``alphanumeric(40)`` :param huid_to: Hashed User ID, bound to account of the authenticated user (doing the request). :type amount: ``integer`` :param amount: Amount in cents. :type description: ``string`` :param description: Transaction description (optional). :rtype: ``dict`` :returns: ``{'transfer_id': <transfer_id>}`` Fort Transfer ID packed inside a dict. :raises Forbidden: consumer has to have ``transfer.outbound`` ACL flag set. :raises GeneralException: :raises NotFound: :resource: ``rewards/`` :access: authorized users (ACL flag: ``transfer.outbound``)", "response": "def reward_user(self, huid_to, amount, description=None):\n        \"\"\"\n        PERFORMS a single reward. User defined with `huid_to` is rewarded with\n        `amount` cents, transfered from the account of the authenticated user.\n        \n        :type huid_to: ``alphanumeric(40)``\n        :param huid_to:\n            Hashed User ID, bound to account of the authenticated user (doing\n            the request).\n        :type amount: ``integer``\n        :param amount:\n            Amount in cents.\n        :type description: ``string``\n        :param description:\n            Transaction description (optional).\n        \n        :rtype: ``dict``\n        :returns: ``{'transfer_id': <transfer_id>}``\n            Fort Transfer ID packed inside a dict.\n        :raises Forbidden: consumer has to have ``transfer.outbound`` ACL flag\n            set.\n        :raises GeneralException: :raises NotFound:\n        \n        :resource: ``rewards/``\n        :access: authorized users (ACL flag: ``transfer.outbound``)\n        \"\"\"\n        return self.request('post', 'rewards', json.dumps({\n            'huid_to': huid_to,\n            'amount': amount,\n            'description': description\n        }))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create_voucher(self, amount, expires=None, message='', gid=None):\n        expires = absdatetime(expires, default=self.EXP_VOUCHER).isoformat()\n        voucher = self.request('post', 'vouchers/', json.dumps({\n            'amount': amount,\n            'until': expires,\n            'message': message,\n            'gid': gid\n        }))\n        return {\n            'raw': voucher,\n            'urls': {\n                'redirect': urljoin(self.usr_frontend, '/vouchers/%s' % voucher['vid_encoded']),\n                'popup': urljoin(self.usr_frontend, '/popup/vouchers/%s' % voucher['vid_encoded'])\n            }\n        }", "response": "Creates a new preallocated voucher with amount in vingd cents reserved by the user."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_vouchers(self, vid_encoded=None,\n                     uid_from=None, uid_to=None, gid=None,\n                     valid_after=None, valid_before=None,\n                     last=None, first=None):\n        \"\"\"\n        FETCHES a filtered list of vouchers.\n        \n        :type vid_encoded: ``alphanumeric(64)``\n        :param vid_encoded:\n            Voucher ID, as a string with CRC.\n        :type uid_from: ``bigint``\n        :param uid_from:\n            Filter by source account UID.\n        :type uid_to: ``bigint``\n        :param uid_to:\n            Filter by destination account UID.\n        :type gid: ``alphanumeric(32)``\n        :param gid:\n            Filter by voucher Group ID. GID is localized to `uid_from`.\n        :type valid_after: ``datetime``/``dict``\n        :param valid_after:\n            Voucher has to be valid after this timestamp. Absolute\n            (``datetime``) or relative (``dict``) timestamps are accepted. Valid\n            keys for relative timestamp dictionary are same as keyword arguments\n            for `datetime.timedelta` (``days``, ``seconds``, ``minutes``,\n            ``hours``, ``weeks``).\n        :type valid_before: ``datetime``/``dict``\n        :param valid_before:\n            Voucher was valid until this timestamp (for format, see the\n            `valid_after` above).\n        :type last: ``bigint``\n        :param last:\n            The number of newest vouchers (that satisfy all other criteria) to\n            return.\n        :type first: ``bigint``\n        :param first:\n            The number of oldest vouchers (that satisfy all other criteria) to\n            return.\n        \n        :note:\n            If `first` or `last` are used, the vouchers list is sorted by time\n            created, otherwise it is sorted alphabetically by `vid_encoded`.\n        \n        :rtype: ``list``/``dict``\n        :returns:\n            A list of voucher description dictionaries. If `vid_encoded` is\n            specified, a single dictionary is returned instead of a list.\n        :raises GeneralException:\n        \n        :resource:\n            ``vouchers[/<vid_encoded>][/from=<uid_from>][/to=<uid_to>]``\n            ``[/valid_after=<valid_after>][/valid_before=<valid_before>]``\n            ``[/last=<last>][/first=<first>]``\n        :access: authorized users (ACL flag: ``voucher.get``)\n        \"\"\"\n        resource = self.kvpath(\n            'vouchers',\n            ('ident', vid_encoded),\n            **{\n                'from': ('int', uid_from),\n                'to': ('int', uid_to),\n                'gid': ('ident', gid),\n                'valid_after': ('isobasic', absdatetime(valid_after)),\n                'valid_before': ('isobasic', absdatetime(valid_before)),\n                'first': ('int', first),\n                'last': ('int', last)\n            }\n        )\n        return self.request('get', resource)", "response": "This method returns a list of vouchers in a given time range."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nfetch a filtered list of vouchers log entries. :type vid_encoded: ``alphanumeric(64)`` :param vid_encoded: Voucher ID, as a string with CRC. :type vid: ``bigint`` :param vid: Voucher ID. :type action: ``string`` (add | use | revoke | expire) :param action: Filter only these actions on vouchers. :type uid_from: ``bigint`` :param uid_from: Filter by source account UID. :type uid_to: ``bigint`` :param uid_to: Filter by destination account UID. :type gid: ``alphanumeric(32)`` :param gid: Filter by voucher Group ID. GID is localized to `uid_from`. :type valid_after: ``datetime``/``dict`` :param valid_after: Voucher has to be valid after this timestamp. Absolute (``datetime``) or relative (``dict``) timestamps are accepted. Valid keys for relative timestamp dictionary are same as keyword arguments for `datetime.timedelta` (``days``, ``seconds``, ``minutes``, ``hours``, ``weeks``). :type valid_before: ``datetime``/``dict`` :param valid_before: Voucher was valid until this timestamp (for format, see the `valid_after` above). :type create_after: ``datetime``/``dict`` :param create_after: Voucher has to be created after this timestamp (for format, see the `valid_after` above). :type create_before: ``datetime``/``dict`` :param create_before: Voucher was created until this timestamp (for format, see the `valid_after` above). :type last: ``bigint`` :param last: The number of newest voucher entries (that satisfy all other criteria) to return. :type first: ``bigint`` :param first: The number of oldest voucher entries (that satisfy all other criteria) to return. :note: If `first` or `last` are used, the vouchers list is sorted by time created, otherwise it is sorted alphabetically by `id`. :rtype: ``list``/``dict`` :returns: A list of voucher log description dictionaries. :raises GeneralException: :resource: ``vouchers/history[/<vid_encoded>][/from=<uid_from>][/to=<uid_to>]`` ``[/vid=<vid>][/action=<action>][/last=<last>][/first=<first>]`` ``[/valid_after=<valid_after>][/valid_before=<valid_before>]`` ``[/create_after=<create_after>][/create_before=<create_before>]`` ``[/gid=<group_id>]`` :access: authorized users (ACL flag: ``voucher.history``)", "response": "def get_vouchers_history(self, vid_encoded=None, vid=None, action=None,\n                             uid_from=None, uid_to=None, gid=None,\n                             valid_after=None, valid_before=None,\n                             create_after=None, create_before=None,\n                             last=None, first=None):\n        \"\"\"\n        FETCHES a filtered list of vouchers log entries.\n        \n        :type vid_encoded: ``alphanumeric(64)``\n        :param vid_encoded:\n            Voucher ID, as a string with CRC.\n        :type vid: ``bigint``\n        :param vid:\n            Voucher ID.\n        :type action: ``string`` (add | use | revoke | expire)\n        :param action:\n            Filter only these actions on vouchers.\n        :type uid_from: ``bigint``\n        :param uid_from:\n            Filter by source account UID.\n        :type uid_to: ``bigint``\n        :param uid_to:\n            Filter by destination account UID.\n        :type gid: ``alphanumeric(32)``\n        :param gid:\n            Filter by voucher Group ID. GID is localized to `uid_from`.\n        :type valid_after: ``datetime``/``dict``\n        :param valid_after:\n            Voucher has to be valid after this timestamp. Absolute\n            (``datetime``) or relative (``dict``) timestamps are accepted. Valid\n            keys for relative timestamp dictionary are same as keyword arguments\n            for `datetime.timedelta` (``days``, ``seconds``, ``minutes``,\n            ``hours``, ``weeks``).\n        :type valid_before: ``datetime``/``dict``\n        :param valid_before:\n            Voucher was valid until this timestamp (for format, see the\n            `valid_after` above).\n        :type create_after: ``datetime``/``dict``\n        :param create_after:\n            Voucher has to be created after this timestamp (for format, see the\n            `valid_after` above).\n        :type create_before: ``datetime``/``dict``\n        :param create_before:\n            Voucher was created until this timestamp (for format, see the\n            `valid_after` above).\n        :type last: ``bigint``\n        :param last:\n            The number of newest voucher entries (that satisfy all other\n            criteria) to return.\n        :type first: ``bigint``\n        :param first:\n            The number of oldest voucher entries (that satisfy all other\n            criteria) to return.\n        \n        :note:\n            If `first` or `last` are used, the vouchers list is sorted by time\n            created, otherwise it is sorted alphabetically by `id`.\n        \n        :rtype: ``list``/``dict``\n        :returns:\n            A list of voucher log description dictionaries.\n        :raises GeneralException:\n        \n        :resource:\n            ``vouchers/history[/<vid_encoded>][/from=<uid_from>][/to=<uid_to>]``\n            ``[/vid=<vid>][/action=<action>][/last=<last>][/first=<first>]``\n            ``[/valid_after=<valid_after>][/valid_before=<valid_before>]``\n            ``[/create_after=<create_after>][/create_before=<create_before>]``\n            ``[/gid=<group_id>]``\n        :access: authorized users (ACL flag: ``voucher.history``)\n        \"\"\"\n        resource = self.kvpath(\n            'vouchers/history',\n            ('ident', vid_encoded),\n            **{\n                'vid': ('int', vid),\n                'action': ('ident', action),\n                'from': ('int', uid_from),\n                'to': ('int', uid_to),\n                'gid': ('ident', gid),\n                'valid_after': ('isobasic', absdatetime(valid_after)),\n                'valid_before': ('isobasic', absdatetime(valid_before)),\n                'create_after': ('isobasic', absdatetime(create_after)),\n                'create_before': ('isobasic', absdatetime(create_before)),\n                'first': ('int', first),\n                'last': ('int', last)\n            }\n        )\n        return self.request('get', resource)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef partition(f, xs):\r\n    t = type(xs)\r\n    true = filter(f, xs)\r\n    false = [x for x in xs if x not in true]\r\n    return t(true), t(false)", "response": "Returns a tuple of two - item tuples where the first item is the sequence of items that passed the filter and the second is the sequence of items that didn t pass the filter."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nmapping a binary function over a sequence.", "response": "def lazy_binmap(f, xs):\r\n    \"\"\"\r\n    Maps a binary function over a sequence. The function is applied to each item\r\n    and the item after it until the last item is reached.\r\n    \"\"\"\r\n    return (f(x, y) for x, y in zip(xs, xs[1:]))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef curry(f, args_supplied=()):\r\n    try:\r\n        nargs_required = len(signature(f).parameters)\r\n    except ValueError as e:\r\n        raise ValueError(str(e) + \" (maybe you're trying to curry a built-in?)\")\r\n\r\n    def inner(arg):\r\n        new_args_supplied = args_supplied + (arg,)\r\n        if len(new_args_supplied) == nargs_required:\r\n            return f(*new_args_supplied)\r\n        return curry(f, new_args_supplied)\r\n\r\n    return inner", "response": "Takes a function and then returns a function that takes each argument for the original\r\n    function through __call__."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef collect(items, convert=(list, tuple), convert_to=tuple):\r\n    if len(items) == 1:\r\n        head_item = head(items)\r\n        if True in (isinstance(head_item, t) for t in convert):\r\n            items = convert_to(*items)\r\n        elif isgenerator(head(items)):\r\n            items = convert_to(*items)\r\n    return convert_to(items)", "response": "Converts a nested list or tuple or generator into a tuple."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef loader(path):\n    finder = ModuleFinder if _isdir(path) else FileFinder\n    return Loader(finder(path))", "response": "Returns a loader object for a given path with\n    the correct finder class for single file\n   ."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef analog_linear2_ramp(ramp_data, start_time, end_time, value_final,\n                       time_subarray):\n    \"\"\"Use this when you want a discontinuous jump at the end of the linear ramp.\"\"\"\n    value_initial = ramp_data[\"value\"]\n    value_final2 = ramp_data[\"value_final\"]\n    interp = (time_subarray - start_time)/(end_time - start_time)\n    return value_initial*(1.0 - interp) + value_final2*interp", "response": "This function is used to calculate the value of a linear ramp."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef bake(self):\n        self.unbake()\n        for key in self.dct:\n            self.get_absolute_time(key)\n        self.is_baked = True", "response": "Find absolute times for all keys."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef unbake(self):\n        for key in self.dct:\n            # pop __abs_time__ if it exists\n            self.dct[key].pop('__abs_time__', None)\n        self.is_baked = False", "response": "Remove absolute times for all keys."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the absolute time position of the key.", "response": "def get_absolute_time(self, key):\n        \"\"\"Returns the absolute time position of the key.\n\n        If absolute time positions are not calculated, then this function\n        calculates it.\n        \"\"\"\n        keyframe = self.dct[key]\n        try:\n            # if absolute time is already calculated, return that\n            return keyframe['__abs_time__']\n        except KeyError:\n            # if not, calculate by adding relative time to parent's time\n            if keyframe['parent'] is None:\n                keyframe['__abs_time__'] = keyframe['time']\n            else:\n                parent_time = self.get_absolute_time(keyframe['parent'])\n                abs_time = keyframe['time'] + parent_time\n                keyframe['__abs_time__'] = abs_time\n            return keyframe['__abs_time__']"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef sorted_key_list(self):\n        if not self.is_baked:\n            self.bake()\n        key_value_tuple = sorted(self.dct.items(),\n                                 key=lambda x: x[1]['__abs_time__'])\n        skl = [k[0] for k in key_value_tuple]\n        return skl", "response": "Returns list of keys sorted according to their absolute time."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset the time of key.", "response": "def set_time(self, key_name, new_time):\n        \"\"\"Sets the time of key.\"\"\"\n        self.unbake()\n        kf = self.dct[key_name]\n        kf['time'] = new_time\n        self.bake()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_comment(self, key_name, new_comment):\n        kf = self.dct[key_name]\n        kf['comment'] = new_comment", "response": "Sets the comment of key."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset the parent of the key.", "response": "def set_parent(self, key_name, new_parent):\n        \"\"\"Sets the parent of the key.\"\"\"\n        self.unbake()\n        kf = self.dct[key_name]\n        kf['parent'] = new_parent\n        self.bake()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef is_ancestor(self, child_key_name, ancestor_key_name):\n\n        # all keys are descendents of None\n        if ancestor_key_name is None:\n            return True\n\n        one_up_parent = self.dct[child_key_name]['parent']\n        if child_key_name == ancestor_key_name:\n            # debatable semantics, but a person lies in his/her own\n            # ancestry tree\n            return True\n        elif one_up_parent is None:\n            return False\n        else:\n            return self.is_ancestor(one_up_parent, ancestor_key_name)", "response": "Returns True if the ancestor lies in the ancestry tree of child."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_hook(self, key_name, hook_name, hook_dict):\n        kf = self.dct[key_name]\n        if 'hooks' not in kf:\n            kf['hooks'] = {}\n        kf['hooks'][str(hook_name)] = hook_dict", "response": "Add hook to the keyframe key_name."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nremoves hook from the keyframe key_name.", "response": "def remove_hook(self, key_name, hook_name):\n        \"\"\"Remove hook from the keyframe key_name.\"\"\"\n        kf = self.dct[key_name]\n        if 'hooks' in kf:\n            if hook_name in kf['hooks']:\n                return kf['hooks'].pop(hook_name)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning list of all hooks attached to key_name.", "response": "def list_hooks(self, key_name):\n        \"\"\"Return list of all hooks attached to key_name.\"\"\"\n        kf = self.dct[key_name]\n        if 'hooks' not in kf:\n            return []\n        else:\n            return kf['hooks'].iterkeys()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncheck for keyframs timing overlap. Returns the name of the first keyframs that overlapped.", "response": "def do_keyframes_overlap(self):\n        \"\"\"Checks for keyframs timing overlap.\n\n        Returns the name of the first keyframs that overlapped.\"\"\"\n        skl = self.sorted_key_list()\n        for i in range(len(skl)-1):\n            this_time = self.dct[skl[i]]['__abs_time__']\n            next_time = self.dct[skl[i+1]]['__abs_time__']\n            if abs(next_time-this_time) < 1e-6:\n                # key frame times overlap\n                return skl[i]\n        # Return None if all passed\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nremoves all keyframes which are not in the key_frame_list.", "response": "def del_unused_keyframes(self):\n        \"\"\"Scans through list of keyframes in the channel and removes those\n        which are not in self.key_frame_list.\"\"\"\n        skl = self.key_frame_list.sorted_key_list()\n        unused_keys = [k for k in self.dct['keys']\n                       if k not in skl]\n        for k in unused_keys:\n            del self.dct['keys'][k]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a list of the keyframes used by this channel sorted with time.", "response": "def get_used_key_frames(self):\n        \"\"\"Returns a list of the keyframes used by this channel, sorted with\n        time. Each element in the list is a tuple. The first element is the\n        key_name and the second is the channel data at that keyframe.\"\"\"\n\n        skl = self.key_frame_list.sorted_key_list()\n        # each element in used_key_frames is a tuple (key_name, key_dict)\n        used_key_frames = []\n        for kf in skl:\n            if kf in self.dct['keys']:\n                used_key_frames.append((kf, self.dct['keys'][kf]))\n        return used_key_frames"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_ramp_regions(self):\n        skl = self.key_frame_list.sorted_key_list()\n        ramp_or_jump = np.zeros(len(skl) - 1)\n        used_key_frames = self.get_used_key_frame_list()\n        for region_number, start_key in enumerate(skl[:-1]):\n            if start_key in used_key_frames:\n                key_data = self.dct['keys'][start_key]\n                ramp_type = key_data['ramp_type']\n                if ramp_type != \"jump\":\n                    # this means that a ramp starts in this region. Figure\n                    # out where it ends\n                    curr_key_num = used_key_frames.index(start_key)\n                    end_key_number = curr_key_num + 1\n                    # figure out if the current key was the last key\n                    if end_key_number < len(used_key_frames):\n                        # if it wasnt, then find the end region\n                        end_key_name = used_key_frames[end_key_number]\n                        end_region_index = skl.index(end_key_name)\n                        ramp_or_jump[region_number:end_region_index] = 1\n        return ramp_or_jump", "response": "Returns a numpy array where each element corresponds to whether to\n        ramp in that region or jump."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the generated ramp and a time array.", "response": "def generate_ramp(self, time_div=4e-3):\n        \"\"\"Returns the generated ramp and a time array.\n\n        This function assumes a uniform time division throughout.\n\n        time_div - time resolution of the ramp.\n        \"\"\"\n        if self.dct['type'] == 'analog':\n            is_analog = True\n        else:\n            is_analog = False\n        skl = self.key_frame_list.sorted_key_list()\n        # each element in used_key_frames is a tuple (key_name, key_dict)\n        used_key_frames = self.get_used_key_frames()\n        max_time = self.key_frame_list.get_absolute_time(skl[-1]) + time_div\n\n        num_points = int(round(max_time/time_div))\n        time = np.arange(num_points) * time_div\n        # time = np.arange(0.0, max_time, time_div)\n        if is_analog:\n            voltage = np.zeros(time.shape, dtype=float)\n        else:\n            voltage = np.zeros(time.shape, dtype='uint32')\n        kf_times = np.array([self.key_frame_list.get_absolute_time(ukf[0])\n                             for ukf in used_key_frames])\n        kf_positions = kf_times/time_div\n\n        if is_analog:\n            # set the start and the end part of the ramp\n            start_voltage = used_key_frames[0][1]['ramp_data']['value']\n            end_voltage = used_key_frames[-1][1]['ramp_data']['value']\n            voltage[0:kf_positions[0]] = start_voltage\n            voltage[kf_positions[-1]:] = end_voltage\n        else:\n            start_voltage = int(used_key_frames[0][1]['state'])\n            end_voltage = int(used_key_frames[-1][1]['state'])\n            voltage[0:kf_positions[0]] = start_voltage\n            voltage[kf_positions[-1]:] = end_voltage\n\n        for i in range(len(kf_times)-1):\n            start_time = kf_times[i]\n            end_time = kf_times[i+1]\n            start_index = kf_positions[i]\n            end_index = kf_positions[i+1]\n            time_subarray = time[start_index:end_index]\n            ramp_type = used_key_frames[i][1]['ramp_type']\n            ramp_data = used_key_frames[i][1]['ramp_data']\n            if is_analog:\n                value_final = used_key_frames[i+1][1]['ramp_data']['value']\n            else:\n                state = used_key_frames[i][1]['state']\n\n            if is_analog:\n                parms_tuple = (ramp_data, start_time, end_time, value_final,\n                               time_subarray)\n            else:\n                parms_tuple = (ramp_data, start_time, end_time, state,\n                               time_subarray)\n\n            if is_analog:\n                ramp_function = analog_ramp_functions[ramp_type]\n            else:\n                ramp_function = digital_ramp_functions[ramp_type]\n            voltage_sub = ramp_function(*parms_tuple)\n            voltage[start_index:end_index] = voltage_sub\n\n        # finally use the conversion and return the voltage\n        return time, self.convert_voltage(voltage, time)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the genre of the current nationale for the given nationale.", "response": "def genre(self):\n        \"\"\" Cette routine convertit les indications morphologiques, donn\u00e9es dans le fichier lemmes.la, pour exprimer le genre du mot dans la langue courante.\n\n        :return: Genre\n        :rtype: str\n        \"\"\"\n        _genre = \"\"\n        if \" m.\" in self._indMorph:\n            _genre += \"m\"\n        if \" f.\" in self._indMorph:\n            _genre += \"f\"\n        if \" n.\" in self._indMorph:\n            _genre += \"n\"\n        _genre = _genre.strip()\n        if self._renvoi and not _genre:\n            lr = self._lemmatiseur.lemme(self._renvoi)\n            if lr:\n                return lr.genre()\n\n        return _genre"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef irreg(self, i):\n        excl = False\n        for ir in self._irregs:\n            if i in ir.morphos():\n                return ir.grq(), ir.exclusif\n        return \"\", excl", "response": "Renvoie la forme irr\u00e9guli\u00e8re de morpho i. excl devient True si elle est exclusive"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef pos(self):\n        if not self._pos and self._renvoi:\n            lr = self._lemmatiseur.lemme(self._renvoi)\n            if lr:\n                return lr.pos()\n        return self._pos", "response": "Renvoie un caract\u00e8re repr\u00e9sentant la cat\u00e9gorie"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngenerates a list of possible forms for the current lemma", "response": "def possible_forms(self):\n        \"\"\" Generate a list of possible forms for the current lemma\n\n        :returns: List of possible forms for the current lemma\n        :rtype: [str]\n        \"\"\"\n        forms = []\n        for morph in self.modele().morphos():\n            for desinence in self.modele().desinences(morph):\n                radicaux = self.radical(desinence.numRad())\n                if isinstance(radicaux, Radical):\n                    forms.append(radicaux.gr() + desinence.gr())\n                else:\n                    for rad in radicaux:\n                        forms.append(rad.gr() + desinence.gr())\n        return list(set(forms))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nvisiting Bulbapedia and pull names and descriptions from the table list of moves. Save as JSON.", "response": "def get_moves():\n    \"\"\"Visit Bulbapedia and pull names and descriptions from the table, 'list of moves.' Save as JSON.\"\"\"\n    page = requests.get('http://bulbapedia.bulbagarden.net/wiki/List_of_moves')\n    soup = bs4.BeautifulSoup(page.text)\n    table = soup.table.table\n    tablerows = [tr for tr in table.children if tr != '\\n'][1:]\n\n    moves = {}\n\n    for tr in tablerows:\n        cells = tr.find_all('td')\n        move_name = cells[1].get_text().strip(' \\n*').replace(' ', '-').lower()\n        move_id = int(cells[0].get_text().strip())\n        move_type = cells[2].get_text().strip()\n        move_ps = cells[3].get_text().strip()\n        moves[move_name] = {'id':move_id, 'type':move_type, 'ps':move_ps}\n\n    srcpath = path.dirname(__file__)\n    with io.open(path.join(srcpath, 'moves.json'), 'w', encoding='utf-8') as f:\n        f.write(json.dumps(moves, ensure_ascii=False))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef load_from_path(path, filetype=None, has_filetype=True):\n    if not isinstance(path, str):\n        try:\n            return path.read()\n        except AttributeError:\n            return path\n    path = normalize_path(path, filetype, has_filetype)\n    with open(path) as data:\n        return data.read()", "response": "load file content from a file specified as dot - separated path"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef load_lines_from_path(path, filetype=None, has_filetype=True):\n    if not isinstance(path, str):\n        try:\n            return path.readlines()\n        except AttributeError:\n            return path\n    path = normalize_path(path, filetype)\n    with open(path) as data:\n        return data.readlines()", "response": "load lines from a file specified as dot - separated path"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef save(self):\n        if self.contacts:  # never write a empty addressbook\n            cache = {'contacts': self.contacts,\n                     'aadbook_cache': CACHE_FORMAT_VERSION}\n            pickle.dump(cache, open(self._config.cache_filename, 'wb'))", "response": "Save the addressbook and a timestamp"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef parse_value(named_reg_value):\n    name, value, value_type = named_reg_value\n    value_class = REG_VALUE_TYPE_MAP[value_type]\n    return name, value_class(value)", "response": "Convert the value returned from EnumValue to a name value tuple using the value classes."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget - Get the current user s id", "response": "def get(self, timeout=10):\n        \"\"\"get() -> {'id': 32-byte-md5, 'body': msg-body}\"\"\"\n        req = self.req({'op': 'GET', 'timeout': timeout})\n        if req.status_code != 200:\n            return None\n        result = req.json()\n        if result.get('status') != 'ok':\n            return False\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nspecifying the user data sent to Intercom API", "response": "def get_intercom_data(self):\n        \"\"\"Specify the user data sent to Intercom API\"\"\"\n        return {\n            \"user_id\": self.intercom_id,\n            \"email\": self.email,\n            \"name\": self.get_full_name(),\n            \"last_request_at\": self.last_login.strftime(\"%s\") if self.last_login else \"\",\n            \"created_at\": self.date_joined.strftime(\"%s\"),\n            \"custom_attributes\": {\n                \"is_admin\": self.is_superuser\n            }\n        }"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_list(file,fmt):\n    '''makes a list out of the fmt from the LspOutput f using the format\n       i for int\n       f for float\n       d for double\n       s for string'''\n    out=[]\n    for i in fmt:\n        if i == 'i':\n            out.append(get_int(file));\n        elif i == 'f' or i == 'd':\n            out.append(get_float(file));\n        elif i == 's':\n            out.append(get_str(file));\n        else:\n            raise ValueError(\"Unexpected flag '{}'\".format(i));\n    return out;", "response": "makes a list out of the fmt from the LspOutput f using the format\n       i for int f for float d for double s for string"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the header for the. p4 file", "response": "def get_header(file,**kw):\n    '''gets the header for the .p4 file, note that this\n       Advanced the file position to the end of the header.\n       \n       Returns the size of the header, and the size of the header,\n       if the header keyword is true.\n    '''\n    if type(file) == str:\n        #if called with a filename, recall with opened file.\n        if test(kw, \"gzip\") and kw['gzip'] == 'guess':\n            kw['gzip'] = re.search(r'\\.gz$', file) is not None;\n        if test(kw, \"gzip\"):\n            with gzip.open(file,'rb') as f:\n                return get_header(f,**kw);\n        else:\n            with open(file,'rb') as f:\n                return get_header(f,**kw);\n    if test(kw, \"size\"):\n        size = file.tell();\n    header = get_dict(\n        file,'iiss',\n        ['dump_type','dversion', 'title','revision']);\n    if header['dump_type'] == 1:\n        #this is a particle dump file\n        d = get_dict(file,\n            'fiiii',\n            ['timestamp','geometry','sflagsx','sflagsy','sflagsz']);\n        header.update(d);\n        #reading params\n        \n        header['num_species'] = get_int(file);\n        header['num_particles'] = get_int(file);\n        nparams = get_int(file);\n        units = [get_str(file) for i in range(nparams)];\n        labels = ['q', 'x', 'y', 'z', 'ux', 'uy', 'uz']\n        if nparams == 7:\n            pass;\n        elif nparams == 8 or nparams == 11:\n            labels += ['H']\n        elif nparams == 10 or nparams == 11:\n            labels += ['xi', 'yi', 'zi'];\n        else:\n            raise NotImplementedError(\n                'Not implemented for these number of parameters:{}.'.format(n));\n        header['params'] = list(zip(labels,units));\n    elif header['dump_type'] == 2 or header['dump_type'] == 3:\n        #this is a fields file or a scalars file.\n        d = get_dict(file,'fii',['timestamp','geometry','domains']);\n        header.update(d);\n        #reading quantities\n        n = get_int(file);\n        names=[get_str(file) for i in range(n)];\n        units=[get_str(file) for i in range(n)];\n        header['quantities'] = list(zip(names,units));\n    elif header['dump_type'] == 6:\n        #this is a particle movie file\n        d = get_dict(file,\n            'iiii',\n            ['geometry','sflagsx','sflagsy','sflagsz']);\n        header.update(d);\n        #reading params\n        n = get_int(file);\n        flags=[bool(get_int(file)) for i in range(n)];\n        units=[get_str(file) for i in range(n)];\n        labels=['q','x','y','z','ux','uy','uz','E'];\n        if n == 8:\n            pass;\n        elif n == 7:\n            labels = labels[:-1];\n        elif n == 11:\n            labels+=['xi','yi','zi'];\n        else:\n            raise NotImplementedError(\n                'Not implemented for these number of parameters:{}.'.format(n));\n        header['params'] = [\n            (label,unit) for (label,unit,flag) in zip(labels,units,flags) if flag\n        ];\n    elif header['dump_type'] == 10:\n        #this is a particle extraction file:\n        header['geometry'] = get_int(file);\n        #reading quantities\n        n = get_int(file);\n        header['quantities'] = [get_str(file) for i in range(n)];\n    else:\n        raise ValueError('Unknown dump_type: {}'.format(header['dump_type']));\n    if test(kw,'size'):\n        return header, file.tell()-size;\n    return header;"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef flds_firstsort(d):\n    '''\n    Perform a lexsort and return the sort indices and shape as a tuple.\n    '''\n    shape = [ len( np.unique(d[l]) )\n              for l in ['xs', 'ys', 'zs'] ];\n    si = np.lexsort((d['z'],d['y'],d['x']));\n    return si,shape;", "response": "Perform a lexsort and return the sort indices and shape as a tuple."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef flds_sort(d,s):\n    '''\n    Sort based on position. Sort with s as a tuple of the sort\n    indices and shape from first sort.\n\n    Parameters:\n    -----------\n\n    d   -- the flds/sclr data\n    s   -- (si, shape) sorting and shaping data from firstsort.\n    '''\n    labels = [ key for key in d.keys()\n               if key not in ['t', 'xs', 'ys', 'zs', 'fd', 'sd'] ];\n    si,shape = s;\n    for l in labels:\n        d[l] = d[l][si].reshape(shape);\n        d[l] = np.squeeze(d[l]);\n    return d;", "response": "Sort based on position."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreads an lsp output file and returns a dictionary of data for the next set of fields.", "response": "def read(fname,**kw):\n    '''\n    Reads an lsp output file and returns a raw dump of data,\n    sectioned into quantities either as an dictionary or a typed numpy array.\n\n    Parameters:\n    -----------\n\n    fname -- filename of thing to read\n    \n    Keyword Arguments:\n    ------------------\n\n    vprint   --  Verbose printer. Used in scripts\n    override --  (type, start) => A tuple of a dump type and a place to start\n                 in the passed file, useful to attempting to read semicorrupted\n                 files.\n    gzip     --  Read as a gzip file.\n\n    flds/sclr Specific Arguments:\n    -----------------------------\n    var          -- list of quantities to be read. For fields, this can consist\n                    of strings that include vector components, e.g., 'Ex'. If \n                    None (default), read all quantities.\n    keep_edges   -- If set to truthy, then don't remove the edges from domains before\n                    concatenation and don't reshape the flds data.\n    sort         -- If not None, sort using these indices, useful for avoiding\n                    resorting. If True and not an ndarray, just sort.\n    first_sort   -- If truthy, sort, and return the sort data for future flds\n                    that should have the same shape.\n    keep_xs      -- Keep the xs's, that is, the grid information. Usually redundant\n                    with x,y,z returned.\n    return_array -- If set to truthy, then try to return a numpy array with a dtype.\n                    Requires of course that the quantities have the same shape.\n    '''\n    if test(kw,'gzip') and kw['gzip'] == 'guess':\n        kw['gzip'] = re.search(r'\\.gz$', fname) is not None;\n    openf = gzip.open if test(kw, 'gzip') else open;\n    with openf(fname,'rb') as file:\n        if test(kw,'override'):\n            dump, start = kw['override'];\n            file.seek(start);\n            header = {'dump_type': dump};\n            if not test(kw, 'var') and 2 <= header['dump_type'] <= 3 :\n                raise ValueError(\n                    \"If you want to force to read as a scalar, you need to supply the quantities\"\n                );\n        else:\n            header = get_header(file);\n        vprint = kw['vprint'] if test(kw, 'vprint') else lambda s: None;\n        if 2 <= header['dump_type'] <= 3 :\n            if not test(kw, 'var'):\n                var=[i[0] for i in header['quantities']];\n            else:\n                var=kw['var'];\n            keep_edges = test(kw, 'keep_edges');\n            first_sort = test(kw, 'first_sort');\n            if test(kw,'sort'):\n                sort = kw['sort']\n            else:\n                sort = None;\n            keep_xs = test(kw, 'keep_xs');\n            return_array = test(kw, 'return_array');\n        readers = {\n            1: lambda: read_particles(file, header),\n            2: lambda: read_flds(\n                file,header,var,vprint,\n                keep_edges=keep_edges,\n                first_sort=first_sort,\n                sort=sort,\n                keep_xs=keep_xs,\n                return_array=return_array),\n            3: lambda: read_flds(\n                file,header,var, vprint,\n                keep_edges=keep_edges,\n                first_sort=first_sort,\n                sort=sort,\n                keep_xs=keep_xs,\n                return_array=return_array,\n                vector=False),\n            6: lambda: read_movie(file, header),\n            10:lambda: read_pext(file,header)\n        };\n        \n        try:\n            d = readers[header['dump_type']]();\n        except KeyError:\n            raise NotImplementedError(\"Other file types not implemented yet!\");\n    return d;"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nregistering a command with the server.", "response": "def register(handler,\n             op,\n             safe_init      = None,\n             at_start       = None,\n             name           = None,\n             at_stop        = None,\n             static         = False,\n             root           = None,\n             replacement    = None,\n             charset        = DEFAULT_CHARSET,\n             content_type   = None,\n             to_auth        = False,\n             to_log         = True):\n    \"\"\"\n    Register a command\n    @handler: function to execute when the command is received\n    @op: http method(s)\n    @safe_init: called by the safe_init() function of this module\n    @at_start: called once just before the server starts\n    @at_stop: called once just before the server stops\n    @name: name of the command (if not name, handler.__name__ is used)\n    @static: render static file\n    @root: root path\n    @replacement: rewrite path when name is regexp\n    @charset: charset\n    @content_type: content_type\n    @to_auth: use basic authentification if True\n    @to_log: log request if True\n\n    prototypes:\n        handler(args)\n        safe_init(options)\n        at_start(options)\n        at_stop()\n    \"\"\"\n    ref_cmd = _NCMD\n    is_reg  = False\n\n    if isinstance(name, re._pattern_type):\n        key         = name.pattern\n        ref_cmd     = _RCMD\n        is_reg      = True\n    elif name:\n        key         = name\n        replacement = None\n    else:\n        key         = handler.__name__\n        name        = handler.__name__\n        replacement = None\n\n    methods = []\n\n    if not isinstance(op, (list, tuple)):\n        op = [op.upper()]\n\n    for x in op:\n        x = x.upper()\n        if x not in _METHODS:\n            raise ValueError(\"unknown HTTP method: %r\" % x)\n\n        if static and x not in ('GET', 'HEAD'):\n            raise ValueError(\"Static must be GET, HEAD command\")\n\n        methods.append(x)\n\n    if not methods:\n        raise ValueError(\"Missing HTTP method\")\n\n    if static and not root:\n        raise ValueError(\"Missing root argument for static\")\n\n    cmd = Command(name,\n                  handler,\n                  methods,\n                  safe_init,\n                  at_start,\n                  at_stop,\n                  static,\n                  root,\n                  replacement,\n                  charset,\n                  content_type,\n                  to_auth,\n                  to_log)\n\n    for method in methods:\n        if not is_reg:\n            mkey = \"%s /%s\" % (method, key)\n        else:\n            mkey = \"%s %s\" % (method, key)\n\n        if mkey in _COMMANDS:\n            raise ValueError(\"%s is already registred\" % name)\n        _COMMANDS[mkey] = cmd\n        ref_cmd[mkey]   = _COMMANDS[mkey]"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsignal handler for SIGTERM signal.", "response": "def sigterm_handler(signum, stack_frame):\n    \"\"\"\n    Just tell the server to exit.\n\n    WARNING: There are race conditions, for example with TimeoutSocket.accept.\n    We don't care: the user can just rekill the process after like 1 sec. if\n    the first kill did not work.\n    \"\"\"\n    # pylint: disable-msg=W0613\n    global _KILLED\n\n    for name, cmd in _COMMANDS.iteritems():\n        if cmd.at_stop:\n            LOG.info(\"at_stop: %r\", name)\n            cmd.at_stop()\n\n    _KILLED = True\n\n    if _HTTP_SERVER:\n        _HTTP_SERVER.kill()\n        _HTTP_SERVER.server_close()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef run(options, http_req_handler = HttpReqHandler):\n    # pylint: disable-msg=W0613\n    global _HTTP_SERVER\n\n    for x in ('server_version', 'sys_version'):\n        if _OPTIONS.get(x) is not None:\n            setattr(http_req_handler, x, _OPTIONS[x])\n\n    _HTTP_SERVER = threading_tcp_server.KillableThreadingHTTPServer(\n                       _OPTIONS,\n                       (_OPTIONS['listen_addr'], _OPTIONS['listen_port']),\n                       http_req_handler,\n                       name = \"httpdis\")\n\n    for name, cmd in _COMMANDS.iteritems():\n        if cmd.at_start:\n            LOG.info(\"at_start: %r\", name)\n            cmd.at_start(options)\n\n    LOG.info(\"will now serve\")\n    while not _KILLED:\n        try:\n            _HTTP_SERVER.serve_until_killed()\n        except (socket.error, select.error), why:\n            if errno.EINTR == why[0]:\n                LOG.debug(\"interrupted system call\")\n            elif errno.EBADF == why[0] and _KILLED:\n                LOG.debug(\"server close\")\n            else:\n                raise\n\n    LOG.info(\"exiting\")", "response": "Start and execute the server"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef init(options, use_sigterm_handler=True):\n    # pylint: disable-msg=W0613\n    global _AUTH, _OPTIONS\n\n    if isinstance(options, dict):\n        _OPTIONS = DEFAULT_OPTIONS.copy()\n        _OPTIONS.update(options)\n    else:\n        for optname, optvalue in DEFAULT_OPTIONS.iteritems():\n            if hasattr(options, optname):\n                _OPTIONS[optname] = getattr(options, optname)\n            else:\n                _OPTIONS[optname] = optvalue\n\n    if _OPTIONS['testmethods']:\n        def fortytwo(request):\n            \"test GET method\"\n            return 42\n        def ping(request):\n            \"test POST method\"\n            return request.payload_params()\n        register(fortytwo, 'GET')\n        register(ping, 'POST')\n\n    if _OPTIONS['auth_basic_file']:\n        _AUTH = HttpAuthentication(_OPTIONS['auth_basic_file'],\n                                   realm = _OPTIONS['auth_basic']).parse_file()\n\n    for name, cmd in _COMMANDS.iteritems():\n        if cmd.safe_init:\n            LOG.info(\"safe_init: %r\", name)\n            cmd.safe_init(_OPTIONS)\n\n    if use_sigterm_handler:\n        # signal.signal(signal.SIGHUP, lambda *x: None) # XXX\n        signal.signal(signal.SIGTERM, sigterm_handler)\n        signal.signal(signal.SIGINT, sigterm_handler)", "response": "Initializes the internal state of the internal state of the internal state of the internal state of the internal state of the internal state of the internal state of the internal state of the internal state of the internal state."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nsend a response corresponding to this error to the client", "response": "def report(self, req_handler):\n        \"Send a response corresponding to this error to the client\"\n        if self.exc:\n            req_handler.send_exception(self.code, self.exc, self.headers)\n            return\n\n        text = (self.text\n                or BaseHTTPRequestHandler.responses[self.code][1]\n                or \"Unknown error\")\n\n        getattr(req_handler, \"send_error_%s\" % self.ctype, 'send_error_msg')(self.code, text, self.headers)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nlog the request to the log.", "response": "def log_request(self, code='-', size='-'):\n        \"\"\"\n        Called by send_response()\n        TODO: a configuration option to log or not\n            (maybe using logging filters?)\n        TODO: discriminate by code and dispatch to various log levels\n        \"\"\"\n        LOG.info(\"%r %s %s\", self.requestline, code, size)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsend the response header and log the response code.", "response": "def send_response(self, code, message=None, size='-'):\n        \"\"\"\n        Send the response header and log the response code.\n\n        Also send two standard headers with the server software\n        version and the current date.\n        \"\"\"\n        # pylint: disable-msg=W0221\n        if self._to_log or LOG.isEnabledFor(logging.DEBUG):\n            self.log_request(code, size)\n\n        if message is None:\n            if code in self.responses:\n                message = self.responses[code][0]\n            else:\n                message = ''\n\n        if self.request_version != 'HTTP/0.9':\n            self.wfile.write(\"%s %d %s\\r\\n\" %\n                             (\"HTTP/1.1\", code, message))\n        self.send_header('Server', self.version_string())\n        self.send_header('Date', self.date_time_string())"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef send_error_explain(self, code, message=None, headers=None, content_type=None):\n        \"do not use directly\"\n        if headers is None:\n            headers = {}\n\n        if code in self.responses:\n            if message is None:\n                message = self.responses[code][0]\n\n            explain = self.responses[code][1]\n        else:\n            explain = \"\"\n\n        if message is None:\n            message = \"\"\n\n        if not isinstance(headers, dict):\n            headers = {}\n\n        if not content_type:\n            if self._cmd and self._cmd.content_type:\n                content_type = self._cmd.content_type\n            else:\n                content_type = self._DEFAULT_CONTENT_TYPE\n\n        if self._cmd and self._cmd.charset:\n            charset = self._cmd.charset\n        else:\n            charset = DEFAULT_CHARSET\n\n        headers['Content-type'] = \"%s; charset=%s\" % (content_type, charset)\n\n        data = self._mk_error_explain_data(code, message, explain)\n\n        self.end_response(self.build_response(code, data, headers))", "response": "do not use directly"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef send_error_msgtxt(self, code, message, headers=None):\n        \"text will be in a <pre> bloc\"\n        if headers is None:\n            headers = {}\n\n        if isinstance(message, (list, tuple)):\n            message = ''.join(message)\n        elif isinstance(message, dict):\n            message = repr(message)\n\n        self.send_error_explain(code,\n                                ''.join((\"<pre>\\n\", cgi.escape(message), \"</pre>\\n\")),\n                                headers,\n                                \"text/html\")", "response": "Send an error message to the client."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsends an error response including a backtrace to the client", "response": "def send_exception(self, code, exc_info=None, headers=None):\n        \"send an error response including a backtrace to the client\"\n        if headers is None:\n            headers = {}\n\n        if not exc_info:\n            exc_info = sys.exc_info()\n\n        self.send_error_msg(code,\n                            traceback.format_exception(*exc_info),\n                            headers)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nsend an error to the client. text message is formatted in a json stream", "response": "def send_error_json(self, code, message, headers=None):\n        \"send an error to the client. text message is formatted in a json stream\"\n        if headers is None:\n            headers = {}\n\n        self.end_response(HttpResponseJson(code,\n                                           {'code':    code,\n                                            'message': message},\n                                           headers))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _pathify(self):\n        try:\n            (path,\n             query,\n             self._fragment) = urisup.uri_help_split(self.path)[2:]\n\n            if not path:\n                path = \"/\"\n\n            if path[0] != \"/\":\n                raise urisup.InvalidURIError('path %r does not start with \"/\"' % path)\n\n            self._path = re.sub(\"^/+\", \"/\", path, 1)\n\n            if query:\n                self._query_params = self.querylist_to_dict(query)\n\n            return self._path\n        except urisup.InvalidURIError, e:\n            LOG.error(\"invalid URI: %s\", e)\n            raise self.req_error(400, str(e))", "response": "Transform the path of the current request to the absolute path."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef data_from_query(self, cmd):\n        res  = None\n        ckey = \"%s /%s\" % (self.command, cmd)\n\n        if not isinstance(self._query_params, dict):\n            self._query_params = {}\n\n        if ckey in _NCMD:\n            self._cmd = _NCMD[ckey]\n        else:\n            for key in sorted(_RCMD, key=len, reverse=True):\n                if not key.startswith(\"%s \" % self.command):\n                    continue\n\n                m = _RCMD[key].name.match(cmd)\n                if m:\n                    self._cmd = _RCMD[key]\n                    self._query_params.update(m.groupdict())\n                    break\n\n        try:\n            if not self._cmd:\n                raise self.req_error(404)\n\n            if not self._cmd.to_log:\n                self._to_log = False\n\n            if self._cmd.to_auth:\n                self.authenticate(self._cmd.auth_users)\n\n            if self._cmd.static:\n                if self._cmd.handler:\n                    res = self._cmd.handler(self)\n\n                return self.static_file(cmd, res)\n\n            res = self._cmd.handler(self)\n\n            if not isinstance(res, HttpResponse):\n                return self.response_dumps(res)\n\n            return res\n        finally:\n            self._query_params = {}", "response": "Callback for. execute_command for DELETE GET HEAD requests"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef data_from_payload(self, cmd):\n        multipart = False\n        ckey      = \"%s /%s\" % (self.command, cmd)\n\n        if not isinstance(self._query_params, dict):\n            self._query_params = {}\n\n        if ckey in _NCMD:\n            self._cmd = _NCMD[ckey]\n        else:\n            for key in sorted(_RCMD, key=len, reverse=True):\n                if not key.startswith(\"%s \" % self.command):\n                    continue\n\n                m = _RCMD[key].name.match(cmd)\n                if m:\n                    self._cmd = _RCMD[key]\n                    self._query_params.update(m.groupdict())\n                    break\n\n        try:\n            if not self._cmd:\n                raise self.req_error(404)\n\n            tenc     = self.headers.get('Transfer-Encoding')\n            if tenc and tenc.lower() != 'identity':\n                raise self.req_error(501, \"Not supported; Transfer-Encoding: %s\" % tenc)\n\n            ctype    = self.headers.get('Content-Type')\n            if ctype:\n                ctype = ctype.lower().split(';', 1)[0]\n                if ctype == 'multipart/form-data':\n                    if not self._ALLOWED_MULTIPART_FORM:\n                        raise self.req_error(501, \"Not supported; Content-Type: %s\", ctype)\n                    multipart = True\n                elif self._ALLOWED_CONTENT_TYPES:\n                    ct_found = False\n                    for x in self._ALLOWED_CONTENT_TYPES:\n                        if ctype == x:\n                            ct_found = True\n                            break\n                    if not ct_found:\n                        raise self.req_error(501, \"Not supported; Content-Type: %s\" % ctype)\n\n            try:\n                clen = long(self.headers.get('Content-Length') or 0)\n            except (ValueError, TypeError):\n                raise self.req_error(411)\n\n            if clen < 0:\n                raise self.req_error(411)\n            elif clen > long(_OPTIONS['max_body_size']):\n                raise self.req_error(413)\n\n            if self._cmd.to_auth:\n                self.authenticate(self._cmd.auth_users)\n\n            if clen > 0:\n                payload       = self.rfile.read(clen)\n                self._payload = StringIO(payload)\n\n                if multipart:\n                    try:\n                        self._payload_params = cgi.FieldStorage(environ = {'REQUEST_METHOD': 'POST'},\n                                                                fp      = self._payload,\n                                                                headers = self.headers)\n                    except Exception, e:\n                        raise self.req_error(415, text=str(e))\n                else:\n                    charset = self._cmd.charset or DEFAULT_CHARSET\n\n                    try:\n                        if ctype == 'application/x-www-form-urlencoded':\n                            self._payload_params = urlparse.parse_qsl(payload)\n                        else:\n                            self._payload_params = self.parse_payload(payload, charset)\n                    except ValueError, e:\n                        raise self.req_error(415, text=str(e))\n\n            res = self._cmd.handler(self)\n\n            if not isinstance(res, HttpResponse):\n                return self.response_dumps(res)\n\n            return res\n        finally:\n            payload                 = None\n            self._payload           = None\n            self._payload_params    = None\n            self._query_params      = {}", "response": "This method is used to parse the payload of a single HTTP request."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef common_req(self, execute, send_body=True):\n        \"Common code for GET and POST requests\"\n        self._SERVER            = {'CLIENT_ADDR_HOST': self.client_address[0],\n                                   'CLIENT_ADDR_PORT': self.client_address[1]}\n\n        self._to_log            = True\n        self._cmd               = None\n\n        self._payload           = None\n        self._path              = None\n        self._payload_params    = None\n        self._query_params      = {}\n        self._fragment          = None\n\n        (cmd, res, req)         = (None, None, None)\n\n        try:\n            try:\n                path    = self._pathify() # pylint: disable-msg=W0612\n                cmd     = path[1:]\n                res     = execute(cmd)\n            except HttpReqError, e:\n                e.report(self)\n            except Exception:\n                try:\n                    self.send_exception(500) # XXX 500\n                except Exception: # pylint: disable-msg=W0703\n                    pass\n                raise\n            else:\n                if not isinstance(res, HttpResponse):\n                    req = self.build_response()\n                    if send_body:\n                        req.add_data(res)\n                    req.set_send_body(send_body)\n                else:\n                    req = res\n\n                self.end_response(req)\n        except socket.error, e:\n            if e.errno in (errno.ECONNRESET, errno.EPIPE):\n                return\n            LOG.exception(\"exception - cmd=%r - method=%r\", cmd, self.command)\n        except Exception: # pylint: disable-msg=W0703\n            LOG.exception(\"exception - cmd=%r - method=%r\", cmd, self.command)\n        finally:\n            del req, res", "response": "Common code for GET and POST requests"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate a parser for the base command line.", "response": "def base_parser():\n    \"\"\" Create arguments parser with basic options and no help message.\n\n    * -c, --config: load configuration file.\n    * -v, --verbose: increase logging verbosity. `-v`, `-vv`, and `-vvv`.\n    * -q, --quiet: quiet logging except critical level.\n    * -o, --output: output file. (default=sys.stdout)\n    * --basedir: base directory. (default=os.getcwd)\n    * --input-encoding: input data encoding. (default=utf-8)\n    * --output-encoding: output data encoding. (default=utf-8)\n    * --processes: count of processes.\n    * --chunksize: a number of chunks submitted to the process pool.\n\n    :rtype: :class:`argparse.ArgumentParser`\n    \"\"\"\n    parser = argparse.ArgumentParser(add_help=False)\n\n    parser.add_argument(\"-c\", \"--config\", dest=\"config\",\n                type=argparse.FileType('r'),\n                metavar=\"FILE\",\n                help=\"configuration file\")\n\n    parser.add_argument(\"-o\", \"--output\", dest=\"output\",\n                type=argparse.FileType('w'),\n                metavar=\"FILE\",\n                default=sys.stdout,\n                help=\"output file\")\n\n    parser.add_argument(\"--basedir\", dest=\"basedir\",\n                default=os.getcwd(),\n                help=\"base directory\")\n\n    parser.add_argument(\"--input-encoding\", dest=\"input_encoding\",\n                default=DEFAULT_ENCODING,\n                help=\"encoding of input source\")\n\n    parser.add_argument(\"--output-encoding\", dest=\"output_encoding\",\n                default=DEFAULT_ENCODING,\n                help=\"encoding of output distination\")\n\n    parser.add_argument(\"--processes\", dest=\"processes\", type=int,\n                help=\"number of processes\")\n\n    parser.add_argument(\"--chunksize\", dest=\"chunksize\", type=int,\n                default=1,\n                help=\"number of chunks submitted to the process pool\")\n\n    group = parser.add_mutually_exclusive_group()\n\n    group.add_argument(\"-v\", \"--verbose\", dest=\"verbose\",\n                action=\"count\", default=0,\n                help=\"increase logging verbosity\")\n\n    group.add_argument(\"-q\", \"--quiet\", dest=\"quiet\",\n                default=False, action=\"store_true\",\n                help=\"set logging to quiet mode\")\n\n    return parser"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nparse command line arguments and set basic options.", "response": "def parse_arguments(**kwargs):\n    \"\"\" Parse command line arguments after setting basic options.\n    If successfully parsed, set logging verbosity.\n    This function accepts variable keyword arguments.\n    Their values are passed to :meth:`ArgumentParser.add_argument`.\n    If special keyword `flags` is given, it'll be converted as flag option.\n\n    Examples - multiple files including zero ::\n\n        cliargs = parse_arguments(files=dict(nargs='*'))\n        if cliargs.files:\n            for fp in cliargs.files:\n                print(fp.name)\n\n    Examples - only one file (but property is list of files) ::\n\n        cliargs = parse_arguments(files=dict(nargs=1))\n        fp = cliargs.files[0]\n        print(fp.name)\n\n    Examples - mode switch of defined values ::\n\n        cliargs = parse_arguments(mode=dict(\n                    flags=('-m', '--mode'), required=True,\n                    choices=(\"A\", \"B\", \"C\")))\n        print(cliargs.mode)\n\n    :param kwargs: keywords arguments to pass :meth:`add_argument` method.\n    :rtype: NameSpace object\n    \"\"\"\n    parser = argparse.ArgumentParser(parents=[base_parser(), ])\n\n    for name in kwargs:\n        opts = kwargs[name]\n        if 'flags' in opts:\n            opts['dest'] = name\n            name_or_flags = opts['flags']\n            del opts['flags']\n        else:\n            name_or_flags = name\n        if name == 'files':\n            opts['type'] = argparse.FileType('r')\n            opts['metavar'] = \"FILE\"\n        parser.add_argument(name_or_flags, **opts)\n\n    try:\n        args = parser.parse_args()\n    except IOError:\n        e = sys.exc_info()[1]\n        parser.error(\"File not found: %s\" % (e, ))\n\n    if args.quiet:\n        logging.basicConfig(level=logging.CRITICAL)\n    elif args.verbose >= 3:\n        logging.basicConfig(level=logging.DEBUG)\n        if args.processes:\n            import multiprocessing.util\n            multiprocessing.util.log_to_stderr(logging.DEBUG)\n    elif args.verbose >= 2:\n        logging.basicConfig(level=logging.INFO)\n    elif args.verbose >= 1:\n        logging.basicConfig(level=logging.WARN)\n    else:\n        logging.basicConfig(level=logging.ERROR)\n\n    return args"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef cliconfig(fp, env=None):\n    if fp is None:\n        raise SystemExit('No configuration file is given.')\n    from clitool.config import ConfigLoader\n    loader = ConfigLoader(fp)\n    cfg = loader.load(env)\n    if not fp.closed:\n        fp.close()\n    if not cfg:\n        logging.warn('Configuration may be empty.')\n    return cfg", "response": "Load configuration data.\n    Given pointer is closed internally.\n    If ``None`` is given, force to exit.\n\n    More detailed information is available on underlying feature,\n    :mod:`clitool.config`.\n\n    :param fp: opened file pointer of configuration\n    :type fp: FileType\n    :param env: environment to load\n    :type env: str\n    :rtype: dict"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nhandling stream data on command line interface and return statistics of success error and total amount.", "response": "def clistream(reporter, *args, **kwargs):\n    \"\"\" Handle stream data on command line interface,\n    and returns statistics of success, error, and total amount.\n\n    More detailed information is available on underlying feature,\n    :mod:`clitool.processor`.\n\n    :param Handler: [DEPRECATED] Handler for file-like streams.\n            (default: :class:`clitool.processor.CliHandler`)\n    :type Handler: object which supports `handle` method.\n    :param reporter: callback to report processed value\n    :type reporter: callable\n    :param delimiter: line delimiter [optional]\n    :type delimiter: string\n    :param args: functions to parse each item in the stream.\n    :param kwargs: keywords, including ``files`` and ``input_encoding``.\n    :rtype: list\n    \"\"\"\n    # Follow the rule of `parse_arguments()`\n    files = kwargs.get('files')\n    encoding = kwargs.get('input_encoding', DEFAULT_ENCODING)\n    processes = kwargs.get('processes')\n    chunksize = kwargs.get('chunksize')\n\n    from clitool.processor import CliHandler, Streamer\n    Handler = kwargs.get('Handler')\n    if Handler:\n        warnings.warn('\"Handler\" keyword will be removed from next release.',\n            DeprecationWarning)\n    else:\n        Handler = CliHandler\n    s = Streamer(reporter, processes=processes, *args)\n    handler = Handler(s, kwargs.get('delimiter'))\n\n    return handler.handle(files, encoding, chunksize)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef no_input(self):\n        default = False\n        if self.config is None:\n            return default\n        try:\n            result = self.config.getboolean('zest.releaser', 'no-input')\n        except (NoSectionError, NoOptionError, ValueError):\n            return default\n        return result", "response": "Return whether the user wants to run in no - input mode."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef python_file_with_version(self):\n        default = None\n        if self.config is None:\n            return default\n        try:\n            result = self.config.get('zest.releaser',\n                                     'python-file-with-version')\n        except (NoSectionError, NoOptionError, ValueError):\n            return default\n        return result", "response": "Return Python filename with version marker."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _read_configfile(self):\n        rc = self.config_filename\n        if not os.path.isabs(rc):\n            rc = os.path.join(os.path.expanduser('~'), self.config_filename)\n        # If there is a setup.cfg in the package, parse it\n        files = [f for f in [rc, 'setup.cfg'] if os.path.exists(f)]\n        if not files:\n            self.config = None\n            return\n        self.config = ConfigParser()\n        self.config.read(files)\n        if (not self.is_old_pypi_config() and\n                not self.is_new_pypi_config()):\n            # Safety valve\n            self.config = None", "response": "Read the config file and store it ( when valid"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef distutils_servers(self):\n        if not multiple_pypi_support():\n            return []\n        try:\n            raw_index_servers = self.config.get('distutils', 'index-servers')\n        except (NoSectionError, NoOptionError):\n            return []\n        ignore_servers = ['']\n        if self.is_old_pypi_config():\n            # We have already asked about uploading to pypi using the normal\n            # upload.\n            ignore_servers.append('pypi')\n            # Yes, you can even have an old pypi config with a\n            # [distutils] server list.\n        index_servers = [\n            server.strip() for server in raw_index_servers.split('\\n')\n            if server.strip() not in ignore_servers]\n        return index_servers", "response": "Return a list of distutils servers for collective. dist. a\n           "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndo the user normally want to release this package?", "response": "def want_release(self):\n        \"\"\"Does the user normally want to release this package.\n\n        Some colleagues find it irritating to have to remember to\n        answer the question \"Check out the tag (for tweaks or\n        pypi/distutils server upload)\" with the non-default 'no' when\n        in 99 percent of the cases they just make a release specific\n        for a customer, so they always answer 'no' here.  This is\n        where an extra config option comes in handy: you can influence\n        the default answer so you can just keep hitting 'Enter' until\n        zest.releaser is done.\n\n        Either in your ~/.pypirc or in a setup.cfg in a specific\n        package, add this when you want the default answer to this\n        question to be 'no':\n\n        [zest.releaser]\n        release = no\n\n        The default when this option has not been set is True.\n\n        Standard config rules apply, so you can use upper or lower or\n        mixed case and specify 0, false, no or off for boolean False,\n        and 1, on, true or yes for boolean True.\n        \"\"\"\n        default = True\n        if self.config is None:\n            return default\n        try:\n            result = self.config.getboolean('zest.releaser', 'release')\n        except (NoSectionError, NoOptionError, ValueError):\n            return default\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef transpose_mat44(src_mat, transpose_mat=None):\n\n    if not transpose_mat:\n        transpose_mat = Matrix44()\n\n    for i in range(4):\n        for j in range(4):\n            transpose_mat.data[i][j] = src_mat.data[j][i]\n\n    return transpose_mat", "response": "Create a transpose of a matrix."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef is_affine_mat44(mat):\n\n    # Ensure scale is uniform\n    if not (mat.data[0][0] == mat.data[1][1] == mat.data[2][2]):\n        return False\n\n    # Ensure row [3] is 0, 0, 0, 1\n    return (mat.data[0][3] == 0 and\n            mat.data[1][3] == 0 and\n            mat.data[2][3] == 0 and\n            mat.data[3][3] == 1)", "response": "Return True if only tranlsate rotate and uniform scale components."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ninvert the affine matrix.", "response": "def invert_affine_mat44(mat):\n    \"\"\"Assumes there is only rotate, translate, and uniform scale componenets\n    to the matrix.\n    \"\"\"\n\n    inverted = Matrix44()\n\n    # Transpose the 3x3 rotation component\n    for i in range(3):\n        for j in range(3):\n            inverted.data[i][j] = mat.data[j][i]\n\n    # Set translation: inverted_trans_vec3 = -inv(rot_mat33) * trans_vec3\n    for row in range(3):\n        inverted.data[3][row] = (\n            -inverted.data[0][row] * mat.data[3][0] +\n            -inverted.data[1][row] * mat.data[3][1] +\n            -inverted.data[2][row] * mat.data[3][2])\n\n    return inverted"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef almost_equal(self, mat2, places=7):\n\n        if not hasattr(mat2, \"data\"):\n            return False\n\n        for i in range(4):\n            if not (_float_almost_equal(self.data[i][0],\n                                        mat2.data[i][0], places) and\n                    _float_almost_equal(self.data[i][1],\n                                        mat2.data[i][1], places) and\n                    _float_almost_equal(self.data[i][2],\n                                        mat2.data[i][2], places) and\n                    _float_almost_equal(self.data[i][3],\n                                        mat2.data[i][3], places)):\n                return False\n\n        return True", "response": "Return True if the values in mat2 are almost equal."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef rot_from_vectors(start_vec, end_vec):\n\n        dot = start_vec.dot(end_vec)\n        # TODO: check if dot is a valid number\n        angle = math.acos(dot)\n        # TODO: check if angle is a valid number\n        cross = start_vec.cross(end_vec)\n        cross.normalize\n        rot_matrix = Matrix44.from_axis_angle(cross, angle)\n\n        # TODO: catch exception and return identity for invalid numbers\n        return rot_matrix", "response": "Return the rotation matrix to rotate from one vector to another."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_trans(self, out_vec=None):\n\n        if out_vec:\n            return out_vec.set(*self.data[3][:3])\n\n        return Vec3(*self.data[3][:3])", "response": "Return the translation portion of the matrix as a vector."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets the translation components of the matrix.", "response": "def set_trans(self, trans_vec):\n        \"\"\"Set the translation components of the matrix.\"\"\"\n\n        # Column major,  translation components in column 3.\n        self.data[3][0] = trans_vec[0]\n        self.data[3][1] = trans_vec[1]\n        self.data[3][2] = trans_vec[2]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef is_running(self):\n        pp = self.pid\n        if pp:\n            try:\n                proc = psutil.Process(pp)\n\n                # Possible status:\n                # \"STATUS_RUNNING\", \"STATUS_IDLE\",\n                # \"STATUS_SLEEPING\", \"STATUS_DISK_SLEEP\",\n                # \"STATUS_STOPPED\", \"STATUS_TRACING_STOP\",\n                # \"STATUS_ZOMBIE\", \"STATUS_DEAD\",\n                # \"STATUS_WAKING\", \"STATUS_LOCKED\",\n\n                if proc.status in (psutil.STATUS_STOPPED,\n                                   psutil.STATUS_DEAD,\n                                   psutil.STATUS_ZOMBIE):\n                    # The PID is still in the process table so call stop to\n                    # remove the PID.\n                    self.stop()\n                    return False\n                else:\n                    # OK, it's running.\n                    return True\n\n            except psutil.NoSuchProcess:\n                pass\n        return False", "response": "Returns True if the subprocess is running."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef pid(self):\n        pf = self.path('cmd.pid')\n        if not os.path.exists(pf):\n            return None\n        with open(pf, 'r') as f:\n            return int(f.read())", "response": "Returns the integer PID of the subprocess or None if the subprocess is not running."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nstopping the subprocess. Keyword Arguments **timeout** Time in seconds to wait for a process and its children to exit.", "response": "def stop(self, timeout=15):\n        \"\"\"Stop the subprocess.\n\n        Keyword Arguments\n\n        **timeout**\n          Time in seconds to wait for a process and its\n          children to exit.\n        \"\"\"\n        pp = self.pid\n        if pp:\n            try:\n                kill_process_nicely(pp, timeout=timeout)\n            except psutil.NoSuchProcess:\n                pass"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a query to filter by type.", "response": "def query_get_kb_by_type(kbtype):\n    \"\"\"Return a query to filter kb by type.\n\n    :param kbtype: type to filter (e.g: taxonomy)\n    :return: query to filter kb\n    \"\"\"\n    return models.KnwKB.query.filter_by(\n        kbtype=models.KnwKB.KNWKB_TYPES[kbtype])"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef query_kb_mappings(kbid, sortby=\"to\", key=\"\", value=\"\",\n                      match_type=\"s\"):\n    \"\"\"Return a list of all mappings from the given kb, ordered by key.\n\n    If key given, give only those with left side (mapFrom) = key.\n    If value given, give only those with right side (mapTo) = value.\n\n    :param kb_name: knowledge base name. if \"\", return all\n    :param sortby: the sorting criteria ('from' or 'to')\n    :param key: return only entries where key matches this\n    :param value: return only entries where value matches this\n    :param match_type: s=substring, e=exact, sw=startswith\n    \"\"\"\n    return models.KnwKBRVAL.query_kb_mappings(kbid, sortby, key,\n                                              value, match_type)", "response": "Query the given kb for all mappings."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_kb_mappings(kb_name=\"\", key=\"\", value=\"\", match_type=\"s\", sortby=\"to\",\n                    limit=None):\n    \"\"\"Return a list of all mappings from the given kb, ordered by key.\n\n    If key given, give only those with left side (mapFrom) = key.\n    If value given, give only those with right side (mapTo) = value.\n\n    :param kb_name: knowledge base name. if \"\", return all\n    :param sortby: the sorting criteria ('from' or 'to')\n    :param key: return only entries where key matches this\n    :param value: return only entries where value matches this\n    :param limit: return only X number of entries\n    :return: list of knowledge converted in dictionary\n    \"\"\"\n    # query\n    query = db.session.query(models.KnwKBRVAL).join(models.KnwKB)\n    # filter\n    if kb_name:\n        query = query.filter(models.KnwKB.name == kb_name)\n    if len(key) > 0:\n        if match_type == \"s\":\n            key = \"%\"+key+\"%\"\n    else:\n        key = '%'\n    if len(value) > 0:\n        if match_type == \"s\":\n            value = \"%\"+value+\"%\"\n    else:\n        value = '%'\n    query = query.filter(\n        models.KnwKBRVAL.m_key.like(key),\n        models.KnwKBRVAL.m_value.like(value))\n    # order by\n    if sortby == \"from\":\n        query = query.order_by(models.KnwKBRVAL.m_key)\n    else:\n        query = query.order_by(models.KnwKBRVAL.m_value)\n    if limit:\n        query = query.limit(limit)\n    # return results\n    return [kbv.to_dict() for (kbv) in query.all()]", "response": "Return a list of all mappings from the given kb ordered by key."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets one unique mapping. If not found return default.", "response": "def get_kb_mapping(kb_name=\"\", key=\"\", value=\"\", match_type=\"e\", default=\"\",\n                   limit=None):\n    \"\"\"Get one unique mapping. If not found, return default.\n\n    :param kb_name: the name of the kb\n    :param key: include only lines matching this on left side in the results\n    :param value: include only lines matching this on right side in the results\n    :param match_type: s = substring match, e = exact match\n    :param default: default value if no mapping is found\n    :return: a mapping\n    \"\"\"\n    mappings = get_kb_mappings(kb_name, key=key, value=value,\n                               match_type=match_type, limit=limit)\n\n    if len(mappings) == 0:\n        return default\n    else:\n        return mappings[0]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd a new mapping to the given kb.", "response": "def add_kb_mapping(kb_name, key, value=\"\"):\n    \"\"\"Add a new mapping to given kb.\n\n    :param kb_name: the name of the kb where to insert the new value\n    :param key: the key of the mapping\n    :param value: the value of the mapping\n    \"\"\"\n    kb = get_kb_by_name(kb_name)\n    if key in kb.kbrvals:\n        # update\n        kb.kbrvals[key].m_value = value\n    else:\n        # insert\n        kb.kbrvals.set(models.KnwKBRVAL(m_key=key, m_value=value))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef update_kb_mapping(kb_name, old_key, key, value):\n    db.session.query(models.KnwKBRVAL).join(models.KnwKB) \\\n        .filter(models.KnwKB.name == kb_name,\n                models.KnwKBRVAL.m_key == old_key) \\\n        .update({\"m_key\": key, \"m_value\": value}, synchronize_session=False)", "response": "Update an existing kb mapping with key old_key with a new key and value."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget leftside or rightside mappings from kb kb_name formatted as json dict.", "response": "def get_kb_mappings_json(kb_name=\"\", key=\"\", value=\"\", match_type=\"s\",\n                         limit=None):\n    \"\"\"Get leftside/rightside mappings from kb kb_name formatted as json dict.\n\n    If key given, give only those with left side (mapFrom) = key.\n    If value given, give only those with right side (mapTo) = value.\n\n    :param kb_name: the name of the kb\n    :param key: include only lines matching this on left side in the results\n    :param value: include only lines matching this on right side in the results\n    :param match_type: s = substring match, e = exact match\n    :param limit: maximum number of results to return (are ALL if set to None)\n    :return: a list of mappings\n    \"\"\"\n    mappings = get_kb_mappings(kb_name, key, value, match_type)\n    ret = []\n    if limit is None:\n        limit = len(mappings)\n    for m in mappings[:limit]:\n        label = m['value'] or m['key']\n        value = m['key'] or m['value']\n        ret.append({'label': label, 'value': value})\n    return json.dumps(ret)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nupdates the kb name with a new name and new description.", "response": "def update_kb_attributes(kb_name, new_name, new_description=''):\n    \"\"\"Update kb kb_name with a new name and (optionally) description.\n\n    :param kb_name: the name of the kb to update\n    :param new_name: the new name for the kb\n    :param new_description: the new description for the kb\n    \"\"\"\n    models.KnwKB.query.filter_by(name=kb_name) \\\n        .update({\"name\": new_name, \"description\": new_description})"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nadd a new kb in database and return the id.", "response": "def add_kb(kb_name=u\"Untitled\", kb_type=None, tries=10):\n    \"\"\"Add a new kb in database, return the id.\n\n    Add a new kb in database, and returns its id\n    The name of the kb will be 'Untitled#'\n    such that it is unique.\n\n    :param kb_name: the name of the kb\n    :param kb_type: the type of the kb, incl 'taxonomy' and 'dynamic'.\n                   None for typical (leftside-rightside).\n    :param tries: exit after <n> retry\n    :return: the id of the newly created kb\n    \"\"\"\n    created = False\n    name = kb_name\n    i = 0\n    while(i < tries and created is False):\n        try:\n            kb = models.KnwKB(name=name, description=\"\", kbtype=kb_type)\n            created = True\n            db.session.add(kb)\n            db.session.commit()\n        except IntegrityError:\n            db.session.rollback()\n            # get the highest id to calculate the new name\n            result = db.session.execute(\n                db.select([models.KnwKB.id])\n                .order_by(db.desc(models.KnwKB.id))\n                .limit(1)).first()\n            index = result[0] + 1 if result is not None else 1\n            name = kb_name + \" \" + str(index)\n            i = i + 1\n            created = False\n        except Exception:\n            db.session.rollback()\n            raise\n\n    if created is False:\n        # TODO raise the right exception\n        raise Exception(_(\"Can't create knowledge base \\\"%(name)s\\\".\\n\"\n                          \"Probabily the server is busy! \"\n                          \"Try again later.\", name=kb_name))\n\n    return kb.id"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add_dynamic_kb(kbname, tag, collection=\"\", searchwith=\"\"):\n    kb_id = add_kb(kb_name=kbname, kb_type='dynamic')\n    save_kb_dyn_config(kb_id, tag, searchwith, collection)\n    return kb_id", "response": "A convenience method to add a dynamic kb."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef save_kb_dyn_config(kb_id, field, expression, collection=None):\n    # check that collection exists\n    if collection:\n        collection = Collection.query.filter_by(name=collection).one()\n\n    kb = get_kb_by_id(kb_id)\n    kb.set_dyn_config(field, expression, collection)", "response": "Save a dynamic knowledge base configuration."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef kb_mapping_exists(kb_name, key):\n    try:\n        kb = get_kb_by_name(kb_name)\n    except NoResultFound:\n        return False\n    return key in kb.kbrvals", "response": "Return the information if a mapping exists."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndeleting given kb from database.", "response": "def delete_kb(kb_name):\n    \"\"\"Delete given kb from database.\n\n    :param kb_name: knowledge base name\n    \"\"\"\n    db.session.delete(models.KnwKB.query.filter_by(\n        name=kb_name).one())"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a list of all the KnwKBs of the given type and name.", "response": "def get_kbs_info(kbtype=\"\", searchkbname=\"\"):\n    \"\"\"A convenience method.\n\n    :param kbtype: type of kb -- get only kb's of this type\n    :param searchkbname: get only kb's where this sting appears in the name\n    \"\"\"\n    # query + order by\n    query = models.KnwKB.query.order_by(\n        models.KnwKB.name)\n    # filters\n    if kbtype:\n        query = query.filter_by(kbtype=kbtype)\n    if searchkbname:\n        query = query.filter_by(name=searchkbname)\n\n    return [row.to_dict() for row in query.all()]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_kba_values(kb_name, searchname=\"\", searchtype=\"s\"):\n    if searchtype == 's' and searchname:\n        searchname = '%'+searchname+'%'\n    if searchtype == 'sw' and searchname:  # startswith\n        searchname = searchname+'%'\n\n    if not searchname:\n        searchname = '%'\n\n    query = db.session.query(models.KnwKBRVAL).join(models.KnwKB) \\\n        .filter(models.KnwKBRVAL.m_value.like(searchname),\n                models.KnwKB.name.like(kb_name))\n\n    return [(k.m_value,) for k in query.all()]", "response": "Return an array of values for authority file type"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn an array of keys.", "response": "def get_kbr_keys(kb_name, searchkey=\"\", searchvalue=\"\", searchtype='s'):\n    \"\"\"Return an array of keys.\n\n    :param kb_name: the name of the knowledge base\n    :param searchkey: search using this key\n    :param searchvalue: search using this value\n    :param searchtype: s = substring, e=exact\n    \"\"\"\n    if searchtype == 's' and searchkey:\n        searchkey = '%'+searchkey+'%'\n    if searchtype == 's' and searchvalue:\n        searchvalue = '%'+searchvalue+'%'\n    if searchtype == 'sw' and searchvalue:  # startswith\n        searchvalue = searchvalue+'%'\n    if not searchvalue:\n        searchvalue = '%'\n    if not searchkey:\n        searchkey = '%'\n\n    query = db.session.query(models.KnwKBRVAL).join(models.KnwKB) \\\n        .filter(models.KnwKBRVAL.m_key.like(searchkey),\n                models.KnwKBRVAL.m_value.like(searchvalue),\n                models.KnwKB.name.like(kb_name))\n\n    return [(k.m_key,) for k in query.all()]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_kbr_values(kb_name, searchkey=\"\", searchvalue=\"\", searchtype='s',\n                   use_memoise=False):\n    \"\"\"Return a tuple of values from key-value mapping kb.\n\n    :param kb_name:     the name of the knowledge base\n    :param searchkey:   search using this key\n    :param searchvalue: search using this value\n    :param searchtype:  s=substring; e=exact\n    :param use_memoise: can we memoise while doing lookups?\n    :type use_memoise:  bool\n    \"\"\"\n    try:\n        if use_memoise:\n            kb = get_kb_by_name_memoised(kb_name)\n        else:\n            kb = get_kb_by_name(kb_name)\n    except NoResultFound:\n        return []\n    return list(kb.get_kbr_values(searchkey, searchvalue, searchtype))", "response": "Return a tuple of values from key - value mapping kb."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a list of dictionaries that match the search.", "response": "def get_kbr_items(kb_name, searchkey=\"\", searchvalue=\"\", searchtype='s'):\n    \"\"\"Return a list of dictionaries that match the search.\n\n    :param kb_name: the name of the knowledge base\n    :param searchkey: search using this key\n    :param searchvalue: search using this value\n    :param searchtype: s = substring, e=exact\n    :return: a list of dictionaries [{'key'=>x, 'value'=>y},..]\n    \"\"\"\n    kb = get_kb_by_name(kb_name)\n    return kb.get_kbr_items(searchkey, searchvalue, searchtype)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_kbd_values(kbname, searchwith=\"\"):\n    kb = get_kb_by_name(kbname)\n    kbid = kb.id\n    if not kbid:\n        return []\n    kbtype = kb.kbtype\n    if not kbtype:\n        return []\n    if kbtype != 'd':\n        return []\n    return get_kbd_values_by_def(kb.kbdefs.to_dict(), searchwith)", "response": "Return a list of values by searching a dynamic kb."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_kbd_values_by_def(confdict, searchwith=\"\"):\n    from invenio_search.api import Query\n\n    # get the configuration so that we see what the field is\n    if not confdict:\n        return []\n    if 'field' not in confdict:\n        return []\n    field = confdict['field']\n    expression = confdict['expression']\n    collection = \"\"\n    if 'collection' in confdict:\n        collection = confdict['collection']\n    if searchwith and expression:\n        if (expression.count('%') > 0):\n            expression = expression.replace(\"%\", searchwith)\n            response = Query(expression).search(collection=collection)\n        else:\n            # no %.. just make a combination\n            expression = expression + \" and \" + searchwith\n            response = Query(expression).search(collection=collection)\n    else:  # either no expr or no searchwith.. but never mind about searchwith\n        if expression:  # in this case: only expression\n            response = Query(expression).search(collection=collection)\n        else:\n            # make a fake expression so that only records that have this field\n            # will be returned\n            fake_exp = \"/.*/\"\n            if searchwith:\n                fake_exp = searchwith\n            response = Query(\"{0}:{1}\".format(field, fake_exp)).search(\n                collection=collection\n            )\n\n    # TODO wait for new search API for pagination\n    response.body[\"size\"] = 9999999\n    values = []\n    for record in response.records():\n        value = record.get(field)\n        if value:\n            values.append(value)\n    return values", "response": "Return a list of values by searching a dynamic kb."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_kbd_values_json(kbname, searchwith=\"\"):\n    res = get_kbd_values(kbname, searchwith)\n    return json.dumps(res)", "response": "Return values from searching a dynamic kb as a json - formatted string."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_kbt_items(taxonomyfilename, templatefilename, searchwith=\"\"):\n    if processor_type == 1:\n        # lxml\n        doc = etree.XML(taxonomyfilename)\n        styledoc = etree.XML(templatefilename)\n        style = etree.XSLT(styledoc)\n        result = style(doc)\n        strres = str(result)\n        del result\n        del style\n        del styledoc\n        del doc\n    elif processor_type == 2:\n        # libxml2 & libxslt\n        styledoc = libxml2.parseFile(templatefilename)\n        style = libxslt.parseStylesheetDoc(styledoc)\n        doc = libxml2.parseFile(taxonomyfilename)\n        result = style.applyStylesheet(doc, None)\n        strres = style.saveResultToString(result)\n        style.freeStylesheet()\n        doc.freeDoc()\n        result.freeDoc()\n    else:\n        # no xml parser found\n        strres = \"\"\n\n    ritems = []\n    if len(strres) == 0:\n        return []\n    else:\n        lines = strres.split(\"\\n\")\n        for line in lines:\n            if searchwith:\n                if line.count(searchwith) > 0:\n                    ritems.append(line)\n            else:\n                if len(line) > 0:\n                    ritems.append(line)\n\n    return ritems", "response": "Get items from taxonomy file using a templatefile."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef to_timestamp(dt):\n    if isinstance(dt, int):\n        return dt\n    return int(total_seconds(dt.replace(tzinfo=None) -\n               datetime.datetime(1970, 1, 1)))", "response": "Convert a datetime object to a unix timestamp."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nfetches a new token using the supplied code.", "response": "def fetch_token(self, **kwargs):\n        \"\"\"Fetch a new token using the supplied code.\n\n        :param str code: A previously obtained auth code.\n\n        \"\"\"\n        if 'client_secret' not in kwargs:\n            kwargs.update(client_secret=self.client_secret)\n        return self.session.fetch_token(token_url, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nrefresh the authentication token.", "response": "def refresh_token(self, **kwargs):\n        \"\"\"Refresh the authentication token.\n\n        :param str refresh_token: The refresh token to use. May be empty if\n                                  retrieved with ``fetch_token``.\n\n        \"\"\"\n        if 'client_secret' not in kwargs:\n            kwargs.update(client_secret=self.client_secret)\n        if 'client_id' not in kwargs:\n            kwargs.update(client_id=self.client_id)\n        return self.session.refresh_token(token_url, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the activity with the given id.", "response": "def get_activity(self, id_num):\n        \"\"\"Return the activity with the given id.\n\n        Note that this contains more detailed information than returned\n        by `get_activities`.\n\n        \"\"\"\n        url = self._build_url('my', 'activities', id_num)\n        return self._json(url)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\niterates over all activities from newest to oldest.", "response": "def get_activities(self, count=10, since=None, style='summary',\n                       limit=None):\n        \"\"\"Iterate over all activities, from newest to oldest.\n\n        :param count: The number of results to retrieve per page. If set to\n                      ``None``, pagination is disabled.\n\n        :param since: Return only activities since this date. Can be either\n                      a timestamp or a datetime object.\n\n        :param style: The type of records to return. May be one of\n                      'summary', 'briefs', 'ids', or 'extended'.\n\n        :param limit: The maximum number of activities to return for the given\n                      query.\n\n        \"\"\"\n        params = {}\n        if since:\n            params.update(fromDate=to_timestamp(since))\n        parts = ['my', 'activities', 'search']\n        if style != 'summary':\n            parts.append(style)\n        url = self._build_url(*parts)\n        # TODO: return an Activity (or ActivitySummary?) class that can do\n        # things like convert date and time fields to proper datetime objects\n        return islice(self._iter(url, count, **params), limit)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the notables of the activity with the given id.", "response": "def get_notables(self, id_num):\n        \"\"\"Return the notables of the activity with the given id.\n        \"\"\"\n        url = self._build_url('my', 'activities', id_num, 'notables')\n        return self._json(url)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_polyline(self, id_num, style='google'):\n        parts = ['my', 'activities', id_num, 'polyline']\n        if style != 'google':\n            parts.append(style)\n        url = self._build_url(*parts)\n\n        return self._json(url)", "response": "Get the polyline of the activity with the given id."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_splits(self, id_num, unit='mi'):\n        url = self._build_url('my', 'activities', id_num, 'splits', unit)\n\n        return self._json(url)", "response": "Get the splits of the activity with the given id."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_stats(self, year=None, month=None):\n        parts = ['my', 'stats']\n        if month and not year:\n            raise ValueError(\"month cannot be specified without year\")\n        if year:\n            parts.append(year)\n        if month:\n            parts.append(year)\n        url = self._build_url(*parts)\n        return self._json(url)", "response": "Return stats for the given year and month."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef create_weight(self, weight, date=None):\n        url = self._build_url('my', 'body', 'weight')\n        data = {'weightInKilograms': weight}\n        if date:\n            if not date.is_aware():\n                raise ValueError(\"provided date is not timezone aware\")\n            data.update(date=date.isoformat())\n        headers = {'Content-Type': 'application/json; charset=utf8'}\n        r = self.session.post(url, data=json.dumps(data), headers=headers)\n        r.raise_for_status()\n        return r", "response": "Submit a new weight record."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef create_activity(self, data):\n        url = self._build_url('my', 'activities')\n        if isinstance(data, dict):\n            data = json.dumps(data)\n        r = self.session.post(url, data=data)\n        r.raise_for_status()\n        return r", "response": "Create a new activity."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nupdate an existing activity.", "response": "def update_activity(self, id_num, data):\n        \"\"\"Update an existing activity (run).\n\n        :param id_num: The activity ID to update\n        :param data: The data representing the activity you want to upload.\n                     May be either JSON, GPX, or TCX.\n\n        \"\"\"\n        url = self._build_url('my', 'activities')\n        if isinstance(data, dict):\n            data = json.dumps(data)\n        r = self.session.put(url, data=data)\n        r.raise_for_status()\n        return r"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndeletes an activity (run). :param id_num: The activity ID to delete", "response": "def delete_activity(self, id_num):\n        \"\"\"Delete an activity (run).\n\n        :param id_num: The activity ID to delete\n\n\n        \"\"\"\n        url = self._build_url('my', 'activities', id_num)\n        r = self.session.delete(url)\n        r.raise_for_status()\n        return r"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nprints start/title/end info before and after the function call Args: title: title will show after the start, if has any", "response": "def as_session(name_or_func):  # decorator\n    \"\"\"print start/title/end info before and after the function call\n\n    Args:\n        title: title will show after the start, if has any\n    \"\"\"\n    if callable(name_or_func):  # no name provided\n        func = name_or_func\n        name = func.__name__\n        name = \"\".join([(' ' + x) if x.isupper() else x for x in name])\n        name = name.replace('_', ' ')\n        return as_session(name)(func)  # deco(func) -> deco(name)(func)\n    else:\n        name = name_or_func\n\n    def get_func(func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            start()\n            title(name)\n            result = func(*args, **kwargs)\n            end()\n            return result\n        return wrapper\n    return get_func"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef title(msg, **options):\n    return echo(Style.BRIGHT + Fore.CYAN + \"__{}__________________________\".format(msg.upper().strip()) + Style.RESET_ALL + Fore.RESET, **options)", "response": "print something like a title"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef allow_origin_tween_factory(handler, registry):\n    def allow_origin_tween(request):\n        settings = request.registry.settings\n        request_origin = request.headers.get('origin')\n\n        def is_origin_allowed(origin):\n            allowed_origins = (\n                request.registry.settings.get('api.allowed_origins', [])\n            )\n            if isinstance(allowed_origins, str):\n                allowed_origins = allowed_origins.splitlines()\n            if not origin:\n                return False\n            for allowed_origin in allowed_origins:\n                if origin.lower().startswith(allowed_origin):\n                    return True\n            return False\n\n        def allow_origin_callback(request, response):\n            \"\"\"Set access-control-allow-origin et. al headers\n\n            \"\"\"\n            allowed_methods = settings.get(\n                'api.allowed_methods',\n                str('GET, POST, PUT, DELETE, PATCH, OPTIONS'),\n            )\n            if callable(allowed_methods):\n                allowed_methods = allowed_methods(request)\n\n            allowed_headers = settings.get(\n                'api.allowed_headers',\n                str('Content-Type, Authorization, Range'),\n            )\n            if callable(allowed_headers):\n                allowed_headers = allowed_headers(request)\n\n            allowed_credentials = settings.get(\n                'api.allowed_credentials',\n                str('true'),\n            )\n            if callable(allowed_credentials):\n                allowed_credentials = allowed_credentials(request)\n\n            response.headers['Access-Control-Allow-Origin'] = request_origin\n            if allowed_credentials:\n                response.headers[str('Access-Control-Allow-Credentials')] = \\\n                    str(allowed_credentials)\n            if allowed_methods:\n                response.headers[str('Access-Control-Allow-Methods')] = str(\n                    allowed_methods,\n                )\n            if allowed_headers:\n                response.headers[str('Access-Control-Allow-Headers')] = str(\n                    allowed_headers,\n                )\n\n        if not is_origin_allowed(request_origin):\n            return handler(request)\n\n        request.add_response_callback(allow_origin_callback)\n        return handler(request)\n    return allow_origin_tween", "response": "Allow cross origin XHR requests and return a function that can be used to handle the response."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef grant(self, source_cidr):\n        self.manager.api.secgroup_rules.create(self.id, source_cidr)", "response": "Allows connections from a source IP range to be granted."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create(self, dbsecgroup_id, source_cidr, port=3306):\n        body = {\n                \"security_group_rule\": {\n                    \"security_group_id\": dbsecgroup_id,\n                    \"cidr\": source_cidr,\n                    \"from_port\": port,\n                    \"to_port\": port,\n                    }\n                }\n        return self._create(\"/security-group-rules\", body,\n                \"security_group_rule\")", "response": "Creates a security group rule."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef main(filename1, filename2, recursive=False, backup=False,\n         suffix='~', *other_filenames):\n    '''An example copy script with some example parameters that might\n    be used in a file or directory copy command.\n\n    :param recursive: -r --recursive copy directories\n        recursively\n    :param backup: -b --backup backup any files you copy over\n    :param suffix: -S --suffix override the usual backup\n        suffix '''\n    filenames = [filename1, filename2] + list(other_filenames)\n    destination = filenames.pop()\n\n    print(\"You asked to move %s to %s\" % (filenames, destination))\n    if recursive:\n        print(\"You asked to copy directories recursively.\")\n    if backup:\n        print(\"You asked to backup any overwritten files.\")\n        print(\"You would use the suffix %s\" % suffix)", "response": "An example copy script with some example parameters that might be used in a file or directory copy command."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef parse_date(my_date):\n        if isinstance(my_date, datetime.datetime):\n            result = my_date\n        elif isinstance(my_date, str):\n            result = datetime.datetime.strptime(my_date, '%Y-%m-%dT%H:%M:%SZ')\n        else:\n            raise ValueError('Unexpected date format for \"%s\" of type \"%s\"' % (\n                str(my_date), type(my_date)))\n        assert result.tzinfo is None, 'Unexpected tzinfo for date %s' % (\n            result)\n        return result", "response": "A function to parse a date into canonical format of datetime. datetime."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_thread_info(self, enforce_re=True, latest_date=None):\n        result = []\n        my_re = re.compile(self.topic_re)\n        url = '%s/issues?sort=updated' % (self.base_url)\n        latest_date = self.parse_date(latest_date) if latest_date else None\n        while url:\n            kwargs = {} if not self.gh_info.user else {'auth': (\n                self.gh_info.user, self.gh_info.token)}\n            my_req = requests.get(url, params=self.params, **kwargs)\n            my_json = my_req.json()\n            for item in my_json:\n                if (not enforce_re) or my_re.search(item['title']):\n                    idate = self.parse_date(item['updated_at'])\n                    if (latest_date is not None and idate > latest_date):\n                        logging.debug('Skip %s since updated at %s > %s',\n                                      item['title'], idate, latest_date)\n                        continue\n                    result.append(item)\n                    if self.max_threads is not None and len(\n                            result) >= self.max_threads:\n                        logging.debug('Stopping after max_threads=%i threads.',\n                                      len(result))\n                        return result\n            url = None\n            if 'link' in my_req.headers:\n                link = my_req.headers['link'].split(',')\n                for thing in link:\n                    potential_url, part = thing.split('; ')\n                    if part == 'rel=\"next\"':\n                        url = potential_url.lstrip(' <').rstrip('> ')\n\n        return result", "response": "This method returns a json list with information about threads in the group."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef export(self, out_filename):\n        with zipfile.ZipFile(out_filename, 'w', zipfile.ZIP_DEFLATED) as arc:\n            id_list = list(self.get_thread_info())\n            for num, my_info in enumerate(id_list):\n                logging.info('Working on item %i : %s', num, my_info['number'])\n                my_thread = GitHubCommentThread(\n                    self.gh_info.owner, self.gh_info.realm, my_info['title'],\n                    self.gh_info.user, self.gh_info.token,\n                    thread_id=my_info['number'])\n                csec = my_thread.get_comment_section()\n                cdict = [item.to_dict() for item in csec.comments]\n                my_json = json.dumps(cdict)\n                arc.writestr('%i__%s' % (my_info['number'], my_info['title']),\n                             my_json)", "response": "Export the desired threads as a zipfile to out_filename."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsleep a little if hit github recently to honor rate limit.", "response": "def sleep_if_necessary(cls, user, token, endpoint='search', msg=''):\n        \"\"\"Sleep a little if hit github recently to honor rate limit.\n        \"\"\"\n        my_kw = {'auth': (user, token)} if user else {}\n        info = requests.get('https://api.github.com/rate_limit', **my_kw)\n        info_dict = info.json()\n        remaining = info_dict['resources'][endpoint]['remaining']\n        logging.debug('Search remaining on github is at %s', remaining)\n\n        if remaining <= 5:\n            sleep_time = 120\n        else:\n            sleep_time = 0\n        if sleep_time:\n            logging.warning('Sleep %i since github requests remaining  = %i%s',\n                            sleep_time, remaining, msg)\n            time.sleep(sleep_time)\n            return True\n\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef update_cache_key(cls, cache_key, item=None):\n        contents = cls.__thread_id_cache.get(cache_key, None)\n        if item is not None:\n            cls.__thread_id_cache[cache_key] = item\n\n        return contents", "response": "Update cache key with item."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef lookup_thread_id(self):\n\n        query_string = 'in:title \"%s\" repo:%s/%s' % (\n            self.topic, self.owner, self.realm)\n        cache_key = (self.owner, self.realm, self.topic)\n        result = self.lookup_cache_key(cache_key)\n        if result is not None:\n            my_req = self.raw_pull(result)\n            if my_req.status_code != 200:\n                result = None  # Cached item was no good\n            elif my_req.json()['title'] != self.topic:\n                logging.debug('Title must have changed; ignore cache')\n                result = None\n            else:\n                logging.debug('Using cached thread id %s for %s', str(result),\n                              str(cache_key))\n                return result\n        data, dummy_hdr = self.raw_search(self.user, self.token, query_string)\n\n        if data['total_count'] == 1:   # unique match\n            if data['items'][0]['title'] == self.topic:\n                result = data['items'][0]['number']\n            else:\n                result = None\n        elif data['total_count'] > 1:  # multiple matches since github doesn't\n            searched_data = [          # have unique search we must filter\n                item for item in data['items'] if item['title'] == self.topic]\n            if not searched_data:  # no matches\n                return None\n            elif len(searched_data) > 1:\n                raise yap_exceptions.UnableToFindUniqueTopic(\n                    self.topic, data['total_count'], '')\n            else:\n                assert len(searched_data) == 1, (\n                    'Confused searching for topic \"%s\"' % str(self.topic))\n                result = searched_data[0]['number']\n        else:\n            result = None\n        self.update_cache_key(cache_key, result)\n\n        return result", "response": "This method will query GitHub to find the thread id for the specified topic and return it."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef raw_search(cls, user, token, query, page=0):\n        page = int(page)\n        kwargs = {} if not user else {'auth': (user, token)}\n        my_url = cls.search_url\n        data = {'items': []}\n        while my_url:\n            cls.sleep_if_necessary(\n                user, token, msg='\\nquery=\"%s\"' % str(query))\n            my_req = requests.get(my_url, params={'q': query}, **kwargs)\n            if my_req.status_code != 200:\n                raise GitHubAngry(\n                    'Bad status code %s finding query %s because %s' % (\n                        my_req.status_code, query, my_req.reason))\n            my_json = my_req.json()\n            assert isinstance(my_json['items'], list)\n            data['items'].extend(my_json.pop('items'))\n            data.update(my_json)\n            my_url = None\n\n            if page and my_req.links.get('next', False):\n                my_url = my_req.links['next']['url']\n            if my_url:\n                page = page - 1\n                logging.debug(\n                    'Paginating %s in raw_search (%i more pages allowed)',\n                    my_req.links, page)\n\n        return data, my_req.headers", "response": "Do a raw search for github issues."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef raw_pull(self, topic):\n        assert topic is not None, 'A topic of None is not allowed'\n        kwargs = {} if not self.user else {'auth': (self.user, self.token)}\n        my_req = requests.get('%s/issues/%s' % (\n            self.base_url, topic), **kwargs)\n        return my_req", "response": "Do a raw pull of data for given topic down from github API."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef lookup_comment_list(self):\n        if self.thread_id is None:\n            return None, None\n\n        # Just pulling a single issue here so pagination shouldn't be problem\n        my_req = self.raw_pull(self.thread_id)\n        if my_req.status_code != 200:\n            raise GitHubAngry('Bad status code %s because %s' % (\n                my_req.status_code, my_req.reason))\n        issue_json = my_req.json()\n        comments_url = issue_json['comments_url'] + self.url_extras\n        kwargs = {} if not self.user else {'auth': (self.user, self.token)}\n        comments_json = []\n        while comments_url:\n            logging.debug('Pulling comments URL: %s', comments_url)\n            c_req = requests.get(comments_url, **kwargs)\n            my_json = c_req.json()\n            assert isinstance(my_json, list)\n            comments_json.extend(my_json)\n            comments_url = None\n            if 'link' in c_req.headers:  # need to handle pagination.\n                logging.debug('Paginating in lookup_comment_list')\n                link = c_req.headers['link'].split(',')\n                for thing in link:\n                    potential_url, part = thing.split('; ')\n                    if part == 'rel=\"next\"':\n                        comments_url = potential_url.lstrip(' <').rstrip('> ')\n\n        return issue_json, comments_json", "response": "This method looks up the comments for a single issue and returns the ISSUE and COMMENTS dicts."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add_comment(self, body, allow_create=False, allow_hashes=True,\n                    summary=None, hash_create=False):\n        \"\"\"Implement as required by CommentThread.add_comment.\n\n        :arg body:    String/text of comment to add.\n\n        :arg allow_create=False: Whether to automatically create a new thread\n                                 if a thread does not exist (usually by calling\n                                 self.create_thread).\n\n        :arg allow_hashes=True:  Whether to support hashtag mentions of other\n                                 topics and automatically insert comment in\n                                 body into those topics as well.\n\n                                 *IMPORTANT*: if you recursively call\n                                 add_comment to insert the hashes, you should\n                                 make sure to set this to False to prevent\n                                 infinite hash processing loops.\n\n        arg summary=None:        Optional summary. If not given, we will\n                                 extract one from body automatically if\n                                 necessary.\n\n        :arg hash_create=False:  Whether to allow creating new threads via\n                                 hash mentions.\n\n        ~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-\n\n        :returns:     Response object indicating whether added succesfully.\n\n        ~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-\n\n        PURPOSE:      This uses the GitHub API to try to add the given comment\n                      to the desired thread.\n\n        \"\"\"\n        if self.thread_id is None:\n            self.thread_id = self.lookup_thread_id()\n        data = json.dumps({'body': body})\n        if self.thread_id is None:\n            if allow_create:\n                return self.create_thread(body)\n            else:\n                raise ValueError(\n                    'Cannot find comment existing comment for %s' % self.topic)\n\n        result = requests.post('%s/issues/%s/comments' % (\n            self.base_url, self.thread_id), data, auth=(self.user, self.token))\n        if result.status_code != 201:\n            if result.reason == 'Not Found' and allow_create:\n                return self.create_thread(body)\n            else:\n                raise GitHubAngry(\n                    'Bad status %s add_comment on %s because %s' % (\n                        result.status_code, self.topic, result.reason))\n\n        if allow_hashes:\n            self.process_hashes(body, allow_create=hash_create)\n\n        return result", "response": "Implement as required by CommentThread. add_comment."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nprocessing any hashes mentioned and push them to related topics. :arg body: Body of the comment to check for hashes and push out. :arg allow_create=False: Whether to allow creating new topics from hash tag mentions. ~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~- PURPOSE: Look for hashtags matching self.hashtag_re and when found, add comment from body to those topics.", "response": "def process_hashes(self, body, allow_create=False):\n        \"\"\"Process any hashes mentioned and push them to related topics.\n\n        :arg body:    Body of the comment to check for hashes and push out.\n\n        :arg allow_create=False:  Whether to allow creating new topics\n                                  from hash tag mentions.\n\n        ~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-\n\n        PURPOSE:    Look for hashtags matching self.hashtag_re and when found,\n                    add comment from body to those topics.\n\n        \"\"\"\n        hash_re = re.compile(self.hashtag_re)\n        hashes = hash_re.findall(body)\n        done = {self.topic.lower(): True}\n        for mention in hashes:\n            mention = mention.strip('#')\n            if mention.lower() in done:\n                continue  # Do not duplicate hash mentions\n            new_thread = self.__class__(\n                owner=self.owner, realm=self.realm, topic=mention,\n                user=self.user, token=self.token)\n            my_comment = '# Hashtag copy from %s:\\n%s' % (self.topic, body)\n            new_thread.add_comment(\n                my_comment, allow_create=allow_create,\n                allow_hashes=False)  # allow_hashes=False to prevent inf loop\n            done[mention.lower()] = True"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nupload an attachment to the comment thread.", "response": "def upload_attachment(self, location, data):\n        \"\"\"Upload attachment as required by CommentThread class.\n\n        See CommentThread.upload_attachment for details.\n        \"\"\"\n        self.validate_attachment_location(location)\n        content = data.read() if hasattr(data, 'read') else data\n        orig_content = content\n        if isinstance(content, bytes):\n            content = base64.b64encode(orig_content).decode('ascii')\n        else:\n            pass  # Should be base64 encoded already\n        apath = '%s/%s' % (self.attachment_location, location)\n        url = '%s/contents/%s' % (self.base_url, apath)\n        result = requests.put(\n            url, auth=(self.user, self.token), data=json.dumps({\n                'message': 'file attachment %s' % location,\n                'content': content}))\n        if result.status_code != 201:\n            raise ValueError(\n                \"Can't upload attachment %s due to error %s.\" % (\n                    location, result.reason))\n        return '[%s](https://github.com/%s/%s/blob/master/%s)' % (\n            location, self.owner, self.realm, apath)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncloses the existing database connection and re - opens it.", "response": "def _reconnect(self):\n        \"\"\"Closes the existing database connection and re-opens it.\"\"\"\n        self.close()\n        self._db = psycopg2.connect(**self._db_args)\n\n        if self._search_path:\n            self.execute('set search_path=%s;' % self._search_path)\n\n        if self._timezone:\n            self.execute(\"set timezone='%s';\" % self._timezone)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nregistering existing types for a new connection", "response": "def _reregister_types(self):\n        \"\"\"Registers existing types for a new connection\"\"\"\n        for _type in self._register_types:\n            psycopg2.extensions.register_type(psycopg2.extensions.new_type(*_type))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef mogrify(self, query, *parameters, **kwargs):\n        cursor = self._cursor()\n        try:\n            if kwargs:\n                res = cursor.mogrify(query % dict([(r[0], adapt(r[1])) for r in list(kwargs.items())]))\n            else:\n                res = cursor.mogrify(query, parameters)\n\n            cursor.close()\n            return res\n\n        except:  # pragma: no cover\n            cursor.close()\n            raise", "response": "From http://initd. org / psycopg. html?highlight = mogrify#cursor. mogrify\n        Return a query string after arguments binding."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef query(self, query, *parameters, **kwargs):\n        cursor = self._cursor()\n        try:\n            self._execute(cursor, query, parameters or None, kwargs)\n            if cursor.description:\n                column_names = [column.name for column in cursor.description]\n                res = [Row(zip(column_names, row)) for row in cursor.fetchall()]\n                cursor.close()\n                return res\n        except:\n            cursor.close()\n            raise", "response": "Returns a row list for the given query and parameters."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef iter(self, query, *parameters, **kwargs):\n        cursor = self._cursor()\n        try:\n            self._execute(cursor, query, parameters or None, kwargs)\n            if cursor.description:\n                column_names = [column.name for column in cursor.description]\n                while True:\n                    record = cursor.fetchone()\n                    if not record:\n                        break\n                    yield Row(zip(column_names, record))\n            raise StopIteration\n\n        except:\n            cursor.close()\n            raise", "response": "Returns a generator for records from the query."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef execute(self, query, *parameters, **kwargs):\n        cursor = self._cursor()\n        try:\n            self._execute(cursor, query, parameters, kwargs)\n\n        except:\n            raise\n\n        finally:\n            cursor.close()", "response": "Same as query but do not process results. Always returns None."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get(self, query, *parameters, **kwargs):\n        rows = self.query(query, *parameters, **kwargs)\n        if not rows:\n            return None\n        elif len(rows) > 1:\n            raise ValueError('Multiple rows returned for get() query')\n        else:\n            return rows[0]", "response": "Returns the first row returned for the given query."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef executemany(self, query, *parameters):\n        cursor = self._cursor()\n        try:\n            self._executemany(cursor, query, parameters)\n            if cursor.description:\n                column_names = [column.name for column in cursor.description]\n                res = [Row(zip(column_names, row)) for row in cursor.fetchall()]\n                cursor.close()\n                return res\n\n        except Exception:  # pragma: no cover\n            cursor.close()\n            raise", "response": "Executes the given query against all the given param sequences. Returns a list of rows."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _executemany(self, cursor, query, parameters):\n        try:\n            self._log(query)\n            cursor.executemany(query, parameters)\n        except OperationalError as e:  # pragma: no cover\n            logging.error('Error connecting to PostgreSQL on %s, e', self.host, e)\n            self.close()\n            raise", "response": "The function is mostly useful for commands that update the database."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\npops and returns all notices http://initd. org / psycopg. html#connection. notices", "response": "def notices(self):\n        \"\"\"pops and returns all notices\n        http://initd.org/psycopg/docs/connection.html#connection.notices\n        \"\"\"\n        return [self._db.notices.pop()[8:].strip() for x in range(len(self._db.notices))]"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ninstalling your package to all Python version you have installed on Windows.", "response": "def install():\n    \"\"\"Install your package to all Python version you have installed on Windows.\n    \"\"\"\n    import os, shutil\n    \n    _ROOT = os.getcwd()\n    _PACKAGE_NAME = os.path.basename(_ROOT)\n    \n    print(\"Installing [%s] to all python version...\" % _PACKAGE_NAME)\n    # find all Python release installed on this windows computer\n    installed_python_version = list()\n    for root, folder_list, _ in os.walk(r\"C:\\\\\"):\n        for folder in folder_list:\n            if folder.startswith(\"Python\"):\n                if os.path.exists(os.path.join(root, folder, \"pythonw.exe\")):\n                    installed_python_version.append(folder)\n        break\n    print(\"\\tYou have installed: {0}\".format(\", \".join(installed_python_version)))\n    \n    # remove __pycache__ folder and *.pyc file\n    print(\"\\tRemoving *.pyc file ...\")\n    pyc_folder_list = list()\n    for root, folder_list, _ in os.walk(_ROOT):\n        if os.path.basename(root) == \"__pycache__\":\n            pyc_folder_list.append(root)\n    \n    for folder in pyc_folder_list:\n        shutil.rmtree(folder)\n    print(\"\\t\\tall *.pyc file has been removed.\")\n    \n    # install this package to all python version\n    for py_root in installed_python_version:\n        dst = os.path.join(r\"C:\\\\\", py_root, r\"Lib\\site-packages\", _PACKAGE_NAME)\n        try:\n            shutil.rmtree(dst)\n        except:\n            pass\n        print(\"\\tRemoved %s.\" % dst)\n        shutil.copytree(_ROOT, dst)\n        print(\"\\tInstalled %s.\" % dst)\n    \n    print(\"Complete!\")"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef namedtuple_asdict(obj):\n    if obj is None:\n        return obj\n    if hasattr(obj, \"_asdict\"):  # detect namedtuple\n        return OrderedDict(zip(obj._fields, (namedtuple_asdict(item)\n                                             for item in obj)))\n    if isinstance(obj, str):  # iterables - strings\n        return obj\n    if hasattr(obj, \"keys\"):  # iterables - mapping\n        return OrderedDict(zip(obj.keys(), (namedtuple_asdict(item)\n                                            for item in obj.values())))\n    if hasattr(obj, \"__iter__\"):  # iterables - sequence\n        return type(obj)((namedtuple_asdict(item) for item in obj))\n    # non-iterable cannot contain namedtuples\n    return obj", "response": "Serializing a nested namedtuple into a Python dict\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets a context from a json dump.", "response": "def from_json(cls, json_dump):\n        \"\"\"\n        How to get a context from a json dump\n        \"\"\"\n        context = cls()\n        if json_dump is None:\n            return None\n        ctxt = json.loads(json_dump)\n        for k in ctxt:\n            context[k] = ctxt[k]\n        return context"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef clean(self):\n        # \u670d\u52a1\u7ed3\u675f\u9636\u6bb5\n        if self.running is False:\n            return False\n        logger.info(\"Stopping worker [%s]\", self.pid)\n        # \u5173\u95edserver\n        self.rpc_server.close()\n        self.loop.run_until_complete(self.rpc_server.wait_closed())\n        # \u5173\u95ed\u8fde\u63a5\n        # \u5b8c\u6210\u6240\u6709\u7a7a\u8f6c\u8fde\u63a5\u7684\u5173\u95ed\u5de5\u4f5c\n        for connection in MPProtocolServer.CONNECTIONS:\n            connection.shutdown()\n\n        # \u7b49\u5f85\u7531graceful_shutdown_timeout\u8bbe\u7f6e\u7684\u65f6\u95f4\n        # \u8ba9\u8fd8\u5728\u8fd0\u8f6c\u7684\u8fde\u63a5\u5173\u95ed,\u9632\u6b62\u8fde\u63a5\u4e00\u76f4\u88ab\u6302\u8d77\n        start_shutdown = 0\n        while MPProtocolServer.CONNECTIONS and (\n                start_shutdown < self.graceful_shutdown_timeout):\n            self.loop.run_until_complete(asyncio.sleep(0.1))\n            start_shutdown = start_shutdown + 0.1\n\n        # \u5728\u7b49\u5f85graceful_shutdown_timeout\u8bbe\u7f6e\u7684\u65f6\u95f4\u540e\n        # \u5f3a\u5236\u5173\u95ed\u6240\u6709\u7684\u8fde\u63a5\n        # for conn in MPProtocolServer.CONNECTIONS:\n        #     conn.close()\n        # \u6536\u5c3e\u9636\u6bb5\u5173\u95ed\u6240\u6709\u534f\u7a0b,\n        self.loop.run_until_complete(self.loop.shutdown_asyncgens())\n        # \u5173\u95edloop\n        self.loop.close()\n        logger.info(\"Stopped worker [%s]\", self.pid)\n        return True", "response": "Clean up the master process."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef system_lenUndoneTasks(self)->int:\n        return len([i for i in MPProtocolServer.TASKS if not i.done()])", "response": "get system total number of undone tasks"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef system_methodSignature(self, method_name: str)->str:\n        method = None\n        if method_name in self.funcs:\n            method = self.funcs[method_name]\n        elif self.instance is not None:\n            try:\n                method = resolve_dotted_attribute(\n                    self.instance,\n                    method_name,\n                    self.allow_dotted_names\n                )\n            except AttributeError:\n                pass\n        if method is None:\n            return \"\"\n        else:\n            return str(inspect.signature(method))", "response": "Returns the signature of the method that is used to add the new object to the current object."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef system_methodHelp(self, method_name: str)->str:\n        method = None\n        if method_name in self.funcs:\n            method = self.funcs[method_name]\n        elif self.instance is not None:\n            try:\n                method = resolve_dotted_attribute(\n                    self.instance,\n                    method_name,\n                    self.allow_dotted_names\n                )\n            except AttributeError:\n                pass\n        if method is None:\n            return \"\"\n        else:\n            return pydoc.getdoc(method)", "response": "Return the docstring of the method that is used to help the user."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef register_instance(self, instance: Any, allow_dotted_names: bool=False):\n        if self.instance:\n            raise RuntimeError(\"can only register one instance\")\n        self.instance = instance\n        self.allow_dotted_names = allow_dotted_names\n        return True", "response": "Register an instance of the class."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_executor(self, executor: futures.Executor):\n        self.loop.set_default_executor(executor)\n        self._func_executor = executor\n        return True", "response": "Set the executor to use for this thread."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\nasync def apply(self, ID: str, method: str, *args: Any, **kwargs: Any):\n        func = None\n        try:\n            # check to see if a matching function has been registered\n            func = self.funcs[method]\n        except KeyError:\n            if self.instance is not None:\n                # check for a _dispatch method\n                try:\n                    func = resolve_dotted_attribute(\n                        self.instance,\n                        method,\n                        self.allow_dotted_names)\n                except AttributeError:\n                    pass\n        if func is not None:\n            sig = inspect.signature(func)\n            try:\n                sig.bind(*args, **kwargs)\n            except:\n                raise ParamError(\n                    \"args can not bind to method {}\".format(method), ID)\n            if method.startswith(\"system.\"):\n                try:\n                    result = func(*args, **kwargs)\n                except Exception as e:\n                    raise RPCRuntimeError(\n                        'Error:{} happend in method {}'.format(\n                            e.__class__.__name__,\n                            method\n                        ),\n                        ID\n                    )\n                else:\n                    return result\n            if inspect.iscoroutinefunction(func):\n                try:\n                    result = await func(*args, **kwargs)\n                except Exception as e:\n                    raise RPCRuntimeError(\n                        'Error:{} happend in method {}'.format(\n                            e.__class__.__name__,\n                            method\n                        ),\n                        ID\n                    )\n                else:\n                    return result\n            elif inspect.isasyncgenfunction(func):\n                result = func(*args, **kwargs)\n                return result\n            elif inspect.isfunction(func) or inspect.ismethod(func):\n                try:\n                    f = partial(func, *args, **kwargs)\n                    result = await self.loop.run_in_executor(None, f)\n                except Exception as e:\n                    raise RPCRuntimeError(\n                        'Error:{} happend in method {}'.format(\n                            e.__class__.__name__,\n                            method\n                        ),\n                        ID\n                    )\n                else:\n                    return result\n            else:\n                raise RpcException('method \"%s\" is not supported' % method)\n        else:\n            raise NotFindError('method \"%s\" is not supported' % method, ID)", "response": "Apply a method on an object."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a TendrilManager instance for the given protocol and endpoint.", "response": "def get_manager(cls, proto, endpoint=None):\n        \"\"\"\n        Find a manager matching the given protocol and endpoint.  If\n        no matching manager currently exists, creates a new one.\n        (Manager classes are looked up using the ``tendril.manager``\n        entrypoint, and the name of the entrypoint corresponds to the\n        ``proto``.  This method makes no guarantees about whether the\n        manager is running; make sure to check the ``running``\n        attribute and call the ``start()`` method if necessary.\n\n        :param proto: The underlying network protocol, such as \"tcp\"\n                      or \"udp\".\n        :param endpoint: Identifies the endpoint of the\n                         TendrilManager.  This will be the IP address\n                         and port number, as a tuple, on which to\n                         accept connections and from which to initiate\n                         connections.  If not given, defaults to\n                         ``('', 0)``.\n\n        Note: TendrilManager instances can only support one of IPv4 or\n        IPv6, and outgoing connection addresses must match how the\n        TendrilManager was initialized.  To get a TendrilManager\n        supporting outgoing IPv6 connections, use the endpoint\n        ``('::', 0)``.\n        \"\"\"\n\n        # First, normalize the proto and endpoint\n        proto = proto.lower()\n        endpoint = endpoint or ('', 0)\n\n        # See if the manager already exists\n        if (proto, endpoint) in cls._managers:\n            return cls._managers[(proto, endpoint)]\n\n        # OK, need to create a new one; use pkg_resources\n        for ep in pkg_resources.iter_entry_points('tendril.manager', proto):\n            try:\n                manager_cls = ep.load()\n                break\n            except (ImportError, pkg_resources.UnknownExtra):\n                continue\n        else:\n            raise ValueError(\"unknown protocol %r\" % proto)\n\n        return manager_cls(endpoint)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfinds the tendril corresponding to the protocol and address tuple. Returns a Tendril object if the tendril is not tracked.", "response": "def find_tendril(cls, proto, addr):\n        \"\"\"\n        Finds the tendril corresponding to the protocol and address\n        tuple.  Returns the Tendril object, or raises KeyError if the\n        tendril is not tracked.\n\n        The address tuple is the tuple of the local address and the\n        remote address for the tendril.\n        \"\"\"\n\n        # First, normalize the proto\n        proto = proto.lower()\n\n        # Now, find and return the tendril\n        return cls._tendrils[proto][addr]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _track_tendril(self, tendril):\n\n        self.tendrils[tendril._tendril_key] = tendril\n\n        # Also add to _tendrils\n        self._tendrils.setdefault(tendril.proto, weakref.WeakValueDictionary())\n        self._tendrils[tendril.proto][tendril._tendril_key] = tendril", "response": "Add the tendril to the set of tracked tendrils."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _untrack_tendril(self, tendril):\n\n        try:\n            del self.tendrils[tendril._tendril_key]\n        except KeyError:\n            pass\n\n        # Also remove from _tendrils\n        try:\n            del self._tendrils[tendril.proto][tendril._tendril_key]\n        except KeyError:\n            pass", "response": "Removes the tendril from the set of tracked tendrils."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef start(self, acceptor=None, wrapper=None):\n\n        # Don't allow a double-start\n        if self.running:\n            raise ValueError(\"TendrilManager already running\")\n\n        # Look out for conflicts\n        if self._manager_key in self._running_managers:\n            raise ValueError(\"Identical TendrilManager already exists\")\n\n        # In a moment, we will begin running\n        self.running = True\n        self._local_addr = None\n        self._local_addr_event.clear()\n\n        # Add ourself to the dictionary of running managers\n        self._running_managers[self._manager_key] = self\n\n        # Start the listening thread\n        self._listen_thread = gevent.spawn(self.listener, acceptor,\n                                           wrapper)\n\n        # Make sure to reset running if it exits\n        self._listen_thread.link(self.stop)", "response": "Starts the Tendril Manager."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nstops the TendrilManager. Requires cooperation from the listener implementation, which must watch the ``running`` attribute and ensure that it stops accepting connections should that attribute become False. Note that some tendril managers will not exit from the listening thread until all connections have been closed.", "response": "def stop(self, *args):\n        \"\"\"\n        Stops the TendrilManager.  Requires cooperation from the\n        listener implementation, which must watch the ``running``\n        attribute and ensure that it stops accepting connections\n        should that attribute become False.  Note that some tendril\n        managers will not exit from the listening thread until all\n        connections have been closed.\n        \"\"\"\n\n        # Remove ourself from the dictionary of running managers\n        try:\n            del self._running_managers[self._manager_key]\n        except KeyError:\n            pass\n\n        self.running = False\n        self._local_addr = None\n        self._local_addr_event.clear()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_local_addr(self, timeout=None):\n\n        # If we're not running, just return None\n        if not self.running:\n            return None\n\n        # OK, we're running; wait on the _local_addr_event\n        if not self._local_addr_event.wait(timeout):\n            # Still not set after timeout\n            return None\n\n        # We have a local address!\n        return self._local_addr", "response": "Retrieve the current local address."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef connect(self, target, acceptor, wrapper=None):\n\n        if not self.running:\n            raise ValueError(\"TendrilManager not running\")\n\n        # Check the target address\n        fam = utils.addr_info(target)\n\n        # Verify that we're in the right family\n        if self.addr_family != fam:\n            raise ValueError(\"address family mismatch\")", "response": "Initiate a connection from the tendril manager s endpoint."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nread the node as a file", "response": "def read(self, *args, **kwargs):\n        \"\"\"Reads the node as a file\n        \"\"\"\n        with self.open('r') as f:\n            return f.read(*args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nlists the children entities of the directory. Raises exception if the object is not a directory.", "response": "def ls(self):\n        \"\"\"List the children entities of the directory.\n\n        Raises exception if the object is a file.\n\n        :return:\n        \"\"\"\n        if self.isfile():\n            raise NotDirectoryError('Cannot ls() on non-directory node: {path}'.format(path=self._pyerarchy_path))\n\n        return os.listdir(self._pyerarchy_path)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef mkdir(self, children, mode=0o0755, return_node=True):\n        result = None\n\n        if isinstance(children, (str, unicode)):\n            if os.path.isabs(children):\n                raise BadValueError('Cannot mkdir an absolute path: {path}'.format(path=self._pyerarchy_path))\n\n            rel_path = os.path.join(self._pyerarchy_path, children)\n            os.makedirs(rel_path, mode)\n\n            if return_node:\n                result = Node(rel_path)\n        else:\n            for child in children:\n                self.mkdir(child, mode, False)\n\n        return result", "response": "Creates child entities in directory."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef capitalize(\n    full_name,\n    articles=None,\n    separator_characters=None,\n    ignore_worls=None,\n):\n    \"\"\"Returns the correct writing of a compound name, respecting the\n    first letters of the names in upper case.\"\"\"\n    if articles is None:\n        articles = _ARTICLES\n    if separator_characters is None:\n        separator_characters = _SEPARATOR_CHARACTERS\n    if ignore_worls is None:\n        ignore_worls = _IGNORE_WORLS\n    new_full_name = full_name\n    if hasattr(new_full_name, 'strip'):\n        new_full_name = new_full_name.strip()\n    if not new_full_name:\n        return full_name\n    new_full_name = deep_unicode(new_full_name)\n    list_full_name = []\n    start_idx = 0\n    for step_idx, char in enumerate(list(new_full_name)):\n        if char in separator_characters:\n            list_full_name.extend(\n                [\n                    _setting_word(\n                        new_full_name[start_idx:step_idx],\n                        separator_characters, ignore_worls,\n                        articles if list_full_name else []\n                    ),\n                    char\n                ]\n            )\n            start_idx = step_idx + 1\n    list_full_name.append(\n        _setting_word(\n            new_full_name[start_idx:],\n            separator_characters, ignore_worls, articles\n        )\n    )\n    return ''.join(list_full_name)", "response": "Returns the correct writing of a compound name respecting the\n    first letters of the names in upper case."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndecodes DEEP S using the codec registered for encoding.", "response": "def deep_unicode(s, encodings=None):\n    \"\"\"decode \"DEEP\" S using the codec registered for encoding.\"\"\"\n    if encodings is None:\n        encodings = ['utf-8', 'latin-1']\n    if isinstance(s, (list, tuple)):\n        return [deep_unicode(i) for i in s]\n    if isinstance(s, dict):\n        return dict([\n            (deep_unicode(key), deep_unicode(s[key]))\n            for key in s\n        ])\n        # in_dict = {}\n        # for key in s:\n        #     in_dict[to_unicode(key)] = to_unicode(s[key])\n        # return in_dict\n    elif isinstance(s, str):\n        for encoding in encodings:\n            try:\n                return s.decode(encoding)\n            except:\n                pass\n    return s"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef deep_encode(s, encoding='utf-8', errors='strict'):\n    # encoding defaults to the default encoding. errors may be given to set\n    # a different error handling scheme. Default is 'strict' meaning\n    # that encoding errors raise\n    # a UnicodeEncodeError. Other possible values are 'ignore', 'replace' and\n    # 'xmlcharrefreplace' as well as any other name registered with\n    # codecs.register_error that can handle UnicodeEncodeErrors.\n    s = deep_encode(s)\n    if sys.version_info.major < 3 and isinstance(s, unicode):\n        return s.encode(encoding, errors)\n    if isinstance(s, (list, tuple)):\n        return [deep_encode(i, encoding=encoding, errors=errors) for i in s]\n    if isinstance(s, dict):\n        return dict([\n            (\n                deep_encode(key, encoding=encoding, errors=errors),\n                deep_encode(s[key], encoding=encoding, errors=errors)\n            ) for key in s\n        ])\n        # new_dict = {}\n        # for key in s:\n        #     new_dict[\n        #         to_encode(key, encoding=encoding, errors=errors)\n        #     ] = to_encode(s[key], encoding=encoding, errors=errors)\n        # return new_dict\n    return s", "response": "Encode DEEP S using the codec registered for encoding."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef namespace(self, key, glob=False):\n        if not self.name:\n            self.name = os.environ['DJANGO_SETTINGS_MODULE'] \n        ns = '.'.join([key, self._glob]) if glob else '.'.join([self.name, self._glob])\n        return ns", "response": "Return a namespace for keyring"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get(self, key, prompt_default='', prompt_help=''):\n        value = os.getenv(key)\n        if not value:\n            ns = self.namespace(key)\n            value = self.keyring.get_password(ns, key)\n        else:\n            ns = 'environ'  \n        if not value:\n            ns = self.namespace(key, glob=True)\n            value = self.keyring.get_password(ns, key)\n        if not value:\n            ns = ''\n        if not value and self.prompt:\n            value = self._prompt_for_value(key, prompt_default, prompt_help)\n            if value:\n                self.set(key, value)\n        if ns:\n            self.kns[key] = ns\n        return value", "response": "Return a value from the environ or keyring"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting the key value pair in a local or global namespace", "response": "def set(self, key, value, glob=False):\n        \"\"\"Set the key value pair in a local or global namespace\"\"\"\n        ns = self.namespace(key, glob)\n        self.keyring.set_password(ns, key, value)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef remove(self, key, glob=False):\n        ns = self.namespace(key, glob)\n        try:\n            self.keyring.delete_password(ns, key)\n        except PasswordDeleteError:  # OSX and gnome have no delete method \n            self.set(key, '', glob)", "response": "Remove a key value pair in a local or global namespace."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget a value for a key from the environment or keyring.", "response": "def get(self, key, prompt_default='', prompt_help=''):\n        \"\"\"\n        Return the value for key from the environment or keyring.\n        The keyring value is resolved from a local namespace or a global one.\n        \"\"\"\n        value = super(DjSecret, self).get(key, prompt_default, prompt_help='')\n        if not value and self.raise_on_none:\n            error_msg = \"The %s setting is undefined in the environment and djset %s\" % (key, self._glob)\n            raise self.raise_on_none(error_msg)\n        return value"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef setLoc(self, loc):   # loc must be a tuple or list of x,y coordinates\r\n        self.loc = loc\r\n        self.rect[0] = self.loc[0]\r\n        self.rect[1] = self.loc[1]", "response": "Sets the location of the current widget."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndraw the button in its current state.", "response": "def draw(self):\r\n        \"\"\"Draws the button in its current state.\r\n\r\n        Should be called every time through the main loop\r\n\r\n        \"\"\"\r\n        if not self.visible:\r\n            return\r\n\r\n        # Blit the button's current appearance to the surface.\r\n        if self.isEnabled:\r\n            if self.mouseIsDown:\r\n                if self.mouseOverButton and self.lastMouseDownOverButton:\r\n                    self.window.blit(self.surfaceDown, self.loc)\r\n                else:\r\n                    self.window.blit(self.surfaceUp, self.loc)\r\n            else:  # mouse is up\r\n                if self.mouseOverButton:\r\n                    self.window.blit(self.surfaceOver, self.loc)\r\n                else:\r\n                    self.window.blit(self.surfaceUp, self.loc)\r\n\r\n        else:\r\n            self.window.blit(self.surfaceDisabled, self.loc)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _debug(self):\r\n        self.window.blit(self.surfaceUp, (self.loc[0], 10))\r\n        self.window.blit(self.surfaceOver, (self.loc[0], 60))\r\n        self.window.blit(self.surfaceDown, (self.loc[0], 110))\r\n        self.window.blit(self.surfaceDisabled, (self.loc[0], 160))", "response": "This is just for debugging."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef handleEvent(self, eventObj):\r\n\r\n        if eventObj.type not in (MOUSEMOTION, MOUSEBUTTONUP, MOUSEBUTTONDOWN) or not self.visible:\r\n            # The checkBox only cares bout mouse-related events (or no events, if it is invisible)\r\n            return False\r\n\r\n        if not self.isEnabled:\r\n            return False\r\n\r\n        clicked = False\r\n\r\n        if (not self.mouseOverButton) and self.rect.collidepoint(eventObj.pos):\r\n            # if mouse has entered the checkBox:\r\n            self.mouseOverButton = True\r\n\r\n\r\n        elif self.mouseOverButton and (not self.rect.collidepoint(eventObj.pos)):\r\n            # if mouse has exited the checkBox:\r\n            self.mouseOverButton = False\r\n\r\n        if self.rect.collidepoint(eventObj.pos):\r\n\r\n            if eventObj.type == MOUSEBUTTONDOWN:\r\n                self.buttonDown = True\r\n                self.lastMouseDownOverButton = True\r\n\r\n        else:\r\n            if eventObj.type in (MOUSEBUTTONUP, MOUSEBUTTONDOWN):\r\n                # if an up/down happens off the checkBox, then the next up won't cause mouseClick()\r\n                self.lastMouseDownOverButton = False\r\n\r\n        if eventObj.type == MOUSEBUTTONDOWN:\r\n            self.mouseIsDown = True\r\n            \r\n        # mouse up is handled whether or not it was over the checkBox\r\n        doMouseClick = False\r\n        if eventObj.type == MOUSEBUTTONUP:\r\n            self.mouseIsDown = False\r\n            if self.lastMouseDownOverButton:\r\n                doMouseClick = True\r\n            self.lastMouseDownOverButton = False\r\n\r\n            if self.buttonDown:\r\n                self.buttonDown = False\r\n\r\n            if doMouseClick:\r\n                self.buttonDown = False\r\n                clicked = True\r\n                \r\n                if self.playSoundOnClick:\r\n                    self.soundOnClick.play()\r\n\r\n                # switch state:\r\n                self.value = not self.value\r\n\r\n        return clicked", "response": "This method is called every time through the main loop. It handles the up over and down states of the button and the button."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef getSelectedRadioButton(self):\r\n        radioButtonListInGroup = PygWidgetsRadioButton.__PygWidgets__Radio__Buttons__Groups__Dicts__[self.group]\r\n        for radioButton in radioButtonListInGroup:\r\n            if radioButton.getValue():\r\n                selectedNickname = radioButton.getNickname()\r\n                return selectedNickname\r\n\r\n        raise Exception('No radio button was selected')", "response": "Returns the nickname of the currently selected radio button."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef enableGroup(self):\r\n        radioButtonListInGroup = PygWidgetsRadioButton.__PygWidgets__Radio__Buttons__Groups__Dicts__[self.group]\r\n        for radioButton in radioButtonListInGroup:\r\n            radioButton.enable()", "response": "Enables all radio buttons in the group."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef disableGroup(self):\r\n        radioButtonListInGroup = PygWidgetsRadioButton.__PygWidgets__Radio__Buttons__Groups__Dicts__[self.group]\r\n        for radioButton in radioButtonListInGroup:\r\n            radioButton.disable()", "response": "Disables all radio buttons in the group"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset a text value into the text field.", "response": "def setValue(self, newText):\r\n        \"\"\"Sets a text value (string) into the text field.\"\"\"\r\n        newText = str(newText)  #  attempt to convert to string (might be int or float ...)\r\n        if self.text == newText:\r\n            return  # nothing to change\r\n\r\n        self.text = newText  # save the new text\r\n\r\n        textLines = self.text.splitlines()\r\n        nLines = len(textLines)\r\n        surfacesList = []  # build up a list of surfaces, one for each line of original text\r\n        actualWidth = 0  # will eventually be set the width of longest line\r\n\r\n        for line in textLines:\r\n            lineSurface = self.font.render(line, True, self.textColor)\r\n            surfacesList.append(lineSurface)\r\n            thisRect = lineSurface.get_rect()\r\n            if thisRect.width > actualWidth:\r\n                actualWidth = thisRect.width\r\n\r\n        heightOfOneLine = self.fontHeight\r\n        actualHeight = nLines * heightOfOneLine\r\n        self.rect = pygame.Rect(self.loc[0], self.loc[1], actualWidth, actualHeight)\r\n\r\n        # Create one larger surface, then blit all line surfaces into it\r\n        # Special flags are needed to set the background alpha as transparent\r\n        self.textImage = pygame.Surface((actualWidth, actualHeight), flags=SRCALPHA)\r\n        if self.backgroundColor is not None:\r\n            self.textImage.fill(self.backgroundColor)\r\n\r\n        thisLineTop = 0\r\n        for lineSurface in surfacesList:\r\n            if self.justified == 'left':\r\n                self.textImage.blit(lineSurface, (0, thisLineTop))\r\n            else:\r\n                thisSurfaceWidth = lineSurface.get_rect()[2]  # element 2 is the width\r\n                if self.justified == 'center':\r\n                    theLeft = (actualWidth - thisSurfaceWidth) / 2\r\n                elif self.justified == 'right':  # right justified\r\n                    theLeft = actualWidth - thisSurfaceWidth\r\n                else:\r\n                    raise Exception('Value of justified was: ' + self.justified + '. Must be left, center, or right')\r\n                self.textImage.blit(lineSurface, (theLeft, thisLineTop))\r\n            thisLineTop = thisLineTop + heightOfOneLine\r\n\r\n\r\n        if self.useSpecifiedArea:\r\n            # Fit the text image into a user specified area, may truncate the text off left, right, or bottom\r\n            textRect = self.textImage.get_rect()\r\n            if self.userWidth is None:\r\n                theWidth = textRect.width\r\n            else:\r\n                theWidth = self.userWidth\r\n            if self.userHeight is None:\r\n                theHeight = textRect.height\r\n            else:\r\n                theHeight = self.userHeight\r\n\r\n            # Create a surface that is the size that the user asked for\r\n            userSizedImage = pygame.Surface((theWidth, theHeight), flags=SRCALPHA)\r\n            self.rect = pygame.Rect(self.loc[0], self.loc[1], theWidth, theHeight)\r\n            if self.backgroundColor is not None:\r\n                userSizedImage.fill(self.backgroundColor)\r\n\r\n            #  Figure out the appropriate left edge within the userSizedImage\r\n            if self.justified == 'left':\r\n                theLeft = 0\r\n            elif self.justified == 'center':\r\n                theLeft = (theWidth - textRect.width) / 2\r\n            else:  # right justified\r\n                theLeft = theWidth - textRect.width\r\n\r\n            # Copy the appropriate part from the text image into the user sized image\r\n            # Then re-name it to the textImage so it can be drawn later\r\n            userSizedImage.blit(self.textImage, (theLeft, 0))\r\n            self.textImage = userSizedImage\r\n            self.textImage = pygame.Surface.convert_alpha(self.textImage)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndrawing the current text in the window", "response": "def draw(self):\r\n        \"\"\"Draws the current text in the window\"\"\"\r\n        if not self.visible:\r\n            return\r\n\r\n        self.window.blit(self.textImage, self.loc)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _updateImage(self):\r\n        # Fill the background of the image\r\n        if self.backgroundColor is not None:\r\n            self.textImage.fill(self.backgroundColor)\r\n\r\n        # Render the text as a single line, and blit it onto the textImage surface\r\n        if self.mask is None:\r\n            lineSurface = self.font.render(self.text, True, self.textColor)\r\n        else:\r\n            nChars = len(self.text)\r\n            maskedText = self.mask * nChars\r\n            lineSurface = self.font.render(maskedText, True, self.textColor)\r\n        self.textImage.blit(lineSurface, (0, 0))", "response": "Internal method to render text as an image."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef handleEvent(self, event):\r\n\r\n        if not self.isEnabled:\r\n            return False\r\n\r\n        if (event.type == pygame.MOUSEBUTTONDOWN) and (event.button == 1): # user clicked\r\n            theX, theY = event.pos\r\n            # if self.imageRect.collidepoint(pos):\r\n            if self.imageRect.collidepoint(theX, theY):\r\n                if not self.focus:\r\n                    self.focus = True   # give this field focus\r\n                else:\r\n                    # Field already has focus, must position the cursor where the user clicked\r\n                    nPixelsFromLeft = theX - self.loc[0]\r\n                    nChars = len(self.text)\r\n\r\n                    lastCharOffset = self.font.size(self.text)[0]\r\n                    if nPixelsFromLeft >= lastCharOffset:\r\n                        self.cursorPosition = nChars\r\n                    else:\r\n                        for thisCharNum in range(0, nChars):\r\n                            thisCharOffset = self.font.size(self.text[:thisCharNum])[0]\r\n                            if thisCharOffset >= nPixelsFromLeft:\r\n                                self.cursorPosition = thisCharNum  # Found the proper position for the cursor\r\n                                break\r\n                    self.cursorVisible = True # Show the cursor at the click point\r\n\r\n            else:\r\n                self.focus = False\r\n\r\n\r\n        if not self.focus:  # if this field does not have focus, don't do anything\r\n            return False\r\n\r\n        keyIsDown = False  # assume False\r\n\r\n        if event.type == pygame.KEYDOWN:\r\n            keyIsDown = True\r\n            self.currentKey = event.key  # remember for potential repeating key\r\n            self.unicodeOfKey = event.unicode # remember for potential repeating key\r\n\r\n        if event.type == pygame.USEREVENT:\r\n            # This is a special signal to check for a repeating key\r\n            # if the key is still down, repeat it\r\n            keyPressedList = pygame.key.get_pressed()\r\n\r\n            if (self.currentKey is not None) and (keyPressedList[self.currentKey]):  # Key is still down\r\n                keyIsDown = True\r\n            else:\r\n                # Key is up\r\n                pygame.time.set_timer(pygame.USEREVENT, 0)  # kill the timer\r\n                return False\r\n\r\n\r\n        if keyIsDown:\r\n            if self.currentKey in (pygame.K_RETURN, pygame.K_KP_ENTER):\r\n                # User is done typing, return True to signal that text is available (via a call to getValue)\r\n                self.focus = False\r\n                self.currentKey = None\r\n                self._updateImage()\r\n\r\n                if self.callBack is not None:\r\n                    self.callBack(self.nickname)\r\n\r\n                return True\r\n\r\n            keyIsRepeatable = True  # assume it is repeatable unless specifically turned off\r\n            if self.currentKey == pygame.K_DELETE:\r\n                self.text = self.text[:self.cursorPosition] + \\\r\n                        self.text[self.cursorPosition + 1:]\r\n                self._updateImage()\r\n\r\n            elif self.currentKey == pygame.K_BACKSPACE:  # forward delete key\r\n                self.text = self.text[:max(self.cursorPosition - 1, 0)] + \\\r\n                                    self.text[self.cursorPosition:]\r\n\r\n                # Subtract one from cursor_pos, but do not go below zero:\r\n                self.cursorPosition = max(self.cursorPosition - 1, 0)\r\n                self._updateImage()\r\n\r\n            elif self.currentKey == pygame.K_RIGHT:\r\n                if self.cursorPosition < len(self.text):\r\n                    self.cursorPosition = self.cursorPosition + 1\r\n\r\n            elif self.currentKey == pygame.K_LEFT:\r\n                if self.cursorPosition > 0:\r\n                    self.cursorPosition = self.cursorPosition - 1\r\n\r\n            elif self.currentKey == pygame.K_END:\r\n                self.cursorPosition = len(self.text)\r\n                keyIsRepeatable = False\r\n\r\n            elif self.currentKey == pygame.K_HOME:\r\n                self.cursorPosition = 0\r\n                keyIsRepeatable = False\r\n\r\n            elif self.currentKey in [pygame.K_UP, pygame.K_DOWN]:\r\n                return False   # ignore up arrow and down arrow\r\n\r\n            else:  # standard key\r\n                # If no special key is pressed, add unicode of key to input_string\r\n                self.text = self.text[:self.cursorPosition] + \\\r\n                                    self.unicodeOfKey + \\\r\n                                    self.text[self.cursorPosition:]\r\n                self.cursorPosition = self.cursorPosition + len(self.unicodeOfKey)\r\n                self._updateImage()\r\n\r\n            if keyIsRepeatable:  # set up userevent to try to repeat key\r\n                pygame.time.set_timer(pygame.USEREVENT, 200)  # wait for a short time before repeating\r\n\r\n        return False", "response": "This method is called every time through the main loop. It handles all of the keyboard key actions\r\n            is called every time through the main loop."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndraw the Text in the window.", "response": "def draw(self):\r\n        \"\"\"Draws the Text in the window.\"\"\"\r\n        if not self.visible:\r\n            return\r\n\r\n        # If this input text has focus, draw an outline around the text image\r\n        if self.focus:\r\n            pygame.draw.rect(self.window, self.focusColor, self.focusedImageRect, 1)\r\n\r\n        # Blit in the image of text (set earlier in _updateImage)\r\n        self.window.blit(self.textImage, self.loc)\r\n\r\n        # If this field has focus, see if it is time to blink the cursor\r\n        if self.focus:\r\n            self.cursorMsCounter = self.cursorMsCounter + self.clock.get_time()\r\n            if self.cursorMsCounter >= self.cursorSwitchMs:\r\n                self.cursorMsCounter = self.cursorMsCounter % self.cursorSwitchMs\r\n                self.cursorVisible = not self.cursorVisible\r\n\r\n            if self.cursorVisible:\r\n                cursorOffset = self.font.size(self.text[:self.cursorPosition])[0]\r\n                if self.cursorPosition > 0: # Try to get between characters\r\n                    cursorOffset = cursorOffset - 1\r\n                if cursorOffset < self.width:  # if the loc is within the text area, draw it\r\n                    self.cursorLoc[0] = self.loc[0] + cursorOffset\r\n                    self.window.blit(self.cursorSurface, self.cursorLoc)\r\n\r\n            self.clock.tick()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef setValue(self, newText):\r\n        self.text = newText\r\n        self.cursorPosition = len(self.text)\r\n        self._updateImage()", "response": "Sets the new text into the field"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef clearText(self, keepFocus=False):\r\n        self.text = ''\r\n        self.focus = keepFocus\r\n        self._updateImage()", "response": "Clear the text in the field"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef handleEvent(self, eventObj):\r\n        if not self.isEnabled:\r\n            return False\r\n\r\n        if eventObj.type not in (MOUSEMOTION, MOUSEBUTTONUP, MOUSEBUTTONDOWN) :\r\n            # The dragger only cares about mouse-related events\r\n            return False\r\n\r\n        clicked = False\r\n        if eventObj.type == MOUSEBUTTONDOWN:\r\n            if self.rect.collidepoint(eventObj.pos):\r\n                self.dragging = True\r\n                self.deltaX = eventObj.pos[0] - self.rect.left\r\n                self.deltaY = eventObj.pos[1] - self.rect.top\r\n                self.startDraggingX = self.rect.left\r\n                self.startDraggingY = self.rect.top\r\n\r\n        elif eventObj.type == MOUSEBUTTONUP:\r\n            if self.dragging:\r\n                self.dragging = False\r\n                clicked = True\r\n                self.mouseUpLoc = (eventObj.pos[0], eventObj.pos[1])\r\n                self.rect.left = eventObj.pos[0] - self.deltaX\r\n                self.rect.top = eventObj.pos[1] - self.deltaY\r\n                self.setLoc((self.rect.left, self.rect.top))\r\n\r\n\r\n        elif eventObj.type == MOUSEMOTION:\r\n            if self.dragging:\r\n                self.rect.left = eventObj.pos[0] - self.deltaX\r\n                self.rect.top = eventObj.pos[1] - self.deltaY\r\n            else:\r\n                self.mouseOver = self.rect.collidepoint(eventObj.pos)\r\n\r\n        if clicked:\r\n            if self.callBack is not None:\r\n                self.callBack(self.nickname)\r\n\r\n        return clicked", "response": "This method is called every time through the main loop. It handles all of the dragging and mouse - related events and then moves the mouse up and mouse down events."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef resetToPreviousLoc(self):\r\n        self.rect.left = self.startDraggingX\r\n        self.rect.top = self.startDraggingY", "response": "Resets the loc of the dragger to place where dragging started."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndraws the dragger at the current mouse location.", "response": "def draw(self):\r\n        \"\"\"Draws the dragger at the current mouse location.\r\n\r\n        Should be called in every frame.\r\n\r\n        \"\"\"\r\n        if not self.visible:\r\n            return\r\n\r\n        if self.isEnabled:\r\n        \r\n            # Draw the dragger's current appearance to the window.\r\n            if self.dragging:\r\n                self.window.blit(self.surfaceDown, self.rect)\r\n            else:  # mouse is up\r\n                if self.mouseOver:\r\n                    self.window.blit(self.surfaceOver, self.rect)\r\n                else:\r\n                    self.window.blit(self.surfaceUp, self.rect)\r\n        else:\r\n            self.window.blit(self.surfaceDisabled, self.rect)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef flipHorizontal(self):\r\n        \r\n        self.flipH = not self.flipH\r\n        self._transmogrophy(self.angle, self.percent, self.scaleFromCenter, self.flipH, self.flipV)", "response": "flips an image object horizontally"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nflips an image object vertically", "response": "def flipVertical(self):\r\n        \"\"\" flips an image object vertically\r\n        \"\"\"\r\n        \r\n        self.flipV = not self.flipV\r\n        self._transmogrophy(self.angle, self.percent, self.scaleFromCenter, self.flipH, self.flipV)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef rotate(self, nDegrees):\r\n        self.angle = self.angle + nDegrees\r\n        self._transmogrophy(self.angle, self.percent, self.scaleFromCenter, self.flipH, self.flipV)", "response": "rotates the image a given number of degrees"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nrotates the image to a given angle", "response": "def rotateTo(self, angle):\r\n        \"\"\"rotates the image to a given angle\r\n\r\n        Parameters:\r\n            | angle - the angle that you want the image rotated to.\r\n            |            Positive numbers are clockwise, negative numbers are counter-clockwise\r\n\r\n        \"\"\"\r\n        self._transmogrophy(angle, self.percent, self.scaleFromCenter, self.flipH, self.flipV)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nscale an Image object with the specified percentage of the original size", "response": "def scale(self, percent, scaleFromCenter=True):\r\n        \"\"\"scales an Image object\r\n\r\n        Parameters:\r\n            | percent - a percent of the original size\r\n            |           numbers bigger than 100 scale up\r\n            |           numbers less than 100 scale down\r\n            |           100 scales to the original size\r\n        Optional keyword parameters:\r\n            | scaleFromCenter - should the image scale from the center or from the upper left hand corner\r\n            |           (default is True, scale from the center)\r\n\r\n        \"\"\"\r\n        self._transmogrophy(self.angle, percent, scaleFromCenter, self.flipH, self.flipV)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _transmogrophy(self, angle, percent, scaleFromCenter, flipH, flipV):\r\n        '''\r\n        Internal method to scale and rotate\r\n\r\n        '''\r\n\r\n        self.angle = angle % 360\r\n        self.percent = percent\r\n        self.scaleFromCenter = scaleFromCenter\r\n\r\n        previousRect = self.rect\r\n        previousCenter = previousRect.center\r\n        previousX = previousRect.x\r\n        previousY = previousRect.y\r\n\r\n        # Rotate - pygame rotates in the opposite direction\r\n        pygameAngle = -self.angle\r\n        rotatedImage = pygame.transform.rotate(self.originalImage, pygameAngle)\r\n        rotatedRect = rotatedImage.get_rect()\r\n        rotatedWidth = rotatedRect.width\r\n        rotatedHeight = rotatedRect.height\r\n\r\n        # Scale\r\n        newWidth = int(rotatedWidth * .01 * self.percent)\r\n        newHeight = int(rotatedHeight * .01 * self.percent)\r\n        self.image = pygame.transform.scale(rotatedImage, (newWidth, newHeight))\r\n\r\n        # Flip\r\n        if flipH:\r\n            self.image = pygame.transform.flip(self.image, True, False)\r\n        if flipV:\r\n            self.image = pygame.transform.flip(self.image, False, True)\r\n\r\n        # Placement\r\n\r\n        self.rect = self.image.get_rect()\r\n        if self.scaleFromCenter:\r\n            self.rect.center = previousCenter\r\n\r\n        else:  # use previous X, Y\r\n            self.rect.x = previousX\r\n            self.rect.y = previousY\r\n\r\n        self.setLoc((self.rect.left, self.rect.top))", "response": "Returns a new instance of the same class with the same attributes."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef draw(self):\r\n        if not self.visible:\r\n            return\r\n\r\n        self.window.blit(self.image, self.loc)", "response": "Draws the image at the given location."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreplacing the image with the new one.", "response": "def replace(self, key):\r\n        \"\"\"Selects a different image to be shown.\r\n\r\n        Parameters:\r\n            | key - a key in the original dictionary to specify which image to show\r\n\r\n        \"\"\"\r\n        if not (key in self.imagesDict):\r\n            print('The key', key, 'was not found in the collection of images dictionary')\r\n            raise KeyError\r\n        self.originalImage = self.imagesDict[key]\r\n        self.image = self.originalImage.copy()\r\n\r\n        # Set the rect of the image to appropriate values - using the current image\r\n        # then scale and rotate\r\n        self.rect = self.image.get_rect()\r\n        self.rect.x = self.loc[0]\r\n        self.rect.y = self.loc[1]\r\n\r\n        self.scale(self.percent, self.scaleFromCenter)\r\n        self.rotate(self.angle)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef handleEvent(self, eventObj):\r\n        if not self.visible:\r\n            return\r\n        if not self.isEnabled:\r\n            return False\r\n\r\n        if eventObj.type != MOUSEBUTTONDOWN:\r\n            # The animation only cares about a mouse down event\r\n            return False\r\n\r\n        eventPointInAnimationRect = self.rect.collidepoint(eventObj.pos)\r\n        if not eventPointInAnimationRect:  # clicked outside of animation\r\n            return False\r\n\r\n        if self.state == PygAnimation.PLAYING:  # if playing, ignore the click\r\n            return False\r\n\r\n        return True", "response": "This method should be called every time through the main loop."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef play(self):\r\n        if self.state == PygAnimation.PLAYING:\r\n            pass  # nothing to do\r\n\r\n        elif self.state == PygAnimation.STOPPED:  # restart from beginning of animation\r\n            self.index = 0  # first image in list\r\n            self.elapsed = 0\r\n            self.playingStartTime = time.time()\r\n            self.elapsedStopTime = self.endTimesList[-1]  # end of last animation image time\r\n            self.nextElapsedThreshold = self.endTimesList[0]\r\n            self.nIterationsLeft = self.nTimes  # typically 1\r\n\r\n        elif self.state == PygAnimation.PAUSED:  # restart where we left off\r\n            self.playingStartTime = time.time() - self.elapsedAtPause  # recalc start time\r\n            self.elapsed = self.elapsedAtPause\r\n            self.elapsedStopTime = self.endTimesList[-1]  # end of last animation image time\r\n            self.nextElapsedThreshold = self.endTimesList[self.index]\r\n\r\n        self.state = PygAnimation.PLAYING", "response": "Starts an animation playing."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef stop(self):\r\n        if self.state == PygAnimation.PLAYING:\r\n            self.index = 0  # set up for first image in list\r\n            self.elapsed = 0\r\n            self.nIterationsLeft = 0\r\n\r\n        elif self.state == PygAnimation.STOPPED:\r\n            pass  # nothing to do\r\n\r\n        elif self.state == PygAnimation.PAUSED:\r\n            self.index = 0  # set up for first image in list\r\n            self.elapsed = 0\r\n\r\n        self.state = PygAnimation.STOPPED", "response": "Stops a playing animation. A subsequent call to play will start from the beginning."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef pause(self):\r\n        if self.state == PygAnimation.PLAYING:\r\n            self.elapsedAtPause = self.elapsed\r\n            # only change state if it was playing\r\n            self.state = PygAnimation.PAUSED\r\n\r\n        elif self.state == PygAnimation.STOPPED:\r\n            pass  # nothing to do\r\n\r\n        elif self.state == PygAnimation.PAUSED:\r\n            pass", "response": "Pauses a playing animation. A subsequent call to play will continue where it left off."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nupdating the currently running animation.", "response": "def update(self):\r\n        \"\"\"Updates the currently running animation.\r\n\r\n        This method should be called in every frame where you want an animation to run.\r\n        Its job is to figure out if it is time to move onto the next image in the animation.\r\n\r\n        \"\"\"\r\n        returnValue = False  # typical return value\r\n        if self.state != PygAnimation.PLAYING:\r\n            return returnValue\r\n\r\n        # The job here is to figure out the index of the image to show\r\n        # and the matching elapsed time threshold for the current image\r\n        self.elapsed = (time.time() - self.playingStartTime)\r\n\r\n        if self.elapsed > self.elapsedStopTime:  # anim finished\r\n            if self.loop:  # restart the animation\r\n                self.playingStartTime = time.time()\r\n                self.nextElapsedThreshold = self.endTimesList[0]\r\n            else:  # not looping\r\n                self.nIterationsLeft = self.nIterationsLeft - 1\r\n                if self.nIterationsLeft == 0:  # done\r\n                    self.state = PygAnimation.STOPPED\r\n                    if self.callBack != None:  # if there is a callBack\r\n                        self.callBack(self.nickname)  # do it\r\n                    returnValue = True  # animation has ended\r\n                else:  # another iteration - start over again\r\n                    self.playingStartTime = time.time()\r\n                    self.nextElapsedThreshold = self.endTimesList[0]\r\n            self.index = 0\r\n\r\n        elif self.elapsed > self.nextElapsedThreshold:\r\n            # Time to move on to next picture\r\n            self.index = self.index + 1\r\n            self.nextElapsedThreshold = self.endTimesList[self.index]\r\n\r\n        return returnValue"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef draw(self):\r\n        # Assumes that self.index has been set earlier (typically in update method)\r\n        # it is used as the index of the current image/endTime/loc\r\n        theImage = self.imagesList[self.index]  # choose the image to show\r\n\r\n        if theImage is None:  # if there is no image to show\r\n            return\r\n\r\n        if self.visible:\r\n            theOffset = self.offsetsList[self.index]\r\n            theLoc = ((self.loc[0] + theOffset[0]), (self.loc[1] + theOffset[1]))\r\n            self.window.blit(theImage, theLoc)", "response": "Draws the current frame of the animation"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef cache(cls, key_attrs, expires=None):\n\n        def decorator(func):\n\n            @functools.wraps(func)\n            def wrapper(self, *args, **kwargs):\n                module = type(self).__module__\n                classname = type(self).__name__\n                method_name = func.__name__\n\n                data = {}\n                if isinstance(key_attrs, basestring):\n                    _key_attrs = key_attrs.split()\n                else:\n                    _key_attrs = key_attrs\n                for key_attr in _key_attrs:\n                    key_value = getattr(self, key_attr)\n                    if isinstance(key_value, dict):\n                        key_value = ('dict', sorted(key_value.items()))\n                    elif isinstance(key_value, set):\n                        key_value = ('set', sorted(key_value))\n                    else:\n                        key_value = (type(key_value).__name__, key_value)\n                    data[key_attr] = key_value\n                data = sorted(data.items())\n\n                result_cache, new = cls.get_or_create(\n                    module=module,\n                    classname=classname,\n                    method_name=method_name,\n                    data=data,\n                    args=args,\n                    kwargs=sorted(kwargs.items()),\n                )\n\n                if new:\n                    result_cache.result = func(self, *args, **kwargs)\n                    result_cache.save(expires)\n\n                return result_cache.result\n\n            return wrapper\n\n        return decorator", "response": "Decorator for methods that provide cached - memoization using the positional arguments keyword argments and a\n whitelisted instance attributes."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef assertCallerError(self, expected_arg0, callable_obj, *args, **kwargs):\n        try:\n            callable_obj(*args, **kwargs)\n            self.fail('Expected AssertionError, but no exception raised')\n        except AssertionError, exc:\n            self.assertEqual(exc.args[0], expected_arg0)\n        except Exception, exc:\n            self.fail('Expected AssertionError, but got %s' % repr(exc))", "response": "Assert that a callable raises an AssertionError with a particular argument."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_region_nt_counts(region, bam, stranded=False):\n    # TODO: I should figure out what the different possible values are that\n    # pysam could give me back (so far I only have ATCGN). Can I get deletions\n    # and insertions? \n    # TODO: This could probably be parallelized.\n    if type(bam) == str:\n        bam = pysam.AlignmentFile(bam, 'rb')\n\n    if type(region) is str:\n        r = parse_region(region)\n        if len(r) == 3:\n            chrom, start, end = r\n        elif len(r) == 4:\n            chrom, start, end, strand = r\n        start = int(start)\n        end = int(end)\n        ind = ['{}:{}'.format(chrom, x) for \n               x in range(start, end + 1)]\n        pp = bam.pileup(region=region, truncate=True)\n    \n    elif type(region) is (list or tuple):\n        chrom, start, end = region\n        ind = ['{}:{}'.format(chrom, x) for \n               x in range(int(start) + 1, int(end) + 1)]\n        pp = bam.pileup(chrom, start, end, truncate=True)\n   \n    cols = ['A', 'T', 'C', 'G', 'N']\n    if stranded:\n        cols = ['{}+'.format(x) for x in cols] + ['{}-'.format(x) for x in cols]\n    counts = pd.DataFrame(0, index=ind, columns=cols)\n    \n    for pc in pp: \n        # Most of this code deals with R1 and R2 reads that overlap so that we\n        # don't get two counts from one fragment.\n        pos = pc.reference_pos + 1\n        r1_qnames = []\n        r1_nts = []\n        r2_qnames = []\n        r2_nts = []\n        for pr in pc.pileups:\n            qnames = [r1_qnames, r2_qnames][pr.alignment.is_read2]\n            nts = [r1_nts, r2_nts][pr.alignment.is_read2]\n            nt = _pos_nt(pr, pc.reference_pos, stranded)\n            if nt:\n                qnames.append(pr.alignment.qname)\n                nts.append(nt)\n        r1 = pd.Series(r1_nts, index=r1_qnames)\n        r2 = pd.Series(r2_nts, index=r2_qnames)\n        df = pd.DataFrame([r1, r2], index=['R1', 'R2']).T\n        singles = df[df.isnull().sum(axis=1) == 1]\n        doubles = df.dropna()\n        vcs = []\n        vcs.append(singles['R1'].value_counts())\n        vcs.append(singles['R2'].value_counts())\n        doubles = doubles[doubles.R1 == doubles.R2]\n        vcs.append(doubles.R1.value_counts())\n        for vc in vcs:\n            counts.ix['{}:{}'.format(chrom, pos), vc.index] += vc\n    return counts", "response": "Get counts of each nucleotide in a given region."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _pos_nt(pr, pos, stranded=False):\n    nt = None\n    bases = dict(zip(pr.alignment.get_reference_positions(), \n                     list(pr.alignment.seq.upper())))\n    if pos in bases.keys():\n        nt = bases[pos]\n    if nt and stranded:\n        strand = None\n        if pr.alignment.is_read1 and pr.alignment.is_reverse:\n            strand = '+'\n        if pr.alignment.is_read2 and not pr.alignment.is_reverse:\n            strand = '+'\n        if pr.alignment.is_read1 and not pr.alignment.is_reverse:\n            nt = str(Seq(nt).reverse_complement())\n            strand = '-'\n        if pr.alignment.is_read2 and pr.alignment.is_reverse:\n            nt = str(Seq(nt).reverse_complement())\n            strand = '-'\n        nt = '{}{}'.format(nt, strand)\n    return nt", "response": "Given a pileup read and a position return the base that is covered by the\n    read at that position."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef nt_counts(bam, positions, stranded=False, vcf=False, bed=False):\n    if not bed and not vcf:\n        if type(positions) == pbt.bedtool.BedTool:\n            df = positions.to_dataframe()\n        elif positions[-4:] == '.bed':\n            bed = True\n        elif positions[-4:] == '.vcf':\n            vcf = True\n        else:\n            sys.stderr.write('Positions must be BedTool, bed file, or vcf '\n                             'file.\\n')\n\n    if bed:\n        df = pbt.BedTool(positions).to_dataframe()\n    elif vcf:\n        from variants import vcf_as_df\n        tdf = vcf_as_df(positions)\n        df = pd.DataFrame(index=tdf.index)\n        df['chrom'] = tdf.CHROM\n        df['start'] = tdf.POS - 1\n        df['end'] = tdf.POS\n\n    res = []\n    for i in df.index:\n        region = [df.ix[i, 'chrom'], df.ix[i, 'start'], df.ix[i, 'end']]\n        res.append(get_region_nt_counts(region, bam, stranded))\n    res = pd.concat(res)\n    return res", "response": "Return the number of nucleotides covered at all positions in a BAM file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the results of an API call. This is the main work horse of the class. It builds the API query string and sends the request to MetaSmoke. If there are multiple pages of results, and we've configured `max_pages` to be greater than 1, it will automatically paginate through the results and return a single object. Returned data will appear in the `items` key of the resulting dictionary. :param endpoint: (string) The API end point being called. Available endpoints are listed on the official `API Documentation <https://github.com/Charcoal-SE/metasmoke/wiki/API-Documentation>`__. This can be as simple as ``fetch('posts/feedback')``, to call feedback end point If calling an end point that takes additional parameter, such as `id`s pass the ids as a list to the `ids` key: .. code-block:: python fetch('posts/{ids}', ids=[1,2,3]) This will attempt to retrieve the posts for the three listed ids. If no end point is passed, a ``ValueError`` will be raised :param page: (int) The page in the results to start at. By default, it will start on the first page and automatically paginate until the result set reaches ``max_pages``. :param kwargs: Parameters accepted by individual endpoints. These parameters **must** be named the same as described in the endpoint documentation :rtype: (dictionary) A dictionary containing wrapper data regarding the API call and the results of the call in the `items` key. If multiple pages were received, all of the results will appear in the ``items`` tag.", "response": "def fetch(self, endpoint=None, page=1, **kwargs):\n        \"\"\"Returns the results of an API call.\n\n            This is the main work horse of the class. It builds the API query\n            string and sends the request to MetaSmoke. If there are multiple\n            pages of results, and we've configured `max_pages` to be greater than\n            1, it will automatically paginate through the results and return a\n            single object.\n\n            Returned data will appear in the `items` key of the resulting\n            dictionary.\n\n            :param endpoint: (string) The API end point being called. Available endpoints are listed on\n                the official `API Documentation <https://github.com/Charcoal-SE/metasmoke/wiki/API-Documentation>`__.\n\n                This can be as simple as ``fetch('posts/feedback')``, to call feedback end point\n\n                If calling an end point that takes additional parameter, such as `id`s\n                pass the ids as a list to the `ids` key:\n\n                    .. code-block:: python\n\n                        fetch('posts/{ids}', ids=[1,2,3])\n\n                This will attempt to retrieve the posts for the three listed ids.\n\n                If no end point is passed, a ``ValueError`` will be raised\n            :param page: (int) The page in the results to start at. By default, it will start on\n                the first page and automatically paginate until the result set\n                reaches ``max_pages``.\n            :param kwargs: Parameters accepted by individual endpoints. These parameters\n                **must** be named the same as described in the endpoint documentation\n            :rtype: (dictionary) A dictionary containing wrapper data regarding the API call\n                and the results of the call in the `items` key. If multiple\n                pages were received, all of the results will appear in the\n                ``items`` tag.\n            \"\"\"\n\n        if not endpoint:\n            raise ValueError('No endpoint provided.')\n\n        self._endpoint = endpoint\n\n        params = {\"per_page\": self.per_page,\n                  \"page\": page,\n                  \"key\": self._api_key\n                  }\n\n        # This block will replace {ids} placeholds in end points\n        # converting .fetch('posts/{ids}', ids=[222, 1306, 99999]) to\n        #   posts/222;1306;99999\n        for k, value in kwargs.items():\n            if \"{\" + k + \"}\" in endpoint:\n                endpoint = endpoint.replace(\"{\" + k + \"}\", ';'.join(str(x) for x in value))\n                kwargs.pop(k, None)\n\n        date_time_keys = ['from_date', 'to_date']\n        for k in date_time_keys:\n            if k in kwargs:\n                if isinstance(kwargs[k], datetime.datetime):\n                    kwargs[k] = int(calendar.timegm(kwargs[k].utctimetuple()))\n\n        # This block will see if there there are ids remaining\n        # This would occur if the developer passed `posts` instead of `posts/{ids}` to `fetch`\n        # If this is the case, then convert to a string and assume this goes at the end of the endpoint\n\n        if 'ids' in kwargs:\n            ids = ';'.join(str(x) for x in kwargs['ids'])\n            kwargs.pop('ids', None)\n            endpoint += \"/{}\".format(ids)\n\n        params.update(kwargs)\n\n        data = []\n        run_cnt = 1\n        while run_cnt <= self.max_pages:\n            run_cnt += 1\n\n            base_url = \"{}{}/\".format(self._base_url, endpoint)\n\n            try:\n                response = requests.get(base_url, params=params, proxies=self.proxy)\n            except requests.exceptions.ConnectionError as e:\n                raise SmokeAPIError(self._previous_call, str(e), str(e), str(e))\n\n            self._previous_call = response.url\n\n            try:\n                response.encoding = 'utf-8-sig'\n                response = response.json()\n            except ValueError as e:\n                raise SmokeAPIError(self._previous_call, str(e), str(e), str(e))\n\n            try:\n                code = response[\"error_code\"]\n                name = response[\"error_name\"]\n                message = response[\"error_message\"]\n                raise SmokeAPIError(self._previous_call, code, name, message)\n            except KeyError:\n                pass  # This means there is no error\n\n            data.append(response)\n\n            if len(data) < 1:\n                break\n\n            if 'has_more' in response and response['has_more']:\n                params[\"page\"] += 1\n            else:\n                break\n\n        r = []\n        for d in data:\n            r.extend(d['items'])\n        items = list(chain(r))\n        has_more = data[-1]['has_more'] if 'has_more' in data[-1] else False\n        result = {'has_more': has_more,\n                  'page': params['page'],\n                  'total': len(items),\n                  'items': items}\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsends data to the API.", "response": "def send_data(self, endpoint=None,  **kwargs):\n        \"\"\"Sends data to the API.\n\n        This call is similar to ``fetch``, but **sends** data to the API instead\n        of retrieving it.\n\n        Returned data will appear in the ``items`` key of the resulting\n        dictionary.\n\n        Sending data **requires** that the ``token`` is set.\n\n        :param endpoint: (string) **(Required)** The API end point being called. Available endpoints are listed on\n            the official `API Documentation <https://github.com/Charcoal-SE/metasmoke/wiki/API-Documentation>`__.\n\n            If no end point is passed, a ``ValueError`` will be raised\n        :param kwargs: Parameters accepted by individual endpoints. These parameters\n            **must** be named the same as described in the endpoint documentation\n        :rtype: (dictionary) A dictionary containing wrapper data regarding the API call\n            and the results of the call in the `items` key. If multiple\n            pages were received, all of the results will appear in the\n            ``items`` tag.\n        \"\"\"\n        if not endpoint:\n            raise ValueError('No end point provided.')\n\n        if not self.token:\n            raise ValueError('A write token has not been set. This is required for all MetaSmoke API routes. This can\\n'\n                             'be set by setting the \"token\" parameter of your SmokeAPI object.')\n\n        self._endpoint = endpoint\n\n        params = {\n            \"key\": self._api_key,\n            \"token\": self.token\n        }\n\n        if 'ids' in kwargs:\n            ids = ';'.join(str(x) for x in kwargs['ids'])\n            kwargs.pop('ids', None)\n        else:\n            ids = None\n\n        params.update(kwargs)\n\n        data = []\n\n        base_url = \"{}{}/\".format(self._base_url, endpoint)\n        response = requests.post(base_url, data=params, proxies=self.proxy)\n        self._previous_call = response.url\n        response = response.json()\n\n        try:\n            code = response[\"error_code\"]\n            name = response[\"error_name\"]\n            message = response[\"error_message\"]\n            raise SmokeAPIError(self._previous_call, code, name, message)\n        except KeyError:\n            pass  # This means there is no error\n\n        data.append(response)\n        r = []\n        for d in data:\n            r.extend(d['items'])\n        items = list(chain(r))\n        result = {'has_more': data[-1]['has_more'],\n                  'page': params['page'],\n                  'total': len(items),\n                  'items': items}\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef save(self, name, file):\n        # Get the proper name for the file, as it will actually be saved.\n        if name is None:\n            name = file.name\n\n        if not hasattr(file, 'chunks'):\n            file = File(file, name=name)\n\n        name = self.get_available_name(name)\n        name = self._save(name, file)\n\n        # Store filenames with forward slashes, even on Windows\n        return name.replace('\\\\', '/')", "response": "Saves new content to the file specified by name."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _prepend_name_prefix(self, name):\n        if not self.name_prefix:\n            return name\n        base = self.name_prefix\n        if base[0] != '/':\n            base = '/' + base\n        if name[0] != '/':\n            name = '/' + name\n        return base + name", "response": "Return file name with the prefix directory prepended"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef request_signature(self, stringtosign):\n        digest = hmac.new(\n            self.secret_key.encode(ENCODING),\n            stringtosign.encode(ENCODING),\n            hashlib.sha1\n        ).digest()\n        return b64_string(digest)", "response": "Construct a base64 - encoded signature for the request."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _get_content_type(self, file):\n        if file.mimetype:\n            return file.mimetype\n\n        # get file extension\n        _, extension = os.path.splitext(file.name)\n        extension = extension.strip('.')\n\n        # Make an educated guess about what the Content-Type should be.\n        return media_types[extension] if extension in media_types else 'binary/octet-stream'", "response": "Get the content type of a file."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _put_file(self, file):\n\n        post_params = {\n            'file_size': file.size,\n            'file_hash': file.md5hash(),\n            'content_type': self._get_content_type(file),\n\n        }\n\n        headers = self._request_headers('PUT', file.prefixed_name, post_params=post_params)\n\n        with closing(HTTPConnection(self.netloc)) as conn:\n            conn.request('PUT', file.prefixed_name, file.read(), headers=headers)\n            response = conn.getresponse()\n\n            if response.status not in (200,):\n                raise S3IOError(\n                    'py3s3 PUT error. '\n                    'Response status: {}. '\n                    'Reason: {}. '\n                    'Response Text: \\n'\n                    '{}'.format(response.status, response.reason, response.read()))", "response": "Send PUT request to S3 with file contents"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _get_file(self, prefixed_name):\n        headers = self._request_headers('GET', prefixed_name)\n        file = S3ContentFile('')\n        with closing(HTTPConnection(self.netloc)) as conn:\n            conn.request('GET', prefixed_name, headers=headers)\n            response = conn.getresponse()\n            if not response.status in (200,):\n                if response.length is None:\n                    # length == None seems to be returned from GET requests\n                    # to non-existing files\n                    raise S3FileDoesNotExistError(prefixed_name)\n                # catch all other cases\n                raise S3IOError(\n                    'py3s3 GET error. '\n                    'Response status: {}. '\n                    'Reason: {}. '\n                    'Response Text: \\n'\n                    '{}'.format(response.status, response.reason, response.read()))\n\n            file = S3ContentFile(response.read())\n        return file", "response": "Get a file from the S3"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning URL of resource", "response": "def url(self, name):\n        \"\"\"Return URL of resource\"\"\"\n        scheme = 'http'\n        path = self._prepend_name_prefix(name)\n        query = ''\n        fragment = ''\n        url_tuple = (scheme, self.netloc, path, query, fragment)\n        return urllib.parse.urlunsplit(url_tuple)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_all_tasks(conf):\n\n    db = HamsterDB(conf)\n\n    fact_list = db.all_facts_id\n    security_days = int(conf.get_option('tasks.security_days'))\n    today = datetime.today()\n\n    tasks = {}\n\n    for fact_id in fact_list:\n        ht = HamsterTask(fact_id, conf, db)\n        if ht.end_time:\n            end_time = ht.get_object_dates()[1]\n            if today - timedelta(security_days) <= end_time:\n                rt = ht.get_remote_task()\n                tasks[rt.task_id] = rt\n\n    db.close_connection()\n\n    print 'Obtained %d tasks' % len(tasks)\n    return tasks", "response": "Returns a list with every task registred on Hamster.\n   "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef SetEncoding(sval):\n    global encoding\n    s=sval.lower()\n    if s == \"additive\":\n        encoding = Encoding.Additive\n    elif s == \"dominant\":\n        encoding = Encoding.Dominant\n    elif s == \"recessive\":\n        encoding = Encoding.Recessive\n    elif s == \"genotype\":\n        encoding = Encoding.Genotype\n    elif s == \"raw\":\n        encoding = Encoding.Raw\n    else:\n        raise InvalidSelection(\"Invalid encoding, %s, selected\" % (sval))", "response": "Sets the encoding variable according to the text specification passed in."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef ReportConfiguration(self, file):\n        global encodingpar\n        print >> file, BuildReportLine(\"FAM FILE\", self.fam_details)\n        print >> file, BuildReportLine(\"IMPUTE_ARCHIVES\", \"%s:%s\" % (str(self.chroms[0]), self.archives[0]))\n        idx = 0\n        for arch in self.archives[1:]:\n            print >> file, BuildReportLine(\"\", \"%s:%s\" % (str(self.chroms[idx+1]), arch))\n            idx += 1\n        print >> file, BuildReportLine(\"ENCODING\", [\"Additive\", \"Dominant\", \"Recessive\", \"Genotype\", \"Raw\"][encoding])\n        print >> file, BuildReportLine(\"INFO-EXT\", Parser.info_ext)\n        print >> file, BuildReportLine(\"INFO-THRESH\", Parser.info_threshold)", "response": "Prints out the configuration of the current instance of the class."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef load_family_details(self, pheno_covar):\n        file = open(self.fam_details)\n        header = file.readline()\n        format = file.readline()\n        self.file_index = 0\n\n        mask_components = []        # 1s indicate an individual is to be masked out\n        for line in file:\n            words = line.strip().split()\n            indid = \":\".join(words[0:2])\n            if DataParser.valid_indid(indid):\n                mask_components.append(0)\n                sex = int(words[5])\n                pheno = float(words[6])\n                pheno_covar.add_subject(indid, sex, pheno)\n            else:\n                mask_components.append(1)\n        mask_components = numpy.array(mask_components)\n        self.ind_mask = numpy.zeros(len(mask_components) * 2, dtype=numpy.int8).reshape(-1, 2)\n        self.ind_mask[0:, 0] = mask_components\n        self.ind_mask[0:, 1] = mask_components\n        self.ind_count = self.ind_mask.shape[0]\n        pheno_covar.freeze_subjects()", "response": "Load family details into the object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef load_genotypes(self):\n\n\n        if self.file_index < len(self.archives):\n            self.current_file = self.archives[self.file_index]\n            info_filename = self.current_file.replace(Parser.gen_ext, Parser.info_ext)\n            if len(self.info_files) > 0:\n                info_filename = self.info_files[self.file_index]\n            self.info_file = open(info_filename)\n            self.info_file.readline()   # Dump the header\n\n            if DataParser.compressed_pedigree:\n                self.freq_file = gzip.open(\"%s\" % (self.current_file), 'rb')\n            else:\n                self.freq_file = open(self.current_file)\n            self.current_chrom = self.chroms[self.file_index]\n            self.file_index += 1\n        else:\n            raise StopIteration", "response": "Prepares the files for genotype parsing."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_next_line(self):\n\n        line = self.freq_file.readline().strip().split()\n        if len(line) < 1:\n            self.load_genotypes()\n            line = self.freq_file.readline().strip().split()\n        info_line = self.info_file.readline().strip().split()\n        info = float(info_line[4])\n        exp_freq = float(info_line[3])\n        return line, info, exp_freq", "response": "Get the next line of the file."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef populate_iteration(self, iteration):\n        global encoding\n        line, info, exp_freq = self.get_next_line()\n\n        if info > Parser.info_threshold:\n            junk, iteration.rsid, iteration.pos, iteration.major_allele, iteration.minor_allele = line[0:5]\n            iteration.chr = self.current_chrom\n            iteration.pos = int(iteration.pos)\n            if DataParser.boundary.TestBoundary(iteration.chr, iteration.pos, iteration.rsid):\n                frequencies = []\n                idx = 5\n                total_maf = 0.0\n                additive = []\n                for is_ignored in self.ind_mask[:,0]:\n                    if not is_ignored:\n                        AA,Aa,aa = [float(x) for x in line[idx:idx+3]]\n                        additive.append(Aa+2*aa)\n                        if encoding==Encoding.Dominant:\n                            estimate = Aa + aa\n                        elif encoding==Encoding.Additive:\n                            estimate = additive[-1]\n                        elif encoding==Encoding.Recessive:\n                            estimate = aa\n                        elif encoding==Encoding.Genotype:\n                            if Aa >= AA and Aa >= aa:\n                                estimate = 1\n                            elif AA >= Aa and AA >= aa:\n                                estimate = 0\n                            else:\n                                estimate = 2\n                        elif encoding==Encoding.Raw:\n                            estimate = [AA, Aa, aa]\n                        total_maf += numpy.sqrt(aa)\n                        frequencies.append(estimate)\n                    idx += 3\n                iteration.non_missing_alc = len(additive)*2\n                maf = numpy.mean(numpy.array(additive))/2\n                iteration.allele_count2 = maf * (len(additive) * 2)\n                iteration.effa_freq = maf\n\n                if maf > 0.5:\n                    iteration.min_allele_count = len(additive)*2 - iteration.allele_count2\n                    iteration.maj_allele_count = iteration.allele_count2\n                    maf = 1.0 - maf\n                else:\n                    iteration.min_allele_count = iteration.allele_count2\n                    iteration.maj_allele_count = len(additive)*2 - iteration.allele_count2\n\n                iteration._maf = maf\n                iteration.genotype_data = numpy.array(frequencies)\n\n                return iteration.maf >= DataParser.min_maf and iteration.maf <= DataParser.max_maf\n            else:\n                return False\n        else:\n            return False", "response": "Populate the ParseLocus object with the information from the file and iteration with relevant marker \\\n details."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a requests. Session object that can be used to make requests.", "response": "def session(self):\n        \"\"\"\n        This is what you should use to make requests.  It sill authenticate for you.\n        :return: requests.sessions.Session\n        \"\"\"\n        if not self._session:\n            self._session = requests.Session()\n            self._session.headers.update(dict(Authorization='Bearer {0}'.format(self.token)))\n        return self._session"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning sanitized docstring from an entity.", "response": "def parse_docstring(entity):\n    \"\"\" Return sanitized docstring from an entity.  The first line of the\n    docstring is the title, and remaining lines are the details, aka git\n    style. \"\"\"\n    doc = inspect.getdoc(entity)\n    if not doc:\n        return None, None\n    doc = doc.splitlines(keepends=True)\n    if not doc[0].strip():\n        doc.pop(0)\n    title = (doc and doc.pop(0).strip()) or None\n    if doc and not doc[0].strip():\n        doc.pop(0)\n    desc = ''.join(doc).rstrip() or None\n    return title, desc"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nparsing the arguments string or sys. argv.", "response": "def parse_args(self, argv=None):\n        \"\"\" Return an argparse.Namespace of the argv string or sys.argv if\n        argv is None. \"\"\"\n        arg_input = shlex.split(argv) if argv is not None else None\n        self.get_or_create_session()\n        return self.argparser.parse_args(arg_input)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_pager_spec(self):\n        self_config = self.get_config()\n        pagercmd = self_config.get('pager')\n        istty = self_config.getboolean('pager_istty')\n        core_config = self.get_config('core')\n        if pagercmd is None:\n            pagercmd = core_config.get('pager')\n        if istty is None:\n            istty = core_config.get('pager_istty')\n        return {\n            \"pagercmd\": pagercmd,\n            \"istty\": istty\n        }", "response": "Find the best pager settings for this command."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef run_wrap(self, args):\n        self.fire_event('prerun', args)\n        self.prerun(args)\n        try:\n            if self.session.allow_pager and self.use_pager:\n                desc = 'Command\\: %s' % '-'.join(self.prog.split())\n                with paging.pager_redirect(desc, **self.get_pager_spec()):\n                    result = self.run(args)\n            else:\n                result = self.run(args)\n        except (SystemExit, Exception) as e:\n            self.postrun(args, exc=e)\n            self.fire_event('postrun', args, exc=e)\n            raise e\n        else:\n            self.postrun(args, result=result)\n            self.fire_event('postrun', args, result=result)\n            return result", "response": "Wrap some standard protocol around a command s run method."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the merged end - user configuration for this command or a specific section if set in section.", "response": "def get_config(self, section=None):\n        \"\"\" Return the merged end-user configuration for this command or a\n        specific section if set in `section`. \"\"\"\n        config = self.session.config\n        section = self.config_section() if section is None else section\n        try:\n            return config[section]\n        except KeyError:\n            config.add_section(section)\n            return config[section]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef parent(self, parent):\n        self._parent = parent\n        if parent:\n            pctx = dict((x, getattr(parent, x)) for x in parent.context_keys)\n            self.inject_context(pctx)\n            self.depth = parent.depth + 1\n            for command in self.subcommands.values():\n                command.parent = self  # bump.\n        else:\n            self.depth = 0", "response": "Copy context from the parent into this instance and adjusting or depth value."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef find_root(self):\n        cmd = self\n        while cmd.parent:\n            cmd = cmd.parent\n        return cmd", "response": "Traverse parent refs to top."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ninject the given context dictionary into this instance s attributes and any subcommands.", "response": "def inject_context(self, __context_dict__=None, **context):\n        \"\"\" Map context dict to this instance as attributes and keep note of\n        the keys being set so we can pass this along to any subcommands. \"\"\"\n        context = context or __context_dict__\n        self.context_keys |= set(context.keys())\n        for key, value in context.items():\n            setattr(self, key, value)\n        for command in self.subcommands.values():\n            command.inject_context(context)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef prog(self, prog):\n        self.argparser.prog = prog\n        fmt = '%s %%s' % prog if prog else '%s'\n        for command in self.subcommands.values():\n            command.prog = fmt % command.name\n        # Rebind autoenv vars with recomputed key.\n        for action in self._autoenv_actions:\n            self.argparser.unbind_env(action)\n            self.argparser.bind_env(action, self._make_autoenv(action))", "response": "Update ourself and any of our subcommands with the given prog."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets the depth of the current instance.", "response": "def depth(self, value):\n        \"\"\" Update ourself and any of our subcommands. \"\"\"\n        for command in self.subcommands.values():\n            command.depth = value + 1\n            del command.argparser._defaults[self.arg_label_fmt % self._depth]\n            command.argparser._defaults[self.arg_label_fmt % value] = command\n        self._depth = value"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add_argument(self, *args, parser=None, autoenv=False, env=None,\n                     complete=None, **kwargs):\n        \"\"\" Allow cleaner action supplementation.  Autoenv will generate an\n        environment variable to be usable as a defaults setter based on the\n        command name and the dest property of the action. \"\"\"\n        if parser is None:\n            parser = self.argparser\n        action = parser.add_argument(*args, **kwargs)\n        if autoenv:\n            if env is not None:\n                raise TypeError('Arguments `env` and `autoenv` are mutually '\n                                'exclusive')\n            env = self._make_autoenv(action)\n        if env:\n            self.argparser.bind_env(action, env)\n            if autoenv:\n                self._autoenv_actions.add(action)\n        if complete:\n            action.complete = complete\n        return action", "response": "Allow cleaner action supplementation."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngenerating a suitable env variable for this action.", "response": "def _make_autoenv(self, action):\n        \"\"\" Generate a suitable env variable for this action.  This is\n        dependant on our subcommand hierarchy.  Review the prog setter for\n        details. \"\"\"\n        env = ('%s_%s' % (self.prog, action.dest)).upper()\n        env = re.sub(self.env_scrub_re, '', env.strip())\n        env = re.sub(self.env_flatten_re, '_', env)\n        if re.match('^[0-9]', env):\n            # Handle leading numbers.\n            env = '_%s' % env\n        return env"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add_file_argument(self, *args, mode='r', buffering=1,\n                          filetype_options=None, **kwargs):\n        \"\"\" Add a tab-completion safe FileType argument.  This argument\n        differs from a normal argparse.FileType based argument in that the\n        value is a factory function that returns a file handle instead of\n        providing an already open file handle.  There are various reasons\n        why this is a better approach but it is also required to avoid\n        erroneous creation of files with shellish tab completion. \"\"\"\n        type_ = supplement.SafeFileType(mode=mode, bufsize=buffering,\n                                        **filetype_options or {})\n        return self.add_argument(*args, type=type_, **kwargs)", "response": "Add a tab - completion safe FileType argument."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef create_argparser(self):\n        if self.desc:\n            if self.title:\n                fulldesc = '%s\\n\\n%s' % (self.title, self.desc)\n            else:\n                fulldesc = self.desc\n        else:\n            fulldesc = self.title\n        return self.ArgumentParser(command=self, prog=self.name,\n                                   description=fulldesc)", "response": "Returns an ArgParser instance compatible with the current command."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate a session and inject it as context for this command and any subcommands.", "response": "def attach_session(self):\n        \"\"\" Create a session and inject it as context for this command and any\n        subcommands. \"\"\"\n        assert self.session is None\n        root = self.find_root()\n        session = self.Session(root)\n        root.inject_context(session=session)\n        return session"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting and format completer choices.", "response": "def complete(self, text, line, begin, end):\n        \"\"\" Get and format completer choices.  Note that all internal calls to\n        completer functions must use [frozen]set()s. \"\"\"\n        self.fire_event('precomplete', text, line, begin, end)\n        choices = self._complete(text, line, begin, end)\n        choices -= self.completion_excludes\n        sz = len(choices)\n        if sz == 1:\n            # XXX: This is pretty bad logic here.  In reality we need much\n            # more complicated escape handling and imbalanced quote support.\n            return set(shlex.quote(x) for x in choices)\n        elif sz > 2:\n            # We don't need the sentinel choice to prevent completion\n            # when there is already more than 1 choice.\n            choices -= {completer.ActionCompleter.sentinel}\n        self.fire_event('postcomplete', choices)\n        return choices"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _complete(self, text, line, begin, end):\n        line = line[:end]  # Ignore characters following the cursor.\n        fullargs = self.split_line(line)[1:]\n        args = fullargs[:]\n        options = self.deep_scan_parser(self.argparser)\n\n        # Walk into options tree if subcommands are detected.\n        last_subcommand = None\n        while True:\n            for key, completers in options.items():\n                if key in args and hasattr(completers[0], 'items'):\n                    args.remove(key)\n                    last_subcommand = key\n                    options = completers[0]\n                    break\n            else:\n                break\n\n        if text == last_subcommand:\n            # We have to specially catch the case where the last argument is\n            # the key used to find our subparser.  More specifically when the\n            # cursor is not preceded by a space too, as this prevents the\n            # completion routines from continuing.  The simplest way without\n            # complicating the algo for coming up with our options list is to\n            # simply shortcut the completer by returning a single item.\n            # Subsequent tabs will work normally.\n            return {text}\n\n        # Look for incomplete actions.\n        choices = set(x for x in options\n                      if x is not None and x.startswith(text))\n        arg_buf = []\n        pos_args = []\n        trailing_action = None\n        # The slice below skips the last arg if it is 'active'.\n        for x in reversed(args[:-1 if text else None]):\n            if x in options:\n                action = options[x][0]\n                action.consume(arg_buf)\n                pos_args.extend(arg_buf)\n                del arg_buf[:]\n                if action.full:\n                    choices -= {action.key}\n                if not trailing_action:\n                    trailing_action = action\n                    if not action.full:\n                        if action.reached_min:\n                            choices |= action(self, text, fullargs)\n                            choices -= {action.key}\n                        else:\n                            choices = action(self, text, fullargs)\n                            break\n            else:\n                arg_buf.insert(0, x)\n        pos_args.extend(arg_buf)\n\n        # Feed any remaining arguments in the buffer to positionals so long as\n        # there isn't a trailing action that can still consume.\n        if None in options and (not trailing_action or trailing_action.full):\n            for x_action in options[None]:\n                x_action.consume(pos_args)\n                if not x_action.reached_min:\n                    choices = x_action(self, text, fullargs)\n                    break\n                elif not x_action.full:\n                    choices |= x_action(self, text, fullargs)\n        return choices", "response": "This is the main completion routine for the command line."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ntrying to split the line until shlex can t parse it.", "response": "def split_line(self, line):\n        \"\"\" Try to do pure shlex.split unless it can't parse the line. In that\n        case we trim the input line until shlex can split the args and tack the\n        unparsable portion on as the last argument. \"\"\"\n        remainder = []\n        while True:\n            try:\n                args = shlex.split(line)\n            except ValueError:\n                remainder.append(line[-1])\n                line = line[:-1]\n            else:\n                if remainder:\n                    args.append(''.join(reversed(remainder)))\n                return args"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_commands_from(self, args):\n        commands = []\n        for i in itertools.count(0):\n            try:\n                commands.append(getattr(args, self.arg_label_fmt % i))\n            except AttributeError:\n                break\n        return commands", "response": "This method scans the command arguments for each level and returns a list of the command arguments."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _take_bits(buf, count):\n\n    # TODO: Verify output\n    bytes_count = (count + 7) // 8\n    bytes_mod = count % 8\n    data = _unpack_from(buf, 'B', bytes_count)\n    values = []\n    for i, byte in enumerate(data):\n        for _ in range(8 if i != bytes_count - 1 else bytes_mod):\n            # TODO: Convert to True / False\n            values.append(byte & 0b10000000)\n            byte <<= 1\n    return values", "response": "Return the booleans that were packed into bytes."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a human-readable dictionary from the inibin. Arguments: key_mapping -- Dictionary used for conversion. Supports nesting. Every other value should be a numeric inibin key, or a tuple of the key and a function to apply to the result. inibin -- The dictionary returned from reading an inibin. string_table -- Used to translate strings. Any string with a key in string_table will be replaced. Typically loaded from a fontconfig_*.txt.", "response": "def _fix_keys(key_mapping, inibin, string_table=None):\n    \"\"\"\n    Return a human-readable dictionary from the inibin.\n\n    Arguments:\n    key_mapping -- Dictionary used for conversion. Supports nesting. Every other\n        value should be a numeric inibin key, or a tuple of the key and a\n        function to apply to the result.\n    inibin -- The dictionary returned from reading an inibin.\n    string_table -- Used to translate strings. Any string with a key in\n        string_table will be replaced. Typically loaded from a fontconfig_*.txt.\n    \"\"\"\n    if string_table is None:\n        string_table = {}\n\n    def walk(node, out_node):\n        # Walk the nodes of the key mapping\n        for key, value in node.items():\n            if isinstance(value, dict):\n                if key not in out_node:\n                    out_node[key] = {}\n                walk(value, out_node[key])\n            else:\n                # Can either be just the index, or the index plus a function to apply\n                func = None\n                if isinstance(value, tuple):\n                    func = value[-1]\n                    index = value[0]\n                else:\n                    index = value\n\n                if index is None or index not in inibin:\n                    out_node[key] = None\n                    continue\n\n                val = inibin[index]\n\n                # Try numeric conversion\n                # Inibins often store numbers in strings\n                if isinstance(val, bytes):\n                    try:\n                        val = int(val)\n                    except ValueError:\n                        try:\n                            val = float(val)\n                        except ValueError:\n                            val = val.decode('utf8')\n\n                # Check if value is a reference to a fontconfig key\n                if val in string_table:\n                    val = string_table[val]\n\n                # Apply the function\n                if callable(func):\n                    val = func(val)\n\n                out_node[key] = val\n\n    out = {}\n    walk(key_mapping, out)\n\n    return out"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _unpack_from(buf, format_s, count=None, little_endian=True):\n\n    if count is not None:\n        assert count > 0\n        format_s = '%i%s' % (count, format_s)\n\n    if little_endian is True:\n        format_s = '<' + format_s\n    else:\n        format_s = '>' + format_s\n\n    size = struct.calcsize(format_s)\n    res = struct.unpack_from(format_s, buf.read(size))\n\n    if count is not None:\n        return res\n    else:\n        return res[0]", "response": "Read a binary format from the buffer."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef make_octal_permissions_mode(user=(False, False, False), group=(False, False, False), other=(False, False, False)):\n    # Create single digit code for each name\n    mode = ''\n    for name in (user, group, other):\n        read, write, execute = name\n\n        # Execute\n        if execute and not all(i for i in (read, write)):\n            code = 1\n\n        # Write\n        elif write and not all(i for i in (read, execute)):\n            code = 2\n\n        # Write & Execute\n        elif all(i for i in (write, execute)) and not read:\n            code = 3\n\n        # Read\n        elif read and not all(i for i in (write, execute)):\n            code = 4\n\n        # Read & Execute\n        elif all(i for i in (read, execute)) and not write:\n            code = 5\n\n        # Read & Write\n        elif all(i for i in (read, write)) and not execute:\n            code = 6\n\n        # Read, Write & Execute\n        elif all(i for i in (read, write, execute)):\n            code = 7\n        else:\n            code = 0\n        mode += str(code)\n    return int(mode)", "response": "Create a permissions bit in absolute notation ( octal."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset permissions mode for a file or directory.", "response": "def set_permissions_mode_from_octal(file_path, code):\n    \"\"\"\n    Set permissions for a file or directory.\n\n    :param file_path: Path to a file or directory\n    :param code: Permission code in absolute notation (octal)\n    :return:\n    \"\"\"\n    # Unpack permissions tuple\n    user, group, other = tuple(str(code[-3:])) if len(str(code)) > 3 else tuple(str(code))\n    user, group, other = int(user), int(group), int(other)\n    mode = get_permissions_mode(user,\n                                'user') & get_permissions_mode(group, 'group') & get_permissions_mode(other, 'other')\n    os.chmod(file_path, mode)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nretrieve a user name group permissions bitwise code.", "response": "def get_permissions_mode(permission_octal, name):\n    \"\"\"Retrieve a user name group permissions bitwise code.\"\"\"\n    read = PERMISSIONS[name]['read']\n    write = PERMISSIONS[name]['write']\n    execute = PERMISSIONS[name]['execute']\n\n    # Read\n    if permission_octal == 4:\n        return read & ~write & ~execute\n\n    # Write\n    elif permission_octal == 2:\n        return ~read & write & ~execute\n\n    # Execute\n    elif permission_octal == 1:\n        return ~read & ~write & execute\n\n    # Read & Write\n    elif permission_octal == 6:\n        return read & write & ~execute\n\n    # Read & Execute\n    elif permission_octal == 5:\n        return read & ~write & execute\n\n    # Write & Execute\n    elif permission_octal == 3:\n        return ~read & write & execute\n\n    # Read, Write & Execute\n    elif permission_octal == 7:\n        return read & write & execute\n\n    # No read, write or execute by default\n    else:\n        return ~read & ~write & ~execute"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef allow(self, privilege):\n        assert privilege in PERMISSIONS['user'].keys()\n        reading = PERMISSIONS['user'][privilege] + PERMISSIONS['group'][privilege] + PERMISSIONS['other'][privilege]\n        os.chmod(self.file_path, reading)", "response": "Add an allowed privilege to the file."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nallow all privileges for a particular name group.", "response": "def allow_rwe(self, name):\n        \"\"\"Allow all privileges for a particular name group (user, group, other).\"\"\"\n        assert name in PERMISSIONS.keys()\n        os.chmod(self.file_path, PERMISSIONS[name]['all'])"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nrevokes all access to this path.", "response": "def revoke_access(self):\n        \"\"\"Revoke all access to this path.\"\"\"\n        reading = PERMISSIONS['user']['execute'] + PERMISSIONS['group']['execute'] + PERMISSIONS['other']['execute']\n        os.chmod(self.file_path, reading)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef timestamp(format=DATEFMT, timezone='Africa/Johannesburg'):\n\n    return formatdate(datetime.now(tz=pytz.timezone(timezone)))", "response": "Return current datetime with timezone applied\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef module_functions(modulestr):\n\n    funcs = dict(inspect.getmembers(import_module(modulestr),\n                 inspect.isfunction))\n\n    return OrderedDict(sorted(funcs.items(), key=lambda f: f[0]))", "response": "Return ordered dictionary of all functions declared in module"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nflashing all form errors", "response": "def flash_errors(form, category='warning'):\n    \"\"\" Flash all form error messages \"\"\"\n\n    for (field, errors) in form.errors.items():\n        for error in errors:\n            flash('{0} - {1}'.format(getattr(form, field).label.text, error),\n                  category)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef render_css(self, fn=None, text=None, margin='', indent='\\t'):\n        fn = fn or os.path.splitext(self.fn)[0]+'.css'\n        if not os.path.exists(os.path.dirname(fn)):\n            os.makedirs(os.path.dirname(fn))\n        curdir = os.path.abspath(os.curdir)\n        os.chdir(os.path.dirname(fn))               # needed in order for scss to relative @import\n        text = text or self.render_styles()\n        if text != '': text = sass.compile(string=text)\n        os.chdir(curdir)\n        return CSS(fn=fn, text=text)", "response": "output css using the Sass processor"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get(self, field):\n        if field in ('username', 'uuid', 'app_data'):\n            return self.data[field]\n        else:\n            return self.data.get('app_data', {})[field]", "response": "Returns the value of a user field."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef auto_update(cls, function):\n\n        def wrapper(self, *args, **kwargs):\n            f = function(self, *args, **kwargs)\n            self.update()\n            return f\n        return wrapper", "response": "This is a class method that ensures that the update method is called after the function execution."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _validate_key(self, key):\n        return not any([key.startswith(i) for i in self.EXCEPTIONS])", "response": "Returns a boolean indicating if the attribute name is valid or not"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef pages(request, path=None, instance=None):\n\n    if instance and instance.active:\n        p = instance\n    else:\n        raise Http404()\n\n    return render(request, p.tpl, get_page_tpl_ctx(p, request))", "response": "\u041f\u0440\u0435\u0434\u0441\u0442\u0430\u0432\u043b\u0435\u043d\u0438\u044f \u0441\u0442\u0440\u0430\u043d\u0438\u0446\u0430 \u043f\u043e \u0441\u0442\u0440\u0430\u043d\u0438\u0446\u0430"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef run(self, raw_args=None):\n\t\targs = self.parser.parse_args(raw_args)\n\n\t\tcore = Core()\n\n\t\ttry:\n\t\t\treport = core.lint(**vars(args))\n\t\texcept Exception as err:\n\t\t\tself.parser.error(str(err))\n\n\t\tprint(report)\n\t\tself.parser.exit()", "response": "Parses the given arguments and runs the linters."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_user(self, user_id):\n        if user_id in self._users:\n            return self._users.get(user_id)\n        else:\n            # Load user\n            # Save user in cache\n            return", "response": "Get details for a specific user."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _extract_html_hex(string):\n    try:\n        hex_string = string and _hex_regexp().search(string).group(0) or ''\n    except AttributeError:\n        return None\n    if len(hex_string) == 3:\n        hex_string = hex_string[0] * 2 + hex_string[1] * 2 + hex_string[2] * 2\n    return hex_string", "response": "Extract the first 3 or 6 hex digits in the string"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget a number for that colour name", "response": "def name_to_int(name):\n    \"\"\"Get a number for that colour name\n\n    if not a name, then not a number\n    \"\"\"\n    if not name:\n        return float('nan')\n    lower = name.lower()\n    cga_names = {s: i for i, s in enumerate(colour_names.cga())}\n    return cga_names.get(lower) or html_to_small_ansi(lower)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef urljoin(end_with_slash, *args):\n        last = args[0]\n        for i in args[1:]:\n            last = '%s/%s' % (last.strip('/'), i.strip('/'))\n\n        if end_with_slash:\n            if last[-1] != '/':\n                last += '/'\n        return last", "response": "Join two URL components."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding an authorization rule.", "response": "def add_rule(self, rule_class, target_class=_Nothing):\n        \"\"\"Adds an authorization rule.\n\n        :param rule_class: a class of authorization rule.\n        :param target_class: (optional) a class\n            or an iterable with classes to associate the rule with.\n        \"\"\"\n        if isinstance(target_class, Iterable):\n            for cls in target_class:\n                self._rules[cls] = rule_class\n        else:\n            self._rules[target_class] = rule_class"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndecorating and adds an authorization rule for a specified class of objects.", "response": "def rule_for(self, target_class):\n        \"\"\"Decorates and adds an authorization rule\n        for a specified class(es) of objects.\n\n        :param target_class: a class or an iterable with classes\n            to associate the rule with.\n        \"\"\"\n        def decorator(rule_class):\n            self.add_rule(rule_class, target_class)\n            return rule_class\n        return decorator"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nraise AuthorizationError when a user has no permission.", "response": "def check(self, user, permission, obj=_nothing):\n        \"\"\"Raises AuthorizationError when a user has no permission.\n\n        :param user: a user.\n        :param permission: permission to check.\n        :param obj: (optional) an object to check permission for.\n        \"\"\"\n        if not self.allows(user, permission, obj):\n            raise AuthorizationError(\n                'Can\\'t {} object of class {}'.format(\n                    permission, type(obj)))"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nchecks that a user has permission. Returns True or False.", "response": "def allows(self, user, permission, obj=_nothing):\n        \"\"\"Checks that a user has permission. Returns True or False.\n\n        :param user: a user.\n        :param permission: permission to check.\n        :param obj: (optional) an object to check permission for.\n        \"\"\"\n        rule = self._get_rule(obj)\n\n        if not isinstance(permission, basestring):\n            return all(\n                self._use_rule(rule, user, perm, obj)\n                for perm in permission\n            )\n\n        return self._use_rule(rule, user, permission, obj)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a set of all permissions that a user can see.", "response": "def get_permissions(self, user, obj=_nothing):\n        \"\"\"Returns permissions of a user.\n\n        :param user: a user.\n        :param obj: (optional) an object to get permissions for.\n        \"\"\"\n        rule = self._get_rule(obj)\n\n        all_permissions = (\n            attr[len('can_'):] for attr in dir(rule)\n            if attr.startswith('can_')\n        )\n\n        return set(\n            permission for permission in all_permissions\n            if self.allows(user, permission, obj)\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef log_debug(func, *args, **kwargs):\n    ''' Wrap call of provided function with debug log statements. '''\n    logging.debug('Starting \"%s\" in thread %s...', func.__name__, current_thread())\n    results = func(*args, **kwargs)\n    logging.debug('Successfully finished \"%s\" in thread %s.', func.__name__, current_thread())\n    return results", "response": "Wrap call of provided function with debug log statements."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nwrapping call of provided function with try and catch block and debug log statements.", "response": "def try_catch(func, *args, **kwargs):\n    '''\n    Wrap call of provided function with try/except block and debug log statements.\n    If an instance of 'Exception' (or one of its subclasses) is thrown by 'func',\n    it is caught, and the exception object itself is return as a result.\n    '''\n    try:\n        return log_debug(func, *args, **kwargs)\n    except Exception as exc:\n        logging.debug('Error in \"%s\" in thread %s: %s', func.__name__, current_thread(), exc)\n        return exc"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreformat the time string.", "response": "def reformat(self, dtstring, before, after):\n        \"\"\"Edit the time string format.\n        \n        See https://docs.python.org/2/library/datetime.html#strftime-and-strptime-behavior\n        for all format string options.\n        \n        **\u4e2d\u6587\u6587\u6863**\n        \n        \u5c06datetime string\u4ece\u4e00\u79cd\u683c\u5f0f\u8f6c\u6362\u6210\u53e6\u4e00\u79cd\u683c\u5f0f\u3002\n        \"\"\"\n        a_datetime = datetime.strptime(dtstring, before)\n        return datetime.strftime(a_datetime, after)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef str2date(self, datestr):\n        try:\n            return datetime.strptime(\n                    datestr, self.default_date_template).date()\n        except: # \u5982\u679c\u9ed8\u8ba4\u7684\u6a21\u677f\u4e0d\u5339\u914d, \u5219\u91cd\u65b0\u5c1d\u8bd5\u6240\u6709\u7684\u6a21\u677f\n            pass\n        \n        # try all date_templates\n        # \u5bf9\u6bcf\u4e2atemplate\u8fdb\u884c\u5c1d\u8bd5, \u5982\u679c\u90fd\u4e0d\u6210\u529f, \u629b\u51fa\u5f02\u5e38\n        for template in self.date_templates: \n            try:\n                a_datetime = datetime.strptime(datestr, template) # \u5982\u679c\u6210\u529f\u4e86\n                self.default_date_template = template # \u4fdd\u5b58\u4e3adefault\n                return a_datetime.date()\n            except:\n                pass\n        raise NoMatchingTemplateError(datestr)", "response": "Try parse date from string."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ntries parse datetime from string.", "response": "def str2datetime(self, datetimestr):\n        \"\"\"Try parse datetime from string. If None template matching this \n        datestr, raise Error.\n         \n        :param datetimestr: a string represent a datetime\n        :type datetimestr: str\n        :return: a datetime.datetime object\n        \n        Usage::\n        \n            >>> from weatherlab.lib.timelib.timewrapper import timewrapper\n            >>> timewrapper.str2date(\"12/15/2014 06:30:00 PM\")\n            datetime.datetime(2014, 12, 15, 18, 30)\n    \n        **\u4e2d\u6587\u6587\u6863**\n        \n        \u5c1d\u8bd5\u4ece\u5b57\u7b26\u4e32\u4e2d\u89e3\u6790\u51fadatetime.date\u5bf9\u8c61\u3002\u6bcf\u6b21\u89e3\u6790\u65f6, \u5148\u5c1d\u8bd5\u9ed8\u8ba4\u6a21\u677f, \u5982\u679c\n        \u5931\u8d25\u4e86, \u518d\u91cd\u65b0\u5bf9\u6240\u6709\u6a21\u677f\u8fdb\u884c\u5c1d\u8bd5; \u4e00\u65e6\u5c1d\u8bd5\u6210\u529f, \u8fd9\u5c06\u5f53\u524d\u6210\u529f\u7684\u6a21\u677f\u4fdd\u5b58\n        \u4e3a\u9ed8\u8ba4\u6a21\u677f\u3002\u8fd9\u6837\u4f7f\u5f97\u5c1d\u8bd5\u7684\u7b56\u7565\u6700\u4f18\u5316\u3002\n        \"\"\"\n        try:\n            return datetime.strptime(\n                    datetimestr, self.default_datetime_templates)\n        except: # \u5982\u679c\u9ed8\u8ba4\u7684\u6a21\u677f\u4e0d\u5339\u914d, \u5219\u91cd\u65b0\u5c1d\u8bd5\u6240\u6709\u7684\u6a21\u677f\n            pass\n        \n        # try all datetime_templates\n        # \u5bf9\u6bcf\u4e2atemplate\u8fdb\u884c\u5c1d\u8bd5, \u5982\u679c\u90fd\u4e0d\u6210\u529f, \u629b\u51fa\u5f02\u5e38\n        for template in self.datetime_templates:\n            try:\n                a_datetime = datetime.strptime(\n                                datetimestr, template) # \u5982\u679c\u6210\u529f\u4e86\n                self.default_datetime_templates = template # \u4fdd\u5b58\u4e3adefault\n                return a_datetime\n            except:\n                pass\n        raise NoMatchingTemplateError(datetimestr)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef std_datetimestr(self, datetimestr):\n        return datetime.strftime(\n                self.str2datetime(datetimestr), self.std_datetimeformat)", "response": "Reformat a datetime string to standard format."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef parse_datetime(self, value):\n        if isinstance(value, datetime):\n            return value\n        elif isinstance(value, str):\n            return self.str2datetime(value)\n        elif isinstance(value, int):\n            return self.fromtimestamp(value)\n        elif isinstance(value, float):\n            return self.fromtimestamp(value)\n        elif isinstance(value, date):\n            return datetime(value.year, value.month, value.day)\n        else:\n            raise Exception(\"Unable to parse datetime from: %s, type<%s>.\" % (\n                            value, type(value)))", "response": "A lazy method to parse anything to datetime."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nparsing a frequency string into a timedelta object.", "response": "def _freq_parser(self, freq):\n        \"\"\"\n        day, hour, min, sec,\n        \"\"\"\n        freq = freq.lower().strip()\n        try:\n            if \"day\" in freq:\n                freq = freq.replace(\"day\", \"\")\n                return timedelta(days=int(freq))\n            elif \"hour\" in freq:\n                freq = freq.replace(\"hour\", \"\")\n                return timedelta(hours=int(freq))\n            elif \"min\" in freq:\n                freq = freq.replace(\"min\", \"\")\n                return timedelta(minutes=int(freq))\n            elif \"sec\" in freq:\n                freq = freq.replace(\"sec\", \"\")\n                return timedelta(seconds=int(freq))\n            else:\n                raise Exception(\"%s is invalid format. use day, hour, min, sec.\" % freq)\n        except:\n            raise Exception(\"%s is invalid format. use day, hour, min, sec.\" % freq)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ngenerate a datetime series with same weekday number.", "response": "def weekday_series(self, start, end, weekday):\n        \"\"\"Generate a datetime series with same weekday number.\n        \n        ISO weekday number: Mon = 1, Sun = 7\n        \n        Usage::\n        \n            >>> timewrapper.weekday_series( # All Tuesday\n            >>>     \"2014-01-01 06:30:25\", \"2014-02-01 06:30:25\", weekday=2),\n            [\n                datetime(2014, 1, 7, 6, 30, 25), \n                datetime(2014, 1, 14, 6, 30, 25),\n                datetime(2014, 1, 21, 6, 30, 25),\n                datetime(2014, 1, 28, 6, 30, 25),\n            ]\n        \n        **\u4e2d\u6587\u6587\u6863**\n        \n        \u751f\u6210\u661f\u671f\u6570\u4e00\u81f4\u7684\u65f6\u95f4\u5e8f\u5217\u3002\n        \"\"\"\n        startdatetime = self.parse_datetime(start)\n        enddatetime = self.parse_datetime(end)\n        \n        series = list()\n        for i in self.dtime_range(startdatetime, enddatetime, freq=\"1day\"):\n            if i.isoweekday() == weekday:\n                series.append(i)\n                \n        return series"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef randdate(self, start=date(1970, 1, 1), end=date.today()):\n        if isinstance(start, str):\n            start = self.str2date(start)\n        if isinstance(end, str):\n            end = self.str2date(end)\n        if start > end:\n            raise Exception(\"start must be smaller than end! \"\n                            \"your start=%s, end=%s\" % (start, end))\n        return date.fromordinal(random.randint(start.toordinal(), end.toordinal()))", "response": "Generate a random date between start and end."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef randdatetime(self, start=datetime(1970,1,1), end=datetime.now()):\n        if isinstance(start, str):\n            start = self.str2datetime(start)\n        if isinstance(end, str):\n            end = self.str2datetime(end)\n        if start > end:\n            raise Exception(\"start must be smaller than end! your start=%s, end=%s\" % (start, end))\n        return datetime.fromtimestamp(random.randint(self.totimestamp(start), self.totimestamp(end)))", "response": "Generate a random datetime between start and end."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef add_months(self, datetimestr, n, return_date=False):\n        a_datetime = self.parse_datetime(datetimestr)\n        month_from_ordinary = a_datetime.year * 12 + a_datetime.month\n        month_from_ordinary += n\n        year, month = divmod(month_from_ordinary, 12)\n        \n        try:\n            a_datetime = datetime(year, month, a_datetime.day,\n                a_datetime.hour, a_datetime.minute, \n                a_datetime.second, a_datetime.microsecond)\n        except ValueError:\n            a_datetime = datetime(year, month+1, 1,\n                a_datetime.hour, a_datetime.minute, \n                a_datetime.second, a_datetime.microsecond)\n            a_datetime = self.add_days(a_datetime, -1)\n\n        if return_date:\n            return a_datetime.date()\n        else:\n            return a_datetime", "response": "Returns a datetime object that n months after a time."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nrounding the given datetime to specified hour minute and second.", "response": "def round_to_specified_time(self, a_datetime, hour, minute, second, mode=\"lower\"):\n        \"\"\"Round the given datetime to specified hour, minute and second.\n        \n        :param mode: if 'lower', floor to. if 'upper', ceiling to.\n        \n        **\u4e2d\u6587\u6587\u6863**\n        \n        \u5c06\u7ed9\u5b9a\u65f6\u95f4\u5bf9\u9f50\u5230\u6700\u8fd1\u7684\u4e00\u4e2a\u6307\u5b9a\u4e86\u5c0f\u65f6, \u5206\u949f, \u79d2\u7684\u65f6\u95f4\u4e0a\u3002\n        \"\"\"\n        mode = mode.lower()\n        \n        new_datetime = datetime(a_datetime.year, a_datetime.month, a_datetime.day,\n                                hour, minute, second)\n        if mode == \"lower\": \n            if new_datetime <= a_datetime:\n                return new_datetime\n            else:\n                return timewrapper.add_days(new_datetime, -1)\n        elif mode == \"upper\":\n            if new_datetime >= a_datetime:\n                return new_datetime\n            else:\n                return timewrapper.add_days(new_datetime, 1)\n        else:\n            raise ValueError(\"'mode' has to be lower or upper!\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef join(self, people):\n        tries = 0\n        if not people:\n            raise SensorJoinException(\"No people given\")\n        ids = set()\n        for person in people:\n            if not person.id and person.id != 0:\n                raise SensorJoinException(\"Invalid id for one or more people\")\n            if person.id in ids:\n                raise SensorJoinException(\n                    u\"Id {} not unique\".format(person.id)\n                )\n            ids.add(person.id)\n\n        while self._is_running and tries < self._join_retry_count:\n            packet = APPJoinMessage(\n                payload={'people': [person.to_dict() for person in people]}\n            )\n            self._send_packet(self._multicast_group, self._multicast_port,\n                              packet)\n            if self._joined.wait(self._join_retry_timeout):\n                break\n            with self._seq_ack_lock:\n                # Got ack for packet?\n                packet_ackd = packet.header.sequence_number \\\n                    not in self._seq_ack\n            if packet_ackd and self._joined.wait(1.0):\n                # Packet already got acked\n                # -> wait another second for ._joined to clear\n                break\n            tries += 1\n            self.warning(\n                u\"Unsuccessful attempt joining audience # {}\".format(tries)\n            )\n\n        if not self._joined.is_set() or tries >= self._join_retry_count:\n            # Failed to join (no config packet received)\n            raise SensorJoinException(\"No config packet received\")\n        self.info(\"Joined the audience\")", "response": "Attempts to join the local audience with the given list of people."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef unjoin(self):\n        self.debug(\"()\")\n        if self._joined.is_set():\n            packet = APPUnjoinMessage(device_id=Id.NOT_SET)\n            self._send_packet(self._server_ip, self._server_port, packet)\n            self._joined.clear()\n            self.info(\"Left the audience\")", "response": "Unjoin the local audience."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nupdate the configuration of the current module and lower layers.", "response": "def config(self, settings):\n        \"\"\"\n        Configuration has changed - config this module and lower layers\n        (calls on_config - if set)\n\n        :param settings: New configuration\n        :type settings: dict\n        :rtype: None\n        :raises SensorUpdateException: Failed to update\n        \"\"\"\n        self.debug(\"()\")\n        # TODO synchronize access to vars\n        try:\n            self._device_id = settings['device_id']\n\n            self._packet_timeout = settings.get(\n                'packet_wait_timeout',\n                self._packet_timeout\n            )\n            self._server_ip = settings.get('server_ip', self._server_ip)\n            self._server_port = settings.get('server_port', self._server_port)\n        except KeyError:\n            raise SensorUpdateException(\"Key not in settings\")\n\n        if callable(self.on_config):\n            try:\n                self.on_config(settings)\n            except:\n                self.exception(\"Failed to update remote config\")\n                raise SensorUpdateException(\"Remote config failed\")"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef person_update(self, people):\n\n        packet = APPUpdateMessage(device_id=Id.NOT_SET, people=people)\n        self._send_packet(\n            self._server_ip, self._server_port, packet,\n            acknowledge_packet=False\n        )", "response": "Update the status of the specified people."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _do_config_packet(self, packet, ip, port):\n        self.debug(\"()\")\n        if packet.header.device_id != Id.SERVER:\n            # Only allow config packets from server\n            self.warning(\"Config packets only allowed from server\")\n            return\n\n        try:\n            config = packet.payload\n            self.debug(u\"{}\".format(config))\n\n            if not isinstance(config, dict):\n                self.error(\"Wrong payload type\")\n                raise RuntimeError(\"Wrong type\")\n            config.setdefault(\"server_ip\", ip)\n            config.setdefault(\"server_port\", port)\n            self.config(config)\n            self._joined.set()\n        except:\n            self.exception(\"Failed to configure\")\n            self.error(u\"Faulty packet {}\".format(format_data(packet.payload)))\n            return", "response": "Apply config to this instance"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nstarts the interface with the specified attributes.", "response": "def start(self, blocking=False):\n        \"\"\"\n        Start the interface\n\n        :param blocking: Should the call block until stop() is called\n            (default: False)\n        :type blocking: bool\n        :rtype: None\n        :raises SensorStartException: Failed to start\n        \"\"\"\n        self.debug(\"()\")\n        super(SensorClient, self).start(blocking=False)\n        try:\n            a_thread = threading.Thread(\n                target=self._thread_wrapper,\n                args=(self._packet_loop,)\n            )\n            a_thread.daemon = True\n            a_thread.start()\n        except:\n            self.exception(\"Failed to run packet loop\")\n            raise SensorStartException(\"Packet loop failed\")\n        self.info(\"Started\")\n        # Blocking - call StartStopable.start\n        super(Sensor, self).start(blocking)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef stop(self):\n        self.debug(\"()\")\n        try:\n            self.unjoin()\n            time.sleep(2)\n        except:\n            self.exception(\"Failed to leave audience\")\n        super(SensorClient, self).stop()", "response": "Stop the interface\n\n        :rtype: None"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ngo through the provided list and returns the first server node that does not return an error.", "response": "def goodnode(self, nodelist):\n        ''' Goes through the provided list\n        and returns the first server node\n        that does not return an error.\n        '''\n        l = len(nodelist)\n        for n in range(self.current_node(l), l):\n            self.msg.message(\"Trying node \" + str(n) + \": \" + nodelist[n])\n            try:\n                req = urllib.request.Request(url=nodelist[n])\n                urllib.request.urlopen(req)\n            except HTTPError as e:\n                self.msg.error_message(e)\n                self.currentnode = int(self.currentnode) + 1\n            else:\n                self.msg.message(\"Using \" + nodelist[n])\n                return nodelist[n]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef permlink(self, identifier):\n        ''' Deconstructs an identifier into\n        an account name and permlink\n        '''\n        temp = identifier.split(\"@\")\n        temp2 = temp[1].split(\"/\")\n        return [temp2[0], temp2[1]]", "response": "Deconstructs an identifier into\n        an account name and permlinks that account name and permlinks that account name."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef minutes_back(self, date):\n        ''' Gives a number (integer) of days\n        since a given date\n        '''\n        elapsed = (datetime.utcnow() - datetime.strptime(date,'%Y-%m-%dT%H:%M:%S'))\n        if elapsed.days > 0:\n            secondsback = (elapsed.days * 24 * 60 * 60) + elapsed.seconds\n        else:\n            secondsback = elapsed.seconds\n        minutesback = secondsback / 60\n        return int(minutesback)", "response": "Gives a number of minutes back since a given date"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef scale_vote(self, value):\n        ''' Scales a vote value between 1 and 100\n        to 150 to 10000 as required by Steem-Python\n        for certain method calls\n        '''\n        value = int(value) * 100\n        if value < 100:\n            value = 100\n        if value > 10000:\n            value = 10000\n        return value", "response": "Scales a vote value between 1 and 100 to 10000 as required by Steem - Python\n        for certain method calls."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncalculating the amount of steem power that would have been regenerated by a certain datetime object", "response": "def calc_regenerated(self, lastvotetime):\n        ''' Uses math formula to calculate the amount\n        of steem power that would have been regenerated\n        given a certain datetime object\n        '''\n        delta = datetime.utcnow() - datetime.strptime(lastvotetime,'%Y-%m-%dT%H:%M:%S')\n        td = delta.days\n        ts = delta.seconds\n        tt = (td * 86400) + ts\n        return tt * 10000 / 86400 / 5"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating the retry message and waits the given default time when a method call fails.", "response": "def retry(self, msg, e, retry_num, waittime):\n        ''' Creates the retry message and waits the \n        given default time when a method call fails\n        or a server does not respond appropriately.\n        '''\n        self.msg.error_message(msg)\n        self.msg.error_message(e)\n        self.msg.error_message(\"Attempt number \" + str(retry_num) + \". Retrying in \" + str(waittime) + \" seconds.\")\n        time.sleep(waittime)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef sp_to_rshares(self, sp, voting_power=10000, vote_pct=10000):\n        vesting_shares = int(self.sp_to_vests(sp) * 1e6)\n        used_power = int((voting_power * vote_pct) / 10000);\n        max_vote_denom = self.vote_power_reserve_rate * (5 * 60 * 60 * 24) / (60 * 60 * 24);\n        used_power = int((used_power + max_vote_denom - 1) / max_vote_denom)\n        rshares = ((vesting_shares * used_power) / 10000)\n        return rshares", "response": "Obtain the r - shares for a given Steem Power\n           "}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate arguments to use with baton.", "response": "def _create_entity_query_arguments(self, load_metadata: bool=True) -> List[str]:\n        \"\"\"\n        Create arguments to use with baton.\n        :param load_metadata: whether baton should load metadata\n        :return: the arguments to use with baton\n        \"\"\"\n        arguments = [\"--acl\", \"--replicate\", \"--timestamp\"]\n        if load_metadata:\n            arguments.append(\"--avu\")\n        return arguments"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _baton_json_to_irods_entities(self, entities_as_baton_json: List[Dict]) -> List[EntityType]:\n        assert(isinstance(entities_as_baton_json, list))\n\n        entities = []\n        for file_as_baton_json in entities_as_baton_json:\n            entity = self._baton_json_to_irods_entity(file_as_baton_json)\n            entities.append(entity)\n\n        return entities", "response": "Converts the baton representation of multiple iRODS entities to a list of EntityTypes."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nsend a payment to a user.", "response": "def send_url(amount, redirect_url, url, api):\n    '''\n    return payment gateway url to redirect user\n    to it for payment.\n    '''\n    values = {'api': api, 'amount': amount, 'redirect': redirect_url}\n    send_request = requests.post(SEND_URL_FINAL, data=values)\n    id_get = send_request.text\n    print(id_get)\n    if int(id_get) > 0:\n        print(\".\u0645\u0639\u062a\u0628\u0631 \u0627\u0633\u062a id_get\")\n        payment_gateway_url = '%s%s' % (GATEWAY_URL_FINAL, id_get)\n        return payment_gateway_url\n    elif id_get == \"-1\":\n        print(\n            \"\u202b\u202a api\u202c\u0627\u0631\u0633\u0627\u0644\u06cc \u0628\u0627 \u0646\u0648\u0639 \u202a api\u202c\u062a\u0639\u0631\u06cc\u0641 \u0634\u062f\u0647 \u062f\u0631 \u202a payline\u202c\u0633\u0627\u0632\u06af\u0627\u0631 \u0646\u06cc\u0633\u062a.\u202c\")\n    elif id_get == \"-2\":\n        print(\n            \"\u202b\u0645\u0642\u062f\u0627\u0631 \u202a amount\u202c\u062f\u0627\u062f\u0647 \u0639\u062f\u062f\u064a \u0646\u0645\u06cc \u0628\u0627\u0634\u062f \u0648 \u06cc\u0627 \u06a9\u0645\u062a\u0631 \u0627\u0632 1000 \u0631\u06cc\u0627\u0644 \u0627\u0633\u062a.\u202c\")\n    elif id_get == \"-3\":\n        print(\"\u202b\u0645\u0642\u062f\u0627\u0631 \u202a redirect\u202c\u0631\u0634\u062a\u0647 \u202a null\u202c\u0627\u0633\u062a.\u202c\")\n    elif id_get == \"-4\":\n        print(\n            \"\u202b\u062f\u0631\u06af\u0627\u0647\u06cc \u0628\u0627 \u0627\u0637\u0644\u0627\u0639\u0627\u062a \u0627\u0631\u0633\u0627\u0644\u06cc \u06cc\u0627\u0641\u062a \u0646\u0634\u062f\u0647 \u0648 \u06cc\u0627 \u062f\u0631 \u062d\u0627\u0644\u062a \u0627\u0646\u062a\u0638\u0627\u0631 \u0645\u06cc \u0628\u0627\u0634\u062f\u202c\")\n    else:\n        print(\"some other error(s) occurred.\")"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_result(api, trans_id, id_get):\n    '''\n    Check if the given id_get and trans_id is from a valid transaction.\n    '''\n    check_values = {'api': api, 'id_get': id_get, 'trans_id': trans_id}\n\n    check_transaction = requests.post(CHECK_URL_FINAL, data=check_values)\n    result = check_transaction.text\n    if result == \"1\":\n        print(\".\u202b\u062a\u0631\u0627\u06a9\u0646\u0634 \u0645\u0648\u0641\u0642\u06cc\u062a \u0622\u0645\u06cc\u0632 \u0628\u0648\u062f\u0647 \u0627\u0633\u062a\u202c\")\n        return True\n    elif result == \"-1\":\n        print(\n            \"\u202b\u202a api\u202c\u0627\u0631\u0633\u0627\u0644\u06cc \u0628\u0627 \u0646\u0648\u0639 \u202a api\u202c\u062a\u0639\u0631\u06cc\u0641 \u0634\u062f\u0647 \u062f\u0631 \u202a payline\u202c\u0633\u0627\u0632\u06af\u0627\u0631 \u0646\u06cc\u0633\u062a.\u202c\")\n    elif result == \"-2\":\n        print(\".\u0627\u0631\u0633\u0627\u0644 \u0634\u062f\u0647 \u0645\u0639\u062a\u0628\u0631 \u0646\u0645\u06cc \u0628\u0627\u0634\u062f\u202c trans_id\")\n    elif result == \"-3\":\n        print(\".\u202bid_get \u0627\u0631\u0633\u0627\u0644 \u0634\u062f\u0647 \u0645\u0639\u062a\u0628\u0631 \u0646\u0645\u06cc \u0628\u0627\u0634\u062f\u202c\")\n    elif result == \"-4\":\n        print(\".\u202b\u0686\u0646\u06cc\u0646 \u062a\u0631\u0627\u06a9\u0646\u0634\u06cc \u062f\u0631 \u0633\u06cc\u0633\u062a\u0645 \u0648\u062c\u0648\u062f \u0646\u062f\u0627\u0631\u062f \u0648 \u06cc\u0627 \u0645\u0648\u0641\u0642\u06cc\u062a \u0622\u0645\u06cc\u0632 \u0646\u0628\u0648\u062f\u0647 \u0627\u0633\u062a\u202c\")\n    else:\n        print(\"some error(s) occurred, please try again.\")", "response": "Check if the given id_get and trans_id are from a valid transaction."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_site_id(name):\n    try:\n        site_id = [site for site in ambition_sites if site[1] == name][0][0]\n    except IndexError:\n        try:\n            site_id = [site for site in ambition_sites if site[2] == name][0][0]\n        except IndexError:\n            site_ids = [site[1] for site in ambition_sites]\n            site_names = [site[2] for site in ambition_sites]\n            raise InvalidSiteError(\n                f\"Invalid site. Got '{name}'. Expected one of \"\n                f\"{site_ids} or {site_names}.\"\n            )\n    return site_id", "response": "Returns the site ID of the given name."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nrun a single runner in a list of modules.", "response": "def _run_once(runner_list, extra_tick, use_poll):\n    \"\"\"\n    :return True - success; False - extra_tick failure; runner object - the runner who tick failure\n    \"\"\"\n    if len(runner_list) > 0:\n        asyncore.loop(0, use_poll, None, 1)\n        for runner in runner_list:\n            if not runner.tick():\n                return runner\n    if extra_tick is not None:\n        code = extra_tick()\n        if code is False:\n            return False\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef run_once(runner_list=None, extra_tick=Sleep(0.001), use_poll=False, auto_stop=True):\n    if runner_list is None:\n        runner_list = _runner_list\n\n    code = _run_once(runner_list, extra_tick, use_poll)\n    if code is True:  # no error\n        return True\n    elif code is False:  # extra tick error\n        if auto_stop:\n            for runner in list(runner_list):\n                runner.stop()\n        return False\n    else:  # runner tick error\n        if hasattr(code, 'only_stop_self_when_tick_error') and code.only_stop_self_when_tick_error:\n            if auto_stop:\n                code.stop()\n            return True\n        else:\n            if auto_stop:\n                for runner in list(runner_list):\n                    runner.stop()\n            return False\n    return True", "response": "Runs a single or multiple runners."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef send_message(self, msg_id, msg_data):\n        if self._error.has_error() or self._force_close_time > 0:\n            return False\n\n        byte_msg = self.message_packer.pack(msg_id, msg_data)\n        length = struct.calcsize(self.__class__.message_packer.size_fmt) + len(byte_msg)\n\n        if length > self.__class__.max_message_size:\n            raise MessageSizeOverflowError(msg_id, length, self.__class__.max_message_size)\n\n        self._out_buffer += struct.pack(self.__class__.message_packer.size_fmt, length)\n        self._out_buffer += byte_msg\n        return True", "response": "Send a message to the server."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef do_connect(self):\n        assert self.socket is None\n        self.create_socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.connect(self._connect_address)", "response": "Connect to the server."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef abspath(relpath, root=None):\n    root = root or cwd()\n    if op.isfile(root):\n        root = op.dirname(root)\n    return op.abspath(op.join(root, relpath))", "response": "Returns an absolute path based on the given root and relative path."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nmakes all directories required for given path ; returns true if successful and false otherwise.", "response": "def makedirs(path, ignore_extsep=False):\n    \"\"\"Makes all directories required for given path; returns true if successful\n    and false otherwise.\n\n    **Examples**:\n    ::\n        auxly.filesys.makedirs(\"bar/baz\")\n    \"\"\"\n    if not ignore_extsep and op.basename(path).find(os.extsep) > -1:\n        path = op.dirname(path)\n    try:\n        os.makedirs(path)\n    except:\n        return False\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef delete(path, regex=None, recurse=False, test=False):\n    deleted = []\n    if op.isfile(path):\n        if not test: os.remove(path)\n        else: return [path]\n        return [] if op.exists(path) else [path]\n    elif op.isdir(path):\n        if regex:\n            for r,ds,fs in os.walk(path):\n                for i in fs:\n                    if _is_match(regex, i):\n                        deleted += delete(op.join(r,i), test=test)\n                if not recurse:\n                    break\n        else:\n            if not test: shutil.rmtree(path)\n            else: return [path]\n            return [] if op.exists(path) else [path]\n    return deleted", "response": "Deletes the file or directory at path."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef walkfiles(startdir, regex=None, recurse=True):\n    for r,_,fs in os.walk(startdir):\n        if not recurse and startdir != r:\n            return\n        for f in fs:\n            path = op.abspath(op.join(r,f))\n            if regex and not _is_match(regex, path):\n                    continue\n            if op.isfile(path):\n                yield path", "response": "Yields the absolute paths of files found within the given start\n    directory. Can optionally filter paths using a regex pattern."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef countfiles(path, recurse=False):\n    if not op.isdir(path):\n        return 0\n    count = 0\n    for r,ds,fs in os.walk(path):\n        count += len(fs)\n        if not recurse:\n            break\n    return count", "response": "Returns the number of files under the given directory path."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn True if the given file or directory path is empty.", "response": "def isempty(path):\n    \"\"\"Returns True if the given file or directory path is empty.\n\n    **Examples**:\n    ::\n        auxly.filesys.isempty(\"foo.txt\")  # Works on files...\n        auxly.filesys.isempty(\"bar\")  # ...or directories!\n    \"\"\"\n    if op.isdir(path):\n        return [] == os.listdir(path)\n    elif op.isfile(path):\n        return 0 == os.stat(path).st_size\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef getsize(path, recurse=False):\n    if not op.isdir(path):\n        return op.getsize(path)\n    size = 0\n    for r,_,fs in os.walk(path):\n        for f in fs:\n            size += getsize(op.join(r,f))\n        if not recurse:\n            break\n    return size", "response": "Returns the size of the file or directory in bytes."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncopy the file or directory at srcpath to dstpath. Returns True if successful False otherwise.", "response": "def copy(srcpath, dstpath, overwrite=True):\n    \"\"\"Copies the file or directory at `srcpath` to `dstpath`. Returns True if\n    successful, False otherwise.\"\"\"\n    # Handle bail conditions.\n    if not op.exists(srcpath):\n        return False\n    if not overwrite:\n        if op.isfile(dstpath):\n            return False\n        if op.isdir(dstpath):\n            chkpath = op.join(dstpath, op.basename(srcpath))\n            if op.isdir(chkpath) or op.isfile(chkpath):\n                return False\n    srcpath = op.abspath(srcpath)\n    dstpath = op.abspath(dstpath)\n\n    # Handle copying.\n    if op.isdir(srcpath):\n        dstdir = dstpath\n        if op.isfile(dstpath):\n            dstdir = op.dirname(dstpath)\n        elif op.isdir(dstpath):\n            # Make sure srcdir is copied INTO dstdir.\n            dstdir = op.join(dstpath, op.basename(srcpath))\n        makedirs(dstdir)\n        for r,ds,fs in os.walk(srcpath):\n            basedir = r.replace(srcpath, \"\").rstrip(os.sep).strip(os.sep)\n            curdir = op.join(dstdir, basedir)\n            makedirs(curdir)\n            for f in fs:\n                if not copy(op.join(r,f), op.join(curdir, f), overwrite=overwrite):\n                    return False\n    elif op.isfile(srcpath):\n        makedirs(dstpath)\n        shutil.copy2(srcpath, dstpath)\n\n    return op.exists(dstpath)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef move(srcpath, dstpath, overwrite=True):\n    # TODO: (JRR@201612230924) Consider adding smarter checks to prevent files ending up with directory names; e.g. if dstpath directory does not exist.\n    if not op.exists(srcpath):\n        return False\n    if srcpath == dstpath:\n        return True\n    if op.isfile(srcpath) and op.isdir(dstpath):\n        verfunc = op.isfile\n        verpath = op.join(dstpath, op.basename(srcpath))\n    elif op.isfile(srcpath):\n        verfunc = op.isfile\n        verpath = dstpath\n        makedirs(dstpath)\n    elif op.isdir(srcpath) and op.isdir(dstpath):\n        verfunc = op.isdir\n        verpath = op.join(dstpath, op.basename(srcpath))\n    elif op.isdir(srcpath):\n        verfunc = op.isdir\n        verpath = dstpath\n    else:\n        return False\n    if op.isfile(verpath):\n        if not overwrite:\n            return False\n        else:\n            # On Windows, filename case is ignored so the following check will\n            # prevent unintentionally deleting the srcpath before moving.\n            if \"nt\" == os.name and srcpath.lower() == dstpath.lower():\n                pass\n            elif not delete(verpath):\n                return False\n    try:\n        shutil.move(srcpath, dstpath)\n    except:\n        return False\n    return verfunc(verpath)", "response": "Moves the file or directory at srcpath to dstpath. Returns True if successful False otherwise."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the checksum of the file at the given path as a hex string or as a bytes literal. Uses MD5 by default.", "response": "def checksum(fpath, hasher=None, asbytes=False):\n    \"\"\"Returns the checksum of the file at the given path as a hex string\n    (default) or as a bytes literal. Uses MD5 by default.\n\n    **Attribution**:\n    Based on code from\n    `Stack Overflow <https://stackoverflow.com/a/3431835/789078>`_.\"\"\"\n    def blockiter(fpath, blocksize=0x1000):\n        with open(fpath, \"rb\") as afile:\n            block = afile.read(blocksize)\n            while len(block) > 0:\n                yield block\n                block = afile.read(blocksize)\n    hasher = hasher or hashlib.md5()\n    for block in blockiter(fpath):\n        hasher.update(block)\n    return (hasher.digest() if asbytes else hasher.hexdigest())"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a Path object for the directory associated with this object.", "response": "def dirpath(self):\n        \"\"\"Returns a Path object for the directory associated with this object.\"\"\"\n        if self.isfile():\n            return Path(op.dirname(self._fspath))\n        else:\n            return Path(self)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nread from the file and returns result as a string.", "response": "def read(self, encoding=None):\n        \"\"\"Reads from the file and returns result as a string.\"\"\"\n        encoding = encoding or ENCODING\n        try:\n            with codecs.open(self.path, encoding=encoding) as fi:\n                return fi.read()\n        except:\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreads from the file and returns result as a list of lines.", "response": "def readlines(self, encoding=None):\n        \"\"\"Reads from the file and returns result as a list of lines.\"\"\"\n        try:\n            encoding = encoding or ENCODING\n            with codecs.open(self.path, encoding=None) as fi:\n                return fi.readlines()\n        except:\n            return []"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef append(self, content, binary=False, encoding=None):\n        mode = \"ab\" if binary else \"a\"\n        return self._write(content, mode, encoding=encoding, linesep=False)", "response": "Appends the given content to the file. Returns true if successful false otherwise."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef appendline(self, content, binary=False, encoding=None):\n        mode = \"ab\" if binary else \"a\"\n        return self._write(content, mode, encoding=encoding, linesep=True)", "response": "Same as append but adds a line break after the content."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef handle_raw_output(ctx, data):\n    if ctx.obj['format'] == 'json':\n        print(json_dump(data))\n        exit(0)\n    if ctx.obj['format'] == 'yaml':\n        print(yaml_dump(data), end='')\n        exit(0)", "response": "Dump data to stdout if the format is json or yaml"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nretrieves files within the root directory", "response": "def _get_root_files(self, directory):\n        \"\"\"Retrieve files within the root directory\"\"\"\n        if len(self.filepaths) is 0:\n            if self.filters:\n                root_files = [(directory, f) for f in os.listdir(directory)\n                              if os.path.isfile(os.path.join(directory, f))\n                              and self.filters.validate(f)\n                              and self.filters.get_level(f) == self.filters.max_level]\n            else:\n                root_files = [(directory, f) for f in os.listdir(directory)\n                              if os.path.isfile(os.path.join(directory, f))]\n            self.add_path(root_files)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nexploring path to discover unsearched directories and save filepaths", "response": "def explore_path_filter(self, task_num, dirpath):\n        \"\"\"\n        Explore path to discover unsearched directories and save filepaths\n        :param task_num: Processor ID\n        :param dirpath: Tuple (base directory, path), path information pulled from unsearched Queue\n        :return: Directories to add to unsearched Queue\n        \"\"\"\n        base, path = dirpath\n        directories = []\n        nondirectories = []\n        if self.filters.validate(path):\n            self._printer(\"Task: \" + str(task_num) + \" >>> Explored path: \" + path, stream=True)\n            # Loop through paths\n            for filename in os.listdir(base + os.sep + path):\n                fullname = os.path.join(path, filename)\n                if self.filters.validate(fullname):\n                    # Check that non-empty folders flag is on and we're at the max directory level\n                    if self.filters.non_empty_folders and self.filters.get_level(fullname) == self.filters.max_level:\n                        # Check that the path is not an empty folder\n                        if os.path.isdir(base + os.sep + fullname):\n                            # Get paths in folder without walking directory\n                            paths = os.listdir(base + os.sep + fullname)\n\n                            # Check that any of the paths are files and not just directories\n                            if paths and any(os.path.isfile(os.path.join(base, fullname, p)) for p in paths):\n                                nondirectories.append((base, fullname))\n                    else:\n                        # Append to directories if dir\n                        if os.path.isdir(base + os.sep + fullname):\n                            directories.append((base, fullname))\n                        # Pass filters and append to nondirectories if file\n                        elif self.filters.validate(fullname):\n                            nondirectories.append((base, fullname))\n            self.add_path(nondirectories)\n        return directories"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef explore_path_encompass(self, task_num, dirpath):\n        base, path = dirpath\n        directories = []\n        nondirectories = []\n        self._printer(\"Task: \" + str(task_num) + \" >>> Explored path: \" + path, stream=True)\n        # Loop through paths\n        for filename in os.listdir(base + os.sep + path):\n            fullname = os.path.join(path, filename)\n            # Append to directories if dir\n            if os.path.isdir(base + os.sep + fullname):\n                directories.append((base, fullname))\n            # Pass filters and append to nondirectories if file\n            else:\n                nondirectories.append((base, fullname))\n        self.add_path(nondirectories)\n        return directories", "response": "Explore path to discover unsearched directories and save filepaths\n       "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncall when parallelize is True. This function will generate the file names in a directory tree by adding directories to a Queue and continuously exploring directories in the Queue until Queue is emptied. Significantly faster than crawler method for larger directory trees.", "response": "def sprinter(self):\n        \"\"\"\n        Called when parallelize is True.\n        This function will generate the file names in a directory tree by adding directories to a Queue and\n        continuously exploring directories in the Queue until Queue is emptied.\n        Significantly faster than crawler method for larger directory trees.\n        \"\"\"\n        self._printer('Multiprocess Walk')\n        # Loop through directories in case there is more than one (1)\n        for directory in self.directory:\n            self._get_root_files(directory)  # Add file within root directory if filepaths is empty\n            # acquire the list of paths\n            first_level_dirs = next(os.walk(directory))[1]\n            for path in first_level_dirs:\n                self.unsearched.put((directory, path))\n        self._printer('Pool Processing STARTED')\n        pool = Pool(self.pool_size)\n        pool.map_async(self.parallel_worker, range(self.pool_size))\n        pool.close()\n        self.unsearched.join()\n        self._printer('Pool Processing ENDED')\n        return self.filepaths"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a new object of type Provider with the given name and credentials.", "response": "def get_provider(name, creds):\n    \"\"\"\n    Generates and memoizes a :class:`~bang.providers.provider.Provider` object\n    for the given name.\n\n    :param str name:  The provider name, as given in the config stanza.  This\n        token is used to find the\n        appropriate :class:`~bang.providers.provider.Provider`.\n\n    :param dict creds:  The credentials dictionary that is appropriate for the\n        desired provider.  Typically, a sub-dict from the main stack config.\n\n    :rtype:  :class:`~bang.providers.provider.Provider`\n\n    \"\"\"\n    p = _PROVIDERS.get(name)\n    if not p:\n        provider = PROVIDER_MAP.get(name)\n        if not provider:\n            if name == 'hpcloud':\n                print \"## Warning - 'hpcloud' is not currently supported as\" \\\n                    \"a provider; use hpcloud_v12 or hpcloud_v13. See \" \\\n                    \"release notes.\"\n            raise Exception(\"No provider matches %s; check imports\" % name)\n        p = provider(creds)\n        _PROVIDERS[name] = p\n    return p"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nempties the bucket associated to the test deployment.", "response": "def empty_bucket(outputs_file):\n    \"\"\"Empty the bucket associated to the test deployment.\"\"\"\n    with open(outputs_file, \"r\") as f:\n        outputs = yaml.load(f)\n\n    bucket = outputs[\"storage\"][\"BucketName\"]\n\n    print(\"Emptying bucket {} ...\".format(bucket))\n    os.system(\"aws s3 rm s3://{} --recursive\".format(bucket))\n    print(\"Bucket {} has been emptied\".format(bucket))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nassume that azpts, elpts are each list of 1-D arrays or 2-D arrays az: 2-D Numpy array of azimuths in the image el: 2-D Numpy array of elevations in the image azpts: 1-D or 2-D Numpy array of azimuth points to see where nearest neighbor index is elpts: 1-D or 2-D Numpy array of azimuth points to see where nearest neighbor index is", "response": "def findClosestAzel(az, el, azpts, elpts):\n    \"\"\"\n    assumes that azpts, elpts are each list of 1-D arrays or 2-D arrays\n    az: 2-D Numpy array of azimuths in the image\n    el: 2-D Numpy array of elevations in the image\n    azpts: 1-D or 2-D Numpy array of azimuth points to see where nearest neighbor index is\n    elpts: 1-D or 2-D Numpy array of azimuth points to see where nearest neighbor index is\n    \"\"\"\n    assert az.ndim == 2\n    assert az.shape == el.shape\n\n    azpts = np.atleast_1d(azpts)\n    elpts = np.atleast_1d(elpts)\n\n    assert azpts.shape == elpts.shape\n\n    az = np.ma.masked_invalid(az)\n    el = np.ma.masked_invalid(el)\n\n    az = np.radians(az)\n    el = np.radians(el)\n    azpts = np.radians(azpts)\n    elpts = np.radians(elpts)\n\n    if np.ma.is_masked(azpts):\n        azpts = azpts.compressed()\n        elpts = elpts.compressed()\n    else:\n        azpts = np.atleast_1d(azpts).ravel()\n        elpts = np.atleast_1d(elpts).ravel()\n\n    # can be FAR FAR faster than scipy.spatial.distance.cdist()\n    nearRow, nearCol = _findindex(az, el, azpts, elpts)\n\n    return nearRow, nearCol"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nfind index of the nearest FOV to each point in the unmasked array", "response": "def _findindex(az0, el0, az, el):\n    \"\"\"\n    inputs:\n    ------\n    az0, el0: N-D array of azimuth, elevation. May be masked arrays\n    az, el: 1-D vectors of azimuth, elevation points from other camera to find closest angle for joint FOV.\n\n    output:\n    row, col:  index of camera 0 closest to camera 1 FOV for each unmasked pixel\n\n    I think with some minor tweaks this could be numba.jit if too slow.\n    \"\"\"\n\n    assert az0.size == el0.size  # just for clarity\n    assert az.ndim == el.ndim == 1, 'expect vector of test points'\n    ic = np.empty(az.size, dtype=int)\n\n    for i, (a, e) in enumerate(zip(az, el)):\n        # we do this point by point because we need to know the closest pixel for each point\n        # errang = haver.anglesep(az,el, apt,ept, deg=False)\n        ic[i] = haver.anglesep_meeus(az0, el0, a, e, deg=False).argmin()\n\n    \"\"\"\n    THIS UNRAVEL_INDEX MUST BE ORDER = 'C'\n    \"\"\"\n    r, c = np.unravel_index(ic, az0.shape, order='C')\n\n    mask = (c == 0) | (c == az0.shape[1] - 1) | (r == 0) | (r == az0.shape[0] - 1)\n\n    r = np.ma.masked_where(mask, r)\n    c = np.ma.masked_where(mask, c)\n\n    return r, c"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndecoding a byte string.", "response": "def decode_bytes(data: bytes, encoding: str = DEFAULT_CODING, errors: str = 'strict') -> str:\n    \"\"\"\n    \u96c6\u4e2d\u8c03\u7528 decode\n    \"\"\"\n    return data.decode(encoding, errors)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn True if the content of the resource is still valid.", "response": "def fresh(req_headers: HEADER_TYPE, res_headers: HEADER_TYPE) -> bool:\n    \"\"\"\n    \u6839\u636e req_headers, res_headers \u5224\u65ad\u6539\u6d88\u606f\u662f\u5426\u4e3a 304\n    \"\"\"\n    modified_since = cast(\n        Optional[str],\n        req_headers.get('if-modified-since'),\n    )\n    none_match = cast(\n        Optional[str],\n        req_headers.get('if-none-match'),\n    )\n    if not modified_since and not none_match:\n        return False\n    cache_control = req_headers.get('cache-control')\n    if cache_control is not None:\n        if isinstance(cache_control, list):\n            for control in cache_control:\n                if control.strip() == \"no-cache\":\n                    return False\n        elif cache_control.strip() == \"no-cache\":\n            return False\n    if none_match is not None and none_match != \"*\":\n        etag = cast(\n            Optional[str],\n            res_headers.get('ETag') or res_headers.get('etag'),\n        )\n        if etag is None:\n            return False\n        if etag.startswith(\"W/\"):\n            etag = etag[2:]\n        if none_match.startswith(\"W/\"):\n            none_match = none_match[2:]\n        etag_stale = True\n        matches = none_match.split(\",\")\n        for match in matches:\n            match = match.strip()\n            if match == etag:\n                etag_stale = False\n                break\n        if etag_stale:\n            return False\n    if modified_since:\n        last_modified = cast(\n            Optional[str],\n            res_headers.get('Last-Modified') or res_headers.get('last-modified'),\n        )\n        modified_stale = True\n        if last_modified is not None:\n            last_date = parse_http_date(last_modified)\n            modified_date = parse_http_date(modified_since)\n            if last_date != 0 and modified_date != 0 and last_date <= modified_date:\n                modified_stale = False\n        if modified_stale:\n            return False\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef reuse_handle(\n            self,\n            name: str,\n            rename: str,\n            pmap: Dict[str, Set[str]],\n    ) -> bool:\n        \"\"\"\n        \u5224\u65ad\u662f\u5426\u590d\u7528\u4e4b\u524d\u7684\n        \"\"\"\n        if name in pmap:\n            name_map = pmap[name]\n            if rename not in name_map:\n                name_map.add(rename)\n                func = self._func_map[name]\n                setattr(self._proto, rename, func)\n            return True\n        return False", "response": "reuse_handle - Reuse the handle for a specific object."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef method(self, name: str, rename: Optional[str] = None) -> 'ProxyAttr':\n        if rename is None:\n            rename = name\n        if self.reuse_handle(name, rename, self._method):\n            return self\n\n        def proxy_method(self2: Any, *args: Any, **kwargs: Any) -> Any:\n            \"\"\"\n            \u4ee3\u7406 method\n            \"\"\"\n            return getattr(getattr(self2, self._target), name)(*args, **kwargs)\n        self._func_map[name] = proxy_method\n        setattr(self._proto, name, proxy_method)\n        self._method[name] = {rename}\n        return self", "response": "Method \u4e3a\u7c7b\u8bbe\u7f6e\u4ee3\u7406 method\n            \u4e3a\u7c7b\u8bbe\u7f6e\u4ee3\u7406 method\n           "}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets a named attribute from the target object.", "response": "def getter(self, name: str, rename: Optional[str] = None) -> 'ProxyAttr':\n        \"\"\"\n        \u4e3a\u7c7b\u8bbe\u7f6e\u4ee3\u7406 getattr\n        \"\"\"\n        if rename is None:\n            rename = name\n        if self.reuse_handle(name, rename, self._getter):\n            return self\n\n        def proxy_get(this: Any) -> None:\n            \"\"\"\n            \u4ee3\u7406 getattr\n            \"\"\"\n            proxy_target = getattr(this, self._target)\n            return getattr(proxy_target, name)\n\n        if name in self._setter:\n            func = self._func_map[name]\n            func = func.getter(proxy_get)\n        else:\n            func = property(proxy_get)\n            self._func_map[name] = func\n        setattr(self._proto, rename, func)\n        self._getter[name] = {rename}\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\naccesses the attribute name.", "response": "def access(self, name: str, rename: Optional[str] = None) -> 'ProxyAttr':\n        \"\"\"\n        \u4e3a\u7c7b\u8bbe\u7f6e\u4ee3\u7406 getter, setter\n        \"\"\"\n        self.getter(name, rename)\n        self.setter(name, rename)\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef fmt_title(text):\n    text = text.strip()\n    if len(text) == 0:  # if empty string, return it\n        return text\n    else:\n        text = text.lower()  # lower all char\n        # delete redundant empty space\n        chunks = [chunk for chunk in text.split(\" \") if len(chunk) >= 1]\n\n        new_chunks = list()\n        for chunk in chunks:\n            if chunk not in _function_words:\n                chunk = chunk[0].upper() + chunk[1:]\n            new_chunks.append(chunk)\n\n        new_chunks[0] = new_chunks[0][0].upper() + new_chunks[0][1:]\n\n        return \" \".join(new_chunks)", "response": "Article title formatter.\n\n    Except functional words, first letter uppercase. Example:\n    \"Google Killing Annoying Browsing Feature\"\n\n    **\u4e2d\u6587\u6587\u6863**\n\n    \u6587\u7ae0\u6807\u9898\u7684\u683c\u5f0f, \u9664\u4e86\u865a\u8bcd, \u6bcf\u4e2a\u82f1\u6587\u5355\u8bcd\u7684\u7b2c\u4e00\u4e2a\u5b57\u6bcd\u5927\u5199\u3002"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef fmt_filename(text):\n    forbidden_char = [\"\\\\\", \"/\", \":\", \"*\", \"?\", \"|\", \"<\", \">\", '\"']\n    for char in forbidden_char:\n        text = text.replace(char, \"\")\n    return text", "response": "File name formatter.\n\n    Remove all file system forbidden char from text.\n\n    **\u4e2d\u6587\u6587\u6863**\n\n    \u79fb\u9664\u6587\u4ef6\u7cfb\u7edf\u4e2d\u4e0d\u5141\u8bb8\u7684\u5b57\u7b26\u3002"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef clean(self, value):\n        value = super().clean(value)\n        if value in (None, ''):\n            value = ''\n        value = smart_text(value)\n        if value == '':\n            return value\n        valid_values = []\n        for group_label, group in self.choices:\n            valid_values += [str(k) for k, v in group]\n        if value not in valid_values:\n            raise ValidationError(gettext('Select a valid choice. That choice is not one of the available choices.'))\n        return value", "response": "Validates that the input is in the list of available items."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef copy_all(self, ctxt):\n        '''\n         copies all values into the current context from given context\n        :param ctxt:\n        '''\n        for key, value  in ctxt.iteritems:\n            self.set_attribute(key, value)", "response": "Copy all values into the current context"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nresolves type of the class property for the object", "response": "def resolve(cls, propname, objcls=None):\n        '''\n            resolve type of the class property for the class. If objcls is not set then \n            assume that cls argument (class that the function is called from) is the class \n            we are trying to resolve the type for \n        :param cls:\n        :param objcls:\n        :param propname:\n        '''\n        # object class is not given\n        if objcls is None:\n            objcls = cls\n        # get type\n        typemap = cls._types.get(objcls)\n        if(typemap is not None):\n            # nothing registered for this property\n            return typemap.get(propname, None)\n        # type map didn't exist so none\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef register_type(cls, propname, valcls, objcls=None):\n        '''\n            register type for class \n             \n        :param cls:\n        :param propname:\n        :param valcls:\n        :param objcls:\n        '''\n        # object class is not given\n        if objcls is None:\n            objcls = cls\n        # get type map for objcls\n        typemap = cls._types.get(objcls, None)\n        # if type map doesn't exist then remove it\n        if not typemap:\n            typemap = {}\n            cls._types[objcls] = typemap\n        # register value class for property\n        typemap[propname] = valcls", "response": "register type for a property and value class for a given object"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _init_request_hooks(self):\n        for method_type in ('pre', 'post'):\n            for method in _METHODS:\n                event = getattr(self.app, 'on_' + method_type + '_' + method)\n                event_hook = getattr(hooks, method_type + '_' + method)\n                event += event_hook", "response": "initialize pre request hooks"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nbuilds a MetricResponse from a JSON object.", "response": "def from_json(cls, json_obj):\n        \"\"\"Build a MetricResponse from JSON.\n\n        :param json_obj: JSON data representing a Cube Metric.\n        :type json_obj: `String` or `json`\n        :throws: `InvalidMetricError` when any of {type,time,data} fields are\n        not present in json_obj.\n        \"\"\"\n        if isinstance(json_obj, str):\n            json_obj = json.loads(json_obj)\n\n        time = None\n        value = None\n\n        if cls.TIME_FIELD_NAME in json_obj:\n            time = json_obj[cls.TIME_FIELD_NAME]\n        else:\n            raise InvalidMetricError(\"{field} must be present!\".format(\n                field=cls.TIME_FIELD_NAME))\n\n        if cls.VALUE_FIELD_NAME in json_obj:\n            value = json_obj[cls.VALUE_FIELD_NAME]\n\n        return cls(time, value)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates an argument parser configured with options to run a bot from the command line.", "response": "def make_parser():\n    \"\"\"\n    Creates an argument parser configured with options to run a bot\n    from the command line.\n\n    :return: configured argument parser\n    :rtype: :class:`argparse.ArgumentParser`\n    \"\"\"\n    parser = ArgumentParser(\n        description='Start an IRC bot instance from the command line.',\n        formatter_class=ArgumentDefaultsHelpFormatter,\n    )\n    parser.add_argument(\n        '-v', '--version',\n        action='version',\n        version='{0} v{1}'.format(NAME, VERSION)\n    )\n    parser.add_argument(\n        '-s', '--server',\n        metavar='HOST',\n        required=True,\n        help='the host to connect to'\n    )\n    parser.add_argument(\n        '-p', '--port',\n        metavar='PORT',\n        type=int,\n        default=6667,\n        help='the port the server is listening on'\n    )\n    parser.add_argument(\n        '-n', '--nick',\n        metavar='NAME',\n        required=True,\n        help=\"the bot's nickname\"\n    )\n    parser.add_argument(\n        '-N', '--name',\n        metavar='NAME',\n        default=NAME,\n        help=\"the bot's real name\"\n    )\n    parser.add_argument(\n        '-c', '--channels',\n        metavar='CHAN',\n        nargs='*',\n        help='join this channel upon connection'\n    )\n    parser.add_argument(\n        '-l', '--log',\n        metavar='LEVEL',\n        default='INFO',\n        help='minimal level for displayed logging messages'\n    )\n    parser.add_argument(\n        '-S', '--ssl',\n        action='store_true',\n        help='connect to the server using SSL'\n    )\n    return parser"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate a new bot instance ready to be launched.", "response": "def make_bot():\n    \"\"\"\n    Creates a new bot instance ready to be launched.\n    \"\"\"\n    parser = make_parser()\n    args = parser.parse_args()\n    settings = {\n        'server': args.server,\n        'port': args.port,\n        'ssl': args.ssl,\n        'nick': args.nick,\n        'realname': args.name,\n        'channels': args.channels or [],\n        'loglevel': args.log,\n    }\n    return IRC(settings)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a SharedNamespace object for the given key.", "response": "def get_namespace(self, key):\n        \"\"\"\n        Returns a :class:`~bang.util.SharedNamespace` for the given\n        :attr:`key`.  These are used by\n        :class:`~bang.deployers.deployer.Deployer` objects of the same\n        ``deployer_class`` to coordinate control over multiple deployed\n        instances of like resources.  E.g. With 5 clones of an application\n        server, 5 :class:`~bang.deployers.deployer.Deployer` objects in\n        separate, concurrent processes will use the same shared namespace to\n        ensure that each object/process controls a distinct server.\n\n        :param str key:  Unique ID for the\n            namespace.  :class:`~bang.deployers.deployer.Deployer` objects that\n            call :meth:`get_namespace` with the same :attr:`key` will receive\n            the same :class:`~bang.util.SharedNamespace` object.\n\n        \"\"\"\n        namespace = self.shared_namespaces.get(key)\n        if namespace:\n            return namespace\n        ns = SharedNamespace(self.manager)\n        self.shared_namespaces[key] = ns\n        return ns"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef find_first(self, attr_name, resources, extra_prefix=''):\n        prefix = self.name + '-' + (extra_prefix + '-' if extra_prefix else '')\n        for res in resources:\n            attr = getattr(res, attr_name)\n            if attr.startswith(prefix):\n                return res", "response": "Returns the first Amazon RDS instance that is in the given stack."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add_lb_secgroup(self, lb_name, hosts, port):\n        self.lb_sec_groups.merge(lb_name, {'hosts': hosts, 'port': port})", "response": "Adds a security group rule to the load balancer"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding a host to the inventory.", "response": "def add_host(self, host, group_names=None, host_vars=None):\n        \"\"\"\n        Used by deployers to add hosts to the inventory.\n\n        :param str host:  The host identifier (e.g. hostname, IP address) to\n            use in the inventory.\n\n        :param list group_names:  A list of group names to which the host\n            belongs.  **Note:  This list will be sorted in-place.**\n\n        :param dict host_vars:  A mapping object of host *variables*.  This can\n            be a nested structure, and is used as the source of all the\n            variables provided to the ansible playbooks.  **Note:  Additional\n            key-value pairs (e.g. dynamic ansible values like\n            ``inventory_hostname``) will be inserted into this mapping\n            object.**\n\n        \"\"\"\n        gnames = group_names if group_names else []\n        hvars = host_vars if host_vars else {}\n\n        # Add in ansible's magic variables.  Assign them here because this is\n        # just about the earliest point we can calculate them before anything\n        # ansible-related (e.g. Stack.configure(), ``bang --host``) executes.\n        gnames.sort()\n        hvars[A.server.GROUP_NAMES] = gnames\n        hvars[A.server.INV_NAME] = host\n        hvars[A.server.INV_NAME_SHORT] = host.split('.')[0]\n\n        self.groups_and_vars.merge(host, hvars)\n\n        for gname in group_names:\n            self.groups_and_vars.append(gname, host)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef describe(self):\n        for stage, corunners in self.get_deployers():\n            print self.name, \"STAGE \", stage\n            for d in corunners:\n                print d.__class__.__name__, \",\".join(\n                        [p[1].__name__ for p in d.phases]\n                        )", "response": "Prints out the name of the deployer and all the tasks that have run"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef configure(self):\n        cfg = self.config\n        bang_config_dir = os.path.abspath(\n                os.path.dirname(cfg.filepath)\n                )\n        playbook_dir = os.path.join(bang_config_dir, 'playbooks')\n        creds = cfg.get(A.DEPLOYER_CREDS, {})\n        pb_kwargs = {\n                # this allows connection reuse using \"ControlPersist\":\n                'transport': 'ssh',\n                'module_path': os.path.join(bang_config_dir, 'common_modules'),\n                'remote_pass': creds.get(A.creds.SSH_PASS),\n                # TODO: determine forks\n                # 'forks': options.forks,\n                }\n        # only add the 'remote_user' kwarg if it's in the config, otherwise use\n        # ansible's default behaviour.\n        ssh_user = creds.get(A.creds.SSH_USER)\n        if ssh_user:\n            pb_kwargs['remote_user'] = ssh_user\n\n        ansible_cfg = cfg.get(A.ANSIBLE, {})\n        ansible_verbosity = ansible_cfg.get(A.ansible.VERBOSITY, 1)\n        ansible.utils.VERBOSITY = ansible_verbosity\n        for playbook in cfg.get(A.PLAYBOOKS, []):\n            playbook_path = os.path.join(playbook_dir, playbook)\n\n            # gratuitously stolen from main() in ``ansible-playbook``\n            stats = callbacks.AggregateStats()\n            playbook_cb = callbacks.PlaybookCallbacks(\n                    verbose=ansible_verbosity\n                    )\n            runner_cb = callbacks.PlaybookRunnerCallbacks(\n                    stats,\n                    verbose=ansible_verbosity\n                    )\n\n            vault_password = ansible_cfg.get(A.ansible.VAULT_PASS)\n            extra_kwargs = {\n                    'playbook': playbook_path,\n\n                    # TODO: do we really need new instances of the following\n                    # for each playbook?\n                    'callbacks': playbook_cb,\n                    'runner_callbacks': runner_cb,\n                    'stats': stats,\n\n                    # ``host_list`` is used to generate the inventory, but\n                    # don't worry, we override the inventory later\n                    'host_list': [],\n                    'vault_password': vault_password,\n                    }\n            pb_kwargs.update(extra_kwargs)\n            pb = PlayBook(**pb_kwargs)\n            inventory = BangsibleInventory(\n                    copy.deepcopy(self.groups_and_vars.lists),\n                    copy.deepcopy(self.groups_and_vars.dicts),\n                    vault_password=vault_password\n                    )\n            inventory.set_playbook_basedir(playbook_dir)\n            pb.inventory = inventory\n\n            pb.run()\n\n            hosts = sorted(pb.stats.processed.keys())\n            playbook_cb.on_stats(pb.stats)\n\n            failed = False\n            for h in hosts:\n                hsum = pb.stats.summarize(h)\n                if hsum['failures'] or hsum['unreachable']:\n                    failed = True\n                print \"%-30s : %s\" % (h, hsum)\n                # TODO: sort this out\n                # print \"%-30s : %s %s %s %s \" % (\n                #     hostcolor(h, hsum),\n                #     colorize('ok', hsum['ok'], 'green'),\n                #     colorize('changed', hsum['changed'], 'yellow'),\n                #     colorize('unreachable', hsum['unreachable'], 'red'),\n                #     colorize('failed', hsum['failures'], 'red'))\n\n            if failed:\n                raise BangError(\"Server configuration failed!\")", "response": "Executes the ansible playbooks that configure the servers in the stack."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nprints the inventory of the current user.", "response": "def show_inventory(self, pretty=False):\n        \"\"\"\n        Satisfies the ``--list`` portion of ansible's external inventory API.\n\n        Allows ``bang`` to be used as an external inventory script, for example\n        when running ad-hoc ops tasks.  For more details, see:\n        http://ansible.cc/docs/api.html#external-inventory-scripts\n\n        \"\"\"\n        inv_lists = copy.deepcopy(self.groups_and_vars.lists)\n        # sort the host lists to help consumers of the inventory (e.g. ansible\n        # playbooks)\n        for l in inv_lists.values():\n            l.sort()\n\n        # new in ansible 1.3: add hostvars directly into ``--list`` output\n        inv_lists['_meta'] = {\n                'hostvars': self.groups_and_vars.dicts.copy()\n                }\n\n        if pretty:\n            kwargs = {\n                    'sort_keys': True,\n                    'indent': 2,\n                    'separators': (',', ': '),\n                    }\n        else:\n            kwargs = {}\n        print json.dumps(inv_lists, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef interpolate(f1: float, f2: float, factor: float) -> float:\n    return f1 + (f2 - f1) * factor", "response": "Linearly interpolate between two float values."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef filter_value(old: float, new: float, factor: float) -> float:\n    r_factor: float = 1 - factor\n    return old * r_factor + new * factor", "response": "Linearly interpolate between two float values."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nformat a relative time.", "response": "def human_timestamp(__timestamp: datetime.datetime) -> str:\n    \"\"\"Format a relative time.\n\n    Args:\n        __timestamp: Event to generate relative timestamp against\n    Returns:\n        Human readable date and time offset\n    \"\"\"\n    numstr = '. a two three four five six seven eight nine ten'.split()\n\n    matches = [\n        60 * 60 * 24 * 365,\n        60 * 60 * 24 * 28,\n        60 * 60 * 24 * 7,\n        60 * 60 * 24,\n        60 * 60,\n        60,\n        1,\n    ]\n    match_names = ['year', 'month', 'week', 'day', 'hour', 'minute', 'second']\n\n    if __timestamp.tzinfo is None:\n        __timestamp = __timestamp.replace(tzinfo=datetime.timezone.utc)\n\n    now = datetime.datetime.utcnow().replace(tzinfo=datetime.timezone.utc)\n\n    delta = int((now - __timestamp).total_seconds())\n    for scale in matches:\n        i = delta // scale\n        if i:\n            name = match_names[matches.index(scale)]\n            break\n    else:\n        i = 0  # Too small\n\n    if i == 0:\n        result = 'right now'\n    elif i == 1 and name in ('year', 'month', 'week'):\n        result = 'last {}'.format(name)\n    elif i == 1 and name == 'day':\n        result = 'yesterday'\n    elif i == 1 and name == 'hour':\n        result = 'about an hour ago'\n    else:\n        result = 'about {} {}{} ago'.format(i if i > 10 else numstr[i], name,\n                                            's' if i > 1 else '')\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef parse_timedelta(__delta: str) -> datetime.timedelta:\n    match = re.fullmatch(r\"\"\"\n            ^(\\d+(?:|\\.\\d+))  # value, possibly float\n            \\ *\n            ([hdwmy])$  # units\n         \"\"\", __delta, re.IGNORECASE | re.VERBOSE)\n    if not match:\n        raise ValueError('Invalid \u2018frequency\u2019 value')\n    value, units = match.groups()\n    units_i = 'hdwmy'.index(units.lower())\n    # hours per hour/day/week/month/year\n    multiplier = (1, 24, 168, 672, 8760)\n    return datetime.timedelta(hours=float(value) * multiplier[units_i])", "response": "Parse human readable frequency."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef process_upload(photo_list, form, parent_object, user, status=''):\r\n    status += \"beginning upload processing. Gathering and normalizing fields....<br>\"\r\n\r\n    for upload_file in photo_list:\r\n        # lowercase and replace spaces in filename\r\n        upload_file.name = upload_file.name.lower().replace(' ', '_')\r\n        upload_name = upload_file.name\r\n\r\n        status += \"\"\"\r\n           File is {}.\r\n           Checking for single file upload or bulk upload... <br>\r\n           \"\"\".format(upload_name)\r\n        if upload_name.endswith('.jpg') or upload_name.endswith('.jpeg'):\r\n            status += \"Found jpg. Attempting to save... <br>\"\r\n            try:\r\n                dupe = ArticleImage.objects.get(photo__contains=upload_name, article=parent_object)\r\n            except ObjectDoesNotExist:\r\n                dupe = None\r\n            if not dupe:\r\n                try:\r\n                    upload = ArticleImage(\r\n                        article=parent_object,\r\n                        photo=upload_file\r\n                    )\r\n                    upload.save()\r\n                    status += \"Saved and uploaded jpg.\"\r\n                except Exception as error:\r\n                    status += \"Error saving image: {}\".format(error)\r\n        time.sleep(1)\r\n    return status", "response": "Processes and saves the files in photo_list."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef parse_vote_data(self, vote_data):\n        if 'epref' not in vote_data.keys():\n            logger.debug('Could not import data without epref %s',\n                vote_data['title'])\n            return\n\n        dossier_pk = self.get_dossier(vote_data['epref'])\n\n        if not dossier_pk:\n            logger.debug('Cannot find dossier with remote id %s',\n                         vote_data['epref'])\n            return\n\n        return self.parse_proposal_data(\n            proposal_data=vote_data,\n            dossier_pk=dossier_pk\n        )", "response": "Parse data from parltrack votes db dumps ( 1 proposal )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nparse a raw proposal data and create a new one", "response": "def parse_proposal_data(self, proposal_data, dossier_pk):\n        \"\"\"Get or Create a proposal model from raw data\"\"\"\n        proposal_display = '{} ({})'.format(proposal_data['title'].encode(\n            'utf-8'), proposal_data.get('report', '').encode('utf-8'))\n\n        if 'issue_type' not in proposal_data.keys():\n            logger.debug('This proposal data without issue_type: %s',\n                         proposal_data['epref'])\n            return\n\n        changed = False\n        try:\n            proposal = Proposal.objects.get(title=proposal_data['title'])\n        except Proposal.DoesNotExist:\n            proposal = Proposal(title=proposal_data['title'])\n            changed = True\n\n        data_map = dict(\n            title=proposal_data['title'],\n            datetime=_parse_date(proposal_data['ts']),\n            dossier_id=dossier_pk,\n            reference=proposal_data.get('report'),\n            kind=proposal_data.get('issue_type')\n        )\n\n        for position in ('For', 'Abstain', 'Against'):\n            position_data = proposal_data.get(position, {})\n            position_total = position_data.get('total', 0)\n\n            if isinstance(position_total, str) and position_total.isdigit():\n                position_total = int(position_total)\n\n            data_map['total_%s' % position.lower()] = position_total\n\n        for key, value in data_map.items():\n            if value != getattr(proposal, key, None):\n                setattr(proposal, key, value)\n                changed = True\n\n        if changed:\n            proposal.save()\n\n        responses = vote_pre_import.send(sender=self, vote_data=proposal_data)\n\n        for receiver, response in responses:\n            if response is False:\n                logger.debug(\n                    'Skipping dossier %s', proposal_data.get(\n                        'epref', proposal_data['title']))\n                return\n\n        positions = ['For', 'Abstain', 'Against']\n        logger.info(\n            'Looking for votes in proposal {}'.format(proposal_display))\n        for position in positions:\n            for group_vote_data in proposal_data.get(\n                    position,\n                    {}).get(\n                    'groups',\n                    {}):\n                for vote_data in group_vote_data['votes']:\n                    if not isinstance(vote_data, dict):\n                        logger.error('Skipping vote data %s for proposal %s',\n                                     vote_data, proposal_data['_id'])\n                        continue\n\n                    representative_pk = self.get_representative(vote_data)\n\n                    if representative_pk is None:\n                        logger.error('Could not find mep for %s', vote_data)\n                        continue\n\n                    representative_name = vote_data.get('orig', '')\n\n                    changed = False\n                    try:\n                        vote = Vote.objects.get(\n                            representative_id=representative_pk,\n                            proposal_id=proposal.pk)\n                    except Vote.DoesNotExist:\n                        vote = Vote(proposal_id=proposal.pk,\n                            representative_id=representative_pk)\n                        changed = True\n\n                    if vote.position != position.lower():\n                        changed = True\n                        vote.position = position.lower()\n\n                    if vote.representative_name != representative_name:\n                        changed = True\n                        vote.representative_name = representative_name\n\n                    if changed:\n                        vote.save()\n                        logger.debug('Save vote %s for MEP %s on %s #%s to %s',\n                            vote.pk, representative_pk, proposal_data['title'],\n                            proposal.pk, position)\n\n        return proposal"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef configurate_app(config_file=''):\n    # Load config\n    app.config.from_pyfile('defaults.py')\n    app.config.from_pyfile(config_file, silent=True)\n\n    if app.config.get('MINIFY_HTML', False):\n        app.jinja_env.add_extension('flask_utils.jinja2htmlcompress.HTMLCompress')\n\n    # Setup web assets\n    assets = Environment(app)\n\n    js = Bundle('common.js', filters='jsmin', output='gen/main.%(version)s.js')\n    css = Bundle('common.css', filters='cssmin', output='gen/main.%(version)s.css')\n\n    assets.register('js_all', js)\n    assets.register('css_all', css)\n\n    # Set host and port\n    port = app.config.get('PORT', 5000)\n    host = app.config.get('HOST', '127.0.0.1')\n\n    return app, host, port", "response": "Configure Flask app using PyConfig file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating a GET request to Yarr! server", "response": "def create_request(query):\n    \"\"\"\n    Creates a GET request to Yarr! server\n\n    :param query: Free-text search query\n    :returns: Requests object\n    \"\"\"\n    yarr_url = app.config.get('YARR_URL', False)\n\n    if not yarr_url:\n        raise('No URL to Yarr! server specified in config.')\n\n    api_token = app.config.get('YARR_API_TOKEN', False)\n    headers = {'X-API-KEY': api_token} if api_token else {}\n    payload = {'q': query}\n    url = '%s/search' % yarr_url\n\n    return requests.get(url, params=payload, headers=headers)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef requires_authentication(func):\n        def _auth(self, *args, **kwargs):\n            if not self._authenticated:\n                raise NotAuthenticatedException('Function {} requires'\n                                                .format(func.__name__)\n                                                + ' authentication')\n            else:\n                return func(self, *args, **kwargs)\n        return _auth", "response": "Decorator that raises an exception if the user is not authenticated and executes the function normally\n       ."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_user_info(self):\n        response = self._session.get(BASE_URL_TSQUARE + '/user/current.json')\n        response.raise_for_status() # raises an exception if not 200: OK\n        user_data = response.json()\n        del user_data['password'] # tsquare doesn't store passwords\n        return TSquareUser(**user_data)", "response": "Returns a TSquareUser object representing the currently logged in user."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_site_by_id(self, id):\n        response = self._session.get(BASE_URL_TSQUARE + '/site/{}.json'.format(id))\n        response.raise_for_status()\n        site_data = response.json()\n        return TSquareSite(**site_data)", "response": "Look up a site by ID and returns a TSquareSite representing that site."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_sites(self, filter_func=lambda x: True):\n        response = self._session.get(BASE_URL_TSQUARE + 'site.json')\n        response.raise_for_status() # raise an exception if not 200: OK\n        site_list = response.json()['site_collection']\n        if not site_list:\n            # this means that this t-square session expired. It's up\n            # to the user to re-authenticate.\n            self._authenticated = False\n            raise SessionExpiredException('The session has expired')\n        result_list = []\n        for site in site_list:\n            t_site = TSquareSite(**site)\n            if not hasattr(t_site, \"props\"):\n                t_site.props = {}\n            if not 'banner-crn' in t_site.props:\n                t_site.props['banner-crn'] = None\n            if not 'term' in t_site.props:\n                t_site.props['term'] = None\n            if not 'term_eid' in t_site.props:\n                t_site.props['term_eid'] = None\n            if filter_func(t_site):\n                result_list.append(t_site)\n        return result_list", "response": "Returns a list of TSquareSite objects that represent the sites available to a user."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the announcement list from a site if site is not None or from every TSquareSite otherwise. Returns a list of TSquareAnnouncement objects.", "response": "def get_announcements(self, site=None, num=10, age=20):\n        \"\"\"\n        Gets announcements from a site if site is not None, or from every\n        site otherwise. Returns a list of TSquareAnnouncement objects.\n        @param site_obj (TSquareSite) If non-None, gets only the announcements\n                                      from that site. If none, get anouncements\n                                      from all sites.\n        @param num - The number of announcements to fetch. Default is 10.\n        @param age - 'How far back' to go to retreive announcements. Default\n                     is 20, which means that only announcements that are\n                     less than 20 days old will be returned, even if there\n                     less than 'num' of them.\n        @returns - A list of TSquareAnnouncement objects. The length will be\n                   at most num, and it may be less than num depending on\n                   the number of announcements whose age is less than age.\n        \"\"\"\n        url = BASE_URL_TSQUARE + 'announcement/'\n        if site:\n            url += 'site/{}.json?n={}&d={}'.format(site.id, num, age)\n        else:\n            url += 'user.json?n={}&d={}'.format(num, age)\n        request = self._session.get(url)\n        request.raise_for_status()\n        announcement_list = request.json()['announcement_collection']\n        return map(lambda x: TSquareAnnouncement(**x), announcement_list)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_tools(self, site):\n        # hack - gotta bypass the tsquare REST api because it kinda sucks with tools\n        url = site.entityURL.replace('direct', 'portal')\n        response = self._session.get(url)\n        response.raise_for_status()\n        # scrape the resulting html\n        tools_dict_list = self._html_iface.get_tools(response.text)\n        return [TSquareTool(**x) for x in tools_dict_list]", "response": "Gets all tools associated with a site."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_syllabus(self, site):\n        tools = self.get_tools(site)\n        syllabus_filter = [x.href for x in tools if x.name == 'syllabus']\n        if not syllabus_filter:\n            return ''\n        response = self._session.get(syllabus_filter[0])\n        response.raise_for_status()\n        iframes = self._html_iface.get_iframes(response.text)\n        iframe_url = ''\n        for frame in iframes:\n            if frame['title'] == 'Syllabus ':\n                iframe_url = frame['src']\n        if iframe_url == '':\n            print \"WARHING: NO SYLLABUS IFRAME FOUND\"\n        response = self._session.get(iframe_url)\n        response.raise_for_status()\n        syllabus_html = self._html_iface.get_syllabus(response.text)\n        return syllabus_html", "response": "Gets the syllabus for a course."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef setup_app_scope(name, scope):\n\n    # load plugins\n    plugins = []\n    for plugin_name, active in get('settings').get('rw.plugins', {}).items():\n        plugin = __import__(plugin_name)\n        plugin_path = plugin_name.split('.')[1:] + ['plugin']\n        for sub in plugin_path:\n            plugin = getattr(plugin, sub)\n        plugins.append(scope.activate(plugin))\n\n    yield plugins\n    raise rw.gen.Return(scope['settings'])", "response": "activate plugins accordingly to config"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding a section to the internal list.", "response": "def add_section(self, section_name):\n        \"\"\"Add an empty section.\n        \"\"\"\n        if section_name == \"DEFAULT\":\n            raise Exception(\"'DEFAULT' is reserved section name.\")\n\n        if section_name in self._sections:\n            raise Exception(\n                \"Error! %s is already one of the sections\" % section_name)\n        else:\n            self._sections[section_name] = Section(section_name)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef remove_section(self, section_name):\n        if section_name == \"DEFAULT\":\n            raise Exception(\"'DEFAULT' is reserved section name.\")\n\n        if section_name in self._sections:\n            del self._sections[section_name]\n        else:\n            raise Exception(\"Error! cannot find section '%s'.\")", "response": "Remove a section from the cache."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting a section. If section already exists, overwrite the old one.", "response": "def set_section(self, section):\n        \"\"\"Set a section. If section already exists, overwrite the old one.\n        \"\"\"\n        if not isinstance(section, Section):\n            raise Exception(\"You\")\n\n        try:\n            self.remove_section(section.name)\n        except:\n            pass\n\n        self._sections[section.name] = copy.deepcopy(section)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreading configuration from file.", "response": "def load(self, path):\n        \"\"\"Read configuration from file.\n        \"\"\"\n        with open(path, \"rb\") as f:\n            content = f.read().decode(\"utf-8\")\n\n        section_text_list = list()\n\n        lines = list()\n        for line in content.split(\"\\n\"):\n            if line.startswith(\"[\"):\n                section_text_list.append(\"\\n\".join(lines))\n                lines = list()\n                lines.append(line)\n            else:\n                lines.append(line)\n\n        section_text_list.append(\"\\n\".join(lines))\n\n        self._sections = OrderedDict()\n        for text in section_text_list[1:]:\n            section = Section.from_text(text)\n            self._sections[section.name] = section"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef setup_logger(log_file, level=logging.DEBUG):\n    '''One function call to set up logging with some nice logs about the machine'''\n    cfg = AppBuilder.get_pcfg()\n    logger = cfg['log_module']\n    # todo make sure structlog is compliant and that logbook is also the correct name???\n    assert logger in (\"logging\", \"logbook\", \"structlog\"), 'bad logger specified'\n    exec(\"import {0};logging = {0}\".format(logger))\n\n    AppBuilder.logger = logging\n\n    logging.basicConfig(\n        filename=log_file,\n        filemode='w',\n        level=level,\n        format='%(asctime)s:%(levelname)s: %(message)s')  # one run\n    logging.debug('System is: %s' % platform.platform())\n    logging.debug('Python archetecture is: %s' % platform.architecture()[0])\n    logging.debug('Machine archetecture is: %s' % platform.machine())\n\n    set_windows_permissions(log_file)", "response": "One function call to set up logging with some nice logs about the machine"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_windows_permissions(filename):\n    '''\n    At least on windows 7 if a file is created on an Admin account,\n    Other users will not be given execute or full control.\n    However if a user creates the file himself it will work...\n    So just always change permissions after creating a file on windows\n\n    Change the permissions for Allusers of the application\n    The Everyone Group\n    Full access\n\n    http://timgolden.me.uk/python/win32_how_do_i/add-security-to-a-file.html\n    '''\n    #Todo rename this to allow_all, also make international not just for english..\n    if os.name == 'nt':\n        try:\n            everyone, domain, type = win32security.LookupAccountName(\n            \"\", \"Everyone\")\n        except Exception:\n            # Todo fails on non english langauge systesm ... FU WINDOWS\n            # Just allow permission for the current user then...\n            everyone, domain, type = win32security.LookupAccountName (\"\", win32api.GetUserName())\n        # ~ user, domain, type = win32security.LookupAccountName (\"\", win32api.GetUserName())\n        #~ userx, domain, type = win32security.LookupAccountName (\"\", \"User\")\n        #~ usery, domain, type = win32security.LookupAccountName (\"\", \"User Y\")\n\n        sd = win32security.GetFileSecurity(\n            filename,\n            win32security.DACL_SECURITY_INFORMATION)\n        # instead of dacl = win32security.ACL()\n        dacl = sd.GetSecurityDescriptorDacl()\n\n        #~ dacl.AddAccessAllowedAce(win32security.ACL_REVISION, con.FILE_GENERIC_READ | con.FILE_GENERIC_WRITE, everyone)\n        #~ dacl.AddAccessAllowedAce(win32security.ACL_REVISION, con.FILE_ALL_ACCESS, user)\n        dacl.AddAccessAllowedAce(\n            win32security.ACL_REVISION,\n            con.FILE_ALL_ACCESS,\n            everyone)\n\n        sd.SetSecurityDescriptorDacl(1, dacl, 0)   # may not be necessary\n        win32security.SetFileSecurity(\n            filename,\n            win32security.DACL_SECURITY_INFORMATION,\n            sd)", "response": "Set the permissions for the file on Windows"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef save(self):\n        '''saves our config objet to file'''\n        if self.app.cfg_mode == 'json':\n            with open(self.app.cfg_file, 'w') as opened_file:\n                json.dump(self.app.cfg, opened_file)\n        else:\n            with open(self.app.cfg_file, 'w')as opened_file:\n                yaml.dump(self.app.cfg, opened_file)", "response": "saves our config objet to file"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreads the config options by reading globals saved in peasoup. py as self. pcfg", "response": "def get_pcfg():\n        '''\n        sets up the config options by reading globals saved in peasoup/global.py\n        as self.pcfg\n        '''\n        path = os.path.dirname(AppBuilder.main_file)\n        file = os.path.join(path,\n                            PEASOUP_USER_DIR,\n                            PEASOUP_CONFIG_FILE)\n        with open(file) as f:\n            pcfg = json.load(f)\n        return pcfg"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate a new config file for the app.", "response": "def create_cfg(self, cfg_file, defaults=None, mode='json'):\n        '''\n        set mode to json or yaml? probably remove this option..Todo\n\n        Creates the config file for your app with default values\n        The file will only be created if it doesn't exits\n\n        also sets up the first_run attribute.\n\n        also sets correct windows permissions\n\n        you can add custom stuff to the config by doing\n        app.cfg['fkdsfa'] = 'fdsaf'\n        # todo auto save on change\n        remember to call cfg.save()\n\n        '''\n        assert mode in ('json', 'yaml')\n        self.cfg_mode = mode\n        self.cfg_file = cfg_file\n        try:\n            self.cfg = CfgDict(app=self, cfg=self.load_cfg())\n            logging.info('cfg file found : %s' % self.cfg_file)\n        except FileNotFoundError:\n            self.cfg = CfgDict(app=self, cfg={'first_run': True})\n            with suppress(TypeError):\n                self.cfg.update(defaults)\n            self.cfg.save()\n            set_windows_permissions(self.cfg_file)\n            logging.info(\n                'Created cfg file for first time!: %s' %\n                self.cfg_file)\n\n        if self._check_first_run():\n            self.first_run = True\n        else:\n            self.first_run = False"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef load_cfg(self):\n        '''loads our config object accessible via self.cfg'''\n        if self.cfg_mode == 'json':\n            with open(self.cfg_file) as opened_file:\n                return json.load(opened_file)\n        else:\n            with open(self.cfg_file) as ymlfile:\n                return yaml.safe_load(ymlfile)", "response": "loads our config object accessible via self. cfg"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _check_first_run(self):\n        '''\n        Checks if this is the first time our app is being run\n        This is called automatically when using create_cfg()\n        use then app.first_run attribute to check for True or False\n        '''\n        if self.cfg['first_run']:\n            self.cfg['first_run'] = False\n            self.cfg.save()\n            return True\n        else:\n            return False", "response": "Checks if this is the first time our app is being run"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_appdir(self, portable_path=None, folder=None, create=False):\n        '''\n        path = uac_bypass(file)\n\n        This function will only operate when your program is installed\n        check the is_installed function for details\n\n        Moves working data to another folder. The idea is to get around\n        security and uac on windows vista +\n\n        returns cwd on linux, windows returns path with write\n        access: C:\\\\ProgramData\\\\appname here\n\n        if a file is passed in it will be appended to the path\n\n        set create to true to create the file in the programData folder\n\n        setting overwrite to True will silently overwrite, otherwise a\n        FileExistsError is raised\n\n        Setting overwrite to get, will get the file path instead of throwing an error\n\n                                ---Background----\n        If a user is using windows, Read write access is restriced in the\n        Program Files directory without prompting for uac.\n\n        We create a folder in c:\\Program Data\\ of the program name and\n        save logging data etc there.\n\n        This way the program doesnt need admin rights.\n\n        '''\n        if self.is_installed():\n            appdir = appdirs.user_data_dir(self.app_name)\n        elif portable_path:\n            appdir = portable_path\n            if not folder:\n                folder = 'data^-^'\n        else:\n            appdir = os.getcwd()\n\n        if folder:\n            path = os.path.join(appdir, folder)\n        else:\n            path = appdir\n\n        path = os.path.realpath(path)\n\n        if create:\n            os.makedirs(path, exist_ok=1)\n        return path", "response": "Get the path to the user - specified app - data directory."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncheck if the app is already open.", "response": "def check_if_open(self, path=None, appdata=False, verbose=False):\n        '''\n        Allows only one version of the app to be open at a time.\n\n        If you are calling create_cfg() before calling this,\n        you don't need to give a path. Otherwise a file path must be\n        given so we can save our file there.\n\n        Set appdata to True to run uac_bypass on the path, otherwise\n        leave it as False\n        '''\n        #~ To know if the system crashed, or if the prgram was exited smoothly\n        #~ turn verbose to True and the function will return a named tuple  # TBD\n        #~ if os.name == 'nt':\n        #~ hwnd = int(self.root.wm_frame(),0)\n        #~ #saving a hwnd reference so we can check if we still open later on\n        #~ with open (self.check_file,'a') as f:\n        #~ f.write(str(hwnd))\n        #~ logging.info('adding hwnd to running info :'+str(hwnd))\n        #~\n        logging.info('Checking if our app is already Open')\n        if not path and self.cfg:\n            self._check_if_open_using_config()\n        elif path:\n            if appdata:\n                file = path.split(os.sep)[-1]\n                self.check_file = self.uac_bypass(file=file)\n            else:\n                self.check_file = path\n            self._check_if_open_using_path()\n\n        self.shutdown_cleanup['release_singleton'] = self.release_singleton"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef release_singleton(self):\n        '''deletes the data that lets our program know if it is\n        running as singleton when calling check_if_open,\n        i.e check_if_open will return fals after calling this\n       '''\n        with suppress(KeyError):\n            del self.cfg['is_programming_running_info']\n        with suppress(FileNotFoundError, AttributeError):\n            os.remove(self.check_file)", "response": "deletes the data that lets our program know if it is running as singleton"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef shutdown(self):\n        ''' shutdown operations on exit, this is run by\n        a finaly statement after the tkinter mainloop ends\n        call root.quit to get here,\n        Note you will still need to call sys.exit()\n        '''\n        logging.info('Shutdown procedures being run!')\n        for func in self.shutdown_cleanup.values():\n            func()\n        session_time = round((time.time() - self.start_time)/60, 0)\n        logging.info('session time: {0} minutes'.format(session_time))\n        logging.info('End..')", "response": "shutdown operations on exit, this is run by\n        a finaly statement after the tkinter mainloop ends\n        call root.quit to get here,\n        Note you will still need to call sys.exit()"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngives relative paths to files works when frozen or unfrozen returns the root path of the file", "response": "def rel_path(*file_path):\n        '''\n        gives relative paths to files, works when frozen or unfrozen\n        to get the root path just pass in the string __file__\n        '''\n        if hasattr(sys, 'frozen'):\n            if file_path[0] == '__file__':\n                return sys.executable\n            return os.path.join(os.path.dirname(sys.executable), *file_path)\n        else:\n            try:\n                main_file = AppBuilder.main_file\n            except AttributeError:\n                # The first call setting up the instance\n                main_file = inspect.stack()[1][1]\n            if file_path[0] == '__file__':\n                return os.path.realpath(main_file)\n            return os.path.join(os.path.dirname(main_file), *file_path)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\npacks an integer value using LEB128 encoding.", "response": "def pack_int_base128(cls, value):\n        \"\"\"\n        Pack integer value using LEB128 encoding\n        :param value: integer value to encode\n        :type value: int\n\n        :return: encoded value\n        :rtype: bytes\n        \"\"\"\n        assert isinstance(value, int)\n        if value < 1 << 14:\n            return cls._int_base128[value]\n\n        if value < 1 << 21:\n            return struct_BBB.pack(\n                value >> 14 & 0xff | 0x80,\n                value >> 7 & 0xff | 0x80,\n                value & 0x7F\n            )\n\n        if value < 1 << 28:\n            return struct_BBBB.pack(\n                value >> 21 & 0xff | 0x80,\n                value >> 14 & 0xff | 0x80,\n                value >> 7 & 0xff | 0x80,\n                value & 0x7F\n            )\n\n        if value < 1 << 35:\n            return struct_BBBBB.pack(\n                value >> 28 & 0xff | 0x80,\n                value >> 21 & 0xff | 0x80,\n                value >> 14 & 0xff | 0x80,\n                value >> 7 & 0xff | 0x80,\n                value & 0x7F\n            )\n\n        raise OverflowError(\"Number is too large to be packed\")"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef pack_str(cls, value):\n        assert isinstance(value, str)\n        value_len_packed = cls.pack_int_base128(len(value))\n        return struct.pack(\"<%ds%ds\" % (len(value_len_packed), len(value)), value_len_packed,  value)", "response": "Pack the string value of the ISO - 8601 date log record set into a byte string."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\npacks a unicode value into a byte array.", "response": "def pack_unicode(cls, value, charset=\"utf-8\", errors=\"strict\"):\n        \"\"\"\n        Pack string field\n        <field> ::= <int32_varint><data>\n\n        :param value: string to be packed\n        :type value: unicode\n\n        :return: packed value\n        :rtype: bytes\n        \"\"\"\n        assert isinstance(value, unicode)\n\n        try:\n            value = value.encode(charset, errors)\n        except UnicodeEncodeError as e:\n            raise InvalidData(\"Error encoding unicode value '%s': %s\" % (repr(value), e))\n\n        value_len_packed = cls.pack_int_base128(len(value))\n        return struct.pack(\"<%ds%ds\" % (len(value_len_packed), len(value)), value_len_packed,  value)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef pack_field(self, value):\n        if isinstance(value, str):\n            return self.pack_str(value)\n        elif isinstance(value, unicode):\n            return self.pack_unicode(value, self.charset, self.errors)\n        elif isinstance(value, int):\n            return self.pack_int(value)\n        elif isinstance(value, long):\n            return self.pack_long(value)\n        else:\n            raise TypeError(\"Invalid argument type '%s'. Only 'str', 'int' or long expected\" % (type(value).__name__))", "response": "Packs a single field of the log entry record into a byte array."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\npack a tuple of values into a byte string.", "response": "def pack_tuple(self, values):\n        \"\"\"\n        Pack tuple of values\n        <tuple> ::= <cardinality><field>+\n\n        :param value: tuple to be packed\n        :type value: tuple of scalar values (bytes, str or int)\n\n        :return: packed tuple\n        :rtype: bytes\n        \"\"\"\n        assert isinstance(values, (tuple, list))\n        cardinality = [struct_L.pack(len(values))]\n        packed_items = [self.pack_field(v) for v in values]\n        return b''.join(itertools.chain(cardinality, packed_items))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _unpack_int_base128(varint, offset):\n        res = ord(varint[offset])\n        if ord(varint[offset]) >= 0x80:\n            offset += 1\n            res = ((res - 0x80) << 7) + ord(varint[offset])\n            if ord(varint[offset]) >= 0x80:\n                offset += 1\n                res = ((res - 0x80) << 7) + ord(varint[offset])\n                if ord(varint[offset]) >= 0x80:\n                    offset += 1\n                    res = ((res - 0x80) << 7) + ord(varint[offset])\n                    if ord(varint[offset]) >= 0x80:\n                        offset += 1\n                        res = ((res - 0x80) << 7) + ord(varint[offset])\n        return res, offset + 1", "response": "Implement Perl unpack s w option aka base 128 decoding."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nunpack the tuple from byte buffer buff", "response": "def _unpack_tuple(self, buff):\n        \"\"\"\n        Unpacks the tuple from byte buffer\n        <tuple> ::= <cardinality><field>+\n\n        :param buff: byte array of the form <cardinality><field>+\n        :type buff: ctypes buffer or bytes\n\n        :return: tuple of unpacked values\n        :rtype: tuple\n        \"\"\"\n        cardinality = struct_L.unpack_from(buff)[0]\n        _tuple = ['']*cardinality\n        offset = 4    # The first 4 bytes in the response body is the <count> we have already read\n        for i in xrange(cardinality):\n            field_size, offset = self._unpack_int_base128(buff, offset)\n            field_data = struct.unpack_from(\"<%ds\" % field_size, buff, offset)[0]\n            _tuple[i] = field(field_data)\n            offset += field_size\n\n        return tuple(_tuple)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _unpack_body(self, buff):\n\n        # Unpack <return_code> and <count> (how many records affected or selected)\n        self._return_code = struct_L.unpack_from(buff, offset=0)[0]\n\n        # Separate return_code and completion_code\n        self._completion_status = self._return_code & 0x00ff\n        self._return_code >>= 8\n\n        # In case of an error unpack the body as an error message\n        if self._return_code != 0:\n            self._return_message = unicode(buff[4:-1], self.charset, self.errors)\n            if self._completion_status == 2:\n                raise TarantoolError(self._return_code, self._return_message)\n\n        # Unpack <count> (how many records affected or selected)\n        self._rowcount = struct_L.unpack_from(buff, offset=4)[0]\n\n        # If the response doesn't contain any tuple - there is nothing to unpack\n        if self._body_length == 8:\n            return\n\n        # Parse response tuples (<fq_tuple>)\n        if self._rowcount > 0:\n            offset = 8    # The first 4 bytes in the response body is the <count> we have already read\n            while offset < self._body_length:\n                # In resonse tuples have the form <size><tuple> (<fq_tuple> ::= <size><tuple>).\n                # Attribute <size> takes into account only size of tuple's <field> payload,\n                # but does not include 4-byte of <cardinality> field.\n                #Therefore the actual size of the <tuple> is greater to 4 bytes.\n                tuple_size = struct.unpack_from(\"<L\", buff, offset)[0] + 4\n                tuple_data = struct.unpack_from(\"<%ds\" % (tuple_size), buff, offset+4)[0]\n                tuple_value = self._unpack_tuple(tuple_data)\n                if self.field_types:\n                    self.append(self._cast_tuple(tuple_value))\n                else:\n                    self.append(tuple_value)\n\n                offset = offset + tuple_size + 4", "response": "Unpack the response body into a list of tuples."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _cast_field(self, cast_to, value):\n        if cast_to in (int, long, str):\n            return cast_to(value)\n        elif cast_to == unicode:\n            try:\n                value = value.decode(self.charset, self.errors)\n            except UnicodeEncodeError, e:\n                raise InvalidData(\"Error encoding unicode value '%s': %s\" % (repr(value), e))\n\n            return value\n        elif cast_to in (any, bytes):\n            return value\n        else:\n            raise TypeError(\"Invalid field type %s\" % (cast_to))", "response": "Convert field type from raw bytes to native python type"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconverts values of the tuple from raw bytes to native python types", "response": "def _cast_tuple(self, values):\n        \"\"\"\n        Convert values of the tuple from raw bytes to native python types\n\n        :param values: tuple of the raw database values\n        :type value: tuple of bytes\n\n        :return: converted tuple value\n        :rtype: value of native python types (bytes, int, unicode (or str for py3k))\n        \"\"\"\n        result = []\n        for i, value in enumerate(values):\n            if i < len(self.field_types):\n                result.append(self._cast_field(self.field_types[i], value))\n            else:\n                result.append(self._cast_field(self.field_types[-1], value))\n\n        return tuple(result)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nsend ping packet to tarantool server and receive response with empty body", "response": "def ping(self):\n        \"\"\"\n        send ping packet to tarantool server and receive response with empty body\n        \"\"\"\n        d = self.replyQueue.get_ping()\n        packet = RequestPing(self.charset, self.errors)\n        self.transport.write(bytes(packet))\n        return d.addCallback(self.handle_reply, self.charset, self.errors, None)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ninserts tuple returns a Deferred that will be called when the insert tuple is completed", "response": "def insert(self, space_no, *args):\n        \"\"\"\n        insert tuple, if primary key exists server will return error\n        \"\"\"\n        d = self.replyQueue.get()\n        packet = RequestInsert(self.charset, self.errors, d._ipro_request_id, space_no, Request.TNT_FLAG_ADD, *args)\n        self.transport.write(bytes(packet))\n        return d.addCallback(self.handle_reply, self.charset, self.errors, None)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef select(self, space_no, index_no, field_types, *args):\n        d = self.replyQueue.get()\n        packet = RequestSelect(self.charset, self.errors, d._ipro_request_id, space_no, index_no, 0, 0xffffffff, *args)\n        self.transport.write(bytes(packet))\n        return d.addCallback(self.handle_reply, self.charset, self.errors, field_types)", "response": "Select a set of fields from the cache."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsending update command and return reply", "response": "def update_ret(self, space_no, field_types, key_tuple, op_list):\n        \"\"\"\n        send update command(s), updated tuple(s) is(are) sent back\n        \"\"\"\n        d = self.replyQueue.get()\n        packet = RequestUpdate(self.charset, self.errors, d._ipro_request_id,\n                               space_no, Request.TNT_FLAG_RETURN, key_tuple, op_list)\n        self.transport.write(bytes(packet))\n        return d.addCallback(self.handle_reply, self.charset, self.errors, field_types)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndeletes tuple by primary key", "response": "def delete(self, space_no, *args):\n        \"\"\"\n        delete tuple by primary key\n        \"\"\"\n        d = self.replyQueue.get()\n        packet = RequestDelete(self.charset, self.errors, d._ipro_request_id, space_no, 0, *args)\n        self.transport.write(bytes(packet))\n        return d.addCallback(self.handle_reply, self.charset, self.errors, None)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef call(self, proc_name, field_types, *args):\n        d = self.replyQueue.get()\n        packet = RequestCall(self.charset, self.errors, d._ipro_request_id, proc_name, 0, *args)\n        self.transport.write(bytes(packet))\n        return d.addCallback(self.handle_reply, self.charset, self.errors, field_types)", "response": "send a request to the server procedure"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef fibs(n, m):\n    a = b = 1\n    for x in range(3, m + 1):\n        a, b = b, a + b\n        if x >= n:\n            yield b", "response": "Yields the Fibonacci numbers starting from n and ending at m."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nunloads the country model.", "response": "def unload_fixture(apps, schema_editor):\n    \"\"\"\n    Brutally deleting all 'Country' model entries for reversing operation\n    \"\"\"\n    appmodel = apps.get_model(APP_LABEL, COUNTRY_MODELNAME)\n    appmodel.objects.all().delete()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef precondition(precond):\n    def decorator(f):\n        \"\"\"`f` can be a reference to a method or function. In\n        both cases the `data` is expected to be passed as the\n        first positional argument (obviously respecting the\n        `self` argument when it is a method).\n        \"\"\"\n        def decorated(*args):\n            if len(args) > 2:\n                raise TypeError('%s takes only 1 argument (or 2 for instance methods)' % f.__name__)\n\n            try:\n                instance, data = args\n                if not isinstance(instance, Pipe):\n                    raise TypeError('%s is not a valid pipe instance' % instance)\n\n            except ValueError:  # tuple unpacking error\n                data = args[0]\n\n            try:\n                precond(data)\n            except UnmetPrecondition:\n                # bypass the pipe\n                return data\n            else:\n                return f(*args)\n        return decorated\n    return decorator", "response": "Decorator that checks that the precondition of the data structure expected for the given object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nwire the pipeline and returns a lazy object of the transformed data.", "response": "def run(self, data, rewrap=False, prefetch=0):\n        \"\"\"\n        Wires the pipeline and returns a lazy object of\n        the transformed data.\n\n        :param data: must be an iterable, where a full document\n        must be returned for each loop\n\n        :param rewrap: (optional) is a bool that indicates the need to rewrap\n        data in cases where iterating over it produces undesired results,\n        for instance ``dict`` instances.\n\n        :param prefetch: (optional) is an int defining the number of items to\n        be prefetched once the pipeline starts yielding data. The\n        default prefetching mechanism is based on threads, so be\n        careful with CPU-bound processing pipelines.\n        \"\"\"\n        if rewrap:\n            data = [data]\n\n        for _filter in self._filters:\n            _filter.feed(data)\n            data = _filter\n        else:\n            iterable = self._prefetch_callable(data, prefetch) if prefetch else data\n            for out_data in iterable:\n                yield out_data"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef camel_case_to_snake_case(name):\n    s1 = _FIRST_CAP_RE.sub(r'\\1_\\2', name)\n    return _ALL_CAP_RE.sub(r'\\1_\\2', s1).lower()", "response": "Convert a camel case string to snake case."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nload a builtin config file from the specs. yaml file.", "response": "def load_builtin_config(name, module_name=__name__, specs_path=specs.__path__):\n    \"\"\"\n    Uses package info magic to find the resource file located in the specs\n    submodule.\n    \"\"\"\n    config_path = Path(next(iter(specs_path)))\n    config_path = config_path / PurePath(resource_filename(module_name, name + '.yaml'))\n    return load_config(config_path)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef load_config(path):\n   with path.open('rb') as fi:\n       file_bytes = fi.read()\n       config = yaml.load(file_bytes.decode('utf-8'))\n\n   return config", "response": "Loads a yaml configuration file."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef load_swagger_config(name, base_url, config):\n   if isinstance(config, collections.abc.Mapping):\n       pass\n   elif isinstance(config, str):\n       with pathlib.Path(config).open('r') as infile:\n           config = yaml.load(infile)\n\n   elif isinstance(config, pathlib.Path):\n       with config.open('r') as infile:\n           config = yaml.load(infile)\n\n   else:\n       raise TypeError('Cannot load swagger config from type: {}'.format(type(config)))\n\n\n   service_config = dict([\n           ('name', name), ('base_url', base_url), ('apis', defaultdict(dict))])\n\n   apis = config['apis']\n\n\n   for api in apis:\n       # /some/path/to/my_resource -> MyResource\n       resource = snake_case_to_camel_case(api['path'].rsplit('/', 1)[-1])\n       for op in api['operations']:\n           verb = op['method'].upper()\n           args = [(param['name'], {'default' : None}) for param in op['parameters']\n                   if param['paramType'].lower() != 'header']\n\n           definition = dict([\n              ('url',  api['path']),\n              (verb, dict(args))\n               ])\n\n           service_config['apis'][resource].update(definition)\n\n   return service_config", "response": "Load a restful service from a YAML file."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef mkdir(path, parents=False):\n    func = os.makedirs if parents else os.mkdir\n    try:\n        return func(path)\n    except:\n        if not parents:\n            raise", "response": "create a new tree of objects"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef system_old(cls, line):\n        print('')\n        print('$ {}'.format(line))\n        return os.system(line)", "response": "A wrapper for os. system that does not work with duplicated system names."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nprocessing command - line arguments and populate values with consuming options and arguments from rargs.", "response": "def _process_args(self, largs, rargs, values):\n        \"\"\"_process_args(largs : [string],\n                         rargs : [string],\n        values : Values)\n\n        Process command-line arguments and populate 'values', consuming\n        options and arguments from 'rargs'.  If 'allow_interspersed_args' is\n        false, stop at the first non-option argument.  If true, accumulate any\n        interspersed non-option arguments in 'largs'.\n        \"\"\"\n        def _through_option(func, *args, **kwds):\n            \"\"\"new function\"\"\"\n            try:\n                func(*args, **kwds)\n            except optparse.BadOptionError as err:\n                largs.append(err.opt_str)\n\n        while rargs:\n            arg = rargs[0]\n            # We handle bare \"--\" explicitly, and bare \"-\" is handled by the\n            # standard arg handler since the short arg case ensures that the\n            # len of the opt string is greater than 1.\n            if arg == \"--\":\n                del rargs[0]\n                return\n            elif arg[0:2] == \"--\":\n                # process a single long option (possibly with value(s))\n                # self._process_long_opt(rargs, values)\n                _through_option(self._process_long_opt, rargs, values)  # modified\n\n            elif arg[:1] == \"-\" and len(arg) > 1:\n                # process a cluster of short options (possibly with\n                # value(s) for the last one only)\n                _through_option(self._process_short_opts, rargs, values)  # modified\n            elif self.allow_interspersed_args:\n                largs.append(arg)\n                del rargs[0]\n            else:\n                return"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nmoving the cursor to the target x y at a certain speed", "response": "def move_line(x, y, speed = 1):\n    \"\"\"\n    Moves the cursor in a straight line to (x, y) at a certain speed\n\n    :param x: target x-ordinate\n    :param y: target y-ordinate\n    :param speed: pixel traversal rate\n    :return: None\n    \"\"\"\n\n    _x, _y = win32api.GetCursorPos()\n    if x - _x:\n        m = (y - _y) / (x - _x)\n        c = y - (m * x)\n        for a in range(_x, x + 1, speed) if _x < x else range(_x, x - 1, -speed):\n            b = int(m * a + c)\n            move(a, b)\n            time.sleep(0.01)\n    else:\n        for b in range(_y, y + 1, speed) if _y <= y else range(_y, y - 1, -speed):\n            move(x, b)\n            time.sleep(0.01)\n    move(x, y)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nmoving the cursor in an arc of radius r to x y at a certain speed.", "response": "def move_arc(x, y, r, speed = 1, orientation = True):\n    # WARNING: This function currently contains inaccuracy likely due to the rounding of trigonometric functions\n    \"\"\"\n    Moves the cursor in an arc of radius r to (x, y) at a certain speed\n\n    :param x: target x-ordinate\n    :param y: target y-ordinate\n    :param r: radius\n    :param speed: pixel traversal rate\n    :param orientation: direction of arc\n    :return: None\n    \"\"\"\n\n    _x, _y = win32api.GetCursorPos()\n    c_len = (r**2 - (((x - _x)/2)**2 + ((y - _y)/2)**2))**0.5\n    t = (c_len**2/((y - _y)**2 + (x - _x)**2))**0.5\n    t = t if orientation else -t\n    centre = ((_x + x)/2 + t*(_x - x), (_y + y)/2 + t*(y - _y))\n    if any(isinstance(ordinate, complex) for ordinate in centre):\n        raise ValueError(\"Radius too low - minimum: {}\".format(((x - _x)**2 + (y - _y)**2)**0.5/2))\n    theta = math.atan2(_y - centre[1], _x - centre[0])\n    end = math.atan2(y - centre[1], x - centre[0])\n    while theta < end:\n        move(*list(map(round, (centre[0] + r*math.cos(theta), centre[1] + r*math.sin(theta)))))\n        theta += speed/100\n        time.sleep(0.01)\n    move(x, y)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndragging the mouse along a specified path", "response": "def drag(*args, function = move):\n    \"\"\"\n    Drags the mouse along a specified path\n\n    :param args: list of arguments passed to function\n    :param function: path to traverse\n    :return: None\n    \"\"\"\n\n    x, y = win32api.GetCursorPos()\n    win32api.mouse_event(win32con.MOUSEEVENTF_LEFTDOWN, x, y, 0, 0)\n    function(*args)\n    x, y = win32api.GetCursorPos()\n    win32api.mouse_event(win32con.MOUSEEVENTF_LEFTUP, x, y, 0, 0)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef click_left(x = None, y = None, hold_time = 0):\n\n    if not x or not y:\n        cursor = win32api.GetCursorPos()\n        if not x:\n            x = cursor[0]\n        if not y:\n            y = cursor[1]\n    move(x, y)\n    win32api.mouse_event(win32con.MOUSEEVENTF_LEFTDOWN, x, y, 0, 0)\n    time.sleep(hold_time)\n    win32api.mouse_event(win32con.MOUSEEVENTF_LEFTUP, x, y, 0, 0)", "response": "Simulates a mouse left click on the specified pixel."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef click_right(x = None, y = None, hold_time = 0):\n\n    if not x or not y:\n        cursor = win32api.GetCursorPos()\n        if not x:\n            x = cursor[0]\n        if not y:\n            y = cursor[1]\n    move(x, y)\n    win32api.mouse_event(win32con.MOUSEEVENTF_RIGHTDOWN, x, y, 0, 0)\n    time.sleep(hold_time)\n    win32api.mouse_event(win32con.MOUSEEVENTF_RIGHTUP, x, y, 0, 0)", "response": "Simulates a mouse right click on the specified pixel."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add(self, action):\n        self._state_machine.transition_to_add()\n        self._actions.append(action)", "response": "Add an action to the execution queue."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef execute(self):\n        self._state_machine.transition_to_execute()\n        for action in self._actions:\n            self._executed_actions.append(action)\n            self.execute_with_retries(action, lambda a: a.execute())\n        self._state_machine.transition_to_execute_complete()", "response": "Execute all actions returning a list of the result classes that have been executed."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncall rollback on executed actions.", "response": "def rollback(self):\n        \"\"\"Call rollback on executed actions.\"\"\"\n        self._state_machine.transition_to_rollback()\n        for action in reversed(self._executed_actions):\n            try:\n                self.execute_with_retries(action, lambda a: a.rollback())\n            except:  # pylint: disable=bare-except\n                pass  # on exception, carry on with rollback of other steps\n        self._state_machine.transition_to_rollback_complete()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef execute_with_retries(self, action, f):\n        # Run action until either it succeeds or throws an exception\n        # that's not an ActionRetryException\n        retry = True\n        while retry:\n            retry = False\n            try:\n                f(action)\n            except ActionRetryException as ex:  # other exceptions should bubble out\n                retry = True\n                time.sleep(ex.ms_backoff / 1000.0)", "response": "Execute function f with single argument action. Retry if ActionRetryException is raised."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nmatch email_pattern to string.", "response": "def email_match(string):\n    \"\"\"\u90ae\u7bb1\u5730\u5740\u5339\u914d. \u5339\u914d\u6210\u529f\u8fd4\u56de(email_name, email_server), \u5426\u5219\u8fd4\u56deNone\"\"\"\n    m = re.match(email_pattern, string)\n    if m:\n        # print('Match success: %s' % m.string)\n        return m.groups()[0], m.groups()[2]\n    else:\n        # print('Match failed: %s' % string)\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef fetch_git(repo, filename, branch=\"master\", hash=None):\n    url = git_url(repo, filename, branch, hash)\n    response = requests.get(url)\n\n    if response.status_code != 200:\n        raise Exception('Got a bad status looking up gist.')\n    body = response.text\n    if not body:\n        raise Exception('Unable to get the gist contents.')\n\n    return body", "response": "Fetch a gist and return the contents as a string."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef setup_git(pelican):\n    pelican.settings.setdefault('GIT_CACHE_ENABLED', False)\n    pelican.settings.setdefault('GIT_CACHE_LOCATION',\n                                '/tmp/git-cache')\n\n    # Make sure the cache directory exists\n    cache_base = pelican.settings.get('GIT_CACHE_LOCATION')\n    if not os.path.exists(cache_base):\n        os.makedirs(cache_base)", "response": "Setup the default settings."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreplace gist tags in the article content with gist tags in the article content.", "response": "def replace_git_url(generator):\n    \"\"\"Replace gist tags in the article content.\"\"\"\n    template = g_jinja2.get_template(GIT_TEMPLATE)\n\n    should_cache = generator.context.get('GIT_CACHE_ENABLED')\n    cache_location = generator.context.get('GIT_CACHE_LOCATION')\n\n    for article in generator.articles:\n        for match in git_regex.findall(article._content):\n            params = collections.defaultdict(str)\n            repo = match[1]\n            filename = match[3]\n            branch = match[5]\n            hash = match[7]\n\n            params['repo'] = match[1]\n            params['filename'] = match[3]\n            if match[5]:\n                params['branch'] = match[5]\n            if match[7]:\n                params['hash'] = match[7]\n\n            logger.info('[git]: Found repo {}, filename {}, branch {} and hash {}'.format(repo, filename, branch, hash))\n            logger.info('[git]: {}'.format(params))\n\n            body = None if not should_cache else get_cache(cache_location, **params)\n\n            # Fetch the git\n            if not body:\n                logger.info('[git]: Git did not exist in cache, fetching...')\n                response = fetch_git(**params)\n                body = get_body(response)\n\n                if should_cache:\n                    logger.info('[git]: Saving git to cache...')\n                    cache_params = copy.copy(params)\n                    cache_params['body'] = body\n                    set_cache(cache_location, **cache_params)\n            else:\n                logger.info('[git]: Found git in cache.')\n\n            # Create a context to render with\n            context = generator.context.copy()\n            context.update({\n                'code': body,\n                'footer': 'full',\n                'base': __url__,\n                'filename': filename,\n                'url': git_url(**params)\n            })\n            replacement = template.render(context)\n            article._content = article._content.replace(match[0], replacement)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef time_str (time_t, slug = False):\n  '''Converts floating point number a'la time.time()\n  using DEFAULT_TIMEFORMAT\n  '''\n  return datetime.fromtimestamp (int (time_t)).strftime (\n    DEFAULT_SLUGFORMAT if slug else DEFAULT_TIMEFORMAT)", "response": "Converts floating point number a la time. time()\n using DEFAULT_TIMEFORMAT\n \u00bb"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngiving current time as tuple t t_str string of t", "response": "def now (time_t = None, slug = False):\n  '''Gives current time as tuple (t, t_str) where\n     t is integer portion from time.time()\n     t_str string of t using DEFAULT_TIMEFORMAT\n  '''\n  if not time_t:\n    time_t = time ()\n  time_s = strftime (\n    DEFAULT_SLUGFORMAT if slug else DEFAULT_TIMEFORMAT,\n    gmtime (time_t))\n  return (int (time_t), time_s)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef input(message, until, single_char=False, transform=lambda a: a):\n    def _getch(message):\n        print(message, end='')\n        return getch()\n\n    while True:\n        text = transform(line_input(message) if not single_char else _getch(message))\n        if until(text):\n            return text", "response": "Takes a message and returns the input text until a condition is met."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreads an option from the screen with a specified prompt.", "response": "def input_option(message, options=\"yn\", error_message=None):\n    \"\"\"\n    Reads an option from the screen, with a specified prompt.\n        Keeps asking until a valid option is sent by the user.\n    \"\"\"\n    def _valid(character):\n        if character not in options:\n            print(error_message % character)\n    return input(\"%s [%s]\" % (message, options), _valid, True, lambda a: a.lower())"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef safe_unicode(obj, *args):\n    try:\n        return unicode(obj, *args)  # noqa for undefined-variable\n    except UnicodeDecodeError:\n        # obj is byte string\n        ascii_text = str(obj).encode('string_escape')\n        try:\n            return unicode(ascii_text)  # noqa for undefined-variable\n        except NameError:\n            # This is Python 3, just return the obj as it's already unicode\n            return obj\n    except NameError:\n        # This is Python 3, just return the obj as it's already unicode\n        return obj", "response": "safe unicode representation of obj"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the byte string representation of obj", "response": "def safe_str(obj):\n    \"\"\" return the byte string representation of obj \"\"\"\n    try:\n        return str(obj)\n    except UnicodeEncodeError:\n        # obj is unicode\n        try:\n            return unicode(obj).encode('unicode_escape')  # noqa for undefined-variable\n        except NameError:\n            # This is Python 3, just return the obj as it's already unicode\n            return obj"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef crosstalk_correction(pathway_definitions,\n                         random_seed=2015,\n                         gene_set=set(),\n                         all_genes=True,\n                         max_iters=1000):\n    \"\"\"A wrapper function around the maximum impact estimation algorithm.\n\n    Parameters\n    -----------\n    pathway_definitions : dict(str -> set(str))\n        The original pathway definitions.\n        A pathway (key) is defined by a set of genes (value).\n    random_seed : int (default=2015)\n        Sets the numpy random seed\n    gene_set : set(str) (default=set())\n        Donato et al. (2013) uses this algorithm to remove crosstalk from\n        definitions in case-control studies. Here, `gene_set` is equivalent\n        to the DE (differentially expressed) genes they refer to in their\n        paper. Because crosstalk removal is a preprocessing step\n        applicable to pathway analyses in general, we keep the variable\n        name nonspecific.\n    all_genes : bool (default=True)\n        This value is checked if `gene_set` is not empty.\n        If False, crosstalk correction is only applied to annotations in\n        the `gene_set`.\n    max_iters : int (default=1000)\n        The maximum number of expectation-maximization steps to take in the\n        maximum impact estimation algorithm.\n\n    Returns\n    ----------\n    dict(str -> tup(set(str), set(str))), where the (str) keys are the\n      pathway names.\n      tup[0] : crosstalk-correction applied to genes in the pathway\n               definition that are also in `gene_set`\n      tup[1] :\n      - `all_genes` is True.\n        Correction is applied to genes outside of `gene_set`.\n      - `all_genes` is False.\n         The second element in the tuple is all genes\n         remaining in the original definition (definition - `gene_set`).\n    \"\"\"\n    np.random.seed(seed=random_seed)\n\n    genes_in_pathway_definitions = set.union(*pathway_definitions.values())\n    pathway_column_names = index_element_map(pathway_definitions.keys())\n\n    corrected_pathway_defns = {}\n    if gene_set:\n        gene_set = gene_set & genes_in_pathway_definitions\n        if not gene_set and not all_genes:\n            print(\"`gene_set` parameter was {0}, returning original\"\n                  \"pathway definitions\".format(gene_set))\n            for pathway, definition in pathway_definitions.items():\n                corrected_pathway_defns[pathway] = (set(), definition)\n            return pathway_definitions\n\n        corrected_pathway_defns = _apply_correction_on_genes(\n            gene_set, pathway_column_names, pathway_definitions)\n\n        # crosstalk correction is _only_ applied to `gene_set`\n        if not all_genes:\n            for pathway, definition in pathway_definitions.items():\n                if pathway not in corrected_pathway_defns:\n                    corrected_pathway_defns[pathway] = set()\n                gene_set_defn = corrected_pathway_defns[pathway]\n                remaining_defn = definition - gene_set\n                corrected_pathway_defns[pathway] = (\n                    gene_set_defn, remaining_defn)\n            return corrected_pathway_defns\n\n    remaining_genes = genes_in_pathway_definitions - gene_set\n    if not remaining_genes:\n        for pathway, definition in corrected_pathway_defns.items():\n            corrected_pathway_defns[pathway] = (definition, set())\n        return corrected_pathway_defns\n\n    pathway_remaining_defns = _apply_correction_on_genes(\n        remaining_genes, pathway_column_names, pathway_definitions)\n\n    for pathway, definitions in pathway_definitions.items():\n        if pathway not in corrected_pathway_defns:\n            corrected_pathway_defns[pathway] = set()\n\n        if pathway not in pathway_remaining_defns:\n            pathway_remaining_defns[pathway] = set()\n\n        corrected_pathway_defns[pathway] = (\n            corrected_pathway_defns[pathway],\n            pathway_remaining_defns[pathway])\n    return corrected_pathway_defns", "response": "A wrapper function around the maximum impact estimation algorithm."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates the binary gene - to - pathway membership matrix that contains the maximum impact estimation procedure.", "response": "def initialize_membership_matrix(gene_row_names, pathway_definitions):\n    \"\"\"Create the binary gene-to-pathway membership matrix that\n    will be considered in the maximum impact estimation procedure.\n\n    Parameters\n    -----------\n    gene_row_names : set(str)\n        The genes for which we want to assess pathway membership\n    pathway_definitions : dict(str -> set(str))\n        Pathway definitions, pre-crosstalk-removal.\n        A pathway (key) is defined by a set of genes (value).\n\n    Returns\n    -----------\n    numpy.array, shape = [n, k], the membership matrix\n    \"\"\"\n    membership = []\n    for pathway, full_definition in pathway_definitions.items():\n        pathway_genes = list(full_definition & gene_row_names)\n        membership.append(np.in1d(list(gene_row_names), pathway_genes))\n    membership = np.array(membership).astype(\"float\").T\n    return membership"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef index_element_map(arr):\n    index_to_element = {}\n    for index, element in enumerate(arr):\n        index_to_element[index] = element\n    return index_to_element", "response": "Map the indices of the array to the respective elements."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _apply_correction_on_genes(genes,\n                               pathway_column_names,\n                               pathway_definitions):\n    \"\"\"Helper function to create the gene-to-pathway\n    membership matrix and apply crosstalk correction on that\n    matrix. Returns the crosstalk-corrected pathway definitions\n    for the input `genes.`\n    \"\"\"\n    gene_row_names = index_element_map(genes)\n    membership_matrix = initialize_membership_matrix(\n        genes, pathway_definitions)\n    crosstalk_corrected_index_map = maximum_impact_estimation(\n        membership_matrix)\n\n    updated_pathway_definitions = _update_pathway_definitions(\n        crosstalk_corrected_index_map,\n        gene_row_names, pathway_column_names)\n    return updated_pathway_definitions", "response": "Helper function to create the gene - to - pathway - tree - model matrix and apply crosstalk correction on the gene - to - pathway - tree model matrix."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _update_pathway_definitions(crosstalk_corrected_index_map,\n                                gene_row_names,\n                                pathway_column_names):\n    \"\"\"Helper function to convert the mapping of int\n    (pathway id -> list of gene ids) to the corresponding pathway\n    names and gene identifiers.\n    \"\"\"\n    corrected_pathway_definitions = {}\n    for pathway_index, gene_indices in crosstalk_corrected_index_map.items():\n        pathway = pathway_column_names[pathway_index]\n        genes = set([gene_row_names[index] for index in list(gene_indices)])\n        corrected_pathway_definitions[pathway] = genes\n    return corrected_pathway_definitions", "response": "Helper function to update pathway_row_names and pathway_column_names with the corrected pathway_row_names and gene identifiers."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nupdate the probability vector for each iteration of the expectation maximum impact estimation.", "response": "def _update_probabilities(pr, membership_matrix):\n    \"\"\"Updates the probability vector for each iteration of the\n    expectation maximum algorithm in maximum impact estimation.\n\n    Parameters\n    -----------\n    pr : numpy.array(float), shape = [k]\n        The current vector of probabilities. An element at index j,\n        where j is between 0 and k - 1, corresponds to the probability that,\n        given a gene g_i, g_i has the greatest impact in pathway j.\n    membership_matrix : numpy.array(float), shape = [n, k]\n        The observed gene-to-pathway membership matrix, where n is the number\n        of genes and k is the number of pathways we are interested in.\n\n    Returns\n    -----------\n    numpy.array(float), shape = [k], a vector of updated probabilities\n    \"\"\"\n    n, k = membership_matrix.shape\n    pathway_col_sums = np.sum(membership_matrix, axis=0)\n\n    weighted_pathway_col_sums = np.multiply(pathway_col_sums, pr)\n    sum_of_col_sums = np.sum(weighted_pathway_col_sums)\n    try:\n        new_pr = weighted_pathway_col_sums / sum_of_col_sums\n    except FloatingPointError:\n        # In the event that we encounter underflow or overflow issues,\n        # apply this approximation.\n        cutoff = 1e-150 / k\n        log_cutoff = np.log(cutoff)\n\n        weighted_pathway_col_sums = _replace_zeros(\n            weighted_pathway_col_sums, cutoff)\n        log_weighted_col_sums = np.log(weighted_pathway_col_sums)\n        log_weighted_col_sums -= np.max(log_weighted_col_sums)\n\n        below_cutoff = log_weighted_col_sums < log_cutoff\n        geq_cutoff = log_weighted_col_sums >= log_cutoff\n\n        print(\"{1} adjustments made to a vector of length {0}\"\n              \" containing the raw weight values\"\n              \" in a call to 'update_probabilities'\".format(\n                  k, len(log_weighted_col_sums[below_cutoff])))\n\n        new_pr = np.zeros(k)\n        new_pr[below_cutoff] = cutoff\n        col_sums_geq_cutoff = log_weighted_col_sums[geq_cutoff]\n        new_pr[geq_cutoff] = np.exp(\n            col_sums_geq_cutoff) / np.sum(np.exp(sorted(col_sums_geq_cutoff)))\n\n    difference = np.abs(1. - np.sum(new_pr))\n    assert difference < 1e-12, \"Probabilities sum to {0}.\".format(\n           np.sum(new_pr))\n    return new_pr"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nsubstitute 0s in the list with a near - zero value.", "response": "def _replace_zeros(arr, default_min_value):\n    \"\"\"Substitute 0s in the list with a near-zero value.\n\n    Parameters\n    -----------\n    arr : numpy.array(float)\n    default_min_value : float\n        If the smallest non-zero element in `arr` is greater than the default,\n        use the default instead.\n\n    Returns\n    -----------\n    numpy.array(float)\n    \"\"\"\n    min_nonzero_value = min(default_min_value, np.min(arr[arr > 0]))\n    closest_to_zero = np.nextafter(min_nonzero_value, min_nonzero_value - 1)\n    arr[arr == 0] = closest_to_zero\n    return arr"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\npatching the thread module to make it greenlet - based.", "response": "def patch_thread(threading=True, _threading_local=True, Queue=True, Event=False):\r\n    \"\"\"Replace the standard :mod:`thread` module to make it greenlet-based.\r\n    If *threading* is true (the default), also patch ``threading``.\r\n    If *_threading_local* is true (the default), also patch ``_threading_local.local``.\r\n    \"\"\"\r\n    monkey.patch_module('thread')\r\n    if threading:\r\n        monkey.patch_module('threading')\r\n        threading = __import__('threading')\r\n        if Event:\r\n            from gevent.event import Event\r\n            threading.Event = Event\r\n        if Queue:\r\n            from gevent import queue\r\n            threading.queue = queue\r\n    if _threading_local:\r\n        _threading_local = __import__('_threading_local')\r\n        from gevent.local import local\r\n        _threading_local.local = local"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef classify(in_x, groups, labels, k):\n    # \u8ba1\u7b97\u6b27\u5f0f\u8ddd\u79bb\n    gl = array_len(groups)\n    tmp = tile(in_x, (gl, 1)) - groups\n    tmp = exponential_operation(tmp, 2)\n    tmp = array_sum(tmp)\n    tmp = exponential_operation(tmp, 0.5)\n\n    # \u5f97\u5230\u6392\u5e8f\u540e\u7684\u6570\u7ec4\u7684\u7d22\u5f15\n    arg = argsort(tmp)\n\n    # \u8ba1\u7b97\u6700\u76f8\u4f3c\u6570\u636e\u7684\u524dk\u4e2a\u6570\u636e\u7684\u5206\u7c7b\u6b21\u6570\n    cc = odict()\n    for i in range(k):\n        # \u83b7\u5f97\u7c7b\u522b\u6b21\u6570\n        la = labels[arg[i]]\n        cc[la] = cc.get(la, 0) + 1\n    return max(cc)", "response": "classify a single group by k"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef annotations(from_defaults=True, **kwargs):\n\n    def decorator(func):\n        func = set_annotations(**kwargs)(func)\n        if from_defaults:\n            func = infer_from_defaults(func)\n        func = resolve_shortcuts(func)\n        func = with_annotations(func)\n        return func\n\n    return decorator", "response": "A decorator which coerces argument values to the annotated types."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\noutputting the frames to an hdf file.", "response": "def hdfoutput(outname, frames, dozip=False):\n    '''Outputs the frames to an hdf file.'''\n    with h5.File(outname,'a') as f:\n        for frame in frames:\n            group=str(frame['step']);\n            h5w(f, frame, group=group,\n                compression='lzf' if dozip else None);"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef beds_to_boolean(beds, ref=None, beds_sorted=False, ref_sorted=False,\n                    **kwargs):\n    \"\"\"\n    Compare a list of bed files or BedTool objects to a reference bed file and\n    create a boolean matrix where each row is an interval and each column is a 1\n    if that file has an interval that overlaps the row interval and a 0\n    otherwise. If no reference bed is provided, the provided bed files will be\n    merged into a single bed and compared to that.\n\n    Parameters\n    ----------\n    beds : list\n        List of paths to bed files or BedTool objects.\n\n    ref : str or BedTool\n        Reference bed file to compare against. If no reference bed is provided,\n        the provided bed files will be merged into a single bed and compared to\n        that.\n\n    beds_sorted : boolean\n        Whether the bed files in beds are already sorted. If False, all bed\n        files in beds will be sorted.\n\n    ref_sorted : boolean\n        Whether the reference bed file is sorted. If False, ref will be sorted.\n\n    names : list of strings\n        Names to use for columns of output files. Overrides define_sample_name \n        if provided.\n\n    define_sample_name : function that takes string as input\n        Function mapping filename to sample name (or basename). For instance,\n        you may have the basename in the path and use a regex to extract it.\n        The basenames will be used as the column names. If this is not provided,\n        the columns will be named as the input files.\n\n    Returns\n    -------\n    out : pandas.DataFrame\n        Boolean data frame indicating whether each bed file has an interval\n        that overlaps each interval in the reference bed file. \n\n    \"\"\"\n    beds = copy.deepcopy(beds)\n    fns = []\n    for i,v in enumerate(beds):\n        if type(v) == str:\n            fns.append(v)\n            beds[i] = pbt.BedTool(v)\n        else:\n            fns.append(v.fn)\n        if not beds_sorted:\n            beds[i] = beds[i].sort()\n\n    names = _sample_names(fns, kwargs)\n    if ref:\n        if type(ref) == str:\n            ref = pbt.BedTool(ref)\n        if not ref_sorted:\n            ref = ref.sort()\n    else:\n        ref = combine(beds)\n    \n    ind = []\n    for r in ref:\n        ind.append('{}:{}-{}'.format(r.chrom, r.start, r.stop))\n    bdf = pd.DataFrame(0, index=ind, columns=names)\n    for i,bed in enumerate(beds):\n        res = ref.intersect(bed, sorted=True, wa=True)\n        ind = []\n        for r in res:\n            ind.append('{}:{}-{}'.format(r.chrom,\n                                         r.start,\n                                         r.stop))\n        bdf.ix[ind, names[i]] = 1\n    return bdf", "response": "Takes a list of bed files or BedTool objects and compares them to a single BedTool object and returns a pandas. DataFrame containing the boolean values of each element in the output file."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef combine(beds, beds_sorted=False, postmerge=True):\n    beds = copy.deepcopy(beds)\n    for i,v in enumerate(beds):\n        if type(v) == str:\n            beds[i] = pbt.BedTool(v)\n        if not beds_sorted:\n            beds[i] = beds[i].sort()\n\n    # For some reason, doing the merging in the reduce statement doesn't work. I\n    # think this might be a pybedtools bug. In any fashion, I can merge\n    # afterward although I think it makes a performance hit because the combined\n    # bed file grows larger than it needs to.\n    out = reduce(lambda x,y : x.cat(y, postmerge=False), beds)\n    out = out.sort()\n    if postmerge:\n        out = out.merge()\n    return out", "response": "Combine a list of bed files or BedTool objects into a single sorted BedTool object."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreading a bed file and write a copy with a trackline. Here s a simple trackline example", "response": "def write_bed_with_trackline(bed, out, trackline, add_chr=False):\n    \"\"\"\n    Read a bed file and write a copy with a trackline. Here's a simple trackline\n    example: 'track type=bed name=\"cool\" description=\"A cool track.\"'\n\n    Parameters\n    ----------\n    bed : str \n        Input bed file name.\n    out : str\n        Output bed file name.\n    trackline : str\n        UCSC trackline.\n    add_chr : boolean\n        Add 'chr' to the chromosomes in the input file. Necessary for\n        UCSC genome browser if not present.\n\n    \"\"\"\n    df = pd.read_table(bed, index_col=None, header=None)\n    bt = pbt.BedTool('\\n'.join(df.apply(lambda x: '\\t'.join(x.astype(str)), \n                                        axis=1)) + '\\n',\n                     from_string=True)\n    if add_chr:\n        bt = add_chr_to_contig(bt)\n    bt = bt.saveas(out, trackline=trackline)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef strip_chr(bt):\n    try:\n        df = pd.read_table(bt.fn, header=None, dtype=str)\n    # If the try fails, I assume that's because the file has a trackline. Note\n    # that I don't preserve the trackline (I'm not sure how pybedtools keeps\n    # track of it anyway).\n    except pd.parser.CParserError:\n        df = pd.read_table(bt.fn, header=None, skiprows=1, dtype=str)\n    df[0] = df[0].apply(lambda x: x[3:])\n    s = '\\n'.join(df.astype(str).apply(lambda x: '\\t'.join(x), axis=1)) + '\\n'\n    out = pbt.BedTool(s, from_string=True)\n    return out", "response": "Strip chr from chromosomes for BedTool object."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef intervals_to_bed(intervals):\n    import re\n    strand = re.compile('(.*):(.*)-(.*):(\\+|-)')\n    no_strand = re.compile('(.*):(.*)-(.*)')\n    bed_lines = []\n    s = False\n    for i in intervals:\n        m = strand.match(i)\n        if m:\n            bed_lines.append('\\t'.join([m.group(x) for x in range(1, 5)]))\n        else:\n            m = no_strand.match(i)\n            if m:\n                bed_lines.append('\\t'.join([m.group(x) for x in range(1, 4)]))\n    bt = pbt.BedTool('\\n'.join(bed_lines) + '\\n', from_string=True)\n    return bt", "response": "Converts list of intervals of format chr1 - 100 - 200 or chr1 - 200 + to \n    BedTool object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nload the BedTool objects from the file system.", "response": "def load_saved_bts(self):\n        \"\"\"If the AnnotatedInteractions object was saved to a pickle and\n        reloaded, this method remakes the BedTool objects.\"\"\"\n        if self._bt1_path:\n            self.bt1 = pbt.BedTool(self._bt1_path)\n        if self._bt2_path:\n            self.bt2 = pbt.BedTool(self._bt2_path)\n        if self._bt_loop_path:\n            self.bt_loop = pbt.BedTool(self._bt_loop_path)\n        if self._bt_loop_inner_path:\n            self.bt_loop_inner = pbt.BedTool(self._bt_loop_inner_path)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsaving AnnotatedInteractions object and bed files.", "response": "def save(\n        self,\n        path,\n        name,\n    ):\n        \"\"\"\n        Save AnnotatedInteractions object and bed files. The object is stored in\n        a pickle and the bed files are saved as separate bed files. The object\n        can be reloaded by reading the pickle using cPickle and the BedTool\n        objects can be recreated using .load_saved_bts().\n            \n        Parameters\n        ----------\n        path : str\n            Path to save files to. Path should include a basename for the files.\n            For instance, path='~/abc' will create files like ~/abc.pickle,\n            ~/abc_anchor1.bed, etc.\n            \n        name : str\n            Descriptive name used for bed file trackline.\n        \"\"\"\n        t = 'track type=bed name=\"{}_anchor1\"'.format(name)\n        self.bt1.saveas(path + '_anchor1.bed', trackline=t)\n        self._bt1_path = path + '_anchor1.bed'\n        t = 'track type=bed name=\"{}_anchor2\"'.format(name)\n        self.bt2.saveas(path + '_anchor2.bed', trackline=t)\n        self._bt2_path = path + '_anchor2.bed'\n        t = 'track type=bed name=\"{}_loop\"'.format(name)\n        self.bt_loop.saveas(path + '_loop.bed', trackline=t)\n        self._bt_loop_path = path + '_loop.bed'\n        t = 'track type=bed name=\"{}_loop_inner\"'.format(name)\n        self.bt_loop_inner.saveas(path + '_loop_inner.bed', trackline=t)\n        self._bt_loop_inner_path = path + '_loop_inner.bed'\n        import cPickle\n        cPickle.dump(self, open(path + '.pickle', 'w'))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef annotate_bed(\n        self,\n        bt,\n        name,\n        col_name,\n        complete=None,\n        df_col=None,\n    ):\n        \"\"\"\n        Annotate the input bed file using one of the annotation beds.\n        Parameters\n        ----------\n        bt : pybedtools.BedTool\n            BedTool for either one of the anchors, the loops,\n            or the loop inners.\n        \n        name : str\n            The key for the annoation bed file in annot_beds. \n        \n        col_name : str\n            Used to name the columns that will be made.\n            \n        complete : bool\n            If True, this method will check whether the features in the\n            annotation bed are completely contained by the features in the input\n            bed.\n            \n        df_col : str\n            If the name for bt isn't the index of self.df, this specifies\n            which column of self.df contains the names for bt. For instance,\n            if bt is the anchor1 BedTool, the df_col='anchor11'.\n        \n        \"\"\"\n        import numpy as np\n        import pandas as pd\n        has_name_col = len(self.annot_beds[name][0].fields) > 3\n        print('one')\n        if complete:\n            res = bt.intersect(self.annot_beds[name], sorted=True, wo=True, F=1)\n        else:\n            res = bt.intersect(self.annot_beds[name], sorted=True, wo=True)\n        print('two')\n        try:\n            df = res.to_dataframe(names=range(len(res[0].fields)))\n            ind = df[3].values\n            if df_col is None:\n                self.df[col_name] = False\n                self.df.ix[set(ind), col_name] = True\n            else:\n                tdf = pd.DataFrame(True, index=ind, columns=[col_name])\n                self.df = self.df.merge(tdf, left_on=df_col, right_index=True,\n                                        how='outer')\n                self.df[col_name] = self.df[col_name].fillna(False)\n                #self.df.ix[self.df[col_name].isnull(), col_name] = False\n            print('a')\n            if has_name_col:\n                vals = df[7].values\n            else:\n                vals = list(df[4].astype(str) + ':' +\n                            df[5].astype(str) + '-' +\n                            df[6].astype(str))\n            print('b')\n            df.index = vals\n            gb = df.groupby(3)\n            t = pd.Series(gb.groups)\n            print('c')\n            t = pd.DataFrame(t.apply(lambda x: set(x)))\n            print('d')\n            t.columns = ['{}_features'.format(col_name)]\n            self.df = self.df.merge(t, left_on=df_col, right_index=True,\n                                    how='outer')\n            print('e')\n        except IndexError:\n            pass", "response": "This method is used to annotate the input BedTool with another BedTool and add the features to the DataFrame."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get1Dcut(cam: List[Cam], odir: Path=None, verbose: bool=False) -> List[Cam]:\n\n# %% determine slant range between other camera and magnetic zenith to evaluate at\n    # 4.5 had zero discards for hst0 #6.8 didn't quite get to zenith\n    srpts = logspace(4.3, 6.9, 25)\n# %% (i) load az/el data from Astrometry.net\n    for C in cam:\n        if C.usecam:\n            C.doorient()\n            C.toecef(srpts)\n\n    # optional: plot ECEF of points between each camera and magnetic zenith (lying at az,el relative to each camera)\n    if verbose:\n        plotLOSecef(cam, odir)\n# %% (2) get az,el of these points from camera to the other camera's points\n    cam[0].az2pts, cam[0].el2pts, cam[0].r2pts = ecef2aer(cam[1].x2mz, cam[1].y2mz, cam[1].z2mz,\n                                                          cam[0].lat, cam[0].lon, cam[0].alt_m)\n    cam[1].az2pts, cam[1].el2pts, cam[1].r2pts = ecef2aer(cam[0].x2mz, cam[0].y2mz, cam[0].z2mz,\n                                                          cam[1].lat, cam[1].lon, cam[1].alt_m)\n# %% (3) find indices corresponding to these az,el in each image\n    # and Least squares fit line to nearest points found in step 3\n    for C in cam:\n        if C.usecam:\n            C.findClosestAzel(odir)\n# %%\n    if verbose and odir:\n        dbgfn = odir / 'debugLSQ.h5'\n        print('writing', dbgfn)\n        with h5py.File(dbgfn, 'w') as f:\n            for C in cam:\n                f[f'/cam{C.name}/cutrow'] = C.cutrow\n                f[f'/cam{C.name}/cutcol'] = C.cutcol\n                f['/cam{C.name}/xpix'] = C.xpix\n    return cam", "response": "get 1Dcut for one camera"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding a hit to the file.", "response": "def add_hit(self, hit):\n        \"\"\"Add a hit to the file.\"\"\"\n        if not self._csv:\n            raise 'Open before write'\n        self._csv.writerow(hit)\n        self.number_of_hits += 1\n        # Todo: check performance for timestamp check\n        # assert self._path == self.get_filename_by_timestamp(timestamp)\n        timestamp = hit['timestamp']\n        if self.latest_timestamp <= timestamp:\n            self.latest_timestamp = timestamp"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_records(self):\n        self.close()\n        with open(self.path, 'r') as filep:\n            first_line = filep.readline().split(',')\n            if first_line[0] != self.fields[0]:\n                yield first_line\n\n            for line in filep:\n                yield line.split(',')", "response": "Get all stored records."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadds a user to the file.", "response": "def add_user(self, uid, nodes, weights):\n        \"\"\"Add a user.\"\"\"\n        for i, node in enumerate(nodes):\n            self.file.write(\"{},{},{}\\n\".format(uid, node, weights[i]))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset a key value pair.", "response": "def set(self, key, value):\n        \"\"\"Set a key, value pair.\"\"\"\n        key = \"{0}{1}\".format(self.prefix, key)\n\n        value = json.dumps(value, cls=NumpyEncoder)\n        self.redis.set(key, value)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the cache file to a given timestamp.", "response": "def get_by_timestamp(self, prefix, timestamp):\n        \"\"\"Get the cache file to a given timestamp.\"\"\"\n        year, week = get_year_week(timestamp)\n        return self.get(prefix, year, week)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get(self, prefix, year, week):\n        filename = self._format_filename(prefix, year, week)\n        return RawEvents(filename, prefix, year, week)", "response": "Get the cache file."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget the user profiles from the cache to the given prefix.", "response": "def get_user_profiles(self, prefix):\n        \"\"\"Get the user profil from the cache to the given prefix.\"\"\"\n        filepath = \"{}{}\".format(self.base_path, prefix)\n        return UserProfiles(filepath, prefix)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _format_filename(self, prefix, year, week):\n        return \"{}{}_{}-{}.csv\".format(self.base_path, prefix, year, week)", "response": "Construct the file name based on the path and options."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the configured recommendation store.", "response": "def get_recommendation_store(self):\n        \"\"\"Get the configured recommendation store.\"\"\"\n        return RedisStore(self.config['host'],\n                          self.config['port'],\n                          self.config['db'],\n                          self.config['prefix'])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef GetStatus(self,directory,files=None,service=None):\n        logger.debug(\"GetStatus dir=%s\" %(directory))\n\n        db=self._loadDB(directory)\n\n        # Get file stats\n        filedict=self._findFiles(directory,files)\n\n        logger.debug(\"Found %d files in dir\"%(len(filedict.keys())))\n        logger.debug(\"DB has %d files\"%(len(db.keys())))\n\n        # Now go through each file and see if in dictionary, compare mtimes\n        keys=filedict.keys()\n        keys.sort()\n        for fn in keys:\n            if fn in db:\n                filedict[fn]['status']=self._computeStatus(db[fn],service)\n                # Only Set the modify flag if the current\n                # file was actually synched in the first place\n                if filedict[fn]['mtime'] > db[fn]['mtime']:\n                    # Compute a new hash\n                    newhash=self._hashfile(os.path.join(directory,fn))\n                    for srv in db[fn]['services']:\n                        if db[fn]['services'][srv]['status']\\\n                                ==self.ST_UPTODATE:\n                            # Only if the hash changed do we update\n                            if newhash!=db[fn]['hash']:\n                                filedict[fn]['status']=self.ST_MODIFIED\n                                db[fn]['services'][srv]['status']\\\n                                        =self.ST_MODIFIED\n                            else:\n                                # Hash didn't change, let's update the mtime\n                                # so we don't have to hash again\n                                db[fn]['mtime']=filedict[fn]['mtime']\n                                self._saveDB(directory,db)\n                # Recompute since status might have changed\n                filedict[fn]['status']=self._computeStatus(db[fn],service)\n            else:\n                filedict[fn]['status']=self.ST_UNTRACKED\n\n\n        return filedict,db", "response": "Get status of all files in directory and return a dictionary of status and status of all files in directory."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _computeStatus(self, dfile, service):\n\n        # If only one service requested\n        if service:\n            if not dfile['services'].has_key(service):\n                return self.ST_UNTRACKED\n            else:\n                return dfile['services'][service]['status']\n\n        # Otherwise go through all services and compute\n        # a sensible status\n        first_service_key=dfile['services'].keys()[0]\n\n        # Save off one of the statuses so we can compute\n        # if they are all the same between services.\n        first_status=dfile['services'][first_service_key]['status']\n\n        all_status_match=True\n\n        # Return ST_COMPLICATED \"C\" if status\n        # differs\n        for service in dfile['services']:\n            if dfile['services'][service]['status']!=first_status:\n                return self.ST_COMPLICATED\n\n        return first_status", "response": "Computes the status of the file based on the status of the given service."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ngive a list of files in a certain directory and a status update the status of the files in the given directory.", "response": "def UpdateStatus(self,directory,files,status,service):\n        \"\"\"Given a list of files in a certain directory,\n        updates to the given status\n        If status is ST_UPTODATE, and no files given\n        will go through current DB and push files\n        with the \"A\" flag\n        service: If none, assumes all services, looks for matching service\n        \"\"\"\n\n        # First get a list of all files in dir\n        # as well as current status\n        dfiles,db=self.GetStatus(directory,files)\n\n        # If no file list given and asked to \n        # bring files up to date, go through files in DB\n        # with \"A\" or M status\n        if not files and status==self.ST_UPTODATE:\n            files=[]\n            logger.debug('No files given, finding all that needs uploading')\n            for fn in dfiles:\n                if dfiles[fn]['status']==self.ST_ADDED\\\n                        or dfiles[fn]['status']==self.ST_MODIFIED\\\n                        or dfiles[fn]['status']==self.ST_COMPLICATED\\\n                        or dfiles[fn]['status']==self.ST_DELETED:\n                    files.append(fn)\n                    logger.debug('Adding %s to list with status %s'\\\n                            %(fn,dfiles[fn]['status']))\n\n        # Go through list of files given, see if they\n        # actually exist\n        files_that_exist=[]\n        for fn in files:\n            if fn in dfiles:\n                files_that_exist.append(fn)\n            else:\n                logger.debug(\"%s - Skipping, does not exist\"%(fn))\n\n        files_that_exist.sort()\n\n        # FIXME: This is bad, but flickr needs to upload\n        # media files first, then meta data files. Here\n        # we ensure this happens\n        if service is None or service is 'flickr':\n            sobj=self.sman.GetServiceObj('flickr')\n            files_hack_media=[]\n            files_hack_config=[]\n            files_hack_other=[]\n            for filename in files_that_exist:\n                if sobj._isMediaFile(filename):\n                    files_hack_media.append(filename)\n                elif sobj._isConfigFile(filename):\n                    files_hack_config.append(filename)\n                else:\n                    files_hack_other.append(filename)\n\n\n            #Now organize as we'd like it, media first, then config, then others\n            files_that_exist=[]\n            files_that_exist.append(files_hack_media)\n            files_that_exist.append(files_hack_config)\n            files_that_exist.append(files_hack_other)\n            # Flatten list\n            files_that_exist=list(chain.from_iterable(files_that_exist))\n\n        for fn in files_that_exist:\n            if status==self.ST_ADDED:\n                self._updateToAdded(directory,fn,dfiles[fn],db,service)\n            elif status==self.ST_UPTODATE:\n                if not db.has_key(fn):\n                    print(\"%s - Not in db, did you do an 'add' first?\"%(fn))\n                    continue\n                if service:\n                    servicelist=[service]\n                else:\n                    servicelist=db[fn]['services'].keys()\n\n                for sn in servicelist:\n                    if not db[fn]['services'].has_key(sn):\n                        print(\"%s - Service [%s] unknown, skipping\"\\\n                                %(fn,sn))\n                        continue\n                    # If push request and file is marked for\n                    # deletion, delete it rather from remote\n                    if db[fn]['services'][sn]['status']==self.ST_DELETED:\n                        self._deleteFile(directory,fn,dfiles[fn],db,sn)\n                    else:\n                        self._uploadFile(directory,fn,dfiles[fn],db,sn)\n\n            elif status==self.ST_DELETED:\n                self._updateToDeleted(directory,fn,dfiles[fn],db,service)\n            # Save for every upload, so we can easily resume\n            self._saveDB(directory,db)\n\n        # Always save when status is updated\n        self._saveDB(directory,db)\n\n        # Now print out updated status\n        self.PrintStatus(directory,files)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _deleteFile(self,directory,fn,dentry,db,service):\n        # FIXME : can switch back to only managing once service\n        # at a time\n        logger.debug(\"%s - Deleting\"%(fn))\n\n        if fn not in db:\n            print(\"%s - rm: Not in DB, can't remove !\"%(fn))\n            return False\n\n        # Build up list of names\n        servicenames=db[fn]['services'].keys()\n        # If service is none, build list of all services\n        # to perform this action on\n        if service is None:\n            servicelist=servicenames\n        else:\n            servicelist=[service]\n\n        for service in servicelist:\n            if not db[fn]['services'].has_key(service):\n                print(\"%s - Can't delete, service [%s] unknown\"%(service))\n                continue\n\n            if db[fn]['services'][service]['status']!=self.ST_DELETED:\n                print(\"%s - rm: Can't remove file with non 'D' status (%s)!\"\\\n                        %(fn,service))\n                continue\n\n            # Only change status if correctly deleted\n            if self.sman.GetServiceObj(service).Remove(directory,fn):\n                # Delete our service entry\n                del db[fn]['services'][service]\n                logger.debug('%s - deleted by service: %s'%(fn,service))\n            else:\n                logger.error('%s - Failed to delete by service: %s'%(fn,service))\n                continue\n\n        # Delete whole entry if no services manage it any more\n        if len(db[fn]['services'].keys())==0:\n            del db[fn]\n\n        return True", "response": "Delete a file from the database and changes status to '?' if no more services manages the file"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nuploading a file and changes status to S.", "response": "def _uploadFile(self,directory,fn,dentry,db,service):\n        \"\"\"Uploads file and changes status to 'S'. Looks\n        up service name with service string\n        \"\"\"\n        # Create a hash of the file\n        if fn not in db:\n            print(\"%s - Not in DB, must run 'add' first!\"%(fn))\n        else:\n            # If already added, see if it's modified, only then\n            # do another upload\n            if db[fn]['services'][service]['status']==self.ST_UPTODATE:\n                if not dentry['status']==self.ST_MODIFIED:\n                    logger.info(\"%s - Up to date, skipping (%s)!\"\\\n                            %(fn,service))\n                    return False\n\n            sobj=self.sman.GetServiceObj(service)\n            # If nobody manages this file, just skip it\n            if (not sobj):\n                print(\"%s - Upload: No service of name [%s] found\"%(fn,service))\n                return\n            # Only change status if correctly uploaded\n            if sobj.Upload(directory,fn):\n                # Write newest mtime/hash to indicate all is well\n                db[fn]['mtime']=dentry['mtime']\n                db[fn]['hash']=self._hashfile(os.path.join(directory,fn))\n                db[fn]['services'][service]['status']=self.ST_UPTODATE\n                logger.debug('%s - uploaded by service: %s'%(fn,sobj.GetName()))\n                return True\n            else:\n                logger.error('%s - Failed to upload by service: %s'%(fn,sobj.GetName()))\n                return False\n\n\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _updateToDeleted(self,directory,fn,dentry,db,service):\n        # Create a hash of the file\n        if fn not in db:\n            print(\"%s - rm: not in DB, skipping!\"%(fn))\n            return\n\n        services=self.sman.GetServices(fn)\n        # If nobody manages this file, just skip it\n        if (not services):\n            print(\"%s - no manger of this file type found\"%(fn))\n            return\n\n        if service:\n            if db[fn]['services'].has_key(service):\n                db[fn]['services'][service]['status']=self.ST_DELETED\n            else:\n                print(\"%s - Service %s doesn't exist, can't delete\"%(fn,service))\n\n            return\n\n        # If we get here it means all services should delete\n        for service in db[fn]['services']:\n            db[fn]['services'][service]['status']=self.ST_DELETED\n\n        return", "response": "Updates status to D if a handler exists and the file has not been deleted"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nupdates status to A if a file is added to the pusher DB.", "response": "def _updateToAdded(self,directory,fn,dentry,db,service):\n        \"\"\"Changes to status to 'A' as long as a handler exists,\n        also generates a hash\n        directory - DIR where stuff is happening\n        fn - File name to be added\n        dentry - dictionary entry as returned by GetStatus for this file\n        db - pusher DB for this directory\n        service - None means all services, otherwise looks for service\n        \"\"\"\n        services=self.sman.GetServices(fn)\n\n        # If nobody manages this file, just skip it\n        if services is None:\n            print(\"%s - No services handle this file\" %(fn))\n            return\n\n        # Build up list of names\n        servicenames=[]\n        for s in services:\n            servicenames.append(s.GetName())\n\n        if service is not None and service not in servicenames:\n            print(\"%s - Requested service (%s) not available for this file\"\\\n                    %(fn,service))\n            return\n\n        # If service is none, build list of all services\n        # to perform this action on\n        if service is None:\n            servicelist=servicenames\n        else:\n            servicelist=[service]\n\n        if not db.has_key(fn):\n            # Since this is a new entry, populate with stuff\n            # we got from GetSatus for this file (usually mtime)\n            db[fn]=dentry\n            del db[fn]['status'] # Delete this key we're not using\n            db[fn]['services']={} # Empty dictionary of services\n                                  # that manages this file + status\n\n        # Now add the hash\n        db[fn]['hash']=self._hashfile(os.path.join(directory,fn))\n\n        # Now run through services and see if we should\n        # perform actions\n        for service in servicelist:\n            if not db[fn]['services'].has_key(service):\n                db[fn]['services'][service]={}\n                db[fn]['services'][service]['status']=self.ST_ADDED\n            else:\n                print(\"%s - Already managed by service %s, maybe do a 'push'?\"\\\n                        %(fn,service))\n\n        logger.info('%s - managers: %s'%(fn,db[fn]['services'].keys()))\n\n        return"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _hashfile(self,filename,blocksize=65536):\n        logger.debug(\"Hashing file %s\"%(filename))\n        hasher=hashlib.sha256()\n        afile=open(filename,'rb')\n        buf=afile.read(blocksize)\n        while len(buf) > 0:\n            hasher.update(buf)\n            buf = afile.read(blocksize)\n        return hasher.hexdigest()", "response": "Hashes the file and returns hash"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _findFiles(self,pushdir,files=None):\n        \n        #If no file list given, go through all\n        if not files:\n            files=os.listdir(pushdir)\n\n        dfiles={}\n        for fn in files:\n            # Skip . files\n            if fn[0]=='.':\n                continue\n            fullfile=os.path.join(pushdir,fn)\n            d={}\n            d['mtime']=os.path.getmtime(fullfile)\n            dfiles[fn]=d\n\n        return dfiles", "response": "Find all files and return dict where key is filename\n           ['mtime'] = modification time\n           ['mtime']"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a storage instance for the current instance of the class.", "response": "def storage(self):\n        \"\"\"\n        Instantiates and returns a storage instance\n        \"\"\"\n        if self.backend == 'redis':\n            return RedisBackend(self.prefix, self.secondary_indexes)\n        if self.backend == 'dynamodb':\n            return DynamoDBBackend(self.prefix, self.key, self.sort_key,\n                                   self.secondary_indexes)\n        return DictBackend(self.prefix, self.secondary_indexes)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget nested value using dot separated keys", "response": "def get_property(self, prop):\n        \"\"\"Access nested value using dot separated keys\n\n        Args:\n            prop (:obj:`str`): Property in the form of dot separated keys\n\n        Returns:\n            Property value if exists, else `None`\n        \"\"\"\n        prop = prop.split('.')\n        root = self\n        for p in prop:\n            if p in root:\n                root = root[p]\n            else:\n                return None\n        return root"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef from_dict(cls, val):\n        if isinstance(val, dict2):\n            return val\n\n        elif isinstance(val, dict):\n            res = cls()\n            for k, v in val.items():\n                res[k] = cls.from_dict(v)\n            return res\n\n        elif isinstance(val, list):\n            res = []\n            for item in val:\n                res.append(cls.from_dict(item))\n            return res\n        else:\n            return val", "response": "Creates dict2 object from dict object."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate dict object from dict2 object", "response": "def to_dict(self, val=UNSET):\n        \"\"\"Creates dict object from dict2 object\n\n        Args:\n            val (:obj:`dict2`): Value to create from\n\n        Returns:\n            Equivalent dict object.\n        \"\"\"\n        if val is UNSET:\n            val = self\n\n        if isinstance(val, dict2) or isinstance(val, dict):\n            res = dict()\n            for k, v in val.items():\n                res[k] = self.to_dict(v)\n            return res\n        elif isinstance(val, list):\n            res = []\n            for item in val:\n                res.append(self.to_dict(item))\n            return res\n        else:\n            return val"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef Scroll_up(self, n, dl = 0):\n        self.Delay(dl)\n        self.mouse.scroll(vertical = n)", "response": "Scroll up n times."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef Scroll_down(self, n, dl = 0):\n        self.Delay(dl)\n        self.mouse.scroll(vertical = -n)", "response": "Scroll down n times."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef Move_to(self, x, y, dl = 0):\n        self.Delay(dl)\n        self.mouse.move(x, y)", "response": "move to x y"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndrag and release the mouse.", "response": "def Drag_and_release(self, start, end, dl = 0):\n        \"\"\"\u4ecestart\u7684\u5750\u6807\u5904\u9f20\u6807\u5de6\u952e\u5355\u51fb\u62d6\u66f3\u5230end\u7684\u5750\u6807\u5904\n        start, end\u662ftuple. \u683c\u5f0f\u662f(x, y)\n        \"\"\"\n        self.Delay(dl)\n        self.mouse.press(start[0], start[1], 1)\n        self.mouse.drag(end[0], end[1])\n        self.Delay(0.1)\n        self.mouse.release(end[0], end[1], 1)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef Ctrl_c(self, dl = 0):\n        self.Delay(dl)\n        self.keyboard.press_key(self.keyboard.control_key)\n        self.keyboard.tap_key(\"c\")\n        self.keyboard.release_key(self.keyboard.control_key)", "response": "Ctrl + c \u590d\u5236"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef Up(self, n = 1, dl = 0):\n        self.Delay(dl)\n        self.keyboard.tap_key(self.keyboard.up_key, n)", "response": "Up key n \u6b21"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef Left(self, n = 1, dl = 0):\n        self.Delay(dl)\n        self.keyboard.tap_key(self.keyboard.left_key, n)", "response": "Left key n \u6b21"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef Right(self, n = 1, dl = 0):\n        self.Delay(dl)\n        self.keyboard.tap_key(self.keyboard.right_key, n)", "response": "tap right key n times"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef Enter(self, n = 1, dl = 0):\n        self.Delay(dl)\n        self.keyboard.tap_key(self.keyboard.enter_key, n)", "response": "Enter key n times."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef Back(self, n = 1, dl = 0):\n        self.Delay(dl)\n        self.keyboard.tap_key(self.keyboard.backspace_key, n)", "response": "Press backspace key n times."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\npresses a key n times.", "response": "def Space(self, n = 1, dl = 0):\n        \"\"\"\u7a7a\u683c\u952en\u6b21\n        \"\"\"\n        self.Delay(dl)\n        self.keyboard.tap_key(\" \", n)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef main():\n    \"Process CLI arguments and call appropriate functions.\"\n    try:\n        args = docopt.docopt(__doc__, version=__about__.__version__)\n    except docopt.DocoptExit:\n        if len(sys.argv) > 1:\n            print(f\"{Fore.RED}Invalid command syntax, \"\n                  f\"check help:{Fore.RESET}\\n\")\n        print(__doc__)\n        sys.exit(1)\n\n    print_all = False\n    if not (args[\"--int-width\"] or args[\"--int-height\"] or args[\"--decimal\"]):\n        print_all = True\n\n    width    = float(args[\"WIDTH\"])\n    height   = float(args[\"HEIGHT\"])\n\n    as_int_   = as_int(width, height)\n    as_float_ = as_float(width, height)\n\n    if args[\"--ndigits\"]:\n        as_float_ = round(as_float_, int(args[\"--ndigits\"]))\n\n    to_print = []\n\n    if args[\"--int-width\"] or print_all:\n        to_print.append(f\"{Fore.BLUE}{as_int_[0]!s}\")\n\n    if args[\"--int-height\"] or print_all:\n        to_print.append(f\"{Fore.BLUE}{as_int_[1]!s}\")\n\n    if args[\"--decimal\"] or print_all:\n        to_print.append(f\"{Fore.MAGENTA}{as_float_!s}\")\n\n    print(\" \".join(to_print))", "response": "Process CLI arguments and call appropriate functions."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_all(slug=None):\n    if slug is None:\n        q = Product.objects.published()\n    else:\n        q = Product.objects.published().filter(sections__slug=slug)\n\n    if getattr(settings, 'MIDNIGHT_CATALOG_PREFETCH_PARAMS', False):\n        q = q.prefetch_related(Prefetch(\"paramvalue_set\", queryset=ParamValue.objects.published().order_by('sort').prefetch_related(\"param\")))\n\n    q = q.prefetch_related('sections').order_by('sort', '-id')\n\n    return q.all()", "response": "Returns all Products with the given slug."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_one(slug):\n    item = Product.objects.published()\\\n        .prefetch_related(Prefetch(\"paramvalue_set\", queryset=ParamValue.objects.published().order_by('sort').prefetch_related(\"param\")))\\\n        .filter(slug=slug).first()\n    return item", "response": "Get one product from queryset"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef start(self):\n        if self.start_time is None:\n            time = datetime.time(hour=19, tzinfo=CET)\n        else:\n            time = self.start_time.replace(tzinfo=CET)\n        return datetime.datetime.combine(self.date, time)", "response": "The start time of the event as a timezone - aware datetime object"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef next_occurrences(self, n=None, since=None):\n        scheme = self.recurrence_scheme\n        if scheme is None:\n            return ()\n\n        db = Session.object_session(self)\n        query = db.query(Event)\n        query = query.filter(Event.series_slug == self.slug)\n        query = query.order_by(desc(Event.date))\n        query = query.limit(1)\n        last_planned_event = query.one_or_none()\n\n        if since is None:\n            last_planned_event = query.one()\n            since = last_planned_event.date\n        elif since < last_planned_event.date:\n            since = last_planned_event.date\n\n        start = getattr(since, 'date', since)\n\n        start += relativedelta.relativedelta(days=+1)\n\n        if (scheme == 'monthly'\n                and last_planned_event\n                and last_planned_event.date.year == start.year\n                and last_planned_event.date.month == start.month):\n            # Monthly events try to have one event per month, so exclude\n            # the current month if there was already a meetup\n            start += relativedelta.relativedelta(months=+1)\n            start = start.replace(day=1)\n\n        start = datetime.datetime.combine(start, datetime.time(tzinfo=CET))\n        result = rrule.rrulestr(self.recurrence_rule, dtstart=start)\n        if n is not None:\n            result = itertools.islice(result, n)\n        return result", "response": "Yield the next n planned occurrences after the date since."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsearch for the possible set of resources for a given entry.", "response": "def search(self, q, **kwargs):\n        \"\"\"\n        You can pass in any of the Summon Search API parameters \n        (without the \"s.\" prefix). For example to remove highlighting:\n\n            result = api.search(\"Web\", hl=False)\n\n        See the Summon API documentation for the full list of possible\n        parameters:\n\n        http://api.summon.serialssolutions.com/help/api/search/parameters\n        \"\"\"\n        params = {\"s.q\": q}\n        for k, v in kwargs.items():\n            params[\"s.\" + k] = v\n        r = self._get(\"/2.0.0/search\", params)\n        return r"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncarries out the upgrade.", "response": "def do_upgrade():\n    \"\"\"Carry out the upgrade.\"\"\"\n    op.alter_column(\n        table_name='knwKBRVAL',\n        column_name='id_knwKB',\n        type_=db.MediumInteger(8, unsigned=True),\n        existing_nullable=False,\n        existing_server_default='0'\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef spark_string(ints):\n    ticks = u'\u2581\u2582\u2583\u2585\u2586\u2587'\n    ints = [i for i in ints if type(i) == int]\n    if len(ints) == 0:\n        return \"\"\n    step = (max(ints) / float(len(ticks) - 1)) or 1\n    return u''.join(\n        ticks[int(round(i / step))] if type(i) == int else u'.' for i in ints)", "response": "Returns a spark string from given iterable of ints."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_facts(api_url=None, query='', verify=False, cert=list()):\n    return utils._make_api_request(api_url, '/facts', verify, cert, params={'query': query})", "response": "Returns facts from a base PuppetDB API url"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning facts by name", "response": "def get_facts_by_name(api_url=None, fact_name=None, verify=False, cert=list()):\n    \"\"\"\n    Returns facts by name\n\n    :param api_url: Base PuppetDB API url\n    :param fact_name: Name of fact\n\n    \"\"\"\n    return utils._make_api_request(api_url, '/facts/{0}'.format(fact_name), verify, cert)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_facts_by_name_and_value(api_url=None, fact_name=None, fact_value=None, verify=False, cert=list()):\n    return utils._make_api_request(api_url, '/facts/{0}/{1}'.format(fact_name, fact_value), verify, cert)", "response": "Returns facts by name and value"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef sanitize_config_loglevel(level):\n    '''\n    Kinda sorta backport of loglevel sanitization for Python 2.6.\n    '''\n    if sys.version_info[:2] != (2, 6) or isinstance(level, (int, long)):\n        return level\n    lvl = None\n    if isinstance(level, basestring):\n        lvl = logging._levelNames.get(level)\n    if not lvl:\n        raise ValueError('Invalid log level, %s' % level)\n    return lvl", "response": "Sanitize a log level."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\npolls a total until it returns None.", "response": "def poll_with_timeout(timeout_s, break_func, wake_every_s=60):\n    \"\"\"\n    Calls :attr:`break_func` every :attr:`wake_every_s` seconds for a total\n    duration of :attr:`timeout_s` seconds, or until :attr:`break_func` returns\n    something other than ``None``.\n\n    If :attr:`break_func` returns anything other than ``None``, that value is\n    returned immediately.\n\n    Otherwise, continues polling until the timeout is reached, then returns\n    ``None``.\n\n    \"\"\"\n    time_slept = 0\n    if wake_every_s > 60:\n        msg = '... sleeping for %0.2f minutes' % (wake_every_s / 60.0)\n    else:\n        msg = '... sleeping for %d seconds' % wake_every_s\n    res = break_func()\n    while res is None and time_slept < timeout_s:\n        log.debug(msg)\n        time.sleep(wake_every_s)\n        time_slept += wake_every_s\n        res = break_func()\n    return res"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef redact_secrets(line):\n    def redact(match):\n        if match.group(2) in SECRET_WHITELIST:\n            return match.group(0)\n        return match.group(1) + 'TOO_TOO_SEXY'\n    return SECRET_PATTERN.sub(redact, line)", "response": "Redacts any secret in the given line."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef count_to_deploy(stack, descriptor, config_count):\n    live_count = count_by_tag(stack, descriptor)\n    if config_count > live_count:\n        live_count = config_count\n\n    return live_count", "response": "count_to_deploy takes the max of config_count and number of instances running\n    with this stack and descriptor combo\n   "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the count of currently running or pending instances that match the given stack and deployer combo", "response": "def count_by_tag(stack, descriptor):\n    \"\"\"\n    Returns the count of currently running or pending instances\n    that match the given stack and deployer combo\n    \"\"\"\n    ec2_conn = boto.ec2.connection.EC2Connection()\n    resses = ec2_conn.get_all_instances(\n                    filters={\n                        'tag:stack': stack,\n                        'tag:descriptor': descriptor\n                    })\n    instance_list_raw = list()\n    [[instance_list_raw.append(x) for x in res.instances] for res in resses]\n    instance_list = [x for x in instance_list_raw if state_filter(x)]\n    instances = len(instance_list)\n    return instances"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nperform an *in-place* deep-merge of key-values from :attr:`incoming` into :attr:`base`. No attempt is made to preserve the original state of the objects passed in as arguments. :param dict base: The target container for the merged values. This will be modified *in-place*. :type base: Any :class:`dict`-like object :param dict incoming: The container from which incoming values will be copied. Nested dicts in this will be modified. :type incoming: Any :class:`dict`-like object :rtype: None", "response": "def deep_merge_dicts(base, incoming):\n    \"\"\"\n    Performs an *in-place* deep-merge of key-values from :attr:`incoming`\n    into :attr:`base`.  No attempt is made to preserve the original state of\n    the objects passed in as arguments.\n\n    :param dict base:  The target container for the merged values.  This will\n        be modified *in-place*.\n    :type base:  Any :class:`dict`-like object\n\n    :param dict incoming:  The container from which incoming values will be\n        copied.  Nested dicts in this will be modified.\n    :type incoming:  Any :class:`dict`-like object\n\n    :rtype:  None\n\n    \"\"\"\n    for ki, vi in incoming.iteritems():\n        if (ki in base\n                and isinstance(vi, collections.MutableMapping)\n                and isinstance(base[ki], collections.MutableMapping)\n                ):\n            deep_merge_dicts(base[ki], vi)\n        else:\n            base[ki] = vi"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nfork a command list and returns the output of the remote command.", "response": "def fork_exec(cmd_list, input_data=None):\n    \"\"\"\n    Like the subprocess.check_*() helper functions, but tailored to bang.\n\n    ``cmd_list`` is the command to run, and its arguments as a list of strings.\n\n    ``input_data`` is the optional data to pass to the command's stdin.\n\n    On success, returns the output (i.e. stdout) of the remote command.\n\n    On failure, raises BangError with the command's stderr.\n    \"\"\"\n    # log.debug('fork_exec: cmd_list = %s, input_data = ^%s^' %\n    #         (cmd_list, input_data))\n    p = subprocess.Popen(\n            cmd_list,\n            stdin=subprocess.PIPE,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n            )\n    out = p.communicate(input_data)\n    if p.returncode != 0:\n        raise bang.BangError('ret: %d, stdout: ^%s^, stderr: ^%s^' %\n                (p.returncode, out[0], out[1]))\n    return out[0]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef append(self, list_name, value):\n        with self.lock:\n            l = self.lists.get(list_name)\n            if l:\n                l.append(value)\n            else:\n                l = [value]\n            self.lists[list_name] = l", "response": "Appends value to the list named list_name."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef merge(self, dict_name, values):\n\n        with self.lock:\n            d = self.dicts.get(dict_name)\n            if d:\n                deep_merge_dicts(d, values)\n            else:\n                d = copy.deepcopy(values)\n            self.dicts[dict_name] = d", "response": "Merges the values of the given dict onto the object containing the given name."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd the given name to the namespace if it does not already exist. Returns True on success.", "response": "def add_if_unique(self, name):\n        \"\"\"\n        Returns ``True`` on success.\n\n        Returns ``False`` if the name already exists in the namespace.\n        \"\"\"\n        with self.lock:\n            if name not in self.names:\n                self.names.append(name)\n                return True\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting all the labs from makery. info.", "response": "def get_labs(format):\n    \"\"\"Gets Lab data from makery.info.\"\"\"\n\n    labs_json = data_from_makery_info(makery_info_labs_api_url)\n    labs = {}\n\n    # Load all the FabLabs\n    for i in labs_json[\"labs\"]:\n        current_lab = MakeryLab()\n        current_lab.address_1 = i[\"address_1\"]\n        current_lab.address_2 = i[\"address_2\"]\n        current_lab.address_notes = i[\"address_notes\"]\n        current_lab.avatar = i[\"avatar\"]\n        current_lab.blurb = i[\"blurb\"]\n        current_lab.capabilities = i[\"capabilities\"]\n        current_lab.city = i[\"city\"]\n        current_lab.country_code = i[\"country_code\"]\n        current_lab.county = i[\"county\"]\n        current_lab.description = i[\"description\"]\n        current_lab.email = i[\"email\"]\n        current_lab.header_image_src = i[\"header_image_src\"]\n        current_lab.id = i[\"id\"]\n        current_lab.kind_name = i[\"kind_name\"]\n        # Some labs do not have coordinates\n        if i[\"latitude\"] is None or i[\"longitude\"] is None:\n            address = i[\"address_1\"] + i[\"city\"] + i[\"country_code\"]\n            try:\n                location = geolocator.geocode(address)\n                current_lab.latitude = location.latitude\n                current_lab.longitude = location.longitude\n            except:\n                try:\n                    location = geolocator.geocode(i[\"city\"])\n                    current_lab.latitude = location.latitude\n                    current_lab.longitude = location.longitude\n                except:\n                    # For labs without a city, add 0,0 as coordinates\n                    current_lab.latitude = 0.0\n                    current_lab.longitude = 0.0\n        else:\n            current_lab.latitude = i[\"latitude\"]\n            current_lab.longitude = i[\"longitude\"]\n        current_lab.links = i[\"links\"]\n        current_lab.name = i[\"name\"]\n        current_lab.parent_id = i[\"parent_id\"]\n        current_lab.phone = i[\"phone\"]\n        current_lab.postal_code = i[\"postal_code\"]\n        current_lab.slug = i[\"slug\"]\n        current_lab.url = i[\"url\"]\n        # Add the lab\n        labs[i[\"slug\"]] = current_lab\n\n    # Return a dictiornary / json\n    if format.lower() == \"dict\" or format.lower() == \"json\":\n        output = {}\n        for j in labs:\n            output[j] = labs[j].__dict__\n    # Return a geojson\n    elif format.lower() == \"geojson\" or format.lower() == \"geo\":\n        labs_list = []\n        for l in labs:\n            single = labs[l].__dict__\n            single_lab = Feature(\n                type=\"Feature\",\n                geometry=Point((single[\"latitude\"], single[\"longitude\"])),\n                properties=single)\n            labs_list.append(single_lab)\n        output = dumps(FeatureCollection(labs_list))\n    # Return a Pandas DataFrame\n    elif format.lower() == \"pandas\" or format.lower() == \"dataframe\":\n        output = {}\n        for j in labs_list:\n            output[j] = labs_list[j].__dict__\n        # Transform the dict into a Pandas DataFrame\n        output = pd.DataFrame.from_dict(output)\n        output = output.transpose()\n    # Return an object\n    elif format.lower() == \"object\" or format.lower() == \"obj\":\n        output = labs\n    # Default: return an oject\n    else:\n        output = labs\n    # Return a proper json\n    if format.lower() == \"json\":\n        output = json.dumps(output)\n    return output"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds the given name to the spec.", "response": "def _add_to_spec(self, name):\n        \"\"\"The spec of the mirrored mock object is updated whenever the mirror\n        gains new attributes\"\"\"\n        self._spec.add(name)\n        self._mock.mock_add_spec(list(self._spec), True)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_fp_meta(fp):\n\n    # Copy metadata list then reverse to start at end of path\n    directory_meta = list(DIR_ATTS)\n\n    # Prefer meta extracted from filename\n    meta = get_dir_meta(fp, directory_meta)\n    meta.update(get_fname_meta(fp))\n\n    return meta", "response": "Processes a CMIP3 style file path."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_fname_meta(fp):\n\n    # Strip directory, extension, then split\n    if '/' in fp:\n        fp = os.path.split(fp)[1]\n    fname = os.path.splitext(fp)[0]\n    meta = fname.split('-')\n\n    res = {}\n\n    try:\n        for key in FNAME_ATTS:\n            res[key] = meta.pop(0)\n    except IndexError:\n        raise PathError(fname)\n\n    return res", "response": "Processes a CMIP3 style file name."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef gen_user_agent(version):\n    def monkey_patch():\n        \"\"\"\n        small monkey patch\n        \"\"\"\n        raise IOError\n\n    # saving original functions\n    orig_system = platform.system\n    orig_release = platform.release\n\n    # applying patch\n    platform.system = monkey_patch\n    platform.release = monkey_patch\n\n    user_agent = requests_toolbelt.user_agent('picuplib', version)\n\n    # reverting patch\n    platform.system = orig_system\n    platform.release = orig_release\n\n    return user_agent", "response": "generates a user agent witch will be used for most requests\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef build_url_request(self):\n        params = {}\n        headers = {}\n        self._authenticator(params, headers)\n        self._grant(params)\n        return Request(self._endpoint, urlencode(params), headers)", "response": "Builds a request object that can be sent to the server."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates and sends a request to the OAuth server and decodes the response and returns the resulting token object.", "response": "def send(self, response_decoder=None):\n        \"\"\"\n        Creates and sends a request to the OAuth server, decodes the response\n        and returns the resulting token object.\n\n            response_decoder - A custom callable can be supplied to override\n              the default method of extracting AccessToken parameters from the\n              response. This is necessary for server implementations which do\n              not conform to the more recent OAuth2 specification\n              (ex: Facebook). By default, this will assume the response is\n              encoded using JSON. The callable should return a dictionary with\n              keys and values as follows:\n\n                access_token - The access token\n\n                token_type - The token type\n\n                expires_in - The number of seconds in which the token expires\n\n                refresh_token - The refresh token\n\n                scope - The permission scope (as a space delimited string)\n        \"\"\"\n        decoder = loads\n        if response_decoder is not None and callable(response_decoder):\n            decoder = response_decoder\n\n        request = self.build_url_request()\n        try:\n            f = urlopen(request)\n        except HTTPError as e:\n            try:\n                error_resp = e.read()\n                error_data = loads(error_resp)\n            except Exception:\n                raise AccessTokenResponseError('Access request returned an error, but the response could not be read: %s ' % error_resp)\n\n            if error_data.get('error') is None:\n                raise AccessTokenResponseError('Access request returned an error, but did not include an error code')\n\n            raise AccessTokenRequestError(error_data['error'], error_data.get('error_description'), error_data.get('error_uri'))\n        token_data = decoder(f.read())\n        return self._create_access_token(token_data)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef setup_parser():\n    '''Set up the command-line options.'''\n    parser = argparse.ArgumentParser(description='Add random pages to existing site.')\n    parser.add_argument('-d','--directory', action='store', default= os.getcwd(),\n                                 help='Site directory (must be a valid s2 structure).')\n    parser.add_argument('-n','--number', action='store', type=int, default = 20,\n                                 help='Number of pages to generate.')\n\n    return parser", "response": "Setup the command - line options."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef build_model_code(client):\n    models = {}\n    references = {}\n    for method in client.wsdl.services[0].ports[0].methods.values():\n        if not '_' in method.name:\n            continue\n        model, action = method.name.split('_')\n        models.setdefault(model, {'properties': [], 'filters': []})\n        references[model] = model\n        if model[-1] == 'y':\n            references[model[:-1] + 'ies'] = model\n        else:\n            references[model+'s'] = model\n\n    references['OurReference'] = 'Employee'\n    references['GetYourReference'] = 'DebtorContact'\n    references['GetAttention'] = 'DebtorContact'\n    references['Layout'] = 'TemplateCollection'\n    special = {\n        'Order_GetPdf': {\n            'type': 'EConomicsFileProperty',\n            'args': [\"'Order_GetPdf'\", \"'pdf'\"]\n        },\n        'Invoice_GetPdf': {\n            'type': 'EConomicsFileProperty',\n            'args': [\"'Invoice_GetPdf'\", \"'pdf'\"]\n        },\n        'CurrentInvoice_GetPdf': {\n            'type': 'EConomicsFileProperty',\n            'args': [\"'CurrentInvoice_GetPdf'\", \"'pdf'\"]\n        }\n    }\n    for line in ['Order', 'Invoice', 'CurrentInvoice', 'Quotation']:\n        method = '%s_GetLines' % line\n        special[method] = {\n            'type': 'EConomicsReferenceList',\n            'args': [\"'%sLine'\" % line, \"'%s'\" % method]\n        }\n\n    for method in client.wsdl.services[0].ports[0].methods.values():\n        if not '_' in method.name:\n            continue\n        model, action = method.name.split('_')\n        if action in ['GetData', 'GetAll', 'GetDataArray']:\n            continue\n        modeldata = models[model]\n\n        if action == 'GetAllUpdated':\n            camelname = action[3:]\n            modeldata['filters'].append({'name': pythonize(camelname), 'method': action})\n        if re.findall('GetAll[A-Z].+', action):\n            camelname = action[3:]\n            modeldata['filters'].append({'name': pythonize(camelname), 'method': action})\n        elif action.startswith('FindBy'):\n            camelname = action[6:]\n            modeldata['filters'].append({'name': pythonize(camelname), 'method': action})\n\n        elif action.startswith('Get'):\n            propname = action[3:]\n            pyname = pythonize(propname)\n            if not propname:\n                continue\n            get_type = re.findall('Get(%s)[a-z0-9]*?$' % ('|'.join(references.keys())), action)\n            if get_type and get_type[0] in references:\n                refmodel = references[get_type[0]]\n                if action[-1] == 's':\n                    modeldata['properties'].append({\n                        'type': 'EConomicsReferenceList',\n                        'args': [\"'%s'\" % propname, \"'%s'\" % refmodel,  \"'%s'\" % method.name],\n                        'name': pyname\n                    })\n                else:\n                    modeldata['properties'].append({\n                        'type': 'EConomicsReference',\n                        'args': [\"'%s'\" % propname, \"'%s'\" % refmodel],\n                        'name': pyname\n                    })\n            elif method.name in special:\n                spdata = special[method.name]\n                modeldata['properties'].append({\n                    'type': spdata['type'],\n                    'args': [\"'%s'\" % propname] + spdata['args'],\n                    'name': pyname\n                })\n            else:\n                modeldata['properties'].append({\n                    'type': 'EConomicsProperty',\n                    'args': [\"'%s'\" % propname],\n                    'name': pyname\n                })\n\n    classes = []\n    for modelname, modeldata in models.items():\n\n        propertycode = [\"%s = %s(%s)\" % (md['name'], md['type'], ', '.join(md['args']))\n                        for md in modeldata['properties']]\n        code = \"class %s(%s):\\n    __filters__ = %r\\n    %s\" % (modelname, 'EConomicsModel',\n                                                                modeldata['filters'], '\\n    '.join(propertycode))\n        classes.append(code)\n    return \"from pyconomic.base import *\\n\\n\\n\" + \"\\n\\n\\n\".join(classes)", "response": "Generates source code for e - conomic models based on WSDL connection."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nfinding all the handles for a given model", "response": "def __find_handles(self, model, **spec):\n        \"\"\" find model instances based on given filter (spec)\n        The filter is based on available server-calls, so some values might not be available for filtering.\n        Multiple filter-values is going to do multiple server-calls.\n        For complex filters in small datasets, it might be faster to fetch all and do your own in-memory filter.\n        Empty filter will fetch all.\n\n        :param model: subclass of EConomicsModel\n        :param spec: mapping of values to filter by\n        :return: a list of EConomicsModel instances\n        \"\"\"\n        server_calls = []\n        filter_names = dict([(f['name'], f['method'],) for f in model.get_filters()])\n        if not spec:\n            server_calls.append({'method': \"%s_GetAll\" % model.__name__, 'args': []})\n        else:\n            for key, value in spec.items():\n                if not key in filter_names:\n                    raise ValueError(\"no server-method exists for filtering by '%s'\" % key)\n                args = []\n                if not hasattr(value, '__iter__'):\n                    value = [value]\n\n                if key.endswith('_list'):\n                    vtype = type(value[0]).__name__\n                    # TODO: this surely does not cover all cases of data types\n                    array = self.soap_factory.create('ArrayOf%s' % vtype.capitalize())\n                    getattr(array, \"%s\" % vtype).extend(value)\n                    args.append(array)\n                else:\n                    args.extend(value)\n\n                method = \"%s_%s\" % (model.__name__, filter_names[key])\n                if filter_names[key].startswith('GetAll'):\n                    args = []\n                server_calls.append({'method': method, 'args': args, 'expect': \"%sHandle\" % model.__name__})\n\n        handles = [\n            map(Handle, self.fetch_list(scall['method'], scall.get('expect'), *scall['args']))\n            for scall in server_calls\n        ]\n        return [h.wsdl for h in reduce(set.intersection, map(set, handles))]"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get(self, model, **spec):\n\n        handles = self.__find_handles(model, **spec)\n        if len(handles) > 1:\n            raise MultipleObjectsReturned()\n        if not handles:\n            raise ObjectDoesNotExist()\n        return self.get_instance(model, handles[0])", "response": "get a single model instance by handle"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the sha blob of the current file", "response": "def get_sha_blob(self):\n        \"\"\"\n        if the current file exists\n            returns the sha blob\n        else\n            returns None\n        \"\"\"\n        r = requests.get(self.api_url, auth=self.get_auth_details())\n        try:\n            return r.json()['sha']\n        except KeyError:\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\npublish a new file or update it.", "response": "def publish_post(self):\n        \"\"\"\n        If it's a new file, add it.\n        Else, update it.\n        \"\"\"\n        payload = {'content': self.content_base64.decode('utf-8')}\n\n        sha_blob = self.get_sha_blob()\n        if sha_blob:\n            commit_msg = 'ghPublish UPDATE: {}'.format(self.title)\n            payload.update(sha=sha_blob)\n            payload.update(message=commit_msg)\n        else:\n            commit_msg = 'ghPublish ADD: {}'.format(self.title)\n            payload.update(message=commit_msg)\n\n        r = requests.put(self.api_url,\n                         auth=self.get_auth_details(),\n                         data=json.dumps(payload))\n        try:\n            url = r.json()['content']['html_url']\n            return r.status_code, url\n        except KeyError:\n            return r.status_code, None"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nfinds a file in a sequence of paths and return the absolute path to the file.", "response": "def find_file(filename, path_dirs=None):\n    \"\"\"Find a file by looking through a sequence of paths.\n    This iterates through a sequence of paths looking for a file and returns\n    the full, absolute path of the first occurence of the file.  If no set of\n    path dirs is given, the filename is tested as is, after running through\n    :func:`expandvars` and :func:`expanduser`.  Thus a simple call::\n        find_file('myfile.txt')\n    will find the file in the current working dir, but::\n        find_file('~/myfile.txt')\n    Will find the file in the users home directory.  This function does not\n    automatically try any paths, such as the cwd or the user's home directory.\n    Parameters\n    ----------\n    filename : str\n        The filename to look for.\n    path_dirs : str, None or sequence of str\n        The sequence of paths to look for the file in.  If None, the filename\n        need to be absolute or be in the cwd.  If a string, the string is\n        put into a sequence and the searched.  If a sequence, walk through\n        each element and join with ``filename``, calling :func:`expandvars`\n        and :func:`expanduser` before testing for existence.\n    Returns\n    -------\n    Raises :exc:`IOError` or returns absolute path to file.\n    \"\"\"\n\n    # If paths are quoted, abspath gets confused, strip them...\n    filename = filename.strip('\"').strip(\"'\")\n    # If the input is an absolute path, just check it exists\n    if os.path.isabs(filename) and os.path.isfile(filename):\n        return filename\n\n    if path_dirs is None:\n        path_dirs = (\"\",)\n    elif isinstance(path_dirs, six.string_types):\n        path_dirs = (path_dirs,)\n\n    for path in path_dirs:\n        if path == '.': path = os.getcwd()\n        testname = expand_path(os.path.join(path, filename))\n        if os.path.isfile(testname):\n            return os.path.abspath(testname)\n\n    raise IOError(\"File %r does not exist in any of the search paths: %r\" %\n                  (filename, path_dirs) )"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget triggered whenever the the gpio state changes :param gpio: Number of gpio that changed :type gpio: int :rtype: None", "response": "def _gpio_callback(self, gpio):\n        \"\"\"\n        Gets triggered whenever the the gpio state changes\n\n        :param gpio: Number of gpio that changed\n        :type gpio: int\n        :rtype: None\n        \"\"\"\n        self.debug(u\"Triggered #{}\".format(gpio))\n        try:\n            index = self.gpios.index(gpio)\n        except ValueError:\n            self.error(u\"{} not present in GPIO list\".format(gpio))\n            return\n        with self._people_lock:\n            person = self.people[index]\n            read_val = GPIO.input(gpio)\n            if read_val == person.sitting:\n                # Nothing changed?\n                time.sleep(self.gpio_bouncetime_sleep)\n                # Really sure?\n                read_val = GPIO.input(gpio)\n            if person.sitting != read_val:\n                person.sitting = read_val\n                self.debug(u\"Person is now {}sitting\".format(\n                    \"\" if person.sitting else \"not \")\n                )\n                try:\n                    self.changer.on_person_update(self.people)\n                except:\n                    self.exception(\n                        u\"Failed to update people (Person: {})\".format(person)\n                    )\n            else:\n                self.warning(u\"Nothing changed on {}\".format(gpio))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef start(self, blocking=False):\n        self.debug(\"()\")\n        # Init GPIO\n        # Enable warnings\n        GPIO.setwarnings(True)\n        # Careful - numbering between different pi version might differ\n        if self.gpio_mode == \"BOARD\":\n            GPIO.setmode(GPIO.BOARD)\n        else:\n            GPIO.setmode(GPIO.BCM)\n\n        # Register people\n        try:\n            self.changer.on_person_new(self.people)\n        except:\n            self.exception(\"Failed to add people to audience\")\n            raise StartException(\"Adding people failed\")\n\n        # Setup pins\n        for gpio in self.gpios:\n            GPIO.setup(gpio, GPIO.IN, pull_up_down=GPIO.PUD_DOWN)\n            GPIO.add_event_detect(\n                gpio, GPIO.BOTH,\n                callback=self._gpio_callback, bouncetime=self.gpio_bouncetime\n            )\n        super(GPIODetector, self).start(blocking)", "response": "Start the interface for the current state of the object."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef stop(self):\n        self.debug(\"()\")\n        # Not sure if this is necessary, but good form\n        if self._is_running:\n            for gpio in self.gpios:\n                GPIO.remove_event_detect(gpio)\n            # Cleanup - includes used numbering scheme\n        GPIO.cleanup()\n        # Leave audience\n        try:\n            self.changer.on_person_leave(self.people)\n        except:\n            self.exception(\"Failed to remove people from audience\")\n        super(GPIODetector, self).stop()", "response": "Stop the interface and remove all event detections from the audience."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding a lint issue to the report.", "response": "def add(self, lines, message):\n\t\t\"\"\"\n\t\tAdds a lint issue to the report. The first arg should be [] of lines on\n\t\twhich the issue is present. The second arg should be the error message.\n\t\t\"\"\"\n\t\terror = Error(message)\n\n\t\tif error not in self.errors:\n\t\t\tself.errors[error] = []\n\n\t\tself.errors[error].extend(lines)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a report each line of which comprises a pair of input line and an error.", "response": "def _get_linewise_report(self):\n\t\t\"\"\"\n\t\tReturns a report each line of which comprises a pair of an input line\n\t\tand an error. Unlike in the standard report, errors will appear as many\n\t\ttimes as they occur.\n\n\t\tHelper for the get_report method.\n\t\t\"\"\"\n\t\td = defaultdict(list)  # line: [] of errors\n\n\t\tfor error, lines in self.errors.items():\n\t\t\tfor line_num in lines:\n\t\t\t\td[line_num].append(error)\n\n\t\treturn '\\n'.join([\n\t\t\t'{:>3} \u2192 {}'.format(line, error.string)\n\t\t\tfor line in sorted(d.keys())\n\t\t\tfor error in d[line]])"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a report which includes each distinct error only once together with a list of input lines where the error occurs.", "response": "def _get_report(self, with_line_nums=True):\n\t\t\"\"\"\n\t\tReturns a report which includes each distinct error only once, together\n\t\twith a list of the input lines where the error occurs. The latter will\n\t\tbe omitted if flag is set to False.\n\n\t\tHelper for the get_report method.\n\t\t\"\"\"\n\t\ttempl = '{} \u2190 {}' if with_line_nums else '{}'\n\n\t\treturn '\\n'.join([\n\t\t\ttempl.format(error.string, ','.join(map(str, sorted(set(lines)))))\n\t\t\tfor error, lines in self.errors.items()])"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a string describing all the errors collected so far.", "response": "def get_report(self, linewise=False, no_lines=False):\n\t\t\"\"\"\n\t\tReturns a string describing all the errors collected so far (the\n\t\treport). The first flag determines the type of report. The second flag\n\t\tis ignored if the first is set to True.\n\t\t\"\"\"\n\t\tif linewise:\n\t\t\treturn self._get_linewise_report()\n\t\telse:\n\t\t\treturn self._get_report(not no_lines)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef send(self, to, from_, body):\n        try:\n            msg = self.client.sms.messages.create(\n                body=body,\n                to=to,\n                from_=from_\n                )\n            print msg.sid\n        except twilio.TwilioRestException as e:\n            raise", "response": "Send a message to a set of users."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate a tar. gz from a directory.", "response": "def tar_gzip_dir(directory, destination, base=None):\n    \"\"\"Creates a tar.gz from a directory.\"\"\"\n    dest_file = tarfile.open(destination, 'w:gz')\n    abs_dir_path = os.path.abspath(directory)\n    base_name = abs_dir_path + \"/\"\n    base = base or os.path.basename(directory)\n    for path, dirnames, filenames in os.walk(abs_dir_path):\n        rel_path = path[len(base_name):]\n        dir_norm_path = os.path.join(base, rel_path)\n        dir_tar_info = dest_file.gettarinfo(name=path)\n        dir_tar_info.name = dir_norm_path\n        dest_file.addfile(dir_tar_info)\n        for filename in filenames:\n            actual_path = os.path.join(path, filename)\n            norm_path = os.path.join(base, rel_path, filename)\n            tar_info = dest_file.gettarinfo(name=actual_path)\n            tar_info.name = norm_path\n            new_file = open(actual_path, 'rb')\n            dest_file.addfile(tar_info, new_file)\n    dest_file.close()"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates a yyyy - mm - dd string from a tuple containing ( yyyy m ) or one with the day too", "response": "def tuple_to_string(date_tuple):\n    \"\"\"\n    Create a yyyy-mm(-dd) string from a tuple containing (yyyy, m) (or one with the day too)\n    \"\"\"\n    if len(date_tuple) == 2:\n        # It's yyyy-mm\n        return str(date_tuple[0]).zfill(4) + '-' + str(date_tuple[1]).zfill(2)\n    # It's yyyy-mm-dd\n    return str(date_tuple[0]).zfill(4) + '-' + str(date_tuple[1]).zfill(2) + '-' + str(date_tuple[2]).zfill(2)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nremoves a KnwKB file.", "response": "def del_kwnkb(mapper, connection, target):\n    \"\"\"Remove taxonomy file.\"\"\"\n    if(target.kbtype == KnwKB.KNWKB_TYPES['taxonomy']):\n        # Delete taxonomy file\n        if os.path.isfile(target.get_filename()):\n            os.remove(target.get_filename())"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef name(self, value):\n        self._name = value\n        # generate slug\n        if not self.slug:\n            self.slug = KnwKB.generate_slug(value)", "response": "Set name and generate the slug."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef to_dict(self):\n        mydict = {'id': self.id, 'name': self.name,\n                  'description': self.description,\n                  'kbtype': self.kbtype}\n        if self.kbtype == 'd':\n            mydict.update((self.kbdefs.to_dict() if self.kbdefs else {}) or {})\n\n        return mydict", "response": "Return a dict representation of KnwKB."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a list of dicts of key and value from a knowledge base.", "response": "def get_kbr_items(self, searchkey=\"\", searchvalue=\"\", searchtype='s'):\n        \"\"\"\n        Return dicts of 'key' and 'value' from a knowledge base.\n\n        :param kb_name the name of the knowledge base\n        :param searchkey search using this key\n        :param searchvalue search using this value\n        :param searchtype s=substring, e=exact, sw=startswith\n        :return a list of dictionaries [{'key'=>x, 'value'=>y},..]\n        \"\"\"\n        import warnings\n        warnings.warn(\"The function is deprecated. Please use the \"\n                      \"`KnwKBRVAL.query_kb_mappings()` instead. \"\n                      \"E.g. [kval.to_dict() for kval in \"\n                      \"KnwKBRVAL.query_kb_mappings(kb_id).all()]\")\n        if searchtype == 's' and searchkey:\n            searchkey = '%' + searchkey + '%'\n        if searchtype == 's' and searchvalue:\n            searchvalue = '%' + searchvalue + '%'\n        if searchtype == 'sw' and searchvalue:  # startswith\n            searchvalue = searchvalue + '%'\n        if not searchvalue:\n            searchvalue = '%'\n        if not searchkey:\n            searchkey = '%'\n\n        kvals = KnwKBRVAL.query.filter(\n            KnwKBRVAL.id_knwKB.like(self.id),\n            KnwKBRVAL.m_value.like(searchvalue),\n            KnwKBRVAL.m_key.like(searchkey)).all()\n        return [kval.to_dict() for kval in kvals]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_kbr_values(self, searchkey=\"\", searchvalue=\"\", searchtype='s'):\n        import warnings\n        warnings.warn(\"The function is deprecated. Please use the \"\n                      \"`KnwKBRVAL.query_kb_mappings()` instead. \"\n                      \"E.g. [(kval.m_value,) for kval in \"\n                      \"KnwKBRVAL.query_kb_mappings(kb_id).all()]\")\n        # prepare filters\n        if searchtype == 's':\n            searchkey = '%' + searchkey + '%'\n        if searchtype == 's' and searchvalue:\n            searchvalue = '%' + searchvalue + '%'\n        if searchtype == 'sw' and searchvalue:  # startswith\n            searchvalue = searchvalue + '%'\n        if not searchvalue:\n            searchvalue = '%'\n        # execute query\n        return db.session.execute(\n            db.select([KnwKBRVAL.m_value],\n                      db.and_(KnwKBRVAL.id_knwKB.like(self.id),\n                              KnwKBRVAL.m_value.like(searchvalue),\n                              KnwKBRVAL.m_key.like(searchkey))))", "response": "Get the values of a key and value pair from a knowledge base."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngenerates a slug for the knowledge.", "response": "def generate_slug(name):\n        \"\"\"Generate a slug for the knowledge.\n\n        :param name: text to slugify\n        :return: slugified text\n        \"\"\"\n        slug = slugify(name)\n\n        i = KnwKB.query.filter(db.or_(\n            KnwKB.slug.like(slug),\n            KnwKB.slug.like(slug + '-%'),\n        )).count()\n\n        return slug + ('-{0}'.format(i) if i > 0 else '')"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn True if a kb with the given filters exists.", "response": "def query_exists(filters):\n        \"\"\"Return True if a kb with the given filters exists.\n\n        E.g: KnwKB.query_exists(KnwKB.name.like('FAQ'))\n\n        :param filters: filter for sqlalchemy\n        :return: True if kb exists\n        \"\"\"\n        return db.session.query(\n            KnwKB.query.filter(\n                filters).exists()).scalar()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a dict representation of KnwKBDDEF.", "response": "def to_dict(self):\n        \"\"\"Return a dict representation of KnwKBDDEF.\"\"\"\n        return {'field': self.output_tag,\n                'expression': self.search_expression,\n                'coll_id': self.id_collection,\n                'collection': self.collection.name\n                if self.collection else None}"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nquerying all mappings from a given kb.", "response": "def query_kb_mappings(kbid, sortby=\"to\", key=\"\", value=\"\",\n                          match_type=\"s\"):\n        \"\"\"Return a list of all mappings from the given kb, ordered by key.\n\n        If key given, give only those with left side (mapFrom) = key.\n        If value given, give only those with right side (mapTo) = value.\n\n        :param kb_name: knowledge base name. if \"\", return all\n        :param sortby: the sorting criteria ('from' or 'to')\n        :param key: return only entries where key matches this\n        :param value: return only entries where value matches this\n        :param match_type: s=substring, e=exact, sw=startswith\n        \"\"\"\n        # query\n        query = KnwKBRVAL.query.filter(\n            KnwKBRVAL.id_knwKB == kbid)\n        # filter\n        if len(key) > 0:\n            if match_type == \"s\":\n                key = \"%\" + key + \"%\"\n            elif match_type == \"sw\":\n                key = key + \"%\"\n        else:\n            key = '%'\n        if len(value) > 0:\n            if match_type == \"s\":\n                value = \"%\" + value + \"%\"\n            elif match_type == \"sw\":\n                value = value + \"%\"\n        else:\n            value = '%'\n        query = query.filter(\n            KnwKBRVAL.m_key.like(key),\n            KnwKBRVAL.m_value.like(value))\n        # order by\n        if sortby == \"from\":\n            query = query.order_by(KnwKBRVAL.m_key)\n        else:\n            query = query.order_by(KnwKBRVAL.m_value)\n        return query"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a dict representation of KnwKBRVAL.", "response": "def to_dict(self):\n        \"\"\"Return a dict representation of KnwKBRVAL.\"\"\"\n        # FIXME remove 'id' dependency from invenio modules\n        return {'id': self.m_key + \"_\" + str(self.id_knwKB),\n                'key': self.m_key,\n                'value': self.m_value,\n                'kbid': self.kb.id if self.kb else None,\n                'kbname': self.kb.name if self.kb else None}"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef social_links(context, object, user=None, authed=False, downable=False, vote_down_msg=None):\n    # check if voting available\n    voting = False\n    if hasattr(object, 'votes'):\n        voting = True\n\n    return {\n        'object': object,\n        'url':    object.get_absolute_url(),\n        'site':   get_current_site(context.request),\n        'ctype':  ContentType.objects.get_for_model(object),\n        'user':   user,\n        'voting': voting,\n        'vote_down': downable,\n        'vote_down_msg': vote_down_msg,\n        'authenticated_request': authed,\n    }", "response": "Outputs social links. At minimum, this will be Facebook and Twitter.\n    But if possible, it will also output voting and watchlist links.\n\n    Usage:\n    {% social_links object %}\n    {% social_links object user %}\n    {% social_links object user authenticated_request %}"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef clean_data(self):\n\n        # TODO: Do the same for duration/timedelta\n        if \"timestamp\" in self:\n            self._check_timestamp()\n            if type(self[\"timestamp\"]) == list:\n                def datetime_to_string(dt):\n                    return fmt_datetime(dt) if type(dt) == datetime else dt\n                self[\"timestamp\"] = list(map(datetime_to_string, self[\"timestamp\"]))\n            elif type(self[\"timestamp\"]) == datetime:\n                self[\"timestamp\"] = fmt_datetime(self[\"timestamp\"])\n\n        # FIXME: Support list of volumes\n        if \"volume\" in self:\n            self[\"volume\"][\"unit\"] = self[\"volume\"][\"unit\"].replace(\"l\", \"L\")\n\n        # FIXME: Support list of weights\n        if \"weight\" in self:\n            # Zenobase uses \"ug\" for micrograms\n            if self[\"weight\"][\"unit\"] in [\"mcg\", \"\u00b5g\"]:\n                self[\"weight\"][\"unit\"] = \"ug\"", "response": "Ensures data is Zenobase compatible and patches it if possible"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef run(self):\n        try:\n            super().run()\n        except Exception as e:\n            print(trace_info())\n        finally:\n            if not self.no_ack:\n                # \u5982\u679c\u4e3aTrue\uff0c\u4efb\u52a1\u7ed3\u675f\u540e\u9700\u8981\u786e\u8ba4\n                self.ch.basic_ack(delivery_tag=self.method.delivery_tag)", "response": "run - \u542f\u52a8 \u542f\ufffd"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef send_task(self, body):\n        self.ch.basic_publish(exchange='', routing_key=self.task_queue,\n            properties=pika.BasicProperties(delivery_mode=2), body=body)", "response": "Send a task to the task queue"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nstores data in the store queue.", "response": "def store_data(self, data):\n        \"\"\"\n        \u5b58\u50a8\u6570\u636e\u5230\u5b58\u50a8\u961f\u5217\n        :param data: \u6570\u636e\n        :return:\n        \"\"\"\n        self.ch.basic_publish(exchange='', routing_key=self.store_queue,\n            properties=pika.BasicProperties(delivery_mode=2), body=data)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef serv_forever(self, func):\n        # \u5982\u679c\u4efb\u52a1\u961f\u5217\u4e0d\u4e3a\u7a7a\u5219\u58f0\u660e\u961f\u5217\n        if self.task_queue:\n            self.ch.queue_declare(\n                queue=self.task_queue, durable=self.durable)\n        if self.store_queue:\n            self.ch.queue_declare(\n                queue=self.store_queue, durable=self.durable)\n\n        def callback(ch, method, properties, body):\n            \"\"\"\n            amqp\u7684\u56de\u8c03\u51fd\u6570\n            :param ch: \u94fe\u9053\n            :param method: \u9ed8\u8ba4\u7684\u65b9\u6cd5\n            :param properties: \u9ed8\u8ba4\n            :param body: \u63a5\u6536\u5230\u7684\u6570\u636e\u4efb\u52a1\n            :return:\n            \"\"\"\n            if self.prefetch_count > 1:\n                # \u5982\u679c\u4efb\u52a1\u961f\u5217\u7684\u5e76\u53d1\u6267\u884c\u6570\u5927\u4e8e1\uff0c\u5219\u542f\u52a8\u7ebf\u7a0b\n                # \u5426\u5219\uff0c\u5355\u7ebf\u7a0b\n                task = _RabbitmqTask(func, (self, body), self.no_ack, ch, method, properties)\n                task.start()\n            else:\n                func(self, body)\n                # \u4efb\u52a1\u7ed3\u675f\u540e\uff0c\u786e\u8ba4\u4efb\u52a1\n                if not self.no_ack:\n                    self.ch.basic_ack(delivery_tag=self.method.delivery_tag)\n\n        # \u58f0\u660e\u961f\u5217\n        self.ch.basic_qos(prefetch_count=self.prefetch_count)\n        self.ch.basic_consume(callback, queue=self.task_queue, no_ack=self.no_ack)\n        # \u542f\u52a8\u6d88\u8d39\u8005\n        self.ch.start_consuming()", "response": "This method is used to run a function in a thread. It is responsible for handling the callback function."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef produce(self, func):\n        # \u58f0\u660e\u961f\u5217\n        if not self.task_queue:\n            self.ch.queue_declare(queue=self.task_queue, durable=self.durable)\n        func(self)", "response": "produce \u542f\u52a8\u751f\u4ea7\u8005\n        func \u751f\u4ea7\u8005\n       "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef render(obj):\n    def get_v(v):\n        return v % env if isinstance(v, basestring) else v\n\n    if isinstance(obj, types.StringType):\n        return obj % env\n    elif isinstance(obj, types.TupleType) or isinstance(obj, types.ListType):\n        rv = []\n        for v in obj:\n            rv.append(get_v(v))\n    elif isinstance(obj, types.DictType):\n        rv = {}\n        for k, v in obj.items():\n            rv[k] = get_v(v)\n\n    return rv", "response": "Convienently render strings with the fabric context"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nfiltering out MOODS motif hits that don t overlap the variant of interest.", "response": "def _filter_variant_motif_res(\n    motif_res, \n    variant_start, \n    variant_end, \n    motif_length, \n    seq,\n):\n    \"\"\"\n    Remove MOODS motif hits that don't overlap the variant of interest.\n    \n    Parameters\n    ----------\n    motif_res : list\n        Result from MOODS search like [(21, 3.947748787969809), (-38,\n        3.979759977155675)].\n        \n    variant_start : int\n        Relative start position of the allele string in seq (not genomic\n        coordinates).  In other words, seq[variant_start:variant_end] should\n        give the allele.\n        \n    variant_end : int\n        Relative end position of the allele string in seq (not genomic\n        coordinates).  In other words, seq[variant_start:variant_end] should\n        give the allele.\n        \n    motif_length : int\n        Length of the motif.\n        \n    seq : str\n        Sequence searched for motifs for this allele.\n\n    Returns\n    -------\n    motif_res : list\n        List in the same format as motif_res input but with entries that don't\n        overlap the variant removed. \n\n    \"\"\"\n    import MOODS\n    remove = []\n    for r in motif_res:\n        motif_start = r[0]\n        motif_end = r[0] + motif_length\n        if r[0] < 0:\n            motif_start += len(seq)\n            motif_end += len(seq)\n\n        if motif_end <= variant_start or motif_start >= variant_end:\n            remove.append(r)\n    motif_res = list(set(motif_res) - set(remove))\n    return motif_res"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef find_motif_disruptions(\n    position, \n    ref, \n    alt, \n    genome_fasta, \n    matrices,\n):\n    \"\"\"\n    Determine whether there is a difference between the ref and alt\n    alleles for TF binding. Requires samtools in your path.\n    \n    Parameters\n    ----------\n    position : str\n        Zero based genomic coordinates of the reference allele of the form\n        chrom:start-end (chr5:100-101 for a SNV for instance). The value end -\n        start should equal the length of the ref allele.\n\n    ref : str\n        Reference allele. This should match the reference sequence at \"position\"\n        in genome_fasta.\n\n    alt : str\n        Alternate allele.\n\n    genome_fasta : str\n        Path to genome fasta file. This file should be indexed.\n    \n    matrices : dict\n        Dict whose keys are motif names and whose values are pandas data frames \n        or numpy arrays containing PWMs with columns ACGT.\n\n    Returns\n    -------\n    out : pandas.DataFrame\n        Pandas data frame with motifs whose best matches that overlapped the\n        variant differed between the reference and alternate sequences. A score\n        of zero and a strand of '' indicates that there was not a match for the\n        motif on the given allele.\n\n    \"\"\"\n    import subprocess\n    import MOODS\n    # import pybedtools as pbt\n    max_motif_length = max([x.shape[0] for x in matrices.values()])\n    chrom, coords = position.split(':')\n    start,end = [int(x) for x in coords.split('-')]\n    s = '{}:{}-{}'.format(chrom, start - max_motif_length + 1, end +\n                          max_motif_length - 1)\n    c = 'samtools faidx {} {}'.format(genome_fasta, s)\n    seq_lines = subprocess.check_output(c, shell=True).strip().split()\n    ref_seq = seq_lines[1]\n    alt_seq = ref_seq[0:max_motif_length - 1] + alt + ref_seq[max_motif_length + len(ref) - 1:]\n\n    ref_variant_start = max_motif_length - 1\n    ref_variant_end = max_motif_length - 1 + len(ref)\n    alt_variant_start = max_motif_length - 1\n    alt_variant_end = max_motif_length - 1 + len(alt)\n\n    ms = [matrices[x].T.values.tolist() for x in matrices.keys()]\n    ref_res = MOODS.search(ref_seq, ms, 0.001, both_strands=True, \n                           bg=[0.25, 0.25, 0.25, 0.25])\n    ref_res = dict(zip(matrices.keys(), ref_res))\n    alt_res = MOODS.search(alt_seq, ms, 0.001, both_strands=True, \n                           bg=[0.25, 0.25, 0.25, 0.25])\n    alt_res = dict(zip(matrices.keys(), alt_res))\n\n    # First we'll remove any motif matches that don't overlap the variant of interest (and thus\n    # can't be affected by the variant and will be the same for ref and alt). Then we'll get the \n    # best match for each motif for ref and alt.\n    rows = []\n    for motif in ref_res.keys():\n        ref_res[motif] = _filter_variant_motif_res(ref_res[motif], ref_variant_start, ref_variant_end, \n                                           matrices[motif].shape[0], ref_seq)\n        alt_res[motif] = _filter_variant_motif_res(alt_res[motif], alt_variant_start, alt_variant_end, \n                                           matrices[motif].shape[0], alt_seq)\n\n        if len(ref_res[motif]) > 0:\n            ref_pos, ref_score = sorted(ref_res[motif], key=lambda x: x[1], reverse=True)[0]\n            ref_strand = {True:'+', False:'-'}[ref_pos > 0]\n        else:\n            ref_score = 0\n            ref_strand = ''\n        if len(alt_res[motif]) > 0:\n            alt_pos, alt_score = sorted(alt_res[motif], key=lambda x: x[1], reverse=True)[0]\n            alt_strand = {True:'+', False:'-'}[alt_pos > 0]\n        else:\n            alt_score = 0\n            alt_strand = ''\n        if ref_score > 0 or alt_score > 0:\n            diff = ref_score - alt_score\n            rows.append([motif, ref_score, ref_strand, alt_score, alt_strand, diff])\n    out = pd.DataFrame(rows, columns=['motif', 'ref_score', 'ref_strand', 'alt_score', \n                                      'alt_strand', 'score_diff'])\n    out.index = out.motif\n    out = out.drop('motif', axis=1)\n    out = out[out.score_diff != 0]\n    return out", "response": "Find motifs that overlap between the reference and alternate sequences."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef read_wwln(file):\n    tmp = pd.read_csv(file, parse_dates=True, header=None,\n                      names=['date', 'time', 'lat', 'lon', 'err', '#sta'])\n    # Generate a list of datetime objects with time to miliseconds\n    list_dts = []\n    for dvals, tvals, in zip(tmp['date'], tmp['time']):\n        list_dts.append(gen_datetime(dvals, tvals))\n    dtdf = pd.DataFrame(list_dts, columns=['datetime'])\n    result = pd.concat([dtdf, tmp], axis=1)\n    result = result.drop(['date', 'time'], axis=1)\n    return result", "response": "Read WWLN file and return as pandas DataFrame"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nread data from Blitzorg and put it into a geopandas dataframe.", "response": "def wwln_to_geopandas(file):\n    \"\"\"Read data from Blitzorg first using pandas.read_csv for convienence, and\n    then convert lat, lon points to a shaleply geometry POINT type.\n    Finally put this gemoetry into a geopandas dataframe and return it.\"\"\"\n    tmp = pd.read_csv(file, parse_dates=True, header=None,\n                      names=['date', 'time', 'lat', 'lon', 'err', '#sta'])\n    list_dts = [gen_datetime(dvals, tvals)\n                for dvals, tvals in zip(tmp['date'], tmp['time'])]\n    points = [[Point(tmp.lat[row], tmp.lon[row]), dt]\n              for row, dt in zip(tmp.index, list_dts)]\n    df = gpd.GeoDataFrame(points, columns=['geometry', 'dt'])\n    return df"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ngenerate list of files in data directory with specific extension", "response": "def gen_listfiles(ext, data_path=current_path, start_date=None, end_date=None):\n    \"\"\"**Generate list of files in data directory**\n\n    Using a specified data path and extension generate list of files in data\n    directory. If start_date and end_date aren't specified, all files in the\n    data directory are selected.\n\n    :paramter data_path: string\n    :parameter ext: string\n    :parameter start_date: time string in format mm-dd-yyy (optional)\n    :paramater end_date: time string in format mm-dd-yyy (optional)\n\n    :Example:\n\n    >>> gen_listfiles(data_path='./data', ext='.loc', start_date='01-01-2016',\n    end_date='01-10-2016')\n    \"\"\"\n    # make list of all files in data directory with certain extension ext\n    listfiles = [fn for fn in os.listdir(data_path) if (fn.endswith(ext))]\n    # check if start_date & end_date are set\n    if (start_date is not None) or (end_date is not None):\n        all_dates = pd.date_range(start_date, end_date, freq='D')\n        # make list with files in selected range\n        files = []\n        for date in all_dates:\n            yyyy = str(date.year)\n            mm = \"%02d\" % (date.month,)\n            dd = \"%02d\" % (date.day,)\n            file = 'A'+yyyy+mm+dd+ext\n            files.append(file)\n        # compare and return matches\n        listfiles = set(listfiles).intersection(files)\n        return files\n    # if start and end dates aren't set use all files in data dir\n    else:\n        return listfiles"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncounts the number of lightning strikes detected within a defined time step.", "response": "def count_lightning(datain, time_step):\n    \"\"\"**Count lightning strikes detected within a defined time_step**\n\n    Generate time intervals according to the time_step defined and count\n    lightning strikes in these intervals. Statistics are also calculated for\n    lightning detection errors and the number of stations and added to an\n    output dataframe. Time stamps in output dataframe correspond to center of\n    time periods in which lightning are counted.\n\n    :paramter datain: dataframe (lightning data)\n    :parameter time_step: integer (time step in minutes)\n\n    :Example:\n\n     >>> count_lightning(LN_data, time_step)\n     \"\"\"\n    if(1440 % time_step == 0):  # check if time_step is multiple of 1 day\n        i = 0\n        # run for loop for all time steps in one day\n        for time_interval in gen_time_intervals(extract_date(datain['datetime'].iloc[0]),\n                                                (extract_date(datain['datetime'].iloc[0])+timedelta(days=1)),\n                                                timedelta(minutes=time_step)):\n            # select data in given time_interval\n            tmp_LN_data = datain.loc[(datain['datetime'] >= time_interval) &\n                                     (datain['datetime'] < time_interval +\n                                      timedelta(minutes=time_step))]\n            # calculate stats\n            stats_err = gen_stats(tmp_LN_data['err'])\n            stats_sta = gen_stats(tmp_LN_data['#sta'])\n            d = {'count': stats_err['count'],\n                 'err_mean': stats_err['mean'],\n                 'err_std': stats_err['std'],\n                 'err_min': stats_err['min'],\n                 'err_max': stats_err['max'],\n                 '#sta_mean': stats_sta['mean'],\n                 '#sta_std': stats_sta['std'],\n                 '#sta_min': stats_sta['min'],\n                 '#sta_max': stats_sta['max']}\n            col_names = [k for k in d.keys()]\n            df_index = time_interval+timedelta(minutes=(time_step/2))\n            temp_LN_count = pd.DataFrame(d, index=[df_index],\n                                         columns=col_names)\n            # add data to existing df\n            if(i >= 1):\n                LN_count = LN_count.append(temp_LN_count)\n            else:\n                LN_count = temp_LN_count\n            i = i + 1\n        return LN_count\n    else:\n        print(\"time_step {0} multiple of 1 day (1400 min)\".format(time_step))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef gen_stats(datain):\n    tmp_dic={}\n    tmp_dic['count'] = len(datain)\n    # if there is no lightning strikes set nan values for all stats parameters\n    if(tmp_dic['count'] == 0):\n        tmp_dic['mean'] = np.nan\n        tmp_dic['std'] = np.nan\n        tmp_dic['min'] = np.nan\n        tmp_dic['max'] = np.nan\n    else:\n        tmp_dic['mean'] = np.mean(datain)\n        tmp_dic['std'] = np.std(datain)\n        tmp_dic['min'] = min(datain)\n        tmp_dic['max'] = max(datain)\n    return tmp_dic", "response": "Calculates lightning statitics and returns a dictionary"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef gen_time_intervals(start, end, delta):\n    curr = start\n    while curr < end:\n        yield curr\n        curr += delta", "response": "Generate time intervals using datetime for start and end."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconverting timestamp to datetime and set everything to zero except a date", "response": "def extract_date(value):\n    \"\"\"\n    Convert timestamp to datetime and set everything to zero except a date\n    \"\"\"\n    dtime = value.to_datetime()\n    dtime = (dtime - timedelta(hours=dtime.hour) - timedelta(minutes=dtime.minute) -\n             timedelta(seconds=dtime.second) - timedelta(microseconds=dtime.microsecond))\n    return dtime"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncheck if user is logged in and if not redirect to login url", "response": "def process_request(self, request):\n        \"\"\"Check if user is logged in\"\"\"\n        assert hasattr(request, 'user')\n        if not request.user.is_authenticated():\n            path = request.path_info.lstrip('/')\n            if not any(m.match(path) for m in EXEMPT_URLS):\n                return HttpResponseRedirect(reverse(settings.LOGIN_URL))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef dump_js(js, abspath, precision=None,\n            fastmode=False, replace=False, compress=False, enable_verbose=True):\n    \"\"\"Dump Json serializable object to file.\n    Provides multiple choice to customize the behavior.\n\n    :param js: Serializable python object.\n    :type js: dict or list\n\n    :param abspath: ``save as`` path, file extension has to be ``.json`` or ``.gz``\n        (for compressed json).\n    :type abspath: string\n\n    :param fastmode: (default False) If ``True``, then dumping json without\n        sorted keys and pretty indent, and it's faster and smaller in size.\n    :type fastmode: boolean\n\n    :param replace: (default False) If ``True``, when you dump json to a existing\n        path, it silently overwrite it. If False, an exception will be raised.\n        Default False setting is to prevent overwrite file by mistake.\n    :type replace: boolean\n\n    :param compress: (default False) If ``True``, use GNU program gzip to\n        compress the json file. Disk usage can be greatly reduced. But you have\n        to use :func:`load_js(abspath, compress=True)<load_js>` in loading.\n    :type compress: boolean\n\n    :param enable_verbose: (default True) Trigger for message.\n    :type enable_verbose: boolean\n\n    Usage::\n\n        >>> from weatherlab.lib.dataIO.js import dump_js\n        >>> js = {\"a\": 1, \"b\": 2}\n        >>> dump_js(js, \"test.json\", replace=True)\n        Dumping to test.json...\n            Complete! Elapse 0.002432 sec\n\n    **\u4e2d\u6587\u6587\u6863**\n\n    \u5c06Python\u4e2d\u53ef\u88ab\u5e8f\u5217\u5316\u7684\"\u5b57\u5178\", \"\u5217\u8868\"\u4ee5\u53ca\u4ed6\u4eec\u7684\u7ec4\u5408, \u6309\u7167Json\u7684\u7f16\u7801\u65b9\u5f0f\u5199\u5165\u6587\u4ef6\n    \u6587\u4ef6\n\n    \u53c2\u6570\u5217\u8868\n\n    :param js: \u53efJson\u5316\u7684Python\u5bf9\u8c61\n    :type js: ``\u5b57\u5178`` \u6216 ``\u5217\u8868``\n\n    :param abspath: \u5199\u5165\u6587\u4ef6\u7684\u8def\u5f84\u3002\u6269\u5c55\u540d\u5fc5\u987b\u4e3a``.json``\u6216``.gz``, \u5176\u4e2dgz\u7528\u4e8e\u88ab\u538b\n        \u7f29\u7684Json\n    :type abspath: ``\u5b57\u7b26\u4e32``\n\n    :param fastmode: (\u9ed8\u8ba4 False) \u5f53\u4e3a``True``\u65f6, Json\u7f16\u7801\u65f6\u4e0d\u5bf9Key\u8fdb\u884c\u6392\u5e8f, \u4e5f\u4e0d\n        \u8fdb\u884c\u7f29\u8fdb\u6392\u7248\u3002\u8fd9\u6837\u505a\u5199\u5165\u7684\u901f\u5ea6\u66f4\u5feb, \u6587\u4ef6\u7684\u5927\u5c0f\u4e5f\u66f4\u5c0f\u3002\n    :type fastmode: \"\u5e03\u5c14\u503c\"\n\n    :param replace: (\u9ed8\u8ba4 False) \u5f53\u4e3a``True``\u65f6, \u5982\u679c\u5199\u5165\u8def\u5f84\u5df2\u7ecf\u5b58\u5728, \u5219\u4f1a\u81ea\u52a8\u8986\u76d6\n        \u539f\u6587\u4ef6\u3002\u800c\u4e3a``False``\u65f6, \u5219\u4f1a\u629b\u51fa\u5f02\u5e38\u3002\u9632\u6b62\u8bef\u64cd\u4f5c\u8986\u76d6\u6e90\u6587\u4ef6\u3002\n    :type replace: \"\u5e03\u5c14\u503c\"\n\n    :param compress: (\u9ed8\u8ba4 False) \u5f53\u4e3a``True``\u65f6, \u4f7f\u7528\u5f00\u6e90\u538b\u7f29\u6807\u51c6gzip\u538b\u7f29Json\u6587\u4ef6\u3002\n        \u901a\u5e38\u80fd\u8ba9\u6587\u4ef6\u5927\u5c0f\u7f29\u5c0f10-20\u500d\u4e0d\u7b49\u3002\u5982\u8981\u8bfb\u53d6\u6587\u4ef6, \u5219\u9700\u8981\u4f7f\u7528\u51fd\u6570\n        :func:`load_js(abspath, compress=True)<load_js>`.\n    :type compress: \"\u5e03\u5c14\u503c\"\n\n    :param enable_verbose: (\u9ed8\u8ba4 True) \u662f\u5426\u6253\u5f00\u4fe1\u606f\u63d0\u793a\u5f00\u5173, \u6279\u5904\u7406\u65f6\u5efa\u8bae\u5173\u95ed.\n    :type enable_verbose: \"\u5e03\u5c14\u503c\"\n    \"\"\"\n    abspath = str(abspath)  # try stringlize\n\n    if precision is not None:\n        encoder.FLOAT_REPR = lambda x: format(x, \".%sf\" % precision)\n    \n    msg = Messenger(enable_verbose=enable_verbose)\n\n    if compress:  # check extension name\n        root, ext = os.path.splitext(abspath)\n        if ext != \".gz\":\n            if ext != \".tmp\":\n                raise Exception(\"compressed json has to use extension '.gz'!\")\n            else:\n                _, ext = os.path.splitext(root)\n                if ext != \".gz\":\n                    raise Exception(\n                        \"compressed json has to use extension '.gz'!\")\n    else:\n        root, ext = os.path.splitext(abspath)\n        if ext != \".json\":\n            if ext != \".tmp\":\n                raise Exception(\"file extension are not '.json'!\")\n            else:\n                _, ext = os.path.splitext(root)\n                if ext != \".json\":\n                    raise Exception(\"file extension are not '.json'!\")\n\n    msg.show(\"\\nDumping to %s...\" % abspath)\n    st = time.clock()\n\n    if os.path.exists(abspath):  # if exists, check replace option\n        if replace:  # replace existing file\n            if fastmode:  # no sort and indent, do the fastest dumping\n                if compress:\n                    with gzip.open(abspath, \"wb\") as f:\n                        f.write(json.dumps(js).encode(\"utf-8\"))\n                else:\n                    with open(abspath, \"wb\") as f:\n                        f.write(json.dumps(js).encode(\"utf-8\"))\n            else:\n                if compress:\n                    with gzip.open(abspath, \"wb\") as f:\n                        f.write(json.dumps(js, sort_keys=True,\n                                           indent=4, separators=(\",\", \": \")).encode(\"utf-8\"))\n                else:\n                    with open(abspath, \"wb\") as f:\n                        f.write(json.dumps(js, f, sort_keys=True,\n                                           indent=4, separators=(\",\", \": \")).encode(\"utf-8\"))\n        else:  # stop, print error message\n            raise Exception(\"\\tCANNOT WRITE to %s, it's already \"\n                            \"exists\" % abspath)\n\n    else:  # if not exists, just write to it\n        if fastmode:  # no sort and indent, do the fastest dumping\n            if compress:\n                with gzip.open(abspath, \"wb\") as f:\n                    f.write(json.dumps(js).encode(\"utf-8\"))\n            else:\n                with open(abspath, \"wb\") as f:\n                    f.write(json.dumps(js).encode(\"utf-8\"))\n        else:\n            if compress:\n                with gzip.open(abspath, \"wb\") as f:\n                    f.write(json.dumps(js, sort_keys=True,\n                                       indent=4, separators=(\",\", \": \")).encode(\"utf-8\"))\n            else:\n                with open(abspath, \"wb\") as f:\n                    f.write(json.dumps(js, sort_keys=True,\n                                       indent=4, separators=(\",\", \": \")).encode(\"utf-8\"))\n\n    msg.show(\"    Complete! Elapse %.6f sec\" % (time.clock() - st))", "response": "Dump a JSON object to a file."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef js2str(js, sort_keys=True, indent=4):\n    return json.dumps(js, sort_keys=sort_keys,\n                      indent=indent, separators=(\",\", \": \"))", "response": "Encode js to nicely formatted human readable string."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nprinting Json in pretty format.", "response": "def prt_js(js, sort_keys=True, indent=4):\n    \"\"\"Print Json in pretty format.\n    There's a standard module pprint, can pretty print python dict and list.\n    But it doesn't support sorted key. That why we need this func.\n\n    Usage::\n\n        >>> from weatherlab.lib.dataIO.js import prt_js\n        >>> prt_js({\"a\": 1, \"b\": 2})\n        {\n            \"a\": 1,\n            \"b\": 2\n        }\n\n    **\u4e2d\u6587\u6587\u6863**\n\n    \u4ee5\u4eba\u7c7b\u53ef\u8bfb\u7684\u65b9\u5f0f\u6253\u5370\u53efJson\u5316\u7684Python\u5bf9\u8c61\u3002\n    \"\"\"\n    print(js2str(js, sort_keys, indent))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nmaking size in bytes human readable.", "response": "def string_SizeInBytes(size_in_bytes):\n    \"\"\"Make ``size in bytes`` human readable.\n    Doesn\"t support size greater than 1000PB.\n\n    Usage::\n\n        >>> from __future__ import print_function\n        >>> from weatherlab.lib.filesystem.windowsexplorer import string_SizeInBytes\n        >>> print(string_SizeInBytes(100))\n        100 B\n        >>> print(string_SizeInBytes(100*1000))\n        97.66 KB\n        >>> print(string_SizeInBytes(100*1000**2))\n        95.37 MB\n        >>> print(string_SizeInBytes(100*1000**3))\n        93.13 GB\n        >>> print(string_SizeInBytes(100*1000**4))\n        90.95 TB\n        >>> print(string_SizeInBytes(100*1000**5))\n        88.82 PB\n    \"\"\"\n    res, by = divmod(size_in_bytes, 1024)\n    res, kb = divmod(res, 1024)\n    res, mb = divmod(res, 1024)\n    res, gb = divmod(res, 1024)\n    pb, tb = divmod(res, 1024)\n    if pb != 0:\n        human_readable_size = \"%.2f PB\" % (pb + tb / float(1024))\n    elif tb != 0:\n        human_readable_size = \"%.2f TB\" % (tb + gb / float(1024))\n    elif gb != 0:\n        human_readable_size = \"%.2f GB\" % (gb + mb / float(1024))\n    elif mb != 0:\n        human_readable_size = \"%.2f MB\" % (mb + kb / float(1024))\n    elif kb != 0:\n        human_readable_size = \"%.2f KB\" % (kb + by / float(1024))\n    else:\n        human_readable_size = \"%s B\" % by\n    return human_readable_size"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef decode(hashcode, delta=False):\n\n    lat, lon, lat_length, lon_length = _decode_c2i(hashcode)\n\n    if hasattr(float, \"fromhex\"):\n        latitude_delta = 90.0/(1 << lat_length)\n        longitude_delta = 180.0/(1 << lon_length)\n        latitude = _int_to_float_hex(lat, lat_length) * 90.0 + latitude_delta\n        longitude = _int_to_float_hex(lon, lon_length) * 180.0 + longitude_delta\n        if delta:\n            return latitude, longitude, latitude_delta, longitude_delta\n        return latitude, longitude\n\n    lat = (lat << 1) + 1\n    lon = (lon << 1) + 1\n    lat_length += 1\n    lon_length += 1\n\n    latitude = 180.0*(lat-(1 << (lat_length-1)))/(1 << lat_length)\n    longitude = 360.0*(lon-(1 << (lon_length-1)))/(1 << lon_length)\n    if delta:\n        latitude_delta = 180.0/(1 << lat_length)\n        longitude_delta = 360.0/(1 << lon_length)\n        return latitude, longitude, latitude_delta, longitude_delta\n\n    return latitude, longitude", "response": "decode a hashcode and get center coordinate and distance between center and outer border"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndecoding a hashcode and get north south east and west border.", "response": "def bbox(hashcode):\n    \"\"\"\n    decode a hashcode and get north, south, east and west border.\n    \"\"\"\n    lat, lon, lat_length, lon_length = _decode_c2i(hashcode)\n\n    if hasattr(float, \"fromhex\"):\n        latitude_delta = 180.0/(1 << lat_length)\n        longitude_delta = 360.0/(1 << lon_length)\n        latitude = _int_to_float_hex(lat, lat_length) * 90.0\n        longitude = _int_to_float_hex(lon, lon_length) * 180.0\n        return {\"s\": latitude, \"w\": longitude, \"n\": latitude+latitude_delta, \"e\": longitude+longitude_delta}\n\n    ret = {}\n    if lat_length:\n        ret['n'] = 180.0*(lat+1-(1 << (lat_length-1)))/(1 << lat_length)\n        ret['s'] = 180.0*(lat-(1 << (lat_length-1)))/(1 << lat_length)\n    else:  # can't calculate the half with bit shifts (negative shift)\n        ret['n'] = 90.0\n        ret['s'] = -90.0\n\n    if lon_length:\n        ret['e'] = 360.0*(lon+1-(1 << (lon_length-1)))/(1 << lon_length)\n        ret['w'] = 360.0*(lon-(1 << (lon_length-1)))/(1 << lon_length)\n    else:  # can't calculate the half with bit shifts (negative shift)\n        ret['e'] = 180.0\n        ret['w'] = -180.0\n\n    return ret"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nfind the kindlegen file", "response": "def find_kindlegen_prog(path=None):\n    '''\n    \u83b7\u53d6kindlegen\u7a0b\u5e8f\u8def\u5f84\n\n    \u8be5\u65b9\u6cd5\u4f1a\u68c0\u7d22\u7cfb\u7edf ``PATH`` \u8def\u5f84\uff0c\u67e5\u627e\u5305\u542b ``kindlegen`` \u6587\u4ef6\u7684\u8def\u5f84\uff0c\n    \u5e76\u8fd4\u56de\u8be5\u6587\u4ef6\u7684\u7edd\u5bf9\u8def\u5f84\u3002\u82e5\u4e0d\u5b58\u5728\u5219\u8fd4\u56de ``None``\n\n    .. attention::\n\n        \u68c0\u7d22 ``PATH`` \u8def\u5f84\u524d\uff0c\u4f1a\u4f18\u5148\u5bfb\u627e\u6307\u5b9a\u8def\u5f84\uff0c\u5e76\u5728\u68c0\u7d22\u5230\u7b2c\u4e00\u4e2a\u7b26\u5408\u6587\u4ef6\u540e\u7acb\u523b\u8fd4\u56de\n\n    :param str path: \u5173\u952e\u5b57\u53c2\u6570\uff0c\u82e5\u4f20\u5165\uff0c\u5219\u4f18\u5148\u68c0\u6d4b\u8be5\u8def\u5f84\u4e0b\u662f\u5426\u5b58\u5728 kindlegen \u7a0b\u5e8f\n    :return: kindlegen\u7684\u7edd\u5bf9\u8def\u5f84\n    :rtype: str\n    '''\n    try:\n        kindlegen_prog = 'kindlegen'\n\n        # search in current directory and PATH to find kinglegen\n        path_list = [path]\n        path_list.extend(os.getenv('PATH').split(':'))\n        for p in path_list:\n            if p:\n                fname = os.path.join(p, kindlegen_prog)\n                if os.path.exists(fname):\n                    return fname\n        return None\n    except Exception:\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef save_formset(self, request, form, formset, change):\n        formset.save()\n\n        for form in formset.forms:\n            if hasattr(form, 'nested_formsets') and form not in formset.deleted_forms:\n                for nested_formset in form.nested_formsets:\n                    self.save_formset(request, form, nested_formset, change)", "response": "Save the inline formset to the database."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef all_valid_with_nesting(self, formsets):\n        \"Recursively validate all nested formsets\"\n        if not all_valid(formsets):\n            return False\n\n        for formset in formsets:\n            if not formset.is_bound:\n                pass\n            for form in formset:\n                if hasattr(form, 'nested_formsets'):\n                    if not self.all_valid_with_nesting(form.nested_formsets):\n                        return False\n\n                    #TODO - find out why this breaks when extra = 1 and just adding new item with no sub items\n                    if (not hasattr(form, 'cleaned_data') or not form.cleaned_data) and self.formset_has_nested_data(form.nested_formsets):\n                        form._errors[\"__all__\"] = form.error_class([\"Parent object must be created when creating nested inlines.\"])\n                        return False\n        return True", "response": "Recursively validate all nested formsets"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef parse_line(self, line: str):\n        for i in KEYPAIR_RE.finditer(line):\n            key = i.group(1)\n            value = urllib.parse.unquote(i.group(2))\n            self[key] = value", "response": "Parse a line from database\n        into self."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nwrite the database to a file.", "response": "def save(self, file_path):\n        \"\"\"\n        Write database to a file. If a file with the specified name exists it's backed up\n        :param file_path: file path\n        \"\"\"\n        if os.path.isfile(file_path):\n            with open(self.get_backup_file_name(file_path), 'w') as d:\n                with open(file_path, 'r') as o:\n                    d.write(o.read())\n        elif os.path.exists(file_path):\n            raise XonoticDBException('%s exists and is not a file. Cannot write to it.', file_path)\n        lines = [''] * self.db_buckets\n        for key, value in self.items():\n            lines[self.hashfunc(key) % self.db_buckets] += r'\\%s\\%s' % (key, urllib.parse.quote(value))\n        with open(file_path, 'w') as f:\n            f.write('%d\\n' % self.db_buckets)\n            for i in lines:\n                f.write(i + '\\n')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nfiltering database key by pattern", "response": "def filter(self, key_pattern='*', is_regex=False):\n        \"\"\"\n        Filter database key by pattern\n        :param key_pattern: pattern (either glob or regex)\n        :param is_regex: should be True if the pattern is regex\n        :return: iterator of (key, value) pairs\n        \"\"\"\n        if is_regex:\n            if isinstance(key_pattern, str):\n                regex = re.compile(key_pattern)\n            else:\n                regex = key_pattern\n        else:\n            regex = None\n        for k, v in self.items():\n            if regex and regex.match(k) or (not regex) and fnmatch(k, key_pattern):\n                yield k, v"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef remove_cts_record(self, map, position):\n        def _key1(pos):\n            return '%s/cts100record/crypto_idfp%s' % (map, pos)\n\n        def _key2(pos):\n            return '%s/cts100record/time%s' % (map, pos)\n\n        for i in range(position, 100):\n            if _key1(i) in self:\n                del self[_key1(i)]\n            if _key2(i) in self:\n                del self[_key2(i)]\n            if _key1(i+1) in self:\n                self[_key1(i)] = self[_key1(i+1)]\n            if _key2(i+1) in self:\n                self[_key2(i)] = self[_key2(i+1)]", "response": "Removes a CTS record from the list."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nremoving all CTS records from the specified player", "response": "def remove_all_cts_records_by(self, crypto_idfp):\n        \"\"\"\n        Remove all CTS records from the specified player\n        :param crypto_idfp:\n        :return:\n        \"\"\"\n        regex = re.compile('(.+)/cts100record/crypto_idfp(\\d+)')\n        to_remove = []\n        for k, v in self.filter(regex, is_regex=True):\n            if v == crypto_idfp:\n                match = regex.match(k)\n                to_remove.append((match.group(1), int(match.group(2))))\n        for i in to_remove:\n            self.remove_cts_record(*i)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef merge_cts_records(self, crypto_idfp, crypto_idfp_list):\n        self.__merge_cts_times(crypto_idfp, crypto_idfp_list)\n        self.__merge_cts_speeds(crypto_idfp, crypto_idfp_list)\n        for i in crypto_idfp_list:\n            k = '/uid2name/{}'.format(i)\n            if k in self:\n                del self[k]", "response": "Merge all CTS records including speeds times and times of each player in crypto_idfp_list with records of crypto_idfp"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef parse_args(add_args, docstring):\n\n    def run_args():\n        \"\"\"Run any global methods eponymous with args\"\"\"\n        valuable_args = {k for k, v in args.__dict__.items() if v}\n        arg_methods = {globals()[a] for a in valuable_args if a in globals()}\n        if not arg_methods:\n            return\n        for method in arg_methods:\n            method()\n        raise SystemExit(_exit_ok)\n\n    parser = argparse.ArgumentParser(\n        description=docstring and docstring.splitlines()[0] or \"No docstring\")\n    result = add_args(parser)\n    parser = result if result else parser\n    parser.add_argument('-v', '--version', action='store_true',\n                        help='Show version [default: %s]' % __version__)\n    # parser.add_argument('-q', '--quiet', action='store_true',\n    # help='Do not show stdout')\n    # parser.add_argument('-Q', '--quiet_errors', action='store_true',\n    # help='Do not show stderr')\n    global args  # pylint: disable=global-statement\n    args = parser.parse_args()\n    run_args()\n    return args", "response": "Parse command line arguments and return a dictionary of arguments."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nrunning the method as a script", "response": "def main(method, add_args, version=None,\n         docstring=None, error_stream=sys.stderr):\n    \"\"\"Run the method as a script\n\n    Add a '--version' argument\n    Call add_args(parser) to add any more\n\n    Parse sys.argv\n    call method(args)\n    Catch any exceptions\n        exit on SystemExit or KeyboardError\n        Others:\n            If version is less then 1, reraise them\n            Else print them to the error stream\n    \"\"\"\n    if version:\n        _versions.append(version)\n    try:\n        args = parse_args(\n            add_args,\n            docstring and docstring or '%s()' % method.__name__)\n        return _exit_ok if method(args) else _exit_fail\n    except KeyboardInterrupt as e:\n        ctrl_c = 3\n        return ctrl_c\n    except SystemExit as e:\n        return e.code\n    except DebugExit:\n        return _exit_fail\n    except Exception as e:  # pylint: disable=broad-except\n        if int(latest_version().split('.')[0]) < 1:\n            raise\n        if error_stream:\n            print(e, file=error_stream)\n        return _exit_fail\n    return _exit_ok"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nloads and parse a pre - formatted and cleaned text file. Garbage in garbage out", "response": "def ingest(self, corpus_file):\n        ''' load and parse a pre-formatted and cleaned text file. Garbage in, garbage out '''\n        corpus = open(corpus_file)\n        total_letters = 0\n        total_words = 0\n        shortest_word = 100\n        for word in corpus.readlines():\n            # clean word\n            word = word.strip()\n            word = re.sub(r'[\\',\\.\\\"]', '', word)\n            total_letters += len(word)\n            total_words += 1\n            shortest_word = len(word) if len(word) < shortest_word else shortest_word\n\n            # iterate through n letter groups, where 1 <= n <= 3\n            n = self.chunk_size\n            start = 0\n            # >: C, Cys: t, yst: i\n            self.links[self.initial].append(word[0:n])\n            for position in range(n, len(word)):\n                start = position - n if position - n >= 0 else 0\n                base = word[start:position]\n                if not base in self.links:\n                    self.links[base] = []\n\n                self.links[base].append(word[position])\n            if not word[-n:] in self.links:\n                self.links[word[-n:]] = []\n            self.links[word[-n:]].append(self.terminal)\n\n        self.average_word_length = total_letters / total_words\n        self.shortest = shortest_word"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate a new word", "response": "def get_word(self, word=None):\n        ''' creates a new word '''\n        word = word if not word == None else self.initial\n        if not self.terminal in word:\n            if len(word) > self.average_word_length and \\\n                    self.terminal in self.links[word[-self.chunk_size:]] \\\n                    and random.randint(0, 1):\n                addon = self.terminal\n            else:\n                options = self.links[word[-self.chunk_size:]]\n                addon = random.choice(options)\n\n            word = word + addon\n            return self.get_word(word)\n        return word[1:-1]"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef existing_path(string):\n    '''\"Convert\" a string to a string that is a path to an existing file.'''\n    if not os.path.exists(string):\n        msg = 'path {0!r} does not exist'.format(string)\n        raise argparse.ArgumentTypeError(msg)\n    return string", "response": "Convert a string to a string that is a path to an existing file."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconvert a string to a string that is an absolute existing path.", "response": "def absolute_path(string):\n    '''\"Convert\" a string to a string that is an absolute existing path.'''\n    if not os.path.isabs(string):\n        msg = '{0!r} is not an absolute path'.format(string)\n        raise argparse.ArgumentTypeError(msg)\n    if not os.path.exists(os.path.dirname(string)):\n        msg = 'path {0!r} does not exist'.format(string)\n        raise argparse.ArgumentTypeError(msg)\n    return string"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _add_work_spec_args(self, parser):\n        '''Add ``--work-spec`` to an :mod:`argparse` `parser`.'''\n        parser.add_argument('-w', '--work-spec', dest='work_spec_path',\n                            metavar='FILE', type=existing_path,\n                            required=True,\n                            help='path to a YAML or JSON file')", "response": "Add the work - spec argument to an argparse parser."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the contents of the work spec from the arguments.", "response": "def _get_work_spec(self, args):\n        '''Get the contents of the work spec from the arguments.'''\n        with open(args.work_spec_path) as f:\n            return yaml.load(f)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _add_work_spec_name_args(self, parser):\n        '''Add either ``--work-spec`` or ``--work-spec-name`` to an\n        :mod:`argparse` `parser`.'''\n        group = parser.add_mutually_exclusive_group(required=True)\n        group.add_argument('-w', '--work-spec', dest='work_spec_path',\n                           metavar='FILE', type=existing_path,\n                           help='path to a YAML or JSON file')\n        group.add_argument('-W', '--work-spec-name', metavar='NAME',\n                           help='name of a work spec for queries')", "response": "Add either - W or - W work - spec or - W work - spec - name to an argparse parser."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _get_work_spec_name(self, args):\n        '''Get the name of the work spec from the arguments.\n\n        This assumes :meth:`_add_work_spec_name_args` has been called,\n        but will also work if just :meth:`_add_work_spec_args` was\n        called instead.\n\n        '''\n        if getattr(args, 'work_spec_name', None):\n            return args.work_spec_name\n        return self._get_work_spec(args)['name']", "response": "Get the name of the work spec from the arguments."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _read_work_units_file(self, work_units_fh):\n        '''work_units_fh is iterable on lines (could actually be ['{}',...])\n        '''\n        count = 0\n        for line in work_units_fh:\n            if not line:\n                continue\n            line = line.strip()\n            if not line:\n                continue\n            if line[0] == '#':\n                continue\n            try:\n                count += 1\n                work_unit = json.loads(line)\n                #work_units.update(work_unit)\n                for k,v in work_unit.iteritems():\n                    yield k,v\n            except:\n                logger.error('failed handling work_unit on line %s: %r', count, line, exc_info=True)\n                raise", "response": "Reads the contents of a file and returns a generator of the keys and values for each entry in the work_units dictionary."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef do_load(self, args):\n        '''loads work_units into a namespace for a given work_spec\n\n        --work-units file is JSON, one work unit per line, each line a\n        JSON dict with the one key being the work unit key and the\n        value being a data dict for the work unit.\n\n        '''\n        work_spec = self._get_work_spec(args)\n        work_spec['nice'] = args.nice\n        self.task_master.set_work_spec(work_spec)\n\n        if args.no_work:\n            work_units_fh = []  # it just has to be an iterable with no lines\n        else:\n            work_units_fh = self._work_units_fh_from_path(args.work_units_path)\n            if work_units_fh is None:\n                raise RuntimeError('need -u/--work-units or --no-work')\n        self.stdout.write('loading work units from {0!r}\\n'\n                          .format(work_units_fh))\n        work_units = dict(self._read_work_units_file(work_units_fh))\n\n        if work_units:\n            self.stdout.write('pushing work units\\n')\n            self.task_master.add_work_units(work_spec['name'], work_units.items())\n            self.stdout.write('finished writing {0} work units to work_spec={1!r}\\n'\n                              .format(len(work_units), work_spec['name']))\n        else:\n            self.stdout.write('no work units. done.\\n')", "response": "loads a given work_units into a namespace for a given work_spec"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef do_delete(self, args):\n        '''delete the entire contents of the current namespace'''\n        namespace = self.config['namespace']\n        if not args.assume_yes:\n            response = raw_input('Delete everything in {0!r}?  Enter namespace: '\n                                 .format(namespace))\n            if response != namespace:\n                self.stdout.write('not deleting anything\\n')\n                return\n        self.stdout.write('deleting namespace {0!r}\\n'.format(namespace))\n        self.task_master.clear()", "response": "delete the entire contents of the current namespace"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef do_work_specs(self, args):\n        '''print the names of all of the work specs'''\n        work_spec_names = [x['name'] for x in self.task_master.iter_work_specs()]\n        work_spec_names.sort()\n        for name in work_spec_names:\n            self.stdout.write('{0}\\n'.format(name))", "response": "print the names of all of the work specs"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef do_work_spec(self, args):\n        '''dump the contents of an existing work spec'''\n        work_spec_name = self._get_work_spec_name(args)\n        spec = self.task_master.get_work_spec(work_spec_name)\n        if args.json:\n            self.stdout.write(json.dumps(spec, indent=4, sort_keys=True) +\n                              '\\n')\n        else:\n            yaml.safe_dump(spec, self.stdout)", "response": "dump the contents of an existing work spec"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef do_status(self, args):\n        '''print the number of work units in an existing work spec'''\n        work_spec_name = self._get_work_spec_name(args)\n        status = self.task_master.status(work_spec_name)\n        self.stdout.write(json.dumps(status, indent=4, sort_keys=True) +\n                          '\\n')", "response": "print the number of work units in an existing work spec"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nprint a summary of running rejester work", "response": "def do_summary(self, args):\n        '''print a summary of running rejester work'''\n        assert args.json or args.text or (args.text is None)\n        do_text = args.text\n\n        xd = {}\n        for ws in self.task_master.iter_work_specs():\n            name = ws['name']\n            status = self.task_master.status(name)\n            xd[name] = status\n        xd['_NOW'] = time.time()\n\n        if args.json:\n            self.stdout.write(json.dumps(xd) + '\\n')\n        else:\n            if do_text is None:\n                do_text = True\n\n        if do_text:\n            self.stdout.write('Work spec               Avail  Pending  Blocked'\n                              '   Failed Finished    Total\\n')\n            self.stdout.write('==================== ======== ======== ========'\n                              ' ======== ======== ========\\n')\n            for name in sorted(xd.keys()):\n                if name == '_NOW':\n                    continue\n                status = xd[name]\n                self.stdout.write('{0:20s} {1[num_available]:8d} '\n                                  '{1[num_pending]:8d} {1[num_blocked]:8d} '\n                                  '{1[num_failed]:8d} {1[num_finished]:8d} '\n                                  '{1[num_tasks]:8d}\\n'.format(name, status))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nlist work units that have not yet completed", "response": "def do_work_units(self, args):\n        '''list work units that have not yet completed'''\n        work_spec_name = self._get_work_spec_name(args)\n        if args.status:\n            status = args.status.upper()\n            statusi = getattr(self.task_master, status, None)\n            if statusi is None:\n                self.stdout.write('unknown status {0!r}\\n'.format(args.status))\n                return\n        else:\n            statusi = None\n        work_units = dict(self.task_master.get_work_units(\n            work_spec_name, state=statusi, limit=args.limit))\n        work_unit_names = sorted(work_units.keys())\n        if args.limit:\n            work_unit_names = work_unit_names[:args.limit]\n        for k in work_unit_names:\n            if args.details:\n                tback = work_units[k].get('traceback', '')\n                if tback:\n                    tback += '\\n'\n                    work_units[k]['traceback'] = 'displayed below'\n                self.stdout.write(\n                    '{0!r}: {1}\\n{2}'\n                    .format(k, pprint.pformat(work_units[k], indent=4),\n                            tback))\n            else:\n                self.stdout.write('{0}\\n'.format(k))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef do_work_unit(self, args):\n        '''print basic details about work units'''\n        work_spec_name = self._get_work_spec_name(args)\n        for work_unit_name in args.unit:\n            status = self.task_master.get_work_unit_status(work_spec_name,\n                                                           work_unit_name)\n            self.stdout.write('{0} ({1!r})\\n'\n                              .format(work_unit_name, status['status']))\n            if 'expiration' in status:\n                when = time.ctime(status['expiration'])\n                if status == 'available':\n                    if status['expiration'] == 0:\n                        self.stdout.write('  Never scheduled\\n')\n                    else:\n                        self.stdout.write('  Available since: {0}\\n'\n                                          .format(when))\n                else:\n                    self.stdout.write('  Expires: {0}\\n'.format(when))\n            if 'worker_id' in status:\n                try:\n                    heartbeat = self.task_master.get_heartbeat(status['worker_id'])\n                except:\n                    heartbeat = None\n                if heartbeat:\n                    hostname = (heartbeat.get('fqdn', None) or\n                                heartbeat.get('hostname', None) or\n                                '')\n                    ipaddrs = ', '.join(heartbeat.get('ipaddrs', ()))\n                    if hostname and ipaddrs:\n                        summary = '{0} on {1}'.format(hostname, ipaddrs)\n                    else:\n                        summary = hostname + ipaddrs\n                else:\n                    summary = 'No information'\n                self.stdout.write('  Worker: {0} ({1})\\n'.format(\n                    status['worker_id'], summary))\n            if 'traceback' in status:\n                self.stdout.write('  Traceback:\\n{0}\\n'.format(\n                    status['traceback']))\n            if 'depends_on' in status:\n                self.stdout.write('  Depends on:\\n')\n                for what in status['depends_on']:\n                    self.stdout.write('    {0!r}\\n'.format(what))", "response": "print basic details about work units"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef do_retry(self, args):\n        '''retry a specific failed job'''\n        work_spec_name = self._get_work_spec_name(args)\n        retried = 0\n        complained = False\n        try:\n            if args.all:\n                while True:\n                    units = self.task_master.get_work_units(\n                        work_spec_name, limit=1000,\n                        state=self.task_master.FAILED)\n                    units = [u[0] for u in units]  # just need wu key\n                    if not units: break\n                    try:\n                        self.task_master.retry(work_spec_name, *units)\n                        retried += len(units)\n                    except NoSuchWorkUnitError, e:\n                        # Because of this sequence, this probably means\n                        # something else retried the work unit.  If we\n                        # try again, we shouldn't see it in the failed\n                        # list...so whatever\n                        pass\n            else:\n                units = args.unit\n                try:\n                    self.task_master.retry(work_spec_name, *units)\n                    retried += len(units)\n                except NoSuchWorkUnitError, e:\n                    unit = e.work_unit_name\n                    self.stdout.write('No such failed work unit {0!r}.\\n'\n                                      .format(unit))\n                    complained = True\n                    units.remove(unit)\n                    # and try again\n        except NoSuchWorkSpecError, e:\n            # NB: you are not guaranteed to get this, especially with --all\n            self.stdout.write('Invalid work spec {0!r}.\\n'\n                              .format(work_spec_name))\n            return\n        if retried == 0 and not complained:\n            self.stdout.write('Nothing to do.\\n')\n        elif retried == 1:\n            self.stdout.write('Retried {0} work unit.\\n'.format(retried))\n        elif retried > 1:\n            self.stdout.write('Retried {0} work units.\\n'.format(retried))", "response": "retry a specific failed job"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nremoving work units from a work spec", "response": "def do_clear(self, args):\n        '''remove work units from a work spec'''\n        # Which units?\n        work_spec_name = self._get_work_spec_name(args)\n        units = args.unit or None\n        # What to do?\n        count = 0\n        if args.status is None:\n            all = units is None\n            count += self.task_master.del_work_units(work_spec_name, work_unit_keys=units, all=all)\n        elif args.status == 'available':\n            count += self.task_master.del_work_units(\n                work_spec_name, work_unit_keys=units, state=self.task_master.AVAILABLE)\n        elif args.status == 'pending':\n            count += self.task_master.del_work_units(\n                work_spec_name, work_unit_keys=units, state=self.task_master.PENDING)\n        elif args.status == 'blocked':\n            count += self.task_master.del_work_units(\n                work_spec_name, work_unit_keys=units, state=self.task_master.BLOCKED)\n        elif args.status == 'finished':\n            count += self.task_master.del_work_units(\n                work_spec_name, work_unit_keys=units, state=self.task_master.FINISHED)\n        elif args.status == 'failed':\n            count += self.task_master.del_work_units(\n                work_spec_name, work_unit_keys=units, state=self.task_master.FAILED)\n        self.stdout.write('Removed {0} work units.\\n'.format(count))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting or set the global rejester worker mode'''", "response": "def do_mode(self, args):\n        '''get or set the global rejester worker mode'''\n        if args.mode:\n            mode = { 'idle': self.task_master.IDLE,\n                     'run': self.task_master.RUN,\n                     'terminate': self.task_master.TERMINATE }[args.mode]\n            self.task_master.set_mode(mode)\n            self.stdout.write('set mode to {0!r}\\n'.format(args.mode))\n        else:\n            mode = self.task_master.get_mode()\n            self.stdout.write('{0!s}\\n'.format(mode))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreading or clear the global lock", "response": "def do_global_lock(self, args):\n        '''read (or clear) the global lock'''\n        if args.purge:\n            self.task_master.registry.force_clear_lock()\n        else:\n            owner = self.task_master.registry.read_lock()\n            if owner:\n                heartbeat = self.task_master.get_heartbeat(owner)\n                if 'hostname' in heartbeat:\n                    self.stdout.write('{0} ({1})\\n'.format(owner,\n                                                         heartbeat['hostname']))\n                else:\n                    self.stdout.write('{0}\\n'.format(owner))\n            else:\n                self.stdout.write('(unlocked)\\n')"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef do_workers(self, args):\n        '''list all known workers'''\n        workers = self.task_master.workers(alive=not args.all)\n        for k in sorted(workers.iterkeys()):\n            self.stdout.write('{0} ({1})\\n'.format(k, workers[k]))\n            if args.details:\n                heartbeat = self.task_master.get_heartbeat(k)\n                for hk, hv in heartbeat.iteritems():\n                    self.stdout.write('  {0}: {1}\\n'.format(hk, hv))", "response": "list all known workers"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nrunning a single job", "response": "def do_run_one(self, args):\n        '''run a single job'''\n        work_spec_names = args.from_work_spec or None\n        worker = SingleWorker(self.config, task_master=self.task_master, work_spec_names=work_spec_names, max_jobs=args.max_jobs)\n        worker.register()\n        rc = False\n        starttime = time.time()\n        count = 0\n        try:\n            while True:\n                rc = worker.run()\n                if not rc:\n                    break\n                count += 1\n                if (args.limit_seconds is None) and (args.limit_count is None):\n                    # only do one\n                    break\n                if (args.limit_seconds is not None) and ((time.time() - starttime) >= args.limit_seconds):\n                    break\n                if (args.limit_count is not None) and (count >= args.limit_count):\n                    break\n        finally:\n            worker.unregister()\n        if not rc:\n            self.exitcode = 2"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef make_phase_space_list():\n    with open('dynac.short') as f:\n        data_str = ''.join(line for line in f.readlines())\n        data_str_array = data_str.split('beam (emit card)')[1:]\n        data_str_matrix = [[j.strip().split() for j in i] for i in[chunk.split('\\n')[1:8] for chunk in data_str_array]]\n\n        return [PhaseSpace(data) for data in data_str_matrix]", "response": "Extract all the phase space information from the input\n    and create a list of PhaseSpace objects."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_number_of_particles():\n    with open('dynac.short') as f:\n        data_str = ''.join(line for line in f.readlines())\n        num_of_parts = int(data_str.split('Simulation with')[1].strip().split()[0])\n    return num_of_parts", "response": "Queries the dynac. short file for the number of particles used in the\n    simulation."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nusing a ProcessPool from the ``concurrent.futures`` module to execute ``num_iters`` number of instances of ``pynac_func``. This function takes advantage of ``do_single_dynac_process`` and ``pynac_in_sub_directory``.", "response": "def multi_process_pynac(file_list, pynac_func, num_iters=100, max_workers=8):\n    \"\"\"\n    Use a ProcessPool from the ``concurrent.futures`` module to execute ``num_iters``\n    number of instances of ``pynac_func``.  This function takes advantage of ``do_single_dynac_process``\n    and ``pynac_in_sub_directory``.\n    \"\"\"\n    with ProcessPoolExecutor(max_workers=max_workers) as executor:\n        tasks = [executor.submit(do_single_dynac_process, num, file_list, pynac_func) for num in range(num_iters)]\n    exc = [task.exception() for task in tasks if task.exception()]\n    if exc:\n        return exc\n    else:\n        return \"No errors encountered\""}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef pynac_in_sub_directory(num, file_list):\n        print('Running %d' % num)\n        new_dir = 'dynacProc_%04d' % num\n        if os.path.isdir(new_dir):\n            shutil.rmtree(new_dir)\n        os.mkdir(new_dir)\n        for f in file_list:\n            shutil.copy(f, new_dir)\n        os.chdir(new_dir)\n\n        yield\n\n        os.chdir('..')", "response": "A context manager to create a new directory and move the files listed in file_list to the new directory and then close the context to the original directory."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nrun the simulation in the current directory.", "response": "def run(self):\n        \"\"\"\n        Run the simulation in the current directory.\n        \"\"\"\n        self._start_dynac_proc(stdin=subp.PIPE, stdout=subp.PIPE)\n        str2write = self.name + '\\r\\n'\n        if self._DEBUG:\n            with open('pynacrun.log', 'a') as f:\n                f.write(str2write)\n        self.dynacProc.stdin.write(str2write.encode())  # The name field\n        for pynEle in self.lattice:\n            try:\n                ele = pynEle.dynacRepresentation()\n            except AttributeError:\n                ele = pynEle\n            str2write = ele[0]\n            if self._DEBUG:\n                with open('pynacrun.log', 'a') as f:\n                    f.write(str2write + '\\r\\n')\n            try:\n                self.dynacProc.stdin.write((str2write + '\\r\\n').encode())\n            except IOError:\n                break\n            for datum in ele[1]:\n                str2write = ' '.join([str(i) for i in datum])\n                if self._DEBUG:\n                    with open('pynacrun.log', 'a') as f:\n                        f.write(str2write+'\\r\\n')\n                try:\n                    self.dynacProc.stdin.write((str2write+'\\r\\n').encode())\n                except IOError:\n                    break\n        self.dynacProc.stdin.close()\n        if self.dynacProc.wait() != 0:\n            raise RuntimeError(\"Errors occured during execution of Dynac\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_x_inds(self, *dynac_type):\n        return [i for i, x in enumerate(self.lattice) for y in dynac_type if dynac_from_ele(x) == y]", "response": "Return the indices into the lattice list attribute of elements whose Dynac\n        type matches the input string."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the indices into the lattice list attribute of elements whose Dynac type matches the input string.", "response": "def get_x_objs(self, *dynac_type):\n        \"\"\"\n        Return the indices into the lattice list attribute of elements whose Dynac\n        type matches the input string.  Multiple input strings can be given, either\n        as a comma-separated list or as a genuine Python list.\n        \"\"\"\n        return [i for i in self.lattice for y in dynac_type if dynac_from_ele(i) == y]"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsubstitutes all the global variables in config_dict with values defined in _ALLOWED.", "response": "def _substitute_globals(config_dict):\n    \"\"\"\n    Set global variables to values defined in `config_dict`.\n\n    Args:\n        config_dict (dict): dict with data, which are used to set `globals`.\n\n    Note:\n        `config_dict` have to be dictionary, or it is ignored. Also all\n        variables, that are not already in globals, or are not types defined in\n        :attr:`_ALLOWED` (str, int, ..) or starts with ``_`` are silently\n        ignored.\n    \"\"\"\n    constants = _get_all_constants()\n\n    if type(config_dict) != dict:\n        return\n\n    for key, val in config_dict.iteritems():\n        if key in constants and type(val) in _ALLOWED:\n            globals()[key] = val"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _read_from_paths():\n    home = os.environ.get(\"HOME\", \"/\")\n    home_path = os.path.join(home, _SETTINGS_PATH)\n    etc_path = os.path.join(\"/etc\", _SETTINGS_PATH)\n\n    read_path = None\n    if home and os.path.exists(home_path):\n        read_path = home_path\n    elif os.path.exists(etc_path):\n        read_path = etc_path\n\n    if read_path:\n        with open(read_path) as f:\n            _substitute_globals(\n                json.loads(f.read())\n            )", "response": "Try to read data from configuration paths."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset a instance method to be call as a wsgi application, adding common behavior and using webob.Request for practical use. @wsgi_handler def handle_verify_token(self, request): pass :param func: :return:", "response": "def wsgi_handler(func):\n    \"\"\"\n    Set a instance method to be call as a wsgi application, adding common\n    behavior and using webob.Request for practical use.\n\n\n    @wsgi_handler\n    def handle_verify_token(self, request):\n        pass\n\n    :param func:\n    :return:\n    \"\"\"\n\n    @wraps(func)\n    def inner(*args):\n        self, environ, start_response, *args = args\n        request = Request(environ)\n\n        try:\n            response = func(self, request)\n        except Exception as err:\n            raise\n        else:\n            return response(environ, start_response)\n\n    return inner"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef format(self, format_target, remove_obsolete=True):\n        original_format, original_format_order = (self.format, self.format_order)\n\n        try:\n            format_target = self.CFG.get(format_target, return_type=str, throw_null_return_error=True)\n        except (errors.ResourceNotFoundError, KeyError):\n            pass\n\n        self.format_string_object.swap_format(format_target)\n        self._update_tokens_from_swap_format(original_format, original_format_order, remove_obsolete=remove_obsolete)", "response": "Changes the internal self. format_string_object format target based on input."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ninitializes the format options for the current locale.", "response": "def initialize_format_options(self, format_target=''):\n        \"\"\" First attempts to use format_target as a config path or gets the default format\n            if it's invalid or is empty.\n\n        :param format_target: (str, list(str)), can be either a query path to a format\n                                                or in format of a naming string the sections should be spaced around\n                                                e.g. - this_is_a_naming_string\n        :raises: IOError\n        \"\"\"\n        try:\n            if format_target:\n                self.format = format_target\n            else:\n                raise errors.FormatError\n        except errors.FormatError:\n            self.format_string_object.swap_format(self.CFG.get(self.DEFAULT_FORMAT_PATH, return_type=str))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nstoring options from the config file", "response": "def initialize_options(cls):\n        \"\"\" Stores options from the config file\n\n        \"\"\"\n        cls.CONFIG_OPTIONS = cls.CFG.get(cls.CONFIG_PATH, return_type=dict)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the string of the current name of the object", "response": "def get(self, **kwargs):\n        \"\"\"Gets the string of the current name of the object\n        Returns (string): the name of the object\n        \"\"\"\n        old_state = self.state.copy()\n        self.merge_dict(kwargs)\n        result = rendering.InputRenderer.render_nomenclative(self)\n        self.merge_dict(old_state)\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ntakes variable inputs compiles them into a dictionary then merges it to the current nomenclate s state", "response": "def merge_dict(self, *args, **kwargs):\n        \"\"\" Takes variable inputs, compiles them into a dictionary then merges it to the current nomenclate's state\n\n        :param args: (dict, Nomenclate), any number of dictionary inputs or Nomenclates to be converted to dicts\n        :param kwargs: str, any number of kwargs that represent token:value pairs\n        \"\"\"\n        input_dict = self._convert_input(*args, **kwargs)\n        if input_dict:\n            self._sift_and_init_configs(input_dict)\n            self.token_dict.merge_serialization(input_dict)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the value for a specific token as a dictionary or replace with default", "response": "def get_token_settings(cls, token, default=None):\n        \"\"\" Get the value for a specific token as a dictionary or replace with default\n\n        :param token: str, token to query the nomenclate for\n        :param default: object, substitution if the token is not found\n        :return: (dict, object, None), token setting dictionary or default\n        \"\"\"\n        setting_dict = {}\n\n        for key, value in iteritems(cls.__dict__):\n            if '%s_' % token in key and not callable(key) and not isinstance(value, tokens.TokenAttr):\n                setting_dict[key] = cls.__dict__.get(key, default)\n        return setting_dict"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ntaking variable inputs and returns a dictionary of all inputs with the same names as the input.", "response": "def _convert_input(self, *args, **kwargs):\n        \"\"\" Takes variable inputs\n\n        :param args: (dict, Nomenclate), any number of dictionary inputs or Nomenclates to be converted to dicts\n        :param kwargs: str, any number of kwargs that represent token:value pairs\n        :return: dict, combined dictionary of all inputs\n        \"\"\"\n        args = [arg.state if isinstance(arg, Nomenclate) else arg for arg in args]\n        input_dict = combine_dicts(*args, **kwargs)\n        return input_dict"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _sift_and_init_configs(self, input_dict):\n        configs = {}\n        for k, v in iteritems(input_dict):\n            if (k not in map(str.lower, self.format_order) and\n                    any([f_order.lower() in k for f_order in self.format_order])):\n                try:\n                    self.CFG.get(self.CONFIG_PATH + [k])\n                except errors.ResourceNotFoundError:\n                    pass\n                finally:\n                    configs[k] = v\n\n        for key, val in iteritems(configs):\n            input_dict.pop(key, None)\n        if configs:\n            self.initialize_overall_config_settings(input_dict=configs)", "response": "This method is called by _sift_and_init_config_settings when we re going to initialize the overall config settings."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nchanges CustomCarry seed example: change_custom_seed([1,2,3]) # then CustomCarry.SEED_LIST == '123' is True :param seed: :return:", "response": "def change_custom_seed(seed):\n    \"\"\"\n    change CustomCarry seed\n    example:\n    change_custom_seed([1,2,3])  # then CustomCarry.SEED_LIST == '123' is True\n    :param seed:\n    :return:\n    \"\"\"\n    if isinstance(seed, (basestring, list, tuple)):\n        seed = Seed(seed)\n    if isinstance(seed, Seed):\n        CustomCarry.SEED_LIST = seed"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef matchiter(r, s, flags=0):\n    if isinstance(r, basestring):\n        r = re.compile(r, flags)\n    i = 0\n    while s:\n        m = r.match(s)\n        g = m and m.group(0)\n        if not m or not g:\n            raise ValueError(\"{}: {!r}\".format(i, s[:50]))\n        i += len(g)\n        s = s[len(g):]\n        yield m", "response": "Yields contiguous MatchObjects of r in s. Raises ValueError if r doesn t match contiguously."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the list of contiguous string matches of r in s or None if r does not successively match the entire s.", "response": "def matchall(r, s, flags=0):\n    \"\"\"\n    Returns the list of contiguous string matches of r in s,\n    or None if r does not successively match the entire s.\n    \"\"\"\n    try:\n        return [m.group(0) for m in matchiter(r, s, flags)]\n    except ValueError:\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nvalidate the configuration of an object within this.", "response": "def check_subconfig(config, name, sub):\n    \"\"\"Validate the configuration of an object within this.\n\n    This calls :meth:`Configurable.check_config` or equivalent on `sub`.\n    A dictionary configuration for `sub` is required in `config`.\n\n    >>> def check_config(config, name):\n    ...     for sub in sub_modules:\n    ...         check_subconfig(config, name, sub)\n\n    :param dict config: parent configuration\n    :param str name: name of the parent configuration block\n    :param sub: Configurable-like subobject to check\n    :raise yakonfig.ConfigurationError: if there is no\n      configuration for `sub`, or it is not a dictionary\n\n    \"\"\"\n    subname = sub.config_name\n    subconfig = config.setdefault(subname, {})\n    if not isinstance(subconfig, collections.Mapping):\n        raise ProgrammerError('configuration for {0} in {1} must be a mapping'\n                              .format(subname, name))\n    checker = getattr(sub, 'check_config', None)\n    if checker is not None:\n        checker(subconfig, '{0}.{1}'.format(name, subname))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nprocess a CMOR style file path.", "response": "def get_cmor_fp_meta(fp):\n    \"\"\"Processes a CMOR style file path.\n\n    Section 3.1 of the `Data Reference Syntax`_ details:\n\n        The standard CMIP5 output tool CMOR optionally writes output files\n        to a directory structure mapping DRS components to directory names as:\n\n            <activity>/<product>/<institute>/<model>/<experiment>/<frequency>/\n            <modeling_realm>/<variable_name>/<ensemble_member>/<CMOR filename>.nc\n\n    Arguments:\n        fp (str): A file path conforming to DRS spec.\n\n    Returns:\n        dict: Metadata as extracted from the file path.\n\n    .. _Data Reference Syntax:\n       http://cmip-pcmdi.llnl.gov/cmip5/docs/cmip5_data_reference_syntax.pdf\n    \"\"\"\n\n    # Copy metadata list then reverse to start at end of path\n    directory_meta = list(CMIP5_FP_ATTS)\n\n    # Prefer meta extracted from filename\n    meta = get_dir_meta(fp, directory_meta)\n    meta.update(get_cmor_fname_meta(fp))\n\n    return meta"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_datanode_fp_meta(fp):\n\n    # Copy metadata list then reverse to start at end of path\n    directory_meta = list(CMIP5_DATANODE_FP_ATTS)\n\n    # Prefer meta extracted from filename\n    meta = get_dir_meta(fp, directory_meta)\n    meta.update(get_cmor_fname_meta(fp))\n\n    return meta", "response": "Processes a datanode style file path."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nprocessing a CMOR style file name.", "response": "def get_cmor_fname_meta(fname):\n    \"\"\"Processes a CMOR style file name.\n\n    Section 3.3 of the `Data Reference Syntax`_ details:\n\n        filename = <variable name>_<mip_table>_<model>_<experiment>_\n            <ensemble_member>[_<temporal_subset>][_<geographical_info>].nc\n\n    Temporal subsets are detailed in section 2.4:\n\n        Time instants or periods will be represented by a construction\n        of the form \u201cN1-N2\u201d, where N1 and N2 are of the form\n        \u2018yyyy[MM[dd[hh[mm[ss]]]]][-suffix]\u2019, where \u2018yyyy\u2019, \u2018MM\u2019, \u2018dd\u2019,\n        \u2018hh\u2019 \u2018mm\u2019 and \u2018ss\u2019 are integer year, month, day, hour, minute,\n        and second, respectively, and the precision with which time is\n        expressed must unambiguously resolve the interval between\n        timesamples contained in the file or virtual file\n\n    Geographic subsets are also detailed in section 2.4:\n\n        The DRS specification for this indicator is a string of the\n        form g-XXXX[-YYYY]. The \u201cg-\u201d indicates that some spatial selection\n        or processing has been done (i.e., selection of a sub-global region\n        and possibly spatial averaging).\n\n    Arguments:\n        fname (str): A file name conforming to DRS spec.\n\n    Returns:\n        dict: Metadata as extracted from the filename.\n\n    .. _Data Reference Syntax:\n       http://cmip-pcmdi.llnl.gov/cmip5/docs/cmip5_data_reference_syntax.pdf\n    \"\"\"\n    if '/' in fname:\n        fname = os.path.split(fname)[1]\n    fname = os.path.splitext(fname)[0]\n    meta = fname.split('_')\n\n    res = {}\n\n    try:\n        for key in CMIP5_FNAME_REQUIRED_ATTS:\n            res[key] = meta.pop(0)\n    except IndexError:\n        raise PathError(fname)\n\n    # Determine presence and order of optional metadata\n    if len(meta) > 2:\n        raise PathError(fname)\n\n    is_geo = lambda x: x[0] == 'g'\n\n    for key in meta:\n        if is_geo(key):\n            res['geographical_info'] = key\n        else:\n            res['temporal_subset'] = key\n\n    return res"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_ansible_groups(group_map):\n    # Some of this logic is cribbed from\n    # ansible.inventory.script.InventoryScript\n    all_hosts = {}\n    group_all = Group('all')\n    groups = [group_all]\n    for gname, hosts in group_map.iteritems():\n        g = Group(gname)\n        for host in hosts:\n            h = all_hosts.get(host, Host(host))\n            all_hosts[host] = h\n            g.add_host(h)\n            group_all.add_host(h)\n        group_all.add_child_group(g)\n        groups.append(g)\n    return groups", "response": "Constructs a list of ansible. inventory. group. Group objects from a dict of host names to hosts."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef run(self, once=False):\n        self._once = once\n        self.start()\n        while self.running:\n            try:\n                time.sleep(1.0)\n            except KeyboardInterrupt:\n                self.stop()\n                self.join()", "response": "Runs the reactor in the main thread."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconvert the filename of a cleartext file and convert it to an encrypted filename", "response": "def clear_to_enc_filename(fname):\n    \"\"\"\n    Converts the filename of a cleartext file and convert it to an encrypted filename\n\n    :param fname:\n    :return: filename of encrypted secret file if found, else None\n    \"\"\"\n    if not fname.lower().endswith('.json'):\n        raise CredkeepException('Invalid filetype')\n\n    if fname.lower().endswith('.enc.json'):\n        raise CredkeepException('File already encrypted')\n\n    enc_fname = fname[:-4] + 'enc.json'\n\n    return enc_fname if exists(enc_fname) else None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nconverting the filename of an encrypted file to cleartext", "response": "def enc_to_clear_filename(fname):\n    \"\"\"\n    Converts the filename of an encrypted file to cleartext\n\n    :param fname:\n    :return: filename of clear secret file if found, else None\n    \"\"\"\n    if not fname.lower().endswith('.json'):\n        raise CredkeepException('Invalid filetype')\n\n    if not fname.lower().endswith('.enc.json'):\n        raise CredkeepException('Not filename of encrypted file')\n\n    clear_fname = fname.replace('.enc.json', '.json')\n    print clear_fname\n\n    return clear_fname if exists(clear_fname) else None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncalculating a 2 - d histogram of two vectors x and y", "response": "def calc_2d_hist(x, y, step=None, min_pt=None, max_pt=None):\n    \"\"\"\n    given two vectors x and y, calculate a 2-d histogram matrix\n    x = data list\n    y = data list\n    step = either a scalar dx/dy, or a tuple (dx,dy)\n    min = tuple for lower left of bounding box (minx, miny)\n    max = tuple for upper right of bounding box\n\n    returns: a tuple (x_vec, y_vec, hist_matrix)\n    \"\"\"\n\n    # rough data boundary    \n    minx = min(x)    \n    maxx = max(x)\n    miny = min(y)\n    maxy = max(y)         \n    \n    # step\n    if step is None:\n        default_bins = 100\n        default_steps = [1e-6, 1e-5, 1e-4, 1e-3, 1e-2,\n                         1, 10, 100, 1000, 1e4, 1e5, 1e6]\n\n        stepx_raw = (maxx - minx)/default_bins\n        stepx = min(default_steps, key=lambda x: abs(x - stepx_raw))\n\n        stepy_raw = (maxy - miny)/default_bins\n        stepy = min(default_steps, key=lambda x: abs(x - stepy_raw))\n    \n        step = (stepx, stepy)\n    elif isinstance(step, (int, float)):  \n        step = (step, step)\n    \n    # set rounding accuracy for min/max\n    x_acc = step[0]\n    y_acc = step[1]\n    \n    # set real data boundary defaults\n    minx = util.floor_nearest(minx, x_acc)\n    maxx = util.ceil_nearest(maxx, x_acc)\n    miny = util.floor_nearest(miny, y_acc)\n    maxy = util.ceil_nearest(maxy, y_acc)\n    \n    # min and max pt\n    if min_pt is None:\n        min_pt = (minx, miny)\n\n    if max_pt is None:\n        max_pt = (maxx, maxy)\n\n    # use output dict to store bin values\n    bin_dict = {}\n    for x0, y0 in zip(x, y):\n        x0 = util.floor_nearest(x0, step[0])\n        y0 = util.floor_nearest(y0, step[1])\n        util.increment(bin_dict, (x0, y0))\n\n    # turn dict into matrix\n    x_vec = [n for n in util.frange(min_pt[0], max_pt[0], step[0])]\n    y_vec = [n for n in util.frange(min_pt[1], max_pt[1], step[1])]\n\n    hist_matrix = []\n\n    for yi in y_vec:\n        row = []\n        for xj in x_vec:\n            key = (xj, yi)\n            if key in bin_dict:\n                row.append(bin_dict[key])\n            else:\n                row.append(0)\n        hist_matrix.append(row)\n\n    # return matrix\n    return (x_vec, y_vec, hist_matrix)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef init_heatmap(x_vec, y_vec, hist_matrix, fig, colormap='Blues',\n                 alpha=1, grid=False, colorbar=True,\n                 vmax='auto', vmin='auto', crop=True):\n    \"\"\"\n    convenience function to initialize a standard colormap in a figure\n    \"\"\"\n    plt.figure(fig.number)\n    ax = fig.gca()\n\n    # set vmax and vmin\n    vma = np.amax(hist_matrix) if vmax == 'auto' else vmax\n    vmi = np.amin(hist_matrix) if vmin == 'auto' else vmin\n\n    # an error check\n    if vma <= vmi:\n        vma = vmi + 1\n\n    # grid the space for pcolormesh\n    x_grid, y_grid = np.meshgrid(x_vec, y_vec)\n\n    hmap = ax.pcolormesh(x_grid, y_grid, np.array(hist_matrix),\n               cmap=colormap, alpha=alpha, shading='gouraud',\n               vmax=vma, vmin=vmi)\n\n    if colorbar:\n        plt.colorbar(hmap)\n\n    if not grid:\n        ax.grid(False)\n\n    if crop:\n        ax.set_xlim([x_vec[0], x_vec[-1]])\n        ax.set_ylim([y_vec[0], y_vec[-1]])", "response": "Initializes a heatmap with the given colormap and a histogram matrix."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef heatmap(x, y, step=None, min_pt=None, max_pt=None,\n                 colormap='Blues', alpha=1, grid=False,\n                 colorbar=True, scale='lin',\n                 vmax='auto', vmin='auto', crop=True):\n    \"\"\"\n    function to take vectors x and y and hist them\n    \"\"\"\n    (x_vec, y_vec, hist_matrix) = calc_2d_hist(x, y, step, min_pt, max_pt)\n\n    # simple in this case because it is positive counts\n    if scale == 'log':\n        for row in hist_matrix:\n            for i, el in enumerate(row):\n                row[i] = 0 if row[i] == 0 else log10(row[i])\n\n    # plot\n    fig = plt.figure()\n    init_heatmap(x_vec, y_vec, hist_matrix, fig, colormap=colormap,\n                 alpha=alpha, grid=grid, colorbar=colorbar,\n                 vmax=vmax, vmin=vmin, crop=crop)\n\n    return fig", "response": "function to plot a heatmap"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the language of the extension in the specified extensions.", "response": "def ext_language(ext, exts=None):\n    \"\"\"Language of the extension in those extensions\n\n    If exts is supplied, then restrict recognition to those exts only\n    If exts is not supplied, then use all known extensions\n\n    >>> ext_language('.py') == 'python'\n    True\n    \"\"\"\n    languages = {\n        '.py': 'python',\n        '.py2': 'python2',\n        '.py3': 'python3',\n        '.sh': 'bash',\n        '.bash': 'bash',\n        '.pl': 'perl',\n        '.js': 'javascript',\n        '.txt': 'english',\n    }\n    ext_languages = {_: languages[_] for _ in exts} if exts else languages\n    return ext_languages.get(ext)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef find_language(script, exts=None):\n    if not script.isfile():\n        return None\n    if script.ext:\n        return ext_language(script.ext, exts)\n    shebang = script.shebang()\n    return shebang and str(shebang.name) or None", "response": "Determine the script s language"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef makepath(s, as_file=False):\n    if s is None:\n        return None\n    result = FilePath(s) if (os.path.isfile(s) or as_file) else DirectPath(s)\n    return result.expandall()", "response": "Make a path from a string"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef cd(path_to):  # pylint: disable=invalid-name\n    if path_to == '-':\n        if not cd.previous:\n            raise PathError('No previous directory to return to')\n        return cd(cd.previous)\n    if not hasattr(path_to, 'cd'):\n        path_to = makepath(path_to)\n    try:\n        previous = os.getcwd()\n    except OSError as e:\n        if 'No such file or directory' in str(e):\n            return False\n        raise\n    if path_to.isdir():\n        os.chdir(path_to)\n    elif path_to.isfile():\n        os.chdir(path_to.parent)\n    elif not os.path.exists(path_to):\n        return False\n    else:\n        raise PathError('Cannot cd to %s' % path_to)\n    cd.previous = previous\n    return True", "response": "cd to the given path_to"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef make_needed(pattern, path_to_directory, wanted):\n    if wanted:\n        def needed(name):\n            return fnmatch(name, pattern) and wanted(\n                os.path.join(path_to_directory, name))\n        return needed\n    else:\n        return lambda name: fnmatch(name, pattern)", "response": "Make a method to check if an item matches the pattern and is wanted\n           "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef list_items(path_to_directory, pattern, wanted):\n    if not path_to_directory:\n        return set()\n    needed = make_needed(pattern, path_to_directory, wanted)\n    return [os.path.join(path_to_directory, name)\n            for name in _names_in_directory(path_to_directory)\n            if needed(name)]", "response": "List all items in the given path which match the given glob and are wanted"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef contains_glob(path_to_directory, pattern, wanted=None):\n    if not path_to_directory:\n        return False\n    needed = make_needed(pattern, path_to_directory, wanted)\n    for name in _names_in_directory(path_to_directory):\n        if needed(name):\n            return True\n    return False", "response": "Whether the given path contains an item matching the given glob"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfinishes file names left short by tab - completion", "response": "def tab_complete(string):\n    \"\"\"Finish file names \"left short\" by tab-completion\n\n    For example, if an argument is \"fred.\"\n        and no file called \"fred.\" exists\n        but \"fred.py\" does exist\n        then return fred.py\n    \"\"\"\n    if is_option(string):\n        return string\n    if not missing_extension(string):\n        return string\n    if os.path.isfile(string):\n        return string\n    extended_files = [f for f in extend(string) if os.path.isfile(f)]\n    try:\n        return extended_files[0]\n    except IndexError:\n        return string"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nchanges some file extensions to those which are more likely to be text", "response": "def pyc_to_py(path_to_file):\n    \"\"\"Change some file extensions to those which are more likely to be text\n\n    >>> pyc_to_py('vim.pyc') == 'vim.py'\n    True\n    \"\"\"\n    stem, ext = os.path.splitext(path_to_file)\n    if ext == '.pyc':\n        return '%s.py' % stem\n    return path_to_file"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the file class for existing files only", "response": "def as_existing_file(self, filepath):\n        \"\"\"Return the file class for existing files only\"\"\"\n        if os.path.isfile(filepath) and hasattr(self, '__file_class__'):\n            return self.__file_class__(filepath)  # pylint: disable=no-member\n        return self.__class__(filepath)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef dirpaths(self):\n        parts = self.parts()\n        result = [DotPath(parts[0] or '/')]\n        for name in parts[1:]:\n            result.append(result[-1] / name)\n        return result", "response": "Split the dirname into individual directory names\n        An absolute path starts with an empty string a relative path does not\n       "}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsplitting the path into parts like Pathlib", "response": "def parts(self):\n        \"\"\"Split the path into parts like Pathlib\n\n        >>> expected = ['/', 'path', 'to', 'there']\n        >>> assert DotPath('/path/to/there').parts() == expected\n        \"\"\"\n        parts = self.split(os.path.sep)\n        parts[0] = parts[0] and parts[0] or '/'\n        return parts"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef short_relative_path_to(self, destination):\n        relative = self.relpathto(destination)\n        absolute = self.__class__(destination).abspath()\n        if len(relative) < len(absolute):\n            return relative\n        return absolute", "response": "The shorter of the absolute path of the destination and the relative path to it\n           ."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef walk_some_dirs(self, levels=-1, pattern=None):\n        if not levels:\n            yield self\n            raise StopIteration\n        levels -= 1\n        for child in self.dirs():\n            if pattern is None or child.fnmatch(pattern):\n                yield child\n            if levels:\n                for subsubdir in child.walk_some_dirs(levels, pattern):\n                    yield subsubdir", "response": "A generator that yields all directories that match the pattern."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef extend_by(self, extension):\n        copy = self[:]\n        filename, _ = os.path.splitext(copy)\n        return self.__class__('%s.%s' % (filename, extension.lstrip('.')))", "response": "The path to the file changed to use the given extension\n       "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef shebang(self):\n        try:\n            try:\n                first_line = self.lines()[0]\n            except (OSError, UnicodeDecodeError):\n                return ''\n            if first_line.startswith('#!'):\n                rest_of_line = first_line[2:].strip()\n                parts = rest_of_line.split(' ')\n                interpreter = parts[0]\n                return makepath(interpreter)\n        except IndexError:\n            pass\n        return ''", "response": "The first line of the file containing the shebang of the entry."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nmake sure the parent directory exists then touch the file", "response": "def make_file_exist(self):\n        \"\"\"Make sure the parent directory exists, then touch the file\"\"\"\n        self.parent.make_directory_exist()\n        self.parent.touch_file(self.name)\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef language(self):\n        try:\n            return self._language\n        except AttributeError:\n            self._language = find_language(self, getattr(self, 'exts', None))\n        return self._language", "response": "The language of this file"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ntries to remove the path AttributeNames", "response": "def try_remove(self):\n        \"\"\"Try to remove the path\n\n        If it is a directory, try recursive removal of contents too\n        \"\"\"\n        if self.islink():\n            self.unlink()\n        elif self.isfile():\n            self.remove()\n        elif self.isdir():\n            self.empty_directory()\n            if self.isdir():\n                self.rmdir()\n        else:\n            return False\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nremove all contents of a directory and all sub - directories and their contents.", "response": "def empty_directory(self):\n        \"\"\"Remove all contents of a directory\n\n        Including any sub-directories and their contents\"\"\"\n        for child in self.walkfiles():\n            child.remove()\n        for child in reversed([d for d in self.walkdirs()]):\n            if child == self or not child.isdir():\n                continue\n            child.rmdir()"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nmakes the directory exist then touch the file", "response": "def make_file_exist(self, filename=None):\n        \"\"\"Make the directory exist, then touch the file\n\n        If the filename is None, then use self.name as filename\n        \"\"\"\n        if filename is None:\n            path_to_file = FilePath(self)\n            path_to_file.make_file_exist()\n            return path_to_file\n        else:\n            self.make_directory_exist()\n            path_to_file = self.touch_file(filename)\n            return FilePath(path_to_file)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ntouch a file in the directory", "response": "def touch_file(self, filename):\n        \"\"\"Touch a file in the directory\"\"\"\n        path_to_file = self.__file_class__(os.path.join(self, filename))\n        path_to_file.touch()\n        return path_to_file"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef existing_sub_paths(self, sub_paths):\n        paths_to_subs = [self / _ for _ in sub_paths]\n        return [_ for _ in paths_to_subs if _.exists()]", "response": "Those in the given list of sub_paths which do exist"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates pending tasks in a dict on self. result with task string as key. It will also create a list on self. tasks that is used to make sure the serialization of the results is correctly ordered.", "response": "def create_pending_tasks(self):\n        \"\"\"\n        Creates pending task results in a dict on self.result with task string as key. It will also\n        create a list on self.tasks that is used to make sure the serialization of the results\n        creates a correctly ordered list.\n        \"\"\"\n        for task in self.settings.tasks['setup']:\n            self.setup_tasks.append(task)\n            self.setup_results[task] = Result(task)\n\n        if self.preset:\n            for task in self.preset['tasks']:\n                self.tasks.append(task)\n                self.results[task] = Result(task)\n\n        for task in self.settings.preview['tasks']:\n            self.tasks.append(task)\n            self.results[task] = Result(task)\n\n        if self.preset:\n            self.tasks.append(self.preset['daemon_task'])\n            self.results[self.preset['daemon_task']] = Result(self.preset['daemon_task'])"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef load_preset(self):\n        if 'preset' in self.settings.preview:\n            with open(os.path.join(os.path.dirname(__file__), 'presets.yaml')) as f:\n                presets = yaml.load(f.read())\n\n            if self.settings.preview['preset'] in presets:\n                self.preset = presets[self.settings.preview['preset']]\n            return self.preset", "response": "Loads the preset if it is specified in the. frigg. yml file."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a parser instance for this .", "response": "def get_parser(self):\n        \"\"\"\n        Returns :class:`monolith.cli.Parser` instance for this\n        *ExecutionManager*.\n        \"\"\"\n        parser = self.parser_cls(prog=self.prog_name, usage=self.get_usage(),\n            stream=self.stderr)\n        subparsers = parser.add_subparsers(\n            title='subcommands',\n        )\n        for name, command in self.registry.items():\n            cmdparser = subparsers.add_parser(name, help=command.help)\n            for argument in command.get_args():\n                cmdparser.add_argument(*argument.args, **argument.kwargs)\n            command.setup_parser(parser, cmdparser)\n            cmdparser.set_defaults(func=command.handle)\n\n        return parser"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nregistering given command as given name at this execution manager s registry.", "response": "def register(self, name, Command, force=False):\n        \"\"\"\n        Registers given ``Command`` (as given ``name``) at this\n        *ExecutionManager*'s registry.\n\n        :param name: name in the registry under which given ``Command``\n          should be stored.\n        :param Command: should be subclass of\n          :class:``monolith.cli.base.BaseCommand``\n        :param force: Forces registration if set to ``True`` - even if another\n          command was already registered, it would be overridden and no\n          execption would be raised. Defaults to ``False``.\n\n        :raises AlreadyRegistered: If another command was already registered\n          under given ``name``.\n        \"\"\"\n        if not force and name in self.registry:\n            raise AlreadyRegistered('Command %r is already registered' % name)\n        command = Command(self.prog_name, self.stdout)\n        command.manager = self\n        self.registry[name] = command\n        command.post_register(self)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a dictionary of all commands stored in the registry sorted by name.", "response": "def get_commands(self):\n        \"\"\"\n        Returns commands stored in the registry (sorted by name).\n        \"\"\"\n        commands = OrderedDict()\n        for cmd in sorted(self.registry.keys()):\n            commands[cmd] = self.registry[cmd]\n        return commands"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nruns a command. :param cmd: command to run (key at the registry) :param argv: arguments that would be passed to the command", "response": "def call_command(self, cmd, *argv):\n        \"\"\"\n        Runs a command.\n\n        :param cmd: command to run (key at the registry)\n        :param argv: arguments that would be passed to the command\n        \"\"\"\n        parser = self.get_parser()\n        args = [cmd] + list(argv)\n        namespace = parser.parse_args(args)\n        self.run_command(namespace)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nexecuting command based on given arguments.", "response": "def execute(self, argv=None):\n        \"\"\"\n        Executes command based on given arguments.\n        \"\"\"\n        if self.completion:\n            self.autocomplete()\n        parser = self.get_parser()\n        namespace = parser.parse_args(argv)\n        if hasattr(namespace, 'func'):\n            self.run_command(namespace)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_commands_to_register(self):\n        return dict((key, get_class(value)) for key, value in\n            self.simple_commands.items())", "response": "Returns dictionary with commands given during construction."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nhandling given namespace by calling handle_no_labels method for each given label.", "response": "def handle(self, namespace):\n        \"\"\"\n        Handles given ``namespace`` by calling ``handle_label`` method\n        for each given *label*.\n        \"\"\"\n        for label in namespace.labels:\n            self.handle_label(label, namespace)\n        else:\n            self.handle_no_labels(namespace)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_path_directories():\n    pth = os.environ['PATH']\n    if sys.platform == 'win32' and os.environ.get(\"BASH\"):\n        # winbash has a bug..\n        if pth[1] == ';':  # pragma: nocover\n            pth = pth.replace(';', ':', 1)\n    return [p.strip() for p in pth.split(os.pathsep) if p.strip()]", "response": "Return a list of all the directories on the path."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _listdir(pth, extensions):\n    try:\n        return [fname for fname in os.listdir(pth)\n                if os.path.splitext(fname)[1] in extensions]\n    except OSError:  # pragma: nocover\n        pass", "response": "Non - raising listdir."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nyielding all executable files on path that matches filename.", "response": "def which(filename, interactive=False, verbose=False):\n    \"\"\"Yield all executable files on path that matches `filename`.\n    \"\"\"\n    exe = [e.lower() for e in os.environ.get('PATHEXT', '').split(';')]\n    if sys.platform != 'win32':  # pragma: nocover\n        exe.append('')\n\n    name, ext = os.path.splitext(filename)\n    has_extension = bool(ext)\n    if has_extension and ext.lower() not in exe:\n        raise ValueError(\"which can only search for executable files\")\n\n    def match(filenames):\n        \"\"\"Returns the sorted subset of ``filenames`` that matches ``filename``.\n        \"\"\"\n        res = set()\n        for fname in filenames:\n            if fname == filename:  # pragma: nocover\n                res.add(fname)  # exact match\n                continue\n            fname_name, fname_ext = os.path.splitext(fname)\n            if fname_name == name and fname_ext.lower() in exe: # pragma: nocover\n                res.add(fname)\n        return sorted(res)\n\n    returnset = set()\n    found = False\n    for pth in get_path_directories():\n        if verbose:  # pragma: nocover\n            print('checking pth..')\n\n        fnames = _listdir(pth, exe)\n        if not fnames:\n            continue\n\n        for m in match(fnames):\n            found_file = _normalize(os.path.join(pth, m))\n            if found_file not in returnset:  # pragma: nocover\n                if is_executable(found_file):\n                    yield found_file\n                returnset.add(found_file)\n        found = True\n\n    if not found and interactive:  # pragma: nocover\n        print(\"Couldn't find %r anywhere on the path..\" % filename)\n        sys.exit(1)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nenabling an effect in the KezMenu.", "response": "def enableEffect(self, name, **kwargs):\n        \"\"\"Enable an effect in the KezMenu.\"\"\"\n        if name not in VALID_EFFECTS:\n            raise KeyError(\"KezMenu doesn't know an effect of type %s\" % name)\n        self.__getattribute__(\n            '_effectinit_{}'.format(name.replace(\"-\", \"_\"))\n        )(name, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _updateEffects(self, time_passed):\n\n        for name in self._effects:\n            update_func = getattr(\n                self,\n                '_effectupdate_{}'.format(name.replace(\"-\", \"_\")),\n            )\n            update_func(time_passed)", "response": "Update the effects of the related objects"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _effectupdate_enlarge_font_on_focus(self, time_passed):\n\n        data = self._effects['enlarge-font-on-focus']\n        fps = data['raise_font_ps']\n        final_size = data['size'] * data['enlarge_factor']\n        for i, option in enumerate(self.options):\n            if i == self.option:\n                # Raise me\n                if option['font_current_size'] < final_size:\n                    option['raise_font_factor'] += fps * time_passed\n                elif option['font_current_size'] > final_size:\n                    option['raise_font_factor'] = data['enlarge_factor']\n            elif option['raise_font_factor'] != 1.0:\n                # decrease\n                if option['raise_font_factor'] > 1.0:\n                    option['raise_font_factor'] -= fps * time_passed\n                elif option['raise_font_factor'] < 1.0:\n                    option['raise_font_factor'] = 1.0\n\n            new_size = int(data['size'] * option['raise_font_factor'])\n            if new_size != option['font_current_size']:\n                option['font'] = pygame.font.Font(data['font'], new_size)\n                option['font_current_size'] = new_size", "response": "Gradually enlarge the font size of the focused line."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _effectinit_raise_col_padding_on_focus(self, name, **kwargs):\n\n        self._effects[name] = kwargs\n        if \"enlarge_time\" not in kwargs:\n            kwargs['enlarge_time'] = 0.5\n        if \"padding\" not in kwargs:\n            kwargs['padding'] = 10\n        kwargs['padding_pps'] = kwargs['padding'] / kwargs['enlarge_time']\n\n        for option in self.options:\n            option['padding_col'] = 0.0", "response": "Init the column padding on focus effect."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nmake a tuple for the choices parameter for a data model field.", "response": "def make_choices_tuple(choices, get_display_name):\n    \"\"\"\n    Make a tuple for the choices parameter for a data model field.\n\n    :param choices: sequence of valid values for the model field\n    :param get_display_name: callable that returns the human-readable name for a choice\n\n    :return: A tuple of 2-tuples (choice, display_name) suitable for the choices parameter\n    \"\"\"\n    assert callable(get_display_name)\n    return tuple((x, get_display_name(x)) for x in choices)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef clean_dict(d, test=lambda v: v):\n    return {k: v for k, v in d.items() if test(v)}", "response": "Clean a dictionary by only keys that meet the test"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nconvert the list of prediction_models passed in into properly formatted prediction model dict", "response": "def prediction_model_dict(self):\n        \"\"\"\n        Converts the list of prediction_models passed in into properly formatted dictionaries\n        :return: formatted prediction model dict\n        \"\"\"\n        models = {}\n        for model in self.predictions_models:\n            models[model.name] = model.keywords\n        return models"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef upload(self, filename, configuration=None, metadata=None, transcript=None):\n        data = {}\n        if metadata:\n            data['metadata'] = str(metadata)\n        if configuration:\n            data['configuration'] = str(configuration)\n\n        # Determine mime type\n        m = magic.Magic(mime=True)\n        mime_type = m.from_file(filename)\n\n        # Open file and pipe to request\n        with open(filename) as handle:\n            file_info = [('media', (filename, handle, mime_type))]\n            rq = requests.Request(b'POST', self.full_url('base'), data=data, headers=self.session.headers,\n                                  files=file_info)\n            prepared_rq = rq.prepare()\n            response = self.session.send(prepared_rq)\n            response.raise_for_status()\n        jsn = response.json()\n        log.debug('Upload response: {}'.format(jsn))\n        return VoicebaseMedia(jsn, api=self.api)", "response": "Uploads a new media to the service as an attachment or from a url."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget this media item and associated analytics.", "response": "def get(self, media_id):\n        \"\"\"\n        Get this media item and associated analytics.\n        HTTP GET on /media/{mediaId}\n        :param media_id: Media ID\n        :return: VoicebaseMedia\n        \"\"\"\n        response = self._get('item', format_dict=dict(media_id=media_id))\n        return VoicebaseMedia(response, api=self.api)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconverts an integer value to an alphanumeric representation of the index .", "response": "def _get_variation_id(value, capital=False):\n        \"\"\" Convert an integer value to a character. a-z then double aa-zz etc\n        Args:\n            value (int): integer index we're looking up\n            capital (bool): whether we convert to capitals or not\n        Returns (str): alphanumeric representation of the index\n        \"\"\"\n        # Reinforcing type just in case a valid string was entered\n        value = int(value)\n        base_power = base_start = base_end = 0\n        while value >= base_end:\n            base_power += 1\n            base_start = base_end\n            base_end += pow(26, base_power)\n        base_index = value - base_start\n\n        # create alpha representation\n        alphas = ['a'] * base_power\n        for index in range(base_power - 1, -1, -1):\n            alphas[index] = chr(int(97 + (base_index % 26)))\n            base_index /= 26\n\n        characters = ''.join(alphas)\n        return characters.upper() if capital else characters"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef getattribute(value, arg):\n\n    if hasattr(value, str(arg)):\n        return getattr(value, arg)\n    elif hasattr(value, 'has_key') and value.has_key(arg):\n        return value[arg]\n    elif numeric_test.match(str(arg)) and len(value) > int(arg):\n        return value[int(arg)]\n    else:\n        return settings.TEMPLATE_STRING_IF_INVALID", "response": "Gets an attribute of an object dynamically from a string name"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nedit the file with the current data", "response": "def edit(self):\n\t\t\"\"\"\n\t\tEdit the file\n\t\t\"\"\"\n\t\tself.changed = False\n\t\twith self:\n\t\t\teditor = self.get_editor()\n\t\t\tcmd = [editor, self.name]\n\t\t\ttry:\n\t\t\t\tres = subprocess.call(cmd)\n\t\t\texcept Exception as e:\n\t\t\t\tprint(\"Error launching editor %(editor)s\" % locals())\n\t\t\t\tprint(e)\n\t\t\t\treturn\n\t\t\tif res != 0:\n\t\t\t\tmsg = '%(editor)s returned error status %(res)d' % locals()\n\t\t\t\traise EditProcessException(msg)\n\t\t\tnew_data = self.read()\n\t\t\tif new_data != self.data:\n\t\t\t\tself.changed = self._save_diff(self.data, new_data)\n\t\t\t\tself.data = new_data"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _search_env(keys):\n\t\tmatches = (os.environ[key] for key in keys if key in os.environ)\n\t\treturn next(matches, None)", "response": "Search the environment for the supplied keys returning the first found."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the editor for the current content type.", "response": "def get_editor(self):\n\t\t\"\"\"\n\t\tGive preference to an XML_EDITOR or EDITOR defined in the\n\t\tenvironment. Otherwise use a default editor based on platform.\n\t\t\"\"\"\n\t\tenv_search = ['EDITOR']\n\t\tif 'xml' in self.content_type:\n\t\t\tenv_search.insert(0, 'XML_EDITOR')\n\t\tdefault_editor = self.platform_default_editors[sys.platform]\n\t\treturn self._search_env(env_search) or default_editor"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nbuilding an Event object from a JSON object.", "response": "def from_json(cls, json_obj):\n        \"\"\"Build an Event from JSON.\n\n        :param json_obj: JSON data representing a Cube Event\n        :type json_obj: `String` or `json`\n        :throws: `InvalidEventError` when any of time field is not present\n        in json_obj.\n        \"\"\"\n        if isinstance(json_obj, str):\n            json_obj = json.loads(json_obj)\n\n        type = None\n        time = None\n        data = None\n        if cls.TYPE_FIELD_NAME in json_obj:\n            type = json_obj[cls.TYPE_FIELD_NAME]\n\n        if cls.TIME_FIELD_NAME in json_obj:\n            time = json_obj[cls.TIME_FIELD_NAME]\n        else:\n            raise InvalidEventError(\"{field} must be present!\".format(\n                field=cls.TIME_FIELD_NAME))\n\n        if cls.DATA_FIELD_NAME in json_obj:\n            data = json_obj[cls.DATA_FIELD_NAME]\n\n        return cls(type, time, data)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef autodiscover():\n    # Get permissions based on urlpatterns from urls.py\n    url_conf = getattr(settings, 'ROOT_URLCONF', ())\n    resolver = urlresolvers.get_resolver(url_conf)\n    urlpatterns = resolver.url_patterns\n    permissions = generate_permissions(urlpatterns)\n    # Refresh permissions\n    refresh_permissions(permissions)", "response": "Autodiscover for urls. py"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_driver_blacklist(driver):  # noqa: E501\n\n    response = errorIfUnauthorized(role='admin')\n    if response:\n        return response\n    else:\n        response = ApitaxResponse()\n\n    driver: Driver = LoadedDrivers.getDriver(driver)\n    response.body.add({'blacklist': driver.getDriverBlacklist()})\n\n    return Response(status=200, body=response.getResponseBody())", "response": "Retrieve the blacklist in the driver"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_driver_config(driver):  # noqa: E501\n\n    response = errorIfUnauthorized(role='admin')\n    if response:\n        return response\n    else:\n        response = ApitaxResponse()\n\n    # TODO: This needs an implementation, but likely requires a change to configs in apitaxcore\n\n    return Response(status=200, body=response.getResponseBody())", "response": "Retrieve the config of a loaded driver"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nretrieves the catalog of drivers", "response": "def get_driver_list():  # noqa: E501\n    \"\"\"Retrieve the catalog of drivers\n\n    Retrieve the catalog of drivers # noqa: E501\n\n\n    :rtype: Response\n    \"\"\"\n\n    response = errorIfUnauthorized(role='admin')\n    if response:\n        return response\n    else:\n        response = ApitaxResponse()\n\n    response.body.add({'drivers': LoadedDrivers.drivers})\n\n    return Response(status=200, body=response.getResponseBody())"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nretrieving the status of a loaded driver", "response": "def get_driver_status(driver):  # noqa: E501\n    \"\"\"Retrieve the status of a loaded driver\n\n    Retrieve the status of a loaded driver # noqa: E501\n\n    :param driver: The driver to use for the request. ie. github\n    :type driver: str\n\n    :rtype: Response\n    \"\"\"\n\n    response = errorIfUnauthorized(role='admin')\n    if response:\n        return response\n    else:\n        response = ApitaxResponse()\n\n    driver: Driver = LoadedDrivers.getDriver(driver)\n    response.body.add({'name': driver.getDriverName()})\n    response.body.add({'description': driver.getDriverDescription()})\n    response.body.add({'tips': driver.getDriverTips()})\n    response.body.add({'help': driver.getDriverHelpEndpoint()})\n    response.body.add({'minimum-role': driver.getDriverMinimumRole()})\n\n    options = {}\n    options['configurable'] = driver.isDriverConfigurable()\n    options['authenticatable'] = driver.isDriverAuthenticatable()\n    options['role-restricted'] = driver.isDriverRoleRestricted()\n    options['whitelisted'] = driver.isDriverWhitelisted()\n    options['blacklisted'] = driver.isDriverBlacklisted()\n    response.body.add({'options': options})\n\n    return Response(status=200, body=response.getResponseBody())"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nretrieving the whitelist in the driver", "response": "def get_driver_whitelist(driver):  # noqa: E501\n    \"\"\"Retrieve the whitelist in the driver\n\n    Retrieve the whitelist in the driver # noqa: E501\n\n    :param driver: The driver to use for the request. ie. github\n    :type driver: str\n\n    :rtype: Response\n    \"\"\"\n\n    response = errorIfUnauthorized(role='admin')\n    if response:\n        return response\n    else:\n        response = ApitaxResponse()\n\n    driver: Driver = LoadedDrivers.getDriver(driver)\n    response.body.add({'whitelist': driver.getDriverWhitelist()})\n\n    return Response(status=200, body=response.getResponseBody())"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nmaking sure that a translation is created when a tag is saved. Also ensures that the original tag name gets updated when the english translation is updated. TODO: This will create two tags when a tag is saved through the admin", "response": "def tag_post_save_handler(sender, **kwargs):\n    \"\"\"\n    Makes sure that a translation is created when a tag is saved.\n\n    Also ensures that the original tag name gets updated when the english\n    translation is updated.\n\n    TODO: This will create two tags when a tag is saved through the admin\n\n    \"\"\"\n    instance = kwargs.get('instance')\n    try:\n        translation = instance.tagtitle_set.get(language='en')\n    except TagTitle.DoesNotExist:\n        translation = TagTitle.objects.create(\n            trans_name=instance.name, tag=instance, language='en')\n    if translation.trans_name != instance.name:\n        instance.name = translation.trans_name\n        instance.save_base(raw=True)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nmaking sure the registry key is editable before trying to edit it.", "response": "def require_editable(f):\n    \"\"\"\n    Makes sure the registry key is editable before trying to edit it.\n    \"\"\"\n\n    def wrapper(self, *args, **kwargs):\n        if not self._edit:\n            raise RegistryKeyNotEditable(\"The key is not set as editable.\")\n        return f(self, *args, **kwargs)\n\n    return wrapper"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef pathNames(self) -> [str]:\n\n        return [f.pathName for f in list(self._files.values())]", "response": "Returns a list of path + name of each file in the current directory."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef paths(self) -> [str]:\n\n        return set([f.path for f in list(self._files.values())])", "response": "A list of the paths effectively a list of relative\n        directory names."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting specific file from the cache.", "response": "def getFile(self, path: str = '', name: str = None,\n                pathName: str = None) -> 'File':\n        \"\"\" Get File\n\n        Get File name corresponding to a path name.\n\n        @param path: File path.  Default as empty string.\n        @param name: File name to be used if passed.\n        @param pathName: Joined file name and path to be used if passed.\n        @type path: String\n        @type name: String\n        @type pathName: String\n        @return: Specific file from dictionary.\n        \"\"\"\n\n        assert (name or pathName)\n        pathName = (pathName if pathName else os.path.join(path, name))\n        return self._files.get(pathName)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef createFile(self, path: str = '', name: str = None,\n                   pathName: str = None) -> 'File':\n        \"\"\" Create File\n\n        Creates a new file and updates file dictionary.\n\n        @param path: File path.  Defaults as empty string.\n        @param name: File name to be used if passed.\n        @param pathName: Joined file name and path to be used if passed.\n        @type path: String\n        @type name: String\n        @type pathName: String\n        @return: Created file.\n        \"\"\"\n\n        file = File(self, path=path, name=name, pathName=pathName)\n        self._files[file.pathName] = file\n        return file", "response": "Create a new file and updates the file dictionary with the file s name and path."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating a temporary file within the directory with a temporary file like name.", "response": "def createTempFile(self, suffix=None, prefix=None, secure=True) -> 'File':\n        \"\"\" Create File\n\n        Creates a new file within the directory with a temporary file like name.\n\n        @return: Created file.\n        \"\"\"\n        if not secure:\n            raise NotImplementedError(\"We only support secure files at this point\")\n\n        # tempfile.mkstemp(suffix=None, prefix=None, dir=None, text=False)\n\n        newFileNum, newFileRealPath = tempfile.mkstemp(\n            suffix=suffix, prefix=prefix, dir=self._path)\n        os.close(newFileNum)\n\n        relativePath = os.path.relpath(newFileRealPath, self.path)\n\n        file = File(self, pathName=relativePath, exists=True)\n        self._files[file.pathName] = file\n        return file"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef createHiddenFolder(self) -> 'File':\n\n        if not self._autoDelete:\n            raise Exception(\"Hidden folders can only be created within\"\n                            \" an autoDelete directory\")\n        return tempfile.mkdtemp(dir=self._path, prefix=\".\")", "response": "Create a hidden folder."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nlists the files and folders in the current directory for Windows OS.", "response": "def _listFilesWin(self) -> ['File']:\n        \"\"\" List Files for Windows OS\n\n        Search and list the files and folder in the current directory for the\n        Windows file system.\n\n        @return: List of directory files and folders.\n        \"\"\"\n\n        output = []\n        for dirname, dirnames, filenames in os.walk(self._path):\n            for subdirname in dirnames:\n                output.append(os.path.join(dirname, subdirname))\n            for filename in filenames:\n                output.append(os.path.join(dirname, filename))\n        return output"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nlist files for POSIX file system.", "response": "def _listFilesPosix(self) -> ['File']:\n        \"\"\" List Files for POSIX\n\n        Search and list the files and folder in the current directory for the\n        POSIX file system.\n\n        @return: List of directory files and folders.\n        \"\"\"\n\n        find = \"find %s -type f\" % self._path\n        output = check_output(args=find.split()).strip().decode().split(\n            '\\n')\n        return output"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nscan the directory for files and folders and update the file dictionary.", "response": "def scan(self) -> ['File']:\n        \"\"\" Scan\n\n        Scan the directory for files and folders and update the file dictionary.\n\n        @return: List of files\n        \"\"\"\n\n        self._files = {}\n        output = self._listFilesWin() if isWindows else self._listFilesPosix()\n        output = [line for line in output if \"__MACOSX\" not in line]\n        for pathName in output:\n            if not pathName:  # Sometimes we get empty lines\n                continue\n\n            pathName = pathName[len(self._path) + 1:]\n            file = File(self, pathName=pathName, exists=True)\n            self._files[file.pathName] = file\n\n        return self.files"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef clone(self, autoDelete: bool = True) -> 'Directory':\n\n        d = Directory(autoDelete=autoDelete)\n        os.rmdir(d._path)  # shutil doesn't like it existing\n        shutil.copytree(self._path, d._path)\n        d.scan()\n        return d", "response": "Clone the current directory tree."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nfiling moved event handler.", "response": "def _fileMoved(self, oldPathName: str, file: 'File'):\n        \"\"\" File Moved\n\n        Drop the old file name from the dictionary and add the new file name.\n\n        @param oldPathName: Previous dictionary path name.\n        @param file: File name.\n        @type oldPathName: String\n        @type file: File\n        \"\"\"\n\n        self._files.pop(oldPathName)\n        self._files[file.pathName] = file"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset the path with passed in variable.", "response": "def path(self, path: str):\n        \"\"\" Path Setter\n\n        Set path with passed in variable.\n\n        @param path: New path string.\n        @type path: String\n        \"\"\"\n\n        path = path if path else ''\n        self.pathName = os.path.join(path, self.name)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nnaming Setter Name with passed in variable.", "response": "def name(self, name: str):\n        \"\"\" Name Setter\n\n        Set name with passed in variable.\n\n        @param name: New name string.\n        @type name: String\n        \"\"\"\n\n        self.pathName = os.path.join(self.path, name)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef pathName(self, pathName: str):\n\n        if self.pathName == pathName:\n            return\n\n        pathName = self.sanitise(pathName)\n        before = self.realPath\n        after = self._realPath(pathName)\n\n        assert (not os.path.exists(after))\n\n        newRealDir = os.path.dirname(after)\n        if not os.path.exists(newRealDir):\n            os.makedirs(newRealDir, DirSettings.defaultDirChmod)\n\n        shutil.move(before, after)\n\n        oldPathName = self._pathName\n        self._pathName = pathName\n\n        self._directory()._fileMoved(oldPathName, self)", "response": "Set the path name of the current object."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef open(self, append: bool = False, write: bool = False):\n\n        flag = {(False, False): 'r',\n                (True, False): 'a',\n                (True, True): 'a',\n                (False, True): 'w'}[(append, write)]\n\n        realPath = self.realPath\n        realDir = os.path.dirname(realPath)\n        if not os.path.exists(realDir):\n            os.makedirs(realDir, DirSettings.defaultDirChmod)\n        return open(self.realPath, flag)", "response": "Open the current log entry file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nname Temporary File Reader", "response": "def namedTempFileReader(self) -> NamedTempFileReader:\n        \"\"\" Named Temporary File Reader\n\n        This provides an object compatible with NamedTemporaryFile, used for reading this\n        files contents. This will still delete after the object falls out of scope.\n\n        This solves the problem on windows where a NamedTemporaryFile can not be read\n        while it's being written to\n        \"\"\"\n\n        # Get the weak ref\n        directory = self._directory()\n        assert isinstance(directory, Directory), (\n            \"Expected Directory, receieved %s\" % directory)\n\n        # Return the object\n        return NamedTempFileReader(directory, self)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef delete(self):\n\n        directory = self._directory()\n        assert isinstance(directory, Directory)\n\n        realPath = self.realPath\n        assert (os.path.exists(realPath))\n        os.remove(realPath)\n\n        directory._fileDeleted(self)", "response": "Delete the file from the dictionary and drops the file name from disk."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nremoving the file from the Directory object.", "response": "def remove(self):\n        \"\"\" Remove\n\n        Removes the file from the Directory object, file on file system\n        remains on disk.\n        \"\"\"\n\n        directory = self._directory()\n        assert isinstance(directory, Directory)\n        directory._fileDeleted(self)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _realPath(self, newPathName: str = None) -> str:\n\n        directory = self._directory()\n        assert directory\n        return os.path.join(directory.path,\n                            newPathName if newPathName else self._pathName)", "response": "Private Real Path Name."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef sanitise(self, pathName: str) -> str:\n\n        assert isinstance(pathName, str)\n        assert '..' not in pathName\n        assert not pathName.endswith(os.sep)\n\n        while pathName.startswith(os.sep):\n            pathName = pathName[1:]\n\n        return pathName", "response": "Sanitize the path name variable."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef import_file(package: str, fname: str) -> ModuleType:\n    mod_name = fname.rstrip('.py')\n    spec = spec_from_file_location(mod_name, '{}/{}'.format(package, fname))\n    module = module_from_spec(spec)\n    spec.loader.exec_module(module)\n    return module", "response": "Imports a file directly."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef t_EXP_ALL(self, tok):  # pylint: disable=locally-disabled,invalid-name\n        r'(-|\\+|\\*|/|%|like|LIKE|=~|in|IN|~~|is|IS|eq|EQ|==|ne|NE|!=|<>|ge|GE|>=|gt|GT|>|le|LE|<=|lt|LT|<|or|OR|\\|\\||xor|XOR|\\^\\^|and|AND|&&|not|NOT|!|exists|EXISTS|\\?)'\n        tok.type = self.reserved.get(tok.value)\n        tok.value = tok.type\n        return tok", "response": "Token handler for EXPL_ALL tokens."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef t_CONSTANT(tok):  # pylint: disable=locally-disabled,invalid-name\n        r'\"([^\"]+)\"|\\'([^\\']+)\\''\n        tok.value = (tok.type, re.sub('[\"\\']', '', tok.value))\n        return tok", "response": "Token handler for CONSTANT types."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef trigger_arbitrary_job(repo_name, builder, revision, auth, files=None, dry_run=False,\n                          extra_properties=None):\n    \"\"\"\n    Request buildapi to trigger a job for us.\n\n    We return the request or None if dry_run is True.\n\n    Raises BuildapiAuthError if credentials are invalid.\n    \"\"\"\n    assert len(revision) == 40, \\\n        'We do not accept revisions shorter than 40 chars'\n    url = _builders_api_url(repo_name, builder, revision)\n    payload = _payload(repo_name, revision, files, extra_properties)\n\n    if dry_run:\n        LOG.info(\"Dry-run: We were going to request a job for '{}'\".format(builder))\n        LOG.info(\"         with this payload: {}\".format(str(payload)))\n        LOG.info(\"         with these files: {}\".format(files))\n        return None\n\n    # NOTE: A good response returns json with request_id as one of the keys\n    req = requests.post(\n        url,\n        headers={'Accept': 'application/json'},\n        data=payload,\n        auth=auth,\n        timeout=TCP_TIMEOUT,\n    )\n    if req.status_code == 401:\n        raise BuildapiAuthError(\"Your credentials were invalid. Please try again.\")\n    elif req.status_code == 503:\n        raise BuildapiDown(\"Please file a bug {}\".format(url))\n\n    try:\n        req.json()\n        return req\n\n    except ValueError:\n        LOG.info('repo: {}, builder: {}, revision: {}'.format(repo_name, builder, revision))\n        LOG.error(\"We did not get info from %s (status code: %s)\" % (url, req.status_code))\n        return None", "response": "Request buildapi to trigger a job for us."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef make_retrigger_request(repo_name, request_id, auth, count=DEFAULT_COUNT_NUM,\n                           priority=DEFAULT_PRIORITY, dry_run=True):\n    \"\"\"\n    Retrigger a request using buildapi self-serve. Returns a request.\n\n    Buildapi documentation:\n    POST  /self-serve/{branch}/request\n    Rebuild `request_id`, which must be passed in as a POST parameter.\n    `priority` and `count` are also accepted as optional\n    parameters. `count` defaults to 1, and represents the number\n    of times this build  will be rebuilt.\n    \"\"\"\n    url = '{}/{}/request'.format(SELF_SERVE, repo_name)\n    payload = {'request_id': request_id}\n\n    if count != DEFAULT_COUNT_NUM or priority != DEFAULT_PRIORITY:\n        payload.update({'count': count,\n                        'priority': priority})\n\n    if dry_run:\n        LOG.info('We would make a POST request to %s with the payload: %s' % (url, str(payload)))\n        return None\n\n    LOG.info(\"We're going to re-trigger an existing completed job with request_id: %s %i time(s).\"\n             % (request_id, count))\n    req = requests.post(\n        url,\n        headers={'Accept': 'application/json'},\n        data=payload,\n        auth=auth,\n        timeout=TCP_TIMEOUT,\n    )\n    # TODO: add debug message with job_id URL.\n    return req", "response": "Re - trigger a request using self - serve."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncancel a request using buildapi self - serve. Returns a request.", "response": "def make_cancel_request(repo_name, request_id, auth, dry_run=True):\n    \"\"\"\n    Cancel a request using buildapi self-serve. Returns a request.\n\n    Buildapi documentation:\n    DELETE /self-serve/{branch}/request/{request_id} Cancel the given request\n    \"\"\"\n    url = '{}/{}/request/{}'.format(SELF_SERVE, repo_name, request_id)\n\n    if dry_run:\n        LOG.info('We would make a DELETE request to %s.' % url)\n        return None\n\n    LOG.info(\"We're going to cancel the job at %s\" % url)\n    req = requests.delete(url, auth=auth, timeout=TCP_TIMEOUT)\n    # TODO: add debug message with the canceled job_id URL. Find a way\n    # to do that without doing an additional request.\n    return req"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nqueries Buildapi for jobs.", "response": "def query_jobs_schedule(repo_name, revision, auth):\n    \"\"\"\n    Query Buildapi for jobs.\n    \"\"\"\n    url = \"%s/%s/rev/%s?format=json\" % (SELF_SERVE, repo_name, revision)\n    LOG.debug(\"About to fetch %s\" % url)\n    req = requests.get(url, auth=auth, timeout=TCP_TIMEOUT)\n\n    # If the revision doesn't exist on buildapi, that means there are\n    # no buildapi jobs for this revision\n    if req.status_code not in [200]:\n        return []\n\n    return req.json()"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nqueries the pending jobs of a specific revision", "response": "def query_pending_jobs(auth, repo_name=None, return_raw=False):\n    \"\"\"Return pending jobs\"\"\"\n    url = '%s/pending?format=json' % HOST_ROOT\n    LOG.debug('About to fetch %s' % url)\n    req = requests.get(url, auth=auth, timeout=TCP_TIMEOUT)\n\n    # If the revision doesn't exist on buildapi, that means there are\n    # no builapi jobs for this revision\n    if req.status_code not in [200]:\n        return []\n\n    raw = req.json()\n\n    # If we don't want the data structure to be reduced\n    if return_raw:\n        return raw\n\n    # If we only want pending jobs of a specific repo\n    if repo_name and repo_name in list(raw['pending'].keys()):\n        repo_list = [repo_name]\n    else:\n        repo_list = list(raw['pending'].keys())\n\n    # Data structure to return\n    data = {}\n    for repo in repo_list:\n        data[repo] = {}\n        repo_jobs = raw['pending'][repo]\n        for revision in repo_jobs.items():\n            data[repo][revision[0]] = revision[1]\n\n    return data"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting object for rendering component and set object to all components", "response": "def set_object(self, object):\n        \"\"\"\n        Set object for rendering component and set object to all components\n\n        :param object:\n        :return:\n        \"\"\"\n        if self.object is False:\n            self.object = object\n\n        # Pass object along to child components for rendering\n        for component in self.components:\n            component.set_object(object)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef parse_field(self, field_data, index=0):\n        field = {\n            '__index__': index,\n        }\n\n        if isinstance(field_data, str):\n            field.update(self.parse_string_field(field_data))\n        elif isinstance(field_data, dict):\n            field.update(field_data)\n        else:\n            raise TypeError('Expected a str or dict get {}'.format(type(field_data)))\n\n        if 'field' not in field:\n            field['field'] = None\n\n        if 'label' not in field and field['field']:\n            try:\n                field['label'] = self.object._meta.get_field(field['field']).verbose_name.capitalize()\n            except Exception:\n                field['label'] = field['field'].replace('_', '').capitalize()\n        elif 'label' not in field:\n            field['label'] = ''\n\n        if 'format' not in field:\n            field['format'] = '{0}'\n\n        # Set default options\n        for name, options in self.fields_options.items():\n            if 'default' in options and name not in field:\n                field[name] = options['default']\n\n        return field", "response": "Parse a single field and add missing options"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nparsing a string field to dict with options and values.", "response": "def parse_string_field(self, field_data):\n        \"\"\"\n        Parse a string field to dict with options\n\n        String value is used as field name. Options can be given after = symbol.\n        Where key value is separated by : and different options by ;, when no : is used then the value becomes True.\n\n        **Example 1:** `field_name`\n\n        .. code-block:: python\n\n            # Output\n            {\n                'field': 'field_name'\n            }\n\n        **Example 3** `field_name=option1:some value;option2: other value`\n\n        .. code-block:: python\n\n            # Output\n            {\n                'field': 'field_name',\n                'option1': 'some value',\n                'option2': 'other value',\n            }\n\n        **Example 3** `field_name=option1;option2: other value`\n\n        .. code-block:: python\n\n            # Output\n            {\n                'field': 'field_name',\n                'option1': True,\n                'option2': 'other value',\n            }\n\n        :param str field_data:\n        :return dict:\n        \"\"\"\n        field_name, *data = field_data.split('=', 1)\n        field = {\n            'field': field_name,\n        }\n\n        for option_string in ''.join(data).split(';'):\n            option, *value = option_string.split(':')\n            if option.strip():\n                field[option.strip()] = value[0].strip() if value else True\n\n        return field"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nrenders the field for given data", "response": "def render_field(self, field, data):\n        \"\"\"Render field for given data\"\"\"\n        from trionyx.renderer import renderer\n\n        if 'value' in field:\n            value = field['value']\n        elif isinstance(data, object) and hasattr(data, field['field']):\n            value = getattr(data, field['field'])\n            if 'renderer' not in field:\n                value = renderer.render_field(data, field['field'], **field)\n        elif isinstance(data, dict) and field['field'] in data:\n            value = data.get(field['field'])\n        elif isinstance(data, list) and field['__index__'] < len(data):\n            value = data[field['__index__']]\n        else:\n            return ''\n\n        options = {key: value for key, value in field.items() if key not in ['value', 'data_object']}\n        if 'renderer' in field:\n            value = field['renderer'](value, data_object=data, **options)\n        else:\n            value = renderer.render_value(value, data_object=data, **options)\n\n        return field['format'].format(value)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_rendered_object(self, obj=None):\n        obj = obj if obj else self.object\n        return [\n            {\n                **field,\n                'value': self.render_field(field, obj)\n            }\n            for field in self.get_fields()\n        ]", "response": "Render the object and return a list of dicts."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the rendered objects", "response": "def get_rendered_objects(self):\n        \"\"\"Render objects\"\"\"\n        objects = self.objects\n\n        if isinstance(objects, str):\n            objects = getattr(self.object, objects).all()\n\n        return [\n            self.get_rendered_object(obj)\n            for obj in objects\n        ]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_attr_text(self):\n        return ' '.join([\n            '{}=\"{}\"'.format(key, value)\n            for key, value in self.attr.items()\n        ])", "response": "Get html attr text to render in template"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef func_runtime(callback):\n    now = time.time()\n    print('%s - start: %f' % (callback, now))\n    callback()\n    now = time.time() - now\n    print('%s - spent: %f Second' % (callback, now))", "response": "Function to run in the thread"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef data_dir(default='data'):\n    if 'OPENSHIFT_DATA_DIR' in os.environ:\n        return os.environ['OPENSHIFT_DATA_DIR']\n    if 'GONDOR_DATA_DIR' in os.environ:\n        return os.environ['GONDOR_DATA_DIR']\n    if provider.detect() == provider.DOTCLOUD:\n        return os.path.expanduser('~/data')\n    return default", "response": "Return persistent data directory or default if not found"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate a tree for the given model and root node.", "response": "def mk_dropdown_tree(cls, model, root_node, for_node=None):\n        '''\n        Override of ``treebeard`` method to enforce the same root.\n        '''\n        options = []\n        # The difference is that we only generate the subtree for the current root.\n        logger.debug(\"Using root node pk of %s\" % root_node.pk)\n        cls.add_subtree(for_node, root_node, options)\n        return options[1:]"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the angle between vec_a and vec_b in range [ 0 PI )", "response": "def angle_v2_rad(vec_a, vec_b):\n    \"\"\"Returns angle between vec_a and vec_b in range [0, PI].  This does not\n    distinguish if a is left of or right of b.\n    \"\"\"\n    # cos(x) = A * B / |A| * |B|\n    return math.acos(vec_a.dot(vec_b) / (vec_a.length() * vec_b.length()))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef angle_v2_rad_dir(vec_a, vec_b):\n    # cos(x) = A * B / |A| * |B|\n    rads = math.acos(vec_a.dot(vec_b) / (vec_a.length() * vec_b.length()))\n    if vec_a.x * vec_b.y >= vec_a.y * vec_b.x:\n        return rads\n    else:\n        return -rads", "response": "Returns the angle between vec_a and vec_b in range - PI PI"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nrotate vector by angle in radians.", "response": "def rot_rads_v2(vec_a, rads):\n    \"\"\" Rotate vector by angle in radians.\"\"\"\n\n    x = vec_a.x * math.cos(rads) - vec_a.y * math.sin(rads)\n    y = vec_a.x * math.sin(rads) + vec_a.y * math.cos(rads)\n    return Vec2(x, y)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef scale_v2(vec, amount):\n\n    return Vec2(vec.x * amount, vec.y * amount)", "response": "Return a new Vec2 with x and y from vec and multiplied by amount."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the dot product of two vectors", "response": "def dot_v2(vec1, vec2):\n    \"\"\"Return the dot product of two vectors\"\"\"\n\n    return vec1.x * vec2.x + vec1.y * vec2.y"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the crossproduct of two vectors as a Vec2.", "response": "def cross_v2(vec1, vec2):\n    \"\"\"Return the crossproduct of the two vectors as a Vec2.\n    Cross product doesn't really make sense in 2D, but return the Z component\n    of the 3d result.\n    \"\"\"\n\n    return vec1.y * vec2.x - vec1.x * vec2.y"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsubtracting v from w.", "response": "def sub_v2(v, w):\n    \"\"\"Subtract: v - w.  Assume the first arg v is a Vec2.\n    The second arg w can be a vec2 or a number.\n    \"\"\"\n\n    if type(w) is float or type(w) is int:\n        return Vec2(v.x - w, v.y - w)\n    else:\n        return Vec2(v.x - w.x, v.y - w.y)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef truncate(self, max_length):\n\n        if self.length() > max_length:\n\n            # If it's longer than the max_length, scale to the max_length.\n            self.scale(max_length / self.length())", "response": "Truncate this vector so it s length does not exceed max."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_scaled_v2(self, amount):\n\n        return Vec2(self.x * amount, self.y * amount)", "response": "Return a new Vec2 with x and y multiplied by amount."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns square length of x and y.", "response": "def get_norm(self):\n        \"\"\"Return square length: x*x + y*y.\"\"\"\n\n        return self.x * self.x + self.y * self.y"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef dot(self, vec):\n\n        return self.x * vec.x + self.y * vec.y", "response": "Return the dot product of self and another Vec2."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the 2d cross product of self with another vector.", "response": "def cross(self, vec):\n        \"\"\"Return the 2d cross product of self with another vector.\n        Cross product doesn't make sense in 2D, but return the Z component\n        of the 3d result.\n        \"\"\"\n\n        return self.x * vec.y - vec.x * self.y"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef rot_rads(self, rads):\n\n        new_x = self.x * math.cos(rads) - self.y * math.sin(rads)\n        self.y = self.x * math.sin(rads) + self.y * math.cos(rads)\n        self.x = new_x", "response": "Rotate vector by angle in radians."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef action(*methods, **kwargs):\n\n    # Convert methods to a list, so it can be mutated if needed\n    methods = list(methods)\n\n    # Build up the function attributes\n    attrs = dict(_wsgi_action=True)\n\n    # Get the path...\n    if methods and methods[0][0] == '/':\n        # Normalize the path and set the attr\n        attrs['_wsgi_path'] = utils.norm_path(methods.pop(0))\n\n        # Are we restricting the methods?\n        if methods:\n            attrs['_wsgi_methods'] = [meth.upper() for meth in methods]\n    else:\n        # Path will be computed from collection/resource and method\n        # name\n        attrs['_wsgi_path'] = None\n\n        # Allowed methods will be based on the function name; provide\n        # some value for the attribute so they get set by the _route()\n        # method\n        attrs['_wsgi_methods'] = None\n\n    # If we have a condition function, set it up\n    if 'conditions' in kwargs:\n        condition = kwargs.pop('conditions')\n\n        @functools.wraps(condition)\n        def wrapper(req, match_dict):\n            if isinstance(req, dict):\n                req = webob.Request(req)\n            return condition(req, match_dict)\n\n        attrs['_wsgi_condition'] = wrapper\n\n    # If we have a default code, set it up\n    if 'code' in kwargs:\n        attrs['_wsgi_code'] = kwargs.pop('code')\n\n    # Strip out action and controller arguments\n    kwargs.pop('action', None)\n    kwargs.pop('controller', None)\n\n    # Save additional keyword arguments\n    if kwargs:\n        attrs['_wsgi_keywords'] = kwargs\n\n    # Now, build the decorator we're going to return\n    def decorator(func):\n        # Save the attributes\n        func.__dict__.update(attrs)\n        return func\n\n    return decorator", "response": "Decorator that marks a method as an action."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _get_action(self, action):\n\n        # If we don't have an action named that, bail out\n        if action not in self.wsgi_actions:\n            return None\n\n        # Generate an ActionDescriptor if necessary\n        if action not in self.wsgi_descriptors:\n            self.wsgi_descriptors[action] = actions.ActionDescriptor(\n                self.wsgi_actions[action],\n                self.wsgi_extensions.get(action, []),\n                self.wsgi_resp_type)\n\n        # OK, return the method descriptor\n        return self.wsgi_descriptors[action]", "response": "Retrieve a method descriptor for the named action."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ngenerate a route for the action and method.", "response": "def _route(self, action, method):\n        \"\"\"\n        Given an action method, generates a route for it.\n        \"\"\"\n\n        # First thing, determine the path for the method\n        path = method._wsgi_path\n        methods = None\n        if path is None:\n            map_rule = self.wsgi_method_map.get(method.__name__)\n            if map_rule is None:\n                # Can't connect this method\n                LOG.warning(\"No path specified for action method %s() of \"\n                            \"resource %s\" % (method.__name__, self.wsgi_name))\n                return\n\n            # Compute the path and the method list\n            path = utils.norm_path(map_rule[0] % self.wsgi_name)\n            methods = map_rule[1]\n\n        # Compute route name\n        name = '%s_%s' % (self.wsgi_name, action)\n\n        # Set up path\n        path = getattr(self, 'wsgi_path_prefix', '') + path\n\n        # Build up the conditions\n        conditions = {}\n        if hasattr(method, '_wsgi_methods'):\n            conditions['method'] = methods if methods else method._wsgi_methods\n        if hasattr(method, '_wsgi_condition'):\n            conditions['function'] = method._wsgi_condition\n\n        # Create the route\n        self.wsgi_mapper.connect(name, path,\n                                 controller=self,\n                                 action=action,\n                                 conditions=conditions,\n                                 **getattr(method, '_wsgi_keywords', {}))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef wsgi_extend(self, controller):\n\n        # Add/override actions\n        for key, action in controller.wsgi_actions.items():\n            # If it's a new action, we'll need to route\n            if self.wsgi_mapper and key not in self.wsgi_actions:\n                self._route(key, action)\n\n            self.wsgi_actions[key] = action\n\n            # Clear existing action descriptors\n            self.wsgi_descriptors.pop(key, None)\n\n        # Register extensions\n        for key, extensions in controller.wsgi_extensions.items():\n            # Skip empty extension lists\n            if not extensions:\n                continue\n\n            # Prime the pump...\n            self.wsgi_extensions.setdefault(key, [])\n\n            # Add the extensions\n            self.wsgi_extensions[key].extend(extensions)\n\n            # Clear existing action descriptors\n            self.wsgi_descriptors.pop(key, None)", "response": "Extends a controller by registering another controller as an anonymization of the controller."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncall when a message is received from the server.", "response": "def on_message(self, data):\n        \"\"\" Parsing data, and try to call responding message \"\"\"\n        # Trying to parse response\n        data = json.loads(data)\n        if not data[\"name\"] is None:\n            logging.debug(\"%s: receiving message %s\" % (data[\"name\"], data[\"data\"]))\n            fct = getattr(self, \"on_\" + data[\"name\"])\n            try:\n                res = fct(Struct(data[\"data\"]))\n            except:\n                # We try without Struct item (on transaction request this can happend)\n                res = fct(data[\"data\"])\n            if res is not None:\n                self.write_message(res)\n        else:\n            logging.error(\"SockJSDefaultHandler: data.name was null\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\npublishes data to all room users", "response": "def publish(self, name, data, userList):\n        \"\"\" Publish data \"\"\"\n        # Publish data to all room users\n        self.broadcast(userList, {\n            \"name\": name,\n            \"data\": SockJSDefaultHandler._parser.encode(data)\n        })"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef join(self, _id):\n        if not SockJSRoomHandler._room.has_key(self._gcls() + _id):\n            SockJSRoomHandler._room[self._gcls() + _id] = set()\n        SockJSRoomHandler._room[self._gcls() + _id].add(self)", "response": "Join a room with the given ID"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef getRoom(self, _id):\n        if SockJSRoomHandler._room.has_key(self._gcls() + _id):\n            return SockJSRoomHandler._room[self._gcls() + _id]\n        return None", "response": "Retrieve a room from it s id"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef publishToRoom(self, roomId, name, data, userList=None):\n        if userList is None:\n            userList = self.getRoom(roomId)\n\n        # Publish data to all room users\n        logging.debug(\"%s: broadcasting (name: %s, data: %s, number of users: %s)\" % (self._gcls(), name, data, len(userList)))\n        self.broadcast(userList, {\n            \"name\": name,\n            \"data\": SockJSRoomHandler._parser.encode(data)\n        })", "response": "Publish data to given room"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef publishToOther(self, roomId, name, data):\n        tmpList = self.getRoom(roomId)\n        # Select everybody except me\n        userList = [x for x in tmpList if x is not self]\n        self.publishToRoom(roomId, name, data, userList)", "response": "Publish to only other people than myself"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef publishToMyself(self, roomId, name, data):\n        self.publishToRoom(roomId, name, data, [self])", "response": "Publish to only myself"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef isInRoom(self, _id):\n        if SockJSRoomHandler._room.has_key(self._gcls() + _id):\n            if self in SockJSRoomHandler._room[self._gcls() + _id]:\n                return True\n        return False", "response": "Check a given user is in given room"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef parse(schema):\n    if not isinstance(schema, basestring):\n        # assume it is file-like\n        schema = schema.read()\n\n    message = re.compile(r'^\\(([^,]+),\\s*(\\d+)\\):\\s*$')\n    field = re.compile(r'^-\\s*([^:]+):\\s+(.+?)\\s*$')\n\n    registry = MessageRegistry({})\n    messages = registry.messages\n    curr = None\n    names = None\n    for lineno, line in enumerate(schema.split('\\n')):\n        line = line.strip()\n        if '#' in line:\n            line = line[:line.index('#')]\n        if line == '':\n            continue\n\n        f = field.match(line)\n        if f:\n            if curr is None:\n                raise ParseError(\n                    'field definition outside of message at line %d' % lineno)\n            name = f.group(1)\n            type = f.group(2)\n            if name not in names:\n                f = Field(curr, name, type)\n                curr.fields.append(f)\n                names.add(name)\n                continue\n            else:\n                raise ParseError(\n                    'duplicate field name \"%s\" at line %d' % (name, lineno))\n\n        m = message.match(line)\n        if m:\n            # new message definition\n            name, vers = m.group(1), int(m.group(2))\n            if (name, vers) in messages:\n                raise ParseError('Duplicate message (%s, %d)' % (name, vers))\n            curr = messages[(name, vers)] = Message(registry, name, vers, [])\n            names = set()\n            continue\n\n    for message in registry.messages.values():\n        message.fields = tuple(message.fields)\n\n    return registry", "response": "Parse a string or file - like object and return a MessageRegistry with the loaded messages."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef write(self, fieldname, value=Nothing):\n        type = self._check(fieldname, value)\n        if self._pos == -1:\n            # write header\n            self.stream.write('M')\n            self._write_str(self.message.name)\n            self._write_int(self.message.version)\n            self._pos = 0\n\n        writer = getattr(self, '_write_' + type)\n        out = writer(value)\n        self._pos += 1\n        return out", "response": "Writes the value to the stream."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef readline(self, size=None):\n        if self._pos >= self.length:\n            return ''\n        if size:\n            amount = min(size, (self.length - self._pos))\n        else:\n            amount = self.length - self._pos\n        out = self.stream.readline(amount)\n        self._pos += len(out)\n        return out", "response": "Read a line from the underlying stream including the trailing new line character."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef skip(self):\n        self.stream.seek(self.bytes_remaining(), os.SEEK_CUR)\n        self._pos = self.length", "response": "Skip the next available data area in the internal buffer."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreads the next value from the stream.", "response": "def read(self, fieldname):\n        \"\"\"\n        Read the next field from the stream. `fieldname` is used\n        to verify that your application logic matches the message\n        field order, and if `fieldname` does not match the next\n        field in the message definition, :class:`SendlibError`\n        is raised.\n\n        Returns a Python object of the correct type, depending on\n        the type present in the stream. If the type is ``data``,\n        returns a :class:`Data` file-like object.\n        \"\"\"\n        if self._pos == -1:\n            self._pos = 0\n            if PREFIX['message'] != self.stream.read(1):\n                raise SendlibError('Invalid message format')\n            if PREFIX['str'] != self.stream.read(1):\n                raise SendlibError('Invalid message format')\n            name = self._read_str()\n            if PREFIX['int'] != self.stream.read(1):\n                raise SendlibError('Invalid message format')\n            version = self._read_int()\n            if name != self.message.name or version != self.message.version:\n                raise SendlibError(\n                    'Reader for %s cannot read message of type (%s, %d)'\n                    % (self.message, name, version))\n\n        if self._data is not None:\n            if self._data.bytes_remaining() == 0:\n                self._data = None\n            else:\n                raise Exception('cannot read field, cursor still on data')\n\n        if self._peek is None:\n            self._peek = self.stream.read(1)\n        typename = self._check(fieldname)\n        reader = getattr(self, '_read_' + typename)\n        value = reader()\n        self._pos += 1\n        self._peek = None\n        return value"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef find_tag(__matcher: str = 'v[0-9]*', *, strict: bool = True,\n             git_dir: str = '.') -> str:\n    \"\"\"Find closest tag for a git repository.\n\n    Note:\n        This defaults to `Semantic Version`_ tag matching.\n\n    Args:\n        __matcher: Glob-style tag pattern to match\n        strict: Allow commit-ish, if no tag found\n        git_dir: Repository to search\n    Returns:\n        Matching tag name\n\n    .. _Semantic Version: http://semver.org/\n    \"\"\"\n    command = 'git describe --abbrev=12 --dirty'.split()\n    with chdir(git_dir):\n        try:\n            stdout = check_output(command + ['--match={}'.format(__matcher), ])\n        except CalledProcessError:\n            if strict:\n                raise\n            stdout = check_output(command + ['--always', ])\n\n        stdout = stdout.decode('ascii', 'replace')\n    return stdout.strip()", "response": "Find closest tag for a git repository."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nwraps of Client. on_message that accepts a message and returns True if the message was accepted False otherwise.", "response": "def on_message(self, *args, accept_query=False, matcher=None, **kwargs):\n        \"\"\"\n        Convenience wrapper of `Client.on_message` pre-bound with `channel=self.name`.\n        \"\"\"\n\n        if accept_query:\n            def new_matcher(msg: Message):\n                ret = True\n                if matcher:\n                    ret = matcher(msg)\n                    if ret is None or ret is False:\n                        return ret\n                if msg.recipient is not self and not isinstance(msg.sender, User):\n                    return False\n                return ret\n        else:\n            kwargs.setdefault(\"channel\", self.name)\n            new_matcher = matcher\n        return self.client.on_message(*args, matcher=new_matcher, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nblocking until a message matches. See on_message.", "response": "def await_message(self, *args, **kwargs) -> 'asyncio.Future[Message]':\n        \"\"\"\n        Block until a message matches. See `on_message`\n        \"\"\"\n        fut = asyncio.Future()\n        @self.on_message(*args, **kwargs)\n        async def handler(message):\n            fut.set_result(message)\n        # remove handler when done or cancelled\n        fut.add_done_callback(lambda _: self.remove_message_handler(handler))\n        return fut"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef on_join(self, channel: str=None) -> Callable[[Callable], Callable]:\n        def decorator(fn: Callable[[self.IrcMessage], None]):\n            jh = self.JoinHandler(channel, fn)\n            self._on_join_handlers.append(jh)\n            self._log.debug(\"Added join handler {}\".format(jh))\n            return fn\n\n        return decorator", "response": "Register a handler that s called after a channel is joined."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nregistering a handler that's called when (the beginning of) a `IrcMessage` matches. The handler is called with the `IrcMessage` as argument, must be a coroutine and is run blocking, i.e. you cannot use `await_command` in it! :param args: commands args that must match (the actual command is the first arg) :param rest: match the rest (after the \" :\") of the `IrcMessage`", "response": "def on_command(self, *args: Sequence[str], rest: str=None) -> Callable[[Callable], Callable]:\n        \"\"\"\n        Register a handler that's called when (the beginning of) a `IrcMessage` matches.\n        The handler is called with the `IrcMessage` as argument, must be a coroutine\n        and is run blocking, i.e. you cannot use `await_command` in it!\n        :param args: commands args that must match (the actual command is the first arg)\n        :param rest: match the rest (after the \" :\") of the `IrcMessage`\n        \"\"\"\n        def decorator(fn: Callable[[self.IrcMessage], None]):\n            ch = self.CommandHandler(args, rest, fn)\n            self._on_command_handlers.append(ch)\n            self._log.debug(\"Added command handler {}\".format(ch))\n            return fn\n\n        return decorator"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nblocking until a command matches. See on_command.", "response": "def await_command(self, *args, **kwargs) -> 'asyncio.Future[IrcMessage]':\n        \"\"\"\n        Block until a command matches. See `on_command`\n        \"\"\"\n        fut = asyncio.Future()\n        @self.on_command(*args, **kwargs)\n        async def handler(msg):\n            fut.set_result(msg)\n        # remove handler when done or cancelled\n        fut.add_done_callback(lambda _: self.remove_command_handler(handler))\n        return fut"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\nasync def message(self, recipient: str, text: str, notice: bool=False) -> None:\n        await self._send(cc.PRIVMSG if not notice else cc.NOTICE, recipient, rest=text)", "response": "Sends a message to recipient."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nruns coro in background", "response": "def _bg(self, coro: coroutine) -> asyncio.Task:\n        \"\"\"Run coro in background, log errors\"\"\"\n        async def runner():\n            try:\n                await coro\n            except:\n                self._log.exception(\"async: Coroutine raised exception\")\n        return asyncio.ensure_future(runner())"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget a user object from the cache.", "response": "def get_user(self, nick: str) -> User:\n        \"\"\"\n        :param nick: nick or prefix\n        \"\"\"\n        hostmask = None\n        if \"!\" in nick:\n            nick, _, hostmask = nick.partition(\"!\")\n        user = self._users.get(nick)\n        if not user:\n            self._users[nick] = user = User(nick, self, hostmask=hostmask)\n        elif not user.hostmask:\n            user.hostmask = hostmask\n        return user"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _populate(self, client):\n        self.client = client\n        for fn in self._buffered_calls:\n            self._log.debug(\"Executing buffered call {}\".format(fn))\n            fn()", "response": "Populate the module with the client when available."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _modify(self, paths: Union[str, List[str]], metadata_for_paths: Union[IrodsMetadata, List[IrodsMetadata]],\n                operation: str):\n        \"\"\"\n        Modifies the metadata of the entity or entities in iRODS with the given path.\n        :param path: the paths of the entity or entities to modify\n        :param metadata_for_paths: the metadata to change. If only one metadata object is given, that metadata is set\n        for all, else the metadata is matched against the path with the corresponding index\n        :param operation: the baton operation used to modify the metadata\n        \"\"\"\n        if isinstance(paths, str):\n            paths = [paths]\n        if isinstance(metadata_for_paths, IrodsMetadata):\n            metadata_for_paths = [metadata_for_paths for _ in paths]\n        elif len(paths) != len(metadata_for_paths):\n            raise ValueError(\"Metadata not supplied for all paths - either supply a single IrodsMetadata collection \"\n                             \"to apply for all paths or supply a collection for each path\")\n\n        assert len(paths) == len(metadata_for_paths)\n        baton_in_json = []\n        for i in range(len(metadata_for_paths)):\n            entity = self._create_entity_with_path(paths[i])\n            entity.metadata = metadata_for_paths[i]\n            baton_in_json.append(self._entity_to_baton_json(entity))\n        arguments = [BATON_METAMOD_OPERATION_FLAG, operation]\n        self.run_baton_query(BatonBinary.BATON_METAMOD, arguments, input_data=baton_in_json)", "response": "Modify the metadata of the entity or entities in iRODS with the given paths."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconverts a path to the type of iRODS entity the mapper deals with.", "response": "def _path_to_baton_json(self, path: str) -> Dict:\n        \"\"\"\n        Converts a path to the type of iRODS entity the mapper deals with, to its JSON representation.\n        :param path: the path to convert\n        :return: the JSON representation of the path\n        \"\"\"\n        entity = self._create_entity_with_path(path)\n        return self._entity_to_baton_json(entity)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets a schema class which has been associated to input data type by the registry or factory.", "response": "def datatype2schemacls(\n        _datatype, _registry=None, _factory=None, _force=True,\n        _besteffort=True, **kwargs\n):\n    \"\"\"Get a schema class which has been associated to input data type by the\n    registry or the factory in this order.\n\n    :param type datatype: data type from where get associated schema.\n    :param SchemaRegisgry _registry: registry from where call the getbydatatype\n        . Default is the global registry.\n    :param SchemaFactory _factory: factory from where call the getschemacls if\n        getbydatatype returns None. Default is the global factory.\n    :param bool _force: if true (default), force the building of schema class\n        if no schema is associated to input data type.\n    :param bool _besteffort: if True (default), try to resolve schema by\n        inheritance.\n    :param dict kwargs: factory builder kwargs.\n    :rtype: type\n    :return: Schema associated to input registry or factory. None if no\n        association found.\n    \"\"\"\n    result = None\n\n    gdbt = getbydatatype if _registry is None else _registry.getbydatatype\n\n    result = gdbt(_datatype, besteffort=_besteffort)\n\n    if result is None:\n        gscls = getschemacls if _factory is None else _factory.getschemacls\n        result = gscls(_datatype, besteffort=_besteffort)\n\n    if result is None and _force:\n        _build = build if _factory is None else _factory.build\n\n        result = _build(_resource=_datatype, **kwargs)\n\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a function that converts data to a schema.", "response": "def data2schema(\n        _data=None, _force=False, _besteffort=True, _registry=None,\n        _factory=None, _buildkwargs=None, **kwargs\n):\n    \"\"\"Get the schema able to instanciate input data.\n\n    The default value of schema will be data.\n\n    Can be used such as a decorator:\n\n    ..code-block:: python\n\n        @data2schema\n        def example(): pass  # return a function schema\n\n        @data2schema(_registry=myregistry)\n        def example(): pass  # return a function schema with specific registry\n\n    ..warning::\n\n        return this function id _data is None.\n\n    :param _data: data possibly generated by a schema. Required but in case of\n        decorator.\n    :param bool _force: if True (False by default), create the data schema\n        on the fly if it does not exist.\n    :param bool _besteffort: if True (default), find a schema class able to\n        validate data class by inheritance.\n    :param SchemaRegistry _registry: default registry to use. Global by\n        default.\n    :param SchemaFactory factory: default factory to use. Global by default.\n    :param dict _buildkwargs: factory builder kwargs.\n    :param kwargs: schema class kwargs.\n    :return: Schema.\n    :rtype: Schema.\n    \"\"\"\n    if _data is None:\n        return lambda _data: data2schema(\n            _data, _force=False, _besteffort=True, _registry=None,\n            _factory=None, _buildkwargs=None, **kwargs\n        )\n\n    result = None\n\n    fdata = _data() if isinstance(_data, DynamicValue) else _data\n\n    datatype = type(fdata)\n\n    content = getattr(fdata, '__dict__', {})\n    if _buildkwargs:\n        content.udpate(_buildkwargs)\n\n    schemacls = datatype2schemacls(\n        _datatype=datatype, _registry=_registry, _factory=_factory,\n        _force=_force, _besteffort=_besteffort, **content\n    )\n\n    if schemacls is not None:\n        result = schemacls(default=_data, **kwargs)\n\n        for attrname in dir(_data):\n\n            if not hasattr(schemacls, attrname):\n                attr = getattr(_data, attrname)\n                if attr is not None:\n                    setattr(result, attrname, attr)\n\n    if result is None and _data is None:\n        result = AnySchema()\n\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconverting a data dict to a schema class.", "response": "def data2schemacls(_data, **kwargs):\n    \"\"\"Convert a data to a schema cls.\n\n    :param data: object or dictionary from where get a schema cls.\n    :return: schema class.\n    :rtype: type\n    \"\"\"\n    content = {}\n\n    for key in list(kwargs):  # fill kwargs\n        kwargs[key] = data2schema(kwargs[key])\n\n    if isinstance(_data, dict):\n        datacontent = iteritems(_data)\n\n    else:\n        datacontent = getmembers(_data)\n\n    for name, value in datacontent:\n\n        if name[0] == '_':\n            continue\n\n        if isinstance(value, dict):\n            schema = data2schemacls(value)()\n\n        else:\n            schema = data2schema(value)\n\n        content[name] = schema\n\n    content.update(kwargs)  # update content\n\n    result = type('GeneratedSchema', (Schema,), content)\n\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nvalidate input data with input schema.", "response": "def validate(schema, data, owner=None):\n    \"\"\"Validate input data with input schema.\n\n    :param Schema schema: schema able to validate input data.\n    :param data: data to validate.\n    :param Schema owner: input schema parent schema.\n    :raises: Exception if the data is not validated.\n    \"\"\"\n    schema._validate(data=data, owner=owner)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef dump(schema):\n    result = {}\n\n    for name, _ in iteritems(schema.getschemas()):\n\n        if hasattr(schema, name):\n            val = getattr(schema, name)\n\n            if isinstance(val, DynamicValue):\n                val = val()\n\n            if isinstance(val, Schema):\n                val = dump(val)\n\n            result[name] = val\n\n    return result", "response": "Get a serialized value of input schema."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ntransform all schema class attributes to schemas. It can be used such as a decorator in order to ensure to update attributes with the decorated schema but take care to the limitation to use old style method call for overidden methods. .. example: @updatecontent # update content at the end of its definition. class Test(Schema): this = ThisSchema() # instance of Test. def __init__(self, *args, **kwargs): Test.__init__(self, *args, **kwargs) # old style method call. :param type schemacls: sub class of Schema. :param bool updateparents: if True (default), update parent content. :param list exclude: attribute names to exclude from updating. :return: schemacls.", "response": "def updatecontent(schemacls=None, updateparents=True, exclude=None):\n    \"\"\"Transform all schema class attributes to schemas.\n\n    It can be used such as a decorator in order to ensure to update attributes\n    with the decorated schema but take care to the limitation to use old style\n    method call for overidden methods.\n\n    .. example:\n        @updatecontent  # update content at the end of its definition.\n        class Test(Schema):\n            this = ThisSchema()  # instance of Test.\n            def __init__(self, *args, **kwargs):\n                Test.__init__(self, *args, **kwargs)  # old style method call.\n\n    :param type schemacls: sub class of Schema.\n    :param bool updateparents: if True (default), update parent content.\n    :param list exclude: attribute names to exclude from updating.\n    :return: schemacls.\n    \"\"\"\n    if schemacls is None:\n        return lambda schemacls: updatecontent(\n            schemacls=schemacls, updateparents=updateparents, exclude=exclude\n        )\n\n    if updateparents and hasattr(schemacls, 'mro'):\n        schemaclasses = reversed(list(schemacls.mro()))\n\n    else:\n        schemaclasses = [schemacls]\n\n    for schemaclass in schemaclasses:\n        for name, member in iteritems(getattr(schemaclass, '__dict__', {})):\n            # transform only public members\n            if name[0] != '_' and (exclude is None or name not in exclude):\n\n                toset = False  # flag for setting schemas\n\n                fmember = member\n\n                if isinstance(fmember, DynamicValue):\n                    fmember = fmember()\n                    toset = True\n\n                if isinstance(fmember, Schema):\n                    schema = fmember\n\n                    if not schema.name:\n                        schema.name = name\n\n                else:\n                    toset = True\n\n                    data = member\n\n                    if name == 'default':\n\n                        if isinstance(fmember, ThisSchema):\n                            data = schemaclass(*fmember.args, **fmember.kwargs)\n\n                        schema = RefSchema(default=data, name=name)\n\n                    elif isinstance(fmember, ThisSchema):\n\n                        schema = schemaclass(\n                            name=name, *fmember.args, **fmember.kwargs\n                        )\n\n                    elif member is None:\n                        schema = AnySchema(name=name)\n\n                    else:\n                        schema = data2schema(_data=data, name=name)\n\n                if isinstance(schema, Schema) and toset:\n\n                    try:\n                        setattr(schemaclass, name, schema)\n\n                    except (AttributeError, TypeError):\n                        break\n\n    return schemacls"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef verify_key(self, url):\n        \n        response = self._request('verify-key', {\n            'blog': url,\n            'key': self._key\n        })\n        \n        if response.status is 200:\n            # Read response (trimmed of whitespace)\n            return response.read().strip() == \"valid\"\n            \n        return False", "response": "For verifying your API key."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef submit_ham(self, params):\n    \n        # Check required params for submit-ham\n        for required in ['blog', 'user_ip', 'user_agent']:\n            if required not in params:\n                raise MissingParams(required) \n    \n        response = self._request('submit-ham', params)\n        \n        if response.status is 200:\n            return response.read() == \"true\"\n            \n        return False", "response": "For submitting a ham comment to Akismet."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _request(self, function, params, method='POST', headers={}):\n        \n        if method is 'POST':\n            params = urllib.parse.urlencode(params)\n            headers = { \"Content-type\": \"application/x-www-form-urlencoded\", \"Accept\": \"text/plain\" }\n        \n        path = '/%s/%s' % (self._version, function)\n        \n        self._conn.request(method, path, params, headers)\n        return self._conn.getresponse()", "response": "Builds a request object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a new user", "response": "def create_user(user, name, create=None):  # noqa: E501\n    \"\"\"Create a new script\n\n    Create a new script # noqa: E501\n\n    :param user: Get user with this name\n    :type user: str\n    :param name: Get status of a driver with this name\n    :type name: str\n    :param create: The data needed to create this user\n    :type create: dict | bytes\n\n    :rtype: Response\n    \"\"\"\n    if connexion.request.is_json:\n        create = Create.from_dict(connexion.request.get_json())  # noqa: E501\n\n    response = errorIfUnauthorized(role='admin')\n    if response:\n        return response\n    else:\n        response = ApitaxResponse()\n\n    driver: Driver = LoadedDrivers.getDriver(name)\n    user: User = mapUserToUser(create.script)\n\n    if driver.createApitaxUser(user):\n        return Response(status=200, body=response.getResponseBody())\n\n    return ErrorResponse(status=500, message='Failed to create user')"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef refresh_token():  # noqa: E501\n    current_user = get_jwt_identity()\n    if not current_user:\n        return ErrorResponse(status=401, message=\"Not logged in\")\n    access_token = create_access_token(identity=current_user)\n    return AuthResponse(status=201, message='Refreshed Access Token', access_token=access_token, auth=UserAuth())", "response": "Refreshes login token using refresh token"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsaves a script Save a script # noqa: E501 :param user: Get user with this name :type user: str :param name: Get status of a driver with this name :type name: str :param save: The data needed to save this user :type save: dict | bytes :rtype: Response", "response": "def save_user(user, name, save=None):  # noqa: E501\n    \"\"\"Save a script\n\n    Save a script # noqa: E501\n\n    :param user: Get user with this name\n    :type user: str\n    :param name: Get status of a driver with this name\n    :type name: str\n    :param save: The data needed to save this user\n    :type save: dict | bytes\n\n    :rtype: Response\n    \"\"\"\n    if connexion.request.is_json:\n        save = Save.from_dict(connexion.request.get_json())  # noqa: E501\n\n    response = errorIfUnauthorized(role='admin')\n    if response:\n        return response\n    else:\n        response = ApitaxResponse()\n\n    driver: Driver = LoadedDrivers.getDriver(name)\n    user: User = mapUserToUser(save.script)\n\n    if driver.saveApitaxUser(user):\n        return Response(status=200, body=response.getResponseBody())\n\n    return ErrorResponse(status=500, message='Failed to create user')"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nbuilds a schema from input _resource.", "response": "def build(_resource, _cache=True, **kwargs):\n    \"\"\"Build a schema from input _resource.\n\n    :param _resource: object from where get the right schema.\n    :param bool _cache: use cache system.\n    :rtype: Schema.\n    \"\"\"\n    return _SCHEMAFACTORY.build(_resource=_resource, _cache=True, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef getschemacls(resource, besteffort=False):\n    return _SCHEMAFACTORY.getschemacls(\n        resource=resource, besteffort=besteffort\n    )", "response": "Get schema class related to input resource."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting a resource from a waited schema class.", "response": "def getresource(self, schemacls, name):\n    \"\"\"Get a resource from a builder name.\n\n    :param type schemacls: waited schema class.\n    :param str name: builder name to use.\n    :return: resource returned by the right builder.getresource(schema).\n    \"\"\"\n    return _SCHEMAFACTORY.getresource(schemacls=schemacls, name=name)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef registerbuilder(self, builder, name=None):\n        if name is None:\n            name = uuid()\n\n        self._builders[name] = builder\n\n        return builder", "response": "Register a schema builder with a key name."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef build(self, _resource, _cache=True, updatecontent=True, **kwargs):\n        result = None\n\n        if _cache and _resource in self._schemasbyresource:\n            result = self._schemasbyresource[_resource]\n\n        else:\n            for builder in self._builders.values():\n                try:\n                    result = builder.build(_resource=_resource, **kwargs)\n\n                except Exception:\n                    pass\n\n                else:\n                    break\n\n            if result is None:\n                raise ValueError('No builder found for {0}'.format(_resource))\n\n            if _cache:\n                self._schemasbyresource[_resource] = result\n\n            if updatecontent:\n                from ..utils import updatecontent\n                updatecontent(result, updateparents=False)\n\n        return result", "response": "Build a schema class from input _resource."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef getschemacls(self, resource, besteffort=True):\n        result = None\n\n        if hasattr(resource, 'mro') and besteffort and isclass(resource):\n            resources = list(resource.mro())\n\n        else:\n            resources = [resource]\n\n        for _resource in resources:\n            if _resource in self._schemasbyresource:\n                result = self._schemasbyresource[_resource]\n\n                break\n\n        return result", "response": "Get schema class related to input resource."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef getresource(self, schemacls, name):\n        return self.builders[name].getresource(schemacls=schemacls)", "response": "Get a resource from a builder name."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nrunning a shell command.", "response": "def s(command, verbose=False, fail_fast=True, interactive=False):\n    \"\"\"\n    Run a shell command.\n    \"\"\"\n\n    completed_process = None\n    output = None\n    if interactive:\n        completed_process = subprocess.run(\n            command,\n            shell=True,\n            stdin=sys.stdin,\n            stdout=sys.stdout,\n            stderr=sys.stderr,\n        )\n        output = {\n            \"exit_code\": completed_process.returncode,\n        }\n    else:\n        completed_process = subprocess.run(\n            command,\n            shell=True,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n        )\n        output = {\n            \"exit_code\": completed_process.returncode,\n            \"out\": completed_process.stdout.decode('utf-8'),\n            \"err\": completed_process.stderr.decode('utf-8'),\n        }\n\n    result = None\n    if completed_process.returncode == 0:\n        result = cmn.OkResult(output)\n    else:\n        result = cmn.ErrorResult(output)\n\n    fail = fail_fast and not result.ok\n\n    if verbose or fail:\n        cmn.logger.log(\n            \"Executed shell command '{command}'\\n\"\n            \"exit code was: {exit_code}\\n\".format(\n                command=command,\n                **result.value\n            )\n        )\n\n    if (verbose or fail) and not interactive:\n        cmn.logger.log(\n            \"stdout was:\\n{out}\\n\"\n            \"stderr was:\\n{err}\".format(\n                **result.value\n            )\n        )\n\n    if fail:\n        cmn.fail(\"Failed executing shell command '{command}'\".format(command=command))\n\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef stop():\n    '''Stops lazarus, regardless of which mode it was started in.\n\n    For example:\n\n        >>> import lazarus\n        >>> lazarus.default()\n        >>> lazarus.stop()\n    '''\n    global _active\n    if not _active:\n        msg = 'lazarus is not active'\n        raise RuntimeWarning(msg)\n    _observer.stop()\n    _observer.join()\n    _deactivate()", "response": "Stops lazarus regardless of which mode it was started in."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nscheduling the restart ; returning True if cancelled False otherwise.", "response": "def _restart():\n    '''Schedule the restart; returning True if cancelled, False otherwise.'''\n    if _restart_cb:\n        # https://github.com/formwork-io/lazarus/issues/2\n        if _restart_cb() is not None:\n            # restart cancelled\n            return True\n\n    def down_watchdog():\n        _observer.stop()\n        _observer.join()\n\n        if _close_fds:\n            # close all fds...\n            _util.close_fds()\n\n        # declare a mulligan ;)\n        if _restart_func:\n            _restart_func()\n            _deactivate()\n        else:\n            _util.do_over()\n\n    _util.defer(down_watchdog)\n    return False"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef is_restart_event(event):\n    '''Default logic for whether a filesystem event is a *restart event*.\n\n    For example:\n\n        >>> import collections\n        >>> Event = collections.namedtuple('Event', 'src_path dest_path')\n        >>> vim_ev = Event('foo.py', None)\n        >>> is_restart_event(vim_ev)\n        True\n        >>> sublime_ev = Event('.subl6f0.tmp', '__main__.py')\n        >>> is_restart_event(sublime_ev)\n        True\n\n    If the event's source or destination path ends in ``.py``, the event is\n    considered a *restart event*. This covers most cases where a restart\n    should take place like developers using editors, IDEs, or version control\n    operations.\n    '''\n    if event.src_path.endswith('.py'):\n        return True\n    elif hasattr(event, 'dest_path') and event.dest_path.endswith('.py'):\n        return True\n    return False", "response": "Default logic for whether an event is a * restart event*."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting up lazarus in default mode.", "response": "def default(restart_cb=None, restart_func=None, close_fds=True):\n    '''Sets up lazarus in default mode.\n\n    See the :py:func:`custom` function for a more powerful mode of use.\n\n    The default mode of lazarus is to watch all modules rooted at\n    ``PYTHONPATH`` for changes and restart when they take place.\n\n    Keyword arguments:\n\n        restart_cb -- Callback invoked prior to restarting the process; allows\n        for any cleanup to occur prior to restarting. Returning anything other\n        than *None* in the callback will cancel the restart.\n\n        restart_func -- Function invoked to restart the process. This supplants\n        the default behavior of using *sys.executable* and *sys.argv*.\n\n        close_fds -- Whether all file descriptors other than *stdin*, *stdout*,\n        and *stderr* should be closed\n\n    A simple example:\n\n        >>> import lazarus\n        >>> lazarus.default()\n        >>> lazarus.stop()\n    '''\n    if _active:\n        msg = 'lazarus is already active'\n        raise RuntimeWarning(msg)\n\n    _python_path = os.getenv('PYTHONPATH')\n    if not _python_path:\n        msg = 'PYTHONPATH is not set'\n        raise RuntimeError(msg)\n\n    if restart_cb and not callable(restart_cb):\n        msg = 'restart_cb keyword argument is not callable'\n        raise TypeError(msg)\n\n    if restart_func and not callable(restart_func):\n        msg = 'restart_func keyword argument is not callable'\n        raise TypeError(msg)\n\n    global _close_fds\n    _close_fds = close_fds\n\n    try:\n        from watchdog.observers import Observer\n        from watchdog.events import FileSystemEventHandler\n    except ImportError as ie:\n        msg = 'no watchdog support (%s)' % str(ie)\n        raise RuntimeError(msg)\n\n    class _Handler(FileSystemEventHandler):\n\n        def __init__(self):\n            self.active = True\n\n        def dispatch(self, event):\n            if not self.active:\n                return\n            super(_Handler, self).dispatch(event)\n\n        def all_events(self, event):\n            if is_restart_event(event):\n                cancelled = _restart()\n                if not cancelled:\n                    self.active = False\n\n        def on_created(self, event):\n            self.all_events(event)\n\n        def on_deleted(self, event):\n            self.all_events(event)\n\n        def on_modified(self, event):\n            self.all_events(event)\n\n        def on_moved(self, event):\n            self.all_events(event)\n\n    global _observer\n    _observer = Observer()\n    handler = _Handler()\n    _observer.schedule(handler, _python_path, recursive=True)\n    global _restart_cb\n    _restart_cb = restart_cb\n    global _restart_func\n    _restart_func = restart_func\n\n    _activate()\n    _observer.start()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef custom(srcpaths, event_cb=None, poll_interval=1, recurse=True,\n           restart_cb=None, restart_func=None, close_fds=True):\n    '''Sets up lazarus in custom mode.\n\n    See the :py:func:`default` function for a simpler mode of use.\n\n    The custom mode of lazarus is to watch all modules rooted at any of the\n    source paths provided for changes and restart when they take place.\n\n    Keyword arguments:\n\n        event_cb -- Callback invoked when a file rooted at a source path\n        changes. Without specifying an event callback, changes to any module\n        rooted at a source path will trigger a restart.\n\n        poll_interval -- Rate at which changes will be detected. The default\n        value of ``1`` means it may take up to one second to detect changes.\n        Decreasing this value may lead to unnecessary overhead.\n\n        recurse -- Whether to watch all subdirectories of every source path for\n        changes or only the paths provided.\n\n        restart_cb -- Callback invoked prior to restarting the process; allows\n        for any cleanup to occur prior to restarting. Returning anything other\n        than *None* in the callback will cancel the restart.\n\n        restart_func -- Function invoked to restart the process. This supplants\n        the default behavior of using *sys.executable* and *sys.argv*.\n\n        close_fds -- Whether all file descriptors other than *stdin*, *stdout*,\n        and *stderr* should be closed\n\n    An example of using a cleanup function prior to restarting:\n\n        >>> def cleanup():\n        ...     pass\n        >>> import lazarus\n        >>> lazarus.custom(os.curdir, restart_cb=cleanup)\n        >>> lazarus.stop()\n\n    An example of avoiding restarts when any ``__main__.py`` changes:\n\n        >>> def skip_main(event):\n        ...     if event.src_path == '__main__.py':\n        ...         return False\n        ...     return True\n        >>> import lazarus\n        >>> lazarus.custom(os.curdir, event_cb=skip_main)\n        >>> lazarus.stop()\n    '''\n    if _active:\n        msg = 'lazarus is already active'\n        raise RuntimeWarning(msg)\n\n    if restart_cb and not callable(restart_cb):\n        msg = 'restart_cb keyword argument is not callable'\n        raise TypeError(msg)\n\n    if restart_func and not callable(restart_func):\n        msg = 'restart_func keyword argument is not callable'\n        raise TypeError(msg)\n\n    global _close_fds\n    _close_fds = close_fds\n\n    try:\n        from watchdog.observers import Observer\n        from watchdog.events import FileSystemEventHandler\n    except ImportError as ie:\n        msg = 'no watchdog support (%s)' % str(ie)\n        raise RuntimeError(msg)\n\n    class _Handler(FileSystemEventHandler):\n\n        def __init__(self):\n            self.active = True\n\n        def dispatch(self, event):\n            if not self.active:\n                return\n            super(_Handler, self).dispatch(event)\n\n        def all_events(self, event):\n            # if caller wants event_cb control, defer _restart logic to them\n            # (caller decides whether this is a restart event)\n            if event_cb:\n                if event_cb(event):\n                    cancelled = _restart()\n                    if not cancelled:\n                        self.active = False\n\n            # use default is_restart_event logic\n            elif is_restart_event(event):\n                cancelled = _restart()\n                if not cancelled:\n                    self.active = False\n                self.active = False\n\n        def on_created(self, event):\n            self.all_events(event)\n\n        def on_deleted(self, event):\n            self.all_events(event)\n\n        def on_modified(self, event):\n            self.all_events(event)\n\n        def on_moved(self, event):\n            self.all_events(event)\n\n    global _observer\n    kwargs = {'timeout': poll_interval}\n    _observer = Observer(**kwargs)\n    global _restart_cb\n    _restart_cb = restart_cb\n\n    handler = _Handler()\n    srcpaths = _as_list(srcpaths)\n    kwargs = {}\n    if recurse:\n        kwargs['recursive'] = True\n    for srcpath in srcpaths:\n        _observer.schedule(handler, srcpath, **kwargs)\n    _activate()\n    _observer.start()", "response": "Sets up lazarus in custom mode."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef tty_stream(self):\n        return hasattr(self.options.stream, \"isatty\") \\\n            and self.options.stream.isatty()", "response": "Returns True if our stream is a tty"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a tty stream if color is set or not", "response": "def color(self):\n        \"\"\"\n        Whether or not color should be output\n        \"\"\"\n        return self.tty_stream if self.options.color is None \\\n            else self.options.color"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef api_auth(func):\n    @wraps(func)\n    def _decorator(request, *args, **kwargs):\n        authentication = APIAuthentication(request)\n        if authentication.authenticate():\n            return func(request, *args, **kwargs)\n        raise Http404\n    return _decorator", "response": "Decorator for API authentication."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nallowing to create customizable decorators. Such decorators (like Django's django.contrib.auth.login_required) can be used in two different ways: # positionally @decorator def myfunc(...): ... and # namely @decorator(**opts) def myfunc(...): ... Being both of them a different type of call (first-order call, and higher-order call). For this to work, it needs (as first/subdecorator= argument) a function to be passed which takes (function, option1=v1, option2=v2, ...) arguments. Such function is the actual implementation of the decorator (being the first argument as positional - the wrapped function - and the remaining arguments just parameters for the implementation). It also can have many by-name arguments which will act as default arguments for the decorator implementation (and so, the specified by-name arguments must be expected/well-received by the implementation). The returned value is a function which can be invoked either positionally (only one argument: the function to wrap) or by-name (arguments as needed, but expected in the decorator's implementation). If called positionally, it is a decorator that wraps a function by calling the implementation passing the to-wrap function AND the default parameters as specified. If called by-name, its return value is a decorator that wraps a function by calling the implementation passing the to-wrap function AND the default parameters updated by the by-name parameters. :param subdecorator: Decorator implementation. Must take a function as positional argument, and many arguments (as desired) which will be passed by-name and will customize the implementation's behavior. :param defaults: Default by-name arguments for the implementation (additional reason to have them separate is that perhaps the user has no control over the function which will be the decorator's implementation). :return: a function which will act as decorator (if called positionally) or as a function returning a decorator (if called by-name).", "response": "def customizable(subdecorator, **defaults):\n    \"\"\"\n    Allows to create customizable decorators. Such decorators (like Django's django.contrib.auth.login_required)\n      can be used in two different ways:\n\n      # positionally\n\n      @decorator\n      def myfunc(...):\n          ...\n\n    and\n\n      # namely\n\n      @decorator(**opts)\n      def myfunc(...):\n          ...\n\n    Being both of them a different type of call (first-order call, and higher-order call). For this to work, it\n      needs (as first/subdecorator= argument) a function to be passed which takes (function, option1=v1, option2=v2,\n      ...) arguments. Such function is the actual implementation of the decorator (being the first argument as\n      positional - the wrapped function - and the remaining arguments just parameters for the implementation). It\n      also can have many by-name arguments which will act as default arguments for the decorator implementation\n      (and so, the specified by-name arguments must be expected/well-received by the implementation).\n\n    The returned value is a function which can be invoked either positionally (only one argument: the function to wrap)\n      or by-name (arguments as needed, but expected in the decorator's implementation).\n\n    If called positionally, it is a decorator that wraps a function by calling the implementation passing the to-wrap\n      function AND the default parameters as specified.\n\n    If called by-name, its return value is a decorator that wraps a function by calling the implementation passing\n      the to-wrap function AND the default parameters updated by the by-name parameters.\n\n    :param subdecorator: Decorator implementation. Must take a function as positional argument, and many arguments (as\n      desired) which will be passed by-name and will customize the implementation's behavior.\n    :param defaults: Default by-name arguments for the implementation (additional reason to have them separate is that\n      perhaps the user has no control over the function which will be the decorator's implementation).\n    :return: a function which will act as decorator (if called positionally) or as a function returning a decorator\n      (if called by-name).\n    \"\"\"\n\n    @wraps(subdecorator, assigned=('__name__', '__module__'))\n    def _decorator(*func, **options):\n        lfunc = len(func)\n        lopts = len(options)\n\n        if lfunc and lopts:\n            raise TypeError(\"Cannot specify both positional arguments and options\")\n        if not lfunc and not lopts:\n            raise TypeError(\"Either positional arguments or options must be specified\")\n\n        if lfunc > 1:\n            raise TypeError(\"Cannot specify more than one positional argument\")\n        elif lfunc == 1:\n            # case 1 - the returned function is being used as the direct\n            # decorator. It must call the subdecorator using the values by\n            # default AND the wrapped function.\n            return subdecorator(func[0], **defaults)\n        else:\n            # case 2 - the returned function is passed more options and so\n            # will return the decorator.\n            return lambda f: subdecorator(f, **dict(defaults, **options))\n    return _decorator"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncalls cmd and return stdout stderr and return_value.", "response": "def system_call(cmd, **kwargs):\n    \"\"\"Call cmd and return (stdout, stderr, return_value).\n\n    Parameters\n    ----------\n    cmd: str\n        Can be either a string containing the command to be run, or a sequence\n        of strings that are the tokens of the command.\n    kwargs : dict, optional\n        Ignored. Available so that this function is compatible with\n        _redis_wrap.\n\n    Notes\n    -----\n    This function is ported from QIIME (http://www.qiime.org), previously\n    named qiime_system_call. QIIME is a GPL project, but we obtained permission\n    from the authors of this function to port it to pyqi (and keep it under\n    pyqi's BSD license).\n    \"\"\"\n    proc = Popen(cmd,\n                 universal_newlines=True,\n                 shell=True,\n                 stdout=PIPE,\n                 stderr=PIPE)\n    # communicate pulls all stdout/stderr from the PIPEs to\n    # avoid blocking -- don't remove this line!\n    stdout, stderr = proc.communicate()\n    return_value = proc.returncode\n\n    if return_value != 0:\n        raise ValueError(\"Failed to execute: %s\\nstdout: %s\\nstderr: %s\" %\n                         (cmd, stdout, stderr))\n\n    return stdout, stderr, return_value"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nupdating the status of a job in the cluster.", "response": "def _status_change(id, new_status):\n    \"\"\"Update the status of a job\n\n    The status associated with the id is updated, an update command is\n    issued to the job's pubsub, and and the old status is returned.\n\n    Parameters\n    ----------\n    id : str\n        The job ID\n    new_status : str\n        The status change\n\n    Returns\n    -------\n    str\n        The old status\n    \"\"\"\n    job_info = json.loads(r_client.get(id))\n    old_status = job_info['status']\n    job_info['status'] = new_status\n    _deposit_payload(job_info)\n\n    return old_status"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nstore job info and publish an update", "response": "def _deposit_payload(to_deposit):\n    \"\"\"Store job info, and publish an update\n\n    Parameters\n    ----------\n    to_deposit : dict\n        The job info\n\n    \"\"\"\n    pubsub = to_deposit['pubsub']\n    id = to_deposit['id']\n\n    with r_client.pipeline() as pipe:\n        pipe.set(id, json.dumps(to_deposit), ex=REDIS_KEY_TIMEOUT)\n        pipe.publish(pubsub, json.dumps({\"update\": [id]}))\n        pipe.execute()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _redis_wrap(job_info, func, *args, **kwargs):\n    status_changer = partial(_status_change, job_info['id'])\n    kwargs['moi_update_status'] = status_changer\n    kwargs['moi_context'] = job_info['context']\n    kwargs['moi_parent_id'] = job_info['parent']\n\n    job_info['status'] = 'Running'\n    job_info['date_start'] = str(datetime.now())\n\n    _deposit_payload(job_info)\n\n    caught = None\n    try:\n        result = func(*args, **kwargs)\n        job_info['status'] = 'Success'\n    except Exception as e:\n        result = traceback.format_exception(*sys.exc_info())\n        job_info['status'] = 'Failed'\n        caught = e\n    finally:\n        job_info['result'] = result\n        job_info['date_end'] = str(datetime.now())\n        _deposit_payload(job_info)\n\n    if caught is None:\n        return result\n    else:\n        raise caught", "response": "Wrap something to compute\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef submit(ctx_name, parent_id, name, url, func, *args, **kwargs):\n    if isinstance(ctx_name, Context):\n        ctx = ctx_name\n    else:\n        ctx = ctxs.get(ctx_name, ctxs[ctx_default])\n    return _submit(ctx, parent_id, name, url, func, *args, **kwargs)", "response": "Submit a function through a context and return the result of the function."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nsubmit a function to a cluster.", "response": "def _submit(ctx, parent_id, name, url, func, *args, **kwargs):\n    \"\"\"Submit a function to a cluster\n\n    Parameters\n    ----------\n    parent_id : str\n        The ID of the group that the job is a part of.\n    name : str\n        The name of the job\n    url : str\n        The handler that can take the results (e.g., /beta_diversity/)\n    func : function\n        The function to execute. Any returns from this function will be\n        serialized and deposited into Redis using the uuid for a key. This\n        function should raise if the method fails.\n    args : tuple or None\n        Any args for ``func``\n    kwargs : dict or None\n        Any kwargs for ``func``\n\n    Returns\n    -------\n    tuple, (str, str, AsyncResult)\n        The job ID, parent ID and the IPython's AsyncResult object of the job\n    \"\"\"\n    parent_info = r_client.get(parent_id)\n    if parent_info is None:\n        parent_info = create_info('unnamed', 'group', id=parent_id)\n        parent_id = parent_info['id']\n        r_client.set(parent_id, json.dumps(parent_info))\n\n    parent_pubsub_key = parent_id + ':pubsub'\n\n    job_info = create_info(name, 'job', url=url, parent=parent_id,\n                           context=ctx.name, store=True)\n    job_info['status'] = 'Queued'\n    job_id = job_info['id']\n\n    with r_client.pipeline() as pipe:\n        pipe.set(job_id, json.dumps(job_info))\n        pipe.publish(parent_pubsub_key, json.dumps({'add': [job_id]}))\n        pipe.execute()\n\n    ar = ctx.bv.apply_async(_redis_wrap, job_info, func, *args, **kwargs)\n    return job_id, parent_id, ar"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nwait for data forever and feeds the input queue.", "response": "def _recv_loop(self):\n        \"\"\"\n        Waits for data forever and feeds the input queue.\n        \"\"\"\n        while True:\n            try:\n                data = self._socket.recv(4096)\n                self._ibuffer += data\n                while '\\r\\n' in self._ibuffer:\n                    line, self._ibuffer = self._ibuffer.split('\\r\\n', 1)\n                    self.iqueue.put(line)\n            except Exception:\n                break"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsend data to the server.", "response": "def _send_loop(self):\n        \"\"\"\n        Waits for data in the output queue to send.\n        \"\"\"\n        while True:\n            try:\n                line = self.oqueue.get().splitlines()[0][:500]\n                self._obuffer += line + '\\r\\n'\n                while self._obuffer:\n                    sent = self._socket.send(self._obuffer)\n                    self._obuffer = self._obuffer[sent:]\n            except Exception:\n                break"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconnects the socket and spawns the send and receive loops.", "response": "def connect(self):\n        \"\"\"\n        Connects the socket and spawns the send/receive loops.\n        \"\"\"\n        jobs = []\n        self._socket.connect((self.host, self.port))\n        try:\n            jobs = [spawn(self._recv_loop), spawn(self._send_loop)]\n            joinall(jobs)\n        finally:\n            killall(jobs)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate a new SSL enabled socket and sets its timeout.", "response": "def _create_socket(self):\n        \"\"\"\n        Creates a new SSL enabled socket and sets its timeout.\n        \"\"\"\n        log.warning('No certificate check is performed for SSL connections')\n        s = super(SSL, self)._create_socket()\n        return wrap_socket(s)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nloads the event definitions from a yaml config file.", "response": "def load_config(filename):\n    \"\"\"Load the event definitions from yaml config file.\"\"\"\n    logger.debug(\"Event Definitions configuration file: %s\", filename)\n\n    with open(filename, 'r') as cf:\n        config = cf.read()\n\n    try:\n        events_config = yaml.safe_load(config)\n    except yaml.YAMLError as err:\n        if hasattr(err, 'problem_mark'):\n            mark = err.problem_mark\n            errmsg = (\"Invalid YAML syntax in Event Definitions file \"\n                      \"%(file)s at line: %(line)s, column: %(column)s.\"\n                      % dict(file=filename,\n                             line=mark.line + 1,\n                             column=mark.column + 1))\n        else:\n            errmsg = (\"YAML error reading Event Definitions file \"\n                      \"%(file)s\"\n                      % dict(file=filename))\n        logger.error(errmsg)\n        raise\n\n    logger.info(\"Event Definitions: %s\", events_config)\n    return events_config"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _extract_when(body):\n\n        # NOTE: I am keeping the logic the same as it was in openstack\n        # code, However, *ALL* notifications should have a 'timestamp'\n        # field, it's part of the notification envelope spec. If this was\n        # put here because some openstack project is generating notifications\n        # without a timestamp, then that needs to be filed as a bug with the\n        # offending project (mdragon)\n        when = body.get('timestamp', body.get('_context_timestamp'))\n        if when:\n            return Datatype.datetime.convert(when)\n        return utcnow()", "response": "Extract the generated datetime from the notification."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nlists all buckets for this user.", "response": "def list_buckets(self, offset=0, limit=100):\n        \"\"\"Limit breaks above 100\"\"\"\n        # TODO: If limit > 100, do multiple fetches\n        if limit > 100:\n            raise Exception(\"Zenobase can't handle limits over 100\")\n        return self._get(\"/users/{}/buckets/?order=label&offset={}&limit={}\".format(self.client_id, offset, limit))"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates a table in sqlite3.", "response": "def _create_table(db, table_name, columns, overwrite=False):\n    \"\"\"\n    Create's `table_name` in `db` if it does not already exist,\n    and adds any missing columns.\n\n    :param db: An active SQLite3 Connection.\n    :param table_name: The (unicode) name of the table to setup.\n    :param columns: An iterable of column names to ensure exist.\n    :param overwrite: If ``True`` and the table already exists,\n                      overwrite it.\n    \"\"\"\n    with contextlib.closing(db.cursor()) as c:\n        table_exists = c.execute((\n            u'SELECT EXISTS(SELECT 1 FROM sqlite_master'\n            u' WHERE type=\"table\" and name=?) as \"exists\"'\n        ), (table_name,)).fetchone()\n\n        if table_exists['exists']:\n            if not overwrite:\n                raise TableExists()\n\n            c.execute(u'DROP TABLE IF EXISTS \"{table_name}\"'.format(\n                table_name=table_name\n            ))\n\n        # Create the table if it doesn't already exist.\n        c.execute((\n            u'CREATE TABLE IF NOT EXISTS \"{table_name}\"'\n            u'(id INTEGER PRIMARY KEY AUTOINCREMENT);'\n        ).format(table_name=table_name))\n\n        # Cache the columns that are already there so we create only\n        # those that are missing.\n        c.execute(u'PRAGMA table_info(\"{table_name}\");'.format(\n            table_name=table_name\n        ))\n\n        results = c.fetchall()\n        existing_columns = set(r['name'] for r in results)\n\n        for header in columns:\n            if header in existing_columns:\n                continue\n\n            # In SQLite3, new columns can only be appended.\n            c.execute((\n                u'ALTER TABLE \"{table_name}\"'\n                u' ADD COLUMN \"{col}\" TEXT;'\n            ).format(\n                table_name=table_name,\n                col=header\n            ))\n\n        # Typically, table modifications occur outside of a\n        # transaction so this is just a precaution.\n        db.commit()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef update_colorbox():\n    base_name = os.path.dirname(__file__)\n    destination = os.path.join(base_name, \"armstrong\", \"apps\", \"images\", \"static\", \"colorbox\")\n    colorbox_source = os.path.join(base_name, \"vendor\", \"colorbox\")\n    colorbox_files = [\n        os.path.join(colorbox_source, \"example1\", \"colorbox.css\"),\n        os.path.join(colorbox_source, \"example1\", \"images\"),\n        os.path.join(colorbox_source, \"colorbox\", \"jquery.colorbox-min.js\"),\n    ]\n    local(\"cp -R %s %s\" % (\" \".join(colorbox_files), destination))\n\n    # We're not supporting IE6, so we can drop the backfill\n    local(\"rm -rf %s\" % (os.path.join(destination, \"images\", \"ie6\")))", "response": "Update Colorbox code from vendor tree"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nparsing data from parltarck dossier export", "response": "def parse_dossier_data(data, ep):\n    \"\"\"Parse data from parltarck dossier export (1 dossier) Update dossier\n    if it existed before, this function goal is to import and update a\n    dossier, not to import all parltrack data\n    \"\"\"\n    changed = False\n    doc_changed = False\n    ref = data['procedure']['reference']\n\n    logger.debug('Processing dossier %s', ref)\n\n    with transaction.atomic():\n        try:\n            dossier = Dossier.objects.get(reference=ref)\n        except Dossier.DoesNotExist:\n            dossier = Dossier(reference=ref)\n            logger.debug('Dossier did not exist')\n            changed = True\n\n        if dossier.title != data['procedure']['title']:\n            logger.debug('Title changed from \"%s\" to \"%s\"', dossier.title,\n                         data['procedure']['title'])\n            dossier.title = data['procedure']['title']\n            changed = True\n\n        if changed:\n            logger.info('Updated dossier %s', ref)\n            dossier.save()\n\n        source = data['meta']['source'].replace('&l=en', '')\n        try:\n            doc = Document.objects.get(dossier=dossier, kind='procedure-file')\n        except Document.DoesNotExist:\n            doc = Document(dossier=dossier, kind='procedure-file', chamber=ep)\n            logger.debug('Document for dossier %s did not exist', ref)\n            doc_changed = True\n\n        if doc.link != source:\n            logger.debug('Link changed from %s to %s', doc.link, source)\n            doc.link = source\n            doc_changed = True\n\n        if doc_changed:\n            logger.info('Updated document %s for dossier %s', doc.link, ref)\n            doc.save()\n\n    if 'votes' in data.keys() and 'epref' in data['votes']:\n        command = Command()\n        command.init_cache()\n        command.parse_vote_data(data['votes'])"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef hkdf(self, chaining_key, input_key_material, dhlen=64):\n\n        if len(chaining_key) != self.HASHLEN:\n            raise HashError(\"Incorrect chaining key length\")\n        if len(input_key_material) not in (0, 32, dhlen):\n            raise HashError(\"Incorrect input key material length\")\n        temp_key = self.hmac_hash(chaining_key, input_key_material)\n        output1 = self.hmac_hash(temp_key, b'\\x01')\n        output2 = self.hmac_hash(temp_key, output1 + b'\\x02')\n        return output1, output2", "response": "Hash - based key derivation function"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nappending a byte string to the end of the buffer.", "response": "def append(self, val):\n        \"\"\"Append byte string val to buffer\n        If the result exceeds the length of the buffer, behavior\n        depends on whether instance was initialized as strict.\n        In strict mode, a ValueError is raised.\n        In non-strict mode, the buffer is extended as necessary.\n        \"\"\"\n        new_len = self.length + len(val)\n        to_add = new_len - len(self.bfr)\n        if self.strict and to_add > 0:\n            raise ValueError(\"Cannot resize buffer\")\n        self.bfr[self.length:new_len] = val\n        self.length = new_len"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _parse_eloss(line, lines):\n\n    split_line = line.split()\n\n    energy = float(split_line[0])\n    eloss_xx = float(split_line[1])\n    eloss_zz = float(split_line[2])\n\n    return {\"energy\": energy, \"eloss_xx\": eloss_xx, \"eloss_zz\": eloss_zz}", "response": "Parse Energy [ eV ]    eloss_xx      eloss_zz"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_or_create(self, commit=False, **kwargs) -> Tuple[model, bool]:\n        instance = self.get_by(**kwargs)\n        if not instance:\n            return self.create(commit=commit, **kwargs), True\n        return instance, False", "response": "Returns a tuple of the instance and whether or not the instance was created."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a random string from the alphabet.", "response": "def random_str(n=20):\n    \"\"\"\n    \u968f\u673a\u751f\u6210\u4e00\u4e32\u5bc6\u7801\n    :param n: \u5bc6\u7801\u7684\u957f\u5ea6\uff0c\u9ed8\u8ba4\u4e3a20\n    :return: \u957f\u5ea6\u4e3an\u7684\u968f\u673a\u5b57\u7b26\u4e32\n    \"\"\"\n    return ''.join(random.sample(string.ascii_letters + string.digits, n))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef addr_info(addr):\n\n    # If it's a string, it's in the UNIX family\n    if isinstance(addr, basestring):\n        return socket.AF_UNIX\n\n    # Verify that addr is a tuple\n    if not isinstance(addr, collections.Sequence):\n        raise ValueError(\"address is not a tuple\")\n\n    # Make sure it has at least 2 fields\n    if len(addr) < 2:\n        raise ValueError(\"cannot understand address\")\n\n    # Sanity-check the port number\n    if not (0 <= addr[1] < 65536):\n        raise ValueError(\"cannot understand port number\")\n\n    # OK, first field should be an IP address; suck it out...\n    ipaddr = addr[0]\n\n    # Empty string means IPv4\n    if not ipaddr:\n        if len(addr) != 2:\n            raise ValueError(\"cannot understand address\")\n\n        return socket.AF_INET\n\n    # See if it's valid...\n    if netaddr.valid_ipv6(ipaddr):\n        if len(addr) > 4:\n            raise ValueError(\"cannot understand address\")\n\n        return socket.AF_INET6\n    elif netaddr.valid_ipv4(ipaddr):\n        if len(addr) != 2:\n            raise ValueError(\"cannot understand address\")\n\n        return socket.AF_INET\n\n    raise ValueError(\"cannot understand address\")", "response": "Interprets an address in standard tuple format to determine if it is valid and if so which socket family it is. Returns the socket family."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadd a wrapper to the chain.", "response": "def chain(self, wrapper, *args, **kwargs):\n        \"\"\"\n        Add a wrapper to the chain.  Any extra positional or keyword\n        arguments will be passed to that wrapper through construction\n        of a ``TendrilPartial``.  For convenience, returns the\n        WrapperChain object, allowing ``chain()`` to be called on the\n        return result to register multiple wrappers.\n        \"\"\"\n\n        if args or kwargs:\n            wrapper = TendrilPartial(wrapper, *args, **kwargs)\n\n        self._wrappers.append(wrapper)\n\n        # For convenience...\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef train(self, X):\n\n    _trainer = bob.learn.linear.CGLogRegTrainer(**{'lambda':self.regularizer})\n\n    if len(X) == 2: #trains and returns a single logistic regression classifer\n\n      return _trainer.train(add_bias(X[0]), add_bias(X[1]))\n\n    else: #trains and returns a multi-class logistic regression classifier\n\n      # use one-versus-all strategy\n      machines = []\n      for k in range(len(X)):\n        NC_range = list(range(0,k)) + list(range(k+1,len(X)))\n        machines.append(_trainer.train(add_bias(numpy.vstack(X[NC_range])),\n            add_bias(X[k])))\n\n      return MultiClassMachine(machines)", "response": "Trains multiple logistic regression classifiers to handle the multiclass\n    problem posed by X"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef recur(obj, type_func_tuple_list=()):\n    '''recuring dealing an object'''\n    for obj_type, func in type_func_tuple_list:\n        if type(obj) == type(obj_type):\n            return func(obj)\n    # by default, we wolud recurring list, tuple and dict\n    if isinstance(obj, list) or isinstance(obj, tuple):\n        n_obj = []\n        for i in obj:\n            n_obj.append(recur(i))\n        return n_obj if isinstance(obj, list) else tuple(obj)\n    elif isinstance(obj, dict):\n        n_obj = {}\n        for k,v in obj.items():\n            n_obj[k] = recur(v)\n        return n_obj\n    return obj", "response": "recuring dealing an object"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\njoining the items into a string using the separator", "response": "def join(items, separator=None):\n    \"\"\"Join the items into a string using the separator\n\n    Converts items to strings if needed\n\n    >>> join([1, 2, 3])\n    '1,2,3'\n    \"\"\"\n    if not items:\n        return ''\n    if separator is None:\n        separator = _default_separator()\n    return separator.join([str(item) for item in items])"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef split(string, separator_regexp=None, maxsplit=0):\n    if not string:\n        return []\n    if separator_regexp is None:\n        separator_regexp = _default_separator()\n    if not separator_regexp:\n        return string.split()\n    return re.split(separator_regexp, string, maxsplit)", "response": "Split a string into a list of lists."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef split_and_strip(string, separator_regexp=None, maxsplit=0):\n    if not string:\n        return ['']\n    if separator_regexp is None:\n        separator_regexp = _default_separator()\n    if not separator_regexp:\n        return string.split()\n    return [item.strip()\n            for item in re.split(separator_regexp, string, maxsplit)]", "response": "Split a string into items and trim any excess spaces from the items\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef split_and_strip_without(string, exclude, separator_regexp=None):\n    result = split_and_strip(string, separator_regexp)\n    if not exclude:\n        return result\n    return [x for x in result if x not in exclude]", "response": "Split a string into items and trim any excess spaces"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nsplit a string and then rejoin it", "response": "def rejoin(string, separator_regexp=None, spaced=False):\n    \"\"\"Split a string and then rejoin it\n\n    Spaces are interspersed between items only if spaced is True\n\n    >>> rejoin('fred, was, here  ')\n    'fred,was,here'\n    \"\"\"\n    strings = split_and_strip(string)\n    if separator_regexp is None:\n        separator_regexp = _default_separator()\n    joiner = spaced and '%s ' % separator_regexp or separator_regexp\n    return joiner.join(strings)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _unpack_zip(self, file_obj, path):\n        old_cwd = os.getcwd()\n        os.chdir(path)\n\n        zip_obj = zipfile.ZipFile(file_obj)\n        for cnt, zip_info in enumerate(zip_obj.infolist()):\n            zip_obj.extract(zip_info)\n\n            if cnt + 1 > self.max_zipfiles:\n                os.chdir(old_cwd)\n\n                msg = \"Too many files in .zip \"\n                msg += \"(self.max_zipfiles == {}, but {} given).\".format(\n                    self.max_zipfiles,\n                    cnt + 1,\n                )\n                raise ValueError(msg)\n\n        os.chdir(old_cwd)", "response": "Unpacks the. zip archive in file_obj to given path."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nadd a zip archive to the storage and unpack it.", "response": "def add_archive_as_dir(self, zip_file_obj):\n        \"\"\"\n        Add archive to the storage and unpack it.\n\n        Args:\n            zip_file_obj (file): Opened file-like object.\n\n        Returns:\n            obj: Path where the `zip_file_obj` was unpacked wrapped in \\\n                 :class:`.PathAndHash` structure.\n\n        Raises:\n            ValueError: If there is too many files in .zip archive. \\\n                        See :attr:`._max_zipfiles` for details.\n            AssertionError: If the `zip_file_obj` is not file-like object.\n        \"\"\"\n        BalancedDiscStorage._check_interface(zip_file_obj)\n\n        file_hash = self._get_hash(zip_file_obj)\n        dir_path = self._create_dir_path(file_hash)\n        full_path = os.path.join(dir_path, file_hash)\n\n        if os.path.exists(full_path):\n            shutil.rmtree(full_path)\n\n        os.mkdir(full_path)\n\n        try:\n            self._unpack_zip(zip_file_obj, full_path)\n        except Exception:\n            shutil.rmtree(full_path)\n            raise\n\n        return PathAndHash(path=full_path, hash=file_hash)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef to_even_columns(data, headers=None):\n    result = ''\n    col_width = max(len(word) for row in data for word in row) + 2  # padding\n    if headers:\n        header_width = max(len(word) for row in headers for word in row) + 2\n        if header_width > col_width:\n            col_width = header_width\n\n        result += \"\".join(word.ljust(col_width) for word in headers) + \"\\n\"\n        result += '-' * col_width * len(headers) + \"\\n\"\n\n    for row in data:\n        result += \"\".join(word.ljust(col_width) for word in row) + \"\\n\"\n    return result", "response": "Nicely format the 2 - dimensional list into evenly spaced columns\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef to_smart_columns(data, headers=None, padding=2):\n    result = ''\n    col_widths = []\n    for row in data:\n        col_counter = 0\n        for word in row:\n            try:\n                col_widths[col_counter] = max(len(word), col_widths[col_counter])\n            except IndexError:\n                col_widths.append(len(word))\n            col_counter += 1\n\n    if headers:\n        col_counter = 0\n        for word in headers:\n            try:\n                col_widths[col_counter] = max(len(word), col_widths[col_counter])\n            except IndexError:\n                col_widths.append(len(word))\n            col_counter += 1\n\n    # Add padding\n    col_widths = [width + padding for width in col_widths]\n    total_width = sum(col_widths)\n\n    if headers:\n        col_counter = 0\n        for word in headers:\n            result += \"\".join(word.ljust(col_widths[col_counter]))\n            col_counter += 1\n        result += \"\\n\"\n        result += '-' * total_width + \"\\n\"\n\n    for row in data:\n        col_counter = 0\n        for word in row:\n            result += \"\".join(word.ljust(col_widths[col_counter]))\n            col_counter += 1\n        result += \"\\n\"\n    return result", "response": "Nicely format the 2 - dimensional list into columns"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef progress_bar(items_total, items_progress, columns=40, base_char='.', progress_char='#', percentage=False, prefix='', postfix=''):\n    bins_total = int(float(items_total) / columns) + 1\n    bins_progress = int((float(items_progress) / float(items_total)) * bins_total) + 1\n    progress = prefix\n    progress += progress_char * bins_progress\n    progress += base_char * (bins_total - bins_progress)\n    if percentage:\n        progress_percentage = float(items_progress) / float(items_total) * 100\n        # Round the percentage to two decimals\n        postfix = ' ' + str(round(progress_percentage, 2)) + '% ' + postfix\n    progress += postfix\n    return progress", "response": "Print a progress bar of width columns"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef merge_x_y(collection_x, collection_y, filter_none=False):\n    data = {}\n    for item in collection_x:\n        #print item[0:-1]\n        #print item[-1]\n        label = datetimeutil.tuple_to_string(item[0:-1])\n        if filter_none and label == 'None-None':\n            continue\n        data[label] = {'label': label, 'x': item[-1], 'y': 0}\n    for item in collection_y:\n        #print item\n        label = datetimeutil.tuple_to_string(item[0:-1])\n        if filter_none and label == 'None-None':\n            continue\n        try:\n            data[label]['y'] = item[-1]\n        except KeyError:\n            data[label] = {'label': label, 'x': 0, 'y': item[-1]}\n\n    # Keys are not sorted\n    return data", "response": "Merge two lists creating a dictionary with key label and a set x and y"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef x_vs_y(collection_x, collection_y, title_x=None, title_y=None, width=43, filter_none=False):\n    data = merge_x_y(collection_x, collection_y, filter_none)\n\n    max_value = get_max_x_y(data)\n    bins_total = int(float(max_value) / width) + 1\n\n    if title_x is not None and title_y is not None:\n        headers = [title_x, title_y]\n    else:\n        headers = None\n    result = []\n    # Sort keys\n    for item in sorted(data):\n        #result.append([item, str(data[item]['x']) + '|' + str(data[item]['y'])])\n        bins_x = int((float(data[item]['x']) / float(max_value)) * bins_total) + 1\n        bins_y = int((float(data[item]['y']) / float(max_value)) * bins_total) + 1\n        print(bins_x)\n        print(bins_y)\n        #result.append([item, str(data[item]['x']), str(data[item]['y'])])\n        result.append([item, '*' * bins_x, '*' * bins_y])\n    result = to_smart_columns(result, headers=headers)\n    return result", "response": "Print a histogram with bins for x to the right and bins for y to the left and bins for y to the right."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _rectify(settings):\n    for key, rectifier in _settings_rectifiers.items():\n        try:\n            new_value = rectifier['func'](settings[key])\n            if new_value is False:\n                raise AuthzConfigurationError(\n                    'Error validating {}->{}: {}'.format(\n                        _settings_key, key, rectifier['errmsg']))\n            settings[key] = new_value\n        except:\n            raise AuthzConfigurationError(\n                'Error validating {}->{}: {}'.format(\n                    _settings_key, key, rectifier['errmsg']))", "response": "Rectify the given settings using the functions in\nInsights. _settings_rectifiers."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef settings():\n    # Get the user-provided settings\n    user_settings = dict(getattr(django_settings, _settings_key, {}))\n    user_settings_keys = set(user_settings.keys())\n    # Check for required but missing settings\n    missing = _required_settings_keys - user_settings_keys\n    if missing:\n        raise AuthzConfigurationError(\n            'Missing required {} config: {}'.format(_settings_key, missing))\n    # Check for unknown settings\n    unknown = user_settings_keys - _available_settings_keys\n    if unknown:\n        raise AuthzConfigurationError(\n            'Unknown {} config params: {}'.format(_settings_key, unknown))\n    # Merge defaults with provided settings\n    defaults = _available_settings_keys - user_settings_keys\n    user_settings.update({key: _available_settings[key] for key in defaults})\n\n    _rectify(user_settings)\n    return types.MappingProxyType(user_settings)", "response": "Fetch the middleware settings."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef run(self):\n        try:\n            while True:\n                message = self.connection.recv()\n                result = self.on_message(message)\n                if result:\n                    self.connection.send(result)\n        except SelenolWebSocketClosedException as ex:\n            self.on_closed(0, '')\n            raise SelenolWebSocketClosedException() from ex", "response": "Run the service in infinitive loop processing requests."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nmessaging from the backend has been received. :param message: Message string received.", "response": "def on_message(self, message):\n        \"\"\"Message from the backend has been received.\n\n        :param message: Message string received.\n        \"\"\"\n        work_unit = SelenolMessage(message)\n        request_id = work_unit.request_id\n\n        if message['reason'] == ['selenol', 'request']:\n            try:\n                result = self.on_request(work_unit)\n                if result is not None:\n                    return {\n                        'reason': ['request', 'result'],\n                        'request_id': request_id,\n                        'content': {\n                            'content': result,\n                        },\n                    }\n            except SelenolException as e:\n                logging.exception(e)\n                return {\n                    'reason': ['request', 'exception'],\n                    'request_id': request_id,\n                    'content': {\n                        'message': str(e),\n                    },\n                }\n            except Exception as e:\n                logging.exception(e)\n                return {\n                    'reason': ['request', 'exception'],\n                    'request_id': request_id,\n                    'content': {\n                        'message': 'Not a Selenol exception',\n                    },\n                }"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef event(self, request_id, trigger, event, message):\n        self.connection.send({\n            'reason': ['request', 'event'],\n            'request_id': request_id,\n            'content': {\n                'trigger': trigger,\n                'message': {\n                    'reason': event,\n                    'content': message,\n                },\n            },\n        })", "response": "Create an event in the backend given a circumstance."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsending a message to the backend.", "response": "def send(self, event, message):\n        \"\"\"Send a message to the backend.\n\n        :param reason: Reason of the message.\n        :param message: Message content.\n        \"\"\"\n        self.connection.send({\n            'reason': ['request', 'send'],\n            'content': {\n                'reason': event,\n                'request_id': self.request_counter,\n                'content': message,\n            },\n        })\n        self.request_counter = self.request_counter + 1"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nchecking if locations contain only the one intended dist. Return the dist with metadata in the new location.", "response": "def _get_matching_dist_in_location(dist, location):\n    \"\"\"\n    Check if `locations` contain only the one intended dist.\n    Return the dist with metadata in the new location.\n    \"\"\"\n    # Getting the dist from the environment causes the\n    # distribution meta data to be read.  Cloning isn't\n    # good enough.\n    import pkg_resources\n    env = pkg_resources.Environment([location])\n    dists = [ d for project_name in env for d in env[project_name] ]\n    dist_infos = [ (d.project_name, d.version) for d in dists ]\n    if dist_infos == [(dist.project_name, dist.version)]:\n        return dists.pop()\n    if dist_infos == [(dist.project_name.lower(), dist.version)]:\n        return dists.pop()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_model_config(self):\n        if not hasattr(self, '__config'):\n            setattr(self, '__config', models_config.get_config(self.get_model_class()))\n        return getattr(self, '__config', None)", "response": "Get Trionyx model config"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nvalidating if user can use view", "response": "def dispatch(self, request, *args, **kwargs):\n        \"\"\"Validate if user can use view\"\"\"\n        if False:  # TODO do permission check based on Model\n            raise PermissionDenied\n        return super().dispatch(request, *args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget value from request session and save value to session", "response": "def get_and_save_value(self, name, default=None):\n        \"\"\"Get value from request/session and save value to session\"\"\"\n        if getattr(self, name, None):\n            return getattr(self, name)\n\n        value = self.get_session_value(name, default)\n        value = self.request.POST.get(name, value)\n        self.save_value(name, value)\n        return value"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget value from session", "response": "def get_session_value(self, name, default=None):\n        \"\"\"Get value from session\"\"\"\n        session_name = 'list_{}_{}_{}'.format(self.kwargs.get('app'), self.kwargs.get('model'), name)\n        return self.request.session.get(session_name, default)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsaves value to session", "response": "def save_value(self, name, value):\n        \"\"\"Save value to session\"\"\"\n        session_name = 'list_{}_{}_{}'.format(self.kwargs.get('app'), self.kwargs.get('model'), name)\n        self.request.session[session_name] = value\n        setattr(self, name, value)\n        return value"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_context_data(self, **kwargs):\n        context = super().get_context_data(**kwargs)\n        context.update({\n            'title': self.get_title(),\n            'ajax_url': self.get_ajax_url(),\n            'download_url': self.get_download_url(),\n            'create_url': self.get_create_url(),\n        })\n        return context", "response": "Add context data to view"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_page(self, paginator):\n        page = int(self.get_and_save_value('page', 1))\n        if page < 1:\n            return self.save_value('page', 1)\n\n        if page > paginator.num_pages:\n            return self.save_value('page', paginator.num_pages)\n        return page", "response": "Get current page or page in session"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_search(self):\n        old_search = self.get_session_value('search', '')\n        search = self.get_and_save_value('search', '')\n        if old_search != search:\n            self.page = 1\n            self.get_session_value('page', self.page)\n        return search", "response": "Get current search or search from session reset page if search is changed"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_all_fields(self):\n        return {\n            name: {\n                'name': name,\n                'label': field['label'],\n            }\n            for name, field in self.get_model_config().get_list_fields().items()\n        }", "response": "Get all aviable fields"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget current list to be used", "response": "def get_current_fields(self):\n        \"\"\"Get current list to be used\"\"\"\n        if hasattr(self, 'current_fields') and self.current_fields:\n            return self.current_fields\n\n        field_attribute = 'list_{}_{}_fields'.format(self.kwargs.get('app'), self.kwargs.get('model'))\n        current_fields = self.request.user.attributes.get_attribute(field_attribute, [])\n        request_fields = self.request.POST.get('selected_fields', None)\n\n        if request_fields and ','.join(current_fields) != request_fields:\n            # TODO validate fields\n            current_fields = request_fields.split(',')\n            self.request.user.attributes.set_attribute(field_attribute, current_fields)\n        elif request_fields:\n            current_fields = request_fields.split(',')\n\n        if not current_fields:\n            config = self.get_model_config()\n            current_fields = config.list_default_fields if config.list_default_fields else ['created_at', 'id']\n\n        self.current_fields = current_fields\n        return current_fields"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets search query set", "response": "def search_queryset(self):\n        \"\"\"Get search query set\"\"\"\n        queryset = self.get_model_class().objects.get_queryset()\n\n        if self.get_model_config().list_select_related:\n            queryset = queryset.select_related(*self.get_model_config().list_select_related)\n\n        return watson.filter(queryset, self.get_search(), ranking=False)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef handle_request(self, request, *args, **kwargs):\n        paginator = self.get_paginator()\n        # Call search first, it will reset page if search is changed\n        search = self.get_search()\n        page = self.get_page(paginator)\n        items = self.get_items(paginator, page)\n        return {\n            'search': search,\n            'page': page,\n            'page_size': self.get_page_size(),\n            'num_pages': paginator.num_pages,\n            'sort': self.get_sort(),\n            'current_fields': self.get_current_fields(),\n            'fields': self.get_all_fields(),\n\n            'items': items,\n        }", "response": "Give back list items + config"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_items(self, paginator, current_page):\n        fields = self.get_model_config().get_list_fields()\n\n        page = paginator.page(current_page)\n\n        items = []\n        for item in page:\n            items.append({\n                'id': item.id,\n                'url': item.get_absolute_url(),\n                'row_data': [\n                    fields[field]['renderer'](item, field)\n                    for field in self.get_current_fields()\n                ]\n            })\n        return items", "response": "Get list items for current page"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef items(self):\n        query = self.get_queryset()\n        fields = self.get_model_config().get_list_fields()\n\n        for item in query.iterator():\n            row = OrderedDict()\n            for field_name in self.get_current_fields():\n                field = fields.get(field_name)\n                if not field_name:\n                    row[field_name] = ''\n\n                if hasattr(item, field['field']):\n                    row[field_name] = getattr(item, field['field'])\n                else:\n                    row[field_name] = ''  # TODO Maybe render field ans strip html?\n            yield row", "response": "Get all list items"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_queryset(self):\n        if self.queryset is None and not self.model:\n            try:\n                ModelClass = apps.get_model(self.kwargs.get('app'), self.kwargs.get('model'))\n                return ModelClass._default_manager.all()\n            except LookupError:\n                raise Http404()\n        return super().get_queryset()", "response": "Get queryset based on url params app mode"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd context data to view", "response": "def get_context_data(self, **kwargs):\n        \"\"\"Add context data to view\"\"\"\n        context = super().get_context_data(**kwargs)\n        tabs = self.get_active_tabs()\n        context.update({\n            'page_detail_tabs': tabs,\n            'active_tab': tabs[0].code if tabs else '',\n            'app_label': self.get_app_label(),\n            'model_name': self.get_model_name(),\n            'model_alias': self.get_model_alias(),\n            'model_verbose_name': self.object._meta.verbose_name.title(),\n            'back_url': self.get_back_url(),\n            'edit_url': self.get_edit_url(),\n            'delete_url': self.get_delete_url(),\n            'title': self.title,\n        })\n        return context"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_delete_url(self):\n        return reverse('trionyx:model-delete', kwargs={\n            'app': self.get_app_label(),\n            'model': self.get_model_name(),\n            'pk': self.object.id\n        })", "response": "Get model object delete url"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_edit_url(self):\n        return reverse('trionyx:model-edit', kwargs={\n            'app': self.get_app_label(),\n            'model': self.get_model_name(),\n            'pk': self.object.id\n        })", "response": "Get model object edit url"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef handle_request(self, request, app, model, pk):\n        ModelClass = self.get_model_class()\n        object = ModelClass.objects.get(id=pk)\n\n        tab_code = request.GET.get('tab')\n        model_alias = request.GET.get('model_alias')\n        model_alias = model_alias if model_alias else '{}.{}'.format(app, model)\n\n        # TODO permission check\n\n        item = tabs.get_tab(model_alias, object, tab_code)\n\n        return item.get_layout(object).render(request)", "response": "Render and return tab"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets queryset based on url params", "response": "def get_queryset(self):\n        \"\"\"Get queryset based on url params(<app>, <mode>) if model is not set on class\"\"\"\n        if self.queryset is None and not self.model:\n            try:\n                return self.get_model_class()._default_manager.all()\n            except LookupError:\n                raise Http404()\n        return super().get_queryset()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting form for model", "response": "def get_form(self, form_class=None):\n        \"\"\"Get form for model\"\"\"\n        form = super().get_form(form_class)\n\n        if not getattr(form, 'helper', None):\n            form.helper = FormHelper()\n            form.helper.form_tag = False\n        else:\n            form.helper.form_tag = False\n        return form"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_context_data(self, **kwargs):\n        context = super().get_context_data(**kwargs)\n        context.update({\n            'title': self.title,\n            'submit_value': self.submit_value,\n            'cancel_url': self.get_cancel_url(),\n            'model_verbose_name': self.get_model_class()._meta.verbose_name\n        })\n\n        return context", "response": "Add context data to view"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_context_data(self, **kwargs):\n        context = super().get_context_data(**kwargs)\n        context.update({\n            'title': self.title,\n            'submit_value': self.submit_value,\n            'cancel_url': self.cancel_url\n        })\n        return context", "response": "Add context data to view"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nhandles a POST request", "response": "def post(self, request, *args, **kwargs):\n        \"\"\"Handle post request\"\"\"\n        try:\n            kwargs = self.load_object(kwargs)\n        except Exception as e:\n            return self.render_te_response({\n                'title': str(e),\n            })\n\n        if not self.has_permission(request):\n            return self.render_te_response({\n                'title': 'No access',\n            })\n        return self.render_te_response(self.handle_dialog(*args, **kwargs))"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nloads object and model config and remove pk from kwargs", "response": "def load_object(self, kwargs):\n        \"\"\"Load object and model config and remove pk from kwargs\"\"\"\n        self.object = None\n        self.config = None\n        self.model = self.get_model_class()\n        kwargs.pop('app', None)\n        kwargs.pop('model', None)\n\n        if self.model and kwargs.get('pk', False):\n            try:\n                self.object = self.model.objects.get(pk=kwargs.pop('pk'))\n            except Exception:\n                raise Exception(\"Could not load {}\".format(self.model.__name__.lower()))\n            setattr(self, self.model.__name__.lower(), self.object)\n\n        return kwargs"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncheck if user has permission to access this object", "response": "def has_permission(self, request):\n        \"\"\"Check if user has permission\"\"\"\n        if not self.object and not self.permission:\n            return True\n\n        if not self.permission:\n            return request.user.has_perm('{}_{}'.format(\n                self.model_permission,\n                self.object.__class__.__name__.lower()), self.object\n            )\n\n        return request.user.has_perm(self.permission)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nrender given template to string and add object to context", "response": "def render_to_string(self, template_file, context):\n        \"\"\"Render given template to string and add object to context\"\"\"\n        context = context if context else {}\n        if self.object:\n            context['object'] = self.object\n            context[self.object.__class__.__name__.lower()] = self.object\n        return render_to_string(template_file, context, self.request)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nrender data to JsonResponse", "response": "def render_te_response(self, data):\n        \"\"\"Render data to JsonResponse\"\"\"\n        if 'submit_label' in data and 'url' not in data:\n            data['url'] = self.request.get_full_path()\n\n        return JsonResponse(data)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef display_dialog(self, *args, **kwargs):\n        form = kwargs.pop('form_instance', None)\n        success_message = kwargs.pop('success_message', None)\n\n        if not form:\n            form = self.get_form_class()(initial=kwargs, instance=self.object)\n\n        if not hasattr(form, \"helper\"):\n            form.helper = FormHelper()\n        form.helper.form_tag = False\n\n        return {\n            'title': self.title.format(\n                model_name=self.get_model_config().model_name,\n                object=str(self.object) if self.object else '',\n            ),\n            'content': self.render_to_string(self.template, {\n                'form': form,\n                'success_message': success_message,\n            }),\n            'submit_label': self.submit_label,\n            'success': bool(success_message),\n        }", "response": "Display form and success message when set"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef handle_dialog(self, *args, **kwargs):\n        form = self.get_form_class()(self.request.POST, initial=kwargs, instance=self.object)\n\n        success_message = None\n        if form.is_valid():\n            obj = form.save()\n            success_message = self.success_message.format(\n                model_name=self.get_model_config().model_name.capitalize(),\n                object=str(obj),\n            )\n        return self.display_dialog(*args, form_instance=form, success_message=success_message, **kwargs)", "response": "Handle form and save and set success message on valid form"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a new column that can be used to link a foreign key to a table or table.", "response": "def foreign_key(model_or_table_name_or_column_name: Union[str, Type[Model]],\n                model_or_table_name: Optional[Union[str, Type[Model]]] = None,\n                *,\n                fk_col: str = 'id',\n                primary_key: bool = False,\n                **kwargs,\n                ) -> Column:\n    \"\"\"Helper method to add a foreign key column to a model.\n\n    For example::\n\n        class Post(Model):\n            category_id = foreign_key('Category')\n            category = relationship('Category', back_populates='posts')\n\n    Is equivalent to::\n\n        class Post(Model):\n            category_id = Column(BigInteger, ForeignKey('category.id'), nullable=False)\n            category = relationship('Category', back_populates='posts')\n\n    :param model_or_table_name_or_column_name: If two arguments are given, then\n        this is treated as the column name. Otherwise, it's treated as the table\n        name (see docs for model_or_table_name)\n\n    :param model_or_table_name: the model or table name to link to\n\n        If given a lowercase string, it's treated as an explicit table name.\n\n        If there are any uppercase characters, it's assumed to be a model name,\n        and will be converted to snake case using the same automatic conversion\n        as Flask-SQLAlchemy does itself.\n\n        If given a subclass of :class:`flask_sqlalchemy.Model`, use its\n        :attr:`__tablename__` attribute.\n\n    :param str fk_col: column name of the primary key (defaults to \"id\")\n    :param bool primary_key: Whether or not this Column is a primary key\n    :param dict kwargs: any other kwargs to pass the Column constructor\n    \"\"\"\n    column_name = model_or_table_name_or_column_name\n    if model_or_table_name is None:\n        column_name = None\n        model_or_table_name = model_or_table_name_or_column_name\n\n    table_name = model_or_table_name\n    if inspect.isclass(model_or_table_name):\n        table_name = model_or_table_name.__tablename__\n    elif table_name != table_name.lower():\n        table_name = snake_case(model_or_table_name)\n\n    args = [column_name] if column_name else []\n    args += [BigInteger, ForeignKey(f'{table_name}.{fk_col}')]\n\n    return Column(*args, primary_key=primary_key, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_term_size():\n        '''Gets the size of your terminal. May not work everywhere. YMMV.'''\n        rows, columns = os.popen('stty size', 'r').read().split()\n        return int(rows), int(columns)", "response": "Gets the size of your terminal. May not work everywhere. YMMV."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef find_commands(management_dir):\n    command_dir = os.path.join(management_dir, 'commands')\n    try:\n        return [f[:-3] for f in os.listdir(command_dir)\n                if not f.startswith('_') and f.endswith('.py')]\n    except OSError:\n        return []", "response": "Finds all the command names that are available in the management directory."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_commands():\n    commands = dict((name, 'pug.crawlnmine') for name in find_commands(__path__[0]))\n\n    if not settings.configured:\n        return commands\n\n    for app_config in reversed(list(apps.get_app_configs())):\n        path = os.path.join(app_config.path, 'management')\n        commands.update(dict((name, app_config.name) for name in find_commands(path)))\n\n    return commands", "response": "Returns a dictionary mapping command names to their callback applications."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncall the given command with the given args and kwargs.", "response": "def call_command(name, *args, **options):\n    \"\"\"\n    Calls the given command, with the given options and args/kwargs.\n\n    This is the primary API you should use for calling specific commands.\n\n    Some examples:\n        call_command('syncdb')\n        call_command('shell', plain=True)\n        call_command('sqlall', 'myapp')\n    \"\"\"\n    # Load the command object.\n    try:\n        app_name = get_commands()[name]\n    except KeyError:\n        raise CommandError(\"Unknown command: %r\" % name)\n\n    if isinstance(app_name, BaseCommand):\n        # If the command is already loaded, use it directly.\n        command = app_name\n    else:\n        command = load_command_class(app_name, name)\n\n    # Simulate argument parsing to get the option defaults (see #10080 for details).\n    parser = command.create_parser('', name)\n    if command.use_argparse:\n        defaults = parser.parse_args(args=args)\n        defaults = dict(defaults._get_kwargs(), **options)\n    else:\n        # Legacy optparse method\n        defaults, _ = parser.parse_args(args=[])\n        defaults = dict(defaults.__dict__, **options)\n\n    return command.execute(*args, **defaults)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef main_help_text(self, commands_only=False):\n        if commands_only:\n            usage = sorted(get_commands().keys())\n        else:\n            usage = [\n                \"\",\n                \"Type '%s help <subcommand>' for help on a specific subcommand.\" % self.prog_name,\n                \"\",\n                \"Available subcommands:\",\n            ]\n            commands_dict = collections.defaultdict(lambda: [])\n            for name, app in six.iteritems(get_commands()):\n                if app == 'pug.crawlnmine':\n                    app = 'pug'\n                else:\n                    app = app.rpartition('.')[-1]\n                commands_dict[app].append(name)\n            style = color_style()\n            for app in sorted(commands_dict.keys()):\n                usage.append(\"\")\n                usage.append(style.NOTICE(\"[%s]\" % app))\n                for name in sorted(commands_dict[app]):\n                    usage.append(\"    %s\" % name)\n            # Output an extra note if settings are not properly configured\n            if self.settings_exception is not None:\n                usage.append(style.NOTICE(\n                    \"Note that only Django core commands are listed \"\n                    \"as settings are not properly configured (error: %s).\"\n                    % self.settings_exception))\n\n        return '\\n'.join(usage)", "response": "Returns the main help text as a string."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef fetch_command(self, subcommand):\n        # Get commands outside of try block to prevent swallowing exceptions\n        commands = get_commands()\n        try:\n            app_name = commands[subcommand]\n        except KeyError:\n            # This might trigger ImproperlyConfigured (masked in get_commands)\n            settings.INSTALLED_APPS\n            sys.stderr.write(\"Unknown command: %r\\nType '%s help' for usage.\\n\" %\n                (subcommand, self.prog_name))\n            sys.exit(1)\n        if isinstance(app_name, BaseCommand):\n            # If the command is already loaded, use it directly.\n            klass = app_name\n        else:\n            klass = load_command_class(app_name, subcommand)\n        return klass", "response": "Tries to fetch the given subcommand from the command line and returns the appropriate command class."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef autocomplete(self):\n        # Don't complete if user hasn't sourced bash_completion file.\n        if 'DJANGO_AUTO_COMPLETE' not in os.environ:\n            return\n\n        cwords = os.environ['COMP_WORDS'].split()[1:]\n        cword = int(os.environ['COMP_CWORD'])\n\n        try:\n            curr = cwords[cword - 1]\n        except IndexError:\n            curr = ''\n\n        subcommands = list(get_commands()) + ['help']\n        options = [('--help', None)]\n\n        # subcommand\n        if cword == 1:\n            print(' '.join(sorted(filter(lambda x: x.startswith(curr), subcommands))))\n        # subcommand options\n        # special case: the 'help' subcommand has no options\n        elif cwords[0] in subcommands and cwords[0] != 'help':\n            subcommand_cls = self.fetch_command(cwords[0])\n            # special case: 'runfcgi' stores additional options as\n            # 'key=value' pairs\n            if cwords[0] == 'runfcgi':\n                from django.core.servers.fastcgi import FASTCGI_OPTIONS\n                options += [(k, 1) for k in FASTCGI_OPTIONS]\n            # special case: add the names of installed apps to options\n            elif cwords[0] in ('dumpdata', 'sql', 'sqlall', 'sqlclear',\n                    'sqlcustom', 'sqlindexes', 'sqlsequencereset', 'test'):\n                try:\n                    app_configs = apps.get_app_configs()\n                    # Get the last part of the dotted path as the app name.\n                    options += [(app_config.label, 0) for app_config in app_configs]\n                except ImportError:\n                    # Fail silently if DJANGO_SETTINGS_MODULE isn't set. The\n                    # user will find out once they execute the command.\n                    pass\n            parser = subcommand_cls.create_parser('', cwords[0])\n            if subcommand_cls.use_argparse:\n                options += [(sorted(s_opt.option_strings)[0], s_opt.nargs != 0) for s_opt in\n                            parser._actions if s_opt.option_strings]\n            else:\n                options += [(s_opt.get_opt_string(), s_opt.nargs) for s_opt in\n                            parser.option_list]\n            # filter out previously specified options from available options\n            prev_opts = [x.split('=')[0] for x in cwords[1:cword - 1]]\n            options = [opt for opt in options if opt[0] not in prev_opts]\n\n            # filter options by current input\n            options = sorted((k, v) for k, v in options if k.startswith(curr))\n            for option in options:\n                opt_label = option[0]\n                # append '=' to options which require args\n                if option[1]:\n                    opt_label += '='\n                print(opt_label)\n        sys.exit(1)", "response": "A function that returns a list of possible completion suggestions for the current command and the current command."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ngive the command-line arguments, this figures out which subcommand is being run, creates a parser appropriate to that command, and runs it.", "response": "def execute(self):\n        \"\"\"\n        Given the command-line arguments, this figures out which subcommand is\n        being run, creates a parser appropriate to that command, and runs it.\n        \"\"\"\n        try:\n            subcommand = self.argv[1]\n        except IndexError:\n            subcommand = 'help'  # Display help if no arguments were given.\n\n        # Preprocess options to extract --settings and --pythonpath.\n        # These options could affect the commands that are available, so they\n        # must be processed early.\n        parser = CommandParser(None, usage=\"%(prog)s subcommand [options] [args]\", add_help=False)\n        parser.add_argument('--settings')\n        parser.add_argument('--pythonpath')\n        parser.add_argument('args', nargs='*')  # catch-all\n        try:\n            options, args = parser.parse_known_args(self.argv[2:])\n            handle_default_options(options)\n        except CommandError:\n            pass  # Ignore any option errors at this point.\n\n        no_settings_commands = [\n            'help', 'version', '--help', '--version', '-h',\n            'compilemessages', 'makemessages',\n            'startapp', 'startproject',\n        ]\n\n        try:\n            settings.INSTALLED_APPS\n        except ImproperlyConfigured as exc:\n            self.settings_exception = exc\n            # A handful of built-in management commands work without settings.\n            # Load the default settings -- where INSTALLED_APPS is empty.\n            if subcommand in no_settings_commands:\n                settings.configure()\n\n        if settings.configured:\n            django.setup()\n\n        self.autocomplete()\n\n        if subcommand == 'help':\n            if '--commands' in args:\n                sys.stdout.write(self.main_help_text(commands_only=True) + '\\n')\n            elif len(options.args) < 1:\n                sys.stdout.write(self.main_help_text() + '\\n')\n            else:\n                self.fetch_command(options.args[0]).print_help(self.prog_name, options.args[0])\n        # Special cases for 'jira.py --version' and 'jira.py --help' to work.\n        elif subcommand == 'version' or self.argv[1:] == ['--version']:\n            sys.stdout.write(django.get_version() + '\\n')\n        elif self.argv[1:] in (['--help'], ['-h']):\n            sys.stdout.write(self.main_help_text() + '\\n')\n        else:\n            self.fetch_command(subcommand).run_from_argv(self.argv)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nshowing a Qt window ensuring it s not duplicated and raise a new one.", "response": "def show_qt(qt_class, modal=False, onshow_event=None, force_style=False):\n    \"\"\"\n    Shows and raise a pyqt window ensuring it's not duplicated\n    (if it's duplicated then raise the old one).\n    qt_class argument should be a class/subclass of QMainWindow, QDialog or any\n    top-level widget.\n    onshow_event provides a way to pass a function to execute before the window\n    is showed on screen, it should be handy with modal windows.\n    Returns the qt_class instance.\n    \"\"\"\n    dialog = None\n    window = anchor()\n    # look for a previous instance\n    for d in window.children():\n        if isinstance(d, qt_class):\n            dialog = d\n    # if there's no previous instance then create a new one\n    if dialog is None:\n        dialog = qt_class(window)\n    # stylize\n    if force_style:\n        set_style(dialog, not isinstance(dialog, QtGui.QMenu))\n    # gc\n    dialog.setAttribute(QtCore.Qt.WA_DeleteOnClose)\n    # show dialog\n    pos = QtGui.QCursor.pos()\n    dialog.move(pos.x(), pos.y())\n    # execute callback\n    if onshow_event:\n        onshow_event(dialog)\n    if modal:\n        dialog.exec_()\n    else:\n        dialog.show()\n        dialog.raise_()  # ensures dialog window is on top\n    return dialog"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ngenerate new random Bitcoin private key using os. urandom and double - sha256.", "response": "def genkeyhex():\n    '''\n    Generate new random Bitcoin private key, using os.urandom and\n    double-sha256.  Hex format.\n    '''\n\n    while True:\n        key = hash256(\n                hexlify(os.urandom(40) + str(datetime.datetime.now())\n                                            .encode(\"utf-8\")))\n        # 40 bytes used instead of 32, as a buffer for any slight\n        #     lack of entropy in urandom\n        # Double-sha256 used instead of single hash, for entropy\n        #     reasons as well.\n        # I know, it's nit-picking, but better safe than sorry.\n\n        if int(key,16) > 1 and int(key,16) < N:\n            break\n    return key"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef genkey(outcompressed=True,prefix='80'):\n    '''\n    Generate new random Bitcoin private key, using os.urandom and\n    double-sha256.\n    '''\n\n    key = prefix + genkeyhex()\n    if outcompressed:\n        key = key + '01'\n    return b58e(key)", "response": "Generate new random Bitcoin private key."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ntakes a hex string that begins with varint data, and has extra at the end, and gets the varint integer, strips the varint bytes, and returns the integer and the remaining data. So rather than having to manually read the varint prefix, count, and strip, you can do it in one function. This function will return a tuple of the data and the leftover. For example, let's say you are parsing a transaction from beginning to end, and you know the next byte is a varint byte. Here's an example: fd5d010048304502200187af928e9d155c4b1ac9c1c9118153239aba76774f77 5d7c1f9c3e106ff33c0221008822b0f658edec22274d0b6ae9de10ebf2da06b1 bbdaaba4e50eb078f39e3d78014730440220795f0f4f5941a77ae032ecb9e337 53788d7eb5cb0c78d805575d6b00a1d9bfed02203e1f4ad9332d1416ae01e270 38e945bc9db59c732728a383a6f1ed2fb99da7a4014cc952410491bba2510912 a5bd37da1fb5b1673010e43d2c6d812c514e91bfa9f2eb129e1c183329db55bd 868e209aac2fbc02cb33d98fe74bf23f0c235d6126b1d8334f864104865c4029 3a680cb9c020e7b1e106d8c1916d3cef99aa431a56d253e69256dac09ef122b1 a986818a7cb624532f062c1d1f8722084861c5c3291ccffef4ec687441048d24 55d2403e08708fc1f556002f1b6cd83f992d085097f9974ab08a28838f07896f bab08f39495e15fa6fad6edbfb1e754e35fa1c7844c41f322a1863d4621353ae ffffffff0140420f00000000001976a914ae56b4db13554d321c402db3961187 aed1bbed5b88ac00000000 If the above tx fragment is input as a single long string with no white-space, this function will return the tuple: ('004830...53ae', 'ffffffff...00000000') See _doctester.py for that example in action.", "response": "def getandstrip_varintdata(data):\n    '''\n    Takes a hex string that begins with varint data, and has extra at\n    the end, and gets the varint integer, strips the varint bytes, and\n    returns the integer and the remaining data.  So rather than having\n    to manually read the varint prefix, count, and strip, you can do\n    it in one function.  This function will return a tuple of the data\n    and the leftover.\n\n    For example, let's say you are parsing a transaction from\n    beginning to end, and you know the next byte is a varint byte.\n\n    Here's an example:\n\n    fd5d010048304502200187af928e9d155c4b1ac9c1c9118153239aba76774f77\n    5d7c1f9c3e106ff33c0221008822b0f658edec22274d0b6ae9de10ebf2da06b1\n    bbdaaba4e50eb078f39e3d78014730440220795f0f4f5941a77ae032ecb9e337\n    53788d7eb5cb0c78d805575d6b00a1d9bfed02203e1f4ad9332d1416ae01e270\n    38e945bc9db59c732728a383a6f1ed2fb99da7a4014cc952410491bba2510912\n    a5bd37da1fb5b1673010e43d2c6d812c514e91bfa9f2eb129e1c183329db55bd\n    868e209aac2fbc02cb33d98fe74bf23f0c235d6126b1d8334f864104865c4029\n    3a680cb9c020e7b1e106d8c1916d3cef99aa431a56d253e69256dac09ef122b1\n    a986818a7cb624532f062c1d1f8722084861c5c3291ccffef4ec687441048d24\n    55d2403e08708fc1f556002f1b6cd83f992d085097f9974ab08a28838f07896f\n    bab08f39495e15fa6fad6edbfb1e754e35fa1c7844c41f322a1863d4621353ae\n    ffffffff0140420f00000000001976a914ae56b4db13554d321c402db3961187\n    aed1bbed5b88ac00000000\n    \n    If the above tx fragment is input as a single long string with no\n    white-space, this function will return the tuple:\n    ('004830...53ae', 'ffffffff...00000000')\n\n    See _doctester.py for that example in action.\n    '''\n\n    data = strlify(data)\n    numbytes = numvarintbytes(data[:2])\n    varint = data[:2*numbytes]\n    data = data[2*numbytes:]\n    tostrip = fromvarint(varint) * 2\n    return data[:tostrip], data[tostrip:]"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nformat an int to DER hex format", "response": "def inttoDER(a):\n    '''\n    Format an int/long to DER hex format\n    '''\n\n    o = dechex(a,1)\n    if int(o[:2],16) > 127:\n        o = '00' + o\n    olen = dechex(len(o)//2,1)\n    return '02' + olen + o"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef inttoLEB128(intinput):\n    '''\n    Convert int/long to unsigned LEB128 format hex\n    '''\n\n    binstr = str(bin(intinput)) \\\n             .lstrip(\"0b\").replace(\"b\",\"\").replace(\"L\",\"\") \\\n             .replace(\"'\",\"\").replace('\"',\"\")\n    if len(binstr) % 7:\n        binstr = binstr.zfill(len(binstr) + 7 - (len(binstr) % 7))\n    bytelist = \"\"\n    for i in range(len(binstr) // 7):\n        if i < ((len(binstr) // 7) - 1):\n            pad = \"1\"\n        else:\n            pad = \"0\"\n        currbyte = binstr[(len(binstr) - (7*i + 7)):(len(binstr) - (7*i))]\n        currbyte = pad + currbyte\n        currbyte = dechex(int(currbyte,2))\n        # assert len(currbyte) == 2\n        bytelist = bytelist + currbyte\n    return bytelist", "response": "Convert int to unsigned LEB128 format hex\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef LEB128toint(LEBinput):\n    '''\n    Convert unsigned LEB128 hex to integer\n    '''\n\n    reversedbytes = hexreverse(LEBinput)\n    binstr = \"\"\n    for i in range(len(LEBinput) // 2):\n        if i == 0:\n            assert int(reversedbytes[2*i:(2*i + 2)],16) < 128\n        else:\n            assert int(reversedbytes[2*i:(2*i + 2)],16) >= 128\n        tempbin = str(bin(int(reversedbytes[2*i:(2*i + 2)],16))) \\\n                  .lstrip(\"0b\").replace(\"b\",\"\").replace(\"L\",\"\") \\\n                  .replace(\"'\",\"\").replace('\"',\"\") \\\n                  .zfill(8)\n        binstr += tempbin[1:]\n    return int(binstr,2)", "response": "Convert unsigned LEB128 hex to integer"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a string of the traceback of the current locale.", "response": "def get_traceback_stxt():\n        \"\"\"\n        Result is (bytes) str type on Python 2 and (unicode) str type on Python 3.\n        \"\"\"\n        #/\n        exc_cls, exc_obj, tb_obj = sys.exc_info()\n        \n        #/\n        txt_s = traceback.format_exception(exc_cls, exc_obj, tb_obj)\n    \n        #/\n        res = ''.join(txt_s)\n    \n        return res"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add_attribute(self, attribute):\n        self.attributes.append(attribute)\n        return len(self.attributes)", "response": "Adds the given attribute to this Card. Returns the length of the attributes after addition."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding the given ability to this Card under the given phase. Returns the length of the abilities for the given phase.", "response": "def add_ability(self, phase, ability):\n        \"\"\"Add the given ability to this Card under the given phase. Returns\n        the length of the abilities for the given phase after the addition.\n        \"\"\"\n        if phase not in self.abilities:\n            self.abilities[phase] = []\n        self.abilities[phase].append(ability)\n        return len(self.abilities[phase])"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets any special info you wish to the given key.", "response": "def set_info(self, key, value, append=True):\n        \"\"\"\n        Set any special info you wish to the given key. Each info is stored in\n        a list and will be appended to rather then overriden unless append is\n        False.\n        \"\"\"\n        if append:\n            if key not in self.info:\n                self.info[key] = []\n            self.info[key].append(value)\n        else:\n            self.info[key] = value"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef save(self):\n        return dict(code=self.code, name=self.name, abilities=self.abilities,\n                    attributes=self.attributes, info=self.info)", "response": "Returns a dictionary capable of reconstructing the\n        card with load or serialized to a string for storage."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef load(self, carddict):\n        self.code = carddict[\"code\"]\n        if isinstance(self.code, text_type):\n            self.code = eval(self.code)\n        self.name = carddict[\"name\"]\n        self.abilities = carddict[\"abilities\"]\n        if isinstance(self.abilities, text_type):\n            self.abilities = eval(self.abilities)\n        self.attributes = carddict[\"attributes\"]\n        if isinstance(self.attributes, text_type):\n            self.attributes = eval(self.attributes)\n        self.info = carddict[\"info\"]\n        if isinstance(self.info, text_type):\n            self.info = eval(self.info)\n        return self", "response": "Loads the details from a carddict."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nyields successive n - sized chunks from l.", "response": "def chunks(l, n):\n    \"\"\"Yield successive n-sized chunks from l.\"\"\"\n    if n:\n        for i in xrange(0, len(l), n):\n            yield l[i:i + n]"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns False if the exception had not been handled gracefully", "response": "def ep(self, exc: Exception) -> bool:\n        \"\"\"Return False if the exception had not been handled gracefully\"\"\"\n        if not isinstance(exc, ConnectionAbortedError):\n            return False\n\n        if len(exc.args) != 2:\n            return False\n\n        origin, reason = exc.args\n\n        logging.getLogger(__name__).warning('Exited')\n\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef required(wrapping_functions, patterns_rslt):\n    '''\n    USAGE:\n\n    from django.contrib.auth.decorators import login_required\n    from django.contrib.admin.views.decorators import staff_member_required\n\n    mypage_patterns = required(\n        login_required,\n        [\n            ... url patterns ...\n        ]\n    )\n\n    staff_patterns = required(\n        staff_member_required,\n        [\n            ... url patterns ...\n        ]\n    )\n\n    urlpatterns += [\n        url(r'^staff/', include(staff_patterns, namespace='staff')),\n        url(r'^mypage/', include(mypage_patterns, namespace='mypage')),\n    ]\n    '''\n    if not hasattr(wrapping_functions, '__iter__'):\n        wrapping_functions = (wrapping_functions,)\n    return [\n        _wrap_instance__resolve(wrapping_functions, instance)\n        for instance in patterns_rslt\n    ]", "response": "returns a list of urls that are required by the given patterns"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget all metadata for the given entity or entities at the given path or paths.", "response": "def get_all(self, paths: Union[str, Sequence[str]]) -> Union[IrodsMetadata, List[IrodsMetadata]]:\n        \"\"\"\n        Gets all of the metadata for the iRODS entities at the given path or paths.\n\n        If multiple paths are given, the metadata collection at index `i` on the output corresponds to the path at index\n        `i` on the input. i.e.\n        ```\n        output = mapper.get_all([\"path_1\", \"path_2\"])\n        metadata_for_path_1 = output[0]\n        metadata_for_path_2 = output[1]\n        ```\n\n        A `ValueError` will be raised will be raised if the path does not correspond to a valid entity.\n        :param path: the path of the entity or entities to get the metadata for\n        :return: metadata for the given entity or entities\n        \"\"\""}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting the given metadata on the given iRODS entities at the given path or paths.", "response": "def set(self, paths: Union[str, Iterable[str]], metadata: Union[IrodsMetadata, List[IrodsMetadata]]):\n        \"\"\"\n        Sets the given metadata on the iRODS entities at the given path or paths. Similar to `add` excpet pre-existing\n        metadata with matching keys will be overwritten.\n\n        If a single metadata collection is given, that metadata is set for all paths. If a list of metadata are given,\n        each collection is set for the path with the corresponding index.\n\n        A `ValueError` will be raised will be raised if the path does not correspond to a valid entity.\n        :param path: the path of the entity to set the metadata for\n        :param metadata: the metadata to set\n        \"\"\""}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_all(self, paths: Union[str, Sequence[str]]) -> Union[Set[AccessControl], Sequence[Set[AccessControl]]]:", "response": "Gets all the access controls for the given entity with the given path."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add_or_replace(self, paths: Union[str, Iterable[str]],\n                       access_controls: Union[AccessControl, Iterable[AccessControl]]):\n        \"\"\"\n        Adds the given access controls to those associated with the given path or collection of paths. If an access\n        control already exists for a user, the access control is replaced.\n        :param paths: the paths to add the access controls\n        :param access_controls: the access controls to add\n        \"\"\"", "response": "Adds the given access controls to those associated with the given path or collection of paths."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set(self, paths: Union[str, Iterable[str]], access_controls: Union[AccessControl, Iterable[AccessControl]]):", "response": "Sets the access controls associated to a give path or collection of paths to those given."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef revoke(self, paths: Union[str, Iterable[str]], users: Union[str, Iterable[str], User, Iterable[User]]):", "response": "Revokes all access controls associated to the given path or collection of users."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsees `AccessControlMapper.add`. :param paths: see `AccessControlMapper.add` :param access_controls: see `AccessControlMapper.add` :param recursive: whether the access control list should be changed recursively for all nested collections", "response": "def add_or_replace(self, paths: Union[str, Iterable[str]],\n                       access_controls: Union[AccessControl, Iterable[AccessControl]], recursive: bool=False):\n        \"\"\"\n        See `AccessControlMapper.add`.\n        :param paths: see `AccessControlMapper.add`\n        :param access_controls: see `AccessControlMapper.add`\n        :param recursive: whether the access control list should be changed recursively for all nested collections\n        \"\"\""}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef revoke(self, paths: Union[str, Iterable[str]], users: Union[str, Iterable[str], User, Iterable[User]],\n               recursive: bool=False):\n        \"\"\"\n        See `AccessControlMapper.revoke`.\n        :param paths: see `AccessControlMapper.revoke`\n        :param users: see `AccessControlMapper.revoke`\n        :param recursive: whether the access control list should be changed recursively for all nested collections\n        \"\"\"", "response": "Removes the specified paths and users from the access control list."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsees `AccessControlMapper.revoke_all`. :param paths: see `AccessControlMapper.revoke_all` :param access_controls: see `AccessControlMapper.revoke_all` :param recursive: whether the access control list should be changed recursively for all nested collections", "response": "def revoke_all(self, paths: Union[str, Iterable[str]], recursive: bool=False):\n        \"\"\"\n        See `AccessControlMapper.revoke_all`.\n        :param paths: see `AccessControlMapper.revoke_all`\n        :param access_controls: see `AccessControlMapper.revoke_all`\n        :param recursive: whether the access control list should be changed recursively for all nested collections\n        \"\"\""}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget entities from iRODS that have metadata that matches the given search criteria.", "response": "def get_by_metadata(self, metadata_search_criteria: Union[SearchCriterion, Iterable[SearchCriterion]],\n                        load_metadata: bool=True, zone: str=None) -> Sequence[EntityType]:\n        \"\"\"\n        Gets entities from iRODS that have metadata that matches the given search criteria.\n        :param metadata_search_criteria: the metadata search criteria\n        :param load_metadata: whether metadata associated to the entities should be loaded\n        :param zone: limit query to specific zone in iRODS\n        :return: the matched entities in iRODS\n        \"\"\""}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_by_path(self, paths: Union[str, Iterable[str]], load_metadata: bool=True) \\\n            -> Union[EntityType, Sequence[EntityType]]:\n        \"\"\"\n        Gets the entity or entities with the given path or paths from iRODS.\n\n        If one or more of the entities does not exist, a `FileNotFound` exception will be raised.\n        :param paths: the paths of the entities to get from iRODS\n        :param load_metadata: whether metadata associated to the entities should be loaded\n        :return: the single entity retrieved from iRODS if a single path is given, else a sequence of retrieved entities\n        \"\"\"", "response": "Gets the entity or entities with the given path or paths from iRODS."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets all entities contained within the given iRODS collections.", "response": "def get_all_in_collection(self, collection_paths: Union[str, Iterable[str]], load_metadata: bool = True) \\\n            -> Sequence[EntityType]:\n        \"\"\"\n        Gets entities contained within the given iRODS collections.\n\n        If one or more of the collection_paths does not exist, a `FileNotFound` exception will be raised.\n        :param collection_paths: the collection(s) to get the entities from\n        :param load_metadata: whether metadata associated to the entities should be loaded\n        :return: the entities loaded from iRODS\n        \"\"\""}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _get_package_name(prefix=settings.TEMP_DIR, book_id=None):\n    if book_id is None:\n        book_id = str(uuid.uuid4())\n\n    return os.path.join(prefix, book_id)", "response": "Return package path. Use uuid to generate package s directory name."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _create_package_hierarchy(prefix=settings.TEMP_DIR, book_id=None):\n    root_dir = _get_package_name(book_id=book_id, prefix=prefix)\n\n    if os.path.exists(root_dir):\n        shutil.rmtree(root_dir)\n\n    os.mkdir(root_dir)\n\n    original_dir = os.path.join(root_dir, \"original\")\n    metadata_dir = os.path.join(root_dir, \"metadata\")\n\n    os.mkdir(original_dir)\n    os.mkdir(metadata_dir)\n\n    return root_dir, original_dir, metadata_dir", "response": "Create a hierarchy of directories at the top of the specification."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef create_ltp_package(aleph_record, book_id, ebook_fn, data, url,\n                       urn_nbn=None):\n    \"\"\"\n    Create LTP package as it is specified in specification v1.0 as I understand\n    it.\n\n    Args:\n        aleph_record (str): XML containing full aleph record.\n        book_id (str): UUID of the book.\n        ebook_fn (str): Original filename of the ebook.\n        data (str/bytes): Ebook's content.\n        url (str): URL of the publication used when the URL can't be found in\n                   `aleph_record`.\n        urn_nbn (str, default None): URN:NBN.\n\n    Returns:\n        str: Name of the package's directory in ``/tmp``.\n    \"\"\"\n    root_dir, orig_dir, meta_dir = _create_package_hierarchy(book_id=book_id)\n\n    # create original file\n    original_fn = os.path.join(\n        orig_dir,\n        fn_composers.original_fn(book_id, ebook_fn)\n    )\n    with open(original_fn, \"wb\") as f:\n        f.write(data)\n\n    # create metadata files\n    metadata_filenames = []\n    records = marcxml2mods(marc_xml=aleph_record, uuid=book_id, url=url)\n    for cnt, mods_record in enumerate(records):\n        fn = os.path.join(\n            meta_dir,\n            fn_composers.volume_fn(cnt)\n        )\n\n        with open(fn, \"w\") as f:\n            f.write(mods_record)\n\n        metadata_filenames.append(fn)\n\n    # collect md5 sums\n    md5_fn = os.path.join(root_dir, fn_composers.checksum_fn(book_id))\n    checksums = checksum_generator.generate_hashfile(root_dir)\n    with open(md5_fn, \"w\") as f:\n        f.write(checksums)\n\n    # create info file\n    info_fn = os.path.join(root_dir, fn_composers.info_fn(book_id))\n    with open(info_fn, \"w\") as f:\n        f.write(\n            info_composer.compose_info(\n                root_dir=root_dir,\n                files=[original_fn] + metadata_filenames,\n                hash_fn=md5_fn,\n                aleph_record=aleph_record,\n                urn_nbn=urn_nbn,\n            )\n        )\n\n    return root_dir", "response": "Create LTP package as it is specified in specification v1. 0 as I understand\n    it."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef steemconnect(self, accesstoken=None):\n        ''' Initializes the SteemConnect Client\n        class\n        '''\n        if self.sc is not None:\n            return self.sc\n        if accesstoken is not None:\n            self.accesstoken = accesstoken\n        if self.accesstoken is None:\n            self.sc = Client(client_id=self.client_id, \n                            client_secret=self.client_secret)\n        else:\n            self.sc = Client(access_token=self.accesstoken,\n                            client_id=self.client_id, \n                            client_secret=self.client_secret)\n        return self.sc", "response": "Initializes the SteemConnect Client\n        class"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nuses a SteemConnect refresh token to retreive an access token", "response": "def get_token(self, code=None):\n        ''' Uses a SteemConnect refresh token\n        to retreive an access token\n        '''\n        tokenobj = self.steemconnect().get_access_token(code)\n        for t in tokenobj:\n            if t == 'error':\n                self.msg.error_message(str(tokenobj[t]))\n                return False\n            elif t == 'access_token':\n                self.username = tokenobj['username']\n                self.refresh_token = tokenobj['refresh_token']\n                return tokenobj[t]"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef vote(self, voter, author, permlink, voteweight):\n        ''' Uses a SteemConnect accses token\n        to vote.\n        '''\n        vote = Vote(voter, author, permlink, voteweight)\n        result = self.steemconnect().broadcast(\n            [vote.to_operation_structure()])\n        return result", "response": "Uses a SteemConnect accses token\n        to vote."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef on_person_new(self, people):\n        try:\n            self.on_person_leave([])\n        except:\n            # Already caught and logged\n            pass\n\n        try:\n            self.sensor_client.join(people)\n        except:\n            self.exception(\"Failed to join audience\")\n            raise Exception(\"Joining audience failed\")", "response": "Called when a new person is added to the audience."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef on_person_update(self, people):\n        try:\n            self.sensor_client.person_update(people)\n        except:\n            self.exception(\"Failed to update people\")\n            raise Exception(\"Updating people failed\")", "response": "Called when a person has changed"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nremoving all keys from the namespace", "response": "def delete_namespace(self):\n        '''Remove all keys from the namespace\n\n        '''\n        conn = redis.Redis(connection_pool=self.pool)\n        keys = conn.keys(\"%s*\" % self._namespace_str)\n        for i in xrange(0, len(keys), 10000):\n            conn.delete(*keys[i:i+10000])\n        logger.debug('tearing down %r', self._namespace_str)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef create_deamon(cmd, shell=False, root=False):\n    try:\n        if root:\n            cmd.insert(0, 'sudo')\n        LOG.info(cmd)\n        subproc = subprocess.Popen(cmd, shell=shell, stdout=subprocess.PIPE,\n                                   stderr=subprocess.PIPE)\n        return subproc.pid\n    except Exception as e:\n        LOG.error(e)\n        raise", "response": "Usage :\n            Create servcice process."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_interface(interface):\n    # Supported CentOS Version\n    supported_dists = ['7.0', '6.5']\n\n    def format_centos_7_0(inf):\n        pattern = r'<([A-Z]+)'\n        state = re.search(pattern, stdout[0]).groups()[0]\n        state = 'UP' if not cmp(state, 'UP') else 'DOWN'\n        inf.state = state\n        stdout.pop(0)\n        pattern = r'inet\\s(.*)\\s\\snetmask\\s(.*)\\s\\sbroadcast\\s(.*)'\n        for line in stdout:\n            if line.startswith('inet '):\n                tmp = re.search(pattern, line).groups()\n                (inf.inet, inf.netmask, inf.broadcast) = tmp\n                stdout.remove(line)\n                break\n        for line in stdout:\n            if line.startswith('ether'):\n                inf.ether = line[6:23]\n                break\n        return stdcode, '', inf.make_dict()\n\n    def format_centos_6_5(inf):\n        pattern = r'HWaddr\\s(.*)'\n        inf.ether = re.search(pattern, stdout[0]).groups()[0]\n        stdout.pop(0)\n        pattern = r'addr:(.*)\\s\\sBcast:(.*)\\s\\sMask:(.*)'\n        for line in stdout:\n            if line.startswith('inet '):\n                tmp = re.search(pattern, line).groups()\n                (inf.inet, inf.broadcast, inf.netmask) = tmp\n                stdout.remove(line)\n                break\n        inf.state = 'DOWN'\n        for line in stdout:\n            if 'RUNNING' in line:\n                state = line[:2]\n                state = 'UP' if not cmp(state, 'UP') else 'DOWN'\n                inf.state = state\n                break\n        return stdcode, '', inf.make_dict()\n\n    linux_dist = platform.linux_distribution()[1][:3]\n    if linux_dist in supported_dists:\n        try:\n            cmd = ['ifconfig', interface]\n            stdcode, stdout = execute(cmd)\n            inf = resource.Interface(interface)\n            if not cmp(linux_dist, '6.5'):\n                return format_centos_6_5(inf)\n            elif not cmp(linux_dist, '7.0'):\n                return format_centos_7_0(inf)\n        except Exception as e:\n            message = stdout.pop(0)\n            return stdcode, message, None\n\n    # Unsupported OS distribute\n    message = 'Unsupported OS distribute %s, only support for CentOS %s.'\n    message = message % (linux_dist, str(supported_dists))\n    return 1, message, None", "response": "Return a list of supported CentOS standard physical interfaces."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef convert_to_str(d):\n    d2 = {}\n    for k, v in d.items():\n        k = str(k)\n        if type(v) in [list, tuple]:\n            d2[k] = [str(a) for a in v]\n        elif type(v) is dict:\n            d2[k] = convert_to_str(v)\n        else:\n            d2[k] = str(v)\n    return d2", "response": "Recursively convert all values in a dictionary to strings"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nstarts the specified docker - compose services.", "response": "def up(services: Iterable[str] = ()) -> int:\n    '''Start the specified docker-compose services.\n\n    Parameters\n    ----------\n\n    :``services``: a list of docker-compose service names to start (must be\n                   defined in docker-compose.yml)\n\n    Return Value(s)\n    ---------------\n\n    The integer status of ``docker-compose up``.\n\n    '''\n\n    services = list(services)\n\n    if not len(services):\n        raise ValueError('empty iterable passed to up(): {0}'.format(services))\n\n    return _call('docker-compose up --no-color -d ' + ' '.join(services), shell = True)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nwrapping around subprocess. Popen that sends command output to logger.", "response": "def _call(command: str, *args, **kwargs) -> int:\n    '''Wrapper around ``subprocess.Popen`` that sends command output to logger.\n\n    .. seealso::\n\n       ``subprocess.Popen``_\n\n    Parameters\n    ----------\n\n    :``command``: string form of the command to execute\n\n    All other parameters are passed directly to ``subprocess.Popen``.\n\n    Return Value(s)\n    ---------------\n\n    The integer status of command.\n\n    '''\n\n    child = subprocess.Popen(command, stdout = subprocess.PIPE, stderr = subprocess.PIPE, *args, **kwargs)\n\n    def log():\n        '''Send processes stdout and stderr to logger.'''\n\n        for fh in select.select(( child.stdout, child.stderr, ), (), (), 0)[0]:\n            line = fh.readline()[:-1]\n\n            if len(line):\n                getattr(logger, {\n                    child.stdout: 'debug',\n                    child.stderr: 'error',\n                }[fh])('%s: %s', command, line)\n\n    while child.poll() is None:\n        log()\n\n    log()\n\n    return child.wait()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _api_private_request(self, endpoint, user, params=None, method=None, headers=None):\n\t\tparams = params or {}\n\t\turl = self._get_api_endpoint_url(endpoint)\n\n\t\tparams['access_token'] = user.access_token\n\t\tr = self._request(url, params = params, method = method, headers = headers)\n\t\t\"\"\" Check if everything was fine\n\t\t\tIf not: Try to refresh the access token \"\"\"\n\t\tif r.status_code == 401:\n\t\t\tself._refresh_access_token(user)\n\t\t\t\"\"\" Repeat the request \"\"\"\n\t\t\tr = self._request(url, params = params, method = method, headers = headers)\n\t\treturn r", "response": "Make a request to the API endpoint with the given user s access token."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nwatch for file changes and reload config when needed.", "response": "def _file_watcher(state):\n    \"\"\"Watch for file changes and reload config when needed.\n\n    Arguments:\n        state (_WaffleState): Object that contains reference to app and its\n            configstore.\n    \"\"\"\n    conf = state.app.config\n\n    file_path = conf.get('WAFFLE_WATCHER_FILE', '/tmp/waffleconf.txt')\n\n    if not os.path.isfile(file_path):\n        # Create watch file\n        open(file_path, 'a').close()\n\n    while True:\n        tstamp = os.path.getmtime(file_path)\n\n        # Compare timestamps and update config if needed\n        if tstamp > state._tstamp:\n            state.update_conf()\n            state._tstamp = tstamp\n\n        # Not too critical\n        time.sleep(10)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nlistening to redis channel for configuration update notifications.", "response": "def _redis_watcher(state):\n    \"\"\"Listen to redis channel for a configuration update notifications.\n\n    Arguments:\n        state (_WaffleState): Object that contains reference to app and its\n            configstore.\n    \"\"\"\n    conf = state.app.config\n\n    r = redis.client.StrictRedis(\n        host=conf.get('WAFFLE_REDIS_HOST', 'localhost'),\n        port=conf.get('WAFFLE_REDIS_PORT', 6379))\n\n    sub = r.pubsub(ignore_subscribe_messages=True)\n    sub.subscribe(conf.get('WAFFLE_REDIS_CHANNEL', 'waffleconf'))\n\n    while True:\n        for msg in sub.listen():\n            # Skip non-messages\n            if not msg['type'] == 'message':\n                continue\n\n            tstamp = float(msg['data'])\n\n            # Compare timestamps and update config if needed\n            if tstamp > state._tstamp:\n                state.update_conf()\n                state._tstamp = tstamp"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nnotifying of configuration update through file.", "response": "def _file_notifier(state):\n    \"\"\"Notify of configuration update through file.\n\n    Arguments:\n        state (_WaffleState): Object that contains reference to app and its\n            configstore.\n    \"\"\"\n    tstamp = time.time()\n    state._tstamp = tstamp\n    conf = state.app.config\n\n    file_path = conf.get('WAFFLE_WATCHER_FILE', '/tmp/waffleconf.txt')\n\n    if not os.path.isfile(file_path):\n        # Create watch file\n        open(file_path, 'a').close()\n\n    # Update timestamp\n    os.utime(file_path, (tstamp, tstamp))"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nnotifies of configuration update through redis.", "response": "def _redis_notifier(state):\n    \"\"\"Notify of configuration update through redis.\n\n    Arguments:\n        state (_WaffleState): Object that contains reference to app and its\n            configstore.\n    \"\"\"\n    tstamp = time.time()\n    state._tstamp = tstamp\n    conf = state.app.config\n\n    # Notify timestamp\n    r = redis.client.StrictRedis()\n    r.publish(conf.get('WAFFLE_REDIS_CHANNEL', 'waffleconf'), tstamp)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates a directory in the system", "response": "def make_dir(cls, directory_name):\n        \"\"\"Create a directory in the system\"\"\"\n        if not os.path.exists(directory_name):\n            os.makedirs(directory_name)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef ReportConfiguration(self, file):\n        print >> file, BuildReportLine(\"PED FILE\", self.datasource)\n        print >> file, BuildReportLine(\"MAP FILE\", self.mapfile)", "response": "Report configuration for logging purposes."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nload the marker data from the map file.", "response": "def load_mapfile(self, map3=False):\n        \"\"\"Load the marker data\n\n        :param map3: When true, ignore the gen. distance column\n\n        Builds up the marker list according to the boundary configuration\n\n\n        \"\"\"\n        cols = [0, 1, 3]\n        if map3:\n            cols = [0, 1, 2]\n        markers = numpy.loadtxt(self.mapfile, dtype=str, usecols=cols)\n\n        self.snp_mask = numpy.ones(markers.shape[0]*2,\n                                   dtype=numpy.int8).reshape(-1, 2)\n\n        if DataParser.boundary.NoExclusions():\n            self.markers = numpy.zeros((markers.shape[0], 2), dtype=int)\n            # Check for plink's \"off\" mode\n            mask = markers[:, 2].astype(int) >= 0\n            # Turn them all 'on'\n            self.snp_mask[:,0] = ~mask\n            self.snp_mask[:,1] = ~mask\n            snp_count = numpy.sum(self.snp_mask[:, 0] == 0)\n\n            self.markers[0:snp_count, 0] = markers[:, 0].astype(int)[mask]\n            self.markers[0:snp_count, 1] = markers[:, 2].astype(int)[mask]\n            self.rsids = markers[:, 1][mask]\n            self.markers = self.markers[0:snp_count]\n        else:\n            idx = 0\n            self.markers = []\n            self.rsids   = []\n            for locus in markers:\n                if DataParser.boundary.TestBoundary(int(locus[0]),\n                                                    int(locus[2]), locus[1]):\n                    self.markers.append([locus[0], locus[2]])\n                    self.rsids.append(locus[1])\n                    self.snp_mask[idx] = 0\n                idx += 1\n            self.markers = numpy.array(self.markers, dtype=numpy.int)\n            self.rsids   = numpy.array(self.rsids)\n\n        # We don't follow these rules here\n        DataParser.boundary.beyond_upper_bound = False\n        self.locus_count    = len(self.markers)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef load_genotypes(self, pheno_covar):\n\n        first_genotype = 6\n        pheno_col      = 5\n        if not DataParser.has_sex:\n            first_genotype -= 1\n            pheno_col -= 1\n        if not DataParser.has_parents:\n            first_genotype -= 2\n            pheno_col -= 2\n        if not DataParser.has_pheno:\n            first_genotype -= 1\n        if not DataParser.has_fid:\n            first_genotype -= 1\n            pheno_col -= 1\n        if DataParser.has_liability:\n            first_genotype += 1\n\n        sex_col = pheno_col - 1\n        individual_mask = []\n        self.individual_mask = []\n        dropped_individuals = []\n\n        # number of missing SNPs we can tolerate before dropping an individual\n        max_missing_for_individual = numpy.sum(\n                self.snp_mask[:, 0]==0) * DataParser.ind_miss_tol\n\n        if DataParser.compressed_pedigree:\n            ind_count, err = sys_call(\"gzip -cd %s | wc -l\" %\n                                      (\"%s.gz\" % (self.datasource)))\n        else:\n            ind_count, err = sys_call(\"wc -l %s\" % (self.datasource))\n        ind_count = int(ind_count[0].split()[0]) + 1\n\n        snp_count = numpy.sum(self.snp_mask[:, 0] == 0)\n\n        allelic_data = numpy.empty((ind_count, snp_count, 2), dtype='S1')\n\n        valid_allele_count = 0\n        if DataParser.compressed_pedigree:\n            input_file = gzip.open(\"%s.gz\" % self.datasource, 'rb')\n        else:\n            input_file = open(self.datasource)\n\n        for line in input_file:\n            line = line.strip()\n            if len(line) > 0:\n                raw_data = line.strip().split()\n                alleles = numpy.ma.MaskedArray(\n                        numpy.array(raw_data[first_genotype:]).reshape(-1, 2),\n                        self.snp_mask).compressed().reshape(-1, 2)\n\n                # Convert the alleles into genotypes\n                indid = \":\".join(raw_data[0:2])\n                if not DataParser.has_fid:\n                    indid = raw_data[0]\n\n                # Ignore any subjects that are to be excluded and remove those\n                # that have too much missingness\n                if DataParser.valid_indid(indid):\n                    missing = numpy.sum(alleles[:, 0] ==\n                                        DataParser.missing_representation)\n\n                    if missing > max_missing_for_individual:\n                        individual_mask += [1, 1]\n                        self.individual_mask.append(1)\n                        dropped_individuals.append(indid)\n                    else:\n                        sex = None\n                        phenotype = None\n                        if DataParser.has_pheno:\n                            phenotype = float(raw_data[pheno_col])\n                        if DataParser.has_sex:\n                            sex = int(raw_data[sex_col])\n                        if pheno_covar is not None:\n                            pheno_covar.add_subject(indid, sex, phenotype)\n                        individual_mask += [0, 0]\n                        self.individual_mask.append(0)\n                        allelic_data[valid_allele_count] = alleles\n                        valid_allele_count += 1\n\n                else:\n                    individual_mask += [1, 1]\n                    self.individual_mask.append(1)\n        self.ind_count = valid_allele_count\n        allelic_data = allelic_data[0:valid_allele_count]\n        self.genotypes = numpy.empty((snp_count, valid_allele_count))\n        max_missing_individuals = DataParser.snp_miss_tol * ind_count\n        dropped_loci = []\n        valid_snps = 0\n        valid_markers = []\n        valid_rsids   = []\n        valid_maf     = []\n        valid_allele_list = []\n        allele_count2s = []\n\n        for i in xrange(0, snp_count):\n            snp_geno = allelic_data[:,i]\n            alleles = list(set(numpy.unique(snp_geno)) -\n                           set([DataParser.missing_representation]))\n\n            if len(alleles) > 2:\n                raise TooManyAlleles(chr=self.markers[i][0],\n                                     rsid=self.rsids[i],\n                                     alleles=alleles)\n\n            allele_count1 = numpy.sum(snp_geno==alleles[0])\n            allele_count2 = 0\n            maf = 0\n\n            if len(alleles) > 1:\n                allele_count2 = numpy.sum(snp_geno==alleles[1])\n                real_allele_count2 = allele_count2\n\n                if allele_count2 > allele_count1:\n                    sorted_alleles = [alleles[1], alleles[0]]\n                    alleles = sorted_alleles\n                    allele_count = allele_count1\n                    allele_count1 = allele_count2\n                    allele_count2 = allele_count\n                maf = allele_count2 / float(allele_count1 + allele_count2)\n                allele_count2s.append(allele_count2)\n                #genotypes = []\n                major_allele       = alleles[0]\n                minor_allele       = alleles[1]\n\n                genotype_data = numpy.sum(snp_geno==alleles[1], axis=1)\n                genotype_data[\n                    snp_geno[:, 0]==DataParser.missing_representation] = \\\n                    DataParser.missing_storage\n            else:\n                major_allele = alleles[0]\n                minor_allele = '?'\n\n            missing = numpy.sum(genotype_data==DataParser.missing_storage)\n            if maf == 0 or maf < DataParser.min_maf or \\\n                            maf > DataParser.max_maf or \\\n                            max_missing_individuals < missing:\n                locus_details = self.markers[i]\n                DataParser.boundary.dropped_snps[\n                    locus_details[0]].add(locus_details[1])\n                dropped_loci.append(\"%s:%s\" % (locus_details[0],\n                                               locus_details[1]))\n                self.invalid_loci.append(i)\n            else:\n                self.genotypes[valid_snps, :] = genotype_data\n                valid_snps += 1\n                valid_markers.append(list(self.markers[i]))\n                valid_rsids.append(self.rsids[i])\n                valid_allele_list.append([major_allele, minor_allele])\n                valid_maf.append(maf)\n\n        self.markers = valid_markers\n        self.alleles = valid_allele_list\n        self.rsids   = valid_rsids\n        self.locus_count = valid_snps\n        self.genotypes = self.genotypes[0:self.locus_count, :]\n        self.allele_count2s = allele_count2s", "response": "Load all data into memory and propagate valid individuals to subject."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\npopulate the iteration with the current locus and return True if the current locus is valid.", "response": "def populate_iteration(self, iteration):\n        \"\"\"Parse genotypes from the file and iteration with relevant marker \\\n            details.\n\n        :param iteration: ParseLocus object which is returned per iteration\n        :return: True indicates current locus is valid.\n\n        StopIteration is thrown if the marker reaches the end of the file or\n        the valid genomic region for analysis.\n        \"\"\"\n\n        cur_idx = iteration.cur_idx\n        if cur_idx < self.locus_count:\n            iteration.chr = self.markers[cur_idx][0]\n            iteration.pos = self.markers[cur_idx][1]\n            iteration.rsid = self.rsids[cur_idx]\n            iteration.major_allele = self.alleles[cur_idx][0]\n            iteration.minor_allele = self.alleles[cur_idx][1]\n            iteration.allele_count2 = self.allele_count2s[cur_idx]\n            iteration.genotype_data = self.genotypes[cur_idx, :]\n            hetero = numpy.sum(iteration.genotype_data==1)\n            iteration.min_allele_count = numpy.sum(\n                iteration.genotype_data==2)*2 + hetero\n            iteration.maj_allele_count = numpy.sum(\n                iteration.genotype_data==0)*2 + hetero\n            return True\n        else:\n            raise StopIteration"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef find_this(search, source=SOURCE):\n    print(\"Searching for {what}.\".format(what=search))\n    if not search or not source:\n        print(\"Not found on source: {what}.\".format(what=search))\n        return \"\"\n    return str(re.compile(r'.*__{what}__ = \"(.*?)\"'.format(\n        what=search), re.S).match(source).group(1)).strip()", "response": "Take a string and a filename path string and return the found value."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef normalize_values_queryset(values_queryset, model=None, app=None, verbosity=1):\n    '''Shoehorn the values from one database table into another\n\n    * Remove padding (leading/trailing spaces) from `CharField` and `TextField` values\n    * Truncate all `CharField`s to the max_length of the destination `model`\n    * Subsititue blanks ('') for any None values destined for `null=False` fields\n\n    Returns a list of unsaved Model objects rather than a queryset\n    '''\n    model = model or values_queryset.model\n    app = app or DEFAULT_APP\n    new_list = []\n    for record in values_queryset:\n        new_record = {}\n        for k, v in record.iteritems():\n            field_name = find_field_name(k, model=model, app=app)\n            field_class = model._meta.get_field(field_name)\n            # if isinstance(field_class, (djmodels.fields.DateTimeField, djmodels.fields.DateField)):\n            #     new_record[field_name] = unix_timestamp(v)\n            # try:\n            if isinstance(field_class, (djmodels.fields.CharField, djmodels.fields.TextField))  or isinstance(v, basestring):\n                if v is None:\n                    v = ''\n                else:\n                    v = unicode(v).strip()\n            if isinstance(field_class, djmodels.fields.CharField):\n                if len(v) > getattr(field_class, 'max_length', 0):\n                    if verbosity > 0:\n                        print k, v, len(v), '>', field_class.max_length\n                        print 'string = %s' % repr(v)\n                    # truncate strings that are too long for the database field\n                    v = v[:getattr(field_class, 'max_length', 0)]\n            new_record[field_name] = v\n            # except:\n            #     pass\n            if (v is None or new_record[field_name] is None) and not getattr(field_class, 'null'):\n                new_record[field_name] = ''\n        if verbosity > 1:\n            print new_record\n        new_list += [new_record]\n    return new_list", "response": "Normalizes the values of a list of models into a list of unsaved models."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconverting a 1 - D sequence into a 2 - D sequence of tuples for use in a Django field choices attribute", "response": "def make_choices(*args):\n    \"\"\"Convert a 1-D sequence into a 2-D sequence of tuples for use in a Django field choices attribute\n\n    >>> make_choices(range(3))\n    ((0, u'0'), (1, u'1'), (2, u'2'))\n    >>> make_choices(dict(enumerate('abcd')))\n    ((0, u'a'), (1, u'b'), (2, u'c'), (3, u'd'))\n    >>> make_choices('hello')\n    (('hello', u'hello'),)\n    >>> make_choices('hello', 'world') == make_choices(['hello', 'world']) == (('hello', u'hello'), ('world', u'world'))\n    True\n    \"\"\"\n    if not args:\n        return tuple()\n    if isinstance(args[0], (list, tuple)):\n        return make_choices(*tuple(args[0]))\n    elif isinstance(args[0], collections.Mapping):\n        return tuple((k, unicode(v)) for (k, v) in args[0].iteritems())\n    elif all(isinstance(arg, (int, float, Decimal, basestring)) for arg in args):\n        return tuple((k, unicode(k)) for k in args)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nnormalizing the database choices for a given field.", "response": "def normalize_choices(db_values, field_name, app=DEFAULT_APP, model_name='', human_readable=True, none_value='Null', \n                      blank_value='Unknown', missing_value='Unknown DB Code'):\n    '''Output the human-readable strings associated with the list of database values for a model field.\n\n    Uses the translation dictionary `CHOICES_<FIELD_NAME>` attribute for the given `model_name`.\n    In addition, translate `None` into 'Null', or whatever string is indicated by `none_value`.\n    '''\n    if app and isinstance(app, basestring):\n        app = get_app(app)\n    if not db_values:\n        return\n    try:\n        db_values = dict(db_values)\n    except:\n        raise NotImplemented(\"This function can only handle objects that can be converted to a dict, not lists or querysets returned by django `.values().aggregate()`.\")\n\n    if not field_name in db_values:\n        return db_values\n    if human_readable:\n        for i, db_value in enumerate(db_values[field_name]):\n            if db_value in (None, 'None') or app in (None, 'None'):\n                db_values[field_name][i] = none_value\n                continue\n            if isinstance(db_value, basestring):\n                normalized_code = str(db_value).strip().upper()\n            # the app is actually the models.py module, NOT the app_name package\n            # so don't look in app.models, you'll only find django.db.models there (app_name.models.models)\n            choices = getattr(app, 'CHOICES_%s' % field_name.upper(), [])\n            normalized_name = None\n            if choices:\n                normalized_name = str(choices.get(normalized_code, missing_value)).strip()\n            elif normalized_code:\n                normalized_name = 'DB Code: \"%s\"' % normalized_code\n            db_values[field_name][i] = normalized_name or blank_value\n    else:\n        raise NotImplemented(\"This function can only convert database choices to human-readable strings.\")\n    return db_values"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting a list of apps that match the app name string", "response": "def get_app(app=None, verbosity=0):\n    \"\"\"Uses django.db.djmodels.get_app and fuzzywuzzy to get the models module for a django app\n\n    Retrieve an app module from an app name string, even if mispelled (uses fuzzywuzzy to find the best match)\n    To get a list of all the apps use `get_app(None)` or `get_app([]) or get_app(())`\n    To get a single random app use `get_app('')`\n\n    >>> get_app('call').__class__.__name__ == 'module'\n    True\n    >>> get_app('model').__name__ == 'miner.models'\n    True\n    >>> isinstance(get_app('whatever'), ModuleType)\n    True\n    >>> isinstance(get_app(''), ModuleType)\n    True\n    isinstance(get_app(), ModuleType)\n    False\n    isinstance(get_app(), list)\n    True\n    \"\"\"\n    # print 'get_app(', app\n    if not app:\n        # for an empty list, tuple or None, just get all apps\n        if isinstance(app, (type(None), list, tuple)):\n            return [app_class.__package__ for app_class in djmodels.get_apps() if app_class and app_class.__package__]\n        # for a blank string, get the default app(s)\n        else:\n            if get_app.default:\n                return get_app(get_app.default)\n            else:\n                return djmodels.get_apps()[-1]\n    elif isinstance(app, ModuleType):\n        return app\n    elif isinstance(app, basestring):\n        if app.strip().endswith('.models'):\n            return get_app(app[:-len('.models')])\n        elif '.' in app:\n            return get_app('.'.join(app.split('.')[1:]))  # django.db.models only looks at the module name in the INSTALLED_APPS list!         \n    try:\n        if verbosity > 1:\n            print 'Attempting django.db.models.get_app(%r)' % app\n        return djmodels.get_app(app)\n    except ImproperlyConfigured:\n        if verbosity > 0:\n            print 'WARNING: unable to find app = %r' % app\n    if verbosity > 2:\n        print 'Trying a fuzzy match on app = %r' % app\n    app_names = [app_class.__package__ for app_class in djmodels.get_apps() if app_class and app_class.__package__]\n    fuzzy_app_name = fuzzy.extractOne(str(app), app_names)[0]\n    if verbosity > 0:\n        print 'WARNING: Best fuzzy match for app name %r is %s' % (app, fuzzy_app_name)\n    return djmodels.get_app(fuzzy_app_name.split('.')[-1])"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_model(model=DEFAULT_MODEL, app=None, fuzziness=False):\n    if isinstance(model, djmodels.base.ModelBase):\n        return model\n    elif isinstance(model, (djmodels.Manager, djmodels.query.QuerySet)):\n        return model.model\n    if not app or (isinstance(model, basestring) and '.' in model):\n        try:\n            app, model = model.split('.')\n        except:\n            tokens = model.split('.')\n            model = tokens[-1]\n            app = '.'.join(tokens[:-1])\n    # print 'getting model=%r from app=%r' % (model, app)\n    try:\n        # FIXME: this will turn app into a list of strings if app=None is passed in!!!\n        app = get_app(app)\n    except:\n        pass\n        # FIXME: This seems futile! model is still just a string!\n        # try:\n        #     app = get_app(model.app_label)\n        # except:\n        #     app = get_app(model._meta.app_label)\n    try:\n        model_object = djmodels.get_model(app.__package__.split('.')[-1], model)\n        if model_object:\n            return model_object\n    except:\n        pass\n    try: \n        model_object = djmodels.get_model(app, model)\n        if model_object:\n            return model_object\n    except:\n        pass\n    if not fuzziness and not model_object:\n        return model_object\n    app = get_app(app)\n    if not app:\n        return None\n    model_names = [mc.__name__ for mc in djmodels.get_models(app)]\n    if app and model and model_names:\n        model_name, similarity_score = fuzzy.extractOne(str(model), model_names)\n        if similarity_score / 100. + float(fuzziness) >= 1.0:\n            return djmodels.get_model(app.__package__.split('.')[-1], model_name)", "response": "Get a Django model class for the indicated model name and app name."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_queryset(qs=None, app=DEFAULT_APP, db_alias=None):\n    # app = get_app(app);\n    # print 'get_model' + repr(model) + ' app ' + repr(app)\n    if isinstance(qs, (djmodels.Manager, djmodels.query.QuerySet)):\n        qs = qs.all()\n    else:\n        qs = get_model(qs, app=app).objects.all()\n    if db_alias:\n        return qs.using(db_alias)\n    else:\n        return qs", "response": "Get a queryset of all the users who have permission on it."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a field object based on a dot - delimited app. model. field name", "response": "def get_field(field):\n    \"\"\"Return a field object based on a dot-delimited app.model.field name\"\"\"\n    if isinstance(field, djmodels.fields.Field):\n        return field\n    elif isinstance(field, basestring):\n        field = field.split('.')\n        if len(field) == 3:\n            model = get_model(app=field[0], model=field[1])\n        elif len(field) == 2:\n            model = get_model(app=DEFAULT_APP, model=field[0])\n        else:\n            return None\n            raise NotImplementedError(\"Unknown default model name. Don't know where to look for field %s\" % '.'.join(field)) \n        field = model._meta.get_field(field[-1])\n    return field"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_primary_key(model):\n    model = get_model(model)\n    return (field.name for field in model._meta.fields if field.primary_key).next()", "response": "Get the name of the field in a model that has primary_key = True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating a queryset from a dictionary of objects.", "response": "def queryset_from_filter_dict(filter_dict=None, model=None, app=None):\n    \"\"\"TODO: add fuzzy app, model and field (filter key) matching\"\"\"\n    model = model or DEFAULT_MODEL\n    app = app or DEFAULT_APP\n    model = get_model(model, app)\n    \n    if filter_dict:\n        return model.objects.filter(**filter_dict)\n    return model.objects"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a list of Querysets from a list of model numbers starting with a title prefix.", "response": "def querysets_from_title_prefix(title_prefix=None, model=DEFAULT_MODEL, app=DEFAULT_APP):\n    \"\"\"Return a list of Querysets from a list of model numbers\"\"\"\n\n    if title_prefix is None:\n        title_prefix = [None]\n\n    filter_dicts = []\n    model_list = []\n    if isinstance(title_prefix, basestring):\n        title_prefix = title_prefix.split(',')\n    elif not isinstance(title_prefix, dict):\n        title_prefix = title_prefix\n    if isinstance(title_prefix, (list, tuple)):\n        for i, title_prefix in enumerate(title_prefix):\n            if isinstance(title_prefix, basestring):\n                if title_prefix.lower().endswith('sales'):\n                    title_prefix = title_prefix[:-5].strip('_')\n                    title_prefix += [title_prefix]\n                    model_list += ['WikiItem']\n                else:\n                    model_list += [DEFAULT_MODEL]\n            filter_dicts += [{'model__startswith': title_prefix}]\n    elif isinstance(title_prefix, dict):\n        filter_dicts = [title_prefix]\n    elif isinstance(title_prefix, (list, tuple)):\n        filter_dicts = util.listify(title_prefix)\n    \n    model = get_model(model, app)\n\n    querysets = []\n    for filter_dict, model in zip(filter_dicts, model_list):\n        filter_dict = filter_dict or {}\n        querysets += [model.objects.filter(**filter_dict)]"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncounts the number of records for each discrete value of a field and return a dict of two lists the field values and the counts.", "response": "def count_in_category(x='call_type', filter_dict=None, model=DEFAULT_MODEL, app=DEFAULT_APP, sort=True, limit=1000):\n    \"\"\"\n    Count the number of records for each discrete (categorical) value of a field and return a dict of two lists, the field values and the counts.\n\n    >>> x, y = count_in_category(x='call_type', filter_dict={'model__startswith': 'LC60'}, limit=5, sort=1)\n    >>> len(x) == len(y) == 5\n    True\n    >>> y[1] >= y[0]\n    True\n    \"\"\"\n    sort = sort_prefix(sort)\n    model = get_model(model, app)\n    filter_dict = filter_dict or {}\n\n    x = fuzzy.extractOne(str(x), model._meta.get_all_field_names())[0]    \n\n    objects = model.objects.filter(**filter_dict)\n    objects = objects.values(x)\n    objects = objects.annotate(y=djmodels.Count(x))\n    if sort is not None:\n        objects = objects.order_by(sort + 'y')\n    objects = objects.all()\n    if limit:\n        objects = objects[:int(limit)]\n    objects = normalize_choices(util.sod_transposed(objects), field_name=x, app=app, human_readable=True)\n    if not objects:\n        return None\n    objects = consolidated_counts(objects, field_name=x, count_name='y')\n    if sort is not None:\n        objects = sorted_dict_of_lists(objects, field_names=['y', x], reverse=bool(sort))\n    return objects[x], objects['y']"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncounting the number of records for each discrete value of a field and return a dict of two lists the field values and the counts.", "response": "def count_in_date(x='date_time', filter_dict=None, model=DEFAULT_MODEL, app=DEFAULT_APP, sort=True, limit=100000):\n    \"\"\"\n    Count the number of records for each discrete (categorical) value of a field and return a dict of two lists, the field values and the counts.\n\n    >>> from django.db import transaction\n    >>> transaction.rollback()\n    >>> x, y = count_in_date(x='date', filter_dict={'model__icontains': 'LC5'}, limit=5, sort=1)\n    >>> len(x) == len(y) == 5\n    True\n    >>> y[1] >= y[0]\n    True\n    \"\"\"\n    sort = sort_prefix(sort)\n    model = get_model(model, app)\n    filter_dict = filter_dict or {}\n\n    x = fuzzy.extractOne(str(x), model._meta.get_all_field_names())[0]    \n\n    objects = model.objects.filter(**filter_dict)\n    objects = objects.extra({'date_bin_for_counting': 'date(%s)' % x})\n    objects = objects.values('date_bin_for_counting')\n    objects = objects.annotate(count_of_records_per_date_bin=djmodels.Count('pk'))\n    \n    # FIXME: this duplicates the dict of lists sort below\n    if sort is not None:\n        objects = objects.order_by(sort + 'date_bin_for_counting')\n    objects = objects.all()\n    if limit:\n        objects = objects[:int(limit)]\n    objects = util.sod_transposed(objects)\n    if sort is not None:\n        objects = sorted_dict_of_lists(objects, field_names=['count_of_records_per_date_bin', 'date_bin_for_counting'], reverse=bool(sort))\n    #logger.info(x)\n    return objects['date_bin_for_counting'], objects['count_of_records_per_date_bin']"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a dict of two lists the field values and the counts for each discrete value of a field.", "response": "def sum_in_date(x='date', y='net_sales', filter_dict=None, model='WikiItem', app=DEFAULT_APP, sort=True, limit=100000):\n    \"\"\"\n    Count the number of records for each discrete (categorical) value of a field and return a dict of two lists, the field values and the counts.\n\n    FIXME: Tests need models with a date field:\n    Examples:\n      >> x, y = sum_in_date(y='net_sales', filter_dict={'model__startswith': 'LC60'}, model='Permission', limit=5, sort=1)\n      >> len(x) == len(y) == 5\n      True\n      >> y[1] >= y[0]\n      True\n    \"\"\"\n    sort = sort_prefix(sort)\n    model = get_model(model, app)\n    filter_dict = filter_dict or {}\n    objects = model.objects.filter(**filter_dict)\n    # only the x values are now in the queryset (datetime information)\n    objects = objects.values(x)\n    objects = objects.annotate(y=djmodels.Sum(y))\n\n    if sort is not None:\n        # FIXME: this duplicates the dict of lists sort below\n        objects = objects.order_by(sort + 'y')\n    objects = objects.all()\n    if limit:\n        objects = objects[:int(limit)]\n    objects = util.sod_transposed(objects)\n    if sort is not None:\n        objects = sorted_dict_of_lists(objects, field_names=['y', x], reverse=bool(sort=='-'))\n    if not x in objects or not 'y' in objects:\n        return [], []\n    else:\n        return objects[x], objects['y']"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef find_field_names(fields, model=DEFAULT_MODEL, app=DEFAULT_APP, score_cutoff=50, pad_with_none=False):\n    fields = util.listify(fields)\n    model = get_model(model, app)\n    available_field_names = model._meta.get_all_field_names()\n    matched_fields = []\n    for field_name in fields:\n        match = fuzzy.extractOne(str(field_name), available_field_names)\n        if match and match[1] is not None and match[1] >= score_cutoff:\n            matched_fields += [match[0]]\n        elif pad_with_none:\n            matched_fields += [None]\n    return matched_fields", "response": "Use fuzzy string matching to find similar model field names without consulting a synonyms list"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef model_from_path(model_path, fuzziness=False):\n    app_name = '.'.join(model_path.split('.')[:-1])\n    model_name = model_path.split('.')[-1]\n\n    if not app_name:\n        return None\n\n    module = importlib.import_module(app_name)\n    try:\n        model = getattr(module, model_name)\n    except AttributeError:\n        try:\n            model = getattr(getattr(module, 'models'), model_name)\n        except AttributeError:\n            model = get_model(model_name, app_name, fuzziness=fuzziness)\n\n    return model", "response": "Find the Django Model - based class for a given model path like project. app. model"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nuses a dictionary of synonyms and fuzzy string matching to find a similarly named field.", "response": "def find_synonymous_field(field, model=DEFAULT_MODEL, app=DEFAULT_APP, score_cutoff=50, root_preference=1.02):\n    \"\"\"Use a dictionary of synonyms and fuzzy string matching to find a similarly named field\n\n    Returns:\n      A single model field name (string)\n\n    Examples:\n\n      >>> find_synonymous_field('date', model='WikiItem')\n      'end_date_time'\n      >>> find_synonymous_field('date', model='WikiItem')\n      'date_time'\n      >>> find_synonymous_field('time', model='WikiItem')\n      'date_time'\n\n    \"\"\"\n    fields = util.listify(field) + list(synonyms(field))\n    model = get_model(model, app)\n    available_field_names = model._meta.get_all_field_names()\n    best_match, best_ratio = None, None\n    for i, field_name in enumerate(fields):\n        match = fuzzy.extractOne(str(field_name), available_field_names)\n        # print match\n        if match and match[1] >= score_cutoff:\n            if not best_match or match[1] > (root_preference * best_ratio):\n                best_match, best_ratio = match\n    return best_match"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef find_model(model_name, apps=settings.INSTALLED_APPS, fuzziness=0):\n    # if it looks like a file system path rather than django project.app.model path the return it as a string\n    if '/' in model_name:\n        return model_name\n    if not apps and isinstance(model_name, basestring) and '.' in model_name:\n        apps = [model_name.split('.')[0]]\n    apps = util.listify(apps or settings.INSTALLED_APPS)\n    for app in apps:\n        # print 'getting %r, from app %r' % (model_name, app)\n        model = get_model(model=model_name, app=app, fuzziness=fuzziness)\n        if model:\n            return model\n    return None", "response": "Find model_name among indicated Django apps and return a Model class."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef find_field_name(field, model=DEFAULT_MODEL, app=DEFAULT_APP, fuzziness=.5):\n    return find_field_names(field, model, app, score_cutoff=int((1-fuzziness)*100), pad_with_none=True)[0]", "response": "Find the field name for a given field."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nlag the y values by the specified number of samples. FIXME: sort has no effect when sequences provided in x, y instead of field names >>> lagged_in_date(x=[.1,.2,.3,.4], y=[1,2,3,4], limit=4, lag=1) ([0.1, 0.2, 0.3, 0.4], [0, 1, 2, 3]) >>> lagged_in_date(x=[.1,.2,.3,.4], y=[1,2,3,4], lag=1, truncate=True) ([0.1, 0.2, 0.3, 0.4], [0, 1, 2, 3])", "response": "def lagged_in_date(x=None, y=None, filter_dict=None, model='WikiItem', app=DEFAULT_APP, sort=True, limit=30000, lag=1, pad=0, truncate=True):\n    \"\"\"\n    Lag the y values by the specified number of samples.\n\n    FIXME: sort has no effect when sequences provided in x, y instead of field names\n\n    >>> lagged_in_date(x=[.1,.2,.3,.4], y=[1,2,3,4], limit=4, lag=1)\n    ([0.1, 0.2, 0.3, 0.4], [0, 1, 2, 3])\n    >>> lagged_in_date(x=[.1,.2,.3,.4], y=[1,2,3,4], lag=1, truncate=True)\n    ([0.1, 0.2, 0.3, 0.4], [0, 1, 2, 3])\n    \"\"\"\n    lag = int(lag or 0)\n    #print 'X, Y:', x, y\n    if isinstance(x, basestring) and isinstance(y, basestring):\n        x, y = sequence_from_filter_spec([find_synonymous_field(x), find_synonymous_field(y)], filter_dict, model=model, \n                                         app=app, sort=sort, limit=limit)\n    if y and len(y) == len(x):\n        if sort:\n            xy = sorted(zip(x,y), reverse=bool(int(sort) < 0))\n            x, y = [col1 for col1, col2 in xy], [col2 for col1, col2 in xy]\n        return x, lagged_seq(y, lag=lag, pad=pad, truncate=truncate)\n    if x and len(x) and 2 == len(x) <= len(x[0]):\n        #print 'X:', x\n        x, y = x[0], lagged_seq(x[1], lag=lag, pad=pad, truncate=truncate)\n        if truncate:\n            print truncate, lag\n            if lag >= 0:\n                x = x[lag:]\n            else:\n                x = x[:lag]\n        #print x, y\n    return x, y"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconstructs a Django model instance from values provided in a python dict or Mapping containing a list of fields.", "response": "def django_object_from_row(row, model, field_names=None, ignore_fields=('id', 'pk'), ignore_related=True, strip=True, ignore_errors=True, verbosity=0):\n    \"\"\"Construct Django model instance from values provided in a python dict or Mapping\n\n    Args:\n      row (list or dict): Data (values of any type) to be assigned to fields in the Django object.\n        If `row` is a list, then the column names (header row) can be provided in `field_names`.\n        If `row` is a list and no field_names are provided, then `field_names` will be taken from the \n        Django model class field names, in the order they appear within the class definition.\n      model (django.db.models.Model): The model class to be constructed with data from `row`\n      field_names (list or tuple of str): The field names to place the row values in. \n        Defaults to the keys of the dict of `row` (if `row` is a `dict`) or the names of the fields\n        in the Django model being constructed.\n      ignore_fields (list or tuple of str): The field names to ignore if place the row values in. \n\n    Returns:\n      Model instance: Django model instance constructed with values from `row` in fields\n        from `field_names` or `model`'s fields\n    \"\"\"\n    field_dict, errors = field_dict_from_row(row, model, field_names=field_names, ignore_fields=ignore_fields, strip=strip,\n                                             ignore_errors=ignore_errors, ignore_related=ignore_related, verbosity=verbosity)\n    if verbosity >= 3:\n        print 'field_dict = %r' % field_dict\n    try:\n        obj = model(**field_dict)\n        return obj, errors\n    except:\n        print_exc()\n        raise ValueError('Unable to coerce the dict = %r into a %r object' % (field_dict, model))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconstructs a dict from field names to values from a row of data.", "response": "def field_dict_from_row(row, model,\n                        field_names=None, ignore_fields=('id', 'pk'), \n                        strip=True, \n                        blank_none=True, \n                        ignore_related=True, \n                        ignore_values=(None,), \n                        ignore_errors=True, \n                        verbosity=0):\n    \"\"\"Construct a Mapping (dict) from field names to values from a row of data\n\n    Args:\n      row (list or dict): Data (values) to be assigned to field_names in the dict.\n        If `row` is a list, then the column names (header row) can be provided in `field_names`.\n        If `row` is a list and no field_names are provided, then `field_names` will be taken from the \n        Django model class field names, in the order they appear within the class definition.\n      model (django.db.models.Model): The model class to be constructed with data from `row`\n      field_names (list or tuple of str): The field names to place the row values in. \n        Defaults to the keys of the dict of `row` (if `row` is a `dict`) or the names of the fields\n        in the Django model being constructed.\n      ignore_fields (list or tuple of str): The field names to ignore if place the row values in. \n\n    Returns:\n      dict: Mapping from fields to values compatible with a Django model constructor kwargs, `model(**kwargs)`\n    \"\"\"\n    errors = collections.Counter()\n    if not field_names:\n        field_classes = [f for f in model._meta._fields() if (not ignore_fields or (f.name not in ignore_fields))]\n        field_names = [f.name for f in field_classes]\n    else:\n        field_classes = [f for f in model._meta._fields() if (f.name in field_names and (not ignore_fields or (f.name not in ignore_fields)))]\n    field_dict = {}\n    if isinstance(row, collections.Mapping):\n        row = [row.get(field_name, None) for field_name in field_names]\n    # if most of the destination field names exist in the source object then \n    elif sum(hasattr(row, field_name) for field_name in field_names) / (len(field_names) / 2. + 1):\n        row = [getattr(row, field_name, None) for field_name in field_names]\n    for field_name, field_class, value in zip(field_names, field_classes, row):\n        clean_value = None\n        if verbosity >= 3:\n            print field_name, field_class, value\n        if isinstance(field_class, related.RelatedField):\n            if not ignore_related:\n                try:\n                    clean_value = field_class.related.parent_model.objects.get(value)\n                except:\n                    try:\n                        clean_value = field_class.related.parent_model.objects.get_by_natural_key(value)\n                    except:\n                        errors += collections.Counter(['num_unlinked_fks'])\n                        if verbosity > 1:\n                            print 'Unable to connect related field %r using value %r' % (field_class, value)\n        # FIXME: lots of redundancy and potential for error here and below\n        if isinstance(value, basestring) and not value:\n            if verbosity >= 3:\n                print 'String field %r setting value %r to None' % (field_class, value)\n            value = None\n            if blank_none and (\n                not isinstance(field_class, related.RelatedField) or field_class.blank or not field_class.null):\n                try:\n                    if isinstance(field_class.to_python(''), basestring):\n                        value = ''\n                    else:\n                        value = None\n                except:\n                    value = None\n            else:\n                value = None\n        if not clean_value:\n            try:\n                # get a clean python value from a string, etc\n                clean_value = field_class.to_python(value)\n            except:  # ValidationError\n                try:\n                    clean_value = str(field_class.to_python(util.clean_wiki_datetime(value)))\n                except:\n                    try:\n                        clean_value = field_class.to_python(util.make_float(value))\n                    except:\n                        try:\n                            clean_value = field_class.to_python(value)  # FIXME: this has already been tried!\n                        except:\n                            if verbosity > 0:\n                                print\n                                print \"The row below has a value (%r) that can't be coerced by %r:\" % (value, field_class.to_python)\n                                print row\n                                print_exc()\n                            clean_value = None\n                            errors += collections.Counter(['num_uncoercible'])\n                            if not ignore_errors:\n                                raise\n        if isinstance(clean_value, basestring):\n            if strip:\n                clean_value = clean_value.strip()\n            # don't forget to decode the utf8 before doing a max_length truncation!\n            clean_value = clean_utf8(clean_value, verbosity=verbosity).decode('utf8')\n            max_length = getattr(field_class, 'max_length')\n            if max_length:\n                try:\n                    assert(len(clean_value) <= field_class.max_length)\n                except:\n                    if verbosity > 0:\n                        print\n                        print \"The row below has a string (%r) that is too long (> %d):\" % (clean_value, max_length)\n                        print row\n                        print_exc()\n                        errors += collections.Counter(['num_truncated'])\n                    clean_value = clean_value[:max_length]\n                    if not ignore_errors:\n                        raise  \n        if not ignore_values or clean_value not in ignore_values:\n            field_dict[field_name] = clean_value\n    return field_dict, errors"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncounting the number of lines in a file.", "response": "def count_lines(fname, mode='rU'):\n    '''Count the number of lines in a file\n\n    Only faster way would be to utilize multiple processor cores to perform parallel reads.\n    http://stackoverflow.com/q/845058/623735\n    '''\n\n    with open(fname, mode) as f:\n        for i, l in enumerate(f):\n            pass\n    return i + 1"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndeleting all data records in a model.", "response": "def clear_model(model, dry_run=True, verbosity=1):\n    '''Delete all data records in a model, obeying `clear`, `dry_run`, and `verbosity` flags\n    \n    If a clear was requested (dry_run or otherwise), return the number of records deleted (# before minus # after)\n    '''\n    N_existing = model.objects.count()\n    if dry_run:\n        print \"DRY_RUN: NOT deleting %d records in %r.\" % (model.objects.all().count(), model)\n    if N_existing:\n        ans = 'y'\n        if verbosity and not dry_run:\n            ans = raw_input('Are you sure you want to delete all %d existing database records in %r? (y/n) ' % (N_existing, model))\n        if ans.lower().startswith('y') and not dry_run:\n            model.objects.all().delete()\n        return N_existing - model.objects.count()\n    return 0"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef load_csv_to_model(path, model, field_names=None, delimiter=None, batch_len=10000, \n                      dialect=None, num_header_rows=1, mode='rUb',\n                      strip=True, clear=False, dry_run=True, ignore_errors=True, verbosity=2):\n    '''Bulk create database records from batches of rows in a csv file.'''\n\n    reader_kwargs = {}\n    errors = collections.Counter()\n    if delimiter or dialect:\n        reader_kwargs['dialect'] = dialect or 'excel'\n        if delimiter:\n            reader_kwargs['delimiter'] = delimiter\n    reader_kwargs['delimiter'] = str(reader_kwargs['delimiter'][0])\n    delimiter = reader_kwargs['delimiter']\n\n    path = path or './'\n    if not delimiter:\n        for d in ',', '|', '\\t', ';':\n            try:\n                return load_csv_to_model(path=path, model=model, field_names=field_names, delimiter=d, batch_len=batch_len,\n                                         dialect=dialect, num_header_rows=num_header_rows,\n                                         strip=strip, clear=clear, dry_run=dry_run, ignore_errors=ignore_errors, verbosity=verbosity)\n            except:\n                pass\n        return None\n\n    if clear:\n        clear_model(model, dry_run=dry_run, verbosity=verbosity)\n\n    M = 0\n    with open(path, mode) as f:\n        reader = csv.reader(f, **reader_kwargs)\n        header_rows = []\n        i = 0\n        while len(header_rows) < num_header_rows and i < 100:\n            row = reader.next()\n            i += 1\n            if not row or any(compiled_regex.match(row[0]) for compiled_regex in header_rows_to_ignore):\n                if verbosity > 1:\n                    print 'IGNORED: %r' % row\n            else:\n                header_rows += [row]\n        if verbosity > 2:\n            print 'HEADER: %r' % header_rows\n        if verbosity > 0:\n            N = count_lines(path, mode) - i + 10  # + 10 fudge factor in case multiple newlines in a single csv row\n            widgets = [pb.Counter(), '/%d lines: ' % N, pb.Percentage(), ' ', pb.RotatingMarker(), ' ', pb.Bar(),' ', pb.ETA()]\n            i, pbar = 0, pb.ProgressBar(widgets=widgets, maxval=N).start()\n        if verbosity > 3:\n            print 'Generating all the batches before iterating may take a while...'\n        for batch_num, batch_of_rows in enumerate(util.generate_batches(reader, batch_len)):\n            if verbosity > 2:\n                print \n                print i\n            batch_of_objects = []\n            for j, row in enumerate(batch_of_rows):\n                if verbosity > 3:\n                    print j, row\n                if not row or all(not el for el in row):\n                    if verbosity > 2:\n                        print 'IGNORED: %r' % row\n                    continue\n                if verbosity or not ignore_errors:\n                    M = M or len(row)\n                    if len(row) != M:\n                        print 'ERROR importing row #%d in batch_num=%d which is row #%d overall. The row had %d columns, but previous rows had %d.' % (j + 1, batch_num + 1, i + j + 1, len(row), M)\n                        print 'Erroneously parsed row:'\n                        print repr(row)\n                        \n                        if not ignore_errors:\n                            raise ValueError('ERROR importing row #%d which had %d columns, but previous rows had %d.' % (i + j + 1, len(row), M))\n                try:\n                    obj, row_errors = django_object_from_row(row, model=model, field_names=field_names, strip=strip, verbosity=verbosity)\n                    batch_of_objects += [obj]\n                    errors += row_errors\n                except:\n                    if verbosity > 0:\n                        print 'Error importing row #%d' % (i + j + 1)\n                        print_exc()\n                    if not ignore_errors:\n                        raise\n                if verbosity > 0:\n                    try:\n                        pbar.update(i + j)\n                    except:\n                        print_exc()\n                        if not ignore_errors:\n                            raise\n            i += len(batch_of_rows)\n            if not dry_run:\n                model.objects.bulk_create(batch_of_objects)\n            elif verbosity > 0:\n                print \"DRY_RUN: NOT bulk creating batch of %d records in %r\" % (len(batch_of_objects), model)\n        if verbosity > 0:\n            pbar.finish()\n    return i", "response": "Bulk create database records from batches of rows in a csv file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nwalking the file tree and query the file. stat object s to compute their total size in bytes.", "response": "def path_size(path, total=False, ext='', level=None, verbosity=0):\n    \"\"\"Walk the file tree and query the file.stat object(s) to compute their total (or individual) size in bytes\n\n    Returns:\n      dict: {relative_path: file_size_in_bytes, ...}\n\n    Examples:\n      >>> all(d >= 0 for d in path_size(__file__).values())\n      True\n      >>> sum(path_size(os.path.dirname(__file__)).values()) == path_size(os.path.dirname(__file__), total=True)\n      True\n      >>> path_size(__file__, total=True) > 10000\n      True\n      >>> len(path_size('.')) >= 2\n      True\n    \"\"\"\n    dict_of_path_sizes = dict((d['path'], d['size']) for d in util.find_files(path, ext=ext, level=level, verbosity=0))\n    if total:\n        return reduce(lambda tot, size: tot + size, dict_of_path_sizes.values(), 0)\n    return dict_of_path_sizes"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nwrite a QuerySet or ValuesListQuerySet to a CSV file.", "response": "def write_queryset_to_csv(qs, filename):\n    \"\"\"Write a QuerySet or ValuesListQuerySet to a CSV file\n\n    based on djangosnippets by zbyte64 and http://palewi.re\n\n    Arguments:\n        qs (QuerySet or ValuesListQuerySet): The records your want to write to a text file (UTF-8)\n        filename (str): full path and file name to write to\n    \"\"\"\n    model = qs.model\n    with open(filename, 'w') as fp:\n        writer = csv.writer(fp)\n        try:\n            headers = list(qs._fields)\n        except:\n            headers = [field.name for field in model._meta.fields]\n        writer.writerow(headers)\n\n        for obj in qs:\n            row = []\n            for colnum, field in enumerate(headers):\n                try:\n                    value = getattr(obj, field, obj[colnum])\n                except:\n                    value = ''\n                if callable(value):\n                    value = value()\n                if isinstance(value, basestring):\n                    value = value.encode(\"utf-8\")\n                else:\n                    value = str(value).encode(\"utf-8\")\n                row += [value]\n            writer.writerow(row)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nbulking create database records from all csv files found within a directory.", "response": "def load_all_csvs_to_model(path, model, field_names=None, delimiter=None, batch_len=10000,\n                           dialect=None, num_header_rows=1, mode='rUb',\n                           strip=True, clear=False, dry_run=True, ignore_errors=True,\n                           sort_files=True, recursive=False, ext='',\n                           min_mod_date=None, max_mod_date=None,\n                           verbosity=2):\n    \"\"\"Bulk create database records from all csv files found within a directory.\"\"\"\n    if min_mod_date and isinstance(min_mod_date, basestring):\n        min_mod_date = parse_date(min_mod_date)\n    if isinstance(min_mod_date, datetime.date):\n        min_mod_date = datetime.datetime.combine(min_mod_date, datetime.datetime.min.time())\n\n    if max_mod_date and isinstance(max_mod_date, basestring):\n        max_mod_date = parse_date(max_mod_date)\n    if isinstance(max_mod_date, datetime.date):\n        max_mod_date = datetime.datetime.combine(max_mod_date, datetime.datetime.min.time())\n\n    path = path or './'\n    batch_len = batch_len or 1000\n    if verbosity > 0:\n        if dry_run:\n            print 'DRY_RUN: actions will not modify the database.'\n        else:\n            print 'THIS IS NOT A DRY RUN, THESE ACTIONS WILL MODIFY THE DATABASE!!!!!!!!!'\n\n    if clear:\n        clear_model(model, dry_run=dry_run, verbosity=verbosity)\n\n    file_dicts = util.find_files(path, ext=ext, level=None if recursive else 0, verbosity=verbosity)\n    file_bytes = reduce(lambda a,b: a+b['size'], file_dicts, 0)\n\n    if sort_files:\n        file_dicts = sorted(file_dicts, key=itemgetter('path'))\n    if verbosity > 1:\n        print file_dicts\n    if verbosity > 0:\n        widgets = [pb.Counter(), '/%d bytes for all files: ' % file_bytes, pb.Percentage(), ' ', pb.RotatingMarker(), ' ', pb.Bar(),' ', pb.ETA()]\n        i, pbar = 0, pb.ProgressBar(widgets=widgets, maxval=file_bytes)\n        pbar.start()\n    N = 0\n    file_bytes_done = 0\n    for meta in file_dicts:\n        if (min_mod_date and meta['modified'] < min_mod_date) or (max_mod_date and meta['modified'] > max_mod_date):\n            if verbosity > 1:\n                print(\"Skipping {0} because it's mdate is not between {1} and {2}\".format(meta['path'], min_mod_date, max_mod_date))\n            continue\n        if verbosity > 0:\n            print\n            print 'Loading \"%s\"...' % meta['path']\n        N += load_csv_to_model(path=meta['path'], model=model, field_names=field_names, delimiter=delimiter, batch_len=batch_len, \n                               dialect=dialect, num_header_rows=num_header_rows, mode=mode,\n                               strip=strip, clear=False, dry_run=dry_run, \n                               ignore_errors=ignore_errors, verbosity=verbosity)\n        if verbosity > 0:\n            file_bytes_done += meta['size']\n            pbar.update(file_bytes_done)\n    if verbosity > 0:\n        pbar.finish()\n    return N"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nthin wrapper for pandas.io.excel.read_excel() that accepts a file path and sheet index/name Arguments: path (str): file or folder to retrieve CSV files and `pandas.DataFrame`s from ext (str): file name extension (to filter files by) date_parser (function): if the MultiIndex can be interpretted as a datetime, this parser will be used Returns: dict of DataFrame: { file_path: flattened_data_frame }", "response": "def dataframe_from_excel(path, sheetname=0, header=0, skiprows=None):  # , parse_dates=False):\n    \"\"\"Thin wrapper for pandas.io.excel.read_excel() that accepts a file path and sheet index/name\n\n    Arguments:\n      path (str): file or folder to retrieve CSV files and `pandas.DataFrame`s from\n      ext (str): file name extension (to filter files by)\n      date_parser (function): if the MultiIndex can be interpretted as a datetime, this parser will be used\n\n    Returns:\n      dict of DataFrame: { file_path: flattened_data_frame }\n    \"\"\"\n    sheetname = sheetname or 0\n    if isinstance(sheetname, (basestring, float)):\n        try:\n            sheetname = int(sheetname)\n        except (TypeError, ValueError, OverflowError):\n            sheetname = str(sheetname)\n    wb = xlrd.open_workbook(path)\n    # if isinstance(sheetname, int):\n    #     sheet = wb.sheet_by_index(sheetname)\n    # else:\n    #     sheet = wb.sheet_by_name(sheetname)\n    # assert(not parse_dates, \"`parse_dates` argument and function not yet implemented!\")\n    # table = [sheet.row_values(i) for i in range(sheet.nrows)]\n    return pd.io.excel.read_excel(wb, sheetname=sheetname, header=header, skiprows=skiprows, engine='xlrd')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncoerce a datetime or string into a datetime. date object", "response": "def make_date(dt, date_parser=parse_date):\n    \"\"\"Coerce a datetime or string into datetime.date object\n\n    Arguments:\n      dt (str or datetime.datetime or atetime.time or numpy.Timestamp): time or date \n        to be coerced into a `datetime.time` object\n\n    Returns:\n      datetime.time: Time of day portion of a `datetime` string or object\n\n    >>> make_date('')\n    datetime.date(1970, 1, 1)\n    >>> make_date(None)\n    datetime.date(1970, 1, 1)\n    >>> make_date(\"11:59 PM\") == datetime.date.today()\n    True\n    >>> make_date(datetime.datetime(1999, 12, 31, 23, 59, 59))\n    datetime.date(1999, 12, 31)\n    \"\"\"\n    if not dt:\n        return datetime.date(1970, 1, 1)\n    if isinstance(dt, basestring):\n        dt = date_parser(dt)\n    try:\n        dt = dt.timetuple()[:3]\n    except:\n        dt = tuple(dt)[:3]\n    return datetime.date(*dt)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconverts a datetime string or datetime. time into a datetime. time object.", "response": "def make_time(dt, date_parser=parse_date):\n    \"\"\"Ignore date information in a datetime string or object\n\n    Arguments:\n      dt (str or datetime.datetime or atetime.time or numpy.Timestamp): time or date \n        to be coerced into a `datetime.time` object\n\n    Returns:\n      datetime.time: Time of day portion of a `datetime` string or object\n\n    >>> make_time(None)\n    datetime.time(0, 0)\n    >>> make_time(\"11:59 PM\")\n    datetime.time(23, 59)\n    >>> make_time(datetime.datetime(1999, 12, 31, 23, 59, 59))\n    datetime.time(23, 59, 59)\n    \"\"\"\n    if not dt:\n        return datetime.time(0, 0)\n    if isinstance(dt, basestring):\n        try:\n            dt = date_parser(dt)\n        except:\n            print 'Unable to parse {0}'.format(repr(dt))\n            print_exc()\n            return datetime.time(0, 0)\n    try:\n        dt = dt.timetuple()[3:6]\n    except:\n        dt = tuple(dt)[3:6]\n    return datetime.time(*dt)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef flatten_dataframe(df, date_parser=parse_date, verbosity=0):\n\n    # extract rows with nonull, nonnan index values\n    df = df[pd.notnull(df.index)]\n\n    # Make sure columns and row labels are all times and dates respectively\n    # Ignores/clears any timezone information \n    if all(isinstance(i, int) for i in df.index):\n        for label in df.columns:\n            if 'date' in str(label).lower():\n                df.index = [make_date(d) for d in df[label]]\n                del df[label]\n                break\n    if not all(isinstance(i, pd.Timestamp) for i in df.index):\n        date_index = []\n        for i in df.index:\n            try:\n                date_index += [make_date(str(i))]\n            except:\n                date_index += [i]\n        df.index = date_index\n    df.columns = [make_time(str(c)) if (c and str(c) and str(c)[0] in '0123456789') else str(c) for c in df.columns]\n    if verbosity > 2:\n        print 'Columns: {0}'.format(df.columns)\n\n    # flatten it\n    df = df.transpose().unstack()\n\n    df = df.drop(df.index[[(isinstance(d[1], (basestring, NoneType))) for d in df.index]])\n\n    # df.index is now a compound key (tuple) of the column labels (df.columns) and the row labels (df.index) \n    # so lets combine them to be datetime values (pandas.Timestamp)\n    dt = None\n    t0 = df.index[0][1]\n    t1 = df.index[1][1]\n    try:\n        dt_stepsize = datetime.timedelta(hours=t1.hour - t0.hour, minutes=t1.minute - t0.minute, seconds=t1.second - t0.second)\n    except:\n        dt_stepsize = datetime.timedelta(hours=0, minutes=15)\n    parse_date_exception = False\n    index = []\n    for i, d in enumerate(df.index.values):\n        dt = i\n        if verbosity > 2:\n            print d\n        # # TODO: assert(not parser_date_exception)\n        # if isinstance(d[0], basestring):\n        #     d[0] = d[0]\n        try:\n            datetimeargs = list(d[0].timetuple()[:3]) + [d[1].hour, d[1].minute, d[1].second, d[1].microsecond]\n            dt = datetime.datetime(*datetimeargs)\n            if verbosity > 2:\n                print '{0} -> {1}'.format(d, dt)\n        except TypeError:\n            if verbosity > 1:\n                print_exc()\n                # print 'file with error: {0}\\ndate-time tuple that caused the problem: {1}'.format(file_properties, d)\n            if isinstance(dt, datetime.datetime):\n                if dt:\n                    dt += dt_stepsize\n                else:\n                    dt = i\n                    parse_date_exception = True\n                    # dt = str(d[0]) + ' ' + str(d[1])\n                    # parse_date_exception = True\n            else:\n                dt = i\n                parse_date_exception = True\n        except:\n            if verbosity > 0:\n                print_exc()\n                # print 'file with error: {0}\\ndate-time tuple that caused the problem: {1}'.format(file_properties, d)\n            dt = i\n        index += [dt]\n\n    if index and not parse_date_exception:\n        df.index = index\n    else:\n        df.index = list(pd.Timestamp(d) for d in index)\n    return df", "response": "Flattens a pandas DataFrame into a single FataFrame with columns and rows with non - null values."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nloading all Excel files in the given path and write. flat. csv files to a single DataFrame", "response": "def flatten_excel(path='.', ext='xlsx', sheetname=0, skiprows=None, header=0, date_parser=parse_date, verbosity=0, output_ext=None):\n    \"\"\"Load all Excel files in the given path, write .flat.csv files, return `DataFrame` dict\n\n    Arguments:\n      path (str): file or folder to retrieve CSV files and `pandas.DataFrame`s from\n      ext (str): file name extension (to filter files by)\n      date_parser (function): if the MultiIndex can be interpretted as a datetime, this parser will be used\n\n    Returns:\n      dict of DataFrame: { file_path: flattened_data_frame }\n    \"\"\"\n\n    date_parser = date_parser or (lambda x: x)\n    dotted_ext, dotted_output_ext = None, None\n    if ext != None and output_ext != None:\n        dotted_ext = ('' if ext.startswith('.') else '.') + ext\n        dotted_output_ext = ('' if output_ext.startswith('.') else '.') + output_ext\n    table = {}\n    for file_properties in util.find_files(path, ext=ext or '', verbosity=verbosity):\n        file_path = file_properties['path']\n        if output_ext and (dotted_output_ext + '.') in file_path:\n            continue\n        df = dataframe_from_excel(file_path, sheetname=sheetname, header=header, skiprows=skiprows)\n        df = flatten_dataframe(df, verbosity=verbosity)\n        if dotted_ext != None and dotted_output_ext != None:\n            df.to_csv(file_path[:-len(dotted_ext)] + dotted_output_ext + dotted_ext)\n    return table"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nhash values of DB table records for a given model.", "response": "def hash_model_values(model, clear=True, hash_field='values_hash', hash_fun=hash, ignore_pk=True, ignore_fields=[]):\n    \"\"\"Hash values of DB table records to facilitate tracking changes to the DB table\n\n    Intended for comparing records in one table to those in another (with potentially differing id/pk values)\n    For example, changes to a table in a read-only MS SQL database can be quickly identified\n    and mirrored to a writeable PostGRE DB where these hash values are stored along side the data.\n    \"\"\"\n    qs = getattr(model, 'objects', model)\n    model = qs.model\n    if ignore_pk:\n        ignore_fields += [model._meta.pk.name]\n    if not hasattr(model, hash_field):\n        warnings.warn(\"%r doesn't have a field named %s in which to store a hash value. Skipping.\" % (model, hash_field))\n        return\n    for obj in qs:\n        # ignore primary key (id field) when hashing values\n        h = hash_fun(tuple([getattr(obj, k) for k in obj._meta.get_all_field_names() if k not in ignore_fields]))\n        tracking_obj, created = ChangeLog.get_or_create(app=model._meta.app_label, model=model._meta.object_name, primary_key=obj.pk)\n        tracking_obj.update(hash_value=h)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nimporting a sequence of dicts into a model", "response": "def import_items(item_seq, dest_model,  batch_len=500, \n                 clear=False, dry_run=True, \n                 start_batch=0, end_batch=None, \n                 overwrite=True,\n                 run_update=False, ignore_related=True,\n                 ignore_errors=False, verbosity=1):\n    \"\"\"Import a sequence (queryset.values(), generator, tuple, list) of dicts into the given model\n\n    \"\"\"\n    if isinstance(dest_model, (djmodels.query.QuerySet, djmodels.Manager)):\n        dest_qs = dest_model.all()\n        dest_model = get_model(dest_qs)\n    else:\n        dest_qs = dest_model.objects.all()\n\n    stats = collections.Counter()\n    try:\n        try:\n            src_qs = item_seq.objects.all()\n        except AttributeError:\n            src_qs = item_seq.all()\n        N = src_qs.count()\n        item_seq = src_qs.values()\n    except AttributeError as e:\n        print_exc()\n        if not ignore_errors:\n            raise e\n        N = len(item_seq)\n\n    if not N:\n        if verbosity > 0:\n            print 'No records found in %r' % src_qs\n        return N\n\n    # make sure there's a valid last batch number so the verbose messages will make sense\n    end_batch = end_batch or int(N / float(batch_len))\n\n    if clear and not dry_run:\n        if N < dest_qs.count():\n            if verbosity > 0:\n                print \"WARNING: There are %d %r records in the destinsation queryset which is more than the %d records in the source data. So no records will be deleted/cleared in the destination!\" % (dest_qs.count(), dest_model, N)\n\n        if verbosity > 0:\n            print \"WARNING: Deleting %d records from %r to make room for %d new records !!!!!!!\" % (dest_qs.count(), dest_model, N)\n        num_deleted = delete_in_batches(dest_qs)\n        if verbosity > 0:\n            print \"Finished deleting %d records in %r.\" % (num_deleted, dest_model)\n\n    if verbosity > 0:\n        print('Loading %r records from sequence provided...' % N)\n        widgets = [pb.Counter(), '/%d rows: ' % N or 1, pb.Percentage(), ' ', pb.RotatingMarker(), ' ', pb.Bar(),' ', pb.ETA()]\n        pbar = pb.ProgressBar(widgets=widgets, maxval=N)\n\n    for batch_num, dict_batch in enumerate(util.generate_slices(item_seq, batch_len=batch_len, start_batch=start_batch)):\n        if start_batch + batch_num > end_batch:\n            if verbosity > 1:\n                print('Stopping before batch {0} because it is not between {1} and {2}'.format(start_batch + batch_num, start_batch, end_batch))\n            break\n        if verbosity > 2:\n            print '-------- dict batch ------'\n            # print(repr(dict_batch))\n            print(repr((start_batch + batch_num, len(dict_batch), batch_len)))\n        item_batch = []\n        total_len_batches = 0\n\n        # convert an iterable of Django ORM record dictionaries into a list of Django ORM objects\n        for d in dict_batch:\n            if verbosity > 2:\n                print '-------- dict of source obj ------'\n                print(repr(d))\n            obj = dest_model()\n            try:\n                # if the model has an import_item method then use it\n                obj.import_item(d, verbosity=verbosity)\n            except:\n                if verbosity > 2:\n                    print '------ Creating a new %r instance --------' % dest_model\n                obj, row_errors = django_object_from_row(d, dest_model, ignore_related=ignore_related, verbosity=verbosity)\n                if verbosity > 2:\n                    print 'new obj.__dict__: %r' % obj.__dict__\n            if run_update:\n                try:\n                    if verbosity > 2:\n                        print '------ Updating FKs with overwrite=%r --------' % overwrite\n                    obj._update(save=False, overwrite=overwrite)\n                except:\n                    if verbosity > 0:\n                        print_exc()\n                        print 'ERROR: Unable to update record: %r' % obj\n                    pass\n            item_batch += [obj]\n            stats += row_errors\n\n        del(dict_batch)\n        if verbosity and verbosity < 2:\n            if batch_num:\n                pbar.update(batch_num * batch_len + len(item_batch))\n            else:\n                # don't start the progress bar until at least one batch has been loaded\n                pbar.start()\n        elif verbosity > 1:\n            print('Writing {0} items (of type {1}) from batch {2}. Will stop at batch {3} which is record {4} ...'.format(\n                len(item_batch), dest_model, start_batch + batch_num, end_batch, min(batch_len * (start_batch + end_batch), N),\n                ))\n        total_len_batches += len(item_batch)\n\n        # use bulk_create to make fast DB insertions. Note: any custom save() or _update() methods will *NOT* be run\n        if not dry_run:\n            try:\n                dest_model.objects.bulk_create(item_batch)\n            except UnicodeDecodeError as err:\n                from django.db import transaction\n                transaction.rollback()\n                if verbosity > 0:\n                    print '%s' % err\n                    print 'Now attempting to save objects one at a time instead of as a batch...'\n                for obj in item_batch:\n                    try:\n                        obj.save()\n                        stats += collections.Counter(['batch_UnicodeDecodeError'])\n                    except:\n                        from django.db import transaction\n                        transaction.rollback()\n                        stats += collections.Counter(['save_UnicodeDecodeError'])\n                        print str(obj)\n                        print repr(obj.__dict__)\n                if not ignore_errors:\n                    print_exc()\n                    raise\n            except Exception as err:\n                from django.db import transaction\n                transaction.rollback()\n                if verbosity > 0:\n                    print '%s' % err\n                    print 'Now attempting to save objects one at a time instead of as a batch...'\n                for obj in item_batch:\n                    try:\n                        obj.save()\n                        stats += collections.Counter(['batch_Error'])\n                    except:\n                        from django.db import transaction\n                        transaction.rollback()\n                        print str(obj)\n                        print repr(obj.__dict__)\n                        print_exc()\n                        stats += collections.Counter(['save_Error'])\n                if not ignore_errors:\n                    print_exc()\n                    raise\n        if batch_num < end_batch:\n            if len(item_batch) != batch_len:\n                stats += collections.Counter(['batch_len={0}'.format(len(item_batch))])\n            print('Retrieving {0} {1} items for the next batch, batch number {2}...'.format(\n                  batch_len, src_qs.model, batch_num + 1))\n        del(item_batch)\n\n    if verbosity > 0:\n        pbar.finish()\n    return stats"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef update_items(item_seq,  batch_len=500, dry_run=True, start_batch=0, end_batch=None, ignore_errors=False, verbosity=1):\n    stats = collections.Counter()\n    try:\n        try:\n            src_qs = item_seq.objects.all()\n        except AttributeError:\n            src_qs = item_seq.all()\n        N = src_qs.count()\n    except AttributeError:\n        item_seq = iter(src_qs)\n        print_exc()\n        N = item_seq.count()\n\n    if not N:\n        if verbosity > 0:\n            print 'No records found in %r' % src_qs\n        return N\n\n    # make sure there's a valid last batch number so the verbose messages will make sense\n    end_batch = end_batch or int(N / float(batch_len))\n\n    if verbosity > 0:\n        print('Updating from a source queryset/model/sequence with %r records...' % N)\n        widgets = [pb.Counter(), '/%d rows: ' % N or 1, pb.Percentage(), ' ', pb.RotatingMarker(), ' ', pb.Bar(),' ', pb.ETA()]\n        pbar = pb.ProgressBar(widgets=widgets, maxval=N).start()\n\n    for batch_num, obj_batch in enumerate(util.generate_batches(item_seq, batch_len=batch_len, start_batch=start_batch)):\n        if start_batch + batch_num > end_batch:\n            if verbosity > 1:\n                print('Stopping before batch {0} because it is not between {1} and {2}'.format(batch_num, start_batch, end_batch))\n            break\n        for obj in obj_batch:\n            if verbosity > 2:\n                print(repr(obj))\n            try:\n                if hasattr(obj, '_update'):\n                    obj._update(save=False, overwrite=False)\n            except:\n                if verbosity > 0:\n                    print_exc()\n                    print 'ERROR: Unable to update record: %r' % obj\n                pass\n        if verbosity and verbosity < 2:\n            pbar.update(batch_num * batch_len + len(obj_batch))\n        elif verbosity > 1:\n            print('Writing {0} items (of type {1}) from batch {2}. Will stop at batch {3} which is records {4} - {5} ...'.format(\n                len(obj_batch), src_qs.model, batch_num, end_batch, min(batch_len * (start_batch + end_batch), N)\n                ))\n        if not dry_run:\n            try:\n                bulk_update(obj_batch, ignore_errors=ignore_errors, delete_first=True, verbosity=verbosity)\n            except Exception as err:\n                from django.db import transaction\n                transaction.rollback()\n                print '%s' % err\n                print 'Attempting to save objects one at a time instead of as a batch...'\n                for obj in obj_batch:\n                    try:\n                        obj.save()\n                        stats += collections.Counter(['batch_Error'])\n                    except:\n                        from django.db import transaction\n                        transaction.rollback()\n                        print str(obj)\n                        print repr(obj.__dict__)\n                        print_exc()\n                        stats += collections.Counter(['save_Error'])\n                if not ignore_errors:\n                    print_exc()\n                    raise\n        if batch_num < end_batch:\n            if len(obj_batch) != batch_len:\n                stats += collections.Counter(['batch_len={0}'.format(len(obj_batch))])\n            print('Retrieving {0} {1} items for the next batch, batch number {2}...'.format(\n                batch_len, src_qs.model, batch_num + 1))\n\n    if verbosity > 0:\n        pbar.finish()\n    return stats", "response": "Update items in a sequence of dicts."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ngive a queryset generator tuple list of dicts import them into a single model and return a new model object.", "response": "def import_queryset_batches(qs, dest_qs,  batch_len=500, clear=None, dry_run=True, verbosity=1):\n    \"\"\"Given a sequence (queryset, generator, tuple, list) of dicts import them into the given model\n\n    FIXME: How is this differenct from import_items above?\n\n    clear = model or queryset to be deleted/cleared \n        False: do not clear/delete anything\n        None: clear/delete the dest_qs\n        True: clear all records in dest_qs.model (e.g. dest_qs.model.objects.all().delete())\n\n    Typical Usage:\n    \n    >> from src_app.models import SrcModel\n    >> from dest_app.models import DestModel\n    >> filter_dict={\"model__startswith\": \"LC\", \"recvdat__gt\":'2013-03-31'}\n    >> dest = DestModel.objects.filter(**filter_dict)\n    >> src = SrcModel.objects.filter(**filter_dict)\n    >> src.count(), dest.count()\n    >> from pug.dj import db\n    >> db.import_queryset_batches(src, dest, batch_len=1000, clear=dest, dry_run=False, verbosity=2)\n    \"\"\"\n    qs = get_queryset(qs)\n    dest_qs = get_queryset(dest_qs)\n    dest_model = get_model(dest_qs)\n\n    N = qs.count()\n\n    if verbosity > 0:\n        print('Loading %r records from the queryset provided...' % N)\n    qs = qs.values()\n\n    if clear is None:\n        clear = dest_qs\n    if clear and not dry_run:\n        if clear == True:\n            clear = dest_model.objects.all()\n        if verbosity > 0:\n            print \"WARNING: Deleting %d records from %r !!!!!!!\" % (clear.count(), clear.model)\n        clear.delete()\n    if verbosity > 0:\n        widgets = [pb.Counter(), '/%d rows: ' % N, pb.Percentage(), ' ', pb.RotatingMarker(), ' ', pb.Bar(),' ', pb.ETA()]\n        pbar = pb.ProgressBar(widgets=widgets, maxval=N).start()\n    for batch_num, dict_batch in enumerate(generate_queryset_batches(qs, batch_len)):\n        if verbosity > 2:\n            print(repr(dict_batch))\n        item_batch = []\n        for d in dict_batch:\n            if verbosity > 2:\n                print(repr(d))\n            m = dest_model()\n            try:\n                m.import_item(d, verbosity=verbosity)\n            except:\n                m = django_object_from_row(d, dest_model)\n            item_batch += [m]\n        if verbosity and verbosity < 2:\n            pbar.update(batch_num * batch_len + len(dict_batch))\n        elif verbosity > 1:\n            print(('DRYRUN:  ' if dry_run else '') + 'Writing {0} items in batch {1} out of {2} batches to the {3} model...'.format(\n                len(item_batch), batch_num, int(N / float(batch_len)), dest_model))\n        if not dry_run:\n            dest_model.objects.bulk_create(item_batch)\n    if verbosity > 0:\n        pbar.finish()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngiving a queryset generator tuple list of dicts import them into a model", "response": "def import_queryset(qs, dest_model,  clear=False, dry_run=True, verbosity=1):\n    \"\"\"Given a sequence (queryset, generator, tuple, list) of dicts import them into the given model\"\"\"\n\n    # # FIXME: use this info to connect relationships, ignoring missing targets (unlike manage.py loaddata)\n    # fields = dest_model._meta.get_fields_with_model()\n    # fk_fields = [(f.name, f.related.parent_model, f.related.field) for (f, m) in fields if isinstance(f, ForeignKey)] \n\n    try:\n        qs = qs.objects\n    except:\n        pass\n    N = qs.count()\n\n    if verbosity > 0:\n        print('Loading %r records from the queryset provided...' % N)\n\n    if clear and not dry_run:\n        if verbosity > 0:\n            print \"WARNING: Deleting %d records from %r !!!!!!!\" % (dest_model.objects.count(), dest_model)\n        dest_model.objects.all().delete()\n    if verbosity > 0:\n        widgets = [pb.Counter(), '/%d rows: ' % N, pb.Percentage(), ' ', pb.RotatingMarker(), ' ', pb.Bar(),' ', pb.ETA()]\n        pbar = pb.ProgressBar(widgets=widgets, maxval=N).start()\n    i = 0\n    dest_model._meta.get_all\n    for d in qs.values():\n        if verbosity > 2:\n            print(repr(d))\n        m = django_object_from_row(d, dest_model)\n        if verbosity > 0:\n            pbar.update(i)\n            i += 1\n            if verbosity > 2:\n                print m\n        if not dry_run:\n            m.save()\n    if verbosity > 0:\n        pbar.finish()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreading json file and create the appropriate records using the provided database model.", "response": "def import_json(path, model, batch_len=100, db_alias='default', start_batch=0, end_batch=None, ignore_errors=False, verbosity=2):\n    \"\"\"Read json file (not in django fixture format) and create the appropriate records using the provided database model.\"\"\"\n\n    # TODO: use a generator to save memory for large json files/databases\n    if verbosity > 0:\n        print('Reading json records (dictionaries) from {0}.'.format(repr(path)))\n    item_list = json.load(open(path, 'r'))\n    if verbosity > 0:\n        print('Finished reading {0} items from {1}.'.format(len(item_list), repr(path)))\n    import_items(item_list, model=model, batch_len=batch_len, db_alias=db_alias, start_batch=start_batch, end_batch=end_batch, ignore_errors=ignore_errors, verbosity=verbosity)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nbulk create objects in provided list of model instances delete database rows for the original pks in the object list.", "response": "def bulk_update(object_list, ignore_errors=False, delete_first=False, verbosity=0):\n    '''Bulk_create objects in provided list of model instances, delete database rows for the original pks in the object list.\n\n    Returns any delta in the number of rows in the database table that resulted from the update.\n    If nonzero, an error has likely occurred and database integrity is suspect.\n\n    # delete_first = True is required if your model has unique constraints that would be violated by creating duplicate records\n\n    # FIXME: check for unique constraints and raise exception if any exist (won't work because new objects may violate!)\n    '''\n    if not object_list:\n        return 0\n    model = object_list[0].__class__\n    N_before = model.objects.count()\n    pks_to_delete = set()\n    for i, obj in enumerate(object_list):\n        pks_to_delete.add(obj.pk)\n        if delete_first:\n            object_list[i] = deepcopy(obj)\n        object_list[i].pk = None\n    if verbosity > 1:\n        print 'Creating %d %r objects.' % (len(object_list), model)\n        print 'BEFORE: %d' % model.objects.count()\n    if not delete_first:\n        model.objects.bulk_create(object_list)\n    if verbosity > 0:\n        print 'Deleting %d objects with pks: %r ........' % (len(pks_to_delete), pks_to_delete)\n    objs_to_delete = model.objects.filter(pk__in=pks_to_delete)\n    num_to_delete = objs_to_delete.count()\n    if num_to_delete != len(pks_to_delete):\n        msg = 'Attempt to delete redundant pks (len %d)! Queryset has count %d. Query was `filter(pk__in=%r). Queryset = %r' % (\n            len(pks_to_delete), num_to_delete, pks_to_delete, objs_to_delete)\n        if ignore_errors:\n            if verbosity > 0:\n                print msg\n        else:\n            raise RuntimeError(msg)\n    if verbosity > 1:\n        print 'Queryset to delete has %d objects' % objs_to_delete.count()\n    objs_to_delete.delete()\n    if delete_first:\n        model.objects.bulk_create(object_list)\n    if verbosity > 1:\n        print 'AFTER: %d' % model.objects.count()\n    N_after = model.objects.count()\n    if ignore_errors:\n        if verbosity > 1:\n            print 'AFTER: %d' % N_after\n    else:\n        if N_after != N_before:\n            print 'Number of records in %r changed by %d during bulk_create of %r.\\n ' % (model, N_after - N_before, object_list)\n            msg = 'Records before and after bulk_create are not equal!!! Before=%d, After=%d' % (N_before, N_after)\n            raise RuntimeError(msg)\n    return N_before - N_after"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngenerating a list of batches of the given length.", "response": "def generate_queryset_batches(queryset, batch_len=1000, verbosity=1):\n    \"\"\"Filter a queryset by the pk in such a way that no batch is larger than the requested batch_len\n\n    SEE ALSO: pug.nlp.util.generate_slices\n\n    >>> from miner.models import TestModel\n    >>> sum(len(list(batch)) for batch in generate_queryset_batches(TestModel, batch_len=7)) == TestModel.objects.count()\n    True\n    \"\"\"\n    if batch_len == 1:\n        for obj in queryset:\n            yield obj\n\n    N = queryset.count()\n\n    if not N:\n        raise StopIteration(\"Queryset is empty!\")\n\n\n    if N == 1:\n        for obj in queryset:\n            yield obj\n\n    if verbosity > 0:\n        widgets = [pb.Counter(), '/%d rows: ' % N, pb.Percentage(), ' ', pb.RotatingMarker(), ' ', pb.Bar(),' ', pb.ETA()]\n        i, pbar = 0, pb.ProgressBar(widgets=widgets, maxval=N).start()\n    pk_queryset = queryset.filter(pk__isnull=False).values_list('pk', flat=True).order_by('pk')\n\n    N_nonnull = pk_queryset.count()\n    N_batches = int(N_nonnull/float(batch_len)) + 1\n    \n    if verbosity > 1:\n        print 'Splitting %d primary_key values (%d nonnull) from %r into %d querysets of size %d or smaller. First loading pks into RAM...' % (N, N_nonnull, queryset.model, N_batches, batch_len)\n    nonnull_pk_list = tuple(pk_queryset)\n    pk_list = []\n\n    if verbosity > 1:\n        print 'Extracting the %d dividing (fencepost) primary keys for use in splitting the querysets with filter queries...' % (N_batches + 1)\n    for j in range(N_batches - 1):\n        pk_list += [(nonnull_pk_list[j*batch_len], nonnull_pk_list[(j+1)*batch_len - 1])]\n    last_batch_len = N_nonnull - (N_batches-1) * batch_len\n    pk_list += [(nonnull_pk_list[(N_batches-1) * batch_len], nonnull_pk_list[N-1])]\n\n    if verbosity > 1:\n        del(nonnull_pk_list)\n        print 'Yielding the %d batches according to the %d dividing (fencepost) primary keys...' % (N_batches, len(pk_list))\n    for j in range(N_batches):\n        if verbosity > 0:\n            pbar.update(i)\n        if j < N_batches - 1:\n            i += batch_len\n        else:\n            i += last_batch_len\n        # inclusive inequality ensures that even if PKs are repeated they will all be included in the queryset returned\n        yield queryset.filter(pk__gte=pk_list[j][0], pk__lte=pk_list[j][1])\n    if verbosity > 0:\n        pbar.finish()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nimprove query speed for a Django ORM queryset filter or exclude kwargs dict aurant", "response": "def optimize_filter_dict(filter_dict, trgm=True):\n    \"\"\"Improve query speed for a Django queryset `filter` or `exclude` kwargs dict\n\n    WARNING: Wtthout `trgm`, this only improves the speed of exclude filters by 0.4%\n\n    Arguments:\n      filter_dict (dict): kwargs for  Django ORM queryset `filter` and `exclude` queries\n      trgm (bool): whether to assume the Django ORM trigram (djorm-trgm) extension is available \n\n    Examples:\n      >>> # This is nothing different than what Django already does:\n      >>> optimize_filter_dict({'name__in': ['Smith', 'Jones', 'Smith']}) == {'name__in': set(('Smith', 'Jones'))}  \n      True\n      >>> # This is an optimjization that Django doesn't do yet, probably because it actually slows `filter` queries down by 0.4%!:\n      >>> # However, it does speed up an `objects.exclude` query by about 1%:\n      >>> optimize_filter_dict({'name__in': ['Smith']}) == {'name': 'Smith'}\n      True\n      >>> # This is the only optimization that actually does significant good, but it requires `djorm-trgm`\n      >>> optimize_filter_dict({'name__contains': 'ith'}) == {'name__similar': 'ith', 'name__contains': 'ith'}\n      True\n    \"\"\"\n    optimized = {}\n    for k, v in filter_dict.iteritems():\n        if k.endswith('__in'):\n            v = set(v)\n            if len(v) == 1:\n                optimized[k[:-4]] = tuple(v)[0]\n            else:\n                optimized[k] = v\n        else:\n            optimized[k] = v\n    # This is the only optimization that actuall does some good\n    if trgm:\n        optimized_copy = dict(optimized)\n        for k, v in optimized_copy.iteritems():\n            if k.endswith('__contains'):\n                optimized[k[:-10] + '__similar'] = v\n            elif k.endswith('__icontains'):\n                optimized[k[:-11] + '__similar'] = v\n    return optimized"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncleans Django ORM filter kwargs dict queries like filter({ <field > __in = member_list", "response": "def clean_filter_dict(filter_dict, strip=False):\n    '''Clear/del Django ORM filter kwargs dict queries like `filter({\"<field>__in\": member_list` where `member_list` is empty\n\n    Brute force processing of user-entered lists of query parameters can often produce null `__in` filters\n      which will return no results if not \"cleaned\" by deleting these dict entries.\n    Similarly `exclude` dicts sometimes contain emtpy or all `None` lists, but these often produce the intended result\n      so they usually do not need to be cleaned.\n\n    Examples:\n      >>> clean_filter_dict({'acctno__in': None, 'serialno': None})\n      {'serialno': None}\n      >>> clean_filter_dict({'acctno__in': [], 'name': None, 'serialno__in': [u'', None, ''], 'serialno__in': ['', None, 0]})\n      {'serialno__in': ['', None, 0]}\n      >>> exclude_dict = {'acctno__in': [], 'serialno__in': [u'', None, r\" \"]}\n      >>> clean_filter_dict(exclude_dict)\n      {'serialno__in': [u'', None, ' ']}\n      >>> print exclude_dict\n      {'serialno__in': [u'', None, ' ']}\n      >>> clean_filter_dict(exclude_dict, strip=True)\n      {}\n      >>> print exclude_dict\n      {}\n      >>> clean_filter_dict({'num__in': [0], 'bool__in': [False], 'str__in': [' \\t \\r \\n ']}, strip=True) ==  {'bool__in': [False], 'num__in': [0]}\n      True\n    '''\n    if not strip:\n        strip = lambda s: s\n    elif not callable(strip):\n        strip = lambda s: str(s).strip()\n    keys_to_del = set()\n    for k, values_list in filter_dict.iteritems():\n        if k.endswith('__in'):\n            if not values_list or not any((v != None and strip(v) != '') for v in values_list):\n                keys_to_del.add(k)\n    for k in keys_to_del:\n        del filter_dict[k]\n    print 'cleaned_filter_dict:'\n    print filter_dict\n    return filter_dict"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef dump_json(model, batch_len=200000, use_natural_keys=True, verbosity=1):\n    model = get_model(model)\n\n    N = model.objects.count()\n\n    if verbosity > 0:\n        widgets = [pb.Counter(), '/%d rows: ' % (N,), pb.Percentage(), ' ', pb.RotatingMarker(), ' ', pb.Bar(),' ', pb.ETA()]\n        i, pbar = 0, pb.ProgressBar(widgets=widgets, maxval=N).start()\n\n    JSONSerializer = serializers.get_serializer(\"json\")\n    jser = JSONSerializer()\n\n    if verbosity > 0:\n        pbar.update(0)\n    for i, partial_qs in enumerate(util.generate_slices(model.objects.all(), batch_len=batch_len)):\n        with open(model._meta.app_label.lower() + '--' + model._meta.object_name.lower() + '--%04d.json' % i, 'w') as fpout:\n            if verbosity > 0:\n                pbar.update(i*batch_len)\n            jser.serialize(partial_qs, indent=1, stream=fpout, use_natural_keys=use_natural_keys)\n    if verbosity > 0:\n        pbar.finish()", "response": "Dump database records to. json Django fixture file"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef filter_exclude_dicts(filter_dict=None, exclude_dict=None, name='acctno', values=[], swap=False):\n    filter_dict = filter_dict or {}\n    exclude_dict = exclude_dict or {}\n\n    if not name.endswith('__in'):\n        name += '__in'\n\n    filter_dict[name], exclude_dict[name] = [], []\n    for v in values:\n        # \"NOT \" means switch from include (filter) to exclude for that one account number\n        if v.startswith('NOT '):\n            exclude_dict[name] += [v[4:]]\n        else:\n            filter_dict[name] += [v]\n    if swap:\n        return exclude_dict, filter_dict\n    return filter_dict, exclude_dict", "response": "Generates kwargs dicts for Django ORM Queryset filter and exclude from a list of values."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef process_kwargs(self, kwargs, prefix='default_', delete=True):\n        processed = []\n        for k in kwargs:\n            if hasattr(self, prefix + k):\n                processed += [k]\n                setattr(self, prefix + k, kwargs[k])\n        for k in processed:\n            del(kwargs[k])\n        return kwargs", "response": "process kwargs and set self attributes based on kwargs that are not already set"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate column - wise Columns object from a row - wise list of lists.", "response": "def from_row_wise_lists(self, lol, header_rows=0, transpose=False, names=None):\n        \"\"\"Create column-wise Columns object from a row-wise table (list of lists).\n\n        Useful for reading a CSV file.\"\"\"\n        #print '-'*10\n        #super(Columns, self).__init__()\n        self.clear()\n        #print(list(self))\n        self.len_column = None\n\n        if header_rows:\n            raise NotImplementedError(\"I don't know how to handle header rows yet\")\n            return self\n\n        if not lol or not hasattr(lol, '__iter__') or not iter(lol).next():\n            return self.from_row_wise_lists([lol], header_rows, transpose, names)\n\n\n        # if the input is just a 1-D sequence then load it all into one column or one row\n        if not hasattr(iter(lol).next(), '__iter__'):\n            return self.from_row_wise_lists(tuple([tuple([row]) for row in lol]), header_rows, transpose, names)\n        #print '='*20\n        #print list(self)\n        for i, d in enumerate(lol):\n            if not i:\n                for j, value in enumerate(d):\n                    self[j] = [value]\n                    #print '-',j\n            else:\n                for j, value in enumerate(d):\n                    self[j] += [value]\n                    #print '-',j\n        #print list(self)\n        try:\n            self.len_column = min(len(self[i]) for i in self)\n        except:\n            self.len_column = None\n        #print self\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef from_column_wise_lists(self, lol, header_rows=0, transpose=False, names=None):\n        #super(Columns, self).__init__()\n        self.clear()\n        self.len_column = None\n\n        if transpose:\n            return self.from_row_wise_lists(lol, header_rows, transpose=False, names=None)\n        names = names or [j for j, column in enumerate(lol)]\n        for i, col in enumerate(lol):\n            self[names[i]] = [value for value in col]\n        self.len_column = min(len(self[i]) for i in self)\n        return self", "response": "Create column - wise Columns object from a list of lists."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef as_column_wise_lists(self, transpose=False):\n        # make this a generator of generators?\n        if transpose:\n            ans = self.from_row_wise_lists(self.as_column_wise_lists(transpose=False))\n            return ans\n        #print self\n        return self.values()", "response": "Generator over the columns of lists"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef pierson(self, ddof=0):\n        C = self.cov(ddof=ddof)\n        rho = []\n        N = len(C)\n        for i in range(N):\n            rho += [[1.] * N]\n        for i in range(N):\n            for j in range(i + 1, N):\n                rho[i][j] = C[i][j] / (C[i][i] * C[j][j] or 1.) ** 0.5\n                rho[j][i] = rho[i][j]\n        return rho", "response": "Matrix of pierson linear correlation coefficients for each pair of columns."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef file_list(self, page_size: int, fields: str, order_by: str, query: str) -> dict:\n        service = self.__get_service()\n        results = service.files().list(\n            pageSize=page_size,\n            fields=fields,\n            orderBy=order_by,\n            q=query\n        ).execute()\n        return results.get('files', [])", "response": "Get file list from Google Drive."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating folder into Google Drive", "response": "def create_folder(self, dir_name: str, parent_dir_id: str) -> str:\n        \"\"\"\n        Create folder into Google Drive\n        :param dir_name:\n        :param parent_dir_name:\n        :return:\n        \"\"\"\n        service = self.__get_service()\n        file_metadata = {\n            'name': dir_name,\n            'mimeType': 'application/vnd.google-apps.folder',\n            'parents': [parent_dir_id],\n        }\n        folder = service.files() \\\n            .create(body=file_metadata, fields='id') \\\n            .execute()\n        return folder.get('id')"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef file_download(self, item_id: str, item_name: str, dir_name: str) -> bool:\n        service = self.__get_service()\n        request = service.files().get_media(fileId=item_id)\n        self.__create_download_dir(dir_name)\n        fh = io.FileIO(os.path.join(dir_name, item_name), mode='wb')\n        downloader = MediaIoBaseDownload(fh, request)\n        done = False\n        while done is False:\n            status, done = downloader.next_chunk()\n\n        return done", "response": "Download file from Google Drive"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nuploads file into Google Drive", "response": "def file_upload(self, folder_id: str, file_name: str, mine_type: str) -> bool:\n        \"\"\"\n        Upload file into Google Drive\n        :param folder_id:\n        :param file_name:\n        :param mine_type:\n        :return:\n        \"\"\"\n        service = self.__get_service()\n        media_body = MediaFileUpload(file_name, mimetype=mine_type, resumable=True)\n        body = {\n            'name': os.path.split(file_name)[-1],\n            'mimeType': \"text/csv\",\n            'parents': [folder_id],\n        }\n        return service.files().create(body=body, media_body=media_body).execute()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_new_articles(last_seen, assignment_slug=None, brief=False, *args, **kwargs):\n    if brief:\n        return Brief.objects.filter(pub_date__gte=last_seen).order_by('-id')\n\n    if assignment_slug:\n        return Article.published.filter(assignment__slug=assignment_slug, created__gte=last_seen)\n    return Article.published.filter(created__gte=last_seen)", "response": "Get a list of articles that have been published since the given date."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ngenerate random numbers from the current set of random values.", "response": "def random(self, n: Optional[int] = None) -> Union[List[float], float]:\n        \"\"\" Similar to :py:func:`randint` \"\"\"\n        return self._generate_randoms(self._request_randoms, max_n=self.config.MAX_NUMBER_OF_FLOATS,\n                                      n=n)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngenerating n numbers as a list or a single one.", "response": "def randint(self, a: int, b: int, n: Optional[int] = None) -> Union[List[int], int]:\n        \"\"\" Generate n numbers as a list or a single one if no n is given.\n\n        n is used to minimize the number of requests made and return type changes to be compatible\n        with :py:mod:`random`'s interface\n        \"\"\"\n        max_n = self.config.MAX_NUMBER_OF_INTEGERS\n        return self._generate_randoms(self._request_randints, max_n=max_n, a=a, b=b, n=n)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nchecking if the quota is exceeded.", "response": "def _check_quota(self):\n        \"\"\" If IP can't make requests, raise BitQuotaExceeded. Called before generating numbers. \"\"\"\n        self._request_remaining_quota_if_unset()\n        if self.quota_estimate < self.quota_limit:\n            raise BitQuotaExceeded(self.quota_estimate)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nwrapping response_from for timeseries calls, returns the resulting dict", "response": "def _construct_timeseries(self, timeseries, constraints={}):\n        \"\"\"\n        wraps response_from for timeseries calls, returns the resulting dict\n        \"\"\"\n        self.response_from(timeseries, constraints)\n        if self.response == None:\n            return None\n        return {'data':self.response['data'],\n                'period':self.response['period'],\n                'start time':datetime.datetime.fromtimestamp(self.response['start_time']),\n                'end time':datetime.datetime.fromtimestamp(self.response['end_time'])}"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nfetches and parses the response from the semetric API and returns the object as a dictionary.", "response": "def response_from(self, ext_endpoint=None, params = {}):\n        \"\"\"\n        fetches and parses data from the semetric API, returning whatever is\n        in the 'response' field in the top level dict on success (200)\n        if the endpoint returns a 204, returns None (no data available for id)\n        else throws a value error\n        self should have these attributes as needed:\n        @entity_type the entity type (eg. list, artist)\n        @entity_id the semetric UUID or resolvable equivelant for the entity to be retrieved\n        these can be passed on call:\n        @ext_endpoint (default: None) if an endpoint beyond the id is required, this is where it should go\n        @params and key value params *besides* the api token\n        on success self.response will have the contents of the response\n        a \n        \"\"\"\n        params['token'] = API_KEY\n        base_endpoint=\"{base_url}/{entity}/{entityID}\"\n        uri = base_endpoint.format(base_url=BASE_URL, entity=self.entity_type, entityID=self.entity_id)\n        if ext_endpoint:\n            if ext_endpoint[0] != '/':\n                ext_endpoint = '/' + ext_endpoint\n            uri += ext_endpoint\n        full_uri = uri + '?' + urlencode(params)\n        log.debug('fetching: {0}'.format(full_uri))\n        wrapped_resp = loads(urllib2.urlopen(full_uri).read(), encoding='utf-8')\n        #better error handling should go here\n        if not wrapped_resp['success']:\n            if wrapped_resp[\"error\"][\"code\"] == 204:\n                self.response = None\n                return\n            raise ValueError(\\\n                'Unable to fetch data for {0} entity with id {1}, ext_endpoint was {2}, params-{3}'.format(\\\n                    self.entity_type, self.entity_id, ext_endpoint, params)+\n                ' code was {0}, msg {1}'.format(wrapped_resp[\"error\"][\"code\"],wrapped_resp[\"error\"][\"msg\"]))\n        self.response = wrapped_resp[\"response\"]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef edit_channel_info(self, new_ch_name, ch_dct):\n        self.ch_name = new_ch_name\n        self.dct = ch_dct\n        if ch_dct['type'] == 'analog':\n            fmter = fmt.green\n        else:\n            fmter = fmt.blue\n        self.ch_name_label.setText(fmt.b(fmter(self.ch_name)))\n        self.generateToolTip()", "response": "Parent widget calls this whenever the user edits channel info."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef connections(request, edges):\n    edge_list, node_list = parse.graph_definition(edges)\n    data = {'nodes': json.dumps(node_list), 'edges': json.dumps(edge_list)}\n    return render_to_response('miner/connections.html', data)", "response": "Plot a force - directed graph based on the edges provided\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a list of statistics for the current user.", "response": "def stats(request, date_offset=0, fields=None, title_prefix=None, model='WikiItem'):\n    \"\"\"\n    In addition to chart data in data['chart'], send statistics data to view in data['stats']\n    \"\"\"\n    data = {}\n\n    modified_chart_data = data['chart']['chartdata']\n    if 'y2' in data['chart']['chartdata']:\n        matrix = db.Columns([modified_chart_data['y1'], modified_chart_data['y2']], ddof=0, tall=True)\n    else:\n        fields = ['date/time'] + fields\n        matrix = db.Columns([modified_chart_data['x'], modified_chart_data['y']], ddof=0, tall=True)\n    if fields and len(fields) > 1:\n        fields = fields[:2]\n    else:\n        fields = [\n            data['chart']['chartdata'].get('name1') or 'time',\n            data['chart']['chartdata'].get('name2') or data['chart']['chartdata'].get('name') or 'value',\n            ]\n    fields = util.pluralize_field_names(fields)\n    data.update({\n        'stats': {\n            'fields': fields,\n            'heading': 'Statistics',\n            'cov': zip(fields, matrix.cov()),\n            'R': zip(fields, matrix.rho),\n            },\n        })\n    data['chart']['chartdata'] = modified_chart_data\n    data['chart']['chart_title'] = 'Time Series'\n    return render_to_response('miner/stats.html', data)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nprocess a GET request to get the context dictionary for the current user.", "response": "def context_from_request(request, context=None, Form=GetLagForm, delim=',', verbosity=0, **kwargs):\n    \"\"\"Process GET query request to normalize query arguments (split lists, etc)\n\n    TODO: Generalize this for any list of API variables/strings and separators for lists\n\n    Returns context dict with these updated elements:\n    context['form']                a Form object populated with the normalized form field values from the GET query\n    context['form_is_valid']       True  or False\n    context['errors']              list of validation error messages to be displayed at top of form\n    context['plot']                normalized acronym for one of 4 histogram type: 'hist', 'pmf', 'cmf', or 'cfd'\n    contexxt['plot_name']          descriptive name for the plot type: 'Histogram', 'Probability Mass Function' ...\n    context['table']               'fast' or 'detailed'\n    context['limit']               int indicating the maximum number of rows (for speeding the query for a detailed table)\n    context['regex']               regular expression string to test whether inspection notes and comments match\n    context['columns']             columns to display in quicktable and csv\n    context['filter']              dict for use in a Django queryset filter:\n    {\n        'model_numbers': mn.split(',')  #    list of strings for ?mn=\n        'sales_groups': sg.split(',')  #     list of strings for ?sg=\n        'fiscal_years': sn.split(',')  #     list of strings for ?fy=\n        'reasons': sn.split(',')  #          list of strings for ?r=\n        'account_numbers': an.split(',')  #  list of strings for ?an=\n        'min_dates': sn.split(',')  #        list of strings for ?min_date=\n        'max_dates': sn.split(',')  #        list of strings for ?max_date=\n        'min_lag': sn.split(',')  #          list of strings for ?min_lag=\n        'max_lag': sn.split(',')  #          list of strings for ?max_lag=\n        'exclude': sn.split(',')  #          \"E\" or \"I\" (include or exclude account numbers)\n        'columns': columns.split(';')  #          list of fields for columns of CSV\n    }\n    \"\"\"\n    context = context or RequestContext(request)\n\n    context['errors'] = []\n    context['filter'] = {}\n\n    limit = request.GET.get('limit') or request.GET.get('num') or request.GET.get('num_rows') or request.GET.get('rows') or request.GET.get('records') or request.GET.get('count', 0)\n\n    context['plot'] = (request.GET.get('plot', '') or request.GET.get('plt', '') or request.GET.get('p', '') \n                        or request.GET.get('chart', '') or request.GET.get('chrt', '')\n                        ).strip().lower()\n    context['plot'] = util.HIST_NAME.get(context['plot'][-3:], context['plot'])\n    context['plot_name'] = util.HIST_CONFIG[context['plot']]['name'] if context['plot'] else ''\n\n\n    context['table'] = (request.GET.get('table', '') or request.GET.get('tbl', '') or request.GET.get('tble', '') \n                        or request.GET.get('tab', '') or request.GET.get('t', '')\n                        ).strip().lower()\n    if context['table'].startswith('f'):\n        context['table'] = 'fast'\n    if context['table'].startswith('a'):\n        context['table'] = 'aggregate'\n        context['aggregates'] = []\n        # context['plot'] = 'aggregate'\n    if context['table'].startswith('d'):\n        context['table'] = 'detailed'\n        limit = limit or 10*1000\n    context['limit'] = util.make_int(limit)\n\n    mn = request.GET.get('mn', \"\") or request.GET.get('model', \"\") or request.GET.get('models', \"\") or request.GET.get('model_number', \"\") or request.GET.get('model_numbers', \"\")\n    mn = [s.strip().upper() for s in mn.split(',')] or ['']\n    context['filter']['model_numbers'] = mn\n\n    sg = request.GET.get('sg', \"\") or request.GET.get('group', \"\") or request.GET.get('sales', \"\") or request.GET.get('sales_group', \"\") or request.GET.get('sale_group_number', \"\")\n    sg = [s.strip().upper() for s in sg.split(',')] or ['']\n    # need to implement filters on sales_group (where serial_numbers was, in explore_lags, and filter_sla_lags or lags_dict)\n    context['filter']['sales_groups'] = sg\n\n    fy = request.GET.get('fy', \"\") or request.GET.get('yr', \"\") or request.GET.get('year', \"\") or request.GET.get('years', \"\") or request.GET.get('fiscal_year', \"\") or request.GET.get('fiscal_years', \"\")\n    fiscal_years = [util.normalize_year(y) for y in fy.split(',')] or []\n    fiscal_years = [str(y) for y in fiscal_years if y]\n    context['filter']['fiscal_years'] = fiscal_years\n\n    rc = request.GET.get('r', \"\") or request.GET.get('rc', \"\") or request.GET.get('rcode', \"\") or request.GET.get('reason', \"\") or request.GET.get('reasons', \"\")\n    context['filter']['reasons'] = [s.strip().upper() for s in rc.split(',')] or ['']\n\n    an = request.GET.get('a', \"\") or request.GET.get('an', \"\") or request.GET.get('account', \"\") or request.GET.get('account_number', \"\") or request.GET.get('account_numbers', \"\")\n    context['filter']['account_numbers'] = [s.strip().upper() for s in an.split(',')] or []\n\n    exclude = request.GET.get('exclude', \"\") or request.GET.get('e', \"\") or request.GET.get('x', \"\") or request.GET.get('ex', \"\") or request.GET.get('excl', \"I\")\n    context['exclude'] = 'E' if exclude.upper().startswith('E') else ''\n\n    min_dates = request.GET.get('mind') or request.GET.get('min_date') or request.GET.get('min_dates') or \"\"\n    min_dates = [s.strip() for s in min_dates.split(',')] or ['']\n    context['filter']['min_dates'] = min_dates\n\n    max_dates = request.GET.get('maxd') or request.GET.get('max_date') or request.GET.get('max_dates') or \"\"\n    max_dates = [s.strip() for s in max_dates.split(',')] or ['']\n    context['filter']['max_dates'] = max_dates\n\n    context['regex'] = request.GET.get('re') or request.GET.get('regex') or request.GET.get('word') or request.GET.get('search') or request.GET.get('find') or \"\"\n\n    context['columns'] = request.GET.get('col') or request.GET.get('cols') or request.GET.get('column') or request.GET.get('columns') or \"\"\n    context['columns'] = [s.strip() for s in context['columns'].split(';')] or []\n\n    context['aggregate_ids'] = request.GET.get('agg') or request.GET.get('ids') or request.GET.get('aggids') or request.GET.get('aggregates') or request.GET.get('aggregate_ids') or '-1'\n    context['aggregate_ids'] = [int(s.strip()) for s in context['aggregate_ids'].split(',') if s and s.strip()] or [-1]\n\n    # whether the FK join queries should be short-circuited\n    if verbosity > 0:\n        print('aggregate_ids: ', context['aggregate_ids'])\n    context['quick'] = context.get('quick') or (context['table'].startswith('agg') and context['aggregate_ids'] and not (context['aggregate_ids'][-1] == -1) and not context['table'] == 'fast')\n    if verbosity > 0:\n        print(context['quick'])\n\n    # lag values can't be used directly in a django filter so don't put them in context['filter']\n    lag = request.GET.get('lag', '') or request.GET.get('l', '')\n    lag = [s.strip().upper() for s in lag.split(',')] or ['']\n    maxl = request.GET.get('max_lag', '') or request.GET.get('maxlag', '') or request.GET.get('maxl', '')\n    minl = request.GET.get('min_lag', '') or request.GET.get('minlag', '') or request.GET.get('maxl', '')\n\n    try:\n        lag = int(lag)\n        minl = lag - 7\n        maxl = lag\n    except:\n        try:\n            minl = int(minl)\n        except:\n            minl = ''\n        try:\n            maxl = int(maxl)\n        except:\n            maxl = ''\n\n    context['filter']['min_lag'] = minl\n    context['filter']['max_lag'] = maxl\n\n    initial = {\n                'mn':       ', '.join(m.strip() for m in context['filter']['model_numbers'] if m.strip()), \n                'sg':       ', '.join(context['filter']['sales_groups']),\n                'r':        ', '.join(context['filter']['reasons']),\n                'an':       ', '.join(context['filter']['account_numbers']),\n                'fy':       ', '.join(context['filter']['fiscal_years']),\n                'exclude':            context['exclude'],\n                'min_lag':            context['filter']['min_lag'],\n                'max_lag':            context['filter']['max_lag'],\n                'min_date': ', '.join(context['filter']['min_dates']),\n                'max_date': ', '.join(context['filter']['max_dates']),\n                'columns':  '; '.join(context['columns']),\n                'regex':              context['regex'],\n                'name':        ''\n              }\n\n    context['name'] = request.GET.get('s') or request.GET.get('n') or request.GET.get('series') or request.GET.get('name') or util.slug_from_dict(initial)\n\n    if verbosity > 0:\n        print 'initial: {0}'.format(initial)\n        print 'normalized GET query parameters: %r' % initial\n        print 'Form before validation {0}'.format(Form)\n\n    if request.method == 'POST':\n        # GetLagForm only has a GET button\n        context['form'] = Form(request.POST)\n    elif request.method == 'GET':\n        context['form'] = Form(data=initial, initial=initial)\n    if verbosity > 0:\n        print Form\n\n    context['form_is_valid'] = context['form'].is_valid()\n    if not context['form_is_valid']:\n        context['form_errors'] = context['form'].errors\n        if verbosity > 0:\n            print 'ERRORS in FORM !!!!!!!!!!!!!'\n            print context['form_errors']\n        #import ipdb\n        #ipdb.set_trace()\n        #raise RuntimeError('form is invalid')\n\n    if not context.get('field_names'):\n        context['field_names'] = kwargs.get('field_names', [])\n\n        \n    if not context.get('filename'):\n        context['filename'] = 'Refurb.csv'\n\n    return context"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nliking getattr but follows model relationships through \"__\" or \".\" as link separators", "response": "def follow_double_underscores(obj, field_name=None, excel_dialect=True, eval_python=False, index_error_value=None):\n    '''Like getattr(obj, field_name) only follows model relationships through \"__\" or \".\" as link separators\n\n    >>> from django.contrib.auth.models import Permission\n    >>> import math\n    >>> p = Permission.objects.all()[0]\n    >>> follow_double_underscores(p, 'content_type__name') == p.content_type.name\n    True\n    >>> follow_double_underscores(p, 'math.sqrt(len(obj.content_type.name))', eval_python=True) == math.sqrt(len(p.content_type.name))\n    True\n    '''\n    if not obj:\n        return obj\n    if isinstance(field_name, list):\n        split_fields = field_name\n    else:\n        split_fields = re_model_instance_dot.split(field_name)\n    if False and eval_python:\n        try:\n            return eval(field_name, {'datetime': datetime, 'math': math, 'collections': collections}, {'obj': obj})\n        except IndexError:\n            return index_error_value\n        except:\n            pass\n\n    if len(split_fields) <= 1:\n        if hasattr(obj, split_fields[0]):\n            value = getattr(obj, split_fields[0])\n        elif hasattr(obj, split_fields[0] + '_id'):\n            value = getattr(obj, split_fields[0] + '_id')\n        elif hasattr(obj, split_fields[0] + '_set'):\n            value = getattr(obj, split_fields[0] + '_set')\n        elif split_fields[0] in obj.__dict__:\n            value = obj.__dict__.get(split_fields[0])\n        elif eval_python:\n\t\t\tvalue = eval('obj.' + split_fields[0])\n        else:\n            return follow_double_underscores(getattr(obj, split_fields[0]), field_name=split_fields[1:], eval_python=eval_python, index_error_value=index_error_value)\n        if value and excel_dialect and isinstance(value, datetime.datetime):\n            value = value.strftime('%Y-%m-%d %H:%M:%S')\n        return value\n    return follow_double_underscores(getattr(obj, split_fields[0]), field_name=split_fields[1:], eval_python=eval_python, index_error_value=index_error_value)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef table_generator_from_list_of_instances(data, field_names=None, excluded_field_names=None, sort=True, excel_dialect=True, eval_python=False):\n    '''Return an iterator over the model instances (or queryset) that yeilds lists of values\n\n    This forms a table suitable for output as a csv\n\n    FIXME: allow specification of related field values with double_underscore\n\n    >>> from django.contrib.auth.models import Permission\n    >>> from django.db.models.base import ModelState\n    >>> t = table_generator_from_list_of_instances(list(Permission.objects.all()))\n    >>> import types\n    >>> isinstance(t, types.GeneratorType)\n    True\n    >>> t = list(t)\n    >>> len(t) > 3\n    True\n    >>> len(t[0])\n    5\n    >>> isinstance(t[0][0], basestring)\n    True\n    >>> isinstance(t[0][-1], basestring)\n    True\n    >>> isinstance(t[1][0], int)\n    True\n    >>> isinstance(t[0][2], basestring)\n    True\n    >>> isinstance(t[1][2], ModelState)\n    True\n    >>> isinstance(t[-1][2], ModelState)\n    True\n    '''\n    excluded_field_names = excluded_field_names or []\n    excluded_field_names += '_state'\n    excluded_field_names = set(excluded_field_names)\n\n    for i, row in enumerate(data):\n        if not field_names or not any(field_names):\n            field_names = [k for (k, v) in row.__dict__.iteritems() if not k in excluded_field_names]\n        if not i:\n            yield field_names\n        yield [follow_double_underscores(row, field_name=k, excel_dialect=True, eval_python=eval_python) for k in field_names]", "response": "Return an iterator over the model instances that yeilds lists of values\n\n    This forms a table suitable for output as a csv\n    This is a generator that yields the model instances that yeilds lists of values\nMimeType."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ngenerate the CSV response for a Download CSV button from data within the context dict.", "response": "def csv_response_from_context(context=None, filename=None, field_names=None, null_string='', eval_python=True):\n    \"\"\"Generate the response for a Download CSV button from data within the context dict\n\n    The CSV data must be in one of these places/formats:\n\n    * context as a list of lists of python values (strings for headers in first list)\n    * context['data']['d3data'] as a string in json format (python) for a list of lists of repr(python_value)s\n    * context['data']['cases'] as a list of lists of python values (strings for headers in first list)\n    * context['data']['cases'] as a django queryset or iterable of model instances (list, tuple, generator)\n\n    If the input data is a list of lists (table) that has more columns that rows it will be trasposed before being processed\n    \"\"\"\n    filename = filename or context.get('filename') or 'table_download.csv'\n    field_names = field_names or context.get('field_names', [])\n    # FIXME: too slow!\n    if field_names and all(field_names) and all(all(c in (string.letters + string.digits + '_.') for c in s) for s in field_names):\n        eval_python=False\n\n    data = context\n\n    # find the data table within the context dict. should be named 'data.cases' or 'data.d3data'\n    if not (isinstance(data, (tuple, list)) and isinstance(data[0], (tuple, list))):\n        data = json.loads(data.get('data', {}).get('d3data', '[[]]'))\n        if not data or not any(data):\n            data = context.get('data', {}).get('cases', [[]])\n\n    if not isinstance(data, (list, tuple)) or not isinstance(data[0], (list, tuple)):\n        data = table_generator_from_list_of_instances(data, field_names=field_names, eval_python=eval_python)\n\n    try:\n        if len(data) < len(data[0]):\n            data = util.transposed_lists(data)  # list(list(row) for row in data)\n    except TypeError:\n        # no need to transpose if a generator was provided instead of a list or tuple (anything with a len attribute)\n        pass\n\n    # Create the HttpResponse object with the appropriate CSV header.\n    response = HttpResponse(content_type='text/csv')\n    response['Content-Disposition'] = 'attachment; filename=\"%s\"' % filename\n\n    writer = csv.writer(response)\n    for row in data:\n        newrow = []\n        for s in row:\n            try:\n                newrow.append(s.encode('utf-8')) #handles strings, unicodes, utf-8s\n            except AttributeError:  #will happen when we try to encode a class object or number\n                newrow.append(s)\n            except: #not sure it ever will be touched.\n                newrow.append(unicode(s))\n        writer.writerow(newrow)\n    return response"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef render_to_response(self, context, indent=None):\n        \"Returns a JSON response containing 'context' as payload\"\n        return self.get_json_response(self.convert_context_to_json(context, indent=indent))", "response": "Returns a JSON response containing context as payload"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nstripping the whitespace and applies Unicode normalisation to the given string.", "response": "def normalise(self, string, line_num):\n\t\t\"\"\"\n\t\tStrips the whitespace and applies Unicode normalisation to the given\n\t\tstring. The second arg is used as an ID of the string when reporting\n\t\tits lint errors (if such).\n\t\t\"\"\"\n\t\tstripped = string.strip()\n\t\tif stripped != string:\n\t\t\tself.strip_errors.append(line_num)\n\n\t\tnfc_pos = [index\n\t\t\t\t\tfor index, char in enumerate(stripped)\n\t\t\t\t\tif char in self.nfc_chars]\n\n\t\tparts = []\n\t\tstart_pos = 0\n\n\t\tfor pos in nfc_pos:\n\t\t\tif pos > 0:\n\t\t\t\tparts.append(self.norm_f(stripped[start_pos:pos]))\n\n\t\t\tparts.append(stripped[pos])\n\t\t\tstart_pos = pos + 1\n\n\t\tif start_pos < len(stripped):\n\t\t\tparts.append(self.norm_f(stripped[start_pos:]))\n\n\t\tnorm = ''.join(parts)\n\n\t\tif norm != stripped:\n\t\t\tself.norm_errors.append(line_num)\n\n\t\treturn norm"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef report(self, reporter, ignore_nfd=False, ignore_ws=False):\n\t\tif self.strip_errors and not ignore_ws:\n\t\t\treporter.add(self.strip_errors, 'leading or trailing whitespace')\n\n\t\tif self.norm_errors and not ignore_nfd:\n\t\t\treporter.add(self.norm_errors, 'not in Unicode NFD')", "response": "Report the problems that have been found so far."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_configuration(self, command):\n        self.permanent_progressbar_slots = command.permanent_progressbar_slots\n        self.redraw_frequency_millis = command.redraw_frequency_millis\n        self.console_level = command.console_level\n        self.task_millis_to_removal = command.task_millis_to_removal\n\n        self.console_format_strftime = command.console_format_strftime\n        self.console_format = command.console_format\n        self.file_handlers = command.file_handlers\n\n        # If the logger has already been initialized, then clear file handlers and add the new ones\n        if len(self.log.handlers) > 0:\n            self.log.handlers.clear()\n\n            for handler in self.file_handlers:\n                if isinstance(handler, StreamHandler)\\\n                        and (handler.stream == sys.stdout or handler.stream == sys.stderr):\n                    self.critical(LogMessageCommand(text='Cannot use logging.StreamHandler with \\'sys.stdout\\' nor '\n                                                         '\\'sys.stderr\\' because those are reserved by the logger '\n                                                         'process',\n                                                    level=logging.CRITICAL))\n                    continue\n\n                self.log.addHandler(hdlr=handler)\n\n        # Do not clear exceptions if the user changes the configuration during runtime\n        if self.exceptions:\n            # If exceptions already exists\n            current_length = len(self.exceptions)\n\n            if command.exception_number < current_length:\n                # Delete exceptions from the end to desired index to keep most recent exceptions\n                range_to_delete = current_length - command.exception_number\n                for i in range(range_to_delete):\n                    del self.exceptions[-1]\n\n            elif command.exception_number > current_length:\n                # Add empty slots at the end\n                range_to_add = command.exception_number - current_length\n                for i in range(range_to_add):\n                    self.exceptions.append('')\n        else:\n            # Else, initialize a new list\n            self.exceptions = command.exception_number * ['']\n\n        # Do not clear messages if the user changes the configuration during runtime\n        if self.messages:\n            # If messages already exists\n            current_length = len(self.messages)\n\n            if command.message_number < current_length:\n                # Delete messages from 0 to desired index to keep most recent messages\n                range_to_delete = current_length - command.message_number\n                for i in range(range_to_delete):\n                    del self.messages[0]\n\n            elif command.message_number > current_length:\n                # Add empty slots at 0\n                range_to_add = command.message_number - current_length\n                for i in range(range_to_add):\n                    self.messages.insert(0, '')\n        else:\n            # Else, initialize a new list\n            self.messages = command.message_number * ['']", "response": "Sets the current configuration of the logger."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef run(self):\n        # Initialize the file logger\n        self.log = getLogger()\n\n        # Deserialize configuration\n        self.set_config_command = dill.loads(self.set_config_command)\n        self.set_configuration(self.set_config_command)\n\n        for handler in self.file_handlers:\n            if isinstance(handler, StreamHandler)\\\n                    and (handler.stream == sys.stdout or handler.stream == sys.stderr):\n                self.critical(LogMessageCommand(text='Cannot use logging.StreamHandler with \\'sys.stdout\\' nor '\n                                                     '\\'sys.stderr\\' because those are reserved by the logger process',\n                                                level=logging.CRITICAL))\n                continue\n\n            self.log.addHandler(hdlr=handler)\n\n        self.log.setLevel(self.console_level)\n\n        while True:\n            o = dill.loads(self.queue.get())\n\n            if isinstance(o, LogMessageCommand):\n                if o.level == logging.DEBUG:\n                    self.debug(command=o)\n                elif o.level == logging.INFO:\n                    self.info(command=o)\n                elif o.level == logging.WARNING:\n                    self.warning(command=o)\n                elif o.level == logging.ERROR:\n                    self.error(command=o)\n                elif o.level == logging.CRITICAL:\n                    self.critical(command=o)\n\n            elif isinstance(o, UpdateProgressCommand):\n                self.update(command=o)\n\n            elif isinstance(o, NewTaskCommand):\n                self.set_task(command=o)\n\n            elif isinstance(o, FlushCommand):\n                self.flush()\n\n            elif isinstance(o, StacktraceCommand):\n                self.throw(command=o)\n\n            elif isinstance(o, SetConfigurationCommand):\n                self.set_configuration(command=o)\n\n            elif isinstance(o, ExitCommand):\n                return\n\n            elif isinstance(o, SetLevelCommand):\n                self.set_level(command=o)", "response": "This method is called by the main application to start the logger process."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncalculates the longest prefix value in character unit.", "response": "def longest_bar_prefix_value(self):\n        \"\"\"\n        Calculates the longest progress bar prefix in order to keep all progress bars left-aligned.\n        :return: Length of the longest task prefix in character unit.\n        \"\"\"\n        longest = 0\n        for key, t in self.tasks.items():\n            size = len(t.prefix)\n            if size > longest:\n                longest = size\n\n        return longest"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef millis_to_human_readable(time_millis):\n        weeks = 0\n        days = 0\n        hours = 0\n        minutes = 0\n        seconds = round(time_millis / 1000)\n\n        while seconds > 59:\n            seconds -= 60\n            minutes += 1\n\n        while minutes > 59:\n            minutes -= 60\n            hours += 1\n\n        while hours > 23:\n            hours -= 24\n            days += 1\n\n        while days > 6:\n            hours -= 7\n            weeks += 1\n\n        if weeks > 0:\n            output = '{} w {} d {} h {} min {} s'.format(weeks, days, hours, minutes, seconds)\n        elif days > 0:\n            output = '{} d {} h {} min {} s'.format(days, hours, minutes, seconds)\n        elif hours > 0:\n            output = '{} h {} min {} s'.format(hours, minutes, seconds)\n        elif minutes > 0:\n            output = '{} min {} s'.format(minutes, seconds)\n        elif seconds > 0:\n            output = '{} s'.format(seconds)\n        else:\n            output = ''\n\n        return output", "response": "Calculates the equivalent time of the given milliseconds into a human readable string."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef print_progress_bar(self, task):\n        str_format = \"{0:.\" + str(task.decimals) + \"f}\"\n        percents = str_format.format(100 * (task.progress / float(task.total)))\n        filled_length = int(round(task.bar_length * task.progress / float(task.total)))\n        bar = '\u2588' * filled_length + '-' * (task.bar_length - filled_length)\n\n        # Build elapsed time if needed\n        elapsed_time = None\n\n        if task.display_time:\n            if task.end_time:\n                # If the task has ended, stop the chrono\n                if not task.elapsed_time_at_end:\n                    task.elapsed_time_at_end = self.millis_to_human_readable(task.end_time - task.begin_time)\n                elapsed_time = task.elapsed_time_at_end\n            else:\n                # If task is new then start the chrono\n                if not task.begin_time:\n                    task.begin_time = millis()\n                elapsed_time = self.millis_to_human_readable(millis() - task.begin_time)\n\n        prefix_pattern = '%{}s'.format(self.longest_bar_prefix_size)\n        time_container_pattern = '(%s)' if task.display_time and not task.end_time else '[%s]'\n\n        if len(task.suffix) > 0 and task.display_time:\n            sys.stdout.write('\\n {} |%s| %3s %% {} - %s'.format(prefix_pattern, time_container_pattern)\n                             % (task.prefix, bar, percents, elapsed_time, task.suffix))\n        elif len(task.suffix) > 0 and not task.display_time:\n            sys.stdout.write('\\n {} |%s| %3s %% - %s'.format(prefix_pattern)\n                             % (task.prefix, bar, percents, task.suffix))\n        elif task.display_time and not len(task.suffix) > 0:\n            sys.stdout.write('\\n {} |%s| %3s %% {}'.format(prefix_pattern, time_container_pattern)\n                             % (task.prefix, bar, percents, elapsed_time))\n        else:\n            sys.stdout.write('\\n {} |%s| %3s %%'.format(prefix_pattern)\n                             % (task.prefix, bar, percents))\n\n        sys.stdout.write('\\n')\n        sys.stdout.flush()", "response": "Prints a progress bar on screen based on the given information."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nredraws the console and waits for messages to be sent to the logger.", "response": "def redraw(self):\n        \"\"\"\n        Clears the console and performs a complete redraw of all progress bars and then awaiting logger messages if the\n        minimum time elapsed since the last redraw is enough.\n        \"\"\"\n\n        # Check if the refresh time lapse has elapsed and if a change requires to redraw\n        lapse_since_last_refresh = millis() - self.refresh_timer\n        if not lapse_since_last_refresh > self.redraw_frequency_millis or not self.changes_made:\n            return\n        # If yes, then reset change indicator and chrono\n        self.changes_made = False\n        self.refresh_timer = millis()\n\n        # Clear the system console\n        os.system(self.os_flush_command)\n\n        # For each task, check if it has complete. If so, start its chrono\n        # Once the chrono has reached the maximum timeout time, delete the task\n        # For the other tasks that have not completed yet, redraw them\n\n        # Delete tasks that have been marked for deletion\n        if len(self.to_delete) > 0:\n            for task_id in self.to_delete:\n                del self.tasks[task_id]\n            self.to_delete = []\n            # If a task has been deleted, recalculate the maximum prefix length to keep progress bars aligned\n            self.longest_bar_prefix_size = self.longest_bar_prefix_value()\n\n        for task_id, task in self.tasks.items():\n\n            # If a task has completed, force its value to its maximum to prevent progress bar overflow\n            # Then start its timeout chrono\n            if task.progress >= task.total and not task.keep_alive:\n                # Prevent bar overflow\n                task.progress = task.total\n\n                # Start task's timeout chrono\n                if not task.timeout_chrono:\n                    task.timeout_chrono = millis()\n                # If task's chrono has reached the maximum timeout time, mark it for deletion\n                elif millis() - task.timeout_chrono >= self.task_millis_to_removal:\n                    self.to_delete.append(task_id)\n\n            # Redraw the task's progress bar through standard output\n            self.print_progress_bar(task=task)\n\n        # Keep space for future tasks if needed\n        slots = self.permanent_progressbar_slots - len(self.tasks)\n        if slots > 0:\n            for i in range(slots):\n                sys.stdout.write('\\n\\t\\t---\\n')\n\n        # Draw some space between bars and messages\n        if len(self.messages) > 0:\n            if self.permanent_progressbar_slots > 0 or len(self.tasks) > 0:\n                sys.stdout.write('\\n\\n')\n\n            # Print all the last log messages through standard output\n            for m in self.messages:\n                sys.stdout.write(m)\n\n        # Draw some space between messages and exceptions\n        if len(self.exceptions) > 0:\n            if len(self.messages) > 0:\n                sys.stdout.write('\\n\\n')\n\n            # Print all the exceptions through error output\n            for ex in self.exceptions:\n                sys.stderr.write(ex)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nappend a message to the end of the list.", "response": "def append_message(self,\n                       message):\n        \"\"\"\n        Appends the given message at the end of the message list and delete the oldest one (top most).\n        :param message: The formatted text to log.\n        \"\"\"\n        # Delete the first message of the list\n        if len(self.messages) > 0:\n            del self.messages[0]\n\n        # Append the new message at the end\n        self.messages.append(message)\n        self.changes_made = True\n\n        # Redraw\n        self.redraw()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef append_exception(self,\n                         stacktrace):\n        \"\"\"\n        Appends the given exception at the top of the exception list and delete the oldest one (bottom most).\n        :param stacktrace: Stacktrace string as returned by 'traceback.format_exc()' in an 'except' block.\n        \"\"\"\n        # Delete the last message of the list\n        if len(self.exceptions) > 0:\n            del self.exceptions[-1]\n\n        # Append the new message at the top\n        self.exceptions.insert(0, stacktrace)\n        self.changes_made = True\n\n        # Redraw\n        self.redraw()", "response": "Append the given exception to the top of the exception list and delete the oldest one."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_level(self, command):\n        if not command.console_only:\n            self.log.setLevel(command.level)\n\n        self.console_level = command.level", "response": "Sets the logging level for the log messages."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndefining a new progress bar with the given information.", "response": "def set_task(self, command):\n        \"\"\"\n        Defines a new progress bar with the given information.\n        :param command: The command object that holds all the necessary information from the remote process.\n        \"\"\"\n        self.tasks[command.task_id] = command.task\n\n        self.longest_bar_prefix_size = self.longest_bar_prefix_value()\n\n        # Redraw\n        self.changes_made = True\n        self.redraw()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef update(self, command):\n        if command.task_id in self.tasks and self.tasks[command.task_id].set_progress(command.progress):\n\n            # Redraw\n            self.changes_made = True\n            self.redraw()", "response": "Update the current progress for this task."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef debug(self, command):\n        if self.console_level == logging.DEBUG:\n\n            message = self.get_format()\n            message = message.replace('{L}', 'DEBUG')\n            message = '{}\\t{}\\n'.format(message, command.text)\n\n            self.append_message(message)\n\n            # Redraw\n            self.changes_made = True\n            self.redraw()\n\n        self.log.debug('\\t{}'.format(command.text))", "response": "Logs a debug message to the log."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef throw(self, command):\n        exception_message = '[Process {}{}]:\\n{}'.format(command.pid, ' - {}'\n                                                        .format(command.process_title) if command.process_title else '',\n                                                        command.stacktrace)\n\n        message = self.get_format()\n        message = message.replace('{L}', 'EXCEPTION')\n        message = '{}\\t{}\\n'.format(message, exception_message)\n\n        self.append_exception(message)\n\n        # Redraw\n        self.changes_made = True\n        self.redraw()\n\n        self.log.critical('\\t{}'.format(exception_message))", "response": "Logs an exception in an except block."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef GetServices(self,filename):\n        objlist=[]\n        for sobj in self.services:\n            if sobj.KnowsFile(filename) :\n                objlist.append(sobj)\n\n        if len(objlist)==0:\n            return None\n\n        return objlist", "response": "Returns a list of service objects handling this file type"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef GetServiceObj(self,servicename):\n        for sobj in self.services:\n            if sobj.GetName().lower()==servicename.lower():\n                return sobj\n\n        return None", "response": "Returns the object that corresponds to the given service name"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the path to the backing file of the object with the given id in the given collection.", "response": "def object_path(collection, id):\n    \"\"\"Returns path to the backing file of the object\n    with the given ``id`` in the given ``collection``.\n    Note that the ``id`` is made filesystem-safe by\n    \"normalizing\" its string representation.\"\"\"\n    _logger.debug(type(id))\n    _logger.debug(id)\n    if isinstance(id, dict) and 'id' in id:\n        id = id['id']\n    normalized_id = normalize_text(str(id), lcase=False)\n    return os.path.join(_basepath, collection,\n        '%s.%s' % (normalized_id, _ext))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef load_object_at_path(path):\n    with open(path, 'r') as f:\n        data = _deserialize(f.read())\n        return aadict(data)", "response": "Load an object from disk at explicit path"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef add_collection(collection,\n                   cache_size=1000,\n                   cache_cls=LRUCache,\n                   **cache_args):\n    \"\"\"Add a collection named ``collection``.\"\"\"\n    assert collection not in _db\n    cache = cache_cls(maxsize=cache_size,\n                      missing=lambda id: load_object(collection, id),\n                      **cache_args)\n    _db[collection] = aadict(cache=cache, indexes={})", "response": "Add a collection named collection to the database."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef prepare(base_path='data',\n            serialize=json.dumps,\n            deserialize=json.loads,\n            file_ext='json'):\n    \"\"\"After you have added your collections, prepare the database\n    for use.\"\"\"\n    global _basepath, _deserialize, _serialize, _ext\n    _basepath = base_path\n    assert callable(serialize)\n    assert callable(deserialize)\n    _serialize = serialize\n    _deserialize = deserialize\n    _ext = file_ext\n    _logger.debug('preparing with base path %s and file ext %s',\n        _basepath, _ext)\n    assert len(_db)\n    for collection in _db.keys():\n        c_path = collection_path(collection)\n        os.makedirs(c_path, exist_ok=True)\n        _logger.info('collection \"%s\": %d objects',\n            collection, object_count(collection))", "response": "Prepare the database\n    for use."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nyield each object in the given collection.", "response": "def each_object(collection):\n    \"\"\"Yields each object in the given ``collection``.\n    The objects are loaded from cache and failing that,\n    from disk.\"\"\"\n    c_path = collection_path(collection)\n    paths = glob('%s/*.%s' % (c_path, _ext))\n    for path in paths:\n        yield load_object_at_path(path)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nyielding each object ID in the given collection.", "response": "def each_object_id(collection):\n    \"\"\"Yields each object ID in the given ``collection``.\n    The objects are not loaded.\"\"\"\n    c_path = collection_path(collection)\n    paths = glob('%s/*.%s' % (c_path, _ext))\n    for path in paths:\n        match = regex.match(r'.+/(.+)\\.%s$' % _ext, path)\n        yield match.groups()[0]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef save_object(collection, obj):\n    if 'id' not in obj:\n        obj.id = uuid()\n    id = obj.id\n    path = object_path(collection, id)\n    temp_path = '%s.temp' % path\n    with open(temp_path, 'w') as f:\n        data = _serialize(obj)\n        f.write(data)\n    shutil.move(temp_path, path)\n    if id in _db[collection].cache:\n        _db[collection].cache[id] = obj\n    _update_indexes_for_mutated_object(collection, obj)\n    return obj", "response": "Save an object to the given collection."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadd a secondary index for a collection.", "response": "def add_index(collection,\n              name,\n              fields,\n              transformer=None,\n              unique=False,\n              case_insensitive=False):\n    \"\"\"\n    Add a secondary index for a collection ``collection`` on one or\n    more ``fields``.\n\n    The values at each of the ``fields`` are loaded from existing\n    objects and their object ids added to the index.\n\n    You can later iterate the objects of an index via\n    ``each_indexed_object``.\n\n    If you update an object and call ``save_object``, the index will\n    be updated with the latest values from the updated object.\n\n    If you delete an object via ``delete_object``, the object will\n    be removed from any indexes on the object's collection.\n\n    If a function is provided for ``transformer``, the values\n    extracted from each object in the collection will be passed to\n    the ``transformer``.  The ``transformer`` should return a list\n    of values that will go into the index.\n\n    If ``unique`` is true, then there may only be at most one object\n    in the collection with a unique set of values for each the\n    ``fields`` provided.\n\n    If ``case_insensitive`` is true, then the value stored in the\n    index will be lower-cased and comparisons thereto will be\n    lower-cased as well.\n    \"\"\"\n    assert len(name) > 0\n    assert len(fields) > 0\n    indexes = _db[collection].indexes\n    index = indexes.setdefault(name, aadict())\n    index.transformer = transformer\n    index.value_map = {}  # json([value]) => set(object_id)\n    index.unique = unique\n    index.case_insensitive = case_insensitive\n    index.fields = fields\n    for obj in each_object(collection):\n        _add_to_index(index, obj)\n    _logger.info('added %s, %s index to collection %s on fields: %s',\n        'unique' if unique else 'non-unique',\n        'case-insensitive' if case_insensitive else 'case-sensitive',\n        collection, ', '.join(fields))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd the given object obj to the given index.", "response": "def _add_to_index(index, obj):\n    \"\"\"Adds the given object ``obj`` to the given ``index``\"\"\"\n    id_set = index.value_map.setdefault(indexed_value(index, obj), set())\n    if index.unique:\n        if len(id_set) > 0:\n            raise UniqueConstraintError()\n    id_set.add(obj.id)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nremoves object obj from the index.", "response": "def _remove_from_index(index, obj):\n    \"\"\"Removes object ``obj`` from the ``index``.\"\"\"\n    try:\n        index.value_map[indexed_value(index, obj)].remove(obj.id)\n    except KeyError:\n        pass"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef each_indexed_object(collection, index_name, **where):\n    index = _db[collection].indexes[index_name]\n    for id in index.value_map.get(indexed_value(index, where), []):\n        yield get_object(collection, id)", "response": "Yields each object indexed by the index with\n name with values matching on indexed\n field values."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nupdates the indexes for the objects that have been mutated by the object.", "response": "def _update_indexes_for_mutated_object(collection, obj):\n    \"\"\"If an object is updated, this will simply remove\n    it and re-add it to the indexes defined on the\n    collection.\"\"\"\n    for index in _db[collection].indexes.values():\n        _remove_from_index(index, obj)\n        _add_to_index(index, obj)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nupdate the indexes for the given object.", "response": "def _update_indexes_for_deleted_object(collection, obj):\n    \"\"\"If an object is deleted, it should no longer be\n    indexed so this removes the object from all indexes\n    on the given collection.\"\"\"\n    for index in _db[collection].indexes.values():\n        _remove_from_index(index, obj)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef parse_delta(__string: str) -> datetime.timedelta:\n    if not __string:\n        return datetime.timedelta(0)\n    match = re.fullmatch(r\"\"\"\n        P\n        ((?P<days>\\d+)D)?\n        T?\n        ((?P<hours>\\d{1,2})H)?\n        ((?P<minutes>\\d{1,2})M)?\n        ((?P<seconds>\\d{1,2})?((?:\\.(?P<microseconds>\\d+))?S)?)\n    \"\"\", __string, re.VERBOSE)\n    if not match:\n        raise ValueError('Unable to parse delta {!r}'.format(__string))\n    match_dict = {k: int(v) if v else 0 for k, v in match.groupdict().items()}\n    return datetime.timedelta(**match_dict)", "response": "Parse ISO - 8601 duration string."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nformatting ISO - 8601 duration string.", "response": "def format_delta(__timedelta: datetime.timedelta) -> str:\n    \"\"\"Format ISO-8601 duration string.\n\n    Args:\n        __timedelta: Duration to process\n    Returns:\n        ISO-8601 representation of duration\n    \"\"\"\n    if __timedelta == datetime.timedelta(0):\n        return ''\n    days_s = '{}D'.format(__timedelta.days) if __timedelta.days else ''\n    hours, minutes = divmod(__timedelta.seconds, 3600)\n    minutes, seconds = divmod(minutes, 60)\n    hours_s = '{:02d}H'.format(hours) if hours else ''\n    minutes_s = '{:02d}M'.format(minutes) if minutes else ''\n    seconds_s = '{:02d}S'.format(seconds) if seconds else ''\n    return 'P{}{}{}{}{}'.format(days_s,\n                                'T' if hours or minutes or seconds else '',\n                                hours_s, minutes_s, seconds_s)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef parse_datetime(__string: str) -> datetime.datetime:\n    if not __string:\n        datetime_ = datetime.datetime.now(datetime.timezone.utc)\n    else:\n        # pylint: disable=no-member\n        datetime_ = ciso8601.parse_datetime(__string)\n    if datetime_.tzinfo is None:\n        datetime_ = datetime_.replace(tzinfo=datetime.timezone.utc)\n    return datetime_", "response": "Parse ISO - 8601 datetime string."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nprinting information about the given device.", "response": "def print_device_info(dev_name):\n    \"\"\"Prints information about the given device.\n\n    Usage:\n    print_device_info(\"Dev1\")\n    \"\"\"\n    string_buffer = ctypes.create_string_buffer(1024)\n    attributes = [pydaq.DAQmx_Dev_ProductType, pydaq.DAQmx_Dev_SerialNum,\n                  pydaq.DAQmx_Dev_AO_PhysicalChans,\n                  pydaq.DAQmx_Dev_CI_PhysicalChans,\n                  pydaq.DAQmx_Dev_CO_PhysicalChans,\n                  pydaq.DAQmx_Dev_DO_Lines]\n    attribute_names = ['DAQmx_Dev_ProductType',\n                       'DAQmx_Dev_SerialNum',\n                       'DAQmx_Dev_AO_PhysicalChans',\n                       'DAQmx_Dev_CI_PhysicalChans',\n                       'DAQmx_Dev_CO_PhysicalChans',\n                       'DAQmx_Dev_DO_Lines']\n    ret_values = []\n    for a in attributes:\n        pydaq.DAQmxGetDeviceAttribute(dev_name, a, string_buffer)\n        ret_values.append(str(string_buffer.value))\n\n    print('Device Name:\\t' + dev_name)\n    for n, v in zip(attribute_names, ret_values):\n        print '\\t' + n + ':\\t' + v"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_device_name_list():\n    dev_names = ctypes.create_string_buffer(1024)\n    pydaq.DAQmxGetSysDevNames(dev_names, len(dev_names))\n    return dev_names.value.split(', ')", "response": "Returns a list of device names installed on the system."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef reset_analog_sample_clock(state=False):\n    set_digital_line_state(expt_settings.dev1_clock_out_name, state)\n    set_digital_line_state(expt_settings.dev2_clock_out_name, state)\n    set_digital_line_state(expt_settings.dev3_clock_out_name, state)\n    set_digital_line_state(expt_settings.dev4_clock_out_name, state)", "response": "Reset the clock line."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets the state of a single digital line.", "response": "def set_digital_line_state(line_name, state):\n    \"\"\"Set the state of a single digital line.\n\n    line_name (str) - The physical name of the line.\n        e.g line_name=\"Dev1/port0/line3\"\n        This should be a single digital line. Specifying more than one would\n        result in unexpected behaviour. For example \"Dev1/port0/line0:5\" is\n        not allowed.\n        see http://zone.ni.com/reference/en-XX/help/370466W-01/mxcncpts/physchannames/\n        for details of naming lines.\n    state (bool) - state=True sets the line to high, state=False sets to low.\n\n    \"\"\"\n    # get the line number from the line name. Thats the number of bits to shift\n    bits_to_shift = int(line_name.split('line')[-1])\n    dig_data = np.ones(2, dtype=\"uint32\")*bool(state)*(2**bits_to_shift)\n    # Note here that the number of samples written here are 2, which is the\n    # minimum required for a buffered write. If we configure a timing for the\n    # write, it is considered buffered.\n    # see http://zone.ni.com/reference/en-XX/help/370471Y-01/daqmxcfunc/daqmxwritedigitalu32/\n    DigitalOutputTask(line_name, dig_data).StartAndWait()"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsends a pulse train of on - off in Dev1 port0.", "response": "def p24_pulse_train(n_samples=100):\n    \"\"\"Sends a pulse train of on-off in Dev1/port0/line24.\n\n    This function creates a task, starts it and waits until it is over.\n    Uses expt_settings.external_clock_line as a clock.\n\n    n_samples - number of on off samples.\n    \"\"\"\n    samples = (np.arange(n_samples, dtype=\"uint32\") % 2)*(2**24)\n    samples[-1] = 0\n    DigitalOutputTask(\"Dev1/port0/line24\", samples).StartAndWait()"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nstarts the task and waits until it is done.", "response": "def StartAndWait(self):\n        \"\"\"Starts the task and waits until it is done.\"\"\"\n        self.StartTask()\n        self.WaitUntilTaskDone(pydaq.DAQmx_Val_WaitInfinitely)\n        self.ClearTask()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn true if task is done.", "response": "def isDone(self):\n        \"\"\"Returns true if task is done.\"\"\"\n        done = pydaq.bool32()\n        self.IsTaskDone(ctypes.byref(done))\n        return done.value"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef padDigitalData(self, dig_data, n):\n        n = int(n)\n        l0 = len(dig_data)\n        if l0 % n == 0:\n            return dig_data  # no need of padding\n        else:\n            ladd = n - (l0 % n)\n            dig_data_add = np.zeros(ladd, dtype=\"uint32\")\n            dig_data_add.fill(dig_data[-1])\n            return np.concatenate((dig_data, dig_data_add))", "response": "Pads the data array with its last element so that the new array is a\n            multiple of n."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef EveryNCallback(self):\n        # print('ncall ', self.n_callbacks)\n        if self.do_callbacks:\n            if self.n_callbacks >= self.callback_step:\n                # print('n_callbacks', self.n_callbacks)\n                for func, func_dict in self.callback_funcs:\n                    func(func_dict)\n                    print('func:::', func)\n\n                self.latest_callback_index +=1\n                if self.latest_callback_index >= len(self.callback_function_list):\n                    # print('done with callbacks')\n                    self.do_callbacks = False\n                else:\n                    out = self.callback_function_list[self.latest_callback_index]\n                    callback_time = out[0]\n                    self.callback_step = int(callback_time/expt_settings.callback_resolution)\n                    # print('updatin callback step', self.callback_step)\n                    self.callback_funcs = out[1]\n\n        self.n_callbacks += 1\n        #print('n_callbacks', self.n_callbacks)\n        return 0", "response": "Called by PyDAQmx whenever a callback event occurs."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_vads_trans_id(vads_site_id, vads_trans_date):\n    vads_trans_id = \"\"\n    for i in range(0, 6):\n        vads_trans_id += str(random.randint(0, 9))\n    return vads_trans_id", "response": "Returns a random vads_trans_id for the given vads_site_id and vads_trans_date."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the signature for the transaction.", "response": "def get_signature(payment_request):\n    \"\"\"\n    Returns the signature for the transaction.\n\n    To compute the signature, first you have to get the value of all\n    the fields that starts by 'vads_', ordering them alphabetically.\n    All the values are separated by the '+' character. Then you add\n    the value of the payzen certificate.\n    Finaly you hash the string using sha1.\"\"\"\n\n    vads_args = {}\n    for field in payment_request._meta.fields:\n        if field.name[:5] == 'vads_':\n            field_value = field.value_from_object(payment_request)\n            if field_value:\n                vads_args.update({\n                    field.name: field_value\n                })\n    base_str = ''\n    for key in sorted(vads_args):\n        base_str += str(vads_args[key]) + '+'\n    base_str += app_settings.VADS_CERTIFICATE\n    return hashlib.sha1(base_str.encode(\"utf-8\")).hexdigest()"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nprocesses a payment response.", "response": "def process_response(data):\n    \"\"\"Process a payment response.\"\"\"\n    # We check if the signature is valid. If not return\n    if not is_signature_valid(data):\n        logger.warning(\n            \"Django-Payzen : Response signature detected as invalid\",\n            extra={\"stack\": True}\n        )\n        return None\n\n    from . import forms\n    from . import models\n\n    # The signature is valid\n    vads_trans_id = data.get(\"vads_trans_id\")\n    vads_trans_date = data.get(\"vads_trans_date\")\n    vads_site_id = data.get(\"vads_site_id\")\n    try:\n        instance = models.PaymentResponse.objects.get(\n            vads_trans_id=vads_trans_id,\n            vads_trans_date=vads_trans_date,\n            vads_site_id=vads_site_id)\n        form = forms.PaymentResponseForm(data, instance=instance)\n    except models.PaymentResponse.DoesNotExist:\n        form = forms.PaymentResponseForm(data)\n    if form.is_valid():\n        response = form.save()\n        logger.info(\"Django-Payzen : Transaction {} response received !\"\n                    .format(response.vads_trans_id))\n    else:\n        logger.error(\"Django-Payzen : Response could not be saved - {} {}\"\n                     .format(form.errors, data),\n                     extra={\"stack\": True})\n        response = None\n    return response"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef apply(self):\n        # In this phase, we look for hyperlinks (references nodes)\n        # that contain substitutions (of the form \"|foo|\").\n        # We then add actual \"substitution\"s nodes to those references,\n        # so that they can be replaced by the substitution processor.\n        subst_re = re.compile(self.subst_pattern)\n\n        for link in self.document.traverse(self._maybe_hyperlink):\n            if 'refuri' not in link:\n                continue\n\n            # Note: \"target\" nodes do not have a \"name\" attribute.\n            if '|' not in link['refuri'] and '|' not in link.get('name', ''):\n                continue\n\n            # This list acts as a cache so that only one substitution node\n            # is added as a child for each substitution name.\n            substitutions = []\n\n            matches = subst_re.findall(link['refuri']) + \\\n                subst_re.findall(link.get('name', ''))\n            for subref_text in matches:\n                if subref_text in substitutions:\n                    continue\n\n                substitutions.append(subref_text)\n                subref_node = nodes.substitution_reference(subref_text)\n                link.append(subref_node)\n                self.document.note_substitution_ref(subref_node, subref_text)\n\n            # Build a map of substitutions names to child indices\n            # (minus one since the actual link label is in link[0]).\n            link['varlinks'] = \\\n                dict(zip(substitutions, range(len(substitutions))))", "response": "Create substitution nodes for hyperlinks."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef apply(self):\n        # In this phase, we replace the substitutions in hyperlinks\n        # with the contents of the sub-nodes introduced during phase 1.\n        # We also remove those temporary nodes from the tree.\n        subst_re = re.compile(self.subst_pattern)\n\n        # Apply the substitutions to hyperlink references.\n        for link in self.document.traverse(nodes.reference):\n            substitutions = link.get('varlinks')\n            if not substitutions:\n                continue\n\n            replacer = self._replace(substitutions, link.children, 1)\n            link['refuri'] = subst_re.sub(replacer, link['refuri'])\n            content = subst_re.sub(replacer, link[0])\n            # Cleanup the temporary nodes and recreate the node's content.\n            link.clear()\n            del link['varlinks']\n            link.append(nodes.Text(content))\n\n        # Do the same with hyperlink targets.\n        for link in self.document.traverse(nodes.target):\n            substitutions = link.get('varlinks')\n            if not substitutions:\n                continue\n\n            replacer = self._replace(substitutions, link.children, 0)\n            link['refuri'] = subst_re.sub(replacer, link['refuri'])\n            # Cleanup the temporary nodes.\n            link.clear()\n            del link['varlinks']", "response": "Apply substitutions to hyperlinks."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nadd the given value to the set of data stored under the given key.", "response": "def add(self, key: str, value: str):\n        \"\"\"\n        Adds the given value to the set of data stored under the given key.\n        :param key: the set's key\n        :param value: the value to add in the set associated to the given key\n        \"\"\"\n        if key in self:\n            # Use super to get mutable set\n            super().__getitem__(key).add(value)\n        else:\n            self[key] = {value}"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_by_number(self, number: int) -> Optional[DataObjectReplica]:\n        return self._data.get(number, None)", "response": "Gets the data object replica with the given number. Will return None if such replica does not exist."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget any data object replicas that are marked as out of date or not in date.", "response": "def get_out_of_date(self) -> Sequence[DataObjectReplica]:\n        \"\"\"\n        Gets any data object replica that are marked as out of date/not in date.\n        :return: the out of data object replica\n        \"\"\"\n        out_of_date = []\n        for number, data_object_replica in self._data.items():\n            if not data_object_replica.up_to_date:\n                out_of_date.append(data_object_replica)\n        return out_of_date"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add(self, data_object_replica: DataObjectReplica):\n        if data_object_replica.number in self._data:\n            raise ValueError(\n                    \"Data object replica with number %d already exists in this collection\" % data_object_replica.number)\n        self._data[data_object_replica.number] = data_object_replica", "response": "Adds the given data object replica to the collection. Will raise a ValueError if the data object replica with the number of the data object already exists."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef remove(self, identifier: Union[DataObjectReplica, int]):\n        if isinstance(identifier, int):\n            self._remove_by_number(identifier)\n        elif isinstance(identifier, DataObjectReplica):\n            self._remove_by_object(identifier)\n        else:\n            raise TypeError(\"Can only remove by number or by object reference: `%s` given\" % type(identifier))", "response": "Removes a data object from this collection that has the given unique identifier. A ValueError will be raised if a data object with the given identifier does not exist."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nremoves the data object with the given number from this collection.", "response": "def _remove_by_number(self, number: int):\n        \"\"\"\n        Removes the data object from this collection with the given number. A `ValueError` will be raised if a data\n        object with the given number does not exist.\n        :param number: the number of the data object to remove\n        \"\"\"\n        if number not in self._data:\n            raise ValueError(\"Data object replica number %d is not in this collection\" % number)\n        del self._data[number]\n        assert number not in self._data"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_safe_variables(self,query,var_dict):\n        ''' Create a list of safe variables: variables bounded to constants or\n        that occur in a positive goal '''\n\n        variables_bounded_to_constants = []\n\n        for constraint in query.constraints:\n            if (constraint.get_left_side().is_variable() and\n                constraint.get_right_side().is_constant() and\n                constraint.is_equality_constraint()):\n                    variables_bounded_to_constants.append(constraint.get_left_side())\n\n        safe_variables = list(var_dict) + variables_bounded_to_constants\n\n        return safe_variables", "response": "Create a list of safe variables that occur in a positive goal"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the global configuration.", "response": "def set_global_config(path_dict_or_stream):\n    '''Set the global configuration.\n\n    Call this from `main()` with a file system path, stream\n    object, or a dict.  Calling it repeatedly with the same path is\n    safe.  Calling it with a different path or repeatedly with a\n    stream or dict requires an explicit call to :func:`clear_global_config`.\n\n    :param path_dict_or_stream: source of configuration\n\n    '''\n    path = None\n    mapping = None\n    stream = None\n\n    global _config_file_path\n    global _config_cache\n\n    if isinstance(path_dict_or_stream, string_types):\n        path = path_dict_or_stream\n        if _config_file_path and _config_file_path != path:\n            raise Exception('set_global_config(%r) differs from %r, '\n                            'consider calling clear_global_config first' %\n                            (path, _config_file_path))\n        _config_file_path = path\n        stream = open(path)\n\n    elif isinstance(path_dict_or_stream, collections.Mapping):\n        mapping = path_dict_or_stream\n\n    elif hasattr(path_dict_or_stream, 'read'):\n        stream = path_dict_or_stream\n\n    else:\n        raise Exception('set_global_config(%r) instead of a path, '\n                        'mapping object, or stream open for reading' %\n                        path_dict_or_stream)\n\n    if stream is not None:\n        mapping = yaml.load(stream, Loader)\n\n    _config_cache = mapping\n\n    # TODO: convert to frozen dict?\n    return _config_cache"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget a subset of the global configuration.", "response": "def get_global_config(*args):\n    '''Get (a subset of) the global configuration.\n\n    If no arguments are provided, returns the entire configuration.\n    Otherwise, start with the entire configuration, and get the item\n    named by the first parameter; then search that for the second\n    parameter; and so on.\n\n    :param args: configuration name path to fetch\n    :return: configuration item or subtree\n    :raise KeyError: if an argument is missing\n\n    '''\n    global _config_cache\n    c = _config_cache\n    if c is None:\n        if len(args) == 0:\n            args = (None,)\n        raise KeyError(args[0])\n    for a in args:\n        c = c[a]\n    return c"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef include_yaml(self, node):\n        '''\n        load another yaml file from the path specified by node's value\n        '''\n        filename = self.construct_scalar(node)\n        if not filename.startswith('/'):\n            if self._root is None:\n                raise Exception('!include_yaml %s is a relative path, '\n                                'but stream lacks path' % filename)\n            filename = os.path.join(self._root, self.construct_scalar(node))\n        with self.open(filename, 'r') as fin:\n            return yaml.load(fin, Loader)", "response": "load another yaml file from the path specified by node s value\n       "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncall when parallelize is False. This function will generate the file names in a directory tree by walking the tree either top-down or bottom-up. For each directory in the tree rooted at directory top (including top itself), it yields a 3-tuple (dirpath, dirnames, filenames).", "response": "def encompass(self):\n        \"\"\"\n        Called when parallelize is False.\n        This function will generate the file names in a directory tree by walking the tree either top-down or\n        bottom-up. For each directory in the tree rooted at directory top (including top itself), it yields a 3-tuple\n        (dirpath, dirnames, filenames).\n        \"\"\"\n        self._printer('Standard Walk')\n        count = Counter(length=3)\n        for directory in self.directory:\n            for root, directories, files in os.walk(directory, topdown=self.topdown):\n                root = root[len(str(directory)) + 1:]\n                self._printer(str(count.up) + \": Explored path - \" + str(root), stream=True)\n                for filename in files:\n                    fullname = os.path.join(root, filename)\n                    # Join the two strings in order to form the full filepath.\n                    self.add_path(directory, fullname)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef filter(self):\n        self._printer('Standard Walk')\n        count = Counter(length=3)\n        for directory in self.directory:\n            self._printer('Searching ' + directory)\n            for root, directories, files in os.walk(directory, topdown=self.topdown):\n                root = root[len(str(directory)) + 1:]\n                self._printer(str(count.up) + \": Explored path - \" + str(root), stream=True)\n                if self.filters.validate(root):\n                    # Check that non-empty folders flag is on and we're at the max directory level\n                    if self.filters.non_empty_folders and self.filters.get_level(root) == self.filters.max_level:\n                        # Check that the path is not an empty folder\n                        if os.path.isdir(directory + os.sep + root):\n                            # Get paths in folder without walking directory\n                            paths = os.listdir(directory + os.sep + root)\n\n                            # Check that any of the paths are files and not just directories\n                            if paths and any(os.path.isfile(os.path.join(directory, p)) for p in paths):\n                                self.add_path(directory, root)\n\n                    else:\n                        for filename in files:\n                            fullname = os.path.join(root, filename)\n                            if self.filters.validate(fullname):\n                                # Join the two strings in order to form the full filepath.\n                                self.add_path(directory, fullname)", "response": "This function will walk the directory tree and generate the file names in the tree."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ntakes a stealth address and generates a payment pubkey and stealth OP_RETURN data.", "response": "def paystealth(stealthaddr,ephempriv=None,_doctest_nonce=-1):\n    '''\n    Input a stealth address, and optionally an ephemeral private key,\n    and generate a payment pubkey and stealth OP_RETURN data.\n\n    (The OP_RETURN data is just a nonce and the ephemeral public key.)\n\n    Works with standard single spend key stealth addresses, which\n    begin with the '2a00' version bytes, and have 00-08 prefix bits\n    and any 1-byte prefix.\n\n    Prefix ff with 08 prefix bits and nonce starts at 0:\n    >>> paystealth(\"vJmvinTgWP1phdFnACjc64U5iMExyv7JcQJVZjMA15MRf2KzmqjSpgDjmj8NxaFfiMBUEjaydmNfLBCcXstVDfkjwRoFQw7rLHWdFk\", \\\n    '824dc0ed612deca8664b3d421eaed28827eeb364ae76abc9a5924242ddca290a', 0)\n    ('03e05931191100fa6cd072b1eda63079736464b950d2875e67f2ab2c8af9b07b8d', \\\n'0600000124025c6fb169b0ff1c95426fa073fadc62f50a6e98482ec8b3f26fb73006009d1c00')\n    '''\n\n    if ephempriv is None:\n        ephempriv = genkeyhex()\n\n    addrhex = b58d(stealthaddr)\n\n    assert len(addrhex) == 142\n    assert int(addrhex[-4:-2],16) < 9\n    # Assume one spend key, and 1-byte prefix and prefix-bits\n\n    assert addrhex[:4] == '2a00'\n    assert addrhex[70:72] == '01'\n\n    scanpub = addrhex[4:70]\n    spendpub = addrhex[72:-4]\n    ephempub = privtopub(ephempriv,True)\n    secret = sha256(multiplypub(scanpub,ephempriv,True))\n    paykey = addpubs(spendpub,privtopub(secret,False),True)\n\n    if _doctest_nonce == -1:\n        nonce = int(genkeyhex(),16) % (2**32)\n    else:\n        nonce = _doctest_nonce\n    assert nonce < 4294967296 and nonce >= 0\n    startingnonce = nonce\n    while True:\n        if nonce > 4294967295:\n            nonce = 0\n        noncehex = dechex(nonce,4)\n        hashprefix = unhexlify(hash256('6a2606' + noncehex + ephempub))[::-1][:4]\n        prebits = int(addrhex[-4:-2],16)\n        if prebits == 0:\n           break\n\n        prefix = unhexlify(addrhex[-2:])\n        # Location of prefix should be explicit if it's ever more than 1 byte\n\n        bytepos = 0\n        cont = False\n        while prebits > 8: # Not necessary with asserted 1-byte prefix\n            if hexstrlify(prefix)[2*bytepos:(2*bytepos)+2] != \\\n               hexstrlify(hashprefix)[2*bytepos:(2*bytepos)+2]:\n                cont = True\n                break\n            prebits = prebits - 8\n            bytepos = bytepos + 1\n        if cont:\n            continue\n\n        prefixhex = hexstrlify(prefix)[2*bytepos:(2*bytepos)+2]\n        if prefixhex == \"\": prefixhex = hexstrlify(b\"00\")\n        hashprefixhex = hexstrlify(hashprefix)[2*bytepos:(2*bytepos)+2]\n        if hashprefixhex == \"\": hashprefixhex = hexstrlify(b\"00\")\n        prefixbits = (((1 << (8 - prebits)) - 1) ^ 0xff) & int(prefixhex, 16)\n        hashbits = (((1 << (8 - prebits)) - 1) ^ 0xff) & int(hashprefixhex, 16)\n        if prefixbits == hashbits:\n            cont = False\n        else:\n            cont = True\n        if not cont:\n            break\n        nonce += 1\n        if nonce == startingnonce:\n            raise Exception(\"No valid nonce was found. A different ephemeral key must be used.\")\n    return paykey, '06' + noncehex + ephempub"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef receivestealth(scanpriv,spendpriv,ephempub):\n    '''\n    Derive the private key for a stealth payment, using the scan and\n    spend private keys, and the ephemeral public key.\n\n    Input private keys should be 64-char hex strings, and ephemeral\n    public key should be a 66-char hex compressed public key.\n\n    >>> receivestealth('af4afaeb40810e5f8abdbb177c31a2d310913f91cf556f5350bca10cbfe8b9ec', \\\n    'd39758028e201e8edf6d6eec6910ae4038f9b1db3f2d4e2d109ed833be94a026', \\\n    '03b8a715c9432b2b52af9d58aaaf0ccbdefe36d45e158589ecc21ba2f064ebb315')\n    '6134396c3bc9a56ccaf80cd38728e6d3a7751524246e7924b21b08b0bfcc3cc4'\n    '''\n\n    return addprivkeys(sha256(multiplypub(ephempub,scanpriv,True)),spendpriv)", "response": "Return the private key for a stealth payment using the scan and spend private keys and ephemeral public keys."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nopen the rendered markdown file locally in a browser.", "response": "def preview_file(post):\n    \"\"\"\n    Opens the rendered markdown file (as html) locally in a browser.\n    \"\"\"\n    with open(post) as f:\n        content = f.read()\n    title = os.path.basename(post)\n    Preview(title, content).preview()"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\npass an HTTP request on to another server.", "response": "def proxy(request):\n    \"\"\"Pass an HTTP request on to another server.\"\"\"\n\n    # TODO: don't hardcode http\n    uri = \"http://\" + HOST + request.META['PATH_INFO']\n    if request.META['QUERY_STRING']:\n        uri += '?' + request.META['QUERY_STRING']\n\n    headers = {}\n    for name, val in six.iteritems(request.environ):\n        if name.startswith('HTTP_'):\n            name = header_name(name)\n            headers[name] = val\n\n    # TODO: try/except\n    http = Http()\n    http.follow_redirects = False\n    logger.debug(\"GET for: %s\" % uri)\n    info, content = http.request(uri, 'GET', headers=headers)\n    response = HttpResponse(content, status=info.pop('status'))\n\n    for name, val in info.items():\n        if not is_hop_by_hop(name):\n            response[name] = val\n    logger.info(\"PROXY to: %s\" % uri)\n    return response"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef header_name(name):\n\n    words = name[5:].split('_')\n    for i in range(len(words)):\n        words[i] = words[i][0].upper() + words[i][1:].lower()\n    result = '-'.join(words)\n    return result", "response": "Convert header name like HTTP_XXXX_XXX to Xxxx - Xxx"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef cycle_generator(cycle, step=1, begin=(0, 0), end=None):\n    '''\n        Generates pairs of values representing a cycle. E.g. clock hours for a day could\n        could be generated with:\n            _cycle_generator(cycle=(1, 12), step=1, begin=(0, 1), end=(23, 12))\n                => (0, 1), (0, 2) ... (0, 12), (1, 1), (1, 2)\n    '''\n    (cycle_begin, cycle_end) = cycle\n    (major, minor) = begin\n    (end_major, end_minor) = end if end is not None else (None, None)\n\n    while True:\n        if end is not None and (major > end_major or (major == end_major and minor > end_minor)):\n            return\n        yield (major, minor)\n        minor += step\n        if minor > cycle_end:\n            major += 1\n            minor = cycle_begin", "response": "Generator that generates pairs of values representing a cycle."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef tabulate(data, header=True, headers=None, accessors=None,\n             **table_options):\n    \"\"\" Shortcut function to produce tabular output of data without the\n    need to create and configure a Table instance directly. The function\n    does however return a table instance when it's done for any further use\n    by the user. \"\"\"\n    if header and not headers:\n        data = iter(data)\n        try:\n            headers = next(data)\n        except StopIteration:\n            pass\n    if headers and hasattr(headers, 'items') and accessors is None:\n        # Dict mode; Build accessors and headers from keys of data.\n        data = itertools.chain([headers], data)\n        accessors = list(headers)\n        headers = [' '.join(map(str.capitalize, x.replace('_', ' ').split()))\n                   for x in accessors]\n    t = Table(headers=headers, accessors=accessors, **table_options)\n    try:\n        t.print(data)\n    except RowsNotFound:\n        pass\n    return t", "response": "Generates a tabular table instance from a list of data."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nattach argparse arguments to an argparse parser.", "response": "def attach_arguments(cls, parser, prefix='--', skip_formats=False,\n                         format_excludes=None, format_title=None,\n                         format_desc=None, skip_render=False,\n                         render_excludes=None, render_title=None,\n                         render_desc=None, skip_filters=False,\n                         filter_excludes=None, filter_title=None,\n                         filter_desc=None):\n        \"\"\" Attach argparse arguments to an argparse parser/group with table\n        options.  These are renderer options and filtering options with the\n        ability to turn off headers and footers.  The return value is function\n        that parses an argparse.Namespace object into keyword arguments for a\n        layout.Table constructor. \"\"\"\n        convs = []\n        if not skip_formats:\n            attach = cls.attach_format_arguments\n            convs.append(attach(parser, prefix, format_excludes, format_title,\n                                format_desc))\n        if not skip_render:\n            attach = cls.attach_render_arguments\n            convs.append(attach(parser, prefix, render_excludes, render_title,\n                                render_desc))\n        if not skip_filters:\n            attach = cls.attach_filter_arguments\n            convs.append(attach(parser, prefix, filter_excludes, filter_title,\n                                filter_desc))\n\n        def argparse_ns_to_table_opts(ns):\n            options = {}\n            for conv in convs:\n                options.update(conv(ns))\n            return options\n        return argparse_ns_to_table_opts"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef make_accessors(self, columns):\n        accessors = list(self.accessors_def or range(columns))\n        for i, x in enumerate(accessors):\n            if not callable(x):\n                if isinstance(x, collections.abc.Sequence) and \\\n                   not isinstance(x, str):\n                    key, default = x\n                else:\n                    key = x\n                    default = ''\n\n                def acc(row, key=key, default=default):\n                    try:\n                        return row[key]\n                    except (KeyError, IndexError):\n                        return default\n                accessors[i] = acc\n        return accessors", "response": "Make the list of accessors that can be used to access the keys in the table."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a full format columns spec dictionary.", "response": "def create_colspec(self, columns, overflow_default=None):\n        \"\"\" Produce a full format columns spec dictionary.  The overrides spec\n        can be a partial columns spec as described in the __init__ method's\n        depiction of the .columns attribute. \"\"\"\n        spec = [{\n            \"width\": None,\n            \"minwidth\": self.column_minwidth,\n            \"padding\": self.column_padding,\n            \"align\": self.column_align,\n            \"overflow\": self.overflow or overflow_default\n        } for x in range(columns)]\n        if self.columns_def:\n            for dst, src in zip(spec, self.columns_def):\n                if hasattr(src, 'items'):\n                    dst.update(src)\n                else:\n                    dst['width'] = src\n        return spec"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nwrites the data to our output stream.", "response": "def print(self, rows):\n        \"\"\" Write the data to our output stream (stdout).  If the table is not\n        rendered yet, we will make a renderer instance which will freeze\n        state. \"\"\"\n        if not self.default_renderer:\n            self.default_renderer = self.make_renderer()\n        self.default_renderer.print(rows)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef render_filter(self, next_filter):\n        next(next_filter)\n        while True:\n            data = (yield)\n            res = [self.cell_format(access(data)) for access in self.accessors]\n            next_filter.send(res)", "response": "Produce formatted output from the raw data stream."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef viewable_width(self):\n        return sum(self.widths) + sum(x['padding'] for x in self.colspec)", "response": "The available combined character width when all padding is removed."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nformatting and print the pre - rendered data to the output device.", "response": "def print_row(self, row, rstrip=True):\n        \"\"\" Format and print the pre-rendered data to the output device. \"\"\"\n        line = ''.join(map(str, row))\n        print(line.rstrip() if rstrip else line, file=self.table.file)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef format_row(self, row):\n        assert all(isinstance(x, VTMLBuffer) for x in row)\n        raw = (fn(x) for x, fn in zip(row, self.formatters))\n        for line in itertools.zip_longest(*raw):\n            line = list(line)\n            for i, col in enumerate(line):\n                if col is None:\n                    line[i] = self._get_blank_cell(i)\n            yield line", "response": "Apply overflow justification and padding to a row."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef format_fullwidth(self, value):\n        assert isinstance(value, VTMLBuffer)\n        pad = self.colspec[0]['padding']\n        fmt = self.make_formatter(self.width - pad, pad,\n                                  self.table.title_align)\n        return VTMLBuffer('\\n').join(fmt(value))", "response": "Return a full width column."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef make_formatter(self, width, padding, alignment, overflow=None):\n        if overflow is None:\n            overflow = self.overflow_default\n        if overflow == 'clip':\n            overflower = lambda x: [x.clip(width, self.table.cliptext)]\n        elif overflow == 'wrap':\n            overflower = lambda x: x.wrap(width)\n        elif overflow == 'preformatted':\n            overflower = lambda x: x.split('\\n')\n        else:\n            raise RuntimeError(\"Unexpected overflow mode: %r\" % overflow)\n        align = self.get_aligner(alignment, width)\n        pad = self.get_aligner('center', width + padding)\n        return lambda value: [pad(align(x)) for x in overflower(value)]", "response": "Create a formatter function that factors the width and alignment\n        settings."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef make_formatters(self):\n        return [self.make_formatter(inner_w, spec['padding'], spec['align'],\n                                    spec['overflow'])\n                for spec, inner_w in zip(self.colspec, self.widths)]", "response": "Create a list of formatter functions for each column."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nproduces a uniform distribution of total across a list of of spread size. The result is non - random and uniform.", "response": "def _uniform_dist(self, spread, total):\n        \"\"\" Produce a uniform distribution of `total` across a list of\n        `spread` size. The result is non-random and uniform. \"\"\"\n        fraction, fixed_increment = math.modf(total / spread)\n        fixed_increment = int(fixed_increment)\n        balance = 0\n        dist = []\n        for _ in range(spread):\n            balance += fraction\n            withdrawl = 1 if balance > 0.5 else 0\n            if withdrawl:\n                balance -= withdrawl\n            dist.append(fixed_increment + withdrawl)\n        return dist"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef format_row_filter(self, next_filter):\n        next(next_filter)\n        while True:\n            items = (yield)\n            assert all(isinstance(x, VTMLBuffer) for x in items)\n            raw = (fn(x) for x, fn in zip(items, self.formatters))\n            for x in itertools.zip_longest(*raw):\n                next_filter.send(x)", "response": "Apply overflow justification padding and expansion to a row."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ntops - align column data irrespective of original row alignment.", "response": "def _column_pack_filter(self, next_filter):\n        \"\"\" Top-align column data irrespective of original row alignment.  E.g.\n            INPUT: [\n                [\"1a\", \"2a\"],\n                [None, \"2b\"],\n                [\"1b\", \"2c\"],\n                [None, \"2d\"]\n            ]\n            OUTPUT: [\n                [\"1a\", \"2a\"],\n                [\"1b\", \"2b\"],\n                [<blank>, \"2c\"],\n                [<blank>, \"2d\"]\n            ]\n        \"\"\"\n        next(next_filter)\n        col_count = len(self.widths)\n        queues = [collections.deque() for _ in range(col_count)]\n        while True:\n            try:\n                row = (yield)\n            except GeneratorExit:\n                break\n            for col, queue in zip(row, queues):\n                if col is not None:\n                    queue.append(col)\n            if all(queues):\n                next_filter.send([x.popleft() for x in queues])\n        blanks = list(map(self._get_blank_cell, range(col_count)))\n        while any(queues):\n            next_filter.send([q.popleft() if q else blank\n                              for q, blank in zip(queues, blanks)])"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _column_pad_filter(self, next_filter):\n        next(next_filter)\n        while True:\n            line = list((yield))\n            for i, col in enumerate(line):\n                if col is None:\n                    line[i] = self._get_blank_cell(i)\n            next_filter.send(line)", "response": "Expand blank lines caused from overflow of other columns to blank\n            whitespace."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nhandles a width style which can be a fractional number representing a percentage of available width or positive integers representing a positive width.", "response": "def width_normalize(self, width):\n        \"\"\" Handle a width style, which can be a fractional number\n        representing a percentage of available width or positive integers\n        which indicate a fixed width. \"\"\"\n        if width is not None:\n            if width > 0 and width < 1:\n                return int(width * self.usable_width)\n            else:\n                return int(width)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nscanning data returning the best width for each column given the max_width constraint.", "response": "def calc_flex(self, data, max_width, cols, preformatted=None):\n        \"\"\" Scan data returning the best width for each column given the\n        max_width constraint.  If some columns will overflow we calculate the\n        best concession widths. \"\"\"\n        if preformatted is None:\n            preformatted = []\n        colstats = []\n        for i in cols:\n            lengths = [len(xx) for x in data\n                       for xx in x[i].text().splitlines()]\n            if self.headers:\n                lengths.append(len(self.headers[i]))\n            lengths.append(self.width_normalize(self.colspec[i]['minwidth']))\n            counts = collections.Counter(lengths)\n            colstats.append({\n                \"column\": i,\n                \"preformatted\": i in preformatted,\n                \"counts\": counts,\n                \"offt\": max(lengths),\n                \"chop_mass\": 0,\n                \"chop_count\": 0,\n                \"total_mass\": sum(a * b for a, b in counts.items())\n            })\n        self.adjust_widths(max_width, colstats)\n        required = sum(x['offt'] for x in colstats)\n        justify = self.table.justify if self.table.justify is not None else \\\n            self.justify_default\n        if required < max_width and justify:\n            # Fill remaining space proportionately.\n            remaining = max_width\n            for x in colstats:\n                x['offt'] = int((x['offt'] / required) * max_width)\n                remaining -= x['offt']\n            if remaining:\n                dist = self._uniform_dist(len(cols), remaining)\n                for adj, col in zip(dist, colstats):\n                    col['offt'] += adj\n        return [(x['column'], x['offt']) for x in colstats]"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadjusts column widths based on the least negative affect it will have on the viewing experience.", "response": "def adjust_widths(self, max_width, colstats):\n        \"\"\" Adjust column widths based on the least negative affect it will\n        have on the viewing experience.  We take note of the total character\n        mass that will be clipped when each column should be narrowed.  The\n        actual score for clipping is based on percentage of total character\n        mass, which is the total number of characters in the column. \"\"\"\n        adj_colstats = []\n        for x in colstats:\n            if not x['preformatted']:\n                adj_colstats.append(x)\n            else:\n                max_width -= x['offt']\n        next_score = lambda x: (x['counts'][x['offt']] + x['chop_mass'] +\n                                x['chop_count']) / x['total_mass']\n        cur_width = lambda: sum(x['offt'] for x in adj_colstats)\n        min_width = lambda x: self.width_normalize(\n            self.colspec[x['column']]['minwidth'])\n        while cur_width() > max_width:\n            nextaffects = [(next_score(x), i)\n                           for i, x in enumerate(adj_colstats)\n                           if x['offt'] > min_width(x)]\n            if not nextaffects:\n                break  # All columns are as small as they can get.\n            nextaffects.sort()\n            chop = adj_colstats[nextaffects[0][1]]\n            chop['chop_count'] += chop['counts'][chop['offt']]\n            chop['chop_mass'] += chop['chop_count']\n            chop['offt'] -= 1"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef make_key(self, value):\n        if value:\n            parts = [self.key_filter.sub('', x)\n                     for x in self.key_split.split(value.lower())]\n            key = parts[0] + ''.join(map(str.capitalize, parts[1:]))\n        else:\n            key = ''\n        if key in self.seen_keys:\n            i = 1\n            while '%s%d' % (key, i) in self.seen_keys:\n                i += 1\n            key = '%s%d' % (key, i)\n        self.seen_keys.add(key)\n        return key", "response": "Make camelCase variant of value."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nbuild a validator that only checks the type of a value.", "response": "def _build_type_validator(value_type):\n    \"\"\"Build a validator that only checks the type of a value.\"\"\"\n\n    def type_validator(data):\n        \"\"\"Validate instances of a particular type.\"\"\"\n        if isinstance(data, value_type):\n            return data\n\n        raise NotValid('%r is not of type %r' % (data, value_type))\n\n    return type_validator"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nbuilding a validator that checks if the data is equal to an exact value.", "response": "def _build_static_validator(exact_value):\n    \"\"\"Build a validator that checks if the data is equal to an exact value.\"\"\"\n\n    def static_validator(data):\n        \"\"\"Validate by equality.\"\"\"\n        if data == exact_value:\n            return data\n\n        raise NotValid('%r is not equal to %r' % (data, exact_value))\n\n    return static_validator"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nbuilding a callable validator that checks the return value of function ( data ).", "response": "def _build_callable_validator(function):\n    \"\"\"Build a validator that checks the return value of function(data).\"\"\"\n\n    def callable_validator(data):\n        \"\"\"Validate by checking the return value of function(data).\"\"\"\n        try:\n            if function(data):\n                return data\n\n        except (TypeError, ValueError, NotValid) as ex:\n            raise NotValid(ex.args)\n\n        raise NotValid(\"%r invalidated by '%s'\" % (data, _get_repr(function)))\n\n    return callable_validator"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nbuilding a validator from an iterable.", "response": "def _build_iterable_validator(iterable):\n    \"\"\"Build a validator from an iterable.\"\"\"\n    sub_schemas = [parse_schema(s) for s in iterable]\n\n    def item_validator(value):\n        \"\"\"Validate items in an iterable.\"\"\"\n        for sub in sub_schemas:\n            try:\n                return sub(value)\n\n            except NotValid:\n                pass\n\n        raise NotValid('%r invalidated by anything in %s.' % (value, iterable))\n\n    def iterable_validator(data):\n        \"\"\"Validate an iterable.\"\"\"\n        if not type(data) is type(iterable):\n            raise NotValid('%r is not of type %s' % (data, type(iterable)))\n\n        return type(iterable)(item_validator(value) for value in data)\n\n    return iterable_validator"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndetermines the different kinds of keys.", "response": "def _determine_keys(dictionary):\n    \"\"\"Determine the different kinds of keys.\"\"\"\n    optional = {}\n    defaults = {}\n    mandatory = {}\n    types = {}\n    for key, value in dictionary.items():\n        if isinstance(key, Optional):\n            optional[key.value] = parse_schema(value)\n            if isinstance(value, BaseSchema) and\\\n                    value.default is not UNSPECIFIED:\n                defaults[key.value] = (value.default, value.null_values)\n            continue  # pragma: nocover\n\n        if type(key) is type:\n            types[key] = parse_schema(value)\n            continue\n\n        mandatory[key] = parse_schema(value)\n    return mandatory, optional, types, defaults"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _validate_mandatory_keys(mandatory, validated, data, to_validate):\n    errors = []\n    for key, sub_schema in mandatory.items():\n        if key not in data:\n            errors.append('missing key: %r' % (key,))\n            continue\n        try:\n            validated[key] = sub_schema(data[key])\n        except NotValid as ex:\n            errors.extend(['%r: %s' % (key, arg) for arg in ex.args])\n        to_validate.remove(key)\n    return errors", "response": "Validate the manditory keys."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _validate_optional_key(key, missing, value, validated, optional):\n    try:\n        validated[key] = optional[key](value)\n    except NotValid as ex:\n        return ['%r: %s' % (key, arg) for arg in ex.args]\n    if key in missing:\n        missing.remove(key)\n    return []", "response": "Validate an optional key."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nvalidates a key s value by type.", "response": "def _validate_type_key(key, value, types, validated):\n    \"\"\"Validate a key's value by type.\"\"\"\n    for key_schema, value_schema in types.items():\n        if not isinstance(key, key_schema):\n            continue\n        try:\n            validated[key] = value_schema(value)\n        except NotValid:\n            continue\n        else:\n            return []\n\n    return ['%r: %r not matched' % (key, value)]"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _validate_other_keys(optional, types, missing, validated, data,\n                         to_validate):\n    \"\"\"Validate the rest of the keys present in the data.\"\"\"\n    errors = []\n    for key in to_validate:\n        value = data[key]\n        if key in optional:\n            errors.extend(\n                _validate_optional_key(\n                    key, missing, value, validated, optional))\n            continue\n        errors.extend(_validate_type_key(key, value, types, validated))\n    return errors", "response": "Validate the rest of the keys present in the data."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _build_dict_validator(dictionary):\n    mandatory, optional, types, defaults = _determine_keys(dictionary)\n\n    def dict_validator(data):\n        \"\"\"Validate dictionaries.\"\"\"\n        missing = list(defaults.keys())\n        if not isinstance(data, dict):\n            raise NotValid('%r is not of type dict' % (data,))\n\n        validated = {}\n        to_validate = list(data.keys())\n        errors = _validate_mandatory_keys(\n            mandatory, validated, data, to_validate)\n        errors.extend(\n            _validate_other_keys(\n                optional, types, missing, validated, data, to_validate))\n        if errors:\n            raise NotValid(*errors)\n        for key in missing:\n            validated[key] = defaults[key][0]\n\n        return validated\n\n    return dict_validator", "response": "Build a validator function from a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nparse a val schema definition.", "response": "def parse_schema(schema):\n    \"\"\"Parse a val schema definition.\"\"\"\n\n    if isinstance(schema, BaseSchema):\n        return schema.validate\n\n    if type(schema) is type:\n        return _build_type_validator(schema)\n\n    if isinstance(schema, dict):\n        return _build_dict_validator(schema)\n\n    if type(schema) in (list, tuple, set):\n        return _build_iterable_validator(schema)\n\n    if callable(schema):\n        return _build_callable_validator(schema)\n\n    return _build_static_validator(schema)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef validate(self, data):\n        validated = self._validated(data)\n        errors = []\n        for validator in self.additional_validators:\n            if not validator(validated):\n                errors.append(\n                    \"%s invalidated by '%s'\" % (\n                        validated, _get_repr(validator)))\n        if errors:\n            raise NotValid(*errors)\n\n        if self.default is UNSPECIFIED:\n            return validated\n\n        if self.null_values is not UNSPECIFIED\\\n                and validated in self.null_values:\n            return self.default\n\n        if validated is None:\n            return self.default\n\n        return validated", "response": "Validate data. Raise NotValid error for invalid data."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _validated(self, data):\n        errors = []\n        for sub in self.schemas:\n            try:\n                return sub(data)\n            except NotValid as ex:\n                errors.extend(ex.args)\n\n        raise NotValid(' and '.join(errors))", "response": "Validate data if any subschema validates it."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nvalidates data if all subschemas validate it.", "response": "def _validated(self, data):\n        \"\"\"Validate data if all subschemas validate it.\"\"\"\n        for sub in self.schemas:\n            data = sub(data)\n        return data"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _validated(self, data):\n        try:\n            return self.convert(data)\n        except (TypeError, ValueError) as ex:\n            raise NotValid(*ex.args)", "response": "Convert data or die trying."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _validated(self, values):\n        if self.length != len(values):\n            raise NotValid(\n                \"%r does not have exactly %d values. (Got %d.)\" % (\n                    values, self.length, len(values)))\n        return type(self.schemas)(\n            self.schemas[i].validate(v) for i, v in enumerate(values))", "response": "Validate if the values are validated one by one in order."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfinds one element matching condition and value.", "response": "def find_element(self, by, value, view_cls=None):\n        # type: (By, Any, View) -> View\n        \"\"\"\n        Find one element matching condition\n        :param by: Type of condition\n        :param value: Condition value\n        :param view_cls: Optional custom class to wrap returned elements\n        :return: Matching element wrapped in a view\n        \"\"\"\n        if view_cls is None:\n            view_cls = View\n\n        return view_cls(lambda: self.driver.find_element(by, value))"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nfind one element matching condition by value and return a view of that element.", "response": "def find_element(self, by, value, view_cls=None):\n        # type: (By, Any, View) -> View\n        \"\"\"\n        Find one element matching condition\n        :param by: Type of condition\n        :param value: Condition value\n        :param view_cls: Optional custom class to wrap returned elements\n        :return: Matching element wrapped in a view\n        \"\"\"\n        if view_cls is None:\n            view_cls = View\n\n        return view_cls(lambda: self.root.find_element(by, value))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef find_elements(self, by, value, view_cls=None):\n        # type: (By, Any, Value) -> List[View]\n        \"\"\"\n        Find one or more elements matching condition\n        :param by: Type of condition\n        :param value: Condition value\n        :param view_cls: Optional custom class to wrap returned elements\n        :return: List of matching web elements wrapped in a view\n        \"\"\"\n        if view_cls is None:\n            view_cls = View\n\n        def get_elements():\n            results = []\n\n            try:\n                results = self.root.find_elements(by, value)\n            except NoSuchElementException:\n                pass\n            finally:\n                return results\n\n        def get_element_at_index(i):\n            return lambda: get_elements()[i]\n\n        return [view_cls(get_element_at_index(i)) for i, element in enumerate(get_elements())]", "response": "Find one or more web elements matching condition\n            and value."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nestablish the actual TCP connection to FB", "response": "def _connectToFB(self):\n        \"\"\"Establish the actual TCP connection to FB\"\"\"\n\n        if self.connected_to_fb:\n            logger.debug(\"Already connected to fb\")\n            return True\n\n        logger.debug(\"Connecting to fb\")\n\n        token = facebook_login.get_fb_token()\n\n        try:\n            self.fb = facebook.GraphAPI(token)\n        except:\n            print(\"Couldn't connect to fb\")\n            return False\n\n        self.connected_to_fb=True\n\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _isConfigFile(self,filename):\n        ext=os.path.splitext(filename)[1].lower()\n        if filename in self.FB_CONFIG_FILES:\n            return True\n        elif ext in self.FB_META_EXTENSIONS:\n            return True\n        return False", "response": "Returns True if this is a config file or meta file."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef KnowsFile(self,filename):\n        if self._isMediaFile(filename) or self._isConfigFile(filename):\n            return True\n        return False", "response": "Looks at extension and decides if it knows\n        how to manage this file"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef Upload(self,directory,filename):\n        if self._isMediaFile(filename):\n            return self._upload_media(directory,filename)\n        elif self._isConfigFile(filename):\n            return self._update_config(directory,filename)\n\n        print \"Not handled!\"\n        return False", "response": "Uploads a file to the specified directory."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nremove a file from the FB", "response": "def Remove(self,directory,filename):\n        \"\"\"Deletes files from fb\"\"\"\n        if self._isMediaFile(filename):\n            return self._remove_media(directory,filename)\n        elif self._isConfigFile(filename):\n            return True\n\n        print \"Not handled!\"\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nmanaging FB config files", "response": "def _update_config(self,directory,filename):\n        \"\"\"Manages FB config files\"\"\"\n        basefilename=os.path.splitext(filename)[0]\n        ext=os.path.splitext(filename)[1].lower()\n        #if filename==LOCATION_FILE:\n            #return self._update_config_location(directory)\n        #FIXME\n        #elif filename==TAG_FILE:\n            #return self._update_config_tags(directory)\n        if filename==SET_FILE:\n            print(\"%s - Moving photos to album\"%(filename))\n            return self._upload_media(directory,movealbum_request=True)\n        elif filename==MEGAPIXEL_FILE:\n            print(\"%s - Resizing photos\"%(filename))\n            return self._upload_media(directory,resize_request=True)\n        elif ext in self.FB_META_EXTENSIONS:\n            print(\"%s - Changing photo title\"%(basefilename))\n            return self._upload_media(directory,basefilename,changetitle_request=True)\n\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _get_title(self,directory,filename):\n        # =========== LOAD TITLE ========\n        fullfile=os.path.join(directory,filename+'.title')\n        try:\n            logger.debug('trying to open [%s]'%(fullfile))\n            _title=(open(fullfile).readline().strip())\n            logger.debug(\"_updatemeta: %s - title is '%s'\",filename,_title)\n        except:\n            _title=''\n\n        return _title", "response": "Loads image title if any"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _load_megapixels(self,directory):\n        #FIXME: should check if DB tracking file before using it\n\n        fullfile=os.path.join(directory,MEGAPIXEL_FILE)\n        try:\n            mp=float(open(fullfile).readline())\n            logger.debug(\"_load_megapixel: MP from file is %f\",mp)\n        except:\n            logger.warning(\"Couldn't open image size file in %s, not scaling images\"\\\n                    %(directory))\n            return None\n\n        return mp", "response": "Opens megapixel file and returns the image size in the specified directory."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nloading sets from set file and return as list of strings", "response": "def _load_sets(self,directory):\n        \"\"\"Loads sets from set file and return\n        as list of strings\n        \"\"\"\n        # --- Read sets out of file\n        _sets=[]\n        try:\n            fullfile=os.path.join(directory,SET_FILE)\n            lsets=open(fullfile).readline().split(',')\n            for tag in lsets:\n                _sets.append(tag.strip())\n        except:\n            logger.error(\"No sets found in %s, FB needs an album name (%s)\"\\\n                    %(directory,SET_FILE))\n            sys.exit(1)\n\n        return _sets"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate a photo set on FB", "response": "def _createphotoset(self,myset):\n        \"\"\"Creates a photo set (album) on FB\"\"\"\n        if not self._connectToFB():\n            print(\"%s - Couldn't connect to fb\"%(directory))\n            return False\n        \n        logger.debug('fb: Creating photo set %s' %(myset))\n        resp=self.fb.put_object(USER_ID,\"albums\",name=myset)\n\n        if not resp.has_key('id'):\n            logger.error(\"%s - fb: _createphotoset failed to create album\",\\\n                    myset);\n            return False\n        else:\n            return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nloads album name from SET_FILE creates album if it doesn t exist creates album if it doesn t exist returns album id and album name", "response": "def _get_album(self,directory):\n        \"\"\"\n        Loads set name from SET_FILE, looks up album_id on fb, \n        it it doesn't exists, creates album. Returns album id and album name\n        \"\"\"\n        if not self._connectToFB():\n            print(\"%s - Couldn't connect to fb\"%(directory))\n            return None,None\n\n\n        # Load sets from SET_FILE\n        _sets=self._load_sets(directory)\n\n        # Only grab the first set, FB supports only one set per photo\n        myset=_sets[0]\n\n        logger.debug(\"Getting album id for %s\"%(myset))\n\n        # Connect to fb and get dicionary of photosets\n        psets=self._getphotosets()\n\n        # create if it doesn't exist\n        if myset not in psets:\n            logger.info('set [%s] not in fb sets, will create set'%(myset))\n            self._createphotoset(myset)\n            # Now reaload photosets from fb\n            psets=self._getphotosets()\n\n        # Return the album id, album name\n        return psets[myset]['id'],myset"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _getphoto_originalsize(self,pid):\n        logger.debug('%s - Getting original size from fb'%(pid))\n        i=self.fb.get_object(pid)\n        width=i['images'][0]['width']\n        height=i['images'][0]['height']\n        return (width,height)", "response": "Asks fb for photo original size returns tuple with width height"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _getphoto_location(self,pid):\n\n        logger.debug('%s - Getting location from fb'%(pid))\n\n        lat=None\n        lon=None\n        accuracy=None\n\n        resp=self.fb.photos_geo_getLocation(photo_id=pid)\n        if resp.attrib['stat']!='ok':\n            logger.error(\"%s - fb: photos_geo_getLocation failed with status: %s\",\\\n                    resp.attrib['stat']);\n            return (None,None,None)\n        \n        for location in resp.find('photo'):\n            lat=location.attrib['latitude']\n            lon=location.attrib['longitude']\n            accuracy=location.attrib['accuracy']\n            \n                \n        return (lat,lon,accuracy)", "response": "Asks fb for photo location information about the given object and returns tuple with lat lon accuracy"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _remove_media(self,directory,files=None):\n        # Connect if we aren't already\n        if not self._connectToFB():\n            logger.error(\"%s - Couldn't connect to fb\")\n            return False\n\n        db=self._loadDB(directory)\n        # If no files given, use files from DB in dir\n        if not files:\n            files=db.keys()\n\n        #If only one file given, make it a list\n        if isinstance(files,basestring):\n            files=[files]\n\n        for fn in files:\n            print(\"%s - Deleting from fb [local copy intact]\"%(fn))\n\n            try:\n                pid=db[fn]['photoid']\n            except:\n                logger.debug(\"%s - Was never in fb DB\"%(fn))\n                continue\n            try:\n                self.fb.delete_object(pid)\n            except facebook.GraphAPIError as e:\n                print(\"%s - fb: delete failed with status: %s:%s\"\\\n                        %(fn,e.type,e.message))\n                return False\n\n            logger.debug('Removing %s from fb DB'%(fn))\n            del db[fn]\n            self._saveDB(directory,db)\n\n        return True", "response": "Removes specified files from fb DB"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nupload media to FB returns True if successfully uploaded False if not already uploaded Will replace if already uploaded Will replace if already uploaded Will replace if already uploaded Will replace scale photos before upload", "response": "def _upload_media(self,directory,files=None,resize_request=None, \\\n            movealbum_request=None,changetitle_request=None):\n        \"\"\"Uploads media file to FB, returns True if\n        uploaded successfully, Will replace \n        if already uploaded, If megapixels > 0, will\n        scale photos before upload\n        If no filename given, will go through all files in DB\"\"\"\n        # Connect if we aren't already\n        if not self._connectToFB():\n            logger.error(\"%s - Couldn't connect to fb\")\n            return False\n\n        _megapixels=self._load_megapixels(directory)\n\n        # Get an album ID (create album if not exists)\n        _album_id,_album_name=self._get_album(directory)\n\n        if not _megapixels:\n            mpstring=\"original\"\n        else:\n            mpstring=(\"%0.1f MP\"%(_megapixels))\n\n        # If no files given, use files from DB in dir\n        if not files:\n            db=self._loadDB(directory)\n            files=db.keys()\n\n        #If only one file given, make it a list\n        if isinstance(files,basestring):\n            files=[files]\n\n        files.sort()\n\n        for filename in files:\n\n            # Get title here if any\n            title=self._get_title(directory,filename)\n\n            if title:\n                print(\"%s - Uploading to fb, album[%s] size=%s title=%s\"\\\n                        %(filename,_album_name,mpstring,title))\n            else:\n                print(\"%s - Uploading to fb, album[%s] size=%s\"\\\n                        %(filename,_album_name,mpstring))\n\n            status=self._upload_or_replace_fb(directory,filename, \\\n                    _album_id, _megapixels,resize_request,movealbum_request,\\\n                    changetitle_request,title)\n            if not status:\n                return False\n\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ndo the actual upload of a picture to the FB.", "response": "def _upload_or_replace_fb(self,directory,fn,_album_id,\\\n            _megapixels=None,resize_request=None,movealbum_request=None,\\\n            changetitle_request=None,_title=None):\n        \"\"\"Does the actual upload to fb.\n        if resize_request, will resize picture only if\n        it already exists and the geometry on fb doesn't match\n        what we want,\n        returns (status)\"\"\"\n        # We should check here if \n        db=self._loadDB(directory)\n\n        # If resize request, make tempfile and\n        # resize.\n        if _megapixels:\n            fp = tempfile.NamedTemporaryFile()\n            fullfile_resized=fp.name\n            logger.debug(\"tempfile for resized is %s\"%(fp.name))\n\n        fullfile=os.path.join(directory,fn)\n\n        # If JPEG, then resize\n        ext=os.path.splitext(fullfile)[1].lower()\n        if ext=='.jpg':\n            isJPG=True\n        else:\n            isJPG=False\n\n        # If already in DB, remove first, then overwrite\n        if fn in db:\n            pid=db[fn]['photoid']\n            if resize_request and isJPG:\n                logger.info(\"fb: Resize request for %s\",fn)\n                if self._already_resized_on_fb(fullfile,pid,_megapixels):\n                    logger.debug(\"%s - Already in DB and resized, skipping\",fn)\n                    return True\n            elif movealbum_request:\n                logger.info(\"fb: Move album request for %s\",fn)\n                if self._already_in_album(fullfile,pid,_album_id):\n                    logger.debug(\"%s - Already in DB and in correct album, skipping\",fn)\n                    return True\n            elif changetitle_request:\n                logger.info(\"fb: Change title request for %s\",fn)\n                if self._title_uptodate(fullfile,pid,_title):\n                    logger.debug(\"%s - Already in DB and title up to date, skipping\",fn)\n                    return True\n\n\n            # --- If we are here it means photo should be updated.\n            # With FB graph API this means removing the photo\n            # and uploading with new meta data.\n            logger.debug(\"%s - Already in DB, removing first\",fn)\n            if not self._remove_media(directory,fn):\n                logger.error(\"%s - fb: couldn't replace (remove) file\\n\",fn)\n                return False\n\n        # Do we have to resize?\n        if _megapixels and isJPG:\n            if pusher_utils.resize_image(fullfile,fullfile_resized,_megapixels):\n                logger.debug(\"%s resized to %s successfully\"\\\n                        %(fullfile,fullfile_resized))\n                fullfile=fullfile_resized\n            else:\n                logger.warning(\"%s couldn't resize, uploading original\"\\\n                        %(fullfile))\n\n        logger.debug(\"Upload %s to fb, album=%s, title='%s'\",\\\n                fn,_album_id,_title)\n\n        # We can get a place id by doing a search\n        # http://graph.facebook.com/search?type=city&center=37,-122&distance=1000\n\n        # Do the actual upload\n        resp=self.fb.put_photo(open(fullfile),\\\n                message=_title,album_id=_album_id,\\\n                )\n                #place='106377336067638'\\\n\n        logger.debug(\"%s - Upload response is : %s\"%(fn,resp))\n\n        if not resp.has_key('id'):\n            print(\"%s - fb: upload failed\", fn)\n            return False\n\n        pid=resp['id']\n        db[fn]={}\n        db[fn]['photoid']=pid\n        logger.debug(\"%s - fb: uploaded with photoid %s\",fn,pid);\n\n        self._saveDB(directory,db)\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nchecking fb photo title against provided title returns true if they match", "response": "def _title_uptodate(self,fullfile,pid,_title):\n        \"\"\"Check fb photo title against provided title,\n        returns true if they match\"\"\"\n        i=self.fb.get_object(pid)\n        if i.has_key('name'):\n            if _title == i['name']:\n                return True\n\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncheck to see if a photo with given pid is already in the album_id returns true if this is the case", "response": "def _already_in_album(self,fullfile,pid,album_id):\n        \"\"\"Check to see if photo with given pid is already\n        in the album_id, returns true if this is the case\n        \"\"\"\n\n        logger.debug(\"fb: Checking if pid %s in album %s\",pid,album_id)\n        pid_in_album=[]\n        # Get all photos in album\n        photos = self.fb.get_connections(str(album_id),\"photos\")['data']\n\n        # Get all pids in fb album\n        for photo in photos:\n            pid_in_album.append(photo['id'])\n\n        logger.debug(\"fb: album %d contains these photos: %s\",album_id,pid_in_album)\n\n        # Check if our pid matches\n        if pid in pid_in_album:\n            return True\n\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nchecks if the image file with photo_id ( pid ) has already been resized on fb. Returns True if so False otherwise.", "response": "def _already_resized_on_fb(self,fn,pid,_megapixels):\n        \"\"\"Checks if image file (fn) with photo_id (pid) has already\n        been resized on fb. If so, returns True\"\"\"\n        logger.debug(\"%s - resize requested\"%(fn))\n        # Get width/height from fb\n        width_fb,height_fb=self._getphoto_originalsize(pid)\n        # Now compute what image will be if we resize it\n        new_width,new_height=pusher_utils.resize_compute_width_height(\\\n                fn,_megapixels)\n        logger.debug(\"%s - fb %d/%d, current %d/%d\"\\\n                %(fn,width_fb,height_fb,new_width,new_height))\n        # Check both cases since FB sometimes rotates photos\n        if width_fb==new_width and height_fb==new_height:\n            return True\n        elif width_fb==new_height and height_fb==new_width:\n            return True\n\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning dictionary of photosets retrieved from Facebook", "response": "def _getphotosets(self):\n        \"\"\"Returns dictionary of photosets retrieved from fb\n        d['title']['number_photos'] : Number of photos\n        d['title']['id']            : ID of photoset\n        d['title']['photo_id']      : ID of primary photo\n        d['title']['url']           : URL to photoset\n        \"\"\"\n        sets={}\n        if not self._connectToFB():\n            print(\"Couldn't connect to fb\")\n            return sets\n\n        # Gets facebook albums\n        psets = self.fb.get_connections(USER_ID,\"albums\")['data']\n        for myset in psets:\n            key=myset['name']\n            sets[key]={}\n            try:\n                sets[key]['number_photos']=int(myset['count'])\n            except:\n                sets[key]['number_photos']=0\n            try:\n                sets[key]['photo_id']=myset['cover_photo']\n            except:\n                sets[key]['photo_id']=None\n\n            sets[key]['id']=int(myset['id'])\n            sets[key]['url']=myset['link']\n\n        return sets"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef PrintSets(self):\n        sets=self._getphotosets()\n        for setname in sets:\n            print(\"%s [%d]\"%(setname,sets[setname]['number_photos']))", "response": "Prints the set name and number of photos in set"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef chdir(__path: str) -> ContextManager:\n    old = os.getcwd()\n    try:\n        os.chdir(__path)\n        yield\n    finally:\n        os.chdir(old)", "response": "Context handler to temporarily switch directories."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef env(**kwargs: Union[Dict[str, str], None]) -> ContextManager:\n    old = os.environ.copy()\n    try:\n        os.environ.clear()\n        # This apparent duplication is because ``putenv`` doesn\u2019t update\n        # ``os.environ``, and ``os.environ`` changes aren\u2019t propagated to\n        # subprocesses.\n        for key, value in old.items():\n            os.environ[key] = value  # NOQA: B003\n            os.putenv(key, value)\n        for key, value in kwargs.items():\n            if value is None:\n                del os.environ[key]\n            else:\n                os.environ[key] = value  # NOQA: B003\n                os.putenv(key, value)\n        yield\n    finally:\n        os.environ.clear()\n        for key, value in old.items():\n            os.environ[key] = value  # NOQA: B003\n            os.putenv(key, value)", "response": "Context handler to temporarily alter environment variables."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndistance to another address", "response": "def distance_to(self, address, measure=\"Miles\", httpclient=None):\n        \"\"\"Distance to another address\n        \"\"\"\n        if isinstance(address, Address) and self.latlng and address.latlng:\n            lat1, lon1 = map(float, self.latlng)\n            lat2, lon2 = map(float, address.latlng)\n        elif self.latlng and type(address) is tuple:\n            lat1, lon1 = map(float, self.latlng)\n            lat2, lon2 = address\n        else:\n            raise ValueError(\":address must be type tuple or Address\")\n            \n        radius = 6371 # km          \n        dlat = math.radians(lat2 - lat1)\n        dlon = math.radians(lon2 - lon1)\n        a = math.sin(dlat / 2) * math.sin(dlat / 2) + math.cos(math.radians(lat1)) \\\n          * math.cos(math.radians(lat2)) * math.sin(dlon / 2) * math.sin(dlon / 2)\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        d = radius * c\n        # d is in kilometers\n        if measure == self.KILOMETERS:\n            return d\n        elif measure == self.METERS:\n            return d / 1000\n        elif measure == self.MILES:\n            return d * .621371\n        else:\n            return d"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ndumps all the data into a JSON file.", "response": "def json_dump_hook(cfg, text: bool=False):\n    \"\"\"\n    Dumps all the data into a JSON file.\n    \"\"\"\n    data = cfg.config.dump()\n\n    if not text:\n        json.dump(data, cfg.fd)\n    else:\n        return json.dumps(data)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef load(self, env=None):\n        self._load()\n        e = env or \\\n            os.environ.get(RUNNING_MODE_ENVKEY, DEFAULT_RUNNING_MODE)\n        if e in self.config:\n            return self.config[e]\n        logging.warn(\"Environment '%s' was not found.\", e)", "response": "Load a section value from the given environment."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nproviding flip view to compare how key value pair is defined in each environment for administrative usage usage.", "response": "def flip(self):\n        \"\"\" Provide flip view to compare how key/value pair is defined in each\n        environment for administrative usage.\n\n        :rtype: dict\n        \"\"\"\n        self._load()\n        groups = self.config.keys()\n        tabular = {}\n        for g in groups:\n            config = self.config[g]\n            for k in config:\n                r = tabular.get(k, {})\n                r[g] = config[k]\n                tabular[k] = r\n        return tabular"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nlist information about a particular file or set of files :param show_details: Whether to show detailed info about files :param cols: specify screen width", "response": "def main(show_details:['-l']=False, cols:['-w', '--width']='', *files):\n    '''\n    List information about a particular file or set of files\n\n    :param show_details: Whether to show detailed info about files\n    :param cols: specify screen width\n    '''\n    print(files)\n    print(show_details)\n    print(cols)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef flip(self):\n\n        maj_count = self.maj_allele_count\n        self.maj_allele_count = self.min_allele_count\n        self.min_allele_count = maj_count\n\n        alleles = self.alleles\n        self.alleles = [alleles[1], alleles[0]]", "response": "Flips the major and minor allele count of the current species."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef random_date():\n    '''Return a valid random date.'''\n    d = datetime.datetime.now().date()\n    d = d - datetime.timedelta(random.randint(20,2001))\n    return d", "response": "Return a valid random date."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef random_md_page():\n    '''Generate random markdown page content..\n\n    If the parameters are zero, instead of a fixed number of elements \n    it uses a random number.\n\n    '''\n    # headers #, ##\n    # blockquote >\n    # lists *\n    # codeblock (indent 4 spaces)\n    # hrule, 3 or more - in a line\n    # emphasis: word surrounded by one * or _\n    lines = []\n    lines.append(\"\\n# \" + random_title(False) + \"\\n\") # add title\n    lines.append(\"\\n\" + random_text(1) + \"\\n\") #and 1 paragraphs\n    for h in range(1,random.randint(2,5)):\n        lines.append(\"\\n## \" + random_title(False) + \"\\n\") # add header\n        lines.append(\"\\n\" + random_paragraphs(random.randint(1,5)) + \"\\n\") #and some paragraphs\n        for sh in range(1,random.randint(1,4)):\n            lines.append(\"\\n### \" + random_title(False) +\"\\n\") # add subheader\n            lines.append(\"\\n\" + random_paragraphs(random.randint(4,13)) + \"\\n\") #and some paragraphs\n    txt = \"\\n\".join(lines)\n    return txt", "response": "Generate random markdown page content."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef create(self, title, **args):\n        # Merge our title as a parameter and JSONify it.\n        data = json.dumps(dict({'title': title}, **args))\n        r = requests.post(\n            \"https://kippt.com/api/lists\",\n            headers=self.kippt.header,\n            data=data\n        )\n        return (r.json())", "response": "Create a new Kippt List."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nrecords - Recommender command line version.", "response": "def cli(config_path, verbose):\n    \"\"\"Record-Recommender command line version.\"\"\"\n    global config, store\n    if not config_path:\n        config_path = '/etc/record_recommender.yml'\n    config = get_config(config_path)\n    setup_logging(config)\n    store = FileStore(config)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nfetch newest PageViews and Downloads.", "response": "def fetch(weeks, force):\n    \"\"\"Fetch newest PageViews and Downloads.\"\"\"\n    weeks = get_last_weeks(weeks)\n    print(weeks)\n    recommender = RecordRecommender(config)\n    recommender.fetch_weeks(weeks, overwrite=force)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndownloads and build the recommendations.", "response": "def update_recommender(ctx, weeks, processes):\n    \"\"\"\n    Download and build the recommendations.\n\n    - Fetch new statistics from the current week.\n    - Generate recommendations.\n    - Update the recommendations.\n    \"\"\"\n    weeks = get_last_weeks(weeks)\n    recommender = RecordRecommender(config)\n    # Redownload incomplete weeks\n    first_weeks = weeks[:2]\n    recommender.fetch_weeks(first_weeks, overwrite=True)\n    # Download missing weeks\n    recommender.fetch_weeks(weeks, overwrite=False)\n\n    print(\"Build Profiles\")\n    ctx.invoke(profiles, weeks=weeks)\n\n    print(\"Generate Recommendations\")\n    ctx.invoke(build, processes=processes)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef profiles(weeks):\n    profiles = Profiles(store)\n    weeks = get_last_weeks(weeks) if isinstance(weeks, int) else weeks\n    print(weeks)\n    profiles.create(weeks)", "response": "Create a new list of profiles for the given number of weeks."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef build(processes):\n    recommender = RecordRecommender(config)\n    recommender.create_all_recommendations(processes, ip_views=True)", "response": "Builds the record recommendations using the number of specified processes."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _bind(self, _descriptor):\n\n        # If the method has a default code, use it\n        self._defcode = getattr(_descriptor.method, '_wsgi_code', 200)\n\n        # Set up content type and serializer\n        self.content_type, self.serializer = _descriptor.serializer(self.req)", "response": "Bind a ResponseObject to a given action descriptor."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _serialize(self):\n\n        # Do something appropriate if the response object is unbound\n        if self._defcode is None:\n            raise exceptions.UnboundResponse()\n\n        # Build the response\n        resp = self.response_class(request=self.req, status=self.code,\n                                   headerlist=self._headers.items())\n\n        # Do we have a body?\n        if self.result:\n            resp.content_type = self.content_type\n            resp.body = self.serializer(self.result)\n\n        # Return the response\n        return resp", "response": "Serialize the ResponseObject. Returns a webob. Response object."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the HTTP response code associated with this ResponseObject.", "response": "def code(self):\n        \"\"\"\n        The HTTP response code associated with this ResponseObject.\n        If instantiated directly without overriding the code, returns\n        200 even if the default for the method is some other value.\n        Can be set or deleted; in the latter case, the default will be\n        restored.\n        \"\"\"\n\n        if self._code is not None:\n            return self._code\n        elif self._defcode is not None:\n            return self._defcode\n        return 200"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a string containing the task failure message.", "response": "def task_failure_message(task_report):\n    \"\"\"Task failure message.\"\"\"\n    trace_list = traceback.format_tb(task_report['traceback'])\n    body = 'Error: task failure\\n\\n'\n    body += 'Task ID: {}\\n\\n'.format(task_report['task_id'])\n    body += 'Archive: {}\\n\\n'.format(task_report['archive'])\n    body += 'Docker image: {}\\n\\n'.format(task_report['image'])\n    body += 'Exception: {}\\n\\n'.format(task_report['exception'])\n    body += 'Traceback:\\n {} {}'.format(\n        string.join(trace_list[:-1], ''), trace_list[-1])\n    return body"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef send_email(self, message):\n        msg = MIMEMultipart()\n        msg['From'] = self.from_address\n        msg['To'] = self.to_address\n        msg['Subject'] = self.title\n        msg.attach(MIMEText('<pre>' + cgi.escape(message) + '</pre>', 'html'))\n        smtp = smtplib.SMTP(self.server, self.port,\n                            timeout=self.timeout)\n        if self.tls_auth:\n            smtp.starttls()\n            smtp.login(self.user, self.password)\n        smtp.sendmail(self.from_address, self.to_address, msg.as_string())\n        smtp.quit()", "response": "Initiate a SMTP session and send an email."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nparsing given JPath into list of dicts describing all of the JPath chunks.", "response": "def jpath_parse(jpath):\n    \"\"\"\n    Parse given JPath into chunks.\n\n    Returns list of dictionaries describing all of the JPath chunks.\n\n    :param str jpath: JPath to be parsed into chunks\n    :return: JPath chunks as list of dicts\n    :rtype: :py:class:`list`\n    :raises JPathException: in case of invalid JPath syntax\n    \"\"\"\n    result = []\n    breadcrumbs = []\n\n    # Split JPath into chunks based on '.' character.\n    chunks = jpath.split('.')\n    for chnk in chunks:\n        match = RE_JPATH_CHUNK.match(chnk)\n        if match:\n            res = {}\n\n            # Record whole match.\n            res['m'] = chnk\n\n            # Record breadcrumb path.\n            breadcrumbs.append(chnk)\n            res['p'] = '.'.join(breadcrumbs)\n\n            # Handle node name.\n            res['n'] = match.group(1)\n\n            # Handle node index (optional, may be omitted).\n            if match.group(2):\n                res['i'] = match.group(3)\n                if str(res['i']) == '#':\n                    res['i'] = -1\n                elif str(res['i']) == '*':\n                    pass\n                else:\n                    res['i'] = int(res['i']) - 1\n\n            result.append(res)\n        else:\n            raise JPathException(\"Invalid JPath chunk '{}'\".format(chnk))\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef jpath_parse_c(jpath):\n    if not jpath in _JPATH_CACHE:\n        _JPATH_CACHE[jpath] = jpath_parse(jpath)\n    return _JPATH_CACHE[jpath]", "response": "Caches variant of : py : func : jpath_parse. Same arguments and return\n    value."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef jpath_values(structure, jpath):\n    # Current working node set.\n    nodes_a = [structure]\n\n    # Next iteration working node set.\n    nodes_b = []\n\n    # Process sequentially all JPath chunks.\n    chunks = jpath_parse_c(jpath)\n    for chnk in chunks:\n        # Process all currently active nodes.\n        for node in nodes_a:\n            key = chnk['n']\n            if not isinstance(node, dict) and not isinstance(node, collections.Mapping):\n                continue\n\n            # Process indexed nodes.\n            if 'i' in chnk:\n                idx = chnk['i']\n                # Skip the node, if the key does not exist, the value is not\n                # a list-like object or the list is empty.\n                if not key in node or not (isinstance(node[key], (list, collections.MutableSequence))) or not node[key]:\n                    continue\n                try:\n                    # Handle '*' special index - append all nodes.\n                    if str(idx) == '*':\n                        nodes_b.extend(node[key])\n                    # Append only node at particular index.\n                    else:\n                        nodes_b.append(node[key][idx])\n                except:\n                    pass\n\n            # Process unindexed nodes.\n            else:\n                # Skip the node, if the key does not exist.\n                if not key in node:\n                    continue\n\n                # Handle list values - expand them.\n                if isinstance(node[key], (list, collections.MutableSequence)):\n                    for i in node[key]:\n                        nodes_b.append(i)\n                # Handle scalar values.\n                else:\n                    nodes_b.append(node[key])\n\n        nodes_a = nodes_b\n        nodes_b = []\n\n    return nodes_a", "response": "Return all values at given JPath within given data structure."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nchecks if node at given JPath within given data structure exists.", "response": "def jpath_exists(structure, jpath):\n    \"\"\"\n    Check if node at given JPath within given data structure does exist.\n\n    :param str structure: data structure to be searched\n    :param str jpath: JPath to be evaluated\n    :return: True or False\n    :rtype: bool\n    \"\"\"\n    result = jpath_value(structure, jpath)\n    if not result is None:\n        return True\n    return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets given value within given structure at given JPath.", "response": "def jpath_set(structure, jpath, value, overwrite = True, unique = False):\n    \"\"\"\n    Set given JPath to given value within given structure.\n\n    For performance reasons this method is intentionally not written as\n    recursive.\n\n    :param str structure: data structure to be searched\n    :param str jpath: JPath to be evaluated\n    :param any value: value of any type to be set at given path\n    :param bool overwrite: enable/disable overwriting of already existing value\n    :param bool unique: ensure uniqueness of value, works only for lists\n    :return: numerical return code, one of the (:py:data:`RC_VALUE_SET`,\n             :py:data:`RC_VALUE_EXISTS`, :py:data:`RC_VALUE_DUPLICATE`)\n    :rtype: int\n    \"\"\"\n    chunks = jpath_parse_c(jpath)\n    size = len(chunks) - 1\n    current = structure\n\n    # Process chunks in order, enumeration is used for detection of the last JPath chunk.\n    for i, chnk in enumerate(chunks):\n        key = chnk['n']\n\n        if not isinstance(current, dict) and not isinstance(current, collections.Mapping):\n            raise JPathException(\"Expected dict-like structure to attach node '{}'\".format(chnk['p']))\n\n        # Process indexed nodes.\n        if 'i' in chnk:\n            idx = chnk['i']\n\n            # Automatically create nodes for non-existent keys.\n            if not key in current:\n                current[key] = []\n            if not isinstance(current[key], list) and not isinstance(current[key], collections.MutableSequence):\n                raise JPathException(\"Expected list-like object under structure key '{}'\".format(key))\n\n            # Detection of the last JPath chunk - node somewhere in the middle.\n            if i != size:\n                # Attempt to access node at given index.\n                try:\n                    current = current[key][idx]\n                # IndexError: list index out of range\n                # Node at given index does not exist, append new one. Using insert()\n                # does not work, item is appended to the end of the list anyway.\n                # TypeError: list indices must be integers or slices, not str\n                # In the case list index was '*', we are appending to the end of\n                # list.\n                except (IndexError, TypeError):\n                    current[key].append({})\n                    current = current[key][-1]\n\n            # Detection of the last JPath chunk - node at the end.\n            else:\n                # Attempt to insert value at given index.\n                try:\n                    if overwrite or not current[key][idx]:\n                        current[key][idx] = value\n                    else:\n                        return RC_VALUE_EXISTS\n                # IndexError: list index out of range\n                # Node at given index does not exist, append new one. Using insert()\n                # does not work, item is appended to the end of the list anyway.\n                # TypeError: list indices must be integers or slices, not str\n                # In the case list index was '*', we are appending to the end of\n                # list.\n                except (IndexError, TypeError):\n                    # At this point only deal with unique, overwrite does not make\n                    # sense, because we would not be here otherwise.\n                    if not unique or not value in current[key]:\n                        current[key].append(value)\n                    else:\n                        return RC_VALUE_DUPLICATE\n\n        # Process unindexed nodes.\n        else:\n            # Detection of the last JPath chunk - node somewhere in the middle.\n            if i != size:\n                # Automatically create nodes for non-existent keys.\n                if not key in current:\n                    current[key] = {}\n                if not isinstance(current[key], dict) and not isinstance(current[key], collections.Mapping):\n                    raise JPathException(\"Expected dict-like object under structure key '{}'\".format(key))\n\n                current = current[key]\n\n            # Detection of the last JPath chunk - node at the end.\n            else:\n                if overwrite or not key in current:\n                    current[key] = value\n                else:\n                    return RC_VALUE_EXISTS\n    return RC_VALUE_SET"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a list of string identifiers for each element in dct. Recursively scans through dct and finds every element whose type is in allowed_types and adds a string indentifier for it. eg: dct = { 'a': 'a string', 'b': { 'c': 1.0, 'd': True } } flatten_dict(dct) would return ['a', 'b-->c', 'b-->d']", "response": "def flatten_dict(dct, separator='-->', allowed_types=[int, float, bool]):\n    \"\"\"Returns a list of string identifiers for each element in dct.\n\n    Recursively scans through dct and finds every element whose type is in\n    allowed_types and adds a string indentifier for it.\n\n    eg:\n    dct = {\n            'a': 'a string',\n            'b': {\n                'c': 1.0,\n                'd': True\n            }\n          }\n    flatten_dict(dct) would return\n    ['a', 'b-->c', 'b-->d']\n    \"\"\"\n    flat_list = []\n    for key in sorted(dct):\n        if key[:2] == '__':\n            continue\n        key_type = type(dct[key])\n        if key_type in allowed_types:\n            flat_list.append(str(key))\n        elif key_type is dict:\n            sub_list = flatten_dict(dct[key])\n            sub_list = [str(key) + separator + sl for sl in sub_list]\n            flat_list += sub_list\n\n    return flat_list"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_dict_item(dct, name_string, set_to):\n    key_strings = str(name_string).split('-->')\n    d = dct\n    for ks in key_strings[:-1]:\n        d = d[ks]\n    item_type = type(d[key_strings[-1]])\n    d[key_strings[-1]] = item_type(set_to)", "response": "Sets the value of the named item in dct to set_to."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the correct order of the name according to the current language.", "response": "def get_name(obj, setting_name='LONG_NAME_FORMAT'):\n    \"\"\"\n    Returns the correct order of the name according to the current language.\n\n    \"\"\"\n    nickname = obj.get_nickname()\n    romanized_first_name = obj.get_romanized_first_name()\n    romanized_last_name = obj.get_romanized_last_name()\n    non_romanized_first_name = obj.get_non_romanized_first_name()\n    non_romanized_last_name = obj.get_non_romanized_last_name()\n    non_translated_title = obj.get_title()\n    non_translated_gender = obj.get_gender()\n    # when the title is blank, gettext returns weird header text. So if this\n    # occurs, we will pass it on blank without gettext\n    if non_translated_title:\n        title = gettext(non_translated_title)\n    else:\n        title = non_translated_title\n    if non_translated_gender:\n        gender = gettext(non_translated_gender)\n    else:\n        gender = non_translated_gender\n\n    format_string = u'{}'.format(get_format(setting_name))\n    format_kwargs = {}\n    if '{n}' in format_string:\n        format_kwargs.update({'n': nickname})\n    if '{N}' in format_string:\n        format_kwargs.update({'N': nickname.upper()})\n    if '{f}' in format_string:\n        format_kwargs.update({'f': romanized_first_name})\n    if '{F}' in format_string:\n        format_kwargs.update({'F': romanized_first_name.upper()})\n    if '{l}' in format_string:\n        format_kwargs.update({'l': romanized_last_name})\n    if '{L}' in format_string:\n        format_kwargs.update({'L': romanized_last_name.upper()})\n    if '{a}' in format_string:\n        format_kwargs.update({'a': non_romanized_first_name})\n    if '{A}' in format_string:\n        format_kwargs.update({'A': non_romanized_first_name.upper()})\n    if '{x}' in format_string:\n        format_kwargs.update({'x': non_romanized_last_name})\n    if '{X}' in format_string:\n        format_kwargs.update({'X': non_romanized_last_name.upper()})\n    if '{t}' in format_string:\n        format_kwargs.update({'t': title})\n    if '{T}' in format_string:\n        format_kwargs.update({'T': title.upper()})\n    if '{g}' in format_string:\n        format_kwargs.update({'g': gender})\n    if '{G}' in format_string:\n        format_kwargs.update({'G': gender.upper()})\n\n    return format_string.format(**format_kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndoing a countdown for duration printing the template.", "response": "def countdown(template, duration=datetime.timedelta(seconds=5)):\n\t\"\"\"\n\tDo a countdown for duration, printing the template (which may accept one\n\tpositional argument). Template should be something like\n\t``countdown complete in {} seconds.``\n\t\"\"\"\n\tnow = datetime.datetime.now()\n\tdeadline = now + duration\n\tremaining = deadline - datetime.datetime.now()\n\twhile remaining:\n\t\tremaining = deadline - datetime.datetime.now()\n\t\tremaining = max(datetime.timedelta(), remaining)\n\t\tmsg = template.format(remaining.total_seconds())\n\t\tprint(msg, end=' ' * 10)\n\t\tsys.stdout.flush()\n\t\ttime.sleep(.1)\n\t\tprint('\\b' * 80, end='')\n\t\tsys.stdout.flush()\n\tprint()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef timethis(func):\n    func_module, func_name = func.__module__, func.__name__\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        start = _time_perf_counter()\n        r = func(*args, **kwargs)\n        end = _time_perf_counter()\n        print('timethis : <{}.{}> : {}'.format(func_module, func_name, end - start))\n        return r\n    return wrapper", "response": "A decorator use for timeit."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef create_info(name, info_type, url=None, parent=None, id=None,\n                context=ctx_default, store=False):\n    \"\"\"Return a group object\"\"\"\n    id = str(uuid4()) if id is None else id\n    pubsub = _pubsub_key(id)\n\n    info = {'id': id,\n            'type': info_type,\n            'pubsub': pubsub,\n            'url': url,\n            'parent': parent,\n            'context': context,\n            'name': name,\n            'status': 'Queued' if info_type == 'job' else None,\n            'date_start': None,\n            'date_end': None,\n            'date_created': str(datetime.now()),\n            'result': None}\n\n    if store:\n        r_client.set(id, json_encode(info))\n\n        if parent is not None:\n            r_client.sadd(_children_key(parent), id)\n\n    return info", "response": "Create a new group object"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget an ID from a user creates if necessary", "response": "def get_id_from_user(user):\n    \"\"\"Get an ID from a user, creates if necessary\"\"\"\n    id = r_client.hget('user-id-map', user)\n    if id is None:\n        id = str(uuid4())\n        r_client.hset('user-id-map', user, id)\n        r_client.hset('user-id-map', id, user)\n    return id"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef traverse(self, id_=None):\n        if id_ is None:\n            id_ = self.group\n\n        nodes = r_client.smembers(_children_key(id_))\n        while nodes:\n            current_id = nodes.pop()\n\n            details = r_client.get(current_id)\n            if details is None:\n                # child has expired or been deleted, remove from :children\n                r_client.srem(_children_key(id_), current_id)\n                continue\n\n            details = self._decode(details)\n            if details['type'] == 'group':\n                children = r_client.smembers(_children_key(details['id']))\n                if children is not None:\n                    nodes.update(children)\n\n            yield details", "response": "Traverse groups and yield info dicts for jobs"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef close(self):\n        for channel in self._listening_to:\n            self.toredis.unsubscribe(channel)\n        self.toredis.unsubscribe(self.group_pubsub)", "response": "Unsubscribe the group and all jobs being listened too"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nattaching a callback on the group pubsub", "response": "def listen_for_updates(self):\n        \"\"\"Attach a callback on the group pubsub\"\"\"\n        self.toredis.subscribe(self.group_pubsub, callback=self.callback)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nattaching a callback on the job pubsub if it exists", "response": "def listen_to_node(self, id_):\n        \"\"\"Attach a callback on the job pubsub if it exists\"\"\"\n        if r_client.get(id_) is None:\n            return\n        else:\n            self.toredis.subscribe(_pubsub_key(id_), callback=self.callback)\n            self._listening_to[_pubsub_key(id_)] = id_\n            return id_"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nstop listening to a job.", "response": "def unlisten_to_node(self, id_):\n        \"\"\"Stop listening to a job\n\n        Parameters\n        ----------\n        id_ : str\n            An ID to remove\n\n        Returns\n        --------\n        str or None\n            The ID removed or None if the ID was not removed\n        \"\"\"\n        id_pubsub = _pubsub_key(id_)\n\n        if id_pubsub in self._listening_to:\n            del self._listening_to[id_pubsub]\n            self.toredis.unsubscribe(id_pubsub)\n\n            parent = json_decode(r_client.get(id_)).get('parent', None)\n            if parent is not None:\n                r_client.srem(_children_key(parent), id_)\n            r_client.srem(self.group_children, id_)\n\n            return id_"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef callback(self, msg):\n        message_type, channel, payload = msg\n\n        if message_type != 'message':\n            return\n\n        try:\n            payload = self._decode(payload)\n        except ValueError:\n            # unable to decode so we cannot handle the message\n            return\n\n        if channel == self.group_pubsub:\n            action_f = self.action\n        elif channel in self._listening_to:\n            action_f = self.job_action\n        else:\n            raise ValueError(\"Callback triggered unexpectedly by %s\" % channel)\n\n        for verb, args in payload.items():\n            action_f(verb, args)", "response": "This method is called when a message is received from the server. It is called when a message is received from the server."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef action(self, verb, args):\n        if not isinstance(args, (list, set, tuple)):\n            raise TypeError(\"args is unknown type: %s\" % type(args))\n\n        if verb == 'add':\n            response = ({'add': i} for i in self._action_add(args))\n        elif verb == 'remove':\n            response = ({'remove': i} for i in self._action_remove(args))\n        elif verb == 'get':\n            response = ({'get': i} for i in self._action_get(args))\n        else:\n            raise ValueError(\"Unknown action: %s\" % verb)\n\n        self.forwarder(response)", "response": "Process the described action\n           "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd IDs to the group", "response": "def _action_add(self, ids):\n        \"\"\"Add IDs to the group\n\n        Parameters\n        ----------\n        ids : {list, set, tuple, generator} of str\n            The IDs to add\n\n        Returns\n        -------\n        list of dict\n            The details of the added jobs\n        \"\"\"\n        return self._action_get((self.listen_to_node(id_) for id_ in ids))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nremoving IDs from the group", "response": "def _action_remove(self, ids):\n        \"\"\"Remove IDs from the group\n\n        Parameters\n        ----------\n        ids : {list, set, tuple, generator} of str\n            The IDs to remove\n\n        Returns\n        -------\n        list of dict\n            The details of the removed jobs\n        \"\"\"\n        return self._action_get((self.unlisten_to_node(id_) for id_ in ids))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the details for the given list of jobs.", "response": "def _action_get(self, ids):\n        \"\"\"Get the details for ids\n\n        Parameters\n        ----------\n        ids : {list, set, tuple, generator} of str\n            The IDs to get\n\n        Notes\n        -----\n        If ids is empty, then all IDs are returned.\n\n        Returns\n        -------\n        list of dict\n            The details of the jobs\n        \"\"\"\n        if not ids:\n            ids = self.jobs\n        result = []\n\n        ids = set(ids)\n        while ids:\n            id_ = ids.pop()\n\n            if id_ is None:\n                continue\n\n            try:\n                payload = r_client.get(id_)\n            except ResponseError:\n                # wrong key type\n                continue\n\n            try:\n                payload = self._decode(payload)\n            except ValueError:\n                # unable to decode or data doesn't exist in redis\n                continue\n            else:\n                result.append(payload)\n\n            if payload['type'] == 'group':\n                for obj in self.traverse(id_):\n                    ids.add(obj['id'])\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef configure(self, *, hwm: int=None, rcvtimeo: int=None, sndtimeo: int=None, linger: int=None) -> 'Socket':\n        if hwm is not None:\n            self.set_hwm(hwm)\n        if rcvtimeo is not None:\n            self.setsockopt(zmq.RCVTIMEO, rcvtimeo)\n        if sndtimeo is not None:\n            self.setsockopt(zmq.SNDTIMEO, sndtimeo)\n        if linger is not None:\n            self.setsockopt(zmq.LINGER, linger)\n        return self", "response": "Allows to configure some common socket options and configurations while allowing method chaining."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nwaits for the next multipart message and asserts that it contains the given data.", "response": "async def recv_multipart_expect(self, data: Tuple[bytes, ...]=(b'',)) -> None:\n        \"\"\"\n        Waits for the next multipart message and asserts that it contains the given data.\n        \"\"\"\n        expect_all(await self.recv_multipart(), data)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef generate_payment(redirect_url, client_name, client_email, payment_owner, validate_address_cmd, *validate_item_cmds):\n    return GeneratePayment(redirect_url, client_name, client_email, payment_owner, validate_address_cmd,\n                           *validate_item_cmds)", "response": "Function used to generate a payment on pagseguro\n   "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef validate_address_cmd(street, number, quarter, postalcode, town, state, complement=\"Sem Complemento\"):\n    return ValidateAddressCmd(street=street, number=number, quarter=quarter, postalcode=postalcode, town=town,\n                              state=state, complement=complement)", "response": "Validate an address command"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef validate_item_cmd(description, price, quantity, reference=None):\n    return ValidateItemCmd(description=description, price=price, quantity=quantity, reference=reference)", "response": "Create a command that validates and saves items from the order."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef search_all_payments(payment_status=None, page_size=20, start_cursor=None, offset=0, use_cache=True,\n                        cache_begin=True, relations=None):\n    \"\"\"\n    Returns a command to search all payments ordered by creation desc\n    @param payment_status: The payment status. If None is going to return results independent from status\n    @param page_size: number of payments per page\n    @param start_cursor: cursor to continue the search\n    @param offset: offset number of payment on search\n    @param use_cache: indicates with should use cache or not for results\n    @param cache_begin: indicates with should use cache on beginning or not for results\n    @param relations: list of relations to bring with payment objects. possible values on list: logs, pay_items, owner\n    @return: Returns a command to search all payments ordered by creation desc\n    \"\"\"\n    if payment_status:\n        return PaymentsByStatusSearch(payment_status, page_size, start_cursor, offset, use_cache,\n                                      cache_begin, relations)\n    return AllPaymentsSearch(page_size, start_cursor, offset, use_cache, cache_begin, relations)", "response": "Returns a command to search all payments in a node."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets a config parser for a given TAPP name.", "response": "def get_config(name=__name__):\n    \"\"\"\n    Get a configuration parser for a given TAPP name.\n    Reads config.ini files only, not in-database configuration records.\n\n    :param name: The tapp name to get a configuration for.\n    :rtype: ConfigParser\n    :return: A config parser matching the given name\n    \"\"\"\n    cfg = ConfigParser()\n    path = os.environ.get('%s_CONFIG_FILE' % name.upper())\n    if path is None or path == \"\":\n        fname = '/etc/tapp/%s.ini' % name\n        if isfile(fname):\n            path = fname\n        elif isfile('cfg.ini'):\n            path = 'cfg.ini'\n        else:\n            raise ValueError(\"Unable to get configuration for tapp %s\" % name)\n\n    cfg.read(path)\n    return cfg"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate a logger based on the given configuration.", "response": "def setup_logging(name, prefix=\"trademanager\", cfg=None):\n    \"\"\"\n    Create a logger, based on the given configuration.\n    Accepts LOGFILE and LOGLEVEL settings.\n\n    :param name: the name of the tapp to log\n    :param cfg: The configuration object with logging info.\n    :return: The session and the engine as a list (in that order)\n    \"\"\"\n    logname = \"/var/log/%s/%s_tapp.log\" % (prefix, name)\n    logfile = cfg.get('log', 'LOGFILE') if cfg is not None and \\\n        cfg.get('log', 'LOGFILE') is not None and cfg.get('log', 'LOGFILE') != \"\" else logname\n    loglevel = cfg.get('log', 'LOGLEVEL') if cfg is not None and \\\n        cfg.get('log', 'LOGLEVEL') is not None else logging.INFO\n    logging.basicConfig(filename=logfile, level=loglevel)\n    return logging.getLogger(name)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef destandardize_variables(self, tv, blin, bvar, errBeta, nonmissing):\n        return self.test_variables.destandardize(tv, blin, bvar, errBeta, nonmissing)", "response": "Destandardize betas and other components."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconvert variable data into numpy arrays.", "response": "def freeze_subjects(self):\n        \"\"\"Converts variable data into numpy arrays.\n\n        This is required after all subjects have been added via the\n        add_subject function, since we don't know ahead of time who is\n        participating in the analysis due to various filtering possibilities.\n        \"\"\"\n        self.phenotype_data = numpy.array(self.phenotype_data)\n        self.covariate_data = numpy.array(self.covariate_data)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nadd a new subject to study with optional sex and phenotype", "response": "def add_subject(self, ind_id, sex=None, phenotype=None):\n        \"\"\"Add new subject to study, with optional sex and phenotype\n\n        Throws MalformedInputFile if sex is can't be converted to int\n        \"\"\"\n\n        self.pedigree_data[ind_id] = len(self.phenotype_data[0])\n        if phenotype != None:\n            if type(self.phenotype_data) is list:\n                self.phenotype_data[0].append(phenotype)\n            else:\n                self.phenotype_data[-1, len(self.individual_mask)] = phenotype\n        self.individual_mask.append(0)\n\n        if PhenoCovar.sex_as_covariate:\n            try:\n                self.covariate_data[0].append(float(sex))\n            except Exception, e:\n                raise MalformedInputFile(\"Invalid setting, %s, for sex in pedigree\" % (sex))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nloading phenotype data from a file.", "response": "def load_phenofile(self, file, indices=[], names=[], sample_file=False):\n        \"\"\"Load phenotype data from phenotype file\n\n        Whitespace delimited, FAMID, INDID, VAR1, [VAR2], etc\n\n        Users can specify phenotypes of interest via indices and names.\n        Indices are 1 based and start with the first variable. names\n        must match name specified in the header (case is ignored). \"\"\"\n\n        file.seek(0)\n        self.phenotype_names = []\n        if file:\n            header = [\"\", \"\", \"\"]\n            header = file.readline().strip().upper().split()\n            line_number = 0\n            valid_indices = [int(x) for x in indices]\n            valid_names  = []\n\n            for name in names:\n                if name.strip() != \"\":\n                    valid_names.append(name)\n\n            # Rows ignored because family/individual missing from our pedigree data\n            ignored_data = []\n            # We can accept a default phenotype column if we only have 3 columns\n            if len(header) == 3:\n                if len(valid_names) + len(valid_indices) == 0:\n                    valid_indices.append(1)\n            if header[0].upper() == \"FID\":\n                phenotype_names = header[2:]\n                for name in valid_names:\n                    try:\n                        valid_indices.append(phenotype_names.index(name.upper()) + 1)\n                    except:\n                        raise InvalidSelection(\n                            \"The name, %s, was not found in %s\" % (name, file.name)\n                        )\n                line_number = 1\n\n                if len(valid_indices) > 0 and max(valid_indices) > (len(header)-2):\n                    raise InvalidSelection(\n                        \"The index, %s, is larger than the number of entries in the file, %s:%s\" %\n                        (max(valid_indices), file.name, line_number)\n                    )\n\n                for i in xrange(0, len(valid_indices)):\n                    self.phenotype_names.append(phenotype_names[valid_indices[i]-1])\n                # Dump the second line for sample_file==True\n                if sample_file:\n                    file.readline()\n                    line_number += 1\n            # if we don't have a header, we'll create dummy names\n            else:\n                file.seek(0)\n                if len(valid_names) > 0:\n                    raise MalformedInputFile(\n                        \"Names only work with phenotype files with headers: %s for file %s\" %\n                        (\",\".join(names), file.name)\n                    )\n                if len(valid_indices) > 0 and max(valid_indices) > (len(header)-2):\n                    raise InvalidSelection(\n                        \"The index, %s, is larger than the number of entries in the file, %s:%s\" %\n                        (max(valid_indices), file.name, line_number)\n                    )\n\n                self.phenotype_names = []\n                for i in xrange(0, len(valid_indices)):\n                    self.phenotype_names.append(\"Pheno-%s\" % (valid_indices[i]))\n\n            pheno_count = len(valid_indices)\n            self.phenotype_data = numpy.empty((pheno_count, len(self.pedigree_data)))\n            self.phenotype_data.fill(PhenoCovar.missing_encoding)\n\n            for line in file:\n                line_number += 1\n                words   = line.split()\n                iid = \":\".join(words[0:2])\n\n                # Indexes are 1 based...silly humans\n                if len(valid_indices) > 0 and max(valid_indices) > (len(words)-2):\n                    raise InvalidSelection(\n                        \"The index, %s, is larger than the number of entries in the file, %s:%s\" %\n                        (max(valid_indices), file.name, line_number)\n                    )\n\n\n                pidx = 0\n                for idx in valid_indices:\n                    try:\n                        pheno = float(words[1+idx])\n                        if iid not in self.pedigree_data:\n                            ignored_data.append(iid)\n                        else:\n                            self.phenotype_data[pidx][self.pedigree_data[iid]] = pheno\n                        pidx += 1\n                    except:\n                        raise MalformedInputFile(\n                            (\"Invalid input found in phenotype file on line: %s:%d. \\n\"+\n                            \"The line in question looks like this: \\n--> %s\") %\n                            (file.name, line_number, line.strip())\n                        )\n        if self.phenotype_data.shape[1] == len(ignored_data):\n            raise NoMatchedPhenoCovars(\"No matching individuals were found in the phenotype file\")"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nload the covariate data from a file.", "response": "def load_covarfile(self, file, indices=[], names=[], sample_file=False):\n        \"\"\"Load covariate data from file.\n\n        Unlike phenofiles, if we already have data, we keep it (that would be the sex covariate)\"\"\"\n\n        # Clean up input in case we are given some empty values\n        var_indices = []\n        for x in indices:\n            try:\n                var_indices.append(int(x) + 1)\n            except:\n                pass\n\n        var_names = []\n        for name in names:\n            if name.strip() != \"\":\n                var_names.append(name)\n\n        if PhenoCovar.sex_as_covariate:\n            self.covariate_labels = [\"SEX\"]\n        file.seek(0)\n        if file:\n            header = file.readline().strip().split()\n            line_number = 0\n\n            # Rows ignored because family/individual missing from our pedigree data\n            ignored_data = []\n            # We can accept a default phenotype column if we only have 3 columns\n            if len(header) == 3:\n                if len(var_names) + len(var_indices) == 0:\n                    var_indices.append(2)\n\n            if header[0].upper() == \"FID\":\n                for name in var_names:\n                    if name.strip() != \"\":\n                        try:\n                            var_indices.append(header.index(name))\n                        except:\n                            raise InvalidSelection(\"The name, %s, was not found in %s\" % (name, file.name))\n                line_number = 1\n\n\n                if len(var_indices) > 0 and max(var_indices) > (len(header)):\n                    raise InvalidSelection(\"The index, %s, is larger than the number of entries in the file, %s:%s\" % (max(var_indices), file.name, line_number))\n\n                for index in var_indices:\n                    self.covariate_labels.append(header[index])\n                # Dump the second line for sample_file==True\n                if sample_file:\n                    file.readline()\n            else:\n                file.seek(0)\n                if len(var_names) > 0:\n                    raise MalformedInputFile(\"Names only work with covariate files with headers: %s\" % (\",\".join(names), file.name))\n                if len(var_indices) > 0 and max(var_indices) > (len(header)):\n                    raise InvalidSelection(\"The index, %s, is larger than the number of entries in the file, %s:%s\" % (max(var_indices), file.name, line_number))\n\n                for i in xrange(0, len(var_indices)):\n                    self.covariate_labels.append(\"Cov-%s\" % (var_indices[i]-1))\n\n            covar_data = numpy.empty((len(var_indices)+len(self.covariate_data), len(self.pedigree_data)))\n            covar_data.fill(PhenoCovar.missing_encoding)\n\n            # We have to be careful to keep the sex covariate data if it came from the pedigree\n            if PhenoCovar.sex_as_covariate:\n                covar_data[0] = self.covariate_data[0]\n            self.covariate_data = covar_data\n\n            for line in file:\n                line_number += 1\n                words   = line.split()\n                iid = \":\".join(words[0:2])\n\n                # Indexes are 1 based...silly humans\n                if len(var_indices) > 0 and max(var_indices) > (len(words)):\n                    raise InvalidSelection(\"The index, %s, is larger than the number of entries in the file, %s:%s\" % (max(var_indices), file.name, line_number))\n\n                cidx = 0\n                if PhenoCovar.sex_as_covariate:\n                    cidx += 1\n                for idx in var_indices:\n                    cov = float(words[idx])\n                    if iid not in self.pedigree_data:\n                        ignored_data.append(iid)\n                    else:\n                        self.covariate_data[cidx, self.pedigree_data[iid]] = cov\n                    cidx += 1\n\n\n        for covar in self.covariate_data:\n            if sum(covar !=PhenoCovar.missing_encoding ) == 0:\n                raise NoMatchedPhenoCovars(\"No matching individuals were found in the covariate file\")"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn formatted HTML5 elements based on given datetime object.", "response": "def format_time(date_obj, time_obj=None, datebox=False, dt_type=None, classes=None):\n    \"\"\"\n    Returns formatted HTML5 elements based on given datetime object.\n    By default returns a time element, but will return a .datebox if requested.\n\n    dt_type allows passing dt_start or dt_end for hcal formatting.\n    link allows passing a url to the datebox.\n\n    classes allows sending arbitrary classnames. Useful for properly microformatting elements.\n\n    Usage::\n\n        {% format_time obj.pub_date %}\n        {% format_time obj.start_date 'datebox' 'dtstart' %}\n        {% format_time obj.end_date obj.end_time 'datebox' 'dt_end' %}\n    \n    \"\"\"\n    if not time_obj:\n        time_obj = getattr(date_obj, 'time', None)\n\n    if dt_type:\n        classes = '{0} {1}'.format(classes, dt_type)\n    if datebox:\n        classes = '{0} {1}'.format(classes, datebox)\n    return {\n        'date_obj': date_obj,\n        'time_obj': time_obj,\n        'datebox': datebox,\n        'current_year': datetime.date.today().year,\n        'classes': classes\n    }"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef short_timesince(date):\n    try:\n        t = timesince(date).split(\", \")[0]\n    except IndexError:\n        t = timesince(date)\n    return t", "response": "Returns a longer version of Django s built - in timesince filter."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef validate_values(func, dic):\n    for value_name, value in dic.items():\n        if not func(value):\n            raise ValueError('{} can not be {}'.format(value_name, value))", "response": "Validate each value in dic by passing it through func. Raise a ValueError if func does not return True."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfinds all tex documents input by this root document.", "response": "def find_input_documents(self):\n        \"\"\"Find all tex documents input by this root document.\n\n        Returns\n        -------\n        paths : list\n            List of filepaths for input documents. Paths are relative\n            to the document (i.e., as written in the latex document).\n        \"\"\"\n        paths = []\n        itr = chain(texutils.input_pattern.finditer(self.text),\n                    texutils.input_ifexists_pattern.finditer(self.text))\n        for match in itr:\n            fname = match.group(1)\n            if not fname.endswith('.tex'):\n                full_fname = \".\".join((fname, 'tex'))\n            else:\n                full_fname = fname\n            paths.append(full_fname)\n        return paths"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nlists with tuples of section names and positions of section names and positions.", "response": "def sections(self):\n        \"\"\"List with tuples of section names and positions.\n        Positions of section names are measured by cumulative word count.\n        \"\"\"\n        sections = []\n\n        for match in texutils.section_pattern.finditer(self.text):\n            textbefore = self.text[0:match.start()]\n            wordsbefore = nlputils.wordify(textbefore)\n            numwordsbefore = len(wordsbefore)\n            sections.append((numwordsbefore, match.group(1)))\n\n        self._sections = sections\n        return sections"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the name of the BibTeX file.", "response": "def bib_name(self):\n        \"\"\"Name of the BibTeX bibliography file (e.g.,\n        ``'mybibliography.bib'``).\n        \"\"\"\n        bib_name = None\n        for match in texutils.bib_pattern.finditer(self.text):\n            bib_name = match.group(1)\n            if not bib_name.endswith('.bib'):\n                bib_name = \".\".join((bib_name, \"bib\"))\n        return bib_name"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nremoves latex comments from the LaTeX document.", "response": "def remove_comments(self, recursive=True):\n        \"\"\"Remove latex comments from document (modifies document in place).\n\n        Parameters\n        ----------\n        recursive : bool\n            Remove comments from all input LaTeX documents (default ``True``).\n        \"\"\"\n        self.text = texutils.remove_comments(self.text)\n        if recursive:\n            for path, document in self._children.iteritems():\n                document.remove_comments(recursive=True)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef bib_keys(self):\n        bib_keys = []\n        # Get bib keys in this document\n        for match in texutils.cite_pattern.finditer(self.text):\n            keys = match.group(5).split(',')\n            bib_keys += keys\n\n        # Recursion\n        for path, document in self._children.iteritems():\n            bib_keys += document.bib_keys\n        bib_keys = list(set(bib_keys))\n\n        return bib_keys", "response": "List of all bib keys in the document and input documents."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef extract_citation_context(self, n_words=20):\n        bib_keys = defaultdict(list)\n        # Get bib keys in this document\n        for match in texutils.cite_pattern.finditer(self.text):\n\n            textbefore = self.text[0:match.start()]\n            textafter = self.text[match.end():-1]\n\n            wordsbefore = nlputils.wordify(textbefore)\n            wordsafter = nlputils.wordify(textafter)\n            numwordsbefore = len(wordsbefore)\n            # numwordsafter = len(wordsafter)\n\n            containing_section = None\n            for (section_pos, section_name) in self._sections:\n                if section_pos < numwordsbefore:\n                    containing_section = (section_pos, section_name)\n\n            citebody = match.groups()\n            keys = (citebody[-1].replace(\" \", \"\")).split(',')\n            for key in keys:\n                cite_instance = {\n                    \"position\": numwordsbefore,\n                    \"wordsbefore\": (\" \".join(wordsbefore[-n_words:])),\n                    \"wordsafter\": (\" \".join(wordsafter[:n_words])),\n                    \"section\": containing_section}\n                bib_keys[key] += [cite_instance]\n\n        # Recursion\n        for path, document in self._children.iteritems():\n            sub_bib_keys = document.rich_bib_keys(n_words=n_words)\n            for k, cite_instances in sub_bib_keys.iteritems():\n                bib_keys[k] += cite_instances\n\n        return bib_keys", "response": "Extract the context of each citation in the document."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nwrites the document s text to a path on the filesystem.", "response": "def write(self, path):\n        \"\"\"Write the document's text to a ``path`` on the filesystem.\"\"\"\n        with codecs.open(path, 'w', encoding='utf-8') as f:\n            f.write(self.text)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef bibitems(self):\n        bibitems = []\n        lines = self.text.split('\\n')\n        for i, line in enumerate(lines):\n            if line.lstrip().startswith(u'\\\\bibitem'):\n                # accept this line\n                # check if next line is also part of bibitem\n                # FIXME ugh, re-write\n                j = 1\n                while True:\n                    try:\n                        if (lines[i + j].startswith(u'\\\\bibitem') is False) \\\n                                and (lines[i + j] != '\\n'):\n                            line += lines[i + j]\n                        elif \"\\end{document}\" in lines[i + j]:\n                            break\n                        else:\n                            break\n                    except IndexError:\n                        break\n                    else:\n                        print line\n                        j += 1\n                print \"finished\", line\n                bibitems.append(line)\n        return bibitems", "response": "List of bibitem strings appearing in the document."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef inline_bbl(self):\n        bbl_path = os.path.splitext(self._filepath)[0] + \".bbl\"\n        try:\n            with codecs.open(bbl_path, 'r', encoding='utf-8') as f:\n                bbl_text = f.read()\n        except IOError:\n            print(\"Cannot open bibliography {0}\".format(bbl_path))\n        self.text = texutils.inline_bbl(self.text, bbl_text)", "response": "Inline a compiled bibliography (. bbl ) in place of a bibliography\n            environment. The document is modified in place."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nremoves all widgets in the given layout. Useful when opening a new file.", "response": "def clearLayout(layout):\n    \"\"\"Removes all widgets in the layout. Useful when opening a new file, want\n    to clear everything.\"\"\"\n    while layout.count():\n        child = layout.takeAt(0)\n        child.widget().deleteLater()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef map_hubs_to_verticals():\n    vertical_hub_map = {}\n    for hub in HUBS_LIST:\n        vertical_slug = hub['vertical']['slug']\n        if vertical_slug not in vertical_hub_map:\n            vertical_hub_map[vertical_slug] = {\n                'name': hub['vertical']['name'],\n                'hubs': [hub['slug']]\n            }\n        else:\n            vertical_hub_map[vertical_slug]['hubs'].append(hub['slug'])\n\n    return vertical_hub_map", "response": "Return all verticals ( sections ) mapped to hubs."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add_dataset(request, dataset_id=None):\n    # Save form to create dataset model\n    # Populate non-form fields\n    if dataset_id:\n        dataset_instance = Dataset.objects.get(pk=dataset_id)\n\n        metadata_form = DatasetUploadForm(\n            request.POST,\n            request.FILES,\n            instance=dataset_instance\n        )\n\n        # metadata_form.base_fields['dataset_file'].required = False\n\n    else:\n        metadata_form = DatasetUploadForm(\n            request.POST,\n            request.FILES\n        )\n\n    if metadata_form.is_valid():\n        dataset_metadata = metadata_form.save(commit=False)\n\n        dataset_metadata.uploaded_by = request.user.email\n        dataset_metadata.slug = slugify(dataset_metadata.title)\n\n        # Find vertical from hub\n        dataset_metadata.vertical_slug = metadata_form.get_vertical_from_hub(\n            dataset_metadata.hub_slug\n        )\n        dataset_metadata.source_slug = slugify(dataset_metadata.source)\n\n        # Save to database so that we can add Articles,\n        # DataDictionaries, other foreignkeyed/M2M'd models.\n        dataset_metadata.save()\n\n        # Create relationships\n        url_list = metadata_form.cleaned_data['appears_in'].split(', ')\n        tag_list = metadata_form.cleaned_data['tags'].split(', ')\n        # print(tag_list)\n\n        dictionary = DataDictionary()\n        dictionary.author = request.user.email\n        dictionary.save()\n\n        dataset_metadata.data_dictionary = dictionary\n        dataset_metadata.save()\n\n        for url in url_list:\n            url = url.strip()\n\n            if len(url) > 0:\n                article, created = Article.objects.get_or_create(url=url)\n\n                if created:\n                    article_req = requests.get(url)\n\n                    if article_req.status_code == 200:\n                        # We good. Get the HTML.\n                        page = article_req.content\n                        soup = BeautifulSoup(page, 'html.parser')\n\n                        # Looking for <meta ... property=\"og:title\">\n                        meta_title_tag = soup.find(\n                            'meta',\n                            attrs={'property': 'og:title'}\n                        )\n\n                        try:\n                            # print \"Trying og:title...\"\n                            # print meta_title_tag\n                            title = meta_title_tag['content']\n                        except (TypeError, KeyError):\n                            # TypeError implies meta_title_tag is None;\n                            # KeyError implies that meta_title_tag does not\n                            # have a content property.\n                            title_tag = soup.find('title')\n\n                            try:\n                                # print \"Falling back to title...\"\n                                # print title_tag\n                                title = title_tag.text\n                            except (TypeError, KeyError):\n                                description_tag = soup.find(\n                                    'meta',\n                                    attrs={'property': 'og:description'}\n                                )\n\n                                try:\n                                    # print \"Falling back to description...\"\n                                    # print description_tag\n                                    title = description_tag['content']\n                                # Fallback value. Display is handled in models.\n                                except (TypeError, KeyError):\n                                    title = None\n\n                        article.title = title\n                        article.save()\n\n                dataset_metadata.appears_in.add(article)\n\n            for tag in tag_list:\n                if tag:\n                    cleanTag = tag.strip().lower()\n\n                    tagToAdd, created = Tag.objects.get_or_create(\n                        slug=slugify(cleanTag),\n                        defaults={'word': cleanTag}\n                    )\n\n                    dataset_metadata.tags.add(tagToAdd)\n\n        return redirect(\n            'datafreezer_datadict_edit',\n            dataset_id=dataset_metadata.id\n        )\n\n    return render(\n        request,\n        'datafreezer/upload.html',\n        {\n            'fileUploadForm': metadata_form,\n        }\n    )", "response": "Handles creation of Dataset models from form POST information."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the first row of a CSV as a list of headers.", "response": "def parse_csv_headers(dataset_id):\n    \"\"\"Return the first row of a CSV as a list of headers.\"\"\"\n    data = Dataset.objects.get(pk=dataset_id)\n    with open(data.dataset_file.path, 'r') as datasetFile:\n        csvReader = reader(datasetFile, delimiter=',', quotechar='\"')\n        headers = next(csvReader)\n        # print headers\n    return headers"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a dictionary mapping names to email addresses.", "response": "def grab_names_from_emails(email_list):\n    \"\"\"Return a dictionary mapping names to email addresses.\n\n    Only gives a response if the email is found\n    in the staff API/JSON.\n\n    Expects an API of the format =\n    [\n        {\n            'email': 'foo@bar.net',\n            ...\n            'fullName': 'Frank Oo'\n        },\n        ...\n    ]\n\n    \"\"\"\n    all_staff = STAFF_LIST\n\n    emails_names = {}\n\n    for email in email_list:\n        for person in all_staff:\n            if email == person['email'] and email not in emails_names:\n                emails_names[email] = person['fullName']\n                # print emails_names[email]\n\n    for email in email_list:\n        matched = False\n        for assignment in emails_names:\n            if email == assignment:\n                matched = True\n        if not matched:\n            emails_names[email] = email\n\n    return emails_names"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef download_data_dictionary(request, dataset_id):\n    dataset = Dataset.objects.get(pk=dataset_id)\n    dataDict = dataset.data_dictionary\n    fields = DataDictionaryField.objects.filter(\n        parent_dict=dataDict\n    ).order_by('columnIndex')\n\n    response = HttpResponse(content_type='text/csv')\n    csvName = slugify(dataset.title + ' data dict') + '.csv'\n    response['Content-Disposition'] = 'attachment; filename=%s' % (csvName)\n\n    csvWriter = writer(response)\n    metaHeader = [\n        'Data Dictionary for {0} prepared by {1}'.format(\n            dataset.title,\n            dataset.uploaded_by\n        )\n    ]\n    csvWriter.writerow(metaHeader)\n    trueHeader = ['Column Index', 'Heading', 'Description', 'Data Type']\n    csvWriter.writerow(trueHeader)\n\n    for field in fields:\n        mappedIndex = field.COLUMN_INDEX_CHOICES[field.columnIndex-1][1]\n        csvWriter.writerow(\n            [mappedIndex, field.heading, field.description, field.dataType]\n        )\n\n    return response", "response": "Generates and returns compiled data dictionary from database."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef home(request):\n    recent_uploads = Dataset.objects.order_by('-date_uploaded')[:11]\n\n    email_list = [upload.uploaded_by.strip() for upload in recent_uploads]\n    # print all_staff\n\n    emails_names = grab_names_from_emails(email_list)\n    # print emails_names\n\n    for upload in recent_uploads:\n        for item in emails_names:\n            if upload.uploaded_by == item:\n                upload.fullName = emails_names[item]\n\n    for upload in recent_uploads:\n        if not hasattr(upload, 'fullName'):\n            upload.fullName = upload.uploaded_by\n\n    return render(\n        request,\n        'datafreezer/home.html',\n        {\n            'recent_uploads': recent_uploads,\n            'heading': 'Most Recent Uploads'\n        }\n    )", "response": "Renders Datafreezer homepage. Includes recent uploads."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nrendering a template to upload or edit a Dataset.", "response": "def edit_dataset_metadata(request, dataset_id=None):\n    \"\"\"Renders a template to upload or edit a Dataset.\n\n    Most of the heavy lifting is done by add_dataset(...).\n\n    \"\"\"\n    if request.method == 'POST':\n        return add_dataset(request, dataset_id)\n\n    elif request.method == 'GET':\n        # create a blank form\n        # Edit\n        if dataset_id:\n            metadata_form = DatasetUploadForm(\n                instance=get_object_or_404(Dataset, pk=dataset_id)\n            )\n        # Upload\n        else:\n            metadata_form = DatasetUploadForm()\n\n        return render(\n            request,\n            'datafreezer/upload.html',\n            {\n                'fileUploadForm': metadata_form,\n            }\n        )"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nrenders individual dataset detail page.", "response": "def dataset_detail(request, dataset_id):\n    \"\"\"Renders individual dataset detail page.\"\"\"\n    active_dataset = get_object_or_404(Dataset, pk=dataset_id)\n    datadict_id = active_dataset.data_dictionary_id\n    datadict = DataDictionaryField.objects.filter(\n        parent_dict=datadict_id\n    ).order_by('columnIndex')\n    uploader_name = grab_names_from_emails([active_dataset.uploaded_by])\n    tags = Tag.objects.filter(dataset=dataset_id)\n    articles = Article.objects.filter(dataset=dataset_id)\n\n    for hub in HUBS_LIST:\n        if hub['slug'] == active_dataset.hub_slug:\n            active_dataset.hub = hub['name']\n            active_dataset.vertical = hub['vertical']['name']\n\n    if len(uploader_name) == 0:\n        uploader_name = active_dataset.uploaded_by\n    else:\n        uploader_name = uploader_name[active_dataset.uploaded_by]\n\n    return render(\n        request,\n        'datafreezer/dataset_details.html',\n        {\n            'dataset': active_dataset,\n            'datadict': datadict,\n            'uploader_name': uploader_name,\n            'tags': tags,\n            'articles': articles,\n        }\n    )"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nhandles HTTP GET request.", "response": "def get(self, request):\n        \"\"\"Handle HTTP GET request.\n\n        Returns template and context from generate_page_title and\n        generate_sections to populate template.\n        \"\"\"\n        sections_list = self.generate_sections()\n\n        p = Paginator(sections_list, 25)\n\n        page = request.GET.get('page')\n\n        try:\n            sections = p.page(page)\n        except PageNotAnInteger:\n            # If page is not an integer, deliver first page.\n            sections = p.page(1)\n        except EmptyPage:\n            # If page is out of range (e.g. 9999), return last page of results.\n            sections = p.page(p.num_pages)\n\n        context = {\n            'sections': sections,\n            'page_title': self.generate_page_title(),\n            'browse_type': self.browse_type\n        }\n\n        return render(\n            request,\n            self.template_path,\n            context\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nviewing for HTTP GET method. Returns template and context from generate_page_title and generate_sections to populate template.", "response": "def get(self, request):\n        \"\"\"View for HTTP GET method.\n\n        Returns template and context from generate_page_title and\n        generate_sections to populate template.\n        \"\"\"\n        sections = self.generate_sections()\n\n        if self.paginated:\n            p = Paginator(sections, 25)\n\n            page = request.GET.get('page')\n\n            try:\n                sections = p.page(page)\n            except PageNotAnInteger:\n                # If page is not an integer, deliver first page.\n                sections = p.page(1)\n            except EmptyPage:\n                # If page is out of range (e.g. 9999), return last page\n                # of results.\n                sections = p.page(p.num_pages)\n\n            pageUpper = int(p.num_pages) / 2\n\n            try:\n                pageLower = int(page) / 2\n            except TypeError:\n                pageLower = -999\n        else:\n            pageUpper = None\n            pageLower = None\n\n        context = {\n            'sections': sections,\n            'page_title': self.generate_page_title(),\n            'browse_type': self.browse_type,\n            'pageUpper': pageUpper,\n            'pageLower': pageLower\n        }\n\n        return render(\n            request,\n            self.template_path,\n            context\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef generate_sections(self):\n        datasets = Dataset.objects.values(\n            'hub_slug'\n        ).annotate(\n            upload_count=Count(\n                'hub_slug'\n            )\n        ).order_by('-upload_count')\n\n        return [\n            {\n                'count': dataset['upload_count'],\n                'name': get_hub_name_from_slug(dataset['hub_slug']),\n                'slug': dataset['hub_slug']\n            }\n            for dataset in datasets\n        ]", "response": "Return all hubs slugs and upload counts."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef generate_sections(self):\n        authors = Dataset.objects.values(\n            'uploaded_by'\n        ).annotate(\n            upload_count=Count(\n                'uploaded_by'\n            )\n        ).order_by('-upload_count')\n\n        email_name_map = grab_names_from_emails(\n            [row['uploaded_by'] for row in authors]\n        )\n\n        for author in authors:\n            for emailKey in email_name_map:\n                if author['uploaded_by'] == emailKey:\n                    author['name'] = email_name_map[emailKey]\n\n        return [\n            {\n                'slug': author['uploaded_by'],\n                'name': author['name'],\n                'count': author['upload_count']\n\n            }\n            for author in authors\n        ]", "response": "Return all authors to which datasets have been attributed."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef generate_sections(self):\n        sources = Dataset.objects.values(\n            'source', 'source_slug'\n        ).annotate(source_count=Count('source_slug'))\n\n        return sorted([\n            {\n                'slug': source['source_slug'],\n                'name': source['source'],\n                'count': source['source_count']\n            }\n            for source in sources\n        ], key=lambda k: k['count'], reverse=True)", "response": "Return dictionary of source section slugs name and counts."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get(self, request, slug):\n        matching_datasets = self.generate_matching_datasets(slug)\n\n        if matching_datasets is None:\n            raise Http404(\"Datasets meeting these criteria do not exist.\")\n\n        base_context = {\n            'datasets': matching_datasets,\n            'num_datasets': matching_datasets.count(),\n            'page_title': self.generate_page_title(slug),\n        }\n\n        additional_context = self.generate_additional_context(\n            matching_datasets\n        )\n\n        base_context.update(additional_context)\n        context = base_context\n\n        return render(\n            request,\n            self.template_path,\n            context\n        )", "response": "Basic functionality for GET request to view."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef generate_additional_context(self, matching_datasets):\n        dataset_ids = [upload.id for upload in matching_datasets]\n        tags = Tag.objects.filter(\n            dataset__in=dataset_ids\n        ).distinct().annotate(\n            Count('word')\n        ).order_by('-word__count')[:5]\n\n        hubs = matching_datasets.values(\"hub_slug\").annotate(\n            Count('hub_slug')\n        ).order_by('-hub_slug__count')\n\n        if hubs:\n            most_used_hub = get_hub_name_from_slug(hubs[0]['hub_slug'])\n            hub_slug = hubs[0]['hub_slug']\n        else:\n            most_used_hub = None\n            hub_slug = None\n\n        return {\n            'tags': tags,\n            'hub': most_used_hub,\n            'hub_slug': hub_slug,\n        }", "response": "Return additional information about matching datasets."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngenerating remainder of page title specific to data_slug.", "response": "def generate_page_title(self, data_slug):\n        \"\"\"Generates remainder of page title specific to data_slug (tag).\"\"\"\n        tag = Tag.objects.filter(slug=data_slug)\n        return tag[0].word"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef generate_matching_datasets(self, data_slug):\n        tag = Tag.objects.filter(slug=data_slug)\n        try:\n            return tag[0].dataset_set.all().order_by('-uploaded_by')\n        except IndexError:\n            return None", "response": "Return datasets that match data_slug."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn additional context about matching datasets.", "response": "def generate_additional_context(self, matching_datasets):\n        \"\"\"Return context about matching datasets.\"\"\"\n        related_tags = Tag.objects.filter(\n            dataset__in=matching_datasets\n        ).distinct().annotate(\n            Count('word')\n        ).order_by('-word__count')[:5]\n\n        return {\n            'related_tags': related_tags\n        }"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef generate_matching_datasets(self, data_slug):\n        matching_datasets = Dataset.objects.filter(\n            hub_slug=data_slug\n        ).order_by('-date_uploaded')\n\n        if len(matching_datasets) > 0:\n            return matching_datasets\n        else:\n            return None", "response": "Return datasets that match data_slug."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn datasets that belong to a vertical by querying hubs.", "response": "def generate_matching_datasets(self, data_slug):\n        \"\"\"Return datasets that belong to a vertical by querying hubs.\n\n        \"\"\"\n        matching_hubs = VERTICAL_HUB_MAP[data_slug]['hubs']\n        return Dataset.objects.filter(hub_slug__in=matching_hubs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef generate_additional_context(self, matching_datasets):\n        top_tags = Tag.objects.filter(\n            dataset__in=matching_datasets\n        ).annotate(\n            tag_count=Count('word')\n        ).order_by('-tag_count')[:3]\n\n        top_authors = Dataset.objects.filter(\n            id__in=matching_datasets\n        ).values('uploaded_by').annotate(\n            author_count=Count('uploaded_by')\n        ).order_by('-author_count')[:3]\n\n        for author in top_authors:\n            author['fullName'] = grab_names_from_emails([\n                author['uploaded_by']\n            ])[author['uploaded_by']]\n\n        return {\n            'top_tags': top_tags,\n            'top_authors': top_authors\n        }", "response": "Generate top tags and authors for a given Vertical."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef generate_additional_context(self, matching_datasets):\n        top_tags = Tag.objects.filter(\n            dataset__in=matching_datasets\n        ).annotate(\n            tag_count=Count('word')\n        ).order_by('-tag_count')[:3]\n\n        return {\n            'top_tags': top_tags\n        }", "response": "Return top tags for a source."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets a fact by its id.", "response": "def get_fact_by_id(self, fact_id):\n        \"\"\" Obtains fact data by it's id.\n\n        As the fact is unique, it returns a tuple like:\n        (activity_id, start_time, end_time, description).\n        If there is no fact with id == fact_id, a NoHamsterData\n        exception will be raise\n        \"\"\"\n\n        columns = 'activity_id, start_time, end_time, description'\n\n        query = \"SELECT %s FROM facts WHERE id = %s\"\n        result = self._query(query % (columns, fact_id))\n\n        if result:\n            return result[0]  # there only one fact with the id\n        else:\n            raise NoHamsterData('facts', fact_id)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_activity_by_id(self, activity_id):\n\n        columns = 'name, category_id'\n\n        query = \"SELECT %s FROM activities WHERE id = %s\"\n        result = self._query(query % (columns, activity_id))\n\n        if result:\n            return result[0]  # there only one fact with the id\n        else:\n            raise NoHamsterData('activities', activity_id)", "response": "Gets the activity data by it s id."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the tags associated with a fact_id.", "response": "def get_tags_by_fact_id(self, fact_id):\n        \"\"\" Obtains the tags associated by a fact_id.\n\n        This function returns a list of the tags name associated\n        to a fact, such as ['foo', 'bar', 'eggs'].\n        If the fact has no tags, it will return a empty list.\n        If there are no fact with id == fact_id, a NoHamsterData\n        exception will be raise\n        \"\"\"\n        if not fact_id in self.all_facts_id:\n            raise NoHamsterData('facts', fact_id)\n\n        query = \"SELECT tag_id FROM fact_tags WHERE fact_id = %s\"\n        return [self.tags[row[0]] for row in self._query(query % fact_id)]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the info for a single movie in: movie name [string] out: movie info [dict]", "response": "def get(self,movie):\n\t\t\"\"\"\n\t\tGets the info for a single movie\n\t\n\t\tin: movie name [string]\n\t\tout: movie info [dict]\n\t\t\"\"\"\n\t\tmovie = movie.replace('.mov','')\n\t\tmovie = movie.replace('.m4v','')\n\t\tmovie = movie.replace('.mp4','')\n\t\tmovie = re.sub('[_-]',' ',movie)\n\t\tmovie = movie.lower()\n\t\t\n\t\ttry:\n\t\t\tret = []\n\t\t\t# if there is a year in the title, the use it for the search\n\t\t\tif '(' in movie and ')' in movie:\n\t\t\t\tret = list(searchMovieWithYear(movie))\n\t\t\telse:\n\t\t\t\tret = searchMovie(movie)\n\t\t\t\n\t\t\tif len(ret) == 0:\n\t\t\t\tprint '[-] Error: could not find',movie\n\t\t\t\treturn False\n\t\t\telse:\n\t\t\t\tans = ret[0]\n\t\t\t\n\t\t\tmov = {}\n\t\t\tmov['title'] = unicode(ans.title.decode('unicode-escape'))\n\t\t\tmov['tagline'] = unicode(ans.tagline.decode('unicode-escape'))\n\t\t\tmov['runtime'] = unicode(ans.runtime)\n\t\t\tt = ans.youtube_trailers\n\t\t\tif not t:\n\t\t\t\tmov['trailer'] = ' '\n\t\t\telse:\n\t\t\t\tmov['trailer'] = unicode(t[0].geturl())\n\t\t\tp = ans.poster\n\t\t\tif 'w342' in p.sizes():\n\t\t\t\tmov['poster'] = unicode(p.geturl('w342'))\n\t\t\telse:\n\t\t\t\tprint '[.] Ops ... getting larger poster for',mov['title'],p.sizes()\n\t\t\t\tmov['poster'] = unicode(p.geturl())\n\t\t\tmov['imdb'] = unicode(ans.imdb)\n\t\t\n\t\t\tmov = self.get_rt(mov)\n\t\t\t\n\t\t\t#pp.pprint(mov)\n\t\t\t\n\t\t\treturn mov\n\t\texcept Exception as e:\n\t\t\tprint '[-] Error:',movie,'msg:',e\n\t\t\treturn False"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef log_user_in(app_id, token, ticket, response, cookie_name='user',\n                url_detail='https://pswdless.appspot.com/rest/detail'):\n    '''\n    Log the user in setting the user data dictionary in cookie\n    Returns a command that execute the logic\n    '''\n    return LogUserIn(app_id, token, ticket, response, cookie_name, url_detail)", "response": "Log the user in"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef fetch_user(app_id, token, ticket, url_detail='https://pswdless.appspot.com/rest/detail'):\n    '''\n    Fetch the user deatil from Passwordless\n    '''\n    return FetchUserWithValidation(app_id, token, ticket, url_detail)", "response": "Fetch the user deatil from Passwordless\n   "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef send_login_email(app_id, token, hook, email=None, user_id=None, lang=\"en_US\",\n                     url_login='https://pswdless.appspot.com/rest/login'):\n    '''\n    Contact password-less server to send user a email containing the login link\n    '''\n    return SendLoginEmail(app_id, token, hook, email, user_id, lang, url_login)", "response": "Sends a login email to the password - less server"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate a connection to the database and register it as a psycopg2. extras module.", "response": "def _create_connection(self):\n        \"\"\".. :py:method::\n\n              If we hava several hosts, we can random choice one to connect\n        \"\"\"\n        db = psycopg2.connect(database=self.dbname,\n                                user=self.user, password=self.password,\n                                host=self.host, port=self.port)\n        if 'psycopg2.extras' in sys.modules:\n            psycopg2.extras.register_hstore(db)\n        return db"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef execute(self, query, vars=None, result=False):\n        with self.connection() as cur:\n            if self.debug:\n                print(cur.mogrify(query, vars))\n\n            resp = cur.execute(query, vars)\n\n            if result == False:\n                return resp\n\n            else:\n                columns = [i[0] for i in cur.description]\n                results = cur.fetchall()\n                return QueryResult(columns, results)", "response": "Execute a query and return a QueryResult object."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nexecutes a batch of queries.", "response": "def batch(self, queries):\n        \"\"\".. :py:method::\n\n        :param tuple queries: [(sql, vars), (sql, vars), ...]\n\n        .. note::\n            batch execute queries.\n            only support `insert` and `update`, have more efficiency\n        \"\"\"\n        with self.connection() as cur:\n            for sql, vars in queries:\n\n                if self.debug:\n                    print(cur.mogrify(query, vars))\n                cur.execute(sql, vars)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef same_origin(url1, url2):\n    ''' Return True if the urls have the same origin, else False.\n    Copied from Django:\n    https://github.com/django/django/blob/master/django/utils/http.py#L255\n    '''\n    p1, p2 = urlparse(url1), urlparse(url2)\n    try:\n        o1 = (p1.scheme, p1.hostname, p1.port or PROTOCOL_TO_PORT[p1.scheme])\n        o2 = (p2.scheme, p2.hostname, p2.port or PROTOCOL_TO_PORT[p2.scheme])\n        return o1 == o2\n    except (ValueError, KeyError):\n        return False", "response": "Return True if the urls have the same origin else False."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning first found file matching names.", "response": "def filefind(self, names):\n        \"\"\"Return first found file matching name (case-insensitive).\n\n        Some packages have docs/HISTORY.txt and\n        package/name/HISTORY.txt.  We make sure we only return the one\n        in the docs directory if no other can be found.\n\n        'names' can be a string or a list of strings; if you have both\n        a CHANGES.txt and a docs/HISTORY.txt, you want the top level\n        CHANGES.txt to be found first.\n        \"\"\"\n        if type(names) is str:\n            names = [names]\n        lower_names = []\n        for name in names:\n            lower_names.append(name.lower())\n        names = lower_names\n        files = self.list_files()\n        found = []\n        for fullpath in files:\n            filename = os.path.basename(fullpath)\n            if filename.lower() in names:\n                logger.debug(\"Found %s\", fullpath)\n                if not os.path.exists(fullpath):\n                    # Strange.  It at least happens in the tests when\n                    # we deliberately remove a CHANGES.txt file.\n                    logger.warn(\"Found file %s in version control but not on \"\n                                \"file system.\", fullpath)\n                    continue\n                found.append(fullpath)\n        if not found:\n            return\n        if len(found) > 1:\n            found.sort(key=len)\n            logger.warn(\"Found more than one file, picked the shortest one to \"\n                        \"change: %s\", ', '.join(found))\n        return found[0]"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef history_file(self, location=None):\n        if location:\n            # Hardcoded location passed from the config file.\n            if os.path.exists(location):\n                return location\n            else:\n                logger.warn(\"The specified history file %s doesn't exist\",\n                            location)\n        filenames = []\n        for base in ['CHANGES', 'HISTORY', 'CHANGELOG']:\n            filenames.append(base)\n            for extension in ['rst', 'txt', 'markdown']:\n                filenames.append('.'.join([base, extension]))\n        history = self.filefind(filenames)\n        if history:\n            return history", "response": "Return the location of the history file."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncheck if a tag exists with the name of the version.", "response": "def tag_exists(self, version):\n        \"\"\"Check if a tag has already been created with the name of the\n        version.\n        \"\"\"\n        for tag in self.available_tags():\n            if tag == version:\n                return True\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nupdates the version of the current version.", "response": "def _update_version(self, version):\n        \"\"\"Find out where to change the version and change it.\n\n        There are three places where the version can be defined. The first one\n        is an explicitly defined Python file with a ``__version__``\n        attribute. The second one is some version.txt that gets read by\n        setup.py. The third is directly in setup.py.\n        \"\"\"\n        if self.get_python_file_version():\n            setup_cfg = pypi.SetupConfig()\n            filename = setup_cfg.python_file_with_version()\n            lines = open(filename).read().split('\\n')\n            for index, line in enumerate(lines):\n                match = UNDERSCORED_VERSION_PATTERN.search(line)\n                if match:\n                    lines[index] = \"__version__ = '%s'\" % version\n            contents = '\\n'.join(lines)\n            open(filename, 'w').write(contents)\n            logger.info(\"Set __version__ in %s to %r\", filename, version)\n            return\n\n        versionfile = self.filefind(['version.txt', 'version'])\n        if versionfile:\n            # We have a version.txt file but does it match the setup.py\n            # version (if any)?\n            setup_version = self.get_setup_py_version()\n            if not setup_version or (setup_version ==\n                                     self.get_version_txt_version()):\n                open(versionfile, 'w').write(version + '\\n')\n                logger.info(\"Changed %s to %r\", versionfile, version)\n                return\n\n        good_version = \"version = '%s'\" % version\n        line_number = 0\n        setup_lines = open('setup.py').read().split('\\n')\n        for line in setup_lines:\n            match = VERSION_PATTERN.search(line)\n            if match:\n                logger.debug(\"Matching version line found: %r\", line)\n                if line.startswith(' '):\n                    # oh, probably '    version = 1.0,' line.\n                    indentation = line.split('version')[0]\n                    # Note: no spaces around the '='.\n                    good_version = indentation + \"version='%s',\" % version\n                setup_lines[line_number] = good_version\n                break\n            line_number += 1\n        contents = '\\n'.join(setup_lines)\n        open('setup.py', 'w').write(contents)\n        logger.info(\"Set setup.py's version to %r\", version)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef function(on_yield=None, progress=False, dt=None):\n    if dt is not None:\n        dt = float(dt)\n        if dt <= 0.0:\n          error = \"dt={0} is invalid, use a positive number (or None).\"\n          raise ValueError(error.format(dt))\n\n    def decorator(generator_function):\n        def function_(*args, **kwargs):\n            if on_yield is not None:\n                yield_handler = on_yield()\n            else:\n                yield_handler = None\n\n            generator = generator_function(*args, **kwargs)\n            t0 = t = None\n            multiplier = None\n            while True:\n                try:\n                    info = generator.send(multiplier)\n                    if progress:\n                        progress_, result = info\n                    else:\n                        progress_, result = None, info\n\n                    rt = float(\"nan\")\n                    if t0 is None: # first yield\n                        t0 = t = time.time()\n                    else:\n                        t_ = time.time()\n                        dt_ = t_ - t\n                        t = t_\n                        if dt:\n                            try:\n                                multiplier = dt / dt_\n                            except ZeroDivisionError: # unspecified behavior\n                                multiplier = float(\"inf\")\n                        if progress_ is not None:\n                            q = (1.0 - progress_) * (t - t0)\n                            try:\n                                rt = q / progress_\n                            except ZeroDivisionError: # unspecified behavior\n                                if q != 0.0:\n                                    sign = (q > 0.0) - (q < 0.0) \n                                    rt = sign * float(\"inf\")\n                                # otherwise, rt = 0.0 / 0.0, and the default\n                                # (rt = nan) is fine.\n                    if yield_handler:\n                        handler_result = yield_handler(progress=progress_, \n                                                       elapsed=t-t0, \n                                                       remaining=rt, \n                                                       result=result,\n                                                       # not documented:\n                                                       args=args,     \n                                                       kwargs=kwargs)\n\n                        if handler_result is not None:\n                            return handler_result # not documented.\n                            # The case where we want to stop the execution\n                            # *and* return None is not supported.\n                except StopIteration:\n                    return result\n        function_.decorator = decorator\n        function_.generator = generator_function\n        return function_\n    return decorator", "response": "Returns a new generator function that can be used to generate a new object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndetect the current size of the terminal window as a numer of rows and columns.", "response": "def terminal_size():\n    \"\"\"\n    Detect the current size of terminal window as a numer of rows and columns.\n    \"\"\"\n    try:\n        (rows, columns) = os.popen('stty size', 'r').read().split()\n        rows    = int(rows)\n        columns = int(columns)\n        return (columns, rows)\n\n    # Currently ignore any errors and return some reasonable default values.\n    # Errors may occur, when the library is used in non-terminal application\n    # like daemon.\n    except:\n        pass\n    return (80, 24)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a list of all appropriate settings and their default values.", "response": "def list_settings(self):\n        \"\"\"\n        Get list of all appropriate settings and their default values.\n\n        The returned list is then used in setup() and get_setup() methods to setup\n        the widget internal settings.\n        \"\"\"\n        return [\n            (self.SETTING_FLAG_PLAIN, False),\n            (self.SETTING_FLAG_ASCII, False),\n            (self.SETTING_WIDTH, 0),\n            (self.SETTING_ALIGN, '<'),\n            (self.SETTING_TEXT_FORMATING, {}),\n            (self.SETTING_DATA_FORMATING, '{:s}'),\n            (self.SETTING_DATA_TYPE, None),\n            (self.SETTING_PADDING, None),\n            (self.SETTING_PADDING_CHAR, ' '),\n            (self.SETTING_PADDING_LEFT, None),\n            (self.SETTING_PADDING_RIGHT, None),\n            (self.SETTING_MARGIN, None),\n            (self.SETTING_MARGIN_CHAR, ' '),\n            (self.SETTING_MARGIN_LEFT, None),\n            (self.SETTING_MARGIN_RIGHT, None),\n        ]"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets current setup by combining the internal settings with the ones given.", "response": "def get_setup(self, content = None, **kwargs):\n        \"\"\"\n        Get current setup by combining internal settings with the ones given.\n        \"\"\"\n        if content is None:\n            content = self.content\n        if content is None:\n            raise Exception(\"No content given to be displayed\")\n\n        setup = {}\n        for setting in self.list_settings():\n            if setting[0] in kwargs:\n                setup[setting[0]] = kwargs.get(setting[0])\n            else:\n                setup[setting[0]] = self._settings.get(setting[0])\n\n        return (content, setup)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _es_data(settings):\n        return {k: settings[k] for k in (ConsoleWidget.SETTING_DATA_FORMATING,\n                                         ConsoleWidget.SETTING_DATA_TYPE)}", "response": "Extract data formating related subset of widget settings."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nextracts content formating related subset of widget settings.", "response": "def _es_content(settings):\n        \"\"\"\n        Extract content formating related subset of widget settings.\n        \"\"\"\n        return {k: settings[k] for k in (ConsoleWidget.SETTING_WIDTH,\n                                         ConsoleWidget.SETTING_ALIGN,\n                                         ConsoleWidget.SETTING_PADDING,\n                                         ConsoleWidget.SETTING_PADDING_LEFT,\n                                         ConsoleWidget.SETTING_PADDING_RIGHT,\n                                         ConsoleWidget.SETTING_PADDING_CHAR)}"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nextract text formating related subset of widget settings.", "response": "def _es_text(settings, text_formating = {}):\n        \"\"\"\n        Extract text formating related subset of widget settings.\n        \"\"\"\n        s = {k: settings[k] for k in (ConsoleWidget.SETTING_FLAG_PLAIN,)}\n        s.update(text_formating)\n        return s"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nextracts margin formating related subset of widget settings.", "response": "def _es_margin(settings):\n        \"\"\"\n        Extract margin formating related subset of widget settings.\n        \"\"\"\n        return {k: settings[k] for k in (ConsoleWidget.SETTING_MARGIN,\n                                         ConsoleWidget.SETTING_MARGIN_LEFT,\n                                         ConsoleWidget.SETTING_MARGIN_RIGHT,\n                                         ConsoleWidget.SETTING_MARGIN_CHAR)}"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncalculating actual widget width based on given margins.", "response": "def calculate_width_widget(width, margin = None, margin_left = None, margin_right = None):\n        \"\"\"\n        Calculate actual widget width based on given margins.\n        \"\"\"\n        if margin_left is None:\n            margin_left = margin\n        if margin_right is None:\n            margin_right = margin\n        if margin_left is not None:\n            width -= int(margin_left)\n        if margin_right is not None:\n            width -= int(margin_right)\n        return width if width > 0 else None"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef fmt_data(text, data_formating = None, data_type = None):\n        if data_type:\n            return DATA_TYPES[data_type](text)\n        elif data_formating:\n            return str(data_formating).format(text)\n        return str(text)", "response": "Format given text according to given data formatting pattern or data type."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef fmt_content(text, width = 0, align = '<', padding = None, padding_left = None, padding_right = None, padding_char = ' '):\n        if padding_left is None:\n            padding_left = padding\n        if padding_right is None:\n            padding_right = padding\n        if padding_left is not None:\n            text = '{}{}'.format(str(padding_char)[0] * int(padding_left), text)\n        if padding_right is not None:\n            text = '{}{}'.format(text, str(padding_char)[0] * int(padding_right))\n        if width:\n            strptrn = '{:' + ('{}{}{}'.format(str(padding_char)[0], str(TEXT_ALIGNMENT[align]), str(width))) + 's}'\n            text = strptrn.format(text)\n        return text", "response": "Format the given text with given width and align."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\napplying given console formating around given text.", "response": "def fmt_text(text, bg = None, fg = None, attr = None, plain = False):\n        \"\"\"\n        Apply given console formating around given text.\n        \"\"\"\n        if not plain:\n            if fg is not None:\n                text = TEXT_FORMATING['fg'][fg] + text\n            if bg is not None:\n                text = TEXT_FORMATING['bg'][bg] + text\n            if attr is not None:\n                text = TEXT_FORMATING['attr'][attr] + text\n            if (fg is not None) or (bg is not None) or (attr is not None):\n                text += TEXT_FORMATING['rst']\n        return text"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nformat given text with given margin characters.", "response": "def fmt_margin(text, margin = None, margin_left = None, margin_right = None, margin_char = ' '):\n        \"\"\"\n        Surround given text with given margin characters.\n        \"\"\"\n        if margin_left is None:\n            margin_left = margin\n        if margin_right is None:\n            margin_right = margin\n        if margin_left is not None:\n            text = '{}{}'.format(str(margin_char)[0] * int(margin_left), text)\n        if margin_right is not None:\n            text = '{}{}'.format(text, str(margin_char)[0] * int(margin_right))\n        return text"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef render(self, content = None, **settings):\n        (content, settings) = self.get_setup(content, **settings)\n        return self._render(content, **settings)", "response": "Perform widget rendering, but do not print anything."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _render(self, content, **settings):\n        result = self._render_content(content, **settings)\n\n        s = self._es_margin(settings)\n        result = self.fmt_margin(result, **s)\n\n        return result", "response": "Render the content and return the formatted version of the content."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nrendering the content and return a list of the result.", "response": "def _render(self, content, **settings):\n        \"\"\"\n        Perform widget rendering, but do not print anything.\n        \"\"\"\n        lines = self._render_content(content, **settings)\n\n        result = []\n        s = self._es_margin(settings)\n        for l in lines:\n            result.append(self.fmt_margin(l, **s))\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndisplaying the content of the current instance.", "response": "def display(self, content = None, **settings):\n        \"\"\"\n        Perform widget rendering and output the result.\n        \"\"\"\n        lines = self.render(content, **settings)\n        for l in lines:\n            print(l)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef list_settings(self):\n        result = super().list_settings()\n        result.append((self.SETTING_FLAG_BORDER, True))\n        result.append((self.SETTING_BORDER_FORMATING, {}))\n        result.append((self.SETTING_BORDER_STYLE, 'utf8.a'))\n        return result", "response": "Get list of all appropriate settings and their default values."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the character that is used for a particular border piece.", "response": "def bchar(posh, posv, border_style):\n        \"\"\"\n        Retrieve table border style for particular box border piece.\n        \"\"\"\n        index = '{}{}'.format(posv, posh).lower()\n        return BORDER_STYLES[border_style][index]"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncalculate actual widget width based on given margins and paddings.", "response": "def calculate_width_widget_int(width, border = False, margin = None, margin_left = None, margin_right = None):\n        \"\"\"\n        Calculate actual widget content width based on given margins and paddings.\n        \"\"\"\n        if margin_left is None:\n            margin_left = margin\n        if margin_right is None:\n            margin_right = margin\n        if margin_left is not None:\n            width -= int(margin_left)\n        if margin_right is not None:\n            width -= int(margin_right)\n        if border:\n            width -= 2\n        return width if width > 0 else None"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncalculates actual width based on given margins and paddings.", "response": "def calculate_width_content(width, border = False, margin = None, margin_left = None, margin_right = None, padding = None, padding_left = None, padding_right = None):\n        \"\"\"\n        Calculate actual widget content width based on given margins and paddings.\n        \"\"\"\n        if margin_left is None:\n            margin_left = margin\n        if margin_right is None:\n            margin_right = margin\n        if margin_left is not None:\n            width -= int(margin_left)\n        if margin_right is not None:\n            width -= int(margin_right)\n        if padding_left is None:\n            padding_left = padding\n        if padding_right is None:\n            padding_right = padding\n        if padding_left is not None:\n            width -= int(padding_left)\n        if padding_right is not None:\n            width -= int(padding_right)\n        if border:\n            width -= 2\n        return width if width > 0 else None"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets list of all appropriate settings and their default values.", "response": "def list_settings(self):\n        \"\"\"\n        Get list of all appropriate settings and their default values.\n        \"\"\"\n        result = super().list_settings()\n        result.append((self.SETTING_TEXT_HIGHLIGHT, None))\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _render_content(self, content, **settings):\n        ocontent = content\n\n        s = self._es_data(settings)\n        content = self.fmt_data(content, **s)\n\n        s = self._es_content(settings)\n        content = self.fmt_content(content, **s)\n\n        if settings[self.SETTING_TEXT_HIGHLIGHT]:\n            s = self._es_text(settings, settings[self.SETTING_TEXT_HIGHLIGHT](ocontent))\n        else:\n            s = self._es_text(settings, settings[self.SETTING_TEXT_FORMATING])\n        content = self.fmt_text(content, **s)\n\n        s = self._es_margin(settings)\n        content = self.fmt_margin(content, **s)\n\n        return content", "response": "Render the content according to the settings."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _render_content(self, content, **settings):\n        settings[self.SETTING_WIDTH] = TERMINAL_WIDTH\n        return super()._render_content(content, **settings)", "response": "Render the content of the widget."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets list of all appropriate settings and their default values.", "response": "def list_settings(self):\n        \"\"\"\n        Get list of all appropriate settings and their default values.\n        \"\"\"\n        result = super().list_settings()\n        result.append((self.SETTING_LIST_FORMATING, {}))\n        result.append((self.SETTING_LIST_STYLE, 'utf8.a'))\n        result.append((self.SETTING_LIST_TYPE, 'unordered'))\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _render_item(self, depth, key, value = None, **settings):\n        strptrn  = self.INDENT * depth\n\n        lchar = self.lchar(settings[self.SETTING_LIST_STYLE])\n        s = self._es_text(settings, settings[self.SETTING_LIST_FORMATING])\n        lchar = self.fmt_text(lchar, **s)\n\n        strptrn = \"{}\"\n        if value is not None:\n            strptrn += \": {}\"\n        s = self._es_text(settings, settings[self.SETTING_TEXT_FORMATING])\n        strptrn = self.fmt_text(strptrn.format(key, value), **s)\n\n        return '{} {} {}'.format(self.INDENT * depth, lchar, strptrn)", "response": "Format single list item."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting list of all appropriate settings and their default values.", "response": "def list_settings(self):\n        \"\"\"\n        Get list of all appropriate settings and their default values.\n        \"\"\"\n        result = super().list_settings()\n        result.append((self.SETTING_TREE_FORMATING, {}))\n        result.append((self.SETTING_TREE_STYLE, 'utf8.a'))\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef tchar(tree_style, cur_level, level, item, size):\n        if (cur_level == level):\n            i1 = '1' if level == 0 else 'x'\n            i2 = '1' if item  == 0 else 'x'\n            i3 = 'x'\n            if size == 1:\n                i3 = '1'\n            elif item == (size - 1):\n                i3 = 'l'\n            index = '{}{}{}'.format(i1, i2, i3)\n        else:\n            index = 'non' if item == (size - 1) else 'ver'\n        return TREE_STYLES[tree_style][index]", "response": "Retrieve tree character for particular tree node."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _render_item(self, dstack, key, value = None, **settings):\n        cur_depth = len(dstack) - 1\n\n        treeptrn = ''\n        s = self._es_text(settings, settings[self.SETTING_TREE_FORMATING])\n        for ds in dstack:\n            treeptrn += ' ' + self.fmt_text(self.tchar(settings[self.SETTING_TREE_STYLE], cur_depth, *ds), **s) + ''\n\n        strptrn = \"{}\"\n        if value is not None:\n            strptrn += \": {}\"\n        s = self._es_text(settings, settings[self.SETTING_TEXT_FORMATING])\n        strptrn = self.fmt_text(strptrn.format(key, value), **s)\n\n        return '{} {}'.format(treeptrn, strptrn)", "response": "Format single tree line."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _render_content(self, content, **settings):\n        if isinstance(content, dict):\n            return self._render_content_dict(content, 0, [], **settings)\n        elif isinstance(content, list):\n            return self._render_content_list(content, 0, [], **settings)\n        else:\n            raise Exception(\"Received invalid data tree for rendering.\")", "response": "Render the tree widget."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef list_settings(self):\n        result = super().list_settings()\n        result.append((self.SETTING_FLAG_HEADER, True))\n        result.append((self.SETTING_HEADER_CONTENT, 'Notice'))\n        result.append((self.SETTING_HEADER_FORMATING, {}))\n        return result", "response": "Get list of all appropriate settings and their default values."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nformatting the border of the log entry.", "response": "def fmt_border(self, width, t = 'm', border_style = 'utf8.a', border_formating = {}):\n        \"\"\"\n        Format box separator line.\n        \"\"\"\n        border = self.bchar('l', t, border_style) + (self.bchar('h', t, border_style) * (width-2)) + self.bchar('r', t, border_style)\n        return self.fmt_text(border, **border_formating)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nwraps given content into lines of given width.", "response": "def _wrap_content(content, width):\n        \"\"\"\n        Wrap given content into lines of given width.\n        \"\"\"\n        data = []\n        if isinstance(content, list):\n            data += content\n        else:\n            data.append(content)\n\n        lines = []\n        for d in data:\n            l = textwrap.wrap(d, width)\n            lines += l\n        return lines"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nrenders box border line.", "response": "def _render_border_line(self, t, settings):\n        \"\"\"\n        Render box border line.\n        \"\"\"\n        s = self._es(settings, self.SETTING_WIDTH, self.SETTING_MARGIN, self.SETTING_MARGIN_LEFT, self.SETTING_MARGIN_RIGHT)\n        w = self.calculate_width_widget(**s)\n        s = self._es(settings, self.SETTING_BORDER_STYLE, self.SETTING_BORDER_FORMATING)\n        border_line = self.fmt_border(w, t, **s)\n        s = self._es(settings, self.SETTING_MARGIN, self.SETTING_MARGIN_LEFT, self.SETTING_MARGIN_RIGHT, self.SETTING_MARGIN_CHAR)\n        border_line = self.fmt_margin(border_line, **s)\n        return border_line"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _render_line(self, line, settings):\n        s = self._es(settings, self.SETTING_WIDTH, self.SETTING_FLAG_BORDER, self.SETTING_MARGIN, self.SETTING_MARGIN_LEFT, self.SETTING_MARGIN_RIGHT)\n        width_content = self.calculate_width_widget_int(**s)\n\n        s = self._es_content(settings)\n        s[self.SETTING_WIDTH] = width_content\n        line = self.fmt_content(line, **s)\n\n        s = self._es_text(settings, settings[self.SETTING_TEXT_FORMATING])\n        line = self.fmt_text(line, **s)\n\n        s = self._es(settings, self.SETTING_BORDER_STYLE)\n        bchar = self.bchar('v', 'm', **s)\n\n        s = self._es_text(settings, settings[self.SETTING_BORDER_FORMATING])\n        bchar = self.fmt_text(bchar, **s)\n\n        line = '{}{}{}'.format(bchar, line, bchar)\n        s = self._es_margin(settings)\n        line = self.fmt_margin(line, **s)\n        return line", "response": "Render single box line."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _render_content(self, content, **settings):\n        if not self.SETTING_WIDTH in settings or not settings[self.SETTING_WIDTH]:\n            settings[self.SETTING_WIDTH] = TERMINAL_WIDTH\n\n        s = {k: settings[k] for k in (self.SETTING_WIDTH, self.SETTING_FLAG_BORDER, self.SETTING_MARGIN, self.SETTING_MARGIN_LEFT, self.SETTING_MARGIN_RIGHT, self.SETTING_PADDING, self.SETTING_PADDING_LEFT, self.SETTING_PADDING_RIGHT)}\n        width_int = self.calculate_width_content(**s)\n\n        lines = self._wrap_content(content, width_int)\n\n        result = []\n        if settings[self.SETTING_FLAG_BORDER]:\n            result.append(self._render_border_line('t', settings))\n        if settings[self.SETTING_FLAG_HEADER]:\n            s = {k: settings[k] for k in settings.keys()}\n            s[self.SETTING_TEXT_FORMATING] = s[self.SETTING_HEADER_FORMATING]\n            result.append(self._render_line(settings[self.SETTING_HEADER_CONTENT], s))\n            result.append(self._render_border_line('m', settings))\n        for l in lines:\n            result.append(self._render_line(l, settings))\n        if settings[self.SETTING_FLAG_BORDER]:\n            result.append(self._render_border_line('b', settings))\n        return result", "response": "Render the content of the current page."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets list of all appropriate settings and their default values.", "response": "def list_settings(self):\n        \"\"\"\n        Get list of all appropriate settings and their default values.\n        \"\"\"\n        result = super().list_settings()\n        result.append((self.SETTING_FLAG_HEADER, True))\n        result.append((self.SETTING_HEADER_CONTENT, 'Notice'))\n        result.append((self.SETTING_HEADER_FORMATING, {'attr': 'bold'}))\n        result.append((self.SETTING_FLAG_ENUMERATE, False))\n        result.append((self.SETTING_COLUMNS, None))\n        result.append((self.SETTING_ROW_HIGHLIGHT, None))\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef fmt_border(self, dimensions, t = 'm', border_style = 'utf8.a', border_formating = {}):\n        cells = []\n        for column in dimensions:\n            cells.append(self.bchar('h', t, border_style) * (dimensions[column] + 2))\n\n        border = '{}{}{}'.format(self.bchar('l', t, border_style), self.bchar('m', t, border_style).join(cells), self.bchar('r', t, border_style))\n        return self.fmt_text(border, **border_formating)", "response": "Format the table border."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef fmt_cell(self, value, width, cell_formating, **text_formating):\n        strptrn = \" {:\" + '{:s}{:d}'.format(cell_formating.get('align', '<'), width) + \"s} \"\n        strptrn = self.fmt_text(strptrn, **text_formating)\n        return strptrn.format(value)", "response": "Format sigle table cell."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef fmt_row(self, columns, dimensions, row, **settings):\n        cells = []\n        i = 0\n        for column in columns:\n            cells.append(self.fmt_cell(\n                    row[i],\n                    dimensions[i],\n                    column,\n                    **settings[self.SETTING_TEXT_FORMATING]\n                )\n            )\n            i += 1\n        return self.bchar('v', 'm', settings[self.SETTING_BORDER_STYLE], **settings[self.SETTING_BORDER_FORMATING]) + \\\n               self.bchar('v', 'm', settings[self.SETTING_BORDER_STYLE], **settings[self.SETTING_BORDER_FORMATING]).join(cells) + \\\n               self.bchar('v', 'm', settings[self.SETTING_BORDER_STYLE], **settings[self.SETTING_BORDER_FORMATING])", "response": "Format single table row."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nformats table header row.", "response": "def fmt_row_header(self, columns, dimensions, **settings):\n        \"\"\"\n        Format table header row.\n        \"\"\"\n        row = list(map(lambda x: x['label'], columns))\n        return self.fmt_row(columns, dimensions, row, **settings)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef table_format(self, columns, content):\n        result = []\n        textw = TextWidget()\n        for row in content:\n            i = 0\n            result_row = []\n            for cell in row:\n                result_row.append(textw.render(cell, **columns[i]))\n                i += 1\n            result.append(result_row)\n        return (columns, result)", "response": "Format the table content."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nenumerate each table column.", "response": "def table_enumerate(self, columns, content):\n        \"\"\"\n        Enumerate each table column.\n        \"\"\"\n        columns.insert(0, { 'label': '#', 'enumerated': True })\n        i = 0\n        for row in content:\n            i += 1\n            row.insert(0, '{:d}'.format(i))\n        return (columns, content)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef table_measure(self, columns, content):\n        dimensions = {}\n        for row in content:\n            i = 0\n            for cell in row:\n                # Calculate maximum from:\n                dimensions[i] = max(\n                        dimensions.get(i, 0),              # current column max width\n                        len(cell),                         # current cell value width\n                        len(columns[i].get('label', '')),  # column label width\n                        columns[i].get('width_min', 0),    # configured column minimal width\n                    )\n                i += 1\n        return dimensions", "response": "Measure the width of each table column."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _render_content(self, content, **settings):\n        result = []\n        columns = settings[self.SETTING_COLUMNS]\n\n        # Format each table cell into string.\n        (columns, content) = self.table_format(columns, content)\n\n        # Enumerate each table row.\n        if settings[self.SETTING_FLAG_ENUMERATE]:\n            (columns, content) = self.table_enumerate(columns, content)\n\n        # Calculate the dimensions of each table column.\n        dimensions = self.table_measure(columns, content)\n\n        # Display table header.\n        sb = {k: settings[k] for k in (self.SETTING_BORDER_STYLE, self.SETTING_BORDER_FORMATING)}\n        result.append(self.fmt_border(dimensions, 't', **sb))\n        if settings[self.SETTING_FLAG_HEADER]:\n            s = {k: settings[k] for k in (self.SETTING_FLAG_PLAIN, self.SETTING_BORDER_STYLE, self.SETTING_BORDER_FORMATING)}\n            s[self.SETTING_TEXT_FORMATING] = settings[self.SETTING_HEADER_FORMATING]\n            result.append(self.fmt_row_header(columns, dimensions, **s))\n            result.append(self.fmt_border(dimensions, 'm', **sb))\n\n        # Display table body.\n        for row in content:\n            s = {k: settings[k] for k in (self.SETTING_FLAG_PLAIN, self.SETTING_BORDER_STYLE, self.SETTING_BORDER_FORMATING)}\n            s[self.SETTING_TEXT_FORMATING] = settings[self.SETTING_TEXT_FORMATING]\n            result.append(self.fmt_row(columns, dimensions, row, **s))\n\n        # Display table footer\n        result.append(self.fmt_border(dimensions, 'b', **sb))\n        return result", "response": "Render the content of the current page."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef list_settings(self):\n        result = super().list_settings()\n        result.append((self.SETTING_BAR_FORMATING, {}))\n        result.append((self.SETTING_BAR_CHAR, '='))\n        result.append((self.SETTING_BAR_WIDTH, 0))\n        return result", "response": "Get list of all appropriate settings and their default values."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nrenders the content of the logo.", "response": "def _render_content(self, content, **settings):\n        \"\"\"\n        Perform widget rendering, but do not print anything.\n        \"\"\"\n        bar_len = int(settings[self.SETTING_BAR_WIDTH])\n        if not bar_len:\n            bar_len = TERMINAL_WIDTH - 10\n        percent = content\n        progress = \"\"\n        progress += str(settings[self.SETTING_BAR_CHAR]) * int(bar_len * percent)\n        s = {k: settings[k] for k in (self.SETTING_FLAG_PLAIN,)}\n        s.update(settings[self.SETTING_BAR_FORMATING])\n        progress = self.fmt_text(progress, **s)\n        progress += ' ' * int(bar_len - int(bar_len * percent))\n        return \"{:6.2f}% [{:s}]\".format(percent * 100, progress)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndisplay the widget content and output the result.", "response": "def display(self, content = None, **settings):\n        \"\"\"\n        Perform widget rendering and output the result.\n        \"\"\"\n        sys.stdout.write(\"\\r\")\n        sys.stdout.write(self.render(content, **settings))\n        sys.stdout.flush()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nmeasure the width of each table column.", "response": "def chart_measure(self, bars):\n        \"\"\"\n        Measure the width of each table column.\n        \"\"\"\n        width = 0\n        for bar in bars:\n            # Calculate maximum from:\n            width = max(\n                width,                      # current label max width\n                len(bar.get('label', '')),  # column label width\n                bar.get('width_min', 0),    # configured column minimal width\n            )\n        return width"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _render_bar(self, bar, value, max_value, label_width, bar_width, **settings):\n        percent = value / max_value\n        barstr = \"\"\n        barstr += str(settings[self.SETTING_BAR_CHAR]) * int(bar_width * percent)\n        s = {k: settings[k] for k in (self.SETTING_FLAG_PLAIN,)}\n        s.update(settings[self.SETTING_BAR_FORMATING])\n        barstr = self.fmt_text(barstr, **s)\n        barstr += ' ' * int(bar_width - int(bar_width * percent))\n        strptrn = \"{:\"+str(label_width)+\"s} [{:s}]\"\n        return strptrn.format(bar.get('label'), barstr)", "response": "Render single chart bar."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _render_content(self, content, **settings):\n        result = []\n        bars = settings[self.SETTING_BARS]\n\n        label_width = self.chart_measure(bars)\n        if not settings[self.SETTING_BAR_WIDTH]:\n            settings[self.SETTING_BAR_WIDTH] = TERMINAL_WIDTH - label_width - 3\n        max_value = max(content)\n        i = 0\n        for bar in content:\n            result.append(self._render_bar(bars[i], bar, max_value, label_width, **settings))\n            i += 1\n        return result", "response": "Render the content of the items in the list content."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngiving a Query obj return the corresponding sql", "response": "def build_select(query_obj):\n    \"\"\"\n    Given a Query obj, return the corresponding sql\n    \"\"\"\n    return build_select_query(query_obj.source, query_obj.fields, query_obj.filter, skip=query_obj.skip, \\\n                              limit=query_obj.limit, sort=query_obj.sort, distinct=query_obj.distinct)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nbuild the sql to insert the data into the table_name.", "response": "def build_insert(table_name, attributes):\n    \"\"\"\n    Given the table_name and the data, return the sql to insert the data\n    \"\"\"\n    sql = \"INSERT INTO %s\" %(table_name)\n    column_str = u\"\"\n    value_str = u\"\"\n    for index, (key, value) in enumerate(attributes.items()):\n        if index > 0:\n            column_str += u\",\"\n            value_str += u\",\"\n        column_str += key\n        value_str += value_to_sql_str(value)\n    sql = sql + u\"(%s) VALUES(%s)\" %(column_str, value_str)\n    return sql"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef make_gatherer(cls, cell, source_tiers, gatherby):\n        pending = collections.defaultdict(dict)\n        tier_hashes = [hash(x) for x in source_tiers]\n\n        @asyncio.coroutine\n        def organize(route, *args):\n            srchash = hash(route.source)\n            key = gatherby(*args)\n            group = pending[key]\n            assert srchash not in group\n            group[srchash] = args\n            if len(group) == len(tier_hashes):\n                del pending[key]\n                yield from route.emit(*[group[x] for x in tier_hashes])\n        return cls(cell, organize)", "response": "Produce a single source tier that gathers from a set of tiers when\n        is returned a unique result for each tier."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nwrap the coroutine with coordination throttles.", "response": "def coord_wrap(self, *args):\n        \"\"\" Wrap the coroutine with coordination throttles. \"\"\"\n        yield from self.cell.coord.start(self)\n        yield from self.coro(*args)\n        yield from self.cell.coord.finish(self)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nsend data to the next tier.", "response": "def emit(self, *args):\n        \"\"\" Send data to the next tier(s).  This call can be delayed if the\n        coordinator thinks the backlog is too high for any of the emit\n        destinations.  Likewise when buffering emit values prior to enqueuing\n        them we ask the coordinator if we should flush the buffer each time in\n        case the coordinator is managing the buffering by other metrics such\n        as latency. \"\"\"\n        if self.buffer is not None:\n            self.buffer.extend(args)\n            if self.buffer_max_size is not None:\n                flush = len(self.buffer) >= self.buffer_max_size\n            else:\n                flush = yield from self.cell.coord.flush(self)\n            if flush:\n                yield from self.flush()\n        else:\n            for t in self.dests:\n                yield from t.enqueue_task(self, *args)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef flush(self):\n        if self.buffer is None:\n            return\n        data = self.buffer\n        self.buffer = []\n        for x in self.dests:\n            yield from x.enqueue_task(self, *data)", "response": "Flushes the buffer of buffered tiers to our destination tiers."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadd a source tier to be called when another tier emits.", "response": "def add_source(self, tier):\n        \"\"\" Schedule this tier to be called when another tier emits. \"\"\"\n        tier.add_dest(self)\n        self.sources.append(tier)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nfreeing any potential cycles.", "response": "def close(self):\n        \"\"\" Free any potential cycles. \"\"\"\n        self.cell = None\n        self.coro = None\n        self.buffer = None\n        del self.dests[:]\n        del self.sources[:]"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds command - line arguments for yakonfig proper.", "response": "def add_arguments(parser):\n    '''Add command-line arguments for yakonfig proper.\n\n    This is part of the :class:`~yakonfig.Configurable` interface, and\n    is usually run by including :mod:`yakonfig` in the\n    :func:`parse_args()` module list.\n\n    :param argparse.ArgumentParser parser: command-line argument\n      parser\n\n    '''\n    parser.add_argument('--config', '-c', metavar='FILE',\n                        help='read configuration from FILE')\n    parser.add_argument('--dump-config', metavar='WHAT', nargs='?',\n                        help='dump out configuration then stop '\n                        '(default, effective, full)')"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef parse_args(parser, modules, args=None):\n    collect_add_argparse(parser, modules)\n    namespace = parser.parse_args(args)\n    try:\n        do_dump_config = getattr(namespace, 'dump_config', None)\n        set_default_config(modules, params=vars(namespace),\n                           validate=not do_dump_config)\n        if do_dump_config:\n            if namespace.dump_config == 'full':\n                to_dump = get_global_config()\n            elif namespace.dump_config == 'default':\n                to_dump = assemble_default_config(modules)\n            else:  # 'effective'\n                to_dump = diff_config(assemble_default_config(modules),\n                                      get_global_config())\n            yaml_mod.dump(to_dump, sys.stdout)\n            parser.exit()\n    except ConfigurationError as e:\n        parser.error(e)\n    return namespace", "response": "This function parses the command - line arguments and returns a new global configuration for the application."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets up global configuration for tests and noninteractive tools.", "response": "def set_default_config(modules, params=None, yaml=None, filename=None,\n                       config=None, validate=True):\n    \"\"\"Set up global configuration for tests and noninteractive tools.\n\n    `modules` is an iterable of\n    :class:`yakonfig.Configurable` objects, or anything\n    equivalently typed.  This function iterates through those objects\n    to produce a default configuration, reads `yaml` as though it were\n    the configuration file, and fills in any values from `params` as\n    though they were command-line arguments.  The resulting\n    configuration is set as the global configuration.\n\n    :param modules: modules or Configurable instances to use\n    :type modules: iterable of :class:`~yakonfig.Configurable`\n    :param dict params: dictionary of command-line argument key to values\n    :param str yaml: global configuration file\n    :param str filename: location of global configuration file\n    :param dict config: global configuration object\n    :param bool validate: check configuration after creating\n    :return: the new global configuration\n    :returntype: dict\n\n    \"\"\"\n    if params is None:\n        params = {}\n\n    # Get the configuration from the file, or from params['config']\n    file_config = {}\n    if yaml is None and filename is None and config is None:\n        if 'config' in params and params['config'] is not None:\n            filename = params['config']\n    if yaml is not None or filename is not None or config is not None:\n        if yaml is not None:\n            file_config = yaml_mod.load(StringIO(yaml))\n        elif filename is not None:\n            with open(filename, 'r') as f:\n                file_config = yaml_mod.load(f)\n        elif config is not None:\n            file_config = config\n\n    # First pass: set up to call replace_config()\n    # Assemble the configuration from defaults + file + arguments\n    base_config = copy.deepcopy(file_config)\n    create_config_tree(base_config, modules)\n    fill_in_arguments(base_config, modules, params)\n    default_config = assemble_default_config(modules)\n    base_config = overlay_config(default_config, base_config)\n\n    # Replace the modules list (accommodate external modules)\n    def replace_module(config, m):\n        name = getattr(m, 'config_name')\n        c = config.get(name, {})\n        if hasattr(m, 'replace_config'):\n            return getattr(m, 'replace_config')(c, name)\n        return m\n    modules = [replace_module(base_config, m) for m in modules]\n\n    # Reassemble the configuration again, this time reaching out to\n    # the environment\n    base_config = file_config\n    create_config_tree(base_config, modules)\n    fill_in_arguments(base_config, modules, params)\n    do_config_discovery(base_config, modules)\n    default_config = assemble_default_config(modules)\n    base_config = overlay_config(default_config, file_config)\n    fill_in_arguments(base_config, modules, params)\n\n    # Validate the configuration\n    if validate and len(modules) > 0:\n        mod = modules[-1]\n        checker = getattr(mod, 'check_config', None)\n        if checker is not None:\n            with _temporary_config():\n                set_global_config(base_config)\n                checker(base_config[mod.config_name], mod.config_name)\n\n    # All done, normalize and set the global configuration\n    normalize_config(base_config, modules)\n    set_global_config(base_config)\n    return base_config"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef defaulted_config(modules, params=None, yaml=None, filename=None,\n                     config=None, validate=True):\n    \"\"\"Context manager version of :func:`set_default_config()`.\n\n    Use this with a Python 'with' statement, like\n\n    >>> config_yaml = '''\n    ... toplevel:\n    ...   param: value\n    ... '''\n    >>> with yakonfig.defaulted_config([toplevel], yaml=config_yaml) as config:\n    ...    assert 'param' in config['toplevel']\n    ...    assert yakonfig.get_global_config('toplevel', 'param') == 'value'\n\n    On exit the global configuration is restored to its previous state\n    (if any).\n\n    :param modules: modules or Configurable instances to use\n    :type modules: iterable of :class:`~yakonfig.Configurable`\n    :param dict params: dictionary of command-line argument key to values\n    :param str yaml: global configuration file\n    :param str filename: location of global configuration file\n    :param dict config: global configuration object\n    :param bool validate: check configuration after creating\n    :return: the new global configuration\n\n    \"\"\"\n    with _temporary_config():\n        set_default_config(modules, params=params, yaml=yaml,\n                           filename=filename, config=config, validate=validate)\n        yield get_global_config()", "response": "Context manager version of set_default_config."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nverify that some dependent configuration is present and correct.", "response": "def check_toplevel_config(what, who):\n    \"\"\"Verify that some dependent configuration is present and correct.\n\n    This will generally be called from a\n    :meth:`~yakonfig.Configurable.check_config` implementation.\n    `what` is a :class:`~yakonfig.Configurable`-like object.  If the\n    corresponding configuration isn't present in the global\n    configuration, raise a :exc:`yakonfig.ConfigurationError`\n    explaining that `who` required it.  Otherwise call that module's\n    :meth:`~yakonfig.Configurable.check_config` (if any).\n\n    :param yakonfig.Configurable what: top-level module to require\n    :param str who: name of the requiring module\n    :raise yakonfig.ConfigurationError: if configuration for\n      `what` is missing or incorrect\n\n    \"\"\"\n    config_name = what.config_name\n    config = get_global_config()\n    if config_name not in config:\n        raise ConfigurationError(\n            '{0} requires top-level configuration for {1}'\n            .format(who, config_name))\n    checker = getattr(what, 'check_config', None)\n    if checker:\n        checker(config[config_name], config_name)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _recurse_config(parent_config, modules, f, prefix=''):\n    '''Walk through the module tree.\n\n    This is a helper function for :func:`create_config_tree` and\n    :func:`_walk_config`.  It calls `f` once for each module in the\n    configuration tree with parameters `parent_config`, `config_name`,\n    `prefix`, and `module`.  `parent_config[config_name]` may or may\n    not exist (but could be populated, as :func:`create_config_tree`).\n    If even the parent configuration doesn't exist, `parent_config`\n    could be :const:`None`.\n\n    :param dict parent_config: configuration dictionary holding\n      configuration for `modules`, or maybe :const:`None`\n    :param modules: modules or Configurable instances to use\n    :type modules: iterable of :class:`~yakonfig.configurable.Configurable`\n    :param f: callable to call on each module\n    :param str prefix: prefix name of `parent_config`\n    :return: `parent_config`\n\n    '''\n    for module in modules:\n        config_name = getattr(module, 'config_name', None)\n        if config_name is None:\n            raise ProgrammerError('{0!r} must provide a config_name'\n                                  .format(module))\n        new_name = prefix + config_name\n\n        f(parent_config, config_name, new_name, module)\n\n        try:\n            _recurse_config((parent_config or {}).get(config_name, None),\n                            getattr(module, 'sub_modules', []),\n                            f,\n                            new_name + '.')\n        except:\n            # achieve a sort of stack trace on the way out\n            logger.error('exception in _recurse_config of %s', module)\n            raise\n    return parent_config", "response": "Recursively calls f on each module in the configuration tree."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating a configuration tree from the provided configuration and modules.", "response": "def create_config_tree(config, modules, prefix=''):\n    '''Cause every possible configuration sub-dictionary to exist.\n\n    This is intended to be called very early in the configuration\n    sequence.  For each module, it checks that the corresponding\n    configuration item exists in `config` and creates it as an empty\n    dictionary if required, and then recurses into child\n    configs/modules.\n\n    :param dict config: configuration to populate\n    :param modules: modules or Configurable instances to use\n    :type modules: iterable of :class:`~yakonfig.configurable.Configurable`\n    :param str prefix: prefix name of the config\n    :return: `config`\n    :raises yakonfig.ConfigurationError: if an expected name is present\n      in the provided config, but that name is not a dictionary\n\n    '''\n    def work_in(parent_config, config_name, prefix, module):\n        if config_name not in parent_config:\n            # this is the usual, expected case\n            parent_config[config_name] = {}\n        elif not isinstance(parent_config[config_name], collections.Mapping):\n            raise ConfigurationError(\n                '{0} must be an object configuration'.format(prefix))\n        else:\n            # config_name is a pre-existing dictionary in parent_config\n            pass\n\n    _recurse_config(config, modules, work_in)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef collect_add_argparse(parser, modules):\n    def work_in(parent_config, config_name, prefix, module):\n        f = getattr(module, 'add_arguments', None)\n        if f is not None:\n            f(parser)\n    _recurse_config(dict(), modules, work_in)\n    return parser", "response": "Collect all command - line options."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nassembles the default configuration from a list of modules.", "response": "def assemble_default_config(modules):\n\n    \"\"\"Build the default configuration from a set of modules.\n\n    `modules` is an iterable of\n    :class:`yakonfig.configurable.Configurable` objects, or anything\n    equivalently typed.  This produces the default configuration from\n    that list of modules.\n\n    :param modules: modules or Configurable instances to use\n    :type modules: iterable of :class:`~yakonfig.configurable.Configurable`\n    :return: configuration dictionary\n\n    \"\"\"\n    def work_in(parent_config, config_name, prefix, module):\n        my_config = dict(getattr(module, 'default_config', {}))\n        if config_name in parent_config:\n            extra_config = parent_config[config_name]\n            raise ProgrammerError(\n                'config for {0} already present when about to fetch {3}.default_config (had {1!r} would have set {2!r})'.format(\n                    prefix, extra_config, my_config, module))\n        parent_config[config_name] = my_config\n    return _recurse_config(dict(), modules, work_in)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef fill_in_arguments(config, modules, args):\n    def work_in(config, module, name):\n        rkeys = getattr(module, 'runtime_keys', {})\n        for (attr, cname) in iteritems(rkeys):\n            v = args.get(attr, None)\n            if v is not None:\n                config[cname] = v\n    if not isinstance(args, collections.Mapping):\n        args = vars(args)\n    return _walk_config(config, modules, work_in)", "response": "Fill in configuration fields from command - line arguments."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef do_config_discovery(config, modules):\n    '''Let modules detect additional configuration values.\n\n    `config` is the initial dictionary with command-line and\n    file-derived values, but nothing else, filled in.  This calls\n    :meth:`yakonfig.configurable.Configurable.discover_config` on\n    every configuration module.  It is expect that this method will\n    modify the passed-in configuration dictionaries in place.\n\n    :param dict config: configuration tree to update\n    :param modules: modules or Configurable instances to use\n    :type modules: iterable of :class:`~yakonfig.configurable.Configurable`\n    :return: `config`\n\n    '''\n    def work_in(config, module, name):\n        f = getattr(module, 'discover_config', None)\n        if f:\n            f(config, name)\n    return _walk_config(config, modules, work_in)", "response": "Let modules detect additional configuration values."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef example_load_data(self):\n        # \u7279\u5f81\u5411\u91cf\n        self.x = constant([[0.7, 0.9]])\n\n        # \u6743\u91cd\u5411\u91cf, w1\u4ee3\u8868\u795e\u7ecf\u7f51\u7edc\u7684\u7b2c\u4e00\u5c42\uff0cw2\u4ee3\u8868\u795e\u7ecf\u7f51\u7edc\u7684\u7b2c\u4e8c\u5c42\n        self.w1 = Variable(random_normal([2, 3], stddev=1, seed=1))\n        self.w2 = Variable(random_normal([3, 1], stddev=1, seed=1))", "response": "Load data from the cache."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef example_compute(self):\n        a = matmul(self.x, self.w1)\n        y = matmul(a, self.w2)\n\n        sess = Session()\n        sess.run(self.w1.initializer)\n        sess.run(self.w2.initializer)\n        print('\u7b2c\u4e00\u79cd\uff1a', sess.run(y))\n        sess.close()", "response": "Compute the random key."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nload data from the cache", "response": "def example_2_load_data(self):\n        \"\"\"\n        \u52a0\u8f7d\u6570\u636e\n        \"\"\"\n        # \u6743\u91cd\u5411\u91cf, w1\u4ee3\u8868\u795e\u7ecf\u7f51\u7edc\u7684\u7b2c\u4e00\u5c42\uff0cw2\u4ee3\u8868\u795e\u7ecf\u7f51\u7edc\u7684\u7b2c\u4e8c\u5c42\n        self.w1 = Variable(random_normal([2, 3], stddev=1, seed=1))\n        self.w2 = Variable(random_normal([3, 1], stddev=1, seed=1))\n        # \u7279\u5f81\u5411\u91cf, \u533a\u522b\u662f\uff0c\u8fd9\u91cc\u4e0d\u4f1a\u5728\u8ba1\u7b97\u56fe\u4e2d\u751f\u6210\u8282\u70b9\n        #self.x = placeholder(float32, shape=(1, 2), name='input')\n        self.x = placeholder(float32, shape=(3, 2), name='input')"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef example_2_compute(self):\n        a = matmul(self.x, self.w1) # \u8ba1\u7b97\u795e\u7ecf\u7f51\u7edc\u7684\u7b2c\u4e00\u5c42\u7684\u8f93\u51fa\u5411\u91cf\n        y = matmul(a, self.w2) # \u4ee5\u7b2c\u4e00\u5c42\u7684\u8f93\u51fa\u4f5c\u4e3a\u7b2c\u4e8c\u5c42\u7684\u8f93\u5165\u518d\u6b21\u8ba1\u7b97\u7b2c\u4e8c\u5c42\u7684\u8f93\u51fa\n\n        sess = Session()\n        initOp = global_variables_initializer() # \u521d\u59cb\u5316\u6240\u6709\u53d8\u91cf\n        sess.run(initOp)\n        #print('\u7b2c\u4e8c\u79cd\uff1a', sess.run(y, feed_dict={self.x: [[0.7, 0.9]]}))\n        print('\u7b2c\u4e8c\u79cd\uff1a', sess.run(y, feed_dict={self.x: [[0.7, 0.9], [0.1, 0.4], [0.5, 0.8]]}))\n        sess.close()", "response": "example_2_compute - compute the n - th cluster"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef main(arguments=None, config=None):\n    # Parse options, initialize gathered stats\n    options = LoggOptions(arguments=arguments).parse()\n\n    # FIXME: pass in only config; set config.journal = options.journal\n    if not config:\n        config = options.config_file\n\n    logg = Logg(config, options.journal)\n\n    return logg.logg_record(options.logg, options.date)", "response": "Main function for the logg_record command."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nparsing the shared [ i ] did arguments and return a tuple containing the populated namespace and the list of remaining arguments.", "response": "def parse(self, arguments=None):\n        \"\"\" Parse the shared [i]did arguments \"\"\"\n        arguments = self.arguments or arguments\n        # FIXME: prep/normalize arguments in __init__\n        # Split arguments if given as string and run the parser\n        if isinstance(arguments, basestring):\n            arguments = utils.split(arguments)\n\n        # run the wrapped argparser command to gather user set arg values\n        # FROM: https://docs.python.org/3/library/argparse.html\n        # Sometimes a script may only parse a few of the command-line\n        # arguments, passing the remaining arguments on to another script or\n        # program.  In these cases, the parse_known_args() method can be\n        # useful. It works much like parse_args() except that it does not\n        # produce an error when extra arguments are present. Instead, it\n        # returns a two item tuple containing the populated namespace and\n        # the list of remaining argument strings.\n        opts, _arguments = self.parser.parse_known_args(arguments)\n\n        if not opts.config_file:\n            opts.config_file = os.path.expanduser(DEFAULT_IDID_CONFIG)\n        opts.config = Configuration().from_file(opts.config_file)\n        # alias shortcut\n        self.config = opts.config\n\n        # if we're passing arguments in as a string we might get \\n's or null\n        # strings '' that we want to be sure to ignore\n        _arguments = filter(\n            lambda x: x if x else None, [_.strip() for _ in _arguments if _])\n\n        # Now let the subclass parse the remaining special opts that\n        # weren't consumed by default argparser\n        opts = self._parse(opts, _arguments)\n\n        return opts"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _parse_date(self, dt, fmt=None):\n        try:\n            # test if it's not a datelike instance ...\n            _dt = utils.Date(dt, fmt=fmt)\n        except ValueError:\n            # nope, not a datelike instance\n            _dt = None\n        return _dt", "response": "Try to convert a given value to a utils. Date instance"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _parse(self, opts, args):\n        k_args = len(args)\n        _dt = opts.date = None\n        logg = opts.logg = None\n        journal = opts.journal = None\n\n        default_journal = self.config.get('default_journal')\n        _journals = self.config.get('journals') or {}\n\n        log.debug(' ... got {0} args [{1}]'.format(k_args, args))\n        if k_args == 0 and default_journal:\n            # launch the editor to save a message into 'default' branch\n            # FIXME: 'unsorted' should be configurable as 'default branch'\n            log.warn('Target branch not set, using \"{0}\"'.format(\n                default_journal))\n            journal, logg = default_journal, '--'\n\n        elif k_args == 1:\n            # NOTE: two different usage patterns can be expected here\n            # 1) idid journal   # launch EDITOR for logg in target journal\n            # 2) idid 'logg record'  # save under default branch 'unsorted'\n            # if we have a value that's got more than one word in it, we\n            # assume it's a logg (B), otherwise (A)\n            arg = args.pop()\n            k_words = len(arg.split())\n            # variant A); user wants to launch the editor\n            # variany B); user wants to save record to 'master' branch\n            # default to an unspecified, unsorted target journal since\n            # journal not specified\n            if k_words == 1:\n                journal, logg = (arg, '--')\n            elif default_journal:\n                journal, logg = (default_journal, arg)\n            else:\n                raise RuntimeError('UNKNOWN ERROR')\n\n        elif k_args == 2:\n            # variants:\n            # 1) idid [datetime] 'logg message'\n            # 2) idid [datetime] journal  # launch editor\n            # 3) idid journal 'logg message'\n            # 4) idid unquoted logg message\n            _one = args[0].strip()\n            _two = args[1].strip()\n\n            # try to parse a date from the value\n            _dt = self._parse_date(_one, DT_ISO_FMT)\n\n            if _dt:\n                if _two in _journals:\n                    # scenario 2)\n                    journal, logg = (_two, '--')\n                else:\n                    # scenario 1)\n                    journal, logg = (_two, _one)\n            elif _one in _journals:\n                # senario 3)\n                journal, logg = (_one, _two)\n            elif default_journal:\n                # senario 4)\n                journal, logg = (default_journal, _two)\n            else:\n                raise RuntimeError(\"No journal specified.\")\n\n        elif k_args >= 3:\n            # variants:\n            # 1) idid [datetime] journal 'message'\n            # 2) idid [datetime] unquoted logg\n            # 3) idid journal unquoted logg\n            _one = args[0]\n            _two = args[1]\n            _three = ' '.join(args[2:])\n\n            # try to parse a date from the value\n            _dt = self._parse_date(_one, DT_ISO_FMT)\n\n            if _dt:\n                if _two in _journals:\n                    # scenario 1)\n                    journal, logg = (_two, _three)\n                elif default_journal:\n                    # scenario 2)\n                    journal, logg = (_two, ' '.join(args[1:]))\n                else:\n                    raise RuntimeError(\"No journal specified.\")\n            elif _one in _journals:\n                # senario 3)\n                journal, logg = (_one, ' '.join(args[1:]))\n            elif default_journal:\n                # senario 4)\n                journal, logg = (default_journal, ' '.join(args[:]))\n            else:\n                raise RuntimeError(\"No journal specified.\")\n\n        else:\n            raise RuntimeError(\"Ambiguous command line arguments!\")\n\n        opts.date = _dt or utils.Date('today', fmt=DT_ISO_FMT)\n        opts.journal = journal\n        opts.logg = logg\n        log.debug(' Found Date: {0}'.format(_dt))\n        log.debug(' Found Target: {0}'.format(journal))\n        log.debug(' Found Logg: {0}'.format(logg))\n        return opts", "response": "Perform additional check for idid command arguments"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nfinds the root. tex file in the current directory that can be considered a root.", "response": "def find_root_tex_document(base_dir=\".\"):\n    \"\"\"Find the tex article in the current directory that can be considered\n    a root. We do this by searching contents for ``'\\documentclass'``.\n\n    Parameters\n    ----------\n    base_dir : str\n        Directory to search for LaTeX documents, relative to the current\n        working directory.\n\n    Returns\n    -------\n    tex_path : str\n        Path to the root tex document relative to the current\n        working directory.\n    \"\"\"\n    log = logging.getLogger(__name__)\n    for tex_path in iter_tex_documents(base_dir=base_dir):\n        with codecs.open(tex_path, 'r', encoding='utf-8') as f:\n            text = f.read()\n            if len(docclass_pattern.findall(text)) > 0:\n                log.debug(\"Found root tex {0}\".format(tex_path))\n                return tex_path\n    log.warning(\"Could not find a root .tex file\")\n    raise RootNotFound"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef iter_tex_documents(base_dir=\".\"):\n    for path, dirlist, filelist in os.walk(base_dir):\n        for name in fnmatch.filter(filelist, \"*.tex\"):\n            yield os.path.join(path, name)", "response": "Iterate through all. tex documents in the current directory."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef inline(root_text,\n           base_dir=\"\",\n           replacer=None,\n           ifexists_replacer=None):\n    \"\"\"Inline all input latex files.\n\n    The inlining is accomplished recursively. All files are opened as UTF-8\n    unicode files.\n\n    Parameters\n    ----------\n    root_txt : unicode\n        Text to process (and include in-lined files).\n    base_dir : str\n        Base directory of file containing ``root_text``. Defaults to the\n        current working directory.\n    replacer : function\n        Function called by :func:`re.sub` to replace ``\\input`` expressions\n        with a latex document. Changeable only for testing purposes.\n    ifexists_replacer : function\n        Function called by :func:`re.sub` to replace ``\\InputIfExists``\n        expressions with a latex document. Changeable only for\n        testing purposes.\n\n    Returns\n    -------\n    txt : unicode\n        Text with referenced files included.\n    \"\"\"\n    def _sub_line(match):\n        \"\"\"Function to be used with re.sub to inline files for each match.\"\"\"\n        fname = match.group(1)\n        if not fname.endswith('.tex'):\n            full_fname = \".\".join((fname, 'tex'))\n        else:\n            full_fname = fname\n        full_path = os.path.abspath(os.path.join(base_dir, full_fname))\n        try:\n            with codecs.open(full_path, 'r', encoding='utf-8') as f:\n                included_text = f.read()\n        except IOError:\n            # TODO actually do logging here\n            print(\"Cannot open {0} for in-lining\".format(full_path))\n            return u\"\"\n        else:\n            # Recursively inline files\n            included_text = inline(included_text, base_dir=base_dir)\n            return included_text\n\n    def _sub_line_ifexists(match):\n        \"\"\"Function to be used with re.sub for the input_ifexists_pattern.\"\"\"\n        fname = match.group(1)\n        if not fname.endswith('.tex'):\n            full_fname = \".\".join((fname, 'tex'))\n        else:\n            full_fname = fname\n        full_path = os.path.abspath(os.path.join(base_dir, full_fname))\n\n        if os.path.exists(full_path):\n            with codecs.open(full_path, 'r', encoding='utf-8') as f:\n                included_text = f.read()\n            # Append extra info after input\n            included_text = \"\\n\".join((included_text, match.group(2)))\n        else:\n            # Use the fall-back clause in InputIfExists\n            included_text = match.group(3)\n        # Recursively inline files\n        included_text = inline(included_text, base_dir=base_dir)\n        return included_text\n\n    # Text processing pipline\n    result = remove_comments(root_text)\n    result = input_pattern.sub(_sub_line, result)\n    result = include_pattern.sub(_sub_line, result)\n    result = input_ifexists_pattern.sub(_sub_line_ifexists, result)\n    return result", "response": "Inline all input latex files and return the text."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set(self, name, value, ex=None, px=None, nx=False, xx=False):\n        self.client.set(name=name, value=value, px=px, nx=nx, xx=xx)", "response": "\u8bbe\u7f6e\u503c\uff0c\u4e0d\u5b58\u5728\u5219\u521b\u5efa\uff0c\u5b58\u5728\u5219\u4fee\u6539\n        :param name: key\n        :param value: value\n        :param ex: \u8fc7\u671f\u65f6\u95f4\uff08\u79d2\uff09\n        :param px: \u8fc7\u671f\u65f6\u95f4\uff08\u6beb\u79d2\uff09\n        :param nx: \u5982\u679c\u8bbe\u7f6e\u4e3aTrue\uff0c\u5219\u53ea\u6709name\u4e0d\u5b58\u5728\u65f6\uff0c\u5f53\u524d\u7684set\u64cd\u4f5c\u624d\u6267\u884c\n        :param xx: \u5982\u679c\u8bbe\u7f6e\u4e3aTrue\uff0c\u5219\u53ea\u6709nmae\u5b58\u5728\u65f6\uff0c\u5f53\u524d\u7684set\u64cd\u4f5c\u624d\u6267\u884c"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _get(self, uri, options):\n        url = \"http://%s/%s\" % (self.host, uri)\n        r = requests.get(url, params=options)\n        if r.status_code == 200:\n            data = r.json()\n            return data['results']\n        else:\n            # Throws anything not 200 error\n            r.raise_for_status()", "response": "Quick and dirty wrapper around the requests object to do\n           "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate a new Nagios server and return a list of modules to execute", "response": "def create(host, port):\n    \"\"\"\n    Prepare server to execute\n\n    :return: Modules to execute, cmd line function\n    :rtype: list[WrapperServer], callable | None\n    \"\"\"\n    wrapper = WrapperEchoServer({\n        'server': None\n    })\n    d = {\n        'listen_port': port,\n        'changer': wrapper\n    }\n    if host:\n        d['listen_bind_ip'] = host\n\n    ses = EchoServer(d)\n    wrapper.server = ses\n    return [wrapper], cmd_line"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef loadSettings(self):\n        self.settings.beginGroup('mainwindow')\n        geometry = self.settings.value('geometry').toByteArray()\n        state = self.settings.value('windowstate').toByteArray()\n\n        default_ramp_path = os.path.join(main_package_dir,\n                                         'examples/test_scene.json')\n\n        self.path_to_ramp_file = str(self.settings.value('path_to_ramp_file',\n                                     default_ramp_path).toString())\n        self.path_to_load_mot_file = str(self.settings.value('path_to_load_mot_file',\n                                         default_ramp_path).toString())\n        if not os.path.isfile(self.path_to_ramp_file):\n            self.path_to_ramp_file = default_ramp_path\n        self.settings.endGroup()\n\n        self.restoreGeometry(geometry)\n        self.restoreState(state)", "response": "Load window geometry and state from self. settings"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef saveSettings(self):\n        self.settings.beginGroup('mainwindow')\n        self.settings.setValue('geometry', self.saveGeometry())\n        self.settings.setValue('windowstate', self.saveState())\n        self.settings.setValue('path_to_ramp_file', self.path_to_ramp_file)\n        self.settings.setValue('path_to_load_mot_file',\n                               self.path_to_load_mot_file)\n        self.settings.endGroup()", "response": "Save the current settings to self. settings."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngrabbing the summary info and sets the corisponding attributes.", "response": "def fetch_summary(self):\n        \"\"\"\n        grabs the summary info and sets the corisponding attributes.\n        Note: overides existing attribute values for these attributes\n        \"\"\"\n        self.response_from()\n        #should really clean up the triple nest\n        for k,v in self.response.items():\n            if not isinstance(v,dict):\n                setattr(self,k,v)\n            else:\n                for subk,subv in v.items():\n                    if not isinstance(subv,dict):\n                        setattr(self,subk,subv)\n                    else:\n                        for ssk,ssv in subv.items():\n                            setattr(self,ssk,ssv)\n        self.fetched_summary = True"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nparse a JWKSet and return a dictionary that maps key IDs on keys.", "response": "def load(jwks):\n    \"\"\"Parse a JWKSet and return a dictionary that maps key IDs on keys.\"\"\"\n    sign_keys = {}\n    verify_keys = {}\n    try:\n        keyset = json.loads(jwks)\n        for key in keyset['keys']:\n            for op in key['key_ops']:\n                if op == 'sign':\n                    k = sign_keys\n                elif op == 'verify':\n                    k = verify_keys\n                else:\n                    raise JWKError(\"Unsupported key operation: {}\".format(op))\n                if key['kty'] == 'oct':\n                    k[key['kid']] = _Key(alg=key['alg'], key=base64.urlsafe_b64decode(key['k']))\n                elif key['kty'] == 'EC':\n                    alg, ec_key = _load_ecdsa(key, op == 'verify')\n                    k[key['kid']] = _Key(alg=alg, key=ec_key)\n                else:\n                    raise JWKError(\"Unsupported key type: {}\".format(key['kty']))\n    except (KeyError, json.JSONDecodeError) as e:\n        raise JWKError() from e\n    keys = _KeySet(signers=MappingProxyType(sign_keys), verifiers=MappingProxyType(verify_keys))\n    return keys"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef version():\n    path = join(\"lib\", _CONFIG[\"name\"], \"__version__.py\")\n    with open(path) as stream:\n        exec(stream.read())\n    return __version__", "response": "Get the local package version."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef run(self):\n        args = {\"remote\": self.remote, \"branch\": self.branch}\n        cmdl = \"git pull --ff-only {remote:s} {branch:s}\".format(**args)\n        try:\n            check_call(cmdl.split())\n        except CalledProcessError:\n            raise SystemExit(1)\n        log.info(\"package version is now {:s}\".format(version()))\n        return", "response": "Execute the command.\nAttributeNames"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreads the config path from environment variable CLOEEPY_CONFIG_PATH and sets the instance attr to the current instance.", "response": "def _set_config_path(self):\n        \"\"\"\n        Reads config path from environment variable CLOEEPY_CONFIG_PATH\n        and sets as instance attr\n        \"\"\"\n        self._path = os.getenv(\"CLOEEPY_CONFIG_PATH\")\n        if self._path is None:\n            msg = \"CLOEEPY_CONFIG_PATH is not set. Exiting...\"\n            sys.exit(msg)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _load_config(self):\n        if not os.path.exists(self._path):\n            sys.exit(\"Config path %s does not exist\" % self._path)\n        # create empty config object\n        self._config_dict = {}\n        # read file and marshal yaml\n        with open(self._path, 'r') as f:\n            self._raw = f.read()\n            self._config_dict = yaml.load(self._raw)", "response": "Loads the YAML configuration file and sets python dictionary and raw contents as instance attrs."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset the attributes of the object to the values of the config dictionary.", "response": "def _set_attributes(self):\n        \"\"\"\n        Recursively transforms config dictionaries into instance attrs to make\n        for easy dot attribute access instead of dictionary access.\n        \"\"\"\n        # turn config dict into nested objects\n        config = obj(self._config_dict)\n        # set the attributes onto instance\n        for k, v in self._config_dict.items():\n            setattr(self, k, getattr(config, k))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef colourise(__text: str, *args, **kwargs) -> str:\n    if sys.stdout.isatty():\n        __text = style(__text, *args, **kwargs)\n    return __text", "response": "Colourise text using click s style function."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef highlight(__text: str, *, lexer: str = 'diff',\n              formatter: str = 'terminal') -> str:\n    \"\"\"Highlight text highlighted using ``pygments``.\n\n    Returns text untouched if colour output is not enabled.\n\n    See also: :pypi:`Pygments`\n\n    Args:\n        __text: Text to highlight\n        lexer: Jinja lexer to use\n        formatter: Jinja formatter to use\n    Returns:\n        Syntax highlighted output, when possible\n    \"\"\"\n    if sys.stdout.isatty():\n        lexer = get_lexer_by_name(lexer)\n        formatter = get_formatter_by_name(formatter)\n        __text = pyg_highlight(__text, lexer, formatter)\n    return __text", "response": "Highlight text using pygments."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef html2text(__html: str, *, width: int = 80,\n              ascii_replacements: bool = False) -> str:\n    \"\"\"HTML to plain text renderer.\n\n    See also: :pypi:`html2text`\n\n    Args:\n        __html: Text to process\n        width: Paragraph width\n        ascii_replacements: Use pseudo-ASCII replacements for Unicode\n    Returns:\n        Rendered text\n    \"\"\"\n    html2.BODY_WIDTH = width\n    html2.UNICODE_SNOB = ascii_replacements\n    return html2.html2text(__html).strip()", "response": "HTML to plain text renderer."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef regexp(__string: str, __pattern: str, __repl: Union[Callable, str], *,\n           count: int = 0, flags: int = 0) -> str:\n    \"\"\"Jinja filter for regexp replacements.\n\n    See :func:`re.sub` for documentation.\n\n    Returns:\n        Text with substitutions applied\n    \"\"\"\n    return re.sub(__pattern, __repl, __string, count, flags)", "response": "Jinja filter for regexp replacements."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconfigure a new Jinja environment with our filters.", "response": "def setup(__pkg: str) -> jinja2.Environment:\n    \"\"\"Configure a new Jinja environment with our filters.\n\n    Args:\n        __pkg: Package name to use as base for templates searches\n    Returns:\n        Configured Jinja environment\n    \"\"\"\n    dirs = [path.join(d, 'templates')\n            for d in xdg_basedir.get_data_dirs(__pkg)]\n\n    env = jinja2.Environment(\n        autoescape=jinja2.select_autoescape(['html', 'xml']),\n        loader=jinja2.ChoiceLoader([jinja2.FileSystemLoader(s) for s in dirs]))\n    env.loader.loaders.append(jinja2.PackageLoader(__pkg, 'templates'))\n    env.filters.update(FILTERS)\n\n    return env"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate or updates single user account on intercom", "response": "def upload_intercom_user(obj_id):\n    \"\"\"Creates or updates single user account on intercom\"\"\"\n    UserModel = get_user_model()\n    intercom_user = False\n    instance = UserModel.objects.get(pk=obj_id)\n    data = instance.get_intercom_data()\n\n    if not getattr(settings, \"SKIP_INTERCOM\", False):\n        try:\n            intercom_user = intercom.users.create(**data)\n        except errors.ServiceUnavailableError:\n            pass\n\n    if intercom_user:\n        UserModel.objects.filter(pk=obj_id).update(\n            intercom_last_api_response=intercom_user.to_dict(),\n            intercom_api_response_timestamp=make_aware(datetime.now(), pytz.UTC)\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nuploads user data to intercom if user is not registered", "response": "def upload_not_registered_user_data(data):\n    \"\"\"\n        Upload user data to intercom, actually any data passed\n        data: Dict\n        Required:\n        \"email\"\n    \"\"\"\n    if type(data) != dict:\n        raise NotImplementedError(\"Incorrect data type\")\n\n    if not data.get(\"email\"):\n        raise KeyError(\"user_id as user.intercom_id or email is required\")\n\n    if not getattr(settings, \"SKIP_INTERCOM\", False):\n        intercom_data = {\n            \"email\": data.get(\"email\"),\n            \"name\": data.get(\"name\"),\n            \"last_request_at\": now().strftime(\"%s\"),\n        }\n        del(data[\"email\"])\n        if data.get(\"name\"):\n            del(data[\"name\"])\n        if data:\n            intercom_data[\"custom_attributes\"] = data\n        try:\n            intercom.users.create(**intercom_data)\n        except errors.ServiceUnavailableError:\n            pass"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nencode a dictionary to bytes.", "response": "def encoder(self, query: Dict[str, Any]):\n        \"\"\"\u7f16\u7801\u8bf7\u6c42\u4e3abytes.\n\n        \u68c0\u67e5\u662f\u5426\u4f7f\u7528debug\u6a21\u5f0f\u548c\u662f\u5426\u5bf9\u6570\u636e\u8fdb\u884c\u538b\u7f29.\u4e4b\u540e\u6839\u636e\u72b6\u6001\u5c06python\u5b57\u5178\u5f62\u5f0f\u7684\u8bf7\u6c42\u7f16\u7801\u4e3a\u5b57\u8282\u4e32.\n\n        Parameters:\n\n            query (Dict[str, Any]): - python\u5b57\u5178\u5f62\u5f0f\u7684\u8bf7\u6c42\u6570\u636e\n\n        Return:\n\n            (bytes): - \u8bf7\u6c42\u7684\u5b57\u8282\u4e32\n\n        \"\"\"\n        if self.debug is True:\n            queryb = json.dumps(\n                query,\n                ensure_ascii=False).encode(\"utf-8\")\n        else:\n            queryb = msgpack.packb(query)\n\n        if self.compreser:\n            queryb = self.compreser.compress(queryb)\n\n        return queryb + self.SEPARATOR"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nload locus exclusions. :param snps: Can either be a list of rsids or a file containing rsids. :return: None If snps is a file, the file must only contain RSIDs separated by whitespace (tabs, spaces and return characters).", "response": "def LoadExclusions(self, snps):\n        \"\"\" Load locus exclusions.\n\n        :param snps: Can either be a list of rsids or a file containing rsids.\n        :return: None\n\n        If snps is a file, the file must only contain RSIDs separated\n        by whitespace (tabs, spaces and return characters).\n        \"\"\"\n\n        snp_names = []\n        if len(snps) == 1 and os.path.isfile(snps[0]):\n            snp_names = open(snps).read().strip().split()\n        else:\n            snp_names = snps\n        for snp in snp_names:\n            if len(snp.strip()) > 0:\n                self.ignored_rs.append(snp)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreports the boundary configuration details.", "response": "def ReportConfiguration(self, f):\n        \"\"\"Report the boundary configuration details\n\n        :param f: File (or standard out/err)\n        :return: None\n        \"\"\"\n\n        if BoundaryCheck.chrom != -1:\n            print >> f, BuildReportLine(\"CHROM\", BoundaryCheck.chrom)\n            if len(self.bounds) > 0:\n                print >> f, BuildReportLine(\"SNP BOUNDARY\", \"-\".join(\n                    [str(x) for x in self.bounds]))\n        if len(self.ignored_rs) > 0:\n            print >> f, BuildReportLine(\"IGNORED RS\", \",\".join(self.ignored_rs))\n        if len(self.target_rs) > 0:\n            print >> f, BuildReportLine(\"TARGET RS\", \",\".join(self.target_rs))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef LoadSNPs(self, snps=[]):\n\n        for snp in snps:\n            bounds = snp.split(\"-\")\n            if len(bounds) == 1:\n                if bounds[0] != \"\":\n                    self.target_rs.append(bounds[0])\n            else:\n                raise InvalidBoundarySpec(snp)", "response": "Load the SNPs from the list of RSIDs."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef getserialnum(flist):\n    sn = []\n    for f in flist:\n        tmp = search(r'(?<=CamSer)\\d{3,6}', f)\n        if tmp:\n            ser = int(tmp.group())\n        else:\n            ser = None\n        sn.append(ser)\n    return sn", "response": "This function returns a list of the serial numbers of the camera in a particular place."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef getNeoParam(fn, FrameIndReq=None, ut1req=None, kineticsec=None, startUTC=None, cmosinit={}, verbose=False):\n    fn = Path(fn).expanduser()\n\n    nHeadBytes = 0\n\n    if fn.suffix.lower() in '.tiff':\n        if tifffile is None:\n            raise ImportError('pip install tifffile')\n        # FIXME didn't the 2011 TIFFs have headers? maybe not.\n        with tifffile.TiffFile(str(fn)) as f:\n            Y, X = f[0].shape\n            cmosinit = {'firstrawind': 1,\n                        'lastrawind': len(f)}\n    elif fn.suffix.lower() in '.fits':\n        with fits.open(fn, mode='readonly', memmap=False) as f:\n\n            kineticsec = f[0].header['KCT']\n            # TODO start of night's recording (with some Solis versionss)\n            startseries = parse(f[0].header['DATE'] + 'Z')\n\n            # TODO wish there was a better way\n            try:\n                frametxt = f[0].header['USERTXT1']\n                m = re.search('(?<=Images\\:)\\d+-\\d+(?=\\.)', frametxt)\n                inds = m.group(0).split('-')\n            except KeyError:  # just a single file?\n                # yes start with 1, end without adding 1 for Andor Solis\n                inds = [1, f[0].shape[0]]\n\n            cmosinit = {'firstrawind': int(inds[0]),\n                        'lastrawind': int(inds[1])}\n\n            # start = parse(f[0].header['FRAME']+'Z') No, incorrect by several hours with some 2015 Solis versions!\n\n            Y, X = f[0].shape[-2:]\n\n        startUTC = startseries.timestamp()\n\n# %% FrameInd relative to this file\n    PixelsPerImage, BytesPerImage, BytesPerFrame = howbig(X, Y, nHeadBytes)\n\n    FrameIndRel = whichframes(fn, FrameIndReq, kineticsec, ut1req, startUTC,\n                              cmosinit['firstrawind'], cmosinit['lastrawind'],\n                              BytesPerImage, BytesPerFrame, verbose)\n\n    assert isinstance(\n        FrameIndReq, int) or FrameIndReq is None, 'TODO: add multi-frame request case'\n    rawFrameInd = arange(cmosinit['firstrawind'],\n                         cmosinit['lastrawind'] + 1,\n                         FrameIndReq, dtype=int64)\n\n    finf = {'superx': X,\n            'supery': Y,\n            'nframeextract': FrameIndRel.size,\n            'nframe': rawFrameInd.size,\n            'frameindrel': FrameIndRel,\n            'frameind': rawFrameInd,\n            'kineticsec': kineticsec}\n# %% absolute frame timing (software, yikes)\n    finf['ut1'] = frame2ut1(startUTC, kineticsec, rawFrameInd)\n\n    return finf", "response": "get the parameter for a Neo sCMOS FITS file"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the current DMCframe and rawInd from the file f", "response": "def getDMCframe(f, iFrm: int, finf: dict, verbose: bool=False):\n    \"\"\"\n    f is open file handle\n    \"\"\"\n    # on windows, \"int\" is int32 and overflows at 2.1GB!  We need np.int64\n    currByte = iFrm * finf['bytesperframe']\n# %% advance to start of frame in bytes\n    if verbose:\n        print(f'seeking to byte {currByte}')\n\n    assert isinstance(iFrm, (int, int64)), 'int32 will fail on files > 2GB'\n\n    try:\n        f.seek(currByte, 0)\n    except IOError as e:\n        raise IOError(f'I couldnt seek to byte {currByte:d}. try using a 64-bit integer for iFrm \\n'\n                      'is {f.name} a DMCdata file?  {e}')\n# %% read data ***LABVIEW USES ROW-MAJOR C ORDERING!!\n    try:\n        currFrame = fromfile(f, uint16,\n                             finf['pixelsperimage']).reshape((finf['supery'], finf['superx']),\n                                                             order='C')\n    except ValueError as e:\n        raise ValueError(f'read past end of file?  {e}')\n\n    rawFrameInd = meta2rawInd(f, finf['nmetadata'])\n\n    if rawFrameInd is None:  # 2011 no metadata file\n        rawFrameInd = iFrm + 1  # fallback\n\n    return currFrame, rawFrameInd"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _fixSize(self):\n        self.height = 0\n        for o in self.options:\n            text = o['label']\n            font = o['font']\n            ren = font.render(text, 1, (0, 0, 0))\n            if ren.get_width() > self.width:\n                self.width = ren.get_width()\n            self.height += font.get_height()", "response": "Fix the menu size. Commonly called when the font is changed"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef update(self, events, time_passed=None):\n        for e in events:\n            if e.type == pygame.QUIT:\n                raise SystemExit\n\n            if e.type == pygame.KEYDOWN:\n                if e.key == pygame.K_ESCAPE:\n                    raise SystemExit\n                if e.key == pygame.K_DOWN:\n                    self.option += 1\n                if e.key == pygame.K_UP:\n                    self.option -= 1\n                if e.key == pygame.K_RETURN or e.key == pygame.K_SPACE:\n                    self.options[self.option]['callable']()\n            # Mouse controls\n            elif e.type == pygame.MOUSEBUTTONDOWN:\n                lb, cb, rb = pygame.mouse.get_pressed()\n                if lb:\n                    self.options[self.option]['callable']()\n        # Menu limits\n        if self.option > len(self.options) - 1:\n            self.option = len(self.options) - 1\n        elif self.option < 0:\n            self.option = 0\n        # Check for mouse position\n        if self.mouse_enabled:\n            self._checkMousePositionForFocus()\n        if time_passed:\n            self._updateEffects(time_passed)", "response": "Update the menu and get input for the menu."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nchecks the mouse position to know if focus on an option", "response": "def _checkMousePositionForFocus(self):\n        \"\"\"Check the mouse position to know if move focus on a option\"\"\"\n        i = 0\n        cur_pos = pygame.mouse.get_pos()\n        ml, mt = self.position\n        for o in self.options:\n            rect = o.get('label_rect')\n            if rect:\n                if rect.collidepoint(cur_pos) and self.mouse_pos != cur_pos:\n                    self.option = i\n                    self.mouse_pos = cur_pos\n                    break\n            i += 1"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef center_at(self, x, y):\n\n        self.x = x - (self.width / 2)\n        self.y = y - (self.height / 2)", "response": "Center the menu at x y"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef do_action(self, target, dry_run=False):\n        original_path = os.path.dirname(target)\n        original_filename, original_extension = os.path.splitext(os.path.basename(target))\n\n        new_filename = re.sub(self.match, self.replace_with, original_filename) + original_extension\n        destination = os.path.join(original_path, new_filename)\n\n        if dry_run is True:\n            self.logger.debug(\"Dry run: Skipping rename {0} to {1}\".format(target, new_filename))\n            return target\n        else:\n            self.logger.debug(\"Renaming {0} to {1}\".format(original_filename + original_extension,\n                                                           new_filename + original_extension))\n\n            if not os.path.exists(destination):\n                try:\n                    shutil.move(target, destination)\n                except IOError:\n                    self.logger.error(\"Error renaming file {0} to {1}\".format(target, new_filename))\n                    raise IOError\n            else:\n                self.logger.error(\"Destination file already exists: {0}\".format(new_filename))\n                raise IOError\n\n        return destination", "response": "Perform the action of the assessment."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nruns many bots in parallel.", "response": "def run_bots(bots):\n    \"\"\"\n    Run many bots in parallel.\n\n    :param bots: IRC bots to run.\n    :type bots: list\n    \"\"\"\n    greenlets = [spawn(bot.run) for bot in bots]\n    try:\n        joinall(greenlets)\n    except KeyboardInterrupt:\n        for bot in bots:\n            bot.disconnect()\n    finally:\n        killall(greenlets)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nparses the message from data.", "response": "def parse(cls, data):\n        \"\"\"\n        Extracts message informations from `data`.\n\n        :param data: received line.\n        :type data: unicode\n        :return: extracted informations (source, destination, command, args).\n        :rtype: tuple(Source, str, str, list)\n        :raise: :class:`fatbotslim.irc.NullMessage` if `data` is empty.\n        \"\"\"\n        src = u''\n        dst = None\n        if data[0] == u':':\n            src, data = data[1:].split(u' ', 1)\n        if u' :' in data:\n            data, trailing = data.split(u' :', 1)\n            args = data.split()\n            args.extend(trailing.split())\n        else:\n            args = data.split()\n        command = args.pop(0)\n        if command in (PRIVMSG, NOTICE):\n            dst = args.pop(0)\n            if ctcp_re.match(args[0]):\n                args = args[0].strip(u'\\x01').split()\n                command = u'CTCP_' + args.pop(0)\n        return Source(src), dst, command, args"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef parse(cls, prefix):\n        try:\n            nick, rest = prefix.split(u'!')\n        except ValueError:\n            return prefix, None, None, None\n        try:\n            mode, rest = rest.split(u'=')\n        except ValueError:\n            mode, rest = None, rest\n        try:\n            user, host = rest.split(u'@')\n        except ValueError:\n            return nick, mode, rest, None\n        return nick, mode, user, host", "response": "Parses a prefix with format <servername >|<nick > [ mode username host."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate a transport channel instance.", "response": "def _create_connection(self):\n        \"\"\"\n        Creates a transport channel.\n\n        :return: transport channel instance\n        :rtype: :class:`fatbotslim.irc.tcp.TCP` or :class:`fatbotslim.irc.tcp.SSL`\n        \"\"\"\n        transport = SSL if self.ssl else TCP\n        return transport(self.server, self.port)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconnecting the bot to the server and identifies itself.", "response": "def _connect(self):\n        \"\"\"\n        Connects the bot to the server and identifies itself.\n        \"\"\"\n        self.conn = self._create_connection()\n        spawn(self.conn.connect)\n        self.set_nick(self.nick)\n        self.cmd(u'USER', u'{0} 3 * {1}'.format(self.nick, self.realname))"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsends a raw line to the server.", "response": "def _send(self, command):\n        \"\"\"\n        Sends a raw line to the server.\n\n        :param command: line to send.\n        :type command: unicode\n        \"\"\"\n        command = command.encode('utf-8')\n        log.debug('>> ' + command)\n        self.conn.oqueue.put(command)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _event_loop(self):\n        while True:\n            orig_line = self.conn.iqueue.get()\n            log.debug('<< ' + orig_line)\n            line = u(orig_line, errors='replace').strip()\n            err_msg = False\n            try:\n                message = Message(line)\n            except ValueError:\n                err_msg = True\n            if err_msg or message.erroneous:\n                log.error(\"Received a line that can't be parsed: \\\"%s\\\"\" % orig_line)\n                continue\n            if message.command == ERR_NICKNAMEINUSE:\n                self.set_nick(IRC.randomize_nick(self.nick))\n            elif message.command == RPL_CONNECTED:\n                for channel in self.channels:\n                    self.join(channel)\n            self._handle(message)", "response": "The main event loop."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _handle(self, msg):\n\n        def handler_yielder():\n            for handler in self.handlers:\n                yield handler\n\n        def handler_callback(_):\n            if msg.propagate:\n                try:\n                    h = hyielder.next()\n                    g = self._pool.spawn(handler_runner, h)\n                    g.link(handler_callback)\n                except StopIteration:\n                    pass\n\n        def handler_runner(h):\n            for command in h.commands:\n                if command == msg.command:\n                    method = getattr(h, h.commands[command])\n                    method(msg)\n\n        hyielder = handler_yielder()\n        try:\n            next_handler = hyielder.next()\n            g = self._pool.spawn(handler_runner, next_handler)\n            g.link(handler_callback)\n        except StopIteration:\n            pass", "response": "Pass a received message to the registered handlers."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef randomize_nick(cls, base, suffix_length=3):\n        suffix = u''.join(choice(u'0123456789') for _ in range(suffix_length))\n        return u'{0}{1}'.format(base, suffix)", "response": "Generates a pseudo - random nickname."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nenable rights management provided by FATBotSlim.", "response": "def enable_rights(self):\n        \"\"\"\n        Enables rights management provided by :class:`fatbotslim.handlers.RightsHandler`.\n        \"\"\"\n        if self.rights is None:\n            handler_instance = RightsHandler(self)\n            self.handlers.insert(len(self.default_handlers), handler_instance)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndisable rights management provided by FatBotSlim.", "response": "def disable_rights(self):\n        \"\"\"\n        Disables rights management provided by :class:`fatbotslim.handlers.RightsHandler`.\n        \"\"\"\n        for handler in self.handlers:\n            if isinstance(handler, RightsHandler):\n                self.handlers.remove(handler)\n                break\n        self.rights = None"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add_handler(self, handler, args=None, kwargs=None):\n        args = [] if args is None else args\n        kwargs = {} if kwargs is None else kwargs\n        handler_instance = handler(self, *args, **kwargs)\n        if isinstance(handler_instance, RightsHandler):\n            self.rights = handler_instance\n        if handler_instance not in self.handlers:\n            self.handlers.append(handler_instance)", "response": "Adds a new handler to the list of handlers."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef cmd(self, command, args, prefix=None):\n        if prefix is None:\n            prefix = u''\n        raw_cmd = u'{0} {1} {2}'.format(prefix, command, args).strip()\n        self._send(raw_cmd)", "response": "Sends a command to the server."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef ctcp_reply(self, command, dst, message=None):\n        if message is None:\n            raw_cmd = u'\\x01{0}\\x01'.format(command)\n        else:\n            raw_cmd = u'\\x01{0} {1}\\x01'.format(command, message)\n        self.notice(dst, raw_cmd)", "response": "This method sends a reply to a CTCP request."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef msg(self, target, msg):\n        self.cmd(u'PRIVMSG', u'{0} :{1}'.format(target, msg))", "response": "Send a message to a user or channel."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef notice(self, target, msg):\n        self.cmd(u'NOTICE', u'{0} :{1}'.format(target, msg))", "response": "Sends a NOTICE to an user or channel."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a softimage object given its fullname.", "response": "def siget(fullname=\"\"):\n    \"\"\"Returns a softimage object given its fullname.\"\"\"\n    fullname = str(fullname)\n    if not len(fullname):\n        return None\n    return sidict.GetObject(fullname, False)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef cmd_wrapper(cmd_name, **kwds):\n    cmd = si.Commands(cmd_name)\n    if not cmd:\n        raise Exception(cmd_name + \" doesnt found!\")\n    for arg in cmd.Arguments:\n        value = kwds.get(arg.Name)\n        if value:\n            arg.Value = value\n    return cmd.Execute()", "response": "Wrap and execute a softimage command accepting named arguments"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating a logger using the given settings.", "response": "def _create_logger(middleware_settings):\n    \"\"\" Creates a logger using the given settings.\n    \"\"\"\n    if django_settings.DEBUG:\n        level = logging.DEBUG\n        formatter = logging.Formatter(\n            middleware_settings['LOGGER_FORMAT_DEBUG'])\n    else:\n        level = middleware_settings['LOGGER_LEVEL']\n        formatter = logging.Formatter(middleware_settings['LOGGER_FORMAT'])\n\n    handler = logging.StreamHandler(sys.stderr)\n    handler.setLevel(level)\n    handler.setFormatter(formatter)\n\n    logger = logging.getLogger(middleware_settings['LOGGER_NAME'])\n\n    # If in some strange way this logger already exists we make sure to delete\n    # its existing handlers\n    del logger.handlers[:]\n\n    logger.addHandler(handler)\n\n    # Disable propagation by default\n    logger.propagate = False\n\n    return logger"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef authorization_middleware(get_response):\n    middleware_settings = settings()\n    logger = _create_logger(middleware_settings)\n\n    min_scope = middleware_settings['MIN_SCOPE']\n\n    def get_token_subject(sub):\n        return sub\n\n    def always_ok(*args, **kwargs):\n        return True\n\n    def authorize_function(scopes, token_signature, x_unique_id=None):\n        \"\"\" Creates a partial around :func:`levels.is_authorized`\n        that wraps the current user's scopes.\n\n        :return func:\n        \"\"\"\n        log_msg_scopes = 'Granted access (needed: {}, granted: {}, token: {})'\n\n        def is_authorized(*needed_scopes):\n            granted_scopes = set(scopes)\n            needed_scopes = set(needed_scopes)\n            result = needed_scopes.issubset(granted_scopes)\n            if result:\n                msg = log_msg_scopes.format(needed_scopes, granted_scopes, token_signature)\n                if x_unique_id:\n                    msg += ' X-Unique-ID: {}'.format(x_unique_id)\n                logger.info(msg)\n            return result\n\n        return is_authorized\n\n    def authorize_forced_anonymous(_):\n        \"\"\" Authorize function for routes that are forced anonymous\"\"\"\n        raise Exception(\n            'Should not call is_authorized_for in anonymous routes')\n\n    def insufficient_scope():\n        \"\"\"Returns an HttpResponse object with a 401.\"\"\"\n        msg = 'Bearer realm=\"datapunt\", error=\"insufficient_scope\"'\n        response = http.HttpResponse('Unauthorized', status=401)\n        response['WWW-Authenticate'] = msg\n        return response\n\n    def expired_token():\n        \"\"\" Returns an HttpResponse object with a 401\n        \"\"\"\n        msg = 'Bearer realm=\"datapunt\", error=\"expired_token\"'\n        response = http.HttpResponse('Unauthorized', status=401)\n        response['WWW-Authenticate'] = msg\n        return response\n\n    def invalid_token():\n        \"\"\" Returns an HttpResponse object with a 401\n        \"\"\"\n        msg = 'Bearer realm=\"datapunt\", error=\"invalid_token\"'\n        response = http.HttpResponse('Unauthorized', status=401)\n        response['WWW-Authenticate'] = msg\n        return response\n\n    def invalid_request():\n        \"\"\" Returns an HttpResponse object with a 400\n        \"\"\"\n        msg = (\n            \"Bearer realm=\\\"datapunt\\\", error=\\\"invalid_request\\\", \"\n            \"error_description=\\\"Invalid Authorization header format; \"\n            \"should be: 'Bearer [token]'\\\"\")\n        response = http.HttpResponse('Bad Request', status=400)\n        response['WWW-Authenticate'] = msg\n        return response\n\n    def token_data(authorization):\n        \"\"\" Get the token data present in the given authorization header.\n        \"\"\"\n        try:\n            prefix, token = authorization.split()\n        except ValueError:\n            logger.warning(\n                'Invalid Authorization header: {}'.format(authorization))\n            raise _AuthorizationHeaderError(invalid_request())\n        if prefix.lower() != 'bearer':\n            logger.warning(\n                'Invalid Authorization header: {}'.format(authorization))\n            raise _AuthorizationHeaderError(invalid_request())\n\n        try:\n            header = jwt.get_unverified_header(token)\n        except jwt.ExpiredSignatureError:\n            logger.info(\"Expired token\")\n            raise _AuthorizationHeaderError(expired_token())\n        except (jwt.InvalidTokenError, jwt.DecodeError):\n            logger.exception(\"API authz problem: JWT decode error while reading header\")\n            raise _AuthorizationHeaderError(invalid_token())\n\n        if 'kid' not in header:\n            logger.exception(\"Did not get a valid key identifier\")\n            raise _AuthorizationHeaderError(invalid_token())\n\n        keys = middleware_settings['JWKS'].verifiers\n\n        if header['kid'] not in keys:\n            logger.exception(\"Unknown key identifier: {}\".format(header['kid']))\n            raise _AuthorizationHeaderError(invalid_token())\n\n        key = keys[header['kid']]\n\n        try:\n            decoded = jwt.decode(token, key=key.key, algorithms=(key.alg,))\n        except jwt.InvalidTokenError:\n            logger.exception('API authz problem: could not decode access '\n                             'token {}'.format(token))\n            raise _AuthorizationHeaderError(invalid_token())\n\n        if 'scopes' not in decoded:\n            logger.warning('API authz problem: access token misses '\n                           'authz and scopes claim: {}'.format(token))\n            raise _AuthorizationHeaderError(invalid_token())\n        else:\n            scopes = decoded['scopes']\n\n        if 'sub' in decoded:\n            sub = decoded['sub']\n        else:\n            sub = None\n\n        token_signature = token.split('.')[2]\n        return scopes, token_signature, sub\n\n    def middleware(request):\n        \"\"\" Parses the Authorization header, decodes and validates the JWT and\n        adds the is_authorized_for function to the request.\n        \"\"\"\n        request_path = request.path\n        forced_anonymous = any(\n            request_path.startswith(route)\n            for route in middleware_settings['FORCED_ANONYMOUS_ROUTES'])\n\n        if middleware_settings['ALWAYS_OK']:\n            logger.warning('API authz DISABLED')\n            request.is_authorized_for = always_ok\n            request.get_token_subject = 'ALWAYS_OK'\n            return get_response(request)\n\n        is_options = request.method == 'OPTIONS'\n\n        if forced_anonymous or is_options:\n            authz_func = authorize_forced_anonymous\n            subject = None\n\n        else:\n            authorization = request.META.get('HTTP_AUTHORIZATION')\n            token_signature = ''\n            sub = None\n\n            if authorization:\n                try:\n                    scopes, token_signature, sub = token_data(authorization)\n                except _AuthorizationHeaderError as e:\n                    return e.response\n            else:\n                scopes = []\n\n            x_unique_id = request.META.get('HTTP_X_UNIQUE_ID')\n            authz_func = authorize_function(scopes, token_signature, x_unique_id)\n            subject = get_token_subject(sub)\n\n            if len(min_scope) > 0 and not authz_func(min_scope):\n                return insufficient_scope()\n\n        request.is_authorized_for = authz_func\n        request.get_token_subject = subject\n\n        response = get_response(request)\n\n        return response\n\n    return middleware", "response": "A middleware that returns a new object that will be used to parse incoming access tokens and validate them and set an authorization function on the request."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef press(*keys):\n\n    for key in keys:\n        win32api.keybd_event(codes[key], 0, 0, 0)\n        release(key)", "response": "Simulates a key - press for all the keys passed to the function\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef hold(*keys, hold_time = 0, hold_while = None):\n\n    for key in keys:\n        win32api.keybd_event(codes[key], 0, 0, 0)\n    if callable(hold_while):\n        while hold_while():\n            pass\n    else:\n        time.sleep(hold_time)\n    release(*keys)", "response": "Holds all the keys passed to the function\n   "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsimulating the release of all the keys passed to this function", "response": "def release(*keys):\n    \"\"\"\n    Simulates the release of all the keys passed to this function\n\n    :param keys: list of keys to be released\n    :return: None\n    \"\"\"\n\n    for key in keys:\n        win32api.keybd_event(codes[key], 0, win32con.KEYEVENTF_KEYUP, 0)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nautomating the processing of typing by converting a string into a set of press and hold calls.", "response": "def write(s = ''):\n    \"\"\"\n    Automates the process of typing by converting a string into a set of press() and hold() calls\n\n    :param s: string to be written\n    :return: None\n    \"\"\"\n\n    for char in s:\n        if char.isupper():  # Handles uppercase\n            hold('shift', char.lower())\n        elif char == \" \":  # Handles spaces\n            press('spacebar')\n        elif char == \"\\n\":  # Handles newline\n            press('enter')\n        elif char in (')', '!', '@', '#', '$', '%', '^', '&', '*', '('):  # Handles shift & number\n            hold('shift', str((')', '!', '@', '#', '$', '%', '^', '&', '*', '(').index(char)))\n        elif char in ('{', '}', '<', '>', '?', ':', '\"', '_', '+', '~'):\n            hold('shift', ('[', ']', ',', '.', '/', ';', \"'\", '-', '=', '`')[('{', '}', '<', '>', '?', ':', '\"', '_',\n                                                                              '+', '~').index(char)])\n        else:\n            press(char)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconverts a server object into a dict representation.", "response": "def server_to_dict(server):\n    \"\"\"\n    Returns the :class:`dict` representation of a server object.\n\n    The returned :class:`dict` is meant to be consumed by\n    :class:`~bang.deployers.cloud.ServerDeployer` objects.\n\n    \"\"\"\n    soul = server.soul\n    return {\n            A.server.ID: server.href,\n            A.server.PUBLIC_IPS: soul.get('public_dns_names', []),\n            A.server.PRIVATE_IPS: soul.get('private_dns_names', []),\n            }"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef normalize_input_value(value):\n    if value in ('blank', 'ignore', 'inherit'):\n        return value\n\n    # assume any unspecified or unknown types are text\n    tokens = value.split(':')\n    if (len(tokens) < 2\n            or tokens[0] not in ('text', 'env', 'cred', 'key', 'array')):\n        return 'text:%s' % value\n\n    return value", "response": "Normalizes the input value for RightScale API 2. 0."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate stack if necessary.", "response": "def create_stack(self, name):\n        \"\"\"\n        Creates stack if necessary.\n        \"\"\"\n        deployment = find_exact(self.api.deployments, name=name)\n        if not deployment:\n            try:\n                # TODO: replace when python-rightscale handles non-json\n                self.api.client.post(\n                        '/api/deployments',\n                        data={'deployment[name]': name},\n                        )\n            except HTTPError as e:\n                log.error(\n                        'Failed to create stack %s. '\n                        'RightScale returned %d:\\n%s'\n                        % (name, e.response.status_code, e.response.content)\n                        )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nfinding * usable* server definitions by name.", "response": "def find_server_defs(self, basename):\n        \"\"\"\n        Finds *usable* server definitions by name.\n\n        A server definition is *usable* if it doesn't have a current instance.\n\n        NOTE: This might result in extra server definitions if some servers are\n        in various non-operational states (e.g. terminating).\n        \"\"\"\n        filters = ['name==%s' % basename]\n        fuzzy = self.deployment.servers.index(params={'filter[]': filters})\n        matches = []\n        for f in fuzzy:\n            if basename != f.soul['name']:\n                continue\n            if 'current_instance' not in f.links:\n                matches.append(f.href)\n        if matches:\n            self.basename = basename\n        return matches"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating a new server instance. This call blocks until the server is created and available for normal use, or :attr:`timeout_s` has elapsed. :param str basename: An identifier for the server. :param str server_tpl: The name of the server template to use. :param str server_tpl_rev: The revision of the server template to use. For ``HEAD``, set this to ``0``. :param str instance_type: The name of an instance type. E.g. ``m3.xlarge``. :param str ssh_key_name: The name of the ssh key to inject into the target server's ``authorized_keys`` file. The key must already have been registered in the RightScale datacenter (e.g. ``EC2 us-east-1``). :param tags: Key-value pairs of arbitrary strings to use as *tags* for the server instance. :type tags: :class:`Mapping` :param str availability_zone: The name of the availability zone (a.k.a. datacenter in RightScale lingo) in which to place the server. :param list security_groups: The security groups to which this server should belong. :param provider_extras: Extra server instance attributes as defined in http://reference.rightscale.com/api1.5/resources/ResourceServers.html#create :rtype: :class:`dict`", "response": "def define_server(\n            self, basename, server_tpl, server_tpl_rev, instance_type,\n            ssh_key_name, tags=None, availability_zone=None,\n            security_groups=None, **provider_extras\n            ):\n        \"\"\"\n        Creates a new server instance.  This call blocks until the server is\n        created and available for normal use, or :attr:`timeout_s` has elapsed.\n\n        :param str basename:  An identifier for the server.\n\n        :param str server_tpl:  The name of the server template to use.\n\n        :param str server_tpl_rev:  The revision of the server template to use.\n            For ``HEAD``, set this to ``0``.\n\n        :param str instance_type:  The name of an instance type.  E.g.\n            ``m3.xlarge``.\n\n        :param str ssh_key_name:  The name of the ssh key to inject into the\n            target server's ``authorized_keys`` file.  The key must already\n            have been registered in the RightScale datacenter\n            (e.g. ``EC2 us-east-1``).\n\n        :param tags:  Key-value pairs of arbitrary strings to use as *tags* for\n            the server instance.\n        :type tags:  :class:`Mapping`\n\n        :param str availability_zone:  The name of the availability zone\n            (a.k.a. datacenter in RightScale lingo) in which to place the\n            server.\n\n        :param list security_groups: The security groups to which this server\n            should belong.\n\n        :param provider_extras: Extra server instance attributes as defined in\n            http://reference.rightscale.com/api1.5/resources/ResourceServers.html#create\n\n        :rtype:  :class:`dict`\n\n        \"\"\"\n        log.info('Defining server %s...' % basename)\n        self.basename = basename\n\n        # required attributes\n        tpl = find_exact(\n                self.api.server_templates,\n                name=server_tpl,\n                revision=server_tpl_rev,\n                )\n        # ... the rightscale and aws apis allow you to spin up a server without\n        #     a key, but let's not. we already assume you need ssh for ansible.\n        sshkey = find_exact(\n                self.cloud.ssh_keys,\n                resource_uid=ssh_key_name,\n                )\n        data = {\n                'server[deployment_href]': self.deployment.href,\n                'server[instance][cloud_href]': self.cloud.href,\n                'server[instance][server_template_href]': tpl.href,\n                'server[instance][ssh_key_href]': sshkey.href,\n                'server[name]': basename,\n                }\n\n        # optional attributes (i.e. you can set these to '' in bang configs)\n        itype = find_exact(\n                self.cloud.instance_types,\n                name=instance_type,\n                )\n        if itype:\n            data['server[instance][instance_type_href]'] = itype.href\n\n        datacenter = find_exact(\n                self.cloud.datacenters,\n                name=availability_zone,\n                )\n        if datacenter:\n            data['server[instance][datacenter_href]'] = datacenter.href\n\n        secgroup_hrefs = []\n        for n in security_groups:\n            secgroup = find_exact(self.cloud.security_groups, name=n)\n            if secgroup:\n                secgroup_hrefs.append(secgroup.href)\n        if secgroup_hrefs:\n            data['server[instance][security_group_hrefs][]'] = secgroup_hrefs\n\n        if provider_extras:\n            # use a copy because the inbound provider_extras will be passed in again\n            # when calling create_server()\n            shallow_kwargs = provider_extras.copy()\n\n            # defer all inputs until launch time\n            shallow_kwargs.pop(A.rightscale.INPUTS, None)\n\n            cloud_specific = shallow_kwargs.pop(A.rightscale.CLOUD_SPECIFIC, {})\n            for k, v in cloud_specific.iteritems():\n                data['server[instance][cloud_specific_attributes][%s]' % k] = v\n            for k, v in shallow_kwargs.iteritems():\n                data['server[instance][%s]' % k] = v\n\n        try:\n            response = self.api.client.post('/api/servers', data=data)\n            server_href = response.headers['location']\n        except HTTPError as e:\n            log.error(\n                    'Definition failed.  RightScale returned %d:\\n%s'\n                    % (e.response.status_code, e.response.content)\n                    )\n            raise\n\n        # tag it!\n        all_tags = [\n                'ec2:role=%s' % self.basename,\n                'ec2:stack=%s' % self.deployment.soul['name'],\n                ]\n        all_tags.extend(['ec2:%s=%s' % (k, v) for k, v in tags.items()])\n        try:\n            self.api.tags.multi_add(\n                    data={\n                        'resource_hrefs[]': [server_href],\n                        'tags[]': all_tags,\n                        }\n                    )\n        except HTTPError as e:\n            log.error(\n                    'Failed to tag server %s. RightScale returned %d:\\n%s' % (\n                        self.basename,\n                        e.response.status_code,\n                        e.response.content\n                        )\n                    )\n            raise\n\n        return server_href"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget a mysql pool", "response": "def get_mysql_pool(host=None, user=None, password=None, charset='utf8', \n        db=None, size=None, isSync=True, ioloop=None):\n    \"\"\"\u4f7f\u7528\u5de5\u5382\u65b9\u6cd5\u8fd4\u56de\u4e00\u4e2a\u8fde\u63a5\u6c60\"\"\"\n    factory = mysql_pool_factory(isSync)\n    kwargs = {\n        'host': host,\n        'user': user,\n        'password': password,\n        'charset': charset,\n        'db': db,\n        'size': size,\n    }\n    return factory(**kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nexecuting SQL query and return result.", "response": "def _execute(self, sql, args):\n        \"\"\"\u6267\u884csql\u8bed\u53e5\n        :param sql: sql\u8bed\u53e5\n        :param args: \u53c2\u6570\n        :return: \u8fd4\u56de\u7684\u90fd\u662f\u6570\u7ec4\u5bf9\u8c61\n        \"\"\"\n        sql = sql.lower().strip()\n        args = args or ()\n        tmp = sql[:6]\n        with (yield self._pool.Connection()) as conn:\n            try:\n                with conn.cursor() as cursor:\n                    yield cursor.execute(sql, args=args)\n                    if tmp == 'select':\n                        datas = cursor.fetchall()   \n                        return datas\n            except Exception as e:\n                err = traceback.format_exc()\n                print(err)\n                if tmp in ['insert', 'update', 'delete']:\n                    yield conn.rollback()\n            else:\n                if tmp == 'insert':\n                    insertId = conn.insert_id()\n                    yield conn.commit()\n                    # \u8fd4\u56de\u63d2\u5165\u7684\u4e3b\u952eid\n                    return insertId\n                elif tmp in ['update', 'delete']:\n                    yield conn.commit()"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets the features types from the given data_frame.", "response": "def set_features_types_from_dataframe(self, data_frame):\n        \"\"\"\n        Sets the features types from the given data_frame.\n        All the calls except the first one are ignored.\n        \"\"\"\n        if self.__feature_types_set:\n            return\n        self.__feature_types_set = True\n\n        dtypes = data_frame.dtypes\n        for feature in self.__iter__():\n            name = feature.get_name()\n            type_name = data_type_to_type_name(dtypes[name])\n            feature.set_type_name(type_name)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nprint the current version of the WinVer.", "response": "def print_version():\r\n    \"\"\"\r\n    Print get_version() return value in a readable format.\r\n\r\n    Params:\r\n        None\r\n\r\n    Returns:\r\n        None\r\n    \"\"\"\r\n    v = get_version()\r\n\r\n    try:\r\n        s = _STR_WIN[v]\r\n    except KeyError:\r\n        s = \"Unknow OS\"\r\n\r\n    print(\"-----------------------------------------------------------\")\r\n    print(\"###################### WinVer Report ######################\")\r\n    print(\"Python Version                           : {}.{}.{}\".format(*sys.version_info[:3]))\r\n    print(\"Windows Version String                   : {}\".format(s))\r\n    print(\"Windows Major Version                    : {}\".format(v[0]))\r\n    print(\"Windows Minor Version                    : {}\".format(v[1]))\r\n    print(\"Windows Service Pack (or Build) Version  : {}\".format(v[2]))\r\n    print(\"Is Windows Server                        : {}\".format('Yes' if v[3]==1 else 'No'))\r\n    print(\"Is Windows 10 (or Windows Server 2016)   : {}\".format('Yes' if v >= WIN_10 else 'No'))\r\n    print(\"-----------------------------------------------------------\")"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef items(iterable):\n    if hasattr(iterable, 'iteritems'):\n        return (p for p in iterable.iteritems())\n    elif hasattr(iterable, 'items'):\n        return (p for p in iterable.items())\n    else:\n        return (p for p in enumerate(iterable))", "response": "Iterate over the items of a sequence."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef labeled_accumulate(sequence, keygetter=operator.itemgetter(0), valuegetter=operator.itemgetter(1), accumulator=operator.add):\n    return izip((keygetter(item) for item in sequence),\n                accumulate((valuegetter(item) for item in sequence), accumulator))", "response": "This function is used to accumulate input elements according to accumulate."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nsteal straight from Stripe Python source.", "response": "def handle_api_error(resp):\n    \"\"\"Stolen straight from the Stripe Python source.\"\"\"\n    content = yield resp.json()\n\n    headers = HeaderWrapper(resp.headers)\n\n    try:\n        err = content['error']\n    except (KeyError, TypeError):\n        raise error.APIError(\n            \"Invalid response object from API: %r (HTTP response code \"\n            \"was %d)\" % (content, resp.code),\n            resp, resp.code, content, headers)\n\n    if resp.code in [400, 404]:\n        raise error.InvalidRequestError(\n            err.get('message'), err.get('param'),\n            resp, resp.code, content, headers)\n    elif resp.code == 401:\n        raise error.AuthenticationError(\n            err.get('message'),\n            resp, resp.code, content, headers)\n    elif resp.code == 402:\n        raise error.CardError(\n            err.get('message'), err.get('param'), err.get('code'),\n            content, resp.code, resp, headers)\n    else:\n        raise error.APIError(\n            err.get('message'), content, resp.code, resp, headers)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef vectors_between_pts(pts=[]):\n    '''Return vectors between points on N dimensions.\nLast vector is the path between the first and last point, creating a loop.\n    '''\n    assert isinstance(pts, list) and len(pts) > 0\n    l_pts = len(pts)\n    l_pt_prev = None\n    for pt in pts:\n        assert isinstance(pt, tuple)\n        l_pt = len(pt)\n        assert l_pt > 1\n        for i in pt:\n            assert isinstance(i, float)\n        if l_pt_prev is not None:\n            assert l_pt == l_pt_prev\n        l_pt_prev = l_pt\n\n    return [tuple([pts[(i+1) % l_pts][j] - pts[i][j] for j in range(l_pt)]) \\\n            for i in range(l_pts)]", "response": "Return vectors between points on N dimensions."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns direction between two points on N dimensions.", "response": "def dir_between_pts(a=(0.0, 0.0), b=(0.0, 0.0)):\n    '''Return direction between two points on N dimensions.\nList of vectors per pair of dimensions are returned in radians.\nE.g. Where X is \"right\", Y is \"up\", Z is \"in\" on a computer screen, and\n  returned value is [pi/4, -pi/4], then the vector will be coming out the\n  screen over the viewer's right shoulder.\n    '''\n    assert isinstance(a, tuple)\n    assert isinstance(b, tuple)\n    l_pt = len(a)\n    assert l_pt > 1\n    assert l_pt == len(b)\n    for i in a:\n        assert isinstance(i, float)\n    for i in b:\n        assert isinstance(i, float)\n\n    # Difference used for calculating gradient, giving 2 quadrants of direction.\n    delta = [b[i] - a[i] for i in range(l_pt)]\n\n    # 180 degree offset to add, giving all 4 quadrants of this pair of\n    #   dimensions.\n    semiturn = [pi * int(b[p] < a[p]) for p in range(l_pt-1)]\n\n    return [atan(delta[p+1] / delta[p]) + semiturn[p] for p in range(l_pt-1)]"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the point between two points on N dimensions.", "response": "def pt_between_pts(a=(0.0, 0.0), b=(0.0, 0.0), t=0.5):\n    '''Return the point between two points on N dimensions.\n    '''\n    assert isinstance(a, tuple)\n    assert isinstance(b, tuple)\n    l_pt = len(a)\n    assert l_pt > 1\n    assert l_pt == len(b)\n    for i in a:\n        assert isinstance(i, float)\n    for i in b:\n        assert isinstance(i, float)\n    assert isinstance(t, float)\n    assert 0 <= t <= 1\n\n    return tuple([ ((b[i] - a[i]) * t) + a[i] for i in range(l_pt) ])"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef distance_between_pts(a=(0.0, 0.0), b=(0.0, 0.0)):\n    '''Return the distance between two points on N dimensions (Euclidean distance).\n    '''\n    assert isinstance(a, tuple)\n    assert isinstance(b, tuple)\n    l_pt = len(a)\n    assert l_pt > 1\n    assert l_pt == len(b)\n    for i in a:\n        assert isinstance(i, float)\n    for i in b:\n        assert isinstance(i, float)\n\n    return sqrt(sum([(b[i] - a[i])**2 for i in range(l_pt)]))", "response": "Return the distance between two points on N dimensions ( Euclidean distance."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning given point with axes flipped and offset converting points between cartesian axis layouts.", "response": "def pt_change_axis(pt=(0.0, 0.0), flip=[False, False], offset=[0.0, 0.0]):\n    '''Return given point with axes flipped and offset, converting points between cartesian axis layouts.\nFor example, SVG Y-axis increases top to bottom but DXF is bottom to top.\n    '''\n    assert isinstance(pt, tuple)\n    l_pt = len(pt)\n    assert l_pt > 1\n    for i in pt:\n        assert isinstance(i, float)\n    assert isinstance(flip, list)\n    l_fl = len(flip)\n    assert l_fl == l_pt\n    for i in flip:\n        assert isinstance(i, bool)\n    assert isinstance(offset, list)\n    l_of = len(offset)\n    assert l_of == l_pt\n    for i in offset:\n        assert isinstance(i, float)\n\n    # Convert True/False to -1/1\n    flip_mul = [-2 * int(f) + 1 for f in flip]\n\n    return tuple([offset[i] + pt[i]*flip_mul[i] for i in range(l_pt)])"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef pts_change_axis(pts=[], flip=[False, False], offset=[0.0, 0.0]):\n    '''Return given point with axes flipped and offset, converting points between cartesian axis layouts.\nFor example, SVG Y-axis increases top to bottom but DXF is bottom to top.\n    '''\n    assert isinstance(pts, list) and len(pts) > 0\n    l_pt_prev = None\n    for pt in pts:\n        assert isinstance(pt, tuple)\n        l_pt = len(pt)\n        assert l_pt > 1\n        for i in pt:\n            assert isinstance(i, float)\n        if l_pt_prev is not None:\n            assert l_pt == l_pt_prev\n        l_pt_prev = l_pt\n    assert isinstance(flip, list)\n    l_fl = len(flip)\n    assert l_fl == l_pt\n    for i in flip:\n        assert isinstance(i, bool)\n    assert isinstance(offset, list)\n    l_of = len(offset)\n    assert l_of == l_pt\n    for i in offset:\n        assert isinstance(i, float)\n\n    return [pt_change_axis(pt, flip, offset) for pt in pts]", "response": "Return given point with axes flipped and offset converting points between cartesian axis layouts."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn given point rotated around a center point in N dimensions.", "response": "def pt_rotate(pt=(0.0, 0.0), angle=[0.0], center=(0.0, 0.0)):\n    '''Return given point rotated around a center point in N dimensions.\nAngle is list of rotation in radians for each pair of axis.\n    '''\n    assert isinstance(pt, tuple)\n    l_pt = len(pt)\n    assert l_pt > 1\n    for i in pt:\n        assert isinstance(i, float)\n    assert isinstance(angle, list)\n    l_angle = len(angle)\n    assert l_angle == l_pt-1\n    for i in angle:\n        assert isinstance(i, float)\n        assert abs(i) <= 2*pi\n    assert isinstance(center, tuple)\n    assert len(center) == l_pt\n    for i in center:\n        assert isinstance(i, float)\n\n    # Get vector from center to point and use to get relative polar coordinate.\n    v_cart = [pt[i] - center[i] for i in range(l_pt)]\n\n    # Length of vector needs to stay constant for new point.\n    v_pol_l = [sqrt(v_cart[i]**2 + v_cart[i+1]**2) for i in range(l_angle)]\n    v_pol_a = [(atan(v_cart[i+1] / v_cart[i]) if v_cart[i] != 0.0 else pi/2) + pi*int(pt[i] < center[i]) \\\n               for i in range(l_angle)]\n\n    # Add rotation angle then convert back to cartesian vector.\n    n_pol_a = [v_pol_a[i] + angle[i] for i in range(l_angle)]\n    n_cart = [v_pol_l[0] * cos(n_pol_a[0])] + [v_pol_l[i] * sin(n_pol_a[i])\\\n                                               for i in range(l_angle)]\n\n    # Add in the centre offset to get original offset from c.\n    r = [n_cart[i] + center[i] for i in range(l_pt)]\n    return tuple(r)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef pts_rotate(pts=[], angle=[0.0], center=(0.0, 0.0)):\n    '''Return given points rotated around a center point in N dimensions.\nAngle is list of rotation in radians for each pair of axis.\n    '''\n    assert isinstance(pts, list) and len(pts) > 0\n    l_pt_prev = None\n    for pt in pts:\n        assert isinstance(pt, tuple)\n        l_pt = len(pt)\n        assert l_pt > 1\n        for i in pt:\n            assert isinstance(i, float)\n        if l_pt_prev is not None:\n            assert l_pt == l_pt_prev\n        l_pt_prev = l_pt\n    assert isinstance(angle, list)\n    l_angle = len(angle)\n    assert l_angle == l_pt-1\n    for i in angle:\n        assert isinstance(i, float)\n        assert abs(i) <= 2*pi\n    assert isinstance(center, tuple)\n    assert len(center) == l_pt\n    for i in center:\n        assert isinstance(i, float)\n\n    return [pt_rotate(pt, angle, center) for pt in pts]", "response": "Return given points rotated around a center point in N dimensions."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns given point shifted in N dimensions.", "response": "def pt_shift(pt=(0.0, 0.0), shift=[0.0, 0.0]):\n    '''Return given point shifted in N dimensions.\n    '''\n    assert isinstance(pt, tuple)\n    l_pt = len(pt)\n    assert l_pt > 1\n    for i in pt:\n        assert isinstance(i, float)\n    assert isinstance(shift, list)\n    l_sh = len(shift)\n    assert l_sh == l_pt\n    for i in shift:\n        assert isinstance(i, float)\n\n    return tuple([pt[i] + shift[i] for i in range(l_pt)])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning given points shifted in N dimensions.", "response": "def pts_shift(pts=[], shift=[0.0, 0.0]):\n    '''Return given points shifted in N dimensions.\n    '''\n    assert isinstance(pts, list) and len(pts) > 0\n    l_pt_prev = None\n    for pt in pts:\n        assert isinstance(pt, tuple)\n        l_pt = len(pt)\n        assert l_pt > 1\n        for i in pt:\n            assert isinstance(i, float)\n        if l_pt_prev is not None:\n            assert l_pt == l_pt_prev\n        l_pt_prev = l_pt\n    assert isinstance(shift, list)\n    l_sh = len(shift)\n    assert l_sh == l_pt\n    for i in shift:\n        assert isinstance(i, float)\n\n    return [pt_shift(pt, shift) for pt in pts]"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef pt_relative(pt=(0.0, 0.0), shift=[0.0, 0.0], angle=[0.0]):\n    '''Convenience shift+rotate combination.\n    '''\n    assert isinstance(pt, tuple)\n    l_pt = len(pt)\n    assert l_pt > 1\n    for i in pt:\n        assert isinstance(i, float)\n    assert isinstance(shift, list)\n    l_sh = len(shift)\n    assert l_sh == l_pt\n    for i in shift:\n        assert isinstance(i, float)\n    assert isinstance(angle, list)\n    l_angle = len(angle)\n    assert l_angle == l_pt-1\n    for i in angle:\n        assert isinstance(i, float)\n        assert abs(i) <= 2*pi\n\n    return pt_rotate(pt_shift(pt, shift), angle, pt)", "response": "Convenience function to calculate a relative point on the base point."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef pt_reflect(pt=(0.0, 0.0), plane=[None, None]):\n    '''Return given point reflected around planes in N dimensions.\nThere must be the same number of planes as dimensions, but the value of each\n  plane may be None to indicate no reflection.\n    '''\n    assert isinstance(pt, tuple)\n    l_pt = len(pt)\n    assert l_pt > 1\n    for i in pt:\n        assert isinstance(i, float)\n    assert isinstance(plane, list)\n    l_pl = len(plane)\n    assert l_pl == l_pt\n    for i in plane:\n        assert isinstance(i, float) or i is None\n\n    return tuple([pt[i] if plane[i] is None else (2*plane[i] - pt[i]) for i in range(l_pt)])", "response": "Return given point reflected around planes in N dimensions."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning given point reflected around N dimensions.", "response": "def pts_reflect(pts=[], plane=[None, None]):\n    '''Return given point reflected around planes in N dimensions.\nThere must be the same number of planes as dimensions, but the value of each\n  plane may be None to indicate no reflection.\n    '''\n    assert isinstance(pts, list) and len(pts) > 0\n    l_pt_prev = None\n    for pt in pts:\n        assert isinstance(pt, tuple)\n        l_pt = len(pt)\n        assert l_pt > 1\n        for i in pt:\n            assert isinstance(i, float)\n        if l_pt_prev is not None:\n            assert l_pt == l_pt_prev\n        l_pt_prev = l_pt\n    assert isinstance(plane, list)\n    l_pl = len(plane)\n    assert l_pl == l_pt\n    for i in plane:\n        assert isinstance(i, float) or i is None\n\n    return [pt_reflect(pt, plane) for pt in pts]"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn given point scaled by factor f from origin.", "response": "def pt_scale(pt=(0.0, 0.0), f=1.0):\n    '''Return given point scaled by factor f from origin.\n    '''\n    assert isinstance(pt, tuple)\n    l_pt = len(pt)\n    assert l_pt > 1\n    for i in pt:\n        assert isinstance(i, float)\n    assert isinstance(f, float)\n\n    return tuple([pt[i]*f for i in range(l_pt)])"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef pts_scale(pts=[], f=1.0):\n    '''Return given points scaled by factor f from origin.\n    '''\n    assert isinstance(pts, list) and len(pts) > 0\n    l_pt_prev = None\n    for pt in pts:\n        assert isinstance(pt, tuple)\n        l_pt = len(pt)\n        assert l_pt > 1\n        for i in pt:\n            assert isinstance(i, float)\n        if l_pt_prev is not None:\n            assert l_pt == l_pt_prev\n        l_pt_prev = l_pt\n    assert isinstance(f, float)\n\n    return [pt_scale(pt, f) for pt in pts]", "response": "Return given points scaled by factor f from origin.\n   "}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning difference in angle from start_a to end_a. direction is a boolean indicating whether the angle is counter - clockwise or counter - clockwise.", "response": "def angle_diff(start_a=[0.0], end_a=[0.0], direction=True):\n    '''Return difference in angle from start_a to end_a.\nDirection follows the right-hand-rule so positive is counter-clockwise.\n    '''\n    assert isinstance(start_a, list)\n    assert isinstance(end_a, list)\n    l_angle = len(start_a)\n    assert l_angle > 0\n    assert l_angle == len(end_a)\n    for i in start_a:\n        assert isinstance(i, float)\n        assert abs(i) <= 2*pi\n    for i in end_a:\n        assert isinstance(i, float)\n        assert abs(i) <= 2*pi\n    assert isinstance(direction, bool)\n\n    # Convert True/False to 1/-1\n    inv = 2 * int(direction) - 1\n\n    diff = [end_a[i] - start_a[i] for i in range(l_angle)]\n    diff = [(2*pi + d) if d < 0.0 else d for d in diff]\n    return [d*inv for d in diff]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ngenerate points for a polygon with a number of radiuses.", "response": "def gen_polygon_pts(n_pts=3, radius=[1.0]):\n    '''Generate points for a polygon with a number of radiuses.\nThis makes it easy to generate shapes with an arbitrary number of sides,\n  regularly angled around the origin.\nA single radius will give a simple shape such as a square, hexagon, etc.\nMultiple radiuses will give complex shapes like stars, gear wheels, ratchet\n  wheels, etc.\n    '''\n    assert isinstance(n_pts, int) and n_pts > 0\n    assert isinstance(radius, list)\n    l_rad = len(radius)\n    assert l_rad > 0\n    for i in radius:\n        assert isinstance(i, float)\n\n    return [pt_rotate((radius[i % l_rad], 0.0), [i*2*pi/n_pts]) \\\n            for i in range(n_pts)]"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds params to doc string", "response": "def _add_params_docstring(params):\n    \"\"\" Add params to doc string\n    \"\"\"\n    p_string = \"\\nAccepts the following paramters: \\n\"\n    for param in params:\n         p_string += \"name: %s, required: %s, description: %s \\n\" % (param['name'], param['required'], param['description'])\n    return p_string"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates a method based on the Cloudmonkey precached_verbs .", "response": "def _create_api_method(cls, name, api_method):\n    \"\"\" Create dynamic class methods based on the Cloudmonkey precached_verbs\n    \"\"\"\n    def _api_method(self, **kwargs):\n        # lookup the command\n        command = api_method['name']\n        if kwargs:\n            return self._make_request(command, kwargs)\n        else:\n            kwargs = {}\n            return self._make_request(command, kwargs)\n    _api_method.__doc__ = api_method['description']\n    _api_method.__doc__ += _add_params_docstring(api_method['params'])\n    _api_method.__name__ = str(name)\n    setattr(cls, _api_method.__name__, _api_method)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ninitialize the Cloudstack API object.", "response": "def Initialize(api_key, api_secret, api_host=\"localhost\", api_port=443, api_ssl=True, asyncblock=False, timeout=10, req_method=\"get\"):\n    \"\"\" Initializes the Cloudstack API\n        Accepts arguments: \n            api_host (localhost)\n            api_port (443)\n            api_ssl (True)\n            api_key\n            api_secret\n    \"\"\"\n    config = Config()\n\n    if api_ssl:\n        proto = \"https\"\n    else:\n        proto = \"http\"\n    api_url = \"%s://%s:%s/client/api\" % (proto, api_host, api_port)\n    if os.access(os.path.expanduser(\"~\") , os.W_OK):\n        d = os.path.expanduser(\"~\")\n    else:\n        d = tempfile.gettempdir()\n    cache_file = os.getenv('MOLNCTRL_CACHE') or '.molnctrl_cache'\n    if os.path.exists(os.path.join(d, cache_file)):\n        apicache = pickle.load(open( os.path.join(d, cache_file), \"rb\" ))\n    else:\n        method = {'description': u'lists all available apis on the server, provided by the Api Discovery plugin',\n            'isasync': False,\n            'name': u'listApis',\n            'params': [{'description': u'API name',\n            'length': 255,\n            'name': u'name',\n            'related': [],\n            'required': False,\n            'type': u'string'}],\n            'related': [],\n            'requiredparams': []}\n        _create_api_method(CSApi, \"list_apis\", method)\n        c = CSApi(api_url, api_key, api_secret, asyncblock)\n        apicache = cachemaker.monkeycache(c.list_apis())\n        pickle.dump(apicache, open(os.path.join(d, cache_file), \"wb\"))\n\n    for verb, methods in six.iteritems(apicache):\n        if isinstance(methods, dict):\n            for method in six.iterkeys(methods):\n                _create_api_method(CSApi, \"%s_%s\" % (verb, method), methods[method])\n    return CSApi(api_url, api_key, api_secret, asyncblock, timeout, req_method)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef validate(backup):\n    data = request.json\n    if not data:\n        abort(400, 'No data received')\n\n    try:\n        archive_path = data['archive_path']\n    except KeyError:\n        abort(400, 'Missing key \\'archive_path\\' in data')\n\n    try:\n        config['extension'][backup]\n    except KeyError:\n        abort(404, 'No extension configuration found for: {}'.format(backup))\n\n    workdir = ''.join([config['valigator']['tmp_dir'], '/', generate_uuid()])\n    backup_data = {'archive_path': archive_path,\n                   'workdir': workdir,\n                   'image': config['extension'][backup]['image'],\n                   'command': config['extension'][backup]['command']}\n    validate_backup.delay(config, backup_data)", "response": "This endpoint is used to start a backup validation. It will validate the backup archive info."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef install(name, pip_args):\n    cdc = CDC(name)\n    try:\n        cdc.install(pip_args)\n    except ErrorReturnCode as e:\n        print_pretty(\"<FG_RED>Something went wrong! Rolling back...<END>\")\n        cdc.uninstall()", "response": "Install the package. Pip args specified with --."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget variant ID from pyvcf. model. _Record", "response": "def record_variant_id(record):\n    \"\"\"Get variant ID from pyvcf.model._Record\"\"\"\n    if record.ID:\n        return record.ID\n    else:\n        return record.CHROM + ':' + str(record.POS)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef wasp_snp_directory(vcf, directory, sample_name=None):\n    chrom = []\n    pos = []\n    ref = []\n    alt = []\n    vcf_reader = pyvcf.Reader(open(vcf, 'r'))\n    if sample_name:\n        def condition(record, sample_name):\n            return sample_name in [x.sample for x in record.get_hets()]\n    else:\n        def condition(record, sample_name):\n            return len(record.get_hets()) > 0\n    for record in vcf_reader:\n        if condition(record, sample_name):\n            if len(record.ALT) == 1:\n                chrom.append(record.CHROM)\n                pos.append(record.POS)\n                ref.append(record.REF)\n                alt.append(record.ALT[0].sequence)\n    df = pd.DataFrame([chrom, pos, ref, alt], \n                      index=['chrom', 'position', 'RefAllele', 'AltAllele']).T\n    if not os.path.exists(directory):\n        os.makedirs(directory)\n    for c in set(df.chrom):\n        tdf = df[df.chrom == c]\n        if tdf.shape[0] > 0:\n            f = gzip.open(os.path.join(directory, '{}.snps.txt.gz'.format(c)),\n                          'wb')\n            lines = (tdf.position.astype(str) + '\\t' + tdf.RefAllele + '\\t' +\n                     tdf.AltAllele)\n            f.write('\\n'.join(lines) + '\\n')\n            f.close()", "response": "Convert VCF file into WASP format."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef vcf_as_df(fn):\n    header_lines = 0\n    with open(fn, 'r') as f:\n        line = f.readline().strip()\n        header_lines += 1\n        while line[0] == '#':\n            line = f.readline().strip()\n            header_lines += 1\n    \n    header_lines -= 2\n    df = pd.read_table(fn, skiprows=header_lines, header=0)\n    df.columns = ['CHROM'] + list(df.columns[1:])\n    return df", "response": "Reads a VCF file into a pandas DataFrame."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nmakes boolean matrix of samples by variants. One indicates that the sample is heterozygous for that variant.", "response": "def make_het_matrix(fn):\n    \"\"\"\n    Make boolean matrix of samples by variants. One indicates that the sample is\n    heterozygous for that variant.\n\n    Parameters:\n    -----------\n    vcf : str\n        Path to VCF file.\n\n    \"\"\"\n    # TODO: parallelize?\n    vcf_df = vcf_as_df(fn)\n    variant_ids = vcf_df.apply(lambda x: df_variant_id(x), axis=1)\n    vcf_reader = pyvcf.Reader(open(fn, 'r'))\n    record = vcf_reader.next()\n    hets = pd.DataFrame(0, index=variant_ids,\n                        columns=[x.sample for x in record.samples])\n    \n    vcf_reader = pyvcf.Reader(open(fn, 'r'))\n    for record in vcf_reader:\n        h = record.get_hets()\n        i = record_variant_id(record)\n        hets.ix[i, [x.sample for x in h]] = 1\n    \n    return hets"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef write_image(r, filename):\n    with open(filename, 'wb') as fd:\n        for chunk in r.iter_content(1024):\n            fd.write(chunk)", "response": "Writes an image to a file."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef current(self):\n        if not has_request_context():\n            return self.no_req_ctx_user_stack.top\n        user_stack = getattr(_request_ctx_stack.top, 'user_stack', None)\n        if user_stack and user_stack.top:\n            return user_stack.top\n        return _get_user()", "response": "Returns the current user s user_stack_tag"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngenerating a unique token associated to the user", "response": "def generate_user_token(self, user, salt=None):\n        \"\"\"Generates a unique token associated to the user\n        \"\"\"\n        return self.token_serializer.dumps(str(user.id), salt=salt)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nloading a user instance identified by the token generated using generate_user_token", "response": "def find_by_token(self, token, salt=None, max_age=None):\n        \"\"\"Loads a user instance identified by the token generated using generate_user_token()\n        \"\"\"\n        model = current_app.features.models[self.options[\"model\"]]\n        try:\n            id = self.token_serializer.loads(token, salt=salt, max_age=max_age)\n        except BadSignature:\n            return None\n        if id is None:\n            return None\n        return self.find_by_id(id)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nupdating the password of a user", "response": "def update_password(self, user, password, skip_validation=False):\n        \"\"\"Updates the password of a user\n        \"\"\"\n        pwcol = self.options[\"password_column\"]\n        pwhash = self.bcrypt.generate_password_hash(password)\n        if not skip_validation:\n            self.validate_password(user, password, pwhash)\n        if self.options['prevent_password_reuse']:\n            user.previous_passwords = [getattr(user, pwcol)] + (user.previous_passwords or [])\n            if self.options['max_password_reuse_saved']:\n                user.previous_passwords = user.previous_passwords[:self.options['max_password_reuse_saved']]\n        setattr(user, pwcol, pwhash)\n        user.last_password_change_at = datetime.datetime.utcnow()\n        user.must_reset_password_at_login = False"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef login_required(self, fresh=False, redirect_to=None):\n        if not self.logged_in() or (fresh and not self.login_manager.login_fresh()):\n            if redirect_to:\n                resp = redirect(redirect_to)\n            else:\n                resp = self.login_manager.unauthorized()\n            current_context.exit(resp, trigger_action_group=\"missing_user\")", "response": "Ensures that a user is authenticated and that the user is logged in."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nlog the user in flask - login", "response": "def _login(self, user, provider=None, remember=False, force=False, **attrs):\n        \"\"\"Updates user attributes and login the user in flask-login\n        \"\"\"\n        user.last_login_at = datetime.datetime.now()\n        user.last_login_provider = provider or self.options[\"default_auth_provider_name\"]\n        user.last_login_from = request.remote_addr\n        populate_obj(user, attrs)\n        save_model(user)\n        flask_login.login_user(user, remember=remember, force=force)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef check_password_confirm(self, form, trigger_action_group=None):\n        pwcol = self.options['password_column']\n        pwconfirmfield = pwcol + \"_confirm\"\n        if pwcol in form and pwconfirmfield in form and form[pwconfirmfield].data != form[pwcol].data:\n            if self.options[\"password_confirm_failed_message\"]:\n                flash(self.options[\"password_confirm_failed_message\"], \"error\")\n            current_context.exit(trigger_action_group=trigger_action_group)", "response": "Checks that the password and confirm password match in\n            the provided form."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef validate_user(self, user=None, username=None, email=None, password=None, ignore_user_id=None,\n                      must_provide_password=False, flash_messages=True, raise_error=True, is_signup=False):\n        \"\"\"Validates a new user object before saving it in the database.\n        Checks if a password is present unless must_provide_password is False.\n        Checks if the username is unique unless the option username_is_unique is set to False.\n        If the email column exists on the user object and the option email_is_unique is set to True,\n        also checks if the email is unique.\n        \"\"\"\n        ucol = self.options['username_column']\n        emailcol = self.options['email_column']\n        if user:\n            username = getattr(user, ucol, None)\n            email = getattr(user, emailcol, None)\n            password = getattr(user, self.options[\"password_column\"], None)\n            ignore_user_id = getattr(user, 'id', None)\n        if username is not None:\n            username = username.strip()\n        if email is not None:\n            email = email.strip().lower()\n\n        if must_provide_password and not password:\n            if raise_error:\n                raise SignupValidationFailedException(\"password_missing\")\n            return False\n\n        if self.user_validator and self.override_builtin_user_validation:\n            if not self.user_validator(username, email, password, is_signup):\n                if raise_error:\n                    raise SignupValidationFailedException(\"failed_validation\")\n                return False\n            return True\n\n        if ucol != emailcol and self.options[\"must_provide_username\"]:\n            if not username:\n                if flash_messages and self.options[\"must_provide_username_error_message\"]:\n                    flash(self.options[\"must_provide_username_error_message\"], \"error\")\n                if raise_error:\n                    raise SignupValidationFailedException(\"username_missing\")\n                return False\n            if username.lower() in self.options['forbidden_usernames']:\n                if flash_messages and self.options[\"signup_user_exists_message\"]:\n                    flash(self.options[\"signup_user_exists_message\"], \"error\")\n                if raise_error:\n                    raise SignupValidationFailedException(\"username_forbidden\")\n                return False\n            if len(username) < self.options['min_username_length']:\n                if flash_messages and self.options[\"username_too_short_message\"]:\n                    flash(self.options[\"username_too_short_message\"], \"error\")\n                if raise_error:\n                    raise SignupValidationFailedException(\"username_too_short\")\n                return False\n            if not self.options['allow_spaces_in_username'] and \" \" in username:\n                if flash_messages and self.options[\"username_has_spaces_message\"]:\n                    flash(self.options[\"username_has_spaces_message\"], \"error\")\n                if raise_error:\n                    raise SignupValidationFailedException(\"username_has_spaces\")\n                return False\n        if ucol != emailcol and username and self.options[\"username_is_unique\"]:\n            col = ucol if self.options[\"username_case_sensitive\"] else ucol + '_lcase'\n            uname = username if self.options[\"username_case_sensitive\"] else username.lower()\n            q = self.query.filter((col, uname))\n            if ignore_user_id:\n                q = q.filter((\"id__ne\", ignore_user_id))\n            if q.count() > 0:\n                if flash_messages and self.options[\"signup_user_exists_message\"]:\n                    flash(self.options[\"signup_user_exists_message\"], \"error\")\n                if raise_error:\n                    raise SignupValidationFailedException(\"user_exists\")\n                return False\n        if self.options[\"must_provide_email\"] and not email:\n            if flash_messages and self.options[\"must_provide_email_error_message\"]:\n                flash(self.options[\"must_provide_email_error_message\"], \"error\")\n            if raise_error:\n                raise SignupValidationFailedException(\"email_missing\")\n            return False\n        if self.options[\"email_is_unique\"] and email:\n            q = self.query.filter((emailcol, email))\n            if ignore_user_id:\n                q = q.filter((\"id__ne\", ignore_user_id))\n            if q.count() > 0:\n                if flash_messages and self.options[\"signup_email_exists_message\"]:\n                    flash(self.options[\"signup_email_exists_message\"], \"error\")\n                if raise_error:\n                    raise SignupValidationFailedException(\"email_exists\")\n                return False\n\n        if self.user_validator and not self.user_validator(username, email, password, is_signup):\n            if raise_error:\n                raise SignupValidationFailedException(\"failed_validation\")\n            return False\n\n        return True", "response": "Validates a user object and saves it in the database."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nexecutes post signup actions.", "response": "def post_signup(self, user, login_user=None, send_email=None):\n        \"\"\"Executes post signup actions: sending the signal, logging in the user and\n        sending the welcome email\n        \"\"\"\n        self.signup_signal.send(self, user=user)\n\n        if (login_user is None and self.options[\"login_user_on_signup\"]) or login_user:\n            self._login(user, user.signup_provider)\n\n        to_email = getattr(user, self.options[\"email_column\"], None)\n        if to_email and ((send_email is None and self.options[\"send_welcome_email\"]) or send_email):\n            template = \"users/welcome.txt\" if self.options[\"send_welcome_email\"] == True else self.options[\"send_welcome_email\"]\n            current_app.features.emails.send(to_email, template, user=user)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef gen_reset_password_token(self, user=None, send_email=None):\n        if not user and \"form\" in current_context.data and request.method == \"POST\":\n            form = current_context.data.form\n            user = self.find_by_email(form[self.options[\"email_column\"]].data)\n            if user is None:\n                if self.options[\"reset_password_token_error_message\"]:\n                    flash(self.options[\"reset_password_token_error_message\"], \"error\")\n                current_context.exit(trigger_action_group=\"reset_password_failed\")\n                \n        if not user:\n            raise InvalidOptionError(\"Invalid user in 'reset_password_token' action\")\n\n        token = self._gen_reset_password_token(user)\n        self.reset_password_token_signal.send(self, user=user, token=token)\n        if (send_email is None and self.options[\"send_reset_password_email\"]) or send_email:\n            to_email = getattr(user, self.options[\"email_column\"])\n            current_app.features.emails.send(to_email, \"users/reset_password.txt\", user=user, token=token)\n        return token", "response": "Generates a reset password token and sends the reset password email"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nresets the password of the user identified by the token.", "response": "def reset_password(self, token=None, login_user=None):\n        \"\"\"Resets the password of the user identified by the token\n        \"\"\"\n        pwcol = self.options['password_column']\n        if not token:\n            if \"token\" in request.view_args:\n                token = request.view_args[\"token\"]\n            elif \"token\" in request.values:\n                token = request.values[\"token\"]\n            else:\n                raise OptionMissingError((\"Missing 'token' option or 'token' view arg \"\n                                          \"or 'token' GET paramater in 'reset_password' action\"))\n\n        user = self.find_by_token(token, salt=\"password-reset\", max_age=self.options[\"reset_password_ttl\"])\n        if user is None:\n            if self.options[\"reset_password_error_message\"]:\n                flash(self.options[\"reset_password_error_message\"], \"error\")\n            current_context.exit(trigger_action_group=\"reset_password_failed\")\n\n        self.update_password_from_form(user)\n        self.reset_password_signal.send(self, user=user)\n        if (login_user is None and self.options[\"login_user_on_reset_password\"]) or login_user:\n            flask_login.login_user(user)\n        return user"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef update_password_from_form(self, user=None, form=None):\n        user = user or self.current\n        if not form and \"form\" in current_context.data and request.method == \"POST\":\n            form = current_context.data.form\n        elif not form:\n            raise OptionMissingError(\"Missing a form in 'update_user_password' action\")\n\n        self._update_password_from_form(user, form)\n        save_model(user)\n        self.update_user_password_signal.send(self, user=user)", "response": "Updates the user password using a form"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nchecking if the password matches the one of the user.", "response": "def check_user_password(self, user, password=None, form=None):\n        \"\"\"Checks if the password matches the one of the user. If no password is\n        provided, the current form will be used\n        \"\"\"\n        pwcol = self.options['password_column']\n        if password is None:\n            if not form and \"form\" in current_context.data and request.method == \"POST\":\n                form = current_context.data.form\n            if form:\n                password = form[pwcol].data\n            else:\n                raise OptionMissingError(\"Missing 'password' option or a form\")\n        current_pwd = getattr(user, pwcol)\n        if not current_pwd or not self.bcrypt.check_password_hash(current_pwd, password):\n            current_context.exit(trigger_action_group=\"password_mismatch\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef check_unique_attr(self, attrs, user=None, form=None, flash_msg=None):\n        user = user or self.current\n        ucol = self.options[\"username_column\"]\n        email = self.options[\"email_column\"]\n        if not isinstance(attrs, (list, tuple, dict)):\n            attrs = [attrs]\n\n        for name in attrs:\n            if isinstance(attrs, dict):\n                value = attrs[name]\n            else:\n                form = form or current_context.data.get(\"form\")\n                if not form:\n                    raise OptionMissingError(\"Missing 'value' option or form in 'check_user_unique_attr' action\")\n                value = form[name].data\n\n            if name == ucol and not self.options[\"username_case_sensitive\"]:\n                filters = (ucol + '_lcase', value.strip().lower())\n            elif name == emailcol:\n                filters = (emailcol, value.strip().lower())\n            else:\n                filters = (name, value.strip())\n\n            if self.query.filter({\"$and\": [filters, (\"id__ne\", user.id)]}).count() > 0:\n                if flash_msg is None:\n                    flash_msg = \"The %s is already in use\" % name\n                if flash_msg:\n                    flash(flash_msg, \"error\")\n                current_context.exit(trigger_action_group=\"user_attr_not_unique\")", "response": "Checks that an attribute of the current user is unique amongst all users."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nexecutes a login via oauth.", "response": "def oauth_login(self, provider, id_column, id, attrs, defaults, redirect_url=None):\n        \"\"\"Execute a login via oauth. If no user exists, oauth_signup() will be called\n        \"\"\"\n        user = self.query.filter(**dict([(id_column, id)])).first()\n        if not redirect_url:\n            redirect_url = request.args.get('next') or url_for(self.options[\"redirect_after_login\"])\n        if self.logged_in():\n            if user and user != self.current:\n                if self.options[\"oauth_user_already_exists_message\"]:\n                    flash(self.options[\"oauth_user_already_exists_message\"].format(provider=provider), \"error\")\n                return redirect(redirect_url)\n            if provider not in self.current.auth_providers:\n                self.current.auth_providers.append(provider)\n            current_app.features.models.save(self.current, **attrs)\n        elif not user:\n            return self.oauth_signup(provider, attrs, defaults, redirect_url=redirect_url)\n        else:\n            self.login(user, provider=provider, **attrs)\n        return redirect(redirect_url)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef oauth_signup(self, provider, attrs, defaults, redirect_url=None):\n        session[\"oauth_user_defaults\"] = defaults\n        session[\"oauth_user_attrs\"] = dict(provider=provider, **attrs)\n        if not redirect_url:\n            redirect_url = request.args.get(\"next\")\n        return redirect(url_for('users.oauth_signup', next=redirect_url))", "response": "Start the oauth signup process after having logged in via oauth"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef pad_length(s):\n    padding_chars = [\n        u'\\ufe4e',  # \ufe4e: CENTRELINE LOW LINE\n        u'\\u040d',  # \u040d: CYRILLIC CAPITAL LETTER I WITH GRAVE\n        u'\\u05d0',  # \u05d0: HEBREW LETTER ALEF\n        u'\\u01c6',  # \u01c6: LATIN SMALL LETTER DZ WITH CARON\n        u'\\u1f8f',  # \u1f8f: GREEK CAPITAL LETTER ALPHA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI\n        u'\\u2167',  # \u2167: ROMAN NUMERAL EIGHT\n        u'\\u3234',  # \u3234: PARENTHESIZED IDEOGRAPH NAME\n        u'\\u32f9',  # \u32f9: CIRCLED KATAKANA RE\n        u'\\ud4db',  # \ud4db: HANGUL SYLLABLE PWILH\n        u'\\ufe8f',  # \ufe8f: ARABIC LETTER BEH ISOLATED FORM\n        u'\\U0001D7D8',  # \ud835\udfd8: MATHEMATICAL DOUBLE-STRUCK DIGIT ZERO\n        u'\\U0001F6A6',  # \ud83d\udea6: VERTICAL TRAFFIC LIGHT\n        ]\n    padding_generator = itertools.cycle(padding_chars)\n    target_lengths = {\n        six.moves.range(1, 11): 3,\n        six.moves.range(11, 21): 2,\n        six.moves.range(21, 31): 1.8,\n        six.moves.range(31, 51): 1.6,\n        six.moves.range(51, 71): 1.4,\n    }\n    if len(s) > 70:\n        target_length = int(math.ceil(len(s) * 1.3))\n    else:\n        for r, v in target_lengths.items():\n            if len(s) in r:\n                target_length = int(math.ceil(len(s) * v))\n    diff = target_length - len(s)\n    pad = u\"\".join([next(padding_generator) for _ in range(diff)])\n    return s + pad", "response": "Pads a string to increase the length of the string."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndissects the format string and gets the order of the tokens as it finds them l -> r", "response": "def parse_format_order(cls, format_target):\n        \"\"\" Dissects the format string and gets the order of the tokens as it finds them l->r\n            Splits on camel case or periods/underscores\n            Modified version from this:\n            http://stackoverflow.com/questions/2277352/python-split-a-string-at-uppercase-letters\n\n        :param format_target: str, format string we want to swap to\n        :return: list(str), list of the matching tokens\n        \"\"\"\n        try:\n            pattern = re.compile(settings.FORMAT_STRING_REGEX)\n            return [match.group() for match in pattern.finditer(format_target)]# if None not in match.groups()]\n        except TypeError:\n            raise exceptions.FormatError('Format string %s is not a valid input type, must be <type str>' %\n                                         format_target)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_valid_format_order(cls, format_target, format_order=None):\n        format_order = format_order or cls.parse_format_order(format_target)\n        cls.validate_no_token_duplicates(format_order)\n        format_target = cls.remove_tokens(format_target, format_order)\n        format_target = cls.remove_static_text(format_target)\n        cls.validate_separator_characters(format_target)\n        cls.validate_matched_parenthesis(format_target)\n        return format_order", "response": "Checks to see if the format string follows the proper style\n       "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef validate_matched_parenthesis(cls, format_target):\n        iparens = iter('(){}[]<>')\n        parens = dict(zip(iparens, iparens))\n        closing = parens.values()\n\n        def balanced(astr):\n            stack = []\n            for c in astr:\n                d = parens.get(c, None)\n                if d:\n                    stack.append(d)\n                elif c in closing:\n                    if not stack or c != stack.pop():\n                        return False\n            return not stack\n\n        if format_target:\n            if not balanced(format_target):\n                raise exceptions.BalanceError(\"Format string has unmatching parentheses.\")", "response": "Validate that the format string has a matching parentheses."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _handle_errors(self, errors_list):\n        errors = []\n        for error in errors_list:\n            errors.append((error.domain_name, error.line, error.column,\n                error.level_name, error.type_name, error.message))\n        return errors", "response": "Handles errors list\n            and returns a list of lists of error messages."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_validation_errors(self, xml_input):\n        errors = []\n        try:\n            parsed_xml = etree.parse(self._handle_xml(xml_input))\n            self.xmlschema.assertValid(parsed_xml)\n        except (etree.DocumentInvalid, etree.XMLSyntaxError), e:\n            errors = self._handle_errors(e.error_log)\n        except AttributeError:\n            raise CannotValidate('Set XSD to validate the XML')\n        return errors", "response": "This method returns a list of validation errors."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef validate(self, xml_input):\n        parsed_xml = etree.parse(self._handle_xml(xml_input))\n        try:\n            return self.xmlschema.validate(parsed_xml)\n        except AttributeError:\n            raise CannotValidate('Set XSD to validate the XML')", "response": "This method validates the parsing and schema of the XML and returns a boolean containing True if the XML is valid False otherwise."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef deserialize(self, xml_input, *args, **kwargs):\n        return xmltodict.parse(xml_input, *args, **kwargs)", "response": "Convert XML to dict"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncompressing folder dump to tar. gz file", "response": "def compress_folder_dump(path, target):\n    '''\n    Compress folder dump to tar.gz file\n    '''\n    import tarfile\n    if not path or not os.path.isdir(path):\n        raise SystemExit(_error_codes.get(105))\n    name_out_file = (target + 'dump-' +\n                     datetime.datetime.now().strftime('%Y-%m-%d-%H-%M-%S'))\n    tar = tarfile.open(name_out_file + '.tar.gz', 'w:gz')\n    tar.add(path, arcname='dump')\n    tar.close()\n    return (name_out_file, name_out_file + '.tar.gz')"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nencrypt file with AES method and password.", "response": "def encrypt_file(path, output, password=None):\n    '''\n    Encrypt file with AES method and password.\n    '''\n    if not password:\n        password = PASSWORD_FILE\n    query = 'openssl aes-128-cbc -salt -in {0} -out {1} -k {2}'\n    with hide('output'):\n        local(query.format(path, output, password))\n        os.remove(path)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef decrypt_file(path, password=None):\n    '''\n    Decrypt file with AES method and password.\n    '''\n    global PASSWORD_FILE\n    if not password:\n        password = PASSWORD_FILE\n    if path and not os.path.isfile(path):\n        raise SystemExit(_error_codes.get(106))\n    query = 'openssl aes-128-cbc -d -salt -in {0} -out {1} -k {2}'\n    with hide('output'):\n        local(query.format(path, path + '.tar.gz', PASSWORD_FILE))", "response": "Decrypt file with AES method and password."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef optional_actions(encrypt, path, compress_file, **kwargs):\n    '''\n    Optional actions about of AWS S3 and encrypt file.\n    '''\n    yes = ('y', 'Y')\n    file_to_upload = normalize_path(path) + compress_file[1]\n    if encrypt in yes:\n        encrypt_file(compress_file[1], compress_file[0])\n        file_to_upload = compress_file[0]\n\n    if kwargs.get('s3') in yes:\n        factory_uploader('S3', name_backup=file_to_upload,\n                         bucket_name=AWS_BUCKET_NAME, action='upload')\n\n    if kwargs.get('glacier') in yes:\n        factory_uploader('Glacier', name_backup=file_to_upload,\n                         vault_name=AWS_VAULT_NAME,\n                         path=os.path.join(os.path.expanduser('~'),\n                                           '.zoort.db'),\n                         action='upload')\n    if kwargs.get('dropbox') in yes:\n        factory_uploader('Dropbox', name_backup=file_to_upload,\n                         action='upload')\n    if kwargs.get('swift') in yes:\n        factory_uploader('Swift', name_backup=file_to_upload,\n                         action='upload')", "response": "Returns a list of optional actions about of AWS S3 and Glacier and Dropbox and Swift files."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef main():\n    '''Main entry point for the mongo_backups CLI.'''\n    args = docopt(__doc__, version=__version__)\n    if args.get('backup'):\n        backup_database(args)\n    if args.get('backup_all'):\n        backup_all(args)\n    if args.get('decrypt'):\n        decrypt_file(args.get('<path>'))\n    if args.get('configure'):\n        configure(service='all')\n    if args.get('configure-aws'):\n        configure(service='aws')\n    if args.get('configure-dropbox'):\n        configure(service='dropbox')\n    if args.get('configure-swift'):\n        configure(service='swift')\n    if args.get('download_all'):\n        download_all()", "response": "This is the main entry point for the mongo_backups CLI."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_history(self):\n        if hasattr(self, '_history'):\n            return self._history\n        try:\n            self._history = APICallDayHistory.objects.get(\n                user=self.user, creation_date=now().date())\n        except APICallDayHistory.DoesNotExist:\n            self._history = APICallDayHistory(user=self.user)\n            self._history.amount_api_calls = 0\n        return self._history", "response": "Returns the history from cache or DB or a newly created one."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef is_rate_limit_exceeded(self):\n        history = self.get_history()\n        if history.amount_api_calls >= settings.UNSHORTEN_DAILY_LIMIT:\n            return True\n        return False", "response": "Returns True if the rate limit is exceeded otherwise False."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef log_api_call(self):\n        history = self.get_history()\n        history.amount_api_calls += 1\n        self._history = history.save()\n        return history", "response": "Increases the amount of logged API calls for the user by 1. Returns the current user s history object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef de_duplicate(items):\n    result = []\n    for item in items:\n        if item not in result:\n            result.append(item)\n    return result", "response": "Remove any duplicate item preserving order\n   "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef is_method(method, flags=METHOD_ALL):\n    if isinstance(method, types.UnboundMethodType):\n        if flags & METHOD_CLASS and issubclass(method.im_class, type):\n            return True\n        if flags & METHOD_INSTANCE and not issubclass(method.im_class, type):\n            return True\n        if flags & METHOD_BOUND and method.im_self is not None:\n            return True\n        if flags & METHOD_UNBOUND and method.im_self is None:\n            return True\n    return False", "response": "Determines whether the passed value is a method."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nread the configuration file stack.", "response": "def read_configs(__pkg: str, __name: str = 'config', *,\n                 local: bool = True) -> ConfigParser:\n    \"\"\"Process configuration file stack.\n\n    We export the time parsing functionality of ``jnrbase`` as custom\n    converters for :class:`configparser.ConfigParser`:\n\n    ===================  ===========================================\n    Method               Function\n    ===================  ===========================================\n    ``.getdatetime()``   :func:`~jnrbase.iso_8601.parse_datetime`\n    ``.gethumantime()``  :func:`~jnrbase.human_time.parse_timedelta`\n    ``.gettimedelta()``  :func:`~jnrbase.iso_8601.parse_delta`\n    ===================  ===========================================\n\n    Args:\n        __pkg: Package name to use as base for config files\n        __name: File name to search for within config directories\n        local: Whether to include config files from current directory\n    Returns:\n        Parsed configuration files\n    \"\"\"\n    configs = get_configs(__pkg, __name)\n    if local:\n        localrc = path.abspath('.{}rc'.format(__pkg))\n        if path.exists(localrc):\n            configs.append(localrc)\n\n    cfg = ConfigParser(converters={\n        'datetime': parse_datetime,\n        'humandelta': parse_timedelta,\n        'timedelta': parse_delta,\n    })\n    cfg.read(configs, 'utf-8')\n    cfg.configs = configs\n\n    if 'NO_COLOUR' in environ or 'NO_COLOR' in environ:\n        cfg.colour = False\n    elif __pkg in cfg:\n        if 'colour' in cfg[__pkg]:\n            cfg.colour = cfg[__pkg].getboolean('colour')\n        if 'color' in cfg[__pkg]:\n            cfg.colour = cfg[__pkg].getboolean('color')\n    else:\n        cfg.colour = True\n\n    return cfg"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _parse_reflectivity(line, lines):\n\n    split_line = line.split()\n\n    energy = float(split_line[0])\n    reflect_xx = float(split_line[1])\n    reflect_zz = float(split_line[2])\n\n    return {\"energy\": energy, \"reflect_xx\": reflect_xx, \"reflect_zz\": reflect_zz}", "response": "Parse reflectivity from line"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef authenticate(self, username, password):\n        if getattr(settings, 'ABAKUS_DUMMY_AUTH', False):\n            return self.dummy_authenticate(username, password)\n        response = requests.post(url=path, data={'username': username, 'password': password})\n        info = response.json()\n\n        try:\n            user_info = info['user']\n        except KeyError:\n            raise ApiError(info['status_message'])\n\n        if not bool(user_info['auth']):\n            return None\n\n        if getattr(settings, 'ABAKUS_AUTH_REQUIRE_ABAKUS', False) and not user_info['is_abakus']:\n            return None\n\n        if getattr(settings, 'ABAKUS_AUTH_REQUIRE_ABAKOM', False) and not user_info['is_abakom']:\n            return None\n\n        if hasattr(settings, 'ABAKUS_GROUP_REQUIRED'):\n            if not self.has_required_group(user_info):\n                return None\n\n        user = get_user_model().objects.get_or_create(username=username)[0]\n        user.is_active = True\n        self.parse_name(user, user_info['name'])\n        user.save()\n\n        if 'committees' in user_info:\n            for committee in user_info['committees']:\n                groups = Group.objects.filter(name=committee)\n                if len(groups) == 1:\n                    user.groups.add(groups[0])\n\n            if hasattr(settings, 'ABAKUS_SUPERUSER_GROUPS'):\n                for superuser_committee in settings.ABAKUS_SUPERUSER_GROUPS:\n                    if superuser_committee in user_info['committees']:\n                        user.is_superuser = True\n                        user.is_staff = True\n                        user.save()\n                        break\n\n        return user", "response": "Should try to login with abakus.no (NERD)."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _start(self):\n\n        # Initialize the locks\n        self._recv_lock = coros.Semaphore(0)\n        self._send_lock = coros.Semaphore(0)\n\n        # Boot the threads\n        self._recv_thread = gevent.spawn(self._recv)\n        self._send_thread = gevent.spawn(self._send)\n\n        # Link the threads such that we get notified if one or the\n        # other exits\n        self._recv_thread.link(self._thread_error)\n        self._send_thread.link(self._thread_error)", "response": "Starts the underlying send and receive threads."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _recv(self):\n\n        # Outer loop: receive some data\n        while True:\n            # Wait until we can go\n            self._recv_lock.release()\n            gevent.sleep()  # Yield to another thread\n            self._recv_lock.acquire()\n\n            recv_buf = self._sock.recv(self.recv_bufsize)\n\n            # If it's empty, the peer closed the other end\n            if not recv_buf:\n                # Manually kill the send thread; do this manually\n                # instead of calling close() because close() will kill\n                # us, and since close() would be running in our thread\n                # context, it would never get around to killing the\n                # send thread\n                if self._send_thread:\n                    self._send_thread.kill()\n                    self._send_thread = None\n\n                # Manually close the socket\n                self._sock.close()\n                self._sock = None\n\n                # Make sure the manager knows we're closed\n                super(TCPTendril, self).close()\n\n                # Notify the application\n                self.closed()\n\n                # As our last step, commit seppuku; this will keep\n                # _thread_error() from notifying the application of an\n                # erroneous exit from the receive thread\n                raise gevent.GreenletExit()\n\n            # Process the received data\n            self._recv_frameify(recv_buf)", "response": "Receives some data from the socket and sends it to the application."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsends the data to the socket.", "response": "def _send(self):\n        \"\"\"\n        Implementation of the send thread.  Waits for data to be added\n        to the send buffer, then passes as much of the buffered data\n        to the socket ``send()`` method as possible.\n        \"\"\"\n\n        # Outer loop: wait for data to send\n        while True:\n            # Release the send lock and wait for data, then reacquire\n            # the send lock\n            self._send_lock.release()\n            self._sendbuf_event.wait()\n            self._send_lock.acquire()\n\n            # Inner loop: send as much data as we can\n            while self._sendbuf:\n                sent = self._sock.send(self._sendbuf)\n\n                # Trim that much data off the send buffer, so we don't\n                # accidentally re-send anything\n                self._sendbuf = self._sendbuf[sent:]\n\n            # OK, _sendbuf is empty; clear the event so we'll sleep\n            self._sendbuf_event.clear()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nhandle the case that the send or receive thread exit or throw an exception.", "response": "def _thread_error(self, thread):\n        \"\"\"\n        Handles the case that the send or receive thread exit or throw\n        an exception.\n        \"\"\"\n\n        # Avoid double-killing the thread\n        if thread == self._send_thread:\n            self._send_thread = None\n        if thread == self._recv_thread:\n            self._recv_thread = None\n\n        # Figure out why the thread exited\n        if thread.successful():\n            exception = socket.error('thread exited prematurely')\n        elif isinstance(thread.exception, gevent.GreenletExit):\n            # Thread was killed; don't do anything but close\n            self.close()\n            return\n        else:\n            exception = thread.exception\n\n        # Close the connection...\n        self.close()\n\n        # Notify the application what happened\n        self.closed(exception)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef wrap(self, wrapper):\n\n        if self._recv_thread and self._send_thread:\n            # Have to suspend the send/recv threads\n            self._recv_lock.acquire()\n            self._send_lock.acquire()\n\n        # Wrap the socket\n        self._sock = wrapper(self._sock)\n\n        # OK, restart the send/recv threads\n        if self._recv_thread and self._send_thread:\n            # Release our locks\n            self._send_lock.release()\n            self._recv_lock.release()", "response": "A wrapper function that wraps the underlying socket."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef send_frame(self, frame):\n\n        self._sendbuf += self._send_streamify(frame)\n        self._sendbuf_event.set()", "response": "Send a frame to the other end of the connection."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncloses the connection. Kills the send and receive threads, as well as closing the underlying socket.", "response": "def close(self):\n        \"\"\"\n        Close the connection.  Kills the send and receive threads, as\n        well as closing the underlying socket.\n        \"\"\"\n\n        if self._recv_thread:\n            self._recv_thread.kill()\n            self._recv_thread = None\n\n        if self._send_thread:\n            self._send_thread.kill()\n            self._send_thread = None\n\n        if self._sock:\n            self._sock.close()\n            self._sock = None\n\n        # Make sure to notify the manager we're closed\n        super(TCPTendril, self).close()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef connect(self, target, acceptor, wrapper=None):\n\n        # Call some common sanity-checks\n        super(TCPTendrilManager, self).connect(target, acceptor, wrapper)\n\n        # Set up the socket\n        sock = socket.socket(self.addr_family, socket.SOCK_STREAM)\n\n        with utils.SocketCloser(sock, ignore=[application.RejectConnection]):\n            # Bind to our endpoint\n            sock.bind(self.endpoint)\n\n            # Connect to our target\n            sock.connect(target)\n\n            # Call any wrappers\n            if wrapper:\n                sock = wrapper(sock)\n\n            # Now, construct a Tendril\n            tend = TCPTendril(self, sock)\n\n            # Finally, set up the application\n            tend.application = acceptor(tend)\n\n            # OK, let's track the tendril\n            self._track_tendril(tend)\n\n            # Start the tendril\n            tend._start()\n\n            # Might as well return the tendril, too\n            return tend\n\n        # The acceptor raised a RejectConnection exception, apparently\n        sock.close()\n        return None", "response": "Initiate a connection from the tendril manager s endpoint and return a TCPTendril object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef listener(self, acceptor, wrapper):\n\n        # If we have no acceptor, there's nothing for us to do here\n        if not acceptor:\n            # Not listening on anything\n            self.local_addr = None\n\n            # Just sleep in a loop\n            while True:\n                gevent.sleep(600)\n            return  # Pragma: nocover\n\n        # OK, set up the socket\n        sock = socket.socket(self.addr_family, socket.SOCK_STREAM)\n\n        with utils.SocketCloser(sock):\n            # Set up SO_REUSEADDR\n            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n\n            # Bind to our endpoint\n            sock.bind(self.endpoint)\n\n            # Get the assigned port number\n            self.local_addr = sock.getsockname()\n\n            # Call any wrappers\n            if wrapper:\n                sock = wrapper(sock)\n\n            # Initiate listening\n            sock.listen(self.backlog)\n\n        # OK, now go into an accept loop with an error threshold of 10\n        closer = utils.SocketCloser(sock, 10,\n                                    ignore=[application.RejectConnection])\n        while True:\n            with closer:\n                cli, addr = sock.accept()\n\n                # OK, the connection has been accepted; construct a\n                # Tendril for it\n                tend = TCPTendril(self, cli, addr)\n\n                # Set up the application\n                with utils.SocketCloser(cli):\n                    tend.application = acceptor(tend)\n\n                    # Make sure we track the new tendril, but only if\n                    # the acceptor doesn't throw any exceptions\n                    self._track_tendril(tend)\n\n                    # Start the tendril\n                    tend._start()", "response": "Listen for new connections to the manager s endpoint."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef getdim(lsp):\n    '''\n    Obtain the dimensionality of a .lsp file. This should work for all well\n    formatted .lsp files.\n\n    Parameters:\n    -----------\n       lsp      : .lsp string\n\n    Returns a list of dimensions.\n    '''\n    dims= ['x','y', 'z'];\n    rxs = ['{}-cells *([0-9]+)'.format(x) for x in ['x','y','z']];\n    return [\n        x for x,rx in zip(dims,rxs)\n        if re.search(rx,lsp) and int(re.search(rx,lsp).group(1)) > 0 ];", "response": "This function returns the dimensionality of a well - known. lsp file. This should work for all well - known. lsp files."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget information from pext planes. This might or might not work, use with caution! Parameters: ----------- lsp : .lsp string Returns a list of dicts with information for all pext planes", "response": "def getpexts(lsp):\n    '''\n    Get information from pext planes. This might or might not work, use with\n    caution!\n\n    Parameters:\n    -----------\n\n      lsp       : .lsp string\n\n    Returns a list of dicts with information for all pext planes\n    '''\n    lines=lsp.split('\\n');\n    #unfortunately regex doesn't work here\n    lns,planens = zip(\n        *[ (i,int(re.search('^ *extract *([0-9]+)',line).group(1)))\n           for i,line in enumerate(lines)\n           if re.search('^ *extract *[0-9]+', line)]);\n    if len(lns) == 0: return [];\n    end = lns[-1];\n    \n    for i,line in enumerate(lines[end+1:]):\n        if re.match(' *\\[',line): break;\n    end += i;\n    lineranges = zip(lns,(lns+(end,))[1:]);\n    planes=dict()\n    for (i,end),plane in zip(lineranges,planens):\n        d=dict();\n        labels = [\n            'species',\n            'direction',\n            'position',];\n        datarx = [\n            '^ *species *([0-9]+)',\n            '^ *direction *([xXyYzZ])',\n            '^ *at *(.*)',];\n        convs  = [\n            lambda s: int(s),\n            lambda i: i,\n            lambda s: np.array(\n                map(float,s.split(' '))),\n        ];\n        for line in lines[i:end]:\n            for label,rx,conv in zip(labels,datarx,convs):\n                if re.match(rx,line):\n                    d[label]=conv(re.match(rx,line).group(1));\n                pass\n            pass\n        planes[plane] = d;\n    return planes;"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef percentile(sorted_list, percent, key=lambda x: x):\n    if not sorted_list:\n        return None\n    if percent == 1:\n        return float(sorted_list[-1])\n    if percent == 0:\n        return float(sorted_list[0])\n    n = len(sorted_list)\n    i = percent * n\n    if ceil(i) == i:\n        i = int(i)\n        return (sorted_list[i-1] + sorted_list[i]) / 2\n    return float(sorted_list[ceil(i)-1])", "response": "Find the percentile of a sorted list of values."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nretrieves the api catalog of the driver", "response": "def get_driver_api_catalog(driver):  # noqa: E501\n    \"\"\"Retrieve the api catalog\n\n    Retrieve the api catalog # noqa: E501\n\n    :param driver: The driver to use for the request. ie. github\n    :type driver: str\n\n    :rtype: Response\n    \"\"\"\n    response = errorIfUnauthorized(role='developer')\n    if response:\n        return response\n    else:\n        response = ApitaxResponse()\n\n    driver: Driver = LoadedDrivers.getDriver(driver)\n    response.body.add(driver.getApiEndpointCatalog())\n\n    return Response(status=200, body=response.getResponseBody())"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_driver_api_status(driver):  # noqa: E501\n    response = errorIfUnauthorized(role='developer')\n    if response:\n        return response\n    else:\n        response = ApitaxResponse()\n\n    driver: Driver = LoadedDrivers.getDriver(driver)\n    response.body.add({\"format\": driver.getApiFormat()})\n    response.body.add({\"description\": driver.getApiDescription()})\n    response.body.add({\"status\": driver.getApiStatus()})\n    response.body.add({\"auth-type\": driver.getApiAuthType()})\n\n    endpoints = {}\n    endpoints['base'] = driver.getApiBaseEndpoint()\n    endpoints['catalog'] = driver.getApiCatalogEndpoint()\n    endpoints['auth'] = driver.getApiAuthEndpoint()\n    response.body.add({'endpoints': endpoints})\n\n    options = {}\n    options['authenticatable'] = driver.isApiAuthenticated()\n    options['authentication-separate'] = driver.isApiAuthenticationSeparateRequest()\n    options['cataloggable'] = driver.isApiCataloggable()\n    options['tokenable'] = driver.isApiTokenable()\n    response.body.add({'options': options})\n\n    return Response(status=200, body=response.getResponseBody())", "response": "Retrieve the status of an api backing a driver"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _parse_engine(engine):\n        engine = (engine or '').strip()\n        backend, path = URI_RE.match(engine).groups()\n\n        if backend not in SUPPORTED_BACKENDS:\n            raise NotImplementedError(\n                \"Logg supports only {0} for now.\".format(SUPPORTED_BACKENDS))\n        log.debug('Found engine: {0}'.format(engine))\n        return backend, path", "response": "Parse the engine uri to determine where to store loggs"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncommit a log record and return a dict of the log entries.", "response": "def _logg_record(self, record, date):\n        \"\"\"\n        # %> idid work 2015-01-01 '... bla bla #tag @mention ...'\n        # results in a logg entry in the 'work' datastore for $DATE (by user)\n\n        # author_date = '2015-01-01T01:01:01'\n        # record = 'Did something AMAZING! [#id] #did'\n\n        # info about specifying a specific date for the committ\n        # http://stackoverflow.com/a/3898842/1289080\n        # Each commit has two dates: the author date and the committer date.\n\n        # commit the record and update the commit date to\n        # r.git.commit(m=record, date=author_date, allow_empty=True)\n        \"\"\"\n        # FIXME: take emails from config (extracted in CLI already)\n        # FIXME: extract out the possible dates and other tokens\n        # FIXME: check that we're using the write dates here...\n        # FIXME: check if it isn't a duplicate... of the previous\n        # and abort usless it's forced\n        #\n        # git date option needs HH:MM:SS +0000 specified too or it will assume\n        # current time values instead of 00:00:00\n        #\n        # When passing this I get a commit on\n        #  Date: Thu Jan 1 09:32:32 2015 +0100\n        # when just passing utcnow() i get\n        #  Date: Sun Oct 11 08:31:51 2015 +0200\n        # according to my clock (CET; +0200) it's Oct 11 10:33:...\n\n        # Make absolutely sure we have a git 1.8+ compatible date format!\n        date = Date(date, fmt=DT_GIT_FMT)\n        # Build dict for sending as args to the git commend\n        # -- or null says we want to open our editor to edit the commit msg\n\n        try:\n            result = self._commit(self._journal, record, date)\n        except KeyboardInterrupt as err:\n            log.error('Error encountered during git commit: {0}'.format(err))\n            raise SystemExit('\\n\\n')\n\n        # FIXME #########\n        # LOAD SYNC_TO options from config PER JOURNAL\n        # ie, sync to remote (friends) journals too\n        # ENABLE syncing to multiple (remotee) branches\n        # sync_to = None\n        # if sync_to:\n        #    # sync/backup branch (eg, master or remote)\n        #    log.info(' ... ... also syncing to: {0}'.format(sync_to))\n        #    record = '{0} [{1}]'.format(record, self._journal)\n        #    result_sync = self._commit(record, date)\n        #    log.debug(\" ... ... record committed\\n{0}\".format(result_sync))\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _init_repo(self):\n        log.debug(\"initializing new Git Repo: {0}\".format(self._engine_path))\n        if os.path.exists(self._engine_path):\n            log.error(\"Path already exists! Aborting!\")\n            raise RuntimeError\n        else:\n            # create the repo if it doesn't already exist\n            _logg_repo = git.Repo.init(path=self._engine_path, mkdir=True)\n            record = \"idid Logg repo initialized on {0}\".format(today())\n            c = _logg_repo.index.commit(record)\n            assert c.type == 'commit'\n            log.info('Created git repo [{0}]'.format(self._engine_path))\n        return _logg_repo", "response": "create and initialize a new Git Repo"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _load_repo(self):\n        if self._logg_repo:\n            return self._logg_repo\n\n        try:\n            _logg_repo = git.Repo(self._engine_path)\n            log.debug('Loaded git repo [{0}]'.format(self._engine_path))\n        except Exception:\n            # FIXME: should this be automatic?\n            # log.error(\"Git repo doesn't exist! run ``idid init``\")\n            _logg_repo = self._init_repo()\n        return _logg_repo", "response": "Load git repo using GitPython"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds generic command - line arguments to a top - level argparse parser.", "response": "def add_arguments(self, parser):\n        '''Add generic command-line arguments to a top-level argparse parser.\n\n        After running this, the results from ``argparse.parse_args()``\n        can be passed to :meth:`main`.\n\n        '''\n        commands = set(name[3:] for name in dir(self) if name.startswith('do_'))\n        parser.add_argument('action', help='action to run', nargs='?',\n                            choices=list(commands))\n        parser.add_argument('arguments', help='arguments specific to ACTION',\n                            nargs=argparse.REMAINDER)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nrunning a single command or else the main shell loop.", "response": "def main(self, args):\n        '''Run a single command, or else the main shell loop.\n\n        `args` should be the :class:`argparse.Namespace` object after\n        being set up via :meth:`add_arguments`.\n\n        '''\n        if args.action:\n            self.runcmd(args.action, args.arguments)\n        else:\n            self.cmdloop()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nrunning a single command from pre - parsed arguments.", "response": "def runcmd(self, cmd, args):\n        '''Run a single command from pre-parsed arguments.\n\n        This is intended to be run from :meth:`main` or somewhere else\n        \"at the top level\" of the program.  It may raise\n        :exc:`exceptions.SystemExit` if an argument such as ``--help``\n        that normally causes execution to stop is encountered.\n\n        '''\n        dof = getattr(self, 'do_' + cmd, None)\n        if dof is None:\n            return self.default(' '.join([cmd] + args))\n        argf = getattr(self, 'args_' + cmd, None)\n        if argf is not None:\n            parser = argparse.ArgumentParser(\n                prog=cmd,\n                description=getattr(dof, '__doc__', None))\n            argf(parser)\n            argl = parser.parse_args(args)\n        else:\n            argl = ' '.join(args)\n        return dof(argl)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef do_help(self, args):\n        '''print help on a command'''\n        if args.command:\n            f = getattr(self, 'help_' + args.command, None)\n            if f:\n                f()\n                return\n\n            f = getattr(self, 'do_' + args.command, None)\n            if not f:\n                msg = self.nohelp % (args.command,)\n                self.stdout.write('{0}\\n'.format(msg))\n                return\n\n            docstr = getattr(f, '__doc__', None)\n            f = getattr(self, 'args_' + args.command, None)\n            if f:\n                parser = argparse.ArgumentParser(\n                    prog=args.command,\n                    description=docstr)\n                f(parser)\n                parser.print_help(file=self.stdout)\n            else:\n                if not docstr:\n                    docstr = self.nohelp % (args.command,)\n                self.stdout.write('{0}\\n'.format(docstr))\n        else:\n            Cmd.do_help(self, '')", "response": "print help on a command"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef load_kb_mappings_file(kbname, kbfile, separator):\n    num_added = 0\n    with open(kbfile) as kb_fd:\n        for line in kb_fd:\n            if not line.strip():\n                continue\n            try:\n                key, value = line.split(separator)\n            except ValueError:\n                # bad split, pass\n                current_app.logger.error(\"Error splitting: {0}\".format(line))\n                continue\n            add_kb_mapping(kbname, key, value)\n            num_added += 1\n    return num_added", "response": "Add values from file to given KB returning rows added."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef by_id(cls, semantictag_id, autoflush=True):\n\t\t'''Return the semantic tag with the given id, or None.\n\n\t\t:param semantictag_id: the id of the semantic tag to return\n\t\t:type semantictag_id: string\n\n\t\t:returns: the semantic tag with the given id, or None if there is no tag with\n\t\t\tthat id\n\t\t:rtype: ckan.model.semantictag.SemanticTag # TODO check this\n\n\t\t'''\n\t\tquery = meta.Session.query(SemanticTag).filter(SemanticTag.id==semantictag_id)\n\t\tquery = query.autoflush(autoflush)\n\t\tsemantictag = query.first()\n\t\treturn semantictag", "response": "Return the semantic tag with the given id or None."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the semantic tag object with the given URI or None.", "response": "def by_URI(cls, URI, label=None, autoflush=True):\n\t\t'''Return the semantic ag with the given URI, or None.\n\n\t\t:param URI: the URI of the semantic tag to return\n\t\t:type URI: string (URI format)\n\t\t:param label: URI's label (optional, default: None)\n\t\t:type label: string\n\n\t\t:returns: the semantic tag object with the given id or URI, or None if there is\n\t\t\tno tag with that id or name\n\t\t:rtype: ckan.model.semantictag.SemanticTag #TODO check this\n\n\t\t'''\n\t\tif label:\n\t\t\tquery = meta.Session.query(SemanticTag).filter(SemanticTag.label==label)\n\t\telse:\n\t\t\tquery = meta.Session.query(SemanticTag).filter(SemanticTag.URI==URI)\n\t\tquery = query.autoflush(autoflush)\n\t\tsemantictag = query.first()\n\t\treturn semantictag"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get(cls, tag_id_or_URI, label=None):\n\t\t'''Return the tag with the given id or URI, or None.\n\n\t\t:param tag_id_or_name: the id or name of the tag to return\n\t\t:type tag_id_or_name: string\n\n\t\t:returns: the tag object with the given id or name, or None if there is\n\t\t\tno tag with that id or name\n\t\t:rtype: ckan.model.tag.Tag\n\n\t\t'''\n\t\t# First try to get the tag by ID.\n\t\tsemantictag = SemanticTag.by_id(tag_id_or_URI)\n\t\tif semantictag:\n\t\t\treturn semantictag\n\n\t\telse:\n\t\t\tsemantictag = SemanticTag.by_URI(tag_id_or_URI)\n\t\t\treturn semantictag", "response": "Get the tag object with the given id or URI or None."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef search_by_URI(cls, search_term):\n\t\t'''Return all tags whose URI or label contain a given string.\n\n\t\t:param search_term: the string to search for in the URI or label names\n\t\t:type search_term: string\n\n\t\t:returns: a list of semantictags that match the search term\n\t\t:rtype: list of ckan.model.semantictag.SemanticTag objects\n\n\t\t'''\n\t#TODO include label search\n\t\tquery = meta.Session.query(SemanticTag)\n\t\tsearch_term = search_term.strip().lower()\n\t\tquery = query.filter(SemanticTag.URI.contains(search_term))\n\t\tquery = query.distinct().join(SemanticTag.tag_semantictags)\n\t\treturn query", "response": "Search by URI or label"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef all(cls):\n\t\t'''Return all tags that are currently applied to any dataset.\n\n\t\t:returns: a list of all tags that are currently applied to any dataset\n\t\t:rtype: list of ckan.model.tag.Tag objects\n\n\t\t'''\n#\t\tif vocab_id_or_name:\n#\t\t\tvocab = vocabulary.Vocabulary.get(vocab_id_or_name)\n#\t\t\tif vocab is None:\n#\t\t\t\t# The user specified an invalid vocab.\n#\t\t\t\traise ckan.logic.NotFound(\"could not find vocabulary '%s'\"\n#\t\t\t\t\t\t% vocab_id_or_name)\n#\t\t   query = meta.Session.query(Tag).filter(Tag.vocabulary_id==vocab.id)\n#\t\telse:\n\t\tquery = meta.Session.query(SemanticTag)\n\t\tquery = query.distinct().join(TagSemanticTag)\n#\t\tquery = query.filter_by(state='active')\n\t\treturn query", "response": "Return all tags that are currently applied to any dataset."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef tags(self):\n\t\t'''Return a list of all tags that have this semantic tag, sorted by name.\n\n\t\t:rtype: list of ckan.model.tag.Tag objects\n\n\t\t'''\n\t\tq = meta.Session.query(_tag.Tag)\n\t\tq = q.join(TagSemanticTag)\n\t\tq = q.filter_by(tag_id=self.id)\n#\t\tq = q.filter_by(state='active')\n\t\tq = q.order_by(_tag.Tag.name)\n\t\ttags = q.all()\n\t\treturn tags", "response": "Return a list of all tags that have this semantic tag sorted by name."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef by_id(cls, predicate_id, autoflush=True):\n\t\t'''Return the predicate with the given id, or None.\n\n\t\t:param predicate_id: the id of the predicate to return\n\t\t:type predicate_id: string\n\n\t\t:returns: the predicate with the given id, or None if there is no predicate with\n\t\t\tthat id\n\t\t:rtype: ckan.model.semantictag.Predicate\n\n\t\t'''\n\t\tquery = meta.Session.query(Predicate).filter(Predicate.id==predicate_id)\n\t\tquery = query.autoflush(autoflush)\n\t\treturn query.first()", "response": "Return the predicate with the given id or None."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns all unique namespaces", "response": "def list_unique(cls):\n\t\t'''Return all unique namespaces\n\n\t\t:returns: a list of all predicates \n\t\t:rtype: list of ckan.model.semantictag.Predicate objects\n\n\t\t'''\n\t\tquery = meta.Session.query(Predicate).distinct(Predicate.namespace)\n\t\treturn query.all()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef by_name(self, tag_name, semantictag_URI,\n\t\t\tautoflush=True):\n\t\t'''Return the TagSemanticTag for the given tag name and semantic tag URI, or None.\n\n\t\t:param tag_name: the name of the tag to look for\n\t\t:type tag_name: string\n\t\t:param tag_URI: the name of the tag to look for\n\t\t:type tag_URI: string\n\n\t\t:returns: the TagSemanticTag for the given tag name and semantic tag URI, or None\n\t\t\tif there is no TagSemanticTag for those semantic tag and tag names\n\t\t:rtype: ckan.model.tag_semanictag.TagSemanticTag\n\n\t\t'''\n\t\t\n\t\tquery = (meta.Session.query(TagSemanticTag)\n\t\t\t\t\t.filter(_tag.Tag.name==tag_name)\n\t\t\t\t\t.filter(SemanticTag.URI==semantictag_URI))\n\t\tquery = query.autoflush(autoflush)\n\t\treturn query.one()[0]", "response": "Return the TagSemanticTag with the given name and semantic tag URI."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef by_tag_id(self,tag_id):\n\t\t'''Return all the semantic tag related to the given tag id\n\n\t\t:returns: a semantic tag or None\n\t\t:rtype: list of ckan.model.semantictag.SemanticTag object\n\n\t\t'''\n\t\tquery = meta.Session.query(TagSemanticTag).filter(TagSemanticTag.tag_id==tag_id)\n\t\treturn query.first()", "response": "Return all the semantic tags related to the given tag id"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns all the semantic tags related to the given tag", "response": "def get(self,id):\n\t\t'''Return all the semantic tag related to the given tag id\n\n\t\t:returns: a semantic tag or None\n\t\t:rtype: list of ckan.model.semantictag.SemanticTag object\n\n\t\t'''\n\t\tquery = meta.Session.query(TagSemanticTag).filter(TagSemanticTag.id==id)\n\t\treturn query.first()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef temp_directory(*args, **kwargs):\n\n    path = tempfile.mkdtemp(*args, **kwargs)\n    try:\n        yield path\n    finally:\n        shutil.rmtree(path)", "response": "Context manager that creates a temporary directory and cleans it up afterwards."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ngenerate random floats by using integers as fractional part.", "response": "def random(self, n: Optional[int] = None) -> Union[List[float], float]:\n        \"\"\" Generate random float(s) by using integers as fractional part.\n\n        random.org's API doesn't offer floats, but a sequence of integers can emulate this:\n\n        [06357, 114, 0210] => 0.06357_00114_00210\n        \"\"\"\n        randoms = []\n        n_or_default = 1 if n is None else n\n\n        for _ in range(n_or_default):\n            number_of_digits = _RandintsToFloatOptions.RANDINTS_NUMBER_OF_DIGITS.value\n            max_int = int('9' * number_of_digits)\n\n            randints = self.randint(0, max_int, _RandintsToFloatOptions.RANDINTS_QUANTITY.value)\n            zero_padded_ints = (str(randint).zfill(number_of_digits) for randint in randints)\n            random = float(f\"0.{''.join(zero_padded_ints)}\")\n            randoms.append(random)\n\n        return randoms if n else randoms[0]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef parse(self):\n        (options, args) = self.parser.parse_args()\n        self._set_attributes(args, options)\n        return self._create_dictionary()", "response": "Parse command line arguments and options.\n           Dictionary Returns a dictionary containing all given command line arguments and options."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef md5file(abspath, nbytes=0):\n    m = hashlib.md5()\n    with open(abspath, \"rb\") as f:\n        if nbytes:\n            data = f.read(nbytes)\n            if data:\n                m.update(data)\n        else:\n            while True:\n                data = f.read(1 << 20)\n                if not data:\n                    break\n                m.update(data)\n    return m.hexdigest()", "response": "Return md5 hash value of a piece of a file."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting initialization mode. Default is slow mode.", "response": "def set_initialize_mode(complexity=2):\n        \"\"\"Set initialization mode. Default is slow mode.\n        \n        **\u4e2d\u6587\u6587\u6863**\n        \n        \u8bbe\u7f6eWinFile\u7c7b\u7684\u5168\u5c40\u53d8\u91cf, \u6307\u5b9aWinFile.initialize\u65b9\u6cd5\u6240\u7ed1\u5b9a\u7684\u521d\u59cb\u5316\u65b9\u5f0f\u3002\n        \"\"\"\n        if complexity == 3:\n            WinFile.initialize = WinFile.level3_initialize\n            WinFile.init_mode = 3\n        elif complexity == 2:\n            WinFile.initialize = WinFile.level2_initialize\n            WinFile.init_mode = 2\n        elif complexity == 1:\n            WinFile.initialize = WinFile.level1_initialize\n            WinFile.init_mode = 1\n        else:\n            raise ValueError(\"complexity has to be 3, 2 or 1.\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef level3_initialize(self):\n        self.dirname, self.basename = os.path.split(self.abspath) # \u76ee\u5f55\u540d, \u6587\u4ef6\u540d\n        self.fname, self.ext = os.path.splitext(self.basename) # \u7eaf\u6587\u4ef6\u540d, \u6587\u4ef6\u6269\u5c55\u540d\n        self.ext = self.ext.lower()\n        \n        self.size_on_disk = os.path.getsize(self.abspath)\n        self.atime = os.path.getatime(self.abspath) # \u63a5\u89e6\u65f6\u95f4\n        self.ctime = os.path.getctime(self.abspath) # \u521b\u5efa\u65f6\u95f4, \u5f53\u6587\u4ef6\u88ab\u4fee\u6539\u540e\u4e0d\u53d8\n        self.mtime = os.path.getmtime(self.abspath) # \u4fee\u6539\u65f6\u95f4\n        self.md5 = md5file(self.abspath, nbytes=1 << 20)", "response": "Load the contents of the file into the internal state."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nloading the contents of the file into the object.", "response": "def level2_initialize(self):\n        \"\"\"Load abspath, dirname, basename, fname, ext, atime, ctime, mtime,\n        size_on_disk attributes in initialization.\n        \n        **\u4e2d\u6587\u6587\u6863**\n        \n        \u6bd4\u8f83\u5168\u9762\u4f46\u7a0d\u6162\u7684WinFile\u5bf9\u8c61\u521d\u59cb\u5316\u65b9\u6cd5, \u4ece\u7edd\u5bf9\u8def\u5f84\u4e2d\u53d6\u5f97:\n        \n        - \u7edd\u5bf9\u8def\u5f84\n        - \u7236\u76ee\u5f55\u8def\u5f84\n        - \u6587\u4ef6\u5168\u540d\n        - \u7eaf\u6587\u4ef6\u540d\n        - \u6587\u4ef6\u6269\u5c55\u540d\n        - access time\n        - create time\n        - modify time\n        - \u6587\u4ef6\u5360\u636e\u78c1\u76d8\u5927\u5c0f\n        \"\"\"\n        self.dirname, self.basename = os.path.split(self.abspath) # \u76ee\u5f55\u540d, \u6587\u4ef6\u540d\n        self.fname, self.ext = os.path.splitext(self.basename) # \u7eaf\u6587\u4ef6\u540d, \u6587\u4ef6\u6269\u5c55\u540d\n        self.ext = self.ext.lower()\n        \n        self.size_on_disk = os.path.getsize(self.abspath)\n        self.atime = os.path.getatime(self.abspath) # \u63a5\u89e6\u65f6\u95f4\n        self.ctime = os.path.getctime(self.abspath) # \u521b\u5efa\u65f6\u95f4, \u5f53\u6587\u4ef6\u88ab\u4fee\u6539\u540e\u4e0d\u53d8\n        self.mtime = os.path.getmtime(self.abspath)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nloading the file name dirname basename fname ext attributes in initialization.", "response": "def level1_initialize(self):\n        \"\"\"Load abspath, dirname, basename, fname, ext \n        attributes in initialization.\n        \n        **\u4e2d\u6587\u6587\u6863**\n        \n        \u5feb\u901f\u7684WinFile\u5bf9\u8c61\u521d\u59cb\u5316\u65b9\u6cd5, \u53ea\u4ece\u7edd\u5bf9\u8def\u5f84\u4e2d\u53d6\u5f97:\n\n        - \u7edd\u5bf9\u8def\u5f84\n        - \u76ee\u5f55\u8def\u5f84\n        - \u6587\u4ef6\u5168\u540d\n        - \u7eaf\u6587\u4ef6\u540d\n        - \u6587\u4ef6\u6269\u5c55\u540d\n        \"\"\"\n        self.dirname, self.basename = os.path.split(self.abspath)\n        self.fname, self.ext = os.path.splitext(self.basename)\n        self.ext = self.ext.lower()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nrenaming the dirname fname extension or their combinations.", "response": "def rename(self, new_dirname=None, new_fname=None, new_ext=None):\n        \"\"\"Rename the dirname, fname, extension or their combinations.\n        \n        **\u4e2d\u6587\u6587\u6863**\n        \n        \u5bf9\u6587\u4ef6\u7684\u7236\u76ee\u5f55\u540d, \u7eaf\u6587\u4ef6\u540d, \u6269\u5c55\u540d, \u6216\u5b83\u4eec\u7684\u7ec4\u5408\u8fdb\u884c\u4fee\u6539\u3002\n        \"\"\"\n        if not new_dirname:\n            new_dirname = self.dirname\n        else:\n            new_dirname = os.path.abspath(new_dirname)\n        if not new_fname:\n            new_fname = self.fname\n        if new_ext: # \u68c0\u67e5\u65b0\u6587\u4ef6\u540d\u7684\u6269\u5c55\u540d\u683c\u5f0f\u662f\u5426\n            if not new_ext.startswith(\".\"):\n                raise ValueError(\"File extension must in format .ext, \"\n                                 \"for example: .jpg, .mp3\")\n        else:\n            new_ext = self.ext\n        new_basename = new_fname + new_ext\n        new_abspath = os.path.join(new_dirname, new_basename)\n\n        os.rename(self.abspath, new_abspath)\n        # \u5982\u679c\u6210\u529f\u91cd\u547d\u540d, \u5219\u66f4\u65b0\u6587\u4ef6\u4fe1\u606f\n        self.abspath = new_abspath\n        self.dirname = new_dirname\n        self.basename = new_basename\n        self.fname = new_fname\n        self.ext = new_ext"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_detail(self):\n        self.size_total = 0\n        self.num_folder_total = 0\n        self.num_file_total = 0\n        \n        self.size_current = 0\n        self.num_folder_current = 0\n        self.num_file_current = 0\n        \n        for current_dir, folderlist, fnamelist in os.walk(self.abspath):\n            self.num_folder_total += len(folderlist)\n            self.num_file_total += len(fnamelist)\n            for fname in fnamelist:\n                self.size_total += os.path.getsize(os.path.join(current_dir, fname))\n                \n        current_dir, folderlist, fnamelist = next(os.walk(self.abspath))\n        self.num_folder_current = len(folderlist)\n        self.num_file_current = len(fnamelist)\n        for fname in fnamelist:\n            self.size_current += os.path.getsize(os.path.join(current_dir, fname))", "response": "Get general stats information."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef prt_detail(self):\n        screen = [\n            \"Detail info of %s: \" % self.abspath,\n            \"total size = %s\" % string_SizeInBytes(self.size_total),\n            \"number of sub folders = %s\" % self.num_folder_total,\n            \"number of total files = %s\" % self.num_file_total,\n            \"lvl 1 file size = %s\" % string_SizeInBytes(self.size_current),\n            \"lvl 1 folder number = %s\" % self.num_folder_current,\n            \"lvl 1 file number = %s\" % self.num_file_current,\n        ]\n        print(\"\\n\".join(screen))", "response": "Nicely print stats information."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef rename(self, new_dirname=None, new_basename=None):\n        if not new_basename:\n            new_basename = self.new_basename\n        if not new_dirname:\n            new_dirname = self.dirname\n        else:\n            new_dirname = os.path.abspath(new_dirname)\n        new_abspath = os.path.join(new_dirname, new_basename)\n        os.rename(self.abspath, new_abspath)\n        \n        # \u5982\u679c\u6210\u529f\u91cd\u547d\u540d, \u5219\u66f4\u65b0\u6587\u4ef6\u4fe1\u606f\n        self.abspath = new_abspath\n        self.dirname = new_dirname\n        self.basename = new_basename", "response": "Rename the dirname or the basename or their combinations."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add(self, abspath_or_winfile, enable_verbose=True):\n        if isinstance(abspath_or_winfile, str): # abspath\n            if abspath_or_winfile in self.files:\n                if enable_verbose:\n                    print(\"'%s' already in this collections\" % \n                          abspath_or_winfile)\n            else:\n                self.files.setdefault(abspath_or_winfile, WinFile(abspath_or_winfile))\n        elif isinstance(abspath_or_winfile, WinFile): # WinFile\n            if abspath_or_winfile.abspath in self.files:\n                if enable_verbose:\n                    print(\"'%s' already in this collections\" % \n                          abspath_or_winfile)\n            else:\n                self.files.setdefault(abspath_or_winfile.abspath, abspath_or_winfile)\n        else:\n            raise TypeError", "response": "Add absolute path or WinFile to FileCollection."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef remove(self, abspath_or_winfile, enable_verbose=True):\n        if isinstance(abspath_or_winfile, str): # abspath\n            try:\n                del self.files[abspath_or_winfile]\n            except KeyError:\n                if enable_verbose:\n                    print(\"'%s' are not in this file collections\" % \n                          abspath_or_winfile)\n        elif isinstance(abspath_or_winfile, WinFile): # WinFile\n            try:\n                del self.files[abspath_or_winfile.abspath]\n            except KeyError:\n                if enable_verbose:\n                    print(\"'%s' are not in this file collections\" % \n                          abspath_or_winfile)\n        else:\n            raise TypeError", "response": "Remove absolute path or WinFile from FileCollection."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nyield all WinFile objects in order.", "response": "def iterfiles(self):\n        \"\"\"Yield all WinFile object.\n        \"\"\"\n        try:\n            for path in self.order:\n                yield self.files[path]\n        except:\n            for winfile in self.files.values():\n                yield winfile"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nyielding all WinFile s absolute path.", "response": "def iterpaths(self):\n        \"\"\"Yield all WinFile's absolute path.\n        \"\"\"\n        try:\n            for path in self.order:\n                yield path\n        except:\n            for path in self.files:\n                yield path"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef yield_all_file_path(dir_abspath):\n        if os.path.isdir(dir_abspath):\n            dir_abspath = os.path.abspath(dir_abspath)\n            for current_folder, _, fnamelist in os.walk(dir_abspath):\n                for fname in fnamelist:\n                    yield os.path.join(current_folder, fname)\n        else:\n            raise FileNotFoundError(\n                \"'%s' may not exists or is not a directory!\" % dir_abspath)", "response": "yields all file paths in a directory"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nyielding all the directory path", "response": "def yield_all_dir_path(dir_abspath):\n        \"\"\"\n        \n        **\u4e2d\u6587\u6587\u6863**\n        \n        \u904d\u5386dir_abspath\u76ee\u5f55\u4e0b\u7684\u6240\u6709\u5b50\u76ee\u5f55, \u8fd4\u56de\u7edd\u5bf9\u8def\u5f84\u3002\n        \"\"\"\n        if os.path.isdir(dir_abspath):\n            for current_folder, folderlist, _ in os.walk(dir_abspath):\n                for folder in folderlist:\n                    yield os.path.join(current_folder, folder)\n        else:\n            raise Exception(\n                \"'%s' may not exists or is not a directory!\" % dir_abspath)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef remove_children(list_of_abspath):\n        sorted_list_of_abspath = list(list_of_abspath)\n        sorted_list_of_abspath.sort()\n        sorted_list_of_abspath.append(\"\")  \n        res = list()\n        temp = sorted_list_of_abspath[0]\n        for abspath in sorted_list_of_abspath:\n            if temp not in abspath:\n                res.append(temp)\n                temp = abspath         \n        return res", "response": "Remove all dir paths that being children path of other dir path."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates a new FileCollection and add all files from a directory path.", "response": "def from_path(list_of_dir):\n        \"\"\"Create a new FileCollection and add all files from ``dir_path``.\n        \n        :param list_of_dir: absolute dir path, WinDir instance, list of \n          absolute dir path or list of WinDir instance.\n          \n        **\u4e2d\u6587\u6587\u6863**\n        \n        \u6dfb\u52a0dir_path\u76ee\u5f55\u4e0b\u7684\u6240\u6709\u6587\u4ef6\u5230\u4e00\u4e2a\u65b0\u7684FileCollection\u4e2d.\n        \"\"\"\n        if isinstance(list_of_dir, str):\n            list_of_dir = [list_of_dir, ]\n        elif isinstance(list_of_dir, WinDir):\n            list_of_dir = [list_of_dir.abspath, ]\n        elif isinstance(list_of_dir, list):\n            list_of_dir = [str(i) for i in list_of_dir]\n            \n        fc = FileCollection()\n        for dir_path in list_of_dir:\n            for winfile in FileCollection.yield_all_winfile(dir_path):\n                fc.files.setdefault(winfile.abspath, winfile)\n        return fc"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef from_path_by_criterion(dir_path, criterion, keepboth=False):\n        if keepboth:\n            fc_yes, fc_no = FileCollection(), FileCollection()\n            for winfile in FileCollection.yield_all_winfile(dir_path):\n                if criterion(winfile):\n                    fc_yes.files.setdefault(winfile.abspath, winfile)\n                else:\n                    fc_no.files.setdefault(winfile.abspath, winfile)\n            return fc_yes, fc_no\n        else:\n            fc = FileCollection()\n            for winfile in FileCollection.yield_all_winfile(dir_path):\n                if criterion(winfile):\n                    fc.files.setdefault(winfile.abspath, winfile)\n            return fc", "response": "Create a FileCollection from a directory path and a custom filter function."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating a FileCollection from all files except a directory.", "response": "def from_path_except(dir_path, \n            ignore=list(), ignore_ext=list(), ignore_pattern=list()):\n        \"\"\"Create a new FileCollection, and select all files except file\n        matching ignore-rule::\n            \n            dir_path = \"your/path\"\n            fc = FileCollection.from_path_except(\n                dir_path, ignore=[\"test\"], ignore_ext=[\".log\", \".tmp\"]\n                ignore_pattern=[\"some_pattern\"])\n        \n        :param dir_path: the root directory you want to start with\n        :param ignore: file or directory defined in this list will be ignored.\n        :param ignore_ext: file with extensions defined in this list will be ignored.\n        :param ignore_pattern: any file or directory that contains this pattern\n          will be ignored.\n          \n        **\u4e2d\u6587\u6587\u6863**\n        \n        \u9009\u62e9dir_path\u4e0b\u7684\u6240\u6709\u6587\u4ef6, \u5728ignore, ignore_ext, ignore_pattern\u4e2d\u6240\u5b9a\u4e49\n        \u7684\u6587\u4ef6\u5c06\u88ab\u6392\u9664\u5728\u5916\u3002\n        \"\"\"\n        ignore = [i.lower() for i in ignore]\n        ignore_ext = [i.lower() for i in ignore_ext]\n        ignore_pattern = [i.lower() for i in ignore_pattern]\n        def filter(winfile):\n            relpath = os.path.relpath(winfile.abspath, dir_path).lower()\n            \n            # exclude ignore\n            for path in ignore:\n                if relpath.startswith(path):\n                    return False\n                \n            # exclude ignore extension\n            if winfile.ext in ignore_ext:\n                return False\n\n            # exclude ignore pattern\n            for pattern in ignore_pattern:\n                if pattern in relpath:\n                    return False\n            \n            return True\n        \n        return FileCollection.from_path_by_criterion(\n            dir_path, filter, keepboth=False)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating a new FileCollection and select all files except file that match the pattern.", "response": "def from_path_by_pattern(dir_path, pattern=list()):\n        \"\"\"Create a new FileCollection, and select all files except file\n        matching ignore-rule::\n            \n            dir_path = \"your/path\"\n            fc = FileCollection.from_path_by_pattern(\n                dir_path, pattern=[\"log\"])\n        \n        :param dir_path: the root directory you want to start with\n        :param pattern: any file or directory that contains this pattern\n          will be selected.\n          \n        **\u4e2d\u6587\u6587\u6863**\n        \n        \u9009\u62e9dir_path\u4e0b\u7684\u6240\u6709\u6587\u4ef6\u7684\u76f8\u5bf9\u8def\u5f84\u4e2d\u5305\u542b\u6709pattern\u7684\u6587\u4ef6\u3002\n        \"\"\"\n        pattern = [i.lower() for i in pattern]\n        def filter(winfile):\n            relpath = os.path.relpath(winfile.abspath, dir_path).lower()\n            for p in pattern:\n                if p in relpath:\n                    return True\n            return False\n        \n        return FileCollection.from_path_by_criterion(\n            dir_path, filter, keepboth=False)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef from_path_by_size(dir_path, min_size=0, max_size=1 << 40):\n        def filter(winfile):\n            if (winfile.size_on_disk >= min_size) and \\\n                (winfile.size_on_disk <= max_size):\n                return True\n            else:\n                return False\n\n        return FileCollection.from_path_by_criterion(\n            dir_path, filter, keepboth=False)", "response": "Create a FileCollection from a directory path and select all files that size in the file collection is smaller than min_size and less than max_size."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate a FileCollection from a directory path and a list of file extensions.", "response": "def from_path_by_ext(dir_path, ext):\n        \"\"\"Create a new FileCollection, and select all files that extension \n        matching ``ext``::\n        \n            dir_path = \"your/path\"\n            \n            fc = FileCollection.from_path_by_ext(dir_path, ext=[\".jpg\", \".png\"])\n        \"\"\"\n        if isinstance(ext, (list, set, dict)): # collection of extension\n            def filter(winfile):\n                if winfile.ext in ext:\n                    return True\n                else:\n                    return False\n        else: # str\n            def filter(winfile):\n                if winfile.ext == ext:\n                    return True\n                else:\n                    return False\n\n        return FileCollection.from_path_by_criterion(\n            dir_path, filter, keepboth=False)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates a FileCollection object from a list of file paths and a md5 value.", "response": "def from_path_by_md5(md5_value, list_of_dir):\n        \"\"\"Create a new FileCollection, and select all files' that md5 is \n        matching.\n        \n        **\u4e2d\u6587\u6587\u6863**\n        \n        \u7ed9\u5b9a\u4e00\u4e2a\u6587\u4ef6\u4f7f\u7528WinFile\u6a21\u5757\u83b7\u5f97\u7684md5\u503c, \u5728list_of_dir\u4e2d\u7684\u6587\u4ef6\u91cc, \n        \u627e\u5230\u4e0e\u4e4b\u76f8\u540c\u7684\u6587\u4ef6\u3002\n        \"\"\"       \n        def filter(winfile):\n            if winfile.md5 == md5_value:\n                return True\n            else:\n                return False\n        \n        if not isinstance(list_of_dir, (list, set)):\n            list_of_dir = [list_of_dir, ]        \n            \n        init_mode = WinFile.init_mode\n        WinFile.use_slow_init()\n        \n        fc = FileCollection()\n        for dir_path in list_of_dir:\n            for winfile in FileCollection.from_path_by_criterion(\n                    dir_path, filter, keepboth=False).iterfiles():\n                fc.files.setdefault(winfile.abspath, winfile)\n        \n        if init_mode == 1:\n            WinFile.use_fast_init()\n        elif init_mode == 2:\n            WinFile.use_regular_init()\n        elif init_mode == 3:\n            WinFile.use_slow_init()\n                \n        return fc"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nsort files by one of it s attributes.", "response": "def sort_by(self, attr_name, reverse=False):\n        \"\"\"Sort files by one of it's attributes.\n        \n        **\u4e2d\u6587\u6587\u6863**\n        \n        \u5bf9\u5bb9\u5668\u5185\u7684WinFile\u6839\u636e\u5176\u67d0\u4e00\u4e2a\u5c5e\u6027\u5347\u5e8f\u6216\u8005\u964d\u5e8f\u6392\u5e8f\u3002\n        \"\"\"\n        try:\n            d = dict()\n            for abspath, winfile in self.files.items():\n                d[abspath] = getattr(winfile, attr_name)\n            self.order = [item[0] for item in sorted(\n                list(d.items()), key=lambda t: t[1], reverse = reverse)]\n        except AttributeError:\n            raise ValueError(\"valid sortable attributes are: \"\n                             \"abspath, dirname, basename, fname, ext, \"\n                             \"size_on_disk, atime, ctime, mtime;\")"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate a new FileCollection containing all files with criterion = True.", "response": "def select(self, criterion, keepboth=False):\n        \"\"\"Filter current file collections, create another file collections \n        contains all winfile with criterion=True.\n        \n        How to construct your own criterion function, see \n        :meth:`FileCollection.from_path_by_criterion`.\n\n        :param criterion: customize filter function\n        :type criterion: function\n        :param keepboth: if True, returns two file collections, one is files\n            with criterion=True, another is False.\n        :type keepboth: boolean\n        \n        **\u4e2d\u6587\u6587\u6863**\n        \n        \u5728\u5f53\u524d\u7684\u6587\u4ef6\u96c6\u5408\u4e2d, \u6839\u636ecriterion\u4e2d\u7684\u89c4\u5219, \u9009\u62e9\u9700\u8981\u7684\u751f\u6210\n        FileCollection\u3002\u5f53keepboth\u53c2\u6570=True\u65f6, \u8fd4\u56de\u4e24\u4e2aFileCollection, \u4e00\u4e2a\n        \u662f\u7b26\u5408\u6761\u4ef6\u7684\u6587\u4ef6\u96c6\u5408, \u4e00\u4e2a\u662f\u4e0d\u7b26\u5408\u6761\u4ef6\u7684\u3002\n        \"\"\"\n        if keepboth:\n            fcs_yes, fcs_no = FileCollection(), FileCollection()\n            for winfile in self.files.values():\n                if criterion(winfile):\n                    fcs_yes.files[winfile.abspath] = winfile\n                else:\n                    fcs_no.files[winfile.abspath] = winfile\n            return fcs_yes, fcs_no\n        else:\n            fcs = FileCollection()\n            for winfile in self.files.values():\n                if criterion(winfile):\n                    fcs.files[winfile.abspath] = winfile\n            \n            return fcs"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nprints all file path that file size greater than threshold and equal than .", "response": "def show_big_file(dir_path, threshold):\n        \"\"\"Print all file path that file size greater and equal than \n        ``#threshold``.\n        \"\"\"\n        fc = FileCollection.from_path_by_size(dir_path, min_size=threshold)\n        fc.sort_by(\"size_on_disk\")\n        \n        lines = list()\n        lines.append(\"Results:\")\n        for winfile in fc.iterfiles():\n            lines.append(\"  %s - %s\" % \n                         (string_SizeInBytes(winfile.size_on_disk), winfile))\n        lines.append(\"Above are files' size greater than %s.\" % \n              string_SizeInBytes(threshold))\n        text = \"\\n\".join(lines)\n        print(text)\n        with open(\"__show_big_file__.log\", \"wb\") as f:\n            f.write(text.encode(\"utf-8\"))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nprint all files that file name contains pattern.", "response": "def show_patterned_file(dir_path, pattern=list(), filename_only=True):\n        \"\"\"Print all file that file name contains ``pattern``.\n        \"\"\"\n        pattern = [i.lower() for i in pattern]\n        if filename_only:\n            def filter(winfile):\n                for p in pattern:\n                    if p in winfile.fname.lower():\n                        return True\n                return False\n        else:\n            def filter(winfile):\n                for p in pattern:\n                    if p in winfile.abspath.lower():\n                        return True\n                return False\n        \n        fc = FileCollection.from_path_by_criterion(\n            dir_path, filter, keepboth=False)\n        if filename_only:\n            fc.sort_by(\"fname\")\n        else:\n            fc.sort_by(\"abspath\")\n            \n        table = {p: \"<%s>\" % p for p in pattern}\n        lines = list()\n        lines.append(\"Results:\")\n        for winfile in fc.iterfiles():\n            lines.append(\"  %s\" % winfile)\n            \n        if filename_only:\n            lines.append(\"Above are all files that file name contains %s\" % pattern)\n        else:\n            lines.append(\"Above are all files that abspath contains %s\" % pattern)\n            \n        text = \"\\n\".join(lines)\n        print(text)\n        with open(\"__show_patterned_file__.log\", \"wb\") as f:\n            f.write(text.encode(\"utf-8\"))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef create_fake_mirror(src, dst):\n        src = os.path.abspath(src)\n        if not (os.path.exists(src) and (not os.path.exists(dst)) ):\n            raise Exception(\"source not exist or distination already exist\")\n        \n        folder_to_create = list()\n        file_to_create = list()\n        \n        for current_folder, _, file_list in os.walk(src):\n            new_folder = os.path.join(dst, os.path.relpath(current_folder, src))\n            folder_to_create.append(new_folder)\n            for basename in file_list:\n                file_to_create.append(os.path.join(new_folder, basename))\n                \n        for abspath in folder_to_create:\n            os.mkdir(abspath)\n        \n        for abspath in file_to_create:\n            with open(abspath, \"w\") as _:\n                pass", "response": "Copy all files from src to dst."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\nasync def _get(self, url: str) -> str:\n        async with self.session.get(url, headers=self.HEADERS) as r:\n            if r.status == 200:\n                return await r.text()\n            else:\n                raise RuneConnectionError(r.status)", "response": "A small wrapper method which makes a quick GET request to get the raw html of the requested page."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\nasync def update_champs(self):\n        html = await self._get(self.URL)\n        self.rune_links = utils.parse_rune_links(html)", "response": "A method which updates self. rune_links."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\nasync def get_raw(self, champion_name: str) -> Tuple[dict]:\n        champion_lower = champion_name.lower()\n        if champion_lower not in self.rune_links:\n            raise ChampNotFoundError(champion_name)\n\n        rune_list = []\n        for x in self.rune_links[champion_lower]:\n            html = await self._get(x)\n            rune_list.append(utils.parse_rune_html(html, x))\n\n        return tuple(rune_list)", "response": "A method to retrieve the optimal runes for a given champion."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef update(self):\n        vm = self._cs_api.list_virtualmachines(id=self.id)[0]\n        self.is_running = self._is_running(vm.state)", "response": "Update the state of the virtual machine"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_access_token(client_id, client_secret):\n\t'''\n\tName: token\n\tParameters: client_id, client_secret\n\tReturn: dictionary\n\t'''\n\n\theaders = {'Content-Type': 'application/x-www-form-urlencoded'}\n\tpayload = {\n\t\t'client_id': client_id,\n\t\t'client_secret': client_secret\n\t}\n\n\trequest = requests.post(token_url, data=payload, headers=headers)\n\tif request.status_code == 200:\n\t\ttoken = request.json()\n\t\treturn token\n\n\treturn {'status': request.status_code, \"message\": request.text}", "response": "Get access token from the API."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nunlocking the user s Keychain.", "response": "def unlock_keychain(username):\n    \"\"\" If the user is running via SSH, their Keychain must be unlocked first. \"\"\"\n\n    if 'SSH_TTY' not in os.environ:\n        return\n\n    # Don't unlock if we've already seen this user.\n    if username in _unlocked:\n        return\n\n    _unlocked.add(username)\n\n    if sys.platform == 'darwin':\n        sys.stderr.write(\"You are running under SSH. Please unlock your local OS X KeyChain:\\n\")\n        subprocess.call(['security', 'unlock-keychain'], stdout=subprocess.PIPE, stderr=subprocess.PIPE)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsaving the given password in the user s keychain.", "response": "def save_password(entry, password, username=None):\n    \"\"\"\n      Saves the given password in the user's keychain.\n\n      :param entry: The entry in the keychain. This is a caller specific key.\n      :param password: The password to save in the keychain.\n      :param username: The username to get the password for. Default is the current user.\n    \"\"\"\n\n    if username is None:\n        username = get_username()\n\n    has_keychain = initialize_keychain()\n\n    if has_keychain:\n        try:\n            keyring.set_password(entry, username, password)\n        except Exception as e:\n            log.warn(\"Unable to set password in keyring. Continuing..\")\n            log.debug(e)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef remove_password(entry, username=None):\n\n    if username is None:\n        username = get_username()\n\n    has_keychain = initialize_keychain()\n\n    if has_keychain:\n        try:\n            keyring.delete_password(entry, username)\n        except Exception as e:\n            print e\n            log.warn(\"Unable to delete password in keyring. Continuing..\")\n            log.debug(e)", "response": "Removes the password for the specific user in the user s keychain."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_password(entry=None, username=None, prompt=None, always_ask=False):\n\n    password = None\n\n    if username is None:\n        username = get_username()\n\n    has_keychain = initialize_keychain()\n\n    # Unlock the user's keychain otherwise, if running under SSH, 'security(1)' will thrown an error.\n    unlock_keychain(username)\n\n    if prompt is None:\n        prompt = \"Enter %s's password: \" % username\n\n    if has_keychain and entry is not None and always_ask is False:\n        password = get_password_from_keyring(entry, username)\n\n    if password is None:\n        password = getpass.getpass(prompt=prompt)\n\n    return password", "response": "Prompt the user for a password on stdin."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the password for a user from a keychain.", "response": "def get_password_from_keyring(entry=None, username=None):\n    \"\"\"\n      :param entry: The entry in the keychain. This is a caller specific key.\n      :param username: The username to get the password for. Default is the current user.\n    \"\"\"\n\n    if username is None:\n        username = get_username()\n\n    has_keychain = initialize_keychain()\n\n    # Unlock the user's keychain otherwise, if running under SSH, 'security(1)' will thrown an error.\n    unlock_keychain(username)\n\n    if has_keychain and entry is not None:\n        try:\n            return keyring.get_password(entry, username)\n        except Exception as e:\n            log.warn(\"Unable to get password from keyring. Continuing..\")\n            log.debug(e)\n\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef validate_password(entry, username, check_function, password=None, retries=1, save_on_success=True, prompt=None, **check_args):\n\n    if password is None:\n        password = get_password(entry, username, prompt)\n\n    for _ in xrange(retries + 1):\n\n        if check_function(username, password, **check_args):\n            if save_on_success:\n                save_password(entry, password, username)\n\n            return True\n\n        log.error(\"Couldn't successfully authenticate your username & password..\")\n\n        password = get_password(entry, username, prompt, always_ask=True)\n\n    return False", "response": "Validate a user s password."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_stored_credentials():\n    with load_config(sections=AUTH_SECTIONS, defaults=AUTH_CONFIG_DEFAULTS) as config:\n        username = config.get(AUTH_SECTION, 'username')\n        if not username:\n            # if we don't have a username then we cannot lookup the password\n            return None, None\n\n    has_keychain = initialize_keychain()\n    # Unlock the user's keychain otherwise, if running under SSH, 'security(1)' will thrown an error.\n    unlock_keychain(username)\n\n    if has_keychain:\n        try:\n            password = keyring.get_password(AUTH_SECTION, username)\n            return username, password\n        except Exception as e:\n            log.warn(\"Unable to get password from keyring. Continuing..\")\n            log.debug(e)\n\n    return username, None", "response": "Gets the username and password that have been stored in\n        ~. shrew. config. ini and the secure keychain respectively without bothering\n       ."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef delete_password(service, username):\n        try:\n            # set up the call for security.\n            call = subprocess.Popen(['security',\n                                     'delete-generic-password',\n                                     '-a',\n                                     username,\n                                     '-s',\n                                     service],\n                                    stderr=subprocess.PIPE,\n                                    stdout=subprocess.PIPE)\n            _, _ = call.communicate()\n            code = call.returncode\n            # check return code.\n            if code is not 0:\n                raise PasswordSetError('Can\\'t delete password in keychain')\n        except:\n            raise PasswordSetError(\"Can't delete password in keychain\")", "response": "Delete the password for the username of the service."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ntake an exception object and return a generator with vtml formatted exception traceback lines.", "response": "def format_exception(exc, indent=0, pad='  '):\n    \"\"\" Take an exception object and return a generator with vtml formatted\n    exception traceback lines. \"\"\"\n    from_msg = None\n    if exc.__cause__ is not None:\n        indent += yield from format_exception(exc.__cause__, indent)\n        from_msg = traceback._cause_message.strip()\n    elif exc.__context__ is not None and not exc.__suppress_context__:\n        indent += yield from format_exception(exc.__context__, indent)\n        from_msg = traceback._context_message.strip()\n    padding = pad * indent\n    if from_msg:\n        yield '\\n%s%s\\n' % (padding, from_msg)\n    yield '%s<b><u>Traceback (most recent call last)</u></b>' % padding\n    tblist = traceback.extract_tb(exc.__traceback__)\n    tbdepth = len(tblist)\n    for x in tblist:\n        depth = '%d.' % tbdepth\n        yield '%s<dim>%-3s</dim> <cyan>File</cyan> \"<blue>%s</blue>\", ' \\\n            'line <u>%d</u>, in <b>%s</b>' % (padding, depth, x.filename,\n                                              x.lineno, x.name)\n        yield '%s      %s' % (padding, x.line)\n        tbdepth -= 1\n    yield '%s<b><red>%s</red>: %s</b>' % (padding, type(exc).__name__, exc)\n    return indent + 1"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nprinting the formatted output of an exception object.", "response": "def print_exception(*args, file=None, **kwargs):\n    \"\"\" Print the formatted output of an exception object. \"\"\"\n    for line in format_exception(*args, **kwargs):\n        vtml.vtmlprint(line, file=file)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a new configuration object.", "response": "def create(cls, config_file=None):\n        \"\"\" Return the default configuration.\n        \"\"\"\n        if cls.instance is None:\n            cls.instance = cls(config_file)\n\n            # Load config file, possibly overwriting the defaults\n            cls.instance.load_ini()\n\n        if config_file and config_file != cls.instance.config_file:\n            raise RuntimeError(\"Configuration initialized a second time with a different file!\")\n\n        return cls.instance"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nloads the given. INI file.", "response": "def load_ini(self):\n        \"\"\" Load the given .INI file.\n        \"\"\"\n        if not self.config_file:\n            return\n\n        # Load INI file\n        ini_file = ConfigParser.SafeConfigParser()\n        if not ini_file.read(self.config_file):\n            raise ConfigParser.ParsingError(\"Global configuration file %r not found!\" % (\n                self.config_file,\n            ))\n\n        \"\"\"\n        # Make sure there's our global settings section\n        if not ini_file.has_section(self.SECTION):\n            raise ConfigParser.ParsingError(\"%r needs to have a [%s] section!\" % (\n                self.config_file, self.SECTION,\n            ))\n\n        # Get the given values\n        for key, val in ini_file.items(self.SECTION):\n            # Ensure that all names are known (to prevent uncaught typos)\n            if key not in self.KEYS:\n                raise ConfigParser.ParsingError(\"%r has an unknown key %s in the [%s] section!\" % (\n                    self.config_file, key, self.SECTION,\n                ))\n\n            # Do some shell-like path expansion\n            val = os.path.expanduser(os.path.expandvars(val))\n\n            # Set as attribute for easy access\n            setattr(self, key, val)\n        \"\"\"\n\n        self._validate()"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreads the file and yield chucks of chunk_size bytes.", "response": "def chunks(self, chunk_size=None):\n        \"\"\"\n        Read the file and yield chucks of ``chunk_size`` bytes (defaults to\n        ``UploadedFile.DEFAULT_CHUNK_SIZE``).\n        \"\"\"\n        if not chunk_size:\n            chunk_size = self.DEFAULT_CHUNK_SIZE\n\n        try:\n            self.seek(0)\n        except (AttributeError, UnsupportedOperation):\n            pass\n\n        while True:\n            data = self.read(chunk_size)\n            if not data:\n                break\n            yield data"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef multiple_chunks(self, chunk_size=None):\n        if not chunk_size:\n            chunk_size = self.DEFAULT_CHUNK_SIZE\n        return self.size > chunk_size", "response": "Returns True if you can expect multiple chunks."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef content(self, value):\n        if isinstance(value, bytes):\n            self._content = value\n        else:\n            self._content = value.encode(ENCODING)\n        self.size = len(value)", "response": "Set content to byte string encoding if necessary\n            is a unicode object."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the MD5 hash of the file content", "response": "def md5hash(self):\n        \"\"\"Return the MD5 hash string of the file content\"\"\"\n        digest = hashlib.md5(self.content).digest()\n        return b64_string(digest)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef read(self, chunk_size=None):\n        if chunk_size:\n            data = self.content[self.pos:self.pos + chunk_size]\n            self.pos += len(data)\n            return data\n        else:\n            return self.content", "response": "Read a set of bytes from the internal buffer."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nnormalize a route path.", "response": "def norm_path(path, allow_trailing=True):\n    \"\"\"\n    Normalize a route path.  Ensures that the path begins with a '/'.\n    If `allow_trailing` is False, strips off any trailing '/'.  Any\n    repeated '/' characters in the path will be collapsed into a\n    single one.\n    \"\"\"\n\n    # Collapse slashes\n    path = _path_re.sub('/', path)\n\n    # Force a leading slash\n    if path[0] != '/':\n        path = '/' + path\n\n    # Trim a trailing slash\n    if not allow_trailing and path[-1] == '/':\n        path = path[:-1]\n\n    return path"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nimport a controller class from an egg. Uses the entry point group appathy. controller.", "response": "def import_egg(string):\n    \"\"\"\n    Import a controller class from an egg.  Uses the entry point group\n    \"appathy.controller\".\n    \"\"\"\n\n    # Split the string into a distribution and a name\n    dist, _sep, name = string.partition('#')\n\n    return pkg_resources.load_entry_point(dist, 'appathy.controller', name)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nimporting the requested controller.", "response": "def import_controller(string):\n    \"\"\"\n    Imports the requested controller.  Controllers are specified in a\n    URI-like manner; the scheme is looked up using the entry point\n    group \"appathy.loader\".  Appathy supports the \"call:\" and \"egg:\"\n    schemes by default.\n    \"\"\"\n\n    # Split out the scheme and the controller descriptor\n    scheme, sep, controller = string.partition(':')\n    if sep != ':':\n        raise ImportError(\"No loader scheme specified by %r\" % string)\n\n    # Look up a loader for that scheme\n    for ep in pkg_resources.iter_entry_points('appathy.loader', scheme):\n        try:\n            loader = ep.load()\n            break\n        except (ImportError, pkg_resources.UnknownExtra):\n            continue\n    else:\n        raise ImportError(\"Unable to find loader for scheme %r\" % scheme)\n\n    # Load the controller\n    return loader(controller)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the first item in a sequence.", "response": "def first(sequence, message=None):\n    \"\"\"The first item in that sequence\n\n    If there aren't any, raise a ValueError with that message\n    \"\"\"\n    try:\n        return next(iter(sequence))\n    except StopIteration:\n        raise ValueError(message or ('Sequence is empty: %s' % sequence))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the last item in a sequence.", "response": "def last(sequence, message=None):\n    \"\"\"The last item in that sequence\n\n    If there aren't any, raise a ValueError with that message\n    \"\"\"\n    try:\n        return sequence.pop()\n    except AttributeError:\n        return list(sequence).pop()\n    except IndexError:\n        raise ValueError(message or f'Sequence is empty: {sequence}')"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef first_that(predicate, sequence, message=None):\n    try:\n        return next(ifilter(predicate, sequence))\n    except StopIteration:\n        raise KeyError(message or 'Not Found')", "response": "Returns the first item in that sequence that matches the predicate."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngenerates a bounded windows.", "response": "def expand_window(center, window_size, array_size):\n    \"\"\"Generate a bounded windows. \n\n    maxlength = 2 * window_size + 1, lower bound is 0 and upper bound is \n    ``array_size - 1``.\n\n    Example::\n\n        >>> expand_window(center=50, window_size=3, max=100)\n        [47, 48, 49, 50, 51, 52, 53]\n\n        >>> expand_window(center=2, window_size=3, max=100)\n        [0, 1, 2, 3, 4, 5]\n\n        >>> expand_window(center=98, window_size=3, max=100)\n        [95, 96, 97, 98, 99]\n    \"\"\"\n    if center - window_size < 0:\n        lower = 0\n    else:\n        lower = center - window_size\n    if center + window_size + 1 > array_size:\n        upper = array_size\n    else:\n        upper = center + window_size + 1\n    return np.array(range(lower, upper))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nconverting an image to ascii art text.", "response": "def img2ascii(img_path, ascii_path, ascii_char=\"*\", pad=0):\n    \"\"\"Convert an image to ascii art text.\n\n    Suppose we have an image like that:\n\n    .. image:: images/rabbit.png\n        :align: left\n\n    Put some codes::\n\n        >>> from weatherlab.math.img2waveform import img2ascii\n        >>> img2ascii(r\"testdata\\img2waveform\\rabbit.png\", \n        ...           r\"testdata\\img2waveform\\asciiart.txt\", pad=0)\n\n    Then you will see this in asciiart.txt::\n\n\n                               ******                                                   \n                              ***  ***                         ****                     \n                             **      **                     *********                   \n                            **        **                   ***     ***                  \n                           **          *                  **         **                 \n                           **          **                **          **                 \n                          **            *               ***           *                 \n                          *             **              **            **                \n                         **              *             **             **                \n                         **              *             **              *                \n                         *               **           **               *                \n                        **               **           *                **               \n                        **                *          **                **               \n                        *                 *          **                **               \n                        *                 **         *                 **               \n                       **                 **        **                 **               \n                       **                  *        **                 **               \n                       **                  *        *                  **               \n                       **                  *       **                   *               \n                       **                  *       **                   *               \n                       *                   **      **                   *               \n                       *                   **      *                    *               \n                       *                   **     **                    *               \n                       *                   **     **                    *               \n                       **                  **     **                   **               \n                       **                   *     **                   **               \n                       **                   *     *                    **               \n                       **                   *     *                    **               \n                       **                   *     *                    **               \n                        *                   *    **                    **               \n                        *                   *    **                    *                \n                        **                  *    **                    *                \n                        **                  *    **                    *                \n                        **                  **   **                   **                \n                         *                  **   **                   **                \n                         *                  **   **                   **                \n                         **                 **   **                   *                 \n                         **                 **   **                  **                 \n                          *                 **   **                  **                 \n                          **                **   **                  *                  \n                          **                *******                  *                  \n                          **                *******                 **                  \n                           **                                       **                  \n                           **                                       *                   \n                           **                                      **                   \n                          ***                                      *                    \n                        ****                                       ***                  \n                      ***                                           ***                 \n                     **                                              ****               \n                    **                                                 ***              \n                   **                                                   ***             \n                  **                                                      **            \n                 **                                                        **           \n                 *                                                          **          \n                **                                                           **         \n               **                                                            **         \n               **                                                             **        \n              **                                                               **       \n              **                                                               **       \n             **                                                                 **      \n             **                                                                 **      \n             *                                                                   **     \n             *                                                                   **     \n            **                                                                    *     \n            **                                                                    **    \n            *                                                                     **    \n            *                                                                     **    \n           **                                                                      *    \n           **                                                                      *    \n           **                                                                      **   \n           **                                                                      **   \n           **                                                                      **   \n           **                                                                      **   \n           **            **                                                        **   \n           **            ***                                      ***              **   \n            *           ****                                      ****             **   \n            *            ***                                      ****             **   \n            **           **                                        **              *    \n            **                                                                     *    \n            **                                                                     *    \n             *                                                                    **    \n             **                                                                   **    \n             **                                                                   *     \n              *                                                                  **     \n              **                                                                 **     \n               **                                                               **      \n               **                                                               *       \n                **                                                             **       \n                **                                                            **        \n                 **                                                          **         \n                  **                        ***  **                         **          \n                   **                        ******                        ***          \n                    ***                     ******                        **            \n                     ***                     *  ***                     ***             \n                       ***                                             ***              \n                        ***                                          ***                \n                          ****                                     ****                 \n                         ********                                *******                \n                        *** **********                       ******** ***               \n                       **   ***  ************         ********** *** * ***              \n                      **  * ****      ***********************   ***  ** ***             \n                     ** *  ** ****  **       ******* *         *** ***** ***            \n                    ****  *  * *****       **********      * **** *  * ** **            \n                   ***  * * ** * ******************************* * ***   * **           \n                   ** ***** * *** ********** **  ** **********   ***   **  ***          \n                  ** * ***** **  *    *****  **  **   *****   * *  ** *     **          \n                 ***  *** ************    ** ****** ** *    * ** ** ** * ** ***         \n                 ** ******* *  * **    **  ** ****    *  ** *  **   * ****   **         \n                ** *** *** ******* ****** * **   * *** ***** *** ** ***** **  **        \n                ** * *  ***** ************************************ * ****  *  **        \n               *** ** ** ***********************************************  *** ***       \n                ***   ** ****************************************** **** ** ** **       \n                ****  ** ** ******************************************** ** *  **       \n               ** ****** ** ******************************************** ** *  ***      \n               **  ***** *********************************************** **  ****       \n               *     *** ****************************** **************** *********      \n              **      **  *************************************** * * *  *****   *      \n              **      ** **********************************************  ***     *      \n               *      ** **  *********************************** ******* **      *      \n               **     **  *****************************************  *** **      *      \n                ***  ** * ********************************************** **     **      \n                 ****** ************************************************ **   ***       \n                   **** *********************************************** ********        \n                     **  *********************************************** ****           \n                     *** **  ******************************************* **             \n                      *** ** ***** ****** * * * * *  ******** *** ** ** ***             \n                       ***  *   * ****   ****  **** * ** **  * *** **  ***              \n                        ****   * * ** **** * *** ********  *  ***   *****               \n                         *****    ** **  ** **  ***  ** ***       *****                 \n                           *******        * * ** * **        ********                   \n                              *************** *   *******************                   \n                               ******************************      ***                  \n                              ***          *********                **                  \n                              **                  *                  **                 \n                             **                   *                  **                 \n                             **                   *                  **                 \n                             **                   *                  **                 \n                             **                   *                  **                 \n                             **                  **                 **                  \n                              **                ****** *  ** *********                  \n                               *************************************                    \n                                  **********    \n\n    :param img_path: the image file path\n    :type img_path: str\n    :param ascii_path: the output ascii text file path\n    :type ascii_path: str\n    :param pad: how many space been filled in between two pixels\n    :type pad: int\n    \"\"\"\n    if len(ascii_char) != 1:\n        raise Exception(\"ascii_char has to be single character.\")\n\n    image = Image.open(img_path).convert(\"L\")\n    matrix = np.array(image)\n\n    # you can customize the gray scale fix behavior to fit color image\n    matrix[np.where(matrix >= 128)] = 255\n    matrix[np.where(matrix < 128)] = 0\n\n    lines = list()\n    for vector in matrix:\n        line = list()\n        for i in vector:\n            line.append(\" \" * pad)\n            if i:\n                line.append(\" \")\n            else:\n                line.append(ascii_char)\n        lines.append(\"\".join(line))\n\n    with open(ascii_path, \"w\") as f:\n        f.write(\"\\n\".join(lines))"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ngenerate 1 - D wav data from an image file.", "response": "def img2wav(path, min_x, max_x, min_y, max_y, window_size=3):\n    \"\"\"Generate 1-D data ``y=f(x)`` from a black/white image.\n\n    Suppose we have an image like that:\n\n    .. image:: images/waveform.png\n        :align: center\n\n    Put some codes::\n\n        >>> from weatherlab.math.img2waveform import img2wav\n        >>> import matplotlib.pyplot as plt\n        >>> x, y = img2wav(r\"testdata\\img2waveform\\waveform.png\", \n        ...                  min_x=0.0, max_x=288, \n        ...                  min_y=15.0, max_y=35.0, \n        ...                  window_size=15)\n        >>> plt.plot(x, y)\n        >>> plt.show()\n\n    Then you got nicely sampled data:\n\n    .. image:: images\\waveform_pyplot.png\n        :align: center\n\n    :param path: the image file path\n    :type path: string\n    :param min_x: minimum value of x axis\n    :type min_x: number\n    :param max_x: maximum value of x axis\n    :type max_x: number\n    :param min_y: minimum value of y axis\n    :type min_y: number\n    :param max_y: maximum value of y axis\n    :type max_y: number\n    :param window_size: the slide window\n    :type window_size: int\n\n    Note:\n\n    In python, a numpy array that represent a image is from left to the right, \n    top to the bottom, but in coordinate, it's from bottom to the top. So we \n    use ::-1 for a reverse output\n    \"\"\"\n    image = Image.open(path).convert(\"L\")\n    matrix = np.array(image)[::-1]\n\n    # you can customize the gray scale fix behavior to fit color image\n    matrix[np.where(matrix >= 128)] = 255\n    matrix[np.where(matrix < 128)] = 0\n\n    tick_x = (max_x - min_x) / matrix.shape[1]\n    tick_y = (max_y - min_y) / matrix.shape[0]\n\n    x, y = list(), list()\n    for i in range(matrix.shape[1]):\n        window = expand_window(  # slide margin window\n            i, window_size, matrix.shape[1])\n        margin_dots_y_indices = np.where(matrix[:, window] == 0)[0]\n        # if found at least one dots in margin\n        if len(margin_dots_y_indices) > 0:\n            x.append(min_x + (i + 1) * tick_x)\n            y.append(min_y + margin_dots_y_indices.mean() * tick_y)\n\n    return np.array(x), np.array(y)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef initial_populate(self, data):\n        if self.config.parsed:\n            return False\n        # Otherwise, create a new ConfigKey.\n        self.config.load_from_dict(data)\n        return True", "response": "Populate a newly created config object with data."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\napplies default values from a different ConfigObject or ConfigKey object to this ConfigObject.", "response": "def apply_defaults(self, other_config):\n        \"\"\"\n        Applies default values from a different ConfigObject or ConfigKey object to this ConfigObject.\n\n        If there are any values in this object that are also in the default object, it will use the values from this object.\n        \"\"\"\n        if isinstance(other_config, self.__class__):\n            self.config.load_from_dict(other_config.config, overwrite=False)\n        else:\n            self.config.load_from_dict(other_config, overwrite=False)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nparsing a string into args and kwargs.", "response": "def to_args(s):\n    \"\"\" parse a string into args and kwargs\n\n        the input is a blank-delimited set of tokens, which may be grouped\n        as strings (tick or double tick delimited) with embedded blanks.\n        a non-string equal (=) acts as a delimiter between key-value pairs.\n\n        the initial tokens are treated as args, followed by key-value pairs.\n\n        Example:\n\n            one 'two three' four=5 six='seven eight'\n\n            parses to:\n\n            args = ['one', 'two three']\n            kwargs = {'four': 5, 'six': 'seven eight'}\n\n        Return:\n\n            args as list\n            kwargs as dict\n\n        Notes:\n\n            1. Does not enforce args and keywords as valid python.\n\n            2. String delimiters can be escaped (\\) within strings.\n\n            3. Key-value delimiters (=) can be surrounded by blanks.\n\n            4. Non-string integer kwarg values will be int; all other\n               values are str.\n\n            5. Designed for functionality, not speed\n    \"\"\"\n    args = []\n    kwargs = {}\n    state = 'arg'\n    for token in to_tokens(s):\n        if state == 'arg':\n            if token.is_key:\n                key = token.value\n                state = 'value'\n            else:\n                args.append(token.value)\n        elif state == 'key':\n            if not token.is_key:\n                raise ExpectingKey(token.value)\n            key = token.value\n            if key in kwargs:\n                raise DuplicateKey(key)\n            state = 'value'\n        elif state == 'value':\n            if token.is_key:\n                raise ConsecutiveKeys(token.value)\n            kwargs[key] = token.value\n            state = 'key'\n\n    if state == 'value':\n        raise IncompleteKeyValue(key)\n\n    return args, kwargs"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndispatch the request to the appropriate controller.", "response": "def dispatch(self, req):\n        \"\"\"\n        Called by the Routes middleware to dispatch the request to the\n        appropriate controller.  If a webob exception is raised, it is\n        returned; if some other exception is raised, the webob\n        `HTTPInternalServerError` exception is raised.  Otherwise, the\n        return value of the controller is returned.\n        \"\"\"\n\n        # Grab the request parameters\n        params = req.environ['wsgiorg.routing_args'][1]\n\n        # What controller is authoritative?\n        controller = params.pop('controller')\n\n        # Determine its name\n        cont_class = controller.__class__\n        cont_name = \"%s:%s\" % (cont_class.__module__, cont_class.__name__)\n\n        # Determine the origin of the request\n        origin = req.remote_addr if req.remote_addr else '[local]'\n        if req.remote_user:\n            origin = '%s (%s)' % (origin, req.remote_user)\n\n        # Log that we're processing the request\n        LOG.info(\"%s %s %s (controller %r)\" %\n                 (origin, req.method, req.url, cont_name))\n\n        # Call into that controller\n        try:\n            return controller(req, params)\n        except webob.exc.HTTPException as e:\n            # Return the HTTP exception directly\n            return e\n        except exceptions.AppathyResponse as e:\n            # Return the webob.Response directly\n            return e.response\n        except Exception as e:\n            # Log the controller exception\n            LOG.exception(\"Exception occurred in controller %r\" % cont_name)\n\n            # These exceptions result in a 500.  Note we're\n            # intentionally not including the exception message, since\n            # it could contain sensitive data.\n            return webob.exc.HTTPInternalServerError()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef my_func(p1, p2,\n            first_option='default_value',\n            second_option=5,\n            third_option=[4, 3],\n            last_option=False):\n    \"\"\"Help docstring. v{VERSION}\n       {message}\n    \"\"\"\n    if last_option:\n        raise RuntimeError(\"Test of DEBUG\")\n    print('%s %s %s %s %s %s' % (p1, p2, first_option, second_option, third_option, last_option))", "response": "Help docstring. v{VERSION}\n       {message}"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _get_variables(self) -> Dict[str, str]:\n        variables = {}  # type: Dict[str, str]\n        for group in self.groups:\n            setting_variables = self._read_group_variables(group)\n            variables.update(setting_variables)\n        return variables", "response": "Gets the variables that should be set for this project."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _resolve_group_location(self, group: str) -> str:\n        if os.path.isabs(group):\n            possible_paths = [group]\n        else:\n            possible_paths = []\n            for repository in self.setting_repositories:\n                possible_paths.append(os.path.join(repository, group))\n\n        for default_setting_extension in self.default_setting_extensions:\n            number_of_paths = len(possible_paths)\n            for i in range(number_of_paths):\n                path_with_extension = \"%s.%s\" % (possible_paths[i], default_setting_extension)\n                possible_paths.append(path_with_extension)\n\n        for path in possible_paths:\n            if os.path.exists(path):\n                return path\n        raise ValueError(\"Could not resolve location of settings identified by: \\\"%s\\\"\" % group)", "response": "Resolves the location of a setting file based on the given identifier."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef query(self, ns, selector='*'):\n    q, r = HicaLabelStore.PREFIX + '.' + ns, []\n    for (key, value) in self.items:\n      if not selector and key == q:\n        r.append((key, value))\n      if key.startswith(q) and key != q:\n        sub = key[len(q):]\n        m = re.match('.' + selector, sub)\n        if m:\n          r.append((key, value))\n    return r", "response": "Query the label store for labels\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets a value from a single fully - qualified name", "response": "def get_value(self, label):\n    \"\"\" Get value from a single fully-qualified name \"\"\" \n    for (key, value) in self.items:\n      if key == label:\n        return value"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _initLocale(ptc):\n\n    def lcase(x):\n        return x.lower()\n\n    if pyicu and ptc.usePyICU:\n        ptc.icuLocale = None\n\n        if ptc.localeID is not None:\n            ptc.icuLocale = pyicu.Locale(ptc.localeID)\n\n        if ptc.icuLocale is None:\n            for id in range(0, len(ptc.fallbackLocales)):\n                ptc.localeID  = ptc.fallbackLocales[id]\n                ptc.icuLocale = pyicu.Locale(ptc.localeID)\n\n                if ptc.icuLocale is not None:\n                    break\n\n        ptc.icuSymbols = pyicu.DateFormatSymbols(ptc.icuLocale)\n\n          # grab ICU list of weekdays, skipping first entry which\n          # is always blank\n        wd  = map(lcase, ptc.icuSymbols.getWeekdays()[1:])\n        swd = map(lcase, ptc.icuSymbols.getShortWeekdays()[1:])\n\n          # store them in our list with Monday first (ICU puts Sunday first)\n        ptc.Weekdays      = wd[1:] + wd[0:1]\n        ptc.shortWeekdays = swd[1:] + swd[0:1]\n        ptc.Months        = map(lcase, ptc.icuSymbols.getMonths())\n        ptc.shortMonths   = map(lcase, ptc.icuSymbols.getShortMonths())\n\n          # not quite sure how to init this so for now\n          # set it to none so it will be set to the en_US defaults for now\n        ptc.re_consts   = None\n        ptc.icu_df      = { 'full':   pyicu.DateFormat.createDateInstance(pyicu.DateFormat.kFull,   ptc.icuLocale),\n                            'long':   pyicu.DateFormat.createDateInstance(pyicu.DateFormat.kLong,   ptc.icuLocale),\n                            'medium': pyicu.DateFormat.createDateInstance(pyicu.DateFormat.kMedium, ptc.icuLocale),\n                            'short':  pyicu.DateFormat.createDateInstance(pyicu.DateFormat.kShort,  ptc.icuLocale),\n                          }\n        ptc.icu_tf      = { 'full':   pyicu.DateFormat.createTimeInstance(pyicu.DateFormat.kFull,   ptc.icuLocale),\n                            'long':   pyicu.DateFormat.createTimeInstance(pyicu.DateFormat.kLong,   ptc.icuLocale),\n                            'medium': pyicu.DateFormat.createTimeInstance(pyicu.DateFormat.kMedium, ptc.icuLocale),\n                            'short':  pyicu.DateFormat.createTimeInstance(pyicu.DateFormat.kShort,  ptc.icuLocale),\n                          }\n        ptc.dateFormats = { 'full':   ptc.icu_df['full'].toPattern(),\n                            'long':   ptc.icu_df['long'].toPattern(),\n                            'medium': ptc.icu_df['medium'].toPattern(),\n                            'short':  ptc.icu_df['short'].toPattern(),\n                          }\n        ptc.timeFormats = { 'full':   ptc.icu_tf['full'].toPattern(),\n                            'long':   ptc.icu_tf['long'].toPattern(),\n                            'medium': ptc.icu_tf['medium'].toPattern(),\n                            'short':  ptc.icu_tf['short'].toPattern(),\n                          }\n    else:\n        if not ptc.localeID in pdtLocales:\n            for id in range(0, len(ptc.fallbackLocales)):\n                ptc.localeID  = ptc.fallbackLocales[id]\n\n                if ptc.localeID in pdtLocales:\n                    break\n\n        ptc.locale   = pdtLocales[ptc.localeID]\n        ptc.usePyICU = False\n\n        ptc.Weekdays      = ptc.locale.Weekdays\n        ptc.shortWeekdays = ptc.locale.shortWeekdays\n        ptc.Months        = ptc.locale.Months\n        ptc.shortMonths   = ptc.locale.shortMonths\n        ptc.dateFormats   = ptc.locale.dateFormats\n        ptc.timeFormats   = ptc.locale.timeFormats\n\n      # these values are used to setup the various bits \n      # of the regex values used to parse\n      #\n      # check if a local set of constants has been\n      # provided, if not use en_US as the default\n    if ptc.localeID in pdtLocales:\n        ptc.re_sources = pdtLocales[ptc.localeID].re_sources\n        ptc.re_values  = pdtLocales[ptc.localeID].re_consts\n\n        units = pdtLocales[ptc.localeID].units\n\n        ptc.Modifiers  = pdtLocales[ptc.localeID].modifiers\n        ptc.dayOffsets = pdtLocales[ptc.localeID].dayoffsets\n\n          # for now, pull over any missing keys from the US set\n        for key in pdtLocales['en_US'].re_consts:\n            if not key in ptc.re_values:\n                ptc.re_values[key] = pdtLocales['en_US'].re_consts[key]\n    else:\n        ptc.re_sources = pdtLocales['en_US'].re_sources\n        ptc.re_values  = pdtLocales['en_US'].re_consts\n        ptc.Modifiers  = pdtLocales['en_US'].modifiers\n        ptc.dayOffsets = pdtLocales['en_US'].dayoffsets\n        units          = pdtLocales['en_US'].units\n\n      # escape any regex special characters that may be found\n    wd   = tuple(map(re.escape, ptc.Weekdays))\n    swd  = tuple(map(re.escape, ptc.shortWeekdays))\n    mth  = tuple(map(re.escape, ptc.Months))\n    smth = tuple(map(re.escape, ptc.shortMonths))\n\n    ptc.re_values['months']      = '%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s' % mth\n    ptc.re_values['shortmonths'] = '%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s|%s' % smth\n    ptc.re_values['days']        = '%s|%s|%s|%s|%s|%s|%s' % wd\n    ptc.re_values['shortdays']   = '%s|%s|%s|%s|%s|%s|%s' % swd\n\n    l = []\n    for unit in units:\n        l.append('|'.join(units[unit]))\n\n    ptc.re_values['units'] = '|'.join(l)\n    ptc.Units              = ptc.re_values['units'].split('|')", "response": "Initialize the locale of the current locale and store them into ptc."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _initSymbols(ptc):\n    ptc.timeSep  = [ u':' ]\n    ptc.dateSep  = [ u'/' ]\n    ptc.meridian = [ u'AM', u'PM' ]\n\n    ptc.usesMeridian = True\n    ptc.uses24       = False\n\n    if pyicu and ptc.usePyICU:\n        am = u''\n        pm = u''\n        ts = ''\n\n        # ICU doesn't seem to provide directly the\n        # date or time seperator - so we have to\n        # figure it out\n        o = ptc.icu_tf['short']\n        s = ptc.timeFormats['short']\n\n        ptc.usesMeridian = u'a' in s\n        ptc.uses24       = u'H' in s\n\n        # '11:45 AM' or '11:45'\n        s = o.format(datetime.datetime(2003, 10, 30, 11, 45))\n\n        # ': AM' or ':'\n        s = s.replace('11', '').replace('45', '')\n\n        if len(s) > 0:\n            ts = s[0]\n\n        if ptc.usesMeridian:\n            # '23:45 AM' or '23:45'\n            am = s[1:].strip()\n            s  = o.format(datetime.datetime(2003, 10, 30, 23, 45))\n\n            if ptc.uses24:\n                s = s.replace('23', '')\n            else:\n                s = s.replace('11', '')\n\n            # 'PM' or ''\n            pm = s.replace('45', '').replace(ts, '').strip()\n\n        ptc.timeSep  = [ ts ]\n        ptc.meridian = [ am, pm ]\n\n        o = ptc.icu_df['short']\n        s = o.format(datetime.datetime(2003, 10, 30, 11, 45))\n        s = s.replace('10', '').replace('30', '').replace('03', '').replace('2003', '')\n\n        if len(s) > 0:\n            ds = s[0]\n        else:\n            ds = '/'\n\n        ptc.dateSep = [ ds ]\n        s           = ptc.dateFormats['short']\n        l           = s.lower().split(ds)\n        dp_order    = []\n\n        for s in l:\n            if len(s) > 0:\n                dp_order.append(s[:1])\n\n        ptc.dp_order = dp_order\n    else:\n        ptc.timeSep      = ptc.locale.timeSep\n        ptc.dateSep      = ptc.locale.dateSep\n        ptc.meridian     = ptc.locale.meridian\n        ptc.usesMeridian = ptc.locale.usesMeridian\n        ptc.uses24       = ptc.locale.uses24\n        ptc.dp_order     = ptc.locale.dp_order\n\n      # build am and pm lists to contain\n      # original case, lowercase and first-char\n      # versions of the meridian text\n\n    if len(ptc.meridian) > 0:\n        am     = ptc.meridian[0]\n        ptc.am = [ am ]\n\n        if len(am) > 0:\n            ptc.am.append(am[0])\n            am = am.lower()\n            ptc.am.append(am)\n            ptc.am.append(am[0])\n    else:\n        am     = ''\n        ptc.am = [ '', '' ]\n\n    if len(ptc.meridian) > 1:\n        pm     = ptc.meridian[1]\n        ptc.pm = [ pm ]\n\n        if len(pm) > 0:\n            ptc.pm.append(pm[0])\n            pm = pm.lower()\n            ptc.pm.append(pm)\n            ptc.pm.append(pm[0])\n    else:\n        pm     = ''\n        ptc.pm = [ '', '' ]", "response": "Helper function to initialize the single character constants\n ptc. timeSep and ptc. dateSep are used to initialize the single character constants\n ptc. uses24 is used to initialize the 24 bit template template"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _initPatterns(ptc):\n    # TODO add code to parse the date formats and build the regexes up from sub-parts\n    # TODO find all hard-coded uses of date/time seperators\n\n    ptc.RE_DATE4     = r'''(?P<date>(((?P<day>\\d\\d?)(?P<suffix>%(daysuffix)s)?(,)?(\\s)?)\n                                      (?P<mthname>(%(months)s|%(shortmonths)s))\\s?\n                                      (?P<year>\\d\\d(\\d\\d)?)?\n                                    )\n                           )''' % ptc.re_values\n\n    # I refactored DATE3 to fix Issue 16 http://code.google.com/p/parsedatetime/issues/detail?id=16\n    # I suspect the final line was for a trailing time - but testing shows it's not needed\n    # ptc.RE_DATE3     = r'''(?P<date>((?P<mthname>(%(months)s|%(shortmonths)s))\\s?\n    #                                  ((?P<day>\\d\\d?)(\\s?|%(daysuffix)s|$)+)?\n    #                                  (,\\s?(?P<year>\\d\\d(\\d\\d)?))?))\n    #                        (\\s?|$|[^0-9a-zA-Z])''' % ptc.re_values\n    ptc.RE_DATE3     = r'''(?P<date>(\n                                     (((?P<mthname>(%(months)s|%(shortmonths)s))|\n                                     ((?P<day>\\d\\d?)(?P<suffix>%(daysuffix)s)?))(\\s)?){1,2}\n                                     ((,)?(\\s)?(?P<year>\\d\\d(\\d\\d)?))?\n                                    )\n                           )''' % ptc.re_values\n    ptc.RE_MONTH     = r'''(\\s?|^)\n                           (?P<month>(\n                                      (?P<mthname>(%(months)s|%(shortmonths)s))\n                                      (\\s?(?P<year>(\\d\\d\\d\\d)))?\n                                     ))\n                           (\\s?|$|[^0-9a-zA-Z])''' % ptc.re_values\n    ptc.RE_WEEKDAY   = r'''(\\s?|^)\n                           (?P<weekday>(%(days)s|%(shortdays)s))\n                           (\\s?|$|[^0-9a-zA-Z])''' % ptc.re_values\n\n    ptc.RE_SPECIAL   = r'(?P<special>^[%(specials)s]+)\\s+' % ptc.re_values\n    ptc.RE_UNITS     = r'''(?P<qty>(-?\\d+\\s*\n                                    (?P<units>((%(units)s)s?))\n                                   ))''' % ptc.re_values\n    ptc.RE_QUNITS    = r'''(?P<qty>(-?\\d+\\s?\n                                    (?P<qunits>%(qunits)s)\n                                    (\\s?|,|$)\n                                   ))''' % ptc.re_values\n    ptc.RE_MODIFIER  = r'''(\\s?|^)\n                           (?P<modifier>\n                            (previous|prev|last|next|eod|eo|(end\\sof)|(in\\sa)))''' % ptc.re_values\n    ptc.RE_MODIFIER2 = r'''(\\s?|^)\n                           (?P<modifier>\n                            (from|before|after|ago|prior))\n                           (\\s?|$|[^0-9a-zA-Z])''' % ptc.re_values\n    ptc.RE_TIMEHMS   = r'''(\\s?|^)\n                           (?P<hours>\\d\\d?)\n                           (?P<tsep>%(timeseperator)s|)\n                           (?P<minutes>\\d\\d)\n                           (?:(?P=tsep)(?P<seconds>\\d\\d(?:[.,]\\d+)?))?''' % ptc.re_values\n    ptc.RE_TIMEHMS2  = r'''(?P<hours>(\\d\\d?))\n                           ((?P<tsep>%(timeseperator)s|)\n                            (?P<minutes>(\\d\\d?))\n                            (?:(?P=tsep)\n                               (?P<seconds>\\d\\d?\n                                (?:[.,]\\d+)?))?)?''' % ptc.re_values\n\n    if 'meridian' in ptc.re_values:\n        ptc.RE_TIMEHMS2 += r'\\s?(?P<meridian>(%(meridian)s))' % ptc.re_values\n\n    dateSeps = ''.join(ptc.dateSep) + '.'\n\n    ptc.RE_DATE      = r'''(\\s?|^)\n                           (?P<date>(\\d\\d?[%s]\\d\\d?([%s]\\d\\d(\\d\\d)?)?))\n                           (\\s?|$|[^0-9a-zA-Z])''' % (dateSeps, dateSeps)\n    ptc.RE_DATE2     = r'[%s]' % dateSeps\n    ptc.RE_DAY       = r'''(\\s?|^)\n                           (?P<day>(today|tomorrow|yesterday))\n                           (\\s?|$|[^0-9a-zA-Z])''' % ptc.re_values\n    ptc.RE_DAY2      = r'''(?P<day>\\d\\d?)|(?P<suffix>%(daysuffix)s)\n                        ''' % ptc.re_values\n    ptc.RE_TIME      = r'''(\\s?|^)\n                           (?P<time>(morning|breakfast|noon|lunch|evening|midnight|tonight|dinner|night|now))\n                           (\\s?|$|[^0-9a-zA-Z])''' % ptc.re_values\n    ptc.RE_REMAINING = r'\\s+'\n\n    # Regex for date/time ranges\n    ptc.RE_RTIMEHMS  = r'''(\\s?|^)\n                           (\\d\\d?)%(timeseperator)s\n                           (\\d\\d)\n                           (%(timeseperator)s(\\d\\d))?\n                           (\\s?|$)''' % ptc.re_values\n    ptc.RE_RTIMEHMS2 = r'''(\\s?|^)\n                           (\\d\\d?)\n                           (%(timeseperator)s(\\d\\d?))?\n                           (%(timeseperator)s(\\d\\d?))?''' % ptc.re_values\n\n    if 'meridian' in ptc.re_values:\n        ptc.RE_RTIMEHMS2 += r'\\s?(%(meridian)s)' % ptc.re_values\n\n    ptc.RE_RDATE  = r'(\\d+([%s]\\d+)+)' % dateSeps\n    ptc.RE_RDATE3 = r'''((((%(months)s))\\s?\n                         ((\\d\\d?)\n                          (\\s?|%(daysuffix)s|$)+)?\n                         (,\\s?\\d\\d\\d\\d)?))''' % ptc.re_values\n\n    # \"06/07/06 - 08/09/06\"\n    ptc.DATERNG1 = ptc.RE_RDATE + r'\\s?%(rangeseperator)s\\s?' + ptc.RE_RDATE\n    ptc.DATERNG1 = ptc.DATERNG1 % ptc.re_values\n\n    # \"march 31 - june 1st, 2006\"\n    ptc.DATERNG2 = ptc.RE_RDATE3 + r'\\s?%(rangeseperator)s\\s?' + ptc.RE_RDATE3\n    ptc.DATERNG2 = ptc.DATERNG2 % ptc.re_values\n\n    # \"march 1rd -13th\"\n    ptc.DATERNG3 = ptc.RE_RDATE3 + r'\\s?%(rangeseperator)s\\s?(\\d\\d?)\\s?(rd|st|nd|th)?'\n    ptc.DATERNG3 = ptc.DATERNG3 % ptc.re_values\n\n    # \"4:00:55 pm - 5:90:44 am\", '4p-5p'\n    ptc.TIMERNG1 = ptc.RE_RTIMEHMS2 + r'\\s?%(rangeseperator)s\\s?' + ptc.RE_RTIMEHMS2\n    ptc.TIMERNG1 = ptc.TIMERNG1 % ptc.re_values\n\n    # \"4:00 - 5:90 \", \"4:55:55-3:44:55\"\n    ptc.TIMERNG2 = ptc.RE_RTIMEHMS + r'\\s?%(rangeseperator)s\\s?' + ptc.RE_RTIMEHMS\n    ptc.TIMERNG2 = ptc.TIMERNG2 % ptc.re_values\n\n    # \"4-5pm \"\n    ptc.TIMERNG3 = r'\\d\\d?\\s?%(rangeseperator)s\\s?' + ptc.RE_RTIMEHMS2\n    ptc.TIMERNG3 = ptc.TIMERNG3 % ptc.re_values\n\n    # \"4:30-5pm \"\n    ptc.TIMERNG4 = ptc.RE_RTIMEHMS + r'\\s?%(rangeseperator)s\\s?' + ptc.RE_RTIMEHMS2\n    ptc.TIMERNG4 = ptc.TIMERNG4 % ptc.re_values", "response": "Helper function to take the different localized bits from ptc and create the regex strings."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef buildSources(self, sourceTime=None):\n        if sourceTime is None:\n            (yr, mth, dy, hr, mn, sec, wd, yd, isdst) = time.localtime()\n        else:\n            (yr, mth, dy, hr, mn, sec, wd, yd, isdst) = sourceTime\n\n        sources  = {}\n        defaults = { 'yr': yr, 'mth': mth, 'dy':  dy,\n                     'hr': hr, 'mn':  mn,  'sec': sec, }\n\n        for item in self.re_sources:\n            values = {}\n            source = self.re_sources[item]\n\n            for key in defaults.keys():\n                if key in source:\n                    values[key] = source[key]\n                else:\n                    values[key] = defaults[key]\n\n            sources[item] = ( values['yr'], values['mth'], values['dy'],\n                              values['hr'], values['mn'], values['sec'], wd, yd, isdst )\n\n        return sources", "response": "Build a dictionary of date and time tuples based on the keys\nAttributeNames and sourceTime."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef write_to_file(self, file_path: str) -> None:\n        data = self.encode()\n        with open(file_path, \"w\") as f:\n            json.dump(data, f, indent=1)", "response": "Serialize and write the data into a JSON file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef load_from_file(cls, file_path: str):\n        with open(file_path, \"r\") as f:\n            data = json.load(f)\n            item = cls.decode(data=data)\n        return item", "response": "Read and reconstruct the data from a JSON file."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef gen_component_name(self, basename, postfix_length=13):\n        def newcname():\n            postfix = ''.join(\n                    random.choice(_AWS_NAME_CHARS)\n                    for i in xrange(postfix_length)\n                    )\n            return '%s-%s' % (basename, postfix)\n        cname = newcname()\n        while cname in self.component_names:\n            cname = newcname()\n        self.component_names.append(cname)\n        return cname", "response": "Generates a random component name."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning an object that a : class : ~bang. Deployer. Deployer uses to control resources of the given type.", "response": "def get_consul(self, resource_type):\n        \"\"\"\n        Returns an object that a :class:`~bang.deployers.deployer.Deployer`\n        uses to control resources of :attr:`resource_type`.\n\n        :param str service:  Any of the resources defined\n            in :mod:`bang.resources`.\n\n        \"\"\"\n        consul = self.CONSUL_MAP.get(resource_type)\n        if consul:\n            return consul(self)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef update_slugs(apps, schema_editor):\n\n    # Get model managers\n    Representative = apps.get_model(\"representatives\", \"Representative\")\n\n    for rep in Representative.objects.all():\n        rep.slug = '%s-%s' % (rep.slug, rep.birth_date)\n        rep.save()", "response": "Update slugs for all the representatives"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates the parl websites for remote_id removal by creating WebSite entities from it.", "response": "def create_parl_websites(apps, schema_editor):\n    \"\"\"\n    Prepare for remote_id removal by creating WebSite entities from it.\n    \"\"\"\n\n    # Get model managers\n    Representative = apps.get_model(\"representatives\", \"Representative\")\n    WebSite = apps.get_model(\"representatives\", \"WebSite\")\n\n    today = datetime.date.today()\n\n    # EP\n    ep_url = 'http://www.europarl.europa.eu/meps/en/%s/_home.html'\n    qs = Representative.objects.filter(\n        models.Q(mandates__end_date__gte=today) |\n        models.Q(mandates__end_date__isnull=True),\n        mandates__group__chamber__abbreviation='EP'\n    )\n    for rep in qs:\n        changed = False\n        url = ep_url % rep.remote_id\n\n        try:\n            site = WebSite.objects.get(representative=rep, kind='EP')\n        except WebSite.DoesNotExist:\n            site = WebSite(representative=rep, kind='EP', url=url)\n            changed = True\n\n        if site.url != url:\n            site.url = url\n            changed = True\n\n        if changed:\n            site.save()\n\n    # AN/SEN\n    for chamber in ['AN', 'SEN']:\n        qs = Representative.objects.filter(\n            models.Q(mandates__end_date__gte=today) |\n            models.Q(mandates__end_date__isnull=True),\n            mandates__group__chamber__abbreviation=chamber\n        )\n        for rep in qs:\n            changed = False\n            url = rep.remote_id\n\n            try:\n                site = WebSite.objects.get(representative=rep, kind=chamber)\n            except WebSite.DoesNotExist:\n                site = WebSite(representative=rep, kind=chamber, url=url)\n                changed = True\n\n            if site.url != url:\n                site.url = url\n                changed = True\n\n            if changed:\n                site.save()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef determine_file_extension_based_on_format(format_specifier):\n\tif format_specifier == FMT_INI:\n\t\treturn 'ini'\n\tif format_specifier == FMT_DELIMITED:\n\t\treturn ''\n\tif format_specifier == FMT_XML:\n\t\treturn 'xml'\n\tif format_specifier == FMT_JSON:\n\t\treturn 'json'\n\tif format_specifier == FMT_YAML:\n\t\treturn 'yml'\n\traise ValueError('invalid format specifier: {}'.format(format_specifier))", "response": "returns file extension string based on format specifier"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef read_element_using_argtuple(self, argtuple):\n\n\t\t# doesn't support DELIMITED, only dict-based formats\n\t\tif self.format == FMT_DELIMITED:\n\t\t\treturn None\n\n\t\tnode = self.cfg_dict\n\t\tfor key in argtuple:\n\t\t\tnode = node[key]\n\t\treturn node", "response": "Reads the element from cfg_dict using the given argtuple."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef load(self):\n\n\t\t\"\"\"\n\t\tthis is a glorified switch/case\n\t\t\"\"\"\n\t\tif self.format == FMT_INI:\n\t\t\tif self.filepaths:\n\t\t\t\treturn self.load_using_ini_format_explicitly()\n\t\t\treturn self.load_using_ini_format_implicitly()\n\n\t\telif self.format == FMT_DELIMITED:\n\t\t\tif self.filepaths:\n\t\t\t\treturn self.load_using_delimited_format_explicitly()\n\t\t\traise ValueError('Implicit mode is not supported with FMT_DELIMITED')\n\n\t\telif self.format == FMT_XML:\n\t\t\tif self.filepaths:\n\t\t\t\treturn self.load_using_xml_format_explicitly()\n\t\t\treturn self.load_using_xml_format_implicitly()\n\n\t\telif self.format == FMT_JSON:\n\t\t\tif self.filepaths:\n\t\t\t\treturn self.load_using_json_format_explicitly()\n\t\t\treturn self.load_using_json_format_implicitly()\n\n\t\telif self.format == FMT_YAML:\n\t\t\tif self.filepaths:\n\t\t\t\treturn self.load_using_yaml_format_explicitly()\n\t\t\treturn self.load_using_yaml_format_implicitly()\n\n\t\telse:\n\t\t\traise ValueError('invalid config format: {}'.format(self.format))\n\n\t\treturn None", "response": "Loads the config file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef length_estimate(self):\n        '''\n        Calculates and estimated word count based on number of characters, locations,\n        and arcs. For reference see:\n        http://www.writingexcuses.com/2017/07/02/12-27-choosing-a-length/\n        '''\n        characters = self.characterinstance_set.filter(\n            Q(main_character=True) |\n            Q(pov_character=True) |\n            Q(protagonist=True) |\n            Q(antagonist=True) |\n            Q(villain=True)).count()\n        locations = self.locationinstance_set.count()\n        arcs = self.arc_set.count()\n        return ((characters + locations) * 750) * (1.5 * arcs)", "response": "Calculates and estimated word count based on number of characters locations and arcs. For reference see :\n        http://www. writingexcuses. com/2017 / 08 - 27 - choosing - a - length /"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates the story arc and initial tree for that arc for the current outline. Returns the resulting Arc instance.", "response": "def create_arc(self, mace_type, name):\n        '''\n        Creates the story arc and initial tree for that arc\n        for the current outline. Returns the resulting Arc\n        instance.\n        '''\n        arc = Arc(mace_type=mace_type, outline=self, name=name)\n        arc.save()\n        milestone_count = arc.generate_template_arc_tree()\n        if milestone_count == 7:  # pragma: no cover\n            arc.refresh_from_db()\n            return arc\n        else:\n            raise ArcIntegrityError('Something went wrong during arc template generation')"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef validate_nesting(self):\n        '''\n        Reviews the story tree and validates associated arc\n        elements are nested appropriately. Returns a dict of errors.\n        '''\n        error_dict = {}\n        story_root = self.story_tree_root\n        story_nodes = story_root.get_descendants().prefetch_related('arcelementnode_set').filter(depth=2)\n\n        def parse_children(node_object, seq=0):\n            '''\n            Recursive method to check all generations of a node for arc\n            elements.\n            '''\n            returnable_ae_dict = {}\n            if node_object.get_children_count():\n                for node in node_object.get_children().prefetch_related('arcelementnode_set'):\n                    if node.get_children_count():\n                        local_ae_dict, newseq = parse_children(node, seq)\n                        for arc in local_ae_dict.keys():\n                            if arc not in returnable_ae_dict.keys():\n                                returnable_ae_dict[arc] = []\n                            returnable_ae_dict[arc] = returnable_ae_dict[arc] + (local_ae_dict[arc])\n                        seq = newseq\n                    else:\n                        local_arc_elements = node.arcelementnode_set.all()\n                        for ae in local_arc_elements:\n                            if ae.is_milestone:\n                                logger.debug('Found a milestone to sequence.')\n                                if ae.arc not in returnable_ae_dict.keys():\n                                    returnable_ae_dict[ae.arc] = []\n                                returnable_ae_dict[ae.arc].append({\n                                    ae.arc_element_type: seq,\n                                })\n                                logger.debug('Appended an element of type %s  from arc %s at sequence %d' % (\n                                    ae.arc_element_type,\n                                    ae.arc.name,\n                                    seq))\n                        seq += 1\n            return returnable_ae_dict, seq\n\n        arcs_out_of_sequence = []\n        arc_milestone_elements = {}\n        x = 0\n        arcs_with_nest_conflicts = []\n        for node in story_nodes:\n            arc_elements_found, x = parse_children(node, x)\n            for arc in arc_elements_found.keys():\n                if arc not in arc_milestone_elements.keys():\n                    arc_milestone_elements[arc] = []\n                arc_milestone_elements[arc] = arc_milestone_elements[arc] + arc_elements_found[arc]\n        arc_entry_exit = {}\n        for arc, elements in arc_milestone_elements.items():\n            z = {}\n            last_local_seq = 0\n            logger.debug(\"There are %d elements to parse\" % len(elements))\n            for ae_elements in elements:\n                logger.debug('Parsing %s' % ae_elements)\n                for k, v in ae_elements.items():\n                    z[k] = v\n            logger.debug('%s' % OrderedDict(sorted(z.items(), key=lambda t: t[1])))\n            for key, value in OrderedDict(sorted(z.items(), key=lambda t: t[1])).items():\n                if last_local_seq > ARC_NODE_ELEMENT_DEFINITIONS[key]['milestone_seq']:\n                    arcs_out_of_sequence.append(arc)\n                    break\n                last_local_seq = ARC_NODE_ELEMENT_DEFINITIONS[key]['milestone_seq']\n                if 'mile_hook' in z.keys() and 'mile_reso' in z.keys():\n                    arc_entry_exit[arc] = {\n                        'entry': z['mile_hook'],\n                        'exit': z['mile_reso'],\n                    }\n        if arc_entry_exit:\n            temp_ent = {}\n            temp_ex = {}\n            for en_arc, enter in arc_entry_exit.items():\n                temp_ent[en_arc] = enter['entry']\n            for ex_arc, leave in arc_entry_exit.items():\n                temp_ex[ex_arc] = leave['exit']\n            arc_entries = OrderedDict(sorted(temp_ent.items(), key=lambda t: t[1]))\n            arc_exits = OrderedDict(sorted(temp_ex.items(), key=lambda t: t[1], reverse=True))\n            logger.debug(\"Evaluating entries vs exits: %s vs %s\" % (arc_entries, arc_exits))\n            index_num = 0\n            for entrance in arc_entries.keys():\n                test_exit = list(arc_exits.keys())[index_num]\n                logger.debug('Checking %s vs %s arcs' % (entrance, test_exit))\n                if entrance != test_exit:\n                    logger.debug(\"Different arcs.. making sure they don't share an entry/exist point\")\n                    if (arc_entry_exit[entrance]['entry'] != arc_entry_exit[test_exit]['entry'] and\n                        arc_entry_exit[entrance]['exit'] != arc_entry_exit[test_exit]['exit']):\n                        if ((arc_entry_exit[entrance]['entry'] < arc_entry_exit[test_exit]['entry'] and\n                                arc_entry_exit[entrance]['exit'] > arc_entry_exit[test_exit]['exit']) or\n                            (arc_entry_exit[entrance]['entry'] > arc_entry_exit[test_exit]['entry'] and\n                             arc_entry_exit[entrance]['exit'] < arc_entry_exit[test_exit]['exit'])):\n                            logger.debug(\"No same entry point, but the nest is still valid.\")\n                        else:\n                            logger.debug(\"nesting error found: %s should resole before %s\" % (entrance, test_exit))\n                            if entrance not in arcs_with_nest_conflicts:\n                                arcs_with_nest_conflicts.append(entrance)\n                            if test_exit not in arcs_with_nest_conflicts:\n                                arcs_with_nest_conflicts.append(test_exit)\n                    else:\n                        logger.debug('Arcs share an entry/exit point so nesting error is ignored.')\n                index_num += 1\n        unique_nest_errors = list(set(arcs_with_nest_conflicts))\n        logger.debug(\"%d arcs with nesting errors found\" % len(unique_nest_errors))\n        logger.debug('Arcs with nesting errors: %s' % unique_nest_errors)\n        story_tree = story_root.get_descendants().prefetch_related('arcelementnode_set')\n        if arcs_out_of_sequence:\n            error_dict['nest_arc_seq'] = {\n                'error_message': \"Arc element milestones are out of sequence\",\n                'offending_arcs': []\n            }\n            logger.debug('There are %d arcs out of internal sequence' % len(arcs_out_of_sequence))\n            arc_sequence_error_dict = {}\n            story_root.refresh_from_db()\n            for arc in arcs_out_of_sequence:\n                arc_sequence_error_dict['offending_nodes'] = story_tree.filter(arcelementnode__arc=arc)\n            error_dict['nest_arc_seq']['offending_arcs'].append(arc_sequence_error_dict)\n        if unique_nest_errors:\n            error_dict['nest_reso_error'] = {\n                'error_message': \"Arcs should resolve in the opposite order that they were introduced\",\n                'offending_nodes': story_tree.filter(\n                    arcelementnode__arc__in=unique_nest_errors,\n                    arcelementnode__arc_element_type='mile_reso'\n                )\n            }\n        return error_dict", "response": "Validate that all arc - level elements in the story tree are nested appropriately."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngenerates a seven point template in this arc.", "response": "def generate_template_arc_tree(self):\n        '''\n        Generate a seven point template in this arc. Arc must be empty.\n        '''\n        arc_root = self.arc_root_node\n        if not arc_root:\n            arc_root = ArcElementNode.add_root(\n                arc_element_type='root',\n                description='root of arc %s' % self.name,\n                arc=self\n            )\n        if arc_root.get_children():\n            raise ArcIntegrityError(_(\"This arc already has elements. You cannot build a template on top of it\"))\n        for key, value in ARC_NODE_ELEMENT_DEFINITIONS.items():\n            if value['milestone']:\n                arc_root.add_child(arc_element_type=key, description=value['template_description'])\n                arc_root.refresh_from_db()\n        return ArcElementNode.objects.get(pk=arc_root.pk).get_children().count()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef fetch_arc_errors(self):\n        '''\n        Evaluates the current tree of the arc and provides a list of errors that\n        the user should correct.\n        '''\n        error_list = []\n        hnode = self.validate_first_element()\n        if hnode:\n            error_list.append({'hook_error': hnode})\n        rnode = self.validate_last_element()\n        if rnode:\n            error_list.append({'reso_error': rnode})\n        try:\n            self.validate_generations()\n        except ArcGenerationError as ag:\n            error_list.append({'generation_error': str(ag)})\n        milecheck = self.validate_milestones()\n        if milecheck:\n            error_list.append({'mseq_error': milecheck})\n        return error_list", "response": "Evaluates the current tree of the arc and provides a list of errors that the user should correct."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef validate_generations(self):\n        '''\n        Make sure that the descendent depth is valid.\n        '''\n        nodes = self.arc_root_node.get_descendants()\n        for node in nodes:\n            logger.debug(\"Checking parent for node of type %s\" % node.arc_element_type)\n            parent = ArcElementNode.objects.get(pk=node.pk).get_parent(update=True)\n            if 'mile' in node.arc_element_type and parent.get_depth() > 1:\n                logger.debug(\"Milestone node... with leaf parent\")\n                raise ArcGenerationError(_(\"Milestones cannot be descendants of anything besides the root!\"))\n            if (parent.get_depth() > 1 and\n                parent.arc_element_type not in ARC_NODE_ELEMENT_DEFINITIONS[node.arc_element_type]['allowed_parents']):\n                raise ArcGenerationError(_(\"Node %s cannot be a descendant of node %s\" % (node, parent)))\n        return None", "response": "Validate that the descendent depth is valid."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreviewing the arc element tree to ensure that milestones appear in the right order. Returns None if no milestones are found.", "response": "def validate_milestones(self):\n        '''\n        Reviews the arc element tree to ensure that milestones appear in the right\n        order.\n        '''\n        milestones = self.arc_root_node.get_children().filter(arc_element_type__contains='mile')\n        current_cursor = 0\n        for mile in milestones:\n            seq = mile.milestone_seq\n            if seq < current_cursor:\n                return mile\n            current_cursor = seq\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\noverride the default treebeard function adding additional integrity checks.", "response": "def add_child(self, arc_element_type, description=None, story_element_node=None, **kwargs):\n        '''\n        Overrides the default `treebeard` function, adding additional integrity checks.\n        '''\n        if 'mile' in arc_element_type:\n            if 'mile' in self.arc_element_type:\n                raise ArcGenerationError('You cannot have a milestone as a child to another milestone.')\n            if self.get_depth() == 1:\n                nodes_to_check = self.get_descendants().filter(arc_element_type__icontains='mile')\n            else:\n                nodes_to_check = self.get_root().get_descendants().filter(arc_element_type__icontains='mile')\n            for node in nodes_to_check:\n                if node.arc_element_type == arc_element_type:\n                    raise ArcIntegrityError('You cannot have two of the same milestone in the same arc.')\n        return super().add_child(\n            arc=self.arc,\n            arc_element_type=arc_element_type,\n            description=description,\n            story_element_node=story_element_node\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\noverriding the default treebeard function adding additional integrity checks.", "response": "def add_sibling(self, pos=None, arc_element_type=None, description=None, story_element_node=None, **kwargs):\n        '''\n        Overrides the default `treebeard` function, adding additional integrity checks.\n        '''\n        if 'mile' in arc_element_type:\n            if self.get_depth() == 1:\n                raise ArcGenerationError('Milestones are invalid to be the root')\n            nodes_to_check = self.get_root().get_descendants().filter(arc_element_type__icontains='mile')\n            for node in nodes_to_check:\n                if node.arc_element_type == arc_element_type:\n                    raise ArcIntegrityError('You cannot have two of the same milestone in the same arc.')\n        return super().add_sibling(\n            pos=pos,\n            arc=self.arc,\n            arc_element_type=arc_element_type,\n            description=description,\n            story_element_node=story_element_node\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a queryset of all characters associated with this node and its descendants excluding any duplicates.", "response": "def all_characters(self):\n        '''\n        Returns a queryset of all characters associated with this node and its descendants,\n        excluding any duplicates.\n        '''\n        qs = self.assoc_characters.all()\n        for node in self.get_descendants():\n            qs2 = node.assoc_characters.all()\n            qs = qs.union(qs2).distinct('pk')\n        return qs"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the impact rating for this node.", "response": "def impact_rating(self):\n        '''\n        Returns the impact rating for this node. Impact rating is a measure\n        of how powerful this moment in the story is by evaluting how many simultaneous\n        arc elements are associated with it. There is also a generational bleed element,\n        where the impact score creates shockwaves throughout their direct ancestor and\n        descendant nodes. This echo fades fast, but the bigger the impact, the farther\n        it goes.\n\n        Currently, the impact bleed does not extend to sibling nodes.\n\n        WARNING: Here be dragons.\n        '''\n        if self.depth == 1:\n            logger.debug('Root node. Skipping.')\n            return 0  # pragma: no cover\n        impact_bleed = {\n            'mile': 0.5,  # A milestone extends it's influence by 50% per generation\n            'tf_beat': 0.25,\n        }\n        inherited_impact = 0\n        base_impact, add_impact, mile_impact = self._local_impact_rating()\n        local_impact = base_impact + add_impact + mile_impact\n        logger.debug(\"Local impact is %f\" % local_impact)\n        parents = self.get_ancestors().filter(depth__gt=1)\n        children = self.get_descendants()\n        logger.debug('Found %d parents and %d children' % (parents.count(), children.count()))\n        for node in parents | children:\n            if node.depth == 1:\n                logger.debug(\"Skipping root node...\")\n            else:\n                logger.debug('Checking a related node...')\n                b, a, m = node._local_impact_rating()\n                logger.debug('Related node has %f of additional impact and %f of milestone impact.' % (a, m))\n                if (a + m) > 0:\n                    if node.depth > self.depth:\n                        depth_diff = node.depth - self.depth\n                    else:\n                        depth_diff = self.depth - node.depth\n                    logger.debug('There is a generational difference of %f. Adjusting impact bleed.' % depth_diff)\n                    for x in range(depth_diff):\n                        a = a * impact_bleed['tf_beat']\n                        m = m * impact_bleed['mile']\n                    logger.debug('Additional impact bleed of %f. Milestone impact bleed of %f' % (a, m))\n                    inherited_impact += a + m\n                    logger.debug('Final impact bleed of %f. Adding to inherited impact.' % inherited_impact)\n                else:\n                    logger.debug('Node had 0 bleedworthy impact. Skipping...')\n        logger.debug('Inherited impact of %f. Adding to local impact of %f' % (inherited_impact, local_impact))\n        return local_impact + inherited_impact"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _local_impact_rating(self):\n        '''\n        Traverses the generations to evaluate the impact/power\n        of the arc elements associated with each node.\n        '''\n        impact_values = {\n            'base': 0.5,\n            'mile': 2,\n            'beat': 0.5,\n            'tf': 0.5,\n            'mile_child': 0.5,\n            'same_mile': 2.5,\n        }\n        base_impact = impact_values['base']\n        mile_impact = 0\n        add_impact = 0\n        direct_arc_nodes = self.arcelementnode_set.all()\n        logger.debug('Found %d associated arc nodes...' % direct_arc_nodes.count())\n        arc_element_types = {}\n        logger.debug('Preloading arc element types...')\n        for type_name, values in ARC_NODE_ELEMENT_DEFINITIONS.items():\n            arc_element_types[type_name] = 0\n        for node in direct_arc_nodes:\n            arc_element_types[node.arc_element_type] += 1\n            logger.debug('Found an node of type %s' % node.arc_element_type)\n            if ARC_NODE_ELEMENT_DEFINITIONS[node.arc_element_type]['milestone']:\n                logger.debug('node is a milestone of type %s. Adding bonus' % node.arc_element_type)\n                mile_impact += impact_values['mile']\n            else:\n                logger.debug('Checking node parent.')\n                parent_type = node.get_parent().arc_element_type\n                logger.debug('Direct parent is of type %s' % parent_type)\n                if ARC_NODE_ELEMENT_DEFINITIONS[node.get_parent().arc_element_type]['milestone']:\n                    logger.debug('Impact calc: adding a bonus for being direct child of milestone.')\n                    add_impact += impact_values['mile_child']\n                if node.arc_element_type == 'beat':\n                    logger.debug('Adding impact for beat.')\n                    add_impact += impact_values['beat']\n                if node.arc_element_type == 'tf':\n                    add_impact += impact_values['tf']\n        for key, value in arc_element_types.items():\n            if ARC_NODE_ELEMENT_DEFINITIONS[key]['milestone'] and value > 1:\n                logger.debug('Adding bonus for same milestone.')\n                add_impact += (value - 1) * .5\n        return base_impact, add_impact, mile_impact", "response": "Calculates the local impact rating for each arc element."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef all_locations(self):\n        '''\n        Returns a queryset of all locations associated with this node and its descendants,\n        excluding any duplicates.\n        '''\n        qs = self.assoc_locations.all()\n        for node in self.get_descendants():\n            qs2 = node.assoc_locations.all()\n            qs = qs.union(qs2).distinct('pk')\n        return qs", "response": "Returns a queryset of all locations associated with this node and its descendants excluding any duplicates."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nmove the element to the target node.", "response": "def move(self, target, pos=None):\n        '''\n        An override of the treebeard api in order to send a signal in advance.\n        '''\n        if self.outline != target.outline:\n            raise IntegrityError('Elements must be from the same outline!')\n        tree_manipulation.send(\n            sender=self.__class__,\n            instance=self,\n            action='move',\n            target_node_type=None,\n            target_node=target,\n            pos=pos\n        )\n        return super().move(target, pos)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding a child to the tree.", "response": "def add_child(self, story_element_type=None, outline=None, name=None, description=None, **kwargs):\n        '''\n        An override of the treebeard add_child() method so we can send a signal.\n        '''\n        if not outline:\n            outline = self.outline\n        if outline != self.outline:\n            raise IntegrityError('Elements must be from the same outline!')\n        tree_manipulation.send(\n            sender=self.__class__,\n            instance=self,\n            action='add_child',\n            target_node_type=story_element_type,\n            target_node=None,\n            pos=None\n        )\n        return super().add_child(\n            story_element_type=story_element_type,\n            outline=outline,\n            name=name,\n            description=description,\n            **kwargs\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef topics(self):\n        topics = self.interface.publishers.copy()\n        topics.update(self.interface.subscribers)\n        return topics", "response": "returns the list of topics we are interfaced with"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef setup(self, publishers=None, subscribers=None, services=None, topics=None, params=None):\n        super(PyrosMock, self).setup(publishers=publishers, subscribers=subscribers, services=services, topics=topics, params=params)", "response": "Sets up the object."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting bitlove data for a list of enclosure URLs", "response": "def get_by_enclosures(self, enclosure_urls):\n        \"\"\" Get bitlove data for a list of enclosure URLs \"\"\"\n\n        # prepare URLs\n        enclosure_urls = map(str.strip, enclosure_urls)\n        enclosure_urls = filter(None, enclosure_urls)\n\n        return BitloveResponse(self.opener, enclosure_urls)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the response for the given enclosure URL", "response": "def get(self, url):\n        \"\"\" Get the response for the given enclosure URL \"\"\"\n        self._query()\n        return Enclosure(self._resp.get(url), url)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _query(self):\n\n        if not self.urls:\n            self._resp = {}\n\n        elif self._resp is None:\n            params = [ ('url', url) for url in self.urls]\n            query = urllib.urlencode(params)\n\n            # query API\n            r = self.opener.open(BITLOVE_ENCLOSURE_API + query)\n            self._resp = json.loads(r.read())", "response": "perform a request to the API only when necessary"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nbuilds a command - line arguments parser.", "response": "def _build_parser():\n    \"\"\"\n    Return a command-line arguments parser.\n    \"\"\"\n    parser = argparse.ArgumentParser(description='Search you Azure AD contacts from mutt or the command-line.')\n    parser.add_argument('-c', '--config', help='Specify alternative configuration file.', metavar=\"FILE\")\n    parser.add_argument('-v', '--verbose', dest=\"log_level\", action='store_const',\n                        const=logging.INFO, help='Be verbose about what is going on (stderr).')\n    parser.add_argument('-V', '--version',\n                        action='version',\n                        version='%%(prog)s %s' % pkg_resources.get_distribution(\"aadbook\").version,\n                        help=\"Print version and exit\")\n    parser.add_argument('-d', '--debug', dest=\"log_level\", action='store_const',\n                        const=logging.DEBUG, help='Output debug info (stderr).')\n    parser.set_defaults(config=CONFIG_FILE, log_level=logging.ERROR)\n\n    subparsers = parser.add_subparsers()\n\n    parser_config_template = subparsers.add_parser('config-template',\n                                                   description='Prints a template for .aadbookrc to stdout')\n    parser_config_template.set_defaults(func=do_config_template)\n\n    parser_reload = subparsers.add_parser('authenticate',\n                                          description='Azure AD authentication.')\n    parser_reload.set_defaults(func=do_authenticate)\n\n    parser_reload = subparsers.add_parser('reload',\n                                          description='Force reload of the cache.')\n    parser_reload.set_defaults(func=do_reload)\n\n    parser_query = subparsers.add_parser('query',\n                                         description='Search contacts using query (regex).')\n    parser_query.add_argument('query', help='regex to search for.', metavar='QUERY')\n    parser_query.set_defaults(func=do_query)\n\n    return parser"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef find_packages_under(path):\n    all_packages = setuptools.find_packages()\n    packages = []\n    for package in all_packages:\n        package_split = package.split(\".\")\n        if package_split[0] == path:\n            packages.append(package)\n    return packages", "response": "Recursive list all of the packages under a specific package."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef copy_version_to_package(path):\n    init_file = os.path.join(path, \"__init__.py\")\n    with open(init_file, \"r\") as original_file:\n        lines = original_file.readlines()\n\n    with open(init_file, \"w\") as new_file:\n        for line in lines:\n            if \"__version__\" not in line:\n                new_file.write(line)\n            else:\n                new_file.write(\"__version__ = \\\"{}\\\"\\n\".format(VERSION))", "response": "Copy the single source of truth version number into the package."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef validate(self):\n\n        if not self.server.enabled:\n\n            if self.security.signature_certificate_file is self.security.defaults['signature_certificate_file']:\n                print(\"ISSUE: If you are not configuring a server, you need to set 'signature_certificate_file'\")\n\n            if self.security.signature_private_key_file is self.security.defaults['signature_private_key_file']:\n                print(\"ISSUE: If you are not configuring a server, you need to set 'signature_private_key_file'\")\n\n        else:\n\n            if self.client.enabled:\n                print(\"ISSUE: Client and server enabled at the same time?\")\n\n            if self.server.protocol is self.server.defaults['protocol']:\n                if self.server.server_certificate_file is self.server.defaults['server_certificate_file'] or \\\n                                self.server.server_private_key_file is self.server.defaults['server_private_key_file']:\n                   print(\"ISSUE: 'server_certificate_file' and/or 'server_private_key_file' are not configured and will be auto-generated.\")\n\n\n            if self.server.certification_authority_certificate_file is self.server.defaults['certification_authority_certificate_file'] or \\\n                            self.server.certification_authority_private_key_file is self.server.defaults['certification_authority_private_key_file']:\n                print(\"ISSUE: 'certification_authority_certificate_file' and/or 'certification_authority_private_key_file' are not configured and will be auto-generated - this is NOT recommended.\")\n\n            if self.server.authentication_script is self.server.defaults['authentication_script']:\n                print(\"ISSUE: No 'authentication_script' has been provided and all authentication requests will be rejected!\")\n\n        if self.client.enabled:\n\n            if self.client.server_endpoint is self.client.defaults['server_endpoint']:\n                print(\"ISSUE: You are running in client mode, but you are using a default server address.\")\n\n            if not self.client.disable_peer_verification is self.client.defaults['disable_peer_verification'] or \\\n                    not self.client.disable_host_verification is self.client.defaults['disable_host_verification']:\n                print(\"ISSUE: Disabling peer/host verification is NOT recommended - AT ALL.\")\n\n            if self.client.username is self.client.defaults['username'] or \\\n                            self.client.password is self.client.defaults['password']:\n                print(\"ISSUE: No username and/or password has been configured for a client.\")\n\n        if self.fscp.contact is self.fscp.defaults['contact']:\n\n            if not self.server.enabled and not self.client.enabled:\n                print(\"ISSUE: You have not defined any contact points while you are neither running as server nor client.\")\n\n        ## hostname_resolution_protocol=ipv4/ipv6\n        ## ipv4_address_prefix_length=9.0.0.1/24\n        ## ipv6_address_prefix_length=2aa1::1/8\n\n        if self.security.authority_certificate_file is self.security.defaults['authority_certificate_file']:\n            print(\"ISSUE: You need to set 'authority_certificate_file'\")\n\n        if self.tap_adapter.ipv4_address_prefix_length is self.tap_adapter.defaults['ipv4_address_prefix_length']:\n            print(\"ISSUE: You are using the default network address - make sure you set a different ip for every machine 'ipv4_address_prefix_length'\")", "response": "Validate the configuration of the current class."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncalls on app initialization to register administration interface.", "response": "def register_admin(app, admin):\n    \"\"\"Called on app initialization to register administration interface.\"\"\"\n    category = 'Knowledge'\n    admin.category_icon_classes[category] = \"fa fa-mortar-board\"\n    admin.add_view(\n        KnowledgeAdmin(app, KnwKB, db.session,\n                       name='Knowledge Base', category=category,\n                       endpoint=\"kb\")\n    )\n    admin.add_view(\n        KnwKBRVALAdmin(app, KnwKBRVAL, db.session,\n                       name=\"Knowledge Mappings\", category=category,\n                       endpoint=\"kbrval\")\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef connect(self):\n        self._client = Telnet(self.hostname, self.port)\n        self.closed = False\n        query = {\n            \"MPRPC\": self.VERSION,\n            \"AUTH\": {\n                \"USERNAME\": self.username,\n                \"PASSWORD\": self.password\n            }\n        }\n        queryb = self.encoder(query)\n        if self.debug is True:\n            print(\"send auth {}\".format(queryb))\n        self._client.write(queryb)\n        self.remote_info = self._responsehandler()", "response": "Connect to the Telnet server."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef reconnect(self):\n        self.closed = True\n        self.connect()\n        if self.debug:\n            print(\"reconnect to {}\".format((self.hostname, self.port)))", "response": "reconnect to the server"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nclosing the connection to the AMI", "response": "def close(self):\n        \"\"\"\u5173\u95ed\u4e0e\u8fdc\u7aef\u7684\u8fde\u63a5.\n\n        \u5224\u65ad\u6807\u5fd7\u4f4dclosed\u662f\u5426\u4e3aFalse,\u5982\u679c\u662f\u5219\u5173\u95ed,\u5426\u5219\u4e0d\u8fdb\u884c\u64cd\u4f5c\n\n        \"\"\"\n        if self.closed is False:\n            self._client.close()\n            self.closed = True\n            if self.debug is True:\n                print('close')\n        if self.debug is True:\n            print(\"closed\")"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nchecks if the status code of the current user is in the cache.", "response": "def _status_code_check(self, response: Dict[str, Any]):\n        \"\"\"\u68c0\u67e5\u54cd\u5e94\u7801\u5e76\u8fdb\u884c\u5bf9\u4e0d\u540c\u7684\u54cd\u5e94\u8fdb\u884c\u5904\u7406.\n\n        \u4e3b\u8981\u5305\u62ec:\n        + \u7f16\u7801\u5728500~599\u6bb5\u4e3a\u670d\u52a1\u5f02\u5e38,\u76f4\u63a5\u629b\u51fa\u5bf9\u5e94\u5f02\u5e38\n        + \u7f16\u7801\u5728400~499\u6bb5\u4e3a\u8c03\u7528\u5f02\u5e38,\u4e3a\u5bf9\u5e94ID\u7684future\u8bbe\u7f6e\u5f02\u5e38\n        + \u7f16\u7801\u5728300~399\u6bb5\u4e3a\u8b66\u544a,\u4f1a\u629b\u51fa\u5bf9\u5e94\u8b66\u544a\n        + \u7f16\u7801\u5728200~399\u6bb5\u4e3a\u6267\u884c\u6210\u529f\u54cd\u5e94,\u5c06\u7ed3\u679c\u8bbe\u7f6e\u7ed9\u5bf9\u5e94ID\u7684future.\n        + \u7f16\u7801\u5728100~199\u6bb5\u4e3a\u670d\u52a1\u5668\u54cd\u5e94,\u4e3b\u8981\u662f\u5904\u7406\u9a8c\u8bc1\u54cd\u5e94\u548c\u5fc3\u8df3\u54cd\u5e94\n\n        Parameters:\n            response (Dict[str, Any]): - \u54cd\u5e94\u7684python\u5b57\u5178\u5f62\u5f0f\u6570\u636e\n\n        Return:\n            (bool): - \u5982\u679c\u662f\u975e\u670d\u52a1\u5f02\u5e38\u7c7b\u7684\u54cd\u5e94,\u90a3\u4e48\u8fd4\u56deTrue\n\n        \"\"\"\n        code = response.get(\"CODE\")\n        if self.debug:\n            print(\"resv:{}\".format(response))\n            print(code)\n\n        if code >= 500:\n            if self.debug:\n                print(\"server error\")\n            return self._server_error_handler(code)\n\n        elif 500 > code >= 400:\n            if self.debug:\n                print(\"call method error\")\n            return self._method_error_handler(response)\n\n        elif 400 > code >= 200:\n            if code >= 300:\n                self._warning_handler(code)\n            if code in (200, 201, 202, 206, 300, 301):\n                if self.debug is True:\n                    print(\"resv resp {}\".format(response))\n                return self._method_response_handler(response)\n\n        elif 200 > code >= 100:\n            return self._server_response_handler(response)\n        else:\n            raise MprpcException(\"unknow status code {}\".format(code))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nhandling a warning code.", "response": "def _warning_handler(self, code: int):\n        \"\"\"\u5904\u7406300~399\u6bb5\u72b6\u6001\u7801,\u629b\u51fa\u5bf9\u5e94\u8b66\u544a.\n\n        Parameters:\n            (code): - \u54cd\u5e94\u7684\u72b6\u6001\u7801\n\n        Return:\n            (bool): - \u5df2\u77e5\u7684\u8b66\u544a\u7c7b\u578b\u5219\u8fd4\u56deTrue,\u5426\u5219\u8fd4\u56deFalse\n\n        \"\"\"\n        if code == 300:\n            warnings.warn(\n                \"ExpireWarning\",\n                RuntimeWarning,\n                stacklevel=3\n            )\n        elif code == 301:\n            warnings.warn(\n                \"ExpireStreamWarning\",\n                RuntimeWarning,\n                stacklevel=3\n            )\n        else:\n            if self.debug:\n                print(\"unknow code {}\".format(code))\n            return False\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nhandles the result of a request.", "response": "def _result_handler(self, response: Dict[str, Any]):\n        \"\"\"\u5e94\u7b54\u7ed3\u679c\u54cd\u5e94\u5904\u7406.\n\n        \u5c06\u7ed3\u679c\u89e3\u6790\u51fa\u6765\u8bbe\u7f6e\u7ed9\u4efb\u52a1\u5bf9\u5e94\u7684Future\u5bf9\u8c61\u4e0a\n\n        Parameters:\n            (response): - \u54cd\u5e94\u7684python\u5b57\u5178\u5f62\u5f0f\u6570\u636e\n\n        Return:\n            (bool): - \u51c6\u786e\u5730\u8bf4\u6ca1\u6709\u9519\u8bef\u5c31\u4f1a\u8fd4\u56deTrue\n\n        \"\"\"\n        res = response.get(\"MESSAGE\")\n        result = res.get(\"RESULT\")\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _make_query(self, ID: str, methodname: str, *args: Any, **kwargs: Any):\n        query = {\n            \"MPRPC\": self.VERSION,\n            \"ID\": ID,\n            \"METHOD\": methodname,\n            \"RETURN\": True,\n            \"ARGS\": args,\n            \"KWARGS\": kwargs\n        }\n        print(query)\n        return query", "response": "Make a query to get the current state of the object."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _send_query(self, query: Dict[str, Any]):\n        queryb = self.encoder(query)\n        self._client.write(queryb)\n        if self.debug is True:\n            print(\"send query {}\".format(queryb))\n\n        return True", "response": "Send a query to the server."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsending a query to the specified resource.", "response": "def send_query(self, ID, methodname, *args, **kwargs):\n        \"\"\"\u5c06\u8c03\u7528\u8bf7\u6c42\u7684ID,\u65b9\u6cd5\u540d,\u53c2\u6570\u5305\u88c5\u4e3a\u8bf7\u6c42\u6570\u636e\u540e\u7f16\u7801\u4e3a\u5b57\u8282\u4e32\u53d1\u9001\u51fa\u53bb.\n\n        Parameters:\n            ID (str): - \u4efb\u52a1ID\n            methodname (str): - \u8981\u8c03\u7528\u7684\u65b9\u6cd5\u540d\n            args (Any): - \u8981\u8c03\u7528\u7684\u65b9\u6cd5\u7684\u4f4d\u7f6e\u53c2\u6570\n            kwargs (Any): - \u8981\u8c03\u7528\u7684\u65b9\u6cd5\u7684\u5173\u952e\u5b57\u53c2\u6570\n\n        Return:\n\n            (bool): - \u51c6\u786e\u5730\u8bf4\u6ca1\u6709\u9519\u8bef\u5c31\u4f1a\u8fd4\u56deTrue\n\n        \"\"\"\n        query = self._make_query(ID, methodname, *args, **kwargs)\n        self._send_query(query)\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nquery the cache for a specific object.", "response": "def _query(self, ID, methodname, *args, **kwargs):\n        \"\"\"\u5c06\u8c03\u7528\u8bf7\u6c42\u7684ID,\u65b9\u6cd5\u540d,\u53c2\u6570\u5305\u88c5\u4e3a\u8bf7\u6c42\u6570\u636e\u540e\u7f16\u7801\u4e3a\u5b57\u8282\u4e32\u53d1\u9001\u51fa\u53bb.\u5e76\u521b\u5efa\u4e00\u4e2aFuture\u5bf9\u8c61\u5360\u4f4d.\n\n        Parameters:\n            ID (str): - \u4efb\u52a1ID\n            methodname (str): - \u8981\u8c03\u7528\u7684\u65b9\u6cd5\u540d\n            args (Any): - \u8981\u8c03\u7528\u7684\u65b9\u6cd5\u7684\u4f4d\u7f6e\u53c2\u6570\n            kwargs (Any): - \u8981\u8c03\u7528\u7684\u65b9\u6cd5\u7684\u5173\u952e\u5b57\u53c2\u6570\n\n        Return:\n\n            (asyncio.Future): - \u8fd4\u56de\u5bf9\u5e94ID\u7684Future\u5bf9\u8c61\n\n        \"\"\"\n        self.send_query(ID, methodname, *args, **kwargs)\n        result = self._responsehandler()\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nquery the cache for a specific object.", "response": "def query(self, methodname, *args, **kwargs):\n        \"\"\"\u5f02\u6b65\u8c03\u7528\u4e00\u4e2a\u8fdc\u7aef\u7684\u51fd\u6570.\n\n        \u4e3a\u8c03\u7528\u521b\u5efa\u4e00\u4e2aID,\u5e76\u5c06\u8c03\u7528\u8bf7\u6c42\u7684\u65b9\u6cd5\u540d,\u53c2\u6570\u5305\u88c5\u4e3a\u8bf7\u6c42\u6570\u636e\u540e\u7f16\u7801\u4e3a\u5b57\u8282\u4e32\u53d1\u9001\u51fa\u53bb.\u5e76\u521b\u5efa\u4e00\u4e2aFuture\u5bf9\u8c61\u5360\u4f4d.\n\n        Parameters:\n            methodname (str): - \u8981\u8c03\u7528\u7684\u65b9\u6cd5\u540d\n            args (Any): - \u8981\u8c03\u7528\u7684\u65b9\u6cd5\u7684\u4f4d\u7f6e\u53c2\u6570\n            kwargs (Any): - \u8981\u8c03\u7528\u7684\u65b9\u6cd5\u7684\u5173\u952e\u5b57\u53c2\u6570\n\n        Return:\n            (asyncio.Future): - \u8fd4\u56de\u5bf9\u5e94ID\u7684Future\u5bf9\u8c61\n\n        \"\"\"\n        ID = str(uuid.uuid4())\n        result = self._query(ID=ID, methodname=methodname, *args, **kwargs)\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ndrills down into tree using the keys", "response": "def _deep_value(*args, **kwargs):\n    \"\"\" Drills down into tree using the keys\n    \"\"\"\n    node, keys = args[0], args[1:]\n    for key in keys:\n        node = node.get(key, {})\n    default = kwargs.get('default', {})\n    if node in ({}, [], None):\n        node = default\n    return node"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nparse the location of the entry as a GeoJSON. Point.", "response": "def _parse_location(self, entry):\n        \"\"\"\n        Return the **first** location as `geojson.Point`.\n        \"\"\"\n        locations = _deep_value_list(entry, 'tif:Geolocalisations')\n        coords = []\n        for location in locations:\n            coords = _deep_value(location, 'tif:DetailGeolocalisation',\n                                           'tif:Zone',\n                                           'tif:Points',\n                                           'tif:DetailPoint',\n                                           'tif:Coordonnees',\n                                           'tif:DetailCoordonnees')\n            if 'tif:Latitude' not in coords:\n                continue\n            lat = float(coords.get('tif:Latitude', 0))\n            lng = float(coords.get('tif:Longitude', 0))\n            altitude = float(coords.get('tif:Altitude', 0))\n            coords = [lng, lat, altitude]\n            return geojson.Point(coords)\n\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _get_dict_default(obj, key):\n    try:\n        return obj[key]\n    except Exception as f:\n        pass\n\n    try:\n        if float(key) == round(float(key), 0):\n            return obj[int(key)]\n    except Exception as f:\n        pass\n\n    return NullType(obj, key)", "response": "Get the default value of a dict."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef listwrap(value):\n    if value == None:\n        return FlatList()\n    elif is_list(value):\n        return wrap(value)\n    elif is_many(value):\n        return wrap(list(value))\n    else:\n        return wrap([unwrap(value)])", "response": "A list - of - values wrapper for the passed in value."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef tuplewrap(value):\n    if is_many(value):\n        return tuple(tuplewrap(v) if is_sequence(v) else v for v in value)\n    return unwrap(value),", "response": "Wraps a list into a tuple."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nload a Python object from a Pickle file.", "response": "def load_pk(abspath, compress=False, enable_verbose=True):\n    \"\"\"Load Python Object from Pickle file.\n\n    :param abspath: File path. Use absolute path as much as you can. File\n        extension has to be ``.pickle`` or ``.gz``. (for compressed Pickle)\n    :type abspath: string\n\n    :param compress: (default False) Load from a gzip compressed Pickle file.\n        Check :func:`dump_pk()<dump_pk>` function for more information.\n    :type compress: boolean\n\n    :param enable_verbose: (default True) Trigger for message.\n    :type enable_verbose: boolean\n\n    Usage::\n\n        >>> from weatherlab.lib.dataIO.pk import load_pk\n        >>> load_pk(\"test.pickle\") # if you have a Pickle file\n        Loading from test.pickle...\n            Complete! Elapse 0.000272 sec.\n        {'a': 1, 'b': 2}\n\n    **\u4e2d\u6587\u6587\u6863**\n\n    \u4ecePickle\u6587\u4ef6\u4e2d\u8bfb\u53d6\u6570\u636e\n\n    \u53c2\u6570\u5217\u8868\n\n    :param abspath: \u6587\u4ef6\u8def\u5f84, \u6269\u5c55\u540d\u9700\u4e3a ``.pickle`` \u6216 ``.gz``\n    :type abspath: ``\u5b57\u7b26\u4e32``\n\n    :param compress: (\u9ed8\u8ba4 False) \u662f\u5426\u4ece\u4e00\u4e2agzip\u538b\u7f29\u8fc7\u7684Pickle\u6587\u4ef6\u4e2d\u8bfb\u53d6\u6570\u636e\u3002 \u8bf7\n        \u53c2\u8003 :func:`dump_pk()<dump_pk>` \u83b7\u5f97\u66f4\u591a\u4fe1\u606f.\n    :type compress: ``\u5e03\u5c14\u503c``\n\n    :param enable_verbose: (\u9ed8\u8ba4 True) \u662f\u5426\u6253\u5f00\u4fe1\u606f\u63d0\u793a\u5f00\u5173, \u6279\u5904\u7406\u65f6\u5efa\u8bae\u5173\u95ed.\n    :type enable_verbose: ``\u5e03\u5c14\u503c``\n    \"\"\"\n    abspath = str(abspath)  # try stringlize\n\n    msg = Messenger(enable_verbose=enable_verbose)\n\n    if compress:  # check extension name\n        if os.path.splitext(abspath)[1] != \".gz\":\n            raise Exception(\"compressed pickle has to use extension '.gz'!\")\n    else:\n        if os.path.splitext(abspath)[1] != \".pickle\":\n            raise Exception(\"file extension are not '.pickle'!\")\n\n    msg.show(\"\\nLoading from %s...\" % abspath)\n    st = time.clock()\n\n    if compress:\n        with gzip.open(abspath, \"rb\") as f:\n            obj = pickle.loads(f.read())\n    else:\n        with open(abspath, \"rb\") as f:\n            obj = pickle.load(f)\n\n    if enable_verbose:\n        msg.show(\"    Complete! Elapse %.6f sec\" % (time.clock() - st))\n\n    return obj"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef dump_pk(obj, abspath,\n            pk_protocol=pk_protocol, replace=False, compress=False,\n            enable_verbose=True):\n    \"\"\"Dump Picklable Python Object to file.\n    Provides multiple choice to customize the behavior.\n\n    :param obj: Picklable Python Object.\n\n    :param abspath: ``save as`` path, file extension has to be ``.pickle`` or\n        ``.gz`` (for compressed Pickle).\n    :type abspath: string\n\n    :param pk_protocol: (default your python version) use 2, to make a\n        py2.x/3.x compatible pickle file. But 3 is faster.\n    :type pk_protocol: int\n\n    :param replace: (default False) If ``True``, when you dump Pickle to a\n        existing path, it silently overwrite it. If False, an exception will be\n        raised. Default False setting is to prevent overwrite file by mistake.\n    :type replace: boolean\n\n    :param compress: (default False) If ``True``, use GNU program gzip to\n        compress the Pickle file. Disk usage can be greatly reduced. But you\n        have to use :func:`load_pk(abspath, compress=True)<load_pk>` in loading.\n    :type compress: boolean\n\n    :param enable_verbose: (default True) Trigger for message.\n    :type enable_verbose: boolean\n\n    Usage::\n\n        >>> from weatherlab.lib.dataIO.pk import dump_pk\n        >>> pk = {\"a\": 1, \"b\": 2}\n        >>> dump_pk(pk, \"test.pickle\", replace=True)\n        Dumping to test.pickle...\n            Complete! Elapse 0.001763 sec\n\n    **\u4e2d\u6587\u6587\u6863**\n\n    \u5c06Python\u5bf9\u8c61\u4ee5Pickle\u7684\u65b9\u5f0f\u5e8f\u5217\u5316, \u4fdd\u5b58\u81f3\u672c\u5730\u6587\u4ef6\u3002(\u6709\u4e9b\u81ea\u5b9a\u4e49\u7c7b\u65e0\u6cd5\u88ab\u5e8f\u5217\u5316)\n\n    \u53c2\u6570\u5217\u8868\n\n    :param obj: \u53efPickle\u5316\u7684Python\u5bf9\u8c61\n\n    :param abspath: \u5199\u5165\u6587\u4ef6\u7684\u8def\u5f84\u3002\u6269\u5c55\u540d\u5fc5\u987b\u4e3a ``.pickle`` \u6216 ``.gz``, \u5176\u4e2dgz\u7528\u4e8e\u88ab\u538b\n        \u7f29\u7684Pickle\n    :type abspath: ``\u5b57\u7b26\u4e32``\n\n    :param pk_protocol: (\u9ed8\u8ba4 \u7b49\u4e8e\u4f60Python\u7684\u5927\u7248\u672c\u53f7) \u4f7f\u75282\u53ef\u4ee5\u4f7f\u5f97\u4fdd\u5b58\u7684\u6587\u4ef6\u80fd\u88ab\n        py2.x/3.x\u90fd\u80fd\u8bfb\u53d6\u3002\u4f46\u662f\u534f\u8bae3\u7684\u901f\u5ea6\u66f4\u5feb, \u4f53\u79ef\u66f4\u5c0f, \u6027\u80fd\u66f4\u9ad8\u3002\n    :type pk_protocol: ``\u6574\u6570``\n\n    :param replace: (\u9ed8\u8ba4 False) \u5f53\u4e3a``True``\u65f6, \u5982\u679c\u5199\u5165\u8def\u5f84\u5df2\u7ecf\u5b58\u5728, \u5219\u4f1a\u81ea\u52a8\u8986\u76d6\n        \u539f\u6587\u4ef6\u3002\u800c\u4e3a``False``\u65f6, \u5219\u4f1a\u629b\u51fa\u5f02\u5e38\u3002\u9632\u6b62\u8bef\u64cd\u4f5c\u8986\u76d6\u6e90\u6587\u4ef6\u3002\n    :type replace: ``\u5e03\u5c14\u503c``\n\n    :param compress: (\u9ed8\u8ba4 False) \u5f53\u4e3a``True``\u65f6, \u4f7f\u7528\u5f00\u6e90\u538b\u7f29\u6807\u51c6gzip\u538b\u7f29Pickle\u6587\u4ef6\u3002\n        \u901a\u5e38\u80fd\u8ba9\u6587\u4ef6\u5927\u5c0f\u7f29\u5c0f10-20\u500d\u4e0d\u7b49\u3002\u5982\u8981\u8bfb\u53d6\u6587\u4ef6, \u5219\u9700\u8981\u4f7f\u7528\u51fd\u6570\n        :func:`load_pk(abspath, compress=True)<load_pk>`.\n    :type compress: ``\u5e03\u5c14\u503c``\n\n    :param enable_verbose: (\u9ed8\u8ba4 True) \u662f\u5426\u6253\u5f00\u4fe1\u606f\u63d0\u793a\u5f00\u5173, \u6279\u5904\u7406\u65f6\u5efa\u8bae\u5173\u95ed.\n    :type enable_verbose: ``\u5e03\u5c14\u503c``\n    \"\"\"\n    abspath = str(abspath)  # try stringlize\n\n    msg = Messenger(enable_verbose=enable_verbose)\n\n    if compress:  # check extension name\n        root, ext = os.path.splitext(abspath)\n        if ext != \".gz\":\n            if ext != \".tmp\":\n                raise Exception(\n                    \"compressed pickle has to use extension '.gz'!\")\n            else:\n                _, ext = os.path.splitext(root)\n                if ext != \".gz\":\n                    raise Exception(\n                        \"compressed pickle has to use extension '.gz'!\")\n    else:\n        root, ext = os.path.splitext(abspath)\n        if ext != \".pickle\":\n            if ext != \".tmp\":\n                raise Exception(\"file extension are not '.pickle'!\")\n            else:\n                _, ext = os.path.splitext(root)\n                if ext != \".pickle\":\n                    raise Exception(\"file extension are not '.pickle'!\")\n\n    msg.show(\"\\nDumping to %s...\" % abspath)\n    st = time.clock()\n\n    if os.path.exists(abspath):  # if exists, check replace option\n        if replace:  # replace existing file\n            if compress:\n                with gzip.open(abspath, \"wb\") as f:\n                    f.write(pickle.dumps(obj, protocol=pk_protocol))\n            else:\n                with open(abspath, \"wb\") as f:\n                    pickle.dump(obj, f, protocol=pk_protocol)\n        else:  # stop, print error message\n            raise Exception(\"\\tCANNOT WRITE to %s, \"\n                            \"it's already exists\" % abspath)\n    else:  # if not exists, just write to it\n        if compress:\n            with gzip.open(abspath, \"wb\") as f:\n                f.write(pickle.dumps(obj, protocol=pk_protocol))\n        else:\n            with open(abspath, \"wb\") as f:\n                pickle.dump(obj, f, protocol=pk_protocol)\n\n    msg.show(\"    Complete! Elapse %.6f sec\" % (time.clock() - st))", "response": "Dump Picklable Python Object to file."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef safe_dump_pk(obj, abspath, pk_protocol=pk_protocol, compress=False,\n                 enable_verbose=True):\n    \"\"\"A stable version of dump_pk, silently overwrite existing file.\n\n    When your program been interrupted, you lose nothing. Typically if your\n    program is interrupted by any reason, it only leaves a incomplete file.\n    If you use replace=True, then you also lose your old file.\n\n    So a bettr way is to:\n\n    1. dump pickle to a temp file.\n    2. when it's done, rename it to #abspath, overwrite the old one.\n\n    This way guarantee atomic write.\n\n    :param obj: Picklable Python Object.\n\n    :param abspath: ``save as`` path, file extension has to be ``.pickle`` or\n        ``.gz`` (for compressed Pickle).\n    :type abspath: string\n\n    :param pk_protocol: (default your python version) use 2, to make a\n        py2.x/3.x compatible pickle file. But 3 is faster.\n    :type pk_protocol: int\n\n    :param compress: (default False) If ``True``, use GNU program gzip to\n        compress the Pickle file. Disk usage can be greatly reduced. But you\n        have to use :func:`load_pk(abspath, compress=True)<load_pk>` in loading.\n    :type compress: boolean\n\n    :param enable_verbose: (default True) Trigger for message.\n    :type enable_verbose: boolean\n\n    Usage::\n\n        >>> from weatherlab.lib.dataIO.pk import safe_dump_pk\n        >>> pk = {\"a\": 1, \"b\": 2}\n        >>> safe_dump_pk(pk, \"test.pickle\")\n        Dumping to test.pickle...\n            Complete! Elapse 0.001763 sec\n\n    **\u4e2d\u6587\u6587\u6863**\n\n    \u5728\u5bf9\u6587\u4ef6\u8fdb\u884c\u5199\u5165\u65f6, \u5982\u679c\u7a0b\u5e8f\u4e2d\u65ad, \u5219\u4f1a\u7559\u4e0b\u4e00\u4e2a\u4e0d\u5b8c\u6574\u7684\u6587\u4ef6\u3002\u5982\u679c\u4f60\u4f7f\u7528\u4e86\u8986\u76d6\u5f0f\n    \u5199\u5165, \u5219\u4f60\u540c\u65f6\u4e5f\u4e22\u5931\u4e86\u539f\u6587\u4ef6\u3002\u6240\u4ee5\u4e3a\u4e86\u4fdd\u8bc1\u5199\u64cd\u4f5c\u7684\u539f\u5b50\u6027(\u8981\u4e48\u5168\u90e8\u5b8c\u6210, \u8981\u4e48\u5168\u90e8\n    \u90fd\u4e0d\u5b8c\u6210), \u66f4\u597d\u7684\u65b9\u6cd5\u662f: \u9996\u5148\u5c06\u6587\u4ef6\u5199\u5165\u4e00\u4e2a\u4e34\u65f6\u6587\u4ef6\u4e2d, \u5b8c\u6210\u540e\u518d\u8bb2\u6587\u4ef6\u91cd\u547d\u540d,\n    \u8986\u76d6\u65e7\u6587\u4ef6\u3002\u8fd9\u6837\u5373\u4f7f\u4e2d\u9014\u7a0b\u5e8f\u88ab\u4e2d\u65ad, \u4e5f\u4ec5\u4ec5\u662f\u7559\u4e0b\u4e86\u4e00\u4e2a\u672a\u5b8c\u6210\u7684\u4e34\u65f6\u6587\u4ef6\u800c\u5df2, \u4e0d\u4f1a\n    \u5f71\u54cd\u539f\u6587\u4ef6\u3002\n\n    \u53c2\u6570\u5217\u8868\n\n    :param obj: \u53efPickle\u5316\u7684Python\u5bf9\u8c61\n\n    :param abspath: \u5199\u5165\u6587\u4ef6\u7684\u8def\u5f84\u3002\u6269\u5c55\u540d\u5fc5\u987b\u4e3a ``.pickle`` \u6216 ``.gz`` , \u5176\u4e2dgz\u7528\u4e8e\u88ab\u538b\n        \u7f29\u7684Pickle\n    :type abspath: ``\u5b57\u7b26\u4e32``\n\n    :param pk_protocol: (\u9ed8\u8ba4 \u7b49\u4e8e\u4f60Python\u7684\u5927\u7248\u672c\u53f7) \u4f7f\u75282\u53ef\u4ee5\u4f7f\u5f97\u4fdd\u5b58\u7684\u6587\u4ef6\u80fd\u88ab\n        py2.x/3.x\u90fd\u80fd\u8bfb\u53d6\u3002\u4f46\u662f\u534f\u8bae3\u7684\u901f\u5ea6\u66f4\u5feb, \u4f53\u79ef\u66f4\u5c0f, \u6027\u80fd\u66f4\u9ad8\u3002\n    :type pk_protocol: ``\u6574\u6570``\n\n    :param compress: (\u9ed8\u8ba4 False) \u5f53\u4e3a ``True`` \u65f6, \u4f7f\u7528\u5f00\u6e90\u538b\u7f29\u6807\u51c6gzip\u538b\u7f29Pickle\u6587\u4ef6\u3002\n        \u901a\u5e38\u80fd\u8ba9\u6587\u4ef6\u5927\u5c0f\u7f29\u5c0f10-20\u500d\u4e0d\u7b49\u3002\u5982\u8981\u8bfb\u53d6\u6587\u4ef6, \u5219\u9700\u8981\u4f7f\u7528\u51fd\u6570\n        :func:`load_pk(abspath, compress=True)<load_pk>`.\n    :type compress: ``\u5e03\u5c14\u503c``\n\n    :param enable_verbose: (\u9ed8\u8ba4 True) \u662f\u5426\u6253\u5f00\u4fe1\u606f\u63d0\u793a\u5f00\u5173, \u6279\u5904\u7406\u65f6\u5efa\u8bae\u5173\u95ed.\n    :type enable_verbose: ``\u5e03\u5c14\u503c``\n    \"\"\"\n    abspath = str(abspath)  # try stringlize\n    temp_abspath = \"%s.tmp\" % abspath\n    dump_pk(obj, temp_abspath, pk_protocol=pk_protocol,\n            replace=True, compress=compress, enable_verbose=enable_verbose)\n    shutil.move(temp_abspath, abspath)", "response": "A stable version of dump_pk that will silently overwrite existing file."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconverting arbitrary object to utf - 8 string using base64encode algorithm.", "response": "def obj2str(obj, pk_protocol=pk_protocol):\n    \"\"\"Convert arbitrary object to utf-8 string, using\n    base64encode algorithm.\n\n    Usage::\n\n        >>> from weatherlab.lib.dataIO.pk import obj2str\n        >>> data = {\"a\": 1, \"b\": 2}\n        >>> obj2str(data, pk_protocol=2)\n        'gAJ9cQAoWAEAAABhcQFLAVgBAAAAYnECSwJ1Lg=='\n\n    **\u4e2d\u6587\u6587\u6863**\n\n    \u5c06\u53efPickle\u5316\u7684Python\u5bf9\u8c61\u8f6c\u5316\u4e3autf-8\u7f16\u7801\u7684\"\u5b57\u7b26\u4e32\"\n    \"\"\"\n    return base64.b64encode(pickle.dumps(\n        obj, protocol=pk_protocol)).decode(\"utf-8\")"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nruns analysis. The basic idea is to recursively find all script files in specific programming language, and analyze each file then sum it up.", "response": "def run(self):\n        \"\"\"Run analysis.\n\n        The basic idea is to recursively find all script files in specific \n        programming language, and analyze each file then sum it up.\n        \"\"\"\n        n_target_file, n_other_file = 0, 0\n\n        code, comment, docstr, purecode = 0, 0, 0, 0\n\n        fc = FileCollection.from_path_except(self.workspace, self.ignore)\n\n        fc_yes, fc_no = fc.select(self.filter, keepboth=True)\n        n_other_file += len(fc_no)\n\n        for abspath in fc_yes:\n            try:\n                with open(abspath, \"rb\") as f:\n                    code_text = f.read().decode(\"utf-8\")\n                    code_, comment_, docstr_, purecode_ = self.analyzer(\n                        code_text)\n                    code += code_\n                    comment += comment_\n                    docstr += docstr_\n                    purecode += purecode_\n                    n_target_file += 1\n            except Exception as e:\n                n_other_file += 1\n\n        lines = list()\n        lines.append(\"Code statistic result for '%s'\" % self.workspace)\n        lines.append(\"  %r %r files, %r other files.\" %\n                     (n_target_file, self.language, n_other_file))\n        lines.append(\"    code line: %s\" % code)\n        lines.append(\"    comment line: %s\" % comment)\n        lines.append(\"    docstr line: %s\" % docstr)\n        lines.append(\"    purecode line: %s\" % purecode)\n        message = \"\\n\".join(lines)\n\n        print(message)\n        return message"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef analyzePython(code_text):\n        code, comment, docstr = 0, 0, 0\n\n        p1 = r\"\"\"(?<=%s)[\\s\\S]*?(?=%s)\"\"\" % ('\"\"\"', '\"\"\"')\n        p2 = r\"\"\"(?<=%s)[\\s\\S]*?(?=%s)\"\"\" % (\"'''\", \"'''\")\n\n        # count docstr\n        for pattern in [p1, p2]:\n            for res in re.findall(pattern, code_text)[::2]:\n                lines = [i.strip() for i in res.split(\"\\n\") if i.strip()]\n                docstr += len(lines)\n\n        # count comment line and code\n        lines = [i.strip() for i in code_text.split(\"\\n\") if i.strip()]\n        for line in lines:\n            if line.startswith(\"#\"):\n                comment += 1\n            else:\n                code += 1\n        purecode = code - docstr  # pure code = code - docstr\n        return code, comment, docstr, purecode", "response": "Count how many line of code comment dosstr purecode in one \n        Python script file."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_default(__func: Callable, __arg: str) -> str:\n    return signature(__func).parameters[__arg].default", "response": "Fetch default value for a function argument\n   "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef config_(name: str, local: bool, package: str, section: str,\n            key: Optional[str]):\n    \"\"\"Extract or list values from config.\"\"\"\n    cfg = config.read_configs(package, name, local=local)\n    if key:\n        with suppress(NoOptionError, NoSectionError):\n            echo(cfg.get(section, key))\n    else:\n        with suppress(NoSectionError):\n            for opt in cfg.options(section):\n                colourise.pinfo(opt)\n                echo('    {}'.format(cfg.get(section, opt)))", "response": "Extract or list values from config."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef find_tag(match: str, strict: bool, directory: str):\n    with suppress(CalledProcessError):\n        echo(git.find_tag(match, strict=strict, git_dir=directory))", "response": "Find a tag for git repository."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef pretty_time(timestamp: str):\n    try:\n        parsed = iso_8601.parse_datetime(timestamp)\n    except ValueError:\n        now = datetime.utcnow().replace(tzinfo=timezone.utc)\n        try:\n            delta = iso_8601.parse_delta(timestamp)\n        except ValueError:\n            delta = human_time.parse_timedelta(timestamp)\n        parsed = now - delta\n\n    echo(human_time.human_timestamp(parsed))", "response": "Format timestamp for human consumption."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef pip_requires(name: str):\n    requires = pip_support.parse_requires(name)\n    for req in requires:\n        echo(req)", "response": "Parse pip requirements file."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates output from Jinja template.", "response": "def gen_text(env: TextIOBase, package: str, tmpl: str):\n    \"\"\"Create output from Jinja template.\"\"\"\n    if env:\n        env_args = json_datetime.load(env)\n    else:\n        env_args = {}\n    jinja_env = template.setup(package)\n    echo(jinja_env.get_template(tmpl).render(**env_args))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ntime the output of a command.", "response": "def time(ctx: Context, command: str):\n    \"\"\"Time the output of a command.\"\"\"\n    with timer.Timing(verbose=True):\n        proc = run(command, shell=True)\n    ctx.exit(proc.returncode)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef register(cls, name, type_):\n\n        if not issubclass(type_, Entry):\n            raise exceptions.InvalidEntryType(\"%s is not a subclass of Entry\" % str(type_))\n        cls._registry[name.lower()] = type_", "response": "Register a new type for an entry - type."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nvalidates each entry in the set.", "response": "def validate(self, **kwargs):\n        \"\"\"\n        Validates each entry (passing the provided arguments down to them and\n        also tries to resolve all cross-references between the entries.\n        \"\"\"\n        self.check_crossrefs()\n        for value in self.values():\n            value.validate(**kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef check_crossrefs(self):\n        broken = []\n        for value in self.values():\n            crossref = value.get('crossref')\n            if crossref is not None:\n                if crossref not in self:\n                    broken.append(value)\n        if len(broken):\n            raise exceptions.BrokenCrossReferences('One or more cross reference could not'\n                    ' be resolved', broken)", "response": "Checks all crossreferences found in the bibliography."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef validate(self, raise_unsupported=False):\n        fields = set(self.keys())\n        flattened_required_fields = set()\n        required_errors = []\n        for field in self.required_fields:\n            found = False\n            if isinstance(field, (list, tuple)):\n                # Check all alternatives\n                for real_f in field:\n                    if real_f in fields:\n                        flattened_required_fields.add(real_f)\n                        found = True\n            else:\n                flattened_required_fields.add(field)\n                if field in fields:\n                    found = True\n            if not found:\n                required_errors.append(field)\n        unsupported_fields = fields - flattened_required_fields \\\n                - set(self.optional_fields)\n        if len(required_errors) or (raise_unsupported\n                and len(unsupported_fields)):\n            raise exceptions.InvalidStructure(\"Missing or unsupported fields found\",\n                    required_fields=required_errors,\n                    unsupported_fields=unsupported_fields)", "response": "Checks if the Entry instance includes all the required fields of its\n        type."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get(file_name, key):\n    db = XonoticDB.load_path(file_name)\n    value = db.get(key)\n    if value is None:\n        sys.exit(1)\n    else:\n        click.echo(value)", "response": "Get a value for the specified key."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set(file_name, key, value, new):\n    db = XonoticDB.load_path(file_name)\n    if key not in db and not new:\n        click.echo('Key %s is not found in the database' % key, file=sys.stderr)\n        sys.exit(1)\n    else:\n        db[key] = value\n        db.save(file_name)", "response": "Set a new value for the specified key."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nremoving a cts record on MAP and POSITION", "response": "def remove_cts_record(file_name, map, position):\n    \"\"\"\n    Remove cts record on MAP and POSITION\n    \"\"\"\n    db = XonoticDB.load_path(file_name)\n    db.remove_cts_record(map, position)\n    db.save(file_name)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nremoves all cts records set by player with CRYPTO_IDFP", "response": "def remove_all_cts_records_by(file_name, crypto_idfp):\n    \"\"\"\n    Remove all cts records set by player with CRYPTO_IDFP\n    \"\"\"\n    db = XonoticDB.load_path(file_name)\n    db.remove_all_cts_records_by(crypto_idfp)\n    db.save(file_name)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nmerging cts records made by CRYPTO_IDFP to CRYPTO_IDFP", "response": "def merge_cts_records(file_name, crypto_idfp, crypto_idfps):\n    \"\"\"\n    Merge cts records made by CRYPTO_IDFPS to CRYPTO_IDFP\n    \"\"\"\n    db = XonoticDB.load_path(file_name)\n    db.merge_cts_records(crypto_idfp, crypto_idfps)\n    db.save(file_name)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef check_rotation(rotation):\n\n    if rotation not in ALLOWED_ROTATION:\n        allowed_rotation = ', '.join(ALLOWED_ROTATION)\n        raise UnsupportedRotation('Rotation %s is not allwoed. Allowed are %s'\n                                  % (rotation, allowed_rotation))", "response": "checks rotation parameter if illegal value raises exception"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef check_resize(resize):\n    if resize is None:\n        return\n\n    resize = resize.lower().strip()\n\n    if 'x' in resize:\n        tmp = resize.lower().split('x')\n        tmp = [x.strip() for x in resize.split('x')]\n        if len(tmp) == 2 and tmp[0].isdigit() and tmp[1].isdigit():\n            return\n    elif '%' in resize:\n        tmp = resize.split('%')[0]\n        if tmp.isnumeric():\n            tmp = int(tmp)\n            if 1 <= tmp <= 1000:\n                return\n            else:\n                raise PercentageOutOfRange(\"percentage must be between 1 and 1000\")\n\n    raise MallformedResize('Resize value \"%s\" is mallformed. '\n                           'Desired format is: {width}x{height} or {percentage}%%' % resize)", "response": "checks resize parameter if illegal value raises exception"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef check_response(response):\n    if response.status_code < 200 or response.status_code > 300:\n        raise ServerError('API requests returned with error: %s'\n                          % response.status_code)\n\n    try:\n        response_text = loads(response.text)\n    except ValueError:\n        raise ServerError('The API did not returned a JSON string.')\n\n    if not response_text:\n        raise EmptyResponse()\n\n    if 'failure' in response_text:\n        if response_text['failure'] == 'Falscher Dateityp':\n            raise UnsupportedFormat('Please look at picflash.org '\n                                    'witch formats are supported')\n        else:\n            raise UnkownError(response_text['failure'])", "response": "Checks the response for errors raises an exception."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef check_if_redirect(url):\n    response = head(url, headers={'User-Agent': USER_AGENT})\n    if response.status_code >= 300 and response.status_code < 400:\n        return response.headers['location']\n\n    return None", "response": "Checks if server redirects url\n    returns the location of the server if it is"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef run_container(docker_client, backup_data):\n    docker_client.pull(backup_data['image'])\n    container = docker_client.create_container(\n        image=backup_data['image'],\n        volumes=['/backup'],\n        command=backup_data['command'])\n\n    docker_client.start(container.get('Id'), binds={\n        backup_data['workdir']:\n        {\n            'bind': '/backup',\n            'ro': False\n        }\n    })\n    return container", "response": "Pulls the Docker image and creates a container with a backup volume."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nscans a module and its entire dependency tree to create a dict of all files with their modified time as keys.", "response": "def module_files(module, dependencies_dict=None):\n    \"\"\"\n    Scan a module and its entire dependency tree to create a dict of all files\n    and their modified time.\n\n    @param module: A <module> object\n    @param dependencies_dict: Pass an existing dict to add only unscanned\n        files or None to create a new file dict\n    @return: A dict containing filenames as keys with their modified time\n        as value\n    \"\"\"\n    if dependencies_dict is None:\n        dependencies_dict = dict()\n    if hasattr(module, '__file__'):\n        filename = module.__file__\n        if filename not in dependencies_dict:\n            realname, modified_time = _get_filename_and_modified(filename)\n            if realname and realname not in dependencies_dict:\n                dependencies_dict[realname] = modified_time\n                for name in dir(module):\n                    try:\n                        item = getattr(module, name)\n                        if hasattr(item, '__file__'):\n                            module_files(item, dependencies_dict)\n                        elif hasattr(item, '__module__'):\n                            item = sys.modules[getattr(item, '__module__')]\n                            if hasattr(item, '__file__'):\n                                module_files(item, dependencies_dict)\n                    except (AttributeError, KeyError):\n                        pass\n    return dependencies_dict"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nscan all modules and create a dict of all the files that have been modified.", "response": "def files():\n    \"\"\"\n    Scan all modules in the currently running app to create a dict of all\n    files and their modified time.\n\n    @note The scan only occurs the first time this function is called.\n        Subsequent calls simply return the global dict.\n\n    @return: A dict containing filenames as keys with their modified time\n        as value\n    \"\"\"\n    if not _scanned:\n        if not module_files(sys.modules['__main__'], _process_files):\n            for module in sys.modules.values():\n                if hasattr(module, '__file__'):\n                    filename = module.__file__\n                    if filename not in _process_files:\n                        realname, modified_time = _get_filename_and_modified(filename)\n                        if realname and realname not in _process_files:\n                            _process_files[realname] = modified_time\n    return _process_files"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ntracks additional files. It is often useful to use glob.glob here. For instance: track('config.ini', glob.glob('templates/*.pt'), glob.glob('db/*.db')) @param args: A list where each element is either a filename or an iterable of filenames", "response": "def track(*args):\n    \"\"\"\n    Track additional files. It is often useful to use glob.glob here.\n    For instance:\n\n        track('config.ini', glob.glob('templates/*.pt'), glob.glob('db/*.db'))\n\n    @param args: A list where each element is either a filename or an\n        iterable of filenames\n    \"\"\"\n    for arg in args:\n        if isinstance(arg, str):\n            arg = [arg]\n        for filename in arg:\n            realname, modified_time = _get_filename_and_modified(filename)\n            if realname and realname not in _process_files:\n                _process_files[realname] = modified_time"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef hup_hook(signal_or_callable=signal.SIGTERM, verbose=False):\n\n    #noinspection PyUnusedLocal\n    def handle_hup(signum, frame):\n        changed = modified()\n        if changed:\n            if callable(signal_or_callable):\n                func = signal_or_callable\n                args = (changed,)\n                op = 'Calling'\n                try:\n                    name = signal_or_callable.__name__\n                except Exception:\n                    name = str(signal_or_callable)\n            else:\n                if isinstance(signal_or_callable, int):\n                    name = str(signal_or_callable)\n                    signum = signal_or_callable\n                    if verbose:\n                        for item in dir(signal):\n                            if item.startswith('SIG') and getattr(signal, item) == signal_or_callable:\n                                name = item\n                                break\n                else:\n                    name = signal_or_callable if signal_or_callable.startswith('SIG') else 'SIG' + signal_or_callable\n                    signum = getattr(signal, name)\n                func = os.kill\n                args = (os.getpid(), signum)\n                op = 'Sending'\n            if verbose:\n                more = ' and {0} other files'.format(len(changed)) if len(changed) > 1 else ''\n                message = '{0} {1} because {2}{3} changed'.format(op, name, changed[0], more)\n                if callable(verbose):\n                    #noinspection PyCallingNonCallable\n                    verbose(message)\n                else:\n                    print(message)\n            func(*args)\n\n    files()\n    signal.signal(signal.SIGHUP, handle_hup)\n    signal.siginterrupt(signal.SIGHUP, False)", "response": "Register a signal handler for signal. SIGTERM and signal. SIGINT and signal. SIGINT are ignored."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nprocess the input buffer.", "response": "def process(self, buff):\n        '''\n            Process the input buffer. The buffer can contains all or a segment of the bytes from the complete message. \n            The function will buffer what will require extra bytes to be processed. \n        :param buff:\n        '''\n        \n        # adding the current to the available\n        self.memory = self.memory + buff \n        self._available = len(self.memory)\n        idx = 0\n        # prepare pointers and inputs\n        # read first byte \n        \n        handleheader = self.handle_read_header\n        handlelength = self.handle_read_length\n        handlevalue = self.handle_read_value\n        handleegend = self.handle_segment_ended\n        # process input while exists\n        while self._available >= self._advance:\n            # expected start of a new segment\n            if self._scstate.value <= ScannerState.WAITING_FOR_HEADER.value:\n                self._advance = 1\n                handleheader(self.memory[idx])\n            # the scanner expects to read one or multiple bytes that contain an \n            # integer contain the length of the value to be expected\n            elif self._scstate is ScannerState.WAITING_FOR_LENGTH:\n                self._advance = self._state[3]\n                # breaking if not available\n                if self._available < self._state[3]:\n                    break\n                handlelength(self.memory, idx, idx + self._advance)\n                # if the scanner is expecting to parse one or multiple bytes as the value of the segment\n            elif self._scstate is ScannerState.WAITING_FOR_VALUE:\n                self._advance = self._state[3]\n                if self._available < self._advance:\n                    break\n                handlevalue(self.memory, idx, idx + self._advance)\n            # if the scanner is expecting to parse an extension\n            elif self._scstate is ScannerState.WAITING_FOR_EXT_TYPE:\n                self._advance = 1\n                self.handle_read_ext_type(self.memory, idx)\n            \n            # if a data segment is ended\n            if self._scstate is ScannerState.SEGMENT_ENDED:\n                handleegend()\n            # proceed with scanning\n            \n            self._available -= self._advance   \n            idx = idx + self._advance\n            self._advance = 1\n        \n        #  finished processing all since it needed extra info     \n        self.memory = buffer(self.memory, idx, len(self.memory))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef handle_read_length(self, buff, start, end):        \n        '''\n            handle read of number bytes needed to parse the value \n        :param buff:\n        :param start:\n        :param end:\n        '''\n        self.set_state_length(self._state, self.parse_uint(buff, start, end) * self._state[1].value.multiplier)\n    \n        if self._state[1].value.valuetype is ValueType.NESTED:\n            self.events.append((self._state[1].value.startevent, self._state[0], None))\n            if self._state[2] is 0:  # it is an empty nested segment\n                self._scstate = ScannerState.SEGMENT_ENDED\n            else:\n                if self._state[1].value.multiplier is 2:\n                    self.parentismap = 1\n                    self.waitingforprop = 1\n                else:\n                    self.parentismap = 0\n                    self.waitingforprop = 0\n                    \n                self.push_state()\n                self._scstate = ScannerState.WAITING_FOR_HEADER\n        else:\n            if self._state[1].value.segmenttype is SegmentType.EXT_FORMAT:\n                self._scstate = ScannerState.WAITING_FOR_EXT_TYPE\n            else:\n                self._scstate = ScannerState.WAITING_FOR_VALUE\n                if self._state[2] is 0:  # it is an empty nested segment\n                    self.events.append((self.value_event_type(EventType.VALUE), self._state[0], self.empty_value(self._state[0])))\n                    self._scstate = self.next_state_afterraw()\n                    self._scstate = ScannerState.SEGMENT_ENDED", "response": "handle read of number bytes needed to parse the value \n       "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef handle_read_value(self, buff, start, end):\n        '''\n            handle read of the value based on the expected length\n        :param buff:\n        :param start:\n        :param end:\n        '''\n        segmenttype = self._state[1].value.segmenttype\n        \n        value = None\n        eventtype = None\n        ftype = self._state[0]\n        # parsing value \n        if segmenttype <= SegmentType.VARIABLE_LENGTH_VALUE:\n            self._scstate = self.next_state_afterraw()\n            value = self.parse_value(self._state[0], buff, start, end)\n            eventtype = EventType.VALUE \n        # next we should expect length\n        elif segmenttype >= SegmentType.EXT_FORMAT:\n            value = self.parse_ext_value(self._state[0], self._state[4], buff, start, end)\n            eventtype = EventType.EXT\n            ftype = ExtType(self._state[0], self._state[4])\n        else:\n            raise InvalidStateException(self._scstate, \"header\")\n        self.events.append((self.value_event_type(eventtype), ftype, value))", "response": "handle the read of the value based on the expected length\n           "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef handle_read_header(self, byte):\n        '''\n            handle read of header and assign fetching the appropriate template that is needed to parse expected segment based on header\n        :param byte:\n        '''\n        \n        (_, frmtcode, _, frmtidx, val) = self.util.find(byte)\n        template = self._templatelist[frmtidx - 1]\n        \n        segmenttype = template.value.segmenttype        \n        # single byte segment\n       \n        if segmenttype is SegmentType.SINGLE_BYTE:\n            self._scstate = self.next_state_afterraw()\n            self._state = self.create_state(frmtcode, template);\n            self.events.append((self.value_event_type(EventType.VALUE), frmtcode, val))\n            \n        # next we should expect value\n        elif segmenttype is SegmentType.HEADER_VALUE_PAIR:\n            self._scstate = ScannerState.WAITING_FOR_VALUE\n            self._state = self.create_state(frmtcode, template, length=template.value.length * template.value.multiplier);\n        # next we should expect value\n        elif segmenttype is SegmentType.HEADER_WITH_LENGTH_VALUE_PAIR:\n            length = val * template.value.multiplier\n            self._state = self.create_state(frmtcode, template, length=length);\n            if self._state[1].value.valuetype is ValueType.NESTED:                \n                self.events.append((self._state[1].value.startevent, frmtcode, None))\n                if length is 0:\n                    self._scstate = ScannerState.SEGMENT_ENDED\n                else:\n                    if template.value.multiplier is 2:\n                        self.parentismap = 1\n                        self.waitingforprop = 1\n                    else:\n                        self.parentismap = 0\n                        self.waitingforprop = 0\n                    self.push_state()\n                    self._scstate = ScannerState.WAITING_FOR_HEADER\n            else:          \n                if length is 0:\n                    self.events.append((self.value_event_type(EventType.VALUE), self._state[0], self.empty_value(self._state[0])))\n                    self._scstate = self.next_state_afterraw()\n                else:\n                    self._scstate = ScannerState.WAITING_FOR_VALUE\n        # next we should expect length\n        elif segmenttype is SegmentType.VARIABLE_LENGTH_VALUE:\n            self._scstate = ScannerState.WAITING_FOR_LENGTH\n            self._state = self.create_state(frmtcode, template, length=template.value.length);\n        # next we should expect length\n        elif segmenttype is SegmentType.EXT_FORMAT:\n            self._scstate = ScannerState.WAITING_FOR_LENGTH\n            self._state = self.create_state(frmtcode, template, length=template.value.length);\n        # next we should expect type       \n        elif segmenttype is SegmentType.FIXED_EXT_FORMAT:\n            self._state = self.create_state(frmtcode, template, length=template.value.length);\n            self._scstate = ScannerState.WAITING_FOR_EXT_TYPE\n        else:\n            raise InvalidStateException(self._scstate, \"header\")", "response": "handle read of header and assign fetching the appropriate template that is needed to parse the expected segment based on the header."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nprocess end of the segment based on template", "response": "def handle_segment_ended(self):\n        '''\n            process end of the segment based on template\n        '''\n        if self._state[1].value.endevent is not None:\n            self.events.append((self._state[1].value.endevent, self._state[0], None))\n        if self._state[1].value.multiplier is 2:\n            self.parentismap = 0\n            self.waitingforprop = 0\n        if(len(self._stack) is  0):\n            self._scstate = ScannerState.IDLE            \n            return       \n        if self._state[1].value.valuetype is not ValueType.RAW:\n            self._stack[-1][3] = self._stack[-1][3] - 1  # #???\n        if self._stack[-1][3] is 0:\n            self._scstate = ScannerState.SEGMENT_ENDED\n            self._state = self._stack.pop()  # pop last state from stack\n            if self._state[1].value.multiplier is 2:\n                self.parentismap = 1\n                self.waitingforprop = 1\n            self.handle_segment_ended()\n        else:\n            if self._stack[-1][1].value.multiplier is 2:\n                self.parentismap = 1\n                self.waitingforprop = 1\n            self._scstate = ScannerState.WAITING_FOR_HEADER"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef parse_value(self, frmtcode, buff, start, end):\n        '''\n            parse the value from the buffer given the interval for the appropraite bytes\n        :param formattype:\n        :param buff:\n        :param start:\n        :param end:\n        '''\n        \n        frmttype = self.util._formatmap[frmtcode]\n        if(frmtcode == FormatType.FLOAT_32.value.code):  # @UndefinedVariable\n            return self.parse_float32(buff, start, end)\n        elif(frmtcode == FormatType.FLOAT_64.value.code):  # @UndefinedVariable\n            return self.parse_float64(buff, start, end)\n        if frmttype.value.idx <= FormatType.FIXSTR.value.idx:  # @UndefinedVariable  \n            return self.parse_str(buff, start, end)\n        elif frmttype.value.idx <= FormatType.INT_64.value.idx:  # @UndefinedVariable\n            return self.parse_int(buff, start, end)\n        elif frmttype.value.idx <= FormatType.UINT_64.value.idx:  # @UndefinedVariable\n            return self.parse_uint(buff, start, end)", "response": "parse the value from the buffer given the interval for the appropraite bytes\n           "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef parse_uint(self, buff, start, end):\n        '''\n            parse an integer from the buffer given the interval of bytes\n        :param buff:\n        :param start:\n        :param end:\n        \n        '''\n        return struct.unpack_from(self.ustructmap[end - start], buff, start)[0]", "response": "parse an integer from the buffer given the interval of bytes\nAttributeNames"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ndoes the things! Return: 0 Exceptions:", "response": "def main():\n    \"\"\"\n    Do the things!\n\n\n    Return: 0\n    Exceptions:\n    \"\"\"\n    description = 'Letter - a commandline interface'\n    parser = argparse.ArgumentParser(description=description)\n    parser.add_argument('--gmail', action='store_true', help='Send via Gmail', )\n    args = parser.parse_args()\n\n    to       = raw_input('To address > ')\n    subject  = raw_input('Subject > ')\n    body     = raw_input('Your Message > ')\n\n\n    if args.gmail:\n        user = fromaddr = raw_input('Gmail Address > ')\n        pw   = getpass.getpass()\n        postie = letter.GmailPostman(user=user, pw=pw)\n    else:\n        postie = letter.Postman() # Unauthorized SMTP, localhost:25\n        fromaddr = raw_input('From address > ')\n\n    class Message(letter.Letter):\n        Postie     = postie\n\n        From       = fromaddr\n        To         = to\n        Subject    = subject\n        Body       = body\n\n    return 0"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconfigure the tornado. web. SocketLogger instance.", "response": "def configure(host=DEFAULT_HOST, port=DEFAULT_PORT):\n    \"\"\"\n    >>> configure('localhost', 9011)\n    \"\"\"\n    global __logger\n    __logger = UDPLogger(host, port)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef send(self, jsonstr):\n        udp_sock = socket(AF_INET, SOCK_DGRAM)\n        udp_sock.sendto(jsonstr.encode('utf-8'), self.addr)", "response": "Send jsonstr to the UDP collector"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nread a UTF - 8 file from the package. Takes a list of strings to join to make the path", "response": "def read_file(path):\n    \"\"\"Read a UTF-8 file from the package. Takes a list of strings to join to\n    make the path\"\"\"\n    file_path = os.path.join(here, *path)\n    with open(file_path, encoding=\"utf-8\") as f:\n        return f.read()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nextract a constant from a python file by looking for a line defining and executing it.", "response": "def exec_file(path, name):\n    \"\"\"Extract a constant from a python file by looking for a line defining\n    the constant and executing it.\"\"\"\n    result = {}\n    code = read_file(path)\n    lines = [line for line in code.split('\\n') if line.startswith(name)]\n    exec(\"\\n\".join(lines), result)\n    return result[name]"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef db_exists():\n    logger.info(\"Checking to see if %s already exists\", repr(DB[\"NAME\"]))\n    try:\n        # Hide stderr since it is confusing here\n        psql(\"\", stderr=subprocess.STDOUT)\n    except subprocess.CalledProcessError:\n        return False\n    return True", "response": "Test if DATABASES [ default ] exists"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef dropdb(force=False):\n\n    if force:\n        logger.info(\n            \"Terminating any other connections to %s on %s\",\n            repr(DB[\"NAME\"]),\n            repr(DB[\"HOST\"]),\n        )\n        kill_other_psql_sessions()\n\n    logger.info(\"Dropping database %s\", repr(DB[\"NAME\"]))\n    return shell('dropdb -U \"{USER}\" -h \"{HOST}\" \"{NAME}\"'.format(**DB))", "response": "Drop the default database."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef pg_dump(db_name, backup_path):\n\n    logger.info(\"Dumping %s to %s\", repr(db_name), repr(backup_path))\n    return shell(\n        'pg_dump \"{db_name}\" -U \"{USER}\" -h \"{HOST}\" '\n        \"--schema=public --file={backup_path}\".format(\n            db_name=db_name, backup_path=backup_path, **DB\n        )\n    )", "response": "Dump the database to backup_path"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nload data in the sql_path into DATABASES.", "response": "def populate_db(sql_path):\n    \"\"\"Load data in the `sql_path` file into DATABASES['default']\"\"\"\n\n    logger.info(\"Populating DB %s from %s\", repr(DB[\"NAME\"]), repr(sql_path))\n    shell(\n        'psql -U \"{USER}\" -h \"{HOST}\" -d \"{NAME}\" --file={sql_path}'.format(\n            sql_path=sql_path, **DB\n        )\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef cleardb(force=False):\n\n    # Drop database, if it exists\n    if db_exists():\n        try:\n            dropdb(force)\n        except subprocess.CalledProcessError as error:\n            output = error.output.decode(\"utf-8\")\n            if \"is being accessed by other users\" in output:\n                raise ValueError(\n                    \"{}\\n\"\n                    \"To forcibly terminate other sessions, run \"\n                    \"this command again with --force\".format(output)\n                )\n            else:\n                raise\n    else:\n        logger.info(\n            \"Database %s does not currently exist; no need to drop\", repr(DB[\"NAME\"])\n        )\n    createdb()", "response": "Drop and create DATABASES [ default ]"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef clone_psql_db(db_to_clone):\n    # If db_to_clone is a path, assume it is a SQL dump...\n    if os.path.isfile(db_to_clone):\n        logger.info(\"Treating %s as a path to a SQL dump\", repr(db_to_clone))\n        # ...and use it to populate our database\n        populate_db(db_to_clone)\n    # Otherwise, assume it is a database name...\n    else:\n        logger.info(\"Treating %s as a database name\", repr(db_to_clone))\n        # ...create a temp file to dump it into...\n        with NamedTemporaryFile(prefix=\"{}.sql.\".format(db_to_clone)) as backup_file:\n            # ...perform the dump...\n            pg_dump(db_to_clone, backup_file.name)\n            # ...and load the contents of the dump into our DB\n            populate_db(backup_file.name)", "response": "Clone a database into DATABASES."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate a filename for the destination zip file.", "response": "def _resolve_file_name(source, destination):\n        \"\"\"Create a filename for the destination zip file.\"\"\"\n        number = 1\n        if os.path.exists(os.path.join(destination, os.path.basename(source) + '.zip')):\n            while True:\n                zip_filename = os.path.join(destination, os.path.basename(source) + '_' + str(number) + '.zip')\n                if not os.path.exists(zip_filename):\n                    break\n                number = number + 1\n        else:\n            zip_filename = os.path.join(destination, os.path.basename(source) + '.zip')\n        return zip_filename"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _backup_compresslevel(self, dirs):\n        # Only supported in Python 3.7+\n        with ZipFile(self.zip_filename, 'w', compresslevel=self.compress_level) as backup_zip:\n            for path in tqdm(dirs, desc='Writing Zip Files', total=len(dirs)):\n                backup_zip.write(path, path[len(self.source):len(path)])", "response": "Create a backup file with a compresslevel parameter."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _backup_pb_gui(self, dirs):\n        import PySimpleGUI as sg\n        # Legacy support\n        with ZipFile(self.zip_filename, 'w') as backup_zip:\n            for count, path in enumerate(dirs):\n                backup_zip.write(path, path[len(self.source):len(path)])\n                if not sg.OneLineProgressMeter('Writing Zip Files', count + 1, len(dirs) - 1, 'Files'):\n                    break", "response": "Create a zip backup with a GUI progress bar."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate a backup with a tqdm progress bar.", "response": "def _backup_pb_tqdm(self, dirs):\n        \"\"\"Create a backup with a tqdm progress bar.\"\"\"\n        with ZipFile(self.zip_filename, 'w') as backup_zip:\n            for path in tqdm(dirs, desc='Writing Zip Files', total=len(dirs)):\n                backup_zip.write(path, path[len(self.source):len(path)])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the S3 URI for the object that matches the regex match m.", "response": "def get_s3_uri(m, file_names, config):\n    \"\"\"\n    populates file_names list with urls that matched the regex match object\n    returns the total filesize of all the files matched\n    \"\"\"\n    bucket_name = m.group(1)\n    path = m.group(2)\n    bucket = get_s3_bucket(bucket_name, config)\n    result = 0\n    if (config.start_date or config.date_range) and (\"{year\" in path or \"{month\" in path or \"{day\" in path):\n        for tmp_date in date_generator(config.end_date, config.date_range or ((config.end_date - config.start_date).days + 1)):\n            # +1 because we want to include end_date\n            for key in bucket.list(prefix=path.format(year=tmp_date.year, month=tmp_date.month, day=tmp_date.day)):\n                file_names.append(\"s3://{}/{}\".format(bucket_name, key.name))\n                result += key.size\n    else:\n        for key in bucket.list(prefix=path):\n            file_names.append(\"s3://{}/{}\".format(bucket_name, key.name))\n            result += key.size\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_local_uri(m, file_names, _):\n    path = m.group(2)\n    result = 0\n    for root, _, files in os.walk(path):\n        for file_name in files:\n            absolute_path = os.path.join(root, file_name)\n            file_names.append(\"file:/{}\".format(absolute_path))\n            result += os.path.getsize(absolute_path)\n    return result", "response": "Get the local URI of the object that matches the regex match."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a tuple of total file size in bytes and the list of files", "response": "def get_uris(config):\n    \"\"\" returns a tuple of total file size in bytes, and the list of files \"\"\"\n    file_names = []\n    if config.INPUT_DATA is None:\n        sys.stderr.write(\"you need to provide INPUT_DATA in config\\n\")\n        sys.exit(1)\n    if isinstance(config.INPUT_DATA, basestring):\n        config.INPUT_DATA = [config.INPUT_DATA]\n    file_size = 0\n    for uri in config.INPUT_DATA:\n        for regex, uri_method, _, _ in URI_REGEXES:\n            m = regex.match(uri)\n            if m is not None:\n                file_size += uri_method(m, file_names, config)\n                break\n    print(\"going to process {} files...\".format(len(file_names)))\n    return file_size, file_names"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef buildschema(_cls=None, **kwargs):\n    if _cls is None:\n        return lambda _cls: buildschema(_cls=_cls, **kwargs)\n\n    result = build(_cls, **kwargs)\n\n    return result", "response": "Class decorator used to build a schema from the decorated class."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef funcschema(default=None, *args, **kwargs):\n    if default is None:\n        return lambda default: funcschema(default=default, *args, **kwargs)\n\n    return FunctionSchema(default=default, *args, **kwargs)", "response": "Decorator to use in order to transform a function into a schema."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _getparams_rtype(cls, function):\n        try:\n            args, vargs, kwargs, default = getargspec(function)\n\n        except TypeError:\n            args, vargs, kwargs, default = (), (), (), ()\n\n        indexlen = len(args) - (0 if default is None else len(default))\n\n        params = OrderedDict()\n\n        for index, arg in enumerate(args):\n\n            pkwargs = {\n                'name': arg,\n                'mandatory': True\n            }  # param kwargs\n\n            if index >= indexlen:  # has default value\n                value = default[index - indexlen]\n                pkwargs['default'] = value\n                pkwargs['ref'] = None if value is None else data2schema(value)\n                pkwargs['mandatory'] = False\n\n            params[arg] = pkwargs\n\n        rtype = None\n\n        # parse docstring\n        if function.__doc__ is not None and not isbuiltin(function):\n\n            scope = get_function_globals(function)\n\n            for match in cls._REC.findall(function.__doc__):\n                if rtype is None:\n                    rrtype = match[4].strip() or None\n\n                    if rrtype:\n\n                        rtypes = rrtype.split(',')\n\n                        schemas = []\n                        for rtype_ in rtypes:\n\n                            rtype_ = rtype_.strip()\n                            islist = False\n\n                            try:\n                                lkrtype = lookup(rtype_, scope=scope)\n\n                            except ImportError:\n                                islist = True\n\n                                try:\n                                    if rtype_[-1] == 's':\n                                        lkrtype = lookup(\n                                            rtype_[:-1], scope=scope\n                                        )\n\n                                    elif rtype_.startswith('list of '):\n                                        lkrtype = lookup(\n                                            rtype_[8:], scope=scope\n                                        )\n\n                                    else:\n                                        raise\n\n                                except ImportError:\n                                    msg = 'rtype \"{0}\" ({1}) from {2} not found.'\n                                    raise ImportError(\n                                        msg.format(rtype_, rrtype, function)\n                                    )\n\n                            try:\n                                schemacls = datatype2schemacls(lkrtype)\n\n                            except TypeError:\n                                schemacls = ParamTypeSchema(type=lkrtype)\n\n                            rschema = schemacls()\n\n                            if islist:\n                                rschema = ArraySchema(itemtype=rschema)\n\n                            schemas.append(rschema)\n\n                        if len(rtypes) > 1:\n                            rtype = OneOfSchema(schemas=schemas, nullable=True)\n\n                        else:\n                            rtype = schemas[0]\n\n                        continue\n\n                pname = (match[1] or match[2]).strip()\n\n                if pname and pname in params:\n\n                    ptype = (match[0] or match[3]).strip()\n\n                    ptypes = ptype.split(',')\n\n                    schemas = []\n\n                    for ptype in ptypes:\n\n                        ptype = ptype.strip()\n\n                        islist = False\n\n                        try:\n                            lkptype = lookup(ptype, scope=scope)\n\n                        except ImportError:\n                            islist = True\n\n                            try:\n                                if ptype[-1] == 's':\n                                    lkptype = lookup(ptype[:-1], scope=scope)\n\n                                elif ptype.startswith('list of '):\n                                    lkptype = lookup(ptype[8:], scope=scope)\n\n                                else:\n                                    raise\n\n                            except ImportError:\n\n                                msg = 'Error on ptype \"{0}\" ({1}) from {2} not found.'\n                                raise ImportError(\n                                    msg.format(pname, ptype, function)\n                                )\n\n                        try:\n                            schemacls = datatype2schemacls(lkptype)\n\n                        except TypeError:\n                            schemacls = ParamTypeSchema(type=lkptype)\n\n                        pschema = schemacls()\n\n                        if islist:\n                            pschema = ArraySchema(itemtype=pschema)\n\n                        schemas.append(pschema)\n\n                    if len(ptypes) > 1:\n                        pschema = OneOfSchema(schemas=schemas, nullable=True)\n\n                    else:\n                        pschema = schemas[0]\n\n                    params[pname]['ref'] = pschema\n\n        return params, rtype, vargs, kwargs", "response": "Get function params rtype vargs kwargs and rtype from input function and rtype."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nimports a sequence of dicts or django ORM objects into the specified model", "response": "def import_wiki_items(item_seq, model=WikiItem,  batch_len=100, db_alias='default', verbosity=2):\n    \"\"\"Import a sequence (queryset, generator, tuple, list) of dicts or django ORM objects into the indicated model\"\"\"\n    return djdb.import_items(item_seq, dest_model=model, batch_len=batch_len, db_alias=db_alias, verbosity=verbosity)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreading json file and create the appropriate records according to the given database model.", "response": "def import_wiki_json(path='wikipedia_crawler_data.json', model=WikiItem, batch_len=100, db_alias='default', verbosity=2):\n    \"\"\"Read json file and create the appropriate records according to the given database model.\"\"\"\n    return djdb.import_json(path=path, model=model,  batch_len=batch_len, db_alias=db_alias, verbosity=verbosity)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef import_item(self, item, crawler='wiki', truncate_strings=True, verbosity=0):\n    \n        item = dict(item)\n        self.crawler = str(crawler)\n        for k, v in self._item_mapping.iteritems():\n            if verbosity > 2:\n                print('%r: %r' % (k, v))\n            value = item.get(k, v['default'])\n            if value is None:\n                continue\n            try: \n                value = v['type'](value)\n            except:\n                pass\n            field = self.__class__._meta.get_field_by_name(v['name'])[0]\n            if isinstance(value, basestring):\n                max_length = getattr(field, 'max_length', None)\n                if max_length and len(value) > max_length:\n                    if truncate_strings:\n                        value = value[:max_length]\n                    else:\n                        raise RuntimeError('String loaded from json is length %s and destination field max_length is %s.' % (len(value), max_length))\n            if isinstance(field, (models.DateTimeField, models.DateField)):\n                value = util.clean_wiki_datetime(value)\n            setattr(self, v['name'], value)\n        return self", "response": "Import a single record from a Scrapy Item dict."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconvert dictionary into a query string ; keys are always str", "response": "def urlencode(self):\n        \"\"\"\n        Convert dictionary into a query string; keys are\n        assumed to always be str\n        \"\"\"\n        output = ('%s=%s' % (k, quote(v)) for k, v in self.items())\n        return '&'.join(output)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef is_valid(self):\n        is_valid = super(GAErrorReportingMixin, self).is_valid()\n        if self.is_bound and not is_valid:\n            try:\n                self.report_errors_to_ga(self.errors)\n            except:  # noqa: E722\n                logger.exception('Failed to report form errors to Google Analytics')\n        return is_valid", "response": "Check if the form is valid and report errors to Google Analytics."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the name of the ga_event_category attribute of the current object.", "response": "def get_ga_event_category(self):\n        \"\"\"\n        Event category, defaults to form class name\n        \"\"\"\n        return self.ga_event_category or '%s.%s' % (self.__class__.__module__, self.__class__.__name__)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef format_ga_hit(self, field_name, error_message):\n        tracking_id = self.get_ga_tracking_id()\n        if not tracking_id:\n            warnings.warn('Google Analytics tracking ID is not set')\n            return None\n        query_dict = self.get_ga_query_dict()\n        query_dict['tid'] = tracking_id\n        query_dict['cid'] = self.get_ga_client_id()\n        query_dict['ec'] = self.get_ga_event_category()\n        query_dict['ea'] = field_name\n        query_dict['el'] = error_message\n        return query_dict.urlencode()", "response": "Format a single hit in the Google Analytics API format"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreport errors to Google Analytics", "response": "def report_errors_to_ga(self, errors):\n        \"\"\"\n        Report errors to Google Analytics\n        https://developers.google.com/analytics/devguides/collection/protocol/v1/devguide\n        \"\"\"\n        hits = []\n        responses = []\n        for field_name in sorted(errors):\n            for error_message in errors[field_name]:\n                event = self.format_ga_hit(field_name, error_message)\n                if event:\n                    hits.append(event)\n\n        if self.ga_batch_hits:\n            for hit_batch in _batch_hits(hits):\n                response = requests.post(self.get_ga_batch_endpoint(), data=hit_batch)\n                responses.append(response)\n        else:\n            for hit in hits:\n                response = requests.post(self.get_ga_single_endpoint(), data=hit)\n                responses.append(response)\n        return responses"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nretrieves tracking ID from settings", "response": "def get_ga_tracking_id(self):\n        \"\"\"\n        Retrieve tracking ID from settings\n        \"\"\"\n        if hasattr(settings, self.ga_tracking_id_settings_key):\n            return getattr(settings, self.ga_tracking_id_settings_key)\n        return super(GARequestErrorReportingMixin, self).get_ga_tracking_id()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nretrieve the client ID from the Google Analytics cookie if available and save in the current session.", "response": "def get_ga_client_id(self):\n        \"\"\"\n        Retrieve the client ID from the Google Analytics cookie, if available,\n        and save in the current session\n        \"\"\"\n        request = self.get_ga_request()\n        if not request or not hasattr(request, 'session'):\n            return super(GARequestErrorReportingMixin, self).get_ga_client_id()\n        if 'ga_client_id' not in request.session:\n            client_id = self.ga_cookie_re.match(request.COOKIES.get('_ga', ''))\n            client_id = client_id and client_id.group('cid') or str(uuid.uuid4())\n            request.session['ga_client_id'] = client_id\n        return request.session['ga_client_id']"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds user agent IP and Accept - Language to the default hit parameters", "response": "def get_ga_query_dict(self):\n        \"\"\"\n        Adds user agent and IP to the default hit parameters\n        \"\"\"\n        query_dict = super(GARequestErrorReportingMixin, self).get_ga_query_dict()\n        request = self.get_ga_request()\n        if not request:\n            return query_dict\n        user_ip = request.META.get('HTTP_X_FORWARDED_FOR', request.META.get('REMOTE_ADDR', ''))\n        user_ip = user_ip.split(',')[0].strip()\n        user_agent = request.META.get('HTTP_USER_AGENT')\n        user_language = request.META.get('HTTP_ACCEPT_LANGUAGE')\n        if user_ip:\n            query_dict['uip'] = user_ip\n        if user_agent:\n            query_dict['ua'] = user_agent\n        if user_language:\n            query_dict['ul'] = user_language\n        return query_dict"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef build_js(ctx, force=False):\n    for fname in JSX_FILENAMES:\n        jstools.babel(\n            ctx,\n            '{pkg.source_js}/' + fname,\n            '{pkg.django_static}/{pkg.name}/js/' + fname + '.js',\n            force=force\n        )", "response": "Build all javascript files."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nbuilds all the necessary files and collectstatic.", "response": "def build(ctx, less=False, docs=False, js=False, force=False):\n    \"\"\"Build everything and collectstatic.\n    \"\"\"\n    specified = any([less, docs, js])\n    buildall = not specified\n\n    if buildall or less:\n        less_fname = ctx.pkg.source_less / ctx.pkg.name + '.less'\n        if less_fname.exists():\n            lessc.LessRule(\n                ctx,\n                src='{pkg.source_less}/{pkg.name}.less',\n                dst='{pkg.django_static}/{pkg.name}/css/{pkg.name}-{version}.min.css',\n                force=force\n            )\n        elif less:\n            print(\"WARNING: build --less specified, but no file at:\", less_fname)\n\n    if buildall or docs:\n        if WARN_ABOUT_SETTINGS:\n            warnings.warn(\n                \"autodoc might need a dummy settings file in the root of \"\n                \"your package. Since it runs in a separate process you cannot\"\n                \"use settings.configure()\"\n            )\n        doctools.build(ctx, force=force)\n\n    if buildall or js:\n        build_js(ctx, force)\n\n    if HAVE_SETTINGS and (force or changed(ctx.pkg.django_static)):\n        collectstatic(ctx, DJANGO_SETTINGS_MODULE)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef watch(ctx):\n    watcher = Watcher(ctx)\n    watcher.watch_directory(\n        path='{pkg.source_less}', ext='.less',\n        action=lambda e: build(ctx, less=True)\n    )\n    watcher.watch_directory(\n        path='{pkg.source_js}', ext='.jsx',\n        action=lambda e: build(ctx, js=True)\n    )\n    watcher.watch_directory(\n        path='{pkg.docs}', ext='.rst',\n        action=lambda e: build(ctx, docs=True)\n    )\n    watcher.start()", "response": "Automatically run build whenever a relevant file changes."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _force_float(v):\n    try:\n        return float(v)\n    except Exception as exc:\n        return float('nan')\n        logger.warning('Failed to convert {} to float with {} error. Using 0 instead.'.format(v, exc))", "response": "Converts given argument to float. On fail logs warning and returns 0. 0."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a dict that can be passed into the ColumnStats constructor.", "response": "def dict(self):\n        \"\"\"Return a  dict that can be passed into the ColumnStats constructor\"\"\"\n\n        try:\n            skewness = self.skewness\n            kurtosis = self.kurtosis\n        except ZeroDivisionError:\n            skewness = kurtosis = float('nan')\n\n        base_cols = [\n            ('name', self.column_name),\n            ('flags', self.flags),\n            ('type', self.type.__name__ ),\n            ('lom', self.lom),\n            ('count', self.n),\n            ('nuniques', self.nuniques),\n            ('width', self.size),\n        ]\n\n        descriptive_cols = [\n            ('mean', self.mean),\n            ('std', self.stddev),\n            ('min', self.min),\n            ('p25', self.p25),\n            ('p50', self.p50),\n            ('p75', self.p75),\n            ('max', self.max)\n        ]\n\n        distribution_cols = [\n            ('skewness', skewness),\n            ('kurtosis', kurtosis),\n            ('hist', self.bins),\n            ('text_hist', text_hist(self.bins)),\n        ]\n\n        sample_values_cols = [\n            ('uvalues', self.uvalues)\n        ]\n\n        return OrderedDict(\n           base_cols +\n           (descriptive_cols if self.descriptive else []) +\n           (distribution_cols if self.distribution else []) +\n           (sample_values_cols if self.sample_values else [])\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nrunning the stats. The source must yield Row proxies.", "response": "def run(self):\n        \"\"\" Run the stats. The source must yield Row proxies.\n        \"\"\"\n\n        self._func, self._func_code = self.build()\n\n        def process_row(row):\n\n            try:\n                self._func(self._stats, row)\n            except TypeError as e:\n                raise TypeError(\"Failed for '{}'; {}\".format(self._func_code, e))\n            except KeyError:\n                raise KeyError(\n                    'Failed to find key in row. headers = \"{}\", code = \"{}\" '\n                    .format(list(row.keys()), self._func_code))\n            except Exception as e:\n                raise type(e)(\n                    'General exception in stats. headers = \"{}\", code = \"{}\": {} '\n                        .format(list(row.keys()), self._func_code, e))\n\n        # Use all of the rows in the source\n        if self._sample_size is None:\n            for i, row in enumerate(self._source):\n                process_row(row)\n        # Use a sample of rows, evenly distributed though the source\n        else:\n\n            skip_rate = self._sample_size / self._n_rows\n\n            i = 0\n            skip = skip_rate\n            for j, row in enumerate(self._source):\n                skip += skip_rate\n                if skip >= 1:\n                    skip -= 1\n                    i += 1\n                    process_row(row)\n\n        if i < 5000:  # Since the hist bins aren't built until 5K row\n            for k, v in self._stats.items():\n                v._build_hist_bins()\n\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_labs(format):\n\n    hackerspaces_json = data_from_hackaday_io(hackaday_io_labs_map_url)\n    hackerspaces = {}\n\n    # Load all the Hackerspaces\n    for i in hackerspaces_json:\n        current_lab = Hackerspace()\n        current_lab.id = i[\"id\"]\n        current_lab.url = \"https://hackaday.io/hackerspace/\" + current_lab.id\n        current_lab.name = i[\"name\"]\n        if len(i[\"description\"]) != 0:\n            current_lab.description = i[\"description\"]\n        elif len(i[\"summary\"]) != 0:\n            current_lab.description = i[\"summary\"]\n        current_lab.created_at = i[\"moments\"][\"exact\"]\n\n        # Check if there are coordinates\n        if i[\"latlon\"] is not None:\n            latlon = json.loads(i[\"latlon\"])\n            current_lab.latitude = latlon[\"lat\"]\n            current_lab.longitude = latlon[\"lng\"]\n            # Get country, county and city from them\n            country = geolocator.reverse(\n                [latlon[\"lat\"], latlon[\"lng\"]])\n            current_lab.country = country.raw[\n                \"address\"][\"country\"]\n            current_lab.address = country.raw[\"display_name\"]\n            current_lab.address_1 = country.raw[\"display_name\"]\n            current_lab.country_code = country.raw[\n                \"address\"][\"country_code\"]\n            current_lab.county = country.raw[\n                \"address\"][\"state_district\"]\n            current_lab.city = country.raw[\n                \"address\"][\"city\"]\n            current_lab.postal_code = country.raw[\n                \"address\"][\"postcode\"]\n        else:\n            # For labs without a location or coordinates\n            # add 0,0 as coordinates\n            current_lab.latitude = 0.0\n            current_lab.longitude = 0.0\n\n        # Add the lab\n        hackerspaces[i[\"name\"]] = current_lab\n\n    # Return a dictiornary / json\n    if format.lower() == \"dict\" or format.lower() == \"json\":\n        output = {}\n        for j in hackerspaces:\n            output[j] = hackerspaces[j].__dict__\n    # Return a geojson\n    elif format.lower() == \"geojson\" or format.lower() == \"geo\":\n        labs_list = []\n        for l in hackerspaces:\n            single = hackerspaces[l].__dict__\n            single_lab = Feature(\n                type=\"Feature\",\n                geometry=Point((single[\"latitude\"], single[\"longitude\"])),\n                properties=single)\n            labs_list.append(single_lab)\n        output = dumps(FeatureCollection(labs_list))\n    # Return a Pandas DataFrame\n    elif format.lower() == \"pandas\" or format.lower() == \"dataframe\":\n        output = {}\n        for j in hackerspaces:\n            output[j] = hackerspaces[j].__dict__\n        # Transform the dict into a Pandas DataFrame\n        output = pd.DataFrame.from_dict(output)\n        output = output.transpose()\n    # Return an object\n    elif format.lower() == \"object\" or format.lower() == \"obj\":\n        output = hackerspaces\n    # Default: return an oject\n    else:\n        output = hackerspaces\n    # Return a proper json\n    if format.lower() == \"json\":\n        output = json.dumps(output)\n    return output", "response": "Gets the Hackerspaces data from hackaday. io."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_digital_channels(channel_list):\n    dig_ids = digital_channel_ids()\n    dig_channels = []\n    for ln in dig_ids:\n        for ch in channel_list:\n            if ch.dct['id'] == ln:\n                dig_channels.append(ch)\n                break\n    return dig_channels", "response": "Goes through channel list and returns a list of digital channels with ids\n    Dev1 / port0. line08 Dev1 / port0. line09 Dev1 / port0. line30."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nchecking ramp for errors.", "response": "def check_ramp_for_errors(ramp_data):\n    \"\"\"Checks ramp for errors. This is experiment specific checklist.\"\"\"\n    error_list = []\n    keyframe_list = ramps.KeyFrameList(ramp_data['keyframes'])\n    sorted_key_list = keyframe_list.sorted_key_list()\n    channel_list = [ramps.Channel(ch_name, ramp_data['channels'][ch_name],\n                                  keyframe_list)\n                    for ch_name in ramp_data['channels']]\n    sorted_absolute_times = [keyframe_list.get_absolute_time(sk) for sk\n                             in sorted_key_list]\n    ramp_properties = ramp_data['properties']\n    jump_resolution = ramp_properties['jump_resolution']\n    for key_name, abs_time in zip(sorted_key_list, sorted_absolute_times):\n        # check if all times are +ve\n        if abs_time < 0.0:\n            error_fmt = \"keyframe \\'{0}\\' has negative absolute time {1}\"\n            error_str = error_fmt.format(key_name, abs_time)\n            error_list.append(error_str)\n\n        # check if all times are a multiple of minimum resolution\n        steps_float = abs_time / jump_resolution\n        steps_residue = steps_float - round(steps_float)\n        if steps_residue > 0.0001:\n            error_fmt = (\"keyframe \\'{0}\\' has absolute time {1} which is not\"\n                         \" a multiple of jump_resolution {2}\")\n            error_str = error_fmt.format(key_name, abs_time, jump_resolution)\n            error_list.append(error_str)\n\n    # find missing channels\n    ch_ids = digital_channel_ids()\n    ch_ids += dev2_analog_ids()\n    # ignore p31, since we used that for Dev1 timing\n    for ch_id in ch_ids:\n        n_found = 0\n        for ch in channel_list:\n            if ch.dct['id'] == ch_id:\n                n_found += 1\n        if n_found != 1:\n            error_fmt = '{0} copies of {1} found. There should only be 1'\n            error_str = error_fmt.format(n_found, ch_id)\n            error_list.append(error_str)\n\n    # check for timing overlap in keyframelist\n    error_keyname = keyframe_list.do_keyframes_overlap()\n    if error_keyname is not None:\n        error_fmt = '{0} overlaps with the next keyframe'\n        error_str = error_fmt.format(error_keyname)\n        error_list.append(error_str)\n\n\n    return error_list"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef make_folder_for_today(log_dir):\n    now = datetime.datetime.now()\n    sub_folders_list = ['{0:04d}'.format(now.year),\n                        '{0:02d}'.format(now.month),\n                        '{0:02d}'.format(now.day)]\n    folder = log_dir\n    for sf in sub_folders_list:\n        folder = os.path.join(folder, sf)\n        if not os.path.exists(folder):\n            os.makedirs(folder)\n    return folder", "response": "Creates the folder log_dir if it doesn t exist and returns the full path of the folder."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nredistributes duplicates between the google map sets", "response": "def redistribute_duplicates(data):\n    \"\"\"Given a dictionary of photo sets, will look at lat/lon between\n    sets, if they match, randomly move them around so the google map\n    markeres do not overlap\n    \"\"\"\n    \n    coordinate_list=[]\n    # Build a list of coordinates\n    for myset in data['sets']:\n        coordinate_list.append((myset['latitude'],myset['longitude']))\n\n    for myset in data['sets']:\n        lat=myset['latitude']\n        lon=myset['longitude']\n        item=(lat,lon)\n        if coordinate_list.count(item) > 1:\n            print(\"moving %s\"%(myset['set_title']))\n            random_number=random.random()\n            myset['latitude']=str(random_number*POS_MOVE_DEG\\\n                    +float(myset['latitude']))\n            myset['longitude']=str(random_number*POS_MOVE_DEG\\\n                    +float(myset['longitude']))"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncolours text if possible.", "response": "def _colourise(text: str, colour: str) -> str:\n    \"\"\"Colour text, if possible.\n\n    Args:\n        text: Text to colourise\n        colour: Colour to display text in\n    Returns:\n        Colourised text, if possible\n    \"\"\"\n    if COLOUR:\n        text = style(text, fg=colour, bold=True)\n    return text"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _apply(self, ctx: ExtensionContext) -> AugmentedDict:\n        def process(pattern: Pattern[str], _str: str) -> Any:\n            _match = pattern.match(_str)\n            if _match is None:\n                return _str  # pragma: no cover\n            # We got a match\n            # Group 0: Whole match; Group 1: Our placeholder;\n            # Group 2: file path to external resource\n            placeholder, external_path = _match.group(1), _match.group(2)\n            with open(self.locator(\n                    external_path,\n                    cast(str, ctx.document) if Validator.is_file(document=ctx.document) else None\n            )) as fhandle:\n                # Json does not support line breaks. We will have to mask them\n                content = fhandle.read()\n            return _str.replace(placeholder, content)\n\n        node_key, node_value = ctx.node\n        _pattern = re.compile(self.__pattern__)\n        return {node_key: process(_pattern, node_value)}", "response": "Applies the loading of an external resource into the current model."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _config(self) -> ExtensionConfig:\n        return dict(pattern=self.__pattern__, search_in_keys=True, search_in_values=False)", "response": "Returns the configuration dictionary for the node key only."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nload a yaml fragment from an external file.", "response": "def _apply(self, ctx: ExtensionContext) -> Any:\n        \"\"\"\n        Loads a yaml fragment from an external file.\n\n        Args:\n            ctx: The processing context.\n\n        Returns:\n            The external resource as a python dictionary. The fragment is already send through\n            the processor as well.\n        \"\"\"\n        _, external_path = ctx.node\n        return ctx.mentor.load_yaml(self.locator(\n            external_path,\n            cast(str, ctx.document) if Validator.is_file(document=ctx.document) else None\n        ))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\napply the filter to the current context and returns the altered node key and value.", "response": "def _apply(self, ctx: ExtensionContext) -> AugmentedDict:\n        \"\"\"\n        Replaces any {{env::*}} directives with it's actual environment variable value or a default.\n\n        Args:\n            ctx: The processing context.\n\n        Returns:\n            Returns the altered node key and value.\n        \"\"\"\n        node_key, node_value = ctx.node\n\n        def process(pattern: Pattern[str], _str: str) -> str:\n            _match = pattern.match(_str)\n            if _match is None:\n                return _str\n            # We got a match\n            # Group 0: Whole match; Group 1: Our placeholder; Group 2: The environment variable\n            placeholder, envvar = _match.group(1), _match.group(2)\n            envvalue = os.environ.get(envvar, None)\n            if envvalue is None and self.fail_on_unset:\n                raise ExtensionError(\"Environment variable '{}' is unset.\".format(envvar))\n\n            return _str.replace(placeholder, envvalue or self.default)\n\n        _pattern = re.compile(self.__pattern__)\n        node_key = process(_pattern, node_key)\n        node_value = process(_pattern, node_value)\n\n        return {node_key: node_value}"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\napplying the filter to the current context and returns the altered node key and value.", "response": "def _apply(self, ctx: ExtensionContext) -> AugmentedDict:\n        \"\"\"\n        Replaces any {{var::*}} directives with it's actual variable value or a default.\n\n        Args:\n            ctx: The processing context.\n\n        Returns:\n            Returns the altered node key and value.\n        \"\"\"\n        node_key, node_value = ctx.node\n\n        def process(pattern: Pattern[str], _str: str) -> Any:\n            _match = pattern.match(_str)\n            if _match is None:\n                return _str\n            # We got a match\n            # Group 0: Whole match; Group 1: Our placeholder; Group 2: The environment variable\n            placeholder, varname = _match.group(1), _match.group(2)\n            varval = self.vars.get(varname, None)\n            if varval is None and self.fail_on_unset:\n                raise ExtensionError(\"Variable '{}' is unset.\".format(varname))\n\n            return _str.replace(placeholder, varval or self.default)\n\n        _pattern = re.compile(self.__pattern__)\n        node_key = process(_pattern, node_key)\n        node_value = process(_pattern, node_value)\n\n        return {node_key: node_value}"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef preprocess(self):\n        '''\n        Performs initial cell conversions to standard types. This will strip units, scale numbers,\n        and identify numeric data where it's convertible.\n        '''\n        self.processed_tables = []\n        self.flags_by_table = []\n        self.units_by_table = []\n        for worksheet, rtable in enumerate(self.raw_tables):\n            ptable, flags, units = self.preprocess_worksheet(rtable, worksheet)\n            self.processed_tables.append(ptable)\n            self.flags_by_table.append(flags)\n            self.units_by_table.append(units)\n\n        return self.processed_tables", "response": "Performs initial cell conversions to standard types. This will strip units scale numbers and numeric data where it s convertible."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngenerates all blocks from the input tables.", "response": "def generate_blocks(self, assume_complete_blocks=None):\n        '''\n        Identifies and extracts all blocks from the input tables. These blocks are logical\n        identifiers for where related information resides in the original table. Any block can be\n        converted into a row-titled table which can then be stitched together with other tables from\n        other blocks to form a fully converted data set.\n\n        Args:\n            assume_complete_blocks: Optimizes block loopups by not allowing titles to be extended.\n                Blocks should be perfectly dense to be found when active. Optional, defaults to\n                constructor value.\n        '''\n        # Store this value to restore object settings later\n        _track_assume_blocks = self.assume_complete_blocks\n        try:\n            if assume_complete_blocks != None:\n                self.assume_complete_blocks = assume_complete_blocks\n            if self.processed_tables == None:\n                self.preprocess()\n            self.processed_blocks = []\n\n            for worksheet in range(len(self.processed_tables)):\n                ptable = self.processed_tables[worksheet]\n                flags = self.flags_by_table[worksheet]\n                units = self.units_by_table[worksheet]\n\n                if not self.assume_complete_blocks:\n                    self.fill_in_table(ptable, worksheet, flags)\n\n                self.processed_blocks.extend(self._find_blocks(ptable, worksheet, flags, units,\n                        { 'worksheet': worksheet }))\n\n            return self.processed_blocks\n        finally:\n            # After execution, reset assume_complete_blocks back\n            self.assume_complete_blocks = _track_assume_blocks"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nperforming a preprocess pass of the table to attempt naive conversions of data and to record the initial types of each cell.", "response": "def preprocess_worksheet(self, table, worksheet):\n        '''\n        Performs a preprocess pass of the table to attempt naive conversions of data and to record\n        the initial types of each cell.\n        '''\n        table_conversion = []\n        flags = {}\n        units = {}\n        for rind, row in enumerate(table):\n            conversion_row = []\n            table_conversion.append(conversion_row)\n            if self.skippable_rows and worksheet in self.skippable_rows and rind in self.skippable_rows[worksheet]:\n                self.flag_change(flags, 'interpreted', (rind, None), worksheet, self.FLAGS['skipped-row'])\n                continue\n            for cind, cell in enumerate(row):\n                position = (rind, cind)\n                if self.skippable_columns and worksheet in self.skippable_columns and cind in self.skippable_columns[worksheet]:\n                    conversion = None\n                    self.flag_change(flags, 'interpreted', position, worksheet, self.FLAGS['skipped-column'])\n                else:\n                    # Do the heavy lifting in pre_process_cell\n                    conversion = auto_convert_cell(self, cell, position, worksheet, flags, units,\n                            parens_as_neg=self.parens_as_neg)\n                conversion_row.append(conversion)\n        # Give back our conversions, type labeling, and conversion flags\n        return table_conversion, flags, units"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nfill in any rows with missing right hand side data with empty cells.", "response": "def fill_in_table(self, table, worksheet, flags):\n        '''\n        Fills in any rows with missing right hand side data with empty cells.\n        '''\n        max_row = 0\n        min_row = sys.maxint\n        for row in table:\n            if len(row) > max_row:\n                max_row = len(row)\n            if len(row) < min_row:\n                min_row = len(row)\n        if max_row != min_row:\n            for row in table:\n                if len(row) < max_row:\n                    row.extend([None]*(max_row-len(row)))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _find_blocks(self, converted_table, worksheet, flags, units,\n                     block_meta=None, start_pos=None, end_pos=None):\n        '''\n        A block is considered any region where we have the following structure:\n\n        text | text or number | ... | text of number\n        text | number         | ... | number\n        text | number         | ... | number\n        ...    .                .     .\n        ...    .                .     .\n        ...    .                .     .\n\n        or:\n\n        text           | ... | text           | text\n        text or number | ... | text or number | number\n        text or number | ... | text of number | number\n        ...              .     .                .\n        ...              .     .                .\n        ...              .     .                .\n\n        With the default cases of all text and all numbers matching to a single block encompassing\n        the entire table.\n        '''\n        blocks = []\n        used_cells = []\n\n        if start_pos == None:\n            start_pos = (0, 0)\n        if end_pos == None:\n            end_pos = (len(converted_table), max(\n                            len(row) for row in converted_table))\n\n        # Track used cells -- these can be non-rectangular, but must be 2D\n        for row in converted_table:\n            used_cells.append([False]*len(row))\n        # Catch an empty table or blank rows\n        if not converted_table or all(not row for row in converted_table):\n            blocks.append(converted_table)\n            self.flag_change(flags, 'error', worksheet=worksheet, message=\"Empty table\")\n            return blocks\n\n        # Start with a boolean to get the while loop going\n        block = True\n        block_search_start = start_pos\n        while block:\n            # Returns None if no more blocks exist\n            block = self._find_valid_block(converted_table, worksheet, flags, units, used_cells,\n                        block_search_start, end_pos)\n            if block:\n                blocks.append(block)\n                # Restart on the row of the last block at the\n                # beginning column\n                block_search_start = (block.start[0], start_pos[1])\n\n        return blocks", "response": "Find all valid blocks in the table."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsearch for the next location where a valid block could reside and constructs the block object representing that location.", "response": "def _find_valid_block(self, table, worksheet, flags, units, used_cells, start_pos, end_pos):\n        '''\n        Searches for the next location where a valid block could reside and constructs the block\n        object representing that location.\n        '''\n        for row_index in range(len(table)):\n            if row_index < start_pos[0] or row_index > end_pos[0]:\n                continue\n            convRow = table[row_index]\n            used_row = used_cells[row_index]\n            for column_index, conv in enumerate(convRow):\n                if (column_index < start_pos[1] or column_index > end_pos[1] or used_row[column_index]):\n                    continue\n                # Is non empty cell?\n                if not is_empty_cell(conv):\n                    block_start, block_end = self._find_block_bounds(table, used_cells,\n                            (row_index, column_index), start_pos, end_pos)\n                    if (block_end[0] > block_start[0] and\n                        block_end[1] > block_start[1]):\n                        try:\n                            return TableBlock(table, used_cells, block_start, block_end, worksheet,\n                                flags, units, self.assume_complete_blocks, self.max_title_rows)\n                        except InvalidBlockError:\n                            pass\n                        # Prevent infinite loops if something goes wrong\n                        used_cells[row_index][column_index] = True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _find_block_bounds(self, table, used_cells, possible_block_start, start_pos, end_pos):\n        '''\n        First walk the rows, checking for the farthest left column belonging to the block and the\n        bottom most row belonging to the block. If a blank cell is hit and the column started with a\n        blank cell or has length < self.blank_repeat_threshold, then restart one row to the right.\n        Alternatively, if assume_complete_blocks has been set to true, any blank cell stops block\n        detection.\n\n        Then walk the columns until a column is reached which has blank cells down to the row which\n        marked the as the row end from prior iteration.\n        '''\n        # If we're only looking for complete blocks, then just walk\n        # until we hit a blank cell\n        if self.assume_complete_blocks:\n            block_start, block_end = self._find_complete_block_bounds(\n                                        table, used_cells, possible_block_start,\n                                        start_pos, end_pos)\n        # Otherwise do a smart, multi-pass approach to finding blocks\n        # with potential missing fields\n        else:\n            block_start, block_end = self._find_block_start(\n                                        table, used_cells, possible_block_start,\n                                        start_pos, end_pos)\n\n            block_start, block_end = self._find_block_end(\n                                        table, used_cells, block_start, block_end,\n                                        start_pos, end_pos)\n        return block_start, block_end", "response": "Find the start and end positions of the block that is found in the cell list."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _find_complete_block_bounds(self, table, used_cells, possible_block_start,\n                                    start_pos, end_pos):\n        '''\n        Finds the end of a block from a start location and a suggested end location.\n        '''\n        block_start = list(possible_block_start)\n        block_end = list(possible_block_start)\n        table_row = table[block_start[0]]\n        used_row = used_cells[block_start[0]]\n        # Find which column the titles end on\n        for column_index in range(block_start[1], end_pos[1]+1):\n            # Ensure we catch the edge case of the data reaching the edge of\n            # the table -- block_end should then equal end_pos\n            block_end[1] = max(block_end[1], column_index)\n            if (column_index == end_pos[1] or used_row[column_index] or\n                    is_empty_cell(table_row[column_index])):\n                break\n        for row_index in range(block_start[0]+1, end_pos[0]+1):\n            block_end[0] = row_index\n            # Stop if we reach the end of the table space\n            if block_end[0] == end_pos[0]:\n                break\n            table_row = table[row_index]\n            blank = False\n            for column_index in range(block_start[1], block_end[1]):\n                if (column_index == block_end[1] or used_row[column_index] or\n                        is_empty_cell(table_row[column_index])):\n                    blank = True\n                    break\n            if blank:\n                break\n        return block_start, block_end", "response": "Find the start and end of a complete block from a start location and a suggested end location."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn true if the row is a single length title element with no other row titles. Useful for tracking pre - data titles that belong in the block.", "response": "def _single_length_title(self, table, row_index, current_col):\n        '''\n        Returns true if the row is a single length title element with no other row titles. Useful\n        for tracking pre-data titles that belong in their own block.\n        '''\n        if len(table[row_index]) - current_col <= 0:\n            return False\n        return (is_text_cell(table[row_index][current_col]) and\n                all(not is_text_cell(table[row_index][next_column])\n                    for next_column in xrange(current_col + 1, len(table[row_index]))))"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfinds the start of a block from a suggested start location.", "response": "def _find_block_start(self, table, used_cells, possible_block_start, start_pos, end_pos):\n        '''\n        Finds the start of a block from a suggested start location. This location can be at a lower\n        column but not a lower row. The function traverses columns until it finds a stopping\n        condition or a repeat condition that restarts on the next column.\n\n        Note this also finds the lowest row of block_end.\n        '''\n        current_col = possible_block_start[1]\n        block_start = list(possible_block_start)\n        block_end = list(possible_block_start)\n        repeat = True\n        checked_all = False\n\n        # Repeat until we've met satisfactory conditions for catching all edge cases or we've\n        # checked all valid block locations\n        while not checked_all and repeat:\n            block_end[0] = max(block_end[0], possible_block_start[0])\n            block_end[1] = max(block_end[1], current_col)\n            single_titled_block = True\n            table_column = TableTranspose(table)[current_col]\n            used_column = TableTranspose(used_cells)[current_col]\n            # We need to find a non empty cell before we can stop\n            blank_start = is_empty_cell(table_column[possible_block_start[0]])\n            blank_exited = not blank_start\n            # Unless we have assume_complete_blocks set to True\n            if blank_start and self.assume_complete_blocks:\n                # Found a blank? We're done\n                repeat = False\n                break\n\n            #TODO refactor code below into new function for easier reading\n            # Analyze the beginning columns\n            for row_index in xrange(possible_block_start[0], end_pos[0] + 1):\n                # Ensure we catch the edge case of the data reaching the edge of the table --\n                # block_end should then equal end_pos\n                if blank_exited:\n                    block_end[0] = max(block_end[0], row_index)\n                if row_index == end_pos[0] or used_column[row_index]:\n                    # We've gone through the whole range\n                    checked_all = True\n                    repeat = False\n                    break\n                if not blank_exited:\n                    blank_exited = not is_empty_cell(table_column[row_index])\n                if single_titled_block and not self._single_length_title(table, row_index, current_col):\n                    single_titled_block = False\n                    # If we saw single length titles for several more than threshold rows, then we\n                    # have a unique block before an actual content block\n                    if self._above_blank_repeat_threshold(possible_block_start[0], row_index):\n                        repeat = False\n                        break\n                if is_empty_cell(table_column[row_index]) and len(table[row_index]) > current_col + 1:\n                    current_col += 1\n                    break\n\n                # Go find the left most column that's still valid\n                table_row = table[row_index]\n                used_row = used_cells[row_index]\n                for column_index in range(current_col, start_pos[1] - 1, -1):\n                    if is_empty_cell(table_row[column_index]) or used_row[column_index]:\n                        break\n                    else:\n                        block_start[1] = min(block_start[1], column_index)\n                # Check if we've seen few enough cells to guess that we have a repeating title\n                repeat = blank_start or self._below_blank_repeat_threshold(possible_block_start[0], row_index)\n\n        return block_start, block_end"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nfinds the end of a block from a start location and a suggested end location.", "response": "def _find_block_end(self, table, used_cells, block_start, block_end, start_pos, end_pos):\n        '''\n        Finds the end of a block from a start location and a suggested end location.\n        '''\n        table_row = table[block_start[0]]\n        used_row = used_cells[block_start[0]]\n        table_transpose = TableTranspose(table)\n\n        # Find which column the titles end on\n        for column_index in range(block_start[1], end_pos[1] + 1):\n            # Ensure we catch the edge case of the data reaching the edge of the table -- block_end\n            # should then equal end_pos\n            block_end[1] = max(block_end[1], column_index)\n            if column_index == end_pos[1]:\n                break\n            if used_row[column_index]:\n                break\n            elif is_empty_cell(table_row[column_index]):\n                table_column = table_transpose[column_index]\n                found_cell = False\n                for row_index in range(block_start[0], block_end[0]):\n                    if not is_empty_cell(table_column[row_index]):\n                        found_cell = True\n                        break\n                # If we have a column of blanks, stop\n                if not found_cell:\n                    break\n        return block_start, block_end"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef threader(group=None, name=None, daemon=True):\n    def decorator(job):\n        \"\"\"\n        :param job: function to be threaded\n        :rtype: wrap\n        \"\"\"\n        def wrapped_job(queue, *args, **kwargs):\n            \"\"\" this function calls the decorated function\n            and puts the result in a queue\n            :type queue: Queue\n            \"\"\"\n            ret = job(*args, **kwargs)\n            queue.put(ret)\n\n        def wrap(*args, **kwargs):\n            \"\"\" this is the function returned from the decorator. It fires off\n            wrapped_f in a new thread and returns the thread object with\n            the result queue attached\n            :rtype: Thread\n            \"\"\"\n            thread = Thread(group=group, target=wrapped_job, name=name, args=args, kwargs=kwargs, daemon=daemon)\n            thread.start()\n            return thread\n        return wrap\n    return decorator", "response": "Threader decorator for functions in order to use the same thread as the function in the thread group."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the error as a path to message dictionary.", "response": "def as_dict(self, join='.'):\n        \"\"\"\n        Returns the error as a path to message dictionary. Paths are joined\n        with the ``join`` string.\n        \"\"\"\n        if self.path:\n            path = [str(node) for node in self.path]\n        else:\n            path = ''\n        return { join.join(path): self.message }"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn all the errors in this collection as a path to message dictionary.", "response": "def as_dict(self, join='.'):\n        \"\"\"\n        Returns all the errors in this collection as a path to message\n        dictionary. Paths are joined with the ``join`` string.\n        \"\"\"\n        result = {}\n        for e in self.errors:\n            result.update(e.as_dict(join))\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef load_gffutils_db(f):\n    import gffutils\n    db = gffutils.FeatureDB(f, keep_order=True)\n    return db", "response": "Load database for gffutils. \n\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef make_gffutils_db(gtf, db):\n    import gffutils\n    out_db = gffutils.create_db(gtf,\n                                db,\n                                keep_order=True,\n                                infer_gene_extent=False)\n    return out_db", "response": "Make database for a single node."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nmake a bed file with promoters for transcripts or genes from the Gencode GTF file. Parameters ---------- gtf : str Filename of the Gencode gtf file. up : int Number of bases to add upstream of the transcription start site. down : int Number of bases to add downstream of the transcription start site. feature : str Either transcript or gene. If transcript, promoters, for each transcript will be included. If gene, a promoter for each gene entry in the GTF will be included. use_gene_id : bool If True and feature='transcript', the gene ID will be used to name each promoter rather than the transcript ID. merge_by_gene : bool If True and feature='transcript', promoters from all of the transcripts of the same gene will be merged and named using the gene ID. This is useful for knowing what sequences are promoters for a given gene. tss : bool Output the transcription start site for each transcript. The up and down options will be ignored and the single base that is the TSS will be written. out : str If provided, the bed file will be written to a file with this name. unique_name : bool If True, ensure that the name column is unique. If the column isn't unique, the coordinates are added to the column to make it unique. Returns ------- bed : pybedtools.BedTool A sorted pybedtools BedTool object.", "response": "def make_promoter_bed(\n    gtf, \n    up=2000, \n    down=200, \n    feature='transcript',\n    use_gene_id=False, \n    merge_by_gene=False, \n    tss=False,\n    out=None, \n    unique_name=True,\n):\n    \"\"\"\n    Make a bed file with promoters for transcripts or genes from the Gencode GTF\n    file.\n\n    Parameters\n    ----------\n    gtf : str\n        Filename of the Gencode gtf file.\n\n    up : int\n        Number of bases to add upstream of the transcription start site.\n\n    down : int\n        Number of bases to add downstream of the transcription start site.\n\n    feature : str\n        Either transcript or gene. If transcript, promoters, for each transcript\n        will be included. If gene, a promoter for each gene entry in the GTF\n        will be included.\n\n    use_gene_id : bool\n        If True and feature='transcript', the gene ID will be used to name each\n        promoter rather than the transcript ID.\n\n    merge_by_gene : bool\n        If True and feature='transcript', promoters from all of the transcripts\n        of the same gene will be merged and named using the gene ID. This is\n        useful for knowing what sequences are promoters for a given gene.\n\n    tss : bool\n        Output the transcription start site for each transcript. The up and down\n        options will be ignored and the single base that is the TSS will be\n        written.\n\n    out : str\n        If provided, the bed file will be written to a file with this name.\n\n    unique_name : bool\n        If True, ensure that the name column is unique. If the column isn't\n        unique, the coordinates are added to the column to make it unique.\n\n    Returns\n    -------\n    bed : pybedtools.BedTool\n        A sorted pybedtools BedTool object. \n\n    \"\"\"\n    import HTSeq\n    import itertools as it\n\n    if merge_by_gene:\n        use_gene_id = True\n\n    plus_feats = []\n    minus_feats = []\n    if feature == 'gene' or use_gene_id or merge_by_gene:\n        name_id = 'gene_id'\n    elif feature == 'transcript':\n        name_id = 'transcript_id'\n\n    if tss:\n        ftype = 'tss'\n    else:\n        ftype = 'promoter'\n\n    gtf = it.islice(HTSeq.GFF_Reader(gtf), None)\n    line = gtf.next()\n    while line != '':\n        if line.type == feature:\n            if line.iv.strand == '+':\n                plus_feats.append(\n                    ('\\t'.join([line.iv.chrom, str(line.iv.start),\n                                str(line.iv.start),\n                                '{}_{}'.format(line.attr[name_id], ftype), '.',\n                                line.iv.strand])))\n            elif line.iv.strand == '-':\n                minus_feats.append(\n                    ('\\t'.join([line.iv.chrom, str(line.iv.end),\n                                str(line.iv.end),\n                                '{}_{}'.format(line.attr[name_id], ftype), '.',\n                                line.iv.strand])))\n        try:\n            line = gtf.next()\n        except StopIteration:\n            line = ''\n\n    plus = pbt.BedTool('\\n'.join(plus_feats) + '\\n', from_string=True)\n    minus = pbt.BedTool('\\n'.join(minus_feats) + '\\n', from_string=True)\n\n    if tss:\n        plus = plus.slop(l=0, r=1, g=pbt.chromsizes('hg19'))\n        minus = minus.slop(l=1, r=0, g=pbt.chromsizes('hg19'))\n    else:\n        plus = plus.slop(l=up, r=down, g=pbt.chromsizes('hg19'))\n        minus = minus.slop(l=down, r=up, g=pbt.chromsizes('hg19'))\n\n    if merge_by_gene:\n        plus = merge_bed_by_name(plus)\n        minus = merge_bed_by_name(minus)\n\n    bt  = plus.cat(minus, postmerge=False)\n    # We'll sort so bedtools operations can be done faster.\n    bt = bt.sort()\n\n    if unique_name:\n        df = bt.to_dataframe()\n        if len(set(df['name'])) != df.shape[0]:\n            df['name'] = (df.name + '_' + df.chrom.astype(str) + ':' +\n                          df.start.astype(str) + '-' + df.end.astype(str))\n            bt = pbt.BedTool('\\n'.join(['\\t'.join([str(x) for x in y]) for y in\n                                        df.values]) + '\\n', from_string=True)\n\n    if out:\n        bt.saveas(out)\n    return bt"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nmerge intervals in a bed file when the intervals have the same name.", "response": "def merge_bed_by_name(bt):\n    \"\"\"\n    Merge intervals in a bed file when the intervals have the same name.\n    Intervals with the same name must be adjacent in the bed file.\n\n    \"\"\"\n    name_lines = dict()\n    for r in bt:\n        name = r.name\n        name_lines[name] = name_lines.get(name, []) + [[r.chrom, r.start, \n                                                         r.end, r.name,\n                                                         r.strand]]\n    new_lines = []\n    for name in name_lines.keys():\n        new_lines += _merge_interval_list(name_lines[name])\n    new_lines = ['\\t'.join(map(str, x)) for x in new_lines]\n    return pbt.BedTool('\\n'.join(new_lines) + '\\n', from_string=True)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef make_feature_bed(gtf, feature, out=None):\n    bed_lines = []\n    with open(gtf) as f:\n        line = f.readline().strip()\n        while line != '':\n            if line[0] != '#':\n                line = line.split('\\t')\n                if line[2] == feature:\n                    chrom = line[0]\n                    start = str(int(line[3]) - 1)\n                    end = line[4]\n                    if feature == 'gene':\n                        name = line[8].split(';')[0].split(' ')[1].strip('\"')\n                    else:\n                        # TODO: I may want to have some smarter naming for\n                        # things that aren't genes or transcripts.\n                        name = line[8].split(';')[1].split(' ')[2].strip('\"')\n                    strand = line[6]\n                    bed_lines.append('\\t'.join([chrom, start, end, name, '.',\n                                                strand]) + '\\n')\n            line = f.readline().strip()\n    bt = pbt.BedTool(''.join(bed_lines), from_string=True)\n    # We'll sort so bedtools operations can be done faster.\n    bt = bt.sort()\n    if out:\n        bt.saveas(out)\n    return bt", "response": "Make a bed file with the start stop coordinates for all of a particular feature in Gencode GTF file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a Pandas Series with the transcript ID s as the index and values as the gene ID containing that transcript.", "response": "def make_transcript_gene_se(fn):\n    \"\"\"\n    Make a Pandas Series with transcript ID's as the index and values as the\n    gene ID containing that transcript.\n\n    Parameters\n    ----------\n    fn : str\n        Filename of the Gencode gtf file.\n\n    Returns\n    -------\n    se : pandas.Series\n        Make a Pandas Series with transcript ID's as the index and values as the\n        gene ID containing that transcript.\n\n    \"\"\"\n    import itertools as it\n\n    import HTSeq\n\n    gtf = it.islice(HTSeq.GFF_Reader(fn), None)\n    transcripts = []\n    genes = []\n    line = gtf.next()\n    while line != '':\n        if line.type == 'transcript':\n            transcripts.append(line.attr['transcript_id'])\n            genes.append(line.attr['gene_id'])\n        try:\n            line = gtf.next()\n        except StopIteration:\n            line = ''\n   \n    return pd.Series(genes, index=transcripts)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef make_gene_info_df(fn):\n    import itertools as it\n\n    import HTSeq\n\n    gff_iter = it.islice(HTSeq.GFF_Reader(fn), None)\n    convD = dict()\n    eof = False\n    while not eof:\n        try:\n            entry = gff_iter.next()\n            if entry.type == 'gene':\n                convD[entry.attr['gene_id']] = [entry.attr['gene_name'], \n                                                entry.attr['gene_type'],\n                                                entry.iv.chrom,\n                                                entry.iv.start,\n                                                entry.iv.end,\n                                                entry.iv.strand,\n                                                entry.attr['gene_status'],\n                                                entry.source,\n                                                entry.attr['level']]\n\n        except StopIteration:\n            eof = True\n\n    ind = ['gene_name', 'gene_type', 'chrom', 'start', 'end', 'strand',\n           'gene_status', 'source', 'level']\n    df = pd.DataFrame(convD, index=ind).T\n    df.index.name = 'gene_id'\n    return df", "response": "Make a Pandas dataframe with gene information for a single object."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef make_splice_junction_df(fn, type='gene'):\n    import itertools as it\n\n    import HTSeq\n    import numpy as np\n\n    # GFF_Reader has an option for end_included. However, I think it is\n    # backwards.  So if your gtf is end-inclusive, you want the default\n    # (end_included=False).  With this, one will NOT be subtracted from the end\n    # coordinate.\n    gffI = it.islice(HTSeq.GFF_Reader(fn), None)    \n    juncL = []\n    eof = False\n    entry = gffI.next()\n    count = 1\n    last_count = 1\n    while not eof:\n        if entry.type == 'transcript':\n            exonL = []\n            entry = gffI.next()\n            count += 1\n            gene = entry.attr['gene_id']\n            strand = entry.iv.strand\n            while not eof and entry.type != 'transcript':\n                if entry.type == 'exon':\n                    exonL.append(entry)\n                try:\n                    entry = gffI.next()\n                    count += 1\n                except StopIteration:\n                    eof = True\n            # The gencode gtf file has one based, end inclusive coordinates for\n            # exons.  HTSeq represents intervals as zero based, end exclusive.\n            # We need one-based, end inclusive to compare with STAR output.\n            if len(exonL) > 1:\n                chrom = exonL[0].iv.chrom\n                # On the minus strand, order of exons in gtf file is reversed.\n                if strand == '-':\n                    exonL.reverse() \n                # We take the exclusive end of the exon intervals and add one to\n                # make the one-based start of the intron.\n                startL = [ x.iv.end + 1 for x in exonL[:-1] ]   \n                # The zero-based inclusive start of the exon is the one-based\n                # inclusive end of the intron.\n                endL = [ x.iv.start for x in exonL[1:] ]\n                for i in range(len(startL)):\n                    start = startL[i]\n                    end = endL[i]\n                    jxn = '{0}:{1}-{2}:{3}'.format(chrom, start, end, strand)\n                    chrstart = '{}:{}'.format(chrom, start)\n                    chrend = '{}:{}'.format(chrom, end)\n                    donor = _gencode_donor(chrom, start, end, strand)\n                    acceptor = _gencode_acceptor(chrom, start, end, strand)\n                    intron = '{}:{}-{}'.format(chrom, start, end)\n                    juncL.append([jxn, gene, chrom, str(start), str(end), \n                                  strand, chrstart, chrend, donor, acceptor,\n                                  intron])\n        else:\n            try:\n                entry = gffI.next()\n                count += 1\n            except StopIteration:\n                eof = True\n            last_count += 1\n    header = ['gene', 'chrom', 'start', 'end', 'strand', 'chrom:start',\n              'chrom:end', 'donor', 'acceptor', 'intron']\n    juncA = np.array(juncL)\n    df = pd.DataFrame(juncA[:,1:], index=juncA[:,0], \n                      columns=header).drop_duplicates() \n    df['start'] = df.start.astype(int)\n    df['end'] = df.end.astype(int)\n    return df", "response": "Read the gencode gtf file and make a pandas dataframe describing the splice junctions."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ninvoking once the request has been finished. Adds a value to a timer in the following format.", "response": "def on_finish(self):\n        \"\"\"Invoked once the request has been finished. Increments a counter\n        created in the format:\n\n        .. code::\n\n            <PREFIX>.counters.<host>.package[.module].Class.METHOD.STATUS\n            sprockets.counters.localhost.tornado.web.RequestHandler.GET.200\n\n        Adds a value to a timer in the following format:\n\n        .. code::\n\n            <PREFIX>.timers.<host>.package[.module].Class.METHOD.STATUS\n            sprockets.timers.localhost.tornado.web.RequestHandler.GET.200\n\n        \"\"\"\n        if self.statsd_prefix != statsd.STATSD_PREFIX:\n            statsd.set_prefix(self.statsd_prefix)\n\n        if hasattr(self, 'request') and self.request:\n            if self.statsd_use_hostname:\n                timer_prefix = 'timers.{0}'.format(socket.gethostname())\n                counter_prefix = 'counters.{0}'.format(socket.gethostname())\n            else:\n                timer_prefix = 'timers'\n                counter_prefix = 'counters'\n\n            statsd.add_timing(timer_prefix,\n                              self.__module__,\n                              str(self.__class__.__name__),\n                              self.request.method,\n                              str(self._status_code),\n                              value=self.request.request_time() * 1000)\n\n            statsd.incr(counter_prefix,\n                        self.__module__,\n                        self.__class__.__name__,\n                        self.request.method,\n                        str(self._status_code))\n\n        super(RequestMetricsMixin, self).on_finish()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _install(_):\n    if not os.path.exists(\".git\"):\n        fatal(\"not in a git repo.\")\n\n    config = __load_config()\n\n    if config.get(\"checks\") is None:\n        fatal(\"global ``checks`` variable missing from configuration.\")\n\n    # We try to load all checks to check that they exist NOW.\n    for hook in config[\"checks\"]:\n        checks = __load_checks(config[\"checks\"][hook])\n        # Also verify that they apply to the hooks.\n        __verify_checks_for_hook(checks, hook)\n\n    reply = input(\"This will overwrite your current hooks. \"\n                  \"Proceed [yes/No]? \")\n    if reply != \"yes\":\n        raise Exit(0)\n\n    for hook in config[\"checks\"]:\n        hook_f = open(os.path.join(\".git/hooks/\", hook), 'w')\n        hook_f.write(\"\"\"#!/usr/bin/env python\n# GENRATED BY GLERBL. DO NOT MODIFY.\nfrom glerbl.__main__ import main\n\n\nexit(main([\"glerbl\", \"hook\", \"{0}\"]))\n\"\"\".format(hook))\n        os.fchmod(hook_f.fileno(),\n                  os.fstat(hook_f.fileno()).st_mode | stat.S_IXUSR)\n        hook_f.close()", "response": "Install the hooks configured in glerbl. conf. py."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _listchecks(_):\n    import glerbl.check\n    package = glerbl.check\n    for _, modname, _ in pkgutil.walk_packages(path=package.__path__):\n        mod = importlib.import_module(package.__name__+ '.' + modname)\n        print(modname, mod.Check.hooks)\n        print(mod.Check.__doc__)", "response": "List all checks in the current directory."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_foreign_key_check(self, to_check):\n        if to_check:\n            self.__db.cursor().execute('SET foreign_key_checks = 1;')\n        else:\n            self.__db.cursor().execute('SET foreign_key_checks = 0;')", "response": "Enable or disable foreign key check."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nchecking whether the given table name exists in this database. Return boolean.", "response": "def is_table_existed(self, tablename):\n        \"\"\"\n        Check whether the given table name exists in this database. Return boolean.\n        \"\"\"\n        all_tablenames = self.list_tables()\n        tablename = tablename.lower()\n\n        if tablename in all_tablenames:\n            return True\n        else:\n            return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef create_table(self, tablename, columns, primary_key=None, force_recreate=False):\n        if self.is_table_existed(tablename):\n            if force_recreate:\n                self.drop_table(tablename)\n            else:\n                raise MonSQLException('TABLE ALREADY EXISTS')\n\n        columns_specs = ','.join(columns)\n        if primary_key is not None:\n            if len(primary_key) == 0:\n                raise MonSQLException('PRIMARY KEY MUST AT LEAST CONTAINS ONE COLUMN')\n\n            columns_specs += ',PRIMARY KEY(%s)' %(','.join(primary_key))\n\n        sql = 'CREATE TABLE %s(%s)' %(tablename, columns_specs)\n        self.__cursor.execute(sql)\n        self.__db.commit()", "response": "Creates a new table in the database."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndrop a table from the database.", "response": "def drop_table(self, tablename, silent=False):\n        \"\"\"\n        Drop a table\n\n        :Parameters:\n\n        - tablename: string\n        - slient: boolean. If false and the table doesn't exists an exception will be raised;\n          Otherwise it will be ignored\n        \n        :Return: Nothing\n\n        \"\"\"\n        if not silent and not self.is_table_existed(tablename):\n            raise MonSQLException('TABLE %s DOES NOT EXIST' %tablename)\n\n        self.__cursor.execute('DROP TABLE IF EXISTS %s' %(tablename))\n        self.__db.commit()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef raw(self, sql):\n        res = self.cursor.execute(sql)\n        if self.cursor.description is None:\n            return res\n\n        rows = self.cursor.fetchall()\n        columns = [d[0] for d in self.cursor.description]\n\n        structured_rows = []\n        for row in rows:\n            data = {}\n            for val, col in zip(row, columns):\n                data[col] = val\n            structured_rows.append(DataRow(data))\n\n        return structured_rows", "response": "Execute raw sql and return a list of DataRow instances"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding the given match rule to this ruleset s match rules .", "response": "def add_match_rule(self, rule_config_name):\n        \"\"\"\n        Adds the given match rule to this ruleset's match rules\n        :param rule_config_name: Plugin's config name\n        :return: None\n        \"\"\"\n        self.logger.debug('Adding match rule {0}'.format(rule_config_name))\n        # Handle rules that are just a string, like 'stop-processing'\n        if type(rule_config_name) == str:\n            self.add_rule(rule_config_name, None, self.available_match_plugins, self.match_rules)\n        # Handle rules built from key-value pairs\n        elif type(rule_config_name) == dict:\n            for r in rule_config_name:\n                self.add_rule(r, rule_config_name[r], self.available_match_plugins, self.match_rules)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_action_rule(self, rule_config_name):\n        self.logger.debug('Adding action rule {0}'.format(rule_config_name))\n        # Handle rules that are just a string, like 'stop-processing'\n        if type(rule_config_name) == str:\n            self.add_rule(rule_config_name, None, self.available_action_plugins, self.action_rules)\n        # Handle rules built from key-value pairs\n        elif type(rule_config_name) == dict:\n            for r in rule_config_name:\n                self.add_rule(r, rule_config_name[r], self.available_action_plugins, self.action_rules)", "response": "Adds the given action rule to this ruleset s action rules\n       ."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds a rule to the list of available action rules or match rules.", "response": "def add_rule(self, config_name, value, plugins, destination):\n        \"\"\"\n        Adds a rule. Use add_action_rule or add_match_rule instead\n        :param rule_wrapper: Rule wrapper class (ActionRule or MatchRule)\n        :param config_name: config_name of the plugin to add\n        :param value: configuration information for the rule\n        :param plugins: list of all available plugins\n        :param destination: list to append plugin to (self.action_rules or self.match_rules)\n        :return:\n        \"\"\"\n        if config_name in plugins:\n            rule = plugins[config_name](value)\n            destination.append(rule)\n        else:\n            self.logger.error(\"Plugin with config_name {0} not found\".format(config_name))\n            raise IndexError(\"Plugin with config_name {0} not found\".format(config_name))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn true if the given file matches all the rules in this ruleset.", "response": "def matches_all_rules(self, target_filename):\n        \"\"\"\n        Returns true if the given file matches all the rules in this ruleset.\n        :param target_filename:\n        :return: boolean\n        \"\"\"\n\n        for rule in self.match_rules:\n            if rule.test(target_filename) is False:\n                return False\n\n        self.logger.debug('{0}: {1} - {2}'.format(self.name,\n                                                  os.path.basename(target_filename),\n                                                  'Match'))\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef do_actions(self, target_filename, dry_run=False):\n        for rule in self.action_rules:\n            target_filename = rule.do_action(target_filename, dry_run)\n\n        raise StopProcessingException", "response": "Runs all the given action rules on the given target_filename."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add_action_rules(self, action_rules):\n        if type(action_rules) == list:\n            for r in action_rules:\n                self.add_action_rule(r)\n        else:\n            # Handle a single rule being passed in that's not in a list\n            self.add_action_rule(action_rules)", "response": "Adds the given action rules to the ruleset. Handles single rules or a list of rules."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef add_match_rules(self, match_rules):\n        if type(match_rules) == list:\n            for r in match_rules:\n                self.add_match_rule(r)\n        else:\n            # Handle a single rule being passed in that's not in a list\n            self.add_match_rule(match_rules)", "response": "Adds the given match rules to the ruleset. Handles single rules or a list of rules."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nshow a 3 - month calendar of meetups.", "response": "def calendar(ctx, date, agenda, year):\n    \"\"\"Show a 3-month calendar of meetups.\n\n    \\b\n    date: The date around which the calendar is centered. May be:\n        - YYYY-MM-DD, YY-MM-DD, YYYY-MM or YY-MM (e.g. 2015-08)\n        - MM (e.g. 08): the given month in the current year\n        - pN (e.g. p1): N-th last month\n        - +N (e.g. +2): N-th next month\n        - Omitted: today\n        - YYYY: Show the entire year, as with -y\n    \"\"\"\n    do_full_year = year\n    today = ctx.obj['now'].date()\n    db = ctx.obj['db']\n    term = ctx.obj['term']\n\n    date_info = cliutil.parse_date(date)\n    if 'relative' in date_info:\n        year = today.year\n        month = today.month + date_info['relative']\n    elif 'date_based' in date_info:\n        year = date_info.get('year', today.year)\n        month = date_info.get('month', today.month)\n        if 'month' not in date_info and 'day' not in date_info:\n            do_full_year = True\n    else:\n        raise click.UsageError('Unknown date format')\n\n    if agenda is None:\n        agenda = not do_full_year\n\n    if do_full_year:\n        first_month = 1\n        num_months = 12\n    else:\n        first_month = month - 1\n        num_months = 3\n\n    calendar = get_calendar(db, year, first_month, num_months)\n    cliutil.handle_raw_output(ctx, list(calendar.values()))\n\n    render_calendar(term, calendar, today, agenda)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef register(self, obj):\n        '''\n        register all methods for of an object as json rpc methods\n\n        obj - object with methods\n        '''\n        for method in dir(obj):\n            #ignore private methods\n            if not method.startswith('_'):\n                fct = getattr(obj, method)\n                #only handle functions\n                try:\n                    getattr(fct, '__call__')\n                except AttributeError:\n                    pass\n                else:\n                    logging.debug('JSONRPC: Found Method: \"%s\"' % method)\n                    self._methods[method] = {\n                        'argspec': inspect.getargspec(fct),\n                        'fct': fct\n                    }", "response": "register all methods for an object as json rpc methods\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _validate_format(req):\n        '''\n        Validate jsonrpc compliance of a jsonrpc-dict.\n\n        req - the request as a jsonrpc-dict\n\n        raises SLOJSONRPCError on validation error\n        '''\n        #check for all required keys\n        for key in SLOJSONRPC._min_keys:\n            if not key in req:\n                logging.debug('JSONRPC: Fmt Error: Need key \"%s\"' % key)\n                raise SLOJSONRPCError(-32600)\n\n        #check all keys if allowed\n        for key in req.keys():\n            if not key in SLOJSONRPC._allowed_keys:\n                logging.debug('JSONRPC: Fmt Error: Not allowed key \"%s\"' % key)\n                raise SLOJSONRPCError(-32600)\n\n        #needs to be jsonrpc 2.0\n        if req['jsonrpc'] != '2.0':\n            logging.debug('JSONRPC: Fmt Error: \"jsonrpc\" needs to be \"2.0\"')\n            raise SLOJSONRPCError(-32600)", "response": "Validate jsonrpc compliance of a jsonrpc - dict."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _validate_params(self, req):\n        '''\n        Validate parameters of a jsonrpc-request.\n\n        req - request as a jsonrpc-dict\n\n        raises SLOJSONRPCError on validation error\n        '''\n\n        #does the method exist?\n        method = req['method']\n        if not method in self._methods:\n            raise SLOJSONRPCError(-32601)\n        fct = self._methods[method]['fct']\n\n        #'id' is only needed for none SLOJSONRPCNotification's\n        try:\n            getattr(fct, '__SLOJSONRPCNotification__')\n            if 'id' in req:\n                logging.debug('JSONRPC: Fmt Error: no id for SLOJSONRPCNotifications')\n                raise SLOJSONRPCError(-32602)\n        except AttributeError:\n            if not 'id' in req:\n                logging.debug('JSONRPC: Fmt Error: Need an id for non SLOJSONRPCNotifications')\n                raise SLOJSONRPCError(-32602)\n\n        #get arguments and defaults for the python-function representing\n        # the method\n        argspec = self._methods[method]['argspec']\n        args, defaults = list(argspec.args), \\\n            list(argspec.defaults if argspec.defaults else [])\n\n        #ignore self and session\n        if 'self' in args:\n            args.remove('self')\n        args.remove('session')\n\n        #create required arguments. delete the ones with defaults\n        required = list(args)\n        if defaults:\n            for default in defaults:\n                required.pop()\n\n        #check if we need paremeters and there are none, then error\n        if len(required) > 0 and 'params' not in req:\n            logging.debug('JSONRPC: Parameter Error: More than zero params required')\n            raise SLOJSONRPCError(-32602)\n\n        if 'params' in req:\n            #parameters must be a dict if there is more then one\n            if not isinstance(req['params'], dict) and len(required) > 1:\n                logging.debug('JSONRPC: Parameter Error: \"params\" must be a dictionary')\n                raise SLOJSONRPCError(-32602)\n\n            if isinstance(req['params'], dict):\n                #check if required parameters are there\n                for key in required:\n                    if not key in req['params']:\n                        logging.debug('JSONRPC: Parameter Error: Required key \"%s\" is missing' % key)\n                        raise SLOJSONRPCError(-32602)\n\n                #check if parameters are given that do not exist in the method\n                for key in req['params']:\n                    if not key in required:\n                        logging.debug('JSONRPC: Parameter Error: Key is not allowed \"%s\"' % key)\n                        raise SLOJSONRPCError(-32602)", "response": "Validate the parameters of a jsonrpc - request."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef handle_request(self, req, validate=True):\n        '''\n        handle a jsonrpc request\n\n        req - request as jsonrpc-dict\n        validate - validate the request? (default: True)\n\n        returns jsonrpc-dict with result or error\n        '''\n\n        #result that will be filled and returned\n        res = {'jsonrpc': '2.0', 'id': -1, 'result': None}\n\n        logging.debug('')\n        logging.debug('--------------------REQUEST' +\n                      '--------------------\\n' +\n                      json.dumps(req,\n                                 sort_keys=True,\n                                 indent=4,\n                                 separators=(',', ': ')))\n        logging.debug('-----------------------------------------------')\n\n        notification = False\n        if self._sessionmaker:\n            session = self._sessionmaker()\n        try:\n            #validate request\n            if validate:\n                self._validate_format(req)\n                self._validate_params(req)\n\n            method = req['method']\n\n            #check if request is a notification\n            try:\n                getattr(self._methods[method]['fct'], '__SLOJSONRPCNotification__')\n                notification = True\n            except AttributeError:\n                notification = False\n\n            #call the python function\n            if 'params' in req:\n                fct = self._methods[method]['fct']\n                if isinstance(req['params'], dict):\n                    req['params']['session'] = session\n                    res['result'] = fct(**req['params'])\n                else:\n                    res['result'] = fct(session, req['params'])\n            else:\n                res['result'] = self._methods[method]['fct'](session)\n        except SLOJSONRPCError as e:\n            res = e.to_json(req.get('id', None))\n        except:\n            logging.debug('Uncaught Exception:')\n            logging.debug('-------------------\\n' + traceback.format_exc())\n            res = SLOJSONRPCError(-32603).to_json(req.get('id', None))\n\n        session.close()\n\n        logging.debug('--------------------RESULT' +\n                      '--------------------\\n' +\n                      json.dumps(res,\n                                 sort_keys=True,\n                                 indent=4,\n                                 separators=(',', ': ')))\n        logging.debug('----------------------------------------------')\n\n        #return None if a notification\n        if notification:\n            return None\n        elif not 'error' in res:\n            res['id'] = req['id']\n\n        return res", "response": "handle a jsonrpc request returning jsonrpc - dict with result or error"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nhandle a string representing a jsonrpc - request 69 - 2. 0. 0", "response": "def handle_string(self, strreq):\n        '''\n        Handle a string representing a jsonrpc-request\n\n        strreq - jsonrpc-request as a string\n\n        returns jsonrpc-response as a string\n        '''\n\n        #convert to jsonrpc-dict\n        req = None\n        try:\n            req = json.loads(strreq)\n        except:\n            logging.debug('JSONRPC: Format Exception:')\n            logging.debug('-----------------\\n' + traceback.format_exc())\n            return json.dumps(SLOJSONRPCError(-32700).to_json())\n\n        #handle single request\n        if isinstance(req, dict):\n            return json.dumps(self.handle_request(req))\n        #handle multiple requests\n        elif isinstance(req, list):\n            for r in req:\n                if not isinstance(r, dict):\n                    logging.debug('JSONRPC: Fmt Error: Item ' +\n                                  '\"%s\" in request is no dictionary.' % str(r))\n                    return json.dumps(SLOJSONRPCError(-32700).to_json())\n                try:\n                    self._validate_format(r)\n                    self._validate_params(r)\n                except SLOJSONRPCError as e:\n                    return json.dumps(e.to_json(r.get('id', None)))\n\n            res = []\n            for r in req:\n                res.append(self.handle_request(r, validate=False))\n            return json.dumps(res)\n        #invalid request\n        else:\n            return json.dumps(SLOJSONRPCError(-32700).to_json())"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreport the number of calls for a given API key.", "response": "def report_calls(request):\n    '''\n        POST endpoint for APIs to report their statistics\n\n        requires parameters: api, key, calls, date, endpoint & signature\n\n        if 'api' or 'key' parameter is invalid returns a 404\n        if signature is bad returns a 400\n        returns a 200 with content 'OK' if call succeeds\n    '''\n    api_obj = get_object_or_404(Api, name=request.POST['api'])\n\n    # check the signature\n    if get_signature(request.POST, api_obj.signing_key) != request.POST['signature']:\n        return HttpResponseBadRequest('bad signature')\n\n    key_obj = get_object_or_404(Key, key=request.POST['key'])\n\n    calls = int(request.POST['calls'])\n    try:\n        # use get_or_create to update unique #calls for (date,api,key,endpoint)\n        report,c = Report.objects.get_or_create(date=request.POST['date'],\n                                                api=api_obj,\n                                                key=key_obj,\n                                                endpoint=request.POST['endpoint'],\n                                                defaults={'calls':calls})\n        if not c:\n            report.calls = calls\n            report.save()\n    except Exception:\n        raise\n\n    return HttpResponse('OK')"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef reset_keys(request):\n    '''\n        POST endpoint to reset API keys for a given API\n        (triggering a request for new keys)\n    '''\n    api_obj = get_object_or_404(Api, name=request.POST['api'])\n\n    # check the signature\n    if get_signature(request.POST, api_obj.signing_key) != request.POST['signature']:\n        return HttpResponseBadRequest('bad signature')\n\n    ReplicatedApiNames = getattr(settings, 'LOCKSMITH_REPLICATED_APIS', [])\n    if api_obj.name in ReplicatedApiNames:\n        for key in Key.objects.all():\n            replicate_key.delay(key, api_obj)\n    else:\n        api_obj.pub_statuses.update(status=UNPUBLISHED)\n        for key in Key.objects.all():\n            push_key.delay(key, replicate_too=False)\n\n    return HttpResponse('OK')", "response": "Reset all API keys for a given API."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nchecks if a key exists and is valid", "response": "def check_key(request):\n    '''\n        POST endpoint determining whether or not a key exists and is valid\n    '''\n    api_objs = list(Api.objects.filter(name=request.POST['api']))\n    if not api_objs:\n        return HttpResponseBadRequest('Must specify valid API')\n\n    # check the signature\n    if get_signature(request.POST, api_objs[0].signing_key) != request.POST['signature']:\n        return HttpResponseBadRequest('bad signature')\n\n    get_object_or_404(Key, key=request.POST['key'], status='A')\n\n    return HttpResponse('OK')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef register(request,\n             email_template='locksmith/registration_email.txt',\n             registration_template=getattr(settings, 'LOCKSMITH_REGISTER_TEMPLATE', 'locksmith/register.html'),\n             registered_template=getattr(settings, 'LOCKSMITH_REGISTERED_TEMPLATE', 'locksmith/registered.html'),\n            ):\n    '''\n        API registration view\n\n        displays/validates form and sends email on successful submission\n    '''\n    if request.method == 'POST':\n        form = KeyForm(request.POST)\n        if form.is_valid():\n            newkey = form.save(commit=False)\n            newkey.key = uuid.uuid4().hex\n            newkey.status = 'U'\n            newkey.save()\n\n            send_key_email(newkey, email_template)\n            return render_to_response(registered_template, {'key': newkey, 'LOCKSMITH_BASE_TEMPLATE': settings.LOCKSMITH_BASE_TEMPLATE }, context_instance=RequestContext(request))\n    else:\n        form = KeyForm()\n    return render_to_response(registration_template, {'form':form, 'LOCKSMITH_BASE_TEMPLATE': settings.LOCKSMITH_BASE_TEMPLATE}, context_instance=RequestContext(request))", "response": "This function is used to register a new resource in the locksmith site."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconfirm an API key for use in a resource.", "response": "def confirm_registration(request, key, template=\"locksmith/confirmed.html\"):\n    '''\n        API key confirmation\n\n        visiting this URL marks a Key as ready for use\n    '''\n    context = {'LOCKSMITH_BASE_TEMPLATE': settings.LOCKSMITH_BASE_TEMPLATE}\n    try:\n        context['key'] = key_obj = Key.objects.get(key=key)\n        if key_obj.status != 'U':\n            context['error'] = 'Key Already Activated'\n        else:\n            key_obj.status = 'A'\n            key_obj.save()\n            key_obj.mark_for_update()\n    except Key.DoesNotExist:\n        context['error'] = 'Invalid Key'\n    return render_to_response(template, context,\n                              context_instance=RequestContext(request))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef profile(request):\n    '''\n        Viewing of signup details and editing of password\n    '''\n    context = {}\n\n    if request.method == 'POST':\n        form = PasswordChangeForm(request.user, request.POST)\n        if form.is_valid():\n            form.save()\n            messages.info(request, 'Password Changed.')\n    else:\n        form = PasswordChangeForm(request.user)\n\n    key = Key.objects.get(email=request.user.email)\n    \n    #analytics\n    endpoint_q = key.reports.values('api__name', 'endpoint').annotate(calls=Sum('calls')).order_by('-calls')\n    endpoints = [{'endpoint':'.'.join((d['api__name'], d['endpoint'])),\n                  'calls': d['calls']} for d in endpoint_q]\n    date_q = key.reports.values('date').annotate(calls=Sum('calls')).order_by('date')\n    context['endpoints'], context['endpoint_calls'] = _dictlist_to_lists(endpoints, 'endpoint', 'calls')\n    context['timeline'] = date_q\n\n    context['form'] = form\n    context['key'] = key\n    context['password_is_key'] = request.user.check_password(key.key)\n    return render_to_response('locksmith/profile.html', context,\n                              context_instance=RequestContext(request))", "response": "View of signup details and editing of password\n   "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _dictlist_to_lists(dl, *keys):\n    ''' convert a list of dictionaries to a dictionary of lists\n\n    >>> dl = [{'a': 'test', 'b': 3}, {'a': 'zaz', 'b': 444},\n              {'a': 'wow', 'b': 300}]\n    >>> _dictlist_to_lists(dl)\n    (['test', 'zaz', 'wow'], [3, 444, 300])\n    '''\n    lists = []\n    for k in keys:\n        lists.append([])\n    for item in dl:\n        for i, key in enumerate(keys):\n            x = item[key]\n            if isinstance(x, unicode):\n                x = str(x)\n            lists[i].append(x)\n    return lists", "response": "convert a list of dictionaries to a list of lists"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _cumulative_by_date(model, datefield):\n    '''\n        Given a model and date field, generate monthly cumulative totals.\n    '''\n    monthly_counts = defaultdict(int)\n    for obj in model.objects.all().order_by(datefield):\n        datevalue = getattr(obj, datefield)\n        monthkey = (datevalue.year, datevalue.month)\n        monthly_counts[monthkey] += 1\n\n    if len(monthly_counts) == 0:\n        return []\n\n    earliest_month = min(monthly_counts.iterkeys())\n    latest_month = max(monthly_counts.iterkeys())\n\n    accumulator = 0\n    cumulative_counts = []\n    for (year, month) in cycle_generator(cycle=(1, 12), begin=earliest_month, end=latest_month):\n        mcount = monthly_counts.get((year, month), 0)\n        accumulator += mcount\n        cumulative_counts.append([datetime.date(year, month, 1), accumulator])\n\n    return cumulative_counts", "response": "Generate monthly cumulative totals."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates a custom exception class with arbitrary error codes and arguments.", "response": "def factory(codes, base=_Exception):\n    \"\"\"\n    Creates a custom exception class with arbitrary error codes and arguments.\n    \"\"\"\n\n    if not issubclass(base, _Exception):\n        raise FactoryException(\"Invalid class passed as parent: Must be a subclass of an Exception class created with this function\",\n                               FactoryException.INVALID_EXCEPTION_CLASS, intended_parent=base)\n\n    class Error(base):\n        pass\n\n    if isinstance(codes, (list, set, tuple, frozenset)):\n        codes = {e: e for e in codes}\n\n    if not isinstance(codes, dict):\n        raise FactoryException(\"Factory codes must be a dict str -> object\",\n                               FactoryException.INVALID_CODES_LIST, intended_codes=codes)\n\n    for code, value in codes.items():\n        try:\n            setattr(Error, code, value)\n        except TypeError:\n            raise FactoryException(\"Cannot set class attribute: (%r) -> (%r)\" % (code, value),\n                                   FactoryException.INVALID_CODE_VALUE, attribute=code, value=value)\n\n    return Error"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsaving the current instance to the DB.", "response": "def save(self):\n        \"\"\"\n            Save the current instance to the DB\n        \"\"\"\n        with rconnect() as conn:\n            try:\n                self.validate()\n            except ValidationError as e:\n                log.warn(e.messages)\n                raise\n            except ModelValidationError as e:\n                log.warn(e.messages)\n                raise\n            except ModelConversionError as e:\n                log.warn(e.messages)\n                raise\n            except ValueError as e:\n                log.warn(e)\n                raise\n            except FrinkError as e:\n                log.warn(e.messages)\n                raise\n            except Exception as e:\n                log.warn(e)\n                raise\n            else:\n                # If this is a new unsaved object, it'll likely have an\n                # id of None, which RethinkDB won't like. So if it's None,\n                # generate a UUID for it. If the save fails, we should re-set\n                # it to None.\n                if self.id is None:\n                    self.id = str(uuid.uuid4())\n                    log.debug(self.id)\n\n                try:\n                    query = r.db(self._db).table(self._table).insert(\n                        self.to_primitive(),\n                        conflict=\"replace\"\n                    )\n                    log.debug(query)\n                    rv = query.run(conn)\n                    # Returns something like this:\n                    # {\n                    #   u'errors': 0,\n                    #   u'deleted': 0,\n                    #   u'generated_keys': [u'dd8ad1bc-8609-4484-b6c4-ed96c72c03f2'],\n                    #   u'unchanged': 0,\n                    #   u'skipped': 0,\n                    #   u'replaced': 0,\n                    #   u'inserted': 1\n                    # }\n                    log.debug(rv)\n                except Exception as e:\n                    log.warn(e)\n                    self.id = None\n                    raise\n                else:\n                    return self"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef delete(self):\n        with rconnect() as conn:\n            # Can't delete an object without an ID.\n            if self.id is None:\n                raise FrinkError(\"You can't delete an object with no ID\")\n            else:\n                if isinstance(self.id, uuid.UUID):\n                    self.id = str(self.id)\n\n                try:\n                    query = r.db(\n                        self._db\n                    ).table(\n                        self._table\n                    ).get(\n                        self.id\n                    ).delete()\n                    log.debug(query)\n                    rv = query.run(conn)\n                except Exception as e:\n                    log.warn(e)\n                    raise\n                else:\n                    return True", "response": "Delete the current instance from the DB."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get(self, id):\n        with rconnect() as conn:\n            if id is None:\n                raise ValueError\n\n            if isinstance(id, uuid.UUID):\n                id = str(id)\n\n            if type(id) != str and type(id) != unicode:\n                raise ValueError\n\n            try:\n                query = self._base().get(id)\n                log.debug(query)\n                rv = query.run(conn)\n            except ReqlOpFailedError as e:\n                log.warn(e)\n                raise\n            except Exception as e:\n                log.warn(e)\n                raise\n            if rv is not None:\n                return self._model(rv)\n\n            return None", "response": "Get a single instance by pk id."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef filter(self, order_by=None, limit=0, **kwargs):\n        with rconnect() as conn:\n            if len(kwargs) == 0:\n                raise ValueError\n\n            try:\n                query = self._base()\n                query = query.filter(kwargs)\n\n                if order_by is not None:\n                    query = self._order_by(query, order_by)\n\n                if limit > 0:\n                    query = self._limit(query, limit)\n\n                log.debug(query)\n                rv = query.run(conn)\n\n            except ReqlOpFailedError as e:\n                log.warn(e)\n                raise\n            except Exception as e:\n                log.warn(e)\n                raise\n            else:\n                data = [self._model(_) for _ in rv]\n                return data", "response": "Fetch a list of instances from the database."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef find_by(self, column=None, value=None, order_by=None, limit=0):\n        with rconnect() as conn:\n            if column is None or value is None:\n                raise ValueError(\"You need to supply both a column and a value\")\n\n            try:\n                query = self._base()\n                if order_by is not None:\n                    query = self._order_by(query, order_by)\n                if limit > 0:\n                    query = self._limit(query, limit)\n                query = query.filter({column: value})\n                log.debug(query)\n                rv = query.run(conn)\n            except Exception as e:\n                log.warn(e)\n                raise\n            else:\n                data = [self._model(_) for _ in rv]\n                return data", "response": "Find all items that match your a column and value."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns one item that matches your a column or value. Raises a NotUniqueError if there is more than one.", "response": "def get_by(self, column=None, value=None):\n        \"\"\"\n            Find one item that matches your a column/value. Raises `NotUniqueError` if\n            it finds more than one.\n\n            :param column: column to search.\n            :param value: value to look for in `column`.\n            :param limit: How many rows to fetch.\n            :param order_by: column on which to order the results. \\\n            To change the sort, prepend with < or >.\n\n        \"\"\"\n        with rconnect() as conn:\n            if column is None or value is None:\n                raise ValueError(\"You need to supply both a column and a value\")\n\n            try:\n                query = self._base()\n                query = query.filter({column: value})\n                log.debug(query)\n                rv = query.run(conn)\n            except Exception as e:\n                log.warn(e)\n                raise\n            else:\n                data = [self._model(_) for _ in rv]\n                if len(data) > 1:\n                    raise NotUniqueError('Found more than one object matching the query')\n                else:\n                    try:\n                        return data[0]\n                    except IndexError:\n                        return None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nfetch all items. :param limit: How many rows to fetch. :param order_by: column on which to order the results. \\ To change the sort, prepend with < or >.", "response": "def all(self, order_by=None, limit=0):\n        \"\"\"\n            Fetch all items.\n\n            :param limit: How many rows to fetch.\n            :param order_by: column on which to order the results. \\\n            To change the sort, prepend with < or >.\n\n        \"\"\"\n        with rconnect() as conn:\n            try:\n                query = self._base()\n                if order_by is not None:\n                    query = self._order_by(query, order_by)\n                if limit > 0:\n                    query = self._limit(query, limit)\n\n                log.debug(query)\n                rv = query.run(conn)\n            except Exception as e:\n                log.warn(e)\n                raise\n            else:\n                data = [self._model(_) for _ in rv]\n                return data"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef then_a_model_exists(context, model_name, key, value):\r\n    model = apps.get_model(model_name)\r\n    args = {\r\n        key: value\r\n    }\r\n    obj = model.objects.get(**args)\r\n    assert obj is not None", "response": "assert that a model exists"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nasserting that a model with the given name exists", "response": "def then_no_model_exists(context, model_name, key, value):\r\n    \"\"\"\r\n    :type model_name: str\r\n    :type key: str\r\n    :type value: str\r\n    :type context: behave.runner.Context\r\n    \"\"\"\r\n    model = apps.get_model(model_name)\r\n    args = {\r\n        key: value\r\n    }\r\n    obj = model.objects.filter(**args)\r\n    assert len(obj) == 0"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef generate_options():\n    '''Helper coroutine to identify short options that haven't been used\n    yet. Yields lists of short option (if available) and long option for\n    the given name, keeping track of which short options have been previously\n    used.\n\n    If you aren't familiar with coroutines, use similar to a generator:\n    x = generate_options()\n    next(x)  # advance coroutine past its initialization code\n    params = x.send(param_name)\n    '''\n    used_short_options = set()\n    param_name = yield\n    while True:\n        names = ['--' + param_name]\n        for letter in param_name:\n            if letter not in used_short_options:\n                used_short_options.add(letter)\n                names.insert(0, '-' + letter)\n                break\n        param_name = yield names", "response": "Yields lists of short option and long option for the given name keeping track of which short options have been previously used."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef portable_argspec(func):\n    '''\n    Given a function, return a tuple of\n    (positional_params, keyword_params, varargs, defaults, annotations)\n    where\n    * positional_params is a list of parameters that don't have default values\n    * keyword_params is a list of parameters that have default values\n    * varargs is the string name for variable arguments\n    * defaults is a dict of default values for the keyword parameters\n    * annotations is a dictionary of param_name: annotation pairs\n        it may be empty, and on python 2 will always be empty.\n\n    This function is portable between Python 2 and Python 3, and does some\n    extra processing of the output from inspect.\n    '''\n    if sys.version_info < (3, 0):  # PYTHON 2 MUST DIE\n        argnames, varargs, varkw, defaults = inspect.getargspec(func)\n        annotations = {}\n    else:\n        (\n            argnames, varargs, varkw, defaults, kwa, kwd, annotations\n        ) = inspect.getfullargspec(func)\n\n    kw_boundary = len(argnames) - len(defaults) if defaults else len(argnames)\n    positional_params = argnames[:kw_boundary]\n    kw_params = argnames[kw_boundary:]\n    return positional_params, kw_params, varargs, defaults, annotations", "response": "Given a function returns a tuple of the parameters that can be used to construct a new object of the correct type."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef show_setup(self):\n        shell = os.getenv('SHELL')\n        if not shell:\n            raise SystemError(\"No $SHELL env var found\")\n        shell = os.path.basename(shell)\n        if shell not in self.script_body:\n            raise SystemError(\"Unsupported shell: %s\" % shell)\n        tplvars = {\n            \"prog\": '-'.join(self.prog.split()[:-1]),\n            \"shell\": shell,\n            \"name\": self.name\n        }\n        print(self.trim(self.script_header % tplvars))\n        print(self.trim(self.script_body[shell] % tplvars))\n        print(self.trim(self.script_footer % tplvars))", "response": "Prints the script for the user to setup completion."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef trim(self, text):\n        lines = text.splitlines()\n        firstline = lines[0] or lines[1]\n        indent = len(firstline) - len(firstline.lstrip())\n        return '\\n'.join(x[indent:] for x in lines if x.strip())", "response": "Trim whitespace indentation from text."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_package_version():\n    base = os.path.abspath(os.path.dirname(__file__))\n    with open(os.path.join(base, \"firepit/__init__.py\")) as pkg:\n        for line in pkg:\n            m = version.match(line.strip())\n            if not m:\n                continue\n            return \".\".join(m.groups()[0].split(\", \"))", "response": "returns package version without importing it"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nload and returns the IPA data stored in the ipa. tsv file.", "response": "def _load_ipa_data(self, ipa_data_path):\n\t\t\"\"\"\n\t\tLoads and returns the {symbol: name} dictionary stored in the\n\t\tdata/ipa.tsv file.\n\t\t\"\"\"\n\t\tipa = {}\n\n\t\ttry:\n\t\t\twith open(ipa_data_path, newline='') as f:\n\t\t\t\treader = csv.reader(f, delimiter='\\t')\n\t\t\t\tfor line in reader:\n\t\t\t\t\tif len(line) != 2:\n\t\t\t\t\t\tcontinue\n\n\t\t\t\t\tif line[0] in ipa:\n\t\t\t\t\t\traise IPADataError('Bad IPA data file')\n\n\t\t\t\t\tipa[line[0]] = line[1]\n\n\t\texcept (IOError, ValueError) as err:\n\t\t\tself.log.error(str(err))\n\t\t\traise IPADataError('Could not open the IPA data file')\n\n\t\treturn ipa"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nloading and returns the common error data file.", "response": "def _load_common_err_data(self, common_err_data_path):\n\t\t\"\"\"\n\t\tLoads and returns the {bad: good} dictionary stored in the common\n\t\terrors data file. Note that the dict's keys are single characters while\n\t\tthe values do not have to be. The method also asserts that all the\n\t\tvalues are valid IPA strings.\n\t\t\"\"\"\n\t\tcommon_err = {}\n\n\t\ttry:\n\t\t\twith open(common_err_data_path, newline='') as f:\n\t\t\t\treader = csv.reader(f, delimiter='\\t')\n\t\t\t\tfor line in reader:\n\t\t\t\t\tif len(line) != 2:\n\t\t\t\t\t\tcontinue\n\n\t\t\t\t\ttry:\n\t\t\t\t\t\tassert line[0] not in common_err\n\t\t\t\t\t\tassert all([char in self.ipa for char in line[1]])\n\t\t\t\t\texcept AssertionError:\n\t\t\t\t\t\traise IPADataError('Bad common IPA errors file')\n\n\t\t\t\t\tcommon_err[line[0]] = line[1]\n\n\t\texcept (IOError, ValueError) as err:\n\t\t\tself.log.error(str(err))\n\t\t\traise IPADataError('Could not open the common IPA errors data file')\n\n\t\treturn common_err"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_nfc_chars(self):\n\t\tex = []\n\n\t\tfor char in self.ipa.keys():\n\t\t\tif len(char) == 1:\n\t\t\t\tdecomp = unicodedata.normalize('NFD', char)\n\t\t\t\tif len(decomp) == 2:\n\t\t\t\t\tex.append(char)\n\n\t\treturn set(ex)", "response": "Returns the set of IPA symbols that are precomposed during string normalisation."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef recognise(self, string, line_num):\n\t\tsymbols = []\n\t\tunknown = []\n\n\t\tfor char in string:\n\t\t\tif char == SPACE:\n\t\t\t\tcontinue\n\n\t\t\ttry:\n\t\t\t\tname = unicodedata.name(char)\n\t\t\texcept ValueError:\n\t\t\t\tname = 'UNNAMED CHARACTER {}'.format(ord(char))\n\n\t\t\tif char in self.ipa:\n\t\t\t\tsymbol = Symbol(char, name, self.ipa[char])\n\t\t\t\tsymbols.append(symbol)\n\t\t\t\tself.ipa_symbols[symbol].append(line_num)\n\t\t\telse:\n\t\t\t\tsymbol = UnknownSymbol(char, name)\n\t\t\t\tunknown.append(symbol)\n\t\t\t\tself.unk_symbols[symbol].append(line_num)\n\n\t\treturn tuple(symbols), tuple(unknown)", "response": "Recognise the string into chars and distributes these into the buckets of IPA and non - IPA symbols."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef report(self, reporter):\n\t\tfor symbol in sorted(self.unk_symbols.keys()):\n\t\t\terr = '{} ({}) is not part of IPA'.format(symbol.char, symbol.name)\n\n\t\t\tif symbol.char in self.common_err:\n\t\t\t\trepl = self.common_err[symbol.char]\n\t\t\t\terr += ', suggested replacement is {}'.format(repl)\n\t\t\t\tif len(repl) == 1:\n\t\t\t\t\terr += ' ({})'.format(unicodedata.name(repl))\n\n\t\t\treporter.add(self.unk_symbols[symbol], err)", "response": "Report the problems that have not been found so far."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef run_npm(self):\n\n        for name, version in npm_dependencies.items():\n            # packages are installed globally to make sure that they are\n            # installed in the virtualenv rather than the current directory.\n            # it is also necessary for packages containing scripts, e.g. less\n            dep_name = '%s@%s' % (name, version)\n            self.run_cmd(['npm', 'install', '-g', dep_name])", "response": "h/t https://github. com / elbaschid / virtual - node. py"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nruns a command and returns the return code and output of the command.", "response": "def run_cmd(self, cmd, cwd=None, extra_env=None):\n        \"\"\" h/t https://github.com/elbaschid/virtual-node/blob/master/setup.py \"\"\"\n        all_output = []\n        cmd_parts = []\n\n        for part in cmd:\n            if len(part) > 45:\n                part = part[:20] + \"...\" + part[-20:]\n            if ' ' in part or '\\n' in part or '\"' in part or \"'\" in part:\n                part = '\"%s\"' % part.replace('\"', '\\\\\"')\n            cmd_parts.append(part)\n        cmd_desc = ' '.join(cmd_parts)\n        logger.debug(\" ** Running command %s\" % cmd_desc)\n\n        # output\n        stdout = subprocess.PIPE\n\n        # env\n        if extra_env:\n            env = os.environ.copy()\n            if extra_env:\n                env.update(extra_env)\n        else:\n            env = None\n\n        # execute\n        try:\n            proc = subprocess.Popen(\n                [' '.join(cmd)], stderr=subprocess.STDOUT, stdin=None, stdout=stdout,\n                cwd=cwd, env=env, shell=True)\n        except Exception:\n            e = sys.exc_info()[1]\n            logger.error(\"Error %s while executing command %s\" % (e, cmd_desc))\n            raise\n\n        stdout = proc.stdout\n        while stdout:\n            line = stdout.readline()\n            if not line:\n                break\n            line = line.rstrip()\n            all_output.append(line)\n            logger.info(line)\n        proc.wait()\n\n        # error handler\n        if proc.returncode:\n            for s in all_output:\n                logger.critical(s)\n            raise OSError(\"Command %s failed with error code %s\"\n                % (cmd_desc, proc.returncode))\n\n        return proc.returncode, all_output"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef parsing(self):\n        with gui.FlexForm(self.title, auto_size_text=True, default_element_size=(40, 1)) as form:\n            layout = [\n                [gui.Text('Directory Paths utility', size=(30, 1), font=(\"Helvetica\", 25), text_color='blue')],\n                # Source\n                [gui.Text('Source Folder', size=(15, 1), auto_size_text=False), gui.InputText('Source'),\n                 gui.FolderBrowse()],\n\n                # Parallel / Sequential\n                [gui.Text('Parallel or Sequential Processing. Larger directory trees are typically parsed faster '\n                          'using parallel processing.')],\n                [gui.Radio('Parallel Processing', \"RADIO1\"), gui.Radio('Sequential Processing', \"RADIO1\",\n                                                                       default=True)],\n                [_line()],\n\n                # Files and non-empty-folders\n                [gui.Text('Return files or folders, returning folders is useful for creating inventories.')],\n                [gui.Radio('Return Files', \"RADIO2\", default=True), gui.Radio('Return Non-Empty Directories',\n                                                                              \"RADIO2\")],\n                [_line()],\n\n                # max_level\n                [gui.Text('Max Depth.... Max number of sub directory depths to traverse (starting directory is 0)')],\n                [gui.InputCombo(list(reversed(range(0, 13))), size=(20, 3))],\n                [_line()],\n\n                # Relative and absolute\n                [gui.Text('Relative or Absolute Paths.  Relative paths are saved relative to the starting directory. '\n                          'Absolute paths are saved as full paths.')],\n                [gui.Radio('Relative Paths', \"RADIO3\", default=True), gui.Radio('Absolute Paths', \"RADIO3\")],\n                [_line()],\n\n                # Topdown and output\n                [gui.Checkbox('Topdown Parse', default=True), gui.Checkbox('Live output results')],\n                [_line()],\n\n                # Save results to file\n                [gui.Checkbox('Save Results to File', default=False)],\n                [gui.Submit(), gui.Cancel()]]\n\n            (button, (values)) = form.LayoutAndShow(layout)\n\n        # gui.MsgBox(self.title, 'Parameters set', 'The results of the form are... ',\n        #            'The button clicked was \"{}\"'.format(button), 'The values are', values, auto_close=True)\n\n        self.params['parse'] = {\n            'directory': values[0],\n            'parallelize': values[1],\n            'sequential': values[2],\n            'yield_files': values[3],\n            'non_empty_folders': values[4],\n            'max_level': int(values[5]),\n            '_relative': values[6],\n            'full_paths': values[7],\n            'topdown': values[8],\n            'console_stream': values[9],\n            'save_file': values[10],\n        }\n\n        if self.params['parse']['save_file']:\n            self._saving()\n\n        return self.params", "response": "Parameters for parsing directory trees"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef contains(self, desired):\n        '''Return the filter closure fully constructed.'''\n        field = self.__field\n        def aFilter(testDictionary):\n            return (desired in testDictionary[field])\n        return aFilter", "response": "Return the filter closure fully constructed."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef listOrgs(self, closure=lambda x: True):\n        url = self.BASE_URL+self.BASE_PATH+self.ORGS_PATH+self.USER_QUERY\n        response = self.requests.get(url, auth=(self.__username, self.__password))\n        response.raise_for_status()\n        return list(filter(closure, response.json()[\"orgs\"]))", "response": "Returns a list of organizations you belong to."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef listDevicesIn(self, organization, closure=lambda x: True):\n        url = self.BASE_URL+self.BASE_PATH+self.ORGS_PATH+\"/\"+ str(organization[\"id\"]) + self.DEVICES_PATH+self.USER_QUERY\n        response = self.requests.get(url, auth=(self.__username, self.__password))\n        response.raise_for_status()\n        return list(filter(closure, response.json()[\"devices\"]))", "response": "List the devices in an organization."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef deleteFrom(self, organization, devices):\n        for device in devices:\n            url = self.BASE_URL+self.BASE_PATH+self.ORGS_PATH+\"/\"+ str(organization[\"id\"]) + self.DEVICES_PATH+ \"/\" + str(device[\"id\"]) + self.USER_QUERY\n            response = self.requests.delete(url, auth=(self.__username, self.__password))\n            response.raise_for_status()", "response": "Deletes all devices in a list."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef is_valid_file(path):\n    ''' Returns True if provided file exists and is a file, or False otherwise. '''\n    return os.path.exists(path) and os.path.isfile(path)", "response": "Returns True if provided file exists and is a file."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning True if provided directory exists and is a directory.", "response": "def is_valid_dir(path):\n    ''' Returns True if provided directory exists and is a directory, or False otherwise. '''\n    return os.path.exists(path) and os.path.isdir(path)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef is_readable(path):\n    '''\n    Returns True if provided file or directory exists and can be read with the current user.\n    Returns False otherwise.\n    '''\n    return os.access(os.path.abspath(path), os.R_OK)", "response": "Returns True if provided file or directory exists and can be read with the current user."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nruns a command at GITPATH directory.", "response": "def run(command, get_output=False, cwd=None):\n    \"\"\"By default, run all commands at GITPATH directory.\n    If command fails, stop program execution.\n    \"\"\"\n    if cwd is None:\n        cwd = GITPATH\n\n    cprint('===')\n    cprint('===  Command: ', command)\n    cprint('===  CWD:     ', cwd)\n    cprint('===')\n\n    if get_output:\n        proc = capture_stdout(command, cwd=cwd)\n        out = proc.stdout.read().decode()\n        print(out, end='')\n        check_exit_code(proc.returncode)\n        return out\n    else:\n        proc = sarge_run(command, cwd=cwd)\n        check_exit_code(proc.returncode)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget a cookie value.", "response": "def get(self, key: Any, default: Any = None) -> Any:\n        \"\"\"\n        \u8bfb\u53d6\u4f7f\u7528 req like koa\n        \"\"\"\n        return self._req_cookies.get(key, default)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set(self, key: str, value: str, opt: dict = None) -> None:\n        self._res_cookies.set(key, value, opt)", "response": "\u5199\u5165\u4f7f\u7528 res like koa"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nbuilding an argument parser from the given executable model.", "response": "def build_argument_parser(executable):\n    \"\"\"creates an argument parser from the given `executable` model.\n\n    An argument '__xml__' for \"--xml\" is added independently.\n\n    :param executable: CLI Model\n    :type executable: clictk.model.Executable\n    :return:\n    \"\"\"\n\n    a = ArgumentParser()\n    a.add_argument(\"--xml\", action=\"store_true\", dest=\"__xml__\", help=\"show cli xml\")\n\n    for p in executable:\n        o = []\n        if p.flag: o.append(\"-%s\" % p.flag)\n        if p.longflag: o.append(\"--%s\" % p.longflag)\n        a.add_argument(\n            *o,\n            metavar=p.type.upper(),\n            dest=p.name,\n            action=\"store\",\n            help=(p.description.strip() or \"parameter %s\" % p.name)\n        )\n\n    return a"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef cmdline(executable):\n\n    args = [executable.executable]\n    indexed_args = []\n\n    for parameter in executable:\n\n        optional = (parameter.type == 'boolean') or parameter.default\n        has_value = parameter.type != 'boolean'\n\n\n        if parameter.longflag:  # use longflag where possible\n            flag = \"--%s\" % parameter.longflag\n        elif parameter.flag:\n            flag = \"-%s VALUE\" % parameter.flag\n        elif parameter.index:\n            flag = parameter.name\n            optional = False\n\n\n        if has_value:\n            flag += \" VALUE\"\n\n        if optional:\n            flag = \"[\" + flag + \"]\"\n\n        if parameter.index:\n            indexed_args.insert(int(parameter.index), flag)\n        else:\n            args.append(flag)\n\n    return args + indexed_args", "response": "Generates a valid command line call for the specified executable."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\naccept relative timestamp dict or timedelta or absolute datetime Returns or None if ts can not be derived from ts.", "response": "def absdatetime(ts, default=None):\n    \"\"\"Accepts relative timestamp (`timedelta` or `timedelta`-supported ``dict``\n    fmt), absolute `datetime`, or failbacks to `default`. Returns `datetime` (or\n    `None` if `datetime` can not be derived from `ts`).\"\"\"\n    if ts is None:\n        ts = default\n    if isinstance(ts, dict):\n        ts = timedelta(**ts)\n    if isinstance(ts, timedelta):\n        ts = now() + ts\n    if isinstance(ts, datetime):\n        return ts\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nparse a duration string into a dictionary of time components.", "response": "def parse_duration(string):\n    '''\n    Parses duration/period stamp expressed in a subset of ISO8601 duration\n    specification formats and returns a dictionary of time components (as\n    integers). Accepted formats are:\n    \n     * ``PnYnMnDTnHnMnS``\n     \n       Note: n is positive integer! Floats are NOT supported. Any component (nX)\n       is optional, but if any time component is specified, ``T`` spearator is\n       mandatory. Also, ``P`` is always mandatory.\n       \n     * ``PnW``\n     \n       Note: n is positive integer representing number of weeks.\n       \n     * ``P<date>T<time>``\n     \n       Note: This format is basically standard ISO8601 timestamp format, without\n       the time zone and with ``P`` prepended. We support both basic and\n       extended format, which translates into following two subformats:\n       \n        - ``PYYYYMMDDThhmmss`` for basic, and\n        - ``PYYYY-MM-DDThh:mm:ss`` for extended format.\n       \n       Note that all subfields are mandatory. \n    \n    Note: whitespaces are ignored.\n    \n    Examples::\n    \n        from datetime import datetime\n        from dateutil.relativedelta import relativedelta\n        \n        rel = parse_duration('P1m')     # +1 month\n        rel = parse_duration('P 1y 1m T 2m 1s')\n        rel = parse_duration('P12w')    # +12 weeks\n        rel = parse_duration('P 0001-02-03 T 03:02:01')\n        rel = parse_duration('P00010203T030201')\n        \n        future = datetime.now() + relativedelta(**rel)\n    \n    Returns: dictionary with (some of the) fields: ``years``, ``months``,\n    ``weeks``, ``days``, ``hours``, ``minutes`` or ``seconds``. If nothing is\n    matched, an empty dict is returned.\n    '''\n\n    string = string.replace(' ', '').upper()\n    \n    # try `PnYnMnDTnHnMnS` form\n    match = re.match(\n        \"^P(?:(?:(?P<years>\\d+)Y)?(?:(?P<months>\\d+)M)?(?:(?P<days>\\d+)D)?)?\" \\\n        \"(?:T(?:(?P<hours>\\d+)H)?(?:(?P<minutes>\\d+)M)?(?:(?P<seconds>\\d+)S)?)?$\",\n        string\n    )\n    if match:\n        d = match.groupdict(0)\n        return dict(zip(d.keys(), map(int, d.values())))\n    \n    # try `PnW` form\n    match = re.match(\n        \"^P(?P<weeks>\\d+)W$\",\n        string\n    )\n    if match:\n        d = match.groupdict(0)\n        return dict(zip(d.keys(), map(int, d.values())))\n    \n    # try `P<date>T<time>` form, subforms `PYYYYMMDDThhmmss` and `PYYYY-MM-DDThh:mm:ss`\n    match = re.match(\n        \"^P(?P<years>\\d{4})(-)?(?P<months>\\d{2})(?(2)-)(?P<days>\\d{2})T(?P<hours>\\d{2})(?(2):)(?P<minutes>\\d{2})(?(2):)(?P<seconds>\\d{2})$\",\n        string\n    )\n    if match:\n        d = match.groupdict(0)\n        return dict(zip(d.keys(), map(int, d.values())))\n    \n    return {}"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef safeformat(format_string, *args):\n    \n    def hex(x):\n        \"\"\"Allow hexadecimal digits.\"\"\"\n        if re.match('^[a-fA-F\\d]*$', str(x)):\n            return str(x)\n        raise ValueError(\"Non-hex digits in hex number.\")\n    \n    def identifier(x):\n        \"\"\"Allow letters, digits, underscore and minus/dash.\"\"\"\n        if re.match('^[-\\w]*$', str(x)):\n            return str(x)\n        raise ValueError(\"Non-identifier characters in string.\")\n    \n    def iso(x):\n        if not isinstance(x, datetime):\n            raise ValueError(\"Datetime expected.\")\n        return x.isoformat()\n    \n    def isobasic(x):\n        if not isinstance(x, datetime):\n            raise ValueError(\"Datetime expected.\")\n        return x.strftime(\"%Y%m%dT%H%M%S%z\")\n    \n    converters = {\n        'int': int,\n        'hex': hex,\n        'str': str,\n        'ident': identifier,\n        'iso': iso,\n        'isobasic': isobasic\n    }\n    \n    argidx = count(0)\n    \n    def replace(match):\n        idx, typ = match.group('idx', 'typ')\n        \n        if idx is None:\n            idx = next(argidx)\n        else:\n            try:\n                idx = int(idx)\n            except:\n                raise ConversionError(\"Non-integer index: '%s'.\" % idx)\n        \n        try:\n            arg = args[idx]\n        except:\n            raise ConversionError(\"Index out of bounds: %d.\" % idx)\n        \n        try:\n            conv = converters[typ]\n        except:\n            raise ConversionError(\"Invalid converter/type: '%s'.\" % typ)\n        \n        try:\n            val = conv(arg)\n        except:\n            raise ConversionError(\"Argument '%s' not of type '%s'.\" % (arg, typ))\n        \n        return str(val)\n    \n    return re.sub(\"{(?:(?P<idx>\\d+))?:(?P<typ>\\w+)}\", replace, format_string)", "response": "String formatter with type validation."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset this person from a dictionary representation of a person.", "response": "def from_dict(self, d):\n        \"\"\"\n        Set this person from dict\n\n        :param d: Dictionary representing a person ('sitting'[, 'id'])\n        :type d: dict\n        :rtype: Person\n        :raises KeyError: 'sitting' not set\n        \"\"\"\n        self.sitting = d['sitting']\n        self.id = d.get('id', None)\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef from_tuple(self, t):\n        if len(t) > 1:\n            self.id = t[0]\n            self.sitting = t[1]\n        else:\n            self.sitting = t[0]\n            self.id = None\n        return self", "response": "Set this person from a tuple."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset this person from bits.", "response": "def from_bits(self, bits):\n        \"\"\"\n        Set this person from bits (ignores the id)\n\n        :param bits: Bits representing a person\n        :type bits: bytearray\n        :rtype: Person\n        :raises ValueError: Bits has an unexpected length\n        \"\"\"\n        # TODO include id\n        if len(bits) != Person.BITS_PER_PERSON:\n            raise ValueError(u\"Person requires exactly {} bits\".format(\n                Person.BITS_PER_PERSON\n            ))\n        self.sitting = bool(bits[0])\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef from_person(person):\n        p = Person()\n        p.id = person.id\n        p.sitting = person.sitting\n        return p", "response": "Copy person into new instance of Person\n       "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef meta_bar_chart(series=None, N=20):\n    \"Each column in the series is a dict of dicts\"\n    if not series or isinstance(series, basestring):\n        series = json.load(load_app_meta)\n    if isinstance(series, Mapping) and isinstance(series.values()[0], Mapping):\n        rows_received = series['# Received'].items()\n    elif isinstance(series, Mapping):\n        rows_received = series.items()\n    else:\n        rows_received = list(series)\n\n    #rows = sorted(rows, key=operator.itemgetter(1), reverse=True)\n    rows = sorted(rows_received, key=lambda x: x[1], reverse=True)\n    received_names, received_qty = zip(*rows)\n    ra_qty = [(series['Qty in RA'].get(name, 0.) or 0.) for name in received_names]\n    # percent = [100. - 100. * (num or 0.) / (den or 1.) for num, den in zip(received_qty, ra_qty)]\n\n    # only care about the top 30 model numbers in terms of quantity\n    #ind = range(N)\n\n    figs = []\n\n    figs += [plt.figure()]\n    ax = figs[-1].add_subplot(111)\n    ax.set_ylabel('# Units Returned')\n    ax.set_title('Most-Returned LCDTV Models 2013-present')\n    x = np.arange(N)\n    bars1 = ax.bar(x, received_qty[:N], color='b', width=.4, log=1)\n    bars2 = ax.bar(x+.4, ra_qty[:N], color='g', width=.4, log=1)\n    ax.set_xticks(range(N))\n    ax.set_xticklabels(received_names[:N], rotation=35)\n    ax.grid(True)\n    ax.legend((bars1[0], bars2[0]), ('# in RA', '# Received'), 'center right')\n    figs[-1].show()", "response": "Each column in the series is a dict of dicts"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a dictionary of dicts containing metadata about the database tables associated with an app.", "response": "def get_db_meta(app=DEFAULT_APP_NAME, db_alias=None, table=None, verbosity=0, column=None):\n    \"\"\"Return a dict of dicts containing metadata about the database tables associated with an app\n\n    TODO: allow multiple apps\n    >>> get_db_meta('crawler', db_alias='default', table='crawler_wikiitem')  # doctest: +ELLIPSIS\n    OrderedDict([('WikiItem', OrderedDict([('Meta', OrderedDict([('primary_key', None), ('count', 1332), ('db_table', u'crawler_wikiitem')])), (u'id', OrderedDict([('name', u'id'), ('type', ...\n    \"\"\"\n    if verbosity > 0:\n        print 'Looking for app %r.' % (app, )\n    if app and isinstance(app, basestring):\n        app = djdb.get_app(app, verbosity=verbosity)\n    else:\n        app = djdb.get_app('')\n    model_names = list(mc.__name__ for mc in models.get_models(app))\n    if verbosity > 0:\n        print 'Found %d models for app %r.' % (len(model_names), app)\n    meta = OrderedDict()\n    # inspectdb uses: for table_name in connection.introspection.table_names(cursor):\n    for model_name in model_names:\n        model = djdb.get_model(model_name, app=app)\n        if db_alias:\n            model_db_alias = db_alias\n        else:\n            model_db_alias = router.db_for_read(model)\n        queryset = model.objects\n        if model_db_alias:\n            queryset = queryset.using(model_db_alias)\n        if model and table is not None and isinstance(table, basestring):\n            if model._meta.db_table != table:\n                if verbosity>1:\n                    print 'Skipped model named %s with db table names %s.' % (model_name, model._meta.db_table)\n                continue\n        elif callable(table):\n            if not table(model._meta.db_table):\n                if verbosity>1:\n                    print 'Skipped model named %s with db table names %s.' % (model_name, model._meta.db_table)\n                continue\n        count = None\n        try:\n            if verbosity > 1:\n                print 'Trying to count records in model %r and db_alias %r' % (model, model_db_alias)\n            count = queryset.count()\n        except DatabaseError as e:\n            if verbosity > 0:\n                print_exc()\n                print \"DatabaseError: Unable to count records for model '%s' (%s) because of %s.\" % (model.__name__, repr(model), e)\n            transaction.rollback()\n        except:\n            print_exc()\n            print 'Connection doesnt exist?'\n\n        meta[model_name] = OrderedDict()\n        meta[model_name]['Meta'] = OrderedDict()\n        meta[model_name]['Meta']['primary_key'] = None\n        meta[model_name]['Meta']['count'] = count\n        meta[model_name]['Meta']['db_table'] = model._meta.db_table\n        \n        if verbosity > 1:\n            print '%s.Meta = %r' % (model_name, meta[model_name]['Meta'])\n        \n        # inspectdb uses: connection.introspection.get_table_description(cursor, table_name)\n        properties_of_fields = sql.get_meta_dicts(cursor=model_db_alias, table=meta[model_name]['Meta']['db_table'], verbosity=verbosity)\n        model_meta = OrderedDict((field['name'], field) for field in properties_of_fields)\n        if verbosity > 1:\n            print '-' * 20 + model_name + '-' * 20\n        db_primary_keys = [field['name'] for field in properties_of_fields if field['primary_key']]\n        if len(db_primary_keys) == 1:\n            meta[model_name]['Meta']['primary_key'] = db_primary_keys[0]\n\n        # augment model_meta with additional stats, but only if there are enough rows to get statistics\n        model_meta = augment_model_meta(model, model_db_alias, model_meta, column_name_filters=column, count=count, verbosity=verbosity)\n\n        if verbosity > 1:\n            print model_meta\n        meta[model_name].update(model_meta)\n    return meta"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\naugment the model meta data with the data from the given model.", "response": "def augment_model_meta(model, db_alias, model_meta, column_name_filters=None, count=0, verbosity=0):\n    \"\"\"Fields are keyed by their db_column name rather than field name (like model_meta)\"\"\"\n    if settings.DEBUG and verbosity > 2:\n        print 'Augmenting model meta data for %r...' % model\n\n    column_name_filters = util.listify(column_name_filters)\n    queryset = djdb.get_queryset(model)\n\n    if db_alias:\n        queryset = queryset.using(db_alias)\n    for field_name in model._meta.get_all_field_names():\n        field = None\n        try:\n            field = model._meta.get_field(field_name)\n            db_column = field.db_column\n        # Django creates reverse ForeignKey relationship fields that may not have a database column in this table\n        # This happens if you make existing fields/columns in other tables a ForeignKey referencing this table\n        except FieldDoesNotExist:\n            db_column = None\n        if not field:\n            if verbosity > 0:\n                print \"WARNING: Skipped 'phantom' field named '%s'.  This is likely because of a ForeignKey relationship elsewhere back to this model (%r). No field found in the model '%s' for database '%s'.\" % (field_name, model, model.__name__, db_alias)\n            continue\n        if not db_column:\n            if field.name in model_meta:\n                db_column = field.name\n            elif field.name.lower() in model_meta:\n                db_column = field.name.lower()\n            elif field.name.upper() in model_meta:\n                db_column = field.name.upper()\n        if not db_column:\n            if verbosity > 0:\n                print \"WARNING: Skipped field named '%s'. No column found in the database.table '%s.%s'.\" % (field.name, db_alias, model.__name__)\n            continue\n        if column_name_filters:\n            if not any(((callable(cnf) and cnf(db_column)) or (db_column == cnf)) for cnf in column_name_filters):\n                if verbosity > 0:\n                    print \"WARNING: Skipped field named '%s' for table '%s.%s' because it didn't match any filters: %r.\" % (field.name, db_alias, model.__name__, column_name_filters)\n                continue\n        if (field.name == 'id' and isinstance(field, models.fields.AutoField)\n                and field.primary_key and (not model_meta[db_column]['primary_key'])):\n            print \"WARNING: Skipped field named '%s' for table '%s.%s' because it is an AutoField and no primary_key is defined for this table.\" % (field.name, db_alias, model.__name__)\n            continue\n\n        model_meta[db_column] = augment_field_meta(field, queryset, model_meta[db_column], count=count, verbosity=verbosity)\n        if verbosity > 1:\n            print '%s (%s of type %s) has %s / %s (%3.1f%%) distinct values between %s and %s, excluding %s nulls.' % (field.name, db_column, \n                                                        model_meta[db_column]['type'],\n                                                        model_meta[db_column]['num_distinct'], \n                                                        count,\n                                                        100. * (model_meta[db_column]['num_distinct'] or 0) / (count or 1),\n                                                        repr(model_meta[db_column]['min']),\n                                                        repr(model_meta[db_column]['max']),\n                                                        model_meta[db_column]['num_null'])\n    return model_meta"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\naugment a field meta data dictionary with the values of the given field.", "response": "def augment_field_meta(field, queryset, field_properties, verbosity=0, count=0):\n    \"\"\"Return a dict of statistical properties (metadata) for a database column (model field)\n\n    Strings are UTF-8 encoded (UTF-16 or invalid UTF-8 characters are ignored)\n    Resulting dictionary is json-serializable using the pug.nlp.db.RobustEncoder class.\n\n    {\n        'num_distinct':   # count of distinct (different) discrete values within the column\n        'min':   # minimum value\n        'max':   # maximum value\n        'num_null':   # count of the Null or None values in the column\n        'type':  # database column type\n    }\n\n    TODO:\n      1. count the number of values that are strings that could be converted to\n         a. integers\n         b. floats\n         c. dates / datetimes\n         d. booleans / nullbooleans\n         e. other ordinal, categorical, or quantitative types\n      2. count the number of null values\n         a. null/None\n         b. blank\n         c. whitespace or other strings signifying null ('NULL', 'None', 'N/A', 'NaN', 'Not provided')\n    \"\"\"\n    if settings.DEBUG and verbosity > 3:\n        print 'Augmenting field meta data for %r...' % field\n    # Calculate the fraction of values in a column that are distinct (unique).\n    #   For columns that aren't populated with 100% distinct values, the fraction may help identify columns that are part of a  \"unique-together\" compound key\n    #   Necessary constraint for col1 and col2 to be compound key: col1_uniqueness + col2_uniqueness >= 1.0 (100%)\n    # TODO: check for other clues about primary_keyness besides just uniqueness \n    field_properties['num_distinct'] = -1\n    field_properties['num_null'] = -1\n    field_properties['fraction_distinct'] = -1\n\n    typ = field_properties.get('type')\n    if typ and typ not in types_not_countable and count:\n        try:\n            field_properties['num_distinct'] = queryset.values(field.name).distinct().count()\n            field_properties['num_null'] = queryset.filter(**{'%s__isnull' % field.name: True}).count()\n            field_properties['fraction_distinct'] = float(field_properties['num_distinct']) / (count or 1)\n        except DatabaseError as e:\n            if verbosity > 0:\n                print_exc()\n                print \"DatabaseError: Skipped count of values in field named '%s' (%s) because of %s.\" % (field.name, repr(field.db_column), e)\n            transaction.rollback()\n        try:\n            if field_properties['num_distinct'] > 1 and (0 < field_properties['fraction_distinct'] < 0.999):\n                # this will not work until pyodbc is updated\n                # May be related to django-pyodbc incompatability with django 1.6\n                # FIXME: use the working query for values.distinct.count and sort that dict and then query the top 10 of those individually\n                field_properties['most_frequent'] = [(v, c) for (v,c) in \n                                                     queryset.distinct().values(field.name).annotate(field_value_count=models.Count(field.name))\n                                                     .extra(order_by=['-field_value_count']).values_list(field.name, 'field_value_count')\n                                                     [:min(field_properties['num_distinct'], 10)]\n                                                    ]\n        except (StandardError, FieldError, DatabaseError) as e:\n            if verbosity > 0:\n                print \"Warning: Failed to calculate the Top-10 histogram for field named '%s' (%s) because of %s.\" % (field.name, repr(field.db_column), e)\n            if verbosity > 2:\n                print_exc()\n\n    field_properties['max'] = None\n    field_properties['min'] = None\n    field_properties['longest'] = None\n    field_properties['shortest'] = None\n    # check field_properties['num_null'] for all Null first?\n    if count and typ and typ not in types_not_aggregatable:\n        transaction.rollback()\n        try:\n            field_properties['max'] = db.clean_utf8(queryset.aggregate(max_value=models.Max(field.name))['max_value'])\n            field_properties['min'] = db.clean_utf8(queryset.aggregate(min_value=models.Min(field.name))['min_value'])\n        except ValueError as e:\n            if verbosity > 0:\n                print_exc()\n                print \"ValueError (perhaps UnicodeDecodeError?): Skipped max/min calculations for field named '%s' (%s) because of %s.\" % (field.name, repr(field.db_column), e)\n            transaction.rollback()\n        except DatabaseError, e:\n            if verbosity > 0:\n                print_exc()\n                print \"DatabaseError: Skipped max/min calculations for field named '%s' (%s) because of %s.\" % (field.name, repr(field.db_column), e)\n            transaction.rollback()\n        # validate values that might be invalid strings do to db encoding/decoding errors (make sure they are UTF-8\n        for k in ('min', 'max'):\n            db.clean_utf8(field_properties.get(k))\n\n        length_name = field.name + '___' + 'bytelength'\n        qs = queryset.extra(select={length_name: \"LENGTH(%s)\"}, select_params=(field.name,)).order_by(length_name)\n        if qs.exists():\n            # first() and last() aren't possible in Django 1.5\n            field_properties['shortest'] = db.clean_utf8(getattr(qs.all()[0], length_name, None))\n            field_properties['longest'] =  db.clean_utf8(getattr(qs.order_by('-'+length_name).all()[0], length_name, None))\n    return field_properties"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef index_with_dupes(values_list, unique_together=2, model_number_i=0, serial_number_i=1, verbosity=1):\n    '''Create dict from values_list with first N values as a compound key.\n\n    Default N (number of columns assumbed to be \"unique_together\") is 2.\n    >>> index_with_dupes([(1,2,3), (5,6,7), (5,6,8), (2,1,3)]) == ({(1, 2): (1, 2, 3), (2, 1): (2, 1, 3), (5, 6): (5, 6, 7)}, {(5, 6): [(5, 6, 7), (5, 6, 8)]})\n    True\n    '''\n    try:\n        N = values_list.count()\n    except:\n        N = len(values_list)\n    if verbosity > 0:\n        print 'Indexing %d values_lists in a queryset or a sequence of Django model instances (database table rows).' % N\n    index, dupes = {}, {}\n    pbar = None\n    if verbosity and N > min(1000000, max(0, 100000**(1./verbosity))):\n        widgets = [pb.Counter(), '%d rows: ' % N, pb.Percentage(), ' ', pb.RotatingMarker(), ' ', pb.Bar(),' ', pb.ETA()]\n        pbar = pb.ProgressBar(widgets=widgets, maxval=N).start()\n    rownum = 0\n    for row in values_list:\n        normalized_key = [str(row[model_number_i]).strip(), str(row[serial_number_i]).strip()]\n        normalized_key += [i for i in range(unique_together) if i not in (serial_number_i, model_number_i)]\n        normalized_key = tuple(normalized_key)\n        if normalized_key in index:\n            # need to add the first nondupe before we add the dupes to the list\n            if normalized_key not in dupes:\n                dupes[normalized_key] = [index[normalized_key]]\n            dupes[normalized_key] = dupes[normalized_key] + [row]\n            if verbosity > 2:\n                print 'Duplicate \"unique_together\" tuple found. Here are all the rows that match this key:'\n                print dupes[normalized_key]\n        else:\n            index[normalized_key] = row \n        if pbar:\n            pbar.update(rownum)\n        rownum += 1\n    if pbar:\n        pbar.finish()\n    if verbosity > 0:\n        print 'Found %d duplicate model-serial pairs in the %d records or %g%%' % (len(dupes), len(index), len(dupes)*100./(len(index) or 1.))\n    return index, dupes", "response": "Create dict from values_list with first N values as a compound key."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef index_model_field(model, field, value_field='pk', key_formatter=str.strip, value_formatter=str.strip, batch_len=10000, limit=10000000, verbosity=1):\n    '''Create dict {obj.<field>: obj.pk} for all field_values in a model or queryset.\n    '''\n    try:\n        qs = model.objects\n    except:\n        qs = model\n\n    N = qs.count()\n    if verbosity > 0:\n        print 'Indexing %d rows to aid in finding %s.%s values using %s.%s.' % (N, qs.model.__name__, value_field, qs.model.__name__, field)\n\n    index, dupes, rownum = {}, {}, 0\n\n    pbar, rownum = None, 0\n    if verbosity and N > min(1000000, max(0, 100000**(1./verbosity))):\n        widgets = [pb.Counter(), '/%d rows: ' % N, pb.Percentage(), ' ', pb.RotatingMarker(), ' ', pb.Bar(),' ', pb.ETA()]\n        pbar = pb.ProgressBar(widgets=widgets, maxval=N).start()\n\n    # to determine the type of the field value and decide whether to strip() or normalize in any way\n    #obj0 = qs.filter(**{field + '__isnull': False}).all()[0]\n\n    for obj in qs.all():\n        field_value = getattr(obj, field)\n        try:\n            field_value = key_formatter(field_value)\n        except:\n            pass\n        if value_field:\n            entry_value = getattr(obj, value_field)\n        else:\n            entry_value = obj\n        try:\n            entry_value = value_formatter(entry_value)\n        except:\n            pass\n        if field_value in index:\n            dupes[field_value] = dupes.get(field_value, []) + [entry_value]\n        else:\n            index[field_value] = entry_value\n        rownum += 1\n        if rownum >= limit:\n            break\n        if pbar:\n            pbar.update(rownum)\n    if pbar:\n        pbar.finish()\n    if verbosity > 0:\n        print 'Found %d duplicate %s values among the %d records or %g%%' % (len(dupes), field, len(index), len(dupes)*100./(len(index) or 1.))\n    return index, dupes", "response": "Index all field_values in a model or queryset."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nlike index_model_field except uses 50x less memory and 10x more processing cycles Returns 2 dicts where the keys and values are tuples where the keys are model - serial pairs and the values are values.", "response": "def index_model_field_batches(model_or_queryset, key_fields=['model_number', 'serial_number'], value_fields=['pk'], \n    key_formatter=lambda x: str.lstrip(str.strip(str(x or '')), '0'), \n    value_formatter=lambda x: str.strip(str(x)), batch_len=10000,\n    limit=100000000, verbosity=1):\n    '''Like index_model_field except uses 50x less memory and 10x more processing cycles\n\n    Returns 2 dicts where both the keys and values are tuples:\n\n    target_index = {(<key_fields[0]>, <key_fields[1]>, ...): (<value_fields[0]>,)} for all distinct model-serial pairs in the Sales queryset\n    target_dupes = {(<key_fields[0]>, <key_fields[1]>, ...): [(<value_fields[1]>,), (<value_fields[2]>,), ...]}  with all the duplicates except the first pk already listed above\n    '''\n\n    qs = djdb.get_queryset(model_or_queryset)\n\n    N = qs.count()\n    if verbosity > 0:\n        print 'Indexing %d rows (database records) to aid in finding record %r values using the field %r.' % (N, value_fields, key_fields)\n\n    index, dupes, rownum = {}, {}, 0\n\n    pbar, rownum = None, 0\n    if verbosity and N > min(1000000, max(0, 100000**(1./verbosity))):\n        widgets = [pb.Counter(), '/%d rows: ' % N, pb.Percentage(), ' ', pb.RotatingMarker(), ' ', pb.Bar(),' ', pb.ETA()]\n        pbar = pb.ProgressBar(widgets=widgets, maxval=N).start()\n\n\n    # to determine the type of the field value and decide whether to strip() or normalize in any way\n    #obj0 = qs.filter(**{field + '__isnull': False}).all()[0]\n\n    value_fields = util.listify(value_fields)\n    key_fields = util.listify(key_fields)\n\n    for batch in djdb.generate_queryset_batches(qs, batch_len=batch_len, verbosity=verbosity):\n        for obj in batch:\n            # print obj\n            # normalize the key\n            keys = []\n            for kf in key_fields:\n                k = getattr(obj, kf)\n                keys += [key_formatter(k or '')]\n            values = []\n            keys = tuple(keys)\n            for vf in value_fields:\n                v = getattr(obj, vf)\n                values += [value_formatter(v or '')]\n            values = tuple(values)           \n\n            if keys in index:\n                dupes[keys] = dupes.get(keys, []) + [values]\n            else:\n                index[keys] = values\n            # print rownum  / float(N)\n            if pbar:\n                pbar.update(rownum)\n            rownum += 1\n            if rownum >= limit:\n                break\n    if pbar:\n        pbar.finish()\n    if verbosity > 0:\n        print 'Found %d duplicate %s values among the %d records or %g%%' % (len(dupes), key_fields, len(index), len(dupes)*100./(len(index) or 1.))\n    return index, dupes"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef find_index(model_meta, weights=None, verbosity=0):\n    weights = weights or find_index.default_weights\n    N = model_meta['Meta'].get('count', 0)\n    for field_name, field_meta in model_meta.iteritems():\n        if field_name == 'Meta':\n            continue\n        pkfield = field_meta.get('primary_key')\n        if pkfield:\n            if verbosity > 1:\n                print pkfield\n            # TODO: Allow more than one index per model/table\n            return {\n                field_name: {\n                    'primary_key': True,\n                    'unique': field_meta.get('unique') or (\n                        N >= 3 and field_meta.get('num_null') <= 1\n                        and field_meta.get('num_distinct') == N),\n                    }}\n    score_names = []\n    for field_name, field_meta in model_meta.iteritems():\n        score = 0\n        for feature, weight in weights:\n            # for categorical features (strings), need to look for a particular value\n            value = field_meta.get(feature)\n            if isinstance(weight, tuple):\n                if value is not None and value in (float, int):\n                    score += weight * value\n                if callable(weight[1]):\n                    score += weight[0] * weight[1](field_meta.get(feature))\n                else:\n                    score += weight[0] * (field_meta.get(feature) == weight[1])\n            else:\n                feature_value = field_meta.get(feature)\n                if feature_value is not None:\n                    score += weight * field_meta.get(feature)\n        score_names += [(score, field_name)]\n    max_name = max(score_names)\n    field_meta = model_meta[max_name[1]]\n    return (\n        max_name[1],\n        {\n            'primary_key': True,\n            'unique': field_meta.get('unique') or (\n                N >= 3 \n                and field_meta.get('num_null') <= 1 \n                and field_meta.get('num_distinct') == N),\n        },\n        max_name[0],\n        )", "response": "Return a tuple of index metadata for the model metadata dict provided."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef meta_to_indexes(meta, table_name=None, model_name=None):\n    indexes, pk_field = {}, None\n\n    indexes = []\n    for meta_model_name, model_meta in meta.iteritems():\n        if (table_name or model_name) and not (table_name == model_meta['Meta'].get('db_table', '') or model_name == meta_model_name):\n            continue\n        field_name, field_infodict, score = find_index(model_meta)\n        indexes.append(('%s.%s' % (meta_model_name, field_name), field_infodict, score))\n    return indexes", "response": "Find all the indexes based on the meta data \n   "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ntry to convert a string into more useful python type.", "response": "def try_convert(value, datetime_to_ms=False, precise=False):\n    \"\"\"Convert a str into more useful python type (datetime, float, int, bool), if possible\n\n    Some precision may be lost (e.g. Decimal converted to a float)\n\n    >>> try_convert('false')\n    False\n    >>> try_convert('123456789.123456')\n    123456789.123456\n    >>> try_convert('1234')\n    1234\n    >>> try_convert(1234)\n    1234\n    >>> try_convert(['1234'])\n    ['1234']\n    >>> try_convert('12345678901234567890123456789012345678901234567890', precise=True)\n    12345678901234567890123456789012345678901234567890L\n    >>> try_convert('12345678901234567890123456789012345678901234567890.1', precise=True)\n    Decimal('12345678901234567890123456789012345678901234567890.1')\n    \"\"\"\n    if not isinstance(value, basestring):\n        return value\n    if value in db.YES_VALUES or value in db.TRUE_VALUES:\n        return True\n    elif value in db.NO_VALUES or value in db.FALSE_VALUES:\n        return False\n    elif value in db.NULL_VALUES:\n        return None\n    try:\n        if not precise:\n            try:\n                return int(value)\n            except:\n                try:\n                    return float(value)\n                except:\n                    pass\n        else:\n            dec, i, f = None, None, None\n            try:\n                dec = Decimal(value)\n            except:\n                return try_convert(value, precise=False)\n            try:\n                i = int(value)\n            except:\n                try:\n                    f = float(value)\n                except:\n                    pass\n            if dec is not None:\n                if dec == i:\n                    return i\n                elif dec == f:\n                    return f\n                return dec\n    except:\n        pass\n    try:\n        dt = dateutil.parse(value)\n        if dt and isinstance(dt, datetime.datetime) and (3000 >= dt.year >= 1900):\n            if datetime_to_ms:\n                return db.datetime_in_milliseconds(dt)\n            return dt\n    except:\n        pass\n    return value"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconverts a loaded json file to native python types", "response": "def convert_loaded_json(js):\n    \"\"\"Convert strings loaded as part of a json file/string to native python types\n\n    convert_loaded_json({'x': '123'})\n    {'x': 123}\n    convert_loaded_json([{'x': '123.'}, {'x': 'Jan 28, 2014'}])\n    [{'x': 123}, datetime.datetime(2014, 1, 18)]\n    \"\"\"\n    if not isinstance(js, (Mapping, tuple, list)):\n        return try_convert(js)\n    try:\n        return type(js)(convert_loaded_json(item) for item in js.iteritems())\n    except:\n        try:\n            return type(js)(convert_loaded_json(item) for item in iter(js))\n        except:\n            return try_convert(js)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a list of models that have at least one field that has all distinct values.", "response": "def models_with_unique_column(meta, exclude_single_pk=True, exclude_multi_pk=True):\n    \"\"\"Return a list of model names for models that have at least 1 field that has all distinct values (could be used as primary_key)\"\"\"\n    models_with_potential_pk = {}\n    fields_distinct = {}\n    for model_name, model_fields in meta.iteritems():\n        if exclude_single_pk and model_fields['Meta']['primary_key']:\n                continue\n        fields_distinct = []\n        for field_name, field in model_fields.iteritems():\n            if field_name is 'Meta':\n                continue\n            if float(field.get('fraction_distinct', 0)) == 1.:\n                fields_distinct += [field_name]\n        # if any(not field['primary_key'] and field['num_distinct'] == 1 for field_name, field in model_fields.iteritems() if field is not 'Meta'):\n        if (not exclude_multi_pk and fields_distinct) or len(fields_distinct) == 1:\n            models_with_potential_pk[model_name] = fields_distinct\n    return models_with_potential_pk"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nuses the Django ORM or collections. Counter to count unique values of a field in a table", "response": "def count_unique(table, field=-1):\n    \"\"\"Use the Django ORM or collections.Counter to count unique values of a field in a table\n\n    `table` is one of:\n    1. An iterable of Django model instances for a database table (e.g. a Django queryset)\n    2. An iterable of dicts or lists with elements accessed by row[field] where field can be an integer or string\n    3. An iterable of objects or namedtuples with elements accessed by `row.field`\n\n    `field` can be any immutable object (the key or index in a row of the table that access the value to be counted)\n    \"\"\"\n    from collections import Counter\n\n    # try/except only happens once, and fastest route (straight to db) tried first\n    try:\n        ans = {}\n        for row in table.distinct().values(field).annotate(field_value_count=models.Count(field)):\n            ans[row[field]] = row['field_value_count']\n        return ans\n    except:\n        try:\n            return Counter(row[field] for row in table)\n        except:\n            try:\n                return Counter(row.get(field, None) for row in table)\n            except:\n                try:\n                    return Counter(row.getattr(field, None) for row in table)\n                except:\n                    pass"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the context for a single page.", "response": "def get_page_tpl_ctx(page, request):\n    \"\"\"\n    \u0412\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u043a\u043e\u043d\u0442\u0435\u043a\u0441\u0442 \u0434\u043b\u044f \u0440\u0435\u043d\u0434\u0435\u0440\u0438\u043d\u0433\u0430 \u043f\u0440\u0435\u0434\u0441\u0442\u0430\u0432\u043b\u0435\u043d\u0438\u044f \u0442\u0435\u043a\u0441\u0442\u043e\u0432\u043e\u0439 \u0441\u0442\u0440\u0430\u043d\u0438\u0446\u044b\n    :param page: \u043c\u043e\u0434\u0435\u043b\u044c \u0441\u0442\u0440\u0430\u043d\u0438\u0446\u044b\n    :param request: \u0437\u0430\u043f\u0440\u043e\u0441\n    :return:\n    \"\"\"\n    text = Template(page.text).render(Context())\n    meta = MetaSeo(page)\n    comments = get_object_comments(PageComment, page.id)\n    comments_form = PageCommentForm(initial=get_comment_init(request, page))\n    if page.slug == Page.MAIN_SLUG:\n        crumbs = None\n    else:\n        crumbs = page.get_breadcrumbs()\n    return {'page': page, 'comments': comments, 'comments_form': comments_form, 'text': text, 'meta': meta, 'crumbs': crumbs}"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a dict that can be used to initialize a single comment.", "response": "def get_comment_init(request, obj):\n    \"\"\"\n    \u0412\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u0441\u043b\u043e\u0432\u0430\u0440\u044c \u0434\u043b\u044f \u0438\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u0438 \u043d\u0430\u0447\u0430\u043b\u044c\u043d\u044b\u0445 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0439 \u043c\u043e\u0434\u0435\u043b\u0438 \u043a\u043e\u043c\u043c\u0435\u043d\u0442\u0430\u0440\u0438\u044f\n    :param request: \u0437\u0430\u043f\u0440\u043e\u0441\n    :param obj: \u043e\u0431\u044a\u0435\u043a\u0442 \u043a \u043a\u043e\u0442\u043e\u0440\u043e\u043c\u0443 \u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u043a\u043e\u043c\u043c\u0435\u043d\u0442\u0430\u0440\u0438\u0439\n    :return:\n    \"\"\"\n    if request.user.is_authenticated():\n        init = {'obj': obj, 'username': request.user.username, 'email': request.user.email}\n    else:\n        init = {'obj': obj}\n    return init"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef post_comment(form, user):\n    if form.is_valid():\n        model = form.save(commit=False)\n        if user.is_authenticated():\n            model.author = user\n        model.save()\n        return True\n    else:\n        return False", "response": "\u041f\u043e\u0441\u0442\u0438\u043d\u0433 \u043a\u043e\u043c\u043c\u0435\u043d\u0442\u0430\u0440\u0438\u044f\n    :param form: \u0444\u043e\u0440\u043c\u0430 \u043a\u043e\u043c\u043c\u0435\u043d\u0442\u0430\u0440\u0438\u044f\n    :param user: \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c\n    :return:"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef save_formset_with_author(formset, user):\n    instances = formset.save(commit=False)\n    for obj in formset.deleted_objects:\n        obj.delete()\n    for instance in instances:\n        if user.is_authenticated() and hasattr(instance, 'author') and not instance.author:\n            instance.author = user\n        instance.save()\n    formset.save_m2m()", "response": "Save a formset with the given user."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_by_page(query, page, page_size):\n    pager = Paginator(query, page_size)\n\n    try:\n        models = pager.page(page)\n    except PageNotAnInteger:\n        # If page is not an integer, deliver first page.\n        models = pager.page(1)\n    except EmptyPage:\n        # If page is out of range (e.g. 9999), deliver last page of results.\n        models = pager.page(pager.num_pages)\n\n    return models", "response": "\u041e\u0441\u0443\u0449\u0435\u0441\u0442\u0432\u043b\u044f\u0435\u0442 \u043f\u0430\u0433\u0438\u043d\u0430\u0446\u0438\u044e\n    :param query: \u0437\u0430\u043f\u0440\u043e\u0441\n    :param page: \u043d\u043e\u043c\u0435\u0440 \u0441\u0442\u0440\u0430\u043d\u0438\u0446\u044b\n    :param page_size: \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043e\u0431\u044a\u0435\u043a\u0442\u043e\u0432 \u043d\u0430 \u0441\u0442\u0440\u0430\u043d\u0438\u0446\u0435\n    :return:"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nmark current menus as current", "response": "def mark_current_menus(menus, path_info):\n    \"\"\"\n    \u041e\u0442\u043c\u0435\u0447\u0430\u0435\u0442 \u0430\u043a\u0442\u0438\u0432\u043d\u044b\u0435 \u043c\u043e\u0434\u0435\u043b\u0438 \u043c\u0435\u043d\u044e (\u0423 \u043a\u043e\u0442\u043e\u0440\u044b\u0445 \u0441\u0441\u044b\u043b\u043a\u0430 \u0441\u043e\u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0443\u0435\u0442 \u0442\u0435\u043a\u0443\u0449\u0435\u043c\u0443 path info)\n    :param menus: \u0441\u043f\u0438\u0441\u043e\u043a \u043c\u043e\u0434\u0435\u043b\u0435\u0439 \u043c\u0435\u043d\u044e\n    :param path_info: path info\n    :return:\n    \"\"\"\n    for menu in menus:\n        if menu.get_absolute_url() == \"/\":\n            menu.is_current = menu.get_absolute_url() == path_info\n        else:\n            menu.is_current = path_info.find(menu.get_absolute_url()) == 0"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef reverse_cipher(message):\n    translated = ''\n\n    i = len(message) - 1\n    while i >= 0:\n        translated = translated + message[i]\n        i = i - 1\n\n    return translated", "response": "Reverse cipher a message."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef readTables(self):\n        class D: pass\n        cur=self.cur\n        cur.execute('SELECT * FROM users')\n        D.users = cur.fetchall()\n        cur.execute('SELECT * FROM profiles')\n        D.profiles = cur.fetchall()\n        cur.execute('SELECT * FROM articles')\n        D.articles = cur.fetchall()\n        cur.execute('SELECT * FROM comments')\n        D.comments = cur.fetchall()\n        cur.execute('SELECT * FROM friendships')\n        D.friendships= cur.fetchall()\n        cur.execute('SELECT * FROM votes')\n        D.votes= cur.fetchall()\n        cur.execute('SELECT * FROM tags')\n        D.tags= cur.fetchall()\n        cur.execute('SELECT * FROM taggings')\n        D.taggings= cur.fetchall()\n        self.D=D\n\n        class N: pass\n        cur.execute(\"select column_name from information_schema.columns where table_name='users';\")\n        UN=cur.fetchall()\n        N.UN=[i[0] for i in UN[::-1]]\n        cur.execute(\"select column_name from information_schema.columns where table_name='profiles';\")\n        PN=cur.fetchall()\n        N.PN=[i[0] for i in PN[::-1]]\n        cur.execute(\"select column_name from information_schema.columns where table_name='articles';\")\n        AN=cur.fetchall()\n        N.AN=[i[0] for i in AN[::-1]]\n        cur.execute(\"select column_name from information_schema.columns where table_name='comments';\")\n        CN=cur.fetchall()\n        N.CN=[i[0] for i in CN[::-1]]\n        cur.execute(\"select column_name from information_schema.columns where table_name='friendships';\")\n        FRN=cur.fetchall()\n        N.FRN=[i[0] for i in FRN[::-1]]\n        cur.execute(\"select column_name from information_schema.columns where table_name='votes';\")\n        VN=cur.fetchall()\n        N.VN=[i[0] for i in VN[::-1]]\n        cur.execute(\"select column_name from information_schema.columns where table_name='tags';\")\n        TN=cur.fetchall()\n        N.TN=[i[0] for i in TN[::-1]]\n        cur.execute(\"select column_name from information_schema.columns where table_name='taggings';\")\n        TTN=cur.fetchall()\n        N.TTN=[i[0] for i in TTN[::-1]]\n        self.N=N", "response": "Reads all relational tables and returns a dictionary of data and names."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef startGraph(self):\n        g = r.Graph()\n        g.namespace_manager.bind(\"rdf\", r.namespace.RDF)    \n        g.namespace_manager.bind(\"foaf\", r.namespace.FOAF)    \n        g.namespace_manager.bind(\"xsd\", r.namespace.XSD)    \n        g.namespace_manager.bind(\"opa\", \"http://purl.org/socialparticipation/opa/\")    \n        g.namespace_manager.bind(\"ops\", \"http://purl.org/socialparticipation/ops/\")    \n        g.namespace_manager.bind(\"wsg\", \"http://www.w3.org/2003/01/geo/wgs84_pos#\")    \n        g.namespace_manager.bind(\"dc2\", \"http://purl.org/dc/elements/1.1/\")    \n        g.namespace_manager.bind(\"dc\", \"http://purl.org/dc/terms/\")    \n        g.namespace_manager.bind(\"sioc\", \"http://rdfs.org/sioc/ns#\")    \n        g.namespace_manager.bind(\"tsioc\", \"http://rdfs.org/sioc/types#\")    \n        g.namespace_manager.bind(\"schema\", \"http://schema.org/\")\n        g.namespace_manager.bind(\"part\", \"http://participa.br/\")\n        self.g=g", "response": "Starts the RDF graph and bing namespaces"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nmakes triples with information about the portal.", "response": "def triplifyPortalInfo(self):\n        \"\"\"Make triples with information about the portal.\n        \"\"\"\n        uri=self.P.opa.ParticipationPortal+self.separator+\"participabr\"\n        self.X.G(uri,self.P.rdf.type,self.P.opa.ParticipationPortal)\n        self.X.G(uri,self.P.opa.description,self.X.L(DATA.portal_description,self.P.xsd.string))\n        self.X.G(uri,self.P.opa.url,self.X.L(\"http://participa.br/\",self.P.xsd.string))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef triplifyOverallStructures(self):\n        if self.compute_networks:\n            self.computeNetworks()\n        if self.compute_bows:\n            self.computeBows()", "response": "Insert into RDF graph the textual and network structures."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef install_npm_modules():\n    # This is a little weird, but we do it this way because if you\n    # have package.json, then heroku thinks this might be a node.js\n    # app.\n    call_command('cp node.json package.json', verbose=True)\n    call_command('npm install', verbose=True)\n    call_command('rm package.json', verbose=True)", "response": "Uses npm to dependencies in node. json"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef defer(\n            self,\n            func: typing.Callable[[], typing.Any],\n            until: typing.Union[int, float]=-1,\n    ) -> typing.Any:\n        \"\"\"Defer the execution of a function until some clock value.\n\n        Args:\n            func (typing.Callable[[], typing.Any]): A callable that accepts no\n                arguments. All return values are ignored.\n            until (typing.Union[int, float]): A numeric value that represents\n                the clock time when the callback becomes available for\n                execution. Values that are less than the current time result in\n                the function being called at the next opportunity.\n\n        Returns:\n            typing.Any: An opaque identifier that represents the callback\n                uniquely within the processor. This identifier is used to\n                modify the callback scheduling.\n\n        Note:\n            The time given should not be considered absolute. It represents\n            the time when the callback becomes available to execute. It may\n            be much later than the given time value when the function actually\n            executes depending on the implementation.\n        \"\"\"\n        raise NotImplementedError()", "response": "Defer the execution of a function until some clock value."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef defer_for(\n            self,\n            wait: typing.Union[int, float],\n            func: typing.Callable[[], typing.Any],\n    ) -> typing.Any:\n        \"\"\"Defer the execution of a function for some number of seconds.\n\n        Args:\n            wait (typing.Union[int, float]): A numeric value that represents\n                the number of seconds that must pass before the callback\n                becomes available for execution. All given values must be\n                positive.\n            func (typing.Callable[[], typing.Any]): A callable that accepts no\n                arguments. All return values are ignored.\n\n        Returns:\n            typing.Any: An opaque identifier that represents the callback\n                uniquely within the processor. This identifier is used to\n                modify the callback scheduling.\n        \"\"\"\n        raise NotImplementedError()", "response": "Defer the execution of a function for some number of seconds."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef delay(\n            self,\n            identifier: typing.Any,\n            until: typing.Union[int, float]=-1,\n    ) -> bool:\n        \"\"\"Delay a deferred function until the given time.\n\n        Args:\n            identifier (typing.Any): The identifier returned from a call\n                to defer or defer_for.\n            until (typing.Union[int, float]): A numeric value that represents\n                the clock time when the callback becomes available for\n                execution. Values that are less than the current time result in\n                the function being called at the next opportunity.\n\n        Returns:\n            bool: True if the call is delayed. False if the identifier is\n                invalid or if the deferred call is already executed.\n        \"\"\"\n        raise NotImplementedError()", "response": "Delay a deferred function until the given time."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef delay_for(\n            self,\n            wait: typing.Union[int, float],\n            identifier: typing.Any,\n    ) -> bool:\n        \"\"\"Defer the execution of a function for some number of seconds.\n\n        Args:\n            wait (typing.Union[int, float]): A numeric value that represents\n                the number of seconds that must pass before the callback\n                becomes available for execution. All given values must be\n                positive.\n            identifier (typing.Any): The identifier returned from a call\n                to defer or defer_for.\n\n        Returns:\n            bool: True if the call is delayed. False if the identifier is\n                invalid or if the deferred call is already executed.\n        \"\"\"\n        raise NotImplementedError()", "response": "Defer the execution of a function for some number of seconds."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsending an email to the specified to.", "response": "def send_email(self, to):\n        \"\"\"\n        Do work.\n        \"\"\"\n        body = self.body()\n        subject = self.subject()\n\n        import letter\n\n        class Message(letter.Letter):\n            Postie = letter.DjangoPostman()\n\n            From    = getattr(settings, 'DEFAULT_FROM_EMAIL', 'contact@example.com')\n            To      = to\n            Subject = subject\n            Body    = body\n\n        if hasattr(self, 'reply_to'):\n            Message.ReplyTo = self.reply_to()\n\n        Message.send()\n        return"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nsend email to the to_addr if the form is valid.", "response": "def form_valid(self, form):\n        \"\"\"\n        Praise be, someone has spammed us.\n        \"\"\"\n        form.send_email(to=self.to_addr)\n        return super(EmailView, self).form_valid(form)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef register_model(self, model_cls):\n        if not getattr(model_cls, '_database_'):\n            raise ModelAttributeError('_database_ missing '\n                                      'on %s!' % model_cls.__name__)\n        if not getattr(model_cls, '_collection_'):\n            raise ModelAttributeError('_collection_ missing '\n                                      'on %s!' % model_cls.__name__)\n\n        model_cls._mongo_client_ = self.client\n\n        logging.info('Registering Model ' + model_cls.__name__)\n        return model_cls", "response": "Decorator for registering model."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef enable_counter(self, base=None, database='counter',\n                       collection='counters'):\n        \"\"\"Register the builtin counter model, return the registered Counter\n        class and the corresponding ``CounterMixin`` class.\n\n        The ``CounterMixin`` automatically increases and decreases the counter\n        after model creation(save without ``_id``) and deletion.\n\n        It contains a classmethod ``count()`` which returns the current count\n        of the model collection.\"\"\"\n        Counter._database_ = database\n        Counter._collection_ = collection\n        bases = (base, Counter) if base else (Counter,)\n        counter = self.register_model(type('Counter', bases, {}))\n\n        class CounterMixin(object):\n            \"\"\"Mixin class for model\"\"\"\n            @classmethod\n            def inc_counter(cls):\n                \"\"\"Wrapper for ``Counter.increase()``.\"\"\"\n                return counter.increase(cls._collection_)\n\n            @classmethod\n            def dec_counter(cls):\n                \"\"\"Wrapper for ``Counter.decrease()``.\"\"\"\n                return counter.decrease(cls._collection_)\n\n            @classmethod\n            def chg_counter(cls, *args, **kwargs):\n                \"\"\"Wrapper for ``Counter.change_by()``.\"\"\"\n                return counter.change_by(cls._collection_, *args, **kwargs)\n\n            @classmethod\n            def set_counter(cls, *args, **kwargs):\n                \"\"\"Wrapper for ``Counter.set_to()``.\"\"\"\n                return counter.set_to(cls._collection_, *args, **kwargs)\n\n            def on_save(self, old_dict):\n                super(CounterMixin, self).on_save(old_dict)\n                if not old_dict.get('_id'):\n                    counter.increase(self._collection_)\n\n            def on_delete(self, *args, **kwargs):\n                super(CounterMixin, self).on_delete(*args, **kwargs)\n                counter.decrease(self._collection_)\n\n            @classmethod\n            def count(cls):\n                \"\"\"Return the current count of this collection.\"\"\"\n                return counter.count(cls._collection_)\n\n        logging.info('Counter enabled on: %s' % counter.collection)\n        return counter, CounterMixin", "response": "Enable the builtin Counter model."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nfind a model object by its ObjectId oid can be string or ObjectId", "response": "def by_id(cls, oid):\n        \"\"\"Find a model object by its ``ObjectId``,\n        ``oid`` can be string or ObjectId\"\"\"\n        if oid:\n            d = cls.collection.find_one(ObjectId(oid))\n            if d:\n                return cls(**d)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef from_dict(cls, d):\n        warnings.warn(\n            'from_dict is deprecated and will be removed in v1.0!',\n            stacklevel=2)\n        d = d or {}\n        return cls(**d)", "response": "Build a new object from a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef find(cls, *args, **kwargs):\n        return cls.from_cursor(cls.collection.find(*args, **kwargs))", "response": "Same as collection. find returns model object instead of dict."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef find_one(cls, *args, **kwargs):\n        d = cls.collection.find_one(*args, **kwargs)\n        if d:\n            return cls(**d)", "response": "Same as collection. find_one returns model object instead of\n            dict."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef reload(self, d=None):\n        if d:\n            self.clear()\n            self.update(d)\n        elif self.id:\n            new_dict = self.by_id(self._id)\n            self.clear()\n            self.update(new_dict)\n        else:\n            # should I raise an exception here?\n            # Like \"Model must be saved first.\"\n            pass", "response": "Reload model from given dict or database."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsaves model object to database.", "response": "def save(self):\n        \"\"\"Save model object to database.\"\"\"\n        d = dict(self)\n        old_dict = d.copy()\n        _id = self.collection.save(d)\n        self._id = _id\n        self.on_save(old_dict)\n        return self._id"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_to(cls, name, num):\n        if num < 0:\n            raise CounterValueError('Counter[%s] can not be set to %s' % (\n                                    name, num))\n        else:\n            counter = cls.collection.find_and_modify(\n                {'name': name},\n                {'$set': {'seq': num}},\n                new=True,\n                upsert=True\n            )\n            return counter['seq']", "response": "Set counter of name to num."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef change_by(cls, name, num):\n        count = cls.count(name)\n        if count + num < 0:\n            raise CounterValueError('Counter[%s] will be negative '\n                                    'after %+d.' % (name, num))\n\n        counter = cls.collection.find_and_modify(\n            {'name': name},\n            {'$inc': {'seq': num}},\n            new=True,\n            upsert=True\n        )\n        return counter['seq']", "response": "Change counter of name by num."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef count(cls, name):\n        counter = cls.collection.find_one({'name': name}) or {}\n        return counter.get('seq', 0)", "response": "Return the count of name"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef geo_filter(d):\n    page = d[\"page\"]\n    if not \"revision\" in page:\n        return None\n    title = page[\"title\"]\n    if skip_article(title):\n        LOG.info(\"Skipping low-value article %s\", title)\n        return None\n    text = page[\"revision\"][\"text\"]\n    if not utils.is_str_type(text):\n        if \"#text\" in text:\n            text = text[\"#text\"]\n        else:\n            return None\n    LOG.debug(\"--------------------------------------------------------------\")\n    LOG.debug(title)\n    LOG.debug(\"--------------------------------------------------------------\")\n    LOG.debug(text)\n    c = find_geo_coords(text)\n    u = wikip_url(title)\n    \"\"\"\n    m = hashlib.md5()\n    m.update(u.encode(\"UTF-8\") if hasattr(u, 'encode') else u)\n    i = base64.urlsafe_b64encode(m.digest()).replace('=', '')\n    \"\"\"\n    return {\n        #\"id\": i,\n        \"title\": title,\n        \"url\": u,\n        \"coords\": c,\n        \"updated\": page[\"revision\"].get(\"timestamp\")\n    } if c else None", "response": "Inspects the given Wikipedia article dict for geo - coordinates."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a list of lat lon coordinates found by scanning the given text.", "response": "def find_geo_coords(s):\n    \"\"\"Returns a list of lat/lons found by scanning the given text\"\"\"\n    coords = []\n    LOG.debug(\"Matching in text size %s\", len(s))\n    for c in INFO_BOX_LAT_LON.findall(s):\n        try:\n            coord = (float(c[1]), float(c[2]))  #, c[0])\n            coords.append(coord)\n            LOG.debug(\"Found info box lat/lon: %s\", coord)\n        except Exception as ex:\n            LOG.warn(\"Bad parse of info box %s: %s\", c, ex)\n    for c in COORDS_GEN.findall(s):\n        # Special cases\n        if skip_coords(c):\n            LOG.debug(\"Ignorning coords %s\", c)\n            continue\n        m = COORDS_GROUPS.search(c)\n        if not m:\n            LOG.warn(\"Unrecognized coord format: %s\", c)\n            continue\n        try:\n            # Remove empty optional groups and remove pipes from matches\n            g = [(s[0:-1] if s[-1] == '|' else s) for s in list(m.groups()) if s is not None and len(s)]\n            #LOG.info(\"Found groups: %s\", g)\n            if len(g) == 1: # Single lat|lon\n                lat, lon = g[0].split('|')\n                coord = (float(lat), float(lon))  #, c)\n                coords.append(coord)\n                LOG.debug(\"Found lat|lon: %s\", coord)\n            elif g[3] == 'E' or g[3] == 'W':\n                lat = depipe(g[0]) * (1 if g[1].upper() == 'N' else -1)\n                lon = depipe(g[2]) * (1 if g[3].upper() == 'E' else -1)\n                coord = (lat, lon)  #, c)\n                coords.append(coord)\n                LOG.debug(\"Found lat|NS|lon|EW: %s\", coord)\n            else:\n                LOG.warn(\"Unrecognized coord format: %s (parsed %s)\", c, g)\n        except Exception as ex:\n            LOG.warn(\"Bad parse of %s: %s\", c, ex)\n    l = []\n    for c in set(coords):  # Dedupe; the reality is non-trivial though...we want to keep only the most precise\n        if c[0] > 90 or c[0] < -90 or c[1] > 180 or c[1] < -180 or (c[0] == 0 and c[1] == 0):\n            LOG.warn(\"Invalid lat or lon: %s\", c)\n        else:\n            l.append({\"type\": \"Point\", \"coordinates\": (c[1], c[0])})  # GeoJSON, lon goes first\n    return l"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef depipe(s):\n    n = 0\n    for i in reversed(s.split('|')):\n        n = n / 60.0 + float(i)\n    return n", "response": "Convert a string of the form DD MM or SS to decimal degrees"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef skip_coords(c):\n    if c == \"{{coord|LAT|LONG|display=inline,title}}\": # Unpopulated coord template\n        return True\n    if c.find(\"globe:\") >= 0 and c.find(\"globe:earth\") == -1: # Moon, venus, etc.\n        return True\n    return False", "response": "Skip coordinate strings that are not valid"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef iter_output(self, pause=0.05):\n        with self.stream as temp:\n            for chunk in self.iter_output_for_stream(temp, pause=pause):\n                yield chunk", "response": "Yields the output of the command line."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the current progress for this task.", "response": "def set_progress(self, progress):\n        \"\"\"\n        Defines the current progress for this progress bar in iteration units (not percent).\n        :param progress:    Current progress in iteration units regarding its total (not percent).\n        :return:            True if the progress has changed. If the given progress is higher than the total or lower\n                            than 0 then it will be ignored.\n        \"\"\"\n        _progress = progress\n        if _progress > self.total:\n            _progress = self.total\n        elif _progress < 0:\n            _progress = 0\n\n        # Stop task chrono if needed\n        if _progress == self.total and self.display_time:\n            self.end_time = time.time() * 1000\n\n            # If the task has completed instantly then define its begin_time too\n            if not self.begin_time:\n                self.begin_time = self.end_time\n\n        has_changed = self.progress != _progress\n\n        if has_changed:\n            self.progress = _progress\n\n        return has_changed"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef terminate(self):\n        self.queue.put(dill.dumps(ExitCommand()))\n\n        if self.process:\n            self.process.join()", "response": "Tells the logger process to exit immediately."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndefine the current configuration of the logger. Can be used at any moment during runtime to modify the logger behavior. :param message_number: [Optional] Number of simultaneously displayed messages below progress bars. :param exception_number: [Optional] Number of simultaneously displayed exceptions below messages. :param permanent_progressbar_slots: [Optional] The amount of vertical space (bar slots) to keep at all times, so the message logger will not move anymore if the bar number is equal or lower than this parameter. :param redraw_frequency_millis: [Optional] Minimum time lapse in milliseconds between two redraws. It may be more because the redraw rate depends upon time AND method calls. :param console_level: [Optional] The logging level (from standard logging module). :param task_millis_to_removal: [Optional] Minimum time lapse in milliseconds at maximum completion before a progress bar is removed from display. The progress bar may vanish at a further time as the redraw rate depends upon time AND method calls. :param console_format_strftime: [Optional] Specify the time format for console log lines using python strftime format. Defaults to format: '29 november 2016 21:52:12'. :param console_format: [Optional] Specify the format of the console log lines. There are two variables available: {T} for timestamp, {L} for level. Will then add some tabulations in order to align text beginning for all levels. Defaults to format: '{T} [{L}]' Which will produce: '29 november 2016 21:52:12 [INFO] my log text' '29 november 2016 21:52:13 [WARNING] my log text' '29 november 2016 21:52:14 [DEBUG] my log text' :param file_handlers: [Optional] Specify the file handlers to use. Each file handler will use its own regular formatter and level. Console logging is distinct from file logging. Console logging uses custom stdout formatting, while file logging uses regular python logging rules. All handlers are permitted except StreamHandler if used with stdout or stderr which are reserved by this library for custom console output.", "response": "def set_configuration(self,\n                          message_number=default_message_number,\n                          exception_number=default_exception_number,\n                          permanent_progressbar_slots=default_permanent_progressbar_slots,\n                          redraw_frequency_millis=default_redraw_frequency_millis,\n                          console_level=default_level,\n                          task_millis_to_removal=default_task_millis_to_removal,\n                          console_format_strftime=default_console_format_strftime,\n                          console_format=default_console_format,\n                          file_handlers=default_file_handlers):\n        \"\"\"\n        Defines the current configuration of the logger. Can be used at any moment during runtime to modify the logger\n        behavior.\n        :param message_number:              [Optional] Number of simultaneously displayed messages below progress bars.\n        :param exception_number:            [Optional] Number of simultaneously displayed exceptions below messages.\n        :param permanent_progressbar_slots: [Optional] The amount of vertical space (bar slots) to keep at all times,\n                                            so the message logger will not move anymore if the bar number is equal or\n                                            lower than this parameter.\n        :param redraw_frequency_millis:     [Optional] Minimum time lapse in milliseconds between two redraws. It may be\n                                            more because the redraw rate depends upon time AND method calls.\n        :param console_level:               [Optional] The logging level (from standard logging module).\n        :param task_millis_to_removal:      [Optional] Minimum time lapse in milliseconds at maximum completion before\n                                            a progress bar is removed from display. The progress bar may vanish at a\n                                            further time as the redraw rate depends upon time AND method calls.\n        :param console_format_strftime:     [Optional] Specify the time format for console log lines using python\n                                            strftime format. Defaults to format: '29 november 2016 21:52:12'.\n        :param console_format:              [Optional] Specify the format of the console log lines. There are two\n                                            variables available: {T} for timestamp, {L} for level. Will then add some\n                                            tabulations in order to align text beginning for all levels.\n                                            Defaults to format: '{T} [{L}]'\n                                            Which will produce: '29 november 2016 21:52:12 [INFO]      my log text'\n                                                                '29 november 2016 21:52:13 [WARNING]   my log text'\n                                                                '29 november 2016 21:52:14 [DEBUG]     my log text'\n        :param file_handlers:               [Optional] Specify the file handlers to use. Each file handler will use its\n                                            own regular formatter and level. Console logging is distinct from file\n                                            logging. Console logging uses custom stdout formatting, while file logging\n                                            uses regular python logging rules. All handlers are permitted except\n                                            StreamHandler if used with stdout or stderr which are reserved by this\n                                            library for custom console output.\n        \"\"\"\n        self.queue.put(dill.dumps(SetConfigurationCommand(task_millis_to_removal=task_millis_to_removal,\n                                                          console_level=console_level,\n                                                          permanent_progressbar_slots=permanent_progressbar_slots,\n                                                          message_number=message_number,\n                                                          exception_number=exception_number,\n                                                          redraw_frequency_millis=redraw_frequency_millis,\n                                                          console_format_strftime=console_format_strftime,\n                                                          console_format=console_format,\n                                                          file_handlers=file_handlers)))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_level(self,\n                  level,\n                  console_only=False):\n        \"\"\"\n        Defines the logging level (from standard logging module) for log messages.\n        :param level:           Level of logging for the file logger.\n        :param console_only:    [Optional] If True then the file logger will not be affected.\n        \"\"\"\n        self.queue.put(dill.dumps(SetLevelCommand(level=level,\n                                                  console_only=console_only)))", "response": "Sets the logging level for the log messages."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_task_object(self,\n                        task_id,\n                        task_progress_object):\n        \"\"\"\n        Defines a new progress bar with the given information using a TaskProgress object.\n        :param task_id:                 Unique identifier for this progress bar. Will erase if already existing.\n        :param task_progress_object:    TaskProgress object holding the progress bar information.\n        \"\"\"\n        self.set_task(task_id=task_id,\n                      total=task_progress_object.total,\n                      prefix=task_progress_object.prefix,\n                      suffix=task_progress_object.suffix,\n                      decimals=task_progress_object.decimals,\n                      bar_length=task_progress_object.bar_length,\n                      keep_alive=task_progress_object.keep_alive,\n                      display_time=task_progress_object.display_time)", "response": "This method is used to set a new TaskProgress object for the given task_id."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndefining a new task in the queue.", "response": "def set_task(self,\n                 task_id,\n                 total,\n                 prefix,\n                 suffix='',\n                 decimals=0,\n                 bar_length=60,\n                 keep_alive=False,\n                 display_time=False):\n        \"\"\"\n        Defines a new progress bar with the given information.\n        :param task_id:         Unique identifier for this progress bar. Will erase if already existing.\n        :param total:           The total number of iteration for this progress bar.\n        :param prefix:          The text that should be displayed at the left side of the progress bar. Note that\n                                progress bars will always stay left-aligned at the shortest possible.\n        :param suffix:          [Optional] The text that should be displayed at the very right side of the progress bar.\n        :param decimals:        [Optional] The number of decimals to display for the percentage.\n        :param bar_length:      [Optional] The graphical bar size displayed on screen. Unit is character.\n        :param keep_alive:      [Optional] Specify whether the progress bar should stay displayed forever once completed\n                                or if it should vanish.\n        :param display_time:    [Optional] Specify whether the duration since the progress has begun should be\n                                displayed. Running time will be displayed between parenthesis, whereas it will be\n                                displayed between brackets when the progress has completed.\n        \"\"\"\n        self.queue.put(dill.dumps(NewTaskCommand(task_id=task_id,\n                                                 task=TaskProgress(total,\n                                                                   prefix,\n                                                                   suffix,\n                                                                   decimals,\n                                                                   bar_length,\n                                                                   keep_alive,\n                                                                   display_time))))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nupdating the current state of a given task.", "response": "def update(self,\n               task_id,\n               progress):\n        \"\"\"\n        Defines the current progress for this progress bar id in iteration units (not percent).\n        If the given id does not exist or the given progress is identical to the current, then does nothing.\n        Logger uses a redraw rate because of console flickering. That means it will not draw new messages or progress\n        at the very time they are being logged but their timestamp will be captured at the right time. Logger will\n        redraw at a given time period AND when new messages or progress are logged. If you still want to force redraw\n        immediately (may produce flickering) then call 'flush' method.\n        :param task_id:     Unique identifier for this progress bar. Will erase if already existing.\n        :param progress:    Current progress in iteration units regarding its total (not percent).\n        \"\"\"\n        self.queue.put(dill.dumps(UpdateProgressCommand(task_id=task_id,\n                                                        progress=progress)))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef debug(self, text):\n        self.queue.put(dill.dumps(LogMessageCommand(text=text, level=logging.DEBUG)))", "response": "Logs a debug message to the log queue."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nlog text into file and console handlers.", "response": "def info(self, text):\n        \"\"\"\n        Posts an info message adding a timestamp and logging level to it for both file and console handlers.\n        Logger uses a redraw rate because of console flickering. That means it will not draw new messages or progress\n        at the very time they are being logged but their timestamp will be captured at the right time. Logger will\n        redraw at a given time period AND when new messages or progress are logged. If you still want to force redraw\n        immediately (may produce flickering) then call 'flush' method.\n        :param text: The text to log into file and console.\n        \"\"\"\n        self.queue.put(dill.dumps(LogMessageCommand(text=text, level=logging.INFO)))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef warning(self, text):\n        self.queue.put(dill.dumps(LogMessageCommand(text=text, level=logging.WARNING)))", "response": "Logs a warning message to the log queue."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nlogs an error message to the log queue.", "response": "def error(self, text):\n        \"\"\"\n        Posts an error message adding a timestamp and logging level to it for both file and console handlers.\n        Logger uses a redraw rate because of console flickering. That means it will not draw new messages or progress\n        at the very time they are being logged but their timestamp will be captured at the right time. Logger will\n        redraw at a given time period AND when new messages or progress are logged. If you still want to force redraw\n        immediately (may produce flickering) then call 'flush' method.\n        :param text: The text to log into file and console.\n        \"\"\"\n        self.queue.put(dill.dumps(LogMessageCommand(text=text, level=logging.ERROR)))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nlog a critical message to the log queue.", "response": "def critical(self, text):\n        \"\"\"\n        Posts a critical message adding a timestamp and logging level to it for both file and console handlers.\n        Logger uses a redraw rate because of console flickering. That means it will not draw new messages or progress\n        at the very time they are being logged but their timestamp will be captured at the right time. Logger will\n        redraw at a given time period AND when new messages or progress are logged. If you still want to force redraw\n        immediately (may produce flickering) then call 'flush' method.\n        :param text: The text to log into file and console.\n        \"\"\"\n        self.queue.put(dill.dumps(LogMessageCommand(text=text, level=logging.CRITICAL)))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef throw(self, stacktrace, process_title=None):\n        self.queue.put(dill.dumps(StacktraceCommand(pid=os.getpid(),\n                                                    stacktrace=stacktrace,\n                                                    process_title=process_title)))", "response": "Sends an exception to the logger so it can be displayed in console refresh cycles from the processes."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef progress(self,\n                 enumerable,\n                 task_progress_object=None):\n        \"\"\"\n        Enables the object to be used as an iterator. Each iteration will produce a progress update in the logger.\n        :param enumerable:              Collection to iterate over.\n        :param task_progress_object:    [Optional] TaskProgress object holding the progress bar information.\n        :return:                        The logger instance.\n        \"\"\"\n        self.list = enumerable\n        self.list_length = len(enumerable)\n        self.task_id = uuid.uuid4()\n        self.index = 0\n\n        if task_progress_object:\n            # Force total attribute\n            task_progress_object.total = self.list_length\n        else:\n            task_progress_object = TaskProgress(total=self.list_length,\n                                                display_time=True,\n                                                prefix='Progress')\n\n        # Create a task progress\n        self.set_task_object(task_id=self.task_id,\n                             task_progress_object=task_progress_object)\n\n        return self", "response": "Creates a new TaskProgress object for the specified enumerable and task_progress_object."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef dump(self) -> dict:\n        d = {}\n        for item in self.__dict__:\n            if item in ['parsed', 'dump', 'parse_data', 'iter_list', 'safe_load']:\n                continue\n            if isinstance(self.__dict__[item], ConfigKey):\n                d[item] = self.__dict__[item].dump()\n            elif isinstance(self.__dict__[item], list):\n                d[item] = self.iter_list_dump(self.__dict__[item])\n            else:\n                d[item] = self.__dict__[item]\n        return d", "response": "Dumps the data from the ConfigKey into a dict."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nload the ConfigKey from a dict or list of key - value pairs into this object.", "response": "def load_from_dict(self, data: dict, overwrite: bool=True):\n        \"\"\"\n        Loads key/values from dicts or list into the ConfigKey.\n        :param data: The data object to load.\n                        This can be a dict, or a list of key/value tuples.\n        :param overwrite: Should the ConfigKey overwrite data already in it?\n        \"\"\"\n        if data is None or data == {}:\n            return False\n        # Loop over items\n        if isinstance(data, list) or isinstance(data, tuple):\n            # Pick a random item from the tuple.\n            if len(data[0]) != 2:\n                raise exc.LoaderException(\"Cannot load data with length {}\".format(len(data[0])))\n            items = data\n        elif isinstance(data, dict) or isinstance(data, self.__class__):\n            items = data.items()\n        else:\n            raise exc.LoaderException(\"Cannot load data of type {}\".format(type(data)))\n        for key, item in items:\n            assert isinstance(key, str)\n            if hasattr(self, key) and not overwrite:\n                # Refuse to overwrite existing data.\n                continue\n            # Check name to verify it's safe.\n            if self.safe_load:\n                if key.startswith(\"__\") or key in ['dump', 'items', 'keys', 'values',\n                                                   'iter_list', 'load_from_dict', 'iter_list_dump',\n                                                   'parsed', 'safe_load']:\n                    # It's evil!\n                    key = \"unsafe_\" + key\n            if '.' in key:\n                # Doubly evil!\n                key = key.replace('.', '_')\n            if isinstance(item, dict):\n                # Create a new ConfigKey object with the dict.\n                ncfg = ConfigKey()\n                # Parse the data.\n                ncfg.load_from_dict(item)\n                # Set our new ConfigKey as an attribute of ourselves.\n                setattr(self, key, ncfg)\n            elif isinstance(item, list):\n                # Iterate over the list, creating ConfigKey items as appropriate.\n                nlst = self.iter_list(item)\n                # Set our new list as an attribute of ourselves.\n                setattr(self, key, nlst)\n            else:\n                # Set the item as an attribute of ourselves.\n                setattr(self, key, item)\n        # Flip the parsed flag,\n        self.parsed = True"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef generate_mail(self):\n\n        # Script info\n        msg = \"Script info : \\r\\n\"\n        msg = msg + \"%-9s: %s\" % ('Script', SOURCEDIR) + \"\\r\\n\"\n        msg = msg + \"%-9s: %s\" % ('User', USER) + \"\\r\\n\"\n        msg = msg + \"%-9s: %s\" % ('Host', HOST) + \"\\r\\n\"\n        msg = msg + \"%-9s: %s\" % ('PID', PID) + \"\\r\\n\"\n\n        # Current trace\n        msg = msg + \"\\r\\nCurrent trace : \\r\\n\"\n        for record in self.current_buffer:\n            msg = msg + record + \"\\r\\n\"\n\n        # Now add stack trace\n        msg = msg + \"\\r\\nFull trace : \\r\\n\"\n        for record in self.complete_buffer:\n            msg = msg + record + \"\\r\\n\"\n\n        # Dump ENV\n        msg = msg + \"\\r\\nEnvironment:\" + \"\\r\\n\"\n        environ = OrderedDict(sorted(os.environ.items()))\n        for name, value in environ.items():\n            msg = msg + \"%-10s = %s\\r\\n\" % (name, value)\n\n        if USE_MIME:\n            real_msg = MIMEText(msg, _charset='utf-8')\n\n            real_msg['Subject'] = self.get_subject()\n            real_msg['To'] = ','.join(self.toaddrs)\n            real_msg['From'] = self.fromaddr\n\n        else:\n            real_msg = EmailMessage()\n\n            real_msg['Subject'] = self.get_subject()\n            real_msg['To'] = ','.join(self.toaddrs)\n            real_msg['From'] = self.fromaddr\n\n            real_msg.set_content(msg)\n\n        return real_msg", "response": "Generate the email as MIMEText or EmailMessage"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef format_query_result(self, query_result, query_path, return_type=list, preceding_depth=None):\n        if type(query_result) != return_type:\n            converted_result = self.format_with_handler(query_result, return_type)\n        else:\n            converted_result = query_result\n\n        converted_result = self.add_preceding_dict(converted_result, query_path, preceding_depth)\n        return converted_result", "response": "Formats the query result based on the return type requested."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef format_with_handler(self, query_result, return_type):\n        handler = self.get_handler(type(query_result), return_type)\n        return handler.format_result(query_result)", "response": "Formats the query result to the desired return type"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_handler(query_result_type, return_type):\n        try:\n            return FormatterRegistry.get_by_take_and_return_type(query_result_type, return_type)\n        except (IndexError, AttributeError, KeyError):\n            raise IndexError(\n                'Could not find function in conversion list for input type %s and return type %s' % (\n                query_result_type, return_type))", "response": "Find the appropriate handler to convert the query result to the desired return type"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add_preceding_dict(config_entry, query_path, preceding_depth):\n        if preceding_depth is None:\n            return config_entry\n\n        preceding_dict = {query_path[-1]: config_entry}\n        path_length_minus_query_pos = len(query_path) - 1\n        preceding_depth = path_length_minus_query_pos - preceding_depth if preceding_depth != -1 else 0\n\n        for index in reversed(range(preceding_depth, path_length_minus_query_pos)):\n            preceding_dict = {query_path[index]: preceding_dict}\n\n        return preceding_dict", "response": "Adds the preceeding config keys to the config_entry to simulate the original full path to the config entry"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef resolve_config_file_path(self, config_filepath):\n        search_paths = [config_filepath,\n                        os.path.normpath(os.path.join(os.getcwd(), config_filepath)),\n                        os.path.normpath(os.path.join(os.path.dirname(os.path.abspath(__file__)), config_filepath))]\n\n        for search_path in search_paths:\n            try:\n                self.validate_config_file(search_path)\n                return search_path\n            except (IOError, OSError):\n                pass\n\n        raise errors.SourceError(\n            'No config file found in current working directory or nomenclate/core and %s is not a valid YAML file')", "response": "Resolves the given config file path to the config file that is available in the current working directory and nomenclate and core."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef rebuild_config_cache(self, config_filepath):\n        self.validate_config_file(config_filepath)\n        config_data = None\n        try:\n            with open(config_filepath, 'r') as f:\n                config_data = yaml.load(f)\n            items = list(iteritems(config_data))\n\n        except AttributeError:\n            items = list(config_data)\n\n        self.config_file_contents = OrderedDict(sorted(items, key=lambda x: x[0], reverse=True))\n        self.config_filepath = config_filepath", "response": "Loads from file and caches all data from the config file in the form of an OrderedDict to self. data\n\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ntraverses the list of query paths to find the data requested :param query_path: (list(str), str), list of query path branches or query string Default behavior: returns list(str) of possible config headers :param return_type: (list, str, dict, OrderedDict), desired return type for the data :param preceding_depth: int, returns a dictionary containing the data that traces back up the path for x depth -1: for the full traversal back up the path None: is default for no traversal :param throw_null_return_error: bool, whether or not to throw an error if we get an empty result but no error :return: (list, str, dict, OrderedDict), the type specified from return_type :raises: exceptions.ResourceNotFoundError: if the query path is invalid", "response": "def get(self, query_path=None, return_type=list, preceding_depth=None, throw_null_return_error=False):\n        \"\"\" Traverses the list of query paths to find the data requested\n\n        :param query_path: (list(str), str), list of query path branches or query string\n                                             Default behavior: returns list(str) of possible config headers\n        :param return_type: (list, str, dict, OrderedDict), desired return type for the data\n        :param preceding_depth: int, returns a dictionary containing the data that traces back up the path for x depth\n                                     -1: for the full traversal back up the path\n                                     None: is default for no traversal\n        :param throw_null_return_error: bool, whether or not to throw an error if we get an empty result but no error\n        :return: (list, str, dict, OrderedDict), the type specified from return_type\n        :raises: exceptions.ResourceNotFoundError: if the query path is invalid\n        \"\"\"\n        function_type_lookup = {str: self._get_path_entry_from_string,\n                                list: self._get_path_entry_from_list}\n\n        if query_path is None:\n            return self._default_config(return_type)\n\n        try:\n            config_entry = function_type_lookup.get(type(query_path), str)(query_path)\n            query_result = self.config_entry_handler.format_query_result(config_entry,\n                                                                         query_path,\n                                                                         return_type=return_type,\n                                                                         preceding_depth=preceding_depth)\n\n            return query_result\n        except IndexError:\n            return return_type()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _get_path_entry_from_string(self, query_string, first_found=True, full_path=False):\n        iter_matches = gen_dict_key_matches(query_string, self.config_file_contents, full_path=full_path)\n        try:\n            return next(iter_matches) if first_found else iter_matches\n        except (StopIteration, TypeError):\n            raise errors.ResourceNotFoundError('Could not find search string %s in the config file contents %s' %\n                                               (query_string, self.config_file_contents))", "response": "Parses a string to form a list of strings that represents a possible config entry header and returns the first found entry or the entire list of entries that match the query string."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the config entry at query path", "response": "def _get_path_entry_from_list(self, query_path):\n        \"\"\" Returns the config entry at query path\n\n        :param query_path: list(str), config header path to follow for entry\n        :return: (list, str, dict, OrderedDict), config entry requested\n        :raises: exceptions.ResourceNotFoundError\n        \"\"\"\n        cur_data = self.config_file_contents\n        try:\n            for child in query_path:\n                cur_data = cur_data[child]\n            return cur_data\n        except (AttributeError, KeyError):\n            raise errors.ResourceNotFoundError('Could not find query path %s in the config file contents' %\n                                               query_path)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _default_config(self, return_type):\n        if return_type == list:\n            return [k for k in self.config_file_contents]\n        return return_type()", "response": "Generates a default instance of the requested type"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nvalidates the filepath to the config file. Detects whether it is a true YAML file + existance", "response": "def validate_config_file(cls, config_filepath):\n        \"\"\" Validates the filepath to the config.  Detects whether it is a true YAML file + existance\n\n        :param config_filepath: str, file path to the config file to query\n        :return: None\n        :raises: IOError\n        \"\"\"\n        is_file = os.path.isfile(config_filepath)\n        if not is_file and os.path.isabs(config_filepath):\n            raise IOError('File path %s is not a valid yml, ini or cfg file or does not exist' % config_filepath)\n\n        elif is_file:\n            if os.path.getsize(config_filepath) == 0:\n                raise IOError('File %s is empty' % config_filepath)\n\n        with open(config_filepath, 'r') as f:\n            if yaml.load(f) is None:\n                raise IOError('No YAML config was found in file %s' % config_filepath)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef format_result(input):\n        items = list(iteritems(input))\n        return OrderedDict(sorted(items, key=lambda x: x[0]))", "response": "Convert a dict to a sorted OrderedDict"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef import_it(cls):\n        if not cls in cls._FEATURES:\n            try:\n                cls._FEATURES[cls] = cls._import_it()\n            except ImportError:\n                raise cls.Error(cls._import_error_message(), cls.Error.UNSATISFIED_IMPORT_REQ)\n        return cls._FEATURES[cls]", "response": "Performs the import only once."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef create_db(self, instance_name, instance_type,\n            admin_username, admin_password, security_groups=None, db_name=None,\n            storage_size_gb=DEFAULT_STORAGE_SIZE_GB,\n            timeout_s=DEFAULT_TIMEOUT_S):\n        \"\"\"\n        Creates a database instance.\n\n        This method blocks until the db instance is active, or until\n        :attr:`timeout_s` has elapsed.\n\n        By default, hpcloud *assigns* an automatically-generated set of\n        credentials for an admin user.  In addition to launching the db\n        instance, this method uses the autogenerated credentials to login to\n        the server and create the intended admin user based on the credentials\n        supplied as method arguments.\n\n        :param str instance_name:  A name to assign to the db instance.\n\n        :param str instance_type:  The server instance type (e.g. ``medium``).\n\n        :param str admin_username:  The admin username.\n\n        :param str admin_password:  The admin password.\n\n        :param security_groups:  *Not used in hpcloud*.\n\n        :param str db_name:  The database name.  If this is not specified, the\n            database will be named the same as the :attr:`instance_name`.\n\n        :param int storage_size_gb:  The size of the storage volume in GB.\n\n        :param float timeout_s:  The number of seconds to poll for an active\n            database server before failing.  This value is also used when\n            attempting to connect to the running mysql server.\n\n        :rtype:  :class:`dict`\n\n        \"\"\"\n        db = self._create_db(instance_name, instance_type,\n                storage_size_gb)\n\n        # hang on to these... hpcloud only provides a way to generate a new\n        # set of username/password - there is no way to retrieve the originals.\n        default_creds = db.credential\n        log.debug('Credentials for %s: %s' % (instance_name, default_creds))\n\n        instance = self._poll_instance_status(db, timeout_s)\n\n        # we're taking advantage of a security bug in hpcloud's dbaas security\n        # group rules.  the default *security* is to allow connections from\n        # everywhere in the world.\n        def connect():\n            try:\n                return pymysql.connect(\n                        host=instance.hostname,\n                        port=instance.port,\n                        # db=self.database,\n                        user=default_creds['username'],\n                        passwd=default_creds['password'],\n                        connect_timeout=timeout_s,\n                        )\n            except:\n                log.warn(\"Could not connect to db, %s\" % instance_name)\n                # log.debug(\"Connection exception\", exc_info=True)\n\n        log.info(\"Connecting to %s...\" % instance_name)\n        db = poll_with_timeout(timeout_s, connect, 10)\n        cur = db.cursor()\n        cur.execute(\n                \"grant all privileges on *.* \"\n                \"to '%s'@'%%' identified by '%s' \"\n                \"with grant option\"\n                % (admin_username, admin_password)\n                )\n        cur.execute(\"flush privileges\")\n        return db_to_dict(instance)", "response": "Creates a new database instance."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef authenticate(self):\n        log.info(\"Authenticating to HP Cloud...\")\n        creds = self.creds\n        access_key_id = creds.get('access_key_id', '')\n        secret_access_key = creds.get('secret_access_key', '')\n        # prefer api key + secret key, but fallback to username + password\n        if access_key_id and secret_access_key:\n            self.nova_client.client.os_access_key_id = access_key_id\n            self.nova_client.client.os_secret_key = secret_access_key\n        self.nova_client.authenticate()", "response": "Authenticate against the HP Cloud Identity Service."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef read(author, kind):\n\n    if not os.path.exists(CACHE_PATH):\n        raise LicenseError('No cache found. You must '\n                           'supply at least -a and -k.')\n\n    cache = read_cache()\n\n    if author is None:\n        author = read_author(cache)\n    if kind is None:\n        kind = read_kind(cache)\n\n    return author, kind", "response": "Reads the cache and returns the author and kind."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef auto_load_app_modules(self, modules):\n        for app in apps.get_app_configs():\n            for module in modules:\n                try:\n                    import_module('{}.{}'.format(app.module.__package__, module))\n                except ImportError:\n                    pass", "response": "Auto load app modules"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nbumping the version of the current version", "response": "def bump(match):\n\t\"\"\"Bumps the version\"\"\"\n\tbefore, old_version, after = match.groups()\n\tmajor, minor, patch = map(int, old_version.split('.'))\n\tpatch += 1\n\tif patch == 10:\n\t\tpatch = 0\n\t\tminor += 1\n\t\tif minor == 10:\n\t\t\tminor = 0\n\t\t\tmajor += 1\n\tnew_version = '{0}.{1}.{2}'.format(major, minor, patch)\n\n\tprint('{0} => {1}'.format(old_version, new_version))\n\n\treturn before + new_version + after"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _tiles_from_bbox(bbox, zoom_level):\n\n        if isinstance(bbox, dict):\n            point_min = Point.from_latitude_longitude(latitude=bbox['tl'], longitude=bbox['tr'])\n            point_max = Point.from_latitude_longitude(latitude=bbox['bl'], longitude=bbox['br'])\n        elif isinstance(bbox, list):\n            point_min = Point.from_latitude_longitude(latitude=bbox[1], longitude=bbox[0])\n            point_max = Point.from_latitude_longitude(latitude=bbox[3], longitude=bbox[2])\n        else:\n            raise RuntimeError(\"bbox must bei either a dict or a list\")\n        tile_min = Tile.for_point(point_min, zoom_level)\n        tile_max = Tile.for_point(point_max, zoom_level)\n        tiles = []\n        for x in range(tile_min.tms_x, tile_max.tms_x + 1):\n            for y in range(tile_min.tms_y, tile_max.tms_y + 1):\n                tiles.append(Tile.from_tms(tms_x=x, tms_y=y, zoom=zoom_level))\n        return tiles", "response": "Returns all tiles in the specified bounding box."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nupdates the mask with the polygons in the given list of polygons.", "response": "def _update_mask(self, mask: np.ndarray, polygons: Iterable, separate_instances: bool = False) -> None:\n        \"\"\"\n         * The first polygon is the exterior ring. All others are treated as interior rings and will just invert\n           the corresponding area of the mask.\n        :param separate_instances:\n        :param mask:\n        :param polygons:\n        :return:\n        \"\"\"\n        for i, p in enumerate(polygons):\n            if isinstance(p, geometry.MultiPolygon):\n                self._update_mask(mask=mask, polygons=p.geoms, separate_instances=True)\n                continue\n            elif not isinstance(p, geometry.Polygon):\n                continue\n            poly_area = Image.fromarray(np.zeros(mask.shape, dtype=np.uint8))\n            holes = Image.fromarray(np.zeros(mask.shape, dtype=np.uint8))\n            outline_color = 0 if separate_instances else 255\n            ImageDraw.Draw(poly_area).polygon(p.exterior.coords, fill=255, outline=outline_color)\n            for h in p.interiors:\n                ImageDraw.Draw(holes).polygon(h.coords, fill=255, outline=255)\n            mask[np.nonzero(np.array(poly_area, dtype=np.uint8))] = 255\n            mask[np.nonzero(np.array(holes, dtype=np.uint8))] = 0"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nwrite all the specified args as styled commands m to the handle", "response": "def set_raw(self, *args):\n        \"\"\"\n        writes all *args as styled commands 'm' to the handle\n        \"\"\"\n        if not self.enabled: return\n        args = map(lambda x: str(x), [x for x in args if x is not None])\n        self._write_raw(';'.join(args) + 'm')"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _write_raw(self, suffix):\n        if not self.enabled: return\n\n        self.buffer.write(CSI)\n        self.buffer.write(suffix)", "response": "Writes a the prefix by the CSI to the handle\n       "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef build_bot(config_file=None):\n    \n    from . import bot\n\n    config = ConfigParser(interpolation=None)\n    if config_file is None:\n        config.read_string(default_config)\n    elif isinstance(config_file, ConfigParser):\n        config = config_file\n    else:\n        config.read(config_file)\n    \n    # shorter names\n    db_conf = config['database']\n    conn_conf = config['connection']\n    client_conf = config['client']\n    log_conf = config['logging']\n    verbosity = config['debug']['verbosity'].lower() or 'notset'\n    debug_file = config['debug']['file'] or None\n    # add more as they're used\n\n    if db_conf.getboolean('use_db'):\n        db = DAL(db_conf['db_string'])\n        build_db_tables(db)\n        log_file = None\n        log_fmts = {}\n    else:\n        db = None\n        log_file = log_conf.pop('file')\n        log_fmts = dict(log_conf)\n        \n    # debug logging\n    debug_lvls = {'notset': 0,\n                  'debug': 10,\n                  'info': 20,\n                  'warning': 30,\n                  'error': 40,\n                  'critical': 50,\n                  }\n    lvl = int(debug_lvls[verbosity])\n    \n    seshetbot = bot.SeshetBot(client_conf['nickname'], db, debug_file, lvl)\n\n    # connection info for connect()\n    seshetbot.default_host = conn_conf['server']\n    seshetbot.default_port = int(conn_conf['port'])\n    seshetbot.default_channel = conn_conf['channels'].split(',')\n    seshetbot.default_use_ssl = conn_conf.getboolean('ssl')\n\n    # client info\n    seshetbot.user = client_conf['user']\n    seshetbot.real_name = client_conf['realname']\n\n    # logging info\n    seshetbot.log_file = log_file\n    seshetbot.log_formats = log_fmts\n    seshetbot.locale = dict(config['locale'])\n    \n    return seshetbot", "response": "Parse a config file and return a SeshetBot instance."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nbuilding a matrix of growth factors according to the CAGR formula.", "response": "def growth_coefficients(start_date, end_date, ref_date, alpha, samples):\n    \"\"\"\n    Build a matrix of growth factors according to the CAGR formula  y'=y0 (1+a)^(t'-t0).\n\n    a growth rate alpha\n    t0 start date\n    t' end date\n    y' output\n    y0 start value\n\n    \"\"\"\n\n    start_offset = 0\n    if ref_date < start_date:\n        offset_delta = rdelta.relativedelta(start_date, ref_date)\n        start_offset = offset_delta.months + 12 * offset_delta.years\n        start_date = ref_date\n\n    end_offset = 0\n    if ref_date > end_date:\n        offset_delta = rdelta.relativedelta(ref_date, end_date)\n        end_offset = offset_delta.months + 12 * offset_delta.years\n        end_date = ref_date\n\n    delta_ar = rdelta.relativedelta(ref_date, start_date)\n    ar = delta_ar.months + 12 * delta_ar.years\n    delta_br = rdelta.relativedelta(end_date, ref_date)\n    br = delta_br.months + 12 * delta_br.years\n\n    # we place the ref point on the lower interval (delta_ar + 1) but let it start from 0\n    # in turn we let the upper interval start from 1\n    g = np.fromfunction(lambda i, j: np.power(1 - alpha, np.abs(i) / 12), (ar + 1, samples), dtype=float)\n    h = np.fromfunction(lambda i, j: np.power(1 + alpha, np.abs(i + 1) / 12), (br, samples), dtype=float)\n    g = np.flipud(g)\n\n    # now join the two arrays\n    a = np.vstack((g, h))\n\n    if start_offset > 0:\n        a = a[start_offset:]\n    if end_offset > 0:\n        a = a[:-end_offset]\n\n    return a"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_mean(self, distribution_function):\n        name = self.distribution_name\n        params = self.random_function_params\n        if name == 'normal':\n            return params[0]\n        if name == 'uniform':\n            return (params[0] + params[1]) / 2.\n        if name == 'choice':\n            return params[0].mean()\n        if name == 'triangular':\n            return (params[0] + params[1] + params[2]) / 3.\n        return distribution_function().mean()", "response": "Get the mean value for a distribution function."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef generate_values(self, *args, **kwargs):\n        sample_size = kwargs.get('size', self.size)\n\n        f = self.instantiate_distribution_function(self.module_name, self.distribution_name)\n        distribution_function = partial(f, *self.random_function_params, size=sample_size)\n\n        if self.sample_mean_value:\n            sample = np.full(sample_size, self.get_mean(distribution_function))\n        else:\n            sample = distribution_function()\n\n        return sample", "response": "Generates a sample of values from a distribution function."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngenerates a random variable and apply annual growth factors.", "response": "def generate_values(self, *args, **kwargs):\n        \"\"\"\n        Instantiate a random variable and apply annual growth factors.\n\n        :return:\n        \"\"\"\n        assert 'ref value' in self.kwargs\n\n        # 1. Generate $\\mu$\n        start_date = self.times[0].to_pydatetime()\n        end_date = self.times[-1].to_pydatetime()\n        ref_date = self.ref_date\n\n        mu = self.generate_mu(end_date, ref_date, start_date)\n\n        # 3. Generate $\\sigma$\n        ## Prepare array with growth values $\\sigma$\n        if self.sample_mean_value:\n            sigma = np.zeros((len(self.times), self.size))\n        else:\n\n            if self.kwargs['type'] == 'interp':\n\n                def get_date(record):\n                    return datetime.datetime.strptime(record[0], \"%Y-%m-%d\")\n\n                ref_value_ = sorted(json.loads(self.kwargs['ref value'].strip()).items(), key=get_date)\n                intial_value = ref_value_[0][1]\n            else:\n                intial_value = self.kwargs['ref value']\n\n            variability_ = intial_value * self.kwargs['initial_value_proportional_variation']\n            logger.debug(f'sampling random distribution with parameters -{variability_}, 0, {variability_}')\n            sigma = np.random.triangular(-1 * variability_, 0, variability_,\n                                         (len(self.times), self.size))\n        ## 4. Prepare growth array for $\\alpha_{sigma}$\n        alpha_sigma = growth_coefficients(start_date,\n                                          end_date,\n                                          ref_date,\n                                          self.kwargs['ef_growth_factor'], 1)\n\n        ### 5. Prepare DataFrame\n        iterables = [self.times, range(self.size)]\n        index_names = ['time', 'samples']\n        _multi_index = pd.MultiIndex.from_product(iterables, names=index_names)\n\n        df = pd.DataFrame(index=_multi_index, dtype=float)\n\n        from dateutil import relativedelta\n        r = relativedelta.relativedelta(end_date, start_date)\n        months = r.years * 12 + r.months + 1\n        name = kwargs['name']\n        ## Apply growth to $\\sigma$ and add $\\sigma$ to $\\mu$\n        df[name] = ((sigma * alpha_sigma) + mu.reshape(months, 1)).ravel()\n\n        ## test if df has sub-zero values\n        df_sigma__dropna = df[name].where(df[name] < 0).dropna()\n        if not df_sigma__dropna.empty:\n            logger.warning(f\"Negative values for parameter {name} from {df_sigma__dropna.index[0][0]}\")\n\n        return df[name]"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding a scenario for this parameter.", "response": "def add_scenario(self, parameter: 'Parameter', scenario_name: str = default_scenario):\n        \"\"\"\n        Add a scenario for this parameter.\n\n        :param scenario_name:\n        :param parameter:\n        :return:\n        \"\"\"\n        self.scenarios[scenario_name] = parameter"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd a parameter to the parameter set.", "response": "def add_parameter(self, parameter: Parameter):\n        \"\"\"\n        A parameter can have several scenarios. They are specified as a comma-separated list in a string.\n        :param parameter:\n        :return:\n        \"\"\"\n\n        # try reading the scenarios from the function arg or from the parameter attribute\n        scenario_string = parameter.source_scenarios_string\n        if scenario_string:\n            _scenarios = [i.strip() for i in scenario_string.split(',')]\n            self.fill_missing_attributes_from_default_parameter(parameter)\n\n        else:\n            _scenarios = [ParameterScenarioSet.default_scenario]\n\n        for scenario in _scenarios:\n            parameter.scenario = scenario\n            self.parameter_sets[parameter.name][scenario] = parameter\n\n        # record all tags for this parameter\n        if parameter.tags:\n            _tags = [i.strip() for i in parameter.tags.split(',')]\n            for tag in _tags:\n                self.tags[tag][parameter.name].add(parameter)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef fill_missing_attributes_from_default_parameter(self, param):\n        if not self.exists(param.name) or not ParameterScenarioSet.default_scenario in self.parameter_sets[\n            param.name].scenarios.keys():\n            logger.warning(\n                f'No default value for param {param.name} found.')\n            return\n        default = self.parameter_sets[param.name][ParameterScenarioSet.default_scenario]\n        for att_name, att_value in default.__dict__.items():\n            if att_name in ['unit', 'label', 'comment', 'source', 'tags']:\n\n                if att_name == 'tags' and default.tags != param.tags:\n                    logger.warning(\n                        f'For param {param.name} for scenarios {param.source_scenarios_string}, tags is different from default parameter tags. Overwriting with default values.')\n                    setattr(param, att_name, att_value)\n\n                if not getattr(param, att_name):\n                    logger.debug(\n                        f'For param {param.name} for scenarios {param.source_scenarios_string}, populating attribute {att_name} with value {att_value} from default parameter.')\n\n                    setattr(param, att_name, att_value)", "response": "Fill missing attributes from default parameter."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef find_by_tag(self, tag) -> Dict[str, Set[Parameter]]:\n        return self.tags[tag]", "response": "Find all registered dicts that are registered for a given tag"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nloads variable text from rows in excel file.", "response": "def load_parameter_definitions(self, sheet_name: str = None):\n        \"\"\"\n        Load variable text from rows in excel file.\n        If no spreadsheet arg is given, all spreadsheets are loaded.\n        The first cell in the first row in a spreadsheet must contain the keyword 'variable' or the sheet is ignored.\n\n        Any cells used as titles (with no associated value) are also added to the returned dictionary. However, the\n        values associated with each header will be None. For example, given the speadsheet:\n\n        | variable | A | B |\n        |----------|---|---|\n        | Title    |   |   |\n        | Entry    | 1 | 2 |\n\n        The following list of definitions would be returned:\n\n        [ { variable: 'Title', A: None, B: None }\n        , { variable: 'Entry', A: 1   , B: 2    }\n        ]\n\n        :param sheet_name:\n        :return: list of dicts with {header col name : cell value} pairs\n        \"\"\"\n        definitions = self.excel_handler.load_definitions(sheet_name, filename=self.filename)\n        self.definition_version = self.excel_handler.version\n        return definitions"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef load_into_repo(self, repository: ParameterRepository = None, sheet_name: str = None):\n        repository.add_all(self.load_parameters(sheet_name))", "response": "Create a Repo from an excel file."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the version number of the most recent release of a particular group and artifact combination.", "response": "def get_most_recent_release(self, group, artifact, remote=False):\n        \"\"\"Get the version number of the most recent release (non-integration version)\n        of a particular group and artifact combination.\n\n        :param str group: Group of the artifact to get the version of\n        :param str artifact: Name of the artifact to get the version of\n        :param bool remote: Should remote repositories be searched to find the latest\n            version? Note this can make the request much slower. Default is false.\n        :return: Version number of the most recent release\n        :rtype: str\n        :raises requests.exceptions.HTTPError: For any non-success HTTP responses\n            from the Artifactory API.\n        \"\"\"\n        url = self._base_url + '/api/search/latestVersion'\n        params = {'g': group, 'a': artifact, 'repos': self._repo, 'remote': int(remote)}\n        self._logger.debug(\"Using latest version API at %s - params %s\", url, params)\n\n        response = self._session.get(url, params=params)\n        response.raise_for_status()\n        return response.text.strip()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget a list of the versions of the most recent release of an artifact.", "response": "def get_most_recent_versions(self, group, artifact, limit, remote=False, integration=False):\n        \"\"\"Get a list of the version numbers of the most recent artifacts (integration\n        or non-integration), ordered by the version number, for a particular group and\n        artifact combination.\n\n        :param str group: Group of the artifact to get versions of\n        :param str artifact: Name of the artifact to get versions of\n        :param int limit: Fetch only this many of the most recent releases\n        :param bool remote: Should remote repositories be searched to find the latest\n            versions? Note this can make the request much slower. Default is false.\n        :param bool integration: If true, fetch only \"integration versions\", otherwise\n            fetch only non-integration versions.\n        :return: Version numbers of the most recent artifacts\n        :rtype: list\n        :raises requests.exceptions.HTTPError: For any non-success HTTP responses\n            from the Artifactory API.\n        :raises ValueError: If limit is 0 or negative.\n        \"\"\"\n        if limit < 1:\n            raise ValueError(\"Releases limit must be positive\")\n\n        url = self._base_url + '/api/search/versions'\n        params = {'g': group, 'a': artifact, 'repos': self._repo, 'remote': int(remote)}\n        self._logger.debug(\"Using all version API at %s - params %s\", url, params)\n\n        response = self._session.get(url, params=params)\n        response.raise_for_status()\n\n        json = response.json()\n        versions = [\n            item['version'] for item in json['results'] if item['integration'] is integration]\n        # pylint: disable=no-member\n        versions.sort(key=distutils.version.LooseVersion, reverse=True)\n        return versions[:limit]"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nexecutes cmd and capture stdout and stderr", "response": "def sys_call(cmd):\n    \"\"\"Execute cmd and capture stdout and stderr\n\n    :param cmd: command to be executed\n    :return: (stdout, stderr)\n    \"\"\"\n    p = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, close_fds=True)\n    return p.stdout.readlines(), p.stderr.readlines()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nexiting execution with return code and message", "response": "def Exit(msg, code=1):\n    \"\"\"Exit execution with return code and message\n    :param msg: Message displayed prior to exit\n    :param code: code returned upon exiting\n    \"\"\"\n    print >> sys.stderr, msg\n    sys.exit(code)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef BuildReportLine(key, value, offset=None):\n    reportline = \"# \" + key.ljust(20) + \" : \"\n\n    if offset is None:\n        return reportline + str(value)\n\n    try:\n        try:\n            v=int(value)\n            return reportline + \"%*s\" % (offset, str(value))\n        except:\n            pass\n        v = float(value)\n        return reportline + \"%*s\" % (offset - 1 + len(str(value)), str(value))\n    except:\n        return reportline + \"%*s\" % (offset - 1 + len(value), value)", "response": "Builds a report line from a key value pair."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nremoving unused tokens surrounding and double underscores from the string that has had tokens replaced", "response": "def cleanup_formatted_string(cls, formatted_string):\n        \"\"\" Removes unused tokens/removes surrounding and double underscores\n\n        :param formatted_string: str, string that has had tokens replaced\n        :return: str, cleaned up name of object\n        \"\"\"\n        # Remove whitespace\n        result = formatted_string.replace(' ', '')\n        # Remove any static token parentheses\n        result = re.sub(settings.REGEX_PARENTHESIS, '', result)\n        # Remove any multiple separator characters\n        multi_character_matches = re.finditer('[%s]{2,}' % settings.SEPARATORS, result)\n        for multi_character_match in sorted(multi_character_matches, key=lambda x: len(x.group()), reverse=True):\n            match = multi_character_match.group()\n            most_common_separator = Counter(list(multi_character_match.group())).most_common(1)[0][0]\n            result = result.replace(match, most_common_separator)\n        # Remove trailing or preceding non letter characters\n        result = re.sub(settings.REGEX_ADJACENT_UNDERSCORE, '', result)\n        #  not sure what this one was...but certainly not it.\n        result = re.sub(settings.REGEX_SINGLE_PARENTHESIS, '', result)\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngiving an input string of either int or char returns what index in the alphabet and case it is", "response": "def _get_alphanumeric_index(query_string):\n        \"\"\" Given an input string of either int or char, returns what index in the alphabet and case it is\n\n        :param query_string: str, query string\n        :return: (int, str), list of the index and type\n        \"\"\"\n        # TODO: could probably rework this. it works, but it's ugly as hell.\n        try:\n            return [int(query_string), 'int']\n        except ValueError:\n            if len(query_string) == 1:\n                if query_string.isupper():\n                    return [string.ascii_uppercase.index(query_string), 'char_hi']\n                elif query_string.islower():\n                    return [string.ascii_lowercase.index(query_string), 'char_lo']\n            else:\n                raise IOError('The input is a string longer than one character')"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nunzips the source_file into destination_dir.", "response": "def unzip(source_file, destination_dir):\n    \"\"\"\n    Unzips <source_file> into <destination_dir>.\n    :param str|unicode source_file: The name of the file to read\n    :param str|unicode destination_dir: The name of the directory to write the unzipped files\n    \"\"\"\n    with zipfile.ZipFile(source_file) as zf:\n        zf.extractall(destination_dir)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nzipping the contents of path into zip_file.", "response": "def add_contents_to_zip(zip_file, path):\n    \"\"\"\n    Zip the contents of <path> into <zip_file>.\n    :param str|unicode zip_file: The file name of the zip file\n    :param str|unicode path: Full path of the directory to zip up\n    \"\"\"\n    path = path.rstrip(os.sep)\n    with zipfile.ZipFile(zip_file, 'a') as zf:\n        for root, dirs, files in os.walk(path):\n            for file in files:\n                file_path = os.path.join(root, file)\n                zf.write(file_path, file_path[len(path)+1:])"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add_file_to_zip(zip_file, filename, archname=None, compress_type=None):\n    with zipfile.ZipFile(zip_file, 'a') as zf:\n        zf.write(filename, archname, compress_type)", "response": "Adds a file into a zip file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef make_dir(dir_name, linux_mode=0o755, error_if_not_writable=False):\n    if not os.path.exists(dir_name):\n        os.makedirs(dir_name, linux_mode)\n    elif error_if_not_writable:\n        if not os.access(dir_name, os.R_OK | os.W_OK | os.X_OK):\n            raise IOError('Directory {0} is not writable.'.format(dir_name))", "response": "Creates a directory if it doesn t exist already."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef load_json_object(file_name, default=None):\n    if not os.path.isfile(file_name):\n        return default\n\n    # use utf-8-sig in case the file has a Byte Order Mark\n    with codecs.open(file_name, 'r', 'utf-8-sig') as in_file:\n        # read the text from the file\n        content = in_file.read()\n\n    # convert Windows line endings to Linux line endings\n    content = content.replace('\\r\\n', '\\n')\n\n    # return a deserialized object\n    return json.loads(content)", "response": "Deserialized file into a Python object"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef write_file(file_name, file_contents, indent=None):\n    # make sure the directory exists\n    make_dir(os.path.dirname(file_name))\n\n    if isinstance(file_contents, string_types):\n        text_to_write = file_contents\n    else:\n        text_to_write = json.dumps(file_contents, sort_keys=True, indent=indent)\n\n    with codecs.open(file_name, 'w', encoding='utf-8') as out_file:\n        out_file.write(text_to_write)", "response": "Writes the contents of file_contents to file_name."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _to_numeric(val):\n    if isinstance(val, (int, float, datetime.datetime, datetime.timedelta)):\n        return val\n    return float(val)", "response": "Helper function for conversion of various data types into numeric representation."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef list(self, rule, **kwargs):\n        return '<ul class=\"pynspect-rule-list\">{}</ul>'.format(''.join(['<li class=\"pynspect-rule-list-item\">{}</li>'.format(v.traverse(self, **kwargs)) for v in rule.value]))", "response": "Return a list of the items in the given rule."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef binary_operation_logical(self, rule, left, right, **kwargs):\n        return '<div class=\"pynspect-rule-operation pynspect-rule-operation-logical\"><h3 class=\"pynspect-rule-operation-name\">{}</h3><ul class=\"pynspect-rule-operation-arguments\"><li class=\"pynspect-rule-operation-argument-left\">{}</li><li class=\"pynspect-rule-operation-argument-right\">{}</li></ul></div>'.format(rule.operation, left, right)", "response": "Return the logical binary operation."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the HTML for the binary operation comparison.", "response": "def binary_operation_comparison(self, rule, left, right, **kwargs):\n        \"\"\"\n        Callback method for rule tree traversing. Will be called at proper time\n        from :py:class:`pynspect.rules.ComparisonBinOpRule.traverse` method.\n\n        :param pynspect.rules.Rule rule: Reference to rule.\n        :param left: Left operand for operation.\n        :param right: right operand for operation.\n        :param dict kwargs: Optional callback arguments.\n        \"\"\"\n        return '<div class=\"pynspect-rule-operation pynspect-rule-operation-comparison\"><h3 class=\"pynspect-rule-operation-name\">{}</h3><ul class=\"pynspect-rule-operation-arguments\"><li class=\"pynspect-rule-operation-argument-left\">{}</li><li class=\"pynspect-rule-operation-argument-right\">{}</li></ul></div>'.format(rule.operation, left, right)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the HTML for the binary operation math.", "response": "def binary_operation_math(self, rule, left, right, **kwargs):\n        \"\"\"\n        Callback method for rule tree traversing. Will be called at proper time\n        from :py:class:`pynspect.rules.MathBinOpRule.traverse` method.\n\n        :param pynspect.rules.Rule rule: Reference to rule.\n        :param left: Left operand for operation.\n        :param right: right operand for operation.\n        :param dict kwargs: Optional callback arguments.\n        \"\"\"\n        return '<div class=\"pynspect-rule-operation pynspect-rule-operation-math\"><h3 class=\"pynspect-rule-operation-name\">{}</h3><ul class=\"pynspect-rule-operation-arguments\"><li class=\"pynspect-rule-operation-argument-left\">{}</li><li class=\"pynspect-rule-operation-argument-right\">{}</li></ul></div>'.format(rule.operation, left, right)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the function tag for the given rule.", "response": "def function(self, rule, args, **kwargs):\n        \"\"\"\n        Callback method for rule tree traversing. Will be called at proper time\n        from :py:class:`pynspect.rules.FunctionRule.traverse` method.\n\n        :param pynspect.rules.Rule rule: Reference to rule.\n        :param args: Optional function arguments.\n        :param dict kwargs: Optional callback arguments.\n        \"\"\"\n        return '<div class=\"pynspect-rule-function\"><h3 class=\"pynspect-rule-function-name\">{}</h3><ul class=\"pynspect-rule-function-arguments>{}</ul></div>'.format(rule.function, ''.join(['<li class=\"pynspect-rule-function-argument\">{}</li>'.format(v) for v in args]))"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nevaluate given logical binary operation with given operands.", "response": "def evaluate_binop_logical(self, operation, left, right, **kwargs):\n        \"\"\"\n        Evaluate given logical binary operation with given operands.\n        \"\"\"\n        if not operation in self.binops_logical:\n            raise ValueError(\"Invalid logical binary operation '{}'\".format(operation))\n        result = self.binops_logical[operation](left, right)\n        return bool(result)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef evaluate_binop_comparison(self, operation, left, right, **kwargs):\n        if not operation in self.binops_comparison:\n            raise ValueError(\"Invalid comparison binary operation '{}'\".format(operation))\n        if left is None or right is None:\n            return None\n        if not isinstance(left, (list, ListIP)):\n            left = [left]\n        if not isinstance(right, (list, ListIP)):\n            right = [right]\n        if not left or not right:\n            return None\n        if operation in ['OP_IS']:\n            res = self.binops_comparison[operation](left, right)\n            if res:\n                return True\n        elif operation in ['OP_IN']:\n            for iteml in left:\n                res = self.binops_comparison[operation](iteml, right)\n                if res:\n                    return True\n        else:\n            for iteml in left:\n                if iteml is None:\n                    continue\n                for itemr in right:\n                    if itemr is None:\n                        continue\n                    res = self.binops_comparison[operation](iteml, itemr)\n                    if res:\n                        return True\n        return False", "response": "Evaluate given comparison binary operation with given operands."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _calculate_vector(self, operation, left, right):\n        result = []\n        if len(right) == 1:\n            right = _to_numeric(right[0])\n            for iteml in left:\n                iteml = _to_numeric(iteml)\n                result.append(self.binops_math[operation](iteml, right))\n        elif len(left) == 1:\n            left = _to_numeric(left[0])\n            for itemr in right:\n                itemr = _to_numeric(itemr)\n                result.append(self.binops_math[operation](left, itemr))\n        elif len(left) == len(right):\n            for iteml, itemr in zip(left, right):\n                iteml = _to_numeric(iteml)\n                itemr = _to_numeric(itemr)\n                result.append(self.binops_math[operation](iteml, itemr))\n        else:\n            raise FilteringRuleException(\"Uneven length of math operation '{}' operands\".format(operation))\n        return result", "response": "Calculate vector result from two list operands with given mathematical operation."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef evaluate_binop_math(self, operation, left, right, **kwargs):\n        if not operation in self.binops_math:\n            raise ValueError(\"Invalid math binary operation '{}'\".format(operation))\n        if left is None or right is None:\n            return None\n        if not isinstance(left, (list, ListIP)):\n            left = [left]\n        if not isinstance(right, (list, ListIP)):\n            right = [right]\n        if not left or not right:\n            return None\n        try:\n            vect = self._calculate_vector(operation, left, right)\n            if len(vect) > 1:\n                return vect\n            return vect[0]\n        except:\n            return None", "response": "Evaluate given mathematical binary operation with given operands."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef evaluate_unop(self, operation, right, **kwargs):\n        if not operation in self.unops:\n            raise ValueError(\"Invalid unary operation '{}'\".format(operation))\n        if right is None:\n            return None\n        return self.unops[operation](right)", "response": "Evaluate given unary operation with given operand."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndecorate function with given name with given decorator.", "response": "def decorate_function(self, name, decorator):\n        \"\"\"\n        Decorate function with given name with given decorator.\n\n        :param str name: Name of the function.\n        :param callable decorator: Decorator callback.\n        \"\"\"\n        self.functions[name] = decorator(self.functions[name])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef function(self, rule, args, **kwargs):\n        fname = rule.function\n        try:\n            return self.functions[fname](args)\n        except KeyError:\n            raise FilteringRuleException(\"Invalid function name '{}'\".format(fname))", "response": "Implementation of pynspect. traversers. RuleTreeTraverser interface. function"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nrendering single model to its html representation.", "response": "def render(self, template=None, additional=None):\n        \"\"\"\n        Render single model to its html representation.\n\n        You may set template path in render function argument,\n            or model's variable named 'template_path',\n            or get default name: $app_label$/models/$model_name$.html\n\n        Settings:\n        * MODEL_RENDER_DEFAULT_EXTENSION\n            set default template extension. Usable if you use jinja or others.\n\n        :param template: custom template_path\n        :return: rendered model html string\n        \"\"\"\n        template_path = template or self.get_template_path()\n\n        template_vars = {'model': self}\n        if additional:\n            template_vars.update(additional)\n\n        rendered = render_to_string(template_path, template_vars)\n        return mark_safe(rendered)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nexecuting a system command.", "response": "def execute(self):\n        \"\"\"Execute a system command.\"\"\"\n        if self._decode_output:\n            # Capture and decode system output\n            with Popen(self.command, shell=True, stdout=PIPE) as process:\n                self._output = [i.decode(\"utf-8\").strip() for i in process.stdout]\n                self._success = True\n        else:\n            # Execute without capturing output\n            os.system(self.command)\n            self._success = True\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef is_vimball(fd):\n    fd.seek(0)\n    try:\n        header = fd.readline()\n    except UnicodeDecodeError:\n        # binary files will raise exceptions when trying to decode raw bytes to\n        # str objects in our readline() wrapper\n        return False\n    if re.match('^\" Vimball Archiver', header) is not None:\n        return True\n    return False", "response": "Test for vimball archive format compliance."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef files(self):\n        # try new file header format first, then fallback on old\n        for header in (r\"(.*)\\t\\[\\[\\[1\\n\", r\"^(\\d+)\\n$\"):\n            header = re.compile(header)\n            filename = None\n            self.fd.seek(0)\n            line = self.readline()\n            while line:\n                m = header.match(line)\n                if m is not None:\n                    filename = m.group(1)\n                    try:\n                        filelines = int(self.readline().rstrip())\n                    except ValueError:\n                        raise ArchiveError('invalid archive format')\n                    filestart = self.fd.tell()\n                    yield (filename, filelines, filestart)\n                line = self.readline()\n            if filename is not None:\n                break", "response": "Yields archive file information."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nextract archive files to a directory.", "response": "def extract(self, extractdir=None, verbose=False):\n        \"\"\"Extract archive files to a directory.\"\"\"\n        if extractdir is None:\n            filebase, ext = os.path.splitext(self.path)\n            if ext in ('.gz', '.bz2', '.xz'):\n                filebase, _ext = os.path.splitext(filebase)\n            extractdir = os.path.basename(filebase)\n            if os.path.exists(extractdir):\n                tempdir = tempfile.mkdtemp(prefix='vimball-', dir=os.getcwd())\n                extractdir = os.path.join(tempdir.split('/')[-1], extractdir)\n\n        self.fd.seek(0)\n        for filename, lines, offset in self.files:\n            filepath = os.path.join(extractdir, filename)\n            try:\n                directory = os.path.dirname(filepath)\n                mkdir_p(directory)\n            except OSError as e:\n                raise ArchiveError(f\"failed creating directory {directory!r}: {e.strerror}\")\n            with open(filepath, 'w') as f:\n                if verbose:\n                    print(filepath)\n                self.fd.seek(offset)\n                for i in range(lines):\n                    f.write(self.readline())"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef ini_load_hook(cfg, **kwargs):\n\n    # Load the data from the INI file.\n    cfg.tmpini = configparser.ConfigParser()\n    try:\n        cfg.tmpini.read_file(cfg.fd)\n    except ValueError as e:\n        raise exc.LoaderException(\"Could not decode INI file: {}\".format(e)) from e\n    # Sanitize data.\n    tmpdict = {}\n    for name in cfg.tmpini.sections():\n        data = dict(cfg.tmpini[name])\n        tmpdict[name] = data\n\n    # Serialize the data into new sets of ConfigKey classes.\n    cfg.config.load_from_dict(tmpdict)", "response": "This handles automatically opening and creating the INI file and then deserializing the data into a ConfigKey class."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef ini_dump_hook(cfg, text: bool=False):\n    data = cfg.config.dump()\n\n    # Load data back into the goddamned ini file.\n    ndict = {}\n    for key, item in data.items():\n        key = key.replace('_', '.')\n        ndict[key] = item\n\n    cfg.tmpini = configparser.ConfigParser()\n    cfg.tmpini.read_dict(data)\n    if not text:\n        cfg.tmpini.write(cfg.fd)\n    else:\n        return\n    cfg.reload()", "response": "Dump all the data into a goddamned ini file."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef exception_message():\n    exc_type, exc_value, exc_tb = exc_info = sys.exc_info()\n    return {'exception': {'type': exc_type,\n                          'value': exc_value,\n                          'traceback': exc_tb},\n            'traceback': traceback.format_exception(*exc_info)}", "response": "Create a message with details on the exception."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the payment request form.", "response": "def payzen_form(payment_request, auto_submit=False):\n    \"\"\"TODO docstring.\"\"\"\n    if auto_submit:\n        template_used = \"django_payzen/auto_submit_form.html\"\n    else:\n        template_used = \"django_payzen/form.html\"\n    payment_request.update()\n    t = template.loader.get_template(template_used)\n    return t.render({\n        \"form\": forms.PaymentRequestForm(instance=payment_request),\n        \"payzen_submit_url\": app_settings.PAYZEN_REQUEST_URL\n    })"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconvert timestamp to a datetime object", "response": "def fromtimestamp(timestamp):\n    \"\"\"Because python doesn't support negative timestamp to datetime\n    so we have to implement my own method\n    \"\"\"\n    if timestamp >= 0:\n        return datetime.fromtimestamp(timestamp)\n    else:\n        return datetime(1969, 12, 31, 20, 0) + timedelta(seconds=timestamp)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfinds the location of a segment on a line and x.", "response": "def locate(x1, y1, x2, y2, x3):\n    \"\"\"An equation solver to solve: given two points on a line and x, solve the\n    y coordinate on the same line.\n\n    Suppose p1 = (x1, y1), p2 = (x2, y2), p3 = (x3, y3) on the same line.\n    given x1, y1, x2, y2, x3, find y3::\n\n        y3 = y1 - (y1 - y2) * (x1 - x3) / (x1 - x3)\n    \"\"\"\n    return y1 - 1.0 * (y1 - y2) * (x1 - x3) / (x1 - x2)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef rigid_linear_interpolate(x_axis, y_axis, x_new_axis):\n    f = interp1d(x_axis, y_axis)\n    return f(x_new_axis)", "response": "Interpolate a y function using linear interpolation."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef rigid_linear_interpolate_by_datetime(datetime_axis, y_axis, datetime_new_axis):\n    numeric_datetime_axis = [\n        totimestamp(a_datetime) for a_datetime in datetime_axis\n    ]\n\n    numeric_datetime_new_axis = [\n        totimestamp(a_datetime) for a_datetime in datetime_new_axis\n    ]\n\n    return rigid_linear_interpolate(\n        numeric_datetime_axis, y_axis, numeric_datetime_new_axis)", "response": "A datetime - version that takes datetime object list as x_axis."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef linear_interpolate(x_axis, y_axis, x_new_axis, enable_warning=True):\n    left_pad_x, left_pad_y = list(), list()\n    right_pad_x, right_pad_y = list(), list()\n\n    if x_new_axis[0] < x_axis[0]:\n        if enable_warning:\n            print(\"WARNING! the first element of x_new_axis is at left \"\n                  \"of x_axis. Use linear_interpolate(enable_warning=False) \"\n                  \"to disable this warning.\")\n        left_pad_x.append(x_new_axis[0])\n        left_pad_y.append(locate(x_axis[0], y_axis[0],\n                                 x_axis[1], y_axis[1], x_new_axis[0]))\n\n    if x_new_axis[-1] > x_axis[-1]:\n        if enable_warning:\n            print(\"WARNING! the last element of x_new_axis is at right \"\n                  \"of x_axis. Use linear_interpolate(enable_warning=False) \"\n                  \"to disable this warning.\")\n        right_pad_x.append(x_new_axis[-1])\n        right_pad_y.append(locate(x_axis[-1], y_axis[-1],\n                                  x_axis[-2], y_axis[-2], x_new_axis[-1]))\n\n    if not ((len(left_pad_x) == 0) and (len(right_pad_x) == 0)):\n        x_axis = left_pad_x + x_axis + right_pad_x\n        y_axis = left_pad_y + y_axis + right_pad_y\n\n    return rigid_linear_interpolate(x_axis, y_axis, x_new_axis)", "response": "Interpolate a function using linear interpolation."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef linear_interpolate_by_datetime(datetime_axis, y_axis, datetime_new_axis,\n                                   enable_warning=True):\n    \"\"\"A datetime-version that takes datetime object list as x_axis\n    \"\"\"\n    numeric_datetime_axis = [\n        totimestamp(a_datetime) for a_datetime in datetime_axis\n    ]\n\n    numeric_datetime_new_axis = [\n        totimestamp(a_datetime) for a_datetime in datetime_new_axis\n    ]\n\n    return linear_interpolate(\n        numeric_datetime_axis, y_axis, numeric_datetime_new_axis,\n        enable_warning=enable_warning)", "response": "A datetime - version that takes datetime object list as x_axis\n    y_axis datetime object list as y_axis\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef exam_reliability(x_axis, x_axis_new, reliable_distance, precision=0.0001):\n    x_axis = x_axis[::-1]\n    x_axis.append(-2**32)\n\n    distance_to_closest_point = list()\n    for t in x_axis_new:\n        while 1:\n            try:\n                x = x_axis.pop()\n                if x <= t:\n                    left = x\n                else:\n                    right = x\n                    x_axis.append(right)\n                    x_axis.append(left)\n                    left_dist, right_dist = (t - left), (right - t)\n                    if left_dist <= right_dist:\n                        distance_to_closest_point.append(left_dist)\n                    else:\n                        distance_to_closest_point.append(right_dist)\n                    break\n            except:\n                distance_to_closest_point.append(t - left)\n                break\n\n    reliable_flag = list()\n    for dist in distance_to_closest_point:\n        if dist - precision - reliable_distance <= 0:\n            reliable_flag.append(True)\n        else:\n            reliable_flag.append(False)\n\n    return reliable_flag", "response": "Examines the data points in x_axis and derives value for x_axis_new and returns a new version of the input data points."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef spline_interpolate(x_axis, y_axis, x_new_axis):\n    f = interp1d(x_axis, y_axis, kind=\"cubic\")\n    return f(x_new_axis)", "response": "Interpolate a y function using Spline interpolation algorithm."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconverts a pointer to a Qt class instance", "response": "def wrapinstance(ptr, base=None):\n    \"\"\"convert a pointer to a Qt class instance (PySide/PyQt compatible)\"\"\"\n    if ptr is None:\n        return None\n    ptr = long(ptr)  # Ensure type\n    from wishlib.qt import active, QtCore, QtGui\n    if active == \"PySide\":\n        import shiboken\n        if base is None:\n            qObj = shiboken.wrapInstance(ptr, QtCore.QObject)\n            metaObj = qObj.metaObject()\n            cls = metaObj.className()\n            superCls = metaObj.superClass().className()\n            if hasattr(QtGui, cls):\n                base = getattr(QtGui, cls)\n            elif hasattr(QtGui, superCls):\n                base = getattr(QtGui, superCls)\n            else:\n                base = QtGui.QWidget\n        return shiboken.wrapInstance(ptr, base)\n    elif active == \"PyQt4\":\n        import sip\n        return sip.wrapinstance(ptr, QtGui.QWidget)\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef rand_str(allowed, length):\n    if (not isinstance(length, int)) or (length <= 0):\n        raise Exception(\"length parameter has to be an integer greater than 0!\")\n    \n    res = list()\n    for _ in range(length):\n        res.append(random.choice(allowed))\n    return \"\".join(res)", "response": "Generate a fixed - length random string from your allowed character pool."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nretrieving the status of a loaded driver", "response": "def driver_status(name):  # noqa: E501\n    \"\"\"Retrieve the status of a loaded driver\n\n    Retrieve the status of a loaded driver # noqa: E501\n\n    :param name: Get status of a driver with this name\n    :type name: str\n\n    :rtype: Response\n    \"\"\"\n    if(not hasAccess()):\n        return redirectUnauthorized()\n\n    driver = LoadedDrivers.getDefaultDriver()\n    body = {\"name\": str(driver.__class__.__name__)}\n    body.update(driver.serialize())\n    return Response(status=200, body=body)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef import_object_by_string(namespace):\n    segments = namespace.split('.')\n    module = importlib.import_module('.'.join(segments[:-1]))\n    return getattr(module, segments[-1])", "response": "Import object by complete namespace"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating Celery beat schedule by get schedule from every installed app", "response": "def create_celerybeat_schedule(apps):\n    \"\"\"Create Celery beat schedule by get schedule from every installed app\"\"\"\n    beat_schedule = {}\n    for app in apps:\n        try:\n            config = import_object_by_string(app)\n            module = importlib.import_module('{}.cron'.format(config.name))\n        except Exception:\n            try:\n                module = importlib.import_module('{}.cron'.format(app))\n            except Exception:\n                continue\n\n        if not (hasattr(module, 'schedule') and isinstance(module.schedule, dict)):\n            logger.warning('{} has no schedule or schedule is not a dict'.format(module.__name__))\n            continue\n\n        # Add cron queue option\n        for name, schedule in module.schedule.items():\n            options = schedule.get('options', {})\n            if 'queue' not in options:\n                options['queue'] = 'cron'\n                schedule['options'] = options\n\n                beat_schedule[name] = schedule\n\n    return beat_schedule"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef say(text='This is so cool', rate_adjust=-50, volume_adjust=0):\n    '''\n    Says an English text, with any adjust rate and/or volume\n    '''\n    # Adjusts the property\n    rate = engine.getProperty('rate')\n    engine.setProperty('rate', rate+rate_adjust)\n    volume = engine.getProperty('volume')\n    engine.setProperty('volume', volume+volume_adjust)\n\n    # Says the text and voila!\n    engine.say(text)\n    engine.runAndWait()", "response": "Says a text and voila!"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef conv3x3(in_planes, out_planes, fn, stride=1):\n    return fn(in_planes, out_planes, kernel_size=3, stride=stride, padding=1, bias=False)", "response": "3x3 convolution with padding"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef configure_client(\n            cls, address: Union[str, Tuple[str, int], Path] = 'localhost', port: int = 6379,\n            db: int = 0, password: str = None, ssl: Union[bool, str, SSLContext] = False,\n            **client_args) -> Dict[str, Any]:\n        \"\"\"\n        Configure a Redis client.\n\n        :param address: IP address, host name or path to a UNIX socket\n        :param port: port number to connect to (ignored for UNIX sockets)\n        :param db: database number to connect to\n        :param password: password used if the server requires authentication\n        :param ssl: one of the following:\n\n            * ``False`` to disable SSL\n            * ``True`` to enable SSL using the default context\n            * an :class:`~ssl.SSLContext` instance\n            * a ``module:varname`` reference to an :class:`~ssl.SSLContext` instance\n            * name of an :class:`~ssl.SSLContext` resource\n        :param client_args: extra keyword arguments passed to :func:`~aioredis.create_redis_pool`\n\n        \"\"\"\n        assert check_argument_types()\n        if isinstance(address, str) and not address.startswith('/'):\n            address = (address, port)\n        elif isinstance(address, Path):\n            address = str(address)\n\n        client_args.update({\n            'address': address,\n            'db': db,\n            'password': password,\n            'ssl': resolve_reference(ssl)\n        })\n        return client_args", "response": "Configure a Redis client."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ngive a list of words, this function returns a new list where the words follow mixed case convention. As a reminder this is mixedCase. :param word_list: list, a list of words :return: list, a list of words where the words are mixed case", "response": "def format_word_list_mixedcase(word_list):\n    \"\"\"\n    Given a list of words, this function returns a new list where the\n    words follow mixed case convention.\n\n    As a reminder this is mixedCase.\n\n    :param word_list: list, a list of words\n    :return: list, a list of words where the words are mixed case\n    \"\"\"\n    to_return, first_word = list(), True\n    for word in word_list:\n        if first_word:\n            to_return.append(word.lower())\n            first_word = False\n        else:\n            to_return.append(word.capitalize())\n    return to_return"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef format_string(string_to_format, wordstyle=\"lowercase\", separator=\" \"):\n    # first split the string up into its constituent words\n    words = string_to_format.split(\" \")\n\n    # format the individual words\n    function_map = {\n        \"lowercase\": format_word_list_lowercase,\n        \"uppercase\": format_word_list_uppercase,\n        \"capitalize\": format_word_list_capitalize,\n        \"mixedcase\": format_word_list_mixedcase\n    }\n\n    try:\n        words = function_map[wordstyle](words)\n    except KeyError:\n        msg = \"Passed in an invalid wordstyle, allowed styles are {}\"\n        raise InvalidWordStyleError(msg.format(function_map.keys()))\n\n    # now add in the separator and return\n    return str(separator).join(words)", "response": "Takes an un - formatted string and returns it in the desired format"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_random_word(dictionary, starting_letter=None):\n    if starting_letter is None:\n        starting_letter = random.choice(list(dictionary.keys()))\n\n    try:\n        to_return = random.choice(dictionary[starting_letter])\n    except KeyError:\n        msg = \"Dictionary does not contain a word starting with '{}'\"\n        raise NoWordForLetter(msg.format(starting_letter))\n\n    return to_return", "response": "Takes a dictionary to read from and returns a random word\n    optionally accepts a starting letter"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfunctions used to import the dictionary file into memory", "response": "def import_dictionary(dictionary):\n    \"\"\"\n    Function used to import the dictionary file into memory\n    opened_file should be an already opened dictionary file\n\n    :raises DictionaryNotFoundError if dictionary can't be loaded\n    \"\"\"\n    def load_into_dictionary(dictionary_file):\n        \"\"\"create the dictionary to hold the words\"\"\"\n        to_return = dict()\n        for line in dictionary_file:\n            try:\n                to_return[line[0].lower()].append(line.strip().lower())\n            except KeyError:\n                to_return[line[0].lower()] = [line.strip().lower()]\n\n        return to_return\n\n    try:\n        with open(dictionary) as dictionary_file:\n            to_return = load_into_dictionary(dictionary_file)\n\n    except TypeError:\n        to_return = load_into_dictionary(dictionary)\n\n    except IOError:\n        message = \"Could not find the dictionary at {}\".format(dictionary)\n        raise DictionaryNotFoundError(message)\n\n    return to_return"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef string_for_initials(dictionary, initials):\n    string_to_print = \"\"\n    for letter in initials:\n        word = get_random_word(dictionary, letter.lower())\n        string_to_print += \"{} \".format(word)\n\n    return string_to_print.strip()", "response": "Create a random string of words of length len ( initials"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef string_for_count(dictionary, count):\n    string_to_print = \"\"\n    if count is not None:\n        if count == 0:\n            return \"\"\n        ranger = count\n    else:\n        ranger = 2\n    for index in range(ranger):\n        string_to_print += \"{} \".format(get_random_word(dictionary))\n\n    return string_to_print.strip()", "response": "Create a random string of N = count words"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngenerating seed for random number generator", "response": "def generate_seed(seed):\n    \"\"\"Generate seed for random number generator\"\"\"\n    if seed is None:\n        random.seed()\n        seed = random.randint(0, sys.maxsize)\n    random.seed(a=seed)\n\n    return seed"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating the argument parser object to be used by the rest of the tool", "response": "def create_parser():\n    \"\"\"Creates the Namespace object to be used by the rest of the tool\"\"\"\n    parser = argparse.ArgumentParser(description=__doc__)\n\n    parser.add_argument('-d', '--dictionary',\n                        nargs='?',\n                        default='dictionaries/all_en_US.dict',\n                        help='Specify a non-default word dictionary to use.')\n    parser.add_argument('-c', '--count',\n                        help='Specify the number of words to return.',\n                        type=int)\n    parser.add_argument('-i', '--initials',\n                        type=str,\n                        help='String of letters used to form the word list')\n    parser.add_argument('-s', '--seed',\n                        help='Specify the seed to use for the random number '\n                        'generator. Using the same seed without changing '\n                        'other settings will give repeatable results.',\n                        type=int)\n    parser.add_argument('-ws', '--wordstyle',\n                        nargs='?',\n                        default='lowercase',\n                        type=str,\n                        help='Specify how to style the individual words. '\n                        'Default is lowercase.')\n    parser.add_argument('-sep', '--separator',\n                        nargs='?',\n                        default=' ',\n                        type=str,\n                        help='How to separate words. Default is space.')\n\n    return parser.parse_args()"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsaves to db and return saved object", "response": "def save_to_db(model_text_id, parsed_values):\n        \"\"\"save to db and return saved object\"\"\"\n        Model = apps.get_model(model_text_id)\n\n        # normalise values and separate to m2m, simple\n        simple_fields = {}\n        many2many_fields = {}\n        for field, value in parsed_values.items():\n            if (Model._meta.get_field(\n                    field).get_internal_type() == 'ManyToManyField'):\n                many2many_fields[field] = value\n            elif (Model._meta.get_field(\n                    field).get_internal_type() == 'DateTimeField'):\n                simple_fields[field] = time_parser.parse(value)\n\n            else:\n                simple_fields[field] = value\n\n        # ToDo: add unique identify parameter to field\n        # ToDo: allow unique identify m2m field\n        model, created = Model.objects.get_or_create(**simple_fields)\n\n        for field, value in many2many_fields.items():\n            setattr(model, field, value)\n        model.save()\n\n        return model"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\niterating over all key value pairs.", "response": "def iteritems(self):\n        ''' Iterate over all (key, value) pairs.\n        All keys will be denormalized.\n        '''\n        for key, value in self._dict.items():\n            yield self._denormalize(key), value"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef grouper(iterable, n):\n    it = iter(iterable)\n    while True:\n        chunk = itertools.islice(it, n)\n        try:\n            first = next(chunk)\n        except StopIteration:\n            return\n\n        yield itertools.chain([first], chunk)", "response": "Slice up iterable into iterables of n items."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef prepare(self, dataframe):\n        mapping = DataFrameMapCreator().get_mapping_from_config(self.__config)\n        self.__mapper = DataFrameMapper(mapping)\n        train, test = split_dataframe_train_test(dataframe, self.__config.get_option_parameter(\"split\", \"train_percentage\"))\n        return self.__get_correct_return_parameters(train, test)", "response": "Takes the already cleaned dataframe splits it into train and test and returns the train and test as numpy arrays."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef __add_target_data(self, transformed_data, original_data):\n        model = self.__config.get_data_model()\n        target_feature = model.find_target_feature()\n        name = target_feature.get_name()\n\n        if target_feature.is_categorical():\n            target_row = original_data[name]\n            target = self.__label_encoder_adapter.transform(target_row)\n        else:\n            target = original_data[name].values.astype(type_name_to_data_type(\"float\"))\n\n        target = target[..., None]\n\n        return np.hstack((transformed_data, target))", "response": "Adds the target data from the original_data and appends it as a\n        column to the transformed_data."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef weighted_random(sequence):\n\n    if isinstance(sequence, dict):\n        sequence = sequence.items()\n\n    accumulated = list(labeled_accumulate(sequence))\n    r = random.random() * accumulated[-1][1]\n    for k, v in accumulated:\n        if r < v:\n            return k\n    #punto inalcanzable a priori\n    return None", "response": "Given a sequence of pairs returns a random element given by a weighted random number."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ngenerate a pseudo - random nonce.", "response": "def nonce(algorithm='sha1', to_hex=True):\n    \"\"\"\n    Generates a nonce (a pseudo-random token). It is seeded with the current date/time.\n    :param algorithm: a string being any of the SHA hash algorithms.\n    :param to_hex: a boolean describing whether we want a base64 digest or a hexadecimal digest\n    :return:\n    \"\"\"\n    if algorithm not in _HASHES:\n        return None\n    result = _HASHES[algorithm](datetime.datetime.now().isoformat())\n    return result.hexdigest() if to_hex else b64encode(result.digest())"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef status(self, status: int) -> None:\n        self._status = status\n        self._message = STATUS_CODES[status]", "response": "set status to the current status"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nwriting data to the socket.", "response": "def write(self, data: bytes, sync: bool = False) -> None:\n        \"\"\"\n        \u5f02\u6b65\u5199\u5165\uff0c\u901a\u8fc7 asyncio \u7684\u539f\u751f\u5f02\u6b65\n        \"\"\"\n        if sync:\n            self.sync_write(data)\n        else:\n            self._transport.write(data)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get(self, name: str) -> Union[None, str, List[str]]:\n        if name in self._headers:\n            return self._headers[name]\n        return None", "response": "Get a key from the cache."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting the value of the named header.", "response": "def set(self, name: str, value: Union[str, List[str]]) -> None:\n        \"\"\"\n        \u8bbe\u7f6e header\n        \"\"\"\n        self._headers[name] = value"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef body(self) -> Union[bytes, str, List[Any], Dict[Any, Any], RawIOBase, None]:\n        return self._body", "response": "Return the body of the message."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting the body of the message.", "response": "def body(self, body: Union[bytes, str, list, dict, RawIOBase, None]) -> None:\n        \"\"\"\n        \u8bbe\u7f6ebody\n        \"\"\"\n        self._body = body"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef handel_default(self) -> None:\n        raw_body = self._body\n        body = cast(Optional[bytes], None)\n        default_type = 2\n        charset = self._charset or self._default_charset\n        if raw_body is None:\n            pass\n        elif isinstance(raw_body, bytes):\n            # body\u4e3abytes\n            default_type = 2\n            body = raw_body\n        elif isinstance(raw_body, str):\n            # body \u4e3a\u5b57\u7b26\u4e32\n            default_type = 2\n            body = encode_str(raw_body, charset)\n        elif isinstance(raw_body, (list, dict)):\n            # body \u4e3ajson\n            default_type = 3\n            body = encode_str(json.dumps(raw_body, ensure_ascii=False), charset)\n        elif isinstance(raw_body, RawIOBase):\n            # body \u4e3a\u6587\u4ef6\n            default_type = 1\n            body = raw_body.read()\n            raw_body.close()\n        if \"Content-Length\" not in self._headers and \\\n                \"Transfer-Encoding\" not in self._headers \\\n                or self._headers[\"Transfer-Encoding\"] != \"chunked\":\n            if self.length is None:\n                if body is not None:\n                    self.length = len(body)\n                else:\n                    self.length = 0\n            # \u8bbe\u7f6e\u9ed8\u8ba4 Content-Length\n            self.set(\"Content-Length\", str(self.length))\n        # print(body[0], body[1])\n        if body is not None and body.startswith(encode_str(\"<\", charset)):\n            default_type = 4\n        if \"Content-Type\" not in self._headers.keys():\n            type_str = self.type\n            if type_str is None:\n                temp = DEFAULT_TYPE.get(default_type)\n                if temp is not None:\n                    if default_type != 1:\n                        temp += \"; charset=%s\" % charset\n                    type_str = temp\n            if type_str is not None:\n                # \u8bbe\u7f6e\u9ed8\u8ba4 Content-Type\n                self.set(\"Content-Type\", type_str)\n        self._body = body", "response": "Handel the default content of the message."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nflushing the HTTP headers to the socket.", "response": "def flush_headers(self, sync: bool = False) -> None:\n        \"\"\"\n        \u901a\u8fc7\u5f02\u6b65\u5199\u5165 header\n        \"\"\"\n        if self._headers_sent:\n            return\n        self._headers_sent = True\n        self.handel_default()\n        self.write(\n            b\"HTTP/%s %d %s\\r\\n\" % (\n                encode_str(self._version),\n                self._status,\n                self._message,\n            ),\n            sync,\n        )\n        for name, value in self._headers.items():\n            name_byte = encode_str(name)\n            if isinstance(value, list):\n                for val in value:\n                    self.write(\n                        b\"%s: %s\\r\\n\" % (\n                            name_byte,\n                            encode_str(val),\n                        ),\n                        sync,\n                    )\n            else:\n                val = value\n                self.write(\n                    b\"%s: %s\\r\\n\" % (\n                        name_byte,\n                        encode_str(value),\n                    ),\n                    sync,\n                )\n        self.write(b\"\\r\\n\", sync)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef flush_body(self) -> bool:\n        if self._body is None:\n            return False\n        elif isinstance(self._body, bytes):\n            self.write(self._body)\n            return True\n        return False", "response": "Flushes the message body to the local file."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a list of deployer objects that create cloud resources.", "response": "def get_stage_deployers(keys, stack):\n    \"\"\"\n    Returns a list of deployer objects that *create* cloud resources.  Each\n    member of the list is responsible for provisioning a single stack resource\n    (e.g. a virtual server, a security group, a bucket, etc...).\n\n    :param keys:  A list of top-level configuration keys for which to create\n        deployers.\n    :type keys:  :class:`~collections.Iterable`\n\n    :param config:  A stack object.\n    :type config:  :class:`~bang.stack.Stack`\n\n    :rtype:  :class:`list` of :class:`~bang.deployers.deployer.Deployer`\n\n    \"\"\"\n    config = stack.config\n    creds = config[A.DEPLOYER_CREDS]\n    deployers = []\n    for res_type in keys:\n        res_configs = config.get(res_type)\n        if not res_configs:\n            continue\n        log.debug(\"Found config for resource type, %s\" % res_type)\n        for res_config in res_configs:\n            if A.PROVIDER in res_config:\n                ds = cloud.get_deployers(res_config, res_type, stack, creds)\n            else:\n                ds = [default.ServerDeployer(stack, res_config)]\n            if ds:\n                deployers.extend(ds)\n    return deployers"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_params(method, params):\n    data = {'method': method, 'params': params, 'id': str(uuid4())}\n    return json.dumps(data)", "response": "Set params to query limesurvey"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nretrieving a list of surveys from current user", "response": "def list_surveys(session):\n    \"\"\"retrieve a list of surveys from current user\"\"\"\n    params = {'sUser': session['user'], 'sSessionKey': session['token']}\n    data = set_params('list_surveys', params)\n    req = requests.post(session['url'], data=data, headers=headers)\n    return req.text"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_linkrolls(num='All', destination_slug=None, *args, **kwargs):\n    if destination_slug:\n        linkrolls = LinkRoll.objects.filter(destination__slug=destination_slug)\n    else:\n        linkrolls = LinkRoll.objects.all()\n\n    if num is not 'All':\n        linkrolls = linkrolls[0:num]\n\n    return {\n        'object_list': linkrolls\n    }", "response": "Get a list of LinkRolls."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_linkroll_details(destination_slug, num='All', *args, **kwargs):\n    links = Link.objects.filter(destination__slug=destination_slug)\n    if num:\n        links = links[0:num]\n\n    return {\n        'link_list': links\n    }", "response": "Get a list of links for a given linkroll."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef new(self, sources):\n        self._response['shouldEndSession'] = True\n        self._response['action']['audio']['interface'] = 'new'\n        self._response['action']['audio']['sources'] = sources\n        return self", "response": "Sends a Play Directive to begin playback and replace current and enqueued streams."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsend a stop signal to stop the current stream playback", "response": "def stop(self):\n        \"\"\"Send signal to stop the current stream playback\"\"\"\n        self._response['shouldEndSession'] = True\n        self._response['action']['audio']['interface'] = 'stop'\n        self._response['action']['audio']['sources'] = []\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsend a pause signal to resume playback at the paused offset", "response": "def play(self):\n        \"\"\"Send signal to resume playback at the paused offset\"\"\"\n        self._response['shouldEndSession'] = True\n        self._response['action']['audio']['interface'] = 'play'\n        self._response['action']['audio']['sources'] = []\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef pause(self):\n        self._response['shouldEndSession'] = True\n        self._response['action']['audio']['interface'] = 'pause'\n        self._response['action']['audio']['sources'] = []\n        return self", "response": "Send a pause signal to resume playback at the paused offset"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef next(self):\n        self._response['shouldEndSession'] = True\n        self._response['action']['audio']['interface'] = 'next'\n        self._response['action']['audio']['sources'] = []\n        return self", "response": "Send signal to resume playback at the paused offset"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the sub - path of the path.", "response": "def sub_path(self, path):\n        \"\"\" If this redirect is a regular expression, it will return a\n        rewritten version of `path`; otherwise returns the `new_path`. \"\"\"\n        if not self.regular_expression:\n            return self.new_path\n        return re.sub(self.old_path, self.new_path, path)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a new class that can be used to compare the contents of the object with the given set of attributes.", "response": "def via(fields):\n    \"\"\"\n    Define the fields (attributes) to use for instance comparison and repr.\n\n    Creates ``__eq__``\\ , ``__ne__`` and ``__repr__`` methods for the\n    decorated class, along with a private ``_contents`` property which\n    simply returns the fields provided with associated values on the\n    instance, and a ``fields`` attribute simply containing the fields.\n\n    Other than ``__eq__`` and ``__ne__`` any existing attributes will be\n    untouched if already defined on the class.\n\n    :argument iterable fields: the names of attributes that should be\n        considered relevant for comparison and display. The order that the\n        iterable returns the fields in affects the order in which comparison\n        happens and the order they are displayed in the ``__repr__``\\ .\n\n    \"\"\"\n\n    def add_methods(cls):\n        nothing = object()\n\n        if getattr(cls, \"fields\", nothing) is nothing:\n            cls.fields = tuple(fields)\n\n        def contents(self):\n            return [(attr, getattr(self, attr)) for attr in fields]\n\n        if getattr(cls, \"_contents\", nothing) is nothing:\n            cls._contents = property(contents)\n\n        def __eq__(self, other):\n            if not isinstance(other, self.__class__):\n                return NotImplemented\n            return contents(self) == contents(other)\n        cls.__eq__ = __eq__\n\n        def __ne__(self, other):\n            if not isinstance(other, self.__class__):\n                return NotImplemented\n            return not self == other\n        cls.__ne__ = __ne__\n\n        if cls.__repr__ == object.__repr__:\n            def __repr__(self):\n                fields_repr = \" \".join(\n                    \"{0}={1}\".format(k, reprlib.repr(v))\n                    for k, v in contents(self)\n                )\n                return \"<{0.__class__.__name__} {1}>\".format(self, fields_repr)\n            cls.__repr__ = __repr__\n\n        return cls\n    return add_methods"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ninspecting config and sets the name of the formatter to json or text", "response": "def _set_formatter(self):\n        \"\"\"\n        Inspects config and sets the name of the formatter to either \"json\" or \"text\"\n        as instance attr. If not present in config, default is \"text\"\n        \"\"\"\n        if hasattr(self._config, \"formatter\") and self._config.formatter == \"json\":\n            self._formatter = \"json\"\n        else:\n            self._formatter = \"text\""}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ninspects config and sets the log level as instance attr.", "response": "def _set_log_level(self):\n        \"\"\"\n        Inspects config and sets the log level as instance attr. If not present\n        in config, default is \"INFO\".\n        \"\"\"\n        # set log level on logger\n        log_level = \"INFO\"\n        if hasattr(self._config, \"level\") and self._config.level.upper() in [\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"]:\n            log_level = self._config.level.upper()\n        self._log_level = log_level"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate a logger with default formatting for internal use by the CloeePy framework and its plugins.", "response": "def _set_framework_logger(self):\n        \"\"\"\n        Creates a logger with default formatting for internal use by the CloeePy\n        framework and its plugins. User may configure customer fields on their\n        logger, but the framework would not know how to incorporate those custom\n        fields, and by design of the logging pkg authors, the program would error\n        out.\n        \"\"\"\n        formatter = None\n        if self._formatter == \"json\":\n            formatter = CustomJsonFormatter(self.default_json_fmt)\n        else:\n            formatter = logging.Formatter(self.default_text_fmt)\n\n        self._logger = logging.getLogger(\"CloeePyFramework\")\n        logHandler = logging.StreamHandler()\n        logHandler.setFormatter(formatter)\n        self._logger.addHandler(logHandler)\n        self._logger.setLevel(self._log_level)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting the application logger.", "response": "def _set_application_logger(self):\n        \"\"\"\n        Creates a logger intended for use by applications using CloeePy. This logger\n        is fully configurable by the user and can include custom fields\n        \"\"\"\n        formatter = None\n        if self._formatter == \"json\":\n            if hasattr(self._config, \"formatString\"):\n                formatter = CustomJsonFormatter(self._config.formatString)\n            else:\n                formatter = CustomJsonFormatter(self.default_json_fmt)\n        else:\n            if hasattr(self._config, \"formatString\"):\n                formatter = logging.Formatter(self._config.formatString)\n            else:\n                formatter = logging.Formatter(self.default_txt_fmt)\n\n        # get logging.Logger instance and set formatter\n        self.logger = logging.getLogger('CloeePyApplication')\n        logHandler = logging.StreamHandler()\n        logHandler.setFormatter(formatter)\n        self.logger.addHandler(logHandler)\n        self.logger.setLevel(self._log_level)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef ajIrreguliers(self):\n        lignes = lignesFichier(self.path(\"irregs.la\"))\n        for lin in lignes:\n            try:\n                irr = self.parse_irreg(lin)\n                self.lemmatiseur._irregs[deramise(irr.gr())].append(irr)\n            except Exception as E:\n                warnings.warn(\"Erreur au chargement de l'irr\u00e9gulier\\n\" + lin + \"\\n\" + str(E))\n                raise E\n\n        for irr in flatten(self.lemmatiseur._irregs.values()):\n            irr.lemme().ajIrreg(irr)", "response": "Ajoute les chargements du fichier data. irr. la"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef ajAssims(self):\n        for lin in lignesFichier(self.path(\"assimilations.la\")):\n            ass1, ass2 = tuple(lin.split(':'))\n            self.lemmatiseur._assims[ass1] = ass2\n            self.lemmatiseur._assimsq[atone(ass1)] = atone(ass2)", "response": "Charge et d\u00e9finit les d\u00e9buts de mots non - assimil\u00e9s associe \u00e0 chacun sa forme assimil\u00e9e.\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncharges et \u00e9tablit une liste qui donne, chaque contraction, forme non contracte qui lui correspond.", "response": "def ajContractions(self):\n        \"\"\" Charge et \u00e9tablit une liste qui donne, chaque contraction, forme non contracte qui lui correspond.\n        \"\"\"\n        for lin in lignesFichier(self.path(\"contractions.la\")):\n            ass1, ass2 = tuple(lin.split(':'))\n            self.lemmatiseur._contractions[ass1] = ass2"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nlecture des lemmes et enregistrement de leurs radicaux", "response": "def lisFichierLexique(self, filepath):\n        \"\"\" Lecture des lemmes, et enregistrement de leurs radicaux\n\n        :param filepath: Chemin du fichier \u00e0 charger\n        :type filepath: str\n        \"\"\"\n        orig = int(filepath.endswith(\"ext.la\"))\n        lignes = lignesFichier(filepath)\n        for ligne in lignes:\n            self.parse_lemme(ligne, orig)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nparse a linea into a curated list of items.", "response": "def parse_lemme(self, linea: str, origin: int=0, _deramise: bool=True):\n        \"\"\" Constructeur de la classe Lemme \u00e0 partir de la ligne linea.\n\n        Exemple de linea avec num\u00e9ro d'\u00e9clat:\n            # c\u0103do|lego|c\u0115c\u012dd|c\u0101s|is, ere, cecidi, casum|687\n            #   0 | 1  | 2   | 3 |     4                | 5\n\n        :param linea: Ligne \u00e0 parser\n        :type linea: str\n        :param origin: 0 for original curated lemma, 1 for automatic import from Gaffiot\n        :type origin: int\n        :param _deramise: Force the deramisation of the normalized graphie\n        :type _deramise: bool\n        \"\"\"\n        eclats = linea.split('|')\n        lg = eclats[0].split('=')\n\n        if _deramise:\n            cle = atone(deramise(lg[0]))\n        else:\n            cle = atone(lg[0])\n\n        # Some lemma have homonyms, we have a number do differentiate them\n        nh = 0\n        if cle[-1].isnumeric():\n            nh = int(cle[-1])\n            grd = cle[:-1]\n        else:\n            grd = cle\n\n        # We setup the accentuated graphie\n        if len(lg) == 1:\n            grq = grd\n        else:\n            grq = lg[1]\n        # Pour l'affichage des dictionnaires, \u00e9limine les doubles de la forme canonique\n        gr = atone(grq.split(\",\")[0])\n        grModele = eclats[1]\n        modele = self.lemmatiseur.modele(grModele)\n\n        # contr\u00f4le de format. la liste doit avoir 6 items\n        if len(eclats) < 6:\n            warnings.warn(\"Ligne mal form\u00e9e : \" + gr + \"\\n ---Dernier champ \" + eclats[-1] + \"\\n ---\" + linea)\n\n        radicaux = DefaultOrderedDict(list)\n        # lecture des radicaux, 2 et 3\n        for i in range(2, 4):\n            if eclats[i]:\n                lrad = eclats[i].split(',')\n                for rad in lrad:\n                    radicaux[i - 1].append(Radical(rad, i - 1))\n\n        # Gros doute sur le fonctionnement ici\n        indMorph = eclats[4]\n        match_renvoi = Lemme.RENVOI.match(indMorph)\n        if match_renvoi is not None:\n            renvoi = match_renvoi.group(1)\n        else:\n            renvoi = \"\"\n\n        pos = \"\"\n        if \"adj.\" in indMorph:\n            pos += 'a'\n        if \"conj\" in indMorph:\n            pos += 'c'\n        if \"excl.\" in indMorph:\n            pos += 'e'\n        if \"interj\" in indMorph:\n            pos += 'i'\n        if \"num.\" in indMorph:\n            pos += 'm'\n        if \"pron.\" in indMorph:\n            pos += 'p'\n        if \"pr\u00e9p\" in indMorph:\n            pos += 'r'\n        if \"adv\" in indMorph:\n            pos += 'd'\n        if \" nom \" in indMorph:\n            pos += 'n'\n        if \"npr.\" in indMorph:\n            pos += 'n'\n        if not pos:\n            pos = modele.pos()  # Je prends le POS du mod\u00e8le\n            if pos == \"d\" and renvoi:\n                pos = \"\"\n                # S'il y a un renvoi (cf.) et que le mod\u00e8le a donn\u00e9 le POS \"d\" (adverbe),\n                # je prendrai le pos du renvoi (les ind\u00e9clinables ont le POS par d\u00e9faut \"d\").\n                # Je ne peux pas le faire maintenant !\n\n        # Nombre d'occurrences\n        if len(eclats[5]):\n            nbOcc = int(eclats[5])\n        else:\n            nbOcc = 1\n\n\n        lemma = Lemme(\n            cle=cle,\n            graphie=gr, graphie_accentuee=grq,\n            modele=modele, radicaux=radicaux,\n            parent=self.lemmatiseur,\n            nombre_homonymie=nh, nbOcc=nbOcc,\n            origin=origin, pos=pos\n        )\n        # We register the lemma for each radical\n        for radNum in lemma._radicaux:\n            for rad in lemma._radicaux[radNum]:\n                rad.set_lemme(lemma)\n        self._register_lemme(lemma)\n        return lemma"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nregisters a modele onto the lemmatizer s _modeles dictionary", "response": "def register_modele(self, modele: Modele):\n        \"\"\" Register a modele onto the lemmatizer\n\n        :param modele: Modele to register\n        \"\"\"\n        self.lemmatiseur._modeles[modele.gr()] = modele"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nregister a lemma into the Lemmatiseur.", "response": "def _register_lemme(self, lemma):\n        \"\"\" Register a lemma into the Lemmatiseur\n\n        :param lemma: Lemma to register\n        :return:\n        \"\"\"\n        if lemma.cle() not in self.lemmatiseur._lemmes:\n            self.ajRadicaux(lemma)\n            self.lemmatiseur._lemmes[lemma.cle()] = lemma"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nlecture des modeles et enregistrement de leurs d\u00e9sinences", "response": "def ajModeles(self):\n        \"\"\" Lecture des mod\u00e8les, et enregistrement de leurs d\u00e9sinences\n        \"\"\"\n        sl = []\n        lines = [line for line in lignesFichier(self.path(\"modeles.la\"))]\n        max = len(lines) - 1\n        for i, l in enumerate(lines):\n            if l.startswith('$'):\n                varname, value = tuple(l.split(\"=\"))\n                self.lemmatiseur._variables[varname] = value\n                continue\n\n            eclats = l.split(\":\")\n            if (eclats[0] == \"modele\" or i == max) and len(sl) > 0:\n                m = self.parse_modele(sl)\n                self.register_modele(m)\n                sl = []\n            sl.append(l)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef parse_irreg(self, l):\n        ecl = l.split(':')\n        grq = ecl[0]\n        exclusif = False\n        if grq.endswith(\"*\"):\n            grq = grq[:-1]\n            exclusif = True\n        return Irreg(\n            graphie_accentuee=grq, graphie=atone(grq),\n            exclusif=exclusif,\n            morphos=listeI(ecl[2]),\n            lemme=self.lemmatiseur.lemme(ecl[1]),\n            parent=self.lemmatiseur\n        )", "response": "Parse a string l into Irreg object"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef atone(string, caps=True):\n    # Fix for unidecode until unidecode stop replace short y by u\n    string = _Y_SHORT_REPLACE.sub(\"y\", string)\n    if caps is True:\n        return unidecode(string)\n    a = \"\"\n    for char in string:\n        if char.isupper():\n            a += char\n        else:\n            a += unidecode(char)\n    return a", "response": "A tone de la forme donn\u00e9e."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nnotes comme communes toutes les voyelles qui ne portent pas de quantit\u00e9.", "response": "def communes(g):\n    \"\"\" Note comme communes toutes les voyelles qui ne portent pas de quantit\u00e9.\n\n    :param string: Cha\u00eene \u00e0 transformer\n    :type string: str\n    :return: Cha\u00eene nettoy\u00e9e\n    :rtype: str\n    \"\"\"\n    if len(g) == 0:\n        return g\n\n    maj = g[0].isupper()\n    g = g.lower()\n    if _VOY_COMMUNES.match(g):\n        g = g.replace(\"a\", \"\u0101\") \\\n             .replace(\"i\", \"\u012b\") \\\n             .replace(\"o\", \"\u014d\")\n        for regex, replace in _VOY_REPLACE:\n            g = regex.sub(replace, g)\n\n    if maj:\n        g = g[0].upper() + g[1:]\n\n    return g"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef deramise(r):\n    return r.replace('J', 'I') \\\n            .replace('j', 'i') \\\n            .replace('v', 'u') \\\n            .replace(\"\u00e6\", \"ae\") \\\n            .replace(\"\u00c6\", \"Ae\") \\\n            .replace(\"\u0153\", \"oe\") \\\n            .replace(\"\u0152\", \"Oe\") \\\n            .replace(\"\u1ee5\", 'u') \\\n            .replace('V', 'U')", "response": "D\u00e9ramise une cha\u00eene \u00e0 transformer\n   "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nregister a command handler that will be invoked when a command is detected. If your handler has a docstring, it will be shown for .help [command]. The function will be invoked with *args set to the list of parameters given (as parsed by shlex.split). You may also include any of these keyword arguments in your signature: message: the original message this was invoked in response to client: the value of CommandSet.client cmdset: this command set If your function returns a string, it will be given back to the user who issued the command. :param name: name of the command. Defaults to __name__ if None. :param hint: hint for the command (shown for .help). :param aliases: aliases for this command.", "response": "def command(self, name: str=None, hint: str=None, aliases: Sequence[str]=list()):\n        \"\"\"\n        Register a command handler that will be invoked when a command is\n        detected. If your handler has a docstring, it will be shown for\n        .help [command]. The function will be invoked with *args set to the\n        list of parameters given (as parsed by shlex.split). You may also\n        include any of these keyword arguments in your signature:\n\n        message:    the original message this was invoked in response to\n        client:     the value of CommandSet.client\n        cmdset:     this command set\n\n        If your function returns a string, it will be given back to the user\n        who issued the command.\n\n        :param name: name of the command. Defaults to __name__ if None.\n        :param hint: hint for the command (shown for .help).\n        :param aliases: aliases for this command.\n        \"\"\"\n        def decorator(fn):\n            _name = name or fn.__name__\n            cmd = _Command(_name, hint, fn)\n            self._commands[_name] = cmd\n            for alias in aliases:\n                self._aliases[alias] = cmd\n            return fn\n        return decorator"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd a callback to an event list so it will be run at this event s firing.", "response": "def add_listener(self, event, callback, single=False, priority=1):\n        \"\"\" Add a callback to an event list so it will be run at this event's\n        firing. If single is True, the event is auto-removed after the first\n        invocation. Priority can be used to jump ahead or behind other\n        callback invocations.\"\"\"\n        event_stack = self._events[event]\n        event_stack.append({\n            \"callback\": callback,\n            \"single\": single,\n            \"priority\": priority\n        })\n        event_stack.sort(key=lambda x: x['priority'])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef remove_listener(self, event, callback, single=None, priority=None):\n        event_stack = self._events[event]\n        for x in event_stack:\n            if x['callback'] == callback and \\\n               (single is None or x['single'] == single) and \\\n               (priority is None or x['priority'] == priority):\n                event_stack.remove(x)\n                break\n        else:\n            raise KeyError('Listener not found for \"%s\": %s' % (event,\n                           callback))", "response": "Removes the event listener matching the same signature used for\n       ."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef fire_event(self, event, *args, **kwargs):\n        remove = []\n        event_stack = self._events[event]\n        for x in event_stack:\n            x['callback'](*args, **kwargs)\n            if x['single']:\n                remove.append(x)\n        for x in remove:\n            event_stack.remove(x)", "response": "Execute the listeners for the specified event passing any arguments that are passed along."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef stop(self):\n        self.elapse = time.clock() - self.st\n        self.records.append(self.elapse)", "response": "Save last elapse time to self. records.\n       "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nprint detailed information about the current record.", "response": "def display_all(self):\n        \"\"\"Print detailed information.\n        \"\"\"\n        print( (\"total elapse %0.6f seconds, last elapse %0.6f seconds, \"\n                \"took %s times measurement\") % (\n                    self.total_elapse, self.elapse, len(self.records)))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _parse_html(html_dump, native=False):\n    # pylint: disable=too-many-locals\n\n    soup = BeautifulSoup(html_dump, \"html.parser\")\n    translations = []\n    for entity in soup.select(\n        \"div.diki-results-left-column > div > div.dictionaryEntity\"\n    ):\n        if not native:\n            meanings = entity.select(\"ol.foreignToNativeMeanings\")\n        else:\n            meanings = entity.select(\"ol.nativeToForeignEntrySlices\")\n        if not meanings:\n            # this can happen when word exists in both polish and english, e.g. 'pet'\n            continue\n        word = tuple(e.get_text().strip() for e in entity.select(\"div.hws h1 span.hw\"))\n        parts = [p.get_text().strip() for p in entity.select(\"span.partOfSpeech\")]\n        parts_list = []\n        for part, m in zip_longest(parts, meanings):\n            meanings = []\n            for elem in m.find_all(\"li\", recursive=False):\n                examples = []\n                if not native:\n                    meaning = [m.get_text().strip() for m in elem.select(\"span.hw\")]\n                    pattern = re.compile(r\"\\s{3,}\")\n                    for e in elem.find_all(\"div\", class_=\"exampleSentence\"):\n                        example = re.split(pattern, e.get_text().strip())\n                        examples.append(example)\n                else:\n                    meaning = [elem.find(\"span\", recursive=False).get_text().strip()]\n                    # When translating to polish 'examples' are just synonyms of translation\n                    synonyms = \", \".join(\n                        sorted(\n                            set(\n                                x.get_text().strip()\n                                for x in elem.select(\"ul > li > span.hw\")\n                            )\n                        )\n                    )\n                    if synonyms:\n                        examples.append([synonyms, None])\n                meanings.append(Meaning(meaning, examples))\n            parts_list.append(PartOfSpeech(part, meanings))\n        translations.append(Translation(word, parts_list))\n    if translations:\n        return translations\n    # if translation wasn't found check if there are any suggestions\n    suggestions = soup.find(\"div\", class_=\"dictionarySuggestions\")\n    if suggestions:\n        raise WordNotFound(suggestions.get_text().strip())\n    raise WordNotFound(\"Nie znaleziono t\u0142umaczenia wpisanej frazy\")", "response": "Parses the given HTML string and returns a list of lists of tuples."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nparses html string from cached html files.", "response": "def _parse_cached(html_dump):\n    \"\"\"Parse html string from cached html files.\n\n    Parameters\n    ----------\n    html_dump : string\n        HTML content\n\n    Returns\n    -------\n    translations : list\n        Translations list.\n    \"\"\"\n    soup = BeautifulSoup(html_dump, \"html.parser\")\n    translations = []\n    for trans in soup.find_all(\"div\", class_=\"translation\"):\n        word = tuple(t.get_text() for t in trans.select(\"div.word > h2\"))\n        trans_list = []\n        for part in trans.find_all(\"div\", class_=\"part-of-speech\"):\n            pn = part.find(\"p\", class_=\"part-name\")\n            if pn:\n                pn = pn.get_text().strip(\"[]\")\n            meanings = []\n            for meaning in part.find_all(\"div\", class_=\"meaning\"):\n                m = [mn.get_text() for mn in meaning.select(\"li > span\")]\n                examples = []\n                for e in meaning.find_all(\"p\"):\n                    examples.append([ex.get_text() for ex in e.find_all(\"span\")])\n                meanings.append(Meaning(m, examples))\n            trans_list.append(PartOfSpeech(pn, meanings))\n        translations.append(Translation(word, trans_list))\n    return translations"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _cache_lookup(word, data_dir, native=False):\n    trans_dir = \"translations\"\n    if native:\n        trans_dir += \"_native\"\n    logger.debug(\"Cache lookup: %s\", word)\n    filename = data_dir.joinpath(trans_dir, \"{}.html\".format(word))\n    if filename.is_file():\n        with open(filename, mode=\"r\") as f:\n            logger.debug(\"Cache found: %s\", word)\n            # TODO: not sure if we should parse data here\n            translation = _parse_cached(f.read())\n            return translation\n    logger.debug(\"Cache miss: %s\", word)\n    return None", "response": "Checks if word is in cache."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _get_words(data_dir):\n    words_file = data_dir.joinpath(\"words.txt\")\n    word_list = []\n    if not words_file.is_file():\n        return word_list\n    with open(words_file, mode=\"r\") as f:\n        for l in f:\n            line = l.rstrip()\n            word_list.append(line)\n    return word_list", "response": "Get list of words from history file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nwriting word to history file.", "response": "def _save_to_history(word, data_dir):\n    \"\"\"Write word to history file.\n\n    Parameters\n    ----------\n    word : str\n        Word to save to history.\n    data_dir : pathlib.Path\n        Directory where history file should be saved.\n\n    data_dir and it's parent directories will be created if needed.\n    \"\"\"\n    if not data_dir.exists():\n        logger.debug(\"Creating DATA DIR: %s\", data_dir.as_posix())\n        data_dir.mkdir(parents=True)\n    if word not in _get_words(data_dir):\n        with open(data_dir.joinpath(\"words.txt\"), mode=\"a+\") as f:\n            logger.debug(\"Adding to history: %s\", word)\n            f.write(word + \"\\n\")"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _create_html_file_content(translations):\n    content = []\n    for i1, t in enumerate(translations):\n        if i1 > 0:\n            content.append(\"<br>\")\n        content.append('<div class=\"translation\">')\n        content.append('<div class=\"word\">')\n        for w in t.word:\n            content.append(\"<h2>{word}</h2>\".format(word=w))\n        content.append(\"</div>\")  # end `word`\n        for i2, t2 in enumerate(t.parts_of_speech):\n            if i2 > 0:\n                content.append(\"<br>\")\n            content.append('<div class=\"part-of-speech\">')\n            if t2.part is not None:\n                content.append('<p class=\"part-name\">[{part}]</p>'.format(part=t2.part))\n            content.append(\"<ol>\")\n            for m in t2.meanings:\n                content.append('<div class=\"meaning\">')\n                mng = [\"<strong><li>\"]\n                for i3, mn in enumerate(m.meaning):\n                    if i3 > 0:\n                        mng.append(\", \")\n                    mng.append(\"<span>{meaning}</span>\".format(meaning=mn))\n                mng.append(\"</li></strong>\")\n                content.append(\"\".join(mng))\n                content.append('<div class=\"examples\">')\n                for e in m.examples:\n                    exmpl = \"<p><span>{ex}</span>\".format(ex=e[0])\n                    if e[1]:\n                        exmpl += \"<br><span>{tr}</span>\".format(tr=e[1])\n                    exmpl += \"</p>\"\n                    content.append(exmpl)\n                content.append(\"</div>\")  # end `examples`\n                content.append(\"</div>\")  # end `meaning`\n            content.append(\"</ol>\")\n            content.append(\"</div>\")  # end `part-of-speech`\n        content.append(\"</div>\")  # end `translation`\n    return \"\\n\".join(content)", "response": "Create html string out of translation dict."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates html file of word translations.", "response": "def _write_html_file(word, translations, data_dir, native=False):\n    \"\"\"Create html file of word translations.\n\n    Parameters\n    ----------\n    word : str\n        Word that was translated.\n    tralnslations : dict\n        Dictionary of word translations.\n    data_dir : pathlib.Path\n        Location where html files are saved.\n    \"\"\"\n    content_str = _create_html_file_content(translations)\n    html_string = HTML_TEMPLATE.replace(\"{% word %}\", word)\n    html_string = html_string.replace(\"{% content %}\", content_str)\n\n    trans_dir = \"translations\"\n    if native:\n        trans_dir += \"_native\"\n    translations_dir = data_dir.joinpath(trans_dir)\n    fname = translations_dir.joinpath(\"{word}.html\".format(word=word))\n    save_file(fname, html_string, mk_parents=True)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates html string of index file.", "response": "def _create_index_content(words):\n    \"\"\"Create html string of index file.\n\n    Parameters\n    ----------\n    words : list of str\n        List of cached words.\n\n    Returns\n    -------\n    str\n        html string.\n    \"\"\"\n    content = [\"<h1>Index</h1>\", \"<ul>\"]\n    for word in words:\n        content.append(\n            '<li><a href=\"translations/{word}.html\">{word}</a></li>'.format(word=word)\n        )\n\n    content.append(\"</ul>\")\n    if not words:\n        content.append(\"<i>Nothing to see here ...yet!</i>\")\n\n    return \"\\n\".join(content)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate index file of cached translations.", "response": "def _write_index_file(data_dir):\n    \"\"\"Create index file of cached translations.\n\n    Parameters\n    ----------\n    data_dir : pathlib.Path\n        Cache directory location.\n    \"\"\"\n    cached_words = [\n        w\n        for w in _get_words(data_dir)\n        if data_dir.joinpath(\"translations/{}.html\".format(w)).is_file()\n    ]\n\n    content_str = _create_index_content(cached_words)\n    html_string = HTML_TEMPLATE.replace(\"{% word %}\", \"Index\")\n    html_string = html_string.replace(\"{% content %}\", content_str)\n\n    filename = data_dir.joinpath(\"index.html\")\n    save_file(filename, html_string, mk_parents=True)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef save_file(filename, data, mk_parents=True):\n    parent = filename.parent\n    if not parent.exists() and mk_parents:\n        logger.debug(\"Creating directory: %s\", parent.as_posix())\n        parent.mkdir(parents=True)\n    with open(filename, mode=\"w\") as f:\n        logger.debug(\"Saving file: %s\", filename.as_posix())\n        f.write(data)", "response": "Save the contents of the file to disk."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _lookup_online(word):\n    URL = \"https://www.diki.pl/{word}\"\n    HEADERS = {\n        \"User-Agent\": (\n            \"Mozilla/5.0 (compatible, MSIE 11, Windows NT 6.3; \"\n            \"Trident/7.0;  rv:11.0) like Gecko\"\n        )\n    }\n\n    logger.debug(\"Looking up online: %s\", word)\n    quoted_word = urllib.parse.quote(word)\n    req = urllib.request.Request(URL.format(word=quoted_word), headers=HEADERS)\n    with urllib.request.urlopen(req) as response:\n        html_string = response.read().decode()\n\n    return html.unescape(html_string)", "response": "Look up word on diki. pl."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ntranslates a word into a new language.", "response": "def translate(word, config, use_cache=True, to_eng=False):\n    \"\"\"Translate a word.\n\n    Parameters\n    ----------\n    word : str\n        Word to translate.\n    config : Config\n        Configuration settings.\n    use_cache : bool, optional\n        Wheter to use cache.\n    to_eng : bool, optional\n        Translate from Polish to English.\n\n    Returns\n    -------\n    translation\n        Translation of a word.\n\n    Raises\n    ------\n    WordNotFound\n        If word can't be found.\n    \"\"\"\n    translation = None\n    data_dir = Path(config[\"data dir\"])\n\n    if use_cache:\n        logger.debug(\"Checking cache: %s\", word)\n        translation = _cache_lookup(word, data_dir, native=to_eng)\n\n    if translation:\n        return translation\n\n    html_dump = _lookup_online(word)\n\n    try:\n        translation = _parse_html(html_dump, native=to_eng)\n    except WordNotFound as exn:\n        logger.error(str(exn))\n        raise exn\n\n    _write_html_file(word, translation, data_dir, native=to_eng)\n    if not to_eng:\n        _save_to_history(word, data_dir)\n        _write_index_file(data_dir)\n\n    return translation"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nopening index in web browser.", "response": "def display_index(config):\n    \"\"\"Open index in web browser.\n\n    Parameters\n    ----------\n    config : Config\n        Configuration settings.\n\n    Raises\n    ------\n    FileNotFoundError\n        If index file doesn't exist.\n    \"\"\"\n    browser = config[\"web browser\"].lower()\n    data_dir = Path(config[\"data dir\"])\n    if browser in webbrowser._browsers:\n        b = webbrowser.get(browser)\n    else:\n        if browser != \"default\":\n            logger.warning(\n                \"Couldn't find '%s' browser. Falling back to default.\", browser\n            )\n        b = webbrowser.get()\n    index_file = data_dir.joinpath(\"index.html\")\n    if not index_file.exists():\n        logger.error(\"File doesn't exist: %s\", index_file.as_posix())\n        raise FileNotFoundError(\"Index file doesn't exist\")\n    else:\n        logger.info(\"Opening %s in '%s'\", index_file.as_posix(), b.name)\n        b.open(index_file.as_uri())"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef wrap_text(translations, linewrap=0):\n    # pylint: disable=too-many-locals\n\n    def wrap(text, width=linewrap, findent=0, sindent=0, bold=False):\n        if width == 0:\n            text = \" \" * findent + text\n        else:\n            text = textwrap.fill(\n                text,\n                width=width,\n                initial_indent=\" \" * findent,\n                subsequent_indent=\" \" * sindent,\n            )\n        # don't use bold when stdout is pipe or redirect\n        if bold and sys.stdout.isatty():\n            text = \"\\033[0;1m\" + text + \"\\033[0m\"\n        return text\n\n    indent = 5\n    result = []\n    for i1, trans in enumerate(translations):\n        if i1 > 0:\n            result.append(\"\\n\")\n        for w in trans.word:\n            result.append(wrap(w, bold=True))\n        for i2, t in enumerate(trans.parts_of_speech):\n            if i2 > 0:\n                result.append(\"\")\n            if t.part:\n                result.append(\"[{part}]\".format(part=t.part))\n            for i3, m in enumerate(t.meanings, 1):\n                if i3 > 1:\n                    result.append(\"\")\n                meaning = \"{index:>3}. {meanings}\".format(\n                    index=i3, meanings=\", \".join(m.meaning)\n                )\n                result.append(wrap(meaning, sindent=indent, bold=True))\n                eindent = indent + 1\n                for e in m.examples:\n                    result.append(\"\")\n                    result.append(wrap(e[0], findent=eindent, sindent=eindent))\n                    if len(e) == 2 and e[1]:\n                        result.append(wrap(e[1], findent=eindent, sindent=eindent + 1))\n    return \"\\n\".join(result)", "response": "Pretty print the text of the given list of word translations."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreads config from a file.", "response": "def read_config(self):\n        \"\"\"\n        Read config from a file.\n\n        Invalid config values will be discarded and defaults used\n        in their place.\n        \"\"\"\n        _config = self.config[\"dikicli\"]\n        # TODO: what if file doesn't exist?\n        if self.config_file.is_file():\n            logger.debug(\"Reading config file: %s\", self.config_file.as_posix())\n            with open(self.config_file, mode=\"r\") as f:\n                self.config.read_file(f)\n\n            # DIKI_DATA_DIR should always take precedence if it's set\n            if \"DIKI_DATA_DIR\" in os.environ:\n                _config[\"data dir\"] = DATA_DIR.as_posix()\n\n            w = _config.get(\"linewrap\")\n            try:\n                w = int(w)\n                if w < 0:\n                    raise ValueError()\n            except ValueError:\n                logger.warning(\"Config: Invalid linewrap value. Using default.\")\n                _config[\"linewrap\"] = self.default_config[\"linewrap\"]\n\n            c = _config.get(\"colors\")\n            if c.lower() not in [\"yes\", \"no\", \"true\", \"false\"]:\n                logger.warning(\"Config: Invalid colors value. Using default.\")\n                _config[\"colors\"] = self.default_config[\"colors\"]"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create_default_config(self):\n        filename = self.config_file.as_posix()\n        logger.info(\"Creating default config file: %s\", filename)\n        config_dir = self.config_file.parent\n        if not config_dir.exists():\n            config_dir.mkdir(parents=True)\n        if self.config_file.is_file():\n            backup = filename + \".old\"\n            logger.info(\"Saving config file backup at: %s\", backup)\n            shutil.copy(filename, backup)\n        with open(self.config_file, mode=\"w\") as f:\n            config_string = CONFIG_TEMPLATE.format(\n                data_dir=self.default_config[\"data dir\"],\n                linewrap=self.default_config[\"linewrap\"],\n                colors=self.default_config[\"colors\"],\n                browser=self.default_config[\"web browser\"],\n            )\n            f.write(config_string)\n        return filename", "response": "Write default config file to disk."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef arc_length(start_a=[0.0], end_a=[0.0], radius=0.0):\n    '''Return Euclidean length of arc.\n    '''\n    assert isinstance(start_a, list)\n    assert isinstance(end_a, list)\n    l_angle = len(start_a)\n    assert l_angle > 0\n    assert l_angle == len(end_a)\n    for i in start_a:\n        assert isinstance(i, float)\n        assert abs(i) <= 2*pi\n    for i in end_a:\n        assert isinstance(i, float)\n        assert abs(i) <= 2*pi\n    assert isinstance(radius, float)\n    # Allow negative radius\n\n    full = pi * radius*2\n    diff = angle_diff(start_a, end_a, True)\n    vec = [full * abs(d)/(2*pi) for d in diff]\n    return sqrt(sum([v**2 for v in vec]))", "response": "Return Euclidean length of arc."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nsplit the arguments to the autopaginate tag and formats them correctly.", "response": "def do_autopaginate(parser, token):\n    \"\"\"\n    Splits the arguments to the autopaginate tag and formats them correctly.\n    \"\"\"\n    split = token.split_contents()\n    as_index = None\n    context_var = None\n    for i, bit in enumerate(split):\n        if bit == 'as':\n            as_index = i\n            break\n    if as_index is not None:\n        try:\n            context_var = split[as_index + 1]\n        except IndexError:\n            raise template.TemplateSyntaxError(\"Context variable assignment \" +\n                \"must take the form of {%% %r object.example_set.all ... as \" +\n                \"context_var_name %%}\" % split[0])\n        del split[as_index:as_index + 2]\n    if len(split) == 2:\n        return AutoPaginateNode(split[1])\n    elif len(split) == 3:\n        return AutoPaginateNode(split[1], paginate_by=split[2], \n            context_var=context_var)\n    elif len(split) == 4:\n        try:\n            orphans = int(split[3])\n        except ValueError:\n            raise template.TemplateSyntaxError(u'Got %s, but expected integer.'\n                % split[3])\n        return AutoPaginateNode(split[1], paginate_by=split[2], orphans=orphans,\n            context_var=context_var)\n    else:\n        raise template.TemplateSyntaxError('%r tag takes one required ' +\n            'argument and one optional argument' % split[0])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef paginate(context, window=DEFAULT_WINDOW):\n    try:\n        paginator = context['paginator']\n        page_obj = context['page_obj']\n        page_range = paginator.page_range\n        # First and last are simply the first *n* pages and the last *n* pages,\n        # where *n* is the current window size.\n        first = set(list(page_range)[:window])\n        last = set(list(page_range)[-window:])\n        # Now we look around our current page, making sure that we don't wrap\n        # around.\n        current_start = page_obj.number-1-window\n        if current_start < 0:\n            current_start = 0\n        current_end = page_obj.number-1+window\n        if current_end < 0:\n            current_end = 0\n        current = set(list(page_range)[current_start:current_end])\n        pages = []\n        # If there's no overlap between the first set of pages and the current\n        # set of pages, then there's a possible need for elusion.\n        if len(first.intersection(current)) == 0:\n            first_list = list(first)\n            first_list.sort()\n            second_list = list(current)\n            second_list.sort()\n            pages.extend(first_list)\n            diff = second_list[0] - first_list[-1]\n            # If there is a gap of two, between the last page of the first\n            # set and the first page of the current set, then we're missing a\n            # page.\n            if diff == 2:\n                pages.append(second_list[0] - 1)\n            # If the difference is just one, then there's nothing to be done,\n            # as the pages need no elusion and are correct.\n            elif diff == 1:\n                pass\n            # Otherwise, there's a bigger gap which needs to be signaled for\n            # elusion, by pushing a None value to the page list.\n            else:\n                pages.append(None)\n            pages.extend(second_list)\n        else:\n            unioned = list(first.union(current))\n            unioned.sort()\n            pages.extend(unioned)\n        # If there's no overlap between the current set of pages and the last\n        # set of pages, then there's a possible need for elusion.\n        if len(current.intersection(last)) == 0:\n            second_list = list(last)\n            second_list.sort()\n            diff = second_list[0] - pages[-1]\n            # If there is a gap of two, between the last page of the current\n            # set and the first page of the last set, then we're missing a \n            # page.\n            if diff == 2:\n                pages.append(second_list[0] - 1)\n            # If the difference is just one, then there's nothing to be done,\n            # as the pages need no elusion and are correct.\n            elif diff == 1:\n                pass\n            # Otherwise, there's a bigger gap which needs to be signaled for\n            # elusion, by pushing a None value to the page list.\n            else:\n                pages.append(None)\n            pages.extend(second_list)\n        else:\n            differenced = list(last.difference(current))\n            differenced.sort()\n            pages.extend(differenced)\n        to_return = {\n            'pages': pages,\n            'page_obj': page_obj,\n            'paginator': paginator,\n            'is_paginated': paginator.count > paginator.per_page,\n        }\n        if 'request' in context:\n            getvars = context['request'].GET.copy()\n            if 'page' in getvars:\n                del getvars['page']\n            if len(getvars.keys()) > 0:\n                to_return['getvars'] = \"&%s\" % getvars.urlencode()\n            else:\n                to_return['getvars'] = ''\n        return to_return\n    except KeyError, AttributeError:\n        return {}", "response": "Renders the pagination. html template for the available pages."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef linebuffered_stdout():\n    if sys.stdout.line_buffering:\n        return sys.stdout\n    orig = sys.stdout\n    new = type(orig)(orig.buffer, encoding=orig.encoding, errors=orig.errors,\n                     line_buffering=True)\n    new.mode = orig.mode\n    return new", "response": "Returns a copy of sys. stdout with line buffering enabled."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef ignore_broken_pipe():\n    for f in sys.stdin, sys.stdout, sys.stderr:\n        try:\n            f.close()\n        except BrokenPipeError:\n            pass", "response": "This function closes any broken pipe exceptions and ignores any exception that is not part of the interpretor."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_user_by_key(app, key):\n    if not hasattr(app, 'example_user_db'):\n        app.example_user_db = {}\n\n    if key in app.example_user_db:\n        return app.example_user_db[key]\n    return None", "response": "This method returns the user object by its public key."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef load_user_from_request(req):\n    load_jws_from_request(req)\n    if not hasattr(req, 'jws_header') or req.jws_header is None or not \\\n            'iat' in req.jws_payload:\n        current_app.logger.info(\"invalid jws request.\")\n        return None\n\n    ln = current_app.bitjws.get_last_nonce(current_app,\n                                           req.jws_header['kid'],\n                                           req.jws_payload['iat'])\n\n    if (ln is None or 'iat' not in req.jws_payload or\n            req.jws_payload['iat'] * 1000 <= ln):\n        current_app.logger.info(\"invalid nonce. lastnonce: %s\" % ln)\n        return None\n\n    rawu = current_app.bitjws.get_user_by_key(current_app,\n                                              req.jws_header['kid'])\n    if rawu is None:\n        return None\n    current_app.logger.info(\"logging in user: %s\" % rawu)\n    return FlaskUser(rawu)", "response": "This function loads a user based on the request."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating a signed bitjws response using the supplied payload.", "response": "def create_response(self, payload):\n        \"\"\"\n        Create a signed bitjws response using the supplied payload.\n        The response content-type will be 'application/jose'.\n\n        :param payload: The response content. Must be json-serializable.\n        :return: The signed Response with headers.\n        :rtype: flask.Response\n        \"\"\"\n        signedmess = bitjws.sign_serialize(self._privkey, requrl='/response',\n                                           iat=time.time(), data=payload)\n        return Response(signedmess, mimetype='application/jose')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef fade_out(self, duration=3, group=0):\n        self.on(group)\n        super(WhiteLight, self).fade_out(duration, group=group)\n        self.off(group)", "response": "Turns off the light by gradually fading it out."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef fade_in(self, duration=3, group=0):\n        self.on(group)\n        super(WhiteLight, self).fade_in(duration, group=group)", "response": "Turns on the light by gradually fading it in."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef dumplist(args):\n\n  from .query import Database\n  db = Database()\n\n  r = db.objects(\n      protocol=args.protocol,\n      purposes=args.purpose,\n      model_ids=(args.client,),\n      groups=args.group,\n      classes=args.sclass\n  )\n\n  output = sys.stdout\n  if args.selftest:\n    from bob.db.utils import null\n    output = null()\n\n  for f in r:\n    output.write('%s\\n' % (f.make_path(args.directory, args.extension),))\n\n  return 0", "response": "Dumps a list of files based on your criteria"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nchecking existence of files based on your criteria", "response": "def checkfiles(args):\n  \"\"\"Checks existence of files based on your criteria\"\"\"\n\n  from .query import Database\n  db = Database()\n\n  r = db.objects()\n\n  # go through all files, check if they are available on the filesystem\n  good = []\n  bad = []\n  for f in r:\n    if os.path.exists(f.make_path(args.directory, args.extension)):\n      good.append(f)\n    else:\n      bad.append(f)\n\n  # report\n  output = sys.stdout\n  if args.selftest:\n    from bob.db.utils import null\n    output = null()\n\n  if bad:\n    for f in bad:\n      output.write('Cannot find file \"%s\"\\n' % (f.make_path(args.directory, args.extension),))\n    output.write('%d files (out of %d) were not found at \"%s\"\\n' % \\\n      (len(bad), len(r), args.directory))\n\n  return 0"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a list of file database identifiers given the path stems", "response": "def reverse(args):\n  \"\"\"Returns a list of file database identifiers given the path stems\"\"\"\n\n  from .query import Database\n  db = Database()\n\n  output = sys.stdout\n  if args.selftest:\n    from bob.db.utils import null\n    output = null()\n\n  r = db.reverse(args.path)\n  for f in r: output.write('%d\\n' % f.id)\n\n  if not r: return 1\n\n  return 0"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a list of fully formed paths or stems given some file id", "response": "def path(args):\n  \"\"\"Returns a list of fully formed paths or stems given some file id\"\"\"\n\n  from .query import Database\n  db = Database()\n\n  output = sys.stdout\n  if args.selftest:\n    from bob.db.utils import null\n    output = null()\n\n  r = db.paths(args.id, prefix=args.directory, suffix=args.extension)\n  for path in r: output.write('%s\\n' % path)\n\n  if not r: return 1\n\n  return 0"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef app_restart(cls):\n        '''\n        Restart a frozen esky app\n        Can also restart if the program is being run as a script\n        passes restarted as an argument to the restarted app\n        '''\n        logging.debug('In restarter')\n        executable = sys.executable.split(os.sep)[-1]\n        if os.name == 'nt':\n            logging.info('executable is is %s' % executable)\n            # restart works here when testing compiled version only\n            if executable != 'python.exe':\n                boot_strap_path = cls.esky_bootstrap_path()\n                bootstrap_file = os.path.join(boot_strap_path, executable)\n                logging.info('Bootstrap file for restart: %s' % bootstrap_file)\n\n                subprocess.Popen(\n                    [os.path.join(bootstrap_file, bootstrap_file), 'restarted'])", "response": "Restart a frozen esky app"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a list of nmodels TermSets representing consistent extensions of the system.", "response": "def get_consistent_labelings(instance,nmodels=0,exclude=[]):\n    '''\n    [consistent_labelings(instance,nmodels,exclude)] returns a list containing\n    [nmodels] TermSet objects representing consistent extensions of the system\n    described by the TermSet [instance]. The list [exclude] should contain TermSet objects\n    representing (maybe partial) solutions that are to be avoided. If [nmodels] equals [0]\n    then the list contain all feasible models.\n    '''\n    #inputs = get_reductions(instance)\n    inst   = instance.to_file()\n    prg    = [ consistency_prg, inst, exclude_sol(exclude) ]\n    co     = str(nmodels)\n    solver = GringoClasp(clasp_options=co)\n    models = solver.run(prg)\n    os.unlink(inst)\n    os.unlink(prg[2])\n    return models"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_minimal_inconsistent_cores(instance,nmodels=0,exclude=[]):\n    '''\n    [compute_mic(instance,nmodels,exclude)] returns a list containing\n    [nmodels] TermSet objects representing subset minimal inconsistent cores of the system\n    described by the TermSet [instance]. The list [exclude] should contain TermSet objects\n    representing (maybe partial) solutions that are to be avoided. If [nmodels] equals [0]\n    then the list contain all feasible models.\n    '''\n    inputs  = get_reductions(instance)\n    prg     = [ dyn_mic_prg, inputs.to_file(), instance.to_file(), exclude_sol(exclude) ]\n    options ='--heuristic=Vmtf '+str(nmodels)\n    solver  = GringoClasp(clasp_options=options)\n    models  = solver.run(prg, collapseTerms=True, collapseAtoms=False)\n    os.unlink(prg[1])\n    os.unlink(prg[2])\n    os.unlink(prg[3])\n    return models", "response": "Compute minimal inconsistent cores of a system."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_predictions_under_minimal_repair(instance, repair_options, optimum):\n    '''\n    Computes the set of signs on edges/vertices that can be cautiously\n    derived from [instance], minus those that are a direct consequence\n    of obs_[ev]label predicates\n    '''\n    inst    = instance.to_file()\n    repops  = repair_options.to_file()\n    prg     = [ inst, repops, prediction_core_prg, repair_cardinality_prg ]\n    options = '--project --enum-mode cautious --opt-mode=optN --opt-bound='+str(optimum)\n    solver  = GringoClasp(clasp_options=options)\n    models  = solver.run(prg, collapseTerms=True, collapseAtoms=False)\n    os.unlink(inst)\n    os.unlink(repops)\n    return whatsnew(instance,models[0])", "response": "Computes the set of signs on edges and vertices that can be cautiously\n    derived from [ instance ] minus those that can be cautiously\n    derived from [ instance ] minus those that can be cautiously\n    derived from [ instance ]."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef whatsnew(instance,pred):\n    '''\n    [whatsnew(instance,pred)] is a TermSet equal to [pred] where all predicates\n    vlabel and elabel which have a corresponding obs_vlabel and obs_elabel in\n    [instance] have been deleted. This function is meant to see which of the invariants\n    are not a direct consequence of the observations.\n    '''\n    accu = TermSet(pred)\n    for t in instance:\n\n        if t.pred() == 'obs_vlabel':\n            [_,e,v,s] = t.explode()\n            accu.discard(Term('vlabel',[e,v,s]))\n        elif t.p('obs_elabel'):\n            [_,j,i,s] = t.explode()\n            accu.discard(Term('elabel',[j,i,s]))\n    return accu", "response": "This function returns a TermSet that contains only the ones which have a corresponding vlabel and elabel and have not been deleted."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncomputes the set of signs on edges and vertices that can be cautiously derived from [ instance ] minus those that are direct consequence", "response": "def get_predictions_under_consistency(instance):\n    '''\n    Computes the set of signs on edges/vertices that can be cautiously\n    derived from [instance], minus those that are a direct consequence\n    of obs_[ev]label predicates\n    '''\n    inst   = instance.to_file()\n    prg    = [ prediction_prg, inst, exclude_sol([]) ]\n    solver = GringoClasp(clasp_options='--project --enum-mode cautious')\n    models = solver.run(prg, collapseTerms=True, collapseAtoms=False)\n    os.unlink(inst)\n    os.unlink(prg[2])\n    return whatsnew(instance,models[0])"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nstarts server with iperf", "response": "def start_server(self, protocol='TCP', port=5001, mss=None, window=None):\n        \"\"\"iperf -s -D --mss mss\n        \"\"\"\n        cmd = ['iperf', '-s', '-p', str(port)]\n        if not cmp(protocol, 'UDP'):\n            cmd.append('-u')\n        if mss:\n            cmd.extend(['-M', str(mss)])\n        if window:\n            cmd.extend(['-w', str(window)])\n        pid = utils.create_deamon(cmd)\n        data = dict()\n        data['pid'] = pid\n        return data"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_external_model(class_object):\n    class_abstract = class_object.CodenerixMeta.abstract\n    if class_abstract is not None:\n        for class_related in class_object._meta.related_objects:\n            if issubclass(class_related.related_model, class_abstract):\n                return class_related.related_model\n    return None", "response": "Given a class object returns the external model that is related to it"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_external_method(class_object, method_name, *args, **kwargs):\n    related_model = get_external_model(class_object)\n    if related_model is not None:\n        f = getattr(related_model, method_name, None)\n        if f:\n            instance = related_model()\n            return f(instance, *args, **kwargs)\n        else:\n            return None\n    return None", "response": "Given a class object a name for a method and its arguments returns the method that was executed."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the language to be used to search the database contents", "response": "def get_language_database():\n    '''\n    Return the language to be used to search the database contents\n    '''\n    lang = None\n    language = get_language()\n    if language:\n        for x in settings.LANGUAGES_DATABASES:\n            if x.upper() == language.upper():\n                lang = language\n                break\n\n    if lang is None:\n        lang = settings.LANGUAGES_DATABASES[0]\n    return lang.lower()"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a nicely formatted string for the given dataframe.", "response": "def df_string(df, percentage_columns=(), format_map=None, **kwargs):\n    \"\"\"Return a nicely formatted string for the given dataframe.\n\n    Arguments\n    ---------\n    df : pandas.DataFrame\n        A dataframe object.\n    percentage_columns : iterable\n        A list of cloumn names to be displayed with a percentage sign.\n\n    Returns\n    -------\n    str\n        A nicely formatted string for the given dataframe.\n\n    Example\n    -------\n    >>> import pandas as pd\n    >>> df = pd.DataFrame([[8,'a'],[5,'b']],[1,2],['num', 'char'])\n    >>> print(df_string(df))\n       num char\n    1    8    a\n    2    5    b\n    \"\"\"\n    formatters_map = {}\n    for col, dtype in df.dtypes.iteritems():\n        if col in percentage_columns:\n            formatters_map[col] = '{:,.2f} %'.format\n        elif dtype == 'float64':\n            formatters_map[col] = '{:,.2f}'.format\n    if format_map:\n        for key in format_map:\n            formatters_map[key] = format_map[key]\n    return df.to_string(formatters=formatters_map, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef big_dataframe_setup():   # pragma: no cover\n    pd.set_option('display.max_colwidth', sys.maxsize)\n    pd.set_option('max_colwidth', sys.maxsize)\n    # height has been deprecated.\n    # pd.set_option('display.height', sys.maxsize)\n    pd.set_option('display.max_rows', sys.maxsize)\n    pd.set_option('display.width', sys.maxsize)\n    pd.set_option('display.colheader_justify', 'center')\n    pd.set_option('display.column_space', sys.maxsize)\n    pd.set_option('display.max_seq_items', sys.maxsize)\n    pd.set_option('display.expand_frame_repr', True)", "response": "Sets pandas to display really big data frames."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef df_to_html(df, percentage_columns=None):  # pragma: no cover\n    big_dataframe_setup()\n    try:\n        res = '<br><h2> {} </h2>'.format(df.name)\n    except AttributeError:\n        res = ''\n    df.style.set_properties(**{'text-align': 'center'})\n    res += df.to_html(formatters=_formatters_dict(\n        input_df=df,\n        percentage_columns=percentage_columns\n    ))\n    res += '<br>'\n    return res", "response": "Return a nicely formatted HTML code string for the given dataframe."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef parts(xs, number = None, length = None):\n    if number is not None and type(number) is not int:\n        raise PartsError(\"Number of parts must be an integer.\")\n\n    if length is not None:\n        if type(length) is not int: \n            if type(length) is not list or (not all([type(l) is int for l in length])):\n                raise PartsError(\"Length parameter must be an integer or list of integers.\")\n\n    if number is not None and length is None:\n        number = max(1, min(len(xs), number)) # Number should be reasonable.\n        length = len(xs) // number\n        i = 0\n        # Produce parts by updating length after each part to ensure\n        # an even distribution.\n        while number > 0 and i < len(xs):\n            number -= 1\n            if number == 0:\n                yield xs[i:]\n                break\n            else:\n                yield xs[i:i + length]\n                i += length\n                length = (len(xs) - i) // number\n    elif number is None and length is not None:\n        if type(length) is int:\n            length = max(1, length)\n            for i in range(0, len(xs), length): # Yield parts of specified length.\n                yield xs[i:i + length]\n        else: # Length is a list of integers.\n            xs_index = 0\n            len_index = 0\n            while xs_index < len(xs):\n                if xs_index + length[len_index] <= len(xs):\n                    yield xs[xs_index:xs_index + length[len_index]]\n                    xs_index += length[len_index]\n                    len_index += 1\n                else:\n                    raise PartsError(\"Cannot return part of requested length; list too short.\")\n    elif number is not None and length is not None:\n        if type(length) is int:\n            if length * number != len(xs):\n                raise PartsError(\"List cannot be split into \" + str(number) + \" parts each of length \" + str(length) + \".\")\n            length = max(1, length)\n            for i in range(0, len(xs), length): # Yield parts of specified length.\n                yield xs[i:i + length]\n        else: # Length is a list of integers.\n            if len(length) == number:\n                xs_index = 0\n                len_index = 0\n                while xs_index < len(xs):\n                    if xs_index + length[len_index] <= len(xs):\n                        yield xs[xs_index:xs_index + length[len_index]]\n                        xs_index += length[len_index]\n                        len_index += 1\n                    else:\n                        raise PartsError(\"Cannot return part of requested length; list too short.\")\n            else:\n                raise PartsError(\"Number of parts does not match number of part lengths specified in input.\")\n    else: # Neither is specified.\n        raise PartsError(\"Must specify number of parts or length of each part.\")", "response": "Split a list into several parts."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef All(*validators):\n    @wraps(All)\n    def built(value):\n        for validator in validators:\n            value = validator(value)\n        return value\n    return built", "response": "A decorator that combines all the given validator callables into one."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef Any(*validators):\n    @wraps(Any)\n    def built(value):\n        error = None\n        for validator in validators:\n            try:\n                return validator(value)\n            except Error as e:\n                error = e\n        raise error\n    return built", "response": "A decorator that returns a value that can be used as a base for the given enumeration."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nwraps the given validator callable only using it for the given value if it is not None.", "response": "def Maybe(validator):\n    \"\"\"\n    Wraps the given validator callable, only using it for the given value if it\n    is not ``None``.\n    \"\"\"\n    @wraps(Maybe)\n    def built(value):\n        if value != None:\n            return validator(value)\n    return built"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef Msg(validator, message):\n    @wraps(Msg)\n    def built(value):\n        try:\n            return validator(value)\n        except Error as e:\n            e.message = message\n            raise e\n    return built", "response": "Wraps a given validator callable replacing any error messages raised."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate a validator callable that replaces None with the specified default value.", "response": "def Default(default):\n    \"\"\"\n    Creates a validator callable that replaces ``None`` with the specified\n    default value.\n    \"\"\"\n    @wraps(Default)\n    def built(value):\n        if value == None:\n            return default\n        return value\n    return built"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef Eq(value, message=\"Not equal to {!s}\"):\n    @wraps(Eq)\n    def built(_value):\n        if _value != value:\n            raise Error(message.format(value))\n        return _value\n    return built", "response": "Returns a validator that compares the given value to\n   ."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef Type(expected, message=\"Not of type {}\"):\n    @wraps(Type)\n    def built(value):\n        if type(value) != expected:\n            raise Error(message.format(expected.__name__))\n        return value\n    return built", "response": "Returns a validator that checks that the given value to\n    is of the given type."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef Instance(expected, message=\"Not an instance of {}\"):\n    @wraps(Instance)\n    def built(value):\n        if not isinstance(value, expected):\n            raise Error(message.format(expected.__name__))\n        return value\n    return built", "response": "Returns a validator that checks if the given value is an instance of the given expected class."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a validator that attempts to coerce the given value to the specified type.", "response": "def Coerce(type, message=\"Not a valid {} value\"):\n    \"\"\"\n    Creates a validator that attempts to coerce the given value to the\n    specified ``type``. Will raise an error if the coercion fails.\n\n    A custom message can be specified with ``message``.\n    \"\"\"\n    @wraps(Coerce)\n    def built(value):\n        try:\n            return type(value)\n        except (TypeError, ValueError) as e:\n            raise Error(message.format(type.__name__))\n    return built"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef List(validator):\n    @wraps(List)\n    def built(value):\n        if not hasattr(value, '__iter__'):\n            raise Error(\"Must be a list\")\n\n        invalid = Invalid()\n        for i, item in enumerate(value):\n            try:\n                value[i] = validator(item)\n            except Invalid as e:\n                for error in e:\n                    error.path.insert(0, i)\n                    invalid.append(error)\n            except Error as e:\n                e.path.insert(0, i)\n                invalid.append(e)\n\n        if len(invalid):\n            raise invalid\n        return value\n    return built", "response": "Returns a validator that runs the given validator on every item in a list of items."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates a validator that attempts to convert the given value to a boolean or raises an error. The following rules are used: ``None`` is converted to ``False``. ``int`` values are ``True`` except for ``0``. ``str`` values converted in lower- and uppercase: * ``y, yes, t, true`` * ``n, no, f, false``", "response": "def Boolean():\n    \"\"\"\n    Creates a validator that attempts to convert the given value to a boolean\n    or raises an error. The following rules are used:\n\n    ``None`` is converted to ``False``.\n\n    ``int`` values are ``True`` except for ``0``.\n\n    ``str`` values converted in lower- and uppercase:\n\n    * ``y, yes, t, true``\n    * ``n, no, f, false``\n    \"\"\"\n    @wraps(Boolean)\n    def built(value):\n        # Already a boolean?\n        if isinstance(value, bool):\n            return value\n\n        # None\n        if value == None:\n            return False\n\n        # Integers\n        if isinstance(value, int):\n            return not value == 0\n\n        # Strings\n        if isinstance(value, str):\n            if value.lower() in { 'y', 'yes', 't', 'true' }:\n                return True\n            elif value.lower() in { 'n', 'no', 'f', 'false' }:\n                return False\n\n        # Nope\n        raise Error(\"Not a boolean value.\")\n    return built"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a validator that checks if the given numeric value is in the specified range inclusive.", "response": "def Range(min=None, max=None, min_message=\"Must be at least {min}\", max_message=\"Must be at most {max}\"):\n    \"\"\"\n    Creates a validator that checks if the given numeric value is in the\n    specified range, inclusive.\n\n    Accepts values specified by ``numbers.Number`` only, excluding booleans.\n\n    The error messages raised can be customized with ``min_message`` and\n    ``max_message``. The ``min`` and ``max`` arguments are formatted.\n    \"\"\"\n    @wraps(Range)\n    def built(value):\n        if not isinstance(value, numbers.Number) or isinstance(value, bool):\n            raise Error(\"Not a number\")\n        if min is not None and min > value:\n            raise Error(min_message.format(min=min, max=max))\n        if max is not None and value > max:\n            raise Error(max_message.format(min=min, max=max))\n        return value\n    return built"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a validator that checks if the given value s length is in the specified range inclusive.", "response": "def Length(min=None, max=None, min_message=\"Must have a length of at least {min}\", max_message=\"Must have a length of at most {max}\"):\n    \"\"\"\n    Creates a validator that checks if the given value's length is in the\n    specified range, inclusive. (Returns the original value.)\n\n    See :func:`.Range`.\n    \"\"\"\n    validator = Range(min, max, min_message, max_message)\n    @wraps(Length)\n    def built(value):\n        if not hasattr(value, '__len__'):\n            raise Error(\"Does not have a length\")\n        validator(len(value))\n        return value\n    return built"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a validator that validates the given string is not empty. Will throw an error for non - string types.", "response": "def NotEmpty():\n    \"\"\"\n    Creates a validator that validates the given string is not empty. Will\n    raise an error for non-string types.\n    \"\"\"\n    @wraps(NotEmpty)\n    def built(value):\n        if not isinstance(value, six.string_types) or not value:\n            raise Error(\"Must not be empty\")\n        return value\n    return built"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating a UUID validator. Will raise an error for non - string types and non - UUID values.", "response": "def Uuid(to_uuid=True):\n    \"\"\"\n    Creates a UUID validator. Will raise an error for non-string types and\n    non-UUID values.\n\n    The given value will be converted to an instance of ``uuid.UUID`` unless\n    ``to_uuid`` is ``False``.\n    \"\"\"\n    @wraps(Uuid)\n    def built(value):\n        invalid = Error(\"Not a valid UUID\")\n\n        if isinstance(value, uuid.UUID):\n            return value\n        elif not isinstance(value, six.string_types):\n            raise invalid\n\n        try:\n            as_uuid = uuid.UUID(value)\n        except (ValueError, AttributeError) as e:\n            raise invalid\n\n        if to_uuid:\n            return as_uuid\n        return value\n    return built"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef counterpart_found(string, counterpart, options, rc_so_far):\n    format = \"%s\" if options.no_newline else \"%s\\n\"\n    sys.stdout.write(format % (counterpart))\n    return rc_so_far or 0", "response": "The sunny - day action is to echo the counterpart to stdout."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ntake action determined by options. else_action and returns the errno that is supposed to be returned in this case.", "response": "def no_counterpart_found(string, options, rc_so_far):\n    \"\"\"Takes action determined by options.else_action.  Unless told to\n    raise an exception, this function returns the errno that is supposed\n    to be returned in this case.\n\n    :param string: The lookup string.\n    :param options: ArgumentParser or equivalent to provide\n        options.else_action, options.else_errno, options.no_newline\n    :param rc_so_far: Becomes set to the value set in options.\n\n    \"\"\"\n    logger.debug(\"options.else_action: %s\", options.else_action)\n    if options.else_action == \"passthrough\":\n        format_list = [string]\n        output_fd = sys.stdout\n    elif options.else_action == \"exception\":\n        raise KeyError(\"No counterpart found for: %s\" % (string))\n    elif options.else_action == \"error\":\n        format_list = [\"# No counterpart found for: %s\" % (string)]\n        output_fd = sys.stderr\n    if not options.no_newline:\n        format_list.append(\"\\n\")\n    output_fd.write(\"\".join(format_list))\n    return options.else_errno"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_counterpart_mapping(config_file=None, skip_home=False):\n    file_skip_list = ([ConfigFromFile.home_rc_file_path]\n                      if skip_home else [])\n    config = ConfigFromFile(config_file, [], skip_file_read=file_skip_list)\n    return CounterpartMapping(map_config=config._parser)", "response": "This function loads the CounterpartMapping from a config file et al."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef map_counterpart(string, config_file=None):\n    skip_home_flag = config_file is not None\n    mapping = get_counterpart_mapping(config_file, skip_home_flag)\n    return mapping[string]", "response": "One - step look - up ; returns a counterpart for the given string"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _generate_input(options):\n    if options.input:\n        fp = open(options.input) if options.input != \"-\" else sys.stdin\n        for string in fp.readlines():\n            yield string\n    if options.strings:\n        for string in options.strings:\n            yield string", "response": "Generator that yields the input strings from any given file one string per line sends\n    any strings provided on the command line."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef register_options(this_class, argparser):\n        default_path = this_class.rc_file_basename\n        default_basename = os.path.basename(default_path)\n        argparser.add_argument('-c', \"--config-file\",\n                               default=default_path,\n                               help=(\"Configuration file to use for lookups \" +\n                                     \"(replaces DEFAULT=%s \" % (default_path) +\n                                     \"but not ~/%s)\" % (default_basename)))", "response": "This method is called by the class method to register the options specific to the class."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _check_and_handle_includes(self, from_file):\n        logger.debug(\"Check/handle includes from %s\", from_file)\n        try:\n            paths = self._parser.get(\"INCLUDE\", \"paths\")\n        except (config_parser.NoSectionError,\n                config_parser.NoOptionError) as exc:\n            logger.debug(\"_check_and_handle_includes: EXCEPTION: %s\", exc)\n            return\n        paths_lines = [p.strip() for p in paths.split(\"\\n\")]\n        logger.debug(\"paths = %s (wanted just once; CLEARING)\", paths_lines)\n        self._parser.remove_option(\"INCLUDE\", \"paths\")\n        for f in paths_lines:\n            abspath = (f if os.path.isabs(f) else\n                       os.path.abspath(\n                           os.path.join(os.path.dirname(from_file), f)))\n            use_path = os.path.normpath(abspath)\n            if use_path in self._parsed_files:\n                raise RecursionInConfigFile(\"In %s: %s already read\",\n                                            from_file, use_path)\n            self._parsed_files.append(use_path)\n            self._handle_rc_file(use_path)", "response": "Check if the file is in the INCLUDE section and if so handle it."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nextracts all imports from a python script", "response": "def extract_imports(script):\n    \"\"\"Extract all imports from a python script\"\"\"\n    if not os.path.isfile(script):\n        raise ValueError('Not a file: %s' % script)\n    parse_tree = parse_python(script)\n    result = find_imports(parse_tree)\n    result.path = script\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncombine featureCounts output files for multiple samples.", "response": "def combine_counts(\n    fns,\n    define_sample_name=None,\n):\n    \"\"\"\n    Combine featureCounts output files for multiple samples.\n\n    Parameters\n    ----------\n    fns : list of strings \n        Filenames of featureCounts output files to combine.\n\n    define_sample_name : function\n        A function mapping the featureCounts output filenames to sample names.\n        If this is not provided, the header of the last column in the\n        featureCounts output will be used as the sample name.\n\n    Returns\n    -------\n    combined_counts :  pandas.DataFrame\n        Combined featureCount counts.\n    \n    \"\"\"\n    counts = []\n    for fn in fns:\n        df = pd.read_table(fn, skiprows=1, index_col=0)\n        counts.append(df[df.columns[-1]])\n    combined_counts = pd.DataFrame(counts).T\n    if define_sample_name:\n        names = [define_sample_name(x) for x in fns]\n        combined_counts.columns = names\n    combined_counts.index.name = ''\n    return combined_counts"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef fix_hp_addrs(server):\n    fixed = {A.server.ID: server[A.server.ID]}\n    both = server.get(A.server.PRIVATE_IPS)\n    if both:\n        fixed[A.server.PUBLIC_IPS] = [both[1]]\n        fixed[A.server.PRIVATE_IPS] = [both[0]]\n    return fixed", "response": "Fixes the public and private IP addresses in a HPCloud server."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef find_servers(self, *args, **kwargs):\n        servers = super(HPNova, self).find_servers(*args, **kwargs)\n        return map(fix_hp_addrs, servers)", "response": "A wrapper around the base class find_servers method to fix the IP addresses in the hpcloud s\n        non - standard return values."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nwrap :meth:`bang.providers.openstack.Nova.create_server` to apply hpcloud specialization, namely pulling IP addresses from the hpcloud's non-standard return values.", "response": "def create_server(self, *args, **kwargs):\n        \"\"\"\n        Wraps :meth:`bang.providers.openstack.Nova.create_server` to apply\n        hpcloud specialization, namely pulling IP addresses from the hpcloud's\n        non-standard return values.\n\n        \"\"\"\n        # hpcloud's management console stuffs all of its tags in a \"tags\" tag.\n        # populate it with the stack and role values here only at server\n        # creation time.  what users do with it after server creation is up to\n        # them.\n        tags = kwargs['tags']\n        tags[A.tags.TAGS] = ','.join([\n                tags.get(A.tags.STACK, ''),\n                tags.get(A.tags.ROLE, ''),\n                ])\n        # Don't create an explicit floating IP; gets one \n        # automatically\n        if 'floating_ip' not in kwargs:\n            kwargs['floating_ip'] = False\n        s = super(HPNova, self).create_server(*args, **kwargs)\n        return fix_hp_addrs(s)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add_to_inventory(self):\n        self.stack.add_host(self.hostname, self.groups, self.hostvars)", "response": "Adds this server and its hostvars to the ansible inventory."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef expect_all(a, b):\n    assert all(_a == _b for _a, _b in zip_longest(a, b))", "response": "\\ Asserts that two iterables contain the same values."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef coroutine(func):\n\n    def decorator(*args, **kwargs):\n        generator = func(*args, **kwargs)\n        next(generator)\n        return lambda *args: generator.send(args)\n    return decorator", "response": "A function decorator that wraps a generator function into a callable interface."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add_entity(self, entity, second=False):\n        ''' Add entity to world.\n            entity is of type Entity\n        '''\n        if not entity in self._entities:\n            if second:\n                self._entities.append(entity)\n            else:\n                entity.set_world(self)\n        else:\n            raise DuplicateEntityError(entity)", "response": "Add entity to the world."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding a system to the world.", "response": "def add_system(self, system):\n        '''\n        Add system to the world.\n        All systems will be processed on World.process()\n        system is of type System\n        '''\n        if system not in self._systems:\n            system.set_world(self)\n            self._systems.append(system)\n        else:\n            raise DuplicateSystemError(system)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding an entity to a group.", "response": "def register_entity_to_group(self, entity, group):\n        '''\n        Add entity to a group.\n        If group does not exist, entity will be added as first member\n        entity is of type Entity\n        group is a string that is the name of the group\n        '''\n        if entity in self._entities:\n            if group in self._groups:\n                self._groups[group].append(entity)\n            else:\n                self._groups[group] = [entity]\n        else:\n            raise UnmanagedEntityError(entity)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef deregister_entity_from_group(self, entity, group):\n        '''\n        Removes entity from group\n        '''\n        if entity in self._entities:\n            if entity in self._groups[group]:\n                self._groups[group].remove(entity)\n        else:\n            raise UnmanagedEntityError(entity)", "response": "Removes entity from group."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nremoves entity from world and kills entity if second is True", "response": "def remove_entity(self, entity, second=False):\n        '''\n        Removes entity from world and kills entity\n        '''\n        if entity in self._entities:\n            if second:\n                for group in self._groups.keys():\n                    if entity in self._groups[group]:\n                        self.deregister_entity_from_group(entity, group)\n                self._entities.remove(entity)\n            else:\n                entity.kill()\n        else:\n            raise UnmanagedEntityError(entity)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nremoves a system from world and kills it", "response": "def remove_system(self, system):\n        '''\n        Removes system from world and kills system\n        '''\n        if system in self._systems:\n            self._systems.remove(system)\n        else:\n            raise UnmanagedSystemError(system)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_entity_by_tag(self, tag):\n        '''\n        Get entity by tag\n        tag is a string that is the tag of the Entity.\n        '''\n        matching_entities = list(filter(lambda entity: entity.get_tag() == tag,\n                                        self._entities))\n        if matching_entities:\n            return matching_entities[0]\n        else:\n            return None", "response": "Get the entity by tag"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget list of entities by list of components", "response": "def get_entities_by_components(self, *components):\n        '''\n        Get entity by list of components\n        All members of components must be of type Component\n        '''\n        return list(filter(lambda entity:\n                           set(components) <=\n                           set(map(type, entity.get_components())),\n                           self._entities))"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the world an entity belongs to.", "response": "def set_world(self, world):\n        '''\n        Sets the world an entity belongs to.\n        Checks for tag conflicts before adding.\n        '''\n        if world.get_entity_by_tag(self._tag) and self._tag != '':\n            raise NonUniqueTagError(self._tag)\n        else:\n            self._world = world\n            world.add_entity(self, True)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_tag(self, tag):\n        '''\n        Sets the tag.\n        If the Entity belongs to the world it will check for tag conflicts.\n        '''\n        if self._world:\n            if self._world.get_entity_by_tag(tag):\n                raise NonUniqueTagError(tag)\n        self._tag = tag", "response": "Sets the tag of the entity."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef kill(self):\n        '''Kills Entity'''\n        if self._world:\n            self._world.remove_entity(self, True)\n            self._world = None\n        self._tag = None\n        self._uuid = None\n        self._components = None", "response": "Kills the current entity."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding a Component to an Entity", "response": "def add_component(self, component):\n        '''\n        Adds a Component to an Entity\n        '''\n        if component not in self._components:\n            self._components.append(component)\n        else:  # Replace Component\n            self._components[self._components.index(component)] = component"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets component of component_type or returns None", "response": "def get_component(self, component_type):\n        '''\n        Gets component of component_type or returns None\n        '''\n        matching_components = list(filter(lambda component:\n                                          isinstance(component,\n                                                     component_type),\n                                          self._components))\n        if matching_components:\n            return matching_components[0]\n        else:\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef optimally_align_text(x, y, texts, expand, renderer=None, ax=None,\n                         direction='xy'):\n    \"\"\"\n    For all text objects find alignment that causes the least overlap with\n    points and other texts and apply it\n    \"\"\"\n    if ax is None:\n        ax = plt.gca()\n    if renderer is None:\n        r = ax.get_figure().canvas.get_renderer()\n    else:\n        r = renderer\n    bboxes = get_bboxes(texts, r, expand)\n    if 'x' not in direction:\n        ha = ['']\n    else:\n        ha = ['left', 'right', 'center']\n    if 'y' not in direction:\n        va = ['']\n    else:\n        va = ['bottom', 'top', 'center']\n    alignment = list(product(ha, va))\n    for i, text in enumerate(texts):\n        counts = []\n        for h, v in alignment:\n            if h:\n                text.set_ha(h)\n            if v:\n                text.set_va(v)\n            bbox = text.get_window_extent(r).expanded(*expand).\\\n                transformed(ax.transData.inverted())\n            c = get_points_inside_bbox(x, y, bbox)\n            counts.append(len(c) + bbox.count_overlaps(bboxes) - 1)\n        a = np.argmin(counts)\n        if 'x' in direction:\n            text.set_ha(alignment[a][0])\n        if 'y' in direction:\n            text.set_va(alignment[a][1])\n        bboxes[i] = text.get_window_extent(r).expanded(*expand).\\\n            transformed(ax.transData.inverted())\n    return texts", "response": "Optimizes text objects to the nearest overlap with the least overlap with other texts."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef adjust_text(x, y, texts, ax=None, expand_text=(1.2, 1.2),\n                expand_points=(1.2, 1.2), autoalign=True,  va='center',\n                ha='center', force_text=1., force_points=1.,\n                lim=100, precision=0, only_move={}, text_from_text=True,\n                text_from_points=True, save_steps=False, save_prefix='',\n                save_format='png', add_step_numbers=True, draggable=True, repel_from_axes=False, min_arrow_sep=0.0,\n                *args, **kwargs):\n    \"\"\"\n    Iteratively adjusts the locations of texts. First moves all texts that are\n    outside the axes limits inside. Then in each iteration moves all texts away\n    from each other and from points. In the end hides texts and substitutes\n    them with annotations to link them to the rescpective points.\n\n    Args:\n        x (seq): x-coordinates of labelled points\n        y (seq): y-coordinates of labelled points\n        texts (list): a list of text.Text objects to adjust\n        ax (obj): axes object with the plot; if not provided is determined by\n            plt.gca()\n        expand_text (seq): a tuple/list/... with 2 numbers (x, y) to expand\n            texts when repelling them from each other; default (1.2, 1.2)\n        expand_points (seq): a tuple/list/... with 2 numbers (x, y) to expand\n            texts when repelling them from points; default (1.2, 1.2)\n        autoalign (bool): If True, the best alignment of all texts will be\n            determined automatically before running the iterative adjustment;\n            if 'x' will only align horizontally, if 'y' - vertically; overrides\n            va and ha\n        va (str): vertical alignment of texts\n        ha (str): horizontal alignment of texts\n        force_text (float): the repel force from texts is multiplied by this\n            value; default 0.5\n        force_points (float): the repel force from points is multiplied by this\n            value; default 0.5\n        lim (int): limit of number of iterations\n        precision (float): up to which sum of all overlaps along both x and y\n            to iterate; may need to increase for complicated situations;\n            default 0, so no overlaps with anything.\n        only_move (dict): a dict to restrict movement of texts to only certain\n            axis. Valid keys are 'points' and 'text', for each of them valid\n            values are 'x', 'y' and 'xy'. This way you can forbid moving texts\n            along either of the axes due to overlaps with points, but let it\n            happen if there is an overlap with texts: only_move={'points':'y',\n            'text':'xy'}. Default: None, so everything is allowed.\n        text_from_text (bool): whether to repel texts from each other; default\n            True\n        text_from_points (bool): whether to repel texts from points; default\n            True; can helpful to switch of in extremely crouded plots\n        save_steps (bool): whether to save intermediate steps as images;\n            default False\n        save_prefix (str): a path and/or prefix to the saved steps; default ''\n        save_format (str): a format to save the steps into; default 'png\n        *args and **kwargs: any arguments will be fed into plt.annotate after\n            all the optimization is done just for plotting\n        add_step_numbers (bool): whether to add step numbers as titles to the\n            images of saving steps\n        draggable (bool): whether to make the annotations draggable; default\n            True\n    \"\"\"\n    if ax is None:\n        ax = plt.gca()\n        r = ax.get_figure().canvas.get_renderer()\n    orig_xy = [text.get_position() for text in texts]\n    orig_x = [xy[0] for xy in orig_xy]\n    orig_y = [xy[1] for xy in orig_xy]\n    for text in texts:\n        text.set_va(va)\n        text.set_ha(ha)\n    if save_steps:\n        if add_step_numbers:\n            plt.title('0a')\n        plt.savefig(save_prefix + '0a.' + save_format, format=save_format)\n    if autoalign:\n        if autoalign is not True:\n            texts = optimally_align_text(x, y, texts,\n                                         direction=autoalign,\n                                         expand=expand_points, renderer=r,\n                                         ax=ax)\n        else:\n            texts = optimally_align_text(orig_x, orig_y, texts,\n                                         expand=expand_points, renderer=r,\n                                         ax=ax)\n\n    if save_steps:\n        if add_step_numbers:\n            plt.title('0b')\n        plt.savefig(save_prefix + '0b.' + save_format, format=save_format)\n    if repel_from_axes is True:\n        texts = repel_text_from_axes(\n            texts, ax, renderer=r, expand=expand_points)\n    history = [np.inf] * 5\n    for i in xrange(lim):\n        q1, q2 = np.inf, np.inf\n        if text_from_text:\n            d_x_text, d_y_text, q1 = repel_text(texts, renderer=r, ax=ax,\n                                                expand=expand_text)\n        else:\n            d_x_text, d_y_text, q1 = [0] * len(texts), [0] * len(texts), 0\n        if text_from_points:\n            d_x_points, d_y_points, q2 = repel_text_from_points(x, y, texts,\n                                                                ax=ax, renderer=r,\n                                                                expand=expand_points)\n        else:\n            d_x_points, d_y_points, q1 = [0] * len(texts), [0] * len(texts), 0\n        if only_move:\n            if 'text' in only_move:\n                if 'x' not in only_move['text']:\n                    d_x_text = np.zeros_like(d_x_text)\n                if 'y' not in only_move['text']:\n                    d_y_text = np.zeros_like(d_y_text)\n            if 'points' in only_move:\n                if 'x' not in only_move['points']:\n                    d_x_points = np.zeros_like(d_x_points)\n                if 'y' not in only_move['points']:\n                    d_y_points = np.zeros_like(d_y_points)\n        dx = np.array(d_x_text) + np.array(d_x_points)\n        dy = np.array(d_y_text) + np.array(d_y_points)\n        q = round(np.sum(np.array([q1, q2])[np.array([q1, q2]) < np.inf]), 5)\n        if q > precision and q < np.max(history):\n            history.pop(0)\n            history.append(q)\n            move_texts(texts, dx * force_text, dy * force_points,\n                       bboxes=get_bboxes(texts, r, (1, 1)), ax=ax)\n            if save_steps:\n                if add_step_numbers:\n                    plt.title(i + 1)\n                    plt.savefig(save_prefix + str(i + 1) + '.' + save_format,\n                                format=save_format)\n        else:\n            break\n\n    bboxes = get_bboxes(texts, r, (1, 1))\n    originLW = kwargs[\"arrowprops\"][\"lw\"]\n    for j, text in enumerate(texts):\n        cx, cy = get_midpoint(bboxes[j])\n        one = (orig_xy[j][0] - cx)**2\n        two = (orig_xy[j][1] - cy)**2\n        sep = (one + two)**0.5\n\n        print text.get_text(), sep\n        try:\n            if sep < min_arrow_sep:\n                kwargs[\"arrowprops\"][\"lw\"] = 0.\n            else:\n                kwargs[\"arrowprops\"][\"lw\"] = originLW\n        except Exception, e:\n            print e\n        a = ax.annotate(text.get_text(), xy=(orig_xy[j]),\n                        xytext=text.get_position(), *args, **kwargs)\n        a.__dict__.update(text.__dict__)\n        if draggable:\n            a.draggable()\n        texts[j].remove()\n    if save_steps:\n        if add_step_numbers:\n            plt.title(i + 1)\n        plt.savefig(save_prefix + str(i + 1) + '.' +\n                    save_format, format=save_format)", "response": "Adjusts the locations of the texts of the current node in the cluster tree."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef write_quota(outbytes: int, outfn: Path) -> Union[None, int]:\n    if not outfn:\n        return None\n\n    anch = Path(outfn).resolve().anchor\n    freeout = shutil.disk_usage(anch).free\n\n    if freeout < 10 * outbytes:\n        raise IOError(f'out of disk space on {anch}.'\n                      '{freeout/1e9} GB free, wanting to write {outbytes/1e9} GB.')\n\n    return freeout", "response": "Returns the number of bytes written to outfn."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef normframe(I: np.ndarray, Clim: tuple) -> np.ndarray:\n    Vmin = Clim[0]\n    Vmax = Clim[1]\n\n    # stretch to [0,1]\n    return (I.astype(np.float32).clip(Vmin, Vmax) - Vmin) / (Vmax - Vmin)", "response": "returns the normalized frame I"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef req2frame(req, N: int=0):\n    if req is None:\n        frame = np.arange(N, dtype=np.int64)\n    elif isinstance(req, int):  # the user is specifying a step size\n        frame = np.arange(0, N, req, dtype=np.int64)\n    elif len(req) == 1:\n        frame = np.arange(0, N, req[0], dtype=np.int64)\n    elif len(req) == 2:\n        frame = np.arange(req[0], req[1], dtype=np.int64)\n    elif len(req) == 3:\n        # this is -1 because user is specifying one-based index\n        frame = np.arange(req[0], req[1], req[2],\n                          dtype=np.int64) - 1  # keep -1 !\n    else:  # just return all frames\n        frame = np.arange(N, dtype=np.int64)\n\n    return frame", "response": "converts a list of request into a numpy array"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef dir2fn(ofn, ifn, suffix) -> Union[None, Path]:\n    if not ofn:  # no output file desired\n        return None\n\n    ofn = Path(ofn).expanduser()\n    ifn = Path(ifn).expanduser()\n    assert ifn.is_file()\n\n    if ofn.suffix == suffix:  # must already be a filename\n        pass\n    else:  # must be a directory\n        assert ofn.is_dir(), f'create directory {ofn}'\n        ofn = ofn / ifn.with_suffix(suffix).name\n\n    try:\n        assert not ofn.samefile(ifn), f'do not overwrite input file! {ifn}'\n    except FileNotFoundError:  # a good thing, the output file doesn't exist and hence it's not the input file\n        pass\n\n    return ofn", "response": "Create a new directory based on ifn and suffix."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef setupimgh5(f: Union[Path, h5py.File],\n               Nframetotal: int, Nrow: int, Ncol: int, dtype=np.uint16,\n               writemode='r+', key='/rawimg', cmdlog: str=None):\n    \"\"\"\n    f: HDF5 handle (or filename)\n\n    h: HDF5 dataset handle\n    \"\"\"\n    if isinstance(f, (str, Path)):  # assume new HDF5 file wanted\n        f = Path(f).expanduser()\n        if f.is_dir():\n            raise IOError(\n                'must provide specific HDF5 filename, not just a directory')\n\n        print('creating', f)\n        with h5py.File(f, writemode) as F:\n            setupimgh5(F, Nframetotal, Nrow, Ncol, dtype, writemode, key)\n\n    elif isinstance(f, h5py.File):\n        h = f.create_dataset(key,\n                             shape=(Nframetotal, Nrow, Ncol),\n                             dtype=dtype,\n                             chunks=(1, Nrow, Ncol),  # each image is a chunk\n                             compression='gzip',\n                             # no difference in filesize from 1 to 5, except much faster to use lower numbers!\n                             compression_opts=1,\n                             shuffle=True,\n                             fletcher32=True,\n                             track_times=True)\n        h.attrs[\"CLASS\"] = np.string_(\"IMAGE\")\n        h.attrs[\"IMAGE_VERSION\"] = np.string_(\"1.2\")\n        h.attrs[\"IMAGE_SUBCLASS\"] = np.string_(\"IMAGE_GRAYSCALE\")\n        h.attrs[\"DISPLAY_ORIGIN\"] = np.string_(\"LL\")\n        h.attrs['IMAGE_WHITE_IS_ZERO'] = np.uint8(0)\n\n        if cmdlog and isinstance(cmdlog, str):\n            f['/cmdlog'] = cmdlog\n    else:\n        raise TypeError(\n            f'{type(f)} is not correct, must be filename or h5py.File HDF5 file handle')", "response": "Setup an image in a HDF5 file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nconverting a single video into a single HDF5 file.", "response": "def vid2h5(data: np.ndarray, ut1, rawind, ticks, outfn: Path, P: dict, i: int=0,\n           Nfile: int=1, det=None, tstart=None, cmdlog: str=None):\n    assert outfn, 'must provide a filename to write'\n\n    outfn = Path(outfn).expanduser()\n    assert not outfn.is_dir(\n    ), 'must provide FILEname, you provided directory {outfn}'\n    outfn.parent.mkdir(exist_ok=True)\n\n    txtupd = f'convert file {i} / {Nfile}'\n    if 'spoolfn' in P:\n        txtupd += f' {P[\"spoolfn\"].name}'\n    txtupd += f' => {outfn}'\n    \"\"\"\n    note if line wraps (>80 characters), this in-place update breaks.\n    \"\"\"\n    print(txtupd + '\\r', end=\"\")\n    # %% saving\n    if outfn.suffix == '.h5':\n        \"\"\"\n        Reference: https://www.hdfgroup.org/HDF5/doc/ADGuide/ImageSpec.html\n        Thanks to Eric Piel of Delmic for pointing out this spec\n        * the HDF5 attributess set are necessary to put HDFView into image mode and enables\n        other conforming readers to easily play images stacks as video.\n        * the string_() calls are necessary to make fixed length strings per HDF5 spec\n        \"\"\"\n        # NOTE write mode r+ to not overwrite incremental images\n        if outfn.is_file():\n            writemode = 'r+'  # append\n        else:\n            writemode = 'w'\n\n        if data is not None:\n\n            N = data.shape[0] * Nfile\n            ind = slice(i * data.shape[0], (i + 1) * data.shape[0])\n        else:  # FIXME haven't reevaluated for update only case\n            for q in (ut1, rawind, ticks):\n                if q is not None:\n                    N = len(q)\n                    break\n            ind = slice(None)\n\n        with h5py.File(outfn, writemode) as f:\n            if data is not None:\n                if 'rawimg' not in f:  # first run\n                    setupimgh5(f, N, data.shape[1], data.shape[2])\n\n                f['/rawimg'][ind, ...] = data\n\n            if ut1 is not None:\n                print(f'writing from {datetime.utcfromtimestamp(ut1[0])}'\n                      f'to {datetime.utcfromtimestamp(ut1[-1])}')\n                if 'ut1_unix' not in f:\n                    fut1 = f.create_dataset(\n                        '/ut1_unix', shape=(N,), dtype=float, fletcher32=True)\n                    fut1.attrs['units'] = 'seconds since Unix epoch Jan 1 1970 midnight'\n\n                f['/ut1_unix'][ind] = ut1\n\n            if tstart is not None and 'tstart' not in f:\n                f['/tstart'] = tstart\n\n            if rawind is not None:\n                if 'rawind' not in f:\n                    fri = f.create_dataset(\n                        '/rawind', shape=(N,), dtype=np.int64, fletcher32=True)\n                    fri.attrs['units'] = 'one-based index since camera program started this session'\n\n                f['/rawind'][ind] = rawind\n\n            if ticks is not None:\n                if 'ticks' not in f:\n                    ftk = f.create_dataset(\n                        '/ticks', shape=(N,), dtype=np.uint64, fletcher32=True)  # Uint64\n                    ftk.attrs['units'] = 'FPGA tick counter for each image frame'\n\n                f['/ticks'][ind] = ticks\n\n            if 'spoolfn' in P:\n                # http://docs.h5py.org/en/latest/strings.html\n                if 'spoolfn' not in f:\n                    fsp = f.create_dataset(\n                        '/spoolfn', shape=(N,), dtype=h5py.special_dtype(vlen=bytes))\n                    fsp.attrs['description'] = 'input filename data was extracted from'\n\n                f['/spoolfn'][ind] = P['spoolfn'].name\n\n            if det is not None:\n                if 'detect' not in f:\n                    fdt = f.create_dataset('/detect', shape=(N,), dtype=int)\n                    fdt.attrs['description'] = '# of auroral detections this frame'\n\n                f['/detect'][i] = det[i]\n\n            if 'params' not in f:\n                cparam = np.array((\n                    P['kineticsec'],\n                    P['rotccw'],\n                    P['transpose'],\n                    P['flipud'],\n                    P['fliplr'],\n                    1),\n                    dtype=[('kineticsec', 'f8'),\n                           ('rotccw', 'i1'),\n                           ('transpose', 'i1'),\n                           ('flipud', 'i1'),\n                           ('fliplr', 'i1'),\n                           ('questionable_ut1', 'i1')]\n                )\n\n                # cannot use fletcher32 here, typeerror\n                f.create_dataset('/params', data=cparam)\n\n            if 'sensorloc' not in f and 'sensorloc' in P:\n                loc = P['sensorloc']\n                lparam = np.array((loc[0], loc[1], loc[2]),\n                                  dtype=[('lat', 'f8'), ('lon', 'f8'), ('alt_m', 'f8')])\n\n                # cannot use fletcher32 here, typeerror\n                Ld = f.create_dataset('/sensorloc', data=lparam)\n                Ld.attrs['units'] = 'WGS-84 lat (deg),lon (deg), altitude (meters)'\n\n            if 'cmdlog' not in f:\n                if isinstance(cmdlog, (tuple, list)):\n                    cmdlog = ' '.join(cmdlog)\n                # cannot use fletcher32 here, typeerror\n                f['/cmdlog'] = str(cmdlog)\n\n            if 'header' not in f and 'header' in P:\n                f['/header'] = str(P['header'])\n\n            if 'hdf5version' not in f:\n                f['/hdf5version'] = h5py.version.hdf5_version_tuple\n\n    elif outfn.suffix == '.fits':\n        from astropy.io import fits\n        # NOTE the with... syntax does NOT yet work with astropy.io.fits\n        hdu = fits.PrimaryHDU(data)\n        hdu.writeto(outfn, clobber=False, checksum=True)\n        # no close\n        \"\"\"\n        Note: the orientation of this FITS in NASA FV program and the preview\n        image shown in Python should/must have the same orientation and pixel indexing')\n        \"\"\"\n\n    elif outfn.suffix == '.mat':\n        from scipy.io import savemat\n        # matlab is fortran order\n        matdata = {'imgdata': data.transpose(1, 2, 0)}\n        savemat(outfn, matdata, oned_as='column')\n    else:\n        raise ValueError(f'what kind of file is {outfn}')"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef imgwriteincr(fn: Path, imgs, imgslice):\n    if isinstance(imgslice, int):\n        if imgslice and not (imgslice % 2000):\n            print(f'appending images {imgslice} to {fn}')\n\n    if isinstance(fn, Path):\n        # avoid accidental overwriting of source file due to misspecified command line\n        assert fn.suffix == '.h5', 'Expecting to write .h5 file'\n\n        with h5py.File(fn, 'r+') as f:\n            f['/rawimg'][imgslice, :, :] = imgs\n    elif isinstance(fn, h5py.File):\n        f['/rawimg'][imgslice, :, :] = imgs\n    else:\n        raise TypeError(\n            f'{fn} must be Path or h5py.File instead of {type(fn)}')", "response": "writes HDF5 huge image files in increments\n           "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef load_js(abspath, default=dict(), compress=False, enable_verbose=True):\n    abspath = str(abspath) # try stringlize\n    \n    if compress: # check extension name\n        if os.path.splitext(abspath)[1] != \".gz\":\n            raise Exception(\"compressed json has to use extension '.gz'!\")\n    else:\n        if os.path.splitext(abspath)[1] != \".json\":\n            raise Exception(\"file extension are not '.json'!\")\n\n    if enable_verbose:\n        print(\"\\nLoading from %s...\" % abspath)\n        st = time.clock()\n        \n    if os.path.exists(abspath): # exists, then load\n        if compress:\n            with gzip.open(abspath, \"rb\") as f:\n                js = json.loads(f.read().decode(\"utf-8\"))\n        else:\n            with open(abspath, \"r\") as f:\n                js = json.load(f)\n        if enable_verbose:\n            print(\"\\tComplete! Elapse %.6f sec.\" % (time.clock() - st) )\n        return js\n    \n    else:\n        if enable_verbose:\n            print(\"\\t%s not exists! cannot load! Create an default object \"\n                  \"instead\" % abspath)\n        return default", "response": "Load the js file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndump a JSON object to a file.", "response": "def dump_js(js, abspath, \n            fastmode=False, replace=False, compress=False, enable_verbose=True):\n    \"\"\"Dump Json serializable object to file.\n    Provides multiple choice to customize the behavior.\n    \n    :param js: Serializable python object.\n    :type js: dict or list\n    \n    :param abspath: ``save as`` path, file extension has to be ``.json`` or ``.gz`` \n        (for compressed json).\n    :type abspath: string\n    \n    :param fastmode: (default False) If ``True``, then dumping json without \n        sorted keys and pretty indent, and it's faster and smaller in size.\n    :type fastmode: boolean\n    \n    :param replace: (default False) If ``True``, when you dump json to a existing \n        path, it silently overwrite it. If False, an exception will be raised.\n        Default False setting is to prevent overwrite file by mistake.\n    :type replace: boolean\n    \n    :param compress: (default False) If ``True``, use GNU program gzip to \n        compress the json file. Disk usage can be greatly reduced. But you have \n        to use :func:`load_js(abspath, compress=True)<load_js>` in loading.\n    :type compress: boolean\n    \n    :param enable_verbose: (default True) Trigger for message.\n    :type enable_verbose: boolean\n\n    Usage::\n\n        >>> from weatherlab.lib.dataIO.js import dump_js\n        >>> js = {\"a\": 1, \"b\": 2}\n        >>> dump_js(js, \"test.json\", replace=True)\n        Dumping to test.json...\n            Complete! Elapse 0.002432 sec\n\n    **\u4e2d\u6587\u6587\u6863**\n    \n    \u5c06Python\u4e2d\u53ef\u88ab\u5e8f\u5217\u5316\u7684\"\u5b57\u5178\", \"\u5217\u8868\"\u4ee5\u53ca\u4ed6\u4eec\u7684\u7ec4\u5408, \u6309\u7167Json\u7684\u7f16\u7801\u65b9\u5f0f\u5199\u5165\u6587\u4ef6\n    \u6587\u4ef6\n    \n    \u53c2\u6570\u5217\u8868\n    \n    :param js: \u53efJson\u5316\u7684Python\u5bf9\u8c61\n    :type js: ``\u5b57\u5178`` \u6216 ``\u5217\u8868``\n    \n    :param abspath: \u5199\u5165\u6587\u4ef6\u7684\u8def\u5f84\u3002\u6269\u5c55\u540d\u5fc5\u987b\u4e3a``.json``\u6216``.gz``, \u5176\u4e2dgz\u7528\u4e8e\u88ab\u538b\n        \u7f29\u7684Json\n    :type abspath: ``\u5b57\u7b26\u4e32``\n    \n    :param fastmode: (\u9ed8\u8ba4 False) \u5f53\u4e3a``True``\u65f6, Json\u7f16\u7801\u65f6\u4e0d\u5bf9Key\u8fdb\u884c\u6392\u5e8f, \u4e5f\u4e0d\n        \u8fdb\u884c\u7f29\u8fdb\u6392\u7248\u3002\u8fd9\u6837\u505a\u5199\u5165\u7684\u901f\u5ea6\u66f4\u5feb, \u6587\u4ef6\u7684\u5927\u5c0f\u4e5f\u66f4\u5c0f\u3002\n    :type fastmode: \"\u5e03\u5c14\u503c\"\n    \n    :param replace: (\u9ed8\u8ba4 False) \u5f53\u4e3a``True``\u65f6, \u5982\u679c\u5199\u5165\u8def\u5f84\u5df2\u7ecf\u5b58\u5728, \u5219\u4f1a\u81ea\u52a8\u8986\u76d6\n        \u539f\u6587\u4ef6\u3002\u800c\u4e3a``False``\u65f6, \u5219\u4f1a\u629b\u51fa\u5f02\u5e38\u3002\u9632\u6b62\u8bef\u64cd\u4f5c\u8986\u76d6\u6e90\u6587\u4ef6\u3002\n    :type replace: \"\u5e03\u5c14\u503c\"\n    \n    :param compress: (\u9ed8\u8ba4 False) \u5f53\u4e3a``True``\u65f6, \u4f7f\u7528\u5f00\u6e90\u538b\u7f29\u6807\u51c6gzip\u538b\u7f29Json\u6587\u4ef6\u3002\n        \u901a\u5e38\u80fd\u8ba9\u6587\u4ef6\u5927\u5c0f\u7f29\u5c0f10-20\u500d\u4e0d\u7b49\u3002\u5982\u8981\u8bfb\u53d6\u6587\u4ef6, \u5219\u9700\u8981\u4f7f\u7528\u51fd\u6570\n        :func:`load_js(abspath, compress=True)<load_js>`.\n    :type compress: \"\u5e03\u5c14\u503c\"\n    \n    :param enable_verbose: (\u9ed8\u8ba4 True) \u662f\u5426\u6253\u5f00\u4fe1\u606f\u63d0\u793a\u5f00\u5173, \u6279\u5904\u7406\u65f6\u5efa\u8bae\u5173\u95ed.\n    :type enable_verbose: \"\u5e03\u5c14\u503c\"\n    \"\"\"\n    abspath = str(abspath) # try stringlize\n    \n    if compress: # check extension name\n        root, ext = os.path.splitext(abspath)\n        if ext != \".gz\":\n            if ext != \".tmp\":\n                raise Exception(\"compressed json has to use extension '.gz'!\")\n            else:\n                _, ext = os.path.splitext(root)\n                if ext != \".gz\":\n                    raise Exception(\"compressed json has to use extension '.gz'!\")\n    else:\n        root, ext = os.path.splitext(abspath)\n        if ext != \".json\":\n            if ext != \".tmp\":\n                raise Exception(\"file extension are not '.json'!\")\n            else:\n                _, ext = os.path.splitext(root)\n                if ext != \".json\":\n                    raise Exception(\"file extension are not '.json'!\")\n    \n    if enable_verbose:\n        print(\"\\nDumping to %s...\" % abspath)\n        st = time.clock()\n    \n    if os.path.exists(abspath): # if exists, check replace option\n        if replace: # replace existing file\n            if fastmode: # no sort and indent, do the fastest dumping\n                if compress:\n                    with gzip.open(abspath, \"wb\") as f:\n                        f.write(json.dumps(js).encode(\"utf-8\"))\n                else:\n                    with open(abspath, \"w\") as f:\n                        json.dump(js, f)\n            else:\n                if compress:\n                    with gzip.open(abspath, \"wb\") as f:\n                        f.write(json.dumps(js, sort_keys=True,\n                            indent=4, separators=(\",\" , \": \")).encode(\"utf-8\"))\n                else:\n                    with open(abspath, \"w\") as f:\n                        json.dump(js, f, sort_keys=True, \n                                  indent=4, separators=(\",\" , \": \") )\n        else: # stop, print error message\n            raise Exception(\"\\tCANNOT WRITE to %s, it's already \"\n                            \"exists\" % abspath)\n                \n    else: # if not exists, just write to it\n        if fastmode: # no sort and indent, do the fastest dumping\n            if compress:\n                with gzip.open(abspath, \"wb\") as f:\n                    f.write(json.dumps(js).encode(\"utf-8\"))\n            else:\n                with open(abspath, \"w\") as f:\n                    json.dump(js, f)\n        else:\n            if compress:\n                with gzip.open(abspath, \"wb\") as f:\n                    f.write(json.dumps(js, sort_keys=True,\n                        indent=4, separators=(\",\" , \": \")).encode(\"utf-8\"))\n            else:\n                with open(abspath, \"w\") as f:\n                    json.dump(js, f, sort_keys=True, \n                              indent=4, separators=(\",\" , \": \") )\n            \n    if enable_verbose:\n        print(\"\\tComplete! Elapse %.6f sec\" % (time.clock() - st) )"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nmigrates constituencies to recompute fingerprints", "response": "def migrate_constituencies(apps, schema_editor):\n    \"\"\"\n    Re-save constituencies to recompute fingerprints\n    \"\"\"\n    Constituency = apps.get_model(\"representatives\", \"Constituency\")\n    for c in Constituency.objects.all():\n        c.save()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nrendering a tree structure based on generic python containers.", "response": "def treeprint(data, render_only=False, file=None, **options):\n    \"\"\" Render a tree structure based on generic python containers. The keys\n    should be titles and the values are children of the node or None if it's\n    an empty leaf node;  Primitives are valid leaf node labels too.  E.g.\n\n        sample = {\n            \"Leaf 1\": None,\n            \"Leaf 2\": \"I have a label on me\",\n            \"Branch A\": {\n                \"Sub Leaf 1 with float label\": 3.14,\n                \"Sub Branch\": {\n                    \"Deep Leaf\": None\n                }\n            },\n            \"Branch B\": {\n                \"Sub Leaf 2\": None\n            }\n        }\n    \"\"\"\n\n    def getiter(obj):\n        if isinstance(obj, collections.abc.Mapping):\n            return obj.items()\n        elif (isinstance(obj, collections.abc.Iterable) and\n              not isinstance(obj, str)):\n            return enumerate(obj)\n\n    def cycle_check(item, seen=set()):\n        item_id = id(item)\n        if item_id in seen:\n            raise ValueError('Cycle detected for: %s' % repr(item))\n        else:\n            seen.add(item_id)\n\n    def crawl(obj, cc=cycle_check):\n        cc(obj)\n        objiter = getiter(obj)\n        if objiter is None:\n            yield TreeNode(obj)\n        else:\n            for key, item in objiter:\n                if isinstance(item, collections.abc.Iterable) and \\\n                   not isinstance(item, str):\n                    yield TreeNode(key, children=crawl(item))\n                elif item is None:\n                    yield TreeNode(key)\n                else:\n                    yield TreeNode(key, label=item)\n    t = Tree(**options)\n    render_gen = t.render(crawl(data))\n    if render_only:\n        return render_gen\n    else:\n        file = sys.stdout if file is None else file\n        conv = (lambda x: x.plain()) if not file.isatty() else (lambda x: x)\n        for x in render_gen:\n            print(conv(x), file=file)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the terminal columns size.", "response": "def terminal_size(self):\n        \"\"\"Gets the terminal columns size.\"\"\"\n        try:\n            _, columns = os.popen('stty size', 'r').read().split()\n            return min(int(columns) - 10, 100)\n        except ValueError:\n            return self.default_terminal_size"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nshowing on the stdout the progress bar for the given progress.", "response": "def bar(self, progress):\n        \"\"\"Shows on the stdout the progress bar for the given progress.\"\"\"\n        if not hasattr(self, \"_limit\") or not self._limit:\n            self._limit = self.terminal_size()\n        graph_progress = int(progress * self._limit)\n        self.stdout.write('\\r', ending='')\n        progress_format = \"[%-{}s] %d%%\".format(self._limit)\n        self.stdout.write(\n            self.style.SUCCESS(progress_format % (self.progress_symbol * graph_progress, int(progress * 100))),\n            ending=''\n        )\n        self.stdout.flush()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _Execute(self, options):\n        whitelist = dict(\n            name=options[\"name\"],\n            description=options.get(\"description\", \"<empty>\"))\n        return self._agent.client.compute.security_groups.create(**whitelist)", "response": "Handles security groups operations."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nloads a config file and validate it.", "response": "def load_args(args):\n    \"\"\"\n    Load a config file. Merges CLI args and validates.\n    \"\"\"\n    config = kaptan.Kaptan(handler='yaml')\n    conf_parent = os.path.expanduser('~')\n    conf_app = '.clancy'\n    conf_filename = 'config.yaml'\n\n    conf_dir = os.path.join(conf_parent, conf_app)\n    for loc in [os.curdir, conf_dir]:\n        configpath = os.path.join(loc, conf_filename)\n        try:\n            if os.path.isfile(configpath):\n                config.import_config(configpath)\n                break\n        except (ValueError, ParserError, ScannerError):\n            warn(\"Ignoring invalid valid yaml file {}\".format(configpath))\n\n    config = (config.configuration_data\n              if config.configuration_data is not None else {})\n\n    # Prepend '--' to conf file keys so it matches docopt. This is the dumbest\n    # thing in the world.\n    for key, val in config.items():\n        config['--'+key] = val\n        del config[key]\n\n    return validate(merge(args, config))"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn default language depending on settings. LANGUAGE_CODE merged with best match from settings. LANGUAGES Returns default language depending on settings. LANGUAGE_CODE merged with best match from settings. LANGUAGES Returns default language depending on settings. LANGUAGE_CODE", "response": "def get_default_language(language_code=None):\n    \"\"\"\n    Returns default language depending on settings.LANGUAGE_CODE merged with\n    best match from settings.LANGUAGES\n\n    Returns: language_code\n\n    Raises ImproperlyConfigured if no match found\n    \"\"\"\n\n    if not language_code:\n        language_code = settings.LANGUAGE_CODE\n\n    languages = dict(settings.LANGUAGES).keys()\n\n    # first try if there is an exact language\n    if language_code in languages:\n        return language_code\n\n    # otherwise split the language code if possible, so iso3\n    language_code = language_code.split(\"-\")[0]\n\n    if language_code not in languages:\n        raise ImproperlyConfigured(\"No match in LANGUAGES for LANGUAGE_CODE %s\" % settings.LANGUAGE_CODE)\n\n    return language_code"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconvert this action to a function or method.", "response": "def as_method(self, docstring=\"\"):\n        \"\"\"\n        Converts this action to a function or method.\n          An optional docstring may be passed.\n        \"\"\"\n        method = lambda obj, *args, **kwargs: self(obj, *args, **kwargs)\n        if docstring:\n            method.__doc__ = docstring\n        return method"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ngenerate a <D x D > ill - conditioned correlation matrix with random coefficients.", "response": "def illmat(D, random_state=None):\n    \"\"\"Generate a <D x D> ill-conditioned correlation matrix\n    with random coefficients\n\n    Parameters:\n    -----------\n    D : int\n        Dimension of the matrix\n\n    Return:\n    -------\n    cmat : ndarray\n        DxD matrix with +1 as diagonal elements,\n        mirrored random numbers [-1,+1].\n    \"\"\"\n    if random_state:\n        np.random.seed(random_state)\n\n    uni = np.random.uniform(size=(D, D))\n\n    tmp = np.minimum(1., np.maximum(-1., 2 * uni - 1.0))\n\n    tmp = np.triu(tmp, k=1)\n\n    return np.eye(D) + tmp + tmp.T"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _create(self, rawtitle):\n        slug = util.make_slug(rawtitle)\n        if self.site.page_exists_on_disk(slug):\n            raise ValueError\n            #print \"Attempted to create a page which already exists.\"\n            #return False\n\n        self._title = unicode(rawtitle,\"UTF-8\")\n        self._slug = slug\n\n        self._dirs['source_dir'] = os.path.join(self.site.dirs['source'], slug)\n        self._dirs['source_filename'] = os.path.join(self._dirs['source_dir'],\n                                                     slug + '.md')\n\n        self._dirs['www_dir'] = os.path.join(self.site.dirs['www'], slug)\n        self._dirs['www_filename'] = os.path.join(self._dirs['www_dir'], \\\n                                                  'index.html')\n        self._config = self._create_config()\n        return True", "response": "Create a page with the given title."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef write(self):\n        if not os.path.isdir(self._dirs['source_dir']):\n            os.mkdir(self._dirs['source_dir'])\n\n        fout = codecs.open(self._dirs['source_filename'], 'w', encoding=\"utf-8\", errors=\"xmlcharrefreplace\")\n        fout.write(self._config_to_text())\n        if self._content:\n            fout.write('\\n')\n            fout.write(self._content)\n            fout.write('\\n')\n        fout.close()", "response": "Write the s2 page to the corresponding source file."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef rename(self, new_title):\n        if not isinstance(new_title, str) and \\\n                not isinstance(new_title, unicode):\n            raise TypeError\n            # print \"Cannot rename page. New title must be string or unicode.\"\n\n        new_slug = util.make_slug(new_title)\n        if self.site.page_exists_on_disk(new_slug):\n            raise ValueError\n            # print \"Cannot rename page. A page with the same \\\n            # title/slug already exists.\"\n\n        #wipe the source directory for this page\n        shutil.rmtree(self._dirs['source_dir'])\n\n        #just change dirinfo, config, and write\n        self._title = new_title\n        self._slug = new_slug\n        self._config['title'] = [self._title]\n        self._config['slug'] = [self._slug]\n\n        self._dirs['source_dir'] = os.path.join(self.site.dirs['source'],\n                                                new_slug)\n        self._dirs['source_filename'] = os.path.join(self._dirs['source_dir'],\n                                                     new_slug + '.md')\n\n        self._dirs['www_dir'] = os.path.join(self.site.dirs['www'], new_slug)\n        #self._dirs['www_filename'] = os.path.join(self._dirs['www_dir'], \\\n        #                                       new_slug + '.html')\n        self.write()", "response": "Rename an existing s2 page."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nrender this page and return the rendition.", "response": "def render(self):\n        \"\"\"Render this page and return the rendition.\n\n        Converts the markdown content to html, and then renders the\n        (mako) template specified in the config, using that html.\n\n        The task of writing of the rendition to a real file is\n        responsibility of the generate method.\n\n        \"\"\"\n        (pthemedir, ptemplatefname) = self._theme_and_template_fp()\n\n        mylookup = TemplateLookup(directories=[self.site.dirs['s2'], pthemedir], input_encoding='utf-8', output_encoding='utf-8')\n\n\n        makotemplate = Template(filename=ptemplatefname, lookup=mylookup,\n                                module_directory=self.site._makodir)\n\n        # I don't really need to use the meta extension here, because I render self._content (has no metadata)\n        #page_html = markdown.markdown(self._content)\n\n        md = markdown.Markdown(extensions=['meta','fenced_code', 'codehilite'],output_format=\"html5\")\n        page_html = md.convert(self._content)   # need to trigger the conversion to obtain md.Meta\n\n        # We assume that the page is always in a dir one level below www\n        themepath = \"../themes/\" + os.path.split(pthemedir)[1] + '/'\n        commonpath = \"../common/\"\n\n        # HERE I'll pass the config variable to the mako template, so I can use the title etc.\n        #buf = StringIO()\n        #ctx = Context(buf, dict(pageContent=page_html, isFrontPage=False, themePath=themepath, pageTitle='pedo',\n        #                        commonPath=commonpath))\n        #makotemplate.render_context(ctx)\n        #rendition = buf.getvalue()\n\n        # IS THERE `PIWIK CODE?\n        # IS THERE DISQUS CODE?\n        # READ from s2 if there's disqus_code.html.tpl and piwik_code.html.tpl\n        # if there's piwik, just define the variable piwik_code with its contents\n        # if there's disqus... nested render?\n        # HERE I NEED TO DIRECTLY INCLUDE A TEMPLATE IN ANOTHER TEMPLATE!!! MAKO!\n        #d_sn = self.site.site_config['disqus_shortname']\n        #if d_sn:   # the site uses disqus\n        piwik_code = None\n        disqus_code, disqus_shortname, disqus_identifier, disqus_title, disqus_url= None, None, None, None, None\n\n        piwik_code_tpl = os.path.join(self.site.dirs['s2'],'piwik_code.html.tpl')\n        if os.path.isfile(piwik_code_tpl):\n            piwik_code = '/piwik_code.html.tpl'\n\n        disqus_code_tpl = os.path.join(self.site.dirs['s2'],'disqus_code.html.tpl')\n        if os.path.isfile(disqus_code_tpl):\n            disqus_code = '/disqus_code.html.tpl'\n            disqus_shortname = self.site.site_config['disqus_shortname']\n            disqus_identifier = self._config['page_id'][0]\n            disqus_title = self.title\n            disqus_url = os.path.join(self.site.site_config['site_url'],self._slug)\n\n        rendition = makotemplate.render(pageContent=page_html,isFrontPage=False,\n                                        themePath=themepath,\n                                        commonPath=commonpath,\n                                        pageTitle=self.title,\n                                        piwik_code=piwik_code,\n                                        disqus_code=disqus_code,\n                                        disqus_shortname = disqus_shortname,\n                                        disqus_identifier = disqus_identifier,\n                                        disqus_url = disqus_url,\n                                        disqus_title= disqus_title)\n        return rendition"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef generate(self):\n        generated_content = ''\n        if 'published' in (self._config['status'][0]).lower():\n            if os.path.isdir(self.dirs['www_dir']):\n                shutil.rmtree(self.dirs['www_dir'])\n            os.mkdir(self.dirs['www_dir'])\n            # copy the whole source directory of the page,\n            # excluding 'nowww' and *s2md\n            sfl = glob.glob(os.path.join(self.dirs['source_dir'], \"*\"))\n            dirlist = [f for f in sfl if os.path.isdir(f)]\n            filelist = [f for f in sfl if os.path.isfile(f)]\n            for f in filelist:\n                if not '.md' in os.path.split(f)[1]:\n                    shutil.copy(f, self.dirs['www_dir'])\n            for d in dirlist:\n                rfn = os.path.split(d)[1]\n                if rfn != 'nowww':\n                    shutil.copytree(d, os.path.join(self.dirs['www_dir'], rfn))\n                #write the rendered \"page\" to file\n\n            #fout = open(self.dirs['www_filename'], 'w')\n            #fout.write(self.render())\n            #fout.close()\n\n            generated_content = self.render()\n            fout = codecs.open(self.dirs['www_filename'], \"w\", encoding=\"utf-8\", errors=\"xmlcharrefreplace\")\n            fout.write(generated_content)\n            fout.close()\n\n        return generated_content", "response": "Generate the page html file. Just open the destination file for writing and write the result\nAttributeNames"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates the default configuration dictionary for this page.", "response": "def _create_config(self):\n        \"\"\"Create the default configuration dictionary for this page.\"\"\"\n        configinfo = {'creation_date': [ datetime.datetime.now().date().isoformat()],\n                      'author': [self.site.site_config['default_author']],\n                      'status': [u'draft'],\n                      'lang': [u''],\n                      'tags': [u''],\n                      'title': [self._title],\n                      'slug': [self._slug],\n                      'theme': [u''],\n                      'template': [u''],\n                      'page_id': [uuid.uuid4().hex]\n                      }  # when theme and template are empty, the generator uses the defaults. Thus, initially\n                                          # they should be empty, to allow for global changes just by changing the site config files.\n        return configinfo"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nloading the page. The _file_name param is known because this method is only called after having checked that the page exists.", "response": "def _load(self, slug):\n        \"\"\"Load the page. The _file_name param is known, because this\n        method is only called after having checked that the page exists.\n\n        \"\"\"\n        #here we know that the slug exists\n        self._slug = slug\n        page_dir = os.path.join(self.site.dirs['source'], self._slug)\n        page_file_name = os.path.join(page_dir, self._slug + '.md')\n        self._dirs['source_dir'] = page_dir\n        self._dirs['source_filename'] = page_file_name\n        self._dirs['www_dir'] = os.path.join(self.site.dirs['www'], slug)\n        self._dirs['www_filename'] = os.path.join(self._dirs['www_dir'],  'index.html')\n\n        #pf = open(self._dirs['source_filename'], 'r')\n        #page_text = pf.read()\n        #pf.close()\n        # need to decode!\n        pf = codecs.open(self._dirs['source_filename'], mode=\"r\", encoding=\"utf-8\")\n        page_text = pf.read()\n        pf.close()\n\n        self._parse_text(page_text)\n        if not self._check_config():\n            raise ValueError\n            #sys.exit()\n        self._title = self._config['title'][0]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _check_config(self):\n        required_data = ['creation_date',\n                         'author',\n                         'status',\n                         'lang',\n                         'tags',\n                         'title',\n                         'slug',\n                         'theme',\n                         'template',\n                         'page_id']\n        isok = True\n        # exclude some statements from coverage analysis. I would need to\n        # refactor how the config is loaded/handled etc. It's not worth\n        # to do that now. Maybe when I change yaml for the markdwn extension.\n        for e in self._config.keys():\n            if not e in required_data: # pragma: no cover\n                print \"The configuration in page '\" + \\\n                      self._slug + \"' is corrupt.\"\n                isok = False\n            # check that the theme and template exist, even if they're default.\n        (pthemedir, ptemplatefname) = self._theme_and_template_fp()\n        if not os.path.isdir(pthemedir): # pragma: no cover\n            print \"Theme \" + self._config['theme'][0] + \\\n                  \" specified in page '\" + \\\n                  self._slug + \"' does not exist.\"\n            isok = False\n        if not os.path.isfile(ptemplatefname): # pragma: no cover\n            print \"Template \" + self._config['template'][0] + \\\n                  \" specified in page '\" + self._slug + \\\n                  \"' does not exist.\"\n            isok = False\n        return isok", "response": "Verify that the configuration is correct."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _theme_and_template_fp(self):\n        ptheme = self._config['theme'][0]\n        if ptheme == \"\":\n            ptheme = self.site.site_config['default_theme']\n        pthemedir = os.path.join(self.site.dirs['themes'], ptheme)\n        ptemplate = self._config['template'][0]\n        if ptemplate == \"\":\n            ptemplate = self.site.site_config['default_template']\n        ptemplatefname = os.path.join(pthemedir, ptemplate)\n        return (pthemedir, ptemplatefname)", "response": "Return the full paths for theme and template in this page"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nextracting the s2config and content from the raw page text.", "response": "def _parse_text(self, page_text):\n        \"\"\"Extract the s2config and the content from the raw page text.\"\"\"\n\n        # 1 sanitize: remove leading blank lines\n        # 2 separate \"config text\" from content, store content\n        # 3 convert config text + \\n to obtain Meta, this is the config.\n\n        lines = page_text.split('\\n')\n        i = 0\n        while lines[i].strip() == '':\n            i += 1\n        if i > 0: # i points to the first non-blank line.  Else, i is 0, there are no leading blank lines\n            lines = lines[i:]  #remove leading blank lines\n\n        i = 0\n        while lines[i].strip() != '':\n            i += 1\n            # i points to the first blank line\n        cfg_lines = '\\n'.join(lines[0:i + 1])  #config lines, plus the empty line\n\n        md = markdown.Markdown(extensions=['meta','fenced_code', 'codehilite'],output_format=\"html5\")\n        md.convert(cfg_lines)   # need to trigger the conversion to obtain md.Meta\n\n        self._config = md.Meta\n        self._content =  '\\n'.join(lines[i+1:])"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _config_to_text(self):\n        r = u'' # unicode('',\"UTF-8\")\n        for k in self._config:\n            # if k == 'creation_date':\n            #     r +=  k + \": \" + self._config[k][0] + '\\n'\n            # else:\n            #uk = unicode(k,\"UTF-8\")\n            cosa = '\\n        '.join(self._config[k]) + '\\n'\n            r += k + \": \" + cosa\n            #r += k + \": \" + '\\n        '.join(self._config[k]) + '\\n'\n        r += '\\n'\n        return r", "response": "Render the configuration as text."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef creation_date(self, value): # pylint: disable-msg=E0102\n        if not isinstance(value, datetime.date):\n            raise TypeError\n        self._config['creation_date'][0] = value.isoformat()", "response": "Set the date in the configuraton"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the tags in the configuraton", "response": "def tags(self, value): # pylint: disable-msg=E0102\n        \"\"\"Set the tags in the configuraton (setter)\"\"\"\n        if not isinstance(value, list):\n            raise TypeError\n        self._config['tags'] = value"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef author(self):\n        r = self.site.site_config['default_author']\n        if 'author' in self._config:\n            r = self._config['author']\n        return r", "response": "Return the full path of the theme used by this page."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _represent_arguments(*arguments, **keyword_arguments):\n    argument_strings = [repr(a) for a in arguments]\n    keyword_strings = [\n        '='.join((k, repr(v))) for k, v in keyword_arguments.items()]\n    return ', '.join(argument_strings + keyword_strings)", "response": "Represent the aruments in a form suitable as a key."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef streamer(main_method):\n    def main(arguments):\n        streams = [StringIO(get_clipboard_data())] if (arguments and '-c' in arguments) else []\n        streams = streams or ([file(_, 'r') for _ in arguments if os.path.isfile(argument)] if arguments else [])\n        streams = streams or ([sys.stdin] if not (streams or arguments) else [])\n        return main_method(arguments, streams)\n    return main", "response": "A streamer that opens a stream for the first file in arguments or sys. stdin"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nopens a stream for the first file in arguments or stdin", "response": "def old_streamer(main_method):\n    \"\"\"Open a stream for the first file in arguments, or stdin\"\"\"\n    if not arguments:\n        return [sys.stdin]\n    elif arguments[0] == '-c':\n        return [StringIO(get_clipboard_data())]\n    for argument in arguments:\n        if os.path.isfile(argument):\n            return file(argument, 'r')\n    return method"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nrecognising globs in args", "response": "def globber(main_method, globs):\n    \"\"\"Recognise globs in args\"\"\"\n    import os\n    from glob import glob\n\n    def main(arguments):\n        lists_of_paths = [_ for _ in arguments if glob(pathname, recursive=True)]\n        return main_method(arguments, lists_of_paths)\n    return main"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_curent_module_classes(module):\n    classes = []\n    for name, obj in inspect.getmembers(module):\n        if inspect.isclass(obj):\n            classes.append(obj)\n    return classes", "response": "get_curent_module_classes - Get all classes in a module"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef is_subclass(obj, cls):\n    try:\n        for i in obj.__bases__:\n            if i is cls or isinstance(i, cls):\n                return True\n        for i in obj.__bases__:\n            if isinstance(i, cls):\n                return True\n    except AttributeError:\n        return isinstance(obj.__class__, cls)\n    return False", "response": "Returns True if obj is a subclass of cls False otherwise"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndispatches the message to the corresponding method.", "response": "def _dispatch_trigger(self, msg):\n        \"\"\"\n        Dispatches the message to the corresponding method.\n        \"\"\"\n        if not msg.args[0].startswith(self.trigger_char):\n            return\n        split_args = msg.args[0].split()\n        trigger = split_args[0].lstrip(self.trigger_char)\n        if trigger in self.triggers:\n            method = getattr(self, trigger)\n            if msg.command == PRIVMSG:\n                if msg.dst == self.irc.nick:\n                    if EVT_PRIVATE in self.triggers[trigger]:\n                        msg.event = EVT_PRIVATE\n                        method(msg)\n                else:\n                    if EVT_PUBLIC in self.triggers[trigger]:\n                        msg.event = EVT_PUBLIC\n                        method(msg)\n            elif (msg.command == NOTICE) and (EVT_NOTICE in self.triggers[trigger]):\n                msg.event = EVT_NOTICE\n                method(msg)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ndisplay available commands or help message for given command", "response": "def help(self, msg):\n        \"\"\"\n        help [command] - displays available commands, or help message for given command\n        \"\"\"\n        commands = {}\n        for handler in self.irc.handlers:\n            if isinstance(handler, CommandHandler):\n                for command in handler.triggers:\n                    method = getattr(handler, command)\n                    if hasattr(method, '__doc__') and method.__doc__:\n                        commands[command] = method.__doc__.strip()\n                    else:\n                        commands[command] = 'No help available for command: %s' % command\n\n        if len(msg.args) == 2:\n            if msg.args[1] not in commands:\n                message = 'Unknown command: %s' % msg.args[1]\n            else:\n                message = commands[msg.args[1]]\n        else:\n            message = 'Available commands: %s' % ', '.join(commands.keys())\n\n        if msg.event == EVT_PUBLIC:\n            self.irc.msg(msg.dst, message)\n        elif msg.event == EVT_PRIVATE:\n            self.irc.msg(msg.src, message)\n        elif msg.event == EVT_NOTICE:\n            self.irc.notice(msg.src, message)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds a restriction for given command.", "response": "def set_restriction(self, command, user, event_types):\n        \"\"\"\n        Adds restriction for given `command`.\n\n        :param command: command on which the restriction should be set.\n        :type command: str\n        :param user: username for which the restriction applies.\n        :type user: str\n        :param event_types: types of events for which the command is allowed.\n        :type event_types: list\n        \"\"\"\n        self.commands_rights[command][user.lower()] = event_types\n        if command not in self.triggers:\n            self.triggers[command] = [EVT_PUBLIC, EVT_PRIVATE, EVT_NOTICE]\n        if not hasattr(self, command):\n            setattr(self, command, lambda msg: self.handle_rights(msg))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef del_restriction(self, command, user, event_types):\n        if user.lower() in self.commands_rights[command]:\n            for event_type in event_types:\n                try:\n                    self.commands_rights[command][user.lower()].remove(event_type)\n                except ValueError:\n                    pass\n            if not self.commands_rights[command][user.lower()]:\n                self.commands_rights[command].pop(user.lower())", "response": "Removes a restriction for given command."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncatches - all command that is called when a restricted command is triggered.", "response": "def handle_rights(self, msg):\n        \"\"\"\n        Catch-all command that is called whenever a restricted command is triggered.\n\n        :param msg: message that triggered the command.\n        :type msg: :class:`fatbotslim.irc.Message`\n        \"\"\"\n        command = msg.args[0][1:]\n        if command in self.commands_rights:\n            if msg.src.name.lower() in self.commands_rights[command]:\n                if msg.event not in self.commands_rights[command][msg.src.name.lower()]:\n                    msg.propagate = False\n            elif '*' in self.commands_rights[command]:\n                if msg.event not in self.commands_rights[command]['*']:\n                    msg.propagate = False\n            if (not msg.propagate) and self.notify:\n                message = \"You're not allowed to use the '%s' command\" % command\n                if msg.event == EVT_PUBLIC:\n                    self.irc.msg(msg.dst, message)\n                elif msg.event == EVT_PRIVATE:\n                    self.irc.msg(msg.src.name, message)\n                elif msg.event == EVT_NOTICE:\n                    self.irc.notice(msg.src.name, message)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncheck if the item is in the list of inclusions.", "response": "def check_inclusions(item, included=[], excluded=[]):\n    \"\"\"Everything passes if both are empty, otherwise, we have to check if \\\n    empty or is present.\"\"\"\n    if (len(included) == 0):\n        if len(excluded) == 0 or item not in excluded:\n            return True\n        else:\n            return False\n    else:\n        if item in included:\n            return True\n    return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef toto(arch_name, comment='', clear=False, read_comment=False, list_members=False, time_show=False):\n    if comment and clear:\n        clingon.RunnerError(\"You cannot specify --comment and --clear together\")\n    z = None\n    # if archive does not exist, create it with up to 3 files from current directory\n    if not os.path.isfile(arch_name):\n        print \"Creating archive\", arch_name\n        z = zipfile.ZipFile(arch_name, 'w')\n        for f in [x for x in glob.iglob('*.*') if not x.endswith('.zip')][:3]:\n            print \"  Add file %s to %s\" % (f, arch_name)\n            z.write(f)\n    if comment:\n        mtime = os.path.getmtime(arch_name)\n        if not z:\n            z = zipfile.ZipFile(arch_name, 'a')\n        z.comment = comment\n    if z:\n        z.close()\n        if comment:\n            os.utime(arch_name, (time.time(), mtime))\n    if read_comment:\n        z = zipfile.ZipFile(arch_name, 'r')\n        print \"Comment:\", z.comment, len(z.comment)\n    if list_members:\n        z = zipfile.ZipFile(arch_name, 'r')\n        print \"Members:\", z.namelist()\n    if time_show:\n        print \"Access time:\", time.ctime(os.path.getatime(arch_name))\n        print \"Modif time:\", time.ctime(os.path.getmtime(arch_name))", "response": "Small utility for changing comment in a zip file"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nquery a meetup database.", "response": "def cli(ctx, data, verbose, color, format, editor):\n    \"\"\"Query a meetup database.\n    \"\"\"\n    ctx.obj['verbose'] = verbose\n    if verbose:\n        logging.basicConfig(level=logging.INFO)\n        logging.getLogger('sqlalchemy.engine').setLevel(logging.INFO)\n    ctx.obj['datadir'] = os.path.abspath(data)\n    if 'db' not in ctx.obj:\n        ctx.obj['db'] = get_db(data)\n    if color is None:\n        ctx.obj['term'] = blessings.Terminal()\n    elif color is True:\n        ctx.obj['term'] = blessings.Terminal(force_styling=True)\n    elif color is False:\n        ctx.obj['term'] = blessings.Terminal(force_styling=None)\n    if 'PYVO_TEST_NOW' in os.environ:\n        # Fake the current date for testing\n        ctx.obj['now'] = datetime.datetime.strptime(\n            os.environ['PYVO_TEST_NOW'], '%Y-%m-%d %H:%M:%S')\n    else:\n        ctx.obj['now'] = datetime.datetime.now()\n    ctx.obj['format'] = format\n    ctx.obj['editor'] = shlex.split(editor)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _assert_path_is_rw(self):\n        if not self.path:\n            raise ValueError(\"`path` argument must be set!\")\n\n        if not os.path.exists(self.path):\n            raise IOError(\"`%s` not found.\" % self.path)\n\n        if not os.path.isdir(self.path):\n            raise IOError(\"`%s` is not a directory!\" % self.path)\n\n        if not os.access(self.path, (os.R_OK or os.W_OK)):\n            raise IOError(\n                \"Can't access `%s`, please check permissions.\" % self.path\n            )", "response": "Ensures that the path exists is readable and writable."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncomputes hash for the file_obj.", "response": "def _get_hash(self, file_obj):\n        \"\"\"\n        Compute hash for the `file_obj`.\n\n        Attr:\n            file_obj (obj): File-like object with ``.write()`` and ``.seek()``.\n\n        Returns:\n            str: Hexdigest of the hash.\n        \"\"\"\n        size = 0\n        hash_buider = self.hash_builder()\n        for piece in self._get_file_iterator(file_obj):\n            hash_buider.update(piece)\n            size += len(piece)\n\n        file_obj.seek(0)\n\n        return \"%s_%x\" % (hash_buider.hexdigest(), size)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _create_dir_path(self, file_hash, path=None, hash_list=None):\n        # first, non-recursive call - parse `file_hash`\n        if hash_list is None:\n            hash_list = list(file_hash)\n\n        if not hash_list:\n            raise IOError(\"Directory structure is too full!\")\n\n        # first, non-recursive call - look for subpath of `self.path`\n        if not path:\n            path = os.path.join(\n                self.path,\n                hash_list.pop(0)\n            )\n\n        # if the path not yet exists, create it and work on it\n        if not os.path.exists(path):\n            os.mkdir(path)\n            return self._create_dir_path(\n                file_hash=file_hash,\n                path=path,\n                hash_list=hash_list\n            )\n\n        files = os.listdir(path)\n\n        # file is already in storage\n        if file_hash in files:\n            return path\n\n        # if the directory is not yet full, use it\n        if len(files) < self.dir_limit:\n            return path\n\n        # in full directories create new sub-directories\n        return self._create_dir_path(\n            file_hash=file_hash,\n            path=os.path.join(path, hash_list.pop(0)),\n            hash_list=hash_list\n        )", "response": "Create proper filesystem paths for given file_hash."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef file_path_from_hash(self, file_hash, path=None, hash_list=None):\n        # first, non-recursive call - parse `file_hash`\n        if hash_list is None:\n            hash_list = list(file_hash)\n\n        if not hash_list:\n            raise IOError(\"Directory structure is too full!\")\n\n        # first, non-recursive call - look for subpath of `self.path`\n        if not path:\n            path = os.path.join(\n                self.path,\n                hash_list.pop(0)\n            )\n\n        files = os.listdir(path)\n\n        # is the file/unpacked archive in this `path`?\n        if file_hash in files:\n            full_path = os.path.join(path, file_hash)\n\n            if os.path.isfile(full_path):\n                return PathAndHash(path=full_path, hash=file_hash)\n\n            return PathAndHash(path=full_path + \"/\", hash=file_hash)\n\n        # end of recursion, if there are no more directories to look into\n        next_path = os.path.join(path, hash_list.pop(0))\n        if not os.path.exists(next_path):\n            raise IOError(\"File not found in the structure.\")\n\n        # look into subdirectory\n        return self.file_path_from_hash(\n            file_hash=file_hash,\n            path=next_path,\n            hash_list=hash_list\n        )", "response": "Returns the path on filesystem."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadd a new file into the storage.", "response": "def add_file(self, file_obj):\n        \"\"\"\n        Add new file into the storage.\n\n        Args:\n            file_obj (file): Opened file-like object.\n\n        Returns:\n            obj: Path where the file-like object is stored contained with hash\\\n                 in :class:`.PathAndHash` object.\n\n        Raises:\n            AssertionError: If the `file_obj` is not file-like object.\n            IOError: If the file couldn't be added to storage.\n        \"\"\"\n        BalancedDiscStorage._check_interface(file_obj)\n\n        file_hash = self._get_hash(file_obj)\n        dir_path = self._create_dir_path(file_hash)\n\n        final_path = os.path.join(dir_path, file_hash)\n\n        def copy_to_file(from_file, to_path):\n            with open(to_path, \"wb\") as out_file:\n                for part in self._get_file_iterator(from_file):\n                    out_file.write(part)\n\n        try:\n            copy_to_file(from_file=file_obj, to_path=final_path)\n        except Exception:\n            os.unlink(final_path)\n            raise\n\n        return PathAndHash(path=final_path, hash=file_hash)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef delete_by_file(self, file_obj):\n        BalancedDiscStorage._check_interface(file_obj)\n\n        file_hash = self._get_hash(file_obj)\n\n        return self.delete_by_hash(file_hash)", "response": "Removes a file from the storage."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nremoving the file by its hash.", "response": "def delete_by_hash(self, file_hash):\n        \"\"\"\n        Remove file/archive by it's `file_hash`.\n\n        Args:\n            file_hash (str): Hash, which is used to find the file in storage.\n\n        Raises:\n            IOError: If the file for given `file_hash` was not found in \\\n                     storage.\n        \"\"\"\n        full_path = self.file_path_from_hash(file_hash)\n\n        return self.delete_by_path(full_path)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _recursive_remove_blank_dirs(self, path):\n        path = os.path.abspath(path)\n\n        # never delete root of the storage or smaller paths\n        if path == self.path or len(path) <= len(self.path):\n            return\n\n        # if the path doesn't exists, go one level upper\n        if not os.path.exists(path):\n            return self._recursive_remove_blank_dirs(\n                os.path.dirname(path)\n            )\n\n        # if the directory contains files, end yourself\n        if os.listdir(path):\n            return\n\n        # blank directories can be removed\n        shutil.rmtree(path)\n\n        # go one level up, check whether the directory is blank too\n        return self._recursive_remove_blank_dirs(\n            os.path.dirname(path)\n        )", "response": "Recursively removes blank directories from the storage."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndeleting file or directory identified by path.", "response": "def delete_by_path(self, path):\n        \"\"\"\n        Delete file/directory identified by `path` argument.\n\n        Warning:\n            `path` have to be in :attr:`path`.\n\n        Args:\n            path (str): Path of the file / directory you want to remove.\n\n        Raises:\n            IOError: If the file / directory doesn't exists, or is not in \\\n                     :attr:`path`.\n        \"\"\"\n        if not os.path.exists(path):\n            raise IOError(\"Unknown path '%s'!\" % path)\n\n        if not path.startswith(self.path):\n            raise IOError(\n                \"Path '%s' is not in the root of the storage ('%s')!\" % (\n                    path,\n                    self.path\n                )\n            )\n\n        if os.path.isfile(path):\n            os.unlink(path)\n            return self._recursive_remove_blank_dirs(path)\n\n        shutil.rmtree(path)\n        self._recursive_remove_blank_dirs(path)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ninput mpub is master xpub key string. Input priv is xprv string. Path is the path string (e.g. 'm/3/6/2') from the mpub to the priv. Path cannot contain any hardened keys.", "response": "def crack(mpub,priv,pathtopriv):\n        '''\n        Input mpub is master xpub key string.\n        Input priv is xprv string.\n        Path is the path string (e.g. 'm/3/6/2') from the mpub to the\n        priv. Path cannot contain any hardened keys.\n        '''\n\n        mpub = str(mpub)\n        priv = b58d(priv)\n        if int(priv[18:26],16) >= 2147483648:\n            raise Exception(\"Private key input is hardened.  Cannot crack up a level from a hardened key.\")\n        pathtopriv = pathtopriv.lower()\n        if 'h' in pathtopriv or \"'\" in pathtopriv:\n            raise Exception(\"Path input indicates a hardened key. Cannot crack up a level from hardened keys.\")\n        for c in pathtopriv:\n            if c not in \"1234567890mh/\":\n                raise Exception(\"Path wrong format\")\n        assert pathtopriv[0] == 'm'\n        if pathtopriv[-1] == \"/\":\n            pathtopriv = pathtopriv[:-1]\n        pathlist = pathtopriv.split(\"/\")\n        pathlist = pathlist[1:]\n        assert int(pathlist[-1]) == int(priv[18:26],16)\n        counter = len(pathlist)\n        xpublist = [mpub]\n        for i in range(counter-1):\n            mpub = BIP32.ckd(mpub,int(pathlist[i]))\n            xpublist.append(mpub)\n        xpublist.reverse()\n        for i in range(counter):\n            newpub = b58d(xpublist[i])\n            tmp = hexstrlify(hmac.new(unhexlify(newpub[-130:-66]), \\\n                              unhexlify(newpub[-66:] + priv[18:26]), \\\n                               hashlib.sha512).digest())\n            tmppriv = subtractprivkeys(priv[-64:],tmp[:64])\n            priv = priv[:8] + newpub[8:-66] + '00' + tmppriv\n            pathlist = pathlist[:-1]\n        return b58e(priv)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nperforms pseudo - localization on a string.", "response": "def pseudolocalize(self, s):\n        \"\"\"\n        Performs pseudo-localization on a string.  The specific transforms to be\n        applied to the string is defined in the transforms field of the object.\n\n        :param s: String to pseudo-localize.\n        :returns: Copy of the string s with the transforms applied.  If the input\n                  string is an empty string or None, an empty string is returned.\n        \"\"\"\n        if not s:  # If the string is empty or None\n            return u\"\"\n        if not isinstance(s, six.text_type):\n            raise TypeError(\"String to pseudo-localize must be of type '{0}'.\".format(six.text_type.__name__))\n        # If no transforms are defined, return the string as-is.\n        if not self.transforms:\n            return s\n        fmt_spec = re.compile(\n            r\"\"\"(\n            {.*?}  # https://docs.python.org/3/library/string.html#formatstrings\n            |\n            %(?:\\(\\w+?\\))?.*?[acdeEfFgGiorsuxX%]  # https://docs.python.org/3/library/stdtypes.html#printf-style-string-formatting\n            )\"\"\", re.VERBOSE)\n        # If we don't find any format specifiers in the input string, just munge the entire string at once.\n        if not fmt_spec.search(s):\n            result = s\n            for munge in self.transforms:\n                result = munge(result)\n        # If there are format specifiers, we do transliterations on the sections of the string that are not format\n        # specifiers, then do any other munging (padding the length, adding brackets) on the entire string.\n        else:\n            substrings = fmt_spec.split(s)\n            for munge in self.transforms:\n                if munge in transforms._transliterations:\n                    for idx in range(len(substrings)):\n                        if not fmt_spec.match(substrings[idx]):\n                            substrings[idx] = munge(substrings[idx])\n                    else:\n                        continue\n                else:\n                    continue\n            result = u\"\".join(substrings)\n            for munge in self.transforms:\n                if munge not in transforms._transliterations:\n                    result = munge(result)\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef pseudolocalizefile(self, input_filename, output_filename, input_encoding='UTF-8', output_encoding='UTF-8',\n                           overwrite_existing=True):\n        \"\"\"\n        Method for pseudo-localizing the message catalog file.\n\n        :param input_filename: Filename of the source (input) message catalog file.\n        :param output_filename: Filename of the target (output) message catalog file.\n        :param input_encoding: String indicating the encoding of the input file.  Optional, defaults to 'UTF-8'.\n        :param output_encoding: String indicating the encoding of the output file.  Optional, defaults to 'UTF-8'.\n        :param overwrite_existing: Boolean indicating if an existing output message catalog file should be overwritten.\n                                   True by default. If False, an IOError will be raised.\n        \"\"\"\n        leading_trailing_double_quotes = re.compile(r'^\"|\"$')\n        if not os.path.isfile(input_filename):\n            raise IOError(\"Input message catalog not found: {0}\".format(os.path.abspath(input_filename)))\n        if os.path.isfile(output_filename) and not overwrite_existing:\n            raise IOError(\"Error, output message catalog already exists: {0}\".format(os.path.abspath(output_filename)))\n        with codecs.open(input_filename, mode=\"r\", encoding=input_encoding) as in_fileobj:\n            with codecs.open(output_filename, mode=\"w\", encoding=output_encoding) as out_fileobj:\n                for current_line in in_fileobj:\n                    out_fileobj.write(current_line)\n                    if current_line.startswith(\"msgid\"):\n                        msgid = current_line.split(None, 1)[1].strip()\n                        msgid = leading_trailing_double_quotes.sub('', msgid)\n                        msgstr = self.l10nutil.pseudolocalize(msgid)\n                        out_fileobj.write(u\"msgstr \\\"{0}\\\"\\n\".format(msgstr))\n                        next(in_fileobj)", "response": "Method for pseudolocalizing the message catalog file."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add_quantities(d, coords=None, massE=0.511e6):\n    '''\n    Add physically interesting quantities to\n    pext data.\n\n    Parameters:\n    -----------\n      d      : pext array\n\n    Keywords:\n    ---------\n      coords : sequence of positions for angle calculation. None\n               or by default, calculate no angles.\n               For 2D, takes the angle depending on the order passed,\n               so this can be used for left-handed coordinate systems\n               like LSP's xz.\n      massE  : rest mass energy of particles.\n    Returns a copy with the quantities appended.\n    '''\n    keys,items = zip(*calc_quantities(d,coords=coords,massE=massE).items());\n    return rfn.rec_append_fields(\n        d, keys, items);", "response": "Adds physically interesting quantities to a single pext array."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncalculates physically interesting quantities from a pext array.", "response": "def calc_quantities(d, coords=None, massE=0.511e6):\n    '''\n    Calculate physically interesting quantities from pext\n\n    Parameters:\n    -----------\n      d      : pext array\n\n    Keywords:\n    ---------\n      coords : sequence of positions for angle calculation. None\n               or by default, calculate no angles.\n               For 2D, takes the angle depending on the order passed,\n               so this can be used for left-handed coordinate systems\n               like LSP's xz.\n      massE  : rest mass energy of particles.\n    Returns a dictionary of physical quantities.\n    '''\n    quants = dict();\n    quants['u_norm'] = np.sqrt(d['ux']**2+d['uy']**2+d['uz']**2)\n    quants['KE']     =(np.sqrt(quants['u_norm']**2+1)-1)*massE;\n    coords[:] = ['u'+coord for coord in coords];\n    if not coords:\n        pass;\n    elif len(coords) == 3:\n        quants['theta'] = np.arccos(d[coords[2]]/quants['u_norm']);\n        quants['phi']   = np.arctan2(d[coords[1]],d[coords[0]]);\n        quants['phi_n'] = np.arctan2(d[coords[2]],d[coords[0]]);\n    elif len(coords) == 2:\n        quants['phi']   = np.arctan2(d[coords[1]],d[coords[0]]);\n    return quants;"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_repo_version(url):\n    response = requests.get(url)\n    if response.status_code == 404:\n        return None\n    else:\n        return response.text.replace('\\n', '')", "response": "Get the current version on GitHub\n    url looks like https://raw. githubusercontent. com / aquatix / ns - notifications / master / VERSION"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create_server(initialize=True):\n    with provider() as p:\n        host_string = p.create_server()\n        if initialize:\n            env.host_string = host_string\n            initialize_server()", "response": "Create a server with the provider."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef try_call(self, client_data=None, api_data=None, aux_data=None, *args, **kwargs):\n        try:\n            return self.call(client_data, api_data, aux_data, *args, **kwargs)\n        except Exception as e:\n            self.last_exception = RequestFailed(cause=e)\n        return None", "response": "Calls the request catching all exceptions and returns the result."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef call(self, client_data=None, api_data=None, aux_data=None, *args, **kwargs):\n        self.build_request(client_data=client_data, api_data=api_data, aux_data=aux_data)\n        self.caller = RequestCall(self.request)\n\n        try:\n            self.caller.call()\n            self.response = self.caller.response\n\n            if self.response is None:\n                raise ValueError('Empty response')\n            if self.response.response is None \\\n                    or 'response' not in self.response.response \\\n                    or self.response.response['response'] is None:\n                raise ValueError('No result data')\n\n            return self.response.response['response']\n\n        except Exception as e:\n            logger.debug('Exception traceback: %s' % traceback.format_exc())\n            logger.info('Exception thrown %s' % e)\n            raise\n        pass", "response": "Calls the request with input data using given configuration."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nbuilding the request for the current object.", "response": "def build_request(self, input_data=None, api_data=None, aux_data=None, *args, **kwargs):\n        \"\"\"\n        Builds request\n\n        :param input_data:\n        :param api_data:\n        :param aux_data:\n        :param args:\n        :param kwargs:\n        :return:\n        \"\"\"\n        if input_data is not None:\n            self.client_data = input_data\n        if api_data is not None:\n            self.api_data = api_data\n        if aux_data is not None:\n            self.aux_data = aux_data\n\n        self.request = RequestHolder()\n        self.request.nonce = get_random_vector(EBConsts.FRESHNESS_NONCE_LEN)\n\n        self.request.endpoint = self.get_endpoint()\n        self.request.url = self.get_endpoint().get_url() + self.url_suffix\n\n        self.request.configuration = self.config\n        self.request.api_method = self.operation\n        self.request.headers = {'X-Auth-Token': 'public'}\n\n        # Result request body\n        self.request.body = {\n            'nonce': to_hex(self.request.nonce),\n            'version': 1,\n            'function': self.operation,\n            'environment': self.env if self.env is not None else ENVIRONMENT_DEVELOPMENT,\n        }\n\n        if self.client_data is not None:\n            self.request.body['client'] = self.client_data\n        if self.api_data is not None:\n            self.request.body['apidata'] = self.api_data\n        if self.aux_data is not None:\n            if isinstance(self.aux_data, dict):\n                self.request.body = EBUtils.merge(self.request.body, self.aux_data)\n            else:\n                raise ValueError('Aux data has to be a dictionary')\n\n        self.request = self.extend_request(self.request)\n        return self.request"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef list(self, list_id):\n\n        r = requests.get(\n            \"https://kippt.com/api/users/%s/lists/%s\" % (self.id, list_id),\n            headers=self.kippt.header\n        )\n        return (r.json())", "response": "Retrieve the list given for the user."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nretrieving what the relationship between the user and the current user then authenticated user is.", "response": "def relationship(self):\n        \"\"\" Retrieve what the relationship between the user and\n        then authenticated user is.\n\n        \"\"\"\n        r = requests.get(\n            \"https://kippt.com/api/users/%s/relationship\" % (self.id),\n            headers=self.kippt.header\n        )\n        return (r.json())"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _find_titles(self, row_index, column_index):\n        '''\n        Helper method to find all titles for a particular cell.\n        '''\n        titles = []\n\n        for column_search in range(self.start[1], column_index):\n            cell = self.table[row_index][column_search]\n            if cell == None or (isinstance(cell, basestring) and not cell):\n                continue\n            elif isinstance(cell, basestring):\n                titles.append(cell)\n            else:\n                break\n\n        for row_search in range(self.start[0], row_index):\n            cell = self.table[row_search][column_index]\n            if cell == None or (isinstance(cell, basestring) and not cell):\n                continue\n            elif isinstance(cell, basestring):\n                titles.append(cell)\n            else:\n                break\n\n        return titles", "response": "Helper method to find all titles for a particular cell."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncopying the raw block into a new table.", "response": "def copy_raw_block(self):\n        '''\n        Copies the block as it was originally specified by start and end into a new table.\n\n        Returns:\n            A copy of the block with no block transformations.\n        '''\n        ctable = []\n        r, c = 0, 0\n        try:\n            for row_index in range(self.start[0], self.end[0]):\n                r = row_index\n                row = []\n                ctable.append(row)\n                for column_index in range(self.start[1], self.end[1]):\n                    c = column_index\n                    row.append(self.table[row_index][column_index])\n        except IndexError:\n            raise InvalidBlockError('Missing table element at [%d, %d]' % (r, c))\n        return ctable"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef copy_numbered_block(self):\n        '''\n        Copies the block as it was originally specified by start and end into a new table.\n        Additionally inserts the original table indices in the first row of the block.\n\n        Returns:\n            A copy of the block with no block transformations.\n        '''\n        raw_block = self.copy_raw_block()\n        # Inserts the column number in row 0\n        raw_block.insert(0, range(self.start[1], self.end[1]))\n        return raw_block", "response": "Copies the block as it was originally specified by start and end into a new table."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconverts the block into row titled elements.", "response": "def convert_to_row_table(self, add_units=True):\n        '''\n        Converts the block into row titled elements. These elements are copied into the return\n        table, which can be much longer than the  original block.\n\n        Args:\n            add_units: Indicates if units should be appened to each row item.\n\n        Returns:\n            A row-titled table representing the data in the block.\n        '''\n        rtable = []\n        if add_units:\n            relavent_units = self.get_relavent_units()\n\n        # Create a row for each data element\n        for row_index in range(self.start[0], self.end[0]):\n            for column_index in range(self.start[1], self.end[1]):\n                cell = self.table[row_index][column_index]\n                if cell != None and isinstance(cell, (int, float, long)):\n                    titles = self._find_titles(row_index, column_index)\n                    titles.append(cell)\n                    if add_units:\n                        titles.append(relavent_units.get((row_index, column_index)))\n                    rtable.append(titles)\n\n        # If we had all 'titles', just return the original block\n        if not rtable:\n            for row_index in range(self.start[0], self.end[0]):\n                row = []\n                rtable.append(row)\n                for column_index in range(self.start[1], self.end[1]):\n                    row.append(self.table[row_index][column_index])\n                if add_units:\n                    row.append(relavent_units.get((row_index, column_index)))\n\n        return rtable"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef flag_is_related(self, flag):\n        '''\n        Checks for relationship between a flag and this block.\n\n        Returns:\n            True if the flag is related to this block.\n        '''\n        same_worksheet = flag.worksheet == self.worksheet\n        if isinstance(flag.location, (tuple, list)):\n            return (flag.location[0] >= self.start[0] and flag.location[0] < self.end[0] and\n                    flag.location[1] >= self.start[1] and flag.location[1] < self.end[1] and\n                    same_worksheet)\n        else:\n            return same_worksheet", "response": "Checks for relationship between a flag and this block."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nchecks for relationship between a unit location and this block.", "response": "def unit_is_related(self, location, worksheet):\n        '''\n        Checks for relationship between a unit location and this block.\n\n        Returns:\n            True if the location is related to this block.\n        '''\n        same_worksheet = worksheet == self.worksheet\n        if isinstance(location, (tuple, list)):\n            return (location[0] >= self.start[0] and location[0] < self.end[0] and\n                    location[1] >= self.start[1] and location[1] < self.end[1] and\n                    same_worksheet)\n        else:\n            return same_worksheet"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nretrieving the relevant flags for this data block.", "response": "def get_relavent_flags(self):\n        '''\n        Retrieves the relevant flags for this data block.\n\n        Returns:\n            All flags related to this block.\n        '''\n        relavent_flags = {}\n\n        for code, flags_list in self.flags.items():\n            relavent_flags[code] = []\n            for flag in flags_list:\n                if self.flag_is_related(flag):\n                    relavent_flags[code].append(flag)\n            # Remove that flag level if no error exists\n            if not relavent_flags[code]:\n                del relavent_flags[code]\n\n        return relavent_flags"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the relevant units for this data block.", "response": "def get_relavent_units(self):\n        '''\n        Retrieves the relevant units for this data block.\n\n        Returns:\n            All flags related to this block.\n        '''\n        relavent_units = {}\n\n        for location,unit in self.units.items():\n            if self.unit_is_related(location, self.worksheet):\n                relavent_units[location] = unit\n\n        return relavent_units"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncheck if the block is valid and returns True if so False otherwise.", "response": "def validate_block(self):\n        '''\n        This method is a multi-stage process which repairs row titles, then repairs column titles,\n        then checks for invalid rows, and finally for invalid columns.\n\n        This maybe should have been written via state machines... Also suggested as being possibly\n        written with code-injection.\n        '''\n        # Don't allow for 0 width or 0 height blocks\n        if self._check_zero_size():\n            return False\n        # Single width or height blocks should be considered\n        self._check_one_size()\n\n        # Repair any obvious block structure issues\n        self._repair_row()\n        self._repair_column()\n\n        # Fill any remaining empty titles if we're not a complete block\n        if not self.complete_block:\n            self._fill_row_holes()\n            self._fill_column_holes()\n\n        # Check for invalid data after repairs\n        self._validate_rows()\n        self._validate_columns()\n\n        # We're valid enough to be used -- though error flags may have\n        # been thrown into flags.\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncheck for zero height or zero width blocks and flags the occurrence.", "response": "def _check_zero_size(self):\n        '''\n        Checks for zero height or zero width blocks and flags the occurrence.\n\n        Returns:\n            True if the block is size 0.\n        '''\n        block_zero = self.end[0] <= self.start[0] or self.end[1] <= self.start[1]\n        if block_zero:\n            self.flag_change(self.flags, 'fatal', worksheet=self.worksheet,\n                             message=self.FLAGS['0-size'])\n        return block_zero"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncheck if the occurrence is one size.", "response": "def _check_one_size(self):\n        '''\n        Checks for single height or single width blocks and flags the occurrence.\n\n        Returns:\n            True if the block is size 1.\n        '''\n        block_one = self.end[0] == self.start[0]+1 or self.end[1] == self.start[1]+1\n        if block_one:\n            self.flag_change(self.flags, 'error', self.start, self.worksheet,\n                             message=self.FLAGS['1-size'])\n        return block_one"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nrepair any missing titles in the table and automatically repair those titles.", "response": "def _repair_row(self):\n        '''\n        Searches for missing titles that can be inferred from the surrounding data and automatically\n        repairs those titles.\n        '''\n        # Repair any title rows\n        check_for_title = True\n        for row_index in range(self.start[0], self.end[0]):\n            table_row = self.table[row_index]\n            row_start = table_row[self.start[1]]\n\n            # Look for empty cells leading titles\n            if check_for_title and is_empty_cell(row_start):\n                self._stringify_row(row_index)\n            # Check for year titles in column or row\n            elif (isinstance(row_start, basestring) and\n                  re.search(allregex.year_regex, row_start)):\n                self._check_stringify_year_row(row_index)\n            else:\n                check_for_title = False"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _repair_column(self):\n        '''\n        Same as _repair_row but for columns.\n        '''\n        # Repair any title columns\n        check_for_title = True\n        for column_index in range(self.start[1], self.end[1]):\n            table_column = TableTranspose(self.table)[column_index]\n            column_start = table_column[self.start[0]]\n\n            # Only iterate through columns starting with a blank cell\n            if check_for_title and is_empty_cell(column_start):\n                self._stringify_column(column_index)\n            # Check for year titles in column or row\n            elif (isinstance(column_start, basestring) and\n                  re.search(allregex.year_regex, column_start)):\n                self._check_stringify_year_column(column_index)\n            else:\n                check_for_title = False", "response": "Repair the column names for the table."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _fill_row_holes(self):\n        '''\n        Fill any remaining row title cells that are empty. This must be done after the other passes\n        to avoid preemptively filling in empty cells reserved for other operations.\n        '''\n        for row_index in range(self.start[0], self.max_title_row):\n            table_row = self.table[row_index]\n            row_start = table_row[self.start[1]]\n            if is_text_cell(row_start):\n                self._check_fill_title_row(row_index)", "response": "Fill any remaining row title cells that are empty."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nfills the column holes with the title of the first cell.", "response": "def _fill_column_holes(self):\n        '''\n        Same as _fill_row_holes but for columns.\n        '''\n        for column_index in range(self.start[1], self.end[1]):\n            table_column = TableTranspose(self.table)[column_index]\n            column_start = table_column[self.start[0]]\n            if is_text_cell(column_start):\n                self._check_fill_title_column(column_index)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _validate_rows(self):\n        '''\n        Checks for any missing data row by row. It also checks for changes in cell type and flags\n        multiple switches as an error.\n        '''\n        for row_index in range(self.start[0], self.end[0]):\n            table_row = self.table[row_index]\n            used_row = self.used_cells[row_index]\n\n            row_type = None\n            if self.end[1] > self.start[1]:\n                row_type = get_cell_type(table_row[self.start[1]])\n\n            num_type_changes = 0\n            for column_index in range(self.start[1], self.end[1]):\n                if used_row[column_index]:\n                    self.flag_change(self.flags, 'error', (row_index, column_index),\n                                     self.worksheet, self.FLAGS['used'])\n                if not check_cell_type(table_row[column_index], row_type):\n                    row_type = get_cell_type(table_row[column_index])\n                    num_type_changes += 1\n                if num_type_changes > 1:\n                    self.flag_change(self.flags, 'warning', (row_index, column_index-1),\n                                     self.worksheet, self.FLAGS['unexpected-change'])\n                    # Decrement this to catch other cells which change again\n                    num_type_changes -= 1\n                # Mark this cell as used\n                used_row[column_index] = True", "response": "Checks for any missing data rows by row. It also checks for any changes in cell type and flags\n        multiple switches as an error."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _validate_columns(self):\n        '''\n        Same as _validate_rows but for columns. Also ignore used_cells as _validate_rows should\n        update used_cells.\n        '''\n        for column_index in range(self.start[1], self.end[1]):\n            table_column = TableTranspose(self.table)[column_index]\n\n            column_type = None\n            if self.end[0] > self.start[0]:\n                column_type = get_cell_type(table_column[self.start[0]])\n\n            num_type_changes = 0\n            for row_index in range(self.start[0], self.end[0]):\n                if not check_cell_type(table_column[row_index], column_type):\n                    column_type = get_cell_type(table_column[row_index])\n                    num_type_changes += 1\n                if num_type_changes > 1:\n                    self.flag_change(self.flags, 'warning', (row_index-1, column_index),\n                                     self.worksheet, self.FLAGS['unexpected-change'])\n                    # Decrement this to catch other cells which change again\n                    num_type_changes -= 1", "response": "Validate the columns of the table."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _stringify_row(self, row_index):\n        '''\n        Stringifies an entire row, filling in blanks with prior titles as they are found.\n        '''\n        table_row = self.table[row_index]\n        prior_cell = None\n        for column_index in range(self.start[1], self.end[1]):\n            cell, changed = self._check_interpret_cell(table_row[column_index], prior_cell, row_index, column_index)\n            if changed:\n                table_row[column_index] = cell\n            prior_cell = cell", "response": "Stringifies an entire row filling in blanks with prior titles as they are found."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _stringify_column(self, column_index):\n        '''\n        Same as _stringify_row but for columns.\n        '''\n        table_column = TableTranspose(self.table)[column_index]\n        prior_cell = None\n        for row_index in range(self.start[0], self.end[0]):\n            cell, changed = self._check_interpret_cell(table_column[row_index], prior_cell, row_index, column_index)\n            if changed:\n                table_column[row_index] = cell\n            prior_cell = cell", "response": "Same as _stringify_row but for columns."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _check_interpret_cell(self, cell, prior_cell, row_index, column_index):\n        '''\n        Helper function which checks cell type and performs cell translation to strings where\n        necessary.\n\n        Returns:\n            A tuple of the form '(cell, changed)' where 'changed' indicates if 'cell' differs from\n            input.\n        '''\n        changed = False\n        if (not is_empty_cell(cell) and\n            not is_text_cell(cell)):\n            self.flag_change(self.flags, 'interpreted', (row_index, column_index),\n                             self.worksheet, self.FLAGS['converted-to-string'])\n            cell = str(cell)\n            changed = True\n        # If we find a blank cell, propagate the prior title\n        elif is_empty_cell(cell):\n            self.flag_change(self.flags, 'interpreted', (row_index, column_index),\n                             self.worksheet, self.FLAGS['copied-title'])\n            cell = prior_cell\n            changed = True\n        return cell, changed", "response": "Helper function which checks the cell type and performs cell translation to strings where\n            necessary."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _check_fill_title_row(self, row_index):\n        '''\n        Checks the given row to see if it is all titles and fills any blanks cells if that is the\n        case.\n        '''\n        table_row = self.table[row_index]\n        # Determine if the whole row is titles\n        prior_row = self.table[row_index-1] if row_index > 0 else table_row\n        for column_index in range(self.start[1], self.end[1]):\n            if is_num_cell(table_row[column_index]) or is_num_cell(prior_row[column_index]):\n                return\n        # Since we're a title row, stringify the row\n        self._stringify_row(row_index)", "response": "Checks the given row to see if it is all titles and fills any blanks cells if that is the\n        case."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _check_fill_title_column(self, column_index):\n        '''\n        Same as _check_fill_title_row but for columns.\n        '''\n        # Determine if the whole column is titles\n        table_column = TableTranspose(self.table)[column_index]\n        prior_column = TableTranspose(self.table)[column_index-1] if column_index > 0 else table_column\n        for row_index in range(self.start[0], self.end[0]):\n            if is_num_cell(table_column[row_index]) or is_num_cell(prior_column[row_index]):\n                return\n        # Since we're a title row, stringify the column\n        self._stringify_column(column_index)", "response": "Check if the column is titles."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncheck the given row to see if it is labeled year data and fills any blank years within that entry.", "response": "def _check_stringify_year_row(self, row_index):\n        '''\n        Checks the given row to see if it is labeled year data and fills any blank years within that\n        data.\n        '''\n        table_row = self.table[row_index]\n        # State trackers\n        prior_year = None\n        for column_index in range(self.start[1]+1, self.end[1]):\n            current_year = table_row[column_index]\n            # Quit if we see\n            if not self._check_years(current_year, prior_year):\n                return\n            # Only copy when we see a non-empty entry\n            if current_year:\n                prior_year = current_year\n\n        # If we have a title of years, convert them to strings\n        self._stringify_row(row_index)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _check_stringify_year_column(self, column_index):\n        '''\n        Same as _check_stringify_year_row but for columns.\n        '''\n        table_column = TableTranspose(self.table)[column_index]\n        # State trackers\n        prior_year = None\n        for row_index in range(self.start[0]+1, self.end[0]):\n            current_year = table_column[row_index]\n            if not self._check_years(current_year, prior_year):\n                return\n            # Only copy when we see a non-empty entry\n            if current_year:\n                prior_year = current_year\n\n        # If we have a title of years, convert them to strings\n        self._stringify_column(column_index)", "response": "Check if the column_index is in the table and if so convert the string representation of the entries to the strings representation of the entries."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef file_hash(content):\n    h = hashlib.sha256()\n    if isinstance(content, bytes_type):\n        h.update(content)\n    else:\n        data = True\n        while data:\n            data = content.read(1024 * 1024)\n            h.update(data)\n    h_digest = h.digest()\n    # base64url\n    # | char | substitute |\n    # |   +  |    -       |\n    # |   /  |    _       |\n    #\n    result = base64.b64encode(h_digest, altchars=b'-_')\n    # ensure this is a str object in 3.x\n    result = result.decode('ascii')\n    result = result.rstrip('=')\n\n    if result[:2].lower() == 'ad':\n        # workaround adblockers blocking everything starting with \"ad\"\n        # by replacing the \"d\" with another charackter\n        if result[1] == 'd':\n            result = result[0] + '~' + result[2:]\n        else:\n            # upper case D\n            result = result[0] + '.' + result[2:]\n\n    return result", "response": "Generate hash for file or file - like object."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef init(scope, app, settings):\n    cfg = settings.get('rw.static', {})\n    static = Static()\n    scope['static'] = static\n    scope['template_env'].globals['static'] = static\n    for base_uri, sources in cfg.items():\n        full_paths = []\n        for source in sources:\n            if isinstance(source, dict):\n                full_path = source['path']\n                full_paths.append(full_path.format(**os.environ))\n                continue\n            elif ',' in source:\n                module_name, path = [part.strip()\n                                     for part in source.split(',')]\n            else:\n                module_name = source\n                path = 'static'\n            full_path = pkg_resources.resource_filename(module_name, path)\n            full_paths.append(full_path)\n\n        app.root.mount('/' + base_uri + '/<h>/<path:path>',\n                       StaticHandler, {'path': full_paths},\n                       name='static_' + base_uri.replace('.', '_'))\n\n        static.handlers.append((base_uri, StaticHandler, full_paths))\n    static.setup()", "response": "Initialize the plugin for serving static files in development mode"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_absolute_path(cls, roots, path):\n        for root in roots:\n            abspath = os.path.abspath(os.path.join(root, path))\n            if abspath.startswith(root) and os.path.exists(abspath):\n                return abspath\n        # XXX TODO\n        return 'file-not-found'", "response": "Returns the absolute location of path relative to one of the roots."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nvalidate and return the absolute path.", "response": "def validate_absolute_path(self, roots, absolute_path):\n        \"\"\"Validate and return the absolute path.\n\n        ``root`` is the configured path for the `StaticFileHandler`,\n        and ``path`` is the result of `get_absolute_path`\n\n        This is an instance method called during request processing,\n        so it may raise `HTTPError` or use methods like\n        `RequestHandler.redirect` (return None after redirecting to\n        halt further processing).  This is where 404 errors for missing files\n        are generated.\n        \"\"\"\n        if absolute_path is None:\n            raise tornado.web.HTTPError(404)\n\n        for root in roots:\n\n            if (absolute_path + os.path.sep).startswith(root):\n                break\n        else:\n            raise tornado.web.HTTPError(403, \"%s is not in root static directory\",\n                                        self.path)\n\n        if not os.path.isfile(absolute_path):\n            raise tornado.web.HTTPError(403, \"%s is not a file\", self.path)\n\n        return absolute_path"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef upload_file_to_bucket(self, bucket, file_path, key, is_public=False):\n\n        with open(file_path, 'rb') as data:\n            self.__s3.upload_fileobj(data, bucket, key)\n\n        if is_public:\n            self.__s3.put_object_acl(ACL='public-read', Bucket=bucket, Key=key)\n\n        bucket_location = self.__s3.get_bucket_location(Bucket=bucket)\n        file_url = \"https://s3-{0}.amazonaws.com/{1}/{2}\".format(\n            bucket_location['LocationConstraint'],\n            bucket,\n            key)\n\n        return file_url", "response": "Uploads a file to a bucket."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndownloading a file from S3 Bucket", "response": "def download_file_from_bucket(self, bucket, file_path, key):\n        \"\"\" Download file from S3 Bucket \"\"\"\n        with open(file_path, 'wb') as data:\n            self.__s3.download_fileobj(bucket, key, data)\n            return file_path"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef next(self):\n        while True:\n            self.cur_idx += 1\n            if self.__datasource.populate_iteration(self):\n                return self\n\n        raise StopIteration", "response": "Move to the next valid loci."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef replace(value, arg):\n\n    replacement = arg.split('|')\n    try:\n        return value.replace(replacement[0], replacement[1])\n    except:\n        return value", "response": "Replaces one string with another in a given string\n    usage"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ngive a list of strings format them with commas and spaces and at the end of the list.", "response": "def humanized_join(value, add_links=False):\n    \"\"\"\n    Given a list of strings, format them with commas and spaces,\n    but with 'and' at the end.\n\n    >>> humanized_join(['apples', 'oranges', 'pears'])\n    \"apples, oranges, and pears\"\n\n    In a template, if mylist = ['apples', 'oranges', 'pears']\n    then {{ mylist|humanized_join }}\n    will output \"apples, oranges, and pears\"\n\n    Passing the add_links option will wrap each item in a link.\n    Note this requires that anything being passed has get_absolute_url() defined.\n\n    then {{ mylist|humanized_join:'add_links' }}\n    will output \"<a href=\"...\">apples</a>, <a href=\"...\">oranges</a>, and <a href=\"...\">pears</a>\"\n\n    \"\"\"\n    if add_links:\n        try:\n            value = ['<a href=\"%s\">%s</a>' % (item.get_absolute_url(), item) for item in value]\n        except AttributeError:\n            print(\"You did not pass objects with get_absolute_url() method.\")\n            return\n    else:\n        # make everything a string to avoid errors\n        value = [six.u(item) for item in value]\n\n    if len(value) == 1:\n        return mark_safe(value[0])\n    if len(value) == 2:\n        return mark_safe(\"%s and %s\" % (value[0], value[1]))\n\n    # join all but the last element\n    all_but_last = \", \".join(value[:-1])\n    return mark_safe(\"%s, and %s\" % (all_but_last, value[-1]))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _combine_sparse_successor(parent_indices, parent_shape, child_indices, child_values, child_shape, name=None):\n\n    with ops.name_scope(name, \"CombineSparseSuccessor\",\n                        [parent_indices, parent_shape, child_indices, child_values, child_shape]):\n        indices, values, shape = ops_module.combine_sparse_successor(\n            parent_indices,\n            parent_shape,\n            child_indices,\n            child_values,\n            child_shape\n        )\n\n        return tf.SparseTensor(indices=indices, values=values, dense_shape=shape)", "response": "Combines two string SparseTensor s where second SparseTensor is the result of expanding\n    first SparseTensor s values."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef expand_char_ngrams(source, minn, maxn, itself='ASIS', name=None):\n\n    with ops.name_scope(name, \"ExpandCharNgrams\", [source]):\n        source = convert_to_tensor_or_sparse_tensor(source, dtype=tf.string)\n        if isinstance(source, tf.SparseTensor):\n            child_indices, child_values, child_shape = ops_module.expand_char_ngrams(source.values, minn, maxn, itself)\n            result = _combine_sparse_successor(source.indices, source.dense_shape, child_indices, child_values,\n                                               child_shape)\n        else:\n            indices, values, shape = ops_module.expand_char_ngrams(source, minn, maxn, itself)\n            result = tf.SparseTensor(indices=indices, values=values, dense_shape=shape)\n\n        return result", "response": "Splits unicode strings into char ngrams. Ngrams size configures with minn and maxn."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nnormalizes unicode strings tensor.", "response": "def transform_normalize_unicode(source, form, name=None):\n    \"\"\"Normalize unicode strings tensor.\n\n    Args:\n        source: `Tensor` or `SparseTensor` of any shape, strings to normalize.\n        form: Scalar value, name of normalization algorithm.\n            One of `\"NFD\"`, `\"NFC\"`, `\"NFKD\"`, `\"NFKC\"`.\n        name: A name for the operation (optional).\n    Returns:\n        `Tensor` or `SparseTensor` of same shape and size as input.\n    \"\"\"\n\n    with ops.name_scope(name, \"TransformNormalizeUnicode\", [source]):\n        source = convert_to_tensor_or_sparse_tensor(source, dtype=tf.string)\n        if isinstance(source, tf.SparseTensor):\n            result = tf.SparseTensor(\n                indices=source.indices,\n                values=ops_module.transform_normalize_unicode(source.values, form),\n                dense_shape=source.dense_shape\n            )\n        else:\n            result = ops_module.transform_normalize_unicode(source, form)\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreplaces all substrings from needle to corresponding strings in haystack with source.", "response": "def transform_regex_replace(source, pattern, rewrite, name=None):\n    \"\"\"Replace all substrings from `needle` to corresponding strings in `haystack` with source.\n\n    Args:\n        source: `Tensor` or `SparseTensor` of any shape, source strings for replacing.\n        pattern: List of RE2 patterns to search in source\n        rewrite: List of strings to replace with. Should have same length as `needle`.\n        name: A name for the operation (optional).\n    Returns:\n        `Tensor` or `SparseTensor` of same shape and size as input.\n    \"\"\"\n\n    with ops.name_scope(name, \"TransformRegexReplace\", [source]):\n        source = convert_to_tensor_or_sparse_tensor(source, dtype=tf.string)\n        if isinstance(source, tf.SparseTensor):\n            result = tf.SparseTensor(\n                indices=source.indices,\n                values=ops_module.transform_regex_replace(source.values, pattern, rewrite),\n                dense_shape=source.dense_shape\n            )\n        else:\n            result = ops_module.transform_regex_replace(source, pattern, rewrite)\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef transform_string_replace(source, needle, haystack, name=None):\n\n    with ops.name_scope(name, \"TransformStringReplace\", [source]):\n        source = convert_to_tensor_or_sparse_tensor(source, dtype=tf.string)\n        if isinstance(source, tf.SparseTensor):\n            result = tf.SparseTensor(\n                indices=source.indices,\n                values=ops_module.transform_string_replace(source.values, needle, haystack),\n                dense_shape=source.dense_shape\n            )\n        else:\n            result = ops_module.transform_string_replace(source, needle, haystack)\n\n    return result", "response": "Replace all substrings from needle to corresponding strings in haystack with source."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nwrap source strings with left and right strings", "response": "def transform_wrap_with(source, left, right, name=None):\n    \"\"\"Wrap source strings with \"left\" and \"right\" strings\n\n    Args:\n        source: `Tensor` or `SparseTensor` of any shape, strings to replace digits.\n        left: Scalar string to add in the beginning\n        right: Scalar string to add in the ending\n        name: A name for the operation (optional).\n    Returns:\n        `SparseTensor` of same shape and size as input.\n    \"\"\"\n\n    with ops.name_scope(name, \"TransformWrapWith\", [source]):\n        source = convert_to_tensor_or_sparse_tensor(source, dtype=tf.string)\n        if isinstance(source, tf.SparseTensor):\n            result = tf.SparseTensor(\n                indices=source.indices,\n                values=ops_module.transform_wrap_with(source.values, left, right),\n                dense_shape=source.dense_shape\n            )\n        else:\n            result = ops_module.transform_wrap_with(source, left, right)\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndisplays for all logs to stdout", "response": "def display(level='DEBUG'):\n    \"\"\"display(level='DEBUG') forwards logs to stdout\"\"\"\n    logger = get_logger()\n    sh = logging.StreamHandler()\n    sh.setLevel(getattr(logging, level))\n    sh.setFormatter(DEFAULT_LOG_FORMAT)\n    logger.addHandler(sh)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngenerating an SQL LIKE filter generator based on the given data.", "response": "def Where_filter_gen(*data):\n    \"\"\"\n    Generate an sqlite \"LIKE\" filter generator based on the given data.\n    This functions arguments should be a N length series of field and data\n    tuples.\n    \"\"\"\n    where = []\n\n    def Fwhere(field, pattern):\n        \"\"\"Add where filter for the given field with the given pattern.\"\"\"\n        where.append(\"WHERE {0} LIKE '{1}'\".format(field, pattern))\n\n    def Fstring(field, string):\n        \"\"\"Add a where filter based on a string.\"\"\"\n        Fwhere(field, \"%{0}%\".format(string if not isinstance(string, str)\n                                     else str(string)))\n\n    def Fdict(field, data):\n        \"\"\"Add where filters to search for dict keys and values.\"\"\"\n        for key, value in data.items():\n            if value == '*':\n                Fstring(field, key)\n            else:\n                Fstring(field, \"{0}:%{1}\".format(key, value if not\n                                                 isinstance(value, str)\n                                                 else str(value)))\n\n    def Flist(field, data):\n        \"\"\"Add where filters to search for elements of a list.\"\"\"\n        for elem in data:\n            Fstring(field, elem if not isinstance(elem, str) else\n                    str(elem))\n\n    for field, data in data:\n        if isinstance(data, str):\n            Fstring(field, data)\n        elif isinstance(data, dict):\n            Fdict(field, data)\n        elif isinstance(data, list):\n            Flist(field, data)\n\n    return ' AND '.join(where)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef cache_card(self, card):\n        code = card.code\n        self.card_cache[code] = card\n        if code in self.card_cache_list:\n            self.card_cache_list.remove(code)\n        self.card_cache_list.append(code)\n\n        if len(self.card_cache_list) > self.cachelimit:\n            del self.card_cache[self.card_cache_list.pop(0)]", "response": "Cache the card for faster future lookups."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nload a card with the given code from the database.", "response": "def load_card(self, code, cache=True):\n        \"\"\"\n        Load a card with the given code from the database. This calls each\n        save event hook on the save string before commiting it to the database.\n\n        Will cache each resulting card for faster future lookups with this\n        method while respecting the libraries cache limit. However only if the\n        cache argument is True.\n\n        Will return None if the card could not be loaded.\n        \"\"\"\n        card = self.card_cache.get(code, None)\n        if card is None:\n            code = code if isinstance(code, str) else str(code)\n            with sqlite3.connect(self.dbname) as carddb:\n                result = carddb.execute(\n                    \"SELECT * FROM CARDS WHERE code = ?\", (code,))\n                loadrow = result.fetchone()\n                if not loadrow:\n                    return None\n                loaddict = dict(zip(FIELDS, loadrow))\n                card = self.cardclass(loaddict=loaddict)\n            if cache:\n                self.cache_card(card)\n        return card"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsaves the given card to the database.", "response": "def save_card(self, card, cache=False):\n        \"\"\"\n        Save the given card to the database. This calls each save event hook\n        on the save string before commiting it to the database.\n        \"\"\"\n        if cache:\n            self.cache_card(card)\n        carddict = card.save()\n        with sqlite3.connect(self.dbname) as carddb:\n            carddb.execute(\"DELETE from CARDS where code = ?\",\n                           (carddict[\"code\"],))\n            carddb.execute(\"INSERT INTO CARDS VALUES(?, ?, ?, ?, ?)\",\n                           [carddict[key] if isinstance(carddict[key], str)\n                            else str(carddict[key]) for key in FIELDS])"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef filter_search(self, code=None, name=None, abilities=None,\n                      attributes=None, info=None):\n        \"\"\"\n        Return a list of codes and names pertaining to cards that have the\n        given information values stored.\n\n        Can take a code integer, name string, abilities dict {phase: ability\n        list/\"*\"}, attributes list, info dict {key, value list/\"*\"}.\n\n        In the above argument examples \"*\" is a string that may be passed\n        instead of a list as the dict value to match anything that stores that\n        key.\n        \"\"\"\n        command = \"SELECT code, name FROM CARDS \"\n        command += Where_filter_gen((\"code\", code), (\"name\", name),\n                                    (\"abilities\", abilities),\n                                    (\"attributes\", attributes),\n                                    (\"info\", info))\n\n        with sqlite3.connect(self.dbname) as carddb:\n            return carddb.execute(command).fetchall()", "response": "Filter cards by given information values stored."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef to_unit(C, val, unit=None):\r\n        md = re.match(r'^(?P<num>[\\d\\.]+)(?P<unit>.*)$', val)\r\n        if md is not None:\r\n            un = float(md.group('num')) * CSS.units[md.group('unit')]\r\n            if unit is not None:\r\n                return un.asUnit(unit)\r\n            else:\r\n                return un", "response": "convert a string measurement to a Unum"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef merge_stylesheets(Class, fn, *cssfns):\r\n        stylesheet = Class(fn=fn)\r\n        for cssfn in cssfns:\r\n            css = Class(fn=cssfn)\r\n            for sel in sorted(css.styles.keys()):\r\n                if sel not in stylesheet.styles:\r\n                    stylesheet.styles[sel] = css.styles[sel]\r\n                else: \r\n                    for prop in [prop for prop in css.styles[sel] if prop not in stylesheet.styles[sel]]:\r\n                        stylesheet.styles[sel][prop] = css.styles[sel][prop]\r\n        return stylesheet", "response": "merge the given CSS files in order into a single stylesheet. First listed takes priority."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef all_selectors(Class, fn):\r\n        selectors = []\r\n        cssparser = cssutils.CSSParser(validate=False)\r\n        css = cssparser.parseFile(fn)\r\n        for rule in [r for r in css.cssRules if type(r)==cssutils.css.CSSStyleRule]:\r\n            selectors += [sel.selectorText for sel in rule.selectorList]\r\n        selectors = sorted(list(set(selectors)))\r\n        return selectors", "response": "return a sorted list of selectors that occur in the stylesheet"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef selector_to_xpath(cls, selector, xmlns=None):\r\n        selector = selector.replace(' .', ' *.')\r\n        if selector[0] == '.':\r\n            selector = '*' + selector\r\n            log.debug(selector)\r\n        \r\n        if '#' in selector:\r\n            selector = selector.replace('#', '*#')\r\n            log.debug(selector)\r\n\r\n        if xmlns is not None:\r\n            prefix = list(xmlns.keys())[0]\r\n            href = xmlns[prefix]\r\n            selector = ' '.join([\r\n                (n.strip() != '>' and prefix + '|' + n.strip() or n.strip())\r\n                for n in selector.split(' ')\r\n                ])\r\n            log.debug(selector)\r\n        \r\n        path = cssselect.GenericTranslator().css_to_xpath(selector)\r\n        path = path.replace(\"descendant-or-self::\", \"\")\r\n        path = path.replace(\"/descendant::\", \"//\")\r\n        path = path.replace('/*/', '//')\r\n        \r\n        log.debug(' ==> %s' % path)\r\n        \r\n        return path", "response": "convert a css selector into an xpath expression. xmlns is option single - item dict with namespace prefix and href"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef cmyk_to_rgb(Class, c, m, y, k):\r\n        c = float(c)/100.0\r\n        m = float(m)/100.0\r\n        y = float(y)/100.0\r\n        k = float(k)/100.0\r\n\r\n        nc = (c * (1-k)) + k\r\n        nm = (m * (1-k)) + k\r\n        ny = (y * (1-k)) + k\r\n\r\n        r = int((1-nc) * 255)\r\n        g = int((1-nm) * 255)\r\n        b = int((1-ny) * 255)\r\n\r\n        return dict(r=r, g=g, b=b)", "response": "Convert CMYK in % to RGB in 0 - 255"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef rgb_to_hex(Class, r, g, b):\r\n        return (\"%2s%2s%2s\" % \r\n                (hex(int(r)).lstrip('0x'), hex(int(g)).lstrip('0x'), hex(int(b)).lstrip('0x'))\r\n            ).replace(' ', '0').upper()", "response": "RGB in 0 - 255 to hex"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef getargs():\n    from argparse import ArgumentParser\n    '''\n    Return arguments\n    '''\n    parser = ArgumentParser(description='Answer yes or no to a question.')\n    parser.add_argument(\"question\", type=str, help=\"A question to ask.\")\n    return parser.parse_args()", "response": "Return the arguments for the\n    command line."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ntransitions to execute complete", "response": "def transition_to_execute_complete(self):\n        \"\"\"Transition to execute complate\"\"\"\n        assert self.state in [AQStateMachineStates.execute]\n        self.state = AQStateMachineStates.execute_complete"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef transition_to_rollback_complete(self):\n        assert self.state in [AQStateMachineStates.rollback]\n        self.state = AQStateMachineStates.rollback_complate", "response": "Transition to rollback complete"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get(self, key, sort_key):\n        key = self.prefixed('{}:{}'.format(key, sort_key))\n        self.logger.debug('Storage - get {}'.format(key))\n        if key not in self.cache.keys():\n            return None\n        return self.cache[key]", "response": "Get an element from the cache."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndeletes an element in dictionary", "response": "def delete(self, key, sort_key):\n        primary_key = key\n        key = self.prefixed('{}:{}'.format(key, sort_key))\n        \"\"\" Delete an element in dictionary \"\"\"\n        self.logger.debug('Storage - delete {}'.format(key))\n        if sort_key is not None:\n            self.cache[self.prefixed(primary_key)].remove(sort_key)\n        for index in self._secondary_indexes:\n            obj = json.loads(self.cache[key])\n            if index in obj.keys():\n                self.cache['secondary_indexes'][index][obj[index]].remove(\n                    key)\n        del(self.cache[key])\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_flask_metadata(app, version, repository, description,\n                       api_version=\"1.0\", name=None, auth=None,\n                       route=None):\n    \"\"\"\n    Sets metadata on the application to be returned via metadata routes.\n\n    Parameters\n    ----------\n    app : :class:`flask.Flask` instance\n        Flask application for the microservice you're adding metadata to.\n\n    version: `str`\n        Version of your microservice.\n\n    repository: `str`\n        URL of the repository containing your microservice's source code.\n\n    description: `str`\n        Description of the microservice.\n\n    api_version: `str`, optional\n        Version of the SQuaRE service API framework.  Defaults to '1.0'.\n\n    name : `str`, optional\n        Microservice name.  Defaults to the Flask app name.  If set, changes\n        the Flask app name to match.\n\n    auth : `dict`, `str`, or `None`\n        The 'auth' parameter must be None, the empty string, the string\n        'none', or a dict containing a 'type' key, which must be 'none',\n        'basic', or 'bitly-proxy'.  If the type is not 'none', there must\n        also be a 'data' key containing a dict which holds authentication\n        information appropriate to the authentication type.  The legal\n        non-dict 'auth' values are equivalent to a 'type' key of 'none'.\n\n    route : `None`, `str`, or list of `str`, optional\n        The 'route' parameter must be None, a string, or a list of strings.\n        If supplied, each string will be prepended to the metadata route.\n\n    Raises\n    ------\n    TypeError\n        If arguments are not of the appropriate type.\n    ValueError\n        If arguments are the right type but have illegal values.\n\n    Returns\n    -------\n        Nothing, but sets `app` metadata and decorates it with `/metadata`\n        and `/v{app_version}/metadata` routes.\n    \"\"\"\n\n    errstr = set_flask_metadata.__doc__\n    if not isinstance(app, Flask):\n        raise TypeError(errstr)\n    if name is None:\n        name = app.name\n    app.config[\"NAME\"] = name\n    if app.name != name:\n        app.name = name\n    app.config[\"VERSION\"] = version\n    app.config[\"REPOSITORY\"] = repository\n    app.config[\"DESCRIPTION\"] = description\n    app.config[\"API_VERSION\"] = api_version\n    if not (isinstance(name, str) and isinstance(description, str) and\n            isinstance(repository, str) and isinstance(version, str) and\n            isinstance(api_version, str)):\n        raise TypeError(errstr)\n    if not (name and description and repository and version and api_version):\n        raise ValueError(errstr)\n    if auth is None or (isinstance(auth, str) and ((auth == \"none\") or\n                                                   (auth == \"\"))):\n        auth = {\"type\": \"none\",\n                \"data\": None}\n    if not isinstance(auth, dict):\n        raise TypeError(errstr)\n    if \"type\" not in auth:\n        raise ValueError(errstr)\n    atp = auth[\"type\"]\n    if atp == \"none\":\n        app.config[\"AUTH\"] = {\"type\": \"none\",\n                              \"data\": None}\n    else:\n        if atp not in [\"basic\", \"bitly-proxy\"] or \"data\" not in auth:\n            raise ValueError(errstr)\n    app.config[\"AUTH\"] = auth\n    add_metadata_route(app, route)", "response": "Sets the application metadata for the microservice."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_metadata_route(app, route):\n    errstr = add_metadata_route.__doc__\n    if route is None:\n        route = [\"\"]\n    if isinstance(route, str):\n        route = [route]\n    if not isinstance(route, list):\n        raise TypeError(errstr)\n    if not all(isinstance(item, str) for item in route):\n        raise TypeError(errstr)\n    api_version = app.config[\"API_VERSION\"]\n\n    for rcomp in route:\n        # Make canonical\n        rcomp = \"/\" + rcomp.strip(\"/\")\n        if rcomp == \"/\":\n            rcomp = \"\"\n        for rbase in [\"/metadata\", \"/v\" + api_version + \"/metadata\"]:\n            for rext in [\"\", \".json\"]:\n                rte = rcomp + rbase + rext\n                with app.app_context():\n                    app.add_url_rule(rte, '_return_metadata', _return_metadata)", "response": "Adds a route that returns service metadata."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _return_metadata():\n    app = current_app\n    retdict = {\"auth\": app.config[\"AUTH\"][\"type\"]}\n    for fld in [\"name\", \"repository\", \"version\", \"description\",\n                \"api_version\"]:\n        retdict[fld] = app.config[fld.upper()]\n    return jsonify(retdict)", "response": "Return the metadata for the route attachment."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nretry an HTTP request with linear backoff.", "response": "def retry_request(method, url, headers=None, payload=None, auth=None,\n                  tries=10, initial_interval=5, callback=None):\n    \"\"\"Retry an HTTP request with linear backoff.  Returns the response if\n    the status code is < 400 or waits (try * initial_interval) seconds and\n    retries (up to tries times) if it\n    is not.\n\n    Parameters\n    ----------\n    method: `str`\n        Method: `GET`, `PUT`, or `POST`\n    url: `str`\n        URL of HTTP request\n    headers: `dict`\n        HTTP headers to supply.\n    payload: `dict`\n        Payload for request; passed as parameters to `GET`, JSON message\n        body for `PUT`/`POST`.\n    auth: `tuple`\n        Authentication tuple for Basic/Digest/Custom HTTP Auth.\n    tries: `int`\n        Number of attempts to make.  Defaults to `10`.\n    initial_interval: `int`\n        Interval between first and second try, and amount of time added\n        before each successive attempt is made.  Defaults to `5`.\n    callback : callable\n        A callable (function) object that is called each time a retry is\n        needed. The callable has a keyword argument signature:\n\n        - ``n``: number of tries completed (integer).\n        - ``remaining``: number of tries remaining (integer).\n        - ``status``: HTTP status of the previous call.\n        - ``content``: body content of the previous call.\n\n    Returns\n    -------\n    :class:`requests.Response`\n        The final HTTP Response received.\n\n    Raises\n    ------\n    :class:`apikit.BackendError`\n        The `status_code` will be `500`, and the reason `Internal Server\n        Error`.  Its `content` will be diagnostic of the last response\n        received.\n    \"\"\"\n    method = method.lower()\n    attempt = 1\n    while True:\n        if method == \"get\":\n            resp = requests.get(url, headers=headers, params=payload,\n                                auth=auth)\n        elif method == \"put\" or method == \"post\":\n            resp = requests.put(url, headers=headers, json=payload, auth=auth)\n        else:\n            raise_ise(\"Bad method %s: must be 'get', 'put', or 'post\" %\n                      method)\n        if resp.status_code < 400:\n            break\n        delay = initial_interval * attempt\n        if attempt >= tries:\n            raise_ise(\"Failed to '%s' %s after %d attempts.\" %\n                      (method, url, tries) +\n                      \"  Last response was '%d %s' [%s]\" %\n                      (resp.status_code, resp.reason, resp.text.strip()))\n        if callback is not None:\n            callback(n=attempt, remaining=tries - attempt,\n                     status=resp.status_code, content=resp.text.strip())\n        time.sleep(delay)\n        attempt += 1\n    return resp"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef raise_ise(text):\n    if isinstance(text, Exception):\n        # Just in case we are exuberantly passed the entire Exception and\n        #  not its textual representation.\n        text = str(text)\n    raise BackendError(status_code=500,\n                       reason=\"Internal Server Error\",\n                       content=text)", "response": "Turn a failed request response into a BackendError that represents\n    an Internal Server Error."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef raise_from_response(resp):\n    if resp.status_code < 400:\n        # Request was successful.  Or at least, not a failure.\n        return\n    raise BackendError(status_code=resp.status_code,\n                       reason=resp.reason,\n                       content=resp.text)", "response": "Turn a failed request response into a BackendError."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_logger(file=None, syslog=False, loghost=None, level=None):\n\n    if not syslog:\n        if not file:\n            handler = logging.StreamHandler(sys.stdout)\n        else:\n            handler = logging.FileHandler(file)\n    else:\n        if loghost:\n            handler = logging.handlers.SysLogHandler(loghost, 514)\n        else:\n            handler = logging.handlers.SysLogHandler()\n    root_logger = logging.getLogger()\n    if level:\n        level = level.upper()\n        lldict = {\n            'DEBUG': logging.DEBUG,\n            'INFO': logging.INFO,\n            'WARNING': logging.WARNING,\n            'ERROR': logging.ERROR,\n            'CRITICAL': logging.CRITICAL\n        }\n        if level in lldict:\n            root_logger.setLevel(lldict[level])\n    root_logger.addHandler(handler)\n    structlog.configure(\n        processors=[\n            structlog.stdlib.filter_by_level,\n            structlog.stdlib.add_logger_name,\n            structlog.stdlib.add_log_level,\n            structlog.stdlib.PositionalArgumentsFormatter(),\n            structlog.processors.TimeStamper(fmt=\"iso\"),\n            structlog.processors.StackInfoRenderer(),\n            structlog.processors.format_exc_info,\n            structlog.processors.JSONRenderer()\n        ],\n        context_class=structlog.threadlocal.wrap_dict(dict),\n        logger_factory=structlog.stdlib.LoggerFactory(),\n        wrapper_class=structlog.stdlib.BoundLogger,\n        cache_logger_on_first_use=True,\n    )\n    log = structlog.get_logger()\n    return log", "response": "Returns a logging object compatible with Python standard logging."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef write(self, obj):\n        accept = self.request.headers.get(\"Accept\")\n        if \"json\" in accept:\n            if JsonDefaultHandler.__parser is None:\n                JsonDefaultHandler.__parser = Parser()\n            super(JsonDefaultHandler, self).write(JsonDefaultHandler.__parser.encode(obj))\n            return\n        # If we are not in json mode\n        super(JsonDefaultHandler, self).write(obj)", "response": "Print object on output"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreconnect to the server.", "response": "async def reconnect(self):\n        \"\"\"\u65ad\u7ebf\u91cd\u8fde.\"\"\"\n        self.clean()\n        try:\n            self.writer.close()\n        except:\n            pass\n        self.closed = True\n        await self.connect()\n        if self.debug:\n            print(\"reconnect to {}\".format((self.hostname, self.port)))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconnect to the server.", "response": "async def connect(self):\n        \"\"\"\u4e0e\u8fdc\u7aef\u5efa\u7acb\u8fde\u63a5.\n\n        \u4e3b\u8981\u6267\u884c\u7684\u64cd\u4f5c\u6709:\n        + \u5c06\u76d1\u542c\u54cd\u5e94\u7684\u534f\u7a0b_response_handler\u653e\u5165\u4e8b\u4ef6\u5faa\u73af\n        + \u5982\u679c\u6709\u9a8c\u8bc1\u4fe1\u606f\u5219\u53d1\u9001\u9a8c\u8bc1\u4fe1\u606f\n        + \u83b7\u53d6\u8fde\u63a5\u5efa\u7acb\u7684\u8fd4\u56de\n\n        \"\"\"\n        self.reader, self.writer = await asyncio.open_connection(\n            host=self.hostname,\n            port=self.port,\n            loop=self.loop)\n        self.closed = False\n        self._response_task = asyncio.ensure_future(self._response_handler())\n        query = {\n            \"MPRPC\": self.VERSION,\n            \"AUTH\": {\n                \"USERNAME\": self.username,\n                \"PASSWORD\": self.password\n            }\n        }\n        queryb = self.encoder(query)\n        if self.debug is True:\n            print(\"send auth {}\".format(queryb))\n        self.writer.write(queryb)\n        self._login_fut = self.loop.create_future()\n        self.remote_info = await self._login_fut\n        if self.remote_info is False:\n            raise abort(501)\n        if self.heart_beat:\n            self._heartbeat_task = asyncio.ensure_future(\n                self._heartbeat_callback())"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncanceling all pending tasks.", "response": "def clean(self):\n        \"\"\"\u6e05\u7406\u8fd8\u5728\u6267\u884c\u6216\u8005\u7b49\u5f85\u6267\u884c\u7684\u534f\u7a0b.\"\"\"\n        for _, i in self.tasks.items():\n            i.cancel()\n        self._heartbeat_task.cancel()\n        self._response_task.cancel()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef close(self):\n        if self.closed is False:\n            self.clean()\n            try:\n                self.writer.write_eof()\n            except:\n                pass\n            self.writer.close()\n            self.closed = True\n            if self.debug is True:\n                print('close')\n        if self.debug is True:\n            print(\"closed\")", "response": "close the file and clean it"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\nasync def _response_handler(self):\n        if self.debug is True:\n            if self.debug is True:\n                print(\"listenning response!\")\n        while True:\n            try:\n                res = await self.reader.readuntil(self.SEPARATOR)\n            except:\n                raise\n            else:\n                response = self.decoder(res)\n                self._status_code_check(response)", "response": "Handle response from the server."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _method_error_handler(self, response: Dict[str, Any]):\n        exp = response.get('MESSAGE')\n        code = response.get(\"CODE\")\n        ID = exp.get(\"ID\")\n        e = abort(code, ID=ID, message=exp.get('MESSAGE'))\n        self.tasks[ID].set_exception(e)\n        return True", "response": "\u5904\u7406400~499\u6bb5\u72b6\u6001\u7801,\u4e3a\u5bf9\u5e94\u7684\u4efb\u52a1\u8bbe\u7f6e\u5f02\u5e38.\n\n        Parameters:s\n            (response): - \u54cd\u5e94\u7684python\u5b57\u5178\u5f62\u5f0f\u6570\u636e\n\n        Return:\n            (bool): - \u51c6\u786e\u5730\u8bf4\u6ca1\u6709\u9519\u8bef\u5c31\u4f1a\u8fd4\u56deTrue"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nhandling response from server.", "response": "def _server_response_handler(self, response: Dict[str, Any]):\n        \"\"\"\u5904\u7406100~199\u6bb5\u72b6\u6001\u7801,\u9488\u5bf9\u4e0d\u540c\u7684\u670d\u52a1\u54cd\u5e94\u8fdb\u884c\u64cd\u4f5c.\n\n        Parameters:\n            (response): - \u54cd\u5e94\u7684python\u5b57\u5178\u5f62\u5f0f\u6570\u636e\n\n        Return:\n            (bool): - \u51c6\u786e\u5730\u8bf4\u6ca1\u6709\u9519\u8bef\u5c31\u4f1a\u8fd4\u56deTrue\n\n        \"\"\"\n        code = response.get(\"CODE\")\n        if code == 100:\n            if self.debug:\n                print(\"auth succeed\")\n            self._login_fut.set_result(response)\n        if code == 101:\n            if self.debug:\n                print('pong')\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nhandle the result response from the server.", "response": "def _result_handler(self, response: Dict[str, Any]):\n        \"\"\"\u5e94\u7b54\u7ed3\u679c\u54cd\u5e94\u5904\u7406.\n\n        \u5c06\u7ed3\u679c\u89e3\u6790\u51fa\u6765\u8bbe\u7f6e\u7ed9\u4efb\u52a1\u5bf9\u5e94\u7684Future\u5bf9\u8c61\u4e0a\n\n        Parameters:\n            (response): - \u54cd\u5e94\u7684python\u5b57\u5178\u5f62\u5f0f\u6570\u636e\n\n        Return:\n            (bool): - \u51c6\u786e\u5730\u8bf4\u6ca1\u6709\u9519\u8bef\u5c31\u4f1a\u8fd4\u56deTrue\n\n        \"\"\"\n        res = response.get(\"MESSAGE\")\n        ID = res.get(\"ID\")\n        result = res.get(\"RESULT\")\n        fut = self.tasks.get(ID)\n        fut.set_result(result)\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\nasync def _gen_result_handler(self, response: Dict[str, Any]):\n        code = response.get(\"CODE\")\n        res = response.get(\"MESSAGE\")\n        ID = res.get(\"ID\")\n        if code in (201, 301):\n            ait = self._wrap_gen(ID)\n            self.tasks.get(ID).set_result(ait)\n            self._gens_queue[ID] = asyncio.Queue()\n        if code == 202:\n            result = res.get('RESULT')\n            await self._gens_queue[ID].put(result)\n\n        if code == 206:\n            await self._gens_queue[ID].put(StopAsyncIteration())\n        return True", "response": "\u6d41\u5f0f\u7ed3\u679c\u54cd\u5e94\u5904\u7406.\n\n        + \u6536\u5230\u72b6\u6001\u7801\u6807\u8bc6201\u6216301\u7684\u54cd\u5e94\u540e,\u5c06tasks\u4e2dID\u5bf9\u5e94\u7684Future\u5bf9\u8c61\u7684\u7ed3\u679c\u8bbe\u7f6e\u4e3a\u4e00\u4e2a\u7528\u4e8e\u5305\u88c5\u7684\u5f02\u6b65\u751f\u6210\u5668.\n        \u5e76\u4e3a\u8fd9\u4e2aID\u521b\u5efa\u4e00\u4e2a\u5f02\u6b65\u961f\u5217\u4fdd\u5b58\u5728`_gens_queue[ID]`\u4e2d\u7528\u4e8e\u5b58\u53d6\u7ed3\u679c\n\n        + \u6536\u5230\u72b6\u6001\u7801\u6807\u8bc6\u4e3a202\u7684\u54cd\u5e94\u540e\u5411\u5bf9\u5e94ID\u7684\u5b58\u53d6\u961f\u5217\u4e2d\u5b58\u5165\u4e00\u6761\u7ed3\u679c.\n\n        + \u6536\u5230\u7ec8\u6b62\u72b6\u6001\u7801206\u540e\u5411\u5bf9\u5e94ID\u7684\u5f02\u6b65\u751f\u6210\u5668\u7ed3\u679c\u83b7\u53d6\u961f\u5217\u4e2d\u5b58\u5165\u4e00\u4e2a`StopAsyncIteration`\u5bf9\u8c61\u7528\u4e8e\u7ec8\u6b62\u5f02\u6b65\u8fed\u4ee3\u5668\n\n        Parameters:\n            (response): - \u54cd\u5e94\u7684python\u5b57\u5178\u5f62\u5f0f\u6570\u636e\n\n        Return:\n            (bool): - \u51c6\u786e\u5730\u8bf4\u6ca1\u6709\u9519\u8bef\u5c31\u4f1a\u8fd4\u56deTrue"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _make_query(self, ID: str, methodname: str, returnable: bool, *args: Any, **kwargs: Any):\n        query = {\n            \"MPRPC\": self.VERSION,\n            \"ID\": ID,\n            \"METHOD\": methodname,\n            \"RETURN\": returnable,\n            \"ARGS\": args,\n            \"KWARGS\": kwargs\n        }\n        print(query)\n        return query", "response": "Make a query string from the data in the cache."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsending a query to the server.", "response": "def send_query(self, ID, methodname, returnable, *args, **kwargs):\n        \"\"\"\u5c06\u8c03\u7528\u8bf7\u6c42\u7684ID,\u65b9\u6cd5\u540d,\u53c2\u6570\u5305\u88c5\u4e3a\u8bf7\u6c42\u6570\u636e\u540e\u7f16\u7801\u4e3a\u5b57\u8282\u4e32\u53d1\u9001\u51fa\u53bb.\n\n        Parameters:\n            ID (str): - \u4efb\u52a1ID\n            methodname (str): - \u8981\u8c03\u7528\u7684\u65b9\u6cd5\u540d\n            returnable (bool): - \u662f\u5426\u8981\u6c42\u8fd4\u56de\u7ed3\u679c\n            args (Any): - \u8981\u8c03\u7528\u7684\u65b9\u6cd5\u7684\u4f4d\u7f6e\u53c2\u6570\n            kwargs (Any): - \u8981\u8c03\u7528\u7684\u65b9\u6cd5\u7684\u5173\u952e\u5b57\u53c2\u6570\n\n        Return:\n\n            (bool): - \u51c6\u786e\u5730\u8bf4\u6ca1\u6709\u9519\u8bef\u5c31\u4f1a\u8fd4\u56deTrue\n\n        \"\"\"\n        query = self._make_query(ID, methodname, returnable, *args, **kwargs)\n        self._send_query(query)\n        self.tasks[ID] = self.loop.create_future()\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef delay(self, methodname, *args, **kwargs):\n        ID = str(uuid.uuid4())\n        self.send_query(ID, methodname, False, *args, **kwargs)\n        return ID", "response": "This method is used to delay a query."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _async_query(self, ID, methodname, *args, **kwargs):\n        self.send_query(ID, methodname, True, *args, **kwargs)\n        task = self.tasks[ID]\n        return task", "response": "Internal method to send a query to the server and return the result."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nqueries the cache for a specific key.", "response": "def async_query(self, methodname, *args, **kwargs):\n        \"\"\"\u5f02\u6b65\u8c03\u7528\u4e00\u4e2a\u8fdc\u7aef\u7684\u51fd\u6570.\n\n        \u4e3a\u8c03\u7528\u521b\u5efa\u4e00\u4e2aID,\u5e76\u5c06\u8c03\u7528\u8bf7\u6c42\u7684\u65b9\u6cd5\u540d,\u53c2\u6570\u5305\u88c5\u4e3a\u8bf7\u6c42\u6570\u636e\u540e\u7f16\u7801\u4e3a\u5b57\u8282\u4e32\u53d1\u9001\u51fa\u53bb.\u5e76\u521b\u5efa\u4e00\u4e2aFuture\u5bf9\u8c61\u5360\u4f4d.\n\n        Parameters:\n            methodname (str): - \u8981\u8c03\u7528\u7684\u65b9\u6cd5\u540d\n            args (Any): - \u8981\u8c03\u7528\u7684\u65b9\u6cd5\u7684\u4f4d\u7f6e\u53c2\u6570\n            kwargs (Any): - \u8981\u8c03\u7528\u7684\u65b9\u6cd5\u7684\u5173\u952e\u5b57\u53c2\u6570\n\n        Return:\n            (asyncio.Future): - \u8fd4\u56de\u5bf9\u5e94ID\u7684Future\u5bf9\u8c61\n\n        \"\"\"\n        ID = str(uuid.uuid4())\n        task = self._async_query(ID=ID, methodname=methodname, *args, **kwargs)\n        return task"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngenerates random JPath with given node depth.", "response": "def random_jpath(depth = 3):\n    \"\"\"\n    Generate random JPath with given node depth.\n    \"\"\"\n    chunks = []\n    while depth > 0:\n        length = random.randint(5, 15)\n        ident  = ''.join(random.choice(string.ascii_uppercase + string.ascii_lowercase) for _ in range(length))\n        if random.choice((True, False)):\n            index  = random.randint(0, 10)\n            ident = \"{:s}[{:d}]\".format(ident, index)\n        chunks.append(ident)\n        depth -= 1\n    return \".\".join(chunks)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef feed_fetch_force(request, id, redirect_to):\n    feed = Feed.objects.get(id=id)\n    feed.fetch(force=True)\n    msg = _(\"Fetched tweets for %s\" % feed.name)\n    messages.success(request, msg, fail_silently=True)\n    return HttpResponseRedirect(redirect_to)", "response": "Forcibly fetch tweets for the given feed"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef search_fetch_force(request, id, redirect_to):\n    search = Search.objects.get(id=id)\n    search.fetch(force=True)\n    msg = _(\"Fetched tweets for %s\" % search.criteria)\n    messages.success(request, msg, fail_silently=True)\n    return HttpResponseRedirect(redirect_to)", "response": "Forcibly fetch tweets for the given search"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconnects a callback to the specified signal.", "response": "def connect(self, callback, weak=False):\n        \"\"\"\n        Connects a new callback to this signal.\n\n        :param callback: The callback to connect.\n        :param weak: If `True`, only holds a weak reference to the specified\n            callback.\n\n        `callback` will be called whenever `emit` gets called on the `Signal`\n        instance.\n\n        If a weak reference is kept, when the callback gets destroyed, it will\n        be unregistered from the signal automatically. This can help avoiding\n        circular references in user-code.\n\n        .. warning::\n            Beware of bound methods ! Those are generally short-lived and don't\n            play nicely with weak reference.\n\n        .. note::\n            Connecting the same callback twice or more will cause the callback\n            to be called several times per `emit` call.\n\n            You will have to call `disconnect` as many times as the `connect`\n            call was called to unregister a callback completely.\n        \"\"\"\n        if weak:\n            callback = ref(callback, self._disconnect)\n\n        with self._write_lock:\n            with self._read_lock:\n                self._callbacks.append(callback)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef __connect():\n    global redis_instance\n    if use_tcp_socket:\n        redis_instance = redis.StrictRedis(host=hostname, port=port)\n    else:\n        redis_instance = redis.StrictRedis(unix_socket_path=unix_socket)", "response": "Connect to a redis instance."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef log(level, message):\n    if redis_instance is None:\n        __connect()\n\n    if level not in __error_levels:\n        raise InvalidErrorLevel('You have used an invalid error level. \\\n                Please choose in: ' + ', '.join(__error_levels))\n    if channel is None:\n        raise NoChannelError('Please set a channel.')\n    c = '{channel}.{level}'.format(channel=channel, level=level)\n    redis_instance.publish(c, message)", "response": "Log a message with the level the redis channel."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nfinding suitable certificates for httplib2.", "response": "def find_certs() -> str:\n    \"\"\"Find suitable certificates for ``httplib2``.\n\n    Warning:\n        The default behaviour is to fall back to the bundled certificates when\n        no system certificates can be found.  If you're packaging ``jnrbase``\n        *please* set ``ALLOW_FALLBACK`` to ``False`` to disable this very much\n        unwanted behaviour, but please maintain the option so that downstream\n        users can inspect the configuration easily.\n\n    See also: :pypi:`httplib2`\n\n    Returns:\n        Path to SSL certificates\n    Raises:\n        RuntimeError: When no suitable certificates are found\n    \"\"\"\n    bundle = path.realpath(path.dirname(httplib2.CA_CERTS))\n    # Some distros symlink the bundled path location to the system certs\n    if not bundle.startswith(path.dirname(httplib2.__file__)):\n        return bundle\n    for platform, files in PLATFORM_FILES.items():\n        if sys.platform.startswith(platform):\n            for cert_file in files:\n                if path.exists(cert_file):\n                    return cert_file\n    # An apparently common environment setting for macOS users to workaround\n    # the lack of \u201cstandard\u201d certs installation\n    if path.exists(getenv('CURL_CA_BUNDLE', '')):\n        return getenv('CURL_CA_BUNDLE')\n    if ALLOW_FALLBACK:\n        warnings.warn('No system certs detected, falling back to bundled',\n                      RuntimeWarning)\n        return httplib2.CA_CERTS\n    else:\n        raise RuntimeError('No system certs detected!')"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_absolute_url(self):\r\n        if self.override_url:\r\n            return self.override_url\r\n        if self.destination.is_blog:\r\n            return reverse('blog_entry_detail', args=[self.destination.slug, self.slug])\r\n        return reverse('article_detail', args=[self.slug])", "response": "Returns the absolute url of the content."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nstoring summary if none was given and created formatted version of body text.", "response": "def save(self, *args, **kwargs):\r\n        \"\"\"\r\n        Store summary if none was given\r\n        and created formatted version of body text.\r\n        \"\"\"\r\n        if not self.summary:\r\n            self.summary = truncatewords(self.body, 50)\r\n        self.body_formatted = sanetize_text(self.body)\r\n        super(Article, self).save()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a list of assets that are commonized for the current locale.", "response": "def get_top_assets(self):\r\n        \"\"\"\r\n        Returns chained list of top assets (photos and video) for commonized templates.\r\n        \"\"\"\r\n        imgs = self.articleimage_set.all()\r\n        try:\r\n            vids = self.videos.all()\r\n        except AttributeError:\r\n            # handles case where videos are not in installed apps\r\n            # or otherwise unavailable\r\n            vids = []\r\n        return list(chain(imgs, vids))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the vads payment config for the current object.", "response": "def set_vads_payment_config(self):\n        \"\"\"\n        vads_payment_config can be set only after object saving.\n\n        A custom payment config can be set once PaymentRequest saved\n        (adding elements to the m2m relationship). As a consequence\n        we set vads_payment_config just before sending data elements\n        to payzen.\"\"\"\n        self.vads_payment_config = tools.get_vads_payment_config(\n            self.payment_config, self.custom_payment_config.all())"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef save(self):\n        if not self.vads_trans_date:\n            self.vads_trans_date = datetime.datetime.utcnow().replace(\n                tzinfo=utc).strftime(\"%Y%m%d%H%M%S\")\n        if not self.vads_trans_id:\n            self.vads_trans_id = tools.get_vads_trans_id(\n                self.vads_site_id, self.vads_trans_date)\n        if self.theme and not self.vads_theme_config:\n            self.vads_theme_config = str(self.theme)\n        if not self.pk:\n            super(PaymentRequest, self).save()\n        self.set_vads_payment_config()\n        self.set_signature()\n        super(PaymentRequest, self).save()", "response": "Save the current instance of the class."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef records(self):\n\t\t'''Return a list of dicts corresponding to the data returned by Factual.'''\n\t\tif self._records == None:\n\t\t\tself._records = self._get_records()\n\t\treturn self._records", "response": "Return a list of dicts corresponding to the data returned by Factual."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef GenerateConfigFile(load_hook, dump_hook, **kwargs) -> ConfigFile:\n    def ConfigFileGenerator(filename, safe_load: bool=True):\n        cfg = ConfigFile(fd=filename, load_hook=load_hook, dump_hook=dump_hook, safe_load=safe_load, **kwargs)\n        return cfg\n\n    return ConfigFileGenerator", "response": "Generates a ConfigFile object using the specified hooks."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef GenerateNetworkedConfigFile(load_hook, normal_class_load_hook, normal_class_dump_hook, **kwargs) -> NetworkedConfigObject:\n    def NetworkedConfigObjectGenerator(url, safe_load: bool=True):\n        cfg = NetworkedConfigObject(url=url, load_hook=load_hook, safe_load=safe_load,\n                                    normal_class_load_hook=normal_class_load_hook,\n                                    normal_class_dump_hook=normal_class_dump_hook)\n        return cfg\n\n    return NetworkedConfigObjectGenerator", "response": "Generates a NetworkedConfigObject using the specified hooks."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef append(self, first, count):\n\n        self.__range.append(IdRange(first, count))", "response": "Add to the set a range of count consecutive ids\n        starting at id first."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nremoving a range of count consecutive ids starting at id first from all the ranges in the set.", "response": "def remove(self, first, count):\n        \"\"\"\n        Remove a range of count consecutive ids starting at id first\n        from all the ranges in the set.\n        \"\"\"\n\n        # Avoid trivialities\n        if first < 0 or count < 1:\n            return\n\n        new_range = []\n        last = first + count - 1\n        for r in self.__range:\n            if first <= r.last and r.first <= last:\n                # There is an overlap\n                if r.first < first:\n                    new_range.append(IdRange(r.first, first-r.first))\n                if last < r.last:\n                    new_range.append(IdRange(last+1, r.last-last))\n            else:\n                # No overlap, range is kept\n                new_range.append(r)\n\n        self.__range = new_range"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsimplifying the set of unique entries in the set.", "response": "def simplify(self):\n        \"\"\"\n        Reorganize the ranges in the set in order to ensure that each range\n        is unique and that there is not overlap between to ranges.\n        \"\"\"\n\n        # Sort the ranges\n        self.__range.sort()\n\n        new_range = []\n        new_first = self.__range[0].first\n        new_count = self.__range[0].count\n\n        for r in self.__range:\n            if r.first == new_first:\n                # Longest range starting at new_first\n                new_count = r.count\n            elif r.first <= new_first + new_count:\n                # Overlapping ranges\n                if new_first + new_count - 1 < r.last:\n                    # There is a part of the range to add to the new range\n                    new_count = r.last - new_first + 1\n            else:\n                # No overlap, this is a new disjoint range\n                new_range.append(IdRange(new_first, new_count))\n                new_first = r.first\n                new_count = r.count\n\n        # End of the last range\n        new_range.append(IdRange(new_first, new_count))\n\n        self.__range = new_range"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef urljoin(refurl, objurl):\n    if objurl.strip() in ('', '#'):\n        return ''\n    elif objurl.startswith('http'):\n        return objurl\n    elif objurl.startswith('/'):\n        refurl = refurl.replace('//', '{$$}')\n        return ''.join([refurl[:refurl.index('/')].replace('{$$}', '//'), objurl])\n    else:\n        return '/'.join([refurl[:refurl.rindex('/')], objurl])", "response": "Join the refurl with the objurl"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _do_recursive(self, method_that_runs_baton_chmod: callable, *args, **kwargs):\n        current_frame_id = id(inspect.currentframe())\n        try:\n            self._hijack_frame_ids.add(current_frame_id)\n            method_that_runs_baton_chmod(*args, **kwargs)\n        finally:\n            self._hijack_frame_ids.remove(current_frame_id)", "response": "Calls the given method that calls baton - chmod with the given arguments."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _hijacked_run_baton_query(\n            self, baton_binary: BatonBinary, program_arguments: List[str]=None, input_data: Any=None) -> List[Dict]:\n        \"\"\"\n        Hijacked `run_baton_query` method with hijacking to add the `--recursive` flag to calls to `baton-chmod` that\n        originate from code called from frames with the ids in `self._hijack_frame_ids`.\n        :param baton_binary: see `BatonRunner.run_baton_query`\n        :param program_arguments: see `BatonRunner.run_baton_query`\n        :param input_data: see `BatonRunner.run_baton_query`\n        :return: see `BatonRunner.run_baton_query`\n        \"\"\"\n        if baton_binary == BatonBinary.BATON_CHMOD:\n            current_frame = inspect.currentframe()\n\n            def frame_code_in_same_file(frame) -> bool:\n                return frame_back.f_code.co_filename == current_frame.f_code.co_filename\n\n            frame_back = current_frame.f_back\n            assert frame_code_in_same_file(frame_back)\n\n            while frame_back is not None and frame_code_in_same_file(frame_back):\n                if id(frame_back) in self._hijack_frame_ids:\n                    return self._original_run_baton_query(baton_binary, [BATON_CHMOD_RECURSIVE_FLAG], input_data)\n                frame_back = frame_back.f_back\n\n        return self._original_run_baton_query(baton_binary, program_arguments, input_data)", "response": "Hijacked run_baton_query method with hijacking to add the recursive flag to call to baton - chmod"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the url to fix my error submission", "response": "def _get_fix_my_django_submission_url(self, tb_info, sanitized_tb):\n        \"\"\"\n        Links to the error submission url with pre filled fields\n        \"\"\"\n        err_post_create_path = '/create/'\n        url = '{0}{1}'.format(base_url, err_post_create_path)\n        return '{url}?{query}'.format(\n            url=url,\n            query=urlencode({\n                'exception_type': clean_exception_type(tb_info['parsed_traceback']['exc_type']),\n                'error_message': tb_info['parsed_traceback']['exc_msg'],\n                'django_version': '{0[0]}.{0[1]}'.format(django.VERSION),\n                'traceback': sanitized_tb\n            }))"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nretrieves the endpoint catalog", "response": "def endpoint_catalog(catalog=None):  # noqa: E501\n    \"\"\"Retrieve the endpoint catalog\n\n    Retrieve the endpoint catalog # noqa: E501\n\n    :param catalog: The data needed to get a catalog\n    :type catalog: dict | bytes\n\n    :rtype: Response\n    \"\"\"\n    if connexion.request.is_json:\n        catalog = UserAuth.from_dict(connexion.request.get_json())  # noqa: E501\n\n    if (not hasAccess()):\n        return redirectUnauthorized()\n\n    driver = LoadedDrivers.getDefaultDriver()\n    auth = None\n    if (catalog):\n        auth = catalog\n    return Response(status=200, body=driver.getCatalog(auth))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nretrieving the script catalog", "response": "def script_catalog():  # noqa: E501\n    \"\"\"Retrieve the script catalog\n\n    Retrieve the script catalog # noqa: E501\n\n\n    :rtype: Response\n    \"\"\"\n    if (not hasAccess()):\n        return redirectUnauthorized()\n\n    driver = LoadedDrivers.getDefaultDriver()\n    return Response(status=200, body=driver.getScriptsCatalog())"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef read_config(config_file):\n    '''Reads the ~/.aadbookrc and any authentication data\n    returns the configuration as a dictionary.\n\n    '''\n    config = Storage({  # Default values\n        'cache_filename': '~/.aadbook_cache',\n        'auth_db_filename': '~/.aadbook_auth.json',\n        'cache_expiry_hours': '24'})\n    config_file = os.path.expanduser(config_file)\n    parser = _get_config(config_file)\n    if parser:\n        config.get_dict().update(dict(parser.items('DEFAULT', raw=True)))\n\n    # Ensure paths are fully expanded\n    config.cache_filename = realpath(expanduser(config.cache_filename))\n    config.auth_db_filename = realpath(expanduser(config.auth_db_filename))\n\n    config.auth = Auth(config.auth_db_filename)\n    # config.creds = config.store.get()\n\n    # What terminal encoding to use\n    config.encoding = ENCODING\n\n    log.debug(config)\n    return config", "response": "Reads the ~. aadbookrc and any authentication data\n    returns the configuration as a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _get_config(config_file):\n    '''find, read and parse configuraton.'''\n    parser = ConfigParser.SafeConfigParser()\n    if os.path.lexists(config_file):\n        try:\n            log.info('Reading config: %s', config_file)\n            inp = open(config_file)\n            parser.readfp(inp)\n            return parser\n        except (IOError, ConfigParser.ParsingError), err:\n            raise ConfigError(\"Failed to read configuration %s\\n%s\" % (config_file, err))\n    return None", "response": "find read and parse configuraton."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef getbool(key, default=False):\n    value = os.getenv(key)\n    if value and value.lower() in ('true', '1'):\n        value = True\n    elif value and value.lower() in ('false', '0'):\n        value = False\n    else:\n        value = default\n    return value", "response": "Get a boolean value from the environment variable."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _locate_settings(settings=''):\n    \"Return the path to the DJANGO_SETTINGS_MODULE\"\n\n    import imp\n    import sys\n    sys.path.append(os.getcwd())\n    settings = settings or os.getenv('DJANGO_SETTINGS_MODULE')\n    if settings:\n        parts = settings.split('.')\n        f = imp.find_module(parts[0])[1]\n        args = [f] + parts[1:]\n        path = os.path.join(*args)\n        path = path + '.py'\n        if os.path.exists(path):\n            return path", "response": "Return the path to the DJANGO_SETTINGS_MODULE"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_from_relations(self, query,aliases):\n        '''\n        Returns list of the names of all positive relations in the query\n        '''\n        return [aliases[rel.get_name()] for rel in query.get_relations() if not rel.is_negated()]", "response": "Returns a list of the names of all positive relations in the query"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a list of implicit constraints that can be used to unify a constant to a position of the relation", "response": "def get_implicit_constraints(self,relations):\n        ''' An implicit constraint is one in which you are unifying a constant to a position of the relation\n            E.G. R(X,2) specifies that R.2 == 2'''\n\n        constraints = []\n        for relation in [r for r in relations if not r.is_negated()]  :\n            const_dict = relation.get_constants()\n            for constant in const_dict:\n                for position in const_dict[constant]:\n                    constraints.append( \\\n                        relation.get_name() + '.' + self.mapPositionToColumnName(relation,position) + ' = ' + str(constant) \\\n                    )\n        return constraints"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_explicit_constraints(self,constraints,var_dict):\n        '''\n        Returns SQL representation of an explicit constraint. An explicit\n        constraint is one of the form Element COMP Element type, explicitly\n        listed in the conjunctive query. E.G. R(X,Y), Y>2 specifies that R.2 > 2\n        '''\n\n        constraints_strings = []\n        for constraint in constraints:\n            ls = constraint.get_left_side()\n            rs = constraint.get_right_side()\n\n            if not (ls.is_variable() and constraint.is_equality_constraint()):\n                ''' Every Var = Constant constraint where var is only in head. We don't want this type of constraints.\n                    We assume that if there is a Var = Constraint, var occurs in the head. Otherwise it would be unified in the preprocessor.\n                '''\n                if ls.is_variable():\n                    left_side = self.mapVariableToRelationDotField(ls, var_dict)\n                elif ls.is_constant():\n                    left_side = str(ls)\n\n                if rs.is_variable():\n                    right_side = self.mapVariableToRelationDotField(rs, var_dict)\n                elif rs.is_constant():\n                    right_side = str(rs)\n\n                constraints_strings.append(\n                    str(left_side) + ' ' + str(constraint.get_operator()) + ' ' + str(right_side)\n                )\n\n        return constraints_strings", "response": "Returns the SQL representation of an explicit constraint."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef photo(self, args):\n        rsp = self._load_rsp(self.flickr.photos_getInfo(photo_id=args[0]))\n        p = rsp['photo']\n        yield self._prep(p)", "response": "Get metadata for a specific photo."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nexecute a search API call", "response": "def search(self, args):\n        \"\"\"\n        Executes a search\n\n        flickr:(credsfile),search,(arg1)=(val1),(arg2)=(val2)...\n        \"\"\"\n        kwargs = {}\n        for a in args:\n            k, v = a.split('=')\n            kwargs[k] = v\n        return self._paged_api_call(self.flickr.photos_search, kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef interesting(self, args=None):\n        kwargs = {'extras':  ','.join(args) if args else 'last_update,geo,owner_name,url_sq'}\n        return self._paged_api_call(self.flickr.interestingness_getList, kwargs)", "response": "Gets interesting photos.\n\n        flickr:(credsfile),interesting"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef search_groups(self, args):\n        kwargs = {'text': args[0]}\n        return self._paged_api_call(self.flickr.groups_search, kwargs, 'group')", "response": "Executes a search\n        flickr. groups_search"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nexecute a search flickr : ( credsfile search )...", "response": "def group(self, args):\n        \"\"\"\n        Executes a search\n\n        flickr:(credsfile),search,(arg1)=(val1),(arg2)=(val2)...\n        \"\"\"\n        kwargs = {'group_id': args[0]}\n        return self._paged_api_call(self.flickr.groups_pools_getPhotos, kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _paged_api_call(self, func, kwargs, item_type='photo'):\n        page = 1\n        while True:\n            LOG.info(\"Fetching page %s\" % page)\n            kwargs['page'] = page\n            rsp = self._load_rsp(func(**kwargs))\n            if rsp[\"stat\"] == \"ok\":\n                plural = item_type + 's'\n                if plural in rsp:\n                    items = rsp[plural]\n                    if int(items[\"page\"]) < page:\n                        LOG.info(\"End of Flickr pages (%s pages with %s per page)\" % (items[\"pages\"], items[\"perpage\"]))\n                        break\n                    for i in items[item_type]:\n                        yield self._prep(i)\n                else:\n                    yield rsp\n                page += 1\n            else:\n                yield [rsp]\n                break", "response": "A generator that yields the response from the API call and yields the response as a list of lists."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nnormalizing lastupdate to a timestamp and constructs a URL from the embedded attributes.", "response": "def _prep(e):\n        \"\"\"\n        Normalizes lastupdate to a timestamp, and constructs a URL from the embedded attributes.\n        \"\"\"\n        if 'lastupdate' in e:\n            e['lastupdate'] = datetime.datetime.fromtimestamp(int(e['lastupdate']))\n        for k in ['farm', 'server', 'id', 'secret']:\n            if not k in e:\n                return e\n        e[\"url\"] = \"https://farm%s.staticflickr.com/%s/%s_%s_b.jpg\" % (e[\"farm\"], e[\"server\"], e[\"id\"], e[\"secret\"])\n        return e"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _load_rsp(rsp):\n        first = rsp.find('(') + 1\n        last = rsp.rfind(')')\n        return json.loads(rsp[first:last])", "response": "Converts raw Flickr string response to Python dict"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef styleProperties(Class, style):\n        properties = Dict()\n        for property in style.getProperties(all=True):\n            stylename = property.name + ':'\n            properties[stylename] = property.value\n            if property.priority != '':\n                properties[stylename] = ' !'+property.priority\n        return properties", "response": "return a properties dict from a given cssutils style"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nparse CSS text into a Styles object using cssutils", "response": "def from_css(Class, csstext, encoding=None, href=None, media=None, title=None, validate=None):\n        \"\"\"parse CSS text into a Styles object, using cssutils\n        \"\"\"\n        styles = Class()\n        cssStyleSheet = cssutils.parseString(csstext, encoding=encoding, href=href, media=media, title=title, validate=validate)\n        for rule in cssStyleSheet.cssRules:\n            if rule.type==cssutils.css.CSSRule.FONT_FACE_RULE:\n                if styles.get('@font-face') is None: styles['@font-face'] = []\n                styles['@font-face'].append(Class.styleProperties(rule.style))\n            \n            elif rule.type==cssutils.css.CSSRule.IMPORT_RULE:\n                if styles.get('@import') is None: styles['@import'] = []\n                styles['@import'].append(\"url(%s)\" % rule.href)\n\n            elif rule.type==cssutils.css.CSSRule.NAMESPACE_RULE:\n                if styles.get('@namespace') is None: styles['@namespace'] = {}\n                styles['@namespace'][rule.prefix] = rule.namespaceURI\n            \n            elif rule.type==cssutils.css.CSSRule.MEDIA_RULE:\n                if styles.get('@media') is None: styles['@media'] = []\n                styles['@media'].append(rule.cssText)\n            \n            elif rule.type==cssutils.css.CSSRule.PAGE_RULE:\n                if styles.get('@page') is None: styles['@page'] = []\n                styles['@page'].append(rule.cssText)\n\n            elif rule.type==cssutils.css.CSSRule.STYLE_RULE:\n                for selector in rule.selectorList:\n                    sel = selector.selectorText\n                    if sel not in styles:\n                        styles[sel] = Class.styleProperties(rule.style)\n            \n            elif rule.type==cssutils.css.CSSRule.CHARSET_RULE:\n                styles['@charset'] = rule.encoding\n\n            elif rule.type==cssutils.css.CSSRule.COMMENT:   # comments are thrown away\n                pass\n\n            elif rule.type==cssutils.css.CSSRule.VARIABLES_RULE:\n                pass\n            \n            else:\n                log.warning(\"Unknown rule type: %r\" % rule.cssText)\n\n        return styles"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\noutput css text from styles. margin is what to put at the beginning of every line in the output. indent is how much to indent indented lines in the output.", "response": "def render(C, styles, margin='', indent='\\t'):\n        \"\"\"output css text from styles. \n        margin is what to put at the beginning of every line in the output.\n        indent is how much to indent indented lines (such as inside braces).\n        \"\"\"\n        from unum import Unum\n        s = \"\"\n        # render the css text\n        for k in styles.keys():\n            s += margin\n            if type(styles[k]) == Unum:\n                s += k + ' ' + str(styles[k]) + ';'\n            elif type(styles[k]) in [str, String]:\n                s += k + ' ' + styles[k] + ';'\n            elif type(styles[k]) in [dict, Dict]:\n                # recurse\n                s += k + ' {\\n' + C.render(styles[k], margin=margin+indent, indent=indent) + '}\\n'\n            elif type(styles[k]) in [tuple, list]:\n                for i in styles[k]:\n                    s += k + ' ' \n                    if type(i) in [str, String]:\n                        s += i + ';\\n'\n                    if type(i) == bytes:\n                        s += str(i, 'utf-8') + ';\\n'\n                    elif type(i) in [dict, Dict]:\n                        # recurse\n                        s += '{\\n' + C.render(i, margin=margin+indent, indent=indent) + '}\\n'\n            else:\n                s += ';'\n            s += '\\n'\n        return s"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_token(code, token_service, client_id, client_secret, redirect_uri,\n              grant_type):\n  \"\"\"Fetches an OAuth 2 token.\"\"\"\n  data = {\n      'code': code,\n      'client_id': client_id,\n      'client_secret': client_secret,\n      'redirect_uri': redirect_uri,\n      'grant_type': grant_type,\n  }\n  # Get the default http client\n  resp = requests.post(token_service, data, verify=False)\n  return resp.json()", "response": "Fetches an OAuth 2 token."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_auth_uri(auth_service, client_id, scope, redirect_uri, response_type,\n                 state, access_type, approval_prompt):\n  \"\"\"Generates an authorization uri.\"\"\"\n  errors = []\n  if response_type not in VALID_RESPONSE_TYPES:\n    errors.append(\n        '{0} is not a valid response_type, must be {1}.'.format(\n        response_type, VALID_RESPONSE_TYPES))\n  if not client_id:\n    errors.append('client_id is missing or empty.')\n  if not redirect_uri:\n    errors.append('redirect_uri is missing or empty.')\n  if not scope:\n    errors.append('scope is missing or empty.')\n  if access_type not in VALID_ACCESS_TYPES:\n    errors.append('access_type is invalid.')\n  if approval_prompt not in VALID_APPROVAL_PROMPTS:\n    errors.append('approval_prompt is invalid')\n  if errors:\n    raise ValueError('Invalid parameters: {0}'.format('\\n'.join(errors)))\n  params = {\n      'response_type': response_type,\n      'client_id': client_id,\n      'redirect_uri': redirect_uri,\n      'scope': scope,\n      'access_type': access_type,\n      'approval_prompt': approval_prompt,\n      'state': state,\n  }\n  return '?'.join([auth_service, urllib.urlencode(params)])", "response": "Generates an authorization uri."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef run_local(client):\n  webbrowser.open(client.get_auth_uri())\n  code = wait_for_redirect()\n  return client.get_token(code)", "response": "Starts a local web server and wait for a redirect."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef check_and_create_directories(paths):\n    for path in paths:\n        if os.path.exists(path):\n            shutil.rmtree(path)\n        os.mkdir(path)", "response": "Check and create directories."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndeleting directories in the specified paths.", "response": "def delete_directories(paths):\n    \"\"\"\n        Delete directories.\n\n        If the directory is exist, It will delete it including files.\n\n        :type paths: Array of string or string\n        :param paths: the location of directory\n    \"\"\"\n    for path in paths:\n        if os.path.exists(path):\n            shutil.rmtree(path)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef delete_files(paths):\n    for path in paths:\n        if os.path.exists(path):\n            os.remove(path)", "response": "Delete files.\n\n        If the file is exist, It will delete it.\n\n        :type paths: Array of string or string\n        :param paths: the location of file"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef move_file(originals, destination):\n    for original in originals:\n        if os.path.exists(original):\n            shutil.move(original, destination)", "response": "Move file from original path to destination path."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef uncompress_files(original, destination):\n    with zipfile.ZipFile(original) as zips:\n        extract_path = os.path.join(destination)\n        zips.extractall(extract_path)", "response": "Move file from original path to destination path."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef truncate_table(self, tablename):\n        self.cursor.execute('TRUNCATE TABLE %s' %tablename)\n        self.db.commit()", "response": "Truncate the given table."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef create_schema(self, schema_name):\n        try:\n            self.cursor.execute('CREATE SCHEMA %s' % schema_name)\n        except Exception as e:\n            raise e\n        finally:\n            self.db.commit()", "response": "Create schema. This method only implemented for this class."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef show_qt(qt_class, modal=False, onshow_event=None, force_style=True):\n    dialog = None\n    anchor = sianchor()\n    # look for a previous instance\n    for d in anchor.children():\n        if isinstance(d, qt_class):\n            dialog = d\n    # if there's no previous instance then create a new one\n    if dialog is None:\n        dialog = qt_class(anchor)\n    # execute callback\n    if onshow_event:\n        onshow_event(dialog)\n    # stylize and gc\n    if force_style:\n        set_style(dialog, not isinstance(dialog, QtGui.QMenu))\n    dialog.setAttribute(QtCore.Qt.WA_DeleteOnClose)\n    # show dialog\n    if modal:\n        dialog.exec_()\n    else:\n        dialog.show()\n        dialog.raise_()  # ensures dialog window is on top\n    return dialog", "response": "Show a QMainWindow or QDialog inside a softimage ensuring it s not duplicated."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef dictfetchall(cursor):\n    desc = cursor.description\n    return [dict(zip([col[0] for col in desc], row)) for row in cursor.fetchall()]", "response": "Returns all rows from a cursor as a list of dicts"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a list of dict objects one for each row in a list of lists", "response": "def dicts_from_table(table, keys=None):\n    \"\"\"Returns a list of dict() objects, one for each row in a list of lists (table)\"\"\"\n    lod = []\n    for row in table:\n        if not keys:\n            keys = row\n            if not all((k not in (None, '') or bool(k.strip())) for k in keys):\n                keys = None\n            continue\n        lod += [OrderedDict((k, v) for k, v in zip(keys, row))]\n    return lod"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef datatype(dbtype, description, cursor):\n    dt = cursor.db.introspection.get_field_type(dbtype, description)\n    if type(dt) is tuple:\n        return dt[0]\n    else:\n        return dt", "response": "Convert a data type into a string."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef json2csv(json_str, show_header=False, separator='\\t'):\n    json_obj = json.loads(json_str)\n    cols = [col for col in json_obj.keys()]\n    vals = [str(json_obj.get(col)) for col in cols]\n    header = None\n    if show_header:\n        header = separator.join(cols)\n    values = separator.join(vals)\n\n    return (header, values) if show_header else values", "response": "Format a json string to csv like."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning the django - filters FilterSet used to filter the queryset.", "response": "def get_filter_class(self, view, queryset=None):\n        \"\"\"\n        Return the django-filters `FilterSet` used to filter the queryset.\n        \"\"\"\n        filter_class = getattr(view, 'filter_class', None)\n        if filter_class:\n            filter_model = filter_class.Meta.model\n\n            assert issubclass(queryset._document, filter_model), \\\n                'FilterSet model %s does not match queryset model %s' % \\\n                (filter_model, queryset.model)\n\n            return filter_class\n        return"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef run(self):\n        sha = VersionUtils.run_git_command([\"rev-parse\", \"HEAD\"], self.git_dir)\n        tag = self.distribution.get_version()\n\n        if self.has_tag(tag, sha):\n            tags_sha = VersionUtils.run_git_command([\"rev-parse\", tag], self.git_dir)\n            if sha != tags_sha:\n                logger.error(\n                    \"git tag {0} sha does not match the sha requesting to be tagged, you need to increment the version number, Skipped Tagging!\".format(\n                        tag\n                    )\n                )\n                return\n            else:\n                logger.info(\n                    \"git tag {0} already exists for this repo, Skipped Tagging!\".format(\n                        tag\n                    )\n                )\n                return\n\n        logger.info(\"Adding tag {0} for commit {1}\".format(tag, sha))\n        if not self.dry_run:\n            VersionUtils.run_git_command(\n                [\"tag\", \"-m\", '\"\"', tag, sha], self.git_dir, throw_on_error=True\n            )\n            logger.info(\"Pushing tag {0} to remote {1}\".format(tag, self.remote))\n            VersionUtils.run_git_command(\n                [\"push\", self.remote, tag], self.git_dir, throw_on_error=True\n            )", "response": "Will tag the currently active git commit id with the next release tag id"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ninitialize markdown extension components.", "response": "def extendMarkdown(self, md, md_globals=None):\n        \"\"\"Initializes markdown extension components.\"\"\"\n        if any(\n                x not in md.treeprocessors\n                for x in self.REQUIRED_EXTENSION_INTERNAL_NAMES):\n            raise RuntimeError(\n                \"The attr_cols markdown extension depends the following\"\n                \" extensions which must preceded it in the extension\"\n                \" list: %s\" % \", \".join(self.REQUIRED_EXTENSIONS))\n        processor = AttrColTreeProcessor(md, self.conf)\n        md.treeprocessors.register(\n            processor, 'attr_cols',\n            5)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreads config from file or list of paths", "response": "def read_file(paths):\n    \"\"\"read config from path or list of paths\n\n    :param str|list[str] paths: path or list of paths\n    :return dict: loaded and merged config\n    \"\"\"\n\n    if isinstance(paths, str):\n        paths = [paths]\n\n    re = {}\n    for path in paths:\n        cfg = yaml.load(open(path))\n        merge(re, cfg)\n\n    return re"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nscraping data from diybio. org.", "response": "def data_from_diybio_org():\n    \"\"\"Scrapes data from diybio.org.\"\"\"\n\n    r = requests.get(diy_bio_labs_url)\n\n    if r.status_code == 200:\n        # Fix a problem in the html source while loading it\n        data = BeautifulSoup(r.text.replace(u'\\xa0', u''), \"lxml\")\n    else:\n        data = \"There was an error while accessing data on diybio.org.\"\n\n    return data"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_labs(format, open_cage_api_key):\n\n    diybiolabs_soup = data_from_diybio_org()\n    diybiolabs = {}\n\n    rows_list = []\n    continents_dict = {}\n    continents_order = 0\n    ranges_starting_points = []\n\n    # Load all the DIYBio Labs\n    # By first parsing the html\n\n    # Parse table rows\n    for row in diybiolabs_soup.select(\"table tr\"):\n        cells = row.find_all('td')\n        rows_list.append(cells)\n\n    # Find the continents in order to iterate over their children td\n    for k, row in enumerate(rows_list):\n        for col in row:\n            if col.find('h3'):\n                for h3 in col.findAll('h3'):\n                    ranges_starting_points.append(k)\n                    continents_dict[continents_order] = h3.get_text()\n                    continents_order += 1\n\n    # Find the rows of each continent\n    ranges = {}\n    for k, j in enumerate(reversed(ranges_starting_points)):\n        if k < len(ranges_starting_points) - 1:\n            ranges[k] = {\"start\": ranges_starting_points[k],\n                         \"end\": ranges_starting_points[k + 1]}\n        else:\n            # The last continent, Oceania\n            ranges[k] = {\"start\": ranges_starting_points[k],\n                         \"end\": len(rows_list)}\n\n    # Iterate over the range of each continent to find the Labs\n    for i in ranges:\n        # The +1 just avoids the H3 line\n        for j in range(ranges[i][\"start\"] + 1, ranges[i][\"end\"]):\n            # Avoid empty rows by measuring the lenght of the content of each cell and with a boolean check\n            rules = [len(n) == 0 for n in rows_list[j]]\n            if False in rules:\n                current_lab = DiyBioLab()\n                current_lab.city = rows_list[j][1].contents[0].encode('utf-8')\n                # Data from the USA is not really well formatted\n                if continents_dict[i] == \"USA-EAST\" or continents_dict[\n                        i] == \"USA-WEST\":\n                    current_lab.state = rows_list[j][2].contents[0].replace(\n                        \" \", \"\").encode('utf-8')\n                else:\n                    current_lab.country_code = rows_list[j][2].contents[\n                        0].encode('utf-8')\n                current_lab.url = rows_list[j][3].contents[0].attrs['href']\n                # Each lab is identified by the simplified url\n                slug = current_lab.url\n                if \"http://\" in slug:\n                    slug = slug.replace(\"http://\", \"\")\n                elif \"https://\" in slug:\n                    slug = slug.replace(\"https://\", \"\")\n                if \"www.\" in slug:\n                    slug = slug.replace(\"www.\", \"\")\n                current_lab.name = slug\n                current_lab.slug = slug\n\n                # Data from the USA is not really well formatted\n                if continents_dict[i] == \"USA-EAST\" or continents_dict[i] == \"USA-WEST\":\n                    current_lab.continent = \"North America\"\n                    current_lab.country_code = \"USA\"\n                    current_lab.country = \"United States of America\"\n                    current_lab.state = us.states.lookup(\n                        current_lab.state).name\n\n                # Get address from city\n                address = get_location(query=current_lab.city, format=\"direct\", api_key=open_cage_api_key)\n                current_lab.continent = address[\"continent\"]\n                current_lab.latitude = address[\"latitude\"]\n                current_lab.longitude = address[\"longitude\"]\n                current_lab.address_1 = address[\"address_1\"]\n                current_lab.country = address[\"country\"]\n                current_lab.country_code = address[\"country_code\"]\n                current_lab.latitude = address[\"latitude\"]\n                current_lab.longitude = address[\"longitude\"]\n                current_lab.county = address[\"county\"]\n                current_lab.postal_code = address[\"postal_code\"]\n                current_lab.state = address[\"state\"]\n\n                # Add the lab to the list\n                diybiolabs[slug] = current_lab\n                del current_lab\n\n    # Return a dictionary / json\n    if format.lower() == \"dict\":\n        output = {}\n        for j in diybiolabs:\n            output[j] = diybiolabs[j].__dict__\n    # Return a geojson\n    elif format.lower() == \"geojson\" or format.lower() == \"geo\":\n        labs_list = []\n        for l in diybiolabs:\n            single = diybiolabs[l].__dict__\n            single_lab = Feature(\n                type=\"Feature\",\n                geometry=Point((single[\"latitude\"], single[\"longitude\"])),\n                properties=single)\n            labs_list.append(single_lab)\n        output = dumps(FeatureCollection(labs_list))\n    # Return a Pandas DataFrame\n    elif format.lower() == \"pandas\" or format.lower() == \"dataframe\":\n        output = {}\n        for j in diybiolabs:\n            output[j] = diybiolabs[j].__dict__\n        # Transform the dict into a Pandas DataFrame\n        output = pd.DataFrame.from_dict(output)\n        # Put labs names as the index, to make it coherent with other APIs\n        output = output.transpose()\n    # Return an object\n    elif format.lower() == \"object\" or format.lower() == \"obj\":\n        output = diybiolabs\n    # Default: return an oject\n    else:\n        output = diybiolabs\n    # Return a proper json\n    if format.lower() == \"json\":\n        output = json.dumps(diybiolabs)\n    return output", "response": "Gets the DIYBio Lab data from diybio. org."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef open(target):\n    if sys.platform == \"win32\":\n        os.startfile(target)\n    else:\n        opener = \"open\" if sys.platform == \"darwin\" else \"xdg-open\"\n        subprocess.call([opener, target])", "response": "Opens the target file or URL in the default application."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn normal print function if enable otherwise a dummy print function is returned which will suppress output.", "response": "def verbose(enabled):\n    \"\"\"Returns normal print function if enable, otherwise a dummy print\n    function is returned which will suppress output.\"\"\"\n    def _vprint(msg, **kwargs):\n        print(msg, **kwargs)\n    def _nprint(msg, **kwargs):\n        pass\n    return _vprint if enabled else _nprint"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nwrapping a function in a try/catch block. Can be used as a function decorator or as a function that accepts another function. **Params**: - func (func) - Function to call. Only available when used as a function. - oncatch (str) [kwargs] - Function to call if an exception is caught. - rethrow (str) [kwargs] - If true, exception will be re-thrown. **Examples**: :: trycatch(myfunc)(myarg1, myarg2, kwarg=mykwarg) trycatch(myfunc, oncatch=mycatchfunc)(myarg1, myarg2, kwarg=mykwarg) trycatch(myfunc, rethrow=True)(myarg1, myarg2, kwarg=mykwarg)", "response": "def trycatch(*args, **kwargs):\n    \"\"\"Wraps a function in a try/catch block. Can be used as a function\n    decorator or as a function that accepts another function.\n\n    **Params**:\n      - func (func) - Function to call. Only available when used as a function.\n      - oncatch (str) [kwargs] - Function to call if an exception is caught.\n      - rethrow (str) [kwargs] - If true, exception will be re-thrown.\n\n    **Examples**:\n    ::\n\n        trycatch(myfunc)(myarg1, myarg2, kwarg=mykwarg)\n        trycatch(myfunc, oncatch=mycatchfunc)(myarg1, myarg2, kwarg=mykwarg)\n        trycatch(myfunc, rethrow=True)(myarg1, myarg2, kwarg=mykwarg)\n    \"\"\"\n    rethrow = kwargs.get('rethrow', False)\n    oncatch = kwargs.get('oncatch', None)\n    def decor(func):\n        def wrapper(*fargs, **fkrgs):\n            try:\n                return func(*fargs, **fkrgs)\n            except:\n                if oncatch != None:\n                    oncatch()\n                if rethrow:\n                    raise\n        return wrapper\n    if len(args) > 0 and callable(args[0]):\n        func = args[0]\n        return decor(func)\n    return decor"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nlimit the number of times a function can be called. Can be used as a function decorator or as a function that accepts another function. If used as a function, it returns a new function that will be call limited. **Params**: - func (func) - Function to call. Only available when used as a function. **Examples**: :: call = callstop(myfunc, limit=3) call(myarg1, myarg2)", "response": "def callstop(*args, **kwargs):\n    \"\"\"Limits the number of times a function can be called. Can be used as a\n    function decorator or as a function that accepts another function. If used\n    as a function, it returns a new function that will be call limited.\n\n    **Params**:\n      - func (func) - Function to call. Only available when used as a function.\n\n    **Examples**:\n    ::\n\n        call = callstop(myfunc, limit=3)\n        call(myarg1, myarg2)\n    \"\"\"\n    limit = kwargs.get('limit', 1)\n    def decor(func):\n        def wrapper(*args, **kwargs):\n            if wrapper.calls < limit:\n                wrapper.calls += 1\n                return func(*args, **kwargs)\n        wrapper.calls = 0\n        return wrapper\n    if len(args) > 0 and callable(args[0]):\n        func = args[0]\n        return decor(func)\n    return decor"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nwaiting for an instance to be running in which case return True otherwise False", "response": "def wait_for_instance(instance):\n    \"\"\" wait for instance status to be 'running' in which case return True, False otherwise \"\"\"\n\n    status = None\n    print(\"getting status for instance {} ...\".format(instance.id))\n    while status is None:\n        try:\n            status = instance.update()\n            if status is None:\n                time.sleep(2)\n        except EC2ResponseError:\n            time.sleep(2)\n\n    print(\"waiting for instance {} ...\".format(instance.id))\n\n    while status == \"pending\":\n        time.sleep(2)\n        status = instance.update()\n\n    if status != \"running\":\n        print(\"Invalid status when starting instance {}: {}\".format(instance.id, status))\n        return False\n\n    print(\"New instance {} started: {}\".format(instance.id, instance.ip_address))\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nvalidating a data package. json file against a jsonschema.", "response": "def validate(datapackage, schema='base'):\n    '''Validate Data Package datapackage.json files against a jsonschema.\n\n    Args:\n        datapackage (str or dict): The Data Package descriptor file (i.e.\n            datapackage.json) as a dict or its contents in a string.\n        schema (str or dict): If a string, it can be the schema ID in the\n            registry, a local path, a URL or the schema's JSON as a string. If\n            a dict, it must be the JSON Schema itself.\n\n    Returns:\n        None\n\n    Raises:\n        DataPackageValidateException: This exception has the list of the\n            validation errors in its `.errors` attribute.\n    '''\n\n    errors = []\n    schema_obj = None\n    datapackage_obj = None\n\n    # Sanity check datapackage\n    # If datapackage is a str, check json is well formed\n    if isinstance(datapackage, six.string_types):\n        try:\n            datapackage_obj = json.loads(datapackage)\n        except ValueError as e:\n            errors.append(DataPackageValidateException(e))\n    elif not isinstance(datapackage, dict):\n        msg = 'Data Package must be a dict or JSON string, but was a \\'{0}\\''\n        dp_type = type(datapackage).__name__\n        error = DataPackageValidateException(msg.format(dp_type))\n        errors.append(error)\n    else:\n        datapackage_obj = datapackage\n\n    try:\n        if isinstance(schema, six.string_types):\n            try:\n                schema = json.loads(schema)\n            except ValueError:\n                pass\n\n        schema_obj = Schema(schema)\n    except (SchemaError,\n            RegistryError) as e:\n        errors.append(e)\n\n    # Validate datapackage against the schema\n    if datapackage_obj is not None and schema_obj is not None:\n        try:\n            schema_obj.validate(datapackage_obj)\n        except ValidationError as e:\n            errors.append(e)\n\n    if errors:\n        exception = DataPackageValidateException()\n        exception.errors = errors\n        raise exception"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef make_request(\n    ins, method, url, stripe_account=None, params=None, headers=None, **kwargs\n):\n    \"\"\"\n    Return a deferred or handle error.\n\n    For overriding in various classes.\n    \"\"\"\n    if txstripe.api_key is None:\n        raise error.AuthenticationError(\n            'No API key provided. (HINT: set your API key using '\n            '\"stripe.api_key = <API-KEY>\"). You can generate API keys '\n            'from the Stripe web interface.  See https://stripe.com/api '\n            'for details, or email support@stripe.com if you have any '\n            'questions.')\n\n    abs_url = '{}{}'.format(txstripe.api_base, url)\n\n    ua = {\n        'lang': 'python',\n        'publisher': 'lextoumbourou',\n        'httplib': 'Twisted',\n    }\n\n    headers = headers or {}\n    headers.update({\n        'X-Stripe-Client-User-Agent': util.json.dumps(ua),\n        'User-Agent': 'txstripe',\n        'Authorization': 'Bearer %s' % (txstripe.api_key,)\n    })\n\n    if stripe_account:\n        headers['Stripe-Account'] = stripe_account\n\n    if txstripe.api_version is not None:\n        headers['Stripe-Version'] = txstripe.api_version\n\n    if method == 'get' or method == 'delete':\n        data = None\n    elif method == 'post':\n        data = {k: v for (k, v) in _api_encode(params)}\n        params = None\n    else:\n        raise error.APIConnectionError(\n            'Unrecognized HTTP method %r.  This may indicate a bug in the '\n            'Stripe bindings.' % (method,))\n\n    resp = yield treq.request(\n        method, abs_url, params=params, data=data, headers=headers, **kwargs)\n\n    if resp.code >= 400:\n        yield util.handle_api_error(resp)\n        return\n\n    body = yield resp.json()\n\n    defer.returnValue(\n        convert_to_stripe_object(\n            body, txstripe.api_key, stripe_account))", "response": "Make a request to the Stripe API."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef request(self, method, url, params=None, headers=None):\n        if params is None:\n            params = self._retrieve_params\n\n        return make_request(\n            self, method, url, stripe_account=self.stripe_account,\n            params=params, headers=headers)", "response": "Make a request to the specified URL using the specified parameters."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef retrieve(cls, id, api_key=None, **params):\n        instance = cls(id, api_key, **params)\n        d = instance.refresh()\n        return d.addCallback(lambda _: instance)", "response": "Retrieve a specific resource from the cache."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef refresh(self):\n        d = self.request('get', self.instance_url())\n        return d.addCallback(self.refresh_from).addCallback(lambda _: self)", "response": "Return a deferred that resolves when the cache is refreshed."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef all(cls, api_key=None, idempotency_key=None,\n            stripe_account=None, **params):\n        \"\"\"Return a deferred.\"\"\"\n        url = cls.class_url()\n        return make_request(\n            cls, 'get', url, stripe_acconut=None, params=params)", "response": "Return a deferred that resolves with the result of a request to retrieve all the items from the database."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates a new resource in the specified stripe account.", "response": "def create(\n        cls, api_key=None, idempotency_key=None, stripe_account=None, **params\n    ):\n        \"\"\"Return a deferred.\"\"\"\n        url = cls.class_url()\n        headers = populate_headers(idempotency_key)\n        return make_request(\n            cls, 'post', url, stripe_account=stripe_account,\n            headers=headers, params=params)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsaving the object to the server.", "response": "def save(self, idempotency_key=None):\n        \"\"\"Return a deferred.\"\"\"\n        updated_params = self.serialize(None)\n        headers = populate_headers(idempotency_key)\n\n        if not updated_params:\n            util.logger.debug(\"Trying to save already saved object %r\", self)\n            return defer.succeed(self)\n\n        d = self.request('post', self.instance_url(), updated_params, headers)\n        return d.addCallback(self.refresh_from).addCallback(lambda _: self)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndeleting the current record set.", "response": "def delete(self, **params):\n        \"\"\"Return a deferred.\"\"\"\n        d = self.request('delete', self.instance_url(), params)\n        return d.addCallback(self.refresh_from).addCallback(lambda _: self)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nupdate the dispute status of the current user.", "response": "def update_dispute(self, idempotency_key=None, **params):\n        \"\"\"Return a deferred.\"\"\"\n        url = self.instance_url() + '/dispute'\n        headers = populate_headers(idempotency_key)\n        d = self.request('post', url, params, headers)\n        d.addCallback(lambda response: self.refresh_from(\n            {'dispute': response}, api_key, True))\n        return d.addCallback(lambda _: self.dispute)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nclosing the current resource.", "response": "def close(self, idempotency_key=None):\n        \"\"\"Return a deferred.\"\"\"\n        url = self.instance_url() + '/close'\n        headers = populate_headers(idempotency_key)\n        d = self.request('post', url, {}, headers)\n        return d.addCallback(self.refresh_from).addCallback(lambda _: self)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef invoices(self, **params):\n        params['customer'] = self.id\n        return Invoice.all(self.api_key, **params)", "response": "Return a deferred that resolves with the invoice objects"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef invoice_items(self, **params):\n        params['customer'] = self.id\n        return InvoiceItem.all(self.api_key, **params)", "response": "Return a deferred that resolves with the invoice items"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndelete the discount from the instance.", "response": "def delete_discount(self, **params):\n        \"\"\"Return a deferred.\"\"\"\n        url = self.instance_url() + '/discount'\n        d = self.request('delete', url)\n        d.addCallback(lambda response: self.refresh_from(\n            {'discount': None}, api_key, True))\n        return d.addCallback(lambda _: self.subscription)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a deferred that resolves when the user is upcoming.", "response": "def upcoming(cls, api_key=None, stripe_account=None, **params):\n        \"\"\"Return a deferred.\"\"\"\n        url = cls.class_url() + '/upcoming'\n        return cls.request('get', url, params)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef cancel(self):\n        d = self.request('post', self.instance_url() + '/cancel')\n        return d.addCallback(self.refresh_from)", "response": "Cancel the current session."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a Deferred that resolves with the Transfer objects.", "response": "def transfers(self, **params):\n        \"\"\"Return a deferred.\"\"\"\n        params['recipient'] = self.id\n        return Transfer.all(self.api_key, **params)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef refund(self, idempotency_key=None, **params):\n        headers = populate_headers(idempotency_key)\n        url = self.instance_url() + '/refund'\n        d = self.request('post', url, params, headers)\n        return d.addCallback(self.refresh_from).addCallback(lambda _: self)", "response": "Refund the current resource."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef move_files_to_folders(directory):\n    # Generate lists of files and folders in root directory\n    files, folders, files_to_move = [], [], []\n    for path in os.listdir(directory):\n        if os.path.isdir(path):\n            folders.append(path)\n        elif os.path.isfile(path):\n            files.append(path)\n\n    # Loop through folders in root directory\n    for path in folders:\n        # Generate list of files with same prefix as current folder\n        child_files = [f for f in files if f.startswith(path)]\n        files_to_move.append((path, child_files))\n\n    # Move child files into parent folder\n    for each in files_to_move:\n        folder, files = each\n        for f in files:\n            shutil.move(f, folder)", "response": "Move files to a parent directory and nests files within folders that already exists and have matching prefixs\n   ."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nremove file paths directory if the directory is empty.", "response": "def remove_path_dirname(path):\n        \"\"\"\n        Removes file paths directory if the directory is empty\n        :param path: Filepath\n        \"\"\"\n        dir_to_remove = os.path.dirname(path)\n        if not os.listdir(dir_to_remove):\n            shutil.rmtree(dir_to_remove)\n        else:\n            if len(os.listdir(dir_to_remove)) == 1:\n                if os.listdir(dir_to_remove)[0].startswith('.'):\n                    shutil.rmtree(dir_to_remove)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef parse_arguments(arguments=sys.argv[1:]):\n        args = docopt.docopt(doc=\"\"\"\nSmart File Sorter\n\nUsage:\n  sfp RULEFILE DIRECTORY [--debug] [--dry-run] [--log LOGFILE]\n  sfp [--debug] --list-plugins\n\nOptions:\n    RULEFILE        Rule configuration file to execute\n    DIRECTORY       Directory of files to process\n    --debug         Log extra information during processing\n    --dry-run       Log actions but do not make any changes\n    --log LOGFILE   Specify log output file\n    --list-plugins  Print match and action plugin information\n        \"\"\", argv=arguments)\n        return args", "response": "Parse command line arguments and return docopt args object"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates and configure the program s logger object.", "response": "def create_logger(self, args={}):\n        \"\"\"\n        Create and configure the program's logger object.\n\n        Log levels:\n        DEBUG - Log everything. Hidden unless --debug is used.\n        INFO - information only\n        ERROR - Critical error\n        :param args: Object containing program's parsed command line arguments\n        :return: None\n        \"\"\"\n        # Set up logging\n        logger = logging.getLogger(\"SmartFileSorter\")\n        logger.level = logging.INFO\n\n        if '--debug' in args and args['--debug'] is True:\n            logger.setLevel(logging.DEBUG)\n\n        file_log_formatter = logging.Formatter('%(asctime)s %(name)s %(levelname)s %(message)s',\n                                               '%Y-%m-%d %H:%M:%S')\n        console_log_formatter = logging.Formatter('%(message)s')\n\n        # Log to stdout\n        stdout_stream = logging.StreamHandler(stream=sys.stdout)\n        stdout_stream.setFormatter(console_log_formatter)\n        logger.addHandler(stdout_stream)\n\n        # Log to file if the option is chosen\n        if '--log' in args and args['--log'] is not None:\n            logfile = open(args['--log'], 'w')\n            logfile_stream = logging.StreamHandler(stream=logfile)\n            logfile_stream.setFormatter(file_log_formatter)\n            logger.addHandler(logfile_stream)\n\n        if '--dry-run' in args and args['--dry-run'] is True:\n            logger.info('Running with --dry-run parameter. Actions will not be performed.')\n        self.logger = logger"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nloads rules from YAML file.", "response": "def load_rules(self, filename):\n        \"\"\"\n        Load rules from YAML configuration in the given stream object\n        :param filename: Filename of rule YAML file\n        :return: rules object\n        \"\"\"\n        self.logger.debug('Reading rules from %s', filename)\n        try:\n            in_file = open(filename)\n        except IOError:\n            self.logger.error('Error opening {0}'.format(filename))\n            raise\n\n        y = None\n        try:\n            y = yaml.load(in_file)\n        except yaml.YAMLError as exc:\n            if hasattr(exc, 'problem_mark'):\n                self.logger.error('Error parsing rules{0}'.format(exc.problem_mark))\n\n            else:\n                self.logger.error('Error parsing rules in {0}'.format(in_file.name))\n            raise\n        return y"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nloads the plugins from the given path.", "response": "def load_plugins(self, plugin_path):\n        \"\"\"\n        Loads plugins from modules in plugin_path. Looks for the config_name property\n        in each object that's found. If so, adds that to the dictionary with the\n        config_name as the key. config_name should be unique between different plugins.\n\n        :param plugin_path: Path to load plugins from\n        :return: dictionary of plugins by config_name\n        \"\"\"\n        self.logger.debug('Loading plugins from {0}'.format(plugin_path))\n        plugins = {}\n        plugin_dir = os.path.realpath(plugin_path)\n        sys.path.append(plugin_dir)\n\n        for f in os.listdir(plugin_dir):\n            if f.endswith(\".py\"):\n                name = f[:-3]\n            elif f.endswith(\".pyc\"):\n                name = f[:-4]\n            # Possible support for plugins inside directories - worth doing?\n            # elif os.path.isdir(os.path.join(plugin_dir, f)):\n            #    name = f\n            else:\n                continue\n\n            try:\n                self.logger.debug('Adding plugin from: {0}'.format(f))\n                mod = __import__(name, globals(), locals(), [], 0)\n\n                for plugin_class in inspect.getmembers(mod):\n                    if plugin_class[0][0:2] == '__':            # Skip dunder members - builtins, etc\n                        continue\n                    if hasattr(plugin_class[1], 'config_name'):\n                        if plugin_class[1].config_name is not None:\n                            # Skip plugins where config_name is None, like the base classes\n                            plugins[plugin_class[1].config_name] = plugin_class[1]\n                            self.logger.debug('Added plugin: {0}'.format(plugin_class[1].config_name))\n\n                            # Todo: Add error checking here. If a plugin with that name already exists,\n                            # log an error. Quit or continue?\n\n            except ImportError as e:\n                self.logger.error(e)\n                pass            # problem importing\n\n        self.logger.debug('Done loading plugins')\n        return plugins"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconvert parsed rule YAML in to a list of ruleset objects", "response": "def build_rules(rule_yaml, match_plugins, action_plugins):\n        \"\"\"\n        Convert parsed rule YAML in to a list of ruleset objects\n        :param rule_yaml: Dictionary parsed from YAML rule file\n        :param match_plugins: Dictionary of match plugins (key=config_name, value=plugin object)\n        :param action_plugins: Dictionary of action plugins (key=config_name, value=plugin object)\n        :return: list of rules\n        \"\"\"\n        rule_sets = []\n\n        for yaml_section in rule_yaml:\n            rule_sets.append(RuleSet(yaml_section, match_plugins=match_plugins, action_plugins=action_plugins))\n        return rule_sets"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nloads plugins and run with the configuration given in args", "response": "def run(self, args):\n        \"\"\"\n        Load plugins and run with the configuration given in args\n        :param args: Object containing program's parsed command line arguments\n        :return: None\n        \"\"\"\n        module_dir = os.path.dirname(__file__)\n        self.match_plugins = self.load_plugins(os.path.join(module_dir, 'matchplugins/'))\n        self.action_plugins = self.load_plugins(os.path.join(module_dir, 'actionplugins/'))\n\n        if args['--list-plugins'] is True:\n            print(\"\\nAvailable Match Plugins:\")\n            for m in sorted(self.match_plugins):\n                print(m)\n            print(\"\\nAvailable Action Plugins:\")\n            for a in sorted(self.action_plugins):\n                print(a)\n            sys.exit()\n\n        rule_yaml = self.load_rules(args['RULEFILE'])\n        rules = self.build_rules(rule_yaml, self.match_plugins, self.action_plugins)\n\n        files_analyzed = 0\n        files_matched = 0\n        result_count = collections.defaultdict(int)\n\n        for cur_file in self.get_files(args['DIRECTORY']):\n            self.logger.debug(\"Processing {0}\".format(cur_file))\n            files_analyzed += 1\n\n            for ruleset in rules:\n                if ruleset.matches_all_rules(cur_file):\n                    files_matched += 1\n                    result_count[ruleset] += 1\n                    # If the file matches all rules in the ruleset, do whatever\n                    # actions the ruleset specifies. Stop processing if the\n                    # ruleset says stop.\n                    try:\n                        ruleset.do_actions(cur_file, args['--dry-run'])\n                    except StopProcessingException:\n                        break\n\n        self.logger.info(\"Files matched: {0}/{1}\".format(files_matched, files_analyzed))\n        for ruleset in sorted(result_count):\n            self.logger.info(\"{0}: {1} files\".format(ruleset.name, result_count[ruleset]))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the error between this and other bearing.", "response": "def delta(self, other):\n        '''\n        Return the error between this and another bearing. This will be an\n        angle in degrees, positive or negative depending on the direction of\n        the error.\n        \n            self   other\n              \\      /\n               \\    /\n                \\__/\n                 \\/ <- angle will be +ve\n\n            other   self\n              \\      /\n               \\    /\n                \\__/\n                 \\/ <- angle will be -ve        \n\n        :param other: bearing to compare to\n        :type other: Bearing\n\n        :returns: error angle\n        :rtype: float\n        '''\n        difference = float(other) - float(self)\n        while difference < -180:\n            difference += 360\n        while difference > 180:\n            difference -= 360\n        return difference"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef deserialize_request(self, req):\n\n        # See if we have a body\n        if req.content_length == 0:\n            return None\n\n        # Get the primary deserializer\n        try:\n            deserializer = self.method.deserializers(req.content_type)\n        except KeyError:\n            raise webob.exc.HTTPUnsupportedMediaType()\n\n        # If it has an attacher, attach all the deserializers for the\n        # extensions\n        if hasattr(deserializer, 'attach'):\n            for ext in self.extensions:\n                try:\n                    deserializer.attach(ext.deserializers(req.content_type))\n                except KeyError:\n                    pass\n\n        # A deserializer is simply a callable, so call it\n        return deserializer(req.body)", "response": "Deserializes the request into a dictionary of the appropriate class."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nselecting and returns the serializer to use based on the action method and extensions.", "response": "def serializer(self, req):\n        \"\"\"\n        Selects and returns the serializer to use, based on the\n        serializers declared on the action method and its extensions.\n        The returned content type is selected based on the types\n        available and the best match generated from the HTTP `Accept`\n        header.  Raises `HTTPNotAcceptable` if the request cannot be\n        serialized to an acceptable media type.  Returns a tuple of\n        the content type and the serializer.\n        \"\"\"\n\n        # Select the best match serializer\n        content_types = self.method.serializers.get_types()\n        content_type = req.accept.best_match(content_types)\n        if content_type is None:\n            raise webob.exc.HTTPNotAcceptable()\n\n        # Select the serializer to use\n        try:\n            serializer = self.method.serializers(content_type)\n        except KeyError:\n            raise webob.exc.HTTPNotAcceptable()\n\n        # If it has an attacher, attach all the serializers for the\n        # extensions\n        if hasattr(serializer, 'attach'):\n            for ext in reversed(self.extensions):\n                try:\n                    serializer.attach(ext.serializers(content_type))\n                except KeyError:\n                    pass\n\n        # Return content type and serializer\n        return content_type, serializer"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nposting - process the extensions for the action.", "response": "def post_process(self, post_list, req, resp, params):\n        \"\"\"\n        Post-process the extensions for the action.  If any\n        post-processing extension (specified by `post_list`, which\n        should be generated by the pre_process() method) yields a\n        value which tests as True, the response being considered by\n        post-processing extensions is updated to be that value.\n        Returns the final response.\n        \"\"\"\n\n        # Walk through the post-processing extensions\n        for ext in post_list:\n            if inspect.isgenerator(ext):\n                try:\n                    result = ext.send(resp)\n                except StopIteration:\n                    # Expected, but not required\n                    result = None\n\n                # If it returned a response, use that for subsequent\n                # processing\n                if result:\n                    resp = self.wrap(req, result)\n            else:\n                result = ext(req, resp, **params)\n\n                # If it returned a response, use that for subsequent\n                # processing\n                if result:\n                    resp = self.wrap(req, result)\n\n        return resp"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nwrapping method return results.", "response": "def wrap(self, req, result):\n        \"\"\"\n        Wrap method return results.  The return value of the action\n        method and of the action extensions is passed through this\n        method before being returned to the caller.  Instances of\n        `webob.Response` are thrown, to abort the rest of action and\n        extension processing; otherwise, objects which are not\n        instances of ResponseObject will be wrapped in one.\n        \"\"\"\n\n        if isinstance(result, webob.exc.HTTPException):\n            # It's a webob HTTP exception; use raise to bail out\n            # immediately and pass it upstream\n            raise result\n        elif isinstance(result, webob.Response):\n            # Straight-up webob Response object; we raise\n            # AppathyResponse to bail out\n            raise exceptions.AppathyResponse(result)\n        elif isinstance(result, response.ResponseObject):\n            # Already a ResponseObject; bind it to this descriptor\n            result._bind(self)\n            return result\n        else:\n            # Create a new, bound, ResponseObject\n            return self.resp_type(req, result, _descriptor=self)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn all outlets that are currently active and have sales.", "response": "def active(self):\n        \"\"\"Returns all outlets that are currently active and have sales.\"\"\"\n        qs = self.get_queryset()\n        return qs.filter(\n            models.Q(\n                models.Q(start_date__isnull=True) |\n                models.Q(start_date__lte=now().date())\n            ) &\n            models.Q(\n                models.Q(end_date__isnull=True) |\n                models.Q(end_date__gte=now().date())\n            )\n        ).distinct()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef future(self):\n        qs = self.get_queryset()\n        return qs.filter(\n            models.Q(end_date__isnull=True) |\n            models.Q(end_date__gte=now().date())\n        )", "response": "Returns all outlets that are or will be active."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _get_path(dict_, path):\n    '''\n    Get value at specific path in dictionary. Path is specified by slash-\n    separated string, eg _get_path(foo, 'bar/baz') returns foo['bar']['baz']\n    '''\n    cur = dict_\n    for part in path.split('/'):\n        cur = cur[part]\n    return cur", "response": "Get value at specific path in dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nensuring chambers are created for the current language.", "response": "def ensure_chambers():\n    \"\"\"\n    Ensures chambers are created\n    \"\"\"\n    france = Country.objects.get(name=\"France\")\n    for key in ('AN', 'SEN'):\n        variant = FranceDataVariants[key]\n        Chamber.objects.get_or_create(name=variant['chamber'],\n                                      abbreviation=variant['abbreviation'],\n                                      country=france)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef touch_model(self, model, **data):\n        '''\n        This method create or look up a model with the given data\n        it saves the given model if it exists, updating its\n        updated field\n        '''\n\n        instance, created = model.objects.get_or_create(**data)\n\n        if not created:\n            if instance.updated < self.import_start_datetime:\n                instance.save()     # Updates updated field\n\n        return (instance, created)", "response": "This method creates or updates the given model with the given data."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nmanage a MEP from a json dict fetched from nosdeputes. fr and save the attributes of the representative attributes.", "response": "def manage_rep(self, rep_json):\n        '''\n        Import a rep as a representative from the json dict fetched from\n        FranceData (which comes from nosdeputes.fr)\n        '''\n\n        # Some versions of memopol will connect to this and skip inactive reps.\n        responses = representative_pre_import.send(sender=self,\n                representative_data=rep_json)\n\n        for receiver, response in responses:\n            if response is False:\n                logger.debug(\n                    'Skipping MEP %s', rep_json['nom'])\n                return\n\n        changed = False\n        slug = slugify('%s-%s' % (\n            rep_json['nom'] if 'nom' in rep_json\n            else rep_json['prenom'] + \" \" + rep_json['nom_de_famille'],\n            _parse_date(rep_json[\"date_naissance\"])\n        ))\n\n        try:\n            representative = Representative.objects.get(slug=slug)\n        except Representative.DoesNotExist:\n            representative = Representative(slug=slug)\n            changed = True\n\n        if rep_json['num_circo'] == 'non disponible':\n            rep_json['num_circo'] = 'nd'\n\n        # Save representative attributes\n        self.import_representative_details(representative, rep_json, changed)\n\n        self.add_mandates(representative, rep_json)\n\n        self.add_contacts(representative, rep_json)\n\n        logger.debug('Imported MEP %s', unicode(representative))\n\n        return representative"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate mandates from rep data based on variant configuration.", "response": "def add_mandates(self, representative, rep_json):\n        '''\n        Create mandates from rep data based on variant configuration\n        '''\n\n        # Mandate in country group for party constituency\n        if rep_json.get('parti_ratt_financier'):\n            constituency, _ = Constituency.objects.get_or_create(\n                name=rep_json.get('parti_ratt_financier'), country=self.france)\n\n            group, _ = self.touch_model(model=Group,\n                                        abbreviation=self.france.code,\n                                        kind='country',\n                                        name=self.france.name)\n\n            _create_mandate(representative, group, constituency, 'membre')\n\n        # Configurable mandates\n        for mdef in self.variant['mandates']:\n            if mdef.get('chamber', False):\n                chamber = self.chamber\n            else:\n                chamber = None\n\n            if 'from' in mdef:\n                elems = mdef['from'](rep_json)\n            else:\n                elems = [rep_json]\n\n            for elem in elems:\n                name = _get_mdef_item(mdef, 'name', elem, '')\n                abbr = _get_mdef_item(mdef, 'abbr', elem, '')\n\n                group, _ = self.touch_model(model=Group,\n                                            abbreviation=abbr,\n                                            kind=mdef['kind'],\n                                            chamber=chamber,\n                                            name=name)\n\n                role = _get_mdef_item(mdef, 'role', elem, 'membre')\n                start = _get_mdef_item(mdef, 'start', elem, None)\n                if start is not None:\n                    start = _parse_date(start)\n                end = _get_mdef_item(mdef, 'end', elem, None)\n                if end is not None:\n                    end = _parse_date(end)\n\n                _create_mandate(representative, group, self.ch_constituency,\n                                role, start, end)\n\n                logger.debug(\n                    '%s => %s: %s of \"%s\" (%s) %s-%s' % (rep_json['slug'],\n                    mdef['kind'], role, name, abbr, start, end))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the environment variable. If not found use a default.", "response": "def env(var_name, default=False):\n    \"\"\" Get the environment variable. If not found use a default or False, but print to stderr a warning about the missing env variable.\"\"\"\n    try:\n        value = os.environ[var_name]\n        if str(value).strip().lower() in ['false', 'f', 'no', 'off' '0', 'none', 'null', '', ]:\n            return None\n        return value\n    except:\n        from traceback import format_exc\n        msg = \"Unable to find the %s environment variable.\\nUsing the value %s (the default) instead.\\n\" % (var_name, default)\n        sys.stderr.write(format_exc())\n        sys.stderr.write(msg)\n        return default"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn set of string names of current available Splunk KV collections", "response": "def current_kv_names(sci, app_user, app_name, request=None):\n    \"\"\"Return set of string names of current available Splunk KV collections\n    \n    Args:\n        sci: Instance of sparc.db.splunk.ISplunkConnectionInfo\n        app_user: Splunk KV Collection app user to reference\n        app_name: Splunk KV Collection application name to reference\n    kwargs:\n        request: instance of sparc.utils.requests.IRequest\n        \n    request will be resolved via 'sparc.utils.requests.request_resolver' named\n    component.\n\n    Returns:\n        Set of string names for collections found\n    \"\"\"\n    resolver = sm.getUtility(IRequest, u'sparc.utils.requests.request_resolver')\n    req = resolver(request=request)\n    kwargs = {'auth': (sci['username'], sci['password'], )}\n    url = \"\".join(['https://',sci['host'],':',sci['port'],\n                                    '/servicesNS/',app_user,'/',\n                                                        app_name,'/'])\n    _return = set()\n    r = req.request('get', url+\"storage/collections/config\", **kwargs)\n    r.raise_for_status()\n    root = ET.fromstring(r.text)\n    for entry in root.findall('./atom:entry', xml_ns):\n        name = entry.find('./atom:title', xml_ns).text\n        if not name:\n            raise ValueError('unexpectedly found empty collection title')\n        _return.add(name)\n    return _return"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn dictionary of file content as well as google reverse GEO data", "response": "def lookupfile(filename):\n    \"\"\"Returns dictionary of file content as well \n    as google reverse GEO data\"\"\"\n    logger.info('Looking up %s'%(filename))\n\n    # First open cache file to see if we already looked up this stuff\n    dirname=os.path.dirname(filename)\n    basefilename=os.path.basename(filename)\n\n    CACHE_FILE = os.path.join(dirname,'.'+basefilename+'.gpscache')\n    cache=loadCacheFile(CACHE_FILE)\n\n    # Get the input file\n    positions=parsePositionFile(filename)\n\n    # If load didn't work, read again and lookup\n    if not cache:\n        logger.info(\"%s - No cache file found, looking up location\"\\\n                %(basefilename))\n        cache=lookupGeoInfo(positions)\n        # Save to DB\n        json.dump(cache,open(CACHE_FILE,'w'))\n    else:\n        logger.info(\"%s - Found cache file for locations\"\\\n                %(basefilename))\n\n    return positions,cache"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef lookup_by_latlon(lat,lon):\n\n    logger.info(\"Looking up %s/%s via google\"%(lat,lon))\n    results = Geocoder.reverse_geocode(float(lat),float(lon))\n    addrs=results.data[0]['address_components']\n    d={}\n    d['fullname']=str(results)\n    for addr in addrs:\n        if addr['types'][0]=='locality':\n            d['city']=addr['short_name']\n        elif addr['types'][0]=='street_number':\n            d['street number']=addr['short_name']\n        elif addr['types'][0]=='route':\n            d['route']=addr['short_name']\n        elif addr['types'][0]=='admin area 2':\n            d['admin area 2']=addr['short_name']\n        elif addr['types'][0]=='admin area 1':\n            d['admin area 1']=addr['short_name']\n        elif addr['types'][0]=='country':\n            d['country']=addr['long_name']\n        elif addr['types'][0]=='postal_code':\n            d['postal_code']=addr['short_name']\n\n    # Slow us down so google doesn't complain!\n    time.sleep(0.1)\n\n    return d", "response": "Looks up location given lat lon\n    returns dictionary with address"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef parsePositionFile(filename):\n    l=[]\n    with open( filename, \"rb\" ) as theFile:\n        reader = csv.DictReader( theFile )\n        for line in reader:\n            # Convert the time string to something\n            # a bit more human readable\n            mytime=dateparser.parse(line['time'])\n            line['strtime']=mytime.strftime(\"%d %b %Y, %H:%M UTC\")\n            l.append(line)\n    return l", "response": "Parses Android GPS logger csv file and returns list of dictionaries"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nlooking up lat / lon info with goole given a list of positions as parsed by parsePositionFile.", "response": "def lookupGeoInfo(positions):\n    \"\"\"Looks up lat/lon info with goole given a list\n    of positions as parsed by parsePositionFile.\n    Returns google results in form of dicionary\n    \"\"\"\n    list_data=[]\n    oldlat=0\n    oldlon=0\n    d={}\n    for pos in positions:\n        # Only lookup point if it is above threshold\n        diff_lat=abs(float(pos['lat'])-oldlat)\n        diff_lon=abs(float(pos['lon'])-oldlon)\n        if (diff_lat>POS_THRESHOLD_DEG) or\\\n           (diff_lon>POS_THRESHOLD_DEG):\n            d=lookup_by_latlon(pos['lat'],pos['lon'])\n            oldlat=float(pos['lat'])\n            oldlon=float(pos['lon'])\n        else:\n            logger.debug(\"Skipping %s/%s, close to prev\"%(pos['lat'],pos['lon']))\n\n        # Use fresh lookup value or old value\n        list_data.append(d)\n\n    logger.info('looked up %d positions'%(len(list_data)))\n    return list_data"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the md5 digest of all interesting files in dirname.", "response": "def digest(dirname, glob=None):\n    \"\"\"Returns the md5 digest of all interesting files (or glob) in `dirname`.\n    \"\"\"\n    md5 = hashlib.md5()\n    if glob is None:\n        fnames = [fname for _, fname in list_files(Path(dirname))]\n        for fname in sorted(fnames):\n            fname = os.path.join(dirname, fname)\n            md5.update(open(fname, 'rb').read())\n    else:\n        fnames = Path(dirname).glob(glob)\n        for fname in sorted(fnames):\n            md5.update(fname.open('rb').read())\n    return md5.hexdigest()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef changed(dirname, filename='.md5', args=None, glob=None):\n    root = Path(dirname)\n    if not root.exists():\n        # if dirname doesn't exist it is changed (by definition)\n        return True\n\n    cachefile = root / filename\n    current_digest = cachefile.open().read() if cachefile.exists() else \"\"\n    \n    _digest = digest(dirname, glob=glob)\n    if args and args.verbose:  # pragma: nocover\n        print(\"md5:\", _digest)\n    has_changed = current_digest != _digest\n\n    if has_changed:\n        with open(os.path.join(dirname, filename), 'w') as fp:\n            fp.write(_digest)\n\n    return has_changed", "response": "Returns True if the checksum of the file in dirname has changed."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef main():  # pragma: nocover\n    p = argparse.ArgumentParser()\n    p.add_argument(\n        'directory',\n        help=\"Directory to check\"\n    )\n    p.add_argument(\n        '--verbose', '-v', action='store_true',\n        help=\"increase verbosity\"\n    )\n    args = p.parse_args()\n\n    import sys\n    _changed = changed(sys.argv[1], args=args)\n    sys.exit(_changed)", "response": "Entry point for the command line interface."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn True if any of the files matched by glob changed?", "response": "def changed(self, filename='.md5', glob=None):\n        \"\"\"Are any of the files matched by ``glob`` changed?\n        \"\"\"\n        if glob is not None:\n            filename += '.glob-' + ''.join(ch.lower()\n                                           for ch in glob if ch.isalpha())\n        return changed(self, filename, glob=glob)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate a new order object for the given debtor and delivery data.", "response": "def create_order(self, debtor, is_vat_included=True, due_date=None,\n                     heading='', text_line1='', text_line2='',\n                     debtor_data=None, delivery_data=None, products=None,\n                     project=None, other_reference='', model=models.Order, **extra\n                     ):\n        \"\"\"Create a new Order.\n\n        Args:\n            debtor (Debtor): the debtor of the order\n            debtor_data (mapping): map of debtor data {'postal_code: .., 'city': .., 'ean': ..}\n                                   defaults to values on debitor instance for missing values\n            delivery_data (mapping): map of delivery data {'address': ..., 'postal_code': ...}\n                                     defaults to values on debitor instance for missing values\n            due_date (datetime): due date\n            heading (string): heading to be displayed in the order pdf\n            text_line1 (string): first order description line\n            text_line2 (string): second order description line\n            other_reference (string): custom string to be used for identification\n            extra (mapping): mapping of extra values to be passed in to the server call\n        Returns:\n            Order instance\n        \"\"\"\n\n        debtor_data = debtor_data or {}\n        delivery_data = delivery_data or {}\n        delivery_date = delivery_data.get('date', datetime.datetime.now())\n        our_reference = extra.get('our_reference', debtor.our_reference)\n        currency = extra.get('currency', debtor.currency)\n        layout = extra.get('layout', debtor.layout)\n        term_of_payment = extra.get('term_of_payment', debtor.term_of_payment)\n        date = extra.get('date', datetime.datetime.now())\n        order_input = {\n            'debtor': debtor,\n            'number': extra.get('number', 1),\n            'project': project,\n        }\n        for dd in ['name', 'address', 'postal_code', 'city', 'country', 'ean']:\n            order_input['debtor_%s' % dd] = debtor_data.get(dd, getattr(debtor, dd))\n\n        for dd in ['address', 'postal_code', 'city', 'country']:\n            order_input['delivery_%s' % dd] = delivery_data.get(dd, getattr(debtor, dd))\n\n        order_input.update({\n            'delivery_date': delivery_date or datetime.datetime.now(),\n            'heading': heading,\n            'text_line1': text_line1,\n            'text_line2': text_line2,\n            'is_archived': extra.get('is_archived', 0),\n            'is_sent': extra.get('is_sent', 0),\n            'net_amount': extra.get('net_amount', 0),\n            'vat_amount': extra.get('vat_amount', 0),\n            'gross_amount': extra.get('gross_amount', 0),\n            'margin': extra.get('margin', 0),\n            'margin_as_percent': extra.get('margin_as_percent', 0),\n            'date': date,\n            'our_reference': our_reference,\n            'other_reference': other_reference,\n            'currency': currency,\n            'exchange_rate': extra.get('exchange_rate', 1.0),\n            'is_vat_included': is_vat_included,\n            'layout': layout,\n            'due_date': due_date or datetime.datetime.now(),\n            'term_of_payment': term_of_payment\n        })\n        order_input.update(extra)\n        order = self.create(model, **order_input)\n        if products:\n            for product in products:\n                self.create_orderline(order, product)\n        return order"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef __flush(self, async=True):\n        rh = self.rh\n        messages = list(self.messages)\n        stream_notices = list(self.stream_notices)\n        self.stream_notices = []\n        self.messages = []\n        args = (rh, messages, stream_notices)\n        if async:\n            self.hub.threadPool.execute_named(self.__inner_flush,\n                '%s __inner__flush' % self.hub.l.name, *args)\n        else:\n            self.__inner_flush(*args)\n        self.rh = None\n        self._set_timeout(int(time.time() + self.hub.timeout))", "response": "Flushes messages through current HttpRequest and closes it."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add_common_arguments(parser: ArgumentParser, project: bool=False):\n    parser.add_argument(\"--url\", type=str, help=\"Location of GitLab\")\n    parser.add_argument(\"--token\", type=str, help=\"GitLab access token\")\n    parser.add_argument(\"--debug\", action=\"store_true\", default=False, help=\"Turns on debugging\")\n    if project:\n        parser.add_argument(\"project\", type=str, help=\"The GitLab project to set the build variables for\")", "response": "Adds common arguments to the given argument parser."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nimplementing the actual version setup keyword.", "response": "def version_keyword(dist, attr, value):\n    \"\"\"\n    Implements the actual version setup() keyword.\n    \"\"\"\n    if value == \"PBR\":\n        from pbr.util import setup_cfg_to_setup_kwargs\n\n        path = \"setup.cfg\"\n        parser = ConfigParser()\n        if not os.path.exists(path):\n            raise ValueError(\"file '%s' does not exist\" % os.path.abspath(path))\n        parser.read(path)\n        config = {}\n        for section in parser.sections():\n            config[section] = dict(parser.items(section))\n        attrs = setup_cfg_to_setup_kwargs(config)\n        version = str(Version(attrs[\"name\"]))\n        os.environ[\"PBR_VERSION\"] = version\n    else:\n        version = str(Version(dist.metadata.get_name()))\n    dist.metadata.version = version"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns an incremented version string.", "response": "def increment(version):\n        \"\"\"Return an incremented version string.\"\"\"\n        release_version = os.environ.get(\"RELEASE_VERSION\", None)\n        if release_version is not None:\n            return release_version\n        if isinstance(version, LegacyVersion):\n            msg = \"\"\"{0} is considered a legacy version and does not\n            support automatic incrementing.  Please bring your version\n            numbering into PEP440 standards and then it can be\n            automatically incremented.\n            \"\"\"\n            raise Exception(msg.format(version))\n        release_type = os.environ.get(\"RELEASE_TYPE\", \"micro\")\n        v = version._version\n        # epoch\n        epoch_name, epoch = VersionUtils.get_version_number(v, 0, None, \"!\")\n        pre_name, pre = VersionUtils.get_version_number(v, 3, None, \"pre\")\n        post_name, post = VersionUtils.get_version_number(v, 4, None, \"post\")\n        dev_name, dev = VersionUtils.get_version_number(v, 2, None, \"dev\")\n        _, major = VersionUtils.get_version_number(v[1], 0, 0)\n        _, minor = VersionUtils.get_version_number(v[1], 1, None)\n        _, micro = VersionUtils.get_version_number(v[1], 2, None)\n\n        # Handle dev/pre/post\n        if release_type == \"pre\":\n            micro, post, pre = VersionUtils.process_pre(micro, post, pre)\n\n        if release_type == \"post\":\n            dev, post = VersionUtils.process_post(dev, post)\n\n        if release_type == \"dev\":\n            dev = VersionUtils.process_dev(dev)\n\n        if release_type == \"micro\":\n            dev, micro, minor, post, pre = VersionUtils.process_micro(\n                dev, micro, minor, post, pre\n            )\n\n        if release_type == \"minor\":\n            dev, micro, minor, post, pre = VersionUtils.process_minor(\n                dev, micro, minor, post, pre\n            )\n\n        if release_type == \"major\":\n            dev, major, micro, minor, post, pre = VersionUtils.process_major(\n                dev, major, micro, minor, post, pre\n            )\n\n        # Handle Epoch\n        if release_type == \"epoch\":\n            dev, epoch, major, micro, minor, post, pre = VersionUtils.process_epoch(\n                dev, epoch, major, micro, minor, post, pre\n            )\n\n        local = \"\".join(v[5] or []) or None\n\n        version_list = [major, minor, micro]\n        if release_type not in [\"epoch\", \"major\", \"minor\", \"micro\", \"pre\"]:\n            version_list += list(v[1][3:])\n        version_string = \".\".join([str(x) for x in version_list if x or x == 0])\n\n        if epoch:\n            version_string = str(epoch) + epoch_name + version_string\n        if pre is not None:\n            version_string = VersionUtils.calc_pre_version_string(\n                pre, pre_name, version_string\n            )\n        if post is not None:\n            version_string += \".\" + post_name + str(post)\n        if dev is not None:\n            version_string += \".\" + dev_name + str(dev)\n        if local is not None:\n            version_string += \".\" + str(local)\n\n        return version_string"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef return_opml_response(self, context, **response_kwargs):\n        '''\n        Returns export data as an opml file.\n        '''\n        self.template_name = 'fiction_outlines/outline.opml'\n        response = super().render_to_response(context, content_type='text/xml', **response_kwargs)\n        response['Content-Disposition'] = 'attachment; filename=\"{}.opml\"'.format(slugify(self.object.title))\n        return response", "response": "Returns export data as an opml file."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nraises 404 if DEBUG is True.", "response": "def not_implemented(self, context, **response_kwargs):\n        '''\n        If DEBUG: raise NotImplemented Exception.\n        If not, raise 404.\n        :raises:`django.http.Http404` if production environment.\n        :raises:`NotImplementedError` if ``settings.DEBUG`` is True\n        '''\n        if settings.DEBUG:\n            raise NotImplementedError(_('This export type ({})is not yet supported.'.format(self.format)))\n        raise Http404"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef return_json_response(self, context, **request_kwargs):\n        '''\n        Returns detailed outline structure as :class:`django.http.JsonResponse`.\n        '''\n        outline_dict = model_to_dict(self.object)\n        logger.debug(str(outline_dict))\n        logger.debug(\"Attepting to switch tags from queryset to name...\")\n        logger.debug(str(self.object.tags.names()))\n        outline_dict.pop('tags')\n        outline_dict['tags'] = list(self.object.tags.names())\n        logger.debug(str(outline_dict))\n        if self.object.series:\n            outline_dict['series'] = model_to_dict(self.object.series)\n            outline_dict['series']['tags'] = list(self.object.series.tags.names())\n            logger.debug('Adding series... {}'.format(outline_dict['series']))\n        if self.object.characterinstance_set.count():\n            outline_dict['characters'] = []\n            for cint in self.object.characterinstance_set.all():\n                character_dict = model_to_dict(cint.character)\n                character_dict['outline_key'] = cint.pk\n                character_dict['tags'] = list(cint.character.tags.names())\n                character_dict['role_properties'] = {\n                    'main_character': cint.main_character,\n                    'pov_character': cint.pov_character,\n                    'protagonist': cint.protagonist,\n                    'antagonist': cint.antagonist,\n                    'villain': cint.villain,\n                    'obstacle': cint.obstacle,\n                }\n                outline_dict['characters'].append(character_dict)\n        if self.object.locationinstance_set.count():\n            outline_dict['locations'] = []\n            for lint in self.object.locationinstance_set.all():\n                location_dict = model_to_dict(lint.location)\n                location_dict['tags'] = list(lint.location.tags.names())\n                location_dict['outline_key'] = lint.pk\n                outline_dict['locations'].append(location_dict)\n        if self.object.arc_set.count():\n            outline_dict['arcs'] = []\n            for arc in self.object.arc_set.all():\n                arc_dict = model_to_dict(arc)\n                arc_dict['nodes'] = ArcElementNode.dump_bulk(parent=arc.arc_root_node)\n                outline_dict['arcs'].append(arc_dict)\n        outline_dict['story_tree'] = StoryElementNode.dump_bulk(parent=self.object.story_tree_root)\n        logger.debug(\"Sending response via JSON: {}\".format(outline_dict))\n        response = JsonResponse(outline_dict)\n        response['Content-Disposition'] = 'attachment; filename=\"{}.json\"'.format(slugify(self.object.title))\n        return response", "response": "Returns detailed outline structure as django. http. JsonResponse."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nrender the requested format to the response.", "response": "def render_to_response(self, context, **response_kwargs):\n        '''\n        Compares requested format to supported formats and routes the response.\n\n        :attribute switcher: A dictionary of format types and their respective response methods.\n        '''\n        switcher = {\n            'json': self.return_json_response,\n            'opml': self.return_opml_response,\n            'md': self.return_md_response,\n            'textbundle': self.not_implemented,\n            'xlsx': self.not_implemented,\n        }\n        if self.format not in switcher.keys():\n            return self.not_implemented(context, **response_kwargs)\n        return switcher[self.format](context, **response_kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef CER(prediction, true_labels):\n\n  errors = (prediction != true_labels).sum()\n  return float(errors)/len(prediction)", "response": "Returns the classification error rate for an N - class classification problem."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\niterates over all of the referreds, and then iterates over all of the referrers that refer to each one. Fairly item instantiation heavy.", "response": "def benchmark(store, n=10000):\n    \"\"\"\n    Iterates over all of the referreds, and then iterates over all of the\n    referrers that refer to each one.\n\n    Fairly item instantiation heavy.\n    \"\"\"\n    R = Referrer\n\n    for referred in store.query(Referred):\n        for _reference in store.query(R, R.reference == referred):\n            pass"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef header(self, title, level, key, width=80):\n        linestyle_code = {1: \"=\", 2: \"-\", 3: \"~\"}\n        if level not in linestyle_code:\n            raise Exception(\"'level' argument has to be 1, 2 or 3\")\n        else:\n            linestyle = linestyle_code[level]\n\n        if key:\n            return \"\\n\".join([\".. _%s\" % key, \"\", title, linestyle * width])\n        else:\n            return \"\\n\".join([title, \"=\" * width])", "response": "Example::\n\n            .. _header_2:\n\n            Header 2\n            -------------------------------------------------------------------\n\n        **\u4e2d\u6587\u6587\u6863**"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef code_block(self, code, language, indent=0):\n        if language not in [None, \"console\", \"python\", \"ruby\", \"c\"]:\n            raise\n        prefix = \"\\t\" * indent\n        code_prefix = \"\\t\" * (indent + 1)\n        lines = list()\n        lines.append(prefix + \".. code-block:: %s\" % language)\n        lines.append(prefix)\n        for line in code.split(\"\\n\"):\n            lines.append(code_prefix + line.strip())\n        return \"\\n\".join(lines)", "response": "Example :: code - block.. code - block:: python\n           "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef table(self, data, header=None):\n        if header:\n            x = PrettyTable(header)\n        else:\n            x = PrettyTable()\n\n        # construct ascii text table, split header and body\n        for row in data:\n            x.add_row(row)\n        s = x.get_string(border=True)\n        lines = s.split(\"\\n\")\n        header_ = lines[:2]\n        body = lines[2:]\n        n_body = len(body)\n        ruler = body[0]\n\n        # add more rulers between each rows\n        new_body = list()\n        counter = 0\n        for line in body:\n            counter += 1\n            new_body.append(line)\n            if (2 <= counter) and (counter < (n_body - 1)):\n                new_body.append(ruler)\n\n        if header:\n            return \"\\n\".join(header_ + new_body)\n        else:\n            return \"\\n\".join(new_body)", "response": "Return a string representation of the ISO - 8601 table."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nextract an archive somewhere on the filesystem.", "response": "def extract_archive(archive_path, destination_path):\n    \"\"\"Extracts an archive somewhere on the filesystem.\"\"\"\n    tar = tarfile.open(archive_path)\n    tar.errorlevel = 1\n    tar.extractall(destination_path)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef remove_file(file_path):\n    if path.exists(file_path):\n        try:\n            rmtree(file_path)\n        except Exception:\n            print('Unable to remove temporary workdir {}'.format(file_path))", "response": "Remove a file from the filesystem."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting a generator yielding consecutive sub - dataframes of the given size.", "response": "def sub_dfs_by_size(df, size):\n    \"\"\"Get a generator yielding consecutive sub-dataframes of the given size.\n\n    Arguments\n    ---------\n    df : pandas.DataFrame\n        The dataframe for which to get sub-dataframes.\n    size : int\n        The size of each sub-dataframe.\n\n    Returns\n    -------\n    generator\n        A generator yielding consecutive sub-dataframe of the given size.\n\n    Example\n    -------\n    >>> import pandas as pd; import pdutil;\n    >>> data = [[23, \"Jen\"], [42, \"Ray\"], [15, \"Fin\"]]\n    >>> df = pd.DataFrame(data, columns=['age', 'name'])\n    >>> for subdf in pdutil.iter.sub_dfs_by_size(df, 2): print(subdf)\n       age name\n    0   23  Jen\n    1   42  Ray\n       age name\n    2   15  Fin\n    \"\"\"\n    for i in range(0, len(df), size):\n        yield (df.iloc[i:i + size])"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef sub_dfs_by_num(df, num):\n    size = len(df) / float(num)\n    for i in range(num):\n        yield df.iloc[int(round(size * i)): int(round(size * (i + 1)))]", "response": "Get a generator yielding num consecutive sub - dataframes of the given dataframe."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef predict_encoding(file_path, n_lines=20):\n    '''Get file encoding of a text file'''\n    import chardet\n\n    # Open the file as binary data\n    with open(file_path, 'rb') as f:\n        # Join binary lines for specified number of lines\n        rawdata = b''.join([f.readline() for _ in range(n_lines)])\n\n    return chardet.detect(rawdata)['encoding']", "response": "Get file encoding of a text file"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the nummber of header rows in a Little Leonardo data file.", "response": "def get_n_header(f, header_char='\"'):\n    '''Get the nummber of header rows in a Little Leonardo data file\n\n    Args\n    ----\n    f : file stream\n        File handle for the file from which header rows will be read\n    header_char: str\n        Character array at beginning of each header line\n\n    Returns\n    -------\n    n_header: int\n        Number of header rows in Little Leonardo data file\n    '''\n\n    n_header = 0\n    reading_headers = True\n    while reading_headers:\n        line = f.readline()\n        if line.startswith(header_char):\n            n_header += 1\n        else:\n            reading_headers = False\n\n    return n_header"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_tag_params(tag_model):\n    '''Load param strs and n_header based on model of tag model'''\n\n    tag_model = tag_model.replace('-', '')\n    tags = dict()\n    tags['W190PD3GT'] = ['Acceleration-X', 'Acceleration-Y', 'Acceleration-Z',\n                         'Depth', 'Propeller', 'Temperature']\n\n    # Return tag parameters if found, else raise error\n    if tag_model in tags:\n        return tags[tag_model]\n    else:\n        raise KeyError('{} not found in tag dictionary'.format(tag_model))", "response": "Load param strs and n_header based on model of tag model"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef find_file(path_dir, search_str, file_ext):\n    '''Find path of file in directory containing the search string'''\n    import os\n\n    file_path = None\n\n    for file_name in os.listdir(path_dir):\n        if (search_str in file_name) and (file_name.endswith(file_ext)):\n            file_path = os.path.join(path_dir, file_name)\n            break\n\n    if file_path == None:\n        raise SystemError('No file found containing string: '\n                          '{}.'.format(search_str))\n\n    return file_path", "response": "Find path of file in directory containing the search string"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef nearest(items, pivot):\n    '''Find nearest value in array, including datetimes\n\n    Args\n    ----\n    items: iterable\n        List of values from which to find nearest value to `pivot`\n    pivot: int or float\n        Value to find nearest of in `items`\n\n    Returns\n    -------\n    nearest: int or float\n        Value in items nearest to `pivot`\n    '''\n    return min(items, key=lambda x: abs(x - pivot))", "response": "Find nearest value in array including datetimes\n    pivot"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nparse experiment parameters from the data directory name name_exp Returns a dictionary of experiment parameters and their corresponding dictionary of experiment parameters.", "response": "def parse_experiment_params(name_exp):\n    '''Parse experiment parameters from the data directory name\n\n    Args\n    ----\n    name_exp: str\n        Name of data directory with experiment parameters\n\n    Returns\n    -------\n    tag_params: dict of str\n        Dictionary of parsed experiment parameters\n    '''\n    if ('/' in name_exp) or ('\\\\' in name_exp):\n        raise ValueError(\"The path {} appears to be a path. Please pass \"\n                         \"only the data directory's name (i.e. the \"\n                         \"experiment name)\".format(name_exp))\n\n    tag_params = dict()\n    tag_params['experiment'] = name_exp\n    tag_params['tag_model'] = (name_exp.split('_')[1]).replace('-','')\n    tag_params['tag_id'] = name_exp.split('_')[2]\n    tag_params['animal'] = name_exp.split('_')[3]\n    tag_params['notes'] = name_exp.split('_')[4]\n\n    return tag_params"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _get_cassandra_config(self):\n        parts = urlsplit(os.environ.get('CASSANDRA_URI', DEFAULT_URI))\n        if parts.scheme != 'cassandra':\n            raise RuntimeError(\n                'CASSANDRA_URI scheme is not \"cassandra://\"!')\n\n        _, _, ip_addresses = socket.gethostbyname_ex(parts.hostname)\n        if not ip_addresses:\n            raise RuntimeError('Unable to find Cassandra in DNS!')\n\n        return {\n            'contact_points': ip_addresses,\n            'port': parts.port or DEFAULT_PORT,\n        }", "response": "Retrieve a dict containing Cassandra client config params."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef prepare(self, query, name=None):\n        key = name or query\n        stmt = CassandraConnection._prepared_statement_cache.get(key, None)\n        if stmt is not None:\n            return stmt\n\n        stmt = self._session.prepare(query)\n        CassandraConnection._prepared_statement_cache[key] = stmt\n        return stmt", "response": "Create and cache a prepared statement using the provided query."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef read_linear2(fn, header=True):\n    dtypes = {'#CHROM':str, 'POS':int, 'ID':str, 'REF':str, 'ALT1':str,\n              'TEST':str, 'OBS_CT':int, 'BETA':float, 'SE':float,\n              'T_STAT':float, 'P':float}\n    if header is None:\n        if fn[-3:] == '.gz':\n            from gzip import open\n            with open(fn, 'r') as f:\n                line = f.readline()\n        else:\n            with open(fn, 'r') as f:\n                line = f.readline()\n        header = line [0] == '#'\n    if header:\n        res = pd.read_table(fn, index_col=2, dtype=dtypes, low_memory=False)\n    else:\n        cols = ['#CHROM', 'POS', 'ID', 'REF', 'ALT1', 'TEST', 'OBS_CT',\n                'BETA', 'SE', 'T_STAT', 'P']\n        res = pd.read_table(fn, index_col=2, dtype=dtypes, names=cols,\n                            low_memory=False)\n    res.columns = [x.replace('#', '') for x in res.columns]\n    return(res)", "response": "Read a plink 2 output file of type glm. linear into a pandas DataFrame."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef parse_log2(fn):\n    with open(fn) as f:\n        lines = f.readlines()\n    if len(lines) == 0:\n        sys.stderr.write('Empty log file: {}.\\n'.format(fn))\n        return(None)\n    logtype = None\n    # TODO: Eventually, I will look for other arguments that indicate which\n    # plink analysis was run.\n    if len([x for x in lines if '--glm standard-beta' in x]):\n        logtype = 'linear'\n    elif len([x for x in lines if '--glm firth-fallback' in x]):\n        logtype = 'logistic'\n    if logtype is None:\n        return(None)\n        sys.stderr.write('Log file not supported: {}.\\n'.format(fn))\n    try:\n        lines = [x for x in lines if 'remaining after' in x]\n        i = 0\n        x = lines[i].split()\n        samples = int(x[0])\n        females = int(x[2][1:])\n        males = int(x[4])\n        i += 1\n        cases = np.nan\n        controls = np.nan\n        if logtype == 'logistic':\n            x = lines[i].split()\n            cases = int(x[0])\n            controls = int(x[3])\n            i += 1\n        variants = int(lines[i].split()[0])\n    except:\n        sys.stderr.write('Error parsing log file: {}.\\n'.format(fn))\n        return(None)\n    se = pd.Series([samples, females, males, cases, controls, variants],\n                     index=['samples', 'females', 'males', 'cases',\n                            'controls', 'variants']).dropna()\n    return(se)", "response": "This function parses a plink 2 log file and returns a pandas. DataFrame with the information that can be used to create a new tree structure."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns an X dataframe and a y series by the given column name.", "response": "def x_y_by_col_lbl(df, y_col_lbl):\n    \"\"\"Returns an X dataframe and a y series by the given column name.\n\n    Parameters\n    ----------\n    df : pandas.DataFrame\n        The dataframe to split.\n    y_col_lbl : object\n        The label of the y column.\n\n    Returns\n    -------\n    X, y : pandas.DataFrame, pandas.Series\n        A dataframe made up of all columns but the column with the given name\n        and a series made up of the same column, respectively.\n\n    Example\n    -------\n    >>> import pandas as pd\n    >>> data = [[23, 'Jo', 4], [19, 'Mi', 3]]\n    >>> df = pd.DataFrame(data, [1, 2] , ['Age', 'Name', 'D'])\n    >>> X, y = x_y_by_col_lbl(df, 'D')\n    >>> X\n       Age Name\n    1   23   Jo\n    2   19   Mi\n    >>> y\n    1    4\n    2    3\n    Name: D, dtype: int64\n    \"\"\"\n    x_cols = [col for col in df.columns if col != y_col_lbl]\n    return df[x_cols], df[y_col_lbl]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef x_y_by_col_lbl_inplace(df, y_col_lbl):\n    y = df[y_col_lbl]\n    df.drop(\n        labels=y_col_lbl,\n        axis=1,\n        inplace=True,\n    )\n    return df, y", "response": "Breaks the given dataframe into an X frame and a y series by the given object - level column name."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef or_by_masks(df, masks):\n    if len(masks) < 1:\n        return df\n    if len(masks) == 1:\n        return df[masks[0]]\n    overall_mask = masks[0] | masks[1]\n    for mask in masks[2:]:\n        overall_mask = overall_mask | mask\n    return df[overall_mask]", "response": "Returns a sub - dataframe by the logical or over the given masks."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ninvoking a rest api test", "response": "def invoke_rest_method(**kwargs):\n        \"\"\"\n        Invokes a rest api test\n        :param kwargs:\n            REQUIRED:\n\n            method = 'GET', 'POST', 'PUT', 'DELETE'\n\n            url = \"http://localhost/api/controller\"\n                or\n            baseurl = \"http://localhost/\"\n            endpoint = \"api/controller\"\n\n            OPTIONAL:\n\n            headers = {'header_name':'header_value', 'header2_name':'header2_value'}\n\n            json = {'key1':'value1', 'key2':'value2'}   #Will be sent as json encoded data\n                or\n            form = {'key1':'value1', 'key2':'value2'}   #Will be sent as form encoded data\n\n            api_key = \"ey123asdk93e378hsdfsfdf\"\n            silent = True,False  (to not log request/response. Default False)\n        :return:\n        \"\"\"\n        logger = kwargs.get('logger', get_default_logger())\n        args = {}\n        headers = kwargs.get('headers', {})\n        api_key = kwargs.get('api_key', None)\n        if api_key is not None:\n            headers['Authorization'] = api_key\n        if headers is not {}:\n            args['headers'] = headers\n        json = kwargs.get('json', None)\n        if json is not None:\n            args['json'] = json\n        form = kwargs.get('form', None)\n        if form is not None:\n            args['data'] = form\n        if json is not None and form is not None:\n            raise ValueError('Cannot specify both json and form parameters')\n        url = kwargs.get('url', None)\n        if url is None:\n            baseurl = kwargs.get('baseurl', None)\n            endpoint = kwargs.get('endpoint', None)\n            if baseurl is None or endpoint is None:\n                raise ValueError('Invalid test arguments. Must specify {url} or {baseurl, endpoint}')\n            url = urljoin(baseurl, endpoint)\n        method = kwargs.get('method', None)\n        if method is None:\n            raise ValueError('Invalid test arguments. Must specify {method}')\n        silent = kwargs.get('silent', False)\n        if not silent:\n            logger.debug(\"Sending {} to url: {}\".format(method, url))\n        req = requests.request(method, url, **args)\n        if not silent:\n            logger.debug(\"Received response code: {}\".format(req.status_code))\n        return req"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nplots one day of the time series.", "response": "def plot_one_day(x, y, xlabel=None, ylabel=None, title=None, ylim=None):\n    \"\"\"\u65f6\u95f4\u8de8\u5ea6\u4e3a\u4e00\u5929\u3002\n    \n    major tick = every hours\n    minor tick = every 15 minutes\n    \"\"\"\n    plt.close(\"all\")\n    \n    fig = plt.figure(figsize=(20, 10))\n    ax = fig.add_subplot(111)\n    ax.plot(x, y)\n    \n    hours = HourLocator(range(24))\n    hoursFmt = DateFormatter(\"%H:%M\")\n    minutes = MinuteLocator([30,])\n    minutesFmt = DateFormatter(\"%M\")\n    \n    ax.xaxis.set_major_locator(hours)\n    ax.xaxis.set_major_formatter(hoursFmt)\n    ax.xaxis.set_minor_locator(minutes)\n    ax.xaxis.set_minor_formatter(minutesFmt)\n    \n    ax.autoscale_view()\n    ax.grid()\n    plt.setp( ax.xaxis.get_majorticklabels(), rotation=90 )\n    plt.setp( ax.xaxis.get_minorticklabels(), rotation=90 )\n    \n    if xlabel:\n        plt.xlabel(xlabel)\n    else:\n        plt.xlabel(\"Time\")\n        \n    if ylabel:\n        plt.ylabel(ylabel)\n    else:\n        plt.ylabel(\"Value\")\n        \n    if title:\n        plt.title(title)\n    else:\n        plt.title(str(x[0].date()))\n    \n    if ylim:\n        plt.ylim(ylim)\n    else:\n        plt.ylim([min(y) - (max(y) - min(y) ) * 0.05, \n                  max(y) + (max(y) - min(y) ) * 0.05])\n    \n    return plt, ax"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nplotting one month of the data.", "response": "def plot_one_month(x, y, xlabel=None, ylabel=None, title=None, ylim=None):\n    \"\"\"\u65f6\u95f4\u8de8\u5ea6\u4e3a\u4e00\u6708\u3002\n    \n    major tick = every days\n    \"\"\"\n    plt.close(\"all\")\n    \n    fig = plt.figure(figsize=(20, 10))\n    ax = fig.add_subplot(111)\n    ax.plot(x, y)\n    \n\n    days = DayLocator(range(365))\n    daysFmt = DateFormatter(\"%Y-%m-%d\")\n    \n    ax.xaxis.set_major_locator(days)\n    ax.xaxis.set_major_formatter(daysFmt)\n    \n    ax.autoscale_view()\n    ax.grid()\n    plt.setp( ax.xaxis.get_majorticklabels(), rotation=90 )\n    \n    if xlabel:\n        plt.xlabel(xlabel)\n    else:\n        plt.xlabel(\"Time\")\n        \n    if ylabel:\n        plt.ylabel(ylabel)\n    else:\n        plt.ylabel(\"Value\")\n    \n    if title:\n        plt.title(title)\n    else:\n        plt.title(\"%s to %s\" % (str(x[0]), str(x[-1]) ) )\n\n    if ylim:\n        plt.ylim(ylim)\n    else:\n        plt.ylim([min(y) - (max(y) - min(y) ) * 0.05, \n                  max(y) + (max(y) - min(y) ) * 0.05])\n    \n    return plt, ax"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef plot_one_quarter(x, y, xlabel=None, ylabel=None, title=None, ylim=None):\n    plt.close(\"all\")\n    \n    fig = plt.figure(figsize=(20, 10))\n    ax = fig.add_subplot(111)\n    ax.plot(x, y)\n    \n    months = MonthLocator(range(12))\n    monthsFmt = DateFormatter(\"%Y-%m\")\n    days = DayLocator([7, 14, 21, 28])\n    daysFmt = DateFormatter(\"%dth\")\n    \n    ax.xaxis.set_major_locator(months)\n    ax.xaxis.set_major_formatter(monthsFmt)\n    ax.xaxis.set_minor_locator(days)\n    ax.xaxis.set_minor_formatter(daysFmt)\n    \n    ax.autoscale_view()\n    ax.grid()\n    plt.setp( ax.xaxis.get_majorticklabels(), rotation=90 )\n    plt.setp( ax.xaxis.get_minorticklabels(), rotation=90 )\n    \n    if xlabel:\n        plt.xlabel(xlabel)\n    else:\n        plt.xlabel(\"Time\")\n        \n    if ylabel:\n        plt.ylabel(ylabel)\n    else:\n        plt.ylabel(\"Value\")\n    \n    if title:\n        plt.title(title)\n    else:\n        plt.title(\"%s to %s\" % (str(x[0]), str(x[-1]) ) )\n\n    if ylim:\n        plt.ylim(ylim)\n    else:\n        plt.ylim([min(y) - (max(y) - min(y) ) * 0.05, \n                  max(y) + (max(y) - min(y) ) * 0.05])\n    \n    return plt, ax", "response": "Plots one quarter of the year."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncalculating the compactness of a single object.", "response": "def compactness_frompts(geoseries):\n    \"\"\"\n    Inverse of 4 * pi * Area / perimeter^2\n    \"\"\"\n    measure = (\n        4 * 3.1415 * (\n            (geoseries.unary_union).convex_hull.area)\n        ) / (\n            (geoseries.unary_union).convex_hull.length\n        )\n    return measure"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget nearest target for each origin", "response": "def _get_target_nearest(self):\n        \"\"\"Get nearest target for each origin\"\"\"\n        reps_query = \"\"\"\n             SELECT DISTINCT ON(g2.cartodb_id)\n                 g1.cartodb_id As origin_id,\n                 g2.the_geom,\n                 g2.cartodb_id + {maxorigin} as cartodb_id,\n                 g2.the_geom_webmercator\n             FROM {origin_table} As g1, {target_table} As g2\n             ORDER BY g2.cartodb_id, g1.the_geom <-> g2.the_geom\n        \"\"\".format(\n            maxorigin=self.origins.index.max(),\n            origin_table=self.origin_table,\n            target_table=self.target_table\n        )\n\n        nearest_reps = self.context.query(\n            reps_query,\n            decode_geom=True\n        )\n\n        nearest_reps = gpd.GeoDataFrame(nearest_reps, geometry='geometry')\n        init_labels = nearest_reps['origin_id'].values\n\n        # update with new information\n        self.targets['labels'] = init_labels\n        logging.info('nearest targets retrieved')\n\n        return nearest_reps"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _get_demand_graph(self):\n        # The number of clusters\n        K = self.origins.shape[0]\n\n        # Set the number of accounts in each cluster to be the same\n        # as for the nearest neighbor solution\n        demand = self.nearest_targets.groupby('origin_id')['geometry'].count().to_dict()\n\n        # Set up the graph so we can extract and initialize the node labels.\n        # For each iteration, we're going to sort all our data by their origin\n        # label assignments in order to properly index our nodes.\n        self.targets = self.targets.sort_values('labels').reset_index(drop=True)\n\n        # Add target nodes\n        g = nx.DiGraph()\n        g.add_nodes_from(self.targets['target_id'], demand=-1)\n\n        # Add origin nodes\n        for idx in demand:\n            g.add_node(int(idx), demand=demand[idx])\n\n        # Dictionary of labels (corresponding to the sales rep) for\n        # each med center node.\n        dict_M = {\n            i: (\n                self.targets[self.targets['target_id'] == i]['labels'].values\n                if i in self.targets.target_id.values\n                else np.array([demand[i]])\n            )\n            for i in g.nodes\n        }\n        logging.info('Graph and demand dictionary created')\n        return dict_M, demand", "response": "Create the demand graph for the cluster."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef calc(self, maxiter=100, fixedprec=1e9):\n        source_data_holder = []\n        N = self.targets.shape[0]\n        K = self.origins.shape[0]\n\n        # dict of labels for each target node\n        M, demand = self._get_demand_graph()\n\n        max_dist_trip = 400  # kilometers\n        cost_holder = []\n        itercnt = 0\n\n        while True:\n            itercnt += 1\n            logging.info(f'Iter count: {itercnt}')\n\n            # Setup the graph\n            g = nx.DiGraph()\n\n            self.targets = self.targets.sort_values('labels').reset_index(drop=True)\n            # Supply of 1 (i.e. demand = -1) means that it can only be connected to one node\n            g.add_nodes_from(self.targets['target_id'], demand=-1) # points\n\n            for idx in self.nearest_targets.origin_id:\n                g.add_node(int(idx), demand=demand[idx])\n\n            ### Create the cluster centers calculate a distance cost\n            cost_dist = dist_vect(\n                np.tile(self.targets['lng'].values, K),\n                np.tile(self.targets['lat'].values, K),\n                np.repeat(self.origins['lng'].values, N),\n                np.repeat(self.origins['lat'].values, N)\n            )[:, np.newaxis].T\n\n            scaler_dist = MinMaxScaler()\n            cost_dist_trans = scaler_dist.fit_transform(cost_dist.T).T\n\n            # Penalty for distances too large\n            cost_dist_trans[cost_dist > max_dist_trip] = 10\n\n            # Create the in-cluster sales and calculate the total volume of sales generated\n            # TODO: rename this to something more generic, like cluster_demanded\n            cluster_sales = self.targets.groupby('labels').sum()[self.demand_col][:, np.newaxis]\n            D = cluster_sales.shape[1]\n\n            cost_sales = abs(\n                np.array([\n                    np.linalg.norm(\n                            np.repeat(cluster_sales, N)[:, np.newaxis] \\\n                            - np.tile(cluster_sales.mean(), (K * N))[:,np.newaxis],\n                            axis=1\n                        )\n                    ])\n                )\n\n            scaler_sales = MinMaxScaler()\n            cost_sales = scaler_sales.fit_transform(cost_sales.T).T\n\n            # Total cost TO CHANGE??\n            cost_total = cost_dist_trans + cost_sales\n\n            cost_holder.append(sum(cost_total[0]))\n\n\n            # Create the edges of points to centers\n            data_to_center_edges = np.concatenate(\n                (\n                    np.tile(self.targets['target_id'], K).T[:, np.newaxis],\n                    np.array([np.tile(int(i+1), self.targets.shape[0]) for i in range(K)]).reshape(self.targets.shape[0] * K, 1),\n                    cost_total.T * 1e5\n                ),\n                axis=1\n            ).astype(np.uint64)\n\n            # Add these edges to the graph\n            g.add_weighted_edges_from(data_to_center_edges)\n\n            # Add the extra balance node\n            # To balance out the network, we create an extra node that is:\n            # -(K*(-1)+sum(demand_per_node))\n            a = 99999\n            g.add_node(a, demand=self.targets.shape[0] - np.sum(list(demand.values())))\n\n            C_to_a_edges = np.concatenate(\n                (\n                    np.array([int(i + 1) for i in range(K)]).T[:, np.newaxis],\n                    np.tile([[a, ]], K).T\n                ),\n                axis=1\n            )\n            g.add_edges_from(C_to_a_edges)\n\n            # Calculate the minimum flow cost\n            f = nx.min_cost_flow(g)\n\n            # Update the new labels\n            M_new = {}\n            p = {}\n\n            for i in list(g.nodes)[:-1]:\n                # Sorts all the items in the dictionary and picks the cluster\n                # with label = 1\n                p = sorted(f[i].items(), key=lambda x: x[1])[-1][0]\n                M_new[i] = p\n\n            # Update the new labels in the df\n            self.targets['labels'] = self.targets.apply(lambda x: M_new[x['target_id']], axis=1)\n\n            # Set the capacity for all edges\n            # TO DO: Figure how/whether we need to properly set a capacity for the edges.\n            C = 50\n            nx.set_edge_attributes(g, C, 'capacity')\n\n            # Test whether we can stop\n            # stop condition\n            if np.all(M_new == M):\n                print(\"All same\")\n                self.results = {\n                    'dict_graph': M,\n                    'min_cost_flow': f,\n                    'nxgraph': g,\n                    'model_labels': self.targets,\n                    'costs': cost_holder\n                }\n                return True\n\n            M = M_new\n\n            source_data_holder.append(self.targets['labels'].values)\n            if maxiter is not None and itercnt >= maxiter:\n                # Max iterations reached\n                self.results = {\n                    'dict_graph': M,\n                    'min_cost_flow': f,\n                    'nxgraph': g,\n                    'model_labels': self.targets,\n                    'costs': cost_holder\n                }\n                return True", "response": "Calculates the minimum cost flow for the cluster."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef results_to_table(self):\n        # Get Labels\n        baseline_labels = self.nearest_targets['origin_id'].values\n        mcf_labels = self.results['model_labels']['labels'].values\n\n        # Create the outcomes\n        outcome = pd.DataFrame({\n                'the_geom': [\n                    'SRID=4326;Point({lng} {lat})'.format(lng=v[0], lat=v[1])\n                    for v in zip(self.results['model_labels']['lng'].values, self.results['model_labels']['lat'].values)],\n                'target_lng': self.results['model_labels']['lng'].values,\n                'target_lng': self.results['model_labels']['lat'].values,\n                'origin_lng': self.origins.reindex(baseline_labels)['lng'].values,\n                'origin_lat': self.origins.reindex(baseline_labels)['lat'].values,\n                'target_id': self.results['model_labels'].target_id,\n                'sales': self.results['model_labels'][self.demand_col].values,\n                'labels': baseline_labels\n            }\n        )\n\n        outcomes2 = pd.DataFrame({\n                'the_geom': [\n                    'SRID=4326;Point({lng} {lat})'.format(lng=v[0], lat=v[1])\n                    for v in zip(\n                        self.results['model_labels']['lng'].values,\n                        self.results['model_labels']['lat'].values\n                    )\n                ],\n                'target_lng': self.results['model_labels']['lng'].values,\n                'target_lat': self.results['model_labels']['lat'].values,\n                'origin_lng': self.origins.reindex(mcf_labels)['lng'].values,\n                'origin_lat': self.origins.reindex(mcf_labels)['lat'].values,\n                'target_id': self.results['model_labels'].target_id,\n                'sales': self.results['model_labels'][self.demand_col].values,\n                'labels': mcf_labels\n            },\n            index=self.results['model_labels'].target_id\n        )\n        now = datetime.datetime.now()\n        out_table = 'mincostflow_{}'.format(now.strftime(\"%Y_%m_%d_%H_%M_%S\"))\n        logging.info('Writing output to {}'.format(out_table))\n        self.context.write(outcomes2.reset_index(drop=True), out_table)\n        logging.info('Table {} written to CARTO'.format(out_table))\n        return out_table", "response": "Process self. results and send to carto table"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a list of MetaOptions that can be used to configure the Meta class on the current end - user models.", "response": "def _get_model_meta_options(self) -> List[MetaOption]:\n        \"\"\"\"\n        Define fields allowed in the Meta class on end-user models, and the\n        behavior of each.\n\n        Custom ModelMetaOptions classes should override this method to customize\n        the options supported on class Meta of end-user models.\n        \"\"\"\n        # we can't use current_app to determine if we're under test, because it\n        # doesn't exist yet\n        testing_options = ([] if os.getenv('FLASK_ENV', False) != TEST\n                           else [_TestingMetaOption()])\n\n        # when options require another option, its dependent must be listed.\n        # options in this list are not order-dependent, except where noted.\n        # all ColumnMetaOptions subclasses require PolymorphicMetaOption\n        return testing_options + [\n            AbstractMetaOption(),  # required; must be first\n            LazyMappedMetaOption(),\n            RelationshipsMetaOption(),  # requires lazy_mapped\n            TableMetaOption(),\n            MaterializedViewForMetaOption(),\n\n            PolymorphicMetaOption(),  # must be first of all polymorphic options\n            PolymorphicOnColumnMetaOption(),\n            PolymorphicIdentityMetaOption(),\n            PolymorphicBaseTablenameMetaOption(),\n            PolymorphicJoinedPkColumnMetaOption(),  # requires _BaseTablename\n\n            # must be after PolymorphicJoinedPkColumnMetaOption\n            PrimaryKeyColumnMetaOption(),\n            CreatedAtColumnMetaOption(),\n            UpdatedAtColumnMetaOption(),\n        ]"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates a Gallery on the server. Returns a Gallery object with the editor_id and reader_id.", "response": "def CreateGallery():\n    \"\"\"Creates a Gallery on the server. Returns a Gallery object with the\n    editor_id and reader_id.\n\n    \"\"\"\n    url = 'http://min.us/api/CreateGallery'\n\n    response = _dopost(url)\n\n    _editor_id = response[\"editor_id\"]\n    _reader_id = response[\"reader_id\"]\n\n    return Gallery(_reader_id, editor_id=_editor_id)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nupload a file to the item store.", "response": "def UploadItem(filename, gallery, desiredName=None, progress_cb=None):\n    \"\"\"filename is the full file location and name of the file\n    WARNING: If your desiredName doesn't have a proper file extension (SHOULD\n    be the same as the filename) it'll still upload, but you won't be able to\n    download it or view it online. You can edit the name later to add the\n    extension, but be careful, because it seems like you can't change the\n    extension after that.\n\n    If progress_cb is not None, it should be a callable which takes two\n    arguments: the total number of bytes to upload and the number of bytes\n    which have been uploaded. The callable is called periodically to show the\n    progress of the upload.\n\n    \"\"\"\n\n    # Must have the ? because urlencode doesn't add that on itself\n    url = 'http://min.us/api/UploadItem?'\n\n    if desiredName:\n        name = desiredName\n    else:\n        name = filename\n\n    params = {\"editor_id\":gallery.editor_id, \"filename\":name}\n\n    with open(filename, 'rb') as f:\n        itemData = f.read()\n\n    response = _dopost(url, params=params,\n            payload=itemData, progress_cb=progress_cb)\n\n    _id = response[\"id\"]\n    _height = response[\"height\"]\n    _width = response[\"width\"]\n    _filesize = response[\"filesize\"]\n\n    return Item(_id, height=_height, width=_width, filesize=_filesize)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _dopost(url, params=None, payload=None, progress_cb=None):\n    if params:\n        encoded = urlencode(params)\n    else:\n        encoded = ''\n\n    url = str(url + encoded)\n\n    if payload is None:\n        payload = ''\n\n    # Try to make use of PyCURL if we have it\n    try:\n        c = pycurl.Curl()\n    except NameError:\n        c = None\n\n    if c is not None:\n        response = [ ]\n        def append_to_response(buf):\n            response.append(buf.decode())\n\n        def progress(download_t, download_d, upload_t, upload_d):\n            if progress_cb is not None:\n                progress_cb(upload_d, upload_t)\n\n        c = pycurl.Curl()\n        c.setopt(pycurl.URL, url)\n        c.setopt(pycurl.POST, 1)\n        c.setopt(pycurl.POSTFIELDS, payload)\n        c.setopt(pycurl.INFILESIZE, len(payload))\n        c.setopt(pycurl.WRITEFUNCTION, append_to_response)\n        c.setopt(pycurl.NOPROGRESS, 0)\n        c.setopt(pycurl.PROGRESSFUNCTION, progress)\n        c.perform()\n        c.close()\n\n        return json.loads(''.join(response))\n    else:\n        if progress_cb is not None:\n            progress_cb(0, len(payload))\n        response = [x.decode() for x in urlopen(url, payload).readlines()]\n        if progress_cb is not None:\n            progress_cb(len(payload), len(payload))\n        return json.loads(''.join(response))", "response": "Do a HTTP POST to the specified url and return the result."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef GetItems(self):\n        url = 'http://min.us/api/GetItems/' + 'm' + self.reader_id\n        response = _doget(url)\n\n        self.name = response[\"GALLERY_TITLE\"]\n\n        # To get the item id, we have to take the file name from the URL\n        # We also need to get rid of any file extension if there is any\n        self.items = [a[16:].split('.')[0] for a in response[\"ITEMS_GALLERY\"]]\n\n        return (self.name, self.items)", "response": "Updates self. name and self. items and returns ( self. name self. items"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef SaveGallery(self, name=None, items=None):\n\n        url = 'http://min.us/api/SaveGallery'\n\n        if not name:\n            if not self.name:\n                name = self.GetItems()[0]\n            if self.name:\n                name = self.name\n\n        if not items:\n            if not self.items:\n                items = self.GetItems()[1]\n            elif self.items:\n                items = self.items\n\n        params = {\"name\": name, \"id\":self.editor_id, \"items\":items}\n\n        try:\n            response = _dopost(url, params)\n        except:\n            pass\n        else:\n            self.name = name\n            self.items = items", "response": "Use this to update the gallery name or change sort order."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef save_user_cmd(email, name=None, groups=None, locale='en_US', timezone='US/Eastern'):\n    if name is None:\n        name = email\n    if groups is None:\n        groups = []\n    return SaveUserCmd(name=name, email=email, groups=groups, locale=locale, timezone=timezone)", "response": "Returns a command that validate date and save a user"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef logged_user(request):\n    dct = cookie_facade.retrive_cookie_data(request, USER_COOKIE_NAME).execute().result\n    if dct is None:\n        return Command()\n    return NodeSearch(dct['id'])", "response": "Returns a command that retrieves the current logged user based on secure cookie."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nlogging user in using Passwordless service", "response": "def login_checking_email(pending_id, ticket, response, detail_url='https://pswdless.appspot.com/rest/detail'):\n    \"\"\"\n    Log user in using Passwordless service\n    :param pending_id: PendingExternalToMainUser's id\n    :param ticket: ticket returned from Passwordless\n    :param response: Response object from webapp2\n    :param detail_url: url to check ticket and user data\n    :return: a Command that log user in when executed\n    \"\"\"\n    return LoginCheckingEmail(pending_id, ticket, response, USER_COOKIE_NAME, detail_url)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef find_users_by_email_starting_with(email_prefix=None, cursor=None, page_size=30):\n    email_prefix = email_prefix or ''\n\n    return ModelSearchCommand(MainUser.query_email_starts_with(email_prefix),\n                              page_size, cursor, cache_begin=None)", "response": "Returns a command that retrieves users by email starting with email_prefix."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a command that retrieves users by email and group.", "response": "def find_users_by_email_and_group(email_prefix=None, group=None, cursor=None, page_size=30):\n    \"\"\"\n    Returns a command that retrieves users by its email_prefix, ordered by email and by Group.\n    If Group is None, only users without any group are going to be searched\n    It returns a max number of users defined by page_size arg. Next result can be retrieved using cursor, in\n    a next call. It is provided in cursor attribute from command.\n    \"\"\"\n    email_prefix = email_prefix or ''\n\n    return ModelSearchCommand(MainUser.query_email_and_group(email_prefix, group),\n                              page_size, cursor, cache_begin=None)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a JSON -ified error object.", "response": "def json_error(code, message):\n    \"\"\"Returns a JSON-ified error object\"\"\"\n    # Message can be an unserializable object.\n    message = repr(message)\n    return jsonify(dict(request=request.path, message=message)), code"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a fixed - length straight line with some text at the center.", "response": "def straight_line(title, length=100, linestyle=\"=\", pad=0):\n        \"\"\"Return a fixed-length straight line with some text at the center.\n        \n        Usage Example::\n            \n            >>> StringTemplate.straight_line(\"Hello world!\", 20, \"-\", 1)\n            --- Hello world! ---\n        \"\"\"\n        text = \"{:%s^%s}\" % (linestyle, length)\n        return text.format(\"%s%s%s\" % (\" \"*pad, title, \" \"*pad))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nprinting a formatted straight line.", "response": "def straight_line_show(title, length=100, linestyle=\"=\", pad=0):\n        \"\"\"Print a formatted straight line.\n        \"\"\"\n        print(StrTemplate.straight_line(\n            title=title, length=length, linestyle=linestyle, pad=pad))"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nprint a formatted indented text.", "response": "def indented_show(text, howmany=1):\n        \"\"\"Print a formatted indented text.\n        \"\"\"\n        print(StrTemplate.pad_indent(text=text, howmany=howmany))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a ascii box with your text center - aligned.", "response": "def box(text, width=100, height=3, corner=\"+\", horizontal=\"-\", vertical=\"|\"):\n        \"\"\"Return a ascii box, with your text center-aligned.\n        \n        Usage Example::\n        \n            >>> StringTemplate.box(\"Hello world!\", 20, 5)\n            +------------------+\n            |                  |\n            |   Hello world!   |\n            |                  |\n            +------------------+\n        \"\"\"\n        if width <= len(text) - 4:\n            print(\"width is not large enough! apply auto-adjust...\")\n            width = len(text) + 4\n        if height <= 2:\n            print(\"height is too small! apply auto-adjust...\")\n            height = 3\n        if (height % 2) == 0:\n            print(\"height has to be odd! apply auto-adjust...\")\n            height += 1\n            \n        head = tail = corner + horizontal * (width - 2) + corner\n    \n        pad = \"%s%s%s\" % (vertical, \" \" * (width - 2), vertical)\n        pad_number = (height - 3) // 2\n        \n        pattern = \"{: ^%s}\" % (width - 2, )\n        body = vertical + pattern.format(text) + vertical\n        return \"\\n\".join([head,] + [pad,] * pad_number + [body,] + [pad,] * pad_number + [tail,])"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nprinting a formatted ascii text box.", "response": "def box_show(text, width=100, height=3, corner=\"+\", horizontal=\"-\", vertical=\"|\"):\n        \"\"\"Print a formatted ascii text box.\n        \"\"\"\n        print(StrTemplate.box(text=text, width=width, height=height,\n            corner=corner, horizontal=horizontal, vertical=vertical))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate a new instance of ArtifactoryClient for use with Maven repositories.", "response": "def new_maven_client(base_url, repo, is_snapshot=False, username=None, password=None):\n    \"\"\"Get a new implementation of :class:`ArtifactoryClient` for use with Maven repository\n    layouts, optionally using the provided authentication.\n\n    Most users will simply call this method to get a new Maven client instance. For example:\n\n    >>> client = new_maven_client('https://www.example.com/artifactory', 'libs-release')\n    >>> latest = client.get_latest_version('com.example.users.service', 'war')\n    '1.6.0'\n\n    :param str base_url: URL to root of the Artifactory installation. Example,\n        \"https://artifactory.example.com/artifactory\".\n    :param str repo: Which repository should searches be done against. Example, \"libs-release-local\"\n        or \"libs-snapshot-local\".\n    :param bool is_snapshot: Does the repository to perform searches against contain SNAPSHOT\n        (a.k.a. integration) versions? Default is ``False``\n    :param str username: Optional username for authentication when making API calls and\n        downloading artifacts.\n    :param str password: Optional password for authentication when making API calls and\n        downloading artifacts.\n    :return: New Artifactory client for use with Maven repositories\n    :rtype: GenericArtifactoryClient\n    \"\"\"\n\n    session = requests.Session()\n    if username is not None and password is not None:\n        session.auth = (username, password)\n\n    config = GenericArtifactoryClientConfig()\n    config.is_integration = is_snapshot\n    config.http_dao = stac.http.VersionApiDao(session, base_url, repo)\n    config.url_generator = MavenArtifactUrlGenerator(base_url, repo)\n\n    return GenericArtifactoryClient(config)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_version_url(self, full_name, packaging, version, descriptor=None):\n        group, artifact = _parse_full_name(full_name)\n        return self._urls.get_url(group, artifact, packaging, version, descriptor)", "response": "Get the URL to a specific version of the given project."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nincrement dict d at key by amount val", "response": "def increment(d, key, val=1):\n    \"\"\"\n    increment dict d at key by amount val\n    no need to return since d is mutable\n    \"\"\"\n    if key in d:\n        d[key] += val\n    else:\n        d[key] = val"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef floor_nearest(x, dx=1):\n    precision = get_sig_digits(dx)\n    return round(math.floor(float(x) / dx) * dx, precision)", "response": "floor a number to within a given rounding accuracy"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef multipart_content(*files):\n    outer = MIMEMultipart()\n    for fname in files:\n        mtype = get_type(fname)\n        maintype, subtype = mtype.split('/', 1)\n        with open(fname) as f:\n            msg = MIMEText(f.read(), _subtype=subtype)\n        msg.add_header('Content-Disposition', 'attachment', \n                       filename=os.path.basename(fname))\n        outer.attach(msg)\n    return outer.as_string()", "response": "Returns a mutlipart content."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef discard(self, key):\n        if key in self.map:        \n            key, prev, next_item = self.map.pop(key)\n            prev[2] = next_item\n            next_item[1] = prev", "response": "Remove a item from its member if it is a member."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef union(*argv):\n        res = OrderedSet()\n        for ods in argv:\n            res = res | ods\n        return res", "response": "Returns a new set with the union of the given items."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the intersection of multiple sets.", "response": "def intersection(*argv):\n        \"\"\"Returns the intersection of multiple sets.\n        Items are ordered by set1, set2, ...\n\n        **\u4e2d\u6587\u6587\u6863**\n        \n        \u6c42\u591a\u4e2a\u6709\u5e8f\u96c6\u5408\u7684\u4ea4\u96c6, \u6309\u7167\u7b2c\u4e00\u4e2a\u96c6\u5408, \u7b2c\u4e8c\u4e2a, ..., \u8fd9\u6837\u7684\u987a\u5e8f\u3002\n        \"\"\"\n        res = OrderedSet(argv[0])\n        for ods in argv:\n            res = ods & res\n        return res"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the access token if it exists otherwise opens a browser session and returns it", "response": "def get_fb_token():\n    \"\"\"Returns access token, optionally launches browser session \n    to get the token via a facebook login.\n    esterhui: got this code from the interweb, but can't find the reference now.\n    \"\"\"\n    global ACCESS_TOKEN\n    if not os.path.exists(TOKEN_FILE):\n        print \"Logging you in to facebook...\"\n        webbrowser.open(get_url('/oauth/authorize',\n                                {'client_id':APP_ID,\n                                 'redirect_uri':REDIRECT_URI,\n                                 'scope':'manage_pages,publish_stream,photo_upload,user_photos,video_upload'}))\n \n        httpd = BaseHTTPServer.HTTPServer(('127.0.0.1', 8080), RequestHandler)\n        while ACCESS_TOKEN is None:\n            httpd.handle_request()\n    else:\n        ACCESS_TOKEN = open(TOKEN_FILE).read()\n\n    return ACCESS_TOKEN"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef do(self):\n        \"run it, you can get a good stitching of the complete URL.\"\n        return urlunparse((self.scheme, self.netloc, self.path, self.params, self.query, self.fragment))", "response": "run it you can get a good stitching of the complete URL."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nrunning it you can get a tuple for ( scheme netloc path params query fragment", "response": "def do(self):\n        \"run it, you can get a tuple for (scheme, netloc, path, params, query, fragment)\"\n        _PR = urlparse(self.url)\n        return _PR.scheme, _PR.netloc, _PR.path, _PR.params, _PR.query, _PR.fragment"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nruns it get a new url", "response": "def do(self):\n        \"run it, get a new url\"\n        scheme, netloc, path, params, query, fragment = Split(self.url).do()\n\n        if isinstance(self.query, dict):\n            query = query + \"&\" + urllib.urlencode(self.query) if query else urllib.urlencode(self.query)\n\n        path = urljoin(path, self.path).replace('\\\\', '/') if self.path else path\n        \n        return Splice(scheme=scheme, netloc=netloc, path=path, params=params, query=query, fragment=fragment).geturl"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef lookups(self, request, model_admin):\n\n        if model_admin.tracked_stamps in {'create', 'update', 'both'}:\n            prefix = model_admin.tracked_stamps + ':'\n        else:\n            raise ValueError(\"Invalid tracked_stamps type. Expected: 'create', 'update', or 'both'\")\n        original = model_admin.get_period_options()\n        return type(original)((prefix + k, v) for (k, v) in original)", "response": "This method is used to perform the lookup in the same way the reporting tool allows to generate a report. It is used to generate a report."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef queryset(self, request, queryset):\n\n        value = self.value()\n        try:\n            if not value:\n                return queryset\n            prefix, period = value.split(':')\n            if prefix == 'create':\n                return queryset.created_on(period)\n            elif prefix == 'update':\n                return queryset.updated_on(period)\n            elif prefix == 'both':\n                return queryset.created_or_updated_on(period)\n            else:\n                return queryset\n        except ValueError:\n            return queryset", "response": "Returns a filtered queryset of the items in the current object."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding the period filter to the filters list.", "response": "def get_list_filter(self, request):\n        \"\"\"\n        Adds the period filter to the filters list.\n        :param request: Current request.\n        :return: Iterable of filters.\n        \"\"\"\n\n        original = super(TrackedLiveAdmin, self).get_list_filter(request)\n        return original + type(original)([PeriodFilter])"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconvert the report_generators list to a dictionary and caches the result.", "response": "def get_reporters(self):\n        \"\"\"\n        Converts the report_generators list to a dictionary, and caches the result.\n        :return: A dictionary with such references.\n        \"\"\"\n\n        if not hasattr(self, '_report_generators_by_key'):\n            self._report_generators_by_key = {r.key: r for r in self.report_generators}\n        return self._report_generators_by_key"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_period_options(self):\n\n        if self.report_period_type == 'ago':\n            return PERIOD_AGO_LOOKUPS\n        elif self.report_period_type == 'current':\n            return PERIOD_CURRENT_LOOKUPS\n        elif self.report_period_type == 'both':\n            return PERIOD_AGO_LOOKUPS + PERIOD_CURRENT_LOOKUPS\n        else:\n            raise ValueError(\"Invalid report period type. Expected: 'ago', 'current', or 'both'\")", "response": "Returns a list of period options given the current setting in report_period_type."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_urls(self):\n\n        info = self.model._meta.app_label, self.model._meta.model_name\n        return [\n            url(r'^report/(?P<key>\\w+)/(?P<period>\\w)$',\n                self.admin_site.admin_view(self.report_view),\n                name='%s_%s_tracking_report' % info)\n        ] + super(TrackedLiveAdmin, self).get_urls()", "response": "Returns additional urls to add to a result of get_urls in a descendant ModelAdmin\n       "}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nupdate the changelist view to include settings from this admin.", "response": "def changelist_view(self, request, extra_context=None):\n        \"\"\"\n        Updates the changelist view to include settings from this admin.\n        \"\"\"\n\n        return super(TrackedLiveAdmin, self).changelist_view(\n            request, dict(extra_context or {},\n                          url_name='admin:%s_%s_tracking_report' % (self.model._meta.app_label, self.model._meta.model_name),\n                          period_options=self.get_period_options(),\n                          report_options=self.get_report_options())\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef render_report_error(self, request, error, status):\n\n        opts = self.model._meta\n        app_label = opts.app_label\n        request.current_app = self.admin_site.name\n        context = dict(\n            self.admin_site.each_context(request),\n            module_name=force_text(opts.verbose_name_plural),\n            title=(_('Tracking report error for %s') % force_text(opts.verbose_name)),\n            opts=opts, app_label=app_label, error=error\n        )\n\n        return TemplateResponse(request, self.report_error_template or [\n            \"admin/{}/{}/tracking_report_error.html\".format(app_label, opts.model_name),\n            \"admin/{}/tracking_report_error.html\".format(app_label),\n            \"admin/tracking_report_error.html\"\n        ], context, status=status)", "response": "Renders the report errors template."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_period_queryset(self, request, period):\n\n        qs = self.get_queryset(request)\n        if not period:\n            return qs\n        if self.tracked_stamps == 'create':\n            return getattr(qs, 'created_on')(period)\n        elif self.tracked_stamps == 'update':\n            return getattr(qs, 'updated_on')(period)\n        elif self.tracked_stamps == 'both':\n            return getattr(qs, 'created_or_updated_on')(period)\n        else:\n            raise ValueError(\"Invalid tracked_stamps type. Expected: 'create', 'update', or 'both'\")", "response": "Returns the queryset for a specific period."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef report_view(self, request, key, period):\n\n        if not self.has_change_permission(request, None):\n            raise PermissionDenied\n\n        reporters = self.get_reporters()\n        try:\n            reporter = reporters[key]\n        except KeyError:\n            return self.render_report_error(request, _('Report not found'), 404)\n\n        allowed_periods = [k for (k, v) in self.get_period_options()]\n        if period == 'A':\n            period = ''\n\n        if period and period not in allowed_periods:\n            return self.render_report_error(request, _('Invalid report type'), 400)\n\n        try:\n            return reporter.process(request, self.get_period_queryset(request, period), period)\n        except:\n            logger.exception('Tracking Reports could not generate the report due to an internal error')\n            return self.render_report_error(request, _('An unexpected error has occurred'), 500)", "response": "Processes the action for the report."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef find_record(self, model_class, record_id, reload=False):\n        cached_model = self.peek_record(model_class, record_id)\n        if cached_model is not None and reload is False:\n            return cached_model\n        else:\n            return self._get_record(model_class, record_id)", "response": "Return an instance of model_class from the API or the local cache."}
