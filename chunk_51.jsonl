{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef house_exists(self, complex: str, house: str) -> bool:\n        try:\n            self.check_house(complex, house)\n        except exceptions.RumetrHouseNotFound:\n            return False\n\n        return True", "response": "Check if a given house exists in our database."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef appt_exists(self, complex: str, house: str, appt: str) -> bool:\n        try:\n            self.check_appt(complex, house, appt)\n        except exceptions.RumetrApptNotFound:\n            return False\n\n        return True", "response": "Check if an appt exists in our database."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndo a POST request to the specified URL and return the JSON response.", "response": "def post(self, url: str, data: str, expected_status_code=201):\n        \"\"\"\n        Do a POST request\n        \"\"\"\n        r = requests.post(self._format_url(url), json=data, headers=self.headers, timeout=TIMEOUT)\n        self._check_response(r, expected_status_code)\n\n        return r.json()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get(self, url):\n        r = requests.get(self._format_url(url), headers=self.headers, timeout=TIMEOUT)\n        self._check_response(r, 200)\n\n        return r.json()", "response": "Do a GET request to get the set of available cache entries"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef check_developer(self) -> bool:\n        if self._last_checked_developer == self.developer:\n            return True\n\n        try:\n            self.get('developers/%s/' % self.developer)\n        except exceptions.Rumetr404Exception:\n            raise exceptions.RumetrDeveloperNotFound('Bad developer id \u2014\u00a0rumetr server does not know it. Is it correct?')\n\n        self._last_checked_developer = self.developer\n        return True", "response": "Check if a given developer id exists in the rumetr database."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef check_complex(self, complex: str) -> bool:\n        self.check_developer()\n        if complex in self._checked_complexes:\n            return True\n\n        try:\n            self.get('developers/{developer}/complexes/{complex}/'.format(\n                developer=self.developer,\n                complex=complex,\n            ))\n        except exceptions.Rumetr404Exception:\n            raise exceptions.RumetrComplexNotFound('Unknown complex \u2014\u00a0maybe you should create one?')\n\n        self._checked_complexes.add(complex)\n        return True", "response": "Check if a given complex exists in the rumetr database."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef check_house(self, complex: str, house: str) -> bool:\n        self.check_complex(complex)\n        if '%s__%s' % (complex, house) in self._checked_houses:\n            return True\n\n        try:\n            self.get('developers/{developer}/complexes/{complex}/houses/{house}/'.format(\n                developer=self.developer,\n                complex=complex,\n                house=house,\n            ))\n        except exceptions.Rumetr404Exception:\n            raise exceptions.RumetrHouseNotFound('Unknown house (complex is known) \u2014\u00a0may be you should create one?')\n\n        self._checked_houses.add('%s__%s' % (complex, house))\n        return True", "response": "Check if given house exists in the rumetr database."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef check_appt(self, complex: str, house: str, appt: str) -> bool:\n        self.check_house(complex, house)\n        if '%s__%s__%s' % (complex, house, appt) in self._checked_appts:\n            return True\n\n        try:\n            self.get('developers/{developer}/complexes/{complex}/houses/{house}/appts/{appt}'.format(\n                developer=self.developer,\n                complex=complex,\n                house=house,\n                appt=appt,\n            ))\n        except exceptions.Rumetr404Exception:\n            raise exceptions.RumetrApptNotFound('Unknown appt (house is known) \u2014\u00a0may be you should create one?')\n\n        self._checked_appts.add('%s__%s__%s' % (complex, house, appt))\n        return True", "response": "Check if given appartment exists in the rumetr database."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds a new complex to the rumetr db", "response": "def add_complex(self, **kwargs):\n        \"\"\"\n        Add a new complex to the rumetr db\n        \"\"\"\n        self.check_developer()\n        self.post('developers/%s/complexes/' % self.developer, data=kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nadd a new house to the rumetr db", "response": "def add_house(self, complex: str, **kwargs):\n        \"\"\"\n        Add a new house to the rumetr db\n        \"\"\"\n        self.check_complex(complex)\n        self.post('developers/{developer}/complexes/{complex}/houses/'.format(developer=self.developer, complex=complex), data=kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadd a new appartment to the rumetr db", "response": "def add_appt(self, complex: str, house: str, price: str, square: str, **kwargs):\n        \"\"\"\n        Add a new appartment to the rumetr db\n        \"\"\"\n        self.check_house(complex, house)\n\n        kwargs['price'] = self._format_decimal(price)\n        kwargs['square'] = self._format_decimal(square)\n\n        self.post('developers/{developer}/complexes/{complex}/houses/{house}/appts/'.format(\n            developer=self.developer,\n            complex=complex,\n            house=house,\n        ), data=kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nupdate the house with the given id.", "response": "def update_house(self, complex: str, id: str, **kwargs):\n        \"\"\"\n        Update the existing house\n        \"\"\"\n        self.check_house(complex, id)\n        self.put('developers/{developer}/complexes/{complex}/houses/{id}'.format(\n            developer=self.developer,\n            complex=complex,\n            id=id,\n        ), data=kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef update_appt(self, complex: str, house: str, price: str, square: str, id: str, **kwargs):\n        self.check_house(complex, house)\n\n        kwargs['price'] = self._format_decimal(price)\n        kwargs['square'] = self._format_decimal(square)\n\n        self.put('developers/{developer}/complexes/{complex}/houses/{house}/appts/{id}'.format(\n            developer=self.developer,\n            complex=complex,\n            house=house,\n            id=id,\n            price=self._format_decimal(price),\n        ), data=kwargs)", "response": "Update an appartment s information"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ninjecting arguments from context into a callable.", "response": "def inject(self, func, **kwargs):\n        \"\"\"Inject arguments from context into a callable.\n\n        :param func: The callable to inject arguments into.\n        :param \\*\\*kwargs: Specify values to override context items.\n        \"\"\"\n        args, varargs, keywords, defaults = self._get_argspec(func)\n        if defaults:\n            required_args = args[:-len(defaults)]\n            optional_args = args[len(required_args):]\n        else:\n            required_args = args\n            optional_args = []\n        values = [\n            kwargs[arg] if arg in kwargs else self[arg]\n            for arg in required_args\n        ]\n        if defaults:\n            values.extend(\n                kwargs[arg] if arg in kwargs else self.get(arg, default)\n                for arg, default in zip(optional_args, defaults)\n            )\n        return func(*values)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndate has no ISO zone information", "response": "def parse_date(val, zone='default'):\n    val = parse_isodate(val, None)\n    ''' date has no ISO zone information '''\n    if not val.tzinfo:\n        val = timezone[zone].localize(val)\n    return val"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nimport the sanitizer python module.", "response": "def import_sanitizer(sanitizer):\n    \"\"\"\n    Imports the sanitizer python module.\n\n    :param sanitizer: Sanitizer python module file.\n    :type sanitizer: unicode\n    :return: Module.\n    :rtype: object\n    \"\"\"\n\n    directory = os.path.dirname(sanitizer)\n    not directory in sys.path and sys.path.append(directory)\n\n    namespace = __import__(foundations.strings.get_splitext_basename(sanitizer))\n    if hasattr(namespace, \"bleach\"):\n        return namespace\n    else:\n        raise foundations.exceptions.ProgrammingError(\n            \"{0} | '{1}' is not a valid sanitizer module file!\".format(sanitizer))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef build_api(packages, input, output, sanitizer, excluded_modules=None):\n\n    LOGGER.info(\"{0} | Building Sphinx documentation API!\".format(build_api.__name__))\n\n    sanitizer = import_sanitizer(sanitizer)\n\n    if os.path.exists(input):\n        shutil.rmtree(input)\n        os.makedirs(input)\n\n    excluded_modules = [] if excluded_modules is None else excluded_modules\n\n    packages_modules = {\"apiModules\": [],\n                        \"testsModules\": []}\n    for package in packages:\n        package = __import__(package)\n        path = foundations.common.get_first_item(package.__path__)\n        package_directory = os.path.dirname(path)\n\n        for file in sorted(\n                list(foundations.walkers.files_walker(package_directory, filters_in=(\"{0}.*\\.ui$\".format(path),)))):\n            LOGGER.info(\"{0} | Ui file: '{1}'\".format(build_api.__name__, file))\n            target_directory = os.path.dirname(file).replace(package_directory, \"\")\n            directory = \"{0}{1}\".format(input, target_directory)\n            if not foundations.common.path_exists(directory):\n                os.makedirs(directory)\n            source = os.path.join(directory, os.path.basename(file))\n            shutil.copyfile(file, source)\n\n        modules = []\n        for file in sorted(\n                list(foundations.walkers.files_walker(package_directory, filters_in=(\"{0}.*\\.py$\".format(path),),\n                                                      filters_out=excluded_modules))):\n            LOGGER.info(\"{0} | Python file: '{1}'\".format(build_api.__name__, file))\n            module = \"{0}.{1}\".format((\".\".join(os.path.dirname(file).replace(package_directory, \"\").split(\"/\"))),\n                                      foundations.strings.get_splitext_basename(file)).strip(\".\")\n            LOGGER.info(\"{0} | Module name: '{1}'\".format(build_api.__name__, module))\n            directory = os.path.dirname(os.path.join(input, module.replace(\".\", \"/\")))\n            if not foundations.common.path_exists(directory):\n                os.makedirs(directory)\n            source = os.path.join(directory, os.path.basename(file))\n            shutil.copyfile(file, source)\n\n            sanitizer.bleach(source)\n\n            if \"__init__.py\" in file:\n                continue\n\n            rst_file_path = \"{0}{1}\".format(module, FILES_EXTENSION)\n            LOGGER.info(\"{0} | Building API file: '{1}'\".format(build_api.__name__, rst_file_path))\n            rst_file = File(os.path.join(output, rst_file_path))\n            header = [\"_`{0}`\\n\".format(module),\n                      \"==={0}\\n\".format(\"=\" * len(module)),\n                      \"\\n\",\n                      \".. automodule:: {0}\\n\".format(module),\n                      \"\\n\"]\n            rst_file.content.extend(header)\n\n            functions = OrderedDict()\n            classes = OrderedDict()\n            module_attributes = OrderedDict()\n            for member, object in module_browser._readmodule(module, [source, ]).iteritems():\n                if object.__class__ == module_browser.Function:\n                    if not member.startswith(\"_\"):\n                        functions[member] = [\".. autofunction:: {0}\\n\".format(member)]\n                elif object.__class__ == module_browser.Class:\n                    classes[member] = [\".. autoclass:: {0}\\n\".format(member),\n                                       \"\t:show-inheritance:\\n\",\n                                       \"\t:members:\\n\"]\n                elif object.__class__ == module_browser.Global:\n                    if not member.startswith(\"_\"):\n                        module_attributes[member] = [\".. attribute:: {0}.{1}\\n\".format(module, member)]\n\n            module_attributes and rst_file.content.append(\"Module Attributes\\n-----------------\\n\\n\")\n            for module_attribute in module_attributes.itervalues():\n                rst_file.content.extend(module_attribute)\n                rst_file.content.append(\"\\n\")\n\n            functions and rst_file.content.append(\"Functions\\n---------\\n\\n\")\n            for function in functions.itervalues():\n                rst_file.content.extend(function)\n                rst_file.content.append(\"\\n\")\n\n            classes and rst_file.content.append(\"Classes\\n-------\\n\\n\")\n            for class_ in classes.itervalues():\n                rst_file.content.extend(class_)\n                rst_file.content.append(\"\\n\")\n\n            rst_file.write()\n            modules.append(module)\n\n        packages_modules[\"apiModules\"].extend([module for module in modules if not \"tests\" in module])\n        packages_modules[\"testsModules\"].extend([module for module in modules if \"tests\" in module])\n\n    api_file = File(\"{0}{1}\".format(output, FILES_EXTENSION))\n    api_file.content.extend(TOCTREE_TEMPLATE_BEGIN)\n    for module in packages_modules[\"apiModules\"]:\n        api_file.content.append(\"   {0} <{1}>\\n\".format(module, \"api/{0}\".format(module)))\n    for module in packages_modules[\"testsModules\"]:\n        api_file.content.append(\"   {0} <{1}>\\n\".format(module, \"api/{0}\".format(module)))\n    api_file.content.extend(TOCTREE_TEMPLATE_END)\n    api_file.write()\n\n    return True", "response": "Builds the Sphinx documentation API."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nstart the Application. :return: Definition success. :rtype: bool", "response": "def main():\n    \"\"\"\n    Starts the Application.\n\n    :return: Definition success.\n    :rtype: bool\n    \"\"\"\n\n    args = get_command_line_arguments()\n    args.sanitizer = args.sanitizer if foundations.common.path_exists(args.sanitizer) else SANITIZER\n    args.excluded_modules = args.excluded_modules if all(args.excluded_modules) else []\n    return build_api(args.packages,\n                     args.input,\n                     args.output,\n                     args.sanitizer,\n                     args.excluded_modules)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the 2 matrix with lat lon of each pixel.", "response": "def pixels_from_coordinates(lat, lon, max_y, max_x):\n    \"\"\"\n    Return the 2 matrix with lat and lon of each pixel.\n\n    Keyword arguments:\n    lat -- A latitude matrix\n    lon -- A longitude matrix\n    max_y -- The max vertical pixels amount of an orthorectified image.\n    max_x -- The max horizontal pixels amount of an orthorectified image.\n    \"\"\"\n    # The degrees by pixel of the orthorectified image.\n    x_ratio, y_ratio = max_x/360., max_y/180.\n    x, y = np.zeros(lon.shape), np.zeros(lat.shape)\n    x = (lon + 180.) * x_ratio\n    y = (lat + 90.) * y_ratio\n    return x, y"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a matrix of Linke turbidity multiplied by 20.", "response": "def obtain(date, compressed=True):\n    \"\"\"\n    Return an integer matrix with the Linke turbidity multiplied by 20. So it\n    should be divided by 20 in before the usage (over the CPU or the GPU).\n\n    Keyword arguments:\n    date -- the datetime of the file.\n    compressed -- the true value if it should return a matrix of integers or\n    if it should return an uncompressed matrix of floats.\n    \"\"\"\n    pattern = \"%s/tifs/%s_longlat_wgs84.tif\"\n    ds = gdal.Open(pattern % (localpath, str(date.month).zfill(2)))\n    linke = ds.ReadAsArray()\n    return linke if compressed else linke / 20."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the linke turbidity projected to the lat lon matrix coordenates.", "response": "def obtain_to(filename, compressed=True):\n    \"\"\"\n    Return the linke turbidity projected to the lat lon matrix coordenates.\n\n    Keyword arguments:\n    filename -- the name of a netcdf file.\n    \"\"\"\n    files = glob.glob(filename)\n    root, _ = nc.open(filename)\n    lat, lon = nc.getvar(root, 'lat')[0,:], nc.getvar(root, 'lon')[0,:]\n    date_str = lambda f: \".\".join((f.split('/')[-1]).split('.')[1:-2])\n    date = lambda f: datetime.strptime(date_str(f), \"%Y.%j.%H%M%S\")\n    linke = lambda f: transform_data(obtain(date(f), compressed), lat, lon)\n    linkes_projected = map(lambda f: (f, linke(f)), files)\n    nc.close(root)\n    return dict(linkes_projected)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\npersist the linke turbidity projected to the netcdf file.", "response": "def persist(filename):\n    \"\"\"\n    Append the linke turbidity projected (using lat lon) as variables of\n    the netcdf file.\n\n    Keyword arguments:\n    filename -- the name of a netcdf file.\n    \"\"\"\n    linkes_projected = obtain_to(filename, compressed=False)\n    keys = sorted(linkes_projected.keys())\n    values = np.vstack([map(lambda k: linkes_projected[k], keys)])\n    with nc.loader(filename) as root:\n        data = nc.getvar(root, 'data')\n        linke = nc.getvar(root, 'linke', 'f4', source=data)\n        linke[:] = values"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _jobs_cursor(plugin_name, location=None, port=None, custom=None):\n    cur = RBJ.get_all(READY, index=STATUS_FIELD)\n    cur_filter = (r.row[TARGET_FIELD][PLUGIN_NAME_KEY] == plugin_name)\n    cur_filter = cur_filter & \\\n                 (~r.row.has_fields(EXPIRE_FIELD) |\n                  r.row[EXPIRE_FIELD].ge(time()))\n    if location:\n        cur_filter = cur_filter & \\\n                     (r.row[TARGET_FIELD][LOCATION_FIELD] == location)\n    if port:\n        cur_filter = cur_filter & \\\n                     (r.row[TARGET_FIELD][PORT_FIELD] == port)\n    if custom:\n        cur_filter = cur_filter & custom\n    return cur.filter(cur_filter).order_by(START_FIELD)", "response": "Generates a reql cursor for the available jobs."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_targets(conn=None):\n    targets = RBT\n    results = targets.run(conn)\n    for item in results:\n        yield item", "response": "get_brain_targets function from Brain. Targets table."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef is_job_done(job_id, conn=None):\n    result = False\n    get_done = RBJ.get_all(DONE, index=STATUS_FIELD)\n    for item in get_done.filter({ID_FIELD: job_id}).run(conn):\n        result = item\n    return result", "response": "Checks to see if a job is done"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nchecking to see if a job is done", "response": "def is_job_complete(job_id, conn=None):\n    \"\"\"\n    is_job_done function checks to if Brain.Jobs Status is Completed\n\n    Completed is defined in statics as Done|Stopped|Error\n\n    :param job_id: <str> id for the job\n    :param conn: (optional)<connection> to run on\n    :return: <dict> if job is done <false> if\n    \"\"\"\n    result = False\n    job = RBJ.get(job_id).run(conn)\n    if job and job.get(STATUS_FIELD) in COMPLETED:\n        result = job\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the content buffer for a job_id if that job output exists else None.", "response": "def get_output_content(job_id, max_size=1024, conn=None):\n    \"\"\"\n    returns the content buffer for a job_id if that job output exists\n\n    :param job_id: <str> id for the job\n    :param max_size: <int> truncate after [max_size] bytes\n    :param conn: (optional)<connection> to run on\n    :return: <str> or <bytes>\n    \"\"\"\n    content = None\n    if RBO.index_list().contains(IDX_OUTPUT_JOB_ID).run(conn):\n        # NEW\n        check_status = RBO.get_all(job_id, index=IDX_OUTPUT_JOB_ID).run(conn)\n    else:\n        # OLD\n        check_status = RBO.filter({OUTPUTJOB_FIELD: {ID_FIELD: job_id}}).run(conn)\n    for status_item in check_status:\n        content = _truncate_output_content_if_required(status_item, max_size)\n    return content"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets all jobs in a node.", "response": "def get_jobs(plugin_name,\n             verify_job=True, conn=None):\n    \"\"\"\n    :param plugin_name: <str>\n    :param verify_job: <bool>\n    :param conn: <connection> or <NoneType>\n    :return: <generator> yields <dict>\n    \"\"\"\n    job_cur = _jobs_cursor(plugin_name).run(conn)\n    for job in job_cur:\n        if verify_job and not verify(job, Job()):\n            continue #to the next job... warn?\n        yield job"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget next job by location.", "response": "def get_next_job_by_location(plugin_name, loc, verify_job=True, conn=None):\n    \"\"\"\n    Deprecated - Use get_next_job\n    \"\"\"\n    return get_next_job(plugin_name, loc, verify_job=verify_job, conn=conn)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting next job by port.", "response": "def get_next_job_by_port(plugin_name, port, verify_job=True, conn=None):\n    \"\"\"\n    Deprecated - Use get_next_job\n    \"\"\"\n    return get_next_job(plugin_name, None, port, verify_job, conn)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the job with the given id", "response": "def get_job_by_id(job_id, conn=None):\n    \"\"\"returns the job with the given id\n\n    :param job_id: <str> id of the job\n    :param conn: <rethinkdb.DefaultConnection>\n    :return: <dict> job with the given id\n    \"\"\"\n    job = RBJ.get(job_id).run(conn)\n    return job"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _setup(self):\n        self._populate_local()\n        try:\n            self._populate_latest()\n        except Exception as e:\n            self.log.exception('Unable to retrieve latest %s version information', self.meta_name)\n        self._sort()", "response": "Run setup tasks after initialization\n           "}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _sort(self):\n        self.versions = OrderedDict(sorted(self.versions.items(), key=lambda v: v[0]))", "response": "Sort versions by their version number"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _populate_local(self):\n        archives = glob(os.path.join(self.path, '*.zip'))\n        for archive in archives:\n            try:\n                version = self._read_zip(archive)\n                self.versions[version.vtuple] = self.meta_class(self, version, filepath=archive)\n            except BadZipfile as e:\n                self.log.warn('Unreadable zip archive in versions directory (%s): %s', e.message, archive)\n\n        if self.dev_path:\n            dev_archives = glob(os.path.join(self.dev_path, '*.zip'))\n            dev_versions = []\n            for dev_archive in dev_archives:\n                try:\n                    dev_versions.append((self._read_zip(dev_archive), dev_archive))\n                except BadZipfile as e:\n                    self.log.warn('Unreadable zip archive in versions directory (%s): %s', e.message, dev_archive)\n\n            if not dev_versions:\n                self.log.debug('No development releases found')\n                return\n\n            dev_version = sorted(dev_versions, key=lambda v: v[0].vtuple).pop()\n            self.dev_version = self.meta_class(self, dev_version[0], filepath=dev_version[1])", "response": "Populate version data for local archives"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the filepath to the specified version", "response": "def get(self, version, use_cache=True):\n        \"\"\"\n        Get the filepath to the specified version (downloading it in the process if necessary)\n        @type   version:    IpsMeta\n        @param  use_cache:  Use cached version downloads if available\n        @type   use_cache:  bool\n        @rtype: str\n        \"\"\"\n        self.log.info('Retrieving %s version %s', self.meta_name, version.version)\n\n        if version.filepath:\n            if use_cache:\n                return version.filepath\n            else:\n                self.log.info('Ignoring cached %s version: %s', self.meta_name, version.version)\n        elif not use_cache:\n            self.log.info(\"We can't ignore the cache of a version that hasn't been downloaded yet\")\n\n        version.download()\n        return version.filepath"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef download(self):\n        # Submit a download request and test the response\n        self.log.debug('Submitting request: %s', self.request)\n        response = self.session.request(*self.request, stream=True)\n        if response.status_code != 200:\n            self.log.error('Download request failed: %d', response.status_code)\n            raise HtmlParserError\n\n        # If we're re-downloading this version, delete the old file\n        if self.filepath and os.path.isfile(self.filepath):\n            self.log.info('Removing old version download')\n            os.remove(self.filepath)\n\n        # Make sure our versions data directory exists\n        if not os.path.isdir(self.basedir):\n            self.log.debug('Creating versions data directory')\n            os.makedirs(self.basedir, 0o755)\n\n        # Process our file download\n        vslug = self.version.vstring.replace(' ', '-')\n        self.filepath = self.filepath or os.path.join(self.basedir, '{v}.zip'.format(v=vslug))\n        with open(self.filepath, 'wb') as f:\n            for chunk in response.iter_content(chunk_size=1024):\n                if chunk:  # filter out keep-alive new chunks\n                    f.write(chunk)\n                    f.flush()\n\n        self.log.info('Version {v} successfully downloaded to {fn}'.format(v=self.version, fn=self.filepath))", "response": "Download the latest IPS release and return the filepath"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get(self, endpoint, *args, **kwargs):\n        endpoint = self.base_url + endpoint\n        return self._make_request(endpoint, type='GET')", "response": "This method is used to make a GET request to a remote endpoint."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef post(self, endpoint, d, *args, **kwargs):\n        endpoint = self.base_url + endpoint\n        if not isinstance(d, str):\n            d = json.dumps(d)\n\n        return self._make_request(endpoint, type='POST', data=d)", "response": "Make a POST request to a remote endpoint"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef put(self, endpoint, d, *args, **kwargs):\n\n        return self._make_request(endpoint, type='PUT', data=d)", "response": "This is the internal method that is used to make a PUT request to a specific entry in the Gett server."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nremove all handlers bound to given object instance.", "response": "def remove_handlers_bound_to_instance(self, obj):\n        \"\"\"\n        Remove all handlers bound to given object instance.\n        This is useful to remove all handler methods that are part of an instance.\n\n        :param object obj: Remove handlers that are methods of this instance\n        \"\"\"\n        for handler in self.handlers:\n            if handler.im_self == obj:\n                self -= handler"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd handler to the container.", "response": "def add(self, handler, priority=10):\n        \"\"\"\n        Add handler.\n\n        :param callable handler: callable handler\n        :return callable: The handler you added is given back so this can be used as a decorator.\n        \"\"\"\n        self.container.add_handler(handler, priority=priority)\n        return handler"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nprinting usage description for this program. Output is to standard out.", "response": "def usage(self):\n    \"\"\"Print usage description for this program. Output is to standard out.\"\"\"\n    print self.programName + \" [options]\",\n    if self.maxArgs == -1 or self.maxArgs - self.minArgs > 1:\n      print \"[files..]\"\n    elif self.maxArgs - self.minArgs == 1:\n      print \"[file]\"\n    print\n\n    print self.shortDescription\n\n    print \"Options:\"\n    for o in self.options:\n      print \"\\t\", (\"-\" + o.short + \", --\" + o.long).ljust(15), \":\",\n      print o.description.replace(\"\\t\", \"\\\\t\").ljust(80)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nparsing the given command line and populate self with the values found.", "response": "def parseCommandLine(self, line):\n    \"\"\"\n    Parse the given command line and populate self with the values found.\n\n    If the command line doesn't conform to the specification defined\n    by this CLI object, this function prints a message to stdout indicating\n    what was wrong, prints the program usage instructions and then exists\n    the program\n\n    :param line: list of tokens from the command line. Should have had program\n                 name removed - generally one would do this: sys.argv[1:]\n    \"\"\"\n    # separate arguments and options\n    try:\n      optlist, args = getopt.getopt(line, self._optlist(), self._longoptl())\n    except getopt.GetoptError, err:\n      print str(err)\n      self.usage()\n      sys.exit(2)\n\n    # parse options\n    for opt, arg in optlist:\n      opt = opt.lstrip(\"-\")\n      found = False\n      for option in self.options:\n        if option.short == opt or option.long == opt:\n          option.value = option.type(arg)\n          option.set = True\n          found = True\n      if not found:\n        sys.stderr.write(\"unknown option: \" + opt)\n        self.usage()\n        sys.exit(2)\n\n    # check for special options\n    specialOptions = False\n    for opt in self.options:\n      if opt.special and opt.isSet():\n        specialOptions = True\n\n    # parse arguments\n    if len(args) < self.minArgs and not specialOptions:\n      err = (str(len(args)) + \" input arguments found, but required at \" +\n             \"least \" + str(self.minArgs) + \" arguments\")\n      sys.stderr.write(err)\n      sys.stderr.write(\"\\n\\n\")\n      self.usage()\n      sys.exit(2)\n    else:\n      self.args = args\n\n    # check for required options\n    for option in self.options:\n      if option.isRequired() and not option.isSet() and not specialOptions:\n        err = \"required option \\'\" + str(option) + \"\\' is missing\"\n        sys.stderr.write(err)\n        print \"\\n\"\n        self.usage()\n        sys.exit(2)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef getOption(self, name):\n    name = name.strip()\n    for o in self.options:\n      if o.short == name or o.long == name:\n        return o\n    raise InterfaceException(\"No such option: \" + name)", "response": "Get the Option object associated with the given name."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef hasOption(self, name):\n    name = name.strip()\n    for o in self.options:\n      if o.short == name or o.long == name:\n        return True\n    return False", "response": "Check whether this CLI has an option with a given name."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef addOption(self, o):\n    if self.hasOption(o.short):\n      raise InterfaceException(\"Failed adding option - already have \" + str(o))\n    self.options.append(o)", "response": "Adds a new option to this CLI."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nchecks whether an option with a given name exists and has been set by the user.", "response": "def optionIsSet(self, name):\n    \"\"\"\n    Check whether an option with a given name exists and has been set.\n\n    :param name: the name of the option to check; can be short or long name.\n    :return: true if an option matching the given name exists and it has had\n             it's value set by the user\n    \"\"\"\n    name = name.strip()\n    if not self.hasOption(name):\n      return False\n    return self.getOption(name).isSet()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef getArgument(self, num):\n    if not self.hasArgument(num):\n      raise InterfaceException(\"Failed to retrieve argument \" + str(num) +\n                               \" -- not enough arguments provided\")\n    return self.args[num]", "response": "Get the num^th argument."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _optlist(self):\n    res = \"\"\n    for o in self.options:\n        res += o.short\n        if o.argName is not None:\n          res += \":\"\n    return res", "response": "Return a string representation of the options in short format."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _longoptl(self):\n    res = []\n    for o in self.options:\n      nm = o.long\n      if o.argName is not None:\n        nm += \"=\"\n      res.append(nm)\n    return res", "response": "Get a list of string representations of the options in long format."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef pull(self):\n        repo_root = settings.REPO_ROOT\n        pull_from_origin(join(repo_root, self.name))", "response": "Pull the record from the origin."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the package representation of this repo.", "response": "def to_package(self, repo_url):\n        \"\"\"Return the package representation of this repo.\"\"\"\n        return Package(name=self.name, url=repo_url + self.name)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef parent_workspace(context):\n    if IWorkspaceFolder.providedBy(context):\n        return context\n    for parent in aq_chain(context):\n        if IWorkspaceFolder.providedBy(parent):\n            return parent", "response": "Return the parent workspace of the given context."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the list of workspace activities in the order of the time they are in.", "response": "def get_workspace_activities(brain, limit=1):\n    \"\"\" Return the workspace activities sorted by reverse chronological\n    order\n\n    Regarding the time value:\n     - the datetime value contains the time in international format\n       (machine readable)\n     - the title value contains the absolute date and time of the post\n    \"\"\"\n    mb = queryUtility(IMicroblogTool)\n    items = mb.context_values(brain.getObject(), limit=limit)\n    return [\n        {\n            'subject': item.creator,\n            'verb': 'published',\n            'object': item.text,\n            'time': {\n                'datetime': item.date.strftime('%Y-%m-%d'),\n                'title': item.date.strftime('%d %B %Y, %H:%M'),\n            }\n        } for item in items\n    ]"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the list of my workspaces", "response": "def my_workspaces(context):\n    \"\"\" The list of my workspaces\n    \"\"\"\n    pc = api.portal.get_tool('portal_catalog')\n    brains = pc(\n        portal_type=\"ploneintranet.workspace.workspacefolder\",\n        sort_on=\"modified\",\n        sort_order=\"reversed\",\n    )\n    workspaces = [\n        {\n            'id': brain.getId,\n            'title': brain.Title,\n            'description': brain.Description,\n            'url': brain.getURL(),\n            'activities': get_workspace_activities(brain),\n            'class': escape_id_to_class(brain.getId),\n        } for brain in brains\n    ]\n    return workspaces"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef existing_users(context):\n    members = IWorkspace(context).members\n    info = []\n    for userid, details in members.items():\n        user = api.user.get(userid)\n        if user is None:\n            continue\n        user = user.getUser()\n        title = user.getProperty('fullname') or user.getId() or userid\n        # XXX tbd, we don't know what a persons description is, yet\n        description = _(u'Here we could have a nice status of this person')\n        classes = description and 'has-description' or 'has-no-description'\n        portal = api.portal.get()\n        portrait = '%s/portal_memberdata/portraits/%s' % \\\n                   (portal.absolute_url(), userid)\n        info.append(\n            dict(\n                id=userid,\n                title=title,\n                description=description,\n                portrait=portrait,\n                cls=classes,\n                member=True,\n                admin='Admins' in details['groups'],\n            )\n        )\n\n    return info", "response": "Return a list of all users that are already in the current workspace"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a random key of choices weighted by their value.", "response": "def random_weighted_choice(choices):\n    \"\"\"\n    Return a random key of choices, weighted by their value.\n\n    :param choices: a dictionary of keys and positive integer pairs;\n    :return: a random key of choices.\n    \"\"\"\n    choices, weights = zip(*choices.items())\n    cumdist = list(accumulate(weights))\n    x = random.random() * cumdist[-1]\n    element = bisect.bisect(cumdist, x)\n    return choices[element]"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef extract_words(lines):\n    for line in lines:\n        for word in re.findall(r\"\\w+\", line):\n            yield word", "response": "Extracts words from the given iterable of lines the list of words."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef absolute_urls(html):\n\n    from bs4 import BeautifulSoup\n    from yacms.core.request import current_request\n\n    request = current_request()\n    if request is not None:\n        dom = BeautifulSoup(html, \"html.parser\")\n        for tag, attr in ABSOLUTE_URL_TAGS.items():\n            for node in dom.findAll(tag):\n                url = node.get(attr, \"\")\n                if url:\n                    node[attr] = request.build_absolute_uri(url)\n        html = str(dom)\n    return html", "response": "Converts relative URLs into absolute URLs. Used for RSS feeds to\n    provide more complete HTML for item descriptions."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef decode_entities(html):\n    def decode(m):\n        html = m.group(0)\n        if html[:2] == \"&#\":\n            try:\n                if html[:3] == \"&#x\":\n                    return chr(int(html[3:-1], 16))\n                else:\n                    return chr(int(html[2:-1]))\n            except ValueError:\n                pass\n        else:\n            try:\n                html = chr(name2codepoint[html[1:-1]])\n            except KeyError:\n                pass\n        return html\n    return re.sub(\"&#?\\w+;\", decode, html.replace(\"&amp;\", \"&\"))", "response": "Remove HTML entities from a string."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef escape(html):\n    from yacms.conf import settings\n    from yacms.core import defaults\n    if settings.RICHTEXT_FILTER_LEVEL == defaults.RICHTEXT_FILTER_LEVEL_NONE:\n        return html\n    tags = settings.RICHTEXT_ALLOWED_TAGS\n    attrs = settings.RICHTEXT_ALLOWED_ATTRIBUTES\n    styles = settings.RICHTEXT_ALLOWED_STYLES\n    if settings.RICHTEXT_FILTER_LEVEL == defaults.RICHTEXT_FILTER_LEVEL_LOW:\n        tags += LOW_FILTER_TAGS\n        attrs += LOW_FILTER_ATTRS\n    return clean(html, tags=tags, attributes=attrs, strip=True,\n                 strip_comments=False, styles=styles)", "response": "Escape the given HTML according to the rules defined by the settings. RichText_ALLOWED_TAGS RichText_ALLOWED_ATTRIBUTES RichText_ALLOWED_STYLES or RichText_ALLOWED_STYLES settings."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef thumbnails(html):\n    from django.conf import settings\n    from bs4 import BeautifulSoup\n    from yacms.core.templatetags.yacms_tags import thumbnail\n\n    # If MEDIA_URL isn't in the HTML string, there aren't any\n    # images to replace, so bail early.\n    if settings.MEDIA_URL.lower() not in html.lower():\n        return html\n\n    dom = BeautifulSoup(html, \"html.parser\")\n    for img in dom.findAll(\"img\"):\n        src = img.get(\"src\", \"\")\n        src_in_media = src.lower().startswith(settings.MEDIA_URL.lower())\n        width = img.get(\"width\")\n        height = img.get(\"height\")\n        if src_in_media and width and height:\n            img[\"src\"] = settings.MEDIA_URL + thumbnail(src, width, height)\n    # BS adds closing br tags, which the browser interprets as br tags.\n    return str(dom).replace(\"</br>\", \"\")", "response": "Converts paths in img tags to thumbnail\n    paths using yacms s thumbnail template tag. Used as\n    one of the default values in RICHTEXT_FILTERS setting."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset the client s service catalog from the response data.", "response": "def _extract_service_catalog(self, body):\n        \"\"\"Set the client's service catalog from the response data.\"\"\"\n        self.auth_ref = access.create(body=body)\n        self.service_catalog = self.auth_ref.service_catalog\n        self.auth_token = self.auth_ref.auth_token\n        self.auth_tenant_id = self.auth_ref.tenant_id\n        self.auth_user_id = self.auth_ref.user_id\n\n        if not self.endpoint_url:\n            self.endpoint_url = self.service_catalog.url_for(\n                region_name=self.region_name,\n                service_type=self.service_type,\n                interface=self.endpoint_type)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef show_partitioning(rdd, show=True):\n    if show:\n        partitionCount = rdd.getNumPartitions()\n        try:\n            valueCount = rdd.countApprox(1000, confidence=0.50)\n        except:\n            valueCount = -1\n        try:\n            name = rdd.name() or None\n        except:\n            pass\n        name = name or \"anonymous\"\n        logging.info(\"For RDD %s, there are %d partitions with on average %s values\" % \n                     (name, partitionCount, int(valueCount/float(partitionCount))))", "response": "Show the number of partitions in the RDD."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef normal_case(name):\n    s1 = re.sub(r'(.)([A-Z][a-z]+)', r'\\1 \\2', name)\n    return re.sub(r'([a-z0-9])([A-Z])', r'\\1 \\2', s1).lower()", "response": "Converts CamelCaseHere to camel case here."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef merge(self, other):\n        for key, value in other.items():\n            if not key in self:\n                self[key] = value\n            elif isinstance(value, (list, tuple)):\n                self[key] += value\n            elif isinstance(value, OrderedSet):\n                if isinstance(self[key], str):\n                    self[key] = OrderedSet([self[key]])\n                elif not isinstance(self[key], OrderedSet):\n                    self[key] = OrderedSet(self[key])\n                self[key] |= value\n            else:\n                self[key] = value\n        return self", "response": "Merge other into this environment."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef install_config(self):\n        text = templ_config.render(**self.options)\n        config = Configuration(self.buildout, 'supervisord.conf', {\n            'deployment': self.deployment_name,\n            'text': text})\n        return [config.install()]", "response": "install supervisor main config file"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ninstall supervisor program config file", "response": "def install_program(self):\n        \"\"\"\n        install supervisor program config file\n        \"\"\"\n        text = templ_program.render(**self.options)\n        config = Configuration(self.buildout, self.program + '.conf', {\n            'deployment': self.deployment_name,\n            'directory': os.path.join(self.options['etc-directory'], 'conf.d'),\n            'text': text})\n        return [config.install()]"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nconverting a time string to the equivalent number in minutes as an int.", "response": "def _time_to_minutes(self, time_str):\n\t\t\"\"\"\n\t\tConvert a time string to the equivalent number in minutes as an int.\n\t\tReturn 0 if the time_str is not a valid amount of time.\n\n\t\t>>> jump = JumprunProApi('skydive-warren-county')\n\t\t>>> jump._time_to_minutes('34 minutes')\n\t\t34\n\t\t>>> jump._time_to_minutes('1 hour, 30 minutes')\n\t\t90\n\t\t>>> jump._time_to_minutes('jfksadjfkas')\n\t\t0\n\t\t\"\"\"\n\t\tminutes = 0\n\t\ttry:\n\t\t\tcall_time_obj = parser.parse(time_str)\n\n\t\t\tminutes = call_time_obj.minute\n\t\t\tminutes += call_time_obj.hour * 60\n\t\texcept ValueError:\n\t\t\tminutes = 0\n\n\t\treturn minutes"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn True if this dropzone is still making new loads False otherwise.", "response": "def jumping(self, _loads=None):\n\t\t\"\"\"\n\t\tReturn True if this dropzone is still making new loads, False otherwise.\n\n\t\t:param _loads: The output of the `departing_loads` function. This\n\t\tshould be left alone except for debugging purposes.\n\t\t\"\"\"\n\t\tif _loads is None:\n\t\t\t_loads = self.departing_loads()\n\n\t\tif len(_loads) < 1:\n\t\t\treturn False\n\n\t\tlast_load = _loads[-1:][0]\n\t\tif last_load['state'].lower() in ('departed', 'closed', 'on hold'):\n\t\t\treturn False\n\n\t\treturn True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning an iterator that yields all devices that belong to a specified subsystem.", "response": "def devices_by_subsystem(subsys, only=lambda x: True):\n    \"\"\"\n    Iterator that yields devices that belong to specified subsystem. Returned\n    values are ``pydev.Device`` instances.\n\n    The ``only`` argument can be used to further filter devices. It should be\n    a function that takes a ``pyudev.Device`` object, and returns ``True`` or\n    ``False`` to indicate whether device should be returned.\n\n    Example::\n\n        >>> devices_by_subsystem('net')\n        [Device('/sys/devices/pci0000:00/0000:00:1c.3/0000:02:00.0/net/wlp2s0'),\n         Device('/sys/devices/virtual/net/lo')]\n    \"\"\"\n    ctx = pyudev.Context()\n    for d in ctx.list_devices():\n        if d.subsystem != subsys:\n            continue\n        if not only(d):\n            continue\n        yield d"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef check_infile(filename):\n    if os.path.isfile(filename):\n        domain = os.path.basename(filename).split('.txt')[0]\n        return domain\n    else:\n        sys.stderr.write(\"ERROR: %s : No such file\\n\" % filename)\n        sys.exit(1)", "response": "Check if a file is in bulk updating the sequence of items"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_json(domain, action, filename=False, record=False):\n    o = JSONConverter(domain)\n\n    if filename:\n        # for 'bulk_create/bulk_delete'\n        with open(filename, 'r') as f:\n            o.separate_input_file(f)\n            for item in o.separated_list:\n                o.read_records(item.splitlines())\n                o.generata_data(action)\n\n    elif record:\n        # for 'create/delete'\n        o.read_records(record)\n        o.generata_data(action)\n\n    return o.dict_records", "response": "Convert text file to JSON."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_password(args):\n    password = ''\n\n    if args.__dict__.get('password'):\n        # Specify password as argument (for -p option)\n        password = args.password\n\n    elif args.__dict__.get('P'):\n        # Enter password interactively (for -P option)\n        while True:\n            # When setting password in $HOME/.tdclirc, using it.\n            if password:\n                break\n\n            else:\n                # Not set in $HOME/.tdclirc, attempt input prompt\n                from getpass import getpass\n                password = getpass(prompt='TonicDNS user password: ')\n\n    return password", "response": "Get the password for the current user"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget record parameters from command options.", "response": "def get_record_params(args):\n    \"\"\"Get record parameters from command options.\n\n    Argument:\n\n        args: arguments object\n    \"\"\"\n    name, rtype, content, ttl, priority = (\n        args.name, args.rtype, args.content, args.ttl, args.priority)\n    return name, rtype, content, ttl, priority"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconvert and print JSON. Argument : args - > object", "response": "def show(args):\n    \"\"\"Convert and print JSON.\n\n    Argument:\n\n        args: arguments object\n    \"\"\"\n    domain = check_infile(args.infile)\n    action = True\n    try:\n        print(json.dumps(set_json(domain, action, filename=args.infile),\n                         sort_keys=True, indent=2))\n    except UnicodeDecodeError as e:\n        sys.stderr.write(\"ERROR: \\\"%s\\\" is invalid format file.\\n\"\n                         % args.infile)\n        exit(1)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nretrieve records. Argument : args - Command line arguments object", "response": "def get(args):\n    \"\"\"Retrieve records.\n\n    Argument:\n\n        args: arguments object\n    \"\"\"\n    password = get_password(args)\n    token = connect.get_token(args.username, password, args.server)\n\n    if args.__dict__.get('search'):\n        # When using '--search' option\n        keyword = args.search\n\n    else:\n        keyword = ''\n\n    if args.__dict__.get('raw_flag'):\n        raw_flag = True\n    else:\n        raw_flag = False\n\n    if args.__dict__.get('domain'):\n        # When specified zone\n        domain = args.domain\n        data = processing.get_zone(args.server, token, domain,\n                                   keyword, raw_flag)\n        return data\n\n    else:\n        # When get all zones\n        processing.get_all_zone(args.server, token)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating records. Argument : args - command line arguments", "response": "def create(args):\n    \"\"\"Create records.\n\n    Argument:\n\n        args: arguments object\n    \"\"\"\n    # for PUT HTTP method\n    action = True\n\n    if ((args.__dict__.get('domain') and args.__dict__.get('name')\n         and args.__dict__.get('rtype') and args.__dict__.get('content'))):\n        # for create sub-command\n\n        domain = args.domain\n        o = JSONConverter(domain)\n\n        name, rtype, content, ttl, priority = get_record_params(args)\n        record_dict = o.set_record(name, rtype, content, ttl, priority)\n\n        json = set_json(domain, action, record=record_dict)\n\n    else:\n        # for bulk_create sub-command\n        if args.__dict__.get('domain'):\n            domain = args.domain\n        else:\n            domain = check_infile(args.infile)\n        json = set_json(domain, action, filename=args.infile)\n\n    password = get_password(args)\n    token = connect.get_token(args.username, password, args.server)\n    processing.create_records(args.server, token, domain, json)\n\n    if args.auto_update_soa == 'True':\n        update_soa_serial(args)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nupdates a record in the tree.", "response": "def update(args):\n    \"\"\"Update a record.\n\n    Argument:\n\n        args: arguments object\n\n    Firstly call delete(), then create().\n    \"\"\"\n    # Check specifying some new values\n    if ((not args.__dict__.get('new_type') and\n         not args.__dict__.get('new_content') and\n         not args.__dict__.get('new_ttl') and\n         not args.__dict__.get('new_priority'))):\n        utils.error(\"Not update any values.\")\n\n    args.__dict__['search'] = (args.__dict__.get('name') + ',' +\n                               args.__dict__.get('rtype') + ',' +\n                               args.__dict__.get('content'))\n\n    args.__dict__['raw_flag'] = True\n    data = get(args)\n    if len(data.get('records')) == 1:\n        cur_ttl = data.get('records')[0].get('ttl')\n        cur_priority = data.get('records')[0].get('priority')\n    elif len(data.get('records')) > 1:\n        utils.error(\"Match multiple records\")\n    else:\n        utils.error(\"No match records\")\n\n    new_args = copy.copy(args)\n\n    if new_args.__dict__.get('new_type'):\n        new_args.__dict__['rtype'] = new_args.__dict__.get('new_type')\n\n    if new_args.__dict__.get('new_content'):\n        new_args.__dict__['content'] = new_args.__dict__.get('new_content')\n\n    if new_args.__dict__.get('new_ttl'):\n        new_args.__dict__['ttl'] = new_args.__dict__.get('new_ttl')\n    else:\n        new_args.__dict__['ttl'] = cur_ttl\n\n    if new_args.__dict__.get('new_priority'):\n        new_args.__dict__['priority'] = new_args.__dict__.get('new_priority')\n    else:\n        if cur_priority:\n            new_args.__dict__['priority'] = cur_priority\n\n    delete(args)\n    create(new_args)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nretrieves template. Argument : args : arguments object", "response": "def retrieve_tmpl(args):\n    \"\"\"Retrieve template.\n\n    Argument:\n\n        args: arguments object\n    \"\"\"\n    password = get_password(args)\n    token = connect.get_token(args.username, password, args.server)\n\n    if args.__dict__.get('template'):\n        # When specified template identifier\n        template = args.template\n        processing.get_template(args.server, token, template)\n\n    else:\n        # When get all templates\n        processing.get_all_templates(args.server, token)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef delete_tmpl(args):\n    if args.__dict__.get('template'):\n        template = args.template\n\n    password = get_password(args)\n    token = connect.get_token(args.username, password, args.server)\n    processing.delete_template(args.server, token, template)", "response": "Delete template.\n\n    Argument:\n\n        args: arguments object"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef update_soa_serial(args):\n    password = get_password(args)\n    token = connect.get_token(args.username, password, args.server)\n    soa_content = dict(domain=args.domain)\n    if args.__dict__.get('mname'):\n        soa_content['mname'] = args.mname\n    if args.__dict__.get('rname'):\n        soa_content['rname'] = args.rname\n    if args.__dict__.get('refresh'):\n        soa_content['refresh'] = args.refresh\n    if args.__dict__.get('retry'):\n        soa_content['retry'] = args.retry\n    if args.__dict__.get('expire'):\n        soa_content['expire'] = args.expire\n    if args.__dict__.get('minimum'):\n        soa_content['minimum'] = args.minimum\n    processing.update_soa_serial(args.server, token, soa_content)", "response": "Update SOA serial.\n\n    Argument:\n\n        args: arguments object"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates zone. Argument : True is zone. args. object", "response": "def create_zone(args):\n    \"\"\"Create zone.\n\n    Argument:\n\n        args: arguments object\n    \"\"\"\n    action = True\n\n    password = get_password(args)\n    token = connect.get_token(args.username, password, args.server)\n\n    domain = args.domain\n    template = args.domain.replace('.', '_')\n\n    master = None\n    dnsaddr = args.dnsaddr\n    if args.__dict__.get('S'):\n        dtype = 'SLAVE'\n        master = dnsaddr\n    elif args.__dict__.get('N'):\n        dtype = 'NATIVE'\n    else:\n        dtype = 'MASTER'\n\n    # generate template data\n    o = JSONConverter(domain)\n    o.generate_template(domain, dnsaddr, desc='')\n\n    # create template\n    processing.create_template(args.server, token, template, o.record)\n\n    # create zone\n    processing.create_zone(args.server, token, domain, template, dtype, master)\n\n    # delete template\n    processing.delete_template(args.server, token, template)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndelete zone. Argument: args: arguments object", "response": "def delete_zone(args):\n    \"\"\"Delete zone.\n\n    Argument:\n\n        args: arguments object\n    \"\"\"\n    if args.__dict__.get('domain'):\n        domain = args.domain\n\n    password = get_password(args)\n    token = connect.get_token(args.username, password, args.server)\n    processing.delete_zone(args.server, token, domain)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the option of the command line.", "response": "def set_option(prs, keyword, required=False):\n    \"\"\"Set options of command line.\n\n    Arguments:\n\n        prs:      parser object of argparse\n        keyword:  processing keyword\n        required: True is required option (default is False)\n    \"\"\"\n    if keyword == 'server':\n        prs.add_argument(\n            '-s', dest='server', required=True,\n            help='specify TonicDNS Server hostname or IP address')\n\n    if keyword == 'username':\n        prs.add_argument('-u', dest='username', required=True,\n                         help='TonicDNS username')\n\n    if keyword == 'password':\n        group = prs.add_mutually_exclusive_group(required=True)\n        group.add_argument('-p', dest='password',\n                           help='TonicDNS password')\n        group.add_argument('-P', action='store_true',\n                           help='TonicDNS password prompt')\n\n    if keyword == 'infile':\n        prs.add_argument('infile', action='store',\n                         help='pre-converted text file')\n\n    if keyword == 'domain':\n        prs.add_argument('--domain', action='store', required=True,\n                         help='create record with specify domain')\n        prs.add_argument('--name', action='store', required=True,\n                         help='specify with domain option')\n        prs.add_argument('--rtype', action='store', required=True,\n                         help='specify with domain option')\n        prs.add_argument('--content', action='store', required=True,\n                         help='specify with domain option')\n        prs.add_argument('--ttl', action='store', default='3600',\n                         help='specify with domain option, default 3600')\n        prs.add_argument('--priority', action='store', default=False,\n                         help='specify with domain and '\n                         'rtype options as MX|SRV')\n\n    if keyword == 'update':\n        prs.add_argument('--new-type', action='store',\n                         help='specify new value with domain option')\n        prs.add_argument('--new-content', action='store',\n                         help='specify new value with domain option')\n        prs.add_argument('--new-ttl', action='store',\n                         help='specify new value with domain option')\n        prs.add_argument('--new-priority', action='store',\n                         help='specify new value with domain option')\n\n    if keyword == 'template':\n        msg = 'specify template identifier'\n        if required:\n            prs.add_argument('--template', action='store',\n                             required=True, help=msg)\n        else:\n            prs.add_argument('--template', action='store',\n                             help=msg)\n\n    if keyword == 'search':\n        prs.add_argument('--search', action='store',\n                         help='partial match search or refine search.\\\n                         latter syntax is \"name,rtype,content\"')"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset options of connecting to TonicDNS API server", "response": "def conn_options(prs, conn):\n    \"\"\"Set options of connecting to TonicDNS API server\n\n    Arguments:\n\n        prs:  parser object of argparse\n        conn: dictionary of connection information\n    \"\"\"\n    if conn.get('server') and conn.get('username') and conn.get('password'):\n        prs.set_defaults(server=conn.get('server'),\n                         username=conn.get('username'),\n                         password=conn.get('password'))\n\n    elif conn.get('server') and conn.get('username'):\n        prs.set_defaults(server=conn.get('server'),\n                         username=conn.get('username'))\n\n    if conn.get('auto_update_soa'):\n        prs.set_defaults(auto_update_soa=conn.get('auto_update_soa'))\n    else:\n        prs.set_defaults(auto_update_soa=False)\n\n    if not conn.get('server'):\n        set_option(prs, 'server')\n    if not conn.get('username'):\n        set_option(prs, 'username')\n    if not conn.get('password'):\n        set_option(prs, 'password')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndefining sub - commands and command line options.", "response": "def parse_options():\n    \"\"\"Define sub-commands and command line options.\"\"\"\n\n    server, username, password, auto_update_soa = False, False, False, False\n\n    prs = argparse.ArgumentParser(description='usage')\n    prs.add_argument('-v', '--version', action='version',\n                     version=__version__)\n    if os.environ.get('HOME'):\n        config_file = os.environ.get('HOME') + '/.tdclirc'\n        if os.path.isfile(config_file):\n            (server, username,\n             password, auto_update_soa) = check_config(config_file)\n\n    conn = dict(server=server, username=username,\n                password=password, auto_update_soa=auto_update_soa)\n\n    subprs = prs.add_subparsers(help='commands')\n\n    # Convert and print JSON\n    parse_show(subprs)\n\n    # Retrieve records\n    parse_get(subprs, conn)\n\n    # Create record\n    parse_create(subprs, conn)\n\n    # Create bulk_records\n    parse_bulk_create(subprs, conn)\n\n    # Delete record\n    parse_delete(subprs, conn)\n\n    # Delete bulk_records\n    parse_bulk_delete(subprs, conn)\n\n    # Update a record\n    parse_update(subprs, conn)\n\n    # Update SOA serial\n    parse_update_soa(subprs, conn)\n\n    # Create zone\n    parse_create_zone(subprs, conn)\n\n    # Delete zone\n    parse_delete_zone(subprs, conn)\n\n    # Retrieve template\n    parse_get_tmpl(subprs, conn)\n\n    # Delete template\n    parse_delete_tmpl(subprs, conn)\n\n    args = prs.parse_args()\n    return args"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nconverts and print JSON. Argument", "response": "def parse_show(prs):\n    \"\"\"Convert and print JSON.\n\n    Argument:\n\n        prs:  parser object of argparse\n    \"\"\"\n    prs_show = prs.add_parser('show',\n                              help='show converted JSON')\n    set_option(prs_show, 'infile')\n    prs_show.set_defaults(func=show)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nretrieving records. Arguments: prs: parser object of argparse conn: dictionary of connection information", "response": "def parse_get(prs, conn):\n    \"\"\"Retrieve records.\n\n    Arguments:\n\n        prs:  parser object of argparse\n        conn: dictionary of connection information\n    \"\"\"\n    prs_get = prs.add_parser(\n        'get', help='retrieve all zones or records with a specific zone')\n    prs_get.add_argument('--domain', action='store',\n                         help='specify domain FQDN')\n    conn_options(prs_get, conn)\n    set_option(prs_get, 'search')\n    prs_get.set_defaults(func=get)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates record. Arguments: prs: parser object of argparse conn: dictionary of connection information", "response": "def parse_create(prs, conn):\n    \"\"\"Create record.\n\n    Arguments:\n\n        prs:  parser object of argparse\n        conn: dictionary of connection information\n    \"\"\"\n    prs_create = prs.add_parser(\n        'create', help='create record of specific zone')\n    set_option(prs_create, 'domain')\n    conn_options(prs_create, conn)\n    prs_create.set_defaults(func=create)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef parse_bulk_create(prs, conn):\n    prs_create = prs.add_parser(\n        'bulk_create', help='create bulk records of specific zone')\n    set_option(prs_create, 'infile')\n    conn_options(prs_create, conn)\n    prs_create.add_argument('--domain', action='store',\n                            help='create records with specify zone')\n    prs_create.set_defaults(func=create)", "response": "Create bulk_records.\n\n    Arguments:\n\n        prs:  parser object of argparse\n        conn: dictionary of connection information"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef parse_delete(prs, conn):\n    prs_delete = prs.add_parser(\n        'delete', help='delete a record of specific zone')\n    set_option(prs_delete, 'domain')\n    conn_options(prs_delete, conn)\n    prs_delete.set_defaults(func=delete)", "response": "Delete record.\n\n    Arguments:\n\n        prs:  parser object of argparse\n        conn: dictionary of connection information"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef parse_bulk_delete(prs, conn):\n    prs_delete = prs.add_parser(\n        'bulk_delete', help='delete bulk records of specific zone')\n    set_option(prs_delete, 'infile')\n    conn_options(prs_delete, conn)\n    prs_delete.add_argument('--domain', action='store',\n                            help='delete records with specify zone')\n    prs_delete.set_defaults(func=delete)", "response": "Delete bulk_records.\n\n    Arguments:\n\n        prs:  parser object of argparse\n        conn: dictionary of connection information"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nparse update command line arguments", "response": "def parse_update(prs, conn):\n    \"\"\"Update a record.\n\n    Arguments:\n\n        prs:  parser object of argparse\n        conn: dictionary of connection information\n    \"\"\"\n\n    prs_update = prs.add_parser(\n        'update', help='update record of specific zone')\n    set_option(prs_update, 'domain')\n    set_option(prs_update, 'update')\n    conn_options(prs_update, conn)\n    prs_update.set_defaults(func=update)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nretrieve template. Arguments: prs: parser object of argparse conn: dictionary of connection information", "response": "def parse_get_tmpl(prs, conn):\n    \"\"\"Retrieve template.\n\n    Arguments:\n\n        prs:  parser object of argparse\n        conn: dictionary of connection information\n    \"\"\"\n    prs_tmpl_get = prs.add_parser(\n        'tmpl_get', help='retrieve templates')\n    set_option(prs_tmpl_get, 'template')\n    conn_options(prs_tmpl_get, conn)\n    prs_tmpl_get.set_defaults(func=retrieve_tmpl)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef parse_delete_tmpl(prs, conn):\n    prs_tmpl_delete = prs.add_parser(\n        'tmpl_delete', help='delete template')\n    set_option(prs_tmpl_delete, 'template', required=True)\n    conn_options(prs_tmpl_delete, conn)\n    prs_tmpl_delete.set_defaults(func=delete_tmpl)", "response": "Delete template.\n\n    Arguments:\n\n        prs:  parser object of argparse\n        conn: dictionary of connection information"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef parse_update_soa(prs, conn):\n    prs_soa = prs.add_parser('soa', help='update SOA record')\n    prs_soa.add_argument('--domain', action='store', required=True,\n                         help='specify domain FQDN')\n    prs_soa.add_argument('--mname', action='store',\n                         help='specify MNAME of SOA record')\n    prs_soa.add_argument('--rname', action='store',\n                         help='specify RNAME of SOA record')\n    prs_soa.add_argument('--refresh', action='store', type=int,\n                         help='specify REFRESH of SOA record')\n    prs_soa.add_argument('--retry', action='store', type=int,\n                         help='specify RETRY of SOA record')\n    prs_soa.add_argument('--expire', action='store', type=int,\n                         help='specify EXPIRE of SOA record')\n    prs_soa.add_argument('--minimum', action='store', type=int,\n                         help='specify MINIMUM of SOA record')\n    conn_options(prs_soa, conn)\n    prs_soa.set_defaults(func=update_soa_serial)", "response": "Parse update SOA record."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate zone. Arguments: prs: parser object of argparse conn: dictionary of connection information", "response": "def parse_create_zone(prs, conn):\n    \"\"\"Create zone.\n\n    Arguments:\n\n        prs:  parser object of argparse\n        conn: dictionary of connection information\n    \"\"\"\n    prs_zone_create = prs.add_parser('zone_create', help='create zone')\n    prs_zone_create.add_argument(\n        '--domain', action='store', required=True, help='specify zone')\n    prs_zone_create.add_argument('--dnsaddr', action='store', required=True,\n                                 help='specify IP address of DNS master')\n    group_zone_create = prs_zone_create.add_mutually_exclusive_group()\n    group_zone_create.add_argument('-S', action='store_true',\n                                   help='create zone to SLAVE')\n    group_zone_create.add_argument('-N', action='store_true',\n                                   help='create zone to NATIVE')\n    conn_options(prs_zone_create, conn)\n    prs_zone_create.set_defaults(func=create_zone)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndelete zone. Arguments: prs: parser object of argparse conn: dictionary of connection information", "response": "def parse_delete_zone(prs, conn):\n    \"\"\"Delete zone.\n\n    Arguments:\n\n        prs:  parser object of argparse\n        conn: dictionary of connection information\n    \"\"\"\n    prs_zone_delete = prs.add_parser('zone_delete', help='delete zone')\n    prs_zone_delete.add_argument('--domain', action='store', required=True,\n                                 help='specify zone')\n    conn_options(prs_zone_delete, conn)\n    prs_zone_delete.set_defaults(func=delete_zone)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef check_config(filename):\n    conf = configparser.SafeConfigParser(allow_no_value=False)\n    conf.read(filename)\n    try:\n        server = conf.get('global', 'server')\n    except configparser.NoSectionError:\n        server = False\n    except configparser.NoOptionError:\n        server = False\n    try:\n        username = conf.get('auth', 'username')\n    except configparser.NoSectionError:\n        username = False\n    except configparser.NoOptionError:\n        username = False\n    try:\n        password = conf.get('auth', 'password')\n    except configparser.NoSectionError:\n        password = False\n    except configparser.NoOptionError:\n        password = False\n    try:\n        auto_update_soa = conf.get('global', 'soa_update')\n    except configparser.NoSectionError:\n        auto_update_soa = False\n    except configparser.NoOptionError:\n        auto_update_soa = False\n\n    return server, username, password, auto_update_soa", "response": "Check the configuration file of TonicDNS CLI."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\naggregating a list of ConfigValue objects into a nested dict.", "response": "def _aggregate_config_values(config_values: typing.List[ConfigValue]) -> dict:\n    \"\"\"\n    Returns a (sorted)\n\n    :param config_values:\n    :type config_values:\n    :return:\n    :rtype:\n    \"\"\"\n    _keys: defaultdict = _nested_default_dict()\n    _sorted_values = sorted(config_values, key=lambda x: x.name)\n    for value in _sorted_values:\n        value_keys = value.path.split(ELIBConfig.config_sep_str)\n        this_config_key = _keys\n        for sub_key in value_keys[:-1]:\n            this_config_key = this_config_key[sub_key]\n        this_config_key[value_keys[-1]] = value\n    return _default_dict_to_dict(_keys)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nwriting an example config file using the config values declared so far", "response": "def write_example_config(example_file_path: str):\n    \"\"\"\n    Writes an example config file using the config values declared so far\n\n    :param example_file_path: path to write to\n    \"\"\"\n    document = tomlkit.document()\n    for header_line in _get_header():\n        document.add(tomlkit.comment(header_line))\n    config_keys = _aggregate_config_values(ConfigValue.config_values)\n    _add_config_values_to_toml_object(document, config_keys)\n    _doc_as_str = document.as_string().replace(f'\"{_NOT_SET}\"', '')\n    with open(example_file_path, 'w') as stream:\n        stream.write(_doc_as_str)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\npreparing the message before sending it out", "response": "def prepare_message(self, message):\n        \"\"\"\n        Prepares the message before sending it out\n\n        Returns:\n            - message.Message: the message\n        \"\"\"\n\n        message.meta.update(path=self.path)\n\n        for handler in self.handlers:\n            handler.outgoing(message, self)\n\n        return message"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef on_receive(self, message=None, wire=None, event_origin=None):\n\n        \"\"\"\n        event handler bound to the receive event of the\n        link the server is wired too.\n\n        Arguments:\n            - message (message.Message): incoming message\n\n        Keyword arguments:\n            - event_origin (connection.Link)\n        \"\"\"\n\n        self.trigger(\"before_call\", message)\n\n        fn_name = message.data\n        pmsg = self.prepare_message\n\n        try:\n            for handler in self.handlers:\n                handler.incoming(message, self)\n\n            fn = self.get_function(fn_name, message.path)\n        except Exception as inst:\n            wire.respond(message, ErrorMessage(str(inst)))\n            return\n\n        if callable(fn) and getattr(fn, \"exposed\", False):\n            try:\n                r = fn(*message.args, **message.kwargs)\n                if isinstance(r,Message):\n                    wire.respond(message, pmsg(r))\n                else:\n                    wire.respond(message, pmsg(Message(r)))\n            except Exception as inst:\n                if self.debug:\n                    wire.respond(message, pmsg(ErrorMessage(str(traceback.format_exc()))))\n                else:\n                    wire.respond(message, pmsg(ErrorMessage(str(inst))))\n        else:\n            wire.respond(\n                message,\n                pmsg(\n                    ErrorMessage(\"action '%s' not exposed on API (%s)\" % (fn_name, self.__class__.__name__)))\n                )\n\n        self.trigger(\"after_call\", message)", "response": "Called by the server when a message is received from the link."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef cleanup(self):\n\n        while self.inactive_timeout > 0:\n            self.time = time.time()\n\n            keys = []\n\n            for key, client in self.clients.items.items():\n                t = getattr(client, \"active_at\", 0)\n                if t > 0 and self.time - t > self.inactive_timeout:\n                    client.kwargs[\"link\"].disconnect()\n                    keys.append(key)\n\n            for key in keys:\n                self.log_debug(\"Removing client (inactive): %s\" % key)\n                del self.clients[key]\n\n            time.sleep(1)", "response": "removes inactive clients (will be run in its own thread, about once\n        every second)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef detach_remote(self, id, name):\n\n        if name in self.widgets:\n            if id in self.widgets[name]:\n                del self.widgets[name]", "response": "Detach remote instance of a specific widget from the cache."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef attach_remote(self, id, name, **kwargs):\n\n        client_id = id.split(\".\")[0]\n\n        widget = self.make_widget(\n            id,\n            name,\n            dispatcher=ProxyDispatcher(\n                self,\n                link=getattr(self.clients[client_id], \"link\", None)\n            ),\n            **kwargs\n        )\n        self.store_widget(widget)\n        self.log_debug(\"Attached widget: %s\" % id)", "response": "attach a remote widget to the cluster"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nwrites a message to this chat connection s handler", "response": "def write_message(self, message):\r\n        \"\"\" Writes a message to this chat connection's handler \"\"\"\r\n        logging.debug(\"Sending message {mes} to {usr}\".format(mes=message, usr=self.id))\r\n        self.handler.write_message(message)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconnects to a given room.", "response": "def join_room(self, room_name):   \r\n        \"\"\" Connects to a given room \r\n                If it does not exist it is created\"\"\"     \r\n        logging.debug('Joining room {ro}'.format(ro=room_name))\r\n\r\n        for room in self.rooms:\r\n            if room.name == room_name:\r\n                room.add_user(self)\r\n                self._rooms[room_name] = room\r\n                room.welcome(self)\r\n                break\r\n        else:\r\n            room = Room(room_name)\r\n            self.rooms.append(room)\r\n            self._rooms[room_name] = room\r\n            room.add_user(self)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef send_to_room(self, message, room_name):\r\n        room = self.get_room(room_name)\r\n\r\n        if room is not None:\r\n            room.send_message(message)", "response": "Sends a given message to a given room"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _send_to_all_rooms(self, message):\r\n        for room in self._rooms.values():\r\n            room.send_message(message)", "response": "Send a message to all connected rooms"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef close(self):\r\n        logging.debug('Closing for user {user}'.format(user=self.id.name))\r\n        self.id.release_name()\r\n        for room in self._rooms.values():\r\n            room.disconnect(self)", "response": "Closes the connection by removing the user from all rooms and disconnecting the user from all users."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_type(obj, **kwargs):\n    t = type(obj)\n\n    s = extract_type(str(t))\n\n    return 'Type: {}'.format(s)", "response": "Return the type of an object. Do some regex to remove the \"<class... bit."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_parents(obj, **kwargs):\n    num_of_mro = kwargs.get(\"num_of_mro\", 5)\n\n    mro = getmro(obj.__class__)\n    mro_string = ', '.join([extract_type(str(t)) for t in mro[:num_of_mro]])\n\n    return \"Hierarchy: {}\".format(mro_string)", "response": "Return the MRO of an object. Do regex on each element to remove the \"<class... bit."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nresetting the handlers and formatters in a given logger and sets it up with Colorful", "response": "def colorize_logger(logger, stream=None, level=logging.DEBUG):\n    \"\"\"resets the handlers and formatters in a given logger, and sets it up with Colorful() logs\n    \"\"\"\n    logger.handlers = []\n    logger.filters = []\n    stream = stream or sys.stderr\n    handler = logging.StreamHandler(stream=stream)\n    handler.setLevel(level)\n    handler.setFormatter(Colorful())\n    logger.addHandler(handler)\n    return logger"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a colorized logger.", "response": "def get_logger(name=None, level=logging.DEBUG, stream=None):\n    \"\"\"returns a colorized logger. This function can be used just like\n    :py:func:`logging.getLogger` except you can set the level right\n    away.\"\"\"\n    logger = logging.getLogger(name)\n    colored = colorize_logger(logger, stream=stream, level=level)\n    return colored"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef python_object_name(item, module=True):\n    if not isinstance(item, type):\n        return python_object_name(type(item))\n\n    return br'.'.join(filter(is_valid_python_name, (module and item.__module__, item.__name__)))", "response": "takes a python object and returns its import path."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef lpad(s, N, char='\\0'):\n    assert isinstance(char, bytes) and len(char) == 1, 'char should be a string with length 1'\n    return s.rjust(N, char)", "response": "pads a string to the left with null - bytes or any other given character."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\npad a string to the right with null - bytes or any other given character.", "response": "def rpad(s, N, char='\\0'):\n    \"\"\"pads a string to the right with null-bytes or any other given character.\n\n    ..note:: This is used by the :py:func:`xor` function.\n\n    :param s: the string\n    :param N: an integer of how much padding should be done\n    :returns: the original bytes\n    \"\"\"\n    assert isinstance(char, bytes) and len(char) == 1, 'char should be a string with length 1'\n    return s.ljust(N, char)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef xor(left, right):\n    maxlength = max(map(len, (left, right)))\n\n    ileft = string_to_int(rpad(left, maxlength))\n    iright = string_to_int(rpad(right, maxlength))\n    xored = ileft ^ iright\n    return int_to_string(xored)", "response": "xor 2 strings. They can be shorter than each other, in which case\n    the shortest will be padded with null bytes at its right.\n\n    :param left: a string to be the left side of the xor\n    :param right: a string to be the left side of the xor"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreplace all non - alphanumeric chars in the string with the given repchar.", "response": "def slugify(string, repchar='_'):\n    \"\"\"replaces all non-alphanumeric chars in the string with the given repchar.\n\n    :param string: the source string\n    :param repchar:\n    \"\"\"\n    slug_regex = re.compile(r'(^[{0}._-]+|[^a-z-A-Z0-9_.-]+|[{0}._-]+$)'.format(repchar))\n    strip_regex = re.compile(r'[{0}._-]+'.format(repchar))\n\n    transformations = [\n        lambda x: slug_regex.sub(repchar, x),\n        lambda x: strip_regex.sub(repchar, x),\n        lambda x: x.strip(repchar),\n        lambda x: x.lower(),\n    ]\n    result = string\n    for process in transformations:\n        result = process(result)\n\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfinds and call local method.", "response": "def dispatch(self, *args, **kwargs):\n        \"\"\"Find and call local method.\"\"\"\n        action = kwargs.pop('action', 'default')\n        action_method = getattr(self, str(action), self.default)\n        return action_method(*args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef update(self, **kwargs):\n    for key, value in kwargs.items():\n      setattr(self, key, value)", "response": "Creates or updates a property for the instance for each parameter."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _varFindLimitSpace(basedir, vars, space, part, lookup_fatal, depth):\n    ''' limits the search space of space to part\n    \n    basically does space.get(part, None), but with\n    templating for part and a few more things\n    '''\n\n    # Previous part couldn't be found, nothing to limit to\n    if space is None:\n        return space\n    # A part with escaped .s in it is compounded by { and }, remove them\n    if part[0] == '{' and part[-1] == '}':\n        part = part[1:-1]\n    # Template part to resolve variables within (${var$var2})\n    part = varReplace(basedir, part, vars, lookup_fatal, depth=depth + 1)\n\n    # Now find it\n    if part in space:\n        space = space[part]\n    elif \"[\" in part:\n        m = _LISTRE.search(part)\n        if not m:\n            return None\n        else:\n            try:\n                space = space[m.group(1)][int(m.group(2))]\n            except (KeyError, IndexError):\n                return None\n    else:\n        return None\n\n    # if space is a string, check if it's a reference to another variable\n    if isinstance(space, basestring):\n        space = template_ds(basedir, space, vars, lookup_fatal, depth)\n\n    return space", "response": "limits the search space of space to part\n    \n    basically does not do space. get returns None"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsearches for a variable in text and finds its replacement in vars.", "response": "def _varFind(basedir, text, vars, lookup_fatal, depth=0):\n    ''' Searches for a variable in text and finds its replacement in vars\n\n    The variables can have two formats;\n    - simple, $ followed by alphanumerics and/or underscores\n    - complex, ${ followed by alphanumerics, underscores, periods, braces and brackets, ended by a }\n\n    Examples:\n    - $variable: simple variable that will have vars['variable'] as its replacement\n    - ${variable.complex}: complex variable that will have vars['variable']['complex'] as its replacement\n    - $variable.complex: simple variable, identical to the first, .complex ignored\n\n    Complex variables are broken into parts by separating on periods, except if enclosed in {}.\n    ${variable.{fully.qualified.domain}} would be parsed as two parts, variable and fully.qualified.domain,\n    whereas ${variable.fully.qualified.domain} would be parsed as four parts.\n\n    Returns a dict(replacement=<value in vars>, start=<index into text where the variable stated>,\n        end=<index into text where the variable ends>)\n    or None if no variable could be found in text. If replacement is None, it should be replaced with the\n    original data in the caller.\n    '''\n\n    start = text.find(\"$\")\n    if start == -1:\n        return None\n    # $ as last character\n    if start + 1 == len(text):\n        return None\n    # Escaped var\n    if start > 0 and text[start - 1] == '\\\\':\n        return {'replacement': '$', 'start': start - 1, 'end': start + 1}\n\n    var_start = start + 1\n    if text[var_start] == '{':\n        is_complex = True\n        brace_level = 1\n        var_start += 1\n    else:\n        is_complex = False\n        brace_level = 1\n    # is_lookup is true for $FILE(...) and friends\n    is_lookup = False\n    lookup_plugin_name = None\n    end = var_start\n    # part_start is an index of where the current part started\n    part_start = var_start\n    space = vars\n    while end < len(text) and (((is_lookup or is_complex) and brace_level > 0) or (not is_complex and not is_lookup)):\n        if text[end].isalnum() or text[end] == '_':\n            pass\n        elif not is_complex and not is_lookup and text[end] == '(' and text[part_start:end].isupper():\n            is_lookup = True\n            lookup_plugin_name = text[part_start:end]\n            part_start = end + 1\n        elif is_lookup and text[end] == '(':\n            brace_level += 1\n        elif is_lookup and text[end] == ')':\n            brace_level -= 1\n        elif is_lookup:\n            # lookups are allowed arbitrary contents\n            pass\n        elif is_complex and text[end] == '{':\n            brace_level += 1\n        elif is_complex and text[end] == '}':\n            brace_level -= 1\n        elif is_complex and text[end] in ('$', '[', ']'):\n            pass\n        elif is_complex and text[end] == '.':\n            if brace_level == 1:\n                space = _varFindLimitSpace(basedir, vars, space, text[part_start:end], lookup_fatal, depth)\n                part_start = end + 1\n        else:\n            # This breaks out of the loop on non-variable name characters\n            break\n        end += 1\n    var_end = end\n    # Handle \"This has $ in it\"\n    if var_end == part_start:\n        return {'replacement': None, 'start': start, 'end': end}\n\n    # Handle lookup plugins\n    if is_lookup:\n        # When basedir is None, handle lookup plugins later\n        if basedir is None:\n            return {'replacement': None, 'start': start, 'end': end}\n        var_end -= 1\n    \tfrom cirruscluster.ext.ansible import utils\n        args = text[part_start:var_end]\n        if lookup_plugin_name == 'LOOKUP':\n            lookup_plugin_name, args = args.split(\",\", 1)\n            args = args.strip()\n        # args have to be templated\n        args = varReplace(basedir, args, vars, depth=depth+1, expand_lists=True)\n        instance = utils.plugins.lookup_loader.get(lookup_plugin_name.lower(), basedir=basedir)\n        if instance is not None:\n            try:\n                replacement = instance.run(args, inject=vars)\n            except errors.AnsibleError:\n                if not lookup_fatal:\n                    replacement = None\n                else:\n                    raise\n        else:\n            replacement = None\n        return {'replacement': replacement, 'start': start, 'end': end}\n\n    if is_complex:\n        var_end -= 1\n        if text[var_end] != '}' or brace_level != 0:\n            return None\n    space = _varFindLimitSpace(basedir, vars, space, text[part_start:var_end], lookup_fatal, depth)\n    return {'replacement': space, 'start': start, 'end': end}"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nperform variable replacement of the values in string raw using vars dictionary.", "response": "def varReplace(basedir, raw, vars, lookup_fatal=True, depth=0, expand_lists=False):\n    ''' Perform variable replacement of $variables in string raw using vars dictionary '''\n    # this code originally from yum\n\n    if (depth > 20):\n        raise errors.AnsibleError(\"template recursion depth exceeded\")\n\n    done = [] # Completed chunks to return\n\n    while raw:\n        m = _varFind(basedir, raw, vars, lookup_fatal, depth)\n        if not m:\n            done.append(raw)\n            break\n\n        # Determine replacement value (if unknown variable then preserve\n        # original)\n\n        replacement = m['replacement']\n        if expand_lists and isinstance(replacement, (list, tuple)):\n            replacement = \",\".join(replacement)\n        if isinstance(replacement, (str, unicode)):\n            replacement = varReplace(basedir, replacement, vars, lookup_fatal, depth=depth+1, expand_lists=expand_lists)\n        if replacement is None:\n            replacement = raw[m['start']:m['end']]\n\n        start, end = m['start'], m['end']\n        done.append(raw[:start])          # Keep stuff leading up to token\n        done.append(unicode(replacement)) # Append replacement value\n        raw = raw[end:]                   # Continue with remainder of string\n\n    return ''.join(done)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef template_ds(basedir, varname, vars, lookup_fatal=True, depth=0):\n    ''' templates a data structure by traversing it and substituting for other data structures '''\n\n    if isinstance(varname, basestring):\n        m = _varFind(basedir, varname, vars, lookup_fatal, depth)\n        if not m:\n            return varname\n        if m['start'] == 0 and m['end'] == len(varname):\n            if m['replacement'] is not None:\n                return template_ds(basedir, m['replacement'], vars, lookup_fatal, depth)\n            else:\n                return varname\n        else:\n            return template(basedir, varname, vars, lookup_fatal)\n    elif isinstance(varname, (list, tuple)):\n        return [template_ds(basedir, v, vars, lookup_fatal, depth) for v in varname]\n    elif isinstance(varname, dict):\n        d = {}\n        for (k, v) in varname.iteritems():\n            d[k] = template_ds(basedir, v, vars, lookup_fatal, depth)\n        return d\n    else:\n        return varname", "response": "templates a data structure by traversing it and substituting for other data structures"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nrun a text buffer through the templating engine until it no longer changes", "response": "def template(basedir, text, vars, lookup_fatal=True, expand_lists=False):\n    ''' run a text buffer through the templating engine until it no longer changes '''\n\n    try:\n        text = text.decode('utf-8')\n    except UnicodeEncodeError:\n        pass # already unicode\n    text = varReplace(basedir, unicode(text), vars, lookup_fatal=lookup_fatal, expand_lists=expand_lists)\n    return text"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef template_from_file(basedir, path, vars):\n    ''' run a file through the templating engine '''\n\n    from cirruscluster.ext.ansible import utils\n    realpath = utils.path_dwim(basedir, path)\n    loader=jinja2.FileSystemLoader([basedir,os.path.dirname(realpath)])\n    environment = jinja2.Environment(loader=loader, trim_blocks=True)\n    for filter_plugin in utils.plugins.filter_loader.all():\n        filters = filter_plugin.filters()\n        if not isinstance(filters, dict):\n            raise errors.AnsibleError(\"FilterModule.filters should return a dict.\")\n        environment.filters.update(filters)\n    try:\n        data = codecs.open(realpath, encoding=\"utf8\").read()\n    except UnicodeDecodeError:\n        raise errors.AnsibleError(\"unable to process as utf-8: %s\" % realpath)\n    except:\n        raise errors.AnsibleError(\"unable to read %s\" % realpath)\n\n    # Get jinja env overrides from template\n    if data.startswith(JINJA2_OVERRIDE):\n        eol = data.find('\\n')\n        line = data[len(JINJA2_OVERRIDE):eol]\n        data = data[eol+1:]\n        for pair in line.split(','):\n            (key,val) = pair.split(':')\n            setattr(environment,key.strip(),val.strip())\n\n    environment.template_class = J2Template\n    t = environment.from_string(data)\n    vars = vars.copy()\n    try:\n        template_uid = pwd.getpwuid(os.stat(realpath).st_uid).pw_name\n    except:\n        template_uid = os.stat(realpath).st_uid\n    vars['template_host']   = os.uname()[1]\n    vars['template_path']   = realpath\n    vars['template_mtime']  = datetime.datetime.fromtimestamp(os.path.getmtime(realpath))\n    vars['template_uid']    = template_uid\n    vars['template_fullpath'] = os.path.abspath(realpath)\n    vars['template_run_date'] = datetime.datetime.now()\n\n    managed_default = C.DEFAULT_MANAGED_STR\n    managed_str = managed_default.format(\n                    host = vars['template_host'],\n                    uid  = vars['template_uid'],\n                    file = vars['template_path']\n                    )\n    vars['ansible_managed'] = time.strftime(managed_str,\n                                time.localtime(os.path.getmtime(realpath)))\n\n    # This line performs deep Jinja2 magic that uses the _jinja2_vars object for vars\n    # Ideally, this could use some API where setting shared=True and the object won't get\n    # passed through dict(o), but I have not found that yet.\n    res = jinja2.utils.concat(t.root_render_func(t.new_context(_jinja2_vars(basedir, vars, t.globals), shared=True)))\n\n    if data.endswith('\\n') and not res.endswith('\\n'):\n        res = res + '\\n'\n    return template(basedir, res, vars)", "response": "run a file through the templating engine"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add_locals(self, locals):\n        '''\n        If locals are provided, create a copy of self containing those\n        locals in addition to what is already in this variable proxy.\n        '''\n        if locals is None:\n            return self\n        return _jinja2_vars(self.basedir, self.vars, self.globals, locals, *self.extras)", "response": "Add locals to the variable proxy."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef error_code(self, code):\n\n\t\tcontext = {\n\t\t\t'error_title': \"Damn error page %i\" % code,\n\t\t\t'error_header': \"What has happened?\",\n\t\t\t'error_footer': \"WHY!?!?!\",\n\t\t\t'error_messages': {\n\t\t\t\t('Error %i' % code): self.__message__(code)\n\t\t\t}\n\t\t}\n\t\treturn WWebTemplateResponse(WTemplateText(self.__error_template__()), context=context)", "response": "This method returns a WWebTemplateResponse object with the error code."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nexpire a cache item.", "response": "def expire_cache(fragment_name, *args):\n    \"\"\"\n    Expire a cache item.\n    \n    @param url: The url object\n    @param product_names: A list of product names\n    @param start: The date from which the reporting should start.\n    @param stop: The date at which the reporting should stop.\n    \"\"\"\n    cache_key = make_template_fragment_key(fragment_name, args)\n    cache.delete(cache_key)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef start(self):\n        self.log.debug('Starting the installation process')\n\n        self.browser.open(self.url)\n\n        self.system_check()", "response": "Start the installation process"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nprovides admin login credentials", "response": "def admin(self):\n        \"\"\"\n        Provide admin login credentials\n        \"\"\"\n        self._check_title(self.browser.title())\n        self.browser.select_form(nr=0)\n\n        # Get the admin credentials\n        prompted = []\n        user = self.ctx.config.get('User', 'AdminUser')\n        if not user:\n            user = click.prompt('Admin display name')\n            prompted.append('user')\n\n        password = self.ctx.config.get('User', 'AdminPass')\n        if not password:\n            password = click.prompt('Admin password', hide_input=True, confirmation_prompt='Confirm admin password')\n            prompted.append('password')\n\n        email = self.ctx.config.get('User', 'AdminEmail')\n        if not email:\n            email = click.prompt('Admin email')\n            prompted.append('email')\n\n        self.browser.form[self.FIELD_ADMIN_USER] = user\n        self.browser.form[self.FIELD_ADMIN_PASS] = password\n        self.browser.form[self.FIELD_ADMIN_PASS_CONFIRM] = password\n        self.browser.form[self.FIELD_ADMIN_EMAIL] = email\n        p = Echo('Submitting admin information...')\n        self.browser.submit()\n        p.done()\n\n        if len(prompted) >= 3:\n            save = click.confirm('Would you like to save and use these admin credentials for future installations?')\n            if save:\n                self.log.info('Saving admin login credentials')\n                self.ctx.config.set('User', 'AdminUser', user)\n                self.ctx.config.set('User', 'AdminPass', password)\n                self.ctx.config.set('User', 'AdminEmail', email)\n                with open(self.ctx.config_path, 'wb') as cf:\n                    self.ctx.config.write(cf)\n\n        self.install()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef install(self):\n        self._start_install()\n        mr_link = self._get_mr_link()\n\n        # Set up the progress bar\n        pbar = ProgressBar(100, 'Running installation...')\n        pbar.start()\n        mr_j, mr_r = self._ajax(mr_link)\n\n        # Loop until we get a redirect json response\n        while True:\n            mr_link = self._parse_response(mr_link, mr_j)\n\n            stage = self._get_stage(mr_j)\n            progress = self._get_progress(mr_j)\n            mr_j, mr_r = self._ajax(mr_link)\n\n            pbar.update(min([progress, 100]), stage)  # NOTE: Response may return progress values above 100\n\n            # If we're done, finalize the installation and break\n            redirect = self._check_if_complete(mr_link, mr_j)\n            if redirect:\n                pbar.finish()\n                break\n\n        p = Echo('Finalizing...')\n        mr_r = self._request(redirect, raise_request=False)\n        p.done()\n\n        # Install developer tools\n        if self.site.in_dev:\n            DevToolsInstaller(self.ctx, self.site).install()\n\n        # Get the link to our community homepage\n        self._finalize(mr_r)", "response": "Install the developer tools and the community homepage."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate a pipe with FDs set CLOEXEC.", "response": "def pipe_cloexec():\n    \"\"\"Create a pipe with FDs set CLOEXEC.\"\"\"\n    # Pipes' FDs are set CLOEXEC by default because we don't want them\n    # to be inherited by other subprocesses: the CLOEXEC flag is removed\n    # from the child's FDs by _dup2(), between fork() and exec().\n    # This is not atomic: we would need the pipe2() syscall for that.\n    r, w = os.pipe()\n    _set_cloexec_flag(r)\n    _set_cloexec_flag(w)\n    return r, w"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_signature(self, base_commit=None):\n        if base_commit is None:\n            base_commit = 'HEAD'\n        self.run('add', '-A', self.path)\n        sha = self.run('rev-parse', '--verify', base_commit).strip()\n        diff = self.run('diff', sha).strip()\n        if len(diff) == 0:\n            try:\n                return self.get_signature(base_commit + '~1')\n            except CommandError:\n                pass\n        h = hashlib.sha1()\n        h.update(sha)\n        h.update(diff)\n        return h.hexdigest()", "response": "Get the signature of the current state of the repository."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ninstalls the repository hook for this repo.", "response": "def install_hook(self, hook_name, hook_content):\n        \"\"\"Install the repository hook for this repo.\n\n        Args:\n            hook_name (str)\n            hook_content (str)\n        \"\"\"\n        hook_path = os.path.join(self.path, '.git/hooks', hook_name)\n        with open(hook_path, 'w') as f:\n            f.write(hook_content)\n        os.chmod(hook_path, stat.S_IEXEC | stat.S_IREAD | stat.S_IWRITE)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_ignored_files(self):\n        return [os.path.join(self.path, p) for p in\n                self.run('ls-files', '--ignored', '--exclude-standard',\n                         '--others').strip().split()\n                ]", "response": "Returns the list of files being ignored in this repository."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef path_is_ignored(self, path):\n        try:\n            self.run('check-ignore', '--quiet', path)\n        except CommandError as e:\n            if e.retcode == 1:\n                # path is ignored\n                return False\n            else:\n                # fatal error\n                raise e\n        return True", "response": "Check if a path would be ignored."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns fully qualified name including module name except for the built - in module.", "response": "def _get_object_pydoc_page_name(obj):\n    \"\"\"Returns fully qualified name, including module name, except for the\n    built-in module.\"\"\"\n    page_name = fullqualname.fullqualname(obj)\n    if page_name is not None:\n       page_name = _remove_builtin_prefix(page_name)\n    return page_name"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _remove_builtin_prefix(name):\n    if name.startswith('builtins.'):\n        return name[len('builtins.'):]\n    elif name.startswith('__builtin__.'):\n        return name[len('__builtin__.'):]\n    return name", "response": "Strip name of builtin module from start of name."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget object from the user namespace given a path containing zero or more dots. Return None if the path is not valid.", "response": "def _get_user_ns_object(shell, path):\n    \"\"\"Get object from the user namespace, given a path containing\n    zero or more dots.  Return None if the path is not valid.\n    \"\"\"\n    parts = path.split('.', 1)\n    name, attr = parts[0], parts[1:]\n    if name in shell.user_ns:\n        if attr:\n            try:\n                return _getattr(shell.user_ns[name], attr[0])\n            except AttributeError:\n                return None\n        else:\n            return shell.user_ns[name]\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _stop_process(p, name):\n    # Based on code in IPython.core.magics.script.ScriptMagics.shebang\n    if p.poll() is not None:\n        print(\"{} is already stopped.\".format(name))\n        return\n    p.terminate()\n    time.sleep(0.1)\n    if p.poll() is not None:\n        print(\"{} is terminated.\".format(name))\n        return\n    p.kill()\n    print(\"{} is killed.\".format(name))", "response": "Stop process by applying terminate and kill."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nmonkeying - patched version of pydoc. cli so that pydoc can be run as a process.", "response": "def pydoc_cli_monkey_patched(port):\n    \"\"\"In Python 3, run pydoc.cli with builtins.input monkey-patched\n    so that pydoc can be run as a process.\n    \"\"\"\n\n    # Monkey-patch input so that input does not raise EOFError when\n    # called by pydoc.cli\n    def input(_):  # pylint: disable=W0622\n        \"\"\"Monkey-patched version of builtins.input\"\"\"\n        while 1:\n            time.sleep(1.0)\n\n    import builtins\n    builtins.input = input\n    sys.argv += [\"-p\", port]\n    pydoc.cli()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nstart the newtab server as a background process.", "response": "def start_server_background(port):\n    \"\"\"Start the newtab server as a background process.\"\"\"\n\n    if sys.version_info[0] == 2:\n        lines = ('import pydoc\\n'\n                 'pydoc.serve({port})')\n        cell = lines.format(port=port)\n    else:\n        # The location of newtabmagic (normally $IPYTHONDIR/extensions)\n        # needs to be added to sys.path.\n        path = repr(os.path.dirname(os.path.realpath(__file__)))\n        lines = ('import sys\\n'\n                 'sys.path.append({path})\\n'\n                 'import newtabmagic\\n'\n                 'newtabmagic.pydoc_cli_monkey_patched({port})')\n        cell = lines.format(path=path, port=port)\n\n    # Use script cell magic so that shutting down IPython stops\n    # the server process.\n    line = \"python --proc proc --bg --err error --out output\"\n    ip = get_ipython()\n    ip.run_cell_magic(\"script\", line, cell)\n\n    return ip.user_ns['proc']"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _port_not_in_use():\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    port = 0\n    s.bind(('', port))\n    _, port = s.getsockname()\n    return port", "response": "Use the port 0 trick to find a port not in use."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef start(self):\n        msg = ''\n        if not self.running():\n            if self._port == 0:\n                self._port = _port_not_in_use()\n            self._process = start_server_background(self._port)\n        else:\n            msg = 'Server already started\\n'\n        msg += 'Server running at {}'.format(self.url())\n        print(msg)", "response": "Start server if not already started."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreading stdout and stdout pipes if process is no longer running.", "response": "def read(self):\n        \"\"\"Read stdout and stdout pipes if process is no longer running.\"\"\"\n        if self._process and self._process.poll() is not None:\n            ip = get_ipython()\n            err = ip.user_ns['error'].read().decode()\n            out = ip.user_ns['output'].read().decode()\n        else:\n            out = ''\n            err = ''\n        return out, err"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef show(self):\n        msg = ''\n        if self._process:\n            msg += 'server pid: {}\\n'.format(self._process.pid)\n            msg += 'server poll: {}\\n'.format(self._process.poll())\n        msg += 'server running: {}\\n'.format(self.running())\n        msg += 'server port: {}\\n'.format(self._port)\n        msg += 'server root url: {}\\n'.format(self.url())\n        print(msg, end='')", "response": "Show state of the current process."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef start(self):\n        if self.isThreadsRunning:\n            raise ThreadManagerException(\"Broker threads are already running\")\n        self.isThreadsRunning = True\n        for client in self.clients:\n            threading.Thread(target = client).start()", "response": "Start all receiving threads."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef stop(self):\n        if not self.isThreadsRunning:\n            raise ThreadManagerException(\"Broker threads are already stopped\")\n        self.isThreadsRunning = False\n        for client in self.clients:\n            client.stop()", "response": "Stop all threads in broker."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef onConnect(self, client, userdata, flags, rc):\n        for sub in self.subsciption:\n            (result, mid) = self.client.subscribe(sub)", "response": "Callback for when the client receives a CONNACK response from the server."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef onMessage(self, client, userdata, msg):\n        dataIdentifier = DataIdentifier(self.broker, msg.topic)\n        self.dataHandler.onNewData(dataIdentifier, msg.payload)", "response": "This callback is called when a PUBLISH message is received from the server."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef createReceiverID(self):\n        _receiverID = self.receiverCounter\n        self.receiverCounter += 1\n        return BrokerReceiverID(self.hostname, self.pid, _receiverID)", "response": "Create a new receiver ID."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef determine_actions(self, request, view):\n        from rest_framework.generics import GenericAPIView\n        actions = {}\n        excluded_methods = {'HEAD', 'OPTIONS', 'PATCH', 'DELETE'}\n        for method in set(view.allowed_methods) - excluded_methods:\n            view.request = clone_request(request, method)\n            try:\n                if isinstance(view, GenericAPIView):\n                    has_object = view.lookup_url_kwarg or view.lookup_field in view.kwargs\n                elif method in {'PUT', 'POST'}:\n                    has_object = method in {'PUT'}\n                else:\n                    continue\n                # Test global permissions\n                if hasattr(view, 'check_permissions'):\n                    view.check_permissions(view.request)\n                # Test object permissions\n                if has_object and hasattr(view, 'get_object'):\n                    view.get_object()\n            except (exceptions.APIException, PermissionDenied, Http404):\n                pass\n            else:\n                # If user has appropriate permissions for the view, include\n                # appropriate metadata about the fields that should be supplied.\n                serializer = view.get_serializer()\n                actions[method] = self.get_serializer_info(serializer)\n            finally:\n                view.request = request\n\n        return actions", "response": "Determine the actions that should be performed for the current request."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncheck that the message content is within the configured length limit.", "response": "def is_within_content_length_limit(payload, api_config):\n        \"\"\"\n        Check that the message content is within the configured length limit.\n        \"\"\"\n        length_limit = api_config.get('content_length_limit')\n        if (length_limit is not None) and (payload[\"content\"] is not None):\n            content_length = len(payload[\"content\"])\n            if content_length > length_limit:\n                return \"Payload content too long: %s > %s\" % (\n                    content_length, length_limit)\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef handle_durability(parent, **kwargs):\n    persist_to = kwargs.get('persist_to')\n    replicate_to = kwargs.get('replicate_to')\n\n    if not persist_to and not replicate_to:\n        persist_to = parent._dur_persist_to\n        replicate_to = parent._dur_replicate_to\n\n    if not persist_to and not replicate_to:\n        return False, 0, 0\n\n    n_replicas = C.lcb_get_num_replicas(parent._lcbh)\n    if replicate_to > n_replicas or persist_to > n_replicas+1:\n        raise pycbc_exc_args('Durability requirements will never be satisfied')\n\n    return True, persist_to, replicate_to", "response": "Handles the durability requirements passed inside options\n   "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate a C key from a Python key.", "response": "def create_key(tc, pykey):\n    \"\"\"\n    Creates a C key from a Python key\n    :param tc: The transcoder to use\n    :param pykey: The python key to encode\n    :return: A tuple of `encoded_key, encoded_length`\n    \"\"\"\n    try:\n        k_enc = tc.encode_key(pykey)\n        if not k_enc:\n            if not pykey:\n                excls = ArgumentError\n            else:\n                excls = ValueFormatError\n            raise excls.pyexc(\"Key is empty\", obj=pykey)\n\n    except (ValueFormatError, ArgumentError):\n        raise\n    except Exception as e:\n        raise ValueFormatError.pyexc(inner=e)\n\n    s_key = ffi.new('char[]', k_enc)\n    return s_key, len(k_enc)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_option(name, key_options, global_options, default=None):\n    if key_options:\n        try:\n            return key_options[name]\n        except KeyError:\n            pass\n    if global_options:\n        try:\n            return global_options[name]\n        except KeyError:\n            pass\n\n    return default", "response": "Search the key - specific options and the global options for a given item."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef set_quiet(mres, parent, global_options):\n    quiet = global_options.get('quiet')\n    if quiet is not None:\n        mres._quiet = quiet\n    else:\n        mres._quiet = parent.quiet", "response": "Sets the quiet property on the MultiResult\n   "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_cas(key_options, global_options, item):\n    if item:\n        ign_cas = get_option('ignore_cas', key_options, globals(), False)\n        return 0 if ign_cas else item.cas\n    else:\n        try:\n            cas = key_options['cas']\n        except KeyError:\n            try:\n                cas = global_options['cas']\n            except KeyError:\n                return 0\n        if not cas:\n            return 0\n        return cas", "response": "Get the CAS from various inputs."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef process_opres_input(key, value, key_options):\n    opres = None\n\n    if isinstance(value, OperationResult):\n        opres = value\n    elif isinstance(key, OperationResult):\n        opres = key\n    elif isinstance(value, (long, int)):\n        key_options['cas'] = value\n\n    if opres is not None:\n        key = opres.key\n        key_options['cas'] = opres.cas\n    return key, value, key_options", "response": "Process the input value or key for the next operation."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nmake a single result which is then stored in the multi result object.", "response": "def make_result(self, key, value):\n        \"\"\"\n        Makes a single result which is then stored in the multi result object\n        :param key: The actual key for the command\n        :param value: The value passed (may be None)\n        :return: A result object\n        \"\"\"\n        v = OperationResult()\n        v.key = key\n        return v"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef submit_single(self, c_key, c_len, value, item, key_options, global_options, mres):\n        raise NotImplementedError()", "response": "Submit a single item to the MultiResult"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _invoke_submit(self, iterobj, is_dict, is_itmcoll, mres, global_kw):\n        if is_itmcoll:\n            item, key_options = next(iterobj)\n            key = item.key\n            value = item.value\n            result = item\n        else:\n            if is_dict:\n                key, value = next(iterobj)\n                if not self.VALUES_ALLOWED and not is_itmcoll:\n                    raise ArgumentError.pyexc(\n                        'Values not allowed for this command', obj=value)\n            else:\n                key = next(iterobj)\n                value = None\n\n            key_options = {}\n            item = None\n            result = self.make_result(key, value)\n\n        result.rc = -1\n\n        # Attempt to get the encoded key:\n        key, value, key_options = self.make_entry_params(key, value, key_options)\n        c_key, c_len = create_key(self.parent._tc, key)\n\n        rc = self.submit_single(c_key, c_len, value, item, key_options, global_kw, mres)\n        if rc:\n            raise pycbc_exc_lcb(rc)\n        try:\n            if key in mres and not self.DUPKEY_OK:\n                # For tests:\n                self.parent._warn_dupkey(key)\n\n            mres[key] = result\n        except TypeError:\n            raise pycbc_exc_enc(obj=key)", "response": "This method is invoked by the submit method in order to get the raw object returned from the iterator."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nexecute the operation scheduling items as needed", "response": "def execute(self, kv, **kwargs):\n        \"\"\"\n        Execute the operation scheduling items as needed\n        :param kv: An iterable of keys (or key-values, or Items)\n        :param kwargs: Settings for the operation\n        :return: A MultiResult object\n        \"\"\"\n        self._verify_iter(kv)\n        if not len(kv):\n            raise ArgumentError.pyexc(obj=kv, message=\"No items in container\")\n\n        if isinstance(kv, dict):\n            is_dict = True\n            try:\n                kviter = kv.iteritems()\n            except AttributeError:\n                kviter = iter(kv.items())\n        else:\n            is_dict = False\n            kviter = iter(kv)\n\n        is_itmcoll = isinstance(kv, ItemCollection)\n\n        mres = kwargs.get('_MRES')\n        if mres is None:\n            mres = self.parent._make_mres()\n\n        self.set_mres_flags(mres, kwargs)\n\n        C.lcb_sched_enter(self.instance)\n        num_items = 0\n        while True:\n            # Clear the previous command object\n            C.memset(self.c_command, 0, ffi.sizeof(self.c_command[0]))\n\n            try:\n                self._invoke_submit(kviter, is_dict, is_itmcoll, mres, kwargs)\n                num_items += 1\n            except StopIteration:\n                break\n            except:\n                C.lcb_sched_fail(self.instance)\n                raise\n\n        C.lcb_sched_leave(self.instance)\n        mres._remaining += num_items\n        # print \"Execute(): mres:\", mres\n        return mres"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef main(context, subject, debug, no_colors):\n    eho = Eh(debug, no_colors)\n    if subject == 'list':\n        eho.subject_list()\n        exit(0)\n    if subject == 'update':\n        eho.update_subject_repo()\n        exit(0)\n    eho.run(subject)\n    exit(0)", "response": "This is the main function for the main function of the main function."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef store_data(data):\n    with open(url_json_path) as json_file:\n        try:\n            json_file_data = load(json_file)\n            json_file_data.update(data)\n        except (AttributeError, JSONDecodeError):\n            json_file_data = data\n    with open(url_json_path, 'w') as json_file:\n        dump(json_file_data, json_file, indent=4, sort_keys=True)", "response": "Store data in a JSON file."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef default_to_hashed_rows(self, default=None):\n        if default is not None:\n            self._default_to_hashed_rows = (default is True)\n\n        return self._default_to_hashed_rows", "response": "Sets the _default_to_hashed_rows flag to True if the default value is set to False otherwise."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _update_internal_column_state(self, column_names):\n        for k in column_names:\n            if k not in self._column_name_idx:\n                self._column_name_idx[k] = len(self._column_name_list)\n                self._column_name_list.append(k)", "response": "Update the internal state with some new columns."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _add_dict_row(self, feature_dict, key=None):\n        self._update_internal_column_state(set(feature_dict.keys()))\n\n        # reset the row memoization\n        self._row_memo = {}\n\n        if key is not None:\n            if key in self._row_name_idx:\n                self._rows[self._row_name_idx[key]] = feature_dict\n                return\n            else:\n                self._row_name_idx[key] = len(self._rows)\n                self._row_name_list.append(key)\n\n        self._rows.append(feature_dict)", "response": "Adds a dict row to the matrix."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _add_list_row(self, feature_list, key=None):\n        if len(feature_list) > len(self._column_name_list):\n            raise IndexError(\"Input list must have %s columns or less\" % len(self._column_name_list))\n\n        # reset the row memoization\n        self._row_memo = {}\n\n        if key is not None:\n            if key in self._row_name_idx:\n                self._rows[self._row_name_idx[key]] = feature_list\n                return\n            else:\n                self._row_name_idx[key] = len(self._rows)\n                self._row_name_list.append(key)\n\n        self._rows.append(feature_list)", "response": "Adds a list row to the matrix."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_row_names(self, row_names):\n        if self.row_count() != len(row_names) or len(self._row_name_list) > 0 or len(self._row_name_idx) > 0:\n            raise NotImplementedError(\"You can only manually set names once data has been added\")\n\n        for idx, k in enumerate(row_names):\n            self._row_name_idx[k] = idx\n\n        self._row_name_list = row_names", "response": "Setup the feature vector with some column names\n       "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nadd a list or dict as a row in the FVM data structure.", "response": "def add_row(self, list_or_dict, key=None):\n        \"\"\" Adds a list or dict as a row in the FVM data structure\n\n        :param str key: key used when rows is a dict rather than an array\n        :param list_or_dict: a feature list or dict\n        \"\"\"\n        if isinstance(list_or_dict, list):\n            self._add_list_row(list_or_dict, key)\n        else:\n            self._add_dict_row(list_or_dict, key)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadds multiple rows at once at once.", "response": "def extend_rows(self, list_or_dict):\n        \"\"\" Add multiple rows at once\n\n        :param list_or_dict: a 2 dimensional structure for adding multiple rows at once\n        :return:\n        \"\"\"\n        if isinstance(list_or_dict, list):\n            for r in list_or_dict:\n                self.add_row(r)\n        else:\n            for k,r in list_or_dict.iteritems():\n                self.add_row(r, k)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_row_list(self, row_idx):\n\n        try:\n            row = self._rows[row_idx]\n        except TypeError:\n            row = self._rows[self._row_name_idx[row_idx]]\n\n        if isinstance(row, list):\n            extra = [ self._default_value ] * (len(self._column_name_list) - len(row))\n            return row + extra\n\n        else:\n            if row_idx not in self._row_memo:\n                self._row_memo[row_idx] = [ row[k] if k in row else self._default_value for k in self._column_name_list ]\n\n            return self._row_memo[row_idx]", "response": "get a list of feature values for the nth row in the table"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a dictionary representation of a matrix row.", "response": "def get_row_dict(self, row_idx):\n        \"\"\" Return a dictionary representation for a matrix row\n\n        :param row_idx: which row\n        :return: a dict of feature keys/values, not including ones which are the default value\n        \"\"\"\n\n        try:\n            row = self._rows[row_idx]\n        except TypeError:\n            row = self._rows[self._row_name_idx[row_idx]]\n\n        if isinstance(row, dict):\n            return row\n\n        else:\n            if row_idx not in self._row_memo:\n                self._row_memo[row_idx] = dict((self._column_name_list[idx], v) for idx, v in enumerate(row) if v != self._default_value)\n\n            return self._row_memo[row_idx]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_matrix(self):\n        return np.array([ self.get_row_list(i) for i in range(self.row_count()) ])", "response": "Use numpy to create a real matrix object from the data\n       "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef transpose(self):\n        if len(self._row_name_list) != len(self._rows):\n            raise NotImplementedError(\"You can't rotate a FVM that doesn't have all rows keyed\")\n\n        fvm = FeatureVectorMatrix(default_value=self._default_value, default_to_hashed_rows=self._default_to_hashed_rows)\n        fvm._update_internal_column_state(self._row_name_list)\n        for idx, r in enumerate(self.get_matrix().transpose()):\n            fvm.add_row(r.tolist(), self._column_name_list[idx])\n\n        return fvm", "response": "Create a matrix transpose it and then create a new FVM that is rotated from self."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef keys(self):\n        if len(self._row_name_list) != len(self._rows):\n            raise NotImplementedError(\"You can't get row keys for a FVM that doesn't have all rows keyed\")\n\n        return self.row_names()", "response": "Returns all row keys"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add(self, process, name=None):\n        name = name or process.name\n        assert name, \"No executable name given.\"\"\"\n        self._registry[name] = process", "response": "Add a new process to the registry."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef uni(key):\n    '''as a crutch, we allow str-type keys, but they really should be\n    unicode.\n\n    '''\n    if isinstance(key, str):\n        logger.warn('assuming utf8 on: %r', key)\n        return unicode(key, 'utf-8')\n    elif isinstance(key, unicode):\n        return key\n    else:\n        raise NonUnicodeKeyError(key)", "response": "assume unicode and return the key as a unicode object."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconvert a string from a script to transliteration and vice versa.", "response": "def convert(self, string, preprocess = None):\n        \"\"\"\n        Swap characters from a script to transliteration and vice versa. \n        Optionally sanitize string by using preprocess function.\n\n        :param preprocess:\n        :param string:\n        :return:\n        \"\"\"\n        string = unicode(preprocess(string) if preprocess else string, encoding=\"utf-8\")\n        if self.regex:\n            return self.regex.sub(lambda x: self.substitutes[x.group()], string).encode('utf-8')\n        else:\n            return string"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nloading input and cache the images", "response": "def interpret(self, msg):\n        \"\"\" Load input \"\"\"\n        slides = msg.get('slides', [])\n        self.cache = msg.get('folder')\n        self.gallery = msg.get('gallery', '..')\n\n        with open(self.cache + '/slides.txt', 'w') as logfile:\n            for ix, item in enumerate(slides):\n                image = self.prepare_image(item)\n                filename = self.cache_image(item, image)\n\n                text = item.get('caption', '')\n\n                # do not write text for heading images\n                if item.get('heading'):\n                    text = ''\n                    \n                if text:\n                    with open(filename + '.txt', 'w') as caption:\n                        caption.write(text)\n                print('%s,%d' % (filename, item.get('time', 0)), file=logfile)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating an image with a caption", "response": "def create_image(self, image_file, caption):\n        \"\"\" Create an image with a caption \"\"\"\n        suffix = 'png'\n        if image_file:\n            img = Image.open(os.path.join(self.gallery, image_file))\n            width, height = img.size\n            ratio = width/WIDTH\n            img = img.resize((int(width // ratio),\n                              int(height // ratio)),\n                             Image.ANTIALIAS)\n        else:\n            img = Image.new('RGB', (WIDTH, HEIGHT), 'black')\n            image = self.add_caption(img, caption)\n            \n        image = img\n\n        return image"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add_caption(self, image, caption, colour=None):\n\n        if colour is None:\n            colour = \"white\"\n    \n        width, height = image.size\n        draw = ImageDraw.Draw(image)\n\n        draw.font = self.font\n\n        draw.font = self.font\n        draw.text((width // 10, height//20), caption,\n                  fill=colour)\n\n        return image", "response": "Add a caption to the image"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the identifier for the current system.", "response": "def identifier(self):\n        # type: () -> str\n        \"\"\"[ID] Built-in HAR v1.2 Converter to loadimpact.com Lua scripts.\"\"\"\n        version = \"_\".join(self._version.split('.'))\n        return \"%s_%s\" % (self._namespace, version)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a Path from the path of caller file", "response": "def from_caller_file():\n        '''return a `Path` from the path of caller file'''\n        import inspect\n        curframe = inspect.currentframe()\n        calframe = inspect.getouterframes(curframe, 2)\n        filename = calframe[1].filename\n        if not os.path.isfile(filename):\n            raise RuntimeError('caller is not a file')\n        return Path(filename)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a Path from module root which include the caller", "response": "def from_caller_module_root():\n        '''return a `Path` from module root which include the caller'''\n        import inspect\n        all_stack = list(inspect.stack())\n        curframe = inspect.currentframe()\n        calframe = inspect.getouterframes(curframe, 2)\n        module = inspect.getmodule(calframe[1].frame)\n        if not module:\n            raise RuntimeError('caller is not a module')\n        root_module_name = module.__name__.partition('.')[0]\n        fullpath = sys.modules[root_module_name].__file__\n        return Path(fullpath)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef commitreturn(self,qstring,vals=()):\n    \"commit and return result. This is intended for sql UPDATE ... RETURNING\"\n    with self.withcur() as cur:\n      cur.execute(qstring,vals)\n      return cur.fetchone()", "response": "commit and return result. This is intended for sql UPDATE... RETURNING"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef getResponse(self, http_request, request):\n        response = remoting.Envelope(request.amfVersion)\n\n        for name, message in request:\n            http_request.amf_request = message\n\n            processor = self.getProcessor(message)\n            response[name] = processor(message, http_request=http_request)\n\n        return response", "response": "Processes the AMF request returning an AMF response."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget a driver for a Parker Motion Gemini drive.", "response": "def get_driver(driver='ASCII_RS232', *args, **keywords):\n    \"\"\" Gets a driver for a Parker Motion Gemini drive.\n\n    Gets and connects a particular driver in ``drivers`` to a Parker\n    Motion Gemini GV-6 or GT-6 servo/stepper motor drive.\n\n    The only driver currently supported is the ``'ASCII_RS232'`` driver\n    which corresponds to ``drivers.ASCII_RS232``.\n\n    Parameters\n    ----------\n    driver : str, optional\n        The driver to communicate to the particular driver with, which\n        includes the hardware connection and possibly the communications\n        protocol. The only driver currently supported is the\n        ``'ASCII_RS232'`` driver which corresponds to\n        ``drivers.ASCII_RS232``.\n    *args : additional positional arguments\n        Additional positional arguments to pass onto the constructor for\n        the driver.\n    **keywords : additional keyword arguments\n        Additional keyword arguments to pass onto the constructor for\n        the driver.\n\n    Returns\n    -------\n    drivers : drivers\n        The connected drivers class that is connected to the drive.\n\n    Raises\n    ------\n    NotImplementedError\n        If the `driver` is not supported.\n\n    See Also\n    --------\n    drivers\n    drivers.ASCII_RS232\n\n    \"\"\"\n    if driver.upper() == 'ASCII_RS232':\n        return drivers.ASCII_RS232(*args, **keywords)\n    else:\n        raise NotImplementedError('Driver not supported: '\n                                      + str(driver))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _get_parameter(self, name, tp, timeout=1.0, max_retries=2):\n        # Raise a TypeError if tp isn't one of the valid types.\n        if tp not in (bool, int, float):\n            raise TypeError('Only supports bool, int, and float; not '\n                      + str(tp))\n\n        # Sending a command of name queries the state for that\n        # parameter. The response will have name preceeded by an '*' and\n        # then followed by a number which will have to be converted.\n        response = self.driver.send_command(name, timeout=timeout,\n                                            immediate=True,\n                                            max_retries=max_retries)\n\n        # If the response has an error, there are no response lines, or\n        # the first response line isn't '*'+name; then there was an\n        # error and an exception needs to be thrown.\n        if self.driver.command_error(response) \\\n                or len(response[4]) == 0 \\\n                or not response[4][0].startswith('*' + name):\n            raise CommandError('Couldn''t retrieve parameter '\n                               + name)\n\n        # Extract the string representation of the value, which is after\n        # the '*'+name.\n        value_str = response[4][0][(len(name)+1):]\n\n        # Convert the value string to the appropriate type and return\n        # it. Throw an error if it is not supported.\n        if tp == bool:\n            return (value_str == '1')\n        elif tp == int:\n            return int(value_str)\n        elif tp == float:\n            return float(value_str)", "response": "Get the specified drive parameter."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset the specified parameter on the specified drive.", "response": "def _set_parameter(self, name, value, tp, timeout=1.0,\n                       max_retries=2):\n        \"\"\" Sets the specified drive parameter.\n\n        Sets a parameter on the drive. Only supports ``bool``,\n        ``int``, and ``float`` parameters.\n\n        Parameters\n        ----------\n        name : str\n            Name of the parameter to set. It is always the command to\n            set it when followed by the value.\n        value : bool, int, or float\n            Value to set the parameter to.\n        tp : type {bool, int, float}\n            The type of the parameter.\n        timeout : number, optional\n            Optional timeout in seconds to use when reading the\n            response. A negative value or ``None`` indicates that the\n            an infinite timeout should be used.\n        max_retries : int, optional\n            Maximum number of retries to do per command in the case of\n            errors.\n\n        Returns\n        -------\n        success : bool\n            Whether the last attempt to set the parameter was successful\n            (``True``) or not (``False`` meaning it had an error).\n\n        See Also\n        --------\n        _get_parameter : Get a parameter.\n\n        \"\"\"\n        # Return False if tp isn't one of the valid types.\n        if tp not in (bool, int, float):\n            return False\n\n        # Convert value to the string that the drive will expect. value\n        # must first be converted to the proper type before getting\n        # converted to str in the usual fasion. As bools need to be a\n        # '1' or a '0', it must be converted to int before going through\n        # str.\n        if tp == bool:\n            value_str = str(int(bool(value)))\n        elif tp == int:\n            value_str = str(int(value))\n        elif tp == float:\n            value_str = str(float(value))\n\n        # Immediately set the named parameter of the drive. The command\n        # is just the parameter name followed by the value string.\n        response = self.driver.send_command(name+value_str, \\\n            timeout=timeout, immediate=True, max_retries=max_retries)\n\n        # Return whether the setting was successful or not.\n        return not self.driver.command_error(response)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef pause(self, max_retries=0):\n        return (not self.driver.command_error(\n                self.driver.send_command('PS', timeout=1.0,\n                immediate=True, max_retries=max_retries)))", "response": "Pauses the drive (execution of commands).\n\n        Causes the drive to pause execution of commands till it is\n        unpaused. Commands will be queued until it is unpaused. Motion\n        is not stopped.\n\n        Parameters\n        ----------\n        max_retries : int, optional\n            Maximum number of retries to do to pause the drive in the\n            case of errors.\n\n        Returns\n        -------\n        success : bool\n            Whether the last pause command (last try or retry) was\n            successful (``True``) or not (``False`` meaning it had an\n            error).\n\n        Notes\n        -----\n        The command sent to the drive is '!C'.\n\n        See Also\n        --------\n        unpause : Unpause the drive."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting a program from the drive and returns its commands.", "response": "def get_program(self, n, timeout=2.0, max_retries=2):\n        \"\"\" Get a program from the drive.\n\n        Gets program 'n' from the drive and returns its commands.\n\n        Parameters\n        ----------\n        n : int\n            Which program to get.\n        timeout : number, optional\n            Optional timeout in seconds to use when reading the\n            response. A negative value or ``None`` indicates that the\n            an infinite timeout should be used.\n        max_retries : int, optional\n            Maximum number of retries to do per command in the case of\n            errors.\n\n        Returns\n        -------\n        commands : list of str\n            ``list`` of ``str`` commands making up the program. The\n            trailing 'END' is removed. Empty if there was an error.\n\n        Notes\n        -----\n        The command sent to the drive is '!TPROG PROGn'.\n\n        See Also\n        --------\n        set_program_profile : Sets a program or profile.\n        run_program_profile : Runs a program or profile.\n\n        \"\"\"\n        # Send the 'TPROG PROGn' command to read the program.\n        response = self.driver.send_command( \\\n            'TPROG PROG' + str(int(n)), timeout=timeout, \\\n            immediate=True, max_retries=max_retries)\n\n        # If there was an error, then return empty. Otherwise, return\n        # the response lines but strip the leading '*' first and the\n        # 'END' at the end of the list.\n        if self.driver.command_error(response) \\\n                or len(response[4]) == 0:\n            return []\n        else:\n            if '*END' in response[4]:\n                response[4].remove('*END')\n            return [line[1:] for line in response[4]]"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset a program or profile on the drive.", "response": "def set_program_profile(self, n, commands,\n                            program_or_profile='program',\n                            timeout=1.0, max_retries=0):\n        \"\"\" Sets a program/profile on the drive.\n\n        Sets program or profile 'n' on the drive to the sequence of\n        commands in 'commands'. If the existing program is identical, it\n        is not overwritten (can't check this for a profile). Returns\n        whether the program or profile was successfully set or not (if\n        the existing one is identical, it is considered a success).\n\n        Parameters\n        ----------\n        n : int\n            Which program to set.\n        commands : list or tuple of strings\n            ``list`` or ``tuple`` of commands to send to the drive. Each\n            command must be a string.\n        program_or_profile : {'program', 'profile'}, optional\n            Whether to read a program or a profile. Anything other than\n            these two values implies the default.\n        timeout : number, optional\n            Optional timeout in seconds to use when reading the\n            response. A negative value or ``None`` indicates that the\n            an infinite timeout should be used.\n        max_retries : int, optional\n            Maximum number of retries to do per command in the case of\n            errors.\n\n        Returns\n        -------\n        success : bool\n            Whether the program or profile was successfully set or not\n            (an identical program already existing on the drive is\n            considered a success).\n\n        Notes\n        -----\n        'commands' gets wrapped between ['DEL PROGn', 'DEF PROGn'] and\n        'END' or the equivalent profile ones.\n\n        See Also\n        --------\n        get_program : Gets a program.\n        run_program_profile : Runs a program or profile.\n\n        \"\"\"\n        # Grab the n'th program on the drive and strip commands. If we\n        # are doing a profile, None will be used as a placeholder.\n        if program_or_profile != 'profile':\n            current_program = self.get_program(n, timeout=timeout, \\\n                max_retries=max_retries+2)\n        else:\n            current_program = None\n        stripped_commands = utilities.strip_commands(commands)\n\n        # If the two are identical and we are doing a program, then\n        # nothing needs to be done and the program is already set\n        # (return True). Otherwise, it needs to be overwritten. If there\n        # were no errors on the last command, then it was written\n        # successfully. Otherwise, the program or profile needs to be\n        # terminated and then deleted.\n\n        if current_program is not None \\\n                and current_program == stripped_commands:\n            return True\n        else:\n            # Construct the End Of Responses for each command that will\n            # be sent. They are '\\n' for deletion and ending, but are\n            # '\\n- ' for the rest.\n            eor = ['\\n'] + (['\\n- '] * (1 + len(stripped_commands))) \\\n                + ['\\n']\n\n            # The commands consist of a header that tells which program\n            # or profile to set, the stripped commands, followed by an\n            # 'END'.\n            if program_or_profile != 'profile':\n                header = ['DEL PROG'+str(int(n)),\n                          'DEF PROG'+str(int(n))]\n            else:\n                header = ['DEL PROF'+str(int(n)),\n                          'DEF PROF'+str(int(n))]\n            responses = self.driver.send_commands(\\\n                header + stripped_commands + ['END'], \\\n                timeout=timeout, max_retries=max_retries, eor=eor)\n\n            # Check to see if it was set successfully. If it was (the\n            # last command had no errors), return True. Otherwise, the\n            # program or profile needs to be ended and deleted before\n            # returning False.\n            if not self.driver.command_error(responses[-1]):\n                return True\n            else:\n                if program_or_profile != 'profile':\n                    cmds = ['END', 'DEL PROG'+str(int(n))]\n                else:\n                    cmds = ['END', 'DEL PROF'+str(int(n))]\n                self.driver.send_commands(cmds, timeout=timeout,\n                                           max_retries=max_retries+2)\n                return False"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nrun a program or profile on the drive and returns the output of the command.", "response": "def run_program_profile(self, n, program_or_profile='program',\n                            timeout=10.0):\n        \"\"\" Runs a program/profile on the drive.\n\n        Runs program or profile 'n' on the drive, grabs its output, and\n        processes the output. The response from the drive is broken down\n        into the echoed command (drive echoes it back), any error\n        returned by the drive (leading '*' is stripped), and the\n        different lines of the response; which are all returned.\n\n        It is **VERY IMPORTANT** that 'timeout' is long enough for the\n        program to run if all the output from the drive is to be\n        collected.\n\n        Parameters\n        ----------\n        n : int\n            Which program to get.\n        program_or_profile : {'program', 'profile'}, optional\n            Whether to read a program or a profile. Anything other than\n            these two values implies the default.\n        timeout : number, optional\n            Optional timeout in seconds to use when reading the\n            response for running a program (set to 1.0 for a profile\n            regardless of what is given). A negative value or ``None``\n            indicates that the an infinite timeout should be used.\n\n        Returns\n        -------\n        output : list\n            A 5-element ``list``. The elements, in order, are the\n            sanitized command (``str``), the full response (``str``),\n            the echoed command (``str``), any error response (``None``\n            if none, or the ``str`` of the error), and the lines of the\n            response that are not the echo or error line (``list`` of\n            ``str`` with newlines stripped).\n\n        Notes\n        -----\n        Sends 'RUN PROGn' (program) or 'PRUN PROFn' (profile) as the\n        command to the drive. For a profile, the only output is that\n        command echoed back. For a program, it will echo back each\n        command in the program (preceeded by an '*' and followed by a\n        line feed as opposed to a carriage return).\n\n        See Also\n        --------\n        get_program : Gets a program.\n        set_program_profile : Sets a program or profile.\n\n        \"\"\"\n        if program_or_profile != 'profile':\n            return self.driver.send_command('RUN PROG' + str(int(n)), \\\n                timeout=timeout, immediate=True, eor='*END\\n')\n        else:\n            return self.driver.send_command( \\\n                'PRUN PROF' + str(int(n)), timeout=1.0, immediate=True)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef motion_commanded(self):\n        rsp = self.driver.send_command('TAS', immediate=True)\n        if self.driver.command_error(rsp) or len(rsp[4]) != 1 \\\n                or rsp[4][0][0:4] != '*TAS':\n            return False\n        else:\n            return (rsp[4][0][4] == '1')", "response": "Whether the current motion is commanded or not."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef apply_fixup_array(bin_view, fx_offset, fx_count, entry_size):\n    '''This function reads the fixup array and apply the correct values\n    to the underlying binary stream. This function changes the bin_view\n    in memory.\n\n    Args:\n        bin_view (memoryview of bytearray) - The binary stream\n        fx_offset (int) - Offset to the fixup array\n        fx_count (int) - Number of elements in the fixup array\n        entry_size (int) - Size of the MFT entry\n    '''\n    fx_array = bin_view[fx_offset:fx_offset+(2 * fx_count)]\n    #the array is composed of the signature + substitutions, so fix that\n    fx_len = fx_count - 1\n    #we can infer the sector size based on the entry size\n    sector_size = int(entry_size / fx_len)\n    index = 1\n    position = (sector_size * index) - 2\n    while (position <= entry_size):\n        if bin_view[position:position+2].tobytes() == fx_array[:2].tobytes():\n            #the replaced part must always match the signature!\n            bin_view[position:position+2] = fx_array[index * 2:(index * 2) + 2]\n        else:\n            _MOD_LOGGER.error(\"Error applying the fixup array\")\n            raise FixUpError(f\"Signature {fx_array[:2].tobytes()} does not match {bin_view[position:position+2].tobytes()} at offset {position}.\")\n        index += 1\n        position = (sector_size * index) - 2\n    _MOD_LOGGER.info(\"Fix up array applied successfully.\")", "response": "This function reads the fixup array and applies the correct values\n    to the underlying binary stream. This function reads the fixup array and applies the correct values\n    to the underlying binary stream."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef flatten(iterable):\n    '''This function allows a simple a way to iterate over a \"complex\" iterable, for example,\n    if the input [12, [23], (4, 3), \"lkjasddf\"], this will return an Iterable that returns\n    12, 23, 4, 3 and \"lkjasddf\".\n\n    Args:\n        iterable (Iterable) - A complex iterable that will be flattened\n\n    Returns:\n        (Iterable): An Iterable that flattens multiple interables'''\n    return itertools.chain.from_iterable(a if isinstance(a,Iterable) and not isinstance(a, str) else [a] for a in iterable)", "response": "This function flattens a complex iterable into a single iterable"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_file_size(file_object):\n    '''Returns the size, in bytes, of a file. Expects an object that supports\n    seek and tell methods.\n\n    Args:\n        file_object (file_object) - The object that represents the file\n\n    Returns:\n        (int): size of the file, in bytes'''\n    position = file_object.tell()\n\n    file_object.seek(0, 2)\n    file_size = file_object.tell()\n    file_object.seek(position, 0)\n\n    return file_size", "response": "Returns the size in bytes of a file. Expects an object that supports\n    seek and tell methods."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndecorate a given function to use as a context processor.", "response": "def context_processor(self, func):\n        \"\"\" Decorate a given function to use as a context processor.\n\n        ::\n            @app.ps.jinja2.context_processor\n            def my_context():\n                return {...}\n        \"\"\"\n        func = to_coroutine(func)\n        self.providers.append(func)\n        return func"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nregisters function to globals.", "response": "def register(self, value):\n        \"\"\" Register function to globals. \"\"\"\n        if self.env is None:\n            raise PluginException('The plugin must be installed to application.')\n\n        def wrapper(func):\n            name = func.__name__\n            if isinstance(value, str):\n                name = value\n            if callable(func):\n                self.env.globals[name] = func\n            return func\n\n        if callable(value):\n            return wrapper(value)\n\n        return wrapper"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nregisters function to filters.", "response": "def filter(self, value):\n        \"\"\" Register function to filters. \"\"\"\n        if self.env is None:\n            raise PluginException('The plugin must be installed to application.')\n\n        def wrapper(func):\n            name = func.__name__\n            if isinstance(value, str):\n                name = value\n            if callable(func):\n                self.env.filters[name] = func\n            return func\n\n        if callable(value):\n            return wrapper(value)\n\n        return wrapper"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsetting the logger if is not None and it is of type Logger.", "response": "def logger(self, logger):\n        \"\"\"Set the logger if is not None, and it is of type Logger.\"\"\"\n        if logger is None or not isinstance(logger, Logger):\n            raise ValueError(\"Logger can not be set to None, and must be of type logging.Logger\")\n\n        self._logger = logger"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef add_handler(self, type, actions, **kwargs):\n        l = self._events.get(type, [])\n        h = Handler(self, type, kwargs, actions)\n        l.append(h)\n        self._events[type] = l\n        return h", "response": "Add an event handler to be processed by this session."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef remove_handler(self, handler):\n        try:\n            self._events[handler.type].remove(handler)\n            return True\n        except ValueError:\n            return False", "response": "Removes a handler from the list."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd a pygame. KEYDOWN event handler.", "response": "def add_keydown(self, actions, **kwargs):\n        \"\"\"\n        Add a pygame.KEYDOWN event handler.\n\n        actions - The methods to be called when this key is pressed.\n\n        kwargs - The kwargs to be passed to self.add_handler.\n\n        See the documentation for self.add_handler for examples.\n        \"\"\"\n        return self.add_handler(pygame.KEYDOWN, actions, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding a keyup handler.", "response": "def add_keyup(self, actions, **kwargs):\n        \"\"\"See the documentation for self.add_keydown.\"\"\"\n        return self.add_handler(pygame.KEYUP, actions, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef change_event_params(self, handler, **kwargs):\n        if not isinstance(handler, Handler):\n            raise TypeError(\"given object must be of type Handler.\")\n        if not self.remove_handler(handler):\n            raise ValueError(\"You must pass in a valid handler that already exists.\")\n\n        self.add_handler(handler.type, handler.actions, **kwargs)\n        self.event = handler.event", "response": "This allows the client to change the parameters for an event."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef change_event_actions(self, handler, actions):\n        if not isinstance(handler, Handler):\n            raise TypeError(\"given object must be of type Handler.\")\n        if not self.remove_handler(handler):\n            raise ValueError(\"You must pass in a valid handler that already exists.\")\n\n        self.add_handler(handler.type, actions, handler.params)\n        self.event = handler.event", "response": "This allows the client to change the actions for an event."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndownloads a resource from the server.", "response": "def download(uri, user=None, password=None, saveas=None, ssl_verify=False,\n             get_args=None):\n    '''\n    FIXME: DOCS...\n    '''\n    if saveas is None:\n        temp = tempfile.NamedTemporaryFile(prefix='requests_', dir='/tmp')\n        saveas = temp.name\n        temp.close()\n\n    if not (user or password):\n        # Fall back to kerberos auth\n        logr.debug(\"Using Kerberos AUTH\")\n        auth = HTTPKerberosAuth(mutual_authentication=OPTIONAL)\n    else:\n        logr.debug(\"Using Basic AUTH\")\n        auth = HTTPBasicAuth(user, password)\n\n    with open(saveas, 'wb') as handle:\n        # pass in arguments as dict; requests knows what to do with them\n        r = rq.get(uri, verify=ssl_verify, auth=auth, data=get_args)\n        if not r.ok:\n            logr.error('[{}] {} ({})'.format(uri, r, r.text))\n            raise RuntimeError\n        for block in r.iter_content(1024):\n            if not block:\n                break\n            handle.write(block)\n    return saveas"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef extract(uid=None, base_url=None, use_default_email_domain=False,\n            default_email_domain=None, user=None, password=None):\n    '''\n    FIXME: DOCS...\n    '''\n    assert base_url and isinstance(base_url, (unicode, str))\n    export_url = os.path.join(base_url, 'export_csv')\n\n    # ded is shortform for \"default email domain\"\n    # this will convert uid's to  uid@default_email_domain.com\n    use_ded = use_default_email_domain\n    ded = default_email_domain\n\n    get_args = GET_ARGS.copy()\n    get_args['uid'] = uid\n    # pass get args as-is; requests handles them in dict form automatically\n    csv_path = download(export_url, user=user, password=password,\n                        get_args=get_args)\n\n    members_df = pd.read_csv(csv_path)\n\n    users = list(members_df['Kerberos'].unique())\n\n    # the team lead should be included as a member of their own team\n    users.append(uid)\n\n    if use_ded:\n        if not ded:\n            raise RuntimeError(\"No default email domain set!\")\n        users = ['@'.join((u, ded)) for u in users]\n\n    logr.info('{} members FOUND'.format(len(users)))\n\n    return sorted(users)", "response": "Extract a user from a Kerberos file."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get(self, bits=2048, type=crypto.TYPE_RSA, digest='sha1'):\n        self.log.debug('Creating a new self-signed SSL certificate')\n        # Generate the key and ready our cert\n        key = crypto.PKey()\n        key.generate_key(type, bits)\n        cert = crypto.X509()\n\n        # Fill in some pseudo certificate information with a wildcard common name\n        cert.get_subject().C  = 'US'\n        cert.get_subject().ST = 'California'\n        cert.get_subject().L  = 'Los Angeles'\n        cert.get_subject().O  = 'Wright Anything Agency'\n        cert.get_subject().OU = 'Law firm / talent agency'\n        cert.get_subject().CN = '*.{dn}'.format(dn=self.site.domain.name)\n\n        # Set the serial number, expiration and issued\n        cert.set_serial_number(1000)\n        cert.gmtime_adj_notBefore(0)\n        cert.gmtime_adj_notAfter(315360000)\n        cert.set_issuer(cert.get_subject())\n\n        # Map the key and sign our certificate\n        cert.set_pubkey(key)\n        cert.sign(key, digest)\n\n        # Dump the PEM data and return a certificate container\n        _cert = crypto.dump_certificate(crypto.FILETYPE_PEM, cert)\n        _key  = crypto.dump_privatekey(crypto.FILETYPE_PEM, key)\n\n        return Certificate(_cert, _key, type, bits, digest)", "response": "Create a new self - signed SSL certificate and return it"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconvert val to a compressed string.", "response": "def to_compressed_string(val, max_length=0):\n  \"\"\"Converts val to a compressed string.\n\n  A compressed string is one with no leading or trailing spaces.\n\n  If val is None, or is blank (all spaces) None is returned.\n\n  If max_length > 0 and  the stripped val is greater than max_length, val[:max_length] is returned.\n  \"\"\"\n  if val is None or len(val) == 0:\n    return None\n  rval = \" \".join(val.split())\n  if len(rval) == 0:\n    return None\n  if max_length == 0:\n    return rval\n  else:\n    return rval[:max_length]"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a function that first returns the start value and returns the previous value + step on Returns a function that first returns the start value and returns the previous value + step on \u2192 1", "response": "def incrementor(start=0, step=1):\n  \"\"\"Returns a function that first returns the start value, and returns previous value + step on\n  each subsequent call.\n  \"\"\"\n  def fxn(_):\n    \"\"\"Returns the next value in the sequnce defined by [start::step)\"\"\"\n    nonlocal start\n    rval = start\n    start += step\n    return rval\n  return fxn"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a function that accepts a value and returns index [ value ].", "response": "def index_resolver(index, strict=False):\n  \"\"\"Returns a function that accepts a value and returns index[value].\"\"\"\n  if strict:\n    return lambda id_: index[id_]\n  else:\n    return index.get"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nwraps a function returning a boolean value if successful.", "response": "def try_wrapper(fxn):\n  \"\"\"Wraps a function, returning (True, fxn(val)) if successful, (False, val) if not.\"\"\"\n  def wrapper(val):\n    \"\"\"Try to call fxn with the given value. If successful, return (True, fxn(val)), otherwise\n    returns (False, val).\n    \"\"\"\n    try:\n      return (True, fxn(val))\n    except Exception:\n      return (False, val)\n  return wrapper"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a list of Google calendar items for a specific user.", "response": "def get_google_calendar_items(user_id):\n    \"\"\"\n    Returns Google calendar items of a specific user\n\n    :param int user_id: (Humhub) User ID\n    :return: Busy appointments\n    :rtype: list\n    \"\"\"\n    global client_id\n    global client_secret\n\n    with open('tokens.json') as f:\n        try:\n            data = json.load(f)\n        except ValueError:\n            raise AccessTokenCredentialsError\n    credentials = GoogleCredentials(\n        data[str(user_id)]['access_token'],\n        client_id,\n        client_secret,\n        data[str(user_id)]['refresh_token'],\n        None,\n        \"https://accounts.google.com/o/oauth2/token\",\n        'my-user-agent/1.0'\n    )\n    service = build('calendar', 'v3', credentials=credentials)\n\n    page_token = None\n    # get utc time diff\n    utcdiff = (time.mktime(time.localtime()) - time.mktime(time.gmtime())) / 60 / 60\n    # check if diff is full-hour or half\n    minutes = utcdiff * 2\n    if minutes % 2: # full hour\n        minutesoffset = '30'\n    else: # half hour\n        minutesoffset = '00'\n    # check sign\n    if utcdiff < 0:\n        sign = '-'\n    else:\n        sign = '+'\n    utcdiff = str(abs(int(utcdiff))).zfill(2)\n    appointments = []\n    while True:\n        try:\n            calendar_list = service.events().list(\n                calendarId='primary', # TODO handle other calendars too\n                timeMin=time.strftime(\"%Y-%m-%dT00:00:00\")+sign+utcdiff+':'+minutesoffset,\n                timeMax=time.strftime(\"%Y-%m-%dT23:59:59\")+sign+utcdiff+':'+minutesoffset,\n                pageToken=page_token).execute()\n        except AccessTokenCredentialsError:\n            # re-auth\n            raise AccessTokenCredentialsError\n\n        # collect busy appointments\n        for calendar_list_entry in calendar_list['items']:\n            appointments.append({\"start\": calendar_list_entry['start']['dateTime'][:-6], \"end\": calendar_list_entry['end']['dateTime'][:-6]}) # remove utc diff\n        page_token = calendar_list.get('nextPageToken')\n        if not page_token:\n            break\n\n    return appointments\n\n\n    @app.route('/login')\n    def login():\n        \"\"\"\n        Handles login process, gets auth url\n\n        :return: Redirect to auth url\n        \"\"\"\n        global client\n        auth_uri = client.step1_get_authorize_url()\n        return redirect(auth_uri)\n\n\n    @app.route('/oauth2callback')\n    def oauth2callback():\n        \"\"\"\n        Handles token exchange, saves token\n\n        :return: Redirect to index\n        \"\"\"\n        code = request.args.get('code')\n        credentials = client.step2_exchange(code)\n\n        # save credentials\n        with open('tokens.json') as f:\n            try:\n                data = json.load(f)\n            except ValueError:\n                data = {}\n\n        token = {}\n        token['refresh_token'] = credentials.refresh_token\n        token['access_token'] = credentials.access_token\n        token['token_expiry'] = time.mktime(credentials.token_expiry.timetuple()) # read: datetime.fromtimestamp(<timestamp>)\n        data[session['user_id']] = token\n\n        # store credentials\n        with open('tokens.json', mode='w', encoding='utf-8') as jsonfile:\n            json.dump(data, jsonfile)\n\n        # redirect to index\n        return redirect(url_for('index'))\n\n\n    @app.route('/')\n    @app.route('/<int:user_id>')\n    def index(user_id = 0):\n        \"\"\"\n        Main page, displays calendar items if logged in, redirects to login otherwise\n\n        :param int user_id: (Humhub) User ID\n        \"\"\"\n        # check user id\n        if (user_id == 0):\n            if session is not None and 'user_id' in session and session['user_id'] is not None:\n                user_id = session['user_id']\n            else:\n                return \"No User ID specified.\"\n        else:\n            session['user_id'] = user_id\n\n        # check if token is available for user\n        with open('tokens.json') as f:\n            try:\n                data = json.load(f)\n            except ValueError:\n                return redirect(url_for('login'))\n        body = \"\"\n        if str(user_id) in data:\n            global client_id\n            global client_secret\n            credentials = GoogleCredentials(\n                data[str(user_id)]['access_token'],\n                client_id,\n                client_secret,\n                data[str(user_id)]['refresh_token'],\n                None,\n                \"https://accounts.google.com/o/oauth2/token\",\n                'my-user-agent/1.0'\n            )\n            #credentials = AccessTokenCredentials(data[str(user_id)]['access_token'], 'my-user-agent/1.0')\n            service = build('calendar', 'v3', credentials=credentials)\n\n            page_token = None\n            # get utc time diff\n            utcdiff = (time.mktime(time.localtime()) - time.mktime(time.gmtime())) / 60 / 60\n            # check if diff is full-hour or half\n            minutes = utcdiff * 2\n            if minutes % 2: # full hour\n                minutesoffset = '30'\n            else: # half hour\n                minutesoffset = '00'\n            # check sign\n            if utcdiff < 0:\n                sign = '-'\n            else:\n                sign = '+'\n            utcdiff = str(abs(int(utcdiff))).zfill(2)\n            appointments = []\n            while True:\n                try:\n                    calendar_list = service.events().list(\n                        calendarId='primary', # TODO handle other calendars too\n                        timeMin=time.strftime(\"%Y-%m-%dT00:00:00\")+sign+utcdiff+':'+minutesoffset,\n                        timeMax=time.strftime(\"%Y-%m-%dT23:59:59\")+sign+utcdiff+':'+minutesoffset,\n                        pageToken=page_token).execute()\n                except AccessTokenCredentialsError:\n                    # re-auth\n                    return redirect(url_for('login'))\n\n                for calendar_list_entry in calendar_list['items']:\n                    appointments.append({\"start\": calendar_list_entry['start']['dateTime'][:-6], \"end\": calendar_list_entry['end']['dateTime'][:-6]}) # remove utc diff\n                page_token = calendar_list.get('nextPageToken')\n                if not page_token:\n                    break\n\n            for event in appointments:\n                body += json.dumps(event)\n        else:\n            return redirect(url_for('login'))\n        return body"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngenerates a matching for WSGI application to serve static files for passed app.", "response": "def generate_static_matching(app,\n                             directory_serve_app=DirectoryApp):\n    \"\"\" Creating a matching for WSGI application to serve static files\n    for passed app.\n\n    Static files will be collected from directory named 'static'\n    under passed application::\n\n        ./blog/static/\n\n    This example is with an application named `blog`.\n    URLs for static files in static directory will begin with\n    /static/app_name/. so in blog app case, if the directory has\n    css/main.css file, the file will be published like this::\n\n         yoursite.com/static/blog/css/main.css\n\n    And you can get this URL by reversing form matching object::\n\n        matching.reverse('blog:static', path=['css', 'main.css'])\n    \"\"\"\n    static_dir = os.path.join(os.path.dirname(app.__file__),\n                              'static')\n    try:\n        static_app = directory_serve_app(static_dir, index_page='')\n    except OSError:\n        return None\n    static_pattern = '/static/{app.__name__}/*path'.format(app=app)\n    static_name = '{app.__name__}:static'.format(app=app)\n    return Matching(static_pattern, static_app, static_name)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_static_app_matching(apps):\n    return reduce(lambda a, b: a + b,\n                  [generate_static_matching(app)\n                   for app in apps if app is not None])", "response": "Returns a matching containing applications to serve static files\n    correspond to each passed application."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef find_location(loc_id=None, loc_name=None):\n        LOGGER.debug(\"LocationService.find_location\")\n        if (loc_id is None or not loc_id) and (loc_name is None or not loc_name):\n            raise exceptions.ArianeCallParametersError('id and name')\n\n        if (loc_id is not None and loc_id) and (loc_name is not None and loc_name):\n            LOGGER.warn('LocationService.find_location - Both id and name are defined. Will give you search on id.')\n            loc_name = None\n\n        params = None\n        if loc_id is not None and loc_id:\n            params = {'id': loc_id}\n        elif loc_name is not None and loc_name:\n            params = {'name': loc_name}\n\n        ret = None\n        if params is not None:\n            args = {'http_operation': 'GET', 'operation_path': 'get', 'parameters': params}\n            response = LocationService.requester.call(args)\n            if response.rc == 0:\n                ret = Location.json_2_location(response.response_content)\n            elif response.rc != 404:\n                err_msg = 'LocationService.find_location - Problem while finding location (id:' + str(loc_id) + \\\n                          ', name:' + str(loc_name) + '). ' \\\n                          'Reason: ' + str(response.response_content) + '-' + str(response.error_message) + \\\n                          \" (\" + str(response.rc) + \")\"\n                LOGGER.warning(err_msg)\n\n        return ret", "response": "find the location according location id or location name"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting all knows locations", "response": "def get_locations():\n        \"\"\"\n        :return: all knows locations\n        \"\"\"\n        LOGGER.debug(\"LocationService.get_locations\")\n        args = {'http_operation': 'GET', 'operation_path': ''}\n        response = LocationService.requester.call(args)\n        ret = None\n        if response.rc == 0:\n            ret = []\n            for location in response.response_content['locations']:\n                ret.append(Location.json_2_location(location))\n        else:\n            err_msg = 'LocationService.get_locations - Problem while getting locations. ' \\\n                      'Reason: ' + str(response.response_content) + '-' + str(response.error_message) + \\\n                      \" (\" + str(response.rc) + \")\"\n            LOGGER.warning(err_msg)\n        return ret"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef json_2_location(json_obj):\n        LOGGER.debug(\"Location.json_2_location\")\n        return Location(locid=json_obj['locationID'],\n                        name=json_obj['locationName'],\n                        description=json_obj['locationDescription'],\n                        address=json_obj['locationAddress'],\n                        zip_code=json_obj['locationZipCode'],\n                        town=json_obj['locationTown'],\n                        dc_type=json_obj['locationType'],\n                        country=json_obj['locationCountry'],\n                        gps_latitude=json_obj['locationGPSLat'],\n                        gps_longitude=json_obj['locationGPSLng'],\n                        routing_area_ids=json_obj['locationRoutingAreasID'],\n                        subnet_ids=json_obj['locationSubnetsID'])", "response": "Transform JSON obj coming from Ariane to ariane_clip3 Location object"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef location_2_json(self):\n        LOGGER.debug(\"Location.location_2_json\")\n        json_obj = {\n            'locationID': self.id,\n            'locationName': self.name,\n            'locationDescription': self.description,\n            'locationAddress': self.address,\n            'locationZipCode': self.zip_code,\n            'locationTown': self.town,\n            'locationType': self.type,\n            'locationCountry': self.country,\n            'locationGPSLat': self.gpsLatitude,\n            'locationGPSLng': self.gpsLongitude,\n            'locationRoutingAreasID': self.routing_area_ids,\n            'locationSubnetsID': self.subnet_ids\n        }\n        return json.dumps(json_obj)", "response": "transform ariane_clip3 location object to Ariane server JSON obj\n           "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nsynchronize this object with Ariane server according its id or name.", "response": "def sync(self):\n        \"\"\"\n        synchronize self from Ariane server according its id (prioritary) or name\n        :return:\n        \"\"\"\n        LOGGER.debug(\"Location.sync\")\n        params = None\n        if self.id is not None:\n            params = {'id': self.id}\n        elif self.name is not None:\n            params = {'name': self.name}\n\n        if params is not None:\n            args = {'http_operation': 'GET', 'operation_path': 'get', 'parameters': params}\n            response = LocationService.requester.call(args)\n            if response.rc == 0:\n                json_obj = response.response_content\n                self.id = json_obj['locationID']\n                self.name = json_obj['locationName']\n                self.description = json_obj['locationDescription']\n                self.address = json_obj['locationAddress']\n                self.zip_code = json_obj['locationZipCode']\n                self.town = json_obj['locationTown']\n                self.type = json_obj['locationType']\n                self.country = json_obj['locationCountry']\n                self.gpsLatitude = json_obj['locationGPSLat']\n                self.gpsLongitude = json_obj['locationGPSLng']\n                self.routing_area_ids = json_obj['locationRoutingAreasID']\n                self.subnet_ids = json_obj['locationSubnetsID']\n            else:\n                LOGGER.warning('Location.sync - Problem while syncing location (name:' +\n                               self.name + ', id: ' + str(self.id) + '). ' +\n                               'Reason: ' + str(response.response_content) + '-' + str(response.error_message) +\n                               \" (\" + str(response.rc) + \")\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nadds a routing area to this location.", "response": "def add_routing_area(self, routing_area, sync=True):\n        \"\"\"\n        add a routing area to this location.\n        :param routing_area: the routing area to add on this location\n        :param sync: If sync=True(default) synchronize with Ariane server. If sync=False,\n        add the routing area object on list to be added on next save().\n        :return:\n        \"\"\"\n        LOGGER.debug(\"Location.add_routing_area\")\n        if not sync:\n            self.routing_areas_2_add.append(routing_area)\n        else:\n            if self.id is not None and routing_area.id is None:\n                routing_area.save()\n            if self.id is not None and routing_area.id is not None:\n                params = {\n                    'id': self.id,\n                    'routingareaID': routing_area.id\n                }\n                args = {'http_operation': 'GET', 'operation_path': 'update/routingareas/add', 'parameters': params}\n                response = LocationService.requester.call(args)\n                if response.rc != 0:\n                    LOGGER.warning(\n                        'Location.add_routing_area - Problem while updating location ' + self.name +\n                        '. Reason: ' + str(response.response_content) + '-' + str(response.error_message) +\n                        \" (\" + str(response.rc) + \")\"\n                    )\n                else:\n                    self.routing_area_ids.append(routing_area.id)\n                    routing_area.loc_ids.append(self.id)\n            else:\n                LOGGER.warning(\n                    'Location.add_routing_area - Problem while updating location ' + self.name +\n                    '. Reason: routing area ' + routing_area.name + ' id is None or self.id is None.'\n                )"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef del_routing_area(self, routing_area, sync=True):\n        LOGGER.debug(\"Location.del_routing_area\")\n        if not sync:\n            self.routing_areas_2_rm.append(routing_area)\n        else:\n            if self.id is not None and routing_area.id is None:\n                routing_area.sync()\n            if self.id is not None and routing_area.id is not None:\n                params = {\n                    'id': self.id,\n                    'routingareaID': routing_area.id\n                }\n                args = {'http_operation': 'GET', 'operation_path': 'update/routingareas/delete', 'parameters': params}\n                response = LocationService.requester.call(args)\n                if response.rc != 0:\n                    LOGGER.warning(\n                        'Location.del_routing_area - Problem while updating location ' + self.name +\n                        '. Reason: ' + str(response.response_content) + '-' + str(response.error_message) +\n                        \" (\" + str(response.rc) + \")\"\n                    )\n                else:\n                    self.routing_area_ids.remove(routing_area.id)\n                    routing_area.loc_ids.remove(self.id)\n            else:\n                LOGGER.warning(\n                    'Location.del_routing_area - Problem while updating location ' + self.name +\n                    '. Reason: routing area ' + routing_area.name + ' id is None'\n                )", "response": "This method deletes the routing area from this location."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsave this location on Ariane server.", "response": "def save(self):\n        \"\"\"\n        :return: save this location on Ariane server (create or update)\n            'locationID': self.id,\n            'locationName': self.name,\n            'locationDescription': self.description,\n            'locationAddress': self.address,\n            'locationZipCode': self.zip_code,\n            'locationTown': self.town,\n            'locationType': self.type,\n            'locationCountry': self.country,\n            'locationGPSLat': self.gpsLatitude,\n            'locationGPSLng': self.gpsLongitude,\n            'locationRoutingAreasID': self.routing_area_ids,\n            'locationSubnetsID': self.subnet_ids\n        \"\"\"\n        LOGGER.debug(\"Location.save\")\n        post_payload = {}\n        consolidated_ra_id = []\n        consolidated_sn_id = []\n\n        if self.id is not None:\n            post_payload['locationID'] = self.id\n\n        if self.name is not None:\n            post_payload['locationName'] = self.name\n\n        if self.description is not None:\n            post_payload['locationDescription'] = self.description\n\n        if self.type is not None:\n            post_payload['locationType'] = self.type\n\n        if self.address is not None:\n            post_payload['locationAddress'] = self.address\n\n        if self.zip_code is not None:\n            post_payload['locationZipCode'] = self.zip_code\n\n        if self.town is not None:\n            post_payload['locationTown'] = self.town\n\n        if self.country is not None:\n            post_payload['locationCountry'] = self.country\n\n        if self.gpsLatitude is not None:\n            post_payload['locationLatitude'] = self.gpsLatitude\n\n        if self.gpsLongitude is not None:\n            post_payload['locationLongitude'] = self.gpsLongitude\n\n        if self.routing_area_ids is not None:\n            consolidated_ra_id = copy.deepcopy(self.routing_area_ids)\n        if self.routing_areas_2_rm is not None:\n            for ra_2_rm in self.routing_areas_2_rm:\n                if ra_2_rm.id is None:\n                    ra_2_rm.sync()\n                consolidated_ra_id.remove(ra_2_rm.id)\n        if self.routing_areas_2_add is not None:\n            for ra_2_add in self.routing_areas_2_add:\n                if ra_2_add.id is None:\n                    ra_2_add.save()\n                consolidated_ra_id.append(ra_2_add.id)\n        post_payload['locationRoutingAreasID'] = consolidated_ra_id\n\n        if self.subnet_ids is not None:\n            consolidated_sn_id = copy.deepcopy(self.subnet_ids)\n        if self.subnets_2_rm is not None:\n            for sn_2_rm in self.subnets_2_rm:\n                if sn_2_rm.id is None:\n                    sn_2_rm.sync()\n                consolidated_sn_id.remove(sn_2_rm.id)\n        if self.subnets_2_add is not None:\n            for sn_2_add in self.subnets_2_add:\n                if sn_2_add.id is None:\n                    sn_2_add.save()\n                consolidated_sn_id.append(sn_2_add.id)\n        post_payload['locationSubnetsID'] = consolidated_sn_id\n\n        args = {'http_operation': 'POST', 'operation_path': '', 'parameters': {'payload': json.dumps(post_payload)}}\n        response = LocationService.requester.call(args)\n        if response.rc != 0:\n            LOGGER.warning('Location.save - Problem while saving location ' + self.name +\n                           '. Reason: ' + str(response.response_content) + '-' + str(response.error_message) +\n                           \" (\" + str(response.rc) + \")\")\n        else:\n            self.id = response.response_content['locationID']\n            if self.routing_areas_2_add is not None:\n                for ra_2_add in self.routing_areas_2_add:\n                    ra_2_add.sync()\n            if self.routing_areas_2_rm is not None:\n                for ra_2_rm in self.routing_areas_2_rm:\n                    ra_2_rm.sync()\n            if self.subnets_2_add is not None:\n                for sn_2_add in self.subnets_2_add:\n                    sn_2_add.sync()\n            if self.subnets_2_rm is not None:\n                for sn_2_rm in self.subnets_2_rm:\n                    sn_2_rm.sync()\n        self.routing_areas_2_rm.clear()\n        self.routing_areas_2_add.clear()\n        self.subnets_2_add.clear()\n        self.subnets_2_rm.clear()\n        self.sync()\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef find_routing_area(ra_id=None, ra_name=None):\n        LOGGER.debug(\"RoutingAreaService.find_routing_area\")\n        if (ra_id is None or not ra_id) and (ra_name is None or not ra_name):\n            raise exceptions.ArianeCallParametersError('id and name')\n\n        if (ra_id is not None and ra_id) and (ra_name is not None and ra_name):\n            LOGGER.warn('RoutingAreaService.find_routing_area - Both id and name are defined. '\n                        'Will give you search on id.')\n            ra_name = None\n\n        params = None\n        if ra_id is not None and ra_id:\n            params = {'id': ra_id}\n        elif ra_name is not None and ra_name:\n            params = {'name': ra_name}\n\n        ret = None\n        if params is not None:\n            args = {'http_operation': 'GET', 'operation_path': 'get', 'parameters': params}\n            response = RoutingAreaService.requester.call(args)\n            if response.rc == 0:\n                ret = RoutingArea.json_2_routing_area(response.response_content)\n            elif response.rc != 404:\n                err_msg = 'RoutingAreaService.find_routing_area - Problem while finding routing area (id:' + \\\n                          str(ra_id) + ', name:' + str(ra_name) + '). ' + \\\n                          'Reason: ' + str(response.response_content) + '-' + str(response.error_message) + \\\n                          \" (\" + str(response.rc) + \")\"\n                LOGGER.warning(\n                    err_msg\n                )\n\n        return ret", "response": "find routing area according routing area id or name"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_routing_areas():\n        LOGGER.debug(\"RoutingAreaService.get_routing_areas\")\n        args = {'http_operation': 'GET', 'operation_path': ''}\n        response = RoutingAreaService.requester.call(args)\n        ret = None\n        if response.rc == 0:\n            ret = []\n            for routing_area in response.response_content['routingAreas']:\n                ret.append(RoutingArea.json_2_routing_area(routing_area))\n        elif response.rc != 404:\n            err_msg = 'RoutingAreaService.get_routing_areas - Problem while getting routing areas. ' \\\n                      'Reason: ' + str(response.response_content) + '-' + str(response.error_message) + \\\n                      \" (\" + str(response.rc) + \")\"\n            LOGGER.warning(err_msg)\n        return ret", "response": "Get all routing areas."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef json_2_routing_area(json_obj):\n        LOGGER.debug(\"RoutingArea.json_2_routing_area\")\n        return RoutingArea(raid=json_obj['routingAreaID'],\n                           name=json_obj['routingAreaName'],\n                           description=json_obj['routingAreaDescription'],\n                           ra_type=json_obj['routingAreaType'],\n                           multicast=json_obj['routingAreaMulticast'],\n                           routing_area_loc_ids=json_obj['routingAreaLocationsID'],\n                           routing_area_subnet_ids=json_obj['routingAreaSubnetsID'])", "response": "Transform the JSON obj coming from Ariane to ariane_clip3 RoutingArea object"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef routing_area_2_json(self):\n        LOGGER.debug(\"RoutingArea.routing_area_2_json\")\n        json_obj = {\n            'routingAreaID': self.id,\n            'routingAreaName': self.name,\n            'routingAreaDescription': self.description,\n            'routingAreaType': self.type,\n            'routingAreaMulticast': self.multicast,\n            'routingAreaLocationsID': self.loc_ids,\n            'routingAreaSubnetsID': self.subnet_ids\n        }\n        return json.dumps(json_obj)", "response": "transform ariane_clip3 routing area object to Ariane server JSON obj\n           "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef sync(self):\n        LOGGER.debug(\"RoutingArea.sync\")\n        params = None\n        if self.id is not None:\n            params = {'id': self.id}\n        elif self.name is not None:\n            params = {'name': self.name}\n\n        if params is not None:\n            args = {'http_operation': 'GET', 'operation_path': 'get', 'parameters': params}\n            response = RoutingAreaService.requester.call(args)\n            if response.rc == 0:\n                json_obj = response.response_content\n                self.id = json_obj['routingAreaID']\n                self.name = json_obj['routingAreaName']\n                self.description = json_obj['routingAreaDescription']\n                self.type = json_obj['routingAreaType']\n                self.multicast = json_obj['routingAreaMulticast']\n                self.loc_ids = json_obj['routingAreaLocationsID']\n                self.subnet_ids = json_obj['routingAreaSubnetsID']\n            else:\n                LOGGER.warning(\n                    'RoutingArea.sync - Problem while syncing routing area (name:' + self.name + ', id:' +\n                    str(self.id) + '). Reason: ' + str(response.response_content) + '-' + str(response.error_message) +\n                    \" (\" + str(response.rc) + \")\"\n                )", "response": "Synchronizes this object with Ariane server according its id or name."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadd a location to this routing area.", "response": "def add_location(self, location, sync=True):\n        \"\"\"\n        add a location to this routing area.\n        :param location: the location to add on this routing area\n        :param sync: If sync=True(default) synchronize with Ariane server. If sync=False,\n        add the location object on list to be added on next save().\n        :return:\n        \"\"\"\n        LOGGER.debug(\"RoutingArea.add_location\")\n        if not sync:\n            self.loc_2_add.append(location)\n        else:\n            if location.id is None:\n                location.save()\n            if self.id is not None and location.id is not None:\n                params = {\n                    'id': self.id,\n                    'locationID': location.id\n                }\n                args = {'http_operation': 'GET', 'operation_path': 'update/locations/add', 'parameters': params}\n                response = RoutingAreaService.requester.call(args)\n                if response.rc != 0:\n                    LOGGER.warning(\n                        'RoutingArea.add_location - Problem while updating routing area ' + self.name +\n                        '. Reason: ' + str(response.response_content) + '-' + str(response.error_message) +\n                        \" (\" + str(response.rc) + \")\"\n                    )\n                else:\n                    self.loc_ids.append(location.id)\n                    location.routing_area_ids.append(self.id)\n            else:\n                LOGGER.warning(\n                    'RoutingArea.add_location - Problem while updating routing area ' + self.name +\n                    '. Reason: location ' + location.name + ' id is None or self.id is None'\n                )"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef del_location(self, location, sync=True):\n        LOGGER.debug(\"RoutingArea.del_location\")\n        if not sync:\n            self.loc_2_rm.append(location)\n        else:\n            if location.id is None:\n                location.sync()\n            if self.id is not None and location.id is not None:\n                params = {\n                    'id': self.id,\n                    'locationID': location.id\n                }\n                args = {'http_operation': 'GET', 'operation_path': 'update/locations/delete', 'parameters': params}\n                response = RoutingAreaService.requester.call(args)\n                if response.rc != 0:\n                    LOGGER.warning(\n                        'RoutingArea.del_location - Problem while updating routing area ' + self.name +\n                        '. Reason: ' + str(response.response_content) + '-' + str(response.error_message) +\n                        \" (\" + str(response.rc) + \")\"\n                    )\n                else:\n                    self.loc_ids.remove(location.id)\n                    location.routing_area_ids.remove(self.id)\n            else:\n                LOGGER.warning(\n                    'RoutingArea.del_location - Problem while updating routing area ' +\n                    self.name + '. Reason: location ' +\n                    location.name + ' id is None or self.id is None'\n                )", "response": "This method deletes a location from this routing area."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef save(self):\n        LOGGER.debug(\"RoutingArea.save\")\n        post_payload = {}\n        consolidated_loc_id = []\n\n        if self.id is not None:\n            post_payload['routingAreaID'] = self.id\n\n        if self.name is not None:\n            post_payload['routingAreaName'] = self.name\n\n        if self.description is not None:\n            post_payload['routingAreaDescription'] = self.description\n\n        if self.type is not None:\n            post_payload['routingAreaType'] = self.type\n\n        if self.multicast is not None:\n            post_payload['routingAreaMulticast'] = self.multicast\n\n        if self.loc_ids is not None:\n            consolidated_loc_id = copy.deepcopy(self.loc_ids)\n        if self.loc_2_rm is not None:\n            for loc_2_rm in self.loc_2_rm:\n                if loc_2_rm.id is None:\n                    loc_2_rm.sync()\n                consolidated_loc_id.remove(loc_2_rm.id)\n        if self.loc_2_add is not None:\n            for loc_2_add in self.loc_2_add:\n                if loc_2_add.id is None:\n                    loc_2_add.save()\n                consolidated_loc_id.append(loc_2_add.id)\n        post_payload['routingAreaLocationsID'] = consolidated_loc_id\n\n        if self.subnet_ids is not None:\n            post_payload['routingAreaSubnetsID'] = self.subnet_ids\n\n        args = {'http_operation': 'POST', 'operation_path': '', 'parameters': {'payload': json.dumps(post_payload)}}\n        response = RoutingAreaService.requester.call(args)\n        if response.rc != 0:\n            LOGGER.warning(\n                'RoutingArea.save - Problem while saving routing area' + self.name +\n                '. Reason: ' + str(response.response_content) + '-' + str(response.error_message) +\n                \" (\" + str(response.rc) + \")\"\n            )\n        else:\n            self.id = response.response_content['routingAreaID']\n            if self.loc_2_add is not None:\n                for loc_2_add in self.loc_2_add:\n                    loc_2_add.sync()\n            if self.loc_2_rm is not None:\n                for loc_2_rm in self.loc_2_rm:\n                    loc_2_rm.sync()\n        self.loc_2_add.clear()\n        self.loc_2_rm.clear()\n        self.sync()\n        return self", "response": "Save this routing area on Ariane server."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfinds the subnet according subnet id or name", "response": "def find_subnet(sb_id=None, sb_name=None):\n        \"\"\"\n        find the subnet according subnet id (prioritary) or subnet name\n        :param sb_id: the subnet id\n        :param sb_name: the subnet name\n        :return: found subnet or None if not found\n        \"\"\"\n        LOGGER.debug(\"SubnetService.find_subnet\")\n        if (sb_id is None or not sb_id) and (sb_name is None or not sb_name):\n            raise exceptions.ArianeCallParametersError('id and name')\n\n        if (sb_id is not None and sb_id) and (sb_name is not None and sb_name):\n            LOGGER.warn('Both id and name are defined. Will give you search on id.')\n            sb_name = None\n\n        params = None\n        if sb_id is not None and sb_id:\n            params = {'id': sb_id}\n        elif sb_name is not None and sb_name:\n            params = {'name': sb_name}\n\n        ret = None\n        if params is not None:\n            args = {'http_operation': 'GET', 'operation_path': 'get', 'parameters': params}\n            response = SubnetService.requester.call(args)\n            if response.rc == 0:\n                ret = Subnet.json_2_subnet(response.response_content)\n            elif response.rc != 404:\n                err_msg = 'SubnetService.find_subnet - Problem while finding subnet (id:' + str(sb_id) + \\\n                          ', name:' + str(sb_name) + '). ' + \\\n                          '. Reason: ' + str(response.response_content) + '-' + str(response.error_message) + \\\n                          \" (\" + str(response.rc) + \")\"\n                LOGGER.warning(err_msg)\n\n        return ret"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget all knows subnets", "response": "def get_subnets():\n        \"\"\"\n        :return: all knows subnets\n        \"\"\"\n        LOGGER.debug(\"SubnetService.get_subnets\")\n        args = {'http_operation': 'GET', 'operation_path': ''}\n        response = SubnetService.requester.call(args)\n        ret = None\n        if response.rc == 0:\n            ret = []\n            for subnet in response.response_content['subnets']:\n                ret.append(Subnet.json_2_subnet(subnet))\n        elif response.rc != 404:\n            err_msg = 'SubnetService.get_subnets - Problem while getting subnets. ' \\\n                      '. Reason: ' + str(response.response_content) + '-' + str(response.error_message) + \\\n                      \" (\" + str(response.rc) + \")\"\n            LOGGER.warning(err_msg)\n        return ret"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef json_2_subnet(json_obj):\n        LOGGER.debug(\"Subnet.json_2_subnet\")\n        return Subnet(subnetid=json_obj['subnetID'],\n                      name=json_obj['subnetName'],\n                      description=json_obj['subnetDescription'],\n                      ip=json_obj['subnetIP'],\n                      mask=json_obj['subnetMask'],\n                      routing_area_id=json_obj['subnetRoutingAreaID'],\n                      ip_address_ids=json_obj['subnetIPAddressesID'],\n                      subnet_loc_ids=json_obj['subnetLocationsID'],\n                      subnet_osi_ids=json_obj['subnetOSInstancesID'])", "response": "Transform JSON obj coming from Ariane to ariane_clip3 Subnet object"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ntransforms ariane_clip3 subnet object to Ariane server JSON obj", "response": "def subnet_2_json(self):\n        \"\"\"\n        transform ariane_clip3 subnet object to Ariane server JSON obj\n        :return: Ariane JSON obj\n        \"\"\"\n        LOGGER.debug(\"Subnet.subnet_2_json\")\n        json_obj = {\n            'subnetID': self.id,\n            'subnetName': self.name,\n            'subnetDescription': self.description,\n            'subnetIP': self.ip,\n            'subnetMask': self.mask,\n            'subnetRoutingAreaID': self.routing_area_id,\n            'subnetIPAddressesID': self.ipAddress_ids,\n            'subnetLocationsID': self.loc_ids,\n            'subnetOSInstancesID': self.osi_ids\n        }\n        return json.dumps(json_obj)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsynchronizing this subnet with Ariane server according its id or name.", "response": "def sync(self):\n        \"\"\"\n        synchronize self from Ariane server according its id (prioritary) or name\n        :return:\n        \"\"\"\n        LOGGER.debug(\"Subnet.sync\")\n        params = None\n        if self.id is not None:\n            params = {'id': self.id}\n        elif self.name is not None:\n            params = {'name': self.name}\n\n        if params is not None:\n            args = {'http_operation': 'GET', 'operation_path': 'get', 'parameters': params}\n            response = SubnetService.requester.call(args)\n            if response.rc != 0:\n                LOGGER.warning(\n                    'Subnet.sync - Problem while syncing subnet (name:' + self.name + ', id:' + str(self.id) +\n                    '). Reason: ' + str(response.response_content) + '-' + str(response.error_message) +\n                    \" (\" + str(response.rc) + \")\"\n                )\n            else:\n                json_obj = response.response_content\n                self.id = json_obj['subnetID']\n                self.name = json_obj['subnetName']\n                self.description = json_obj['subnetDescription']\n                self.ip = json_obj['subnetIP']\n                self.mask = json_obj['subnetMask']\n                self.routing_area_id = json_obj['subnetRoutingAreaID']\n                self.loc_ids = json_obj['subnetLocationsID']\n                self.ipAddress_ids = json_obj['subnetIPAddressesID']\n                self.osi_ids = json_obj['subnetOSInstancesID']"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding an OS instance to this subnet.", "response": "def add_os_instance(self, os_instance, sync=True):\n        \"\"\"\n        add a OS instance to this subnet.\n        :param os_instance: the OS instance to add on this subnet\n        :param sync: If sync=True(default) synchronize with Ariane server. If sync=False,\n        add the OS instance object on list to be added on next save().\n        :return:\n        \"\"\"\n        LOGGER.debug(\"Subnet.add_os_instance\")\n        if not sync:\n            self.osi_2_add.append(os_instance)\n        else:\n            if os_instance.id is None:\n                os_instance.save()\n            if self.id is not None and os_instance.id is not None:\n                params = {\n                    'id': self.id,\n                    'osiID': os_instance.id\n                }\n                args = {'http_operation': 'GET', 'operation_path': 'update/osinstances/add', 'parameters': params}\n                response = SubnetService.requester.call(args)\n                if response.rc != 0:\n                    LOGGER.warning(\n                        'Subnet.add_os_instance - Problem while updating subnet ' + self.name +\n                        '. Reason: ' + str(response.response_content) + '-' + str(response.error_message) +\n                        \" (\" + str(response.rc) + \")\"\n                    )\n                else:\n                    self.osi_ids.append(os_instance.id)\n                    os_instance.subnet_ids.append(self.id)\n            else:\n                LOGGER.warning(\n                    'Subnet.add_os_instance - Problem while updating subnet ' + self.name + '. Reason: OS instance ' +\n                    os_instance.name + ' id is None or self.id is None'\n                )"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef del_os_instance(self, os_instance, sync=True):\n        LOGGER.debug(\"Subnet.del_os_instance\")\n        if not sync:\n            self.osi_2_rm.append(os_instance)\n        else:\n            if os_instance.id is None:\n                os_instance.sync()\n            if self.id is not None and os_instance.id is not None:\n                params = {\n                    'id': self.id,\n                    'osiID': os_instance.id\n                }\n                args = {'http_operation': 'GET', 'operation_path': 'update/osinstances/delete', 'parameters': params}\n                response = SubnetService.requester.call(args)\n                if response.rc != 0:\n                    LOGGER.warning(\n                        'Subnet.del_os_instance - Problem while updating subnet ' + self.name +\n                        '. Reason: ' + str(response.response_content) + '-' + str(response.error_message) +\n                        \" (\" + str(response.rc) + \")\"\n                    )\n                else:\n                    self.osi_ids.remove(os_instance.id)\n                    os_instance.subnet_ids.remove(self.id)\n            else:\n                LOGGER.warning(\n                    'Subnet.del_os_instance - Problem while updating subnet ' + self.name + '. Reason: OS instance ' +\n                    os_instance.name + ' id is None or self.id is None'\n                )", "response": "Delete the OS instance from this subnet."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef save(self):\n        LOGGER.debug(\"Subnet.save\")\n        post_payload = {}\n        consolidated_osi_id = []\n        consolidated_loc_id = []\n\n        if self.id is not None:\n            post_payload['subnetID'] = self.id\n\n        if self.name is not None:\n            post_payload['subnetName'] = self.name\n\n        if self.description is not None:\n            post_payload['subnetDescription'] = self.description\n\n        if self.ip is not None:\n            post_payload['subnetIP'] = self.ip\n\n        if self.mask is not None:\n            post_payload['subnetMask'] = self.mask\n\n        if self.routing_area_id is not None:\n            post_payload['subnetRoutingAreaID'] = self.routing_area_id\n\n        if self.ipAddress_ids is not None:\n            post_payload['subnetIPAddressesID'] = self.ipAddress_ids\n\n        if self.loc_ids is not None:\n            consolidated_loc_id = copy.deepcopy(self.loc_ids)\n        if self.loc_2_rm is not None:\n            for loc_2_rm in self.loc_2_rm:\n                if loc_2_rm.id is None:\n                    loc_2_rm.sync()\n                consolidated_loc_id.remove(loc_2_rm.id)\n        if self.loc_2_add is not None:\n            for loc_2_add in self.loc_2_add:\n                if loc_2_add.id is None:\n                    loc_2_add.save()\n                consolidated_loc_id.append(loc_2_add.id)\n        post_payload['subnetLocationsID'] = consolidated_loc_id\n\n        if self.osi_ids is not None:\n            consolidated_osi_id = copy.deepcopy(self.osi_ids)\n        if self.osi_2_rm is not None:\n            for osi_2_rm in self.osi_2_rm:\n                if osi_2_rm.id is None:\n                    osi_2_rm.sync()\n                consolidated_osi_id.remove(osi_2_rm.id)\n        if self.osi_2_add is not None:\n            for osi_id_2_add in self.osi_2_add:\n                if osi_id_2_add.id is None:\n                    osi_id_2_add.save()\n                consolidated_osi_id.append(osi_id_2_add.id)\n        post_payload['subnetOSInstancesID'] = consolidated_osi_id\n\n        args = {'http_operation': 'POST', 'operation_path': '', 'parameters': {'payload': json.dumps(post_payload)}}\n        response = SubnetService.requester.call(args)\n        if response.rc != 0:\n            LOGGER.warning(\n                'Subnet.save - Problem while saving subnet ' + self.name +\n                '. Reason: ' + str(response.response_content) + '-' + str(response.error_message) +\n                \" (\" + str(response.rc) + \")\"\n            )\n        else:\n            self.id = response.response_content['subnetID']\n            if self.osi_2_add is not None:\n                for osi_2_add in self.osi_2_add:\n                    osi_2_add.sync()\n            if self.osi_2_rm is not None:\n                for osi_2_rm in self.osi_2_rm:\n                    osi_2_rm.sync()\n            if self.loc_2_add is not None:\n                for loc_2_add in self.loc_2_add:\n                    loc_2_add.sync()\n            if self.loc_2_rm is not None:\n                for loc_2_rm in self.loc_2_rm:\n                    loc_2_rm.sync()\n        self.osi_2_add.clear()\n        self.osi_2_rm.clear()\n        self.loc_2_add.clear()\n        self.loc_2_rm.clear()\n        self.sync()\n        return self", "response": "Save this subnet on Ariane server."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef find_ip_address(ipa_id=None, ipa_fqdn=None, ipa_ip_address=None, ipa_subnet_id=None, ipa_osi_id=None):\n        LOGGER.debug(\"IPAddressService.find_ip_address\")\n        if (ipa_id is None or not ipa_id) and (ipa_fqdn is None or not ipa_fqdn) and \\\n                ((ipa_ip_address is None or not ipa_ip_address) and\n                    ((ipa_subnet_id is None or not ipa_subnet_id) or (ipa_osi_id is None or not ipa_osi_id))):\n            raise exceptions.ArianeCallParametersError('id and fqdn and (ip_address,(ip_subnet_id|ip_osi_id))')\n\n        if (ipa_id is not None and ipa_id) and \\\n           ((ipa_fqdn is not None and ipa_fqdn) or (ipa_ip_address is not None and ipa_ip_address)):\n            LOGGER.warn('IPAddressService.find_ip_address - Both id and (fqdn or ipAddress) are defined. '\n                        'Will give you search on id.')\n            ipa_fqdn = None\n            ipa_ip_address = None\n            ipa_osi_id = None\n            ipa_subnet_id = None\n\n        if (ipa_id is None or not ipa_id) and (ipa_fqdn is not None and ipa_fqdn) and \\\n                (ipa_ip_address is not None and ipa_ip_address):\n            LOGGER.warn('IPAddressService.find_ip_address - Both fqdn and ipAddress are defined. '\n                        'Will give you search on fqdn.')\n            ipa_ip_address = None\n            ipa_osi_id = None\n            ipa_subnet_id = None\n\n        params = None\n        if ipa_id is not None and ipa_id:\n            params = {'id': ipa_id}\n        elif ipa_fqdn is not None and ipa_fqdn:\n            params = {'fqdn': ipa_fqdn}\n        elif (ipa_ip_address is not None and ipa_ip_address) and (ipa_subnet_id is not None and ipa_subnet_id):\n            params = {'ipAddress': ipa_ip_address, 'subnetID': ipa_subnet_id}\n        elif (ipa_ip_address is not None and ipa_ip_address) and (ipa_osi_id is not None and ipa_osi_id):\n            params = {'ipAddress': ipa_ip_address, 'osiID': ipa_osi_id}\n\n        ret = None\n        if params is not None:\n            args = {'http_operation': 'GET', 'operation_path': 'get', 'parameters': params}\n            response = IPAddressService.requester.call(args)\n            if response.rc == 0:\n                ret = IPAddress.json_2_ip_address(response.response_content)\n            elif response.rc != 404:\n                err_msg = 'IPAddressService.find_ip_address - Problem while finding IP Address (id:' + \\\n                          str(ipa_id) + ', ipAddress:' + str(ipa_ip_address) \\\n                          + '). Reason: ' + str(response.response_content) + '-' + str(response.error_message) + \\\n                          \" (\" + str(response.rc) + \")\"\n                LOGGER.warning(\n                    err_msg\n                )\n\n        return ret", "response": "This function finds the IP Address in the current namespace and returns the corresponding IP Address object or None if not found."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget all knows IP Address", "response": "def get_ip_addresses():\n        \"\"\"\n        :return: all knows IP Address\n        \"\"\"\n        LOGGER.debug(\"IPAddressService.get_ip_addresses\")\n        args = {'http_operation': 'GET', 'operation_path': ''}\n        response = IPAddressService.requester.call(args)\n        ret = None\n        if response.rc == 0:\n            ret = []\n            for ipAddress in response.response_content['ipAddresses']:\n                ret.append(IPAddress.json_2_ip_address(ipAddress))\n        elif response.rc != 404:\n            err_msg = 'IPAddressService.get_ip_addresses - Problem while getting IP Address. ' \\\n                      'Reason: ' + str(response.response_content) + '-' + str(response.error_message) + \\\n                      \" (\" + str(response.rc) + \")\"\n            LOGGER.warning(err_msg)\n        return ret"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef json_2_ip_address(json_obj):\n        LOGGER.debug(\"IPAddress.json_2_ip_address\")\n        return IPAddress(ipa_id=json_obj['ipAddressID'],\n                         ip_address=json_obj['ipAddressIPA'],\n                         fqdn=json_obj['ipAddressFQDN'],\n                         ipa_osi_id=json_obj['ipAddressOSInstanceID'],\n                         ipa_subnet_id=json_obj['ipAddressSubnetID'])", "response": "Transform JSON obj coming from Ariane to ariane_clip3 IP Address object"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ntransforms ariane_clip3 OS Instance object to Ariane server JSON object", "response": "def ip_address_2_json(self):\n        \"\"\"\n        transform ariane_clip3 OS Instance object to Ariane server JSON obj\n        :return: Ariane JSON obj\n        \"\"\"\n        LOGGER.debug(\"IPAddress.ip_address_2_json\")\n        json_obj = {\n            'ipAddressID': self.id,\n            'ipAddressIPA': self.ip_address,\n            'ipAddressFQDN': self.fqdn,\n            'ipAddressOSInstanceID': self.ipa_os_instance_id,\n            'ipAddressSubnetID': self.ipa_subnet_id,\n        }\n        return json.dumps(json_obj)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef sync(self):\n        LOGGER.debug(\"IPAddress.sync\")\n        params = None\n        if self.id is not None:\n            params = {'id': self.id}\n        elif self.ip_address is not None:\n            params = {'ipAddress': self.ip_address}\n\n        if params is not None:\n            args = {'http_operation': 'GET', 'operation_path': 'get', 'parameters': params}\n            response = IPAddressService.requester.call(args)\n            if response.rc != 0:\n                LOGGER.warning(\n                    'IPAddress.sync - Problem while syncing IP address (name:' + self.ip_address +\n                    ', id: ' + str(self.id) +\n                    '). Reason: ' + str(response.response_content) + '-' + str(response.error_message) +\n                    \" (\" + str(response.rc) + \")\"\n                )\n            else:\n                json_obj = response.response_content\n                self.id = json_obj['ipAddressID']\n                self.ip_address = json_obj['ipAddressIPA']\n                self.fqdn = json_obj['ipAddressFQDN']\n                self.ipa_os_instance_id = json_obj['ipAddressOSInstanceID']\n                self.ipa_subnet_id = json_obj['ipAddressSubnetID']", "response": "Synchronize this object with Ariane server according its id or name."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nsave this IP Address on Ariane server.", "response": "def save(self):\n        \"\"\"\n        :return: save this IP Address on Ariane server (create or update)\n        \"\"\"\n        LOGGER.debug(\"IPAddress.save\")\n        post_payload = {}\n\n        if self.id is not None:\n            post_payload['ipAddressID'] = self.id\n\n        if self.ip_address is not None:\n            post_payload['ipAddressIPA'] = self.ip_address\n\n        if self.fqdn is not None:\n            post_payload['ipAddressFQDN'] = self.fqdn\n\n        if self.ipa_os_instance_id is not None:\n            post_payload['ipAddressOSInstanceID'] = self.ipa_os_instance_id\n\n        if self.ipa_subnet_id is not None:\n            post_payload['ipAddressSubnetID'] = self.ipa_subnet_id\n\n        args = {'http_operation': 'POST', 'operation_path': '', 'parameters': {'payload': json.dumps(post_payload)}}\n        response = IPAddressService.requester.call(args)\n        if response.rc != 0:\n            LOGGER.warning(\n                'IPAddress.save - Problem while saving IP Address ' + self.ip_address +\n                '. Reason: ' + str(response.response_content) + '-' + str(response.error_message) +\n                \" (\" + str(response.rc) + \")\"\n            )\n        else:\n            self.id = response.response_content['ipAddressID']\n\n        self.sync()\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef remove(self):\n        LOGGER.debug(\"IPAddress.remove\")\n        if self.id is None:\n            return None\n        else:\n            params = {\n                'id': self.id\n            }\n            args = {'http_operation': 'GET', 'operation_path': 'delete', 'parameters': params}\n            response = IPAddressService.requester.call(args)\n            if response.rc != 0:\n                LOGGER.warning(\n                    'IPAddress.remove - Problem while deleting IP Address' + self.ip_address +\n                    '. Reason: ' + str(response.response_content) + '-' + str(response.error_message) +\n                    \" (\" + str(response.rc) + \")\"\n                )\n                return self\n            else:\n                return None", "response": "Removes this object from Ariane server."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef find_nic(nic_id=None, nic_mac_address=None, nic_name=None):\n        LOGGER.debug(\"NICService.find_nic\")\n        if (nic_id is None or not nic_id) and (nic_name is None or not nic_name) and \\\n           (nic_mac_address is None or not nic_mac_address):\n            raise exceptions.ArianeCallParametersError('id and name and mac_Address)')\n\n        if (nic_id is not None and nic_id) and \\\n           ((nic_name is not None and nic_name) or (nic_mac_address is not None and nic_mac_address)):\n            LOGGER.warn('NICService.find_nic - Both id and (name or macAddress) are defined. '\n                        'Will give you search on id.')\n            nic_name = None\n            nic_mac_address = None\n\n        if (nic_name is not None or nic_name) and (nic_mac_address is not None and nic_mac_address):\n            LOGGER.warn('NICService.find_nic - Both name and mac address are defined. '\n                        'Will give you search on mac address.')\n            nic_name = None\n\n        params = None\n        if nic_id is not None and nic_id:\n            params = {'id': nic_id}\n        elif nic_mac_address is not None and nic_mac_address:\n            params = {'macAddress': nic_mac_address}\n        elif nic_name is not None and nic_name:\n            params = {'name': nic_name}\n\n        ret = None\n        if params is not None:\n            args = {'http_operation': 'GET', 'operation_path': 'get', 'parameters': params}\n            response = NICService.requester.call(args)\n            if response.rc == 0:\n                ret = NIC.json_2_nic(response.response_content)\n            elif response.rc != 404:\n                err_msg = 'NICService.find_nic - Problem while finding NIC (id:' + str(nic_id) + \\\n                          ', name:' + str(nic_name) + \\\n                          \", mac address:\" + str(nic_mac_address) \\\n                          + '. Reason: ' + str(response.response_content) + '-' + str(response.error_message) + \\\n                          \" (\" + str(response.rc) + \")\"\n                LOGGER.warning(\n                    err_msg\n                )\n\n        return ret", "response": "find the NIC according to the given parameters"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_nics():\n        LOGGER.debug(\"NICService.get_nics\")\n        args = {'http_operation': 'GET', 'operation_path': ''}\n        response = NICService.requester.call(args)\n        ret = None\n        if response.rc == 0:\n            ret = []\n            for nic in response.response_content['nics']:\n                ret.append(NIC.json_2_nic(nic))\n        elif response.rc != 404:\n            err_msg = 'NICService.get_nics - Problem while getting NIC. ' \\\n                      'Reason: ' + str(response.response_content) + '-' + str(response.error_message) + \\\n                      \" (\" + str(response.rc) + \")\"\n            LOGGER.warning(err_msg)\n        return ret", "response": "Get all knows NICs."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ntransforms JSON obj coming from Ariane to ariane_clip3 NIC object", "response": "def json_2_nic(json_obj):\n        \"\"\"\n        transform JSON obj coming from Ariane to ariane_clip3 object\n        :param json_obj: the JSON obj coming from Ariane\n        :return: ariane_clip3 NIC object\n        \"\"\"\n        LOGGER.debug(\"NIC.json_2_nic\")\n        return NIC(nic_id=json_obj['nicID'],\n                   mac_address=json_obj['nicMacAddress'],\n                   name=json_obj['nicName'],\n                   speed=json_obj['nicSpeed'],\n                   duplex=json_obj['nicDuplex'],\n                   mtu=json_obj['nicMtu'],\n                   nic_osi_id=json_obj['nicOSInstanceID'],\n                   nic_ipa_id=json_obj['nicIPAddressID'])"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef nic_2_json(self):\n        LOGGER.debug(\"NIC.nic_2_json\")\n        json_obj = {\n            'nicID': self.id,\n            'nicName': self.name,\n            'nicMacAddress': self.mac_address,\n            'nicDuplex': self.duplex,\n            'nicSpeed': self.speed,\n            'nicMtu': self.mtu,\n            'nicOSInstanceID': self.nic_osi_id,\n            'nicIPAddressID': self.nic_ipa_id\n        }\n        return json.dumps(json_obj)", "response": "Transform ariane_clip3 OS Instance object to Ariane server JSON object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsynchronizing this NIC with Ariane server according its id or name.", "response": "def sync(self):\n        \"\"\"\n        synchronize self from Ariane server according its id (priority) or name\n        :return:\n        \"\"\"\n        LOGGER.debug(\"NIC.sync\")\n        params = None\n        if self.id is not None:\n            params = {'id': self.id}\n        elif self.name is not None:\n            params = {'name': self.name}\n\n        if params is not None:\n            args = {'http_operation': 'GET', 'operation_path': 'get', 'parameters': params}\n            response = NICService.requester.call(args)\n            if response.rc != 0:\n                LOGGER.warning(\n                    'NIC.sync - Problem while syncing NIC (name:' + self.name + ', id:' + str(self.id) +\n                    '). Reason: ' + str(response.response_content) + '-' + str(response.error_message) +\n                    \" (\" + str(response.rc) + \")\"\n                )\n            else:\n                json_obj = response.response_content\n                self.id = json_obj['nicID']\n                self.name = json_obj['nicName']\n                self.mac_address = json_obj['nicMacAddress']\n                self.duplex = json_obj['nicDuplex']\n                self.speed = json_obj['nicSpeed']\n                self.mtu = json_obj['nicMtu']\n                self.nic_ipa_id = json_obj['nicIPAddressID']\n                self.nic_osi_id = json_obj['nicOSInstanceID']"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsaves this NIC on Ariane server.", "response": "def save(self):\n        \"\"\"\n        :return: save this NIC on Ariane server (create or update)\n        \"\"\"\n        LOGGER.debug(\"NIC.save\")\n        post_payload = {}\n\n        if self.id is not None:\n            post_payload['nicID'] = self.id\n\n        if self.name is not None:\n            post_payload['nicName'] = self.name\n\n        if self.mac_address is not None:\n            post_payload['nicMacAddress'] = self.mac_address\n\n        if self.duplex is not None:\n            post_payload['nicDuplex'] = self.duplex\n\n        if self.speed is not None:\n            post_payload['nicSpeed'] = self.speed\n\n        if self.mtu is not None:\n            post_payload['nicMtu'] = self.mtu\n\n        if self.nic_osi_id is not None:\n            post_payload['nicOSInstanceID'] = self.nic_osi_id\n\n        if self.nic_ipa_id is not None:\n            post_payload['nicIPAddressID'] = self.nic_ipa_id\n\n        args = {'http_operation': 'POST', 'operation_path': '', 'parameters': {'payload': json.dumps(post_payload)}}\n        response = NICService.requester.call(args)\n        if response.rc != 0:\n            LOGGER.warning(\n                'NIC.save - Problem while saving NIC ' + self.name +\n                '. Reason: ' + str(response.response_content) + '-' + str(response.error_message) +\n                \" (\" + str(response.rc) + \")\"\n            )\n        else:\n            self.id = response.response_content['nicID']\n\n        self.sync()\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nfinds the OS instance according to the id or name.", "response": "def find_os_instance(osi_id=None, osi_name=None):\n        \"\"\"\n        find the OS instance (osi) according osi id (prioritary) or osi name\n        :param osi_id: the OS instance id\n        :param osi_name: the OS instance name\n        :return: found OS instance or None if not found\n        \"\"\"\n        LOGGER.debug(\"OSInstanceService.find_os_instance\")\n        if (osi_id is None or not osi_id) and (osi_name is None or not osi_name):\n            raise exceptions.ArianeCallParametersError('id and name')\n\n        if (osi_id is not None and osi_id) and (osi_name is not None and osi_name):\n            LOGGER.warn('OSInstanceService.find_os_instance - Both id and name are defined. '\n                        'Will give you search on id.')\n            osi_name = None\n\n        params = None\n        if osi_id is not None and osi_id:\n            params = {'id': osi_id}\n        elif osi_name is not None and osi_name:\n            params = {'name': osi_name}\n\n        ret = None\n        if params is not None:\n            args = {'http_operation': 'GET', 'operation_path': 'get', 'parameters': params}\n            response = OSInstanceService.requester.call(args)\n            if response.rc == 0:\n                ret = OSInstance.json_2_os_instance(response.response_content)\n            elif response.rc != 404:\n                err_msg = 'OSInstanceService.find_os_instance - Problem while finding OS Instance (id:' + \\\n                          str(osi_id) + ', name:' + str(osi_name) + '). ' + \\\n                          '. Reason: ' + str(response.response_content) + '-' + str(response.error_message) + \\\n                          \" (\" + str(response.rc) + \")\"\n                LOGGER.warning(\n                    err_msg\n                )\n\n        return ret"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_os_instances():\n        LOGGER.debug(\"OSInstanceService.get_os_instances\")\n        args = {'http_operation': 'GET', 'operation_path': ''}\n        response = OSInstanceService.requester.call(args)\n        ret = None\n        if response.rc == 0:\n            ret = []\n            for osInstance in response.response_content['osInstances']:\n                ret.append(OSInstance.json_2_os_instance(osInstance))\n        elif response.rc != 404:\n            err_msg = 'OSInstanceService.get_os_instances - Problem while getting os instances. ' \\\n                      '. Reason: ' + str(response.response_content) + '-' + str(response.error_message) + \\\n                      \" (\" + str(response.rc) + \")\"\n            LOGGER.warning(err_msg)\n        return ret", "response": "Get all knows OS instance names."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ntransform the JSON obj coming from Ariane to ariane_clip3 object", "response": "def json_2_os_instance(json_obj):\n        \"\"\"\n        transform JSON obj coming from Ariane to ariane_clip3 object\n        :param json_obj: the JSON obj coming from Ariane\n        :return: ariane_clip3 OS instance object\n        \"\"\"\n        LOGGER.debug(\"OSInstance.json_2_os_instance\")\n        return OSInstance(osiid=json_obj['osInstanceID'],\n                          name=json_obj['osInstanceName'],\n                          description=json_obj['osInstanceDescription'],\n                          admin_gate_uri=json_obj['osInstanceAdminGateURI'],\n                          osi_embedding_osi_id=json_obj['osInstanceEmbeddingOSInstanceID'],\n                          osi_ost_id=json_obj['osInstanceOSTypeID'],\n                          osi_embedded_osi_ids=json_obj['osInstanceEmbeddedOSInstancesID'],\n                          osi_ip_address_ids=json_obj['osInstanceIPAddressesID'],\n                          osi_nic_ids=json_obj['osInstanceNICsID'],\n                          osi_application_ids=json_obj['osInstanceApplicationsID'],\n                          osi_environment_ids=json_obj['osInstanceEnvironmentsID'],\n                          osi_subnet_ids=json_obj['osInstanceSubnetsID'],\n                          osi_team_ids=json_obj['osInstanceTeamsID'])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ntransform ariane_clip3 OS Instance object to Ariane server JSON obj", "response": "def os_instance_2_json(self):\n        \"\"\"\n        transform ariane_clip3 OS Instance object to Ariane server JSON obj\n        :return: Ariane JSON obj\n        \"\"\"\n        LOGGER.debug(\"OSInstance.os_instance_2_json\")\n        json_obj = {\n            'osInstanceID': self.id,\n            'osInstanceName': self.name,\n            'osInstanceDescription': self.description,\n            'osInstanceAdminGateURI': self.admin_gate_uri,\n            'osInstanceEmbeddingOSInstanceID': self.embedding_osi_id,\n            'osInstanceOSTypeID': self.ost_id,\n            'osInstanceEmbeddedOSInstancesID': self.embedded_osi_ids,\n            'osInstanceIPAddressesID': self.ip_address_ids,\n            'osInstanceNICsID': self.nic_ids,\n            'osInstanceApplicationsID': self.application_ids,\n            'osInstanceEnvironmentsID': self.environment_ids,\n            'osInstanceSubnetsID': self.subnet_ids,\n            'osInstanceTeamsID': self.team_ids\n        }\n        return json.dumps(json_obj)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsynchronizes this OSInstance with Ariane server according its id or name.", "response": "def sync(self):\n        \"\"\"\n        synchronize self from Ariane server according its id (prioritary) or name\n        :return:\n        \"\"\"\n        LOGGER.debug(\"OSInstance.sync\")\n        params = None\n        if self.id is not None:\n            params = {'id': self.id}\n        elif self.name is not None:\n            params = {'name': self.name}\n\n        if params is not None:\n            args = {'http_operation': 'GET', 'operation_path': 'get', 'parameters': params}\n            response = OSInstanceService.requester.call(args)\n            if response.rc != 0:\n                LOGGER.warning(\n                    'OSInstance.sync - Problem while syncing OS instance (name:' + self.name + ', id:' + str(self.id) +\n                    '). Reason: ' + str(response.response_content) + '-' + str(response.error_message) +\n                    \" (\" + str(response.rc) + \")\"\n                )\n            else:\n                json_obj = response.response_content\n                self.id = json_obj['osInstanceID']\n                self.name = json_obj['osInstanceName']\n                self.description = json_obj['osInstanceDescription']\n                self.admin_gate_uri = json_obj['osInstanceAdminGateURI']\n                if json_obj['osInstanceOSTypeID'] == -1:\n                    self.ost_id = None\n                else:\n                    self.ost_id = json_obj['osInstanceOSTypeID']\n                if json_obj['osInstanceEmbeddingOSInstanceID'] == -1:\n                    self.embedding_osi_id = None\n                else:\n                    self.embedding_osi_id = json_obj['osInstanceEmbeddingOSInstanceID']\n                self.embedded_osi_ids = json_obj['osInstanceEmbeddedOSInstancesID']\n                self.ip_address_ids = json_obj['osInstanceIPAddressesID']\n                self.nic_ids = json_obj['osInstanceNICsID']\n                self.application_ids = json_obj['osInstanceApplicationsID']\n                self.environment_ids = json_obj['osInstanceEnvironmentsID']\n                self.subnet_ids = json_obj['osInstanceSubnetsID']\n                self.team_ids = json_obj['osInstanceTeamsID']"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add_subnet(self, subnet, sync=True):\n        LOGGER.debug(\"OSInstance.add_subnet\")\n        if not sync:\n            self.subnets_2_add.append(subnet)\n        else:\n            if subnet.id is None:\n                subnet.save()\n            if self.id is not None and subnet.id is not None:\n                params = {\n                    'id': self.id,\n                    'subnetID': subnet.id\n                }\n                args = {'http_operation': 'GET', 'operation_path': 'update/subnets/add', 'parameters': params}\n                response = OSInstanceService.requester.call(args)\n                if response.rc != 0:\n                    LOGGER.warning(\n                        'OSInstance.add_subnet - Problem while updating OS instance ' + self.name +\n                        '. Reason: ' + str(response.response_content) + '-' + str(response.error_message) +\n                        \" (\" + str(response.rc) + \")\"\n                    )\n                else:\n                    self.subnet_ids.append(subnet.id)\n                    subnet.osi_ids.append(self.id)\n            else:\n                LOGGER.warning(\n                    'OSInstance.add_subnet - Problem while updating OS instance ' + self.name + '. Reason: subnet ' +\n                    subnet.name + ' id is None'\n                )", "response": "This method adds a subnet to the OS instance."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add_ip_address(self, ip_address, sync=True):\n        LOGGER.debug(\"OSInstance.add_ip_address\")\n        if not sync:\n            self.ip_address_2_add.append(ip_address)\n        else:\n            if ip_address.id is None:\n                ip_address.save()\n            if self.id is not None and ip_address.id is not None:\n                params = {\n                    'id': self.id,\n                    'ipAddressID': ip_address.id\n                }\n                args = {'http_operation': 'GET', 'operation_path': 'update/ipAddresses/add', 'parameters': params}\n                response = OSInstanceService.requester.call(args)\n                if response.rc != 0:\n                    LOGGER.warning(\n                        'OSInstance.add_ip_address - Problem while updating OS instance ' + self.name +\n                        '. Reason: ' + str(response.response_content) + '-' + str(response.error_message) +\n                        \" (\" + str(response.rc) + \")\"\n                    )\n                else:\n                    self.ip_address_ids.append(ip_address.id)\n                    ip_address.ipa_os_instance_id = self.id\n            else:\n                LOGGER.warning(\n                    'OSInstance.add_ip_address - Problem while updating OS instance ' +\n                    self.name + '. Reason: IP Address ' + ip_address.ipAddress + ' id is None'\n                )", "response": "Add an IP Address to the OS instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef del_ip_address(self, ip_address, sync=True):\n        LOGGER.debug(\"OSInstance.del_ip_address\")\n        if not sync:\n            self.ip_address_2_rm.append(ip_address)\n        else:\n            if ip_address.id is None:\n                ip_address.sync()\n            if self.id is not None and ip_address.id is not None:\n                params = {\n                    'id': self.id,\n                    'ipAddressID': ip_address.id\n                }\n                args = {'http_operation': 'GET', 'operation_path': 'update/ipAddresses/delete', 'parameters': params}\n                response = OSInstanceService.requester.call(args)\n                if response.rc != 0:\n                    LOGGER.warning(\n                        'OSInstance.del_ip_address - Problem while updating OS instance ' + self.name +\n                        '. Reason: ' + str(response.response_content) + '-' + str(response.error_message) +\n                        \" (\" + str(response.rc) + \")\"\n                    )\n                else:\n                    self.ip_address_ids.remove(ip_address.id)\n                    ip_address.ipa_os_instance_id = None\n            else:\n                LOGGER.warning(\n                    'OSInstance.del_ip_address - Problem while updating OS instance ' + self.name +\n                    '. Reason: IP Address ' + ip_address.ipAddress + ' id is None'\n                )", "response": "Delete an IP address from this OS instance."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add_nic(self, nic, sync=True):\n        LOGGER.debug(\"OSInstance.add_nic\")\n        if not sync:\n            self.nic_2_add.append(nic)\n        else:\n            if nic.id is None:\n                nic.save()\n            if self.id is not None and nic.id is not None:\n                params = {\n                    'id': self.id,\n                    'nicID': nic.id\n                }\n                args = {'http_operation': 'GET', 'operation_path': 'update/nics/add', 'parameters': params}\n                response = OSInstanceService.requester.call(args)\n                if response.rc != 0:\n                    LOGGER.warning(\n                        'OSInstance.add_nic - Problem while updating OS instance ' + self.name +\n                        '. Reason: ' + str(response.response_content) + '-' + str(response.error_message) +\n                        \" (\" + str(response.rc) + \")\"\n                    )\n                else:\n                    self.nic_ids.append(nic.id)\n                    nic.nic_osi_id = self.id\n            else:\n                LOGGER.warning(\n                    'OSInstance.add_nic - Problem while updating OS instance ' + self.name +\n                    '. Reason: NIC ' + nic.name + ' id is None'\n                )", "response": "Add a nic to this OS instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef del_nic(self, nic, sync=True):\n        LOGGER.debug(\"OSInstance.del_nic\")\n        if not sync:\n            self.nic_2_rm.append(nic)\n        else:\n            if nic.id is None:\n                nic.sync()\n            if self.id is not None and nic.id is not None:\n                params = {\n                    'id': self.id,\n                    'nicID': nic.id\n                }\n                args = {'http_operation': 'GET', 'operation_path': 'update/nics/delete', 'parameters': params}\n                response = OSInstanceService.requester.call(args)\n                if response.rc != 0:\n                    LOGGER.warning(\n                        'OSInstance.del_nic - Problem while updating OS instance ' + self.name +\n                        '. Reason: ' + str(response.response_content) + '-' + str(response.error_message) +\n                        \" (\" + str(response.rc) + \")\"\n                    )\n                else:\n                    self.nic_ids.remove(nic.id)\n                    nic.nic_osi_id = None\n            else:\n                LOGGER.warning(\n                    'OSInstance.del_nic - Problem while updating OS instance ' + self.name + '. Reason: NIC ' +\n                    nic.name + ' id is None'\n                )", "response": "Delete a nic from this OS instance."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add_embedded_osi(self, e_osi, sync=True):\n        LOGGER.debug(\"OSInstance.add_embedded_osi\")\n        if not sync:\n            self.embedded_osi_2_add.append(e_osi)\n        else:\n            if e_osi.id is None:\n                e_osi.save()\n            if self.id is not None and e_osi.id is not None:\n                params = {\n                    'id': self.id,\n                    'osiID': e_osi.id\n                }\n                args = {'http_operation': 'GET', 'operation_path': 'update/embeddedOSInstances/add',\n                        'parameters': params}\n                response = OSInstanceService.requester.call(args)\n                if response.rc != 0:\n                    LOGGER.warning(\n                        'OSInstance.add_embedded_osi - Problem while updating OS instance ' + self.name +\n                        '. Reason: ' + str(response.response_content) + '-' + str(response.error_message) +\n                        \" (\" + str(response.rc) + \")\"\n                    )\n                else:\n                    self.embedded_osi_ids.append(e_osi.id)\n                    e_osi.sync()\n            else:\n                LOGGER.warning(\n                    'OSInstance.add_embedded_osi - Problem while updating OS instance ' + self.name +\n                    '. Reason: embedded OS instance ' + e_osi.name + ' id is None'\n                )", "response": "Add an embedded OS instance to this OS instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef del_embedded_osi(self, e_osi, sync=True):\n        LOGGER.debug(\"OSInstance.del_embedded_osi\")\n        if not sync:\n            self.embedded_osi_2_rm.append(e_osi)\n        else:\n            if e_osi.id is None:\n                e_osi.sync()\n            if self.id is not None and e_osi.id is not None:\n                params = {\n                    'id': self.id,\n                    'osiID': e_osi.id\n                }\n                args = {'http_operation': 'GET', 'operation_path': 'update/embeddedOSInstances/delete',\n                        'parameters': params}\n                response = OSInstanceService.requester.call(args)\n                if response.rc != 0:\n                    LOGGER.warning(\n                        'OSInstance.del_embedded_osi - Problem while updating OS instance ' + self.name +\n                        '. Reason: ' + str(response.response_content) + '-' + str(response.error_message) +\n                        \" (\" + str(response.rc) + \")\"\n                    )\n                else:\n                    self.embedded_osi_ids.remove(e_osi.id)\n                    e_osi.sync()\n            else:\n                LOGGER.warning(\n                    'OSInstance.del_embedded_osi - Problem while updating OS instance ' +\n                    self.name + '. Reason: embedded OS instance ' + e_osi.name + ' id is None'\n                )", "response": "Delete an embedded OS instance from this OS instance."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add_application(self, application, sync=True):\n        LOGGER.debug(\"OSInstance.add_application\")\n        if not sync:\n            self.application_2_add.append(application)\n        else:\n            if application.id is None:\n                application.save()\n            if self.id is not None and application.id is not None:\n                params = {\n                    'id': self.id,\n                    'applicationID': application.id\n                }\n                args = {'http_operation': 'GET', 'operation_path': 'update/applications/add', 'parameters': params}\n                response = OSInstanceService.requester.call(args)\n                if response.rc != 0:\n                    LOGGER.warning(\n                        'OSInstance.add_application - Problem while updating OS instance ' + self.name +\n                        '. Reason: ' + str(response.response_content) + '-' + str(response.error_message) +\n                        \" (\" + str(response.rc) + \")\"\n                    )\n                else:\n                    self.application_ids.append(application.id)\n                    application.osi_ids.append(self.id)\n            else:\n                LOGGER.warning(\n                    'OSInstance.add_application - Problem while updating OS instance ' + self.name +\n                    '. Reason: application ' + application.name + ' id is None'\n                )", "response": "Add an application to this OS instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndeletes an application from this OS instance.", "response": "def del_application(self, application, sync=True):\n        \"\"\"\n        delete application from this OS instance\n        :param application: the application to be deleted from this OS instance\n        :param sync: If sync=True(default) synchronize with Ariane server. If sync=False,\n        add the application object on list to be removed on next save().\n        :return:\n        \"\"\"\n        LOGGER.debug(\"OSInstance.del_application\")\n        if not sync:\n            self.application_2_rm.append(application)\n        else:\n            if application.id is None:\n                application.sync()\n            if self.id is not None and application.id is not None:\n                params = {\n                    'id': self.id,\n                    'applicationID': application.id\n                }\n                args = {'http_operation': 'GET', 'operation_path': 'update/applications/delete', 'parameters': params}\n                response = OSInstanceService.requester.call(args)\n                if response.rc != 0:\n                    LOGGER.warning(\n                        'OSInstance.del_application - Problem while updating OS instance ' + self.name +\n                        '. Reason: ' + str(response.response_content) + '-' + str(response.error_message) +\n                        \" (\" + str(response.rc) + \")\"\n                    )\n                else:\n                    self.application_ids.remove(application.id)\n                    application.osi_ids.remove(self.id)\n            else:\n                LOGGER.warning(\n                    'OSInstance.del_application - Problem while updating OS instance ' + self.name +\n                    '. Reason: application ' + application.name + ' id is None'\n                )"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add_environment(self, environment, sync=True):\n        LOGGER.debug(\"OSInstance.add_environment\")\n        if not sync:\n            self.environment_2_add.append(environment)\n        else:\n            if environment.id is None:\n                environment.save()\n            if self.id is not None and environment.id is not None:\n                params = {\n                    'id': self.id,\n                    'environmentID': environment.id\n                }\n                args = {'http_operation': 'GET', 'operation_path': 'update/environments/add', 'parameters': params}\n                response = OSInstanceService.requester.call(args)\n                if response.rc != 0:\n                    LOGGER.warning(\n                        'OSInstance.add_environment - Problem while updating OS instance ' + self.name +\n                        '. Reason: ' + str(response.response_content) + '-' + str(response.error_message) +\n                        \" (\" + str(response.rc) + \")\"\n                    )\n                else:\n                    self.environment_ids.append(environment.id)\n                    environment.osi_ids.append(self.id)\n            else:\n                LOGGER.warning(\n                    'OSInstance.add_environment - Problem while updating OS instance ' +\n                    self.name + '. Reason: application ' + environment.name + ' id is None'\n                )", "response": "Add an environment to this OS instance."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndelete an environment from this OS instance.", "response": "def del_environment(self, environment, sync=True):\n        \"\"\"\n        delete environment from this OS instance\n        :param environment: the environment to be deleted from this OS instance\n        :param sync: If sync=True(default) synchronize with Ariane server. If sync=False,\n        add the environment object on list to be removed on next save().\n        :return:\n        \"\"\"\n        LOGGER.debug(\"OSInstance.del_environment\")\n        if not sync:\n            self.environment_2_rm.append(environment)\n        else:\n            if environment.id is None:\n                environment.sync()\n            if self.id is not None and environment.id is not None:\n                params = {\n                    'id': self.id,\n                    'environmentID': environment.id\n                }\n                args = {'http_operation': 'GET', 'operation_path': 'update/environments/delete', 'parameters': params}\n                response = OSInstanceService.requester.call(args)\n                if response.rc != 0:\n                    LOGGER.warning(\n                        'OSInstance.del_environment - Problem while updating OS instance ' + self.name +\n                        '. Reason: ' + str(response.response_content) + '-' + str(response.error_message) +\n                        \" (\" + str(response.rc) + \")\"\n                    )\n                else:\n                    self.environment_ids.remove(environment.id)\n                    environment.osi_ids.remove(self.id)\n            else:\n                LOGGER.warning(\n                    'OSInstance.del_environment - Problem while updating OS instance ' + self.name +\n                    '. Reason: application ' + environment.name + ' id is None'\n                )"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadd a team to this OS instance.", "response": "def add_team(self, team, sync=True):\n        \"\"\"\n        add a team to this OS instance.\n        :param team: the team to add on this OS instance\n        :param sync: If sync=True(default) synchronize with Ariane server. If sync=False,\n        add the team object on list to be added on next save().\n        :return:\n        \"\"\"\n        LOGGER.debug(\"OSInstance.add_team\")\n        if not sync:\n            self.team_2_add.append(team)\n        else:\n            if team.id is None:\n                team.save()\n            if self.id is not None and team.id is not None:\n                params = {\n                    'id': self.id,\n                    'teamID': team.id\n                }\n                args = {'http_operation': 'GET', 'operation_path': 'update/teams/add', 'parameters': params}\n                response = OSInstanceService.requester.call(args)\n                if response.rc != 0:\n                    LOGGER.warning(\n                        'OSInstance.add_team - Problem while updating OS instance ' + self.name +\n                        '. Reason: ' + str(response.response_content) + '-' + str(response.error_message) +\n                        \" (\" + str(response.rc) + \")\"\n                    )\n                else:\n                    self.team_ids.append(team.id)\n                    team.osi_ids.append(self.id)\n            else:\n                LOGGER.warning(\n                    'OSInstance.add_team - Problem while updating OS instance ' + self.name + '. Reason: application ' +\n                    team.name + ' id is None'\n                )"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef del_team(self, team, sync=True):\n        LOGGER.debug(\"OSInstance.del_team\")\n        if not sync:\n            self.team_2_rm.append(team)\n        else:\n            if team.id is None:\n                team.sync()\n            if self.id is not None and team.id is not None:\n                params = {\n                    'id': self.id,\n                    'teamID': team.id\n                }\n                args = {'http_operation': 'GET', 'operation_path': 'update/teams/delete', 'parameters': params}\n                response = OSInstanceService.requester.call(args)\n                if response.rc != 0:\n                    LOGGER.warning(\n                        'OSInstance.del_team - Problem while updating OS instance ' + self.name +\n                        '. Reason: ' + str(response.response_content) + '-' + str(response.error_message) +\n                        \" (\" + str(response.rc) + \")\"\n                    )\n                else:\n                    self.team_ids.remove(team.id)\n                    team.osi_ids.remove(self.id)\n            else:\n                LOGGER.warning(\n                    'OSInstance.del_team - Problem while updating OS instance ' + self.name + '. Reason: application ' +\n                    team.name + ' id is None'\n                )", "response": "Delete a team from this OS instance."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsaves this OS instance on Ariane server.", "response": "def save(self):\n        \"\"\"\n        :return: save this OS instance on Ariane server (create or update)\n        \"\"\"\n        LOGGER.debug(\"OSInstance.save\")\n        post_payload = {}\n        consolidated_osi_id = []\n        consolidated_ipa_id = []\n        consolidated_nic_id = []\n        consolidated_app_id = []\n        consolidated_env_id = []\n        consolidated_snet_id = []\n        consolidated_team_id = []\n\n        if self.id is not None:\n            post_payload['osInstanceID'] = self.id\n\n        if self.name is not None:\n            post_payload['osInstanceName'] = self.name\n\n        if self.description is not None:\n            post_payload['osInstanceDescription'] = self.description\n\n        if self.admin_gate_uri is not None:\n            post_payload['osInstanceAdminGateURI'] = self.admin_gate_uri\n\n        if self.embedding_osi_id is not None:\n            post_payload['osInstanceEmbeddingOSInstanceID'] = self.embedding_osi_id\n\n        if self.ost_id is not None:\n            post_payload['osInstanceOSTypeID'] = self.ost_id\n\n        if self.embedded_osi_ids is not None:\n            consolidated_osi_id = copy.deepcopy(self.embedded_osi_ids)\n        if self.embedded_osi_2_rm is not None:\n            for osi_2_rm in self.embedded_osi_2_rm:\n                if osi_2_rm.id is None:\n                    osi_2_rm.sync()\n                consolidated_osi_id.remove(osi_2_rm.id)\n        if self.embedded_osi_2_add is not None:\n            for osi_id_2_add in self.embedded_osi_2_add:\n                if osi_id_2_add.id is None:\n                    osi_id_2_add.save()\n                consolidated_osi_id.append(osi_id_2_add.id)\n        post_payload['osInstanceEmbeddedOSInstancesID'] = consolidated_osi_id\n\n        if self.ip_address_ids is not None:\n            consolidated_ipa_id = copy.deepcopy(self.ip_address_ids)\n        if self.ip_address_2_rm is not None:\n            for ipa_2_rm in self.ip_address_2_rm:\n                if ipa_2_rm.id is None:\n                    ipa_2_rm.sync()\n                consolidated_ipa_id.remove(ipa_2_rm.id)\n        if self.ip_address_2_add is not None:\n            for ipa_2_add in self.ip_address_2_add:\n                if ipa_2_add.id is None:\n                    ipa_2_add.save()\n                consolidated_ipa_id.append(ipa_2_add.id)\n        post_payload['osInstanceIPAddressesID'] = consolidated_ipa_id\n\n        if self.nic_ids is not None:\n            consolidated_nic_id = copy.deepcopy(self.nic_ids)\n        if self.nic_2_rm is not None:\n            for nic_2_rm in self.nic_2_rm:\n                if nic_2_rm.id is None:\n                    nic_2_rm.sync()\n                consolidated_nic_id.remove(nic_2_rm.id)\n        if self.nic_2_add is not None:\n            for nic_2_add in self.nic_2_add:\n                if nic_2_add.id is None:\n                    nic_2_add.save()\n                consolidated_nic_id.append(nic_2_add.id)\n        post_payload['osInstanceNICsID'] = consolidated_nic_id\n\n        if self.subnet_ids is not None:\n            consolidated_snet_id = copy.deepcopy(self.subnet_ids)\n        if self.subnets_2_rm is not None:\n            for snet_2_rm in self.subnets_2_rm:\n                if snet_2_rm.id is None:\n                    snet_2_rm.sync()\n                consolidated_snet_id.remove(snet_2_rm.id)\n        if self.subnets_2_add is not None:\n            for snet_2_add in self.subnets_2_add:\n                if snet_2_add.id is None:\n                    snet_2_add.save()\n                consolidated_snet_id.append(snet_2_add.id)\n        post_payload['osInstanceSubnetsID'] = consolidated_snet_id\n\n        if self.application_ids is not None:\n            consolidated_app_id = copy.deepcopy(self.application_ids)\n        if self.application_2_rm is not None:\n            for app_2_rm in self.application_2_rm:\n                if app_2_rm.id is None:\n                    app_2_rm.sync()\n                consolidated_app_id.remove(app_2_rm.id)\n        if self.application_2_add is not None:\n            for app_2_add in self.application_2_add:\n                if app_2_add.id is None:\n                    app_2_add.save()\n                consolidated_app_id.append(app_2_add.id)\n        post_payload['osInstanceApplicationsID'] = consolidated_app_id\n\n        if self.environment_ids is not None:\n            consolidated_env_id = copy.deepcopy(self.environment_ids)\n        if self.environment_2_rm is not None:\n            for env_2_rm in self.environment_2_rm:\n                if env_2_rm.id is None:\n                    env_2_rm.sync()\n                consolidated_env_id.remove(env_2_rm.id)\n        if self.environment_2_add is not None:\n            for env_2_add in self.environment_2_add:\n                if env_2_add.id is None:\n                    env_2_add.save()\n                consolidated_env_id.append(env_2_add.id)\n        post_payload['osInstanceEnvironmentsID'] = consolidated_env_id\n\n        if self.team_ids is not None:\n            consolidated_team_id = copy.deepcopy(self.team_ids)\n        if self.team_2_rm is not None:\n            for team_2_rm in self.team_2_rm:\n                if team_2_rm.id is None:\n                    team_2_rm.sync()\n                consolidated_team_id.remove(team_2_rm.id)\n        if self.team_2_add is not None:\n            for team_2_add in self.team_2_add:\n                if team_2_add.id is None:\n                    team_2_add.save()\n                consolidated_team_id.append(team_2_add.id)\n        post_payload['osInstanceTeamsID'] = consolidated_team_id\n\n        args = {'http_operation': 'POST', 'operation_path': '', 'parameters': {'payload': json.dumps(post_payload)}}\n        response = OSInstanceService.requester.call(args)\n        if response.rc != 0:\n            LOGGER.warning(\n                'OSInstance.save - Problem while saving OS instance ' + self.name +\n                '. Reason: ' + str(response.response_content) + '-' + str(response.error_message) +\n                \" (\" + str(response.rc) + \")\"\n            )\n        else:\n            self.id = response.response_content['osInstanceID']\n            if self.embedded_osi_2_add is not None:\n                for osi_2_add in self.embedded_osi_2_add:\n                    osi_2_add.sync()\n            if self.embedded_osi_2_rm is not None:\n                for osi_2_rm in self.embedded_osi_2_rm:\n                    osi_2_rm.sync()\n            if self.ip_address_2_add is not None:\n                for ipa_2_add in self.ip_address_2_add:\n                    ipa_2_add.sync()\n            if self.ip_address_2_rm is not None:\n                for ipa_2_rm in self.ip_address_2_rm:\n                    ipa_2_rm.sync()\n            if self.nic_2_add is not None:\n                for nic_2_add in self.nic_2_add:\n                    nic_2_add.sync()\n            if self.nic_2_rm is not None:\n                for nic_2_rm in self.nic_2_rm:\n                    nic_2_rm.sync()\n            if self.subnets_2_add is not None:\n                for snet_2_add in self.subnets_2_add:\n                    snet_2_add.sync()\n            if self.subnets_2_rm is not None:\n                for snet_2_rm in self.subnets_2_rm:\n                    snet_2_rm.sync()\n            if self.application_2_add is not None:\n                for app_2_add in self.application_2_add:\n                    app_2_add.sync()\n            if self.application_2_rm is not None:\n                for app_2_rm in self.application_2_rm:\n                    app_2_rm.sync()\n            if self.environment_2_add is not None:\n                for env_2_add in self.environment_2_add:\n                    env_2_add.sync()\n            if self.environment_2_rm is not None:\n                for env_2_rm in self.environment_2_rm:\n                    env_2_rm.sync()\n            if self.team_2_add is not None:\n                for team_2_add in self.team_2_add:\n                    team_2_add.sync()\n            if self.team_2_rm is not None:\n                for team_2_rm in self.team_2_rm:\n                    team_2_rm.sync()\n\n        self.embedded_osi_2_add.clear()\n        self.embedded_osi_2_rm.clear()\n        self.ip_address_2_add.clear()\n        self.ip_address_2_rm.clear()\n        self.nic_2_add.clear()\n        self.nic_2_rm.clear()\n        self.subnets_2_add.clear()\n        self.subnets_2_rm.clear()\n        self.application_2_add.clear()\n        self.application_2_rm.clear()\n        self.environment_2_add.clear()\n        self.environment_2_rm.clear()\n        self.team_2_add.clear()\n        self.team_2_rm.clear()\n        self.sync()\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nfinds the OS type according to the given parameters.", "response": "def find_ostype(ost_id=None, ost_name=None, ost_arch=None):\n        \"\"\"\n        find the OS type (ost) according ost id (prioritary) or ost name\n        :param ost_id: the OS type id\n        :param ost_name: the OS type name\n        :param ost_arch: the OS type architecture\n        :return: found OS type or None if not found\n        \"\"\"\n        LOGGER.debug(\"OSTypeService.find_ostype\")\n        if (ost_id is None or not ost_id) and (ost_name is None or not ost_name) and (ost_arch is None or not ost_arch):\n            raise exceptions.ArianeCallParametersError('id and (name, architecture)')\n\n        if (ost_id is not None and ost_id) and ((ost_name is not None and ost_name) or\n                                                (ost_arch is not None and ost_arch)):\n            LOGGER.warn('OSTypeService.find_ostype - Both id and (name, arc) are defined. Will give you search on id.')\n            ost_name = None\n            ost_arch = None\n\n        if ((ost_name is not None and ost_name) and (ost_arch is None or not ost_arch)) or\\\n           ((ost_arch is not None and ost_arch) and (ost_name is None or not ost_name)):\n            raise exceptions.ArianeCallParametersError('(name, architecture)')\n\n        params = None\n        if ost_id is not None and ost_id:\n            params = {'id': ost_id}\n        elif ost_name is not None and ost_name and ost_arch is not None and ost_arch:\n            params = {'name': ost_name, 'arc': ost_arch}\n\n        ret = None\n        if params is not None:\n            args = {'http_operation': 'GET', 'operation_path': 'get', 'parameters': params}\n            response = OSTypeService.requester.call(args)\n            if response.rc == 0:\n                ret = OSType.json_2_ostype(response.response_content)\n            elif response.rc != 404:\n                err_msg = 'OSTypeService.find_ostype - Problem while finding OS Type (id:' + str(ost_id) + \\\n                          ', name:' + str(ost_name) + '). ' + \\\n                          'Reason: ' + str(response.response_content) + '-' + str(response.error_message) + \\\n                          \" (\" + str(response.rc) + \")\"\n                LOGGER.warning(\n                    err_msg\n                )\n\n        return ret"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_ostypes():\n        LOGGER.debug(\"OSTypeService.get_ostypes\")\n        args = {'http_operation': 'GET', 'operation_path': ''}\n        response = OSTypeService.requester.call(args)\n        ret = None\n        if response.rc == 0:\n            ret = []\n            for os_type in response.response_content['osTypes']:\n                ret.append(OSType.json_2_ostype(os_type))\n        elif response.rc != 404:\n            err_msg = 'OSTypeService.get_ostypes - Problem while getting OS Types.' \\\n                      '. Reason: ' + str(response.response_content) + '-' + str(response.error_message) + \\\n                      \" (\" + str(response.rc) + \")\"\n            LOGGER.warning(err_msg)\n\n        return ret", "response": "Get all knows OS types."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef json_2_ostype(json_obj):\n        LOGGER.debug(\"OSType.json_2_ostype\")\n        return OSType(ostid=json_obj['osTypeID'],\n                      name=json_obj['osTypeName'],\n                      architecture=json_obj['osTypeArchitecture'],\n                      os_type_company_id=json_obj['osTypeCompanyID'],\n                      os_type_os_instance_ids=json_obj['osTypeOSInstancesID'])", "response": "Transform the JSON obj coming from Ariane to ariane_clip3 OS type object."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ntransform ariane_clip3 OS Type object to Ariane server JSON obj", "response": "def ostype_2_json(self):\n        \"\"\"\n        transform ariane_clip3 OS Type object to Ariane server JSON obj\n        :return: Ariane JSON obj\n        \"\"\"\n        LOGGER.debug(\"OSType.ostype_2_json\")\n        json_obj = {\n            'osTypeID': self.id,\n            'osTypeName': self.name,\n            'osTypeArchitecture': self.architecture,\n            'osTypeCompanyID': self.company_id,\n            'osTypeOSInstancesID': self.osi_ids\n        }\n        return json.dumps(json_obj)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef sync(self):\n        LOGGER.debug(\"OSType.sync\")\n        params = None\n        if self.id is not None:\n            params = {'id': self.id}\n        elif self.name is not None:\n            params = {'name': self.name}\n\n        if params is not None:\n            args = {'http_operation': 'GET', 'operation_path': 'get', 'parameters': params}\n            response = OSTypeService.requester.call(args)\n            if response.rc != 0:\n                LOGGER.warning(\n                    'OSType.sync - Problem while syncing OS type (name:' + self.name + ', id: ' + str(self.id) +\n                    '). Reason: ' + str(response.response_content) + '-' + str(response.error_message) +\n                    \" (\" + str(response.rc) + \")\"\n                )\n            else:\n                json_obj = response.response_content\n                self.id = json_obj['osTypeID']\n                self.name = json_obj['osTypeName']\n                self.architecture = json_obj['osTypeArchitecture']\n                if json_obj['osTypeCompanyID'] == -1:\n                    self.company_id = None\n                else:\n                    self.company_id = json_obj['osTypeCompanyID']\n                self.osi_ids = json_obj['osTypeOSInstancesID']", "response": "Synchronizes this OSType object with Ariane server according its id or name."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef find_application(app_id=None, app_name=None):\n        LOGGER.debug(\"ApplicationService.find_application\")\n        if (app_id is None or not app_id) and (app_name is None or not app_name):\n            raise exceptions.ArianeCallParametersError('id and name')\n\n        if (app_id is not None and app_id) and (app_name is not None and app_name):\n            LOGGER.warn('ApplicationService.find_application - Both id and name are defined. '\n                        'Will give you search on id.')\n            app_name = None\n\n        params = None\n        if app_id is not None and app_id:\n            params = {'id': app_id}\n        elif app_name is not None and app_name:\n            params = {'name': app_name}\n\n        ret = None\n        if params is not None:\n            args = {'http_operation': 'GET', 'operation_path': 'get', 'parameters': params}\n            response = ApplicationService.requester.call(args)\n            if response.rc == 0:\n                ret = Application.json_2_application(response.response_content)\n            elif response.rc != 404:\n                err_msg = 'ApplicationService.find_application - Problem while finding application (id:' + \\\n                          str(app_id) + ', name:' + str(app_name) + '). ' + \\\n                          'Reason: ' + str(response.response_content) + '-' + str(response.error_message) + \\\n                          \" (\" + str(response.rc) + \")\"\n                LOGGER.warning(\n                    err_msg\n                )\n\n        return ret", "response": "find the application according application id or application name"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_applications():\n        LOGGER.debug(\"ApplicationService.get_applications\")\n        args = {'http_operation': 'GET', 'operation_path': ''}\n        response = ApplicationService.requester.call(args)\n        ret = None\n        if response.rc == 0:\n            ret = []\n            for application in response.response_content['applications']:\n                ret.append(Application.json_2_application(application))\n        elif response.rc != 404:\n            err_msg = 'ApplicationService.get_applications - Problem while getting applications. ' \\\n                      'Reason: ' + str(response.response_content) + '-' + str(response.error_message) + \\\n                      \" (\" + str(response.rc) + \")\"\n            LOGGER.warning(err_msg)\n        return ret", "response": "Get all knows applications"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ntransforming JSON obj coming from Ariane to ariane_clip3 object", "response": "def json_2_application(json_obj):\n        \"\"\"\n        transform JSON obj coming from Ariane to ariane_clip3 object\n        :param json_obj: the JSON obj coming from Ariane\n        :return: ariane_clip3 Application object\n        \"\"\"\n        LOGGER.debug(\"Application.json_2_application\")\n        return Application(appid=json_obj['applicationID'],\n                           name=json_obj['applicationName'],\n                           description=json_obj['applicationDescription'],\n                           short_name=json_obj['applicationShortName'],\n                           color_code=json_obj['applicationColorCode'],\n                           company_id=json_obj['applicationCompanyID'],\n                           team_id=json_obj['applicationTeamID'],\n                           osi_ids=json_obj['applicationOSInstancesID'])"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ntransforms ariane_clip3 Application object to Ariane server JSON obj", "response": "def application_2_json(self):\n        \"\"\"\n        transform ariane_clip3 Application object to Ariane server JSON obj\n        :return: Ariane JSON obj\n        \"\"\"\n        LOGGER.debug(\"Application.application_2_json\")\n        json_obj = {\n            'applicationID': self.id,\n            'applicationName': self.name,\n            'applicationDescription': self.description,\n            'applicationShortName': self.short_name,\n            'applicationColorCode': self.color_code,\n            'applicationCompanyID': self.company_id,\n            'applicationTeamID': self.team_id,\n            'applicationOSInstancesID': self.osi_ids\n        }\n        return json.dumps(json_obj)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nsynchronize this application with Ariane server according its id or name.", "response": "def sync(self):\n        \"\"\"\n        synchronize self from Ariane server according its id (prioritary) or name\n        :return:\n        \"\"\"\n        LOGGER.debug(\"Application.sync\")\n        params = None\n        if self.id is not None:\n            params = {'id': self.id}\n        elif self.name is not None:\n            params = {'name': self.name}\n\n        if params is not None:\n            args = {'http_operation': 'GET', 'operation_path': 'get', 'parameters': params}\n            response = ApplicationService.requester.call(args)\n            if response.rc != 0:\n                LOGGER.warning(\n                    'Application.sync - Problem while syncing application (name:' + self.name + 'id: ' + str(self.id) +\n                    '). Reason: ' + str(response.response_content) + '-' + str(response.error_message) +\n                    \" (\" + str(response.rc) + \")\"\n                )\n            else:\n                json_obj = response.response_content\n                self.id = json_obj['applicationID']\n                self.name = json_obj['applicationName']\n                self.description = json_obj['applicationDescription']\n                self.short_name = json_obj['applicationShortName']\n                self.color_code = json_obj['applicationColorCode']\n                if json_obj['applicationCompanyID'] == -1:\n                    self.company_id = None\n                else:\n                    self.company_id = json_obj['applicationCompanyID']\n                if json_obj['applicationTeamID'] == -1:\n                    self.team_id = None\n                else:\n                    self.team_id = json_obj['applicationTeamID']\n                self.osi_ids = json_obj['applicationOSInstancesID']"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nfind the company according company id or company name", "response": "def find_company(cmp_id=None, cmp_name=None):\n        \"\"\"\n        find the company according company id (prioritary) or company name\n        :param cmp_id: the company id\n        :param cmp_name: the company name\n        :return: found company or None if not found\n        \"\"\"\n        LOGGER.debug(\"CompanyService.find_company\")\n        if (cmp_id is None or not cmp_id) and (cmp_name is None or not cmp_name):\n            raise exceptions.ArianeCallParametersError('id and name')\n\n        if (cmp_id is not None and cmp_id) and (cmp_name is not None and cmp_name):\n            LOGGER.warn('CompanyService.find_company - Both id and name are defined. Will give you search on id.')\n            cmp_name = None\n\n        params = None\n        if cmp_id is not None and cmp_id:\n            params = {'id': cmp_id}\n        elif cmp_name is not None and cmp_name:\n            params = {'name': cmp_name}\n\n        ret = None\n        if params is not None:\n            args = {'http_operation': 'GET', 'operation_path': 'get', 'parameters': params}\n            response = CompanyService.requester.call(args)\n            if response.rc == 0:\n                ret = Company.json_2_company(response.response_content)\n            elif response.rc != 404:\n                err_msg = 'CompanyService.find_company - Problem while finding company (id:' + str(cmp_id) + \\\n                          ', name:' + str(cmp_name) + '). ' + \\\n                          'Reason: ' + str(response.response_content) + '-' + str(response.error_message) + \\\n                          \" (\" + str(response.rc) + \")\"\n                LOGGER.warning(\n                    err_msg\n                )\n\n        return ret"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_companies():\n        LOGGER.debug(\"CompanyService.get_companies\")\n        args = {'http_operation': 'GET', 'operation_path': ''}\n        response = CompanyService.requester.call(args)\n        ret = None\n        if response.rc == 0:\n            ret = []\n            for company in response.response_content['companies']:\n                ret.append(Company.json_2_company(company))\n        elif response.rc != 404:\n            err_msg = 'CompanyService.get_companies - Problem while getting companies. ' \\\n                      'Reason: ' + str(response.response_content) + '-' + str(response.error_message) + \\\n                      \" (\" + str(response.rc) + \")\"\n            LOGGER.warning(err_msg)\n        return ret", "response": "Get all knows companies"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ntransforming JSON obj coming from Ariane to ariane_clip3 company object", "response": "def json_2_company(json_obj):\n        \"\"\"\n        transform JSON obj coming from Ariane to ariane_clip3 object\n        :param json_obj: the JSON obj coming from Ariane\n        :return: ariane_clip3 Company object\n        \"\"\"\n        LOGGER.debug(\"Company.json_2_company\")\n        return Company(cmpid=json_obj['companyID'],\n                       name=json_obj['companyName'],\n                       description=json_obj['companyDescription'],\n                       application_ids=json_obj['companyApplicationsID'],\n                       ost_ids=json_obj['companyOSTypesID'])"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ntransform ariane_clip3 company object to Ariane server JSON obj", "response": "def company_2_json(self):\n        \"\"\"\n        transform ariane_clip3 company object to Ariane server JSON obj\n        :return: Ariane JSON obj\n        \"\"\"\n        LOGGER.debug(\"Company.company_2_json\")\n        json_obj = {\n            'companyID': self.id,\n            'companyName': self.name,\n            'companyDescription': self.description,\n            'companyApplicationsID': self.applications_ids,\n            'companyOSTypesID': self.ost_ids\n        }\n        return json.dumps(json_obj)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef sync(self):\n        LOGGER.debug(\"Company.sync\")\n        params = None\n        if self.id is not None:\n            params = {'id': self.id}\n        elif self.name is not None:\n            params = {'name': self.name}\n\n        if params is not None:\n            args = {'http_operation': 'GET', 'operation_path': 'get', 'parameters': params}\n            response = CompanyService.requester.call(args)\n            if response.rc != 0:\n                LOGGER.warning(\n                    'Company.sync - Problem while syncing company (name:' + self.name + ', id:' + str(self.id) +\n                    '). Reason: ' + str(response.response_content) + '-' + str(response.error_message) +\n                    \" (\" + str(response.rc) + \")\"\n                )\n            else:\n                json_obj = response.response_content\n                self.id = json_obj['companyID']\n                self.name = json_obj['companyName']\n                self.description = json_obj['companyDescription']\n                self.applications_ids = json_obj['companyApplicationsID']\n                self.ost_ids = json_obj['companyOSTypesID']", "response": "Synchronize this company with Ariane server according its id or name."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add_application(self, application, sync=True):\n        LOGGER.debug(\"Company.add_application\")\n        if not sync:\n            self.applications_2_add.append(application)\n        else:\n            if application.id is None:\n                application.save()\n            if self.id is not None and application.id is not None:\n                params = {\n                    'id': self.id,\n                    'applicationID': application.id\n                }\n                args = {'http_operation': 'GET', 'operation_path': 'update/applications/add', 'parameters': params}\n                response = CompanyService.requester.call(args)\n                if response.rc != 0:\n                    LOGGER.warning(\n                        'Company.add_application - Problem while updating company ' + self.name +\n                        '. Reason: ' + str(response.response_content) + '-' + str(response.error_message) +\n                        \" (\" + str(response.rc) + \")\"\n                    )\n                else:\n                    self.applications_ids.append(application.id)\n                    application.sync()\n            else:\n                LOGGER.warning(\n                    'Company.add_application - Problem while updating company ' + self.name + '. Reason: application ' +\n                    application.name + ' id is None or self.id is None'\n                )", "response": "Add an application to this company."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef del_application(self, application, sync=True):\n        LOGGER.debug(\"Company.del_application\")\n        if not sync:\n            self.applications_2_rm.append(application)\n        else:\n            if application.id is None:\n                application.sync()\n            if self.id is not None and application.id is not None:\n                params = {\n                    'id': self.id,\n                    'applicationID': application.id\n                }\n                args = {'http_operation': 'GET', 'operation_path': 'update/applications/delete', 'parameters': params}\n                response = CompanyService.requester.call(args)\n                if response.rc != 0:\n                    LOGGER.warning(\n                        'Company.del_application - Problem while updating company ' + self.name +\n                        '. Reason: ' + str(response.response_content) + '-' + str(response.error_message) +\n                        \" (\" + str(response.rc) + \")\"\n                    )\n                else:\n                    self.applications_ids.remove(application.id)\n                    application.sync()\n            else:\n                LOGGER.warning(\n                    'Company.del_application - Problem while updating company ' + self.name + '. Reason: application ' +\n                    application.name + ' id is None or self.id is None'\n                )", "response": "This method deletes an application from this company."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add_ostype(self, ostype, sync=True):\n        LOGGER.debug(\"Company.add_ostype\")\n        if not sync:\n            self.ost_2_add.append(ostype)\n        else:\n            if ostype.id is None:\n                ostype.save()\n            if self.id is not None and ostype.id is not None:\n                params = {\n                    'id': self.id,\n                    'ostypeID': ostype.id\n                }\n                args = {'http_operation': 'GET', 'operation_path': 'update/ostypes/add', 'parameters': params}\n                response = CompanyService.requester.call(args)\n                if response.rc != 0:\n                    LOGGER.warning(\n                        'Company.add_ostype - Problem while updating company ' + self.name +\n                        '. Reason: ' + str(response.response_content) + '-' + str(response.error_message) +\n                        \" (\" + str(response.rc) + \")\"\n                    )\n                else:\n                    self.ost_ids.append(ostype.id)\n                    ostype.sync()\n            else:\n                LOGGER.warning(\n                    'Company.add_ostype - Problem while updating company ' + self.name + '. Reason: ostype ' +\n                    ostype.name + ' id is None or self.id is None'\n                )", "response": "Add an OS type object to this company."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndeleting an OS type from this company.", "response": "def del_ostype(self, ostype, sync=True):\n        \"\"\"\n        delete OS type from this company\n        :param ostype: the OS type to be deleted from this company\n        :param sync: If sync=True(default) synchronize with Ariane server. If sync=False,\n        add the OS type object on list to be removed on next save().\n        :return:\n        \"\"\"\n        LOGGER.debug(\"Company.del_ostype\")\n        if not sync:\n            self.ost_2_rm.append(ostype)\n        else:\n            if ostype.id is None:\n                ostype.sync()\n            if self.id is not None and ostype.id is not None:\n                params = {\n                    'id': self.id,\n                    'ostypeID': ostype.id\n                }\n                args = {'http_operation': 'GET', 'operation_path': 'update/ostypes/delete', 'parameters': params}\n                response = CompanyService.requester.call(args)\n                if response.rc != 0:\n                    LOGGER.warning(\n                        'Company.del_ostype - Problem while updating company ' + self.name +\n                        '. Reason: ' + str(response.response_content) + '-' + str(response.error_message) +\n                        \" (\" + str(response.rc) + \")\"\n                    )\n                else:\n                    self.ost_ids.remove(ostype.id)\n                    ostype.sync()\n            else:\n                LOGGER.warning(\n                    'Company.del_ostype - Problem while updating company ' + self.name + '. Reason: ostype ' +\n                    ostype.name + ' id is None or self.id is None'\n                )"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsaves this company on Ariane server.", "response": "def save(self):\n        \"\"\"\n        :return: save this company on Ariane server (create or update)\n        \"\"\"\n        LOGGER.debug(\"Company.save\")\n        post_payload = {}\n        consolidated_app_id = []\n        consolidated_ost_id = []\n\n        if self.id is not None:\n            post_payload['companyID'] = self.id\n\n        if self.name is not None:\n            post_payload['companyName'] = self.name\n\n        if self.description is not None:\n            post_payload['companyDescription'] = self.description\n\n        if self.ost_ids is not None:\n            consolidated_ost_id = copy.deepcopy(self.ost_ids)\n        if self.ost_2_rm is not None:\n            for ost_2_rm in self.ost_2_rm:\n                if ost_2_rm.id is None:\n                    ost_2_rm.sync()\n                consolidated_ost_id.remove(ost_2_rm.id)\n        if self.ost_2_add is not None:\n            for ost_id_2_add in self.ost_2_add:\n                if ost_id_2_add.id is None:\n                    ost_id_2_add.save()\n                consolidated_ost_id.append(ost_id_2_add.id)\n        post_payload['companyOSTypesID'] = consolidated_ost_id\n\n        if self.applications_ids is not None:\n            consolidated_app_id = copy.deepcopy(self.applications_ids)\n        if self.applications_2_rm is not None:\n            for app_2_rm in self.applications_2_rm:\n                if app_2_rm.id is None:\n                    app_2_rm.sync()\n                consolidated_app_id.remove(app_2_rm.id)\n        if self.applications_2_add is not None:\n            for app_id_2_add in self.applications_2_add:\n                if app_id_2_add.id is None:\n                    app_id_2_add.save()\n                consolidated_app_id.append(app_id_2_add.id)\n        post_payload['companyApplicationsID'] = consolidated_app_id\n\n        args = {'http_operation': 'POST', 'operation_path': '', 'parameters': {'payload': json.dumps(post_payload)}}\n        response = CompanyService.requester.call(args)\n        if response.rc != 0:\n            LOGGER.warning(\n                'Company.save - Problem while saving company' + self.name +\n                '. Reason: ' + str(response.response_content) + '-' + str(response.error_message) +\n                \" (\" + str(response.rc) + \")\"\n            )\n        else:\n            self.id = response.response_content['companyID']\n            if self.ost_2_add is not None:\n                for ost_2_add in self.ost_2_add:\n                    ost_2_add.sync()\n            if self.ost_2_rm is not None:\n                for ost_2_rm in self.ost_2_rm:\n                    ost_2_rm.sync()\n            if self.applications_2_add is not None:\n                for app_2_add in self.applications_2_add:\n                    app_2_add.sync()\n            if self.applications_2_rm is not None:\n                for app_2_rm in self.applications_2_rm:\n                    app_2_rm.sync()\n        self.ost_2_add.clear()\n        self.ost_2_rm.clear()\n        self.applications_2_add.clear()\n        self.applications_2_rm.clear()\n        self.sync()\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef find_environment(env_id=None, env_name=None):\n        LOGGER.debug(\"EnvironmentService.find_environment\")\n        if (env_id is None or not env_id) and (env_name is None or not env_name):\n            raise exceptions.ArianeCallParametersError('id and name')\n\n        if (env_id is not None and env_id) and (env_name is not None and env_name):\n            LOGGER.warn('Both id and name are defined. Will give you search on id.')\n            env_name = None\n\n        params = None\n        if env_id is not None and env_id:\n            params = {'id': env_id}\n        elif env_name is not None and env_name:\n            params = {'name': env_name}\n\n        ret = None\n        if params is not None:\n            args = {'http_operation': 'GET', 'operation_path': 'get', 'parameters': params}\n            response = EnvironmentService.requester.call(args)\n            if response.rc == 0:\n                ret = Environment.json_2_environment(response.response_content)\n            elif response.rc != 404:\n                err_msg = 'EnvironmentService.find_environment - Problem while finding environment (id:' + \\\n                          str(env_id) + ', name:' + str(env_name) + '). ' + \\\n                          'Reason: ' + str(response.response_content) + '-' + str(response.error_message) + \\\n                          \" (\" + str(response.rc) + \")\"\n                LOGGER.warning(\n                    err_msg\n                )\n\n        return ret", "response": "find the environment according environment id or environment name"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting all knows environments", "response": "def get_environments():\n        \"\"\"\n        :return: all knows environments\n        \"\"\"\n        LOGGER.debug(\"EnvironmentService.get_environments\")\n        args = {'http_operation': 'GET', 'operation_path': ''}\n        response = EnvironmentService.requester.call(args)\n        ret = None\n        if response.rc == 0:\n            ret = []\n            for environment in response.response_content['environments']:\n                ret.append(Environment.json_2_environment(environment))\n        elif response.rc != 404:\n            err_msg = 'EnvironmentService.get_environments - Problem while getting environments. ' \\\n                      'Reason: ' + str(response.response_content) + '-' + str(response.error_message) + \\\n                      \" (\" + str(response.rc) + \")\"\n            LOGGER.warning(err_msg)\n        return ret"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ntransform JSON obj coming from Ariane to ariane_clip3 Environment object", "response": "def json_2_environment(json_obj):\n        \"\"\"\n        transform JSON obj coming from Ariane to ariane_clip3 object\n        :param json_obj: the JSON obj coming from Ariane\n        :return: ariane_clip3 Environment object\n        \"\"\"\n        LOGGER.debug(\"Environment.json_2_environment\")\n        return Environment(envid=json_obj['environmentID'],\n                           name=json_obj['environmentName'],\n                           description=json_obj['environmentDescription'],\n                           color_code=json_obj['environmentColorCode'],\n                           osi_ids=json_obj['environmentOSInstancesID'])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ntransforming ariane_clip3 environment object to Ariane server JSON obj", "response": "def environment_2_json(self):\n        \"\"\"\n        transform ariane_clip3 environment object to Ariane server JSON obj\n        :return: Ariane JSON obj\n        \"\"\"\n        LOGGER.debug(\"Environment.environment_2_json\")\n        json_obj = {\n            'environmentID': self.id,\n            'environmentName': self.name,\n            'environmentDescription': self.description,\n            'environmentColorCode': self.color_code,\n            'environmentOSInstancesID': self.osi_ids\n        }\n        return json.dumps(json_obj)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef save(self):\n        LOGGER.debug(\"Environment.save\")\n        post_payload = {}\n        consolidated_osi_id = []\n\n        if self.id is not None:\n            post_payload['environmentID'] = self.id\n\n        if self.name is not None:\n            post_payload['environmentName'] = self.name\n\n        if self.description is not None:\n            post_payload['environmentDescription'] = self.description\n\n        if self.color_code is not None:\n            post_payload['environmentColorCode'] = self.color_code\n\n        if self.osi_ids is not None:\n            consolidated_osi_id = copy.deepcopy(self.osi_ids)\n        if self.osi_2_rm is not None:\n            for osi_2_rm in self.osi_2_rm:\n                if osi_2_rm.id is None:\n                    osi_2_rm.sync()\n                consolidated_osi_id.remove(osi_2_rm.id)\n        if self.osi_2_add is not None:\n            for osi_id_2_add in self.osi_2_add:\n                if osi_id_2_add.id is None:\n                    osi_id_2_add.save()\n                consolidated_osi_id.append(osi_id_2_add.id)\n        post_payload['environmentOSInstancesID'] = consolidated_osi_id\n\n        args = {'http_operation': 'POST', 'operation_path': '', 'parameters': {'payload': json.dumps(post_payload)}}\n        response = EnvironmentService.requester.call(args)\n        if response.rc != 0:\n            LOGGER.warning(\n                'Environment.save - Problem while saving environment ' + self.name +\n                '. Reason: ' + str(response.response_content) + '-' + str(response.error_message) +\n                \" (\" + str(response.rc) + \")\"\n            )\n        else:\n            self.id = response.response_content['environmentID']\n            if self.osi_2_add is not None:\n                for osi_2_add in self.osi_2_add:\n                    osi_2_add.sync()\n            if self.osi_2_rm is not None:\n                for osi_2_rm in self.osi_2_rm:\n                    osi_2_rm.sync()\n        self.osi_2_add.clear()\n        self.osi_2_rm.clear()\n        self.sync()\n        return self", "response": "Save this environment on Ariane server."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nremove this environment from Ariane server.", "response": "def remove(self):\n        \"\"\"\n        remove this object from Ariane server\n        :return:\n        \"\"\"\n        LOGGER.debug(\"Environment.remove\")\n        if self.id is None:\n            return None\n        else:\n            params = {\n                'id': self.id\n            }\n            args = {'http_operation': 'GET', 'operation_path': 'delete', 'parameters': params}\n            response = EnvironmentService.requester.call(args)\n            if response.rc != 0:\n                LOGGER.warning(\n                    'Environment.remove - Problem while deleting environment ' + self.name +\n                    '. Reason: ' + str(response.response_content) + '-' + str(response.error_message) +\n                    \" (\" + str(response.rc) + \")\"\n                )\n                return self\n            else:\n                return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef find_team(team_id=None, team_name=None):\n        LOGGER.debug(\"TeamService.find_team\")\n        if (team_id is None or not team_id) and (team_name is None or not team_name):\n            raise exceptions.ArianeCallParametersError('id and name')\n\n        if (team_id is not None and team_id) and (team_name is not None and team_name):\n            LOGGER.warn('TeamService.find_team - Both id and name are defined. Will give you search on id.')\n            team_name = None\n\n        params = None\n        if team_id is not None and team_id:\n            params = {'id': team_id}\n        elif team_name is not None and team_name:\n            params = {'name': team_name}\n\n        ret = None\n        if params is not None:\n            args = {'http_operation': 'GET', 'operation_path': 'get', 'parameters': params}\n            response = TeamService.requester.call(args)\n            if response.rc == 0:\n                ret = Team.json_2_team(response.response_content)\n            elif response.rc != 404:\n                err_msg = 'TeamService.find_team - Problem while finding team (id:' + str(team_id) + \\\n                          ', name:' + str(team_name) + '). ' + \\\n                          '. Reason: ' + str(response.response_content) + '-' + str(response.error_message) + \\\n                          \" (\" + str(response.rc) + \")\"\n                LOGGER.warning(\n                    err_msg\n                )\n\n        return ret", "response": "Find the team according team id or team name."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_teams():\n        LOGGER.debug(\"TeamService.get_teams\")\n        args = {'http_operation': 'GET', 'operation_path': ''}\n        response = TeamService.requester.call(args)\n        ret = None\n        if response.rc == 0:\n            ret = []\n            for team in response.response_content['teams']:\n                ret.append(Team.json_2_team(team))\n        elif response.rc != 404:\n            err_msg = 'TeamService.get_teams - Problem while getting teams. ' \\\n                      '. Reason: ' + str(response.response_content) + '-' + str(response.error_message) + \\\n                      \" (\" + str(response.rc) + \")\"\n            LOGGER.warning(err_msg)\n        return ret", "response": "Get all knows teams"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ntransform JSON obj coming from Ariane to ariane_clip3 Team object", "response": "def json_2_team(json_obj):\n        \"\"\"\n        transform JSON obj coming from Ariane to ariane_clip3 object\n        :param json_obj: the JSON obj coming from Ariane\n        :return: ariane_clip3 Team object\n        \"\"\"\n        LOGGER.debug(\"Team.json_2_team\")\n        return Team(teamid=json_obj['teamID'],\n                    name=json_obj['teamName'],\n                    description=json_obj['teamDescription'],\n                    color_code=json_obj['teamColorCode'],\n                    app_ids=json_obj['teamApplicationsID'],\n                    osi_ids=json_obj['teamOSInstancesID'])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef team_2_json(self):\n        LOGGER.debug(\"Team.team_2_json\")\n        json_obj = {\n            'teamID': self.id,\n            'teamName': self.name,\n            'teamDescription': self.description,\n            'teamColorCode': self.color_code,\n            'teamOSInstancesID': self.osi_ids,\n            'teamApplicationsID': self.app_ids\n        }\n        return json.dumps(json_obj)", "response": "transform ariane_clip3 team object to Ariane server JSON obj"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nadd an application to this team.", "response": "def add_application(self, application, sync=True):\n        \"\"\"\n        add a application to this team.\n        :param application: the application to add on this team\n        :param sync: If sync=True(default) synchronize with Ariane server. If sync=False,\n        add the application object on list to be added on next save().\n        :return:\n        \"\"\"\n        LOGGER.debug(\"Team.add_application\")\n        if not sync:\n            self.app_2_add.append(application)\n        else:\n            if application.id is None:\n                application.save()\n            if self.id is not None and application.id is not None:\n                params = {\n                    'id': self.id,\n                    'applicationID': application.id\n                }\n                args = {'http_operation': 'GET', 'operation_path': 'update/applications/add', 'parameters': params}\n                response = TeamService.requester.call(args)\n                if response.rc != 0:\n                    LOGGER.warning(\n                        'Team.add_application - Problem while updating team ' + self.name +\n                        '. Reason: ' + str(response.response_content) + '-' + str(response.error_message) +\n                        \" (\" + str(response.rc) + \")\"\n                    )\n                else:\n                    self.app_ids.append(application.id)\n                    application.sync()\n            else:\n                LOGGER.warning(\n                    'Team.add_application - Problem while updating team ' + self.name + '. Reason: application ' +\n                    application.name + ' id is None or self.id is None'\n                )"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef del_application(self, application, sync=True):\n        LOGGER.debug(\"Team.del_application\")\n        if not sync:\n            self.app_2_rm.append(application)\n        else:\n            if application.id is None:\n                application.sync()\n            if self.id is not None and application.id is not None:\n                params = {\n                    'id': self.id,\n                    'applicationID': application.id\n                }\n                args = {'http_operation': 'GET', 'operation_path': 'update/applications/delete', 'parameters': params}\n                response = TeamService.requester.call(args)\n                if response.rc != 0:\n                    LOGGER.warning(\n                        'Team.del_application - Problem while updating team ' + self.name +\n                        '. Reason: ' + str(response.response_content) + '-' + str(response.error_message) +\n                        \" (\" + str(response.rc) + \")\"\n                    )\n                else:\n                    self.app_ids.remove(application.id)\n                    application.sync()\n            else:\n                LOGGER.warning(\n                    'Team.del_application - Problem while updating team ' + self.name + '. Reason: application ' +\n                    application.name + ' id is None or self.id is None'\n                )", "response": "Delete an application from this team."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsaves this team on Ariane server.", "response": "def save(self):\n        \"\"\"\n        :return: save this team on Ariane server (create or update)\n        \"\"\"\n        LOGGER.debug(\"Team.save\")\n        post_payload = {}\n        consolidated_osi_id = []\n        consolidated_app_id = []\n\n        if self.id is not None:\n            post_payload['teamID'] = self.id\n\n        if self.name is not None:\n            post_payload['teamName'] = self.name\n\n        if self.description is not None:\n            post_payload['teamDescription'] = self.description\n\n        if self.color_code is not None:\n            post_payload['teamColorCode'] = self.color_code\n\n        if self.osi_ids is not None:\n            consolidated_osi_id = copy.deepcopy(self.osi_ids)\n        if self.osi_2_rm is not None:\n            for osi_2_rm in self.osi_2_rm:\n                if osi_2_rm.id is None:\n                    osi_2_rm.sync()\n                consolidated_osi_id.remove(osi_2_rm.id)\n        if self.osi_2_add is not None:\n            for osi_id_2_add in self.osi_2_add:\n                if osi_id_2_add.id is None:\n                    osi_id_2_add.save()\n                consolidated_osi_id.append(osi_id_2_add.id)\n        post_payload['teamOSInstancesID'] = consolidated_osi_id\n\n        if self.app_ids is not None:\n            consolidated_app_id = copy.deepcopy(self.app_ids)\n        if self.app_2_rm is not None:\n            for app_2_rm in self.app_2_rm:\n                if app_2_rm.id is None:\n                    app_2_rm.sync()\n                consolidated_app_id.remove(app_2_rm.id)\n        if self.app_2_add is not None:\n            for app_id_2_add in self.app_2_add:\n                if app_id_2_add.id is None:\n                    app_id_2_add.save()\n                consolidated_app_id.append(app_id_2_add.id)\n        post_payload['teamApplicationsID'] = consolidated_app_id\n\n        args = {'http_operation': 'POST', 'operation_path': '', 'parameters': {'payload': json.dumps(post_payload)}}\n        response = TeamService.requester.call(args)\n        if response.rc != 0:\n            LOGGER.warning(\n                'Team.save - Problem while saving team ' + self.name +\n                '. Reason: ' + str(response.response_content) + '-' + str(response.error_message) +\n                \" (\" + str(response.rc) + \")\"\n            )\n        else:\n            self.id = response.response_content['teamID']\n            if self.osi_2_add is not None:\n                for osi_2_add in self.osi_2_add:\n                    osi_2_add.sync()\n            if self.osi_2_rm is not None:\n                for osi_2_rm in self.osi_2_rm:\n                    osi_2_rm.sync()\n            if self.app_2_add is not None:\n                for app_2_add in self.app_2_add:\n                    app_2_add.sync()\n            if self.app_2_rm is not None:\n                for app_2_rm in self.app_2_rm:\n                    app_2_rm.sync()\n        self.osi_2_add.clear()\n        self.osi_2_rm.clear()\n        self.app_2_add.clear()\n        self.app_2_rm.clear()\n        self.sync()\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef random(magnitude=1):\n        theta = random.uniform(0, 2 * math.pi)\n        return magnitude * Vector(math.cos(theta), math.sin(theta))", "response": "Create a random unit vector pointing in a random direction."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef from_rectangle(box):\n        x = box.left + box.width * random.uniform(0, 1)\n        y = box.bottom + box.height * random.uniform(0, 1)\n        return Vector(x, y)", "response": "Create a vector randomly within the given rectangle."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nmove this vector towards the given target by the given extent.", "response": "def interpolate(self, target, extent):\n        \"\"\" Move this vector towards the given towards the target by the given \n        extent.  The extent should be between 0 and 1. \"\"\"\n        target = cast_anything_to_vector(target)\n        self += extent * (target - self)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef project(self, axis):\n        projection = self.get_projection(axis)\n        self.assign(projection)", "response": "Project this vector onto the given axis."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef dot_product(self, other):\n        return self.x * other.x + self.y * other.y", "response": "Return the dot product of the given vectors."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef perp_product(self, other):\n\n        return self.x * other.y - self.y * other.x", "response": "Return the perp product of the given vectors."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef rotate(self, angle):\n        x, y = self.tuple\n        self.x = x * math.cos(angle) - y * math.sin(angle)\n        self.y = x * math.sin(angle) + y * math.cos(angle)", "response": "Rotate the vector by an angle."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef round(self, digits=0):\n        # Meant as a way to clean up Vector.rotate()\n        # For example:\n        #   V = Vector(1,0)\n        #   V.rotate(2*pi)\n        #   \n        #   V is now <1.0, -2.4492935982947064e-16>, when it should be \n        #   <1,0>. V.round(15) will correct the error in this example.\n        \n        self.x = round(self.x, digits)\n        self.y = round(self.y, digits)", "response": "Round the elements of the given vector to the given number of digits."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a unit vector parallel to this one.", "response": "def get_scaled(self, magnitude):\n        \"\"\" Return a unit vector parallel to this one. \"\"\"\n        result = self.copy()\n        result.scale(magnitude)\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_interpolated(self, target, extent):\n        result = self.copy()\n        result.interpolate(target, extent)\n        return result", "response": "Return a new vector that has been moved towards the given target by \n        the given extent."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_projection(self, axis):\n        scale = axis.dot(self) / axis.dot(axis)\n        return axis * scale", "response": "Return the projection of this vector onto the given axis."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nbreak this vector into two vectors that are perpendicular to the given vector and other that are parallel to it.", "response": "def get_components(self, other):\n        \"\"\" Break this vector into one vector that is perpendicular to the \n        given vector and another that is parallel to it. \"\"\"\n        tangent = self.get_projection(other)\n        normal = self - tangent\n        return normal, tangent"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_radians(self):\n        if not self: raise NullVectorError()\n        return math.atan2(self.y, self.x)", "response": "Return the angle between this vector and the positive x - axis \n        measured in radians."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a vector rotated by angle from the given vector.", "response": "def get_rotated(self, angle):\n        \"\"\" Return a vector rotated by angle from the given vector. Angle measured in radians counter-clockwise. \"\"\"\n        result = self.copy()\n        result.rotate(angle)\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a copy of the set with the elements rounded to the given number of digits.", "response": "def get_rounded(self, digits):\n        \"\"\" Return a vector with the elements rounded to the given number of digits. \"\"\"\n        result = self.copy()\n        result.round(digits)\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset the angle that this vector makes with the x - axis.", "response": "def set_radians(self, angle):\n        \"\"\" Set the angle that this vector makes with the x-axis. \"\"\"\n        self.x, self.y = math.cos(angle), math.sin(angle)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef grow(self, *padding):\n        try:\n            lpad, rpad, tpad, bpad = padding\n        except ValueError:\n            lpad = rpad = tpad = bpad = padding[0]\n\n        self._bottom -= bpad\n        self._left -= lpad\n        self._width += lpad + rpad\n        self._height += tpad + bpad\n        return self", "response": "Grow this rectangle by the given padding on all sides."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndisplace this rectangle by the given vector.", "response": "def displace(self, vector):\n        \"\"\" Displace this rectangle by the given vector. \"\"\"\n        self._bottom += vector.y\n        self._left += vector.x\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef round(self, digits=0):\n        self._left = round(self._left, digits)\n        self._bottom = round(self._bottom, digits)\n        self._width = round(self._width, digits)\n        self._height = round(self._height, digits)", "response": "Round the dimensions of the given rectangle to the given number of digits."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set(self, shape):\n        self.bottom, self.left = shape.bottom, shape.left\n        self.width, self.height = shape.width, shape.height\n        return self", "response": "Fill this rectangle with the dimensions of the given shape."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn True if this rectangle is inside the given shape.", "response": "def inside(self, other):\n        \"\"\" Return true if this rectangle is inside the given shape. \"\"\"\n        return ( self.left >= other.left and\n                 self.right <= other.right and\n                 self.top <= other.top and\n                 self.bottom >= other.bottom)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn True if this rectangle is touching the given shape.", "response": "def touching(self, other):\n        \"\"\" Return true if this rectangle is touching the given shape. \"\"\"\n        if self.top < other.bottom: return False\n        if self.bottom > other.top: return False\n\n        if self.left > other.right: return False\n        if self.right < other.left: return False\n\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning True if the given shape is inside this rectangle.", "response": "def contains(self, other):\n        \"\"\" Return true if the given shape is inside this rectangle. \"\"\"\n        return (self.left <= other.left and\n                self.right >= other.right and\n                self.top >= other.top and\n                self.bottom <= other.bottom)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ngive a piece of data check each node type that the last node_type can lead to and act using the first whose checker returns true.", "response": "def _handle_node(self, data):\n    \"\"\"Given a piece of data, check each node_type that the last_node_type can lead to and act using\n    the first whose checker returns true.\n    \"\"\"\n    next_options = self.graph[self.last_node_type]\n    for node_type in next_options:\n      checker, handler, *_ = node_type\n      if checker(data):\n        self.last_node_type = node_type\n        self.handle(handler(data), node_type, data)\n        return\n    raise Exception(\"Unable to handle data: {}\".format(data))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef parse(self, nodes):\n    self.last_node_type = self.initial_node_type\n    for node_number, node in enumerate(nodes):\n      try:\n        self.step(node)\n      except Exception as ex:\n        raise Exception(\"An error occurred on node {}\".format(node_number)) from ex", "response": "Given a stream of nodes try to parse the nodes according to the machine s graph."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_name_for(self, dynamic_part):\n        dynamic_part = self.from_python(dynamic_part)\n        return super(DynamicRelatedFieldMixin, self).get_name_for(dynamic_part)", "response": "Returns the name for the current dynamic field accepting a limpyd\n        instance for the dynamic part"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nadds the given container in - place with this ConfigValue", "response": "def add_to_toml_obj(self, toml_obj: tomlkit.container.Container, not_set: str):\n        \"\"\"\n        Updates the given container in-place with this ConfigValue\n\n        :param toml_obj: container to update\n        :type toml_obj: tomlkit.container.Containers\n        :param not_set: random UUID used to denote a value that has no default\n        :type not_set: str\n        \"\"\"\n        self._toml_add_description(toml_obj)\n        self._toml_add_value_type(toml_obj)\n        self._toml_add_comments(toml_obj)\n        toml_obj.add(tomlkit.comment(''))\n        self._toml_add_value(toml_obj, not_set)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncomputes the statistics for each Jackknife subsample and the full sample.", "response": "def jackknife_stats(theta_subs, theta_full, N=None, d=1):\n    \"\"\"Compute Jackknife Estimates, SE, Bias, t-scores, p-values\n\n    Parameters:\n    -----------\n    theta_subs : ndarray\n        The metrics, estimates, parameters, etc. of\n        the model (see \"func\") for each subsample.\n        It is a <C x M> matrix, i.e. C=binocoeff(N,d)\n        subsamples, and M parameters that are returned\n        by the model.\n\n    theta_full : ndarray\n        The metrics, estimates, parameters, etc. of\n        the model (see \"func\") for the full sample.\n        It is a <1 x M> vecotr with the M parameters\n        that are returned by the model.\n\n    N : int\n        The number of observations in the full sample.\n        Is required for Delete-d Jackknife, i.e. d>1.\n        (Default is N=None)\n\n    d : int\n        The number of observations to leave out for\n        each Jackknife subsample, i.e. the subsample\n        size is N-d. (The default is d=1 for the\n        \"Delete-1 Jackknife\" procedure.)\n\n    Returns:\n    --------\n    pvalues : ndarray\n        The two-sided P-values of the t-Score for each\n        Jackknife estimate.\n        (In Social Sciences pval<0.05 is referred as\n        acceptable but it is usually better to look\n        for p-values way closer to Zero. Just remove\n        or replace a variable/feature with high\n        pval>=pcritical and run the Jackknife again.)\n\n    tscores : ndarray\n        The t-Score for each Jackknife estimate.\n        (As rule of thumb a value abs(tscore)>2 indicates\n        a bad model parameter but jsut check the p-value.)\n\n    theta_jack : ndarray\n        The bias-corrected Jackknife Estimates (model\n        parameter, metric, coefficient,  etc.). Use the\n        parameters for prediction.\n\n    se_jack : ndarray\n        The Jackknife Standard Error\n\n    theta_biased : ndarray\n        The biased Jackknife Estimate.\n\n\n    Other Variables:\n    ----------------\n    These variables occur in the source code as\n    intermediate results.\n\n    Q : int\n        The Number of independent variables of\n        a model (incl. intercept).\n\n    C : int\n        The number of Jackknife subsamples if d>1.\n        There are C=binocoeff(N,d) combinations.\n\n    \"\"\"\n    # The biased Jackknife Estimate\n    import numpy as np\n    theta_biased = np.mean(theta_subs, axis=0)\n\n    # Inflation Factor for the Jackknife Standard Error\n    if d is 1:\n        if N is None:\n            N = theta_subs.shape[0]\n        inflation = (N - 1) / N\n    elif d > 1:\n        if N is None:\n            raise Exception((\n                \"If d>1 then you must provide N (number of \"\n                \"observations in the full sample)\"))\n        C = theta_subs.shape[0]\n        inflation = ((N - d) / d) / C\n\n    # The Jackknife Standard Error\n    se_jack = np.sqrt(\n        inflation * np.sum((theta_subs - theta_biased)**2, axis=0))\n\n    # The bias-corrected Jackknife Estimate\n    theta_jack = N * theta_full - (N - 1) * theta_biased\n\n    # The Jackknife t-Statistics\n    tscores = theta_jack / se_jack\n\n    # Two-sided P-values\n    import scipy.stats\n    Q = theta_subs.shape[1]\n    pvalues = scipy.stats.t.sf(np.abs(tscores), N - Q - d) * 2\n\n    # done\n    return pvalues, tscores, theta_jack, se_jack, theta_biased"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef import_tasks(self, path):\n        for zz in os.walk(path):\n            for module in zz[2]:\n\n                if module.endswith('.py'):\n\n                    import importlib\n\n                    # from tasks.message_popup import *\n\n\n\n                    importlib.import_module('tasks.' + module[:-3])\n\n                    print 'imported', module", "response": "Attempts to load tasks from a given path."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef space_out_camel_case(stringAsCamelCase):\n    pattern = re.compile(r'([A-Z][A-Z][a-z])|([a-z][A-Z])')\n\n    if stringAsCamelCase is None:\n        return None\n\n    return pattern.sub(lambda m: m.group()[:1] + \" \" + m.group()[1:], stringAsCamelCase)", "response": "Space out a string in a camel case string."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef slugify(text, length_limit=0, delimiter=u'-'):\n    result = []\n    for word in _punctuation_regex.split(text.lower()):\n        word = _available_unicode_handlers[0](word)\n        if word:\n            result.append(word)\n    slug = delimiter.join(result)\n    if length_limit > 0:\n        return slug[0:length_limit]\n    return slug", "response": "Generates an ASCII - only slug of a string."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef read(self, stream):\n        stack = self.stack\n        while True:\n            if stack[0]:  # will be true once one sexp has been parsed\n                self.rest_string = stream\n                return False\n            c = stream.read(1)\n            if not c:\n                # no more stream and no complete sexp\n                return True\n            reading = type(stack[-1])\n            self.sexp_string.write(c)\n\n            if reading == tuple:\n                if c in atom_end:\n                    atom = stack.pop()\n                    stack[-1].append(atom)\n                    reading = type(stack[-1])\n            if reading == list:\n                if c == '(':\n                    stack.append([])\n                elif c == ')':\n                    stack[-2].append(stack.pop())\n                elif c == '\"':\n                    stack.append('')\n                elif c == \"'\":\n                    continue\n                elif c in whitespace:\n                    continue\n                else:\n                    stack.append(tuple())\n            elif reading == str:\n                if c == '\"':\n                    stack.pop()\n                # escaped char coming up, so read ahead\n                elif c == '\\\\':\n                    self.sexp_string.write(stream.read(1))", "response": "Reads a set of sexps from the stream. Returns True if the stream is complete."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nconverting a name to the ASCII vector.", "response": "def name_to_vector(name):\n    \"\"\"\n    Convert `name` to the ASCII vector.\n\n    Example:\n        >>> name_to_vector(\"ing. Franta Put\u0161\u00e1lek\")\n        ['putsalek', 'franta', 'ing']\n\n    Args:\n        name (str): Name which will be vectorized.\n\n    Returns:\n        list: Vector created from name.\n    \"\"\"\n    if not isinstance(name, unicode):\n        name = name.decode(\"utf-8\")\n\n    name = name.lower()\n    name = unicodedata.normalize('NFKD', name).encode('ascii', 'ignore')\n    name = \"\".join(filter(lambda x: x.isalpha() or x == \" \", list(name)))\n\n    return sorted(name.split(), key=lambda x: len(x), reverse=True)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef compare_names(first, second):\n    first = name_to_vector(first)\n    second = name_to_vector(second)\n\n    zipped = zip(first, second)\n\n    if not zipped:\n        return 0\n\n    similarity_factor = 0\n    for fitem, _ in zipped:\n        if fitem in second:\n            similarity_factor += 1\n\n    return (float(similarity_factor) / len(zipped)) * 100", "response": "Compare two names in complicated but more error prone way."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nfilter publications based at data from Aleph.", "response": "def filter_publication(publication, cmp_authors=True):\n    \"\"\"\n    Filter publications based at data from Aleph.\n\n    Args:\n        publication (obj): :class:`.Publication` instance.\n\n    Returns:\n        obj/None: None if the publication was found in Aleph or `publication` \\\n                  if not.\n    \"\"\"\n    query = None\n    isbn_query = False\n\n    # there can be ISBN query or book title query\n    if publication.optionals and publication.optionals.ISBN:\n        query = aleph.ISBNQuery(publication.optionals.ISBN)\n        isbn_query = True\n    else:\n        query = aleph.TitleQuery(publication.title)\n\n    result = aleph.reactToAMQPMessage(aleph.SearchRequest(query), \"\")\n\n    if not result.records:\n        return publication  # book is not in database\n\n    # if there was results with this ISBN, compare titles of the books\n    # (sometimes, there are different books with same ISBN because of human\n    # errors)\n    if isbn_query:\n        for record in result.records:\n            epub = record.epublication\n\n            # try to match title of the book\n            if compare_names(epub.nazev, publication.title) >= 80:\n                return None  # book already in database\n\n        return publication\n\n    # checks whether the details from returned EPublication match Publication's\n    for record in result.records:\n        epub = record.epublication\n\n        # if the title doens't match, go to next record from aleph\n        if not compare_names(epub.nazev, publication.title) >= 80:\n            continue\n\n        if not cmp_authors:\n            return None  # book already in database\n\n        # compare authors names\n        for author in epub.autori:\n            # convert Aleph's author structure to string\n            author_str = \"%s %s %s\" % (\n                author.firstName,\n                author.lastName,\n                author.title\n            )\n\n            # normalize author data from `publication`\n            pub_authors = map(lambda x: x.name, publication.authors)\n            if type(pub_authors) not in [list, tuple, set]:\n                pub_authors = [pub_authors]\n\n            # try to compare authors from `publication` and Aleph\n            for pub_author in pub_authors:\n                if compare_names(author_str, pub_author) >= 50:\n                    return None  # book already in database\n\n    return publication"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreads the long description.", "response": "def get_long_description():\n    \"\"\" Read the long description. \"\"\"\n    here = path.abspath(path.dirname(__file__))\n    with open(path.join(here, 'README.rst')) as readme:\n        return readme.read()\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\npops off the most recent state.", "response": "def pop_state(self, idx=None):\n        \"\"\"\n        Pops off the most recent state.\n\n        :param idx: If provided, specifies the index at which the next\n                    string begins.\n        \"\"\"\n\n        self.state.pop()\n\n        if idx is not None:\n            self.str_begin = idx"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd the text from the specified beginning index to the specified ending index.", "response": "def add_text(self, end, next=None):\n        \"\"\"\n        Adds the text from string beginning to the specified ending\n        index to the format.\n\n        :param end: The ending index of the string.\n        :param next: The next string begin index.  If None, the string\n                     index will not be updated.\n        \"\"\"\n\n        if self.str_begin != end:\n            self.fmt.append_text(self.format[self.str_begin:end])\n\n        if next is not None:\n            self.str_begin = next"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_escape(self, idx, char):\n\n        self.fmt.append_text(self.fmt._unescape.get(\n            self.format[self.str_begin:idx], char))", "response": "Translates and adds the escape sequence."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_param(self, idx):\n\n        self.modifier.set_param(self.format[self.param_begin:idx])", "response": "Adds the parameter to the conversion modifier."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef set_conversion(self, idx):\n\n        # First, determine the name\n        if self.conv_begin:\n            name = self.format[self.conv_begin:idx]\n        else:\n            name = self.format[idx]\n\n        # Next, add the status code modifiers, as needed\n        if self.codes:\n            self.modifier.set_codes(self.codes, self.reject)\n\n        # Append the conversion to the format\n        self.fmt.append_conv(self.fmt._get_conversion(name, self.modifier))\n\n        # Clear the conversion data\n        self.param_begin = None\n        self.conv_begin = None\n        self.modifier = None\n        self.codes = []\n        self.reject = False\n        self.code_last = False", "response": "Adds the conversion to the format."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset the code of the entry in the internal list of the available log entries.", "response": "def set_code(self, idx):\n        \"\"\"\n        Sets a code to be filtered on for the conversion.  Note that\n        this also sets the 'code_last' attribute and configures to\n        ignore the remaining characters of the code.\n\n        :param idx: The index at which the code _begins_.\n\n        :returns: True if the code is valid, False otherwise.\n        \"\"\"\n\n        code = self.format[idx:idx + 3]\n\n        if len(code) < 3 or not code.isdigit():\n            return False\n\n        self.codes.append(int(code))\n        self.ignore = 2\n        self.code_last = True\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nwraps things up and add any final string content.", "response": "def end_state(self):\n        \"\"\"\n        Wrap things up and add any final string content.\n        \"\"\"\n\n        # Make sure we append any trailing text\n        if self.str_begin != len(self.format):\n            if len(self.state) > 1 or self.state[-1] != 'string':\n                self.fmt.append_text(\n                    \"(Bad format string; ended in state %r)\" % self.state[-1])\n            else:\n                self.fmt.append_text(self.format[self.str_begin:])\n\n        # Convenience return\n        return self.fmt"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nswitch into the conversion state used to parse a % conversion.", "response": "def conversion(self, idx):\n        \"\"\"\n        Switches into the 'conversion' state, used to parse a %\n        conversion.\n\n        :param idx: The format string index at which the conversion\n                    begins.\n        \"\"\"\n\n        self.state.append('conversion')\n        self.str_begin = idx\n        self.param_begin = None\n        self.conv_begin = None\n        self.modifier = conversions.Modifier()\n        self.codes = []\n        self.reject = False\n        self.code_last = False"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _get_conversion(cls, conv_chr, modifier):\n\n        # Do we need to look up the conversion?\n        if conv_chr not in cls._conversion_cache:\n            for ep in pkg_resources.iter_entry_points('bark.conversion',\n                                                      conv_chr):\n                try:\n                    # Load the conversion class\n                    cls._conversion_cache[conv_chr] = ep.load()\n                    break\n                except (ImportError, pkg_resources.UnknownExtra):\n                    # Couldn't load it; odd...\n                    continue\n            else:\n                # Cache the negative result\n                cls._conversion_cache[conv_chr] = None\n\n        # Handle negative caching\n        if cls._conversion_cache[conv_chr] is None:\n            return conversions.StringConversion(\"(Unknown conversion '%%%s')\" %\n                                                conv_chr)\n\n        # Instantiate the conversion\n        return cls._conversion_cache[conv_chr](conv_chr, modifier)", "response": "Returns a conversion given its character."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nparse a format string and return an instance of the class Format.", "response": "def parse(cls, format):\n        \"\"\"\n        Parse a format string.  Factory function for the Format class.\n\n        :param format: The format string to parse.\n\n        :returns: An instance of class Format.\n        \"\"\"\n\n        fmt = cls()\n\n        # Return an empty Format if format is empty\n        if not format:\n            return fmt\n\n        # Initialize the state for parsing\n        state = ParseState(fmt, format)\n\n        # Loop through the format string with a state-based parser\n        for idx, char in enumerate(format):\n            # Some characters get ignored\n            if state.check_ignore():\n                continue\n\n            if state == 'string':\n                if char == '%':\n                    # Handle '%%'\n                    if format[idx:idx + 2] == '%%':\n                        # Add one % to the string context\n                        state.add_text(idx + 1, idx + 2)\n                        state.set_ignore(1)\n                    else:\n                        state.add_text(idx)\n                        state.conversion(idx)\n                elif char == '\\\\':\n                    state.add_text(idx)\n                    state.escape(idx)\n            elif state == 'escape':\n                state.add_escape(idx + 1, char)\n                state.pop_state(idx + 1)\n            elif state == 'param':\n                if char == '}':\n                    state.set_param(idx)\n                    state.pop_state()\n            elif state == 'conv':\n                if char == ')':\n                    state.set_conversion(idx)\n                    state.pop_state()  # now in 'conversion'\n                    state.pop_state(idx + 1)  # now in 'string'\n            else:  # state == 'conversion'\n                if char in '<>':\n                    # Allowed for Apache compatibility, but ignored\n                    continue\n                elif char == '!':\n                    state.set_reject()\n                    continue\n                elif char == ',' and state.code_last:\n                    # Syntactically allowed ','\n                    continue\n                elif char.isdigit():\n                    # True if the code is valid\n                    if state.set_code(idx):\n                        continue\n                elif char == '{' and state.param_begin is None:\n                    state.param(idx + 1)\n                    continue\n                elif char == '(' and state.conv_begin is None:\n                    state.conv(idx + 1)\n                    continue\n\n                # OK, we have a complete conversion\n                state.set_conversion(idx)\n                state.pop_state(idx + 1)\n\n        # Finish the parse and return the completed format\n        return state.end_state()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef append_text(self, text):\n\n        if (self.conversions and\n                isinstance(self.conversions[-1],\n                           conversions.StringConversion)):\n            self.conversions[-1].append(text)\n        else:\n            self.conversions.append(conversions.StringConversion(text))", "response": "Append static text to the Format."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nprepare any preparations necessary for the Format.", "response": "def prepare(self, request):\n        \"\"\"\n        Performs any preparations necessary for the Format.\n\n        :param request: The webob Request object describing the\n                        request.\n\n        :returns: A list of dictionary values needed by the convert()\n                  method.\n        \"\"\"\n\n        data = []\n        for conv in self.conversions:\n            data.append(conv.prepare(request))\n\n        return data"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef convert(self, request, response, data):\n\n        result = []\n        for conv, datum in zip(self.conversions, data):\n            # Only include conversion if it's allowed\n            if conv.modifier.accept(response.status_code):\n                result.append(conv.convert(request, response, datum))\n            else:\n                result.append('-')\n\n        return ''.join(result)", "response": "Performs the desired formatting."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef is_valid(self, name=None, debug=False):\n        valid_tags = self.action_tree\n        invalid = False\n        for item in self.current_tree:\n            try:\n                if item in valid_tags or self.ALL_TAGS in valid_tags:\n                    valid_tags = valid_tags[item if item in valid_tags else self.ALL_TAGS]\n                else:\n                    valid_tags = None\n                    invalid = True\n                    break\n            except (KeyError, TypeError) as e:  # object is either missing the key or is not a dictionary type\n                invalid = True\n                break\n        if debug:\n            print name, not invalid and valid_tags is not None\n        return not invalid and valid_tags is not None", "response": "Check to see if the current xml path is to be processed."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a FormHelper object that can be used to create a Category s form.", "response": "def category_helper(form_tag=True):\n    \"\"\"\n    Category's form layout helper\n    \"\"\"\n    helper = FormHelper()\n    helper.form_action = '.'\n    helper.attrs = {'data_abide': ''}\n    helper.form_tag = form_tag\n    \n    helper.layout = Layout(\n        Row(\n            Column(\n                'title',\n                css_class='small-12'\n            ),\n        ),\n        Row(\n            Column(\n                'slug',\n                css_class='small-12 medium-10'\n            ),\n            Column(\n                'order',\n                css_class='small-12 medium-2'\n            ),\n        ),\n        Row(\n            Column(\n                'description',\n                css_class='small-12'\n            ),\n        ),\n        Row(\n            Column(\n                'visible',\n                css_class='small-12'\n            ),\n        ),\n        ButtonHolderPanel(\n            Submit('submit', _('Submit')),\n            css_class='text-right',\n        ),\n    )\n    \n    return helper"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a new Thread s form layout helper.", "response": "def thread_helper(form_tag=True, edit_mode=False, for_moderator=False):\n    \"\"\"\n    Thread's form layout helper\n    \"\"\"\n    helper = FormHelper()\n    helper.form_action = '.'\n    helper.attrs = {'data_abide': ''}\n    helper.form_tag = form_tag\n    \n    fieldsets = [\n        Row(\n            Column(\n                'subject',\n                css_class='small-12'\n            ),\n        ),\n    ]\n    \n    # Category field only in edit form\n    if edit_mode:\n        fieldsets.append(\n            Row(\n                Column(\n                    'category',\n                    css_class='small-12'\n                ),\n            ),\n        )\n    \n    if for_moderator:\n        fieldsets.append(\n            Row(\n                Column(\n                    'sticky',\n                    css_class='small-12 medium-4'\n                ),\n                Column(\n                    'announce',\n                    css_class='small-12 medium-4'\n                ),\n                Column(\n                    'closed',\n                    css_class='small-12 medium-4'\n                ),\n            ),\n        )\n    \n    # First message is not in edit form\n    if not edit_mode:\n        fieldsets.append(\n            Row(\n                Column(\n                    'text',\n                    css_class='small-12'\n                ),\n            ),\n        )\n    \n    if for_moderator:\n        fieldsets.append(\n            Row(\n                Column(\n                    'visible',\n                    css_class='small-12'\n                ),\n            ),\n        )\n    \n    # Threadwatch option is not in edit form\n    if not edit_mode:\n        fieldsets.append(\n            Row(\n                Column(\n                    'threadwatch',\n                    css_class='small-12'\n                ),\n            ),\n        )\n    \n    fieldsets = fieldsets+[\n        ButtonHolderPanel(\n            Submit('submit', _('Submit')),\n            css_class='text-right',\n        ),\n    ]\n    \n    helper.layout = Layout(*fieldsets)\n    \n    return helper"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a FormHelper object that can be used to display a post.", "response": "def post_helper(form_tag=True, edit_mode=False):\n    \"\"\"\n    Post's form layout helper\n    \"\"\"\n    helper = FormHelper()\n    helper.form_action = '.'\n    helper.attrs = {'data_abide': ''}\n    helper.form_tag = form_tag\n    \n    fieldsets = [\n        Row(\n            Column(\n                'text',\n                css_class='small-12'\n            ),\n        ),\n    ]\n    \n    # Threadwatch option is not in edit form\n    if not edit_mode:\n        fieldsets.append(\n            Row(\n                Column(\n                    'threadwatch',\n                    css_class='small-12'\n                ),\n            ),\n        )\n    \n    fieldsets = fieldsets+[\n        ButtonHolderPanel(\n            Submit('submit', _('Submit')),\n            css_class='text-right',\n        ),\n    ]\n    \n    helper.layout = Layout(*fieldsets)\n    \n    return helper"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a FormHelper that can be used to create a delete form.", "response": "def post_delete_helper(form_tag=True):\n    \"\"\"\n    Message's delete form layout helper\n    \"\"\"\n    helper = FormHelper()\n    helper.form_action = '.'\n    helper.attrs = {'data_abide': ''}\n    helper.form_tag = form_tag\n    \n    helper.layout = Layout(\n        ButtonHolderPanel(\n            Row(\n                Column(\n                    'confirm',\n                    css_class='small-12 medium-8'\n                ),\n                Column(\n                    Submit('submit', _('Submit')),\n                    css_class='small-12 medium-4 text-right'\n                ),\n            ),\n        ),\n    )\n    \n    return helper"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef permission_required_raise(perm, login_url=None, raise_exception=True):\n    return permission_required(perm, login_url=login_url, raise_exception=raise_exception)", "response": "A permission_required decorator that raises by default."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef request_data_url(url, headers=None, num_retries=NUM_RETRIES, timeout=TIMEOUT,\n                     params_request=None, json_req=False, **kwargs_req):\n    \"\"\"\n    Realiza sucesivos intentos de request a una url dada, intent\u00e1ndolo hasta que recibe un status 200 (OK)\n    y el texto recibido es mayor que MIN_LEN_REQUEST (=10).\n    Resulta \u00fatil cuando se est\u00e1n realizando m\u00faltiples requests al mismo servidor (por velocidad), y no siempre\n    las respuestas que emite son correctas.\n    :param url:\n    :param headers:\n    :param num_retries:\n    :param timeout:\n    :param params_request:\n    :param json_req:\n    \"\"\"\n    count, status, response = 0, -1, None\n    kwargs_req.update(timeout=timeout)\n    while count < num_retries:\n        try:\n            resp = requests.get(url, headers=headers, params=params_request, **kwargs_req)\n            status = resp.status_code\n            if status == 200:\n                if json_req:\n                    response = resp.json()\n                else:\n                    response = resp.content.decode()\n                if json_req or len(response) > MIN_LEN_REQUEST:\n                    break  # SALIDA BUCLE WHILE\n            elif status == 503:  # HTTP 503 Service unavailable\n                print('RECIBIDO ERROR HTTP 503 Service unavailable en url:\"{}\". Esperando 10 segs'.format(url))\n                time.sleep(10)\n        except (ConnectionError, ConnectTimeout, HTTPError) as e:\n            if count == num_retries - 1:\n                print('ERROR: ' + str(e) + ' \u00bfNo hay conexi\u00f3n de internet??')\n                print(e.__name__)\n                logging.error('ERROR: ' + str(e) + ' \u00bfNo hay conexi\u00f3n de internet??')\n            time.sleep(1)\n        except JSONDecodeError as e:\n            if count == num_retries - 1:\n                # print('ERROR: {}\\n-> RESPONSE: {}\\n{}'.format(e, resp, resp.content))\n                # logging.error('ERROR: {}\\n-> RESPONSE: {}\\n{}'.format(e, resp, resp.content))\n                print('ERROR: {}'.format(e))\n                logging.error('ERROR: {}'.format(e))\n            time.sleep(1)\n        except TypeError as e:\n            print('TypeError')\n            logging.error(str(e))\n            print(str(e))\n        except Exception as e:\n            if count > 0:\n                logging.error('%lu\u00ba Exception no reconocida: %s!!' % (count + 1, type(e)))\n                print('%lu\u00ba Exception no reconocida: %s!!' % (count + 1, type(e)))\n                print(str(e))\n        count += 1\n    if count > 0 and count == num_retries:\n        print('NO SE HA PODIDO OBTENER LA INFO EN %s' % url)\n        logging.error('NO SE HA PODIDO OBTENER LA INFO EN %s' % url)\n    return status, response", "response": "Request a url and return the data as a list of objects."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_data_en_intervalo(d0=None, df=None, date_fmt=DATE_FMT,\n                          usar_multithread=USAR_MULTITHREAD, max_threads_requests=MAX_THREADS_REQUESTS,\n                          timeout=TIMEOUT, num_retries=NUM_RETRIES,\n                          func_procesa_data_dia=None, func_url_data_dia=None, max_act_exec=None, verbose=True,\n                          data_extra_request=None):\n        \"\"\"\n        Obtiene los datos en bruto de la red realizando m\u00faltiples requests al tiempo\n        Procesa los datos en bruto obtenidos de la red convirtiendo a Pandas DataFrame\n        \"\"\"\n        def _date(dia_string):\n            if dia_string is None:\n                return dt.date.today()\n            elif type(dia_string) is pd.Timestamp:\n                return dia_string.to_datetime().date()\n            elif type(dia_string) is not dt.date:\n                return dt.datetime.strptime(dia_string, date_fmt).date()\n            else:\n                return dia_string\n\n        def _procesa_merge_datos_dias(lista_m, dict_data_merge):\n\n            def _merge_datos_dias(key_tarea_merge, dict_merge_dias):\n                dict_merge_dias[key_tarea_merge] = merge_data(dict_merge_dias[key_tarea_merge])\n\n            if num_dias > 1 and usar_multithread:\n                lista_grupos = list()\n                grupos_dias = [lista_m[i:i + DIAS_MERGE_MAX] for i in np.arange(0, num_dias, DIAS_MERGE_MAX)]\n                for grupo in grupos_dias:\n                    lista_dfs = list()\n                    for key_g in grupo:\n                        lista_dfs.append(dict_data_merge[key_g])\n                    lista_grupos.append(lista_dfs)\n                keys_grupos = np.arange(len(lista_grupos))\n                dict_merge = dict(zip(keys_grupos, lista_grupos))\n                procesa_tareas_paralelo(keys_grupos, dict_merge, _merge_datos_dias,\n                                        '\\nMERGE DATAFRAMES DE DATOS WEB DIARIOS (%lu GRUPOS)',\n                                        usar_multithread, MAX_THREADS_MERGE, verbose=verbose)\n                dict_merge_final = {0: [dict_merge[k] for k in dict_merge.keys()]}\n                _merge_datos_dias(0, dict_merge_final)\n                return dict_merge_final[0]\n            else:\n                return merge_data(list(dict_data_merge.values()))\n\n        def _hay_errores_en_datos_obtenidos(dict_data_obtenida):\n            keys = list(sorted(dict_data_obtenida.keys()))\n            data_es_none = [dict_data_obtenida[k] is None for k in keys]\n            error = False\n            if any(data_es_none):\n                df_err = pd.DataFrame({'key': keys, 'is_bad': data_es_none})\n                df_err['date'] = df_err['key'].apply(lambda x: pd.Timestamp(x))\n                df_err['delta'] = (df_err['date'] - df_err['date'].shift(1)).fillna(3600 * 24)\n                df_g = df_err[~df_err['is_bad']].copy()\n                df_g['delta_g'] = (df_g['date'] - df_g['date'].shift(1)).fillna(3600 * 24)\n                # print(df_err)\n                # print(df_err['delta'].describe())\n                # print(df_g['delta_g'].describe())\n\n                if df_g['delta_g'].max() < pd.Timedelta(2, 'D'):\n                    bad_days = df_err[df_err['is_bad']]['key'].tolist()\n                    if verbose:\n                        print('HAY TAREAS NO REALIZADAS ({}):\\n{}'.format(len(bad_days), bad_days))\n                    logging.error('HAY TAREAS NO REALIZADAS ({}):\\n{}'.format(len(bad_days), bad_days))\n                    error = False\n                else:\n                    if verbose:\n                        print('NO HAY NINGUNA TAREA REALIZADA!')\n                    logging.error('NO HAY NINGUNA TAREA REALIZADA!')\n                    bad_days = df_err['key'].tolist()\n                    error = True\n                for k in bad_days:\n                    dict_data_obtenida.pop(k)\n            return error\n\n        def _obtiene_request(url, key, headers=None, p_req=None, json_r=False, **kwargs_r):\n            if type(url) is list:\n                results = [request_data_url(u, headers, num_retries, timeout, p_req, json_r, **kwargs_r) for u in url]\n                dict_data[key] = list(zip(*results))\n            else:\n                stat_response = request_data_url(url, headers, num_retries, timeout, p_req, json_r, **kwargs_r)\n                dict_data[key] = stat_response\n\n        def _obtiene_data_dia(key, dict_data_responses):\n            url = func_url_data_dia(key)\n            extra = dict_data_responses[key] if type(dict_data_responses[key]) is dict else {}\n            headers = extra.pop('headers', None)\n            json_req = extra.pop('json_req', False)\n            params_request = extra.pop('params_request', None)\n            try:\n                count_process, ok = 0, -1\n                while count_process < num_retries and ok != 0:\n                    _obtiene_request(url, key, headers, params_request, json_req, **extra)\n                    data_import, ok = func_procesa_data_dia(key, dict_data_responses[key][1])\n                    if ok == 0:\n                        dict_data_responses[key] = data_import\n                    elif ok == -2:  # C\u00f3digo de salida temprana:\n                        count_process = num_retries\n                    count_process += 1\n                if ok != 0:\n                    dict_data_responses[key] = None\n            except Exception as e:\n                if verbose:\n                    print('PROCESANDO DATA!???? (Exception: {}; KEY: {}; URL: {})'.format(e, key, url))\n                logging.error('PROCESANDO DATA!???? (Exception: {}; KEY: {}; URL: {})'.format(e, key, url))\n                dict_data_responses[key] = None\n\n        tic_ini = time.time()\n        lista_dias = [dia.strftime(date_fmt) for dia in pd.date_range(_date(d0), _date(df))]\n        if max_act_exec:  # BORRAR. Es para limitar el n\u00ba de d\u00edas adquiridos de golpe.\n            lista_dias = lista_dias[:max_act_exec]\n        num_dias = len(lista_dias)\n        if data_extra_request is None:\n            dict_data = dict(zip(lista_dias, np.zeros(num_dias)))\n        else:\n            dict_data = dict(zip(lista_dias, [data_extra_request.copy() for _ in range(num_dias)]))\n        # IMPORTA DATOS Y LOS PROCESA\n        procesa_tareas_paralelo(lista_dias, dict_data, _obtiene_data_dia,\n                                '\\nPROCESADO DE DATOS WEB DE %lu D\u00cdAS',\n                                usar_multithread, max_threads_requests, verbose=verbose)\n        hay_errores = _hay_errores_en_datos_obtenidos(dict_data)\n        # MERGE DATOS\n        # print(len(lista_dias), len(dict_data.keys()))\n        if not hay_errores and num_dias > 0:\n            # data_merge = _procesa_merge_datos_dias(lista_dias, dict_data)\n            data_merge = _procesa_merge_datos_dias(list(sorted(dict_data.keys())), dict_data)\n            str_resumen_import = '\\n%lu d\u00edas importados [Proceso Total %.2f seg, %.4f seg/d\u00eda]' \\\n                                 % (num_dias, time.time() - tic_ini, (time.time() - tic_ini) / float(num_dias))\n            return data_merge, hay_errores, str_resumen_import\n        else:\n            return None, hay_errores, 'ERROR IMPORTANDO!!'", "response": "Get data en intervalo"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nput the object into a file URL.", "response": "def write(url, content, **args):\n    \"\"\"Put the object/collection into a file URL.\"\"\"\n    with FileResource(url, **args) as resource:\n        resource.write(content)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef singleton_per_scope(_cls, _scope=None, _renew=False, *args, **kwargs):\n\n    result = None\n\n    singletons = SINGLETONS_PER_SCOPES.setdefault(_scope, {})\n\n    if _renew or _cls not in singletons:\n        singletons[_cls] = _cls(*args, **kwargs)\n\n    result = singletons[_cls]\n\n    return result", "response": "Instanciate a singleton per scope."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconstruct a safe builtin environment without I / O functions.", "response": "def _safebuiltins():\n    \"\"\"Construct a safe builtin environment without I/O functions.\n\n    :rtype: dict\"\"\"\n\n    result = {}\n\n    objectnames = [\n        objectname for objectname in dir(builtins)\n        if objectname not in BUILTIN_IO_PROPS\n    ]\n\n    for objectname in objectnames:\n        result[objectname] = getattr(builtins, objectname)\n\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndo a safe processing of input fn in using SAFE_BUILTINS.", "response": "def _safe_processing(nsafefn, source, _globals=None, _locals=None):\n    \"\"\"Do a safe processing of input fn in using SAFE_BUILTINS.\n\n    :param fn: function to call with input parameters.\n    :param source: source object to process with fn.\n    :param dict _globals: global objects by name.\n    :param dict _locals: local objects by name.\n    :return: fn processing result\"\"\"\n\n    if _globals is None:\n        _globals = SAFE_BUILTINS\n\n    else:\n        _globals.update(SAFE_BUILTINS)\n\n    return nsafefn(source, _globals, _locals)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngenerates new function where code is an input function code with all of the constants changed to LOAD_CONST statements.", "response": "def _make_constants(func, builtin_only=False, stoplist=None, verbose=None):\n    \"\"\"Generate new function where code is an input function code with all\n    LOAD_GLOBAL statements changed to LOAD_CONST statements.\n\n    :param function func: code function to transform.\n    :param bool builtin_only: only transform builtin objects.\n    :param list stoplist: attribute names to not transform.\n    :param function verbose: logger function which takes in parameter a message\n\n    .. warning::\n        Be sure global attributes to transform are not resolved dynamically.\"\"\"\n\n    result = func\n\n    if stoplist is None:\n        stoplist = []\n\n    try:\n        fcode = func.__code__\n    except AttributeError:\n        return func        # Jython doesn't have a __code__ attribute.\n    newcode = list(fcode.co_code) if PY3 else [ord(co) for co in fcode.co_code]\n    newconsts = list(fcode.co_consts)\n    names = fcode.co_names\n    codelen = len(newcode)\n\n    env = vars(builtins).copy()\n    if builtin_only:\n        stoplist = dict.fromkeys(stoplist)\n        stoplist.update(func.__globals__)\n    else:\n        env.update(func.__globals__)\n\n    # First pass converts global lookups into constants\n    changed = False\n    i = 0\n    while i < codelen:\n        opcode = newcode[i]\n        if opcode in (EXTENDED_ARG, STORE_GLOBAL):\n            return func    # for simplicity, only optimize common cases\n        if opcode == LOAD_GLOBAL:\n            oparg = newcode[i + 1] + (newcode[i + 2] << 8)\n            name = fcode.co_names[oparg]\n            if name in env and name not in stoplist:\n                value = env[name]\n                for pos, val in enumerate(newconsts):\n                    if val is value:\n                        break\n                else:\n                    pos = len(newconsts)\n                    newconsts.append(value)\n                newcode[i] = LOAD_CONST\n                newcode[i + 1] = pos & 0xFF\n                newcode[i + 2] = pos >> 8\n                changed = True\n                if verbose is not None:\n                    verbose(\"{0} --> {1}\".format(name, value))\n        i += 1\n        if opcode >= HAVE_ARGUMENT:\n            i += 2\n\n    # Second pass folds tuples of constants and constant attribute lookups\n    i = 0\n    while i < codelen:\n\n        newtuple = []\n        while newcode[i] == LOAD_CONST:\n            oparg = newcode[i + 1] + (newcode[i + 2] << 8)\n            newtuple.append(newconsts[oparg])\n            i += 3\n\n        opcode = newcode[i]\n        if not newtuple:\n            i += 1\n            if opcode >= HAVE_ARGUMENT:\n                i += 2\n            continue\n\n        if opcode == LOAD_ATTR:\n            obj = newtuple[-1]\n            oparg = newcode[i + 1] + (newcode[i + 2] << 8)\n            name = names[oparg]\n            try:\n                value = getattr(obj, name)\n            except AttributeError:\n                continue\n            deletions = 1\n\n        elif opcode == BUILD_TUPLE:\n            oparg = newcode[i + 1] + (newcode[i + 2] << 8)\n            if oparg != len(newtuple):\n                continue\n            deletions = len(newtuple)\n            value = tuple(newtuple)\n\n        else:\n            continue\n\n        reljump = deletions * 3\n        newcode[i - reljump] = JUMP_FORWARD\n        newcode[i - reljump + 1] = (reljump - 3) & 0xFF\n        newcode[i - reljump + 2] = (reljump - 3) >> 8\n\n        nclen = len(newconsts)\n        newconsts.append(value)\n        newcode[i] = LOAD_CONST\n        newcode[i + 1] = nclen & 0xFF\n        newcode[i + 2] = nclen >> 8\n        i += 3\n        changed = True\n        if verbose is not None:\n            verbose(\"new folded constant:{0}\".format(value))\n\n    if changed:\n\n        codeobj = getcodeobj(newconsts, newcode, fcode, fcode)\n\n        result = type(func)(\n            codeobj,\n            func.__globals__, func.__name__, func.__defaults__, func.__closure__\n        )\n\n        # set func attributes to result\n        for prop in WRAPPER_ASSIGNMENTS:\n            try:\n                attr = getattr(func, prop)\n            except AttributeError:\n                pass\n            else:\n                setattr(result, prop, attr)\n\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef getcodeobj(consts, intcode, newcodeobj, oldcodeobj):\n\n    # get code string\n    if PY3:\n        codestr = bytes(intcode)\n\n    else:\n        codestr = reduce(lambda x, y: x + y, (chr(b) for b in intcode))\n\n    # get vargs\n    vargs = [\n        newcodeobj.co_argcount, newcodeobj.co_nlocals, newcodeobj.co_stacksize,\n        newcodeobj.co_flags, codestr, tuple(consts), newcodeobj.co_names,\n        newcodeobj.co_varnames, newcodeobj.co_filename, newcodeobj.co_name,\n        newcodeobj.co_firstlineno, newcodeobj.co_lnotab,\n        oldcodeobj.co_freevars, newcodeobj.co_cellvars\n    ]\n    if PY3:\n        vargs.insert(1, newcodeobj.co_kwonlyargcount)\n\n    # instanciate a new newcodeobj object\n    result = type(newcodeobj)(*vargs)\n\n    return result", "response": "Get code object from decompiled code."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef bind_all(morc, builtin_only=False, stoplist=None, verbose=None):\n\n    if stoplist is None:\n        stoplist = []\n\n    def _bind_all(morc, builtin_only=False, stoplist=None, verbose=False):\n        \"\"\"Internal bind all decorator function.\n        \"\"\"\n        if stoplist is None:\n            stoplist = []\n\n        if isinstance(morc, (ModuleType, type)):\n            for k, val in list(vars(morc).items()):\n                if isinstance(val, FunctionType):\n                    newv = _make_constants(\n                        val, builtin_only, stoplist, verbose\n                    )\n                    setattr(morc, k, newv)\n                elif isinstance(val, type):\n                    _bind_all(val, builtin_only, stoplist, verbose)\n\n    if isinstance(morc, dict):  # allow: bind_all(globals())\n        for k, val in list(morc.items()):\n            if isinstance(val, FunctionType):\n                newv = _make_constants(val, builtin_only, stoplist, verbose)\n                morc[k] = newv\n            elif isinstance(val, type):\n                _bind_all(val, builtin_only, stoplist, verbose)\n    else:\n        _bind_all(morc, builtin_only, stoplist, verbose)", "response": "Recursively apply constant binding to functions in a module or class."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a function which creates a function which will replace global references with their currently defined values.", "response": "def make_constants(builtin_only=False, stoplist=None, verbose=None):\n    \"\"\"Return a decorator for optimizing global references.\n\n    Replaces global references with their currently defined values.\n    If not defined, the dynamic (runtime) global lookup is left undisturbed.\n    If builtin_only is True, then only builtins are optimized.\n    Variable names in the stoplist are also left undisturbed.\n    Also, folds constant attr lookups and tuples of constants.\n    If verbose is True, prints each substitution as is occurs.\n\n    :param bool builtin_only: only transform builtin objects.\n    :param list stoplist: attribute names to not transform.\n    :param function verbose: logger function which takes in parameter a message\n    \"\"\"\n\n    if stoplist is None:\n        stoplist = []\n\n    if isinstance(builtin_only, type(make_constants)):\n        raise ValueError(\"The bind_constants decorator must have arguments.\")\n\n    return lambda func: _make_constants(func, builtin_only, stoplist, verbose)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef init(vcs):\n    path = os.path.join(vcs.private_dir(), 'locks')\n    if not os.path.exists(path):\n        os.mkdir(path)", "response": "Initialize the locking module for a repository"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef lock(vcs, lock_object, wait=True):\n    if wait:\n        timeout = -1\n    else:\n        timeout = 0\n    lock_path = _get_lock_path(vcs, lock_object)\n    lock = filelock.FileLock(lock_path)\n    with lock.acquire(timeout=timeout):\n        yield", "response": "A context manager that grabs the lock and releases it when done."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the slug arg defined for the home urlpattern which is the definitive source of the homepage object.", "response": "def home_slug():\n    \"\"\"\n    Returns the slug arg defined for the ``home`` urlpattern, which\n    is the definitive source of the ``url`` field defined for an\n    editable homepage object.\n    \"\"\"\n    prefix = get_script_prefix()\n    slug = reverse(\"home\")\n    if slug.startswith(prefix):\n        slug = '/' + slug[len(prefix):]\n    try:\n        return resolve(slug).kwargs[\"slug\"]\n    except KeyError:\n        return slug"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef slugify_unicode(s):\n    chars = []\n    for char in str(smart_text(s)):\n        cat = unicodedata.category(char)[0]\n        if cat in \"LN\" or char in \"-_~\":\n            chars.append(char)\n        elif cat == \"Z\":\n            chars.append(\" \")\n    return re.sub(\"[-\\s]+\", \"-\", \"\".join(chars).strip()).lower()", "response": "A slugifier for Django s unicode."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a unique slug for the given queryset.", "response": "def unique_slug(queryset, slug_field, slug):\n    \"\"\"\n    Ensures a slug is unique for the given queryset, appending\n    an integer to its end until the slug is unique.\n    \"\"\"\n    i = 0\n    while True:\n        if i > 0:\n            if i > 1:\n                slug = slug.rsplit(\"-\", 1)[0]\n            slug = \"%s-%s\" % (slug, i)\n        try:\n            queryset.get(**{slug_field: slug})\n        except ObjectDoesNotExist:\n            break\n        i += 1\n    return slug"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the next URL to redirect to from the next param in the request.", "response": "def next_url(request):\n    \"\"\"\n    Returns URL to redirect to from the ``next`` param in the request.\n    \"\"\"\n    next = request.GET.get(\"next\", request.POST.get(\"next\", \"\"))\n    host = request.get_host()\n    return next if next and is_safe_url(next, host=host) else None"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef login_redirect(request):\n    ignorable_nexts = (\"\",)\n    if \"yacms.accounts\" in settings.INSTALLED_APPS:\n        from yacms.accounts import urls\n        ignorable_nexts += (urls.SIGNUP_URL, urls.LOGIN_URL, urls.LOGOUT_URL)\n    next = next_url(request) or \"\"\n    if next in ignorable_nexts:\n        next = settings.LOGIN_REDIRECT_URL\n        if next == \"/accounts/profile/\":\n            # Use the homepage if LOGIN_REDIRECT_URL is Django's defaut.\n            next = get_script_prefix()\n        else:\n            try:\n                next = reverse(next)\n            except NoReverseMatch:\n                pass\n    return redirect(next)", "response": "Returns the response for login or signup."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef path_to_slug(path):\n    from yacms.urls import PAGES_SLUG\n    lang_code = translation.get_language_from_path(path)\n    for prefix in (lang_code, settings.SITE_PREFIX, PAGES_SLUG):\n        if prefix:\n            path = path.replace(prefix, \"\", 1)\n    return clean_slashes(path) or \"/\"", "response": "Converts a given URL path to a slug that can be used in a page instance."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreport exceptions from requests via Exreporter.", "response": "def process_exception(self, request, exception):\n        \"\"\"Report exceptions from requests via Exreporter.\n        \"\"\"\n        gc = GithubCredentials(\n            user=settings.EXREPORTER_GITHUB_USER,\n            repo=settings.EXREPORTER_GITHUB_REPO,\n            auth_token=settings.EXREPORTER_GITHUB_AUTH_TOKEN)\n        gs = GithubStore(credentials=gc)\n        reporter = ExReporter(\n            store=gs, labels=settings.EXREPORTER_GITHUB_LABELS)\n\n        reporter.report()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef left_indent(text, indent=12, end='\\n'):\n    ''' A bit of the ol' ultraviolence  :-/ '''\n    indent = ' ' * indent\n    lines = [indent + line for line in text.splitlines(True)]\n    lines.append(end)\n    return ''.join(lines)", "response": "A bit of the ol ultraviolence"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nformats a log record.", "response": "def format(self, record):\n        ''' Log color formatting. '''\n        levelname = record.levelname    # len7 limit\n        if levelname == 'CRITICAL':\n            levelname = record.levelname = 'FATAL'\n        if self.usesTime():\n            record.asctime = self.formatTime(record, self.datefmt)\n\n        # render the message part with arguments\n        try:  # Allow {} style - need a faster way to determine this:\n            message = record.getMessage()\n        except TypeError:\n            message = record.msg.format(*record.args)\n\n        # decide to highlight w/ pygments\n        #\u00a0TODO:\u00a0Highlight args directly and drop text scan? - didn't work well.\n        if self._highlight:\n            match = self.data_search(message, 0, DATA_SEARCH_LIMIT)\n            if match:\n                pos = match.start()\n                front, back = message[:pos], message[pos:]  # Spliten-Sie\n                if front.endswith('\\n'):                    # indent data?\n                    back = pformat(record.args)\n                    back = left_indent(back, self._code_indent)\n                back = self._highlight(back, self._lexer, self._hl_formatter)\n                message = f'{front}{back}'\n\n        record.message = message\n        record.on = self._theme_style.get(levelname, '')\n        record.icon = self._theme_icons.get(levelname, '')\n        record.off = _end\n        s = self.formatMessage(record)\n\n        # this needs to be here, Formatter class isn't very extensible.\n        if record.exc_info:\n            # Cache the traceback text to avoid converting it multiple times\n            # (it's constant anyway)\n            if not record.exc_text:\n                record.exc_text = self.formatException(record.exc_info)\n        if record.exc_text:\n            if s[-1:] != \"\\n\":\n                s = s + \"\\n\"\n            s = s + record.exc_text\n        if record.stack_info:\n            if s[-1:] != \"\\n\":\n                s = s + \"\\n\"\n            s = s + self.formatStack(record.stack_info)\n        return s"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nformat a log record.", "response": "def format(self, record):\n        ''' Log color formatting. '''\n        levelname = record.levelname\n        if levelname == 'CRITICAL':\n            levelname = record.levelname = 'FATAL'\n        record.asctime = self.formatTime(record, self.datefmt)\n\n        # render the message part with arguments\n        try:  # Allow {} style - need a faster way to determine this:\n            message = record.getMessage()\n        except TypeError:\n            message = record.msg.format(*record.args)\n        record.message = message\n\n        fields = self._fields\n        data = { name: getattr(record, name) for name in fields }\n        if 'asctime' in fields and 'msecs' in fields:  # needs option for this\n            data['asctime'] += '.{:03.0f}'.format(data.pop('msecs'))\n        s = self.dumps(data)\n        if self._highlight:\n            s = self._highlight(s, get_lexer_by_name('JSON'), _term_formatter,\n                                ).rstrip()\n\n        # this needs to be here, Formatter class isn't very extensible.\n        if record.exc_info:\n            # Cache the traceback text to avoid converting it multiple times\n            # (it's constant anyway)\n            if not record.exc_text:\n                record.exc_text = self.formatException(record.exc_info)\n        if record.exc_text:\n            if s[-1:] != \"\\n\":\n                s = s + \"\\n\"\n            s = s + record.exc_text\n        if record.stack_info:\n            if s[-1:] != \"\\n\":\n                s = s + \"\\n\"\n            s = s + self.formatStack(record.stack_info)\n        return s"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\npublish a message to the broker", "response": "def publish(self, message_type, client_id, client_storage, *args, **kwargs):\n        \"\"\"\n        Publishes a message\n        \"\"\"\n        p = self.pack(message_type, client_id, client_storage, args, kwargs)\n        self.client.publish(self.channel, p)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef connect(self):\n        logger.info(\"Connecting to Redis on {host}:{port}...\".format(\n            host=self.host, port=self.port))\n\n        super(RedisSubscriber, self).connect()\n        logger.info(\"Successfully connected to Redis\")\n\n        # Subscribe to channel\n        self.pubsub = self.client.pubsub()\n        self.pubsub.subscribe(self.channel)\n\n        logger.info(\"Subscribed to [{channel}] Redis channel\".format(\n            channel=self.channel))\n\n        # Start listening\n        t = Thread(target=self.listen)\n        t.setDaemon(True)\n        t.start()", "response": "Connects to Redis and starts listening to the channel."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef listen(self):\n        for message in self.pubsub.listen():\n            if message['type'] == 'message':\n                message_type, client_id, client_storage, args, kwargs = self.unpack(\n                    message['data'])\n\n                self.dispatch_message(\n                    message_type, client_id, client_storage, args, kwargs)", "response": "Listen for messages in the current publication."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef exit(self):\n        self.pubsub.unsubscribe()\n        self.client.connection_pool.disconnect()\n\n        logger.info(\"Connection to Redis closed\")", "response": "Closes the connection to Redis"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_kwargs(self):\n        return {\n            'host': self.host,\n            'port': self.port,\n            'channel': self.channel,\n            'password': self.password\n        }", "response": "Returns kwargs for both publisher and subscriber classes\nAttributeNames"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreads the passed file", "response": "def read(fname):\n    \" read the passed file \"\n    if exists(fname):\n        return open(join(dirname(__file__), fname)).read()"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreads an object from a ftp URL.", "response": "def read(url, **args):\n    \"\"\"Get the object from a ftp URL.\"\"\"\n    all_ = args.pop('all', False)\n    password = args.pop('password', '')\n    if not password:\n        raise ValueError('password')\n    try:\n        username, __ = url.username.split(';')\n    except ValueError:\n        username = url.username\n    if not username:\n        username = os.environ.get('USERNAME')\n        username = os.environ.get('LOGNAME', username)\n        username = os.environ.get('USER', username)\n    client = poplib.POP3(url.hostname, url.port or poplib.POP3_PORT,\n                         args.pop('timeout', socket._GLOBAL_DEFAULT_TIMEOUT))\n    response, count, __ = client.apop(username, password)\n    if 'OK' not in response:\n        raise BadPOP3Response(response)\n    if count == 0:\n        raise ValueError('count: 0')\n    collection = []\n    for id_ in range(count if all_ is True else 1):\n        response, lines, __ = client.retr(id_ + 1)\n        if 'OK' not in response:\n            raise BadPOP3Response(response)\n        client.dele(id_ + 1)\n        message = email.message_from_string('\\n'.join(lines))\n        content_type = message.get_content_type()\n        filename = message.get_filename('')\n        encoding = message['Content-Encoding']\n        content = message.get_payload(decode=True)\n        content = content_encodings.get(encoding).decode(content)\n        content = content_types.get(content_type).parse(content)\n        collection.append((filename, content))\n    client.quit()\n    return collection if len(collection) > 0 else collection[0][1]"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets all nagios status information from a local nagios instance", "response": "def get():\n    \"\"\" Get all nagios status information from a local nagios instance\n    \"\"\"\n    livestatus = mk_livestatus()\n    hosts = livestatus.get_hosts()\n    services = livestatus.get_services()\n    result = {}\n    result['hosts'] = hosts\n    result['services'] = services\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef post(hosts=None, services=None, check_existance=True, create_services=True, create_hosts=False):\n\n    nagios_config = config()\n    nagios_config.parse_maincfg()\n    check_result_path = nagios_config.get_cfg_value(\"check_result_path\")\n\n\n    fd, filename = tempfile.mkstemp(prefix='c', dir=check_result_path)\n    if not hosts:\n        hosts = []\n    if not services:\n        services = []\n\n    if check_existance:\n        checkresults_overhaul(hosts, services, create_services=create_services, create_hosts=create_hosts)\n    checkresults = '### Active Check Result File Made by Nago ###\\n'\n    checkresults += 'file_time=%s' % (int(time.time()))\n    checkresults = ''\n\n    for host in hosts:\n        checkresults += _format_checkresult(**host)\n    for service in services:\n        checkresults += _format_checkresult(**service)\n    os.write(fd, checkresults)\n\n    # Cleanup and make sure our file is readable by nagios\n    os.close(fd)\n    os.chmod(filename, 0644)\n\n    # Create an ok file, so nagios knows it's ok to reap our changes\n    file('%s.ok' % filename, 'w')", "response": "Post a list of hosts into a nagios checkresults file"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef send(remote_host=None):\n    my_data = get()\n    if not remote_host:\n        remote_host = nago.extensions.settings.get('server')\n    remote_node = nago.core.get_node(remote_host)\n    remote_node.send_command('checkresults', 'post', **my_data)\n    return \"checkresults sent to %s\" % remote_host", "response": "Send local nagios data to a remote nago instance"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a string in a nagios checkresults compatible format", "response": "def _format_checkresult(**kwargs):\n    \"\"\" Returns a string in a nagios \"checkresults\" compatible format \"\"\"\n    o = {}\n    o['check_type'] = '1'\n    o['check_options'] = '0'\n    o['scheduled_check'] = '1'\n    o['reschedule_check'] = '1'\n    o['latency'] = '0.0'\n    o['start_time'] = '%5f' % time.time()\n    o['finish_time'] = '%5f' % time.time()\n    o['early_timeout'] = '0'\n    o['exited_ok'] = '1'\n    o['long_plugin_output'] = ''\n    o['performance_data'] = ''\n    o.update(locals())\n    o.update(kwargs)\n    del o['kwargs']\n    del o['o']\n\n    template = _host_check_result\n    # Escape all linebreaks if we have them\n    for k, v in o.items():\n        if isinstance(v, basestring) and '\\n' in v:\n            o[k] = v.replace('\\n', '\\\\n')\n\n    # Livestatus returns slightly different output than status.dat\n    # Lets normalize everything to status.dat format\n    if 'name' in o and not 'host_name' in o:\n        o['host_name'] = o['name']\n    if 'state' in o and not 'return_code' in o:\n        o['return_code'] = o['state']\n    if 'description' in o and not 'service_description' in o:\n        o['service_description'] = o['description']\n    if not o['performance_data'] and 'perf_data' in o:\n        o['performance_data'] = o['perf_data']\n\n    # If this is a service (as opposed to host) lets add service_description field in out putput\n    if 'service_description' in o:\n        template += \"service_description={service_description}\\n\"\n    if not o['performance_data'].endswith('\\\\n'):\n        o['performance_data'] += '\\\\n'\n\n    # Format the string and return\n    return template.format(**o) + '\\n'"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef to_json(self):\n\n        j = {}\n        for p in self.properties:\n            j[p] = getattr(self, p)\n\n        return json.dumps(j)", "response": "Serialize an object to JSON based on its properties class\n        attribute."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef to_dictionary(self):\n\n        j = {}\n        for p in self.properties:\n            j[p] = getattr(self, p)\n\n        return j", "response": "Serialize an object into dictionary form. Useful for debugging."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nserialize an object into dictionary form. Useful if you have to serialize an array of objects into JSON.", "response": "def to_dictionary(self):\n        \"\"\"Serialize an object into dictionary form.  Useful if you have to\n        serialize an array of objects into JSON.  Otherwise, if you call the\n        :meth:`to_json` method on each object in the list and then try to\n        dump the array, you end up with an array with one string.\"\"\"\n\n        j = {}\n        j['series'] = self.series.to_dictionary()\n        j['data'] = self.data.to_dictionary()\n        return j"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef to_dictionary(self):\n\n        d = {'start': self.start.isoformat(),\n             'end': self.end.isoformat(),\n             'tz': self.tz,\n             'summary': self.summary.to_dictionary(),\n             'series': self.series.to_dictionary()\n             }\n        return d", "response": "Serialize an object into dictionary form. Useful if you have to serialize an array of objects into JSON."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates a DataPoint object from data.", "response": "def from_data(self, time, value, series_id=None, key=None, tz=None):\n        \"\"\"Create a DataPoint object from data, rather than a JSON object or\n        string.  This should be used by user code to construct DataPoints from\n        Python-based data like Datetime objects and floats.\n\n        The series_id and key arguments are only necessary if you are doing a\n        multi write, in which case those arguments can be used to specify which\n        series the DataPoint belongs to.\n\n        If needed, the tz argument should be an Olsen database compliant string\n        specifying the time zone for this DataPoint.  This argument is most\n        often used internally when reading data from TempoDB.\n\n        :param time: the point in time for this reading\n        :type time: ISO8601 string or Datetime\n        :param value: the value for this reading\n        :type value: int or float\n        :param string series_id: (optional) a series ID for this point\n        :param string key: (optional) a key for this point\n        :param string tz: (optional) a timezone for this point\n        :rtype: :class:`DataPoint`\"\"\"\n\n        t = check_time_param(time)\n        if type(value) in [float, int]:\n            v = value\n        else:\n            raise ValueError('Values must be int or float. Got \"%s\".' %\n                             str(value))\n\n        j = {\n            't': t,\n            'v': v,\n            'id': series_id,\n            'key': key\n        }\n        return DataPoint(j, None, tz=tz)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef to_dictionary(self):\n\n        j = {}\n        for p in self.properties:\n            try:\n                v = getattr(self, p)\n            except AttributeError:\n                continue\n            if v is not None:\n                if p == 't':\n                    j[p] = getattr(self, p).isoformat()\n                else:\n                    j[p] = getattr(self, p)\n\n        return j", "response": "Serialize an object into dictionary form. Useful if you have to serialize an array of objects into JSON."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef from_json(self, json_text):\n\n        if type(json_text) in [str, unicode]:\n            j = json.loads(json_text)\n        else:\n            j = json_text\n\n        try:\n            for p in self.properties:\n                if p == 'interval':\n                    self.start = convert_iso_stamp(j[p]['start'], self.tz)\n                    self.end = convert_iso_stamp(j[p]['end'], self.tz)\n                elif p == 'found':\n                    t = convert_iso_stamp(j[p]['t'], self.tz)\n                    setattr(self, 't', t)\n                    v = j[p]['v']\n                    setattr(self, 'v', v)\n        #overriding this exception allows us to handle optional values like\n        #id and key which are only present during particular API calls like\n        #multi writes\n        except KeyError:\n            pass", "response": "This method will take a JSON object and deserialize it into this object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef to_dictionary(self):\n\n        j = {}\n        j['interval'] = {'start': self.start.isoformat(),\n                         'end': self.end.isoformat()}\n        j['found'] = {'v': self.v, 't': self.t.isoformat()}\n        return j", "response": "Serialize an object into dictionary form. Useful if you have to serialize an array of objects into JSON."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef to_json(self):\n\n        j = {}\n        for p in self.properties:\n            try:\n                v = getattr(self, p)\n            except AttributeError:\n                continue\n            if v is not None:\n                if p == 't':\n                    j[p] = getattr(self, p).isoformat()\n                else:\n                    j[p] = getattr(self, p)\n\n        return json.dumps(j)", "response": "Serialize an object to JSON based on its properties class\n        attribute."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef read(self, n=-1):\n        if n < -1:\n            raise IOError('Cannot read backwards')\n\n        bytes = self._buffer.read(n)\n\n        return bytes", "response": "Reads n bytes from the stream."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef truncate(self, size=0):\n        if size == 0:\n            self._buffer = StringIO()\n            self._len_changed = True\n\n            return\n\n        cur_pos = self.tell()\n        self.seek(0)\n        buf = self.read(size)\n        self._buffer = StringIO()\n\n        self._buffer.write(buf)\n        self.seek(cur_pos)\n        self._len_changed = True", "response": "Truncates the stream to the specified length."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nwrite the specified bytes into the internal buffer.", "response": "def write(self, s, size=None):\n        \"\"\"\n        Writes the content of the specified C{s} into this buffer.\n\n        @param s: Raw bytes\n        \"\"\"\n        self._buffer.write(s)\n        self._len_changed = True"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _get_len(self):\n        if hasattr(self._buffer, 'len'):\n            self._len = self._buffer.len\n\n            return\n\n        old_pos = self._buffer.tell()\n        self._buffer.seek(0, 2)\n\n        self._len = self._buffer.tell()\n        self._buffer.seek(old_pos)", "response": "Return total number of bytes in buffer."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef consume(self):\n        try:\n            bytes = self.read()\n        except IOError:\n            bytes = ''\n\n        self.truncate()\n\n        if len(bytes) > 0:\n            self.write(bytes)\n            self.seek(0)", "response": "Consume the next set of entries from the internal memory."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _read(self, length):\n        bytes = self.read(length)\n\n        if len(bytes) != length:\n            self.seek(0 - len(bytes), 1)\n\n            raise IOError(\"Tried to read %d byte(s) from the stream\" % length)\n\n        return bytes", "response": "Reads length bytes from the stream."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ndetermine if the current endian is big endian.", "response": "def _is_big_endian(self):\n        \"\"\"\n        Whether the current endian is big endian.\n        \"\"\"\n        if self.endian == DataTypeMixIn.ENDIAN_NATIVE:\n            return SYSTEM_ENDIAN == DataTypeMixIn.ENDIAN_BIG\n\n        return self.endian in (DataTypeMixIn.ENDIAN_BIG, DataTypeMixIn.ENDIAN_NETWORK)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef write_uchar(self, c):\n        if type(c) not in python.int_types:\n            raise TypeError('expected an int (got:%r)' % type(c))\n\n        if not 0 <= c <= 255:\n            raise OverflowError(\"Not in range, %d\" % c)\n\n        self.write(struct.pack(\"B\", c))", "response": "Writes an unsigned char to the stream."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef write_ushort(self, s):\n        if type(s) not in python.int_types:\n            raise TypeError('expected an int (got:%r)' % (type(s),))\n\n        if not 0 <= s <= 65535:\n            raise OverflowError(\"Not in range, %d\" % s)\n\n        self.write(struct.pack(\"%sH\" % self.endian, s))", "response": "Writes a 2 byte unsigned integer to the stream."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef write_ulong(self, l):\n        if type(l) not in python.int_types:\n            raise TypeError('expected an int (got:%r)' % (type(l),))\n\n        if not 0 <= l <= 4294967295:\n            raise OverflowError(\"Not in range, %d\" % l)\n\n        self.write(struct.pack(\"%sL\" % self.endian, l))", "response": "Writes a 4 byte unsigned integer to the stream."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreading a 24 bit unsigned integer from the stream.", "response": "def read_24bit_uint(self):\n        \"\"\"\n        Reads a 24 bit unsigned integer from the stream.\n\n        @since: 0.4\n        \"\"\"\n        order = None\n\n        if not self._is_big_endian():\n            order = [0, 8, 16]\n        else:\n            order = [16, 8, 0]\n\n        n = 0\n\n        for x in order:\n            n += (self.read_uchar() << x)\n\n        return n"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nwriting a 24 bit unsigned integer to the stream.", "response": "def write_24bit_uint(self, n):\n        \"\"\"\n        Writes a 24 bit unsigned integer to the stream.\n\n        @since: 0.4\n        @param n: 24 bit unsigned integer\n        @type n: C{int}\n        @raise TypeError: Unexpected type for int C{n}.\n        @raise OverflowError: Not in range.\n        \"\"\"\n        if type(n) not in python.int_types:\n            raise TypeError('expected an int (got:%r)' % (type(n),))\n\n        if not 0 <= n <= 0xffffff:\n            raise OverflowError(\"n is out of range\")\n\n        order = None\n\n        if not self._is_big_endian():\n            order = [0, 8, 16]\n        else:\n            order = [16, 8, 0]\n\n        for x in order:\n            self.write_uchar((n >> x) & 0xff)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef write_double(self, d):\n        if not type(d) is float:\n            raise TypeError('expected a float (got:%r)' % (type(d),))\n\n        self.write(struct.pack(\"%sd\" % self.endian, d))", "response": "Writes an 8 byte float to the stream."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nwrite a 4 byte float to the stream.", "response": "def write_float(self, f):\n        \"\"\"\n        Writes a 4 byte float to the stream.\n\n        @param f: 4 byte float\n        @type f: C{float}\n        @raise TypeError: Unexpected type for float C{f}.\n        \"\"\"\n        if type(f) is not float:\n            raise TypeError('expected a float (got:%r)' % (type(f),))\n\n        self.write(struct.pack(\"%sf\" % self.endian, f))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nread a UTF - 8 string from the stream.", "response": "def read_utf8_string(self, length):\n        \"\"\"\n        Reads a UTF-8 string from the stream.\n\n        @rtype: C{unicode}\n        \"\"\"\n        s = struct.unpack(\"%s%ds\" % (self.endian, length), self.read(length))[0]\n\n        return s.decode('utf-8')"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nwrite a unicode object to the stream in UTF - 8.", "response": "def write_utf8_string(self, u):\n        \"\"\"\n        Writes a unicode object to the stream in UTF-8.\n\n        @param u: unicode object\n        @raise TypeError: Unexpected type for str C{u}.\n        \"\"\"\n        if not isinstance(u, python.str_types):\n            raise TypeError('Expected %r, got %r' % (python.str_types, u))\n\n        bytes = u\n\n        if isinstance(bytes, unicode):\n            bytes = u.encode(\"utf8\")\n\n        self.write(struct.pack(\"%s%ds\" % (self.endian, len(bytes)), bytes))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nread up to the specified number of bytes from the stream into a byte array.", "response": "def read(self, length=-1):\n        \"\"\"\n        Reads up to the specified number of bytes from the stream into\n        the specified byte array of specified length.\n\n        @raise IOError: Attempted to read past the end of the buffer.\n        \"\"\"\n        if length == -1 and self.at_eof():\n            raise IOError(\n                'Attempted to read from the buffer but already at the end')\n        elif length > 0 and self.tell() + length > len(self):\n            raise IOError('Attempted to read %d bytes from the buffer but '\n                'only %d remain' % (length, len(self) - self.tell()))\n\n        return StringIOProxy.read(self, length)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef peek(self, size=1):\n        if size == -1:\n            return self.peek(len(self) - self.tell())\n\n        if size < -1:\n            raise ValueError(\"Cannot peek backwards\")\n\n        bytes = ''\n        pos = self.tell()\n\n        while not self.at_eof() and len(bytes) != size:\n            bytes += self.read(1)\n\n        self.seek(pos)\n\n        return bytes", "response": "Reads up to size bytes ahead in the stream and returns them as a string."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef append(self, data):\n        t = self.tell()\n\n        # seek to the end of the stream\n        self.seek(0, 2)\n\n        if hasattr(data, 'getvalue'):\n            self.write_utf8_string(data.getvalue())\n        else:\n            self.write_utf8_string(data)\n\n        self.seek(t)", "response": "Append data to the end of the stream."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the calibration dictionary for a given satellite.", "response": "def calibration(date, satellite):\n    \"\"\"\n    Return the calibration dictionary.\n\n    Keyword arguments:\n    satellite -- the name of the satellite.\n    date --  the datetime of an image.\n    \"\"\"\n    counts_shift = CountsShift()\n    space_measurement = SpaceMeasurement()\n    prelaunch = PreLaunch()\n    postlaunch = PostLaunch()\n    return {\n        'counts_shift': counts_shift.coefficient(satellite),\n        'space_measurement': space_measurement.coefficient(satellite),\n        'prelaunch': prelaunch.coefficient(satellite),\n        'postlaunch': postlaunch.coefficient(date, satellite)\n    }"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ninstall all plugin directories in the specified plugins directory.", "response": "def install_dependencies(plugins_directory, ostream=sys.stdout):\n    '''\n    Run ``on_plugin_install`` script for each plugin directory found in\n    specified plugins directory.\n\n    Parameters\n    ----------\n    plugins_directory : str\n        File system path to directory containing zero or more plugin\n        subdirectories.\n    ostream : file-like\n        Output stream for status messages (default: ``sys.stdout``).\n    '''\n    plugin_directories = plugins_directory.realpath().dirs()\n\n    print >> ostream, 50 * '*'\n    print >> ostream, 'Processing plugins:'\n    print >> ostream, '\\n'.join(['  - {}'.format(p)\n                                    for p in plugin_directories])\n    print >> ostream, '\\n' + 50 * '-' + '\\n'\n\n    for plugin_dir_i in plugin_directories:\n        try:\n            on_plugin_install(plugin_dir_i, ostream=ostream)\n        except RuntimeError, exception:\n            print exception\n        print >> ostream, '\\n' + 50 * '-' + '\\n'"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nparses arguments returns options and args.", "response": "def parse_args(args=None):\n    '''Parses arguments, returns ``(options, args)``.'''\n    if args is None:\n        args = sys.argv\n\n    parser = argparse.ArgumentParser(description='MicroDrop plugin '\n                                     'dependencies installer',\n                                     parents=[INSTALL_REQUIREMENTS_PARSER])\n\n    return parser.parse_args()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the last weekday before date", "response": "def previous_weekday(date):\n    '''\n    Returns the last weekday before date\n\n    Args:\n        date (datetime or datetime.date)\n    Returns:\n        (datetime or datetime.date)\n    Raises:\n        -\n    '''\n    weekday = date.weekday()\n    if weekday == 0:\n        n_days = 3\n    elif weekday == 6:\n        n_days = 2\n    else:\n        n_days = 1\n    return date - datetime.timedelta(days=n_days)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the next weekday after date", "response": "def next_weekday(date):\n    '''\n    Return the first weekday after date\n\n    Args:\n        date (datetime or datetime.date)\n    Returns:\n        (datetime or datetime.date)\n    Raises:\n        -\n    '''\n    n_days = 7 - date.weekday()\n    if n_days > 3:\n        n_days = 1\n    return date + datetime.timedelta(days=n_days)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef last_year(date_):\n    '''\n    Returns the same date 1 year ago.\n\n    Args:\n        date (datetime or datetime.date)\n    Returns:\n        (datetime or datetime.date)\n    Raises:\n        -\n    '''\n    day = 28 if date_.day == 29 and date_.month == 2 else date_.day\n    return datetime.date(date_.year-1, date_.month, day)", "response": "Returns the same date 1 year ago."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef timestr2time(time_str):\n    '''\n    Turns a string into a datetime.time object. This will only work if the \n    format can be \"guessed\", so the string must have one of the formats from\n    VALID_TIME_FORMATS_TEXT.\n\n    Args:\n        time_str (str) a string that represents a date\n    Returns:\n        datetime.time object\n    Raises:\n        ValueError if the input string does not have a valid format.\n    '''\n    if any(c not in '0123456789:' for c in time_str):\n        raise ValueError('Illegal character in time string')\n    if time_str.count(':') == 2:\n        h, m, s = time_str.split(':')\n    elif time_str.count(':') == 1:\n        h, m = time_str.split(':')\n        s = '00'\n    elif len(time_str) == 6:\n        h = time_str[:2]\n        m = time_str[2:4]\n        s = time_str[4:]\n    else:\n        raise ValueError('Time format not recognised. {}'.format(\n                VALID_TIME_FORMATS_TEXT))\n    if len(m) == 2 and len(s) == 2:\n        mins = int(m)\n        sec = int(s)\n    else:\n        raise ValueError('m and s must be 2 digits')\n    try:\n        return datetime.time(int(h), mins, sec)\n    except ValueError:\n        raise ValueError('Invalid time {}. {}'.format(time_str, \n                VALID_TIME_FORMATS_TEXT))", "response": "Converts a string into a datetime. time object."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconverts a datetime. time object into a string.", "response": "def time2timestr(time, fmt='hhmmss'):\n    '''\n    Turns a datetime.time object into a string. The string must have one of the\n    formats from VALID_TIME_FORMATS_TEXT to make it compatible with \n    timestr2time.\n\n    Args:\n        time (datetime.time) the time to be translated\n        fmt (str) a format string.\n    Returns:\n        (str) that represents a time.\n    Raises:\n        ValueError if the format is not valid.\n    '''\n    if fmt.count(':') == 2:\n        if not fmt.index('h') < fmt.index('m') < fmt.index('s'):\n            raise ValueError('Invalid format string. {}'.format(\n                    VALID_TIME_FORMATS_TEXT))\n        h, m, s = fmt.split(':')\n    elif fmt.count(':') == 1:\n        if not fmt.index('h') < fmt.index('m'):\n            raise ValueError('Invalid format string. {}'.format(\n                    VALID_TIME_FORMATS_TEXT))\n        h, m = fmt.split(':')\n        s = None\n    elif any(c not in 'hms' for c in fmt) or len(fmt) != 6:\n        raise ValueError('Invalid character in format string. {}'.format(\n                VALID_TIME_FORMATS_TEXT))\n    else:\n        if not fmt.index('h') < fmt.index('m') < fmt.index('s'):\n            raise ValueError('Invalid format string. {}'.format(\n                    VALID_TIME_FORMATS_TEXT))\n        h, m, s = fmt[:-4], fmt[-4:-2], fmt[-2:]\n    for string, char in ((h, 'h'), (m, 'm'), (s, 's')):\n        if string is not None and any(c != char for c in string):\n            raise ValueError('Invalid date format: {} is not {}'.\\\n                    format(char, string))\n    if len(h) == 2:\n        fmt = fmt.replace('hh', '%H', 1)\n    elif len(h) == 1:\n        fmt = fmt.replace('h', 'X%H', 1)\n    else:\n        raise ValueError('Invalid format string, hour must have 1 or 2 digits')\n    if len(m) == 2:\n        fmt = fmt.replace('mm', '%M', 1)\n    else:\n        raise ValueError('Invalid format string, minutes must have 2 digits')\n    if s is not None and len(s) == 2:\n        fmt = fmt. replace('ss', '%S', 1)\n    elif s is not None:\n        raise ValueError('Invalid format string, seconds must have 2 digits')\n    return time.strftime(fmt).replace('X0','X').replace('X','')"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the index of the date in the date list.", "response": "def index(self, date):\n        '''\n        Overloads the default list.index, because of special behaviour if the\n        date is not in the list:\n            - If <date> is not in the list, the index of the latest date before\n                <date> is returned.\n            - If <date> is earlier than the earliest date in the list, the \n                return value is 0\n            - If <date> is later than the latest date in self.dates the return\n                value is the index of the most recent date.\n        '''\n        if date in self:\n            index = super(DateList, self).index(date)\n        elif date < self[0]:\n            index = 0\n        elif date > self[-1]:\n            index = len(self) - 1\n        else:\n            while date not in self:\n                date -= self.ONE_DAY\n            index = super(DateList, self).index(date)\n        return index"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef delta(self, fromdate, todate):\n        '''\n        Return the number of dates in the list between <fromdate> and\n        <todate>.\n        '''\n#CONSIDER: raise an exception if a date is not in self\n        return self.index(todate) - self.index(fromdate)", "response": "Return the number of dates in the list between fromdate and todate."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the date n_days after or before date", "response": "def offset(self, date, n_days):\n        '''\n        Return the date n_days after (or before if n_days < 0) <date>\n        note: not calender days, but self days!\n        '''\n#CONSIDER: raise an exception if a date is not in self\n        index = self.index(date) + n_days\n        if index < 0:\n            index = 0\n        if index > len(self) - 1:\n            index = len(self) - 1\n        return self[index]"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef subset(self, fromdate, todate):\n        '''\n        Return a list of dates from the list between <fromdate> and <todate>\n        (inclusive)\n        '''\n#CONSIDER: raise an exception if a date is not in self\n        i_from = self.index(fromdate)\n        if fromdate != self[i_from]:\n            # don't go back before fromdate\n            i_from += 1\n        i_to = self.index(todate)\n        return self[i_from:i_to + 1]", "response": "Return a list of dates from the list between fromdate and todate"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nchecks if the concurrency value is valid according to the default one and the forced one.", "response": "def check_custom_concurrency(default, forced, logger=None):\n    \"\"\" Get the proper concurrency value according to the default one\n    and the one specified by the crawler.\n\n    :param int default:\n      default tasks concurrency\n\n    :param forced:\n      concurrency asked by crawler\n\n    :return:\n      concurrency to use.\n    :rtype: int\n    \"\"\"\n    logger = logger or LOGGER\n    cmc_msg = 'Invalid \"max_concurrent_tasks: '\n    if not isinstance(forced, int):\n        logger.warn(cmc_msg + 'expecting int')\n    elif forced > default:\n        msg = 'may not be greater than: %s' % default\n        logger.warn(cmc_msg + msg)\n    elif forced < 1:\n        msg = 'may not be less than 1'\n        logger.warn(cmc_msg + msg)\n    else:\n        default = forced\n    return default"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef reorg_crawl_tasks(tasks, concurrency, logger=None):\n    futures = tasks['tasks']\n    epilogue = tasks.get('epilogue')\n    custom_concurrency = tasks.get('max_concurrent_tasks', concurrency)\n    check_custom_concurrency(concurrency, custom_concurrency, logger)\n    futures = list(futures)\n    return futures, epilogue, concurrency", "response": "Extract content returned by the crawler iter_crawl_tasks member method."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef split_crawl_tasks(tasks, concurrency):\n    if any(tasks) and isinstance(tasks[0], list):\n        for seq in tasks:\n            if not isinstance(seq, list):\n                raise Exception(\"Expected a list of tasks\")\n    else:\n        if concurrency > 1:\n            chain_size = int(ceil(float(len(tasks)) / concurrency))\n            tasks = [\n                chunk for chunk in\n                chunks(\n                    iter(tasks),\n                    max(1, chain_size)\n                )\n            ]\n        else:\n            tasks = [tasks]\n    return tasks", "response": "Reorganize tasks according to the tasks max concurrency value."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef do_static_merge(cls, c_source, c_target):\n        c_target.extend(c_source)\n        c_source.parent = c_target.parent\n        cls.CLUSTERS.remove(c_source)\n        for m in c_source.mentions:\n            cls.MENTION_TO_CLUSTER[m] = c_target", "response": "This method merges the instance and cluster entries in the source set into the target set."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets a series of pseudo - random letters with no repeats.", "response": "def random_letters(count):\n    \"\"\"Get a series of pseudo-random letters with no repeats.\"\"\"\n    rv = random.choice(string.ascii_uppercase)\n    while len(rv) < count:\n        l = random.choice(string.ascii_uppercase)\n        if not l in rv:\n            rv += l\n    return rv"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngenerating a month - long codebuch and save it to a file.", "response": "def random_codebuch(path):\n    \"\"\"Generate a month-long codebuch and save it to a file.\"\"\"\n\n    lines = []\n    for i in range(31):\n        line = str(i+1) + \" \"\n\n        # Pick rotors\n        all_rotors = ['I', 'II', 'III', 'IV', 'V']\n        rotors = [random.choice(all_rotors)]\n        while len(rotors) < 3:\n            r = random.choice(all_rotors)\n            if not r in rotors:\n                rotors.append(r)\n                line += r + ' '\n\n        # Pick rotor settings.\n        settings = [str(random.randint(1, 26))]\n        while len(settings) < 3:\n            s = str(random.randint(1, 26))\n            if not s in settings:\n                settings.append(s)\n                line += s + ' '\n\n        # Pick plugboard settings.\n        plugboard = []\n        while len(plugboard) < 20:\n            p1 = random_letters(1)\n            p2 = random_letters(1)\n            if (not p1 == p2 and\n               not p1 in plugboard and not p2 in plugboard):\n                plugboard.extend([p1, p2])\n                line += p1 + p2 + ' '\n\n        # Pick a reflector.\n        reflector = random.choice(['B', 'C'])\n        line += reflector\n\n        line += os.linesep\n        lines.append(line)\n\n    with open(path, 'w') as f:\n        f.writelines(lines)\n\n    return lines"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nhave the operator encrypt a message.", "response": "def encrypt(self, plaintext):\n        \"\"\"Have the operator encrypt a message.\"\"\"\n\n        # Encrpyt message key.\n        msg_key = random_letters(3)\n        while msg_key == self.grundstellung:\n            msg_key = random_letters(3)\n        self.machine.set_display(self.grundstellung)\n        enc_key = self.machine.process_text(msg_key)\n\n        # Encrpyt message.\n        self.machine.set_display(msg_key)\n        ciphertext = self.machine.process_text(plaintext)\n\n        # Encode message with keys.\n        return \"{enc_key}{ciphertext}{grundstellung}\".format(\n            enc_key=enc_key,\n            ciphertext=ciphertext,\n            grundstellung=self.grundstellung\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nhas the operator decrypt a message.", "response": "def decrypt(self, ciphertext):\n        \"\"\"Have the operator decrypt a message.\"\"\"\n\n        # Separate keys from message.\n        enc_key = ciphertext[:3]\n        message = ciphertext[3:-3]\n        grundstellung = ciphertext[-3:]\n\n        # Decrypt message key.\n        self.machine.set_display(grundstellung)\n        msg_key = self.machine.process_text(enc_key)\n        # Decrpyt message.\n        self.machine.set_display(msg_key)\n        return self.machine.process_text(message)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a string -ified version number.", "response": "def get_version(full=False):\n    \"\"\"\n    Returns a string-ified version number.\n\n    Optionally accepts a ``full`` parameter, which if ``True``, will include\n    any pre-release information. (Default: ``False``)\n    \"\"\"\n    version = '.'.join([str(bit) for bit in __version__[:3]])\n\n    if full:\n        version = '-'.join([version] + list(__version__[3:]))\n\n    return version"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a list of URL strings.", "response": "def getAdditionalImages(self):\n        '''\n        The same as calling ``client.getAdditionalImages(build.setID)``.\n\n        :returns: A list of URL strings.\n        :rtype: list\n        '''\n\n        self._additionalImages = self._client.getAdditionalImages(self.setID)\n        return self._additionalImages"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a list of brickfront. review. Review objects.", "response": "def getReviews(self):\n        '''\n        The same as calling ``client.getReviews(build.setID)``.\n\n        :returns: A list of :class:`brickfront.review.Review` objects.\n        :rtype: list\n        '''\n\n        self._reviews = self._client.getReviews(self.setID)\n        return self._reviews"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef getInstructions(self):\n        '''\n        The same as calling ``client.getInstructions(build.setID)``\n\n        :returns: A list of instructions.\n        :rtype: list\n        '''\n\n        self._instructions = self._client.getInstructions(self.setID)\n        return self._instructions", "response": "Returns a list of instructions for this build."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef parse_args_kwargs(self, *args, **kwargs):\n        '''Parse the arguments with keywords.'''\n        # unpack the arginfo\n        keys, defdict = self.arginfo\n        assigned = keys[:len(args)]\n        not_assigned = keys[len(args):]\n\n        # validate kwargs\n        for key in kwargs:\n            assert key not in assigned\n            assert key in keys\n\n        # integrate args and kwargs\n        knowns = dict(defdict, **kwargs)\n        parsed_args = args + tuple([knowns[key] for key in not_assigned])\n        return parsed_args", "response": "Parse the arguments with keywords."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the keys and the default dictionary of the given function s arguments", "response": "def _get_keys_defdict(self):\n        '''Get the keys and the default dictionary of the given function's\n        arguments\n        '''\n        # inspect argspecs\n        argspec = inspect.getargspec(self.func)\n        keys, defvals = argspec.args, argspec.defaults\n\n        # convert to (list_of_argkeys, dict_of_default_keys)\n        if defvals is None:\n            return keys, None\n        else:\n            defvals = list(defvals)\n            keys.reverse()\n            defvals.reverse()\n            defdict = dict(zip(keys, defvals))\n            keys.reverse()\n            return keys, defdict"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncompile the function with array - like objects", "response": "def compile_with_value(self, func, args=None, owner=None):\n        '''Compile the function with array-like objects'''\n        # format args\n        if args is None:\n            args = []\n\n        # cast numpy.ndarray into theano.tensor\n        theano_args = [self.cast2theano_var(a, 'extheano.jit.Compiler-arg-%d' % i)\n                       for a, i in zip(args, range(len(args)))]\n\n        # compiled value with symbol\n        return self.compile_with_symbol(func, theano_args, owner)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef compile_with_symbol(self, func, theano_args=None, owner=None):\n        '''Compile the function with theano symbols'''\n        if theano_args is None:\n            theano_args = []\n\n        # initialize the shared buffers\n        upc = UpdateCollector()\n\n        # get the output symbols and other Theano options\n        theano_ret = func(*theano_args) if owner is None \\\n            else func(owner, *theano_args)\n\n        # integrate the information of updates, givens and the other options\n        out = copy.copy(self.default_options)\n        out['outputs'] = theano_ret\n        out['updates'] = upc.extract_updates()\n\n        # compile the function\n        return theano.function(theano_args, **out)", "response": "Compile the function with theano symbols"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef cast2theano_var(self, array_like, name=None):\n        '''Cast `numpy.ndarray` into `theano.tensor` keeping `dtype` and `ndim`\n        compatible\n        '''\n        # extract the information of the input value\n        array = np.asarray(array_like)\n        args = (name, array.dtype)\n        ndim = array.ndim\n\n        # cast with the information above\n        if ndim == 0:\n            return T.scalar(*args)\n        elif ndim == 1:\n            return T.vector(*args)\n        elif ndim == 2:\n            return T.matrix(*args)\n        elif ndim == 3:\n            return T.tensor3(*args)\n        elif ndim == 4:\n            return T.tensor4(*args)\n        else:\n            raise ValueError('extheano.jit.Compiler: Unsupported type or shape')", "response": "Cast numpy. ndarray into theano. tensor keeping dtype and ndim compatible\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _get_fn(fn, mode, load):\n    '''\n    Load a contents, checking that the file was not modified during the read.\n    '''\n    try:\n        mtime_before = os.path.getmtime(fn)\n    except OSError:\n        mtime_before = None\n\n    try:\n        with open(fn, mode) as fp:\n            item = load(fp)\n    except OpenError:\n        raise\n    else:\n        mtime_after = os.path.getmtime(fn)\n        if mtime_before in {None, mtime_after}:\n            return item\n        else:\n            raise EnvironmentError('File was edited during read: %s' % fn)", "response": "Load a contents of a file and check that the file was not modified during the read."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nflattens a nested iterable into a single level.", "response": "def flatten_iterable(iterable):\n    \"\"\"\n    Flattens a nested iterable into a single layer. Generator.\n\n    If you only want to flatten a single level, use more_itertools.flatten.\n\n    Example::\n\n        >>> nested_iterable = (('t1', 't2'), ['l1', 'l2', ('l1', 'l2')])\n        >>> list(flatten_iterable(nested_iterable))\n        ['t1', 't2', 'l1', 'l2', 'l1', 'l2']\n        >>> set(flatten_iterable(nested_iterable)) == {'t1', 't2', 'l1', 'l2'}\n        True\n    \"\"\"\n    for item in iterable:\n        if isinstance(item, Iterable) and not isinstance(item, string_types):\n            for sub in flatten_iterable(item):\n                yield sub\n        else:\n            yield item"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef list_events_view(request):\n    ''' A list view of upcoming events. '''\n    page_name = \"Upcoming Events\"\n    profile = UserProfile.objects.get(user=request.user)\n    event_form = EventForm(\n        request.POST if 'post_event' in request.POST else None,\n        profile=profile,\n    )\n    if event_form.is_valid():\n        event_form.save()\n        return HttpResponseRedirect(reverse('events:list'))\n\n    # a pseudo-dictionary, actually a list with items of form (event, ongoing,\n    # rsvpd, rsvp_form), where ongoing is a boolean of whether the event is\n    # currently ongoing, rsvpd is a boolean of whether the user has rsvp'd to\n    # the event\n    events_dict = list()\n    for event in Event.objects.filter(end_time__gte=now()):\n        rsvp_form = RsvpForm(\n            request.POST if \"rsvp-{0}\".format(event.pk) in request.POST else None,\n            instance=event,\n            profile=profile,\n        )\n        if rsvp_form.is_valid():\n            rsvpd = rsvp_form.save()\n            if rsvpd:\n                message = MESSAGES['RSVP_ADD'].format(event=event.title)\n            else:\n                message = MESSAGES['RSVP_REMOVE'].format(event=event.title)\n            messages.add_message(request, messages.SUCCESS, message)\n            return HttpResponseRedirect(reverse('events:list'))\n\n        ongoing = ((event.start_time <= now()) and (event.end_time >= now()))\n        rsvpd = (profile in event.rsvps.all())\n        events_dict.append((event, ongoing, rsvpd, rsvp_form))\n\n    if request.method == \"POST\":\n        messages.add_message(request, messages.ERROR, MESSAGES[\"EVENT_ERROR\"])\n\n    return render_to_response('list_events.html', {\n        'page_name': page_name,\n        'events_dict': events_dict,\n        'now': now(),\n        'event_form': event_form,\n    }, context_instance=RequestContext(request))", "response": "A list view of upcoming events."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef edit_event_view(request, event_pk):\n    ''' The view to edit an event. '''\n    page_name = \"Edit Event\"\n    profile = UserProfile.objects.get(user=request.user)\n    event = get_object_or_404(Event, pk=event_pk)\n\n    if event.owner != profile and not request.user.is_superuser:\n        return HttpResponseRedirect(\n            reverse('events:view', kwargs={\"event_pk\": event_pk}),\n        )\n\n    event_form = EventForm(\n        request.POST or None,\n        profile=profile,\n        instance=event,\n    )\n    if event_form.is_valid():\n        event = event_form.save()\n        messages.add_message(\n            request, messages.SUCCESS,\n            MESSAGES['EVENT_UPDATED'].format(event=event.title),\n        )\n        return HttpResponseRedirect(\n            reverse('events:view', kwargs={\"event_pk\": event_pk}),\n        )\n\n    return render_to_response('edit_event.html', {\n        'page_name': page_name,\n        'event_form': event_form,\n    }, context_instance=RequestContext(request))", "response": "The view to edit an event."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _get_url_node(parser, bits):\n    viewname = parser.compile_filter(bits[1])\n    args = []\n    kwargs = {}\n    bits = bits[2:]\n\n    if len(bits):\n        kwarg_re = re.compile(r\"(?:(\\w+)=)?(.+)\")\n        for bit in bits:\n            match = kwarg_re.match(bit)\n            if not match:\n                raise TemplateSyntaxError(\"Malformed arguments to url tag\")\n            name, value = match.groups()\n            if name:\n                kwargs[name] = parser.compile_filter(value)\n            else:\n                args.append(parser.compile_filter(value))\n\n    return URLNode(viewname, args, kwargs, asvar=None)", "response": "Parses the expression as if it was a normal url tag."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a list of url parameters that can be used to search for a specific resource.", "response": "def qurl(parser, token):\n    \"\"\"\n    Append, remove or replace query string parameters (preserve order)\n\n        {% qurl url [param]* [as <var_name>] %}\n\n        {% qurl 'reverse_name' [reverse_params] | [param]* [as <var_name>] %}\n\n    param:\n            name=value: replace all values of name by one value\n            name=None: remove all values of name\n            name+=value: append a new value for name\n            name-=value: remove the value of name with the value\n\n    Example::\n\n        {% qurl '/search?page=1&color=blue&color=green'\n                 order='name' page=None color+='red' color-='green' %}\n        Output: /search?color=blue&order=name&color=red\n\n        {% qurl request.get_full_path order='name' %}\n    \"\"\"\n    bits = token.split_contents()\n    if len(bits) < 2:\n        raise TemplateSyntaxError(\n            '\"{0}\" takes at least one argument (url)'.format(bits[0]))\n\n    if bits.count('|') > 1:\n        raise TemplateSyntaxError(\n            '\"{0}\" may take only one separator'.format(bits[0]))\n\n    if bits.count('|'):\n        # A url expression was passed, needs reversing\n        url = _get_url_node(parser, bits[:bits.index('|')])\n        bits = bits[bits.index('|')+1:]\n    else:\n        # A url was passed directly\n        url = parser.compile_filter(bits[1])\n        bits = bits[2:]\n\n    asvar = None\n    if len(bits) >= 2 and bits[-2] == 'as':\n        asvar = bits[-1]\n        bits = bits[:-2]\n\n    qs = []\n    if len(bits):\n        kwarg_re = re.compile(r\"(\\w+)(\\-=|\\+=|=|\\-\\-)(.*)\")\n        for bit in bits:\n            match = kwarg_re.match(bit)\n            if not match:\n                raise TemplateSyntaxError(\"Malformed arguments to url tag\")\n            name, op, value = match.groups()\n            qs.append((name, op, parser.compile_filter(value),))\n\n    return QURLNode(url, qs, asvar)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef trigger(self, identifier, force=True):\n        self.debug(identifier)\n        url = \"{base}/{identifier}\".format(\n            base=self.local_base_url,\n            identifier=identifier\n        )\n        param = {}\n        if force:\n            param['force'] = force\n        encode = urllib.urlencode(param)\n        if encode:\n            url += \"?\"\n            url += encode\n        return self.core.update(url, {})", "response": "Trigger an upgrade task."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a gif based on search of several reactions", "response": "def devopsy(self, *args):\n        \"\"\"Return a gif based on search of several *reactions\n        Ported to Legobot from:\n            \"https://github.com/ricardokirkner/err-devops-reactions\"\n            ... and extended.\n\n        Return a random gif if no query is specified or query not found\n\n        Example:\n            !devopsy somefoofulquery\n            !devopsy\n        \"\"\"\n\n        args = ' '.join(self.message['text'].split()[1:])\n        if args:\n            base_main = {\n                'dev': 'https://devopsreactions.tumblr.com/',\n                'sec': 'https://securityreactions.tumblr.com/'\n            }\n            main_items = list(base_main.items())\n            key, val = random.choice(main_items)  # nosec\n        else:\n            base_alt = {\n                'qa': 'https://qareacts.tumblr.com/',\n                'dba': 'http://dbareactions.com/'\n            }\n            alt_items = list(base_alt.items())\n            key, val = random.choice(alt_items)  # nosec\n\n        if args and set(('dev', 'sec')) <= set(base_main):\n            q = urlencode({'q': args})\n            path = ''.join(['?', q])\n        else:\n            path = 'random'\n        url = urljoin(val, path)\n        r = requests.get(url)\n        logger.debug('url sent: {}'.format(r.url))\n\n        if r.ok:\n            dom = PyQuery(r.content)\n            results = dom('div[class=post_title] a')\n            logger.debug('results found: {}'.format(len(results)))\n        else:\n            results = []\n\n        if results:\n            item = random.choice(results)  # nosec\n            img = item.get('href')\n            response = img\n        else:\n            path = 'random'\n            noway = urljoin(url, path)\n            response = 'Foo for you: {}'.format(noway)\n        return response"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ngenerate the negation of the comparison node.", "response": "def _negate_compare_text(atok: asttokens.ASTTokens, node: ast.Compare) -> str:\n    \"\"\"\n    Generate the text representing the negation of the comparison node.\n\n    :param atok:\n        parsing obtained with ``asttokens`` so that we can access the last tokens of a node.\n\n        The standard ``ast`` module provides only the first token of an AST node. In lack of concrete syntax tree,\n        getting text from first to last token is currently the simplest approach.\n    :param node: AST node representing the comparison in a condition\n    :return: text representation of the node's negation\n    \"\"\"\n    assert len(node.ops) == 1, \"A single comparison expected, but got: {}\".format(len(node.ops))\n    assert len(node.comparators) == 1, \"A single comparator expected, but got: {}\".format(len(node.comparators))\n\n    operator = node.ops[0]\n    left = node.left\n    right = node.comparators[0]\n\n    left_text = atok.get_text(node=left)\n    right_text = atok.get_text(node=right)\n\n    text = ''\n\n    if isinstance(operator, ast.Eq):\n        text = '{} != {}'.format(left_text, right_text)\n\n    elif isinstance(operator, ast.NotEq):\n        text = '{} == {}'.format(left_text, right_text)\n\n    elif isinstance(operator, ast.Lt):\n        text = '{} >= {}'.format(left_text, right_text)\n\n    elif isinstance(operator, ast.LtE):\n        text = '{} > {}'.format(left_text, right_text)\n\n    elif isinstance(operator, ast.Gt):\n        text = '{} <= {}'.format(left_text, right_text)\n\n    elif isinstance(operator, ast.GtE):\n        text = '{} < {}'.format(left_text, right_text)\n\n    elif isinstance(operator, ast.Is):\n        text = '{} is not {}'.format(left_text, right_text)\n\n    elif isinstance(operator, ast.IsNot):\n        text = '{} is {}'.format(left_text, right_text)\n\n    elif isinstance(operator, ast.In):\n        text = '{} not in {}'.format(left_text, right_text)\n\n    elif isinstance(operator, ast.NotIn):\n        text = '{} in {}'.format(left_text, right_text)\n\n    else:\n        raise NotImplementedError(\"Unhandled comparison operator: {}\".format(operator))\n\n    return text"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nformats condition lambda function as reST.", "response": "def _condition_as_text(lambda_inspection: icontract._represent.ConditionLambdaInspection) -> str:\n    \"\"\"Format condition lambda function as reST.\"\"\"\n    lambda_ast_node = lambda_inspection.node\n    assert isinstance(lambda_ast_node, ast.Lambda)\n\n    body_node = lambda_ast_node.body\n\n    text = None  # type: Optional[str]\n    if isinstance(body_node, ast.BoolOp) and isinstance(body_node.op, ast.Or) and len(body_node.values) == 2:\n        left, right = body_node.values\n\n        if isinstance(left, ast.UnaryOp) and isinstance(left.op, ast.Not):\n            # Handle the case: not A or B is transformed to A => B\n            text = ':code:`{}` \u21d2 :code:`{}`'.format(\n                lambda_inspection.atok.get_text(node=left.operand), lambda_inspection.atok.get_text(node=right))\n\n        elif isinstance(left, (ast.UnaryOp, ast.BinOp, ast.GeneratorExp, ast.IfExp)):\n            text = ':code:`not ({})` \u21d2 :code:`{}`'.format(\n                lambda_inspection.atok.get_text(node=left), lambda_inspection.atok.get_text(node=right))\n\n        elif isinstance(left, ast.Compare) and len(left.ops) == 1:\n            text = ':code:`{}` \u21d2 :code:`{}`'.format(\n                _negate_compare_text(atok=lambda_inspection.atok, node=left),\n                lambda_inspection.atok.get_text(node=right))\n\n        elif isinstance(left, (ast.Call, ast.Attribute, ast.Name, ast.Subscript, ast.Index, ast.Slice, ast.ExtSlice,\n                               ast.ListComp, ast.SetComp, ast.DictComp)):\n            text = ':code:`not {}` \u21d2 :code:`{}`'.format(\n                lambda_inspection.atok.get_text(node=left), lambda_inspection.atok.get_text(node=right))\n\n    elif isinstance(body_node, ast.IfExp) and isinstance(body_node.orelse, ast.NameConstant) and body_node.orelse.value:\n        text = ':code:`{}` \u21d2 :code:`{}`'.format(\n            lambda_inspection.atok.get_text(node=body_node.test), lambda_inspection.atok.get_text(node=body_node.body))\n\n    if text is None:\n        # None of the previous reformatings worked, take the default approach.\n        text = ':code:`{}`'.format(lambda_inspection.atok.get_text(node=body_node))\n\n    return text"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ninspects the error argument of a contract and infer the error type and error message.", "response": "def _error_type_and_message(\n        decorator_inspection: icontract._represent.DecoratorInspection) -> Tuple[Optional[str], Optional[str]]:\n    \"\"\"\n    Inspect the error argument of a contract and infer the error type and the message if the error is given as a lambda.\n\n    If the error argument is not given or if it is not given as a lambda function, return immediately.\n\n    The error message is inferred as the single string-literal argument to a single call in the lambda body.\n\n    :param decorator_inspection: inspection of a contract decorator\n    :return: error type (None if not inferrable), error message (None if not inferrable)\n    \"\"\"\n    call_node = decorator_inspection.node\n\n    error_arg_node = None  # type: Optional[ast.AST]\n    for keyword in call_node.keywords:\n        if keyword.arg == 'error':\n            error_arg_node = keyword.value\n\n    if error_arg_node is None and len(call_node.args) == 5:\n        error_arg_node = call_node.args[4]\n\n    if not isinstance(error_arg_node, ast.Lambda):\n        return None, None\n\n    body_node = error_arg_node.body\n\n    # The body of the error lambda needs to be a callable, since it needs to return an instance of Exception\n    if not isinstance(body_node, ast.Call):\n        return None, None\n\n    error_type = decorator_inspection.atok.get_text(node=body_node.func)\n\n    error_message = None  # type: Optional[str]\n    if len(body_node.args) == 1 and len(body_node.keywords) == 0:\n        if isinstance(body_node.args[0], ast.Str):\n            error_message = body_node.args[0].s\n\n    elif len(body_node.args) == 0 and len(body_node.keywords) == 1:\n        if isinstance(body_node.keywords[0].value, ast.Str):\n            error_message = body_node.keywords[0].value.s\n\n    else:\n        # The error message could not be inferred.\n        pass\n\n    return error_type, error_message"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _format_contract(contract: icontract._Contract) -> str:\n    # pylint: disable=too-many-branches\n    decorator_inspection = None  # type: Optional[icontract._represent.DecoratorInspection]\n\n    ##\n    # Parse condition\n    ##\n\n    if not icontract._represent._is_lambda(a_function=contract.condition):\n        condition_text = ':py:func:`{}`'.format(contract.condition.__name__)\n    else:\n        # We need to extract the source code corresponding to the decorator since inspect.getsource() is broken with\n        # lambdas.\n\n        # Find the line corresponding to the condition lambda\n        lines, condition_lineno = inspect.findsource(contract.condition)\n        filename = inspect.getsourcefile(contract.condition)\n\n        decorator_inspection = icontract._represent.inspect_decorator(\n            lines=lines, lineno=condition_lineno, filename=filename)\n\n        lambda_inspection = icontract._represent.find_lambda_condition(decorator_inspection=decorator_inspection)\n        assert lambda_inspection is not None, \\\n            \"Expected non-None lambda inspection with the condition: {}\".format(contract.condition)\n\n        condition_text = _condition_as_text(lambda_inspection=lambda_inspection)\n\n    ##\n    # Parse error\n    ##\n\n    error_type = None  # type: Optional[str]\n\n    # Error message is set only for an error of a contract given as a lambda that takes no arguments and returns\n    # a result of a call on a string literal (*e.g.*, ``error=ValueError(\"some message\")``.\n    error_msg = None  # type: Optional[str]\n\n    if contract.error is not None:\n        if isinstance(contract.error, type):\n            error_type = contract.error.__qualname__\n        elif inspect.isfunction(contract.error) and icontract._represent._is_lambda(a_function=contract.error):\n            if decorator_inspection is None:\n                lines, condition_lineno = inspect.findsource(contract.error)\n                filename = inspect.getsourcefile(contract.error)\n\n                decorator_inspection = icontract._represent.inspect_decorator(\n                    lines=lines, lineno=condition_lineno, filename=filename)\n\n            error_type, error_msg = _error_type_and_message(decorator_inspection=decorator_inspection)\n        else:\n            # Error type could not be inferred\n            pass\n\n    ##\n    # Format\n    ##\n\n    description = None  # type: Optional[str]\n    if contract.description:\n        description = contract.description\n    elif error_msg is not None:\n        description = error_msg\n    else:\n        # Description could not be inferred.\n        pass\n\n    doc = None  # type: Optional[str]\n    if description and error_type:\n        if description.strip()[-1] in [\".\", \"!\", \"?\"]:\n            doc = \"{} Raise :py:class:`{}`\".format(description, error_type)\n        elif description.strip()[-1] in [\",\", \";\"]:\n            doc = \"{} raise :py:class:`{}`\".format(description, error_type)\n        else:\n            doc = \"{}; raise :py:class:`{}`\".format(description, error_type)\n\n    elif not description and error_type:\n        doc = \"Raise :py:class:`{}`\".format(error_type)\n\n    elif description and not error_type:\n        doc = description\n\n    else:\n        # No extra documentation can be generated since the error type could not be inferred and\n        # no contract description was given.\n        doc = None\n\n    if doc is not None:\n        return \"{} ({})\".format(condition_text, doc)\n\n    return condition_text", "response": "Format the contract as reST."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _format_preconditions(preconditions: List[List[icontract._Contract]], prefix: Optional[str] = None) -> List[str]:\n    if not preconditions:\n        return []\n\n    result = []  # type: List[str]\n    for i, group in enumerate(preconditions):\n        if i == 0:\n            if prefix is not None:\n                result.append(\":{} requires:\".format(prefix))\n            else:\n                result.append(\":requires:\")\n        else:\n            if prefix is not None:\n                result.append(\":{} requires else:\".format(prefix))\n            else:\n                result.append(\":requires else:\")\n\n        for precondition in group:\n            result.append(\"    * {}\".format(_format_contract(contract=precondition)))\n\n    return result", "response": "Format preconditions as reST."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _capture_as_text(capture: Callable[..., Any]) -> str:\n    if not icontract._represent._is_lambda(a_function=capture):\n        signature = inspect.signature(capture)\n        param_names = list(signature.parameters.keys())\n\n        return \"{}({})\".format(capture.__qualname__, \", \".join(param_names))\n\n    lines, lineno = inspect.findsource(capture)\n    filename = inspect.getsourcefile(capture)\n    decorator_inspection = icontract._represent.inspect_decorator(lines=lines, lineno=lineno, filename=filename)\n\n    call_node = decorator_inspection.node\n\n    capture_node = None  # type: Optional[ast.Lambda]\n\n    if len(call_node.args) > 0:\n        assert isinstance(call_node.args[0], ast.Lambda), \\\n            (\"Expected the first argument to the snapshot decorator to be a condition as lambda AST node, \"\n             \"but got: {}\").format(type(call_node.args[0]))\n\n        capture_node = call_node.args[0]\n\n    elif len(call_node.keywords) > 0:\n        for keyword in call_node.keywords:\n            if keyword.arg == \"capture\":\n                assert isinstance(keyword.value, ast.Lambda), \\\n                    \"Expected lambda node as value of the 'capture' argument to the decorator.\"\n\n                capture_node = keyword.value\n                break\n\n        assert capture_node is not None, \"Expected to find a keyword AST node with 'capture' arg, but found none\"\n    else:\n        raise AssertionError(\n            \"Expected a call AST node of a snapshot decorator to have either args or keywords, but got: {}\".format(\n                ast.dump(call_node)))\n\n    capture_text = decorator_inspection.atok.get_text(capture_node.body)\n\n    return capture_text", "response": "Convert the capture function into its text representation by parsing the source code of the decorator."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nformat snapshots as reST.", "response": "def _format_snapshots(snapshots: List[icontract._Snapshot], prefix: Optional[str] = None) -> List[str]:\n    \"\"\"\n    Format snapshots as reST.\n\n    :param snapshots: snapshots defined to capture the argument values of a function before the invocation\n    :param prefix: prefix to be prepended to ``:OLD:`` directive\n    :return: list of lines describing the snapshots\n    \"\"\"\n    if not snapshots:\n        return []\n\n    result = []  # type: List[str]\n\n    if prefix is not None:\n        result.append(\":{} OLD:\".format(prefix))\n    else:\n        result.append(\":OLD:\")\n\n    for snapshot in snapshots:\n        text = _capture_as_text(capture=snapshot.capture)\n        result.append(\"    * :code:`.{}` = :code:`{}`\".format(snapshot.name, text))\n\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _format_postconditions(postconditions: List[icontract._Contract], prefix: Optional[str] = None) -> List[str]:\n    if not postconditions:\n        return []\n\n    result = []  # type: List[str]\n\n    if prefix is not None:\n        result.append(\":{} ensures:\".format(prefix))\n    else:\n        result.append(\":ensures:\")\n\n    for postcondition in postconditions:\n        result.append(\"    * {}\".format(_format_contract(contract=postcondition)))\n\n    return result", "response": "Format postconditions as reST."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _format_invariants(invariants: List[icontract._Contract]) -> List[str]:\n    if not invariants:\n        return []\n\n    result = [\":establishes:\"]  # type: List[str]\n    for invariant in invariants:\n        result.append(\"    * {}\".format(_format_contract(contract=invariant)))\n\n    return result", "response": "Format invariants as reST."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncollect the preconditions snapshots and postconditions from a contract checker of a function.", "response": "def _preconditions_snapshots_postconditions(checker: Callable) -> _PrePostSnaps:\n    \"\"\"Collect the preconditions, snapshots and postconditions from a contract checker of a function.\"\"\"\n    preconditions = getattr(checker, \"__preconditions__\", [])  # type: List[List[icontract._Contract]]\n\n    assert all(isinstance(precondition_group, list) for precondition_group in preconditions)\n    assert (all(\n        isinstance(precondition, icontract._Contract) for precondition_group in preconditions\n        for precondition in precondition_group))\n\n    # Filter empty precondition groups (\"require else\" blocks)\n    preconditions = [group for group in preconditions if len(group) > 0]\n\n    snapshots = getattr(checker, \"__postcondition_snapshots__\", [])  # type: List[icontract._Snapshot]\n    assert all(isinstance(snap, icontract._Snapshot) for snap in snapshots)\n\n    postconditions = getattr(checker, \"__postconditions__\", [])  # type: List[icontract._Contract]\n\n    assert all(isinstance(postcondition, icontract._Contract) for postcondition in postconditions)\n\n    return _PrePostSnaps(preconditions=preconditions, snapshots=snapshots, postconditions=postconditions)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nformatting the preconditions and postconditions of a function given its checker decorator.", "response": "def _format_function_contracts(func: Callable, prefix: Optional[str] = None) -> List[str]:\n    \"\"\"\n    Format the preconditions and postconditions of a function given its checker decorator.\n\n    :param func: function whose contracts we are describing\n    :param prefix: prefix to be prepended to the contract directives such as ``get`` or ``set``\n    :return: list of lines\n    \"\"\"\n    checker = icontract._checkers.find_checker(func=func)\n    if checker is None:\n        return []\n\n    pps = _preconditions_snapshots_postconditions(checker=checker)\n\n    pre_block = _format_preconditions(preconditions=pps.preconditions, prefix=prefix)\n    old_block = _format_snapshots(snapshots=pps.snapshots, prefix=prefix)\n    post_block = _format_postconditions(postconditions=pps.postconditions, prefix=prefix)\n\n    return pre_block + old_block + post_block"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nformats the contracts as reST.", "response": "def _format_contracts(what: str, obj: Any) -> List[str]:\n    \"\"\"Format the contracts as reST.\"\"\"\n    if what in ['function', 'method', 'attribute']:\n        if what == 'attribute':\n            if not isinstance(obj, property):\n                return []\n\n            return _format_property_contracts(prop=obj)\n\n        if what in ['function', 'method']:\n            return _format_function_contracts(func=obj)\n\n        raise NotImplementedError(\"Unhandled what: {}\".format(what))\n\n    elif what == 'class':\n        invariants = getattr(obj, \"__invariants__\", [])  # type: List[icontract._Contract]\n        assert isinstance(invariants, list)\n        assert all(isinstance(inv, icontract._Contract) for inv in invariants)\n\n        return _format_invariants(invariants=invariants)\n\n    # Only properties, functions and classes have contracts.\n    return []"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreacting to a docstring event and append contracts to it.", "response": "def process_docstring(app, what, name, obj, options, lines):\n    \"\"\"React to a docstring event and append contracts to it.\"\"\"\n    # pylint: disable=unused-argument\n    # pylint: disable=too-many-arguments\n    lines.extend(_format_contracts(what=what, obj=obj))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _update_plugin(package_name):\n    '''\n    Update plugin (no user interface).\n\n    .. versionadded:: 0.19\n\n    Parameters\n    ----------\n    package_name : str, optional\n        Conda MicroDrop plugin package name, e.g., `microdrop.mr-box-plugin`.\n\n    Returns\n    -------\n    dict\n        If plugin was updated successfully, output will *at least* contain\n        items with the keys ``old_versions`` and ``new_versions``.\n\n        If no update was available, output will *at least* contain an item with\n        the key ``version`` and will **not** contain the keys ``old_versions``\n        and ``new_versions``.\n\n    Raises\n    ------\n    IOError\n        If Conda update server cannot be reached, e.g., if there is no network\n        connection available.\n\n    See also\n    --------\n    _update_plugin_ui\n    '''\n    try:\n        update_json_log = plugin_install(package_name)\n    except RuntimeError, exception:\n        if 'CondaHTTPError' in str(exception):\n            raise IOError('Error accessing update server.')\n        else:\n            raise\n\n    if update_json_log.get('success'):\n        if 'actions' in update_json_log:\n            # Plugin was updated successfully.\n            # Display prompt indicating previous version\n            # and new version.\n            actions = update_json_log['actions']\n            update_json_log['old_versions'] = actions.get('UNLINK', [])\n            update_json_log['new_versions'] = actions.get('LINK', [])\n        else:\n            # No update available.\n            version_dict = ch.package_version(package_name)\n            update_json_log.update(version_dict)\n        return update_json_log", "response": "Update the plugin with the given package name."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef build_wheel(ireq, sources, hashes=None, cache_dir=None):\n    kwargs = _prepare_wheel_building_kwargs(ireq)\n    finder = _get_finder(sources, cache_dir=cache_dir)\n\n    # Not for upgrade, hash not required. Hashes are not required here even\n    # when we provide them, because pip skips local wheel cache if we set it\n    # to True. Hashes are checked later if we need to download the file.\n    ireq.populate_link(finder, False, False)\n\n    # Ensure ireq.source_dir is set.\n    # This is intentionally set to build_dir, not src_dir. Comments from pip:\n    #   [...] if filesystem packages are not marked editable in a req, a non\n    #   deterministic error occurs when the script attempts to unpack the\n    #   build directory.\n    # Also see comments in `_prepare_wheel_building_kwargs()` -- If the ireq\n    # is editable, build_dir is actually src_dir, making the build in-place.\n    ireq.ensure_has_source_dir(kwargs[\"build_dir\"])\n\n    # Ensure the source is fetched. For wheels, it is enough to just download\n    # because we'll use them directly. For an sdist, we need to unpack so we\n    # can build it.\n    if not ireq.editable or not pip_shims.is_file_url(ireq.link):\n        if ireq.is_wheel:\n            only_download = True\n            download_dir = kwargs[\"wheel_download_dir\"]\n        else:\n            only_download = False\n            download_dir = kwargs[\"download_dir\"]\n        ireq.options[\"hashes\"] = _convert_hashes(hashes)\n        unpack_url(\n            ireq.link, ireq.source_dir, download_dir,\n            only_download=only_download, session=finder.session,\n            hashes=ireq.hashes(False), progress_bar=\"off\",\n        )\n\n    if ireq.is_wheel:\n        # If this is a wheel, use the downloaded thing.\n        output_dir = kwargs[\"wheel_download_dir\"]\n        wheel_path = os.path.join(output_dir, ireq.link.filename)\n    else:\n        # Othereise we need to build an ephemeral wheel.\n        wheel_path = _build_wheel(\n            ireq, vistir.path.create_tracked_tempdir(prefix=\"ephem\"),\n            finder, _get_wheel_cache(cache_dir=cache_dir), kwargs,\n        )\n        if wheel_path is None or not os.path.exists(wheel_path):\n            raise WheelBuildError\n    return distlib.wheel.Wheel(wheel_path)", "response": "Builds a wheel file for the InstallRequirement object."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the current process s effective UID for the current process.", "response": "def set_euid():\n    \"\"\"\n    Set settings.DROPLET_USER effective UID for the current process\n\n    This adds some security, but nothing magic, an attacker can still\n    gain root access, but at least we only elevate privileges when needed\n\n    See root context manager\n    \"\"\"\n    current = os.geteuid()\n    logger.debug(\"Current EUID is %s\" % current)\n\n    if settings.DROPLET_USER is None:\n        logger.info(\"Not changing EUID, DROPLET_USER is None\")\n        return\n\n    uid = int(pwd.getpwnam(settings.DROPLET_USER).pw_uid)\n    if current != uid:\n        try:\n            os.seteuid(uid)\n            logger.info(\"Set EUID to %s (%s)\" %\n                        (settings.DROPLET_USER, os.geteuid()))\n        except:\n            current_user = pwd.getpwuid(os.getuid()).pw_name\n            logger.error(\"Failed to set '%s' EUID, running as '%s'\" %\n                         (settings.DROPLET_USER, current_user))\n    else:\n        logger.debug(\"Didn't set EUID, it was already correct\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef drop_privileges():\n    uid = int(pwd.getpwnam(settings.DROPLET_USER).pw_uid)\n    os.setuid(uid)", "response": "Set the current process s uid to the current UID"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef root():\n    logger.debug('Entering ROOT mode')\n    old_euid = os.geteuid()\n    os.seteuid(0)\n    yield\n    os.seteuid(old_euid)\n    logger.debug('Exited ROOT mode')", "response": "Run the enclosed code as root"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nmerge the current log entry into the given group.", "response": "def merge_into_group(self, group):\n        \"\"\"\n        Redefines :meth:`~candv.base.Constant.merge_into_group` and adds\n        ``verbose_name`` and ``help_text`` attributes to the target group.\n        \"\"\"\n        super(VerboseMixin, self).merge_into_group(group)\n        group.verbose_name = self.verbose_name\n        group.help_text = self.help_text"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a dictionary of the verbose_name and help_text fields of the log entry.", "response": "def to_primitive(self, context=None):\n        \"\"\"\n        .. versionadded:: 1.3.0\n        \"\"\"\n        primitive = super(VerboseMixin, self).to_primitive(context)\n        to_text = lambda x: six.text_type(x) if x is not None else x\n        primitive.update({\n            'verbose_name': to_text(self.verbose_name),\n            'help_text': to_text(self.help_text),\n        })\n        return primitive"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef merge_into_group(self, group):\n        super(ValueConstant, self).merge_into_group(group)\n        group.value = self.value", "response": "Merge this value into the given group."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconvert the valueConstant to a dictionary.", "response": "def to_primitive(self, context=None):\n        \"\"\"\n        .. versionadded:: 1.3.0\n        \"\"\"\n        primitive = super(ValueConstant, self).to_primitive(context)\n        value = self.value\n\n        if hasattr(value, 'isoformat'):\n            value = value.isoformat()\n        elif callable(value):\n            value = value()\n\n        primitive['value'] = value\n        return primitive"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets a constant by its value.", "response": "def get_by_value(cls, value):\n        \"\"\"\n        Get constant by its value.\n\n        :param value: value of the constant to look for\n        :returns: first found constant with given value\n        :raises ValueError: if no constant in container has given value\n        \"\"\"\n        for constant in cls.iterconstants():\n            if constant.value == value:\n                return constant\n        raise ValueError(\n            \"Constant with value \\\"{0}\\\" is not present in \\\"{1}\\\"\"\n            .format(value, cls)\n        )"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets all constants which have given value.", "response": "def filter_by_value(cls, value):\n        \"\"\"\n        Get all constants which have given value.\n\n        :param value: value of the constants to look for\n        :returns: list of all found constants with given value\n        \"\"\"\n        constants = []\n        for constant in cls.iterconstants():\n            if constant.value == value:\n                constants.append(constant)\n        return constants"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_machine(self, key):\n        h = self.hash(key)\n\n        # edge case where we cycle past hash value of 1 and back to 0.\n        if h > self.hash_tuples[-1][2]:\n            return self.hash_tuples[0][0]\n\n        hash_values = map(lambda x: x[2], self.hash_tuples)\n        index = bisect.bisect_left(hash_values, h)\n        return self.hash_tuples[index][0]", "response": "Returns the number of the machine which key gets sent to."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef create_user(name,\n                username,\n                email,\n                password,\n                token_manager=None,\n                app_url=defaults.APP_URL):\n    \"\"\"\n    create a new user with the specified name, username email and password\n\n    \"\"\"\n    headers = token_manager.get_access_token_headers()\n    auth_url = environment.get_auth_url(app_url=app_url)\n    url = \"%s/api/v1/accounts\" % auth_url\n\n    payload = {\n        'name': name,\n        'username': username,\n        'email': email,\n        'password': password\n    }\n\n    response = requests.post(url,\n                             data=json.dumps(payload),\n                             headers=headers)\n\n    if response.status_code == 201:\n        return response.json()\n\n    else:\n        raise JutException('Error %s: %s' % (response.status_code, response.text))", "response": "create a new user with the specified name username email and password"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndeletes a user by its username", "response": "def delete_user(username,\n                token_manager=None,\n                app_url=defaults.APP_URL):\n    \"\"\"\n    delete a user by its account_id and with the access_token from that same\n    user as only a user may delete him/her-self\n\n    \"\"\"\n    account_id = get_account_id(username,\n                                token_manager=token_manager,\n                                app_url=app_url)\n\n    headers = token_manager.get_access_token_headers()\n    auth_url = environment.get_auth_url(app_url=app_url)\n    url = \"%s/api/v1/accounts/%s\" % (auth_url, account_id)\n    response = requests.delete(url, headers=headers)\n\n    if response.status_code == 204:\n        return response.text\n\n    else:\n        raise JutException('Error %s; %s' % (response.status_code, response.text))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_logged_in_account(token_manager=None,\n                          app_url=defaults.APP_URL):\n    \"\"\"\n    get the account details for logged in account of the auth token_manager\n\n    \"\"\"\n    return get_logged_in_account(token_manager=token_manager,\n                                 app_url=app_url)['id']", "response": "get the logged in account"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the logged in account details for credentials provided", "response": "def get_logged_in_account(token_manager=None,\n                          app_url=defaults.APP_URL):\n    \"\"\"\n    get the account details for credentials provided\n\n    \"\"\"\n    headers = token_manager.get_access_token_headers()\n    auth_url = environment.get_auth_url(app_url=app_url)\n    url = \"%s/api/v1/account\" % auth_url\n\n    response = requests.get(url,\n                            headers=headers)\n\n    if response.status_code == 200:\n        return response.json()\n\n    else:\n        raise JutException('Error %s; %s' % (response.status_code, response.text))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef user_exists(username,\n                token_manager=None,\n                app_url=defaults.APP_URL):\n    \"\"\"\n    check if the user exists with the specified username\n\n    \"\"\"\n    headers = token_manager.get_access_token_headers()\n    auth_url = environment.get_auth_url(app_url=app_url)\n    url = \"%s/api/v1/accounts?username=%s\" % (auth_url, username)\n    response = requests.get(url, headers=headers)\n\n    if response.status_code == 404:\n        return False\n    elif response.status_code == 200:\n        return True\n    else:\n        raise JutException('Error %s: %s' % (response.status_code, response.text))", "response": "check if the user exists with the specified username"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add_field(self, name, field):\n        # testing names \n        if name.startswith(\"_\"):\n            raise SchemaError(\"Field names cannot start with an underscore.\")\n        if \" \" in name:\n            raise SchemaError(\"Field names cannot contain spaces.\")\n        if name in self._fields:\n            raise SchemaError(\"Schema already has a field named '%s'\" % name)\n        if not isinstance(field, GenericType):\n            raise SchemaError(\"Wrong type in schema for field: %s, %s is not a GenericType\" % (name, field))\n        self._fields[name] = field", "response": "Add a named field to the schema."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets new values for the current object", "response": "def set(self, values):\n        \"\"\" set new values (values have to be iterable)\n        \"\"\"\n        if not hasattr(values, '__iter__') or isinstance(values, string_types):\n            raise SchemaError(\"Wrong value '%s' for field '%s'\" % (values, self._ftype))\n        # check data are valid before deleting the data\n        # prevents losing data if wrong type is passed\n        values = [self._ftype.validate(v) for v in values]\n        del self[:]\n        for v in values:\n            list.append(self, v)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding a data attribute.", "response": "def add_attribute(self, name, ftype):\n        \"\"\" Add a data attribute.\n        Note that the field type will be modified !\n        \n        :param name: name of the new attribute\n        :type name: str\n        :param ftype: type of the new attribute\n        :type ftype: subclass of :class:`.GenericType`\n        \"\"\"\n        if name in self._ftype.attrs:\n            raise SchemaError(\"VectorField has already attribute named '%s' (attrs: %s)\" % (name, list(self._ftype.attrs)))\n        # add the attr to the underlying GenericType\n        self._ftype.attrs[name] = ftype\n        # add the attr it self\n        self._attrs[name] = [DocField.FromType(ftype) for _ in range(len(self))]"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef clear_attributes(self):\n        self._attrs = {} # removes all attr\n        for name, attr_field in six.iteritems(self._ftype.attrs):\n            self._attrs[name] = []", "response": "Removes all attributes from the object."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a dictionary pre - seriasation of the field", "response": "def export(self):\n        \"\"\" returns a dictionary pre-seriasation of the field\n        \n        :hide:\n            >>> from pprint import pprint\n        \n        >>> from reliure.types import Text, Numeric\n        >>> doc = Doc(docnum='1')\n        >>> doc.terms = Text(multi=True, uniq=True, attrs={'tf': Numeric(default=1)}) \n        >>> doc.terms.add('chat')\n        >>> doc.terms.add('rat', tf=5)\n        >>> doc.terms.add('chien', tf=2)\n        >>> pprint(doc.terms.export())\n        {'keys': {'chat': 0, 'chien': 2, 'rat': 1}, 'tf': [1, 5, 2]}\n        \"\"\"\n        data = {}\n        data[\"keys\"] = dict( zip(self.keys(), range(len(self))) )\n        # each attr\n        for name in self._attrs.keys():\n            data[name] = self.get_attribute(name).export()\n        return data"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add(self, key, **kwargs):\n        if not self.has(key):\n            # check if kwargs are valid\n            for attr_name, value in six.iteritems(kwargs):\n                if attr_name not in self._ftype.attrs:\n                    raise ValueError(\"Invalid attribute name: '%s'\" % attr_name)\n                self._ftype.attrs[attr_name].validate(value)\n            # add the key\n            self._keys[key] = len(self._keys)\n            # append attributes\n            for name, attr_type in six.iteritems(self._ftype.attrs):\n                attr_field = DocField.FromType(attr_type)\n                if name in kwargs:\n                    attr_field.set(kwargs[name])\n                self._attrs[name].append(attr_field)", "response": "Add a key to the vector."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set(self, keys):\n        # clear keys and atributes\n        self._keys = OrderedDict()\n        self.clear_attributes()\n        _validate = self._ftype.validate\n        for key in keys:\n            self.add(_validate(key))", "response": "Set new keys.\n        Mind this will clear all attributes and keys before adding new keys\n        \n        >>> doc = Doc(docnum='1')\n        >>> doc.terms = Text(multi=True, attrs={'tf': Numeric(default=1)}) \n        >>> doc.terms.add('copmputer', tf=12)\n        >>> doc.terms.tf.values()\n        [12]\n        >>> doc.terms.set(['keyboard', 'mouse'])\n        >>> list(doc.terms)\n        ['keyboard', 'mouse']\n        >>> doc.terms.tf.values()\n        [1, 1]"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the value of a given attribute for a given key", "response": "def get_attr_value(self, key, attr):\n        \"\"\" returns the value of a given attribute for a given key\n        \n        >>> doc = Doc(docnum='1')\n        >>> doc.terms = Text(multi=True, uniq=True, attrs={'tf': Numeric()}) \n        >>> doc.terms.add('chat', tf=55)\n        >>> doc.terms.get_attr_value('chat', 'tf')\n        55\n        \"\"\"\n        idx = self._keys[key]\n        return self._attrs[attr][idx].get_value()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the value of an attribute for a given key", "response": "def set_attr_value(self, key, attr, value):\n        \"\"\" set the value of a given attribute for a given key\n        \"\"\"\n        idx = self._keys[key]\n        self._attrs[attr][idx].set(value)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add_field(self, name, ftype, docfield=None):\n        self.schema.add_field(name, ftype)\n        self[name] = docfield or DocField.FromType(ftype)", "response": "Add a field to the document and to the underlying schema"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the field with the given name.", "response": "def get_field(self, name):\n        \"\"\" Returns the :class:`DocField` field for the given name\n        \"\"\"\n        try:\n            return dict.__getitem__(self, name)\n        except KeyError as err:\n            raise SchemaError(\"'%s' is not a document field (existing attributes are: %s)\" % (err, list(self)))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_field(self, name, value, parse=False):\n        # explicit getitem needed for ValueField\n        try: \n            item = dict.__getitem__(self, name)\n            item.set( item.parse(value) if parse else value  )\n        except ValidationError as err:\n            raise FieldValidationError(name, value, list(err))", "response": "Set the value of a field in the value store"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a dictionary representation of the document", "response": "def export(self, exclude=[]):\n        \"\"\" returns a dictionary representation of the document\n        \"\"\"\n        fields = ( (key, self.get_field(key)) for key in self.schema\n            if not key.startswith(\"_\") and key not in exclude )\n        \n        doc = {name: field.export() for name, field in fields}\n        return doc"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef init_dirs(rootdir_or_loader, outputpath, saveto_dir='data',\n              auximages_dir='auximages', prefix='crd'):\n    \"\"\"Initialize the directiories.\n\n    Inputs:\n        rootdir_or_loader: depends on the type:\n            str:\n                the root directory of the SAXSCtrl/CCT\n                software, i.e. where the subfolders ``eval2d``, ``param``,\n                ``images``, ``mask`` etc. reside.\n            sastool.classes2.Loader instance:\n                a fully initialized loader, which will be used to acquire\n                headers and exposures.\n            list:\n                a list of sastool.classes2.Loader instances, which will\n                be used to open headers and exposures. When opening something,\n                always the first item will be tried first, and if it fails with\n                FileNotFoundError, the second, third, etc. will be tried until\n                either the file can be opened or the last one fails.\n\n        outputpath: the directory where the produced files are\n            written. This is usually the working directory of\n            the IPython notebook.\n\n        saveto_dir: the subdirectory where averaged, united,\n            subtracted etc. datasets are written.\n\n        auximages_dir: the subdirectory where automatically produced\n            images reside.\n\n    Remarks:\n        If a single root directory is given, a list of four loaders will be\n        constructed in this order: CCT (processed), CCT (raw), SAXSCtrl (processed),\n        SAXSCtrl (raw). Raw and processed loaders are handled separately.\n    \"\"\"\n    ip = get_ipython()\n    if isinstance(rootdir_or_loader, str):\n        print(\"Initializing loaders for SAXSCtrl and CCT.\", flush=True)\n        ip.user_ns['_loaders'] = [\n            credo_cct.Loader(rootdir_or_loader, processed=True, exposureclass=prefix),\n            credo_saxsctrl.Loader(rootdir_or_loader, processed=True, exposureclass=prefix),\n            credo_cct.Loader(rootdir_or_loader, processed=False, exposureclass=prefix),\n            credo_saxsctrl.Loader(rootdir_or_loader, processed=False, exposureclass=prefix),\n        ]\n        print(\"Loaders initialized.\", flush=True)\n    elif isinstance(rootdir_or_loader, Loader):\n        ip.user_ns['_loaders'] = [rootdir_or_loader]\n    elif isinstance(rootdir_or_loader, list) and all([isinstance(l, Loader) for l in rootdir_or_loader]):\n        ip.user_ns['_loaders'] = rootdir_or_loader[:]\n    else:\n        raise TypeError(rootdir_or_loader)\n    if not os.path.isdir(outputpath):\n        os.makedirs(outputpath)\n    print(\"Output files will be written to:\", outputpath)\n    os.chdir(outputpath)\n    ip.user_ns['outputpath'] = outputpath\n    if not os.path.isdir(os.path.join(ip.user_ns['outputpath'], saveto_dir)):\n        os.mkdir(os.path.join(ip.user_ns['outputpath'], saveto_dir))\n    if not os.path.isdir(os.path.join(ip.user_ns['outputpath'], auximages_dir)):\n        os.mkdir(os.path.join(ip.user_ns['outputpath'], auximages_dir))\n    ip.user_ns['auximages_dir'] = os.path.join(outputpath, auximages_dir)\n    ip.user_ns['saveto_dir'] = os.path.join(outputpath, saveto_dir)\n    ip.user_ns['saveto_dir_rel'] = saveto_dir\n    ip.user_ns['auximages_dir_rel'] = auximages_dir\n    ip.user_ns['crd_prefix']=prefix\n    set_length_units('nm')", "response": "Initialize the directiories of the CCT and SAXSCtrl modules."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef convert(self, text):\n\n    url = self.API_URL\n    encoding = self.ENCODING\n    headers = self.HEADERS\n\n    data = urlencode({\n      'farsi': str(text)\n      }).encode(encoding)\n\n    request = Request(url=url,data=data,headers=headers)\n\n    response = urlopen(request)\n\n    result = response.read()\n\n    response_encoding = response.headers['Content-Type']\n    response_encoding = response_encoding[response_encoding.find('=')+1:]\n    result = result.decode(response_encoding)\n\n    # a simple fix\n    result = result.replace('\\ufeff','')[:-1]\n\n    return result", "response": "converts a Finglish to Persian."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_pg_core(connection_string, *, cursor_factory=None, edit_connection=None):\n  import psycopg2 as pq\n  from psycopg2.extras import NamedTupleCursor\n\n  def opener():\n    \"\"\"Opens a single PostgreSQL connection with the scope-captured connection string.\"\"\"\n    cn = pq.connect(connection_string)\n    cn.cursor_factory = cursor_factory or NamedTupleCursor\n    if edit_connection:\n      edit_connection(cn)\n    return cn\n\n  return InjectedDataAccessCore(\n    opener,\n    default_connection_closer,\n    (\"%({0})s\", \"%s\", \"{0}::{1}\"),\n    empty_params=None,\n    supports_timezones=True,\n    supports_returning_syntax=True,\n    get_autocommit=get_pg_autocommit,\n    set_autocommit=set_pg_autocommit)", "response": "Creates a simple PostgreSQL core. Requires the psycopg2 library. Requires the psycopg2 library."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate a pooled PostgreSQL core. Requires the psycopg2 library.", "response": "def get_pooled_pg_core(connection_string, pool_size=None, *, cursor_factory=None,\n                       edit_connection=None, threaded=True):\n  \"\"\"Creates a pooled PostgreSQL core. Requires the psycopg2 library.\n\n  :pool_size: must be a 2-tuple in the form (min_connections, max_connections).\n  \"\"\"\n  from psycopg2.extras import NamedTupleCursor\n  from psycopg2.pool import ThreadedConnectionPool as TPool, SimpleConnectionPool as SPool\n  if not pool_size:\n    pool_size = (5, 10)\n  if threaded:\n    pool = TPool(pool_size[0], pool_size[1], connection_string)\n  else:\n    pool = SPool(pool_size[0], pool_size[1], connection_string)\n\n  def opener():\n    \"\"\"Gets a PostgreSQL connection from the scope-captured connection pool.\"\"\"\n    cn = pool.getconn()\n    cn.cursor_factory = cursor_factory or NamedTupleCursor\n    if edit_connection:\n      edit_connection(cn)\n    return cn\n\n  def closer(connection):\n    \"\"\"Returns a connection to the scope-captured connection pool.\"\"\"\n    pool.putconn(connection)\n\n  return InjectedDataAccessCore(\n    opener,\n    closer,\n    (\"%({0})s\", \"%s\", \"{0}::{1}\"),\n    empty_params=None,\n    supports_timezones=True,\n    supports_returning_syntax=True,\n    get_autocommit=get_pg_autocommit,\n    set_autocommit=set_pg_autocommit)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_sqlite_autocommit(cn, autocommit):\n  if isinstance(autocommit, bool):\n    cn.isolation_level = None if autocommit else \"\"\n  else:\n    cn.isolation_level = autocommit", "response": "SQLite autocommit setter for core."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates a simple SQLite3 core.", "response": "def get_sqlite_core(connection_string, *, cursor_factory=None, edit_connection=None):\n  \"\"\"Creates a simple SQLite3 core.\"\"\"\n  import sqlite3 as sqlite\n\n  def opener():\n    \"\"\"Opens a single connection with the scope-captured connection string.\"\"\"\n    cn = sqlite.connect(connection_string)\n    if cursor_factory:\n      cn.row_factory = cursor_factory\n    if edit_connection:\n      edit_connection(cn)\n    return cn\n\n  return InjectedDataAccessCore(\n    opener,\n    default_connection_closer, (\":{0}\", \"?\", SQL_CAST),\n    empty_params=[],\n    supports_timezones=True,\n    supports_returning_syntax=False,\n    get_autocommit=get_sqlite_autocommit,\n    set_autocommit=set_sqlite_autocommit)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_mysql_core(connection_args, *, cursor_factory=None, edit_connection=None):\n  import pymysql\n\n  def opener():\n    \"\"\"Opens a single connection with the scope-captured connection string.\"\"\"\n    cn = pymysql.connect(**connection_args)\n    if cursor_factory:\n      cn.cursorclass = cursor_factory\n    if edit_connection:\n      edit_connection(cn)\n    return cn\n\n  return InjectedDataAccessCore(\n    opener,\n    default_connection_closer,\n    (\"%({0})s\", \"%s\", SQL_CAST),\n    empty_params=None,\n    supports_timezones=False,\n    supports_returning_syntax=False,\n    get_autocommit=get_mysql_autocommit,\n    set_autocommit=set_mysql_autocommit)", "response": "Creates a simple MySQL core. Requires the pymysql library."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncloses the connection using the closer method passed to the constructor.", "response": "def close(self, connection, *, commit=True):\n    \"\"\"Close the connection using the closer method passed to the constructor.\"\"\"\n    if commit:\n      connection.commit()\n    else:\n      connection.rollback()\n    self.closer(connection)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nbuilding a structured dataset out of a cities1000. txt file", "response": "def build_db():\n    \"\"\"Get a structured dataset out of\n       http://download.geonames.org/export/dump/cities1000.txt\n    \"\"\"\n    if not os.path.exists(MISC_PATH):\n        os.makedirs(MISC_PATH)\n    cities_path = os.path.join(MISC_PATH, \"cities1000.txt\")\n    cities_msgpack = os.path.join(MISC_PATH, \"cities1000.bin\")\n    if not os.path.isfile(cities_path):\n        download()\n    if not os.path.isfile(cities_msgpack):\n        with open(cities_path) as f:\n            lines = f.readlines()\n\n        db = []\n        for i, line in enumerate(lines):\n            l = line.strip().split('\\t')\n            db.append({'latitude': float(l[4]),\n                       'longitude': float(l[5]),\n                       'linenr': i})\n        packed = msgpack.packb(db, use_bin_type=True)\n        with open(cities_msgpack, 'wb') as f:\n            f.write(packed)\n    else:\n        with open(cities_msgpack, 'rb') as f:\n            content = f.read()\n        db = msgpack.unpackb(content)\n    return db"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the cartesian coordinates of the metres in the chemical system", "response": "def get_cartesian(lat, lon):\n    \"\"\"\n    the x-axis goes through long,lat (0,0), so longitude 0 meets the equator;\n    the y-axis goes through (0,90);\n    and the z-axis goes through the poles.\n\n    In other words:\n    * (0, 0, 0) is the center of earth\n    * (0, 0, R) is the north pole\n    * (0, 0, -R) is the south pole\n    * (R, 0, 0) is somewhere in africa?\n\n    :param lat: latitude in radians\n    :param lon: longitude in radians\n    \"\"\"\n    R = 6371000.0  # metres\n    x = R * math.cos(lat) * math.cos(lon)\n    y = R * math.cos(lat) * math.sin(lon)\n    z = R * math.sin(lat)\n    return [x, y, z]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef find_closest(db, pos):\n    def get_dist(d1, d2):\n        \"\"\"Get distance between d1 and d2 in meters.\"\"\"\n        lat1, lon1 = d1['latitude'], d1['longitude']\n        lat2, lon2 = d2['latitude'], d2['longitude']\n        R = 6371000.0  # metres\n        phi1 = math.radians(lat1)\n        phi2 = math.radians(lat2)\n        delta_phi = math.radians(lat2-lat1)\n        delta_delta = math.radians(lon2-lon1)\n\n        a = math.sin(delta_phi/2) * math.sin(delta_phi/2) + \\\n            math.cos(phi1) * math.cos(phi2) * \\\n            math.sin(delta_delta/2) * math.sin(delta_delta/2)\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))\n\n        d = R * c\n        return d\n    closest_dataset, closest_dist = db[0], get_dist(pos, db[0])\n    for dataset in db:\n        dist = get_dist(pos, dataset)\n        if dist < closest_dist:\n            closest_dataset = dataset\n            closest_dist = dist\n    return closest_dataset, closest_dist", "response": "Find the closest point in db to pos."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_parser():\n    from argparse import ArgumentParser, ArgumentDefaultsHelpFormatter\n    from argparse import ArgumentTypeError\n\n    def latitude(x):\n        x = float(x)\n        if x < -90.0 or x > 90.0:\n            raise ArgumentTypeError(\"%r not in range [-90.0, 90.0]\" % (x,))\n        return x\n\n    def longitude(x):\n        x = float(x)\n        if x < -180.0 or x > 180.0:\n            raise ArgumentTypeError(\"%r not in range [-180.0, 180.0]\" % (x,))\n        return x\n\n    parser = ArgumentParser(description=__doc__,\n                            formatter_class=ArgumentDefaultsHelpFormatter)\n    parser.add_argument(\"--lat\",\n                        dest=\"latitude\",\n                        required=True,\n                        type=latitude,\n                        help=\"Latitude (in -90, 90)\")\n    parser.add_argument(\"--lng\",\n                        dest=\"longitude\",\n                        required=True,\n                        type=longitude,\n                        help=\"Longitude (in -180, 180)\")\n    version = geocodertools.__version__\n    parser.add_argument('--version',\n                        action='version',\n                        version=('geocodertools %s' % str(version)))\n    return parser", "response": "Return the parser object for this script."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef main(pos, bobj=None):\n    city, distance = get_city(pos, bobj)\n    city = get_city_from_file(city['linenr'])\n    print(\"The city '%s' is about %0.2fkm away from your location %s\" %\n          (city['asciiname'], distance/1000.0, str(pos)))\n    for key, value in sorted(city.items()):\n        print(\"%s: %s\" % (key, value))", "response": "A function to get the city information from a location."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get(self, pos):\n        latitude = int(round(pos['latitude']))\n        search_set = self.bins[latitude]\n        i = 1\n        if latitude - i >= -90:\n            search_set += self.bins[latitude-i]\n        if latitude + i <= 90:\n            search_set += self.bins[latitude+i]\n        while len(search_set) == 0 and i <= 200:\n            if latitude - i >= -90:\n                search_set += self.bins[latitude-i]\n            if latitude + i <= 90:\n                search_set += self.bins[latitude+i]\n            i += 1\n        return find_closest(search_set, pos)", "response": "Get the closest dataset."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef from_urlencode(self, data, options=None):\n        qs = dict((k, v if len(v) > 1 else v[0])\n                  for k, v in urlparse.parse_qs(data).iteritems())\n        return qs", "response": "handles basic formencoded url posts"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting html species info", "response": "def _get_electricity_info_html( apart_id, meter_room):\n        \"\"\"get html\n\n        :param apart_id: \u680b\u6570\n        :param meter_room: \u5bbf\u820d\u53f7\n        \"\"\"\n        if apart.get(apart_id) is None:\n            raise KeyError('not support the apart_id= ' + apart_id)\n        post_data = {\n            'action': 'search',\n            'apartID': apart.get(apart_id),\n            'meter_room': apart_id + meter_room\n        }\n        r = requests.post('http://202.192.252.140/index.asp', data=post_data)\n        return r.content.decode(_.get_charset(r.content))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget electricity info :param apart_id: \u680b\u6570 :param meter_room: \u5bbf\u820d\u53f7", "response": "def get_electricity_info(self, apart_id, meter_room):\n        \"\"\"get electricity info\n\n            :param apart_id: \u680b\u6570\n            :param meter_room: \u5bbf\u820d\u53f7\n        \"\"\"\n        apart_id = str(apart_id)\n        meter_room = str(meter_room)\n        try:\n            content = LifeService._get_electricity_info_html(apart_id, meter_room)\n        except KeyError as e:\n            _.d(e.message)\n            result = {\n                'response': None\n            }\n            return _.to_json_string(result)\n        soup = BeautifulSoup(content)\n        tags = soup.find_all(name='span', class_='STYLE7')\n        result = {\n            'response': {\n                'apart': _.trim(tags[0].string),\n                'apart_id': _.trim(tags[1].string),\n                'used': _.trim(tags[2].string),\n                'left': _.trim(tags[3].string),\n                'update_time': _.trim(tags[4].string)\n            }\n        }\n        return _.to_json_string(result)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_channels(self, channels):\n        for key in channels:\n            self.set(key, channels[key])", "response": "Sets the state of multiple channels in one operation."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nfind all PDF files in the specified directory.", "response": "def _get_pdf_filenames_at(source_directory):\n    \"\"\"Find all PDF files in the specified directory.\n\n    Args:\n        source_directory (str): The source directory.\n\n    Returns:\n        list(str): Filepaths to all PDF files in the specified directory.\n\n    Raises:\n        ValueError\n    \"\"\"\n    if not os.path.isdir(source_directory):\n        raise ValueError(\"%s is not a directory!\" % source_directory)\n    return [os.path.join(source_directory, filename)\n            for filename in os.listdir(source_directory)\n            if filename.endswith(PDF_EXTENSION)]"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncompressing a single PDF file.", "response": "def compress_pdf(filepath, output_path, ghostscript_binary):\n    \"\"\"Compress a single PDF file.\n\n    Args:\n        filepath (str): Path to the PDF file.\n        output_path (str): Output path.\n        ghostscript_binary (str): Name/alias of the Ghostscript binary.\n\n    Raises:\n        ValueError\n        FileNotFoundError\n    \"\"\"\n    if not filepath.endswith(PDF_EXTENSION):\n        raise ValueError(\"Filename must end with .pdf!\\n%s does not.\" % filepath)\n    try:\n        file_size = os.stat(filepath).st_size\n        if file_size < FILE_SIZE_LOWER_LIMIT:\n            LOGGER.info(NOT_COMPRESSING.format(filepath, file_size, FILE_SIZE_LOWER_LIMIT))\n            process = subprocess.Popen(['cp', filepath, output_path])\n        else:\n            LOGGER.info(COMPRESSING.format(filepath))\n            process = subprocess.Popen(\n                [ghostscript_binary, \"-sDEVICE=pdfwrite\",\n                 \"-dCompatabilityLevel=1.4\", \"-dPDFSETTINGS=/ebook\",\n                 \"-dNOPAUSE\", \"-dQUIET\", \"-dBATCH\",\n                 \"-sOutputFile=%s\" % output_path, filepath]\n                )\n    except FileNotFoundError:\n        msg = GS_NOT_INSTALLED.format(ghostscript_binary)\n        raise FileNotFoundError(msg)\n    process.communicate()\n    LOGGER.info(FILE_DONE.format(output_path))"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncompresses all PDF files in the current directory and place the output in the given output directory. This is a generator function that first yields the amount of files to be compressed, and then yields the output path of each file. Args: source_directory (str): Filepath to the source directory. output_directory (str): Filepath to the output directory. ghostscript_binary (str): Name of the Ghostscript binary. Returns: list(str): paths to outputs.", "response": "def compress_multiple_pdfs(source_directory, output_directory, ghostscript_binary):\n    \"\"\"Compress all PDF files in the current directory and place the output in the\n    given output directory. This is a generator function that first yields the amount\n    of files to be compressed, and then yields the output path of each file.\n\n    Args:\n        source_directory (str): Filepath to the source directory.\n        output_directory (str): Filepath to the output directory.\n        ghostscript_binary (str): Name of the Ghostscript binary.\n\n    Returns:\n        list(str): paths to outputs.\n    \"\"\"\n    source_paths = _get_pdf_filenames_at(source_directory)\n    yield len(source_paths)\n    for source_path in source_paths:\n        output = os.path.join(output_directory, os.path.basename(source_path))\n        compress_pdf(source_path, output, ghostscript_binary)\n        yield output"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncalling automatically by container after class construction.", "response": "def _post_init(self, name, container=None):\n        \"\"\"\n        Called automatically by container after container's class construction.\n        \"\"\"\n        self.name = name\n        self.container = container"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef to_primitive(self, context=None):\n        return {\n            'name': self.name,\n            'items': [x.to_primitive(context) for x in self.iterconstants()]\n        }", "response": "Converts the object to a primitive dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a filename that s free on the target storage system and also available for new content to be written to.", "response": "def get_available_name(self, name):\n        \"\"\"Returns a filename that's free on the target storage system, and\n        available for new content to be written to.\n\n        Found at http://djangosnippets.org/snippets/976/\n\n        This file storage solves overwrite on upload problem. Another\n        proposed solution was to override the save method on the model\n        like so (from https://code.djangoproject.com/ticket/11663):\n\n        def save(self, *args, **kwargs):\n            try:\n                this = MyModelName.objects.get(id=self.id)\n                if this.MyImageFieldName != self.MyImageFieldName:\n                    this.MyImageFieldName.delete()\n            except: pass\n            super(MyModelName, self).save(*args, **kwargs)\n        \"\"\"\n        # If the filename already exists, remove it as if it was a true file system\n        if self.exists(name):\n            os.remove(os.path.join(settings.MEDIA_ROOT, name))\n        return name"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning specific resource. :param str rscpath: resource path. :param Logger logger: logger to use. :param bool error: raise internal error if True (False by default). :param bool force: create the resource even if rscpath does not exist. :return: specific configuration resource.", "response": "def pathresource(self, rscpath=None, logger=None):\n        \"\"\"Returns specific resource.\n\n        :param str rscpath: resource path.\n        :param Logger logger: logger to use.\n        :param bool error: raise internal error if True (False by default).\n        :param bool force: create the resource even if rscpath does not exist.\n        :return: specific configuration resource.\n        \"\"\"\n\n        result = None\n\n        try:\n            result = self._pathresource(rscpath=rscpath)\n\n        except Exception as ex:\n            if logger is not None:\n                msg = 'Error while getting resource from {0}.'.format(rscpath)\n                full_msg = '{0} {1}: {2}'.format(msg, ex, format_exc())\n                logger.error(full_msg)\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nparses a configuration path with input conf and returns a Configuration object.", "response": "def getconf(self, path, conf=None, logger=None):\n        \"\"\"Parse a configuration path with input conf and returns\n        parameters by param name.\n\n        :param str path: conf resource path to parse and from get parameters.\n        :param Configuration conf: conf to fill with path values and\n            conf param names.\n        :param Logger logger: logger to use in order to trace\n            information/error.\n        :rtype: Configuration\n        \"\"\"\n\n        result = conf\n\n        pathconf = None\n\n        rscpaths = self.rscpaths(path=path)\n\n        for rscpath in rscpaths:\n\n            pathconf = self._getconf(rscpath=rscpath, logger=logger, conf=conf)\n\n            if pathconf is not None:\n\n                if result is None:\n                    result = pathconf\n\n                else:\n                    result.update(pathconf)\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef setconf(self, conf, rscpath, logger=None):\n\n        resource = self.pathresource(rscpath=rscpath, logger=logger)\n\n        if resource is None:\n            resource = self.resource()\n\n        try:\n            self._setconf(conf=conf, resource=resource, rscpath=rscpath)\n\n        except Exception as ex:\n            if logger is not None:\n                msg = 'Error while setting conf to {0}.'.format(rscpath)\n                full_msg = '{0} {1}: {2}'.format(msg, ex, format_exc())\n                logger.error(full_msg)\n                reraise(self.Error, self.Error(msg))", "response": "Set input conf in input path."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget specific configuration from one driver path.", "response": "def _getconf(self, rscpath, logger=None, conf=None):\n        \"\"\"Get specific conf from one driver path.\n\n        :param str rscpath: resource path.\n        :param Logger logger: logger to use.\n        \"\"\"\n\n        result = None\n\n        resource = self.pathresource(rscpath=rscpath, logger=logger)\n\n        if resource is not None:\n\n            for cname in self._cnames(resource=resource):\n\n                category = Category(name=cname)\n\n                if result is None:\n                    result = Configuration()\n\n                result += category\n\n                for param in self._params(resource=resource, cname=cname):\n\n                    if conf is not None:\n                        confparam = None\n\n                        if cname in conf and param.name in conf[cname]:\n                            confparam = conf[cname][param.name]\n\n                        else:\n                            confparam = conf.param(pname=param.name)\n\n                        if confparam is not None:\n                            svalue = param.svalue\n\n                            param.update(confparam)\n\n                            if svalue is not None:\n                                param.svalue = svalue\n                                param.resolve()\n\n                    category += param\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef save(self, delete_zip_import=True, *args, **kwargs):\n        super(BaseGallery, self).save(*args, **kwargs)\n        if self.zip_import:\n            zip_file = ZipFile(self.zip_import)\n            for name in zip_file.namelist():\n                data = zip_file.read(name)\n                try:\n                    from PIL import Image\n                    image = Image.open(BytesIO(data))\n                    image.load()\n                    image = Image.open(BytesIO(data))\n                    image.verify()\n                except ImportError:\n                    pass\n                except:\n                    continue\n                name = os.path.split(name)[1]\n\n                # In python3, name is a string. Convert it to bytes.\n                if not isinstance(name, bytes):\n                    try:\n                        name = name.encode('cp437')\n                    except UnicodeEncodeError:\n                        # File name includes characters that aren't in cp437,\n                        # which isn't supported by most zip tooling. They will\n                        # not appear correctly.\n                        tempname = name\n\n                # Decode byte-name.\n                if isinstance(name, bytes):\n                    encoding = charsetdetect(name)['encoding']\n                    tempname = name.decode(encoding)\n\n                # A gallery with a slug of \"/\" tries to extract files\n                # to / on disk; see os.path.join docs.\n                slug = self.slug if self.slug != \"/\" else \"\"\n                path = os.path.join(GALLERIES_UPLOAD_DIR, slug, tempname)\n                try:\n                    saved_path = default_storage.save(path, ContentFile(data))\n                except UnicodeEncodeError:\n                    from warnings import warn\n                    warn(\"A file was saved that contains unicode \"\n                         \"characters in its path, but somehow the current \"\n                         \"locale does not support utf-8. You may need to set \"\n                         \"'LC_ALL' to a correct value, eg: 'en_US.UTF-8'.\")\n                    # The native() call is needed here around str because\n                    # os.path.join() in Python 2.x (in posixpath.py)\n                    # mixes byte-strings with unicode strings without\n                    # explicit conversion, which raises a TypeError as it\n                    # would on Python 3.\n                    path = os.path.join(GALLERIES_UPLOAD_DIR, slug,\n                                        native(str(name, errors=\"ignore\")))\n                    saved_path = default_storage.save(path, ContentFile(data))\n                self.images.create(file=saved_path)\n            if delete_zip_import:\n                zip_file.close()\n                self.zip_import.delete(save=True)", "response": "Save the gallery to the gallery s file store."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nconvert seconds to Days Hours Minutes Seconds", "response": "def seconds_to_DHMS(seconds, as_str=True):\n    \"\"\"converts seconds to Days, Hours, Minutes, Seconds\n\n    :param int seconds: number of seconds\n    :param bool as_string: to return a formated string defaults to True\n    :returns: a formated string if as_str else a dictionary\n    :Example:\n        >>> seconds_to_DHMS(60*60*24)\n        001-00:00:00\n        >>> seconds_to_DHMS(60*60*24, False)\n        {'hours': 0, 'seconds': 0, 'minutes': 0, 'days': 1}\n    \"\"\"\n    d = DotDot()\n    d.days = int(seconds // (3600 * 24))\n    d.hours = int((seconds // 3600) % 24)\n    d.minutes = int((seconds // 60) % 60)\n    d.seconds = int(seconds % 60)\n    return FMT_DHMS_DICT.format(**d) if as_str else d"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a new dictionary with encoded values useful for encoding http queries", "response": "def dict_encode(in_dict):\n    \"\"\"returns a new dictionary with encoded values useful for encoding http queries (python < 3)\"\"\"\n    if _IS_PY2:\n        out_dict = {}\n        for k, v in list(in_dict.items()):\n            if isinstance(v, unicode):\n                v = v.encode('utf8')\n            elif isinstance(v, str):\n                # Must be encoded in UTF-8\n                v.decode('utf8')\n            out_dict[k] = v\n        return out_dict\n    else:\n        raise NotImplementedError"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef relations_dict(rel_lst):\n    dc = {}\n    for c in rel_lst:\n        for i in c:\n            for k in c:\n                dc.setdefault(i, [])\n                dc[i].append(k)\n    do = {}\n    for k in list(dc.keys()):\n        if dc[k]:\n            vl = list(set(dc[k]))   # remove duplicates\n            vl.remove(k)\n            do[k] = vl\n    return do", "response": "constructs a dictionary that represents amphidromus relations between objects\n    and a list of amphidromus relations between objects\n   "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a list of lists of any slice -able object each of max lentgh n", "response": "def chunks(sliceable, n):\n    \"\"\"\n    returns a list of lists of any slice-able object each of max lentgh n\n\n    :Parameters:\n        -sliceable: (string|list|tuple) any sliceable object\n        - n max elements of ech chunk\n    :Example:\n        >>> chunksn([1,2,3,4,5,6,7,8,9,'x'], 4)\n        [[1, 2, 3, 4], [5, 6, 7, 8], [9, 'x']]\n        >>> chunksn('123456789X', 3)\n        ['123', '456', '789', 'X']\n\n    \"\"\"\n    return [sliceable[i:i+n] for i in range(0, len(sliceable), n)]"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a string with max n characters", "response": "def chunks_str(str, n, separator=\"\\n\", fill_blanks_last=True):\n    \"\"\"returns lines with max n characters\n\n    :Example:\n        >>> print (chunks_str('123456X', 3))\n        123\n        456\n        X\n    \"\"\"\n    return separator.join(chunks(str, n))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef class_name_str(obj, skip_parent=False):\n    rt = str(type(obj)).split(\" \")[1][1:-2]\n    if skip_parent:\n        rt = rt.split(\".\")[-1]\n    return rt", "response": "returns object s class name as string"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a string representing the path to the root element separated by separator", "response": "def path(self, separator=\"/\"):\n        \"\"\":returns: a string representing the path to root element separated by separator\"\"\"\n        rt = \"\"\n        for i in reversed(self):\n            rt = \"{}{}{}\".format(rt, i.name, separator)\n        return rt[:-1]"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef root_and_path(self):\n        rt = []\n        curAttr = self\n        while isinstance(curAttr.parent, AdHocTree):\n            rt.append(curAttr.name)\n            curAttr = curAttr.parent\n        rt.reverse()\n        return (curAttr.parent, rt)", "response": "returns a tuple containing the parent and the path of the root element of the tree."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef value_name(cls, value):\n        for k, v in list(cls.__dict__.items()):\n            if v == value:\n                return k\n        return value", "response": "Returns the name of a value in a class"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _is_visible(cls, property_name):\n        if isinstance(property_name, list):\n            return [cls._is_visible(p) for p in property_name]\n        if property_name.startswith('__') and property_name.endswith('__'):\n            return False\n        return property_name.startswith(cls.STARTS_WITH) and property_name.endswith(cls.ENDS_WITH)", "response": "private method to check visible object property to be visible"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nclass method to create object of a given class", "response": "def _from_class(cls, class_name, module_name=None, *args, **kwargs):\n        \"\"\" class method to create object of a given class \"\"\"\n        def _get_module(module_name):\n            names = module_name.split(\".\")\n            module = __import__(names[0])\n            for i in xrange(1, len(names)):\n                module = getattr(module, names[i])\n            return module\n\n        if module_name:\n            # module = globals()[module_name]\n            # module = __import__(module_name)\n            module = _get_module(module_name)\n            class_ = getattr(module, class_name)\n        else:\n            class_ = globals()[class_name]\n\n        if not issubclass(class_, PersistentObject):\n            t = class_.__name__, PersistentObject.__name__\n            raise TypeError, 'Requested object type %s must be subtype of %s ' % t\n\n        # workaround to mimic FactoryType to work well with FactoryObject.\n        name = str(args[0]) if args else cls.__name__\n        name = kwargs['name'] if 'name' in kwargs else name\n        if hasattr(cls, 'get'):\n            instance = cls.get(name)\n            if instance:\n                return instance\n\n        instance = class_.__new__(class_, *args, **kwargs)\n        instance.__init__(*args, **kwargs)\n        return instance"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef from_serializable(cls, object_dict):\n\n        key_class = cls._from_visible(cls.STARTS_WITH + 'class' + cls.ENDS_WITH)\n        key_module = cls._from_visible(cls.STARTS_WITH + 'module' + cls.ENDS_WITH)\n\n        obj_class = object_dict.pop(key_class)\n        obj_module = object_dict.pop(key_module) if key_module in object_dict else None\n\n        obj = cls._from_class(obj_class, obj_module)\n        obj.modify_object(object_dict)\n        return obj", "response": "core class method to create visible objects from a dictionary"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef modify_object(self, property_name, property_value_variant=None):\n        if type(property_name) is dict:\n            property_value_variant = property_name.values()\n            property_name = property_name.keys()\n\n        if isinstance(property_name, str):\n            property_name, property_value_variant = [property_name], [property_value_variant]\n        assert len(property_name) == len(property_value_variant)\n\n        # convert names into visible\n        property_name = self.__class__._to_visible(property_name)\n\n        # loop over properties to set\n        for n, v in zip(property_name, property_value_variant):\n            self._modify_property(n.encode('ascii','ignore'), v)\n\n        # rebuild object in order to maintain consistency\n        self._rebuild_object()\n        return self", "response": "api visible method for modifying visible object properties\n\n        :param property_name: property name\n        :type property_name: string, list or dict\n        :param property_value_variant: property value, must be `None` if property_name is of type `dict`\n        :type property_value_variant: various or None\n        :return: modified object\n        :rtype: unicum.lfojbect.VisibleObject"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _is_modified_property(self, prop):\n        if type(prop) is str:\n            return prop in self._modified_members\n        return False", "response": "Returns True if the given property is in the modifed members\n       "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef wrap_log_handler(handler):\n\n    # Set the formatter on the handler to be the SimpleFormatter\n    handler.setFormatter(SimpleFormatter())\n\n    # Get file name, line number, and function name for\n    # wrap_log_handler()\n    obj = wrap_log_handler\n    filename = inspect.getsourcefile(obj)\n    lineno = inspect.getsourcelines(obj)[1]\n    funcname = 'wrap_log_handler'\n\n    @functools.wraps(handler.emit)\n    def wrapper(msg):\n        # First, generate a LogRecord\n        record = logging.LogRecord('bark', logging.INFO, filename, lineno,\n                                   msg, (), None, funcname)\n\n        # Now, pass it to the handler's emit method\n        handler.emit(record)\n\n    return wrapper", "response": "A function which takes a Python logging handler and wraps it."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nmarks the expected types of certain arguments. Arguments for which no types are provided default to strings. To specify an argument type, give this decorator a keyword argument, where the argument name is the name of the function argument and the value is a callable taking one argument, which will convert a string to a value of that type. Note that the 'bool' type is treated specially.", "response": "def arg_types(**kwargs):\n    \"\"\"\n    Mark the expected types of certain arguments.  Arguments for which\n    no types are provided default to strings.  To specify an argument\n    type, give this decorator a keyword argument, where the argument\n    name is the name of the function argument and the value is a\n    callable taking one argument, which will convert a string to a\n    value of that type.\n\n    Note that the 'bool' type is treated specially.\n    \"\"\"\n\n    def decorator(func):\n        if not hasattr(func, '_bark_types'):\n            func._bark_types = {}\n        func._bark_types.update(kwargs)\n        return func\n\n    return decorator"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef boolean(text):\n\n    tmp = text.lower()\n    if tmp.isdigit():\n        return bool(int(tmp))\n    elif tmp in ('t', 'true', 'on', 'yes'):\n        return True\n    elif tmp in ('f', 'false', 'off', 'no'):\n        return False\n\n    raise ValueError(\"invalid Boolean value %r\" % text)", "response": "Returns a boolean value from a string."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef address(addr):\n\n    if ':' in addr:\n        # Using rpartition here means we should be able to support\n        # IPv6, but only with a strict syntax\n        host, _sep, port = addr.rpartition(':')\n\n        # Convert the port to a number\n        try:\n            port = int(port)\n        except ValueError:\n            raise ValueError(\"invalid port number %r\" % port)\n\n        addr = (host, port)\n\n    return addr", "response": "Converts an address into a tuple of host and port."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef file_handler(name, logname, filename, mode='a', encoding=None,\n                 delay=False):\n    \"\"\"\n    A Bark logging handler logging output to a named file.\n\n    Similar to logging.FileHandler.\n    \"\"\"\n\n    return wrap_log_handler(logging.FileHandler(\n        filename, mode=mode, encoding=encoding, delay=delay))", "response": "A Bark logging handler logging output to a named file."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef timed_rotating_file_handler(name, logname, filename, when='h',\n                                interval=1, backupCount=0,\n                                encoding=None, delay=False, utc=False):\n    \"\"\"\n    A Bark logging handler logging output to a named file.  At\n    intervals specified by the 'when', the file will be rotated, under\n    control of 'backupCount'.\n\n    Similar to logging.handlers.TimedRotatingFileHandler.\n    \"\"\"\n\n    return wrap_log_handler(logging.handlers.TimedRotatingFileHandler(\n        filename, when=when, interval=interval, backupCount=backupCount,\n        encoding=encoding, delay=delay, utc=utc))", "response": "A Bark logging handler logging output to a named file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef datagram_handler(name, logname, host, port):\n\n    return wrap_log_handler(logging.handlers.DatagramHandler(host, port))", "response": "A Bark logging handler logging output to a datagram socket."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef smtp_handler(name, logname, mailhost, fromaddr, toaddrs, subject,\n                 credentials=None):\n    \"\"\"\n    A Bark logging handler logging output via SMTP.  To specify a\n    non-standard SMTP port, use the \"host:port\" format.  To specify\n    multiple \"To\" addresses, separate them with commas.  To specify\n    authentication credentials, supply a \"username:password\".\n\n    Similar to logging.handlers.SMTPHandler.\n    \"\"\"\n\n    return wrap_log_handler(logging.handlers.SMTPHandler(\n        mailhost, fromaddr, toaddrs, subject, credentials=credentials))", "response": "A Bark logging handler logging output via SMTP."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef http_handler(name, logname, host, url, method=\"GET\"):\n\n    return wrap_log_handler(logging.handlers.HTTPHandler(\n        host, url, method=method))", "response": "A Bark logging handler logging output to an HTTP server."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nlooking up the implementation of a named handler.", "response": "def _lookup_handler(name):\n    \"\"\"\n    Look up the implementation of a named handler.  Broken out for\n    testing purposes.\n\n    :param name: The name of the handler to look up.\n\n    :returns: A factory function for the log handler.\n    \"\"\"\n\n    # Look up and load the handler factory\n    for ep in pkg_resources.iter_entry_points('bark.handler', name):\n        try:\n            # Load and return the handler factory\n            return ep.load()\n        except (ImportError, pkg_resources.UnknownExtra):\n            # Couldn't load it...\n            continue\n\n    raise ImportError(\"Unknown log file handler %r\" % name)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_handler(name, logname, args):\n\n    factory = _lookup_handler(name)\n\n    # What arguments are we passing to the handler?\n    available = set(args.keys())\n\n    # Now, let's introspect the factory to pass it the right arguments\n    if inspect.isclass(factory):\n        argspec = inspect.getargspec(factory.__init__)\n        ismethod = True\n    else:\n        argspec = inspect.getargspec(factory)\n        ismethod = inspect.ismethod(factory)\n\n    # Now, let's select the arguments we'll be passing in from the\n    # args dictionary\n    argnames = argspec.args[2 + ismethod:]\n    recognized = set(argnames)\n\n    # Now, which ones are required?\n    if argspec.defaults:\n        required = set(argnames[:len(argnames) - len(argspec.defaults)])\n    else:\n        required = set(argnames)\n    missing = required - available\n    if missing:\n        raise TypeError(\"Missing required parameters: %s\" %\n                        ', '.join(repr(arg) for arg in sorted(missing)))\n\n    # OK, let's determine the argument types\n    type_map = getattr(factory, '_bark_types', {})\n\n    # Now go convert the arguments\n    kwargs = {}\n    additional = set()\n    for arg, value in args.items():\n        # Should we ignore it?\n        if not argspec.keywords and arg not in recognized:\n            additional.add(arg)\n            continue\n\n        # Translate the value, first\n        target_type = type_map.get(arg, lambda x: x)\n        if target_type is bool:\n            target_type = boolean\n        try:\n            value = target_type(value)\n        except ValueError as exc:\n            raise ValueError(\"Argument %r: invalid %s value %r: %s\" %\n                             (arg, target_type.__name__, value, exc))\n\n        # OK, save it\n        kwargs[arg] = value\n\n    # Log any unused arguments\n    if additional:\n        LOG.warn(\"Unused arguments for handler of type %r for log %r: %s\" %\n                 (name, logname, ', '.join(repr(arg)\n                                           for arg in sorted(additional))))\n\n    # OK, we have now constructed the arguments to feed to the handler\n    # factory; call it and return the result\n    return factory(name, logname, **kwargs)", "response": "Retrieve a handler given its name and logname and arguments."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef make_keys_safe(dct):\n    result = {}\n    for key, val in dct.items():\n        key = key.replace('-', '_')\n        if key in keyword.kwlist:\n            key = key + '_'\n        result[key] = val\n    return result", "response": "Modify the keys in dct to be valid attribute names."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nunpacks the argparse Namespace object and applies the contents of the function func as normal arguments to the object func", "response": "def _apply_args_to_func(global_args, func):\n    \"\"\" Unpacks the argparse Namespace object and applies its\n    contents as normal arguments to the function func \"\"\"\n    global_args = vars(global_args)\n    local_args = dict()\n    for argument in inspect.getargspec(func).args:\n        local_args[argument] = global_args[argument]\n    return func(**local_args)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ndefine a subcommand for the psychic_disco function", "response": "def subcommand(f):\n    \"\"\" Define a subcommand for the psychic_disco function\n    Expects functions to supply a list of their arguments\n    Converts these to arg_parse arguments, and transforms\n    the argparse Namespace object so that commands can be\n    invoked as though they are normal functions (which they are)\"\"\"\n    sp = subparsers.add_parser(f.__name__, help=f.__doc__)\n    for argument in inspect.getargspec(f).args:\n        sp.add_argument(argument)\n    sp.set_defaults(func=lambda args: _apply_args_to_func(args, f))\n    return f"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef open(self, path, mode='r', *args, **kwargs):\n        return open(os.path.join(os.path.dirname(self.path), path),\n                    mode=mode, *args, **kwargs)", "response": "Proxy to function open with path to the current file."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns absolute path for a path relative to the current file.", "response": "def abspath(self, path):\n        \"\"\"Return absolute path for a path relative to the current file.\"\"\"\n        return os.path.abspath(os.path.join(os.path.dirname(self.path), path))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef run(cmd, background=False):\n    logger.debug('Running command: %s' % cmd)\n\n    if background:\n        return subprocess.Popen(cmd, shell=True, close_fds=True)\n\n    else:\n        (status, output) = commands.getstatusoutput(cmd)\n        if status != 0:\n            logger.error(\"Command failed: %s\" % cmd)\n\n        if output:\n            logger.debug('OUTPUT:\\n' + output)\n\n        if status != 0:\n            raise CommandException(status, output)\n\n        return output", "response": "Executes a command in a thread and returns stdout."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef lot(self, id, user=True, dependencies=True, comments=True, votes=True, no_strip=False):\n        args = {}\n        if user:\n            args['user'] = 'true'\n        if dependencies:\n            args['dependencies'] = 'true'\n        if comments:\n            args['comments'] = 'true'\n        if votes:\n            args['votes'] = 'true'\n        if no_strip:\n            args['nostrip'] = 'true'\n\n        return self._get_json('lot/{0}', id, **args)", "response": "Retrieve the lot with given identifier"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndownloading the file with given identifier to the given directory.", "response": "def download(self, id, directory):\n        \"\"\"\n        Download the file with given identifier to the given directory\n        :param id: Identifier of the lot to download\n        :param directory: Directory where the downloaded ZIP should be stored\n        :return: None\n        \"\"\"\n        url = (self._base + 'lot/{0}/download').format(id)\n        r = requests.get(url, auth=self._auth, stream=True)\n        file_name = r.headers['Content-Disposition'].split('\"')[-2]\n\n        if len(directory) < 1:\n            return\n\n        with open(os.path.join(directory, file_name), 'wb') as file:\n            for chunk in r.iter_content(chunk_size=1024):\n                if chunk:\n                    file.write(chunk)\n                    file.flush()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef rate(self, id, comment=None, vote=None):\n\n        rating = {}\n\n        if vote is not None:\n            if 1 <= vote <= 3:\n                rating['rating'] = vote\n        if comment is not None:\n            if len(comment) > 0:\n                rating['comment'] = comment\n\n        url = self._base + 'lot/{0}/comment'.format(id)\n        r = requests.post(url, auth=self._auth, params=rating)\n        r.raise_for_status()\n        return r.json()", "response": "Add a rating and comment to the lot with given identifier."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef set_dependencies(self, id, internal=list(), external=list()):\n        dependency_str = 'NONE'\n        if len(internal) > 0 or len(external) > 0:\n            deps = internal\n            for (name, link) in external:\n                deps.append(\"{0}@{1}\".format(name, link))\n            dependency_str = '$'.join(str(x) for x in deps)\n\n        params = {\n            'string': b64encode(dependency_str.encode('ascii'))\n        }\n\n        url = self._base + 'lot/{0}/dependency-string'.format(id)\n        r = requests.put(url, auth=self._auth, params=params)\n        r.raise_for_status()\n\n        return {\n            'plain': dependency_str,\n            'encoded': params['string']\n        }", "response": "Sets the dependency string for a lot."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nuploads a file to LinShare using its rest api.", "response": "def upload(self, thread_uuid, file_path, description=None):\n        \"\"\" Upload a file to LinShare using its rest api.\n        The uploaded document uuid will be returned\"\"\"\n        url = \"threads/%s/entries\" % thread_uuid\n        return self.core.upload(file_path, url, description)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets one workgroup member.", "response": "def get(self, wg_uuid, uuid, tree=False):\n        \"\"\" Get one workgroup member.\"\"\"\n        url = \"%(base)s/%(wg_uuid)s/nodes/%(uuid)s\" % {\n            'base': self.local_base_url,\n            'wg_uuid': wg_uuid,\n            'uuid': uuid\n        }\n        param = {}\n        if tree:\n            param['tree'] = True\n        encode = urllib.urlencode(param)\n        if encode:\n            url += \"?\"\n            url += encode\n        return self.core.get(url)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef head(self, wg_uuid, uuid):\n        url = \"%(base)s/%(wg_uuid)s/nodes/%(uuid)s\" % {\n            'base': self.local_base_url,\n            'wg_uuid': wg_uuid,\n            'uuid': uuid\n        }\n        # return self.core.head(url)\n        try:\n            # workaround\n            return self.core.get(url)\n        except LinShareException:\n            return False", "response": "Get one workgroup node."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting a list of workgroup nodes.", "response": "def list(self, wg_uuid, parent=None, flat=False, node_types=None):\n        \"\"\" Get a list of workgroup nodes.\"\"\"\n        url = \"%(base)s/%(wg_uuid)s/nodes\" % {\n            'base': self.local_base_url,\n            'wg_uuid': wg_uuid\n        }\n        param = []\n        if parent:\n            # I use only the last folder uuid, the first ones are not really useful\n            if isinstance(parent, (list,)):\n                if len(parent) >= 1:\n                    parent = parent[-1]\n            param.append((\"parent\", parent))\n        if flat:\n            param.append((\"flat\", True))\n        if node_types:\n            for node_type in node_types:\n                param.append((\"type\", node_type))\n        encode = urllib.urlencode(param)\n        if encode:\n            url += \"?\"\n            url += encode\n        return self.core.list(url)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef upload(self, wg_uuid, file_path, description=None, parent=None):\n        url = \"%(base)s/%(wg_uuid)s/nodes\" % {\n            'base': self.local_base_url,\n            'wg_uuid': wg_uuid\n        }\n        param = {}\n        if parent:\n            # I use only the last folder uuid, the first ones are not really useful\n            if isinstance(parent, (list,)):\n                if len(parent) >= 1:\n                    parent = parent[-1]\n            param['parent'] = parent\n        encode = urllib.urlencode(param)\n        if encode:\n            url += \"?\"\n            url += encode\n        return self.core.upload(file_path, url, description)", "response": "Upload a file to LinShare using its rest api."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef update(self, data):\n        self.debug(data)\n        self._check(data)\n        wg_uuid = data.get('workGroup')\n        self.log.debug(\"wg_uuid : %s \", wg_uuid)\n        uuid = data.get('uuid')\n        url = \"%(base)s/%(wg_uuid)s/nodes/%(uuid)s\" % {\n            'base': self.local_base_url,\n            'wg_uuid': wg_uuid,\n            'uuid': uuid\n        }\n        return self.core.update(url, data)", "response": "Update meta of one document."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nclaim a list of attributes for the current client. Returns an update response object.", "response": "def arquire_attributes(self, attributes, active=True):\n        \"\"\"\n        Claims a list of attributes for the current client.\n        Can also disable attributes. Returns update response object.\n        \"\"\"\n        attribute_update = self._post_object(self.update_api.attributes.acquire, attributes)\n        return ExistAttributeResponse(attribute_update)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef release_attributes(self, attributes, active=True):\n        attribute_update = self._post_object(self.update_api.attributes.release, attributes)\n        return ExistAttributeResponse(attribute_update)", "response": "Releases named attributes from this service. Returns an update response object."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning a list of attributes owned by this service.", "response": "def owned_attributes(self):\n        \"\"\"\n        Returns a list of attributes owned by this service.\n        \"\"\"\n        attributes = self._get_object(self.update_api.attributes.owned)\n        return [ExistOwnedAttributeResponse(attribute) for attribute in attributes]"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nupdates named attributes from this service. Returns an update response object.", "response": "def update_attributes(self, attributes):\n        \"\"\"\n        Releases named attributes from this service. Returns update response object.\n        \"\"\"\n        attribute_update = self._post_object(self.update_api.attributes.update, attributes)\n        return ExistAttributeResponse(attribute_update)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef eval(self, valuation=None, trace=None):\n        args2 = []\n        for a in self.args:\n            if isinstance(a, Function) or isinstance(a, IPredicate):\n                args2.append(Constant(a.eval(valuation=valuation, trace=trace)))\n\n            elif isinstance(a, Variable):\n                found = False\n                for v in valuation:\n                    if str(v.var) == a.name:\n                        args2.append(Constant(str(v.value.name)))\n                        found = True\n                        break\n                if not found:\n                    raise Exception(\"IPredicate instantiation failed : missing vars\")\n            else:\n                args2.append(Constant(a))\n\n        return args2", "response": "This method evaluates the receiver s arguments."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef compile_sequence(cycles, program_or_profile='program',\n                     unit_converter=None):\n    \"\"\" Makes the command list for a move sequence.\n\n    Constructs the list of commands to execute the given sequence of\n    motion. Program/command line commands or profile commands can be\n    generated depending on the value of `program_or_profile` so that the\n    commands can be used to construct a program or profile later. Types\n    of motion supported (see Notes for how to specify) are moves from\n    one position to another (the motion will always come to a stop\n    before doing the next motion), waiting a given interval of time till\n    starting the next move, and looping over a sequence of moves.\n\n    Parameters\n    ----------\n    cycles : iterable of dicts\n        The iterable of cycles of motion to do one after another. See\n        Notes for format.\n    program_or_profile : {'program', 'profile'}, optional\n        Whether program or profile motion commands should be used.\n        Anything other than these two values implies the default.\n    unit_converter : UnitConverter, optional\n        ``GeminiMotorDrive.utilities.UnitConverter`` to use to convert\n        the units in `cycles` to motor units. ``None`` indicates that\n        they are already in motor units.\n\n    Returns\n    -------\n    commands : list of str\n        ``list`` of ``str`` commands making up the move sequence.\n\n    Notes\n    -----\n    `cycles` is an iterable of individual cycles of motion. Each cycle\n    is a ``dict`` that represents a sequence of moves that could\n    possibly be looped over. The field ``'iterations'`` gives how many\n    times the sequence of moves should be done (a value > 1 implies a\n    loop). Then the field ``'moves'`` is an iterable of the individual\n    moves. Each individual move is a ``dict`` with the acceleration\n    (``'A'``), deceleration (``'AD'`` with 0 meaning the value of the\n    acceleration is used), velocity (``'V'``), and the distance/position\n    (``'D'``). Back in the cycle, the field ``'wait_times'`` is an\n    iterable of numbers giving the time in seconds to wait after each\n    move before going onto the next.\n\n    See Also\n    --------\n    get_sequence_time\n    convert_sequence_to_motor_units\n    GeminiMotorDrive.utilities.UnitConverter\n\n    Examples\n    --------\n\n    Simple program style two motions with a pause in between.\n\n    >>> from GeminiMotorDrive.compilers.move_sequence import *\n    >>> cycles = [{'iterations':1, 'wait_times':[1, 0],\n    ...           'moves':[{'A':100, 'AD':0, 'D':-1000, 'V':100},\n    ...           {'A':90, 'AD':0, 'D':-1000, 'V':100}]}]\n    >>> compile_sequence(cycles)\n    ['A100',\n     'AD0',\n     'V100',\n     'D-1000',\n     'GO1',\n     'WAIT(AS.1=b0)',\n     'T1',\n     'A90',\n     'GO1',\n     'WAIT(AS.1=b0)']\n\n    The same motion but in profile style commands\n\n    >>> from GeminiMotorDrive.compilers.move_sequence import *\n    >>> cycles = [{'iterations':1, 'wait_times':[1, 0],\n    ...           'moves':[{'A':100, 'AD':0, 'D':-1000, 'V':100},\n    ...           {'A':90, 'AD':0, 'D':-1000, 'V':100}]}]\n    >>> compile_sequence(cycles, program_or_profile='profile')\n    ['A100',\n     'AD100',\n     'V100',\n     'D-1000',\n     'VF0',\n     'GOBUF1',\n     'GOWHEN(T=1000)',\n     'A90',\n     'AD90',\n     'VF0',\n     'GOBUF1']\n\n    Another motion with a back and forth loop (100 iterations) in the\n    middle, done in program style commands.\n\n    >>> from GeminiMotorDrive.compilers.move_sequence import *\n    >>> cycles = [{'iterations':1, 'wait_times':[1],\n    ...           'moves':[{'A':100, 'AD':0, 'D':-1000, 'V':100}]},\n    ...           {'iterations':100, 'wait_times':[0, 0],\n    ...           'moves':[{'A':50, 'AD':40, 'D':-1000, 'V':30},\n    ...           {'A':50, 'AD':40, 'D':1000, 'V':30}]},\n    ...           {'iterations':1, 'wait_times':[0],\n    ...           'moves':[{'A':100, 'AD':0, 'D':1000, 'V':100}]}]\n    >>> compile_sequence(cycles)\n    ['A100',\n     'AD0',\n     'V100',\n     'D-1000',\n     'GO1',\n     'WAIT(AS.1=b0)',\n     'T1',\n     'L100',\n     'A50',\n     'AD40',\n     'V30',\n     'D-1000',\n     'GO1',\n     'WAIT(AS.1=b0)',\n     'D~',\n     'GO1',\n     'WAIT(AS.1=b0)',\n     'LN',\n     'A100',\n     'AD0',\n     'V100',\n     'GO1',\n     'WAIT(AS.1=b0)']\n\n    \"\"\"\n    # If needed, cycles needs to be converted to motor units.\n    if unit_converter is None:\n        cv_cycles = cycles\n    else:\n        cv_cycles = convert_sequence_to_motor_units(cycles, \\\n            unit_converter=unit_converter)\n\n    # Initially, we have no commands in our command list.\n    commands = []\n\n    # The A, AD, D, and V parameters of the previous motion should be\n    # kept track of because if they don't change from one motion to the\n    # next, the commands to set them don't need to be included. They\n    # will be started blank since there are no previous motions yet.\n    previous_motion = {'A': [], 'AD': [], 'D': [], 'V': []}\n\n    # Construct each cycle one by one.\n    for cycle in cv_cycles:\n        # If more than one iteration is being done, a loop needs to be\n        # setup. It will be either 'L' or 'PLOOP' with the number of\n        # iterations attached if it is a program or a profile\n        # respectively. Since it will be tough to keep track of what\n        # motion changed from the end of a loop to the beginning of it,\n        # it is easier to just forget all previous motion values and set\n        # them all at the beginning of the loop (clear previous_motion).\n        iterations = int(cycle['iterations'])\n        if iterations > 1:\n            previous_motion = {'A': [], 'AD': [], 'D': [], 'V': []}\n            if program_or_profile != 'profile':\n                commands.append('L' + str(iterations))\n            else:\n                commands.append('PLOOP' + str(iterations))\n\n        # Construct each individual move in the cycle.\n        for i in range(0, len(cycle['moves'])):\n            # Grab the motion indicated by the current move.\n            new_motion = cycle['moves'][i]\n\n            # If we are doing a profile, AD must be set explicitly\n            # to A if it is 0.\n            if program_or_profile == 'profile' \\\n                    and new_motion['AD'] == 0.0:\n                new_motion['AD'] = new_motion['A']\n\n            # Set A, AD, and V if they have changed.\n            for k in ('A', 'AD', 'V'):\n                if previous_motion[k] != new_motion[k]:\n                    # Grab it and round it to 4 places after the decimal\n                    # point because that is the most that is\n                    # supported. Then, if it is an integer value,\n                    # convert it to an integer because that is what the\n                    # drive will send back if requested (makes\n                    # comparisons easier). Then add the command.\n                    val = round(float(new_motion[k]), 4)\n                    if val == int(val):\n                        val = int(val)\n                    commands.append(k + str(val))\n\n            # If the sign of D has flipped, we just need to issue a 'D~'\n            # command. If the value has changed in another way, it needs\n            # to be reset.\n            if previous_motion['D'] != new_motion['D']:\n                if previous_motion['D'] == -new_motion['D']:\n                    commands.append('D~')\n                else:\n                    commands.append('D'\n                                    + str(int(new_motion['D'])))\n\n            # Grab the amount of time that should be waited after the\n            # move is done.\n            wait_time = cycle['wait_times'][i]\n\n            # Give the motion command (GO or GOBUF), tell the drive to\n            # wait till the motor has stopped (a WAIT command if it is a\n            # program and a VF0 command if it is a profile), and make it\n            # wait the period of time wait_time (T and GOWHEN commands).\n            if program_or_profile != 'profile':\n                commands.append('GO1')\n                commands.append('WAIT(AS.1=b0)')\n                if wait_time != 0:\n                    # The wait time needs to be rounded to 3 places\n                    # after the decimal. If it is an integer, it should\n                    # be converted to an int so that the drive will send\n                    # back what we send (makes compairisons easier).\n                    wait_time = round(float(wait_time), 3)\n                    if wait_time == int(wait_time):\n                        wait_time = int(wait_time)\n                    commands.append('T' + str(wait_time))\n            else:\n                commands.append('VF0')\n                commands.append('GOBUF1')\n                if wait_time != 0:\n                    commands.append('GOWHEN(T='\n                                    + str(int(1000*wait_time))\n                                    + ')')\n\n            # Before going onto the next move, previous_motion needs to\n            # be set to the one just done.\n            previous_motion = new_motion\n\n        # Done with all the moves of the cycle. If we are looping, the\n        # loop end needs to be put in.\n        if iterations > 1:\n            if program_or_profile != 'profile':\n                commands.append('LN')\n            else:\n                commands.append('PLN')\n\n    # Done constructing the command list.\n    return commands", "response": "Builds the command list for a given sequence of cycles."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncalculates the time the move sequence will take to complete.", "response": "def get_sequence_time(cycles, unit_converter=None, eres=None):\n    \"\"\" Calculates the time the move sequence will take to complete.\n\n    Calculates the amount of time it will take to complete the given\n    move sequence. Types of motion supported are moves from one position\n    to another (the motion will always come to a stop before doing the\n    next motion), waiting a given interval of time till starting the\n    next move, and looping over a sequence of moves.\n\n    Parameters\n    ----------\n    cycles : list of dicts\n        The ``list`` of cycles of motion to do one after another. See\n        ``compile_sequence`` for format.\n    unit_converter : UnitConverter, optional\n        ``GeminiMotorDrive.utilities.UnitConverter`` to use to convert\n        the units in `cycles` to motor units. ``None`` indicates that\n        they are already in motor units.\n    eres : int\n        Encoder resolution. Only relevant if `unit_converter` is\n        ``None``.\n\n\n    Returns\n    -------\n    time : float\n        Time the move sequence will take in seconds.\n\n    See Also\n    --------\n    compile_sequence\n    GeminiMotorDrive.utilities.UnitConverter\n    move_time\n\n    \"\"\"\n    # If we are doing unit conversion, then that is equivalent to motor\n    # units but with eres equal to one.\n    if unit_converter is not None:\n        eres = 1\n    # Starting with 0 time, steadily add the time of each movement.\n    tme = 0.0\n    # Go through each cycle and collect times.\n    for cycle in cycles:\n        # Add all the wait times.\n        tme += cycle['iterations']*sum(cycle['wait_times'])\n        # Add the time for each individual move.\n        for move in cycle['moves']:\n            tme += cycle['iterations'] \\\n                * move_time(move, eres=eres)\n    # Done.\n    return tme"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef move_time(move, eres):\n    # Grab the move parameters. If the deceleration is given as zero,\n    # that means it has the same value as the acceleration. Distance is\n    # converted to the same units as the others by dividing by the\n    # encoder resolution. The absolute value of everything is taken for\n    # simplicity.\n    A = abs(move['A'])\n    AD = abs(move['AD'])\n    if AD == 0.0:\n        AD = A\n    V = abs(move['V'])\n    D = abs(move['D'])/eres\n\n    # Calculate the times it would take to accelerate from stop to V and\n    # decelerate to stop at rates A and AD respectively.\n    accel_times = [V/A, V/AD]\n\n    # Calculate the distances that would be moved in those times.\n    dists = [0.5*A*(accel_times[0]**2), 0.5*AD*(accel_times[1]**2)]\n\n    # If the sum of those dists is greater than D, then the velocity V\n    # is never reached. The way the time is calculated depends on which\n    # case it is.\n    if sum(dists) <= D:\n        # The time is just the sum of the acceleration times plus the\n        # remaining distance divided by V.\n        return (sum(accel_times) + (D-sum(dists))/V)\n    else:\n        # We need to find the time it takes for the acceleration path\n        # and deceleration path to meet and have the same speeds.\n        #\n        # (1) t = t_1 + t_2\n        # (2) A*t_1 = AD*t_2\n        # (3) D = 0.5*A*(t_1**2) + 0.5*AD*(t_2**2)\n        #\n        # Re-writing t_2 in terms of t_1 using (2)\n        # (4) t_2 = (A / AD) * t_1\n        #\n        # Putting that into (1) and (3)\n        # (4) t = (1 + (A / AD)) * t_1\n        # (5) D = 0.5*A*(1 + (A / AD)) * (t_1**2)\n        #\n        # Solving (5) for t_1,\n        # (6) t_1 = sqrt( 2*D / (A * (1 + (A / AD))))\n        #\n        # Putting that into (4),\n        # t = sqrt(2*D*(1 + (A / AD)) / A)\n        return math.sqrt(2*D * (1 + (A / AD)) / A)", "response": "Calculates the time that a move will take in seconds."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef convert_sequence_to_motor_units(cycles, unit_converter):\n    # Make a deep copy of cycles so that the conversions don't damage\n    # the original one.\n    cv_cycles = copy.deepcopy(cycles)\n\n    # Go through each cycle and do the conversions.\n    for cycle in cv_cycles:\n        # Go through each of the moves and do the conversions.\n        for move in cycle['moves']:\n            move['A'] = unit_converter.to_motor_velocity_acceleration( \\\n                move['A'])\n            move['AD'] = \\\n                unit_converter.to_motor_velocity_acceleration( \\\n                move['AD'])\n            move['V'] = unit_converter.to_motor_velocity_acceleration( \\\n                move['V'])\n            move['D'] = int(unit_converter.to_motor_distance(move['D']))\n\n    # Now return the converted move sequence.\n    return cv_cycles", "response": "Converts a move sequence to motor units using the provied converter."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns Hip string if not already compiled else compile it.", "response": "def compile(self):\n        \"\"\"Return Hip string if already compiled else compile it.\"\"\"\n        if self.buffer is None:\n            self.buffer = self._compile_value(self.data, 0)\n\n        return self.buffer.strip()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndispatch to correct compilation method.", "response": "def _compile_value(self, data, indent_level):\n        \"\"\"Dispatch to correct compilation method.\"\"\"\n        if isinstance(data, dict):\n            return self._compile_key_val(data, indent_level)\n        elif isinstance(data, list):\n            return self._compile_list(data, indent_level)\n        else:\n            return self._compile_literal(data)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nwriting correct representation of literal.", "response": "def _compile_literal(self, data):\n        \"\"\"Write correct representation of literal.\"\"\"\n        if data is None:\n            return 'nil'\n        elif data is True:\n            return 'yes'\n        elif data is False:\n            return 'no'\n        else:\n            return repr(data)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _compile_list(self, data, indent_level):\n        if len(data) == 0:\n            return '--'\n        elif not any(isinstance(i, (dict, list)) for i in data):\n            return ', '.join(self._compile_literal(value) for value in data)\n        else:\n            # 'ere be dragons,\n            # granted there are fewer dragons than the parser,\n            # but dragons nonetheless\n            buffer = ''\n            i = 0\n            while i < len(data):\n                if isinstance(data[i], dict):\n                    buffer += '\\n'\n                    buffer += self._indent * indent_level\n                    while i < len(data) and isinstance(data[i], dict):\n                        buffer += '-\\n'\n                        buffer += self._compile_key_val(data[i], indent_level)\n                        buffer += self._indent * indent_level + '-'\n                        i += 1\n                    buffer += '\\n'\n                elif (\n                    isinstance(data[i], list) and\n                    any(isinstance(item, (dict, list)) for item in data[i])\n                ):\n                    buffer += self._compile_list(data[i], indent_level+1)\n                elif isinstance(data[i], list):\n                    buffer += '\\n'\n                    buffer += self._indent * indent_level\n                    buffer += self._compile_list(data[i], indent_level+1)\n                else:\n                    buffer += '\\n'\n                    buffer += self._indent * indent_level\n                    buffer += self._compile_literal(data[i])\n\n                i += 1\n\n            return buffer", "response": "Correctly write possibly nested list."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _compile_key_val(self, data, indent_level):\n        buffer = ''\n        for (key, val) in data.items():\n            buffer += self._indent * indent_level\n            # TODO: assumes key is a string\n            buffer += key + ':'\n\n            if isinstance(val, dict):\n                buffer += '\\n'\n                buffer += self._compile_key_val(val, indent_level+1)\n            elif (\n                isinstance(val, list) and\n                any(isinstance(i, (dict, list)) for i in val)\n            ):\n                buffer += self._compile_list(val, indent_level+1)\n            else:\n                buffer += ' '\n                buffer += self._compile_value(val, indent_level)\n                buffer += '\\n'\n\n        return buffer", "response": "Compile a dictionary of key - value pairs into a string."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef transaction(data_access):\n  old_autocommit = data_access.autocommit\n  data_access.autocommit = False\n  try:\n    yield data_access\n  except RollbackTransaction as ex:\n    data_access.rollback()\n  except Exception as ex:\n    data_access.rollback()\n    raise ex\n  else:\n    data_access.commit()\n  finally:\n    data_access.autocommit = old_autocommit", "response": "Wrap statements in a transaction."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef autocommit(data_access):\n  if not data_access.autocommit:\n    data_access.commit()\n  old_autocommit = data_access.autocommit\n  data_access.autocommit = True\n  try:\n    yield data_access\n  finally:\n    data_access.autocommit = old_autocommit", "response": "A context manager that commits the current transaction if it is not already committed."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset the autocommit value.", "response": "def autocommit(self, value):\n    \"\"\"Set the autocommit value.\n\n    :param value: the new autocommit value\n    \"\"\"\n    logger.debug(\"Setting autocommit from %s to %s\", self.autocommit, value)\n    self.core.set_autocommit(self.connection, value)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _configure_connection(self, name, value):\n    self.update(\"pg_settings\", dict(setting=value), dict(name=name))", "response": "Sets a Postgres run - time connection configuration parameter."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the connection with the core s open method.", "response": "def open(self, *, autocommit=False):\n    \"\"\"Sets the connection with the core's open method.\n\n    :param autocommit: the default autocommit state\n    :type autocommit: boolean\n    :return: self\n    \"\"\"\n    if self.connection is not None:\n      raise Exception(\"Connection already set\")\n    self.connection = self.core.open()\n    self.autocommit = autocommit\n    if self._search_path:\n      self._configure_connection(\n        \"search_path\",\n        self._search_path)\n    return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef close(self, *, commit=True):\n    self.core.close(self.connection, commit=commit)\n    self.connection = None\n    return self", "response": "Closes the connection via the core s close method."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef execute(self, query_string, params=None):\n    cr = self.connection.cursor()\n    logger.info(\"SQL: %s (%s)\", query_string, params)\n    self.last_query = (query_string, params)\n    t0 = time.time()\n    cr.execute(query_string, params or self.core.empty_params)\n    ms = (time.time() - t0) * 1000\n    logger.info(\"RUNTIME: %.2f ms\", ms)\n    self._update_cursor_stats(cr)\n    return cr", "response": "Executes a query and returns the resulting cursor."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef callproc(self, name, params, param_types=None):\n\n    if param_types:\n      placeholders = [self.sql_writer.typecast(self.sql_writer.to_placeholder(), t)\n                      for t in param_types]\n    else:\n      placeholders = [self.sql_writer.to_placeholder() for p in params]\n\n    # TODO: This may be Postgres specific...\n    qs = \"select * from {0}({1});\".format(name, \", \".join(placeholders))\n    return self.execute(qs, params), params", "response": "Calls a procedure.\n\n    :param name: the name of the procedure\n    :param params: a list or tuple of parameters to pass to the procedure.\n    :param param_types: a list or tuple of type names. If given, each param will be cast via\n                        sql_writers typecast method. This is useful to disambiguate procedure calls\n                        when several parameters are null and therefore cause overload resoluation\n                        issues.\n    :return: a 2-tuple of (cursor, params)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a procedure s signature from the name and list of types.", "response": "def get_callproc_signature(self, name, param_types):\n    \"\"\"Returns a procedure's signature from the name and list of types.\n\n    :name: the name of the procedure\n    :params: can be either strings, or 2-tuples. 2-tuples must be of the form (name, db_type).\n    :return: the procedure's signature\n    \"\"\"\n    if isinstance(param_types[0], (list, tuple)):\n      params = [self.sql_writer.to_placeholder(*pt) for pt in param_types]\n    else:\n      params = [self.sql_writer.to_placeholder(None, pt) for pt in param_types]\n\n    return name + self.sql_writer.to_tuple(params)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the first record that matches the given criteria.", "response": "def find(self, table_name, constraints=None, *, columns=None, order_by=None):\n    \"\"\"Returns the first record that matches the given criteria.\n\n    :table_name: the name of the table to search on\n    :constraints: is any construct that can be parsed by SqlWriter.parse_constraints.\n    :columns: either a string or a list of column names\n    :order_by: the order by clause\n    \"\"\"\n    query_string, params = self.sql_writer.get_find_all_query(\n      table_name, constraints, columns=columns, order_by=order_by)\n    query_string += \" limit 1;\"\n    return self.execute(query_string, params).fetchone()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef find_all(self, table_name, constraints=None, *, columns=None, order_by=None, limiting=None):\n    query_string, params = self.sql_writer.get_find_all_query(\n      table_name, constraints, columns=columns, order_by=order_by, limiting=limiting)\n    query_string += \";\"\n    return self.execute(query_string, params)", "response": "Returns all records that match a given criteria."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nperform a find_all method with paging.", "response": "def page(self, table_name, paging, constraints=None, *, columns=None, order_by=None,\n           get_count=True):\n    \"\"\"Performs a find_all method with paging.\n\n    :param table_name: the name of the table to search on\n    :param paging: is a tuple containing (page, page_size).\n    :param constraints: is any construct that can be parsed by SqlWriter.parse_constraints.\n    :param columns: either a string or a list of column names\n    :param order_by: the order by clause\n    :param get_count: if True, the total number of records that would be included without paging are\n                      returned. If False, None is returned for the count.\n    :return: a 2-tuple of (records, total_count)\n    \"\"\"\n    if get_count:\n      count = self.count(table_name, constraints)\n    else:\n      count = None\n\n    page, page_size = paging\n\n    limiting = None\n    if page_size > 0:\n      limiting = (page_size, page * page_size)\n\n    records = list(self.find_all(\n      table_name, constraints, columns=columns, order_by=order_by, limiting=limiting))\n    return (records, count)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nbuilds and executes an update statement.", "response": "def update(self, table_name, values, constraints=None, *, returning=None):\n    \"\"\"Builds and executes and update statement.\n\n    :param table_name: the name of the table to update\n    :param values: can be either a dict or an enuerable of 2-tuples in the form (column, value).\n    :param constraints: can be any construct that can be parsed by SqlWriter.parse_constraints.\n                        However, you cannot mix tuples and dicts between values and constraints.\n    :param returning: the columns to return after updating. Only works for cores that support the\n                      returning syntax\n    :return: a cursor object\n    \"\"\"\n    if constraints is None:\n      constraints = \"1=1\"\n    assignments, assignment_params = self.sql_writer.parse_constraints(\n      values, \", \", is_assignment=True)\n    where, where_params = self.sql_writer.parse_constraints(constraints, \" and \")\n    returns = \"\"\n    if returning and self.core.supports_returning_syntax:\n      returns = \" returning {0}\".format(returning)\n    sql = \"update {0} set {1} where {2}{3};\".format(table_name, assignments, where, returns)\n    params = assignment_params\n\n    if constraints is None or isinstance(constraints, str):\n      pass\n    elif isinstance(constraints, dict):\n      if isinstance(params, list):\n        raise ValueError(\"you cannot mix enumerable and dict values and constraints\")\n      params = params or {}\n      params.update(where_params)\n    else:\n      if isinstance(params, dict):\n        raise ValueError(\"you cannot mix enumerable and dict values and constraints\")\n      params = params or []\n      params.extend(where_params)\n\n    cr = self.execute(sql, params)\n    return cr"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nbuild and executes an insert statement.", "response": "def insert(self, table_name, values, *, returning=None, upsert=None):\n    \"\"\"Builds and executes an insert statement.\n\n    :param table_name: the name of the table to insert into\n    :param values: can be either a dict or an enumerable of 2-tuples in the form (column, value).\n    :param returning: the columns to return after updating. Only works for cores that support the\n                      returning syntax\n    :param upsert: an Upsert instance, defining how to perform the uspert.\n    :return: a cursor object\n    \"\"\"\n    if isinstance(values, dict):\n      names = values.keys()\n      placeholders = [self.sql_writer.to_placeholder(i) for i in names]\n      params = values\n    else:\n      names = [i[0] for i in values]\n      placeholders = [self.sql_writer.to_placeholder() for i in values]\n      params = [i[1] for i in values]\n    placeholders = self.sql_writer.to_tuple(placeholders)\n    names = self.sql_writer.to_tuple(names)\n    returns = \"\"\n    if returning and self.core.supports_returning_syntax:\n      returns = \" returning {0}\".format(returning)\n\n    if upsert:\n      if upsert.action == Upsert.DO_NOTHING:\n        u_action_fmt = \" on conflict{} do nothing\"\n        u_assignments = None\n        u_constraints = None\n      else:\n        u_action_fmt = \" on conflict{} do update set {}{}\"\n        u_assignments, u_assignment_params = self.sql_writer.parse_constraints(\n          values, \", \", is_assignment=True)\n        u_constraints = \"\"\n\n        if isinstance(values, dict):\n          if not upsert.force:\n            # Build constraints based on the full column name, and using !=. This will make it so\n            # that the record won't be updated if all the fields we care about are the same.\n            u_constraints, u_params = self.core.sql_writer.parse_constraints(\n              {\"{}.{}\".format(table_name, k): v for k, v in values.items()},\n              \" or \",\n              comp=\"!=\")\n            params.update(u_params)\n        else:\n          # Add assignment params\n          params.extend(u_assignment_params)\n\n          if not upsert.force:\n            # Build constraints based on the full column name, and using !=. This will make it so\n            # that the record won't be updated if all the fields we care about are the same.\n            u_constraints, u_params = self.core.sql_writer.parse_constraints(\n              [(\"{}.{}\".format(table_name, col), val, \"!=\") for (col, val, *_) in values],\n              \" or \")\n            params.extend(u_params)\n\n      if u_constraints:\n        u_constraints = \" where {}\".format(u_constraints)\n\n      u_action_str = u_action_fmt.format(upsert.target_str or \"\", u_assignments, u_constraints)\n\n      sql = \"insert into {0} {1} values {2}{3}{4}\".format(\n        table_name,\n        names,\n        placeholders,\n        u_action_str,\n        returns)\n    else:\n      sql = \"insert into {0} {1} values {2}{3};\".format(table_name, names, placeholders, returns)\n\n    cr = self.execute(sql, params)\n    return cr"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nbuilding and executes a delete statement.", "response": "def delete(self, table_name, constraints=None):\n    \"\"\"Builds and executes an delete statement.\n\n    :param table_name: the name of the table to delete from\n    :param constraints: can be any construct that can be parsed by SqlWriter.parse_constraints.\n    :return: a cursor object\n    \"\"\"\n    if constraints is None:\n      constraints = \"1=1\"\n    where, params = self.sql_writer.parse_constraints(constraints)\n    sql = \"delete from {0} where {1};\".format(table_name, where)\n    self.execute(sql, params)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef count(self, table_name, constraints=None, *, extract=\"index\"):\n    where, params = self.sql_writer.parse_constraints(constraints)\n    sql = \"select count(*) as count from {0} where {1};\".format(table_name, where or \"1 = 1\")\n    # NOTE: Won't work right with dict cursor\n    return self.get_scalar(self.execute(sql, params), 0 if extract == \"index\" else \"count\")", "response": "Returns the number of records in a table."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_scalar(self, cursor, index=0):\n    if isinstance(index, int):\n      return cursor.fetchone()[index]\n    else:\n      return get_value(cursor.fetchone(), index)", "response": "Returns a single value from the first returned record from a dict\n   ."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef target_str(self):\n    if isinstance(self.target, tuple):\n      return \"({})\".format(\", \".join(self.target))\n    else:\n      return self.target", "response": "Returns the string representation of the target property."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a list of points within a given cut - off of each other in a periodic system.", "response": "def get_inters(r, L, R_cut):\n    '''\n    Return points within a given cut-off of each other,\n    in a periodic system.\n\n    Uses a cell-list.\n\n    Parameters\n    ----------\n    r: array, shape (n, d) where d is one of (2, 3).\n        A set of n point coordinates.\n        Coordinates are assumed to lie in [-L / 2, L / 2].\n    L: float.\n        Bounds of the system.\n    R_cut: float.\n        The maximum distance within which to consider points to lie\n        near each other.\n\n    Returns\n    -------\n    inters: array, shape (n, n)\n        Indices of the nearby points.\n        For each particle indexed by the first axis,\n        the second axis lists each index of a nearby point.\n    intersi: array, shape (n,)\n        Total number of nearby points.\n        This array should be used to index `inters`, as for point `i`,\n        elements in `inters[i]` beyond `intersi[i]` have no well-defined value.\n    '''\n    if r.shape[1] == 2:\n        _cell_list.cell_list_2d.make_inters(r.T, L, R_cut)\n    elif r.shape[1] == 3:\n        _cell_list.cell_list_3d.make_inters(r.T, L, R_cut)\n    else:\n        print('Warning: cell list not implemented in this dimension, falling'\n              'back to direct computation')\n        return get_inters_direct(r, L, R_cut)\n    return _parse_inters()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a list of points within a given cut - off of each other in a periodic system.", "response": "def get_inters_direct(r, L, R_cut):\n    '''\n    Return points within a given cut-off of each other,\n    in a periodic system.\n\n    Uses a direct algorithm, which may be very slow for large numbers of\n    points.\n\n    Parameters\n    ----------\n    r: array, shape (n, d) where d is one of (2, 3).\n        A set of n point coordinates.\n        Coordinates are assumed to lie in [-L / 2, L / 2].\n    L: float.\n        Bounds of the system.\n    R_cut: float.\n        The maximum distance within which to consider points to lie\n        near each other.\n\n    Returns\n    -------\n    inters: array, shape (n, n)\n        Indices of the nearby points.\n        For each particle indexed by the first axis,\n        the second axis lists each index of a nearby point.\n    intersi: array, shape (n,)\n        Total number of nearby points.\n        This array should be used to index `inters`, as for point `i`,\n        elements in `inters[i]` beyond `intersi[i]` have no well-defined value.\n    '''\n    _cell_list.cell_list_direct.make_inters(r.T, L, R_cut)\n    return _parse_inters()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef json_serial(cls, obj):\n\n        if isinstance(obj, datetime):\n            serial = obj.isoformat()\n\n        elif issubclass(obj.__class__, enum.Enum):\n            serial = obj.value\n\n        elif isinstance(obj, timedelta):\n            serial = str(obj)\n\n        elif isinstance(obj, set):\n            serial = list(x for x in obj)\n\n        elif isinstance(obj, uuid.UUID):\n            serial = str(obj)\n\n        # FIXME: if you want to add one more custom serializer, think twice about `singledispatch`\n\n        else:\n            raise TypeError(\"Type not serializable %s in %s\" % (type(obj), obj))\n\n        return serial", "response": "JSON serializer for objects not serializable by default json code"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nruns on_plugin_install script for specified plugin directory.", "response": "def on_plugin_install(plugin_directory, ostream=sys.stdout):\n    '''\n    Run ``on_plugin_install`` script for specified plugin directory (if\n    available).\n\n    **TODO** Add support for Linux, OSX.\n\n    Parameters\n    ----------\n    plugin_directory : str\n        File system to plugin directory.\n    ostream :file-like\n        Output stream for status messages (default: ``sys.stdout``).\n    '''\n    current_directory = os.getcwd()\n\n    plugin_directory = ph.path(plugin_directory).realpath()\n    print >> ostream, ('Processing post-install hook for: '\n                        '{}'.format(plugin_directory.name))\n\n    hooks_dir_i = plugin_directory.joinpath('hooks/Windows').realpath()\n    hook_path_i = hooks_dir_i.joinpath('on_plugin_install.bat')\n\n    if hook_path_i.isfile():\n        logger.info('Processing post-install hook for: %s',\n                    plugin_directory.name)\n        os.chdir(hook_path_i.parent)\n        try:\n            process = sp.Popen([hook_path_i, sys.executable], shell=True,\n                               stdin=sp.PIPE)\n            # Emulate return key press in case plugin uses\n            # \"Press <enter> key to continue...\" prompt.\n            process.communicate(input='\\r\\n')\n            if process.returncode != 0:\n                raise RuntimeError('Process return code == {}'\n                                   .format(process.returncode))\n            return hook_path_i\n        except Exception, exception:\n            raise RuntimeError('Error running: {}\\n{}'.format(hook_path_i,\n                                                              exception))\n        finally:\n            os.chdir(current_directory)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef register(type, parser, composer, **meta):\n    return default_bank.register(type, parser, composer, **meta)", "response": "Registers a parser and composer of a format."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef cli_certify_core_number(\n    config, min_value, max_value, value,\n):\n    \"\"\"Console script for certify_number\"\"\"\n    verbose = config['verbose']\n    if verbose:\n        click.echo(Back.GREEN + Fore.BLACK + \"ACTION: certify-int\")\n\n    def parser(v):\n        # Attempt a json/pickle decode:\n        try:\n            v = load_json_pickle(v, config)\n        except Exception:\n            pass\n\n        # Attempt a straight conversion to float or integer:\n        try:\n            if v.find('.') != -1:\n                # Assume is float:\n                v = float(v)\n            else:\n                # Assume is int:\n                v = int(v)\n            return v\n        except Exception as err:\n            six.raise_from(\n                CertifierTypeError(\n                    message='Not integer or float: {v}'.format(\n                        v=v,\n                    ),\n                    value=v,\n                ),\n                err,\n            )\n\n    execute_cli_command(\n        'number',\n        config,\n        parser,\n        certify_number,\n        value[0] if value else None,\n        min_value=min_value,\n        max_value=max_value,\n        required=config['required'],\n    )", "response": "Console script for certify_core_number"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets token when needed.", "response": "def token(self):\n        \" Get token when needed.\"\n\n        if hasattr(self, '_token'):\n            return getattr(self, '_token')\n\n        # Json formatted auth.\n        data = json.dumps({'customer_name': self.customer,\n                           'user_name': self.username,\n                           'password': self.password})\n\n        # Start session.\n        response = requests.post(\n            'https://api2.dynect.net/REST/Session/', data=data,\n            headers={'Content-Type': 'application/json'})\n\n        # convert to data.\n        content = json.loads(response.content)\n\n        if response.status_code != 200:\n            # Check for errors.\n            if self.check_error(content, 'failure', 'INVALID_DATA'):\n                raise self.CredentialsError(\n                    self.response_message(content, 'ERROR'))\n\n            raise self.Failure(self.response_message(content, 'ERROR'),\n                               'Unhandled failure')\n\n        # Extract token from content\n        if 'data' in content and 'token' in content['data']:\n            token = content['data']['token']\n        else:\n            raise self.AuthenticationError(response)\n\n        setattr(self, '_token', token)\n        return token"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nchecking an error in the response.", "response": "def check_error(self, response, status, err_cd):\n        \" Check an error in the response.\"\n\n        if 'status' not in response:\n            return False\n\n        if response['status'] != status:\n            return False\n\n        if 'msgs' not in response:\n            return False\n\n        if not isinstance(response['msgs'], list):\n            return False\n\n        for msg in response['msgs']:\n\n            if 'LVL' in msg and msg['LVL'] != 'ERROR':\n                continue\n\n            if 'ERR_CD' in msg and msg['ERR_CD'] == err_cd:\n                return True\n\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef check_errors(self, response):\n        \" Check some common errors.\"\n\n        # Read content.\n        content = response.content\n\n        if 'status' not in content:\n            raise self.GeneralError('We expect a status field.')\n\n        # Return the decoded content if status is success.\n        if content['status'] == 'success':\n            response._content = content\n            return\n\n        # Expect messages if some kind of error.\n        if 'msgs' not in content:\n            raise self.GeneralError('We expcet messages in case of error.')\n\n        try:\n            messages = list(content['msgs'])\n        except:\n            raise self.GeneralError(\"Messages must be a list.\")\n\n        # Try to found common errors in the response.\n        for msg in messages:\n\n            if 'LVL' in msg and msg['LVL'] == 'ERROR':\n\n                # Check if is a not found error.\n                if msg['ERR_CD'] == 'NOT_FOUND':\n                    raise self.NotFoundError(msg['INFO'])\n\n                # Duplicated target.\n                elif msg['ERR_CD'] == 'TARGET_EXISTS':\n                    raise self.TargetExistsError(msg['INFO'])\n\n                # Some other error.\n                else:\n                    raise self.DynectError(msg['INFO'])\n\n        raise self.GeneralError(\"We need at least one error message.\")", "response": "Check some common errors."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd a new address to a domain.", "response": "def add_address(self, fqdn, address, ttl=0):\n        \" Add a new address to a domain.\"\n\n        data = {'rdata': {'address': address}, 'ttl': str(ttl)}\n\n        # Make request.\n        response = self.post('/REST/ARecord/%s/%s' % (\n            self.zone, fqdn), data=data)\n\n        return Address(self, data=response.content['data'])"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the list of addresses of a single domain.", "response": "def list_address(self, domain):\n        \" Get the list of addresses of a single domain.\"\n\n        try:\n            response = self.get('/REST/ARecord/%s/%s' % (\n                self.zone, domain))\n        except self.NotFoundError:\n            return []\n\n        # Return a generator with the addresses.\n        addresses = response.content['data']\n        return [Address.from_url(self, uri) for uri in addresses]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef remove_address(self, fqdn, address):\n        \" Remove an address of a domain.\"\n\n        # Get a list of addresses.\n        for record in self.list_address(fqdn):\n            if record.address == address:\n                record.delete()\n                break", "response": "Remove an address of a domain."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef make_tstore_conn(params, **kwargs):\n    log.setLevel(params.get('log_level', __LOG_LEVEL__))\n    log.debug(\"\\n%s\", params)\n    params.update(kwargs)\n    try:\n        vendor = RdfwConnections['triplestore'][params.get('vendor')]\n    except KeyError:\n        vendor = RdfwConnections['triplestore']['blazegraph']\n    conn = vendor(**params)\n    return conn", "response": "Creates a connection to the tstore"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef setup_conn(**kwargs):\n    from rdfframework.configuration import RdfConfigManager\n    if kwargs.get(\"conn\"):\n        conn = kwargs['conn']\n    elif kwargs.get(\"tstore_def\"):\n        conn = make_tstore_conn(kwargs['tstore_def'])\n    elif kwargs.get(\"triplestore_url\"):\n        conn = RdfwConnections['triplestore']['blazegraph']( \\\n                kwargs['triplestore_url'])\n    elif kwargs.get(\"rdflib\"):\n        conn = RdfwConnections['triplestore']['rdflib'](kwargs.get('rdflib'))\n    elif RdfConfigManager().data_tstore and \\\n            not isinstance(RdfConfigManager().data_tstore, EmptyDot):\n        conn = ConnManager().datastore\n    elif RdfConfigManager().TRIPLESTORE_URL and \\\n            not isinstance(RdfConfigManager().TRIPLESTORE_URL, EmptyDot):\n        conn = RdfwConnections['triplestore']['blazegraph'](\\\n                RdfConfigManager().TRIPLESTORE_URL)\n    else:\n        conn = RdfwConnections['triplestore']['blazegraph']()\n    return conn", "response": "returns a triplestore connection based on the kwargs"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ntaking a connection creates the connection", "response": "def set_conn(self, **kwargs):\n        \"\"\" takes a connection and creates the connection \"\"\"\n\n        # log = logging.getLogger(\"%s.%s\" % (self.log, inspect.stack()[0][3]))\n        log.setLevel(kwargs.get('log_level',self.log_level))\n\n        conn_name = kwargs.get(\"name\")\n        if not conn_name:\n            raise NameError(\"a connection requires a 'name': %s\" % kwargs)\n        elif self.conns.get(conn_name):\n            raise KeyError(\"connection '%s' has already been set\" % conn_name)\n\n        if not kwargs.get(\"active\", True):\n            log.warning(\"Connection '%s' is set as inactive\" % conn_name)\n            return\n        conn_type = kwargs.get(\"conn_type\")\n        if not conn_type or conn_type not in self.conn_mapping.nested:\n            err_msg = [\"a connection requires a valid 'conn_type':\\n\",\n                       \"%s\"]\n            raise NameError(\"\".join(err_msg) % (list(self.conn_mapping.nested)))\n        log.info(\"Setting '%s' connection\", conn_name)\n        if conn_type == \"triplestore\":\n            conn = make_tstore_conn(kwargs)\n        else:\n            conn = RdfwConnections[conn_type][kwargs['vendor']](**kwargs)\n        self.conns[conn_name] = conn\n        self.__is_initialized__ = True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get(self, conn_name, default=None, **kwargs):\n\n        if isinstance(conn_name, RdfwConnections):\n            return conn_name\n        try:\n            return self.conns[conn_name]\n        except KeyError:\n            if default:\n                return self.get(default, **kwargs)\n            raise LookupError(\"'%s' connection has not been set\" % conn_name)", "response": "returns the specified connection"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ntake a list of connections and sets them in the manager", "response": "def load(self, conn_list, **kwargs):\n        \"\"\" Takes a list of connections and sets them in the manager\n\n        args:\n            conn_list: list of connection defitions\n        \"\"\"\n        for conn in conn_list:\n            conn['delay_check'] = kwargs.get('delay_check', False)\n            self.set_conn(**conn)\n        if kwargs.get('delay_check'):\n            test = self.wait_for_conns(**kwargs)\n            if not test:\n                log.critical(\"\\n\\nEXITING:Unable to establish connections \\n\"\n                             \"%s\", test)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef failing(self):\n        log_levels = {key: conn.log_level for key, conn in self.conns.items()\n                      if hasattr(conn, 'log_level')}\n        for key in log_levels:\n            self.conns[key].log_level = logging.CRITICAL\n        failing_conns = {key: conn for key, conn in self.active.items()\n                         if not conn.check_status}\n        for key, level in log_levels.items():\n            self.conns[key].log_level = level\n        return failing_conns", "response": "Tests to see if all connections are working\n           "}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndelays unitil all connections are working args: timeout: number of seconds to try to connecting. Error out when timeout is reached start_delay: number of seconds to wait before checking status interval: number of seconds to wait between checks", "response": "def wait_for_conns(self, timeout=60, start_delay=0, interval=5, **kwargs):\n        ''' delays unitil all connections are working\n\n            args:\n                timeout: number of seconds to try to connecting. Error out when\n                        timeout is reached\n                start_delay: number of seconds to wait before checking status\n                interval: number of seconds to wait between checks\n        '''\n        log.setLevel(kwargs.get('log_level',self.log_level))\n        timestamp = time.time()\n        last_check = time.time() + start_delay - interval\n        last_delay_notification = time.time() - interval\n        timeout += 1\n        failing = True\n        up_conns = {}\n        # loop until the server is up or the timeout is reached\n        while((time.time()-timestamp) < timeout) and failing:\n            # if delaying, the start of the check, print waiting to start\n            if start_delay > 0 and time.time() - timestamp < start_delay \\\n                    and (time.time()-last_delay_notification) > 5:\n                print(\"Delaying server status check until %ss. Current time: %ss\" \\\n                        % (start_delay, int(time.time() - timestamp)))\n                last_delay_notification = time.time()\n            # check status at the specified 'interval' until the server is up\n            first_check = True\n            while ((time.time()-last_check) > interval) and failing:\n                msg = [\"\\tChecked status of servers at %ss\" % \\\n                        int((time.time()-timestamp)),\n                       \"\\t** CONNECTION STATUS:\"]\n                last_check = time.time()\n                failing = self.failing\n                new_up = (self.active.keys() - failing.keys()) - \\\n                          up_conns.keys()\n                msg += [\"\\t\\t UP - %s: %s\" % (key, self.conns[key])\n                       for key in new_up]\n                up_conns.update({key: self.conns[key] for key in new_up})\n                msg.append(\"\\t*** '%s' connection(s) up\" % len(up_conns))\n                msg += [\"\\t\\t FAILING - %s: %s\" % (key, self.conns[key])\n                        for key in failing]\n                log.info(\"** CONNECTION STATUS:\\n%s\", \"\\n\".join(msg))\n                if not failing:\n                    log.info(\"**** Servers up at %ss\" % \\\n                        int((time.time()-timestamp)))\n                    break\n        if failing:\n            raise RuntimeError(\"Unable to establish connection(s): \",\n                               failing)\n        for conn in up_conns.values():\n            conn.delay_check_pass()\n        return not failing"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef active(self):\n        return {key: value for key, value in self.conns.items()\n                if value.active}", "response": "returns a dictionary of connections set as active."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates a new entry in the cluster.", "response": "def __create(self, account_id, name, short_description, amount, period,\n                 **kwargs):\n        \"\"\"Call documentation: `/subscription_plan/create\n        <https://www.wepay.com/developer/reference/subscription_plan#create>`_,\n        plus extra keyword parameters:\n        \n        :keyword str access_token: will be used instead of instance's\n           ``access_token``, with ``batch_mode=True`` will set `authorization`\n           param to it's value.\n\n        :keyword bool batch_mode: turn on/off the batch_mode, see \n           :class:`wepay.api.WePay`\n\n        :keyword str batch_reference_id: `reference_id` param for batch call,\n           see :class:`wepay.api.WePay`\n\n        :keyword str api_version: WePay API version, see\n           :class:`wepay.api.WePay`\n\n        \"\"\"\n        params = {\n            'account_id': account_id,\n            'name': name,\n            'short_description': short_description,\n            'amount': amount,\n            'period': period\n        }\n        return self.make_call(self.__create, params, kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncalls documentation: `/subscription_plan/delete <https://www.wepay.com/developer/reference/subscription_plan#delete>`_, plus extra keyword parameters: :keyword str access_token: will be used instead of instance's ``access_token``, with ``batch_mode=True`` will set `authorization` param to it's value. :keyword bool batch_mode: turn on/off the batch_mode, see :class:`wepay.api.WePay` :keyword str batch_reference_id: `reference_id` param for batch call, see :class:`wepay.api.WePay` :keyword str api_version: WePay API version, see :class:`wepay.api.WePay`", "response": "def __delete(self, subscription_plan_id, **kwargs):\n        \"\"\"Call documentation: `/subscription_plan/delete\n        <https://www.wepay.com/developer/reference/subscription_plan#delete>`_,\n        plus extra keyword parameters:\n        \n        :keyword str access_token: will be used instead of instance's\n           ``access_token``, with ``batch_mode=True`` will set `authorization`\n           param to it's value.\n\n        :keyword bool batch_mode: turn on/off the batch_mode, see \n           :class:`wepay.api.WePay`\n\n        :keyword str batch_reference_id: `reference_id` param for batch call,\n           see :class:`wepay.api.WePay`\n\n        :keyword str api_version: WePay API version, see\n           :class:`wepay.api.WePay`\n\n        \"\"\"\n        params = {\n            'subscription_plan_id': subscription_plan_id\n        }\n        return self.make_call(self.__delete, params, kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncalls documentation: `/subscription_plan/get_button <https://www.wepay.com/developer/reference/subscription_plan#get_button>`_, plus extra keyword parameters: :keyword str access_token: will be used instead of instance's ``access_token``, with ``batch_mode=True`` will set `authorization` param to it's value. :keyword bool batch_mode: turn on/off the batch_mode, see :class:`wepay.api.WePay` :keyword str batch_reference_id: `reference_id` param for batch call, see :class:`wepay.api.WePay` :keyword str api_version: WePay API version, see :class:`wepay.api.WePay`", "response": "def __get_button(self, account_id, button_type, **kwargs):\n        \"\"\"Call documentation: `/subscription_plan/get_button\n        <https://www.wepay.com/developer/reference/subscription_plan#get_button>`_,\n        plus extra keyword parameters:\n        \n        :keyword str access_token: will be used instead of instance's\n           ``access_token``, with ``batch_mode=True`` will set `authorization`\n           param to it's value.\n\n        :keyword bool batch_mode: turn on/off the batch_mode, see \n           :class:`wepay.api.WePay`\n\n        :keyword str batch_reference_id: `reference_id` param for batch call,\n           see :class:`wepay.api.WePay`\n\n        :keyword str api_version: WePay API version, see\n           :class:`wepay.api.WePay`\n\n        \"\"\"\n        params = {\n            'account_id': account_id,\n            'button_type': button_type\n        }\n        return self.make_call(self.__get_button, params, kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef __modify(self, subscription_plan_id, **kwargs):\n        params = {\n            'subscription_plan_id': subscription_plan_id\n        }\n        return self.make_call(self.__modify, params, kwargs)", "response": "Modify the internal state of a wePay instance s internal state."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef small_register_machine(rom_size = 50, ram_size = 200, flash_size = 500):\n\trom = memory.ROM(rom_size)\n\tram = memory.RAM(ram_size)\n\tflash = device.Flash(flash_size)\n\n\tproc = processor.Processor()\n\n\tproc.register_memory_device(rom)\n\tproc.register_memory_device(ram)\n\tproc.register_device(flash)\n\n\tregisters = [register.OutputRegister(\"out0\", sys.stdout),\n\t\tregister.Register(\"r0\"),\n\t\tregister.Register(\"r1\"),\n\t\tregister.Register(\"r2\"),\n\t\tregister.Register(\"r3\"),\n\t\tregister.Register(\"r4\"),\n\t\tregister.Register(\"r5\"),\n\t\tregister.Register(\"r6\"),\n\t\tregister.Register(\"r7\"),\n\t\tregister.Register(\"r8\"),\n\t\tregister.Register(\"r9\"),\n\t\tregister.Register(\"r10\"),\n\t\tregister.Register(\"r11\"),\n\t\tregister.Register(\"r12\"),\n\t\tregister.Register(\"r13\"),\n\t\tregister.Register(\"r14\")]\n\n\tfor r in registers:\n\t\tproc.add_register(r)\n\n\tfor command in basic_commands:\n\t\tproc.register_command(command)\n\n\treturn (proc, rom, ram, flash)", "response": "A small register machine with \n - > r0 - > r1 - > r2 - > r3 - > r4 - > r5 - > r6 - > r7 - > r14 - > r14 - > r14"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding a new vertex and update the attributes of the vertex.", "response": "def add_vertex(self, vertex, **attr):\r\n        \"\"\"\r\n        Add vertex and update vertex attributes\r\n        \"\"\"\r\n        self.vertices[vertex] = []\r\n        if attr:\r\n            self.nodes[vertex] = attr\r\n        self.pred[vertex] = []\r\n        self.succ[vertex] = []"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd an edge from u to v and update edge attributes.", "response": "def add_edge(self, u, v, **attr):\r\n        \"\"\"\r\n        Add an edge from u to v and update edge attributes\r\n        \"\"\"\r\n        if u not in self.vertices:\r\n            self.vertices[u] = []\r\n            self.pred[u] = []\r\n            self.succ[u] = []\r\n        if v not in self.vertices:\r\n            self.vertices[v] = []\r\n            self.pred[v] = []\r\n            self.succ[v] = []\r\n        vertex = (u, v)\r\n        self.edges[vertex] = {}\r\n        self.edges[vertex].update(attr)\r\n        self.vertices[u].append(v)\r\n        self.pred[v].append(u)\r\n        self.succ[u].append(v)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef remove_vertex(self, vertex):\r\n        try:\r\n            self.vertices.pop(vertex)\r\n            self.succ.pop(vertex)\r\n        except KeyError:\r\n            raise GraphInsertError(\"Vertex %s doesn't exist.\" % (vertex,))\r\n        if vertex in self.nodes:\r\n            self.nodes.pop(vertex)\r\n        for element in self.vertices:\r\n            if vertex in self.vertices[element]:\r\n                self.vertices[element].remove(vertex)\r\n        edges = []  # List for edges that include vertex\r\n        for element in self.edges:\r\n            if vertex in element:\r\n                edges.append(element)\r\n        for element in edges:\r\n            del self.edges[element]\r\n        for element in self.pred:\r\n            if vertex in self.pred[element]:\r\n                self.pred[element].remove(vertex)\r\n        for element in self.succ:\r\n            if vertex in self.succ[element]:\r\n                self.succ[element].remove(vertex)", "response": "Remove vertex from G\r\n           ."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nchecks if vertex u has successor v", "response": "def has_successor(self, u, v):\r\n        \"\"\"\r\n        Check if vertex u has successor v\r\n        \"\"\"\r\n        if u not in self.vertices:\r\n            raise GraphInsertError(\"Vertex %s doesn't exist.\" % (u,))\r\n        return (u in self.succ and v in self.succ[u])"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef has_predecessor(self, u, v):\r\n        if u not in self.vertices:\r\n            raise GraphInsertError(\"Vertex %s doesn't exist.\" % (u,))\r\n        return(u in self.pred and v in self.pred[u])", "response": "Check if vertex u has predecessor v"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef format_question(self, correct_answer, possible_wrong_answers, question, add_images_to_question=False):\n\n        # Lets randomly select some wrong answers\n        wrong_answers = random.sample(possible_wrong_answers, 2)\n\n        # Combine the selected wrong answers with the actual answer and shuffle\n        choices = [x for x in wrong_answers]\n        choices.append(correct_answer)\n        random.shuffle(choices)\n\n        # Format it all in a nice dict\n        question = {\n            'answer': correct_answer[0],\n            'question': question,\n            'choices': self.convert_choices_to_dict(choices)\n        }\n\n        if add_images_to_question is True:\n            question['images'] = get_type_links(correct_answer[0])\n\n        return question", "response": "Takes a set of values and converts it to a dict that matches what is expected as a return from self. ask."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ntaking a list of tuples and converts it to a list of dictionaries where each dictionary has a value and text key.", "response": "def convert_choices_to_dict(choices):\n        \"\"\" Takes a list of tuples and converts it to a list of dictionaries of\n        where each dictionary has a value and text key. This is the expected format\n        of question choices to be returned by self.ask()\n\n        :param convert_choices_to_dict:\n        :type convert_choices_to_dict: list\n\n        :return:\n        :rtype:\n        \"\"\"\n\n        formatted_choices = []\n\n        for x in choices:\n            formatted_choices.append({\n                'value': x[0],\n                'text': x[1],\n            })\n\n        return formatted_choices"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef format_header(frmt, return_len=False):\n    names = re.sub(\"{(.*?):.*?}\", r\"\\1\", frmt)\n    names = [i for i in names.split(\"|\") if i]\n    frmt_clean = re.sub(\"\\.\\df\", r\"\", frmt)                 # get read of floats i.e {:8.2f}\n    sizes = re.findall(r':(\\d+)', frmt_clean)\n    frmt_header = \"|{{:^{}}}\" * len(sizes) + \"|\"\n    header_frmt = frmt_header.format(*sizes)\n    header = header_frmt.format(*names)\n    header_len = len(header)\n    header = \"{}\\n{}\\n{}\\n\".format(\".\" * header_len, header, \".\" * header_len)\n    return header.strip() if return_len is False else (header.strip(), header_len)", "response": "creates a header string from a new style format string useful when printing dictionaries"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef chunks_str_frame(a_str, n=None, center=True):\n    if n is None:\n        n = len(a_str)\n    elif n > len(a_str) and center is True:\n        a_str = a_str.center(n)\n    spcs = \"\" if n == 1 or n == len(a_str) else \" \" * (n - (len(a_str) % n))\n    n = len(a_str) if n is None else n\n    r = chunks_str(a_str, n, \"\u2551\\n\u2551\")\n    return \"\u2554{}\u2557\\n\u2551{}{}\u2551\\n\u255a{}\u255d\".format('\u2550' * n, r, spcs, '\u2550' * n)", "response": "places a frame around a string"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nexpanding a compressed mac addres str ie ( AC8674075628 ) to mac address ie ( AC8674075628 ) also makes it lower case", "response": "def mac_expand(cls, mac, upper=True, lower=False):\n        \"\"\"expands a compressed mac addres str ie (AC8674075628) to mac address (AC:86:74:07:56:28) also makes it lower/upper case\"\"\"\n        mac = \":\".join([\"\".join(i) for i in zip(mac[::2], mac[1::2])])\n        return mac.upper() if upper else mac.lower() if lower else mac"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_view(self, request, **kwargs):\n        try:\n            return super(ClonedRepoAdmin, self).add_view(request, **kwargs)\n        except ValidationError:\n            # Rerender the form, having messaged the user.\n            return redirect(request.path)", "response": "A custom add_view to catch exceptions from save_model."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nperforming a git pull and redirect back to the repo.", "response": "def git_pull_view(self, request, repo_name):\n        \"\"\"Perform a git pull and redirect back to the repo.\"\"\"\n        LOG.info(\"Pull requested for %s.\" % repo_name)\n        repo = get_object_or_404(self.model, name=repo_name)\n        repo.pull()\n        self.message_user(request, \"Repo %s successfully updated.\" % repo_name,\n                          level=messages.SUCCESS)\n        return redirect('admin:registry_clonedrepo_change', repo_name)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef update_all_view(self, request):\n        LOG.info(\"Total update requested.\")\n        total_count = errors = 0\n        for repo in self.model.objects.all():\n            total_count += 1\n            try:\n                repo.pull()\n            except:\n                LOG.exception('While updating %s.' % repo)\n                errors += 1\n        msg = \"{0} repos successfully updated, {1} failed.\".format(total_count,\n                                                                   errors)\n        self.message_user(request, msg, level=messages.SUCCESS)\n        return redirect('admin:registry_clonedrepo_changelist')", "response": "Update all repositories and redirect back to the repo list."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef clean(self):\n        cleaned_data = super(NewRepoForm, self).clean()\n        origin_url = cleaned_data['origin_url']\n        origin_source = cleaned_data['origin_source']\n        if origin_source == 'origin_url' and not origin_url:\n            msg = 'Please provide an origin URL.'\n            self._errors['origin_url'] = self.error_class([msg])\n\n            del cleaned_data['origin_url']\n            del cleaned_data['origin_source']\n        elif origin_source == 'upstream':\n            upstream = settings.UPSTREAM_BOWER_REGISTRY\n            name = cleaned_data['name']\n            try:\n                upstream_pkg = bowerlib.get_package(upstream, name)\n            except IOError as exc:\n                msg = str(exc)\n                self._errors['origin_source'] = self.error_class([msg])\n            else:\n                if not upstream_pkg:\n                    msg = 'Upstream registry has no knowledge of %s.' % name\n                    self._errors['name'] = self.error_class([msg])\n\n                    del cleaned_data['name']\n                else:\n                    upstream_origin_url = upstream_pkg['url']\n                    cleaned_data['origin_url'] = upstream_origin_url\n\n        return cleaned_data", "response": "Validate the new repo form."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nactivate a translation for lang.", "response": "def activate(lang=None):\n    \"\"\"Activate a translation for lang.\n\nIf lang is None, then the language of locale.getdefaultlocale() is used.\nIf the translation file does not exist, the original messages will be used.\n\"\"\"\n    if lang is None:\n        lang = locale.getlocale()[0]\n    tr = gettext.translation(\"argparse\", os.path.join(locpath, \"locale\"),\n                             [lang], fallback=True)\n    argparse._ = tr.gettext\n    argparse.ngettext = tr.ngettext"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef run(self):\n        self._stop = False\n        while not self._stop:\n            have_sources = self._timers or self._readers or self._writers\n            if not self._processor.pending and not have_sources:\n                break\n            events = QEventLoop.AllEvents\n            if not self._processor.pending:\n                events |= QEventLoop.WaitForMoreEvents\n            self._qapp.processEvents(events)\n            if self._processor.pending:\n                self._processor.run()", "response": "Run until there are no more events."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nimporting the CSV file and create the record for the current locale.", "response": "def __import_csv(self):\n        \"\"\"\n        file format:\n        header\n        C\u00f3digo WMLB|C\u00f3digo WMHT|WMLB EN|WMLB PT|WMHT EN|WMHT PT|Nome do Campo|Tipo do Campo|Contexto|Local de Uso\n        primary_tag|auxiliary_tag|text_en|text_pt_br|auxiliary_text_en|auxiliary_text_pt_br|Nome do Campo|Tipo do Campo|Contexto|Local de Uso\n        0|1|2|3|4|5|6|7|8|9\n        \"\"\"\n        # valids = re.sub(r\"[^A-Za-z]+\", '', my_string)\n        # if \"c\u00f3digo\" in line, then it's header, ignore it\n        # type = re.sub(r\"[^A-Za-z]+\", '', line[0])\n        # auxiliary_type = re.sub(r\"[^A-Za-z]+\", '', line[1])\n        import sys\n        import csv\n\n        with open(self.csv_file, 'r') as f:\n            has_auxiliary_text = False\n            reader = csv.reader(f)\n            for row in reader:\n                # Translation Type\n                if len(row) == 2:\n                    translation_type_tag = None\n                    auxiliary_translation_type_tag = None\n                    has_auxiliary_text = False\n                    types_list = row[0].split(\"e\")\n                    translation_type_tag = types_list[0].strip()\n                    if len(types_list) == 2:\n                        auxiliary_translation_type_tag = types_list[1].strip()\n                        has_auxiliary_text = True\n                    self.__create_record(\"TranslationType\",\n                                         **{'tag': translation_type_tag,\n                                            'name': translation_type_tag,\n                                            'has_auxiliary_text': has_auxiliary_text,\n                                            'auxiliary_tag': auxiliary_translation_type_tag,\n                                            'name_en': translation_type_tag,\n                                            'name_pt_br': translation_type_tag})\n                else:\n                    if \"C\u00f3digo\" not in row[0] and len(row) > 1:\n                        if len(row) == 5:\n                            params_dict = {\n                                'type': re.sub(r\"[^A-Za-z]+\", '', row[0]),\n                                'tag': row[0],\n                                'text': row[1],\n                                'text_en': row[1],\n                                'text_pt_br': row[2],\n                            }\n                        else:\n                            params_dict = {\n                                'type': re.sub(r\"[^A-Za-z]+\", '', row[0]),\n                                'tag': row[0],\n                                'text': row[2],\n                                'text_en': row[2],\n                                'text_pt_br': row[3],\n                            }\n                            if has_auxiliary_text:\n                                params_dict.update({\n                                    'auxiliary_tag': row[1],\n                                    'auxiliary_text': row[4],\n                                    'auxiliary_text_en': row[4],\n                                    'auxiliary_text_pt_br': row[5]\n                                })\n                        self.__create_record(\"Translation\", **params_dict)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconvert class to namedtuple.", "response": "def to_namedtuple(self):\n        \"\"\"\n        Convert class to namedtuple.\n\n        Note:\n            This method is neccessary for AMQP communication.\n\n        Returns:\n            namedtuple: Representation of the class as simple structure.\n        \"\"\"\n        keys = filter(lambda x: not x.startswith(\"_\"), self.__dict__)\n        opt_nt = namedtuple(self.__class__.__name__, keys)\n        filtered_dict = dict(map(lambda x: (x, self.__dict__[x]), keys))\n\n        return opt_nt(**filtered_dict)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nconverting the object to a namedtuple.", "response": "def to_namedtuple(self):\n        \"\"\"\n        Convert class and all subclasses (:class:`Author`, :class:`Optionals`)\n        to namedtuple.\n\n        Note:\n            This method is neccessary for AMQP communication.\n\n        Returns:\n            namedtuple: Representation of the class as simple structure.\n        \"\"\"\n        keys = filter(lambda x: not x.startswith(\"_\"), self.__dict__)\n        opt_nt = namedtuple(self.__class__.__name__, keys)\n\n        filt_dict = dict(map(lambda x: (x, self.__dict__[x]), keys))\n\n        # convert Author objects to namedtuple\n        authors = []\n        for author in filt_dict[\"authors\"]:\n            authors.append(author.to_namedtuple())\n\n        filt_dict[\"authors\"] = authors\n\n        # convert optionals to namedtuple if set, or to None if not\n        if filt_dict[\"optionals\"]._any_set:\n            filt_dict[\"optionals\"] = filt_dict[\"optionals\"].to_namedtuple()\n        else:\n            filt_dict[\"optionals\"] = None\n\n        return opt_nt(**filt_dict)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating hash of the class.", "response": "def _get_hash(self):\n        \"\"\"\n        Create hash of the class.\n\n        Hash should be unique for given ebook, so ISBN is main component of the\n        hash if provided.\n\n        Returns:\n            str: Hash.\n        \"\"\"\n        if self.optionals and self.optionals.ISBN:\n            isbn = self.optionals.ISBN.replace(\"-\", \"\")\n\n            if len(isbn) <= 10:\n                return \"97880\" + isbn\n\n            return isbn\n\n        if self.optionals and self.optionals.EAN:\n            return self.optionals.EAN\n\n        return self.title + \",\".join(map(lambda x: x.name, self.authors))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef luriegold(R):\n\n    # subfunctions\n    def xtotril(x, idx, mat):\n        \"\"\"Create 'L' lower triangular matrix.\"\"\"\n        mat[idx] = x\n        return mat\n\n    def xtocorr(x, idx, mat):\n        L = xtotril(x, idx, mat)\n        C = np.dot(L, L.T)\n        return C, L\n\n    def objectivefunc(x, R, idx, mat):\n        C, _ = xtocorr(x, idx, mat)\n        f = np.sum((R - C)**2)\n        return f\n\n    def nlcon_diagone(x, idx, mat):\n        C, _ = xtocorr(x, idx, mat)\n        return np.diag(C) - 1\n\n    # dimension of the correlation matrix\n    d = R.shape[0]\n    n = int((d**2 + d) / 2.)\n\n    # other arguments\n    mat = np.zeros((d, d))  # the lower triangular matrix without values\n    idx = np.tril(np.ones((d, d)), k=0) > 0  # boolean matrix\n    # idx = np.tril_indices(d,k=0); #row/col ids (same result)\n\n    # start values of the optimization are Ones\n    x0 = np.ones(shape=(n, )) / n\n\n    # for each of the k factors, the sum of its d absolute params\n    # values has to be less than 1\n    condiag = {'type': 'eq', 'args': (idx, mat), 'fun': nlcon_diagone}\n\n    # optimization\n    algorithm = 'SLSQP'\n    opt = {'disp': False}\n\n    # run the optimization\n    results = scipy.optimize.minimize(\n        objectivefunc, x0,\n        args=(R, idx, mat),\n        constraints=[condiag],\n        method=algorithm,\n        options=opt)\n\n    # Compute Correlation Matrix\n    C, L = xtocorr(results.x, idx, mat)\n\n    # done\n    return C, L, results", "response": "This function is used to adjust a correlation matrix to be semipositive definite"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_driver(browser='firefox', args=None):\n    if browser not in BROWSER_MAPPING.keys():\n        raise RuntimeError(\"unknown browser %s. allowed: %s\" % (browser, \", \".join(BROWSER_MAPPING.keys())))\n    driver_cls = BROWSER_MAPPING.get(browser)\n    safe_args = {}\n    if args is not None:\n        expected_arguments = inspect.getargspec(driver_cls.__init__).args\n        expected_arguments.remove(\"self\")\n        for arg in expected_arguments:\n            if arg in args:\n                safe_args[arg] = args[arg]\n    return driver_cls(**safe_args)", "response": "Returns a new RemoteDriver instance for the given browser and arguments."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ngenerate datasets list to activate WorkItem", "response": "def generate_datasets_list(settings, argv):\n    \"\"\"\n    generate datasets list to activate\n\n    args:\n        settings: dictionary\n            from settings file\n        argv: list\n            from sys.argv\n    \"\"\"\n    datasets_string_list = settings[\"DATASETS_LIST\"]\n    datasets_list = []\n    if len(argv) == 2:\n        try:\n            datasets_items = datasets_string_list.iteritems()\n        except AttributeError:\n            datasets_items = datasets_string_list.items()\n        for key, val in datasets_items:\n            key_module = importlib.import_module(\n                settings[\"PYTHON_MODULE\"] + \".\" + key\n            )\n            for element in val:\n                datasets_list.append(\n                    (key, element, getattr(key_module, element)())\n                )\n    elif len(argv) > 2:\n        arguments = argv[2:]\n        for argument in arguments:\n            argument_list = argument.split(\".\")\n            key = \".\".join(argument_list[:-1])\n            key_module = importlib.import_module(\n                settings[\"PYTHON_MODULE\"] + \".\" + key\n            )\n            datasets_list.append(\n                (key, argument_list[-1],\n                 getattr(key_module, argument_list[-1])())\n            )\n    else:\n        print_help()\n    return datasets_list"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef manage(settingspath, root_dir, argv):\n    # add settings.json to environment variables\n    os.environ[ENV_VAR_SETTINGS] = settingspath\n    # add root_dir\n    os.environ[ENV_VAR_ROOT_DIR] = root_dir\n    # get datasets list\n    with open(settingspath) as settings_file:\n        settings = json.load(settings_file)\n    # manage args\n    datasets_list = generate_datasets_list(settings, argv)\n    if \"make-data-file\" == argv[1]:\n        make_data_file(datasets_list, argv)\n    elif \"parse-data\" == argv[1]:\n        parse_data(datasets_list, argv)\n    elif \"do-operations\" == argv[1]:\n        do_operations(datasets_list, argv)\n    else:\n        print_help()", "response": "Manage all processes and datasets"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef is_pathname_valid(pathname: str) -> bool:\n    # If this pathname is either not a string or is but is empty, this pathname\n    # is invalid.\n    try:\n        if not isinstance(pathname, str) or not pathname:\n            return False\n\n        # Strip this pathname's Windows-specific drive specifier (e.g., `C:\\`)\n        # if any. Since Windows prohibits path components from containing `:`\n        # characters, failing to strip this `:`-suffixed prefix would\n        # erroneously invalidate all valid absolute Windows pathnames.\n        _, pathname = os.path.splitdrive(pathname)\n\n        # Directory guaranteed to exist. If the current OS is Windows, this is\n        # the drive to which Windows was installed (e.g., the \"%HOMEDRIVE%\"\n        # environment variable); else, the typical root directory.\n        root_dirname = os.environ.get('HOMEDRIVE', 'C:') \\\n            if sys.platform == 'win32' else os.path.sep\n        assert os.path.isdir(root_dirname)   # ...Murphy and her ironclad Law\n\n        # Append a path separator to this directory if needed.\n        root_dirname = root_dirname.rstrip(os.path.sep) + os.path.sep\n\n        # Test whether each path component split from this pathname is valid or\n        # not, ignoring non-existent and non-readable path components.\n        for pathname_part in pathname.split(os.path.sep):\n            try:\n                os.lstat(root_dirname + pathname_part)\n            # If an OS-specific exception is raised, its error code\n            # indicates whether this pathname is valid or not. Unless this\n            # is the case, this exception implies an ignorable kernel or\n            # filesystem complaint (e.g., path not found or inaccessible).\n            #\n            # Only the following exceptions indicate invalid pathnames:\n            #\n            # * Instances of the Windows-specific \"WindowsError\" class\n            #   defining the \"winerror\" attribute whose value is\n            #   \"ERROR_INVALID_NAME\". Under Windows, \"winerror\" is more\n            #   fine-grained and hence useful than the generic \"errno\"\n            #   attribute. When a too-long pathname is passed, for example,\n            #   \"errno\" is \"ENOENT\" (i.e., no such file or directory) rather\n            #   than \"ENAMETOOLONG\" (i.e., file name too long).\n            # * Instances of the cross-platform \"OSError\" class defining the\n            #   generic \"errno\" attribute whose value is either:\n            #   * Under most POSIX-compatible OSes, \"ENAMETOOLONG\".\n            #   * Under some edge-case OSes (e.g., SunOS, *BSD), \"ERANGE\".\n            except OSError as exc:\n                if hasattr(exc, 'winerror'):\n                    if exc.winerror == ERROR_INVALID_NAME:\n                        return False\n                elif exc.errno in {errno.ENAMETOOLONG, errno.ERANGE}:\n                    return False\n    # If a \"TypeError\" exception was raised, it almost certainly has the\n    # error message \"embedded NUL character\" indicating an invalid pathname.\n    except TypeError as exc:\n        return False\n    # If no exception was raised, all path components and hence this\n    # pathname itself are valid. (Praise be to the curmudgeonly python.)\n    else:\n        return True", "response": "Checks if the given path name is valid for the current OS."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncheck whether the given path is creatable.", "response": "def is_path_creatable(pathname: str) -> bool:\n    \"\"\"Checks whether the given path is creatable.\n\n    Returns\n    -------\n    `True` if the current user has sufficient permissions to create the passed\n    pathname; `False` otherwise.\n    \"\"\"\n    # Parent directory of the passed path. If empty, we substitute the current\n    # working directory (CWD) instead.\n    dirname = os.path.dirname(pathname) or os.getcwd()\n    return os.access(dirname, os.W_OK)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nchecking whether the given path exists or is creatable.", "response": "def path_exists_or_creatable(pathname: str) -> bool:\n    \"\"\"Checks whether the given path exists or is creatable.\n\n    This function is guaranteed to _never_ raise exceptions.\n\n    Returns\n    -------\n    `True` if the passed pathname is a valid pathname for the current OS _and_\n    either currently exists or is hypothetically creatable; `False` otherwise.\n    \"\"\"\n    try:\n        # To prevent \"os\" module calls from raising undesirable exceptions on\n        # invalid pathnames, is_pathname_valid() is explicitly called first.\n        return is_pathname_valid(pathname) and (\n            os.path.exists(pathname) or is_path_creatable(pathname))\n    # Report failure on non-fatal filesystem complaints (e.g., connection\n    # timeouts, permissions issues) implying this path to be inaccessible. All\n    # other exceptions are unrelated fatal issues and should not be caught\n    # here.\n    except OSError:\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nchecks whether current user can create siblings of the given path.", "response": "def is_path_sibling_creatable(pathname: str) -> bool:\n    \"\"\"Checks whether current user can create siblings of the given path.\n\n    Returns\n    -------\n    `True` if the current user has sufficient permissions to create siblings\n    (i.e., arbitrary files in the parent directory) of the passed pathname;\n    `False` otherwise.\n    \"\"\"\n    # Parent directory of the passed path. If empty, we substitute the current\n    # working directory (CWD) instead.\n    dirname = os.path.dirname(pathname) or os.getcwd()\n\n    try:\n        # For safety, explicitly close and hence delete this temporary file\n        # immediately after creating it in the passed path's parent directory.\n        with tempfile.TemporaryFile(dir=dirname):\n            pass\n        return True\n    # While the exact type of exception raised by the above function depends on\n    # the current version of the Python interpreter, all such types subclass\n    # the following exception superclass.\n    except EnvironmentError:\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncheck if the passed pathname exists or is creatable on the current OS and return True if it exists.", "response": "def path_exists_or_creatable_portable(pathname: str) -> bool:\n    \"\"\"OS-portable check for whether current path exists or is creatable.\n\n    This function is guaranteed to _never_ raise exceptions.\n\n    Returns\n    ------\n    `True` if the passed pathname is a valid pathname on the current OS _and_\n    either currently exists or is hypothetically creatable in a cross-platform\n    manner optimized for POSIX-unfriendly filesystems; `False` otherwise.\n    \"\"\"\n    try:\n        # To prevent \"os\" module calls from raising undesirable exceptions on\n        # invalid pathnames, is_pathname_valid() is explicitly called first.\n        return is_pathname_valid(pathname) and (\n            os.path.exists(pathname) or is_path_sibling_creatable(pathname))\n    # Report failure on non-fatal filesystem complaints (e.g., connection\n    # timeouts, permissions issues) implying this path to be inaccessible. All\n    # other exceptions are unrelated fatal issues and should not be caught\n    # here.\n    except OSError:\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef Q(name):\n    retval = PApplet.getDeclaredField(name).get(Sketch.get_instance())\n    if isinstance(retval, (long, int)):\n        return float(retval)\n    else:\n        return retval", "response": "Gets a variable from the current sketch."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ninitialize the underlying PApplet and creates a frame for the current entry.", "response": "def run_sketch(self):\n        \"\"\"\n        Initialises the underlying PApplet and creates a frame ( using ``create_frame`` if\n        required ) to display it in.\n\n        \"\"\"\n        Sketch.instance = self\n        self.init()\n        frame = self.create_frame()\n        if frame:\n            frame.add(self)\n            frame.pack()\n            frame.visible = 1"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _get_source(link):\n    if link.startswith(\"http://\") or link.startswith(\"https://\"):\n        down = httpkie.Downloader()\n        return down.download(link)\n\n    if os.path.exists(link):\n        with open(link) as f:\n            return f.read()\n\n    raise UserWarning(\"html: '%s' is neither URL or data!\" % link)", "response": "Return source of the link whether it is filename or url."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _process_config_item(item, dirname):\n    item = copy.deepcopy(item)\n    html = item.get(\"html\", None)\n\n    if not html:\n        raise UserWarning(\"Can't find HTML source for item:\\n%s\" % str(item))\n\n    # process HTML link\n    link = html if \"://\" in html else os.path.join(dirname, html)\n    del item[\"html\"]\n\n    # replace $name with the actual name of the field\n    for key, val in item.items():\n        if \"notfoundmsg\" in val:\n            val[\"notfoundmsg\"] = val[\"notfoundmsg\"].replace(\"$name\", key)\n\n    return {\n        \"html\": _get_source(link),\n        \"link\": link,\n        \"vars\": item\n    }", "response": "Process one item from the configuration file which contains multiple items\n    saved as dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreads the YAML file with configuration and pointers to example data.", "response": "def read_config(file_name):\n    \"\"\"\n    Read YAML file with configuration and pointers to example data.\n\n    Args:\n        file_name (str): Name of the file, where the configuration is stored.\n\n    Returns:\n        dict: Parsed and processed data (see :func:`_process_config_item`).\n\n    Example YAML file::\n        html: simple_xml.xml\n        first:\n            data: i wan't this\n            required: true\n            notfoundmsg: Can't find variable $name.\n        second:\n            data: and this\n        ---\n        html: simple_xml2.xml\n        first:\n            data: something wanted\n            required: true\n            notfoundmsg: Can't find variable $name.\n        second:\n            data: another wanted thing\n    \"\"\"\n    dirname = os.path.dirname(\n        os.path.abspath(file_name)\n    )\n    dirname = os.path.relpath(dirname)\n\n    # create utf-8 strings, not unicode\n    def custom_str_constructor(loader, node):\n        return loader.construct_scalar(node).encode('utf-8')\n    yaml.add_constructor(u'tag:yaml.org,2002:str', custom_str_constructor)\n\n    config = []\n    with open(file_name) as f:\n        for item in yaml.load_all(f.read()):\n            config.append(\n                _process_config_item(item, dirname)\n            )\n\n    return config"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef hash(value, arg):\n    arg = str(arg).lower()\n    if sys.version_info >= (3,0):\n        value = value.encode(\"utf-8\")\n    if not arg in get_available_hashes():\n        raise TemplateSyntaxError(\"The %s hash algorithm does not exist. Supported algorithms are: %\" % (arg, get_available_hashes()))\n    try:\n        f = getattr(hashlib, arg)\n        hashed = f(value).hexdigest()\n    except Exception:\n        raise ValueError(\"The %s hash algorithm cannot produce a hex digest. Ensure that OpenSSL is properly installed.\" % arg)\n    return hashed", "response": "Returns a hex - digest of the passed in value for the hash algorithm given."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef paginator(context, adjacent_pages=2):\r\n    current_page = context.get('page')\r\n    paginator    = context.get('paginator')\r\n    if not paginator:\r\n        return\r\n    pages        = paginator.num_pages\r\n    current_range = range(current_page - adjacent_pages, current_page + adjacent_pages + 1)\r\n    page_numbers = [n for n in current_range if n > 0 and n <= pages]\r\n    slugtype = ''\r\n\r\n    if 'topic_slug' in context:\r\n        page_url = context[\"topic\"].get_short_url()\r\n        slugtype = 'topic'\r\n    elif 'forum_slug' in context:\r\n        page_url = '/forum/%s/' % context[\"forum_slug\"]\r\n        slugtype = 'forum'\r\n    else:\r\n        page_url = context['request'].get_full_path()\r\n\r\n    return {\r\n        \"is_paginated\": context[\"is_paginated\"],\r\n        \"page\": current_page,\r\n        \"pages\": pages,\r\n        \"page_obj\": context['page_obj'],\r\n        \"page_numbers\": page_numbers,\r\n        \"has_next\": context[\"page_obj\"].has_next(),\r\n        \"has_previous\": context[\"page_obj\"].has_previous(),\r\n        \"page_url\" : page_url,\r\n        'slugtype' : slugtype,\r\n    }", "response": "Returns a dictionary of fields that can be used in conjunction with the object_list generic view."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef parse_link(value):\n\n    links = []\n\n    replace_chars = ' \\'\"'\n\n    value = value.strip(replace_chars)\n    if not value:\n        return links\n\n    for val in re.split(', *<', value):\n        try:\n            url, params = val.split(';', 1)\n        except ValueError:\n            url, params = val, ''\n\n        link = {'url': url.strip('<> \\'\"')}\n\n        for param in params.split(';'):\n            try:\n                key, value = param.split('=')\n            except ValueError:\n                break\n\n            link[key.strip(replace_chars)] = value.strip(replace_chars)\n\n        links.append(link)\n\n    return links", "response": "Parse a link header value into a list of dicts."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef parse_headers_link(headers):\n\n    header = CaseInsensitiveDict(headers).get('link')\n\n    l = {}\n\n    if header:\n        links = parse_link(header)\n\n        for link in links:\n            key = link.get('rel') or link.get('url')\n            l[key] = link\n\n    return l", "response": "Returns the parsed header links of the response if any."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef run(self, cmd, timeout=None, key=None):\n        if not isinstance(cmd, list):\n            raise TypeError(\"cmd needs to be a list\")\n        if not all(isinstance(item, str) for item in cmd):\n            raise TypeError(\"cmd needs to be a list of strings\")\n        self.connect(timeout, key)\n        return self._run_ssh(cmd)", "response": "Run a command on the phablet device using ssh\n       "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nconnecting to the target device.", "response": "def connect(self, timeout=None, key=None):\n        \"\"\"\n        Perform one-time setup procedure.\n\n        :param timeout:\n            a timeout (in seconds) for device discovery\n        :param key:\n            a path to a public ssh key to use for connection\n\n        This method will allow you to execute :meth:`cmdline()`\n        repeatedly without incurring the extra overhead of the setup procedure.\n\n        Note that this procedure needs to be repeated whenever:\n        - the target device reboots\n        - the local adb server is restarted\n        - your ssh keys change\n\n        .. versionadded:: 0.2\n        \"\"\"\n        if self.port is not None:\n            return\n        self._wait_for_device(timeout)\n        self._setup_port_forwarding()\n        self._purge_known_hosts_entry()\n        self._copy_ssh_key(key)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef ssh_cmdline(self, cmd):\n        if not isinstance(cmd, list):\n            raise TypeError(\"cmd needs to be a list\")\n        if not all(isinstance(item, str) for item in cmd):\n            raise TypeError(\"cmd needs to be a list of strings\")\n        if self._port is None:\n            raise ProgrammingError(\"run connect() first\")\n        ssh_cmd = ['ssh']\n        for opt in self._get_ssh_options():\n            ssh_cmd.append('-o')\n            ssh_cmd.append(opt)\n        ssh_cmd.extend(['phablet@localhost', '--'])\n        ssh_cmd.extend(cmd)\n        _logger.debug(\"ssh_cmdline %r => %r\", cmd, ssh_cmd)\n        return ssh_cmd", "response": "Return the command line for the phablet command line."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the command line for rsync.", "response": "def rsync_cmdline(self, src, dest, *rsync_options):\n        \"\"\"\n        Get argument list for meth:`subprocess.Popen()` to run rsync.\n\n        :param src:\n            source file or directory\n        :param dest:\n            destination file or directory\n        :param rsync_options:\n            any additional arguments to pass to rsync, useful if you\n            want to pass '-a'\n        :returns:\n            argument list to pass as the first argument to subprocess.Popen()\n\n        .. note::\n            you must call :meth:`connect()` at least once\n            before calling this method.\n\n        This method returns the ``args`` argument (first argument) to\n        subprocess.Popen() required to rsync something over to the phablet\n        device. You can use it to construct your own connections, to intercept\n        command output or to setup any additional things that you may require.\n\n        .. versionadded:: 0.2\n        \"\"\"\n        if not all(isinstance(item, str) for item in rsync_options):\n            raise TypeError(\"cmd needs to be a list of strings\")\n        if self._port is None:\n            raise ProgrammingError(\"run connect() first\")\n        ssh_cmd = ['ssh']\n        for opt in self._get_ssh_options():\n            ssh_cmd.append('-o')\n            ssh_cmd.append(opt)\n        rsync_cmd = ['rsync', '-e', ' '.join(ssh_cmd),\n                     str(src), 'phablet@localhost:{}'.format(dest)]\n        rsync_cmd.extend(rsync_options)\n        _logger.debug(\"rsync_cmdline %r-> %r (with %s) => %r\",\n                      src, dest, ' '.join(rsync_options), rsync_cmd)\n        return rsync_cmd"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\npush some data onto the phablet device", "response": "def push(self, src, dest, timeout=None, key=None):\n        \"\"\"\n        Push (synchronize) some data onto the phablet device\n\n        :param src:\n            source file or directory\n        :param dest:\n            destination file or directory\n        :param timeout:\n            a timeout (in seconds) for device discovery\n        :param key:\n            a path to a public ssh key to use for connection\n        :returns:\n            the exit code of the command\n        \"\"\"\n        self.connect(timeout, key)\n        _logger.info(\"Pushing %r to %r\", src, dest)\n        return self._check_call(\n            self.rsync_cmdline(src, dest, '-a'))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef FromType(name, otype):\n        if otype.attrs is not None and len(otype.attrs):\n            raise NotImplementedError(\"for otype, options can't have attributs\")\n            #return VectorField(ftype)\n        elif otype.uniq:\n            return SetOption(name, otype)\n        elif otype.multi:\n            #XXX: dbl check needed?\n            #raise NotImplementedError(\"for now, options can't have multiple values\")\n            return ListOption(name, otype)\n        else:\n            return ValueOption(name, otype)", "response": "Factory for creating a convenient option to store a specific value from a given Type."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset the value of the option.", "response": "def set(self, value, parse=False):\n        \"\"\" Set the value of the option.\n        \n        One can also set the 'value' property:\n\n        >>> opt = ValueOption(\"oname\", Numeric(default=1,help=\"an option exemple\"))\n        >>> opt.value = 12\n        \n        :param value: the new value\n        \"\"\"\n        self.value = self.parse(value) if parse else value"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the option converted in a dictionary", "response": "def as_dict(self):\n        \"\"\" returns a dictionary view of the option\n        \n        :returns: the option converted in a dict\n        :rtype: dict\n        \"\"\"\n        opt_info = {}\n        opt_info[\"type\"] = \"value\"\n        opt_info[\"name\"] = self.name\n        opt_info[\"value\"] = self.value\n        opt_info[\"otype\"] = self.otype.as_dict()\n        #TODO: est-ce que l'on ne met pas a plat et les attr de otype et ceux de l'option\n        return opt_info"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef upsert_object_property(self, identifier, properties, ignore_constraints=False):\n        # Retrieve the object with the gievn identifier. This is a (sub-)class\n        # of ObjectHandle\n        obj = self.get_object(identifier)\n        if not obj is None:\n            # Modify property set of retrieved object handle. Raise exception if\n            # and of the upserts is not valid.\n            for key in properties:\n                value = properties[key]\n                # If the update affects an immutable property raise exception\n                if not ignore_constraints and key in self.immutable_properties:\n                    raise ValueError('update to immutable property: ' + key)\n                # Check whether the operation is an UPSERT (value != None) or\n                # DELETE (value == None)\n                if not value is None:\n                    obj.properties[key] = value\n                else:\n                    # DELETE. Make sure the property is not mandatory\n                    if not ignore_constraints and key in self.mandatory_properties:\n                        raise ValueError('delete mandatory property: ' + key)\n                    elif key in obj.properties:\n                        del obj.properties[key]\n            # Update object in database\n            self.replace_object(obj)\n        # Return object handle\n        return obj", "response": "Manipulate an object s property set. Inserts or updates properties in\n        given dictionary."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ndeletes the object with given identifier in the database.", "response": "def delete_object(self, identifier, erase=False):\n        \"\"\"Delete the entry with given identifier in the database. Returns the\n        handle for the deleted object or None if object identifier is unknown.\n\n        If the read-only property of the object is set to true a ValueError is\n        raised.\n\n        Parameters\n        ----------\n        identifier : string\n            Unique object identifier\n        erase : Boolean, optinal\n            If true, the record will be deleted from the database. Otherwise,\n            the active flag will be set to False to support provenance tracking.\n\n        Returns\n        -------\n        (Sub-class of)ObjectHandle\n        \"\"\"\n        # Get object to ensure that it exists.\n        db_object = self.get_object(identifier)\n        # Set active flag to False if object exists.\n        if db_object is None:\n            return None\n        # Check whether the read-only property is set to true\n        if PROPERTY_READONLY in db_object.properties:\n            if db_object.properties[PROPERTY_READONLY]:\n                raise ValueError('cannot delete read-only resource')\n        if erase:\n            # Erase object from database\n            self.collection.delete_many({\"_id\": identifier})\n        else:\n            # Delete object with given identifier by setting active flag\n            # to False\n            self.collection.update_one({\"_id\": identifier}, {'$set' : {'active' : False}})\n        # Return retrieved object or None if it didn't exist.\n        return db_object"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_object(self, identifier, include_inactive=False):\n        # Find all objects with given identifier. The result size is expected\n        # to be zero or one\n        query = {'_id': identifier}\n        if not include_inactive:\n            query['active'] = True\n        cursor = self.collection.find(query)\n        if cursor.count() > 0:\n            return self.from_dict(cursor.next())\n        else:\n            return None", "response": "Retrieve object with given identifier from the database."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates new entry in the database.", "response": "def insert_object(self, db_object):\n        \"\"\"Create new entry in the database.\n\n        Parameters\n        ----------\n        db_object : (Sub-class of)ObjectHandle\n        \"\"\"\n        # Create object using the  to_dict() method.\n        obj = self.to_dict(db_object)\n        obj['active'] = True\n        self.collection.insert_one(obj)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nlist all objects in the object store.", "response": "def list_objects(self, query=None, limit=-1, offset=-1):\n        \"\"\"List of all objects in the database. Optinal parameter limit and\n        offset for pagination. A dictionary of key,value-pairs can be given as\n        addictional query condition for document properties.\n\n        Parameters\n        ----------\n        query : Dictionary\n            Filter objects by property-value pairs defined by dictionary.\n        limit : int\n            Limit number of items in the result set\n        offset : int\n            Set offset in list (order as defined by object store)\n\n        Returns\n        -------\n        ObjectListing\n        \"\"\"\n        result = []\n        # Build the document query\n        doc = {'active' : True}\n        if not query is None:\n            for key in query:\n                doc[key] = query[key]\n        # Iterate over all objects in the MongoDB collection and add them to\n        # the result\n        coll = self.collection.find(doc).sort([('timestamp', pymongo.DESCENDING)])\n        count = 0\n        for document in coll:\n            # We are done if the limit is reached. Test first in case limit is\n            # zero.\n            if limit >= 0 and len(result) == limit:\n                break\n            if offset < 0 or count >= offset:\n                result.append(self.from_dict(document))\n            count += 1\n        return ObjectListing(result, offset, limit, coll.count())"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef replace_object(self, db_object):\n        # To enable provenance traces objects are not actually deleted from the\n        # database. Instead, their active flag is set to False.\n        obj = self.to_dict(db_object)\n        obj['active'] = True\n        self.collection.replace_one({'_id' : db_object.identifier, 'active' : True}, obj)", "response": "Update an existing object with the given object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef to_dict(self, db_obj):\n        # Base Json serialization for database objects\n        return {\n            '_id' : db_obj.identifier,\n            'timestamp' : str(db_obj.timestamp.isoformat()),\n            'properties' : db_obj.properties}", "response": "Create a Json - like dictionary for objects managed by this object\n            store."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndetermine the recipient message content and metadata and return it as a dict that can be Posted to the message sender", "response": "def compile_msg_payload(self, invite):\n        \"\"\" Determine recipient, message content, return it as\n        a dict that can be Posted to the message sender\n        \"\"\"\n        self.l.info(\"Compiling the outbound message payload\")\n        update_invite = False\n\n        # Determine the recipient address\n        if \"to_addr\" in invite.invite:\n            to_addr = invite.invite[\"to_addr\"]\n        else:\n            update_invite = True\n            to_addr = get_identity_address(invite.identity)\n\n        # Determine the message content\n        if \"content\" in invite.invite:\n            content = invite.invite[\"content\"]\n        else:\n            update_invite = True\n            content = settings.INVITE_TEXT\n\n        # Determine the metadata\n        if \"metadata\" in invite.invite:\n            metadata = invite.invite[\"metadata\"]\n        else:\n            update_invite = True\n            metadata = {}\n\n        msg_payload = {\n            \"to_addr\": to_addr,\n            \"content\": content,\n            \"metadata\": metadata\n        }\n\n        if update_invite is True:\n            self.l.info(\"Updating the invite.invite field\")\n            invite.invite = msg_payload\n            invite.save()\n\n        self.l.info(\"Compiled the outbound message payload\")\n        return msg_payload"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate a post request to the message sender", "response": "def send_message(self, payload):\n        \"\"\" Create a post request to the message sender\n        \"\"\"\n        self.l.info(\"Creating outbound message request\")\n        result = ms_client.create_outbound(payload)\n        self.l.info(\"Created outbound message request\")\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef run(self, invite_id, **kwargs):\n        self.l = self.get_logger(**kwargs)\n        self.l.info(\"Looking up the invite\")\n        invite = Invite.objects.get(id=invite_id)\n        msg_payload = self.compile_msg_payload(invite)\n        result = self.send_message(msg_payload)\n        self.l.info(\"Creating task to update invite after send\")\n        post_send_update_invite.apply_async(args=[invite_id])\n        self.l.info(\"Created task to update invite after send\")\n        return \"Message queued for send. ID: <%s>\" % str(result[\"id\"])", "response": "Sends a message about service rating to the invitee\n       "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef start(self):\n        # While the implemetation matches the description in the docstring\n        # conceptually, it always adds a new waiter and then calls\n        # _check_concurrent() to handle the various cases.\n        if self._limit < 0:\n            # Special case for no limit, never block.\n            return succeed(None)\n        elif self._limit == 0:\n            # Special case for limit of zero, always block forever.\n            return Deferred()\n        d = self._make_waiter()\n        self._check_concurrent()\n        return d", "response": "Start a concurrent operation."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef start(self, key):\n        start_d = self._get_limiter(key).start()\n        self._cleanup_limiter(key)\n        return start_d", "response": "Start a concurrent operation. This gets the concurrency limiter for the given key and starts a concurrent operation on it."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nstops a concurrent operation.", "response": "def stop(self, key):\n        \"\"\"\n        Stop a concurrent operation.\n\n        This gets the concurrency limiter for the given key (creating it if\n        necessary) and stops a concurrent operation on it. If the concurrency\n        limiter is empty, it is deleted.\n        \"\"\"\n        self._get_limiter(key).stop()\n        self._cleanup_limiter(key)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef fields_for(context, form, template=\"includes/form_fields.html\"):\n    context[\"form_for_fields\"] = form\n    return get_template(template).render(context)", "response": "Renders the fields for a form."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef gravatar_url(email, size=32):\n    bits = (md5(email.lower().encode(\"utf-8\")).hexdigest(), size)\n    return \"//www.gravatar.com/avatar/%s?s=%s&d=identicon&r=PG\" % bits", "response": "Return the full URL for a Gravatar given an email hash."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef metablock(parsed):\n    parsed = \" \".join(parsed.replace(\"\\n\", \"\").split()).replace(\" ,\", \",\")\n    return escape(strip_tags(decode_entities(parsed)))", "response": "Remove HTML tags entities and superfluous characters from\n    meta blocks."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef pagination_for(context, current_page, page_var=\"page\", exclude_vars=\"\"):\n    querystring = context[\"request\"].GET.copy()\n    exclude_vars = [v for v in exclude_vars.split(\",\") if v] + [page_var]\n    for exclude_var in exclude_vars:\n        if exclude_var in querystring:\n            del querystring[exclude_var]\n    querystring = querystring.urlencode()\n    return {\n        \"current_page\": current_page,\n        \"querystring\": querystring,\n        \"page_var\": page_var,\n    }", "response": "Returns a dictionary of pagination template and data for persisting querystring\n    in pagination links."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the search form with a list of models to use as choices for filtering the search by.", "response": "def search_form(context, search_model_names=None):\n    \"\"\"\n    Includes the search form with a list of models to use as choices\n    for filtering the search by. Models should be a string with models\n    in the format ``app_label.model_name`` separated by spaces. The\n    string ``all`` can also be used, in which case the models defined\n    by the ``SEARCH_MODEL_CHOICES`` setting will be used.\n    \"\"\"\n    template_vars = {\n        \"request\": context[\"request\"],\n    }\n    if not search_model_names or not settings.SEARCH_MODEL_CHOICES:\n        search_model_names = []\n    elif search_model_names == \"all\":\n        search_model_names = list(settings.SEARCH_MODEL_CHOICES)\n    else:\n        search_model_names = search_model_names.split(\" \")\n    search_model_choices = []\n    for model_name in search_model_names:\n        try:\n            model = apps.get_model(*model_name.split(\".\", 1))\n        except LookupError:\n            pass\n        else:\n            verbose_name = model._meta.verbose_name_plural.capitalize()\n            search_model_choices.append((verbose_name, model_name))\n    template_vars[\"search_model_choices\"] = sorted(search_model_choices)\n    return template_vars"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef thumbnail(image_url, width, height, upscale=True, quality=95, left=.5,\n              top=.5, padding=False, padding_color=\"#fff\"):\n    \"\"\"\n    Given the URL to an image, resizes the image using the given width\n    and height on the first time it is requested, and returns the URL\n    to the new resized image. If width or height are zero then original\n    ratio is maintained. When ``upscale`` is False, images smaller than\n    the given size will not be grown to fill that size. The given width\n    and height thus act as maximum dimensions.\n    \"\"\"\n\n    if not image_url:\n        return \"\"\n    try:\n        from PIL import Image, ImageFile, ImageOps\n    except ImportError:\n        return \"\"\n\n    image_url = unquote(str(image_url)).split(\"?\")[0]\n    if image_url.startswith(settings.MEDIA_URL):\n        image_url = image_url.replace(settings.MEDIA_URL, \"\", 1)\n    image_dir, image_name = os.path.split(image_url)\n    image_prefix, image_ext = os.path.splitext(image_name)\n    filetype = {\".png\": \"PNG\", \".gif\": \"GIF\"}.get(image_ext, \"JPEG\")\n    thumb_name = \"%s-%sx%s\" % (image_prefix, width, height)\n    if not upscale:\n        thumb_name += \"-no-upscale\"\n    if left != .5 or top != .5:\n        left = min(1, max(0, left))\n        top = min(1, max(0, top))\n        thumb_name = \"%s-%sx%s\" % (thumb_name, left, top)\n    thumb_name += \"-padded-%s\" % padding_color if padding else \"\"\n    thumb_name = \"%s%s\" % (thumb_name, image_ext)\n\n    # `image_name` is used here for the directory path, as each image\n    # requires its own sub-directory using its own name - this is so\n    # we can consistently delete all thumbnails for an individual\n    # image, which is something we do in filebrowser when a new image\n    # is written, allowing us to purge any previously generated\n    # thumbnails that may match a new image name.\n    thumb_dir = os.path.join(settings.MEDIA_ROOT, image_dir,\n                             settings.THUMBNAILS_DIR_NAME, image_name)\n    if not os.path.exists(thumb_dir):\n        try:\n            os.makedirs(thumb_dir)\n        except OSError:\n            pass\n\n    thumb_path = os.path.join(thumb_dir, thumb_name)\n    thumb_url = \"%s/%s/%s\" % (settings.THUMBNAILS_DIR_NAME,\n                              quote(image_name.encode(\"utf-8\")),\n                              quote(thumb_name.encode(\"utf-8\")))\n    image_url_path = os.path.dirname(image_url)\n    if image_url_path:\n        thumb_url = \"%s/%s\" % (image_url_path, thumb_url)\n\n    try:\n        thumb_exists = os.path.exists(thumb_path)\n    except UnicodeEncodeError:\n        # The image that was saved to a filesystem with utf-8 support,\n        # but somehow the locale has changed and the filesystem does not\n        # support utf-8.\n        from yacms.core.exceptions import FileSystemEncodingChanged\n        raise FileSystemEncodingChanged()\n    if thumb_exists:\n        # Thumbnail exists, don't generate it.\n        return thumb_url\n    elif not default_storage.exists(image_url):\n        # Requested image does not exist, just return its URL.\n        return image_url\n\n    f = default_storage.open(image_url)\n    try:\n        image = Image.open(f)\n    except:\n        # Invalid image format.\n        return image_url\n\n    image_info = image.info\n\n    # Transpose to align the image to its orientation if necessary.\n    # If the image is transposed, delete the exif information as\n    # not all browsers support the CSS image-orientation:\n    # - http://caniuse.com/#feat=css-image-orientation\n    try:\n        orientation = image._getexif().get(0x0112)\n    except:\n        orientation = None\n    if orientation:\n        methods = {\n           2: (Image.FLIP_LEFT_RIGHT,),\n           3: (Image.ROTATE_180,),\n           4: (Image.FLIP_TOP_BOTTOM,),\n           5: (Image.FLIP_LEFT_RIGHT, Image.ROTATE_90),\n           6: (Image.ROTATE_270,),\n           7: (Image.FLIP_LEFT_RIGHT, Image.ROTATE_270),\n           8: (Image.ROTATE_90,)}.get(orientation, ())\n        if methods:\n            image_info.pop('exif', None)\n            for method in methods:\n                image = image.transpose(method)\n\n    to_width = int(width)\n    to_height = int(height)\n    from_width = image.size[0]\n    from_height = image.size[1]\n\n    if not upscale:\n        to_width = min(to_width, from_width)\n        to_height = min(to_height, from_height)\n\n    # Set dimensions.\n    if to_width == 0:\n        to_width = from_width * to_height // from_height\n    elif to_height == 0:\n        to_height = from_height * to_width // from_width\n    if image.mode not in (\"P\", \"L\", \"RGBA\"):\n        try:\n            image = image.convert(\"RGBA\")\n        except:\n            return image_url\n    # Required for progressive jpgs.\n    ImageFile.MAXBLOCK = 2 * (max(image.size) ** 2)\n\n    # Padding.\n    if padding and to_width and to_height:\n        from_ratio = float(from_width) / from_height\n        to_ratio = float(to_width) / to_height\n        pad_size = None\n        if to_ratio < from_ratio:\n            pad_height = int(to_height * (float(from_width) / to_width))\n            pad_size = (from_width, pad_height)\n            pad_top = (pad_height - from_height) // 2\n            pad_left = 0\n        elif to_ratio > from_ratio:\n            pad_width = int(to_width * (float(from_height) / to_height))\n            pad_size = (pad_width, from_height)\n            pad_top = 0\n            pad_left = (pad_width - from_width) // 2\n        if pad_size is not None:\n            pad_container = Image.new(\"RGBA\", pad_size, padding_color)\n            pad_container.paste(image, (pad_left, pad_top))\n            image = pad_container\n\n    # Create the thumbnail.\n    to_size = (to_width, to_height)\n    to_pos = (left, top)\n    try:\n        image = ImageOps.fit(image, to_size, Image.ANTIALIAS, 0, to_pos)\n        image = image.save(thumb_path, filetype, quality=quality, **image_info)\n        # Push a remote copy of the thumbnail if MEDIA_URL is\n        # absolute.\n        if \"://\" in settings.MEDIA_URL:\n            with open(thumb_path, \"rb\") as f:\n                default_storage.save(unquote(thumb_url), File(f))\n    except Exception:\n        # If an error occurred, a corrupted image may have been saved,\n        # so remove it, otherwise the check for it existing will just\n        # return the corrupted image next time it's requested.\n        try:\n            os.remove(thumb_path)\n        except Exception:\n            pass\n        return image_url\n    return thumb_url", "response": "This function returns a URL that can be used to create a thumbnail of the given image."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef editable_loader(context):\n    user = context[\"request\"].user\n    template_vars = {\n        \"has_site_permission\": has_site_permission(user),\n        \"request\": context[\"request\"],\n    }\n    if (settings.INLINE_EDITING_ENABLED and\n            template_vars[\"has_site_permission\"]):\n        t = get_template(\"includes/editable_toolbar.html\")\n        template_vars[\"REDIRECT_FIELD_NAME\"] = REDIRECT_FIELD_NAME\n        template_vars[\"editable_obj\"] = context.get(\"editable_obj\",\n                                        context.get(\"page\", None))\n        template_vars[\"accounts_logout_url\"] = context.get(\n            \"accounts_logout_url\", None)\n        template_vars[\"toolbar\"] = t.render(Context(template_vars))\n        template_vars[\"richtext_media\"] = RichTextField().formfield(\n            ).widget.media\n    return template_vars", "response": "This function is used to load the in - line editing toolbar and controls."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ntake a value edited via the WYSIWYG editor and passes it through the RICHTEXT_FILTERS setting and returns it.", "response": "def richtext_filters(content):\n    \"\"\"\n    Takes a value edited via the WYSIWYG editor, and passes it through\n    each of the functions specified by the RICHTEXT_FILTERS setting.\n    \"\"\"\n    for filter_name in settings.RICHTEXT_FILTERS:\n        filter_func = import_dotted_path(filter_name)\n        content = filter_func(content)\n    return content"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds the required HTML to the parsed content for in - line editing.", "response": "def editable(parsed, context, token):\n    \"\"\"\n    Add the required HTML to the parsed content for in-line editing,\n    such as the icon and edit form if the object is deemed to be\n    editable - either it has an ``editable`` method which returns\n    ``True``, or the logged in user has change permissions for the\n    model.\n    \"\"\"\n    def parse_field(field):\n        field = field.split(\".\")\n        obj = context.get(field.pop(0), None)\n        attr = field.pop()\n        while field:\n            obj = getattr(obj, field.pop(0))\n            if callable(obj):\n                # Allows {% editable page.get_content_model.content %}\n                obj = obj()\n        return obj, attr\n\n    fields = [parse_field(f) for f in token.split_contents()[1:]]\n    if fields:\n        fields = [f for f in fields if len(f) == 2 and f[0] is fields[0][0]]\n    if not parsed.strip():\n        try:\n            parsed = \"\".join([str(getattr(*field)) for field in fields])\n        except AttributeError:\n            pass\n\n    if settings.INLINE_EDITING_ENABLED and fields and \"request\" in context:\n        obj = fields[0][0]\n        if isinstance(obj, Model) and is_editable(obj, context[\"request\"]):\n            field_names = \",\".join([f[1] for f in fields])\n            context[\"editable_form\"] = get_edit_form(obj, field_names)\n            context[\"original\"] = parsed\n            t = get_template(\"includes/editable_form.html\")\n            return t.render(context)\n    return parsed"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef try_url(url_name):\n    from warnings import warn\n    warn(\"try_url is deprecated, use the url tag with the 'as' arg instead.\")\n    try:\n        url = reverse(url_name)\n    except NoReverseMatch:\n        return \"\"\n    return url", "response": "Try to get the url from the url_name."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a list of models grouped by admin_menu_order.", "response": "def admin_app_list(request):\n    \"\"\"\n    Adopted from ``django.contrib.admin.sites.AdminSite.index``.\n    Returns a list of lists of models grouped and ordered according to\n    ``yacms.conf.ADMIN_MENU_ORDER``. Called from the\n    ``admin_dropdown_menu`` template tag as well as the ``app_list``\n    dashboard widget.\n    \"\"\"\n    app_dict = {}\n\n    # Model or view --> (group index, group title, item index, item title).\n    menu_order = {}\n    for (group_index, group) in enumerate(settings.ADMIN_MENU_ORDER):\n        group_title, items = group\n        for (item_index, item) in enumerate(items):\n            if isinstance(item, (tuple, list)):\n                item_title, item = item\n            else:\n                item_title = None\n            menu_order[item] = (group_index, group_title,\n                                item_index, item_title)\n\n    # Add all registered models, using group and title from menu order.\n    for (model, model_admin) in admin.site._registry.items():\n        opts = model._meta\n        in_menu = not hasattr(model_admin, \"in_menu\") or model_admin.in_menu()\n        if hasattr(model_admin, \"in_menu\"):\n            import warnings\n            warnings.warn(\n                'ModelAdmin.in_menu() has been replaced with '\n                'ModelAdmin.has_module_permission(request). See '\n                'https://docs.djangoproject.com/en/stable/ref/contrib/admin/'\n                '#django.contrib.admin.ModelAdmin.has_module_permission.',\n                DeprecationWarning)\n        in_menu = in_menu and model_admin.has_module_permission(request)\n        if in_menu and request.user.has_module_perms(opts.app_label):\n            admin_url_name = \"\"\n            if model_admin.has_change_permission(request):\n                admin_url_name = \"changelist\"\n                change_url = admin_url(model, admin_url_name)\n            else:\n                change_url = None\n            if model_admin.has_add_permission(request):\n                admin_url_name = \"add\"\n                add_url = admin_url(model, admin_url_name)\n            else:\n                add_url = None\n            if admin_url_name:\n                model_label = \"%s.%s\" % (opts.app_label, opts.object_name)\n                try:\n                    app_index, app_title, model_index, model_title = \\\n                        menu_order[model_label]\n                except KeyError:\n                    app_index = None\n                    try:\n                        app_title = opts.app_config.verbose_name.title()\n                    except AttributeError:\n                        # Third party admin classes doing weird things.\n                        # See GH #1628\n                        app_title = \"\"\n                    model_index = None\n                    model_title = None\n                else:\n                    del menu_order[model_label]\n\n                if not model_title:\n                    model_title = capfirst(model._meta.verbose_name_plural)\n\n                if app_title not in app_dict:\n                    app_dict[app_title] = {\n                        \"index\": app_index,\n                        \"name\": app_title,\n                        \"models\": [],\n                    }\n                app_dict[app_title][\"models\"].append({\n                    \"index\": model_index,\n                    \"perms\": model_admin.get_model_perms(request),\n                    \"name\": model_title,\n                    \"object_name\": opts.object_name,\n                    \"admin_url\": change_url,\n                    \"add_url\": add_url\n                })\n\n    # Menu may also contain view or url pattern names given as (title, name).\n    for (item_url, item) in menu_order.items():\n        app_index, app_title, item_index, item_title = item\n        try:\n            item_url = reverse(item_url)\n        except NoReverseMatch:\n            continue\n        if app_title not in app_dict:\n            app_dict[app_title] = {\n                \"index\": app_index,\n                \"name\": app_title,\n                \"models\": [],\n            }\n        app_dict[app_title][\"models\"].append({\n            \"index\": item_index,\n            \"perms\": {\"custom\": True},\n            \"name\": item_title,\n            \"admin_url\": item_url,\n        })\n\n    app_list = list(app_dict.values())\n    sort = lambda x: (x[\"index\"] if x[\"index\"] is not None else 999, x[\"name\"])\n    for app in app_list:\n        app[\"models\"].sort(key=sort)\n    app_list.sort(key=sort)\n    return app_list"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef admin_dropdown_menu(context):\n    template_vars = context.flatten()\n    user = context[\"request\"].user\n    if user.is_staff:\n        template_vars[\"dropdown_menu_app_list\"] = admin_app_list(\n            context[\"request\"])\n        if user.is_superuser:\n            sites = Site.objects.all()\n        else:\n            try:\n                sites = user.sitepermissions.sites.all()\n            except ObjectDoesNotExist:\n                sites = Site.objects.none()\n        template_vars[\"dropdown_menu_sites\"] = list(sites)\n        template_vars[\"dropdown_menu_selected_site_id\"] = current_site_id()\n        template_vars[\"settings\"] = context[\"settings\"]\n        template_vars[\"request\"] = context[\"request\"]\n        return template_vars", "response": "Renders the admin dropdown menu navigation."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef dashboard_column(context, token):\n    column_index = int(token.split_contents()[1])\n    output = []\n    for tag in settings.DASHBOARD_TAGS[column_index]:\n        t = Template(\"{%% load %s %%}{%% %s %%}\" % tuple(tag.split(\".\")))\n        output.append(t.render(context))\n    return \"\".join(output)", "response": "Returns the dashboard column for the given token."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ntranslate the current URL for the given language code.", "response": "def translate_url(context, language):\n    \"\"\"\n    Translates the current URL for the given language code, eg:\n\n        {% translate_url de %}\n    \"\"\"\n    try:\n        request = context[\"request\"]\n    except KeyError:\n        return \"\"\n    view = resolve(request.path)\n    current_language = translation.get_language()\n    translation.activate(language)\n    try:\n        url = reverse(view.func, args=view.args, kwargs=view.kwargs)\n    except NoReverseMatch:\n        try:\n            url_name = (view.url_name if not view.namespace\n                        else '%s:%s' % (view.namespace, view.url_name))\n            url = reverse(url_name, args=view.args, kwargs=view.kwargs)\n        except NoReverseMatch:\n            url_name = \"admin:\" + view.url_name\n            url = reverse(url_name, args=view.args, kwargs=view.kwargs)\n    translation.activate(current_language)\n    if context['request'].META[\"QUERY_STRING\"]:\n        url += \"?\" + context['request'].META[\"QUERY_STRING\"]\n    return url"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef validate(self, value):\n\n        # check choices\n        if self.choices:\n            if isinstance(self.choices[0], (list, tuple)):\n                option_keys = [k for k, v in self.choices]\n                if value not in option_keys:\n                    msg = ('Value {0} is not listed among valid choices {1}'.format(value, option_keys))\n                    self.raise_error(msg)\n            elif value not in self.choices:\n                msg = ('Value {0} is not listed among valid choices {1}'.format(value, self.choices))\n                self.raise_error(msg)", "response": "Performs validation of the value.\n        :param value: value to validate\n        :raise ValidationError if the value is invalid"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nmaking sure that value is of the right type", "response": "def validate(self, value):\n        \"\"\"Make sure that value is of the right type \"\"\"\n        if not isinstance(value, self.nested_klass):\n            self.raise_error('NestedClass is of the wrong type: {0} vs expected {1}'\n                             .format(value.__class__.__name__, self.nested_klass.__name__))\n        super(NestedDocumentField, self).validate(value)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef validate(self, value):\n        if not isinstance(value, (list, tuple)) or isinstance(value, str_types):\n            self.raise_error('Only lists and tuples may be used in the ListField vs provided {0}'\n                             .format(type(value).__name__))\n        super(ListField, self).validate(value)", "response": "Make sure that the inspected value is of type list or tuple"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef validate(self, value):\n        if not isinstance(value, dict):\n            self.raise_error('Only Python dict may be used in the DictField vs provided {0}'\n                             .format(type(value).__name__))\n        super(DictField, self).validate(value)", "response": "Make sure that the inspected value is of type dict"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the current locale", "response": "def get(self):\n        \"\"\"\n        *do the frankenstein magic!*\n        \"\"\"\n        self.log.info('starting the ``get`` method')\n\n        self._copy_folder_and_get_directory_listings()\n        self._join_all_filenames_and_text()\n        self._collect_placeholders_required()\n        self._populate_dynamic_placeholders()\n        self._fill_placeholders_from_settings()\n        self._request_remaining_placeholders()\n        self._populate_placeholders_in_files()\n        self._move_template_to_destination(ignoreExisting=self.ignoreExisting)\n\n        self.log.info('completed the ``get`` method')\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _copy_folder_and_get_directory_listings(\n            self):\n        \"\"\"\n        *copy template folder to /tmp and get directory listings*\n        \"\"\"\n        self.log.info(\n            'starting the ``_copy_folder_and_get_directory_listings`` method')\n\n        # COPY TEMPLATE STRUCTURE TO /tmp/\n        basename = os.path.basename(self.pathToTemplate)\n        tmpPath = \"/tmp/%(basename)s\" % locals()\n        try:\n            shutil.rmtree(tmpPath)\n        except:\n            pass\n        shutil.copytree(self.pathToTemplate, tmpPath)\n\n        directoryContents = recursive_directory_listing(\n            log=self.log,\n            baseFolderPath=tmpPath,\n            whatToList=\"all\"  # all | files | dirs\n        )\n\n        self.directoryContents = directoryContents\n        self.tmpPath = tmpPath\n\n        self.log.info(\n            'completed the ``_copy_folder_and_get_directory_listings`` method')\n        return None", "response": "Copy the template folder to tmp and get the directory listings"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncollects the required placeholders from the content string and return the dict of the keys that are required for the new entry", "response": "def _collect_placeholders_required(\n            self):\n        \"\"\"\n        *collect placeholders required from filename etc*\n        \"\"\"\n        self.log.info('starting the ``_collect_placeholders_required`` method')\n\n        phs = self.settings[\"frankenstein\"][\"placeholder delimiters\"]\n        phsString = \"|\".join(phs)\n\n        matchObject = re.finditer(\n            r'(%(phsString)s)([^\\s]*?)\\1' % locals(),\n            string=self.contentString,\n            flags=re.S  # re.S\n        )\n\n        phDict = {}\n        for match in matchObject:\n            phDict[match.group(2)] = None\n\n        self.phDict = phDict\n\n        self.log.info(\n            'completed the ``_collect_placeholders_required`` method')\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _join_all_filenames_and_text(\n            self):\n        \"\"\"\n        *join all file names, driectory names and text content together*\n        \"\"\"\n        self.log.info('starting the ``_join_all_filenames_and_text`` method')\n\n        contentString = u\"\"\n        for i in self.directoryContents:\n            contentString += u\"%(i)s\\n\" % locals()\n            if os.path.isfile(os.path.join(i)):\n                if i[-4:] in [\".png\", \".jpg\", \".gif\"]:\n                    continue\n                readFile = codecs.open(i, encoding='ISO-8859-1', mode='r')\n                if \".DS_Store\" in i:\n                    continue\n                data = readFile.read()\n                contentString += u\"%(data)s\\n\" % locals()\n                readFile.close()\n\n        self.contentString = contentString\n\n        self.log.info('completed the ``_join_all_filenames_and_text`` method')\n        return None", "response": "This method joins all file names driectory names and text content together and returns the new contentString attribute."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _populate_dynamic_placeholders(\n            self):\n        \"\"\"\n        *populate dynamic placeholders - times etc*\n        \"\"\"\n        self.log.info('starting the ``_populate_dynamic_placeholders`` method')\n\n        from datetime import datetime, date, time\n        now = datetime.now()\n\n        dynamicPhs = {\n            \"now-ymd\": now.strftime(\"%Y%m%d\"),\n            \"now-ymdhms\": now.strftime(\"%Y%m%dt%H%M%S\"),\n            \"now-date\": now.strftime(\"%B %e, %Y\"),\n            \"now-datetime\": now.strftime(\"%B %e, %Y %I:%M \") + now.strftime(\"%p\").lower(),\n            \"now-time\": now.strftime(\"%I:%M \") + now.strftime(\"%p\").lower(),\n            \"now-hms\": now.strftime(\"%H%M%S\"),\n            \"now-year\": now.strftime(\"%Y\")\n        }\n\n        for k, v in self.phDict.iteritems():\n            if k in dynamicPhs.keys():\n                self.phDict[k] = dynamicPhs[k]\n\n        self.log.info(\n            'completed the ``_populate_dynamic_placeholders`` method')\n        return None", "response": "populate the internal dictionary with dynamic placeholders - times etc *"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nfilling the placeholders in the dictionary with the values from the settings file", "response": "def _fill_placeholders_from_settings(\n            self):\n        \"\"\"\n        *fill placeholders from the placeholders in the settings file*\n        \"\"\"\n        self.log.info(\n            'starting the ``_fill_placeholders_from_settings`` method')\n\n        for k, v in self.phDict.iteritems():\n            if k in self.settings[\"frankenstein\"][\"fixed placeholders\"].keys():\n                self.phDict[k] = self.settings[\n                    \"frankenstein\"][\"fixed placeholders\"][k]\n\n        self.log.info(\n            'completed the ``_fill_placeholders_from_settings`` method')\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _request_remaining_placeholders(\n            self):\n        \"\"\"\n        *request remaining placeholders needing populated from the user*\n        \"\"\"\n        self.log.info(\n            'starting the ``_request_remaining_placeholders`` method')\n\n        phNeeded = False\n        for k, v in self.phDict.iteritems():\n            if not v:\n                phNeeded = True\n\n        if phNeeded == False:\n            return\n\n        print \"please add your placeholder values ...\"\n\n        for k, v in self.phDict.iteritems():\n            if not v:\n                v = raw_input(\"%(k)s? \\n  >  \" % locals())\n                self.phDict[k] = v\n\n        self.log.info(\n            'completed the ``_request_remaining_placeholders`` method')\n        return None", "response": "request remaining placeholders needing populated from the user"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _move_template_to_destination(\n            self,\n            ignoreExisting=False):\n        \"\"\"\n        *move template to destination*\n\n        **Key Arguments:**\n            # -\n\n        **Return:**\n            - None\n\n        .. todo::\n\n            - @review: when complete, clean _move_template_to_destination method\n            - @review: when complete add logging\n        \"\"\"\n        self.log.info('starting the ``_move_template_to_destination`` method')\n\n        # CREATE DIRECTORY STRUCTURE\n        sourceDirectories = recursive_directory_listing(\n            log=self.log,\n            baseFolderPath=self.tmpPath,\n            whatToList=\"dirs\"  # all | files | dirs\n        )\n\n        destinationDirectories = []\n        destinationDirectories = []\n        destinationDirectories[:] = [self.pathToDestination +\n                                     d.replace(self.tmpPath, \"\") for d in sourceDirectories]\n        for d in destinationDirectories:\n            # Recursively create missing directories\n            if not os.path.exists(d):\n                os.makedirs(d)\n\n        # CREATE NEW FILES\n        sourceFiles = recursive_directory_listing(\n            log=self.log,\n            baseFolderPath=self.tmpPath,\n            whatToList=\"files\"  # all | files | dirs\n        )\n        destinationFiles = []\n        destinationFiles = []\n        destinationFiles[:] = [self.pathToDestination +\n                               d.replace(self.tmpPath, \"\") for d in sourceFiles]\n\n        appendText = \"\"\n        for s, f in zip(sourceFiles, destinationFiles):\n            try:\n                readFile = codecs.open(f, encoding='ISO-8859-1', mode='r')\n                content = readFile.read()\n                readFile.close()\n                fileExists = True\n            except IOError:\n                fileExists = False\n            if fileExists == True and len(content) > 1 and ignoreExisting == False:\n                readFile = codecs.open(s, encoding='ISO-8859-1', mode='r')\n                content = readFile.read()\n                readFile.close()\n                appendText += \"\"\"\n## `%(f)s`\n\n```\n%(content)s \n```\n\n\"\"\" % locals()\n            else:\n                try:\n                    if ignoreExisting == False or (ignoreExisting == True and fileExists == False):\n                        self.log.debug(\"attempting to rename file %s to %s\" %\n                                       (s, f))\n                        shutil.move(s, f)\n                    else:\n                        pass\n                except Exception, e:\n                    self.log.error(\"could not rename file %s to %s - failed with this error: %s \" %\n                                   (s, f, str(e),))\n                    sys.exit(0)\n\n        # CREATE NOTE TO USER TO APPEND TEXT\n        if len(appendText) > 3:\n            appendText = \"\"\"\n# Text to Append to Pre-Existing Files\n\n%(appendText)s\n\"\"\" % locals()\n            writeFile = codecs.open(\n                \"/tmp/append.md\", encoding='ISO-8859-1', mode='w')\n            writeFile.write(appendText)\n            writeFile.close()\n            try:\n                cmd = \"\"\"open -a \"Marked 2\" /tmp/append.md\"\"\" % locals()\n                p = Popen(cmd, stdout=PIPE, stdin=PIPE, shell=True)\n                output = p.communicate()[0]\n                self.log.debug('output: %(output)s' % locals())\n            except:\n                pass\n\n        # REMOVE THE TMP FOLDER\n        shutil.rmtree(self.tmpPath)\n\n        self.log.info('completed the ``_move_template_to_destination`` method')\n        return None", "response": "move template to destination"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nupdates the status endpoint on ScraperWiki to the latest entry e. g.", "response": "def update_status(table_name=\"swdata\", date_column=\"date\"):\n    \"\"\"\n    Set the status endpoint on ScraperWiki to the latest entry e.g.\n    'Latest entry: 2013-10-01'\n    \"\"\"\n    status_text = 'Latest entry: {}'.format(\n        _get_most_recent_record(table_name, date_column))\n    L.info(status_text)\n\n    scraperwiki.status('ok', status_text)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef install_cache(expire_after=12 * 3600, cache_post=False):\n    allowable_methods = ['GET']\n    if cache_post:\n        allowable_methods.append('POST')\n    requests_cache.install_cache(\n        expire_after=expire_after,\n        allowable_methods=allowable_methods)", "response": "Installs the requests cache for the current request."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndownloads a URL and return a file - like object.", "response": "def download_url(url, back_off=True, **kwargs):\n    \"\"\"\n    Get the content of a URL and return a file-like object.\n    back_off=True provides retry\n    \"\"\"\n    if back_off:\n        return _download_with_backoff(url, as_file=True, **kwargs)\n    else:\n        return _download_without_backoff(url, as_file=True, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndownloads a file from a URL and return a file - like object.", "response": "def _download_without_backoff(url, as_file=True, method='GET', **kwargs):\n    \"\"\"\n    Get the content of a URL and return a file-like object.\n    \"\"\"\n    # Make requests consistently hashable for caching.\n    # 'headers' is handled by requests itself.\n    # 'cookies' and 'proxies' contributes to headers.\n    # 'files' and 'json' contribute to data.\n    for k in ['data', 'params']:\n        if k in kwargs and isinstance(kwargs[k], dict):\n            kwargs[k] = OrderedDict(sorted(kwargs[k].items()))\n\n    kwargs_copy = dict(kwargs)\n    if not _is_url_in_cache(method, url, **kwargs):\n        now = datetime.datetime.now()\n        _rate_limit_for_url(url, now)\n        _rate_limit_touch_url(url, now)\n\n    L.info(\"Download {}\".format(url))\n    if 'timeout' not in kwargs_copy:\n        kwargs_copy['timeout'] = _TIMEOUT\n    if 'headers' in kwargs_copy:\n        head_dict = CaseInsensitiveDict(kwargs_copy['headers'])\n        if 'user-agent' not in head_dict:\n            head_dict['user-agent'] = _USER_AGENT\n        kwargs_copy['headers'] = head_dict\n    else:\n        kwargs_copy['headers'] = CaseInsensitiveDict({'user-agent': _USER_AGENT})\n\n    response = requests.request(method, url, **kwargs_copy)\n\n    if logging.getLogger().isEnabledFor(logging.DEBUG):\n        # This can be slow on large responses, due to chardet.\n        L.debug('\"{}\"'.format(response.text))\n\n    response.raise_for_status()\n\n    if as_file:\n        return BytesIO(response.content)\n    else:\n        return response"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns True if request has been cached or False otherwise.", "response": "def _is_url_in_cache(*args, **kwargs):\n    \"\"\" Return True if request has been cached or False otherwise. \"\"\"\n    # Only include allowed arguments for a PreparedRequest.\n    allowed_args = inspect.getargspec(\n        requests.models.PreparedRequest.prepare).args\n    # self is in there as .prepare() is a method.\n    allowed_args.remove('self')\n\n    kwargs_cleaned = {}\n    for key, value in dict(kwargs).items():\n        if key in allowed_args:\n            kwargs_cleaned[key] = value\n\n    prepared_request = _prepare(*args, **kwargs_cleaned)\n    request_hash = _get_hash(prepared_request)\n    try:\n        return requests_cache.get_cache().has_key(request_hash)\n    except AttributeError as e:  # requests_cache not enabled\n        if str(e) == \"'Session' object has no attribute 'cache'\":\n            return False\n        raise"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add_logging(parser, log_format=LOG_FORMAT, log_level=LOG_LEVEL, color=True):\n    parser.set_defaults(log_level=log_level)\n    parser.add_argument('-v', dest='log_level', action=_LogLevelAddAction, const=1, help='use more verbose logging (stackable)')\n    parser.add_argument('-q', dest='log_level', action=_LogLevelAddAction, const=-1, help='use less verbose logging (stackable)')\n\n    root_logger = logging.getLogger()\n    root_logger.setLevel(log_level)\n\n    handler = logging.StreamHandler()  # using sys.stderr\n    if hasattr(sys.stderr, 'isatty') and sys.stderr.isatty():\n\n        class ColorAction(argparse.Action):\n            def __call__(self, parser, namespace, values, option_string=None):\n                setattr(namespace, self.dest, True)\n                handler.setFormatter(_ColorLogFormatter(log_format))\n\n        class NoColorAction(argparse.Action):\n            def __call__(self, parser, namespace, values, option_string=None):\n                setattr(namespace, self.dest, False)\n                handler.setFormatter(_NoColorLogFormatter(log_format))\n\n        parser.add_argument('--color', dest='color', action=ColorAction, nargs=0, help='use color in log (when available)')\n        parser.add_argument('--no-color', dest='color', action=NoColorAction, nargs=0, help='use no color in log')\n\n        if color:\n            formatter_class = _ColorLogFormatter\n        else:\n            formatter_class = _NoColorLogFormatter\n    else:\n        # Make the options available, but they don't do anything.\n        parser.add_argument('--color', dest='color', action='store_true', help='use color in log (when available)')\n        parser.add_argument('--no-color', dest='color', action='store_false', help='use no color in log')\n        formatter_class = _NoColorLogFormatter\n\n    handler.setFormatter(formatter_class(log_format))\n    root_logger.addHandler(handler)", "response": "Configure the argument parser with arguments to configure logging."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef assertHeader(self, name, value=None, *args, **kwargs):\n        return name in self.raw_headers and (\n            True if value is None else self.raw_headers[name] == value)", "response": "Returns True if name was in the headers and whether or not the values match."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nnegate of the presence of a HTTP header.", "response": "def assertNotHeader(self, name, value=None, *args, **kwargs):\n        \"\"\" Negation of :meth:`assertHeader`. \"\"\"\n        return not self.assertHeader(name, value)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef assertCookie(self, name, value=None, attrs={}, *args, **kwargs):\n        name = name.lower()\n        if name not in self.cookies:\n            return False\n        if value is not None and self.cookies[name][name] != value:\n            return False\n\n        cookie = self.cookies[name]\n        for k, v in attrs.items():\n            k = k.lower()\n            if k not in cookie or cookie[k] != v:\n                return False\n\n        return True", "response": "Checks if a cookie is present in the response and if it does not return False"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef assertNotCookie(self, name, value=None, attrs={}, *args, **kwargs):\n        return not self.assertCookie(name, value, attrs)", "response": "Negates of : meth : assertCookie."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef ConfigureLazyWorkers(self):\n    lazy_worker_instances = self.__GetMissingWorkers()\n    if not lazy_worker_instances:\n      return\n    reachable_states = self.__AreInstancesReachable(lazy_worker_instances)\n    reachable_instances = [t[0] for t in zip(lazy_worker_instances, \n                                             reachable_states) if t[1]]\n    print 'reachable_instances: %s' % reachable_instances \n    self.__ConfigureWorkers(reachable_instances)\n    return", "response": "Lazy workers are instances that are running and reachable but failed to \n    register with the cldb to join the mapr cluster. This trys to find these \n    missing workers and add them to the cluster."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nstarts a master node.", "response": "def __StartMaster(self):\n    \"\"\" Starts a master node, configures it, and starts services. \"\"\"    \n    num_masters = len(self.cluster.get_instances_in_role(\"master\", \"running\"))\n    assert(num_masters < 1)\n    logging.info( \"waiting for masters to start\")\n    if self.config.master_on_spot_instances:          \n      self.__LaunchSpotMasterInstances()\n    else:\n      self.__LaunchOnDemandMasterInstances()\n    time.sleep(1)\n    self.__ConfigureMaster()\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd workers evenly across all enabled zones.", "response": "def __AddWorkers(self, num_to_add):\n    \"\"\" Adds workers evenly across all enabled zones.\"\"\"                \n    # Check preconditions\n    assert(self.__IsWebUiReady())\n    zone_to_ips = self.__GetZoneToWorkerIpsTable()    \n    zone_old_new = []\n    for zone, ips in zone_to_ips.iteritems():\n      num_nodes_in_zone = len(ips) \n      num_nodes_to_add = 0\n      zone_old_new.append((zone, num_nodes_in_zone, num_nodes_to_add))    \n    print 'num_to_add %s' % num_to_add\n    for _ in range(num_to_add):\n      zone_old_new.sort(key= lambda z : z[1]+z[2])\n      zt = zone_old_new[0]\n      zone_old_new[0] = (zt[0], zt[1], zt[2]+1)\n    #print zone_old_new\n    zone_plan = [(zt[2], zt[0]) for zt in zone_old_new]\n    print 'resize plan'\n    if self.config.workers_on_spot_instances:\n      new_worker_instances = self.__LaunchSpotWorkerInstances(zone_plan)\n    else:  \n      new_worker_instances = self.__LaunchOnDemandWorkerInstances(zone_plan)\n    self.__WaitForInstancesReachable(new_worker_instances)\n    self.__ConfigureWorkers(new_worker_instances)\n    return"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef __IpsToServerIds(self):\n    master_instance = self.__GetMasterInstance()\n    assert(master_instance)\n    retval, response = self.__RunMaprCli('node list -columns id')\n    ip_to_id = {}\n    for line_num, line in enumerate(response.split('\\n')):\n      tokens = line.split()\n      if len(tokens) == 3 and tokens[0] != 'id':        \n        instance_id = tokens[0]\n        ip = tokens[2]\n        ip_to_id[ip] = instance_id\n    return ip_to_id", "response": "Get list of mapping of ip address into server id"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef __CleanUpCoresAlarm(self):\n    instances = self.__GetAllInstances()\n    clean_cores_cmd = \"\"\"sudo sh -c 'rm /opt/cores/*'\"\"\"\n    self.__RunCommandOnInstances(clean_cores_cmd, instances)\n    return", "response": "Disable core alarm.\n    Mapr signals an alarm in the web ui when there are files in a nodes \n    /opt/cores dir.  This is anoying because we can't see if there is a real \n    problem with the node because of this pointless error message.  \n    This removes those files so the alarm goes away."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef __CleanUpRootPartition(self):\n    instances = self.__GetAllInstances()\n    clean_cores_cmd = \"\"\"sudo sh -c 'rm -rf /opt/mapr/cache/tmp/*'\"\"\"\n    self.__RunCommandOnInstances(clean_cores_cmd, instances)\n    return", "response": "Clean up the root partition of the mapr instance."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef contents(self):\n        response = GettRequest().get(\"/files/%s/%s/blob\" % (self.sharename, self.fileid))\n\n        return response.response", "response": "This method downloads the contents of the file represented by a GettFile object."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef thumbnail(self):\n        response = GettRequest().get(\"/files/%s/%s/blob/thumb\" % (self.sharename, self.fileid))\n\n        return response.response", "response": "This method returns a thumbnail representation of the file if the data is a supported graphics format."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef upload_url(self):\n        if self.put_upload_url:\n            return self.put_upload_url\n        else:\n            response = GettRequest().get(\"/files/%s/%s/upload?accesstoken=%s\" % (self.sharename, self.fileid, self.user.access_token()))\n            if response.http_status == 200:\n                return response.response['puturl']", "response": "This method generates URLs which allow overwriting a file s content with new content."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef send_data(self, **kwargs):\n        put_url = None\n        if 'put_url' in kwargs:\n            put_url = kwargs['put_url']\n        else:\n            put_url = self.put_upload_url\n\n        if 'data' not in kwargs:\n            raise AttributeError(\"'data' parameter is required\")\n\n        if not put_url:\n            raise AttributeError(\"'put_url' cannot be None\")\n\n        if not isinstance(kwargs['data'], str):\n            raise TypeError(\"'data' parameter must be of type 'str'\")\n\n        response = GettRequest().put(put_url, kwargs['data'])\n\n        if response.http_status == 200:\n            return True", "response": "This method sends data to the Gett service."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nallowing using a generator to chain together reversible actions. This decorator may be added to a generator that yields reversible actions (any object with a ``.forwards()`` and ``.backwards()`` method). These may be constructed manually or via :py:func:`reversible.action`. The decorated function, when called, will return another reversible action that runs all yielded actions and if any of them fails, rolls back all actions that had been executed *in the reverse order*. Values can be returned by raising the :py:class:`reversible.Return` exception, or if using Python 3.3 or newer, by simply using the ``return`` statement. For example, .. code-block:: python @reversible.gen def submit_order(order): # CreateOrder is a class that declares a forwards() and # backwards() method. The forwards() method returns the # order_id. It is propagated back to the yield point. order_id = yield CreateOrder(order.cart) # If get_payment_info throws an exception, the order will # be deleted and the exeception will be re-raised to the # caller. payment_info = PaymentStore.get_payment_info(order.user_id) try: # charge_order is a function that returns an action. # It is easy to create such a function by using # reversible.action as a decorator. total = yield charge_order(payment_info, order_id) except InsufficientFundsException: # Exceptions thrown by a dependency's forwards() # method are propagated at the yield point. It's # possible to handle them and prevent rollback for # everything else. send_insufficient_funds_email(order_id, order.user_id) else: yield update_receipt(order_id, total) send_receipt(order_id) # The order ID is the result of this action. raise reversible.Return(order_id) order_id = reversible.execute(submit_order(order)) # If another action based on reversible.gen calls # submit_order, it can simply do: # # order_id = yield submit_order(order_details) When an action fails, its ``backwards`` method and the ``backwards`` methods of all actions executed so far will be called in reverse of the order in which the ``forwards`` methods were called. If any of the ``backwards`` methods fail, rollback will be aborted. :param function: The generator function. This generator must yield action objects. :returns: A function that, when called, produces an action object that executes actions and functions as yielded by the generator.", "response": "def gen(function):\n    \"\"\"\n    Allows using a generator to chain together reversible actions.\n\n    This decorator may be added to a generator that yields reversible actions\n    (any object with a ``.forwards()`` and ``.backwards()`` method). These may\n    be constructed manually or via :py:func:`reversible.action`. The decorated\n    function, when called, will return another reversible action that runs all\n    yielded actions and if any of them fails, rolls back all actions that had\n    been executed *in the reverse order*.\n\n    Values can be returned by raising the :py:class:`reversible.Return`\n    exception, or if using Python 3.3 or newer, by simply using the ``return``\n    statement.\n\n    For example,\n\n    .. code-block:: python\n\n        @reversible.gen\n        def submit_order(order):\n            # CreateOrder is a class that declares a forwards() and\n            # backwards() method. The forwards() method returns the\n            # order_id. It is propagated back to the yield point.\n            order_id = yield CreateOrder(order.cart)\n\n            # If get_payment_info throws an exception, the order will\n            # be deleted and the exeception will be re-raised to the\n            # caller.\n            payment_info = PaymentStore.get_payment_info(order.user_id)\n\n            try:\n                # charge_order is a function that returns an action.\n                # It is easy to create such a function by using\n                # reversible.action as a decorator.\n                total = yield charge_order(payment_info, order_id)\n            except InsufficientFundsException:\n                # Exceptions thrown by a dependency's forwards()\n                # method are propagated at the yield point. It's\n                # possible to handle them and prevent rollback for\n                # everything else.\n                send_insufficient_funds_email(order_id, order.user_id)\n            else:\n                yield update_receipt(order_id, total)\n                send_receipt(order_id)\n\n            # The order ID is the result of this action.\n            raise reversible.Return(order_id)\n\n        order_id = reversible.execute(submit_order(order))\n\n        # If another action based on reversible.gen calls\n        # submit_order, it can simply do:\n        #\n        #    order_id = yield submit_order(order_details)\n\n    When an action fails, its ``backwards`` method and the ``backwards``\n    methods of all actions executed so far will be called in reverse of the\n    order in which the ``forwards`` methods were called.\n\n    If any of the ``backwards`` methods fail, rollback will be aborted.\n\n    :param function:\n        The generator function. This generator must yield action objects.\n    :returns:\n        A function that, when called, produces an action object that executes\n        actions and functions as yielded by the generator.\n    \"\"\"\n\n    @functools.wraps(function)  # TODO: use wrapt instead?\n    def new_function(*args, **kwargs):\n        try:\n            value = function(*args, **kwargs)\n        except Return as result:\n            return SimpleAction(\n                lambda ctx: ctx.value,\n                lambda _: None,\n                result,\n            )\n        else:\n            if isinstance(value, types.GeneratorType):\n                return _GeneratorAction(value)\n            else:\n                return SimpleAction(\n                    lambda _: value,\n                    lambda _: None,\n                    None,\n                )\n\n    return new_function"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef __signal(self, sig, verbose=None):\n        '''\n        Helper class preventing code duplication..\n\n        :param sig:\n            Signal to use (e.g. \"HUP\", \"ALRM\")\n        :param verbose:\n            Overwrite :func:`photon.Photon.m`'s `verbose`\n        :returns:\n            |kill_return| with specified `pid`\n\n        .. |kill_return| replace::\n            :func:`photon.Photon.m`'s result of killing `pid`\n        .. |kill_verbose| replace:: with visible shell warning\n        '''\n        return self.m(\n            'killing process %s with \"%s\"' % (self.__pid, sig),\n            cmdd=dict(cmd='%s kill -%s %d' % (self.__sudo, sig, self.__pid)),\n            verbose=verbose\n        )", "response": "Signal the process with the specified signal."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef linreg_mle(y, X, algorithm='Nelder-Mead', debug=False):\n    import numpy as np\n    import scipy.stats as sstat\n    import scipy.optimize as sopt\n\n    def objective_nll_linreg(theta, y, X):\n        yhat = np.dot(X, theta[:-1])  # =X*beta\n        return -1.0 * sstat.norm.logpdf(y, loc=yhat, scale=theta[-1]).sum()\n\n    # check eligible algorithm\n    if algorithm not in ('Nelder-Mead', 'CG', 'BFGS'):\n        raise Exception('Optimization Algorithm not supported.')\n\n    # set start values\n    theta0 = np.ones((X.shape[1] + 1, ))\n\n    # run solver\n    results = sopt.minimize(\n        objective_nll_linreg,\n        theta0,\n        args=(y, X),\n        method=algorithm,\n        options={'disp': False})\n\n    # debug?\n    if debug:\n        return results\n\n    # done\n    return results.x[:-1]", "response": "MLE for Linear Regression Model"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef fill(self, paths):\n        for path in paths:\n            tree = self.tree\n            parts = tuple(path.split('/'))\n            dir_parts = parts[:-1]\n            built = ()\n            for part in dir_parts:\n                self.cache[built] = tree\n                built += (part, )\n                parent = tree\n                tree = parent.folders.get(part, empty)\n                if tree is empty:\n                    tree = parent.folders[part] = TreeItem(name=built, folders={}, files=set(), parent=parent)\n\n            self.cache[dir_parts] = tree\n            tree.files.add(parts[-1])", "response": "Initialise the tree with the tree items from a list of paths."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef remove(self, prefix, name):\n        tree = self.cache.get(prefix, empty)\n        if tree is empty:\n            return False\n\n        if name not in tree.files:\n            return False\n\n        tree.files.remove(name)\n        self.remove_folder(tree, list(prefix))\n\n        return True", "response": "Remove a path from the tree with the given prefix and name."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef remove_folder(self, tree, prefix):\n        while True:\n            child = tree\n            tree = tree.parent\n\n            if not child.folders and not child.files:\n                del self.cache[tuple(prefix)]\n                if tree:\n                    del tree.folders[prefix.pop()]\n\n            if not tree or tree.folders or tree.files:\n                break", "response": "Removes a folder from the tree."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef fmt_addr_raw(addr, reverse=True):\n    addr = addr.replace(':', '')\n    raw_addr = [int(addr[i:i+2], 16) for i in range(0, len(addr), 2)]\n    if reverse:\n        raw_addr.reverse()\n\n    # for Python 2, this needs to be a string instead of a bytearray\n    if sys.version_info[0] == 2:\n        return str(bytearray(raw_addr))\n    return bytearray(raw_addr)", "response": "Given a string containing a xx : xx : xx : xx : xx : xx format return as a bytearray."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef pp_hex(raw, reverse=True):\n    if not reverse:\n        return ''.join(['{:02x}'.format(v) for v in bytearray(raw)])\n    return ''.join(reversed(['{:02x}'.format(v) for v in bytearray(raw)]))", "response": "Return a pretty - printed hex version of a binary string."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning True if a user can manage a workshift semester.", "response": "def can_manage(user, semester=None, pool=None, any_pool=False):\n    \"\"\"\n    Whether a user is allowed to manage a workshift semester. This includes the\n    current workshift managers, that semester's workshift managers, and site\n    superusers.\n    \"\"\"\n    if semester and user in semester.workshift_managers.all():\n        return True\n\n    if Manager and Manager.objects.filter(\n            incumbent__user=user, workshift_manager=True,\n    ).count() > 0:\n        return True\n\n    if pool and pool.managers.filter(incumbent__user=user).count() > 0:\n        return True\n\n    if any_pool and WorkshiftPool.objects.filter(\n            managers__incumbent__user=user,\n    ):\n        return True\n\n    return user.is_superuser or user.is_staff"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_year_season(day=None):\n    if day is None:\n        day = date.today()\n    year = day.year\n\n    if day.month > 3 and day.month <= 7:\n        season = Semester.SUMMER\n    elif day.month > 7 and day.month <= 10:\n        season = Semester.FALL\n    else:\n        season = Semester.SPRING\n        if day.month > 10:\n            year += 1\n    return year, season", "response": "Returns a guess of the year and season of the current semester."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_semester_start_end(year, season):\n    if season == Semester.SPRING:\n        start_month, start_day = 1, 20\n        end_month, end_day = 5, 17\n    elif season == Semester.SUMMER:\n        start_month, start_day = 5, 25\n        end_month, end_day = 8, 16\n    else:\n        start_month, start_day = 8, 24\n        end_month, end_day = 12, 20\n\n    return date(year, start_month, start_day), date(year, end_month, end_day)", "response": "Returns a guess of the start and end dates for a given semester."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef is_available(workshift_profile, shift):\n    if shift.week_long:\n        return True\n\n    start_time = (\n        shift.start_time\n        if shift.start_time is not None\n        else time(hour=0)\n    )\n    end_time = (\n        shift.end_time\n        if shift.end_time is not None\n        else time(hour=23, minute=59)\n    )\n    relevant_blocks = list()\n\n    for block in workshift_profile.time_blocks.order_by('start_time'):\n        if block.day == shift.day and block.preference == TimeBlock.BUSY \\\n           and block.start_time < end_time \\\n           and block.end_time > start_time:\n            relevant_blocks.append(block)\n\n    # Time blocks should be ordered; so go through and see if there is a wide\n    # enough window for the workshifter to do the shift.  If there is,\n    # return True.\n    if not relevant_blocks:\n        return True\n\n    hours_delta = timedelta(hours=float(shift.hours))\n\n    # Check the time between shift start and block start\n    block = relevant_blocks.pop(0)\n    start_delta = timedelta(\n        hours=block.start_time.hour - start_time.hour,\n        minutes=block.start_time.minute - start_time.minute,\n    )\n\n    if start_delta >= hours_delta:\n        return True\n\n    while len(relevant_blocks) > 0:\n        block, prev_block = relevant_blocks.pop(0), block\n\n        # Check the time between the last block and the next block\n        # is larger than the length of the shift\n        start_end_delta = timedelta(\n            hours=block.start_time.hour - prev_block.end_time.hour,\n            minutes=block.start_time.minute - prev_block.end_time.minute,\n        )\n\n        if start_end_delta >= hours_delta:\n            return True\n\n    # Check the time between the end of the time block to the end of the shift\n    end_delta = timedelta(\n        hours=end_time.hour - block.end_time.hour,\n        minutes=end_time.minute - block.end_time.minute,\n    )\n\n    if end_delta >= hours_delta:\n        return True\n\n    return False", "response": "Check whether a user can do a specified workshift."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef auto_assign_shifts(semester=None, pool=None, profiles=None, shifts=None):\n    if semester is None:\n        try:\n            semester = Semester.objects.get(current=True)\n        except (Semester.DoesNotExist, Semester.MultipleObjectsReturned):\n            return\n    if pool is None:\n        pool = WorkshiftPool.objects.get(\n            semester=semester,\n            is_primary=True,\n        )\n    if profiles is None:\n        profiles = WorkshiftProfile.objects.filter(\n            semester=semester,\n        ).order_by('preference_save_time')\n    if shifts is None:\n        shifts = RegularWorkshift.objects.filter(\n            pool=pool,\n            workshift_type__assignment=WorkshiftType.AUTO_ASSIGN,\n        )\n\n    shifts = set([\n        shift\n        for shift in shifts\n        if shift.current_assignees.count() < shift.count\n    ])\n    profiles = list(profiles)\n\n    # List of hours assigned to each profile\n    hours_mapping = defaultdict(float)\n\n    # Pre-process, rank shifts by their times / preferences\n    rankings = defaultdict(set)\n\n    # Initialize with already-assigned shifts\n    for profile in profiles:\n        pool_hours = profile.pool_hours.get(pool=pool)\n        hours_mapping[profile] = float(pool_hours.assigned_hours)\n\n        for shift in shifts:\n            # Skip shifts that put a member over their hour requirement\n            added_hours = float(shift.hours) + hours_mapping[profile]\n            if added_hours > float(pool_hours.hours):\n                continue\n\n            # Check how well this shift fits the member's schedule\n            status = is_available(profile, shift)\n            if not status or status == TimeBlock.BUSY:\n                continue\n\n            try:\n                rating = profile.ratings.get(\n                    workshift_type=shift.workshift_type,\n                ).rating\n            except WorkshiftRating.DoesNotExist:\n                rating = WorkshiftRating.INDIFFERENT\n\n            if rating == WorkshiftRating.DISLIKE:\n                rank = 5\n            elif rating == WorkshiftRating.INDIFFERENT:\n                rank = 3\n            else:\n                rank = 1\n\n            if status != TimeBlock.PREFERRED:\n                rank += 1\n\n            rankings[profile, rank].add(shift)\n\n    # Assign shifts in a round-robin manner, run until we can't assign anyone\n    # any more shifts\n    while any(rankings.values()):\n        for profile in profiles[:]:\n            pool_hours = profile.pool_hours.get(pool=pool)\n\n            # Assign a shift, picking from the most preferable groups first\n            for rank in range(1, 7):\n                # Update the rankings with the list of available shifts\n                rankings[profile, rank].intersection_update(shifts)\n\n                if rankings[profile, rank]:\n                    # Select the shift, starting with those that take the most\n                    # hours and fit the best into the workshifter's allotted\n                    # hours\n                    shift = max(rankings[profile, rank], key=lambda x: x.hours)\n\n                    # Assign the person to their shift\n                    shift.current_assignees.add(profile)\n\n                    hours_mapping[profile] += float(shift.hours)\n\n                    # Remove shift from shifts if it has been completely filled\n                    if shift.current_assignees.count() >= shift.count:\n                        shifts.remove(shift)\n\n                    break\n\n            # Remove profiles when their hours have all been assigned\n            if float(pool_hours.hours) <= hours_mapping[profile]:\n                profiles.remove(profile)\n\n                for rank in range(1, 7):\n                    if (profile, rank) in rankings:\n                        del rankings[profile, rank]\n\n                continue\n\n            # Otherwise, Remove shifts that put people above their weekly\n            # allocation\n            for rank in range(1, 7):\n                rankings[profile, rank] = set(\n                    shift\n                    for shift in rankings[profile, rank]\n                    if float(shift.hours) + hours_mapping[profile] <=\n                    float(pool_hours.hours)\n                )\n\n    # Return profiles that were incompletely assigned shifts\n    return profiles", "response": "Auto - assigns profiles to regular workshifts."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nclearing all regular workshift assignments.", "response": "def clear_all_assignments(semester=None, pool=None, shifts=None):\n    \"\"\"\n    Clears all regular workshift assignments.\n\n    Parameters\n    ----------\n    semester : workshift.models.Semester, optional\n    pool : workshift.models.WorkshiftPool, optional\n        If set, grab workshifts from a specific pool. Otherwise, the primary\n        workshift pool will be used.\n    shifts : list of workshift.models.RegularWorkshift, optional\n    \"\"\"\n    if semester is None:\n        try:\n            semester = Semester.objects.get(current=True)\n        except (Semester.DoesNotExist, Semester.MultipleObjectsReturned):\n            return []\n    if pool is None:\n        pool = WorkshiftPool.objects.get(\n            semester=semester,\n            is_primary=True,\n        )\n    if shifts is None:\n        shifts = RegularWorkshift.objects.filter(\n            pool=pool,\n            is_manager_shift=False,\n            workshift_type__assignment=WorkshiftType.AUTO_ASSIGN,\n        )\n\n    for shift in shifts:\n        shift.current_assignees.clear()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef reset_standings(semester=None, pool_hours=None):\n    if semester is None:\n        try:\n            semester = Semester.objects.get(current=True)\n        except (Semester.DoesNotExist, Semester.MultipleObjectsReturned):\n            return\n    if pool_hours is None:\n        pool_hours = PoolHours.objects.filter(pool__semester=semester)\n\n    for hours in pool_hours:\n        hours.last_updated = None\n        hours.standing = hours.hour_adjustment\n\n        profile = WorkshiftProfile.objects.get(pool_hours=hours)\n\n        instances = WorkshiftInstance.objects.filter(\n            Q(weekly_workshift__pool=hours.pool) |\n            Q(info__pool=hours.pool),\n            Q(workshifter=profile) | Q(liable=profile),\n            closed=True,\n        )\n        for instance in instances:\n            if instance.blown:\n                hours.standing -= instance.hours\n            else:\n                hours.standing += instance.hours\n\n        hours.save(update_fields=[\"standing\", \"last_updated\"])\n\n    update_standings(\n        semester=semester,\n        pool_hours=pool_hours,\n    )", "response": "Utility function to recalculate the standings of a single resource in the manager shell."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef calculate_assigned_hours(semester=None, profiles=None):\n    if semester is None:\n        try:\n            semester = Semester.objects.get(current=True)\n        except (Semester.DoesNotExist, Semester.MultipleObjectsReturned):\n            return\n    if profiles is None:\n        profiles = WorkshiftProfile.objects.filter(semester=semester)\n\n    for profile in profiles:\n        for pool_hours in profile.pool_hours.all():\n            shifts = RegularWorkshift.objects.filter(\n                current_assignees=profile,\n                pool=pool_hours.pool,\n                active=True,\n            )\n            pool_hours.assigned_hours = sum(shift.hours for shift in shifts)\n            pool_hours.save(update_fields=[\"assigned_hours\"])", "response": "Utility function to recalculate the assigned workshift hours for a given semester and list of profiles."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef reset_instance_assignments(semester=None, shifts=None):\n    if semester is None:\n        try:\n            semester = Semester.objects.get(current=True)\n        except (Semester.DoesNotExist, Semester.MultipleObjectsReturned):\n            return\n    if shifts is None:\n        shifts = RegularWorkshift.objects.filter(\n            pool__semester=semester,\n        )\n\n    for shift in shifts:\n        instances = WorkshiftInstance.objects.filter(\n            closed=False,\n            weekly_workshift=shift,\n        ).order_by(\"date\")\n\n        assignees = list(shift.current_assignees.all())\n        assignees += [None] * (shift.count - len(assignees))\n        dates = defaultdict(set)\n\n        for assignee, instance in zip(cycle(assignees), instances):\n            if assignee is not None:\n                if instance.date in dates[assignee.pk]:\n                    continue\n\n                dates[assignee.pk].add(instance.date)\n\n            instance.workshifter = assignee\n            instance.liable = None\n            instance.save(update_fields=[\"workshifter\", \"liable\"])\n\n            instance.logs.add(\n                ShiftLogEntry.objects.create(\n                    person=instance.workshifter,\n                    entry_type=ShiftLogEntry.ASSIGNED,\n                    note=\"Manager reset assignment.\",\n                )\n            )", "response": "Utility function to reset instance assignments for a given semester and list of regular workshifts."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndetermines if a system process identifer exists in process table.", "response": "def pid_exists(pid):\n    \"\"\" Determines if a system process identifer exists in process table.\n        \"\"\"\n    try:\n        os.kill(pid, 0)\n    except OSError as exc:\n        return exc.errno == errno.EPERM\n    else:\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef daemonize(pid_file, working_dir, func):\n\n    def _fork():\n        \"\"\" Fork a child process.\n\n            Returns ``False`` if fork failed; otherwise,\n            we are inside the new child process.\n            \"\"\"\n        try:\n            pid = os.fork()\n            if pid > 0:\n                os._exit(0)  # exit parent\n            return True\n\n        except OSError:\n            return False\n\n    def _register_pidfile(filename):\n        \"\"\" Registers a pid file for the current process which will cleaned up\n            when the process terminates.\n\n            `filename`\n                Filename to save pid to.\n            \"\"\"\n        if common.writefile(filename, str(os.getpid()) + os.linesep):\n            os.chmod(filename, 0644)  # rw-r--r--\n\n            def _cleanup_pid():\n                \"\"\" Removes pidfile.\n                    \"\"\"\n                common.safe_remove_file(filename)\n            atexit.register(_cleanup_pid)\n\n    if not pid_file or not working_dir or not func:\n        return\n\n    if not os.path.isfile(pid_file):  # enforce pid lock file\n        # attempt first fork\n        if not _fork():\n            return\n\n        try:\n            # detach from current environment\n            os.chdir(working_dir)\n            os.setsid()\n            os.umask(0)\n\n        except OSError:\n            return\n\n        # attempt second fork\n        if not _fork():\n            return\n\n        # we'll ignore closing file descriptors..\n        # redirecting the streams should be sufficient\n\n        # redirect streams to /dev/null\n        _fd = os.open(os.devnull, os.O_RDWR)\n        os.dup2(_fd, sys.stdin.fileno())\n        os.dup2(_fd, sys.stdout.fileno())\n        os.dup2(_fd, sys.stderr.fileno())\n\n        # setup pidfile\n        _register_pidfile(pid_file)\n\n        # execute provided callable\n        func()", "response": "This function takes a pid file and a working directory and a function to run after the daemon starts."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef shell_focusd(data_dir):\n\n    command = 'focusd {0}'.format(data_dir)\n\n    # see what event hook plugins are registered\n    plugins = registration.get_registered(event_hooks=True)\n\n    if not plugins:  # none registered, bail\n        raise errors.NoPluginsRegistered\n\n    # do any of the plugins need root access?\n    # if so, wrap command with sudo to escalate privs, if not already root\n    needs_root = any(p for p in plugins if p.needs_root)\n\n    if needs_root and os.getuid() != 0:  # only if not already root\n        command = 'sudo ' + command\n    else:\n        needs_root = False\n\n    # shell the daemon process\n    _, code = common.shell_process(command, exitcode=True)\n\n    if code == 1 and needs_root:  # passwords failed?\n        raise ValueError\n\n    return code == 0", "response": "Shells a new instance of a focusd daemon process."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef focusd(task):\n\n    # determine if command server should be started\n    if registration.get_registered(event_hooks=True, root_access=True):\n        # root event plugins available\n        start_cmd_srv = (os.getuid() == 0)  # must be root\n    else:\n        start_cmd_srv = False\n\n    # daemonize our current process\n    _run = lambda: Focusd(task).run(start_cmd_srv)\n    daemonize(get_daemon_pidfile(task), task.task_dir, _run)", "response": "Forks the current process as a daemon to run a task."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nregisters signal handlers to this class.", "response": "def _reg_sighandlers(self):\n        \"\"\" Registers signal handlers to this class.\n            \"\"\"\n\n        # SIGCHLD, so we shutdown when any of the child processes exit\n        _handler = lambda signo, frame: self.shutdown()\n        signal.signal(signal.SIGCHLD, _handler)\n        signal.signal(signal.SIGTERM, _handler)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreduce effective privileges for this process to that of the task.", "response": "def _drop_privs(self):\n        \"\"\" Reduces effective privileges for this process to that of the task\n            owner. The umask and environment variables are also modified to\n            recreate the environment of the user.\n            \"\"\"\n\n        uid = self._task.owner\n\n        # get pwd database info for task owner\n        try:\n            pwd_info = pwd.getpwuid(uid)\n\n        except OSError:\n            pwd_info = None\n\n        # set secondary group ids for user, must come first\n        if pwd_info:\n            try:\n                gids = [g.gr_gid for g in grp.getgrall()\n                        if pwd_info.pw_name in g.gr_mem]\n                gids.append(pwd_info.pw_gid)\n                os.setgroups(gids)\n\n            except OSError:\n                pass\n\n            # set group id, must come before uid\n            try:\n                os.setgid(pwd_info.pw_gid)\n            except OSError:\n                pass\n\n        # set user id\n        try:\n            os.setuid(uid)\n\n            # update user env variables\n            if pwd_info:\n                for k in ('USER', 'USERNAME', 'SHELL', 'HOME'):\n                    if k in os.environ:\n                        if k in ('USER', 'USERNAME'):\n                            val = pwd_info.pw_name\n\n                        elif k == 'SHELL':\n                            val = pwd_info.pw_shell\n\n                        elif k == 'HOME':\n                            val = pwd_info.pw_dir\n\n                        # update value\n                        os.environ[k] = val\n\n            # remove unneeded env variables\n            keys = []\n            for k, _ in os.environ.iteritems():\n                if k.startswith('SUDO_') or k == 'LOGNAME':\n                    keys.append(k)\n            for k in keys:\n                del os.environ[k]\n\n        except OSError:\n            pass\n\n        # set default umask\n        try:\n            os.umask(022)\n        except OSError:\n            pass"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nshutting down the daemon process.", "response": "def shutdown(self):\n        \"\"\" Shuts down the daemon process.\n            \"\"\"\n\n        if not self._exited:\n            self._exited = True\n\n            # signal task runner to terminate via SIGTERM\n            if self._task_runner.is_alive():\n                self._task_runner.terminate()\n\n                # if command server is running, then block until\n                # task runner completes so it has time to use\n                # the command server to clean up root plugins\n                if self._command_server.is_alive():\n                    if self._task_runner.is_alive():\n                        self._task_runner.join()\n\n            _shutdown_pipe(self._pipe)\n            self._task.stop()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef run(self, start_command_srv):\n\n        if start_command_srv:\n            # note, this must be established *before* the task runner is forked\n            # so the task runner can communicate with the command server.\n\n            # fork the command server\n            self._command_server.start()\n\n            # drop root privileges; command server will remain as the only\n            # daemon process with root privileges. while root plugins have root\n            # shell access, they are known and the commands are logged by the\n            # command server.\n            self._drop_privs()\n\n        # fork the task runner\n        self._task_runner.start()\n\n        # setup signal handlers\n        self._reg_sighandlers()\n\n        while self.running:\n            time.sleep(self._sleep_period)\n\n        self.shutdown()", "response": "Start the daemon process."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef running(self):\n\n        # check if task is active and pid file exists\n        return (not self._exited and os.path.isfile(self._pidfile)\n                and self._task.active)", "response": "Determines if daemon is running."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nregister SIGTERM signal handler.", "response": "def _register_sigterm(self):\n        \"\"\" Registers SIGTERM signal handler.\n            \"\"\"\n\n        _handler = lambda signo, frame: self.shutdown()\n        signal.signal(signal.SIGTERM, _handler)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nshuts down the process.", "response": "def shutdown(self):\n        \"\"\" Shuts down the process.\n            \"\"\"\n\n        if not self._exited:\n            self._exited = True\n            _shutdown_pipe(self._pipe)\n            self._task.stop()\n            raise SystemExit"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ninject a run_root method into the registered root event plugins.", "response": "def _setup_root_plugins(self):\n        \"\"\" Injects a `run_root` method into the registered root event plugins.\n            \"\"\"\n\n        def run_root(_self, command):\n            \"\"\" Executes a shell command as root.\n\n                `command`\n                    Shell command string.\n\n                Returns boolean.\n                \"\"\"\n\n            try:\n                # get lock, so this plugin has exclusive access to command pipe\n                self._rlock.acquire()\n\n                # TODO: log root command for this plugin\n                self._cmd_pipe.send_bytes('\\x80'.join(['SHL', command]))\n                res = self._cmd_pipe.recv_bytes()\n\n                if res != 'TRM':  # sentinel value, shutdown\n                    return res == 'OK'\n\n            except (EOFError, IOError):\n                pass\n\n            finally:\n                self._rlock.release()\n\n            self.shutdown(skip_hooks=True)\n            return False\n\n        # inject method into each event plugin\n        for plugin in registration.get_registered(event_hooks=True,\n                                                  root_access=True):\n            plugin.run_root = types.MethodType(run_root, plugin)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _run_events(self, shutdown=False):\n\n        # run task_start events, if not ran already\n        if not self._ran_taskstart:\n            self._ran_taskstart = True\n            registration.run_event_hooks('task_start', self._task)\n\n        # run events\n        event = 'task_end' if shutdown else 'task_run'\n        registration.run_event_hooks(event, self._task)\n\n        # reclaim any subprocesses plugins may have forked\n        try:\n            os.waitpid(-1, os.P_NOWAIT)\n        except OSError:\n            pass", "response": "Runs event hooks for registered event plugins."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nshutting down the process.", "response": "def shutdown(self, skip_hooks=False):\n        \"\"\" Shuts down the process.\n\n            `skip_hooks`\n                Set to ``True`` to skip running task end event plugins.\n            \"\"\"\n\n        if not self._exited:\n            self._exited = True\n\n            if not skip_hooks:\n                self._run_events(shutdown=True)\n\n            _shutdown_pipe(self._pipe)\n            self._task.stop()\n            raise SystemExit"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _process_commands(self):\n\n        try:\n            # poll for data, so we don't block forever\n            if self._cmd_pipe.poll(1):  # 1 sec timeout\n                payload = self._cmd_pipe.recv_bytes()\n\n                if payload:\n                    # segment payload\n                    parts = payload.split('\\x80', 2)\n                    _op = parts[0]\n\n                    # terminate operation\n                    if _op == 'TRM':\n                        raise EOFError\n\n                    # shell command operation\n                    elif _op == 'SHL' and len(parts) == 2:\n                        command = parts[1]\n\n                        if command:\n                            # run command and return success or fail\n                            res = common.shell_process(command)\n\n                            if res is not None:\n                                self._cmd_pipe.send_bytes('OK')\n                                return True\n\n                    # everything else, should reply with \"FAIL\"\n                    self._cmd_pipe.send_bytes('FAIL')\n\n        except (EOFError, IOError):\n            return False\n\n        else:\n            return True", "response": "Processes commands received and executes them accordingly."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nread Mongodb Source configuration from the provided settings", "response": "def from_settings(cls, settings):\n        \"\"\"Read Mongodb Source configuration from the provided settings\"\"\"\n        if not 'mongodb' in settings or not 'collection' in settings or \\\n                settings['mongodb'] == '' or settings['collection'] == '':\n            raise Exception(\n                \"Erroneous mongodb settings, \"\n                \"needs a collection and mongodb setting\",\n                settings)\n\n        cx_uri = urlparse.urlsplit(settings[\"mongodb\"])\n        db_name = cx_uri.path\n\n        if '?' in db_name:\n            db_name, query = db_name.split('?', 1)\n\n        db_name = db_name[1:]\n\n        if db_name == \"\":\n            raise Exception(\n                \"Erroneous mongodb settings, \"\n                \"missing db_name\", settings)\n\n        cx_uri = urlparse.urlunsplit(\n            (cx_uri.scheme, cx_uri.netloc, \"/\", cx_uri.query, cx_uri.fragment))\n        options = copy.deepcopy(settings)\n        del options['mongodb']\n        del options['collection']\n\n        return Mongodb(\n            cls.connection_for_uri(cx_uri),\n            db_name, settings['collection'], options)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef compute_key(cli, familly, discriminant=None):\n    hash_key = hashlib.sha256()\n    hash_key.update(familly)\n    hash_key.update(cli.host)\n    hash_key.update(cli.user)\n    hash_key.update(cli.password)\n    if discriminant:\n        if isinstance(discriminant, list):\n            for i in discriminant:\n                if i is not None and i is not False:\n                    hash_key.update(str(i))\n        elif isinstance(discriminant, tuple):\n            for i in discriminant:\n                if i is not None and i is not False:\n                    hash_key.update(str(i))\n        else:\n            hash_key.update(discriminant)\n    hash_key = hash_key.hexdigest()\n    cli.log.debug(\"hash_key: \" + hash_key)\n    return hash_key", "response": "This function is used to compute a unique key from all connection parametters."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nlooking in the current wrapped object to find a cache configuration to override the current default configuration.", "response": "def override_familly(self, args):\n        \"\"\"Look in the current wrapped object to find a cache configuration to\n        override the current default configuration.\"\"\"\n        resourceapi = args[0]\n        cache_cfg = resourceapi.cache\n        if cache_cfg.has_key('familly'):\n            self.familly = cache_cfg['familly']\n        if cache_cfg.has_key('whole_familly'):\n            self.whole_familly = cache_cfg['whole_familly']\n        if self.familly is None:\n            raise Exception(\"Invalid familly value for Cache decorator.\")"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsaves the given record's page content to a .html file Attributes record (Record) -- The log record", "response": "def handleHTML(self, record):\n        \"\"\" Saves the given record's page content to a .html file\n        \n        Attributes\n           record (Record) -- The log record\n        \"\"\"\n        # Create a unique file name to identify where this HTML source is coming from\n        fileName = datetime.today().strftime(\"Neolib %Y-%m-%d %H-%M-%S \") + record.module + \".html\"\n        \n        # Sometimes module may encase the text with < > which is an invalid character for a file name\n        fileName = fileName.replace(\"<\", \"\").replace(\">\", \"\")\n        \n        # Grab the pg\n        pg = record.args['pg']\n        \n        # Format a log message that details the page\n        ret = \"Message: \" + record.msg + \"\\nLine Number: \" + str(record.lineno) + \"\\nURL: \" + str(pg.url) + \"\\nPost Data: \" + str(pg.postData) + \"\\nAdditional Vars: \" + str(pg.vars)\n        ret += \"\\n\\n\\n\" + str(pg.header) + \"\\n\\n\" + pg.content\n        \n        # Write the file\n        f = open(fileName, \"w\", encoding='utf-8')\n        f.write(ret)\n        f.close()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef function_from_string(func_string):\n\n    func = None\n    func_string_splitted = func_string.split('.')\n    module_name = '.'.join(func_string_splitted[:-1])\n    function_name = func_string_splitted[-1]\n    module = import_module(module_name)\n    if module and function_name:\n        func = getattr(module, function_name)\n    return func", "response": "Returns a function object from the function string."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a user - friendly type name for the given raw type.", "response": "def friendly_type_name(raw_type: typing.Type) -> str:\n    \"\"\"\n    Returns a user-friendly type name\n\n    :param raw_type: raw type (str, int, ...)\n    :return: user friendly type as string\n    \"\"\"\n    try:\n        return _TRANSLATE_TYPE[raw_type]\n    except KeyError:\n        LOGGER.error('unmanaged value type: %s', raw_type)\n        return str(raw_type)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef loads(content):\n    lines = _group_lines(line for line in content.split('\\n'))\n    lines = [\n        (i, _parse_envfile_line(line))\n        for i, line in lines if line.strip()\n    ]\n    errors = []\n    # Reject files with duplicate variables (no sane default).\n    duplicates = _find_duplicates(((i, line[0]) for i, line in lines))\n    for i, variable, j in duplicates:\n        errors.append(''.join([\n                'Line %d: duplicate environment variable \"%s\": ',\n                'already appears on line %d.',\n            ]) % (i + 1, variable, j + 1)\n        )\n    # Done!\n    if errors:\n        raise ValueError(errors)\n    return {k: v for _, (k, v) in lines}", "response": "Loads variable definitions from a string."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get(self):\n        with open(self.filename, 'r') as f:\n            self.config = ujson.load(f)\n        return self.config", "response": "Loads the configuration and returns it as a dictionary"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsets an option to a value.", "response": "def set(self, option, value):\n        \"\"\"\n        Sets an option to a value.\n        \"\"\"\n        if self.config is None:\n            self.config = {}\n        self.config[option] = value"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef delete(self, option):\n        if self.config is not None:\n            if option in self.config:\n                del self.config[option]", "response": "Deletes an option from the configuration."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsaves the configuration to the file.", "response": "def save(self):\n        \"\"\"\n        Saves the configuration\n        \"\"\"\n        with open(self.filename, 'w') as f:\n            ujson.dump(self.config, f, indent=4)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nvalidates timestamp specified by request.", "response": "def timestamp(stamp, tolerance=150):\n    \"\"\"Validate timestamp specified by request.\n\n    See `validate.request` for additional info.\n\n    Args:\n        stamp: str. Time request was made as ISO 8601 timestamp.\n        tolerance: int. Number of seconds request remains valid from timestamp.\n\n    Returns\n        bool: True if valid, False otherwise.\n    \"\"\"\n    try:\n        tolerance = datetime.timedelta(0, tolerance)\n        timestamp_low = dateutil.parser.parse(stamp)\n        timestamp_high = timestamp_low + tolerance\n        now = datetime.datetime.now(timestamp_low.tzinfo)\n    except ValueError:\n        return False\n\n    return now >= timestamp_low and now <= timestamp_high"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef signature_cert_chain_url(url):\n    r = urlparse(url)\n    if not r.scheme.lower() == 'https':\n        warnings.warn('Certificate URL scheme is invalid.')\n        return False\n    if not r.hostname.lower() == 's3.amazonaws.com':\n        warnings.warn('Certificate URL hostname is invalid.')\n        return False\n    if not os.path.normpath(r.path).startswith('/echo.api/'):\n        warnings.warn('Certificate URL path is invalid.')\n        return False\n    if r.port and not r.port == 443:\n        warnings.warn('Certificate URL port is invalid.')\n        return False\n    return True", "response": "Validate URL specified by SignatureCertChainUrl."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef retrieve(url):\n    try:\n        pem_data = urlopen(url).read()\n    except (ValueError, HTTPError):\n        warnings.warn('Certificate URL is invalid.')\n        return False\n\n    if sys.version >= '3':\n        try:\n            pem_data = pem_data.decode()\n        except(UnicodeDecodeError):\n            warnings.warn('Certificate encoding is not utf-8.')\n            return False\n\n    return _parse_pem_data(pem_data)", "response": "Retrieve and parse PEM - encoded X.509 certificate chain."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nparse PEM - encoded X.509 certificate chain.", "response": "def _parse_pem_data(pem_data):\n    \"\"\"Parse PEM-encoded X.509 certificate chain.\n\n    Args:\n        pem_data: str. PEM file retrieved from SignatureCertChainUrl.\n\n    Returns:\n        list or bool: If url is valid, returns the certificate chain as a list\n            of cryptography.hazmat.backends.openssl.x509._Certificate\n            certificates where certs[0] is the first certificate in the file; if\n            url is invalid, returns False.\n    \"\"\"\n    sep = '-----BEGIN CERTIFICATE-----'\n    cert_chain = [six.b(sep + s) for s in pem_data.split(sep)[1:]]\n    certs = []\n    load_cert = x509.load_pem_x509_certificate\n    for cert in cert_chain:\n        try:\n            certs.append(load_cert(cert, default_backend()))\n        except ValueError:\n            warnings.warn('Certificate is invalid.')\n            return False\n\n    return certs"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nvalidates PEM - encoded X.509 certificate chain.", "response": "def cert_chain(certs):\n    \"\"\"Validate PEM-encoded X.509 certificate chain.\n\n    See `validate.request` for additional info.\n\n    Args:\n        certs: list. The certificate chain as a list of\n            cryptography.hazmat.backends.openssl.x509._Certificate certificates.\n            See `validate.retrieve` to create certs obj.\n\n    Returns:\n        bool: True if valid, False otherwise.\n    \"\"\"\n    if len(certs) < 2:\n        warnings.warn('Certificate chain contains < 3 certificates.')\n        return False\n\n    cert = certs[0]\n    today = datetime.datetime.today()\n    if not today > cert.not_valid_before:\n        warnings.warn('Certificate Not Before date is invalid.')\n        return False\n    if not today < cert.not_valid_after:\n        warnings.warn('Certificate Not After date is invalid.')\n        return False\n\n    oid_san = x509.oid.ExtensionOID.SUBJECT_ALTERNATIVE_NAME\n    ext = cert.extensions.get_extension_for_oid(oid_san)\n    sans = ext.value.get_values_for_type(x509.DNSName)\n    if not 'echo-api.amazon.com' in sans:\n        return False\n\n    for i in range(len(certs) - 1):\n        if not certs[i].issuer == certs[i + 1].subject:\n            return False\n\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nvalidate a request signature.", "response": "def signature(cert, sig, body):\n    \"\"\"Validate data request signature.\n\n    See `validate.request` for additional info.\n\n    Args:\n        cert: cryptography.hazmat.backends.openssl.x509._Certificate. The Amazon\n            signing certificate.\n        sig: str. Signature header value sent by request.\n        body: str. HTTPS request body.\n\n    Returns:\n        bool: True if valid, False otherwise.\n    \"\"\"\n    body = six.b(body)\n\n    sig = base64.decodestring(sig)\n    padder = padding.PKCS1v15()\n    public_key = cert.public_key()\n    try:\n        public_key.verify(sig, body, padder, hashes.SHA1())\n        return True\n    except InvalidSignature:\n        warnings.warn('Signature verification failed.')\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nvalidate request application id matches true application id.", "response": "def application_id(self, app_id):\n        \"\"\"Validate request application id matches true application id.\n\n        Verifying the Application ID matches: https://goo.gl/qAdqe4.\n\n        Args:\n            app_id: str. Request application_id.\n\n        Returns:\n            bool: True if valid, False otherwise.\n        \"\"\"\n        if self.app_id != app_id:\n            warnings.warn('Application ID is invalid.')\n            return False\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef sender(self, body, stamp, url, sig):\n        if not timestamp(stamp):\n            return False\n\n        if self.url != url:\n            if not signature_cert_chain_url(url):\n                return False\n\n            certs = retrieve(url)\n            if not certs:\n                return False\n\n            if not cert_chain(certs):\n                return False\n\n            self.url = url\n            self.cert = certs[0]\n\n        if not signature(self.cert, sig, body):\n            return False\n\n        return True", "response": "Validate that the request was sent by Alexa."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef request(self, app_id=None, body=None, stamp=None, url=None, sig=None):\n        if self.app_id:\n            if not self.application_id(app_id):\n                return False\n\n        if (url or sig):\n            if not (body and stamp and url and sig):\n                raise ValueError('Unable to validate sender, check arguments.')\n            else:\n                if not self.sender(body, stamp, url, sig):\n                    return False\n\n        return True", "response": "Validate application ID and request is from Alexa."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a list of all the processes in the .", "response": "def get_stored_procs(db_connection):\n    \"\"\"\n    :param db_connection:\n    :return:\n    \"\"\"\n\n    sql = \"SHOW PROCEDURE STATUS;\"\n    procs = execute_sql(sql, db_connection)\n\n    return [x[1] for x in procs]"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nloads all required tables from disk to DB.", "response": "def load_tables_from_files(db_connection):\n    \"\"\" Looks in the current working directory for all required tables. \"\"\"\n\n    _log.info('Loading tables from disk to DB.')\n\n    sde_dir_path = os.path.join(os.path.dirname(os.path.realpath(__file__)), 'sde')\n\n    for sde_file_name in os.listdir(sde_dir_path):\n        _log.info('Loading the following table: {}'.format(sde_file_name))\n\n        sde_file_path = os.path.join(sde_dir_path, sde_file_name)\n\n        with open(sde_file_path, 'r') as sde_file:\n            sql = sde_file.read()\n            execute_sql(sql, db_connection)\n\n    _log.info('Finished loading all requested tables.')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate a connection to the MySQL DB.", "response": "def get_connection(connection_details=None):\n    \"\"\" Creates a connection to the MySQL DB. \"\"\"\n\n    if connection_details is None:\n        connection_details = get_default_connection_details()\n\n    return MySQLdb.connect(\n        connection_details['host'],\n        connection_details['user'],\n        connection_details['password'],\n        connection_details['database']\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the connection details based on environment vars or Thanatos default settings.", "response": "def get_default_connection_details():\n    \"\"\" Gets the connection details based on environment vars or Thanatos default settings.\n\n    :return: Returns a dictionary of connection details.\n    :rtype: dict\n    \"\"\"\n\n    return {\n        'host': os.environ.get('MYSQL_HOST', '127.0.0.1'),\n        'user': os.environ.get('MYSQL_USER', 'vagrant'),\n        'password': os.environ.get('MYSQL_PASSWORD', 'vagrant'),\n        'database': os.environ.get('MYSQL_DB', 'thanatos'),\n    }"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef maybe(cls, val: Optional[T]) -> 'Option[T]':\n        return cast('Option[T]', NONE) if val is None else cls.Some(val)", "response": "Shortcut method to return Some or NONE based on val."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nunwrap the option. Raises an exception if the value is not a valid value.", "response": "def expect(self, msg) -> T:\n        \"\"\"\n        Unwraps the option. Raises an exception if the value is :py:data:`NONE`.\n\n        Args:\n            msg: The exception message.\n\n        Returns:\n            The wrapped value.\n\n        Raises:\n            ``ValueError`` with message provided by ``msg`` if the value is :py:data:`NONE`.\n\n        Examples:\n            >>> Some(0).expect('sd')\n            0\n            >>> try:\n            ...     NONE.expect('Oh No!')\n            ... except ValueError as e:\n            ...     print(e)\n            Oh No!\n        \"\"\"\n        if self._is_some:\n            return self._val\n        raise ValueError(msg)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef unwrap_or(self, default: U) -> Union[T, U]:\n        return self.unwrap_or_else(lambda: default)", "response": "Returns the contained value or default."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef unwrap_or_else(self, callback: Callable[[], U]) -> Union[T, U]:\n        return self._val if self._is_some else callback()", "response": "Returns the contained value or computes it from callback."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef map(self, callback: Callable[[T], U]) -> 'Option[U]':\n        return self._type.Some(callback(self._val)) if self._is_some else cast('Option[U]', NONE)", "response": "Applies the callback with the contained value as its argument or\n            returns an Option that is a Some value."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef map_or(self, callback: Callable[[T], U], default: A) -> Union[U, A]:\n        return callback(self._val) if self._is_some else default", "response": "Applies the callback to the contained value or returns default."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\napplies the callback to the contained value if the option is not NONE.", "response": "def flatmap(self, callback: 'Callable[[T], Option[U]]') -> 'Option[U]':\n        \"\"\"\n        Applies the callback to the contained value if the option\n        is not :py:data:`NONE`.\n\n        This is different than :py:meth:`Option.map` because the result\n        of the callback isn't wrapped in a new :py:class:`Option`\n\n        Args:\n            callback: The callback to apply to the contained value.\n\n        Returns:\n            :py:data:`NONE` if the option is :py:data:`NONE`.\n\n            otherwise calls `callback` with the contained value and\n            returns the result.\n\n        Examples:\n            >>> def square(x): return Some(x * x)\n            >>> def nope(x): return NONE\n            >>> Some(2).flatmap(square).flatmap(square)\n            Some(16)\n            >>> Some(2).flatmap(square).flatmap(nope)\n            NONE\n            >>> Some(2).flatmap(nope).flatmap(square)\n            NONE\n            >>> NONE.flatmap(square).flatmap(square)\n            NONE\n        \"\"\"\n        return callback(self._val) if self._is_some else cast('Option[U]', NONE)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn an Option containing only the contained value if the predicate returns True otherwise.", "response": "def filter(self, predicate: Callable[[T], bool]) -> 'Option[T]':\n        \"\"\"\n        Returns :py:data:`NONE` if the :py:class:`Option` is :py:data:`NONE`,\n        otherwise filter the contained value by ``predicate``.\n\n        Args:\n            predicate: The fitler function.\n\n        Returns:\n            :py:data:`NONE` if the contained value is :py:data:`NONE`, otherwise:\n                * The option itself if the predicate returns True\n                * :py:data:`NONE` if the predicate returns False\n\n        Examples:\n            >>> Some(0).filter(lambda x: x % 2 == 1)\n            NONE\n            >>> Some(1).filter(lambda x: x % 2 == 1)\n            Some(1)\n            >>> NONE.filter(lambda x: True)\n            NONE\n        \"\"\"\n        if self._is_some and predicate(self._val):\n            return self\n        return cast('Option[T]', NONE)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get(\n            self: 'Option[Mapping[K,V]]',\n            key: K,\n            default=None\n    ) -> 'Option[V]':\n        \"\"\"\n        Gets a mapping value by key in the contained value or returns\n        ``default`` if the key doesn't exist.\n\n        Args:\n            key: The mapping key.\n            default: The defauilt value.\n\n        Returns:\n            * ``Some`` variant of the mapping value if the key exists\n               and the value is not None.\n            * ``Some(default)`` if ``default`` is not None.\n            * :py:data:`NONE` if ``default`` is None.\n\n        Examples:\n            >>> Some({'hi': 1}).get('hi')\n            Some(1)\n            >>> Some({}).get('hi', 12)\n            Some(12)\n            >>> NONE.get('hi', 12)\n            Some(12)\n            >>> NONE.get('hi')\n            NONE\n        \"\"\"\n        if self._is_some:\n            return self._type.maybe(self._val.get(key, default))\n        return self._type.maybe(default)", "response": "Gets a mapping value by key in the contained value or returns the default value."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nbuilds the image. :param resort.engine.execution.Context context: Current execution context.", "response": "def insert(self, context):\n\t\n\t\t\"\"\"\n\t\tBuild the image.\n\t\t\n\t\t:param resort.engine.execution.Context context:\n\t\t   Current execution context.\n\t\t\"\"\"\n\t\t\n\t\ttry:\n\t\t\tcurrent_dir = os.getcwd()\n\t\t\tos.chdir(os.path.join(context.profile_dir(), self.__base_dir))\n\t\t\targs = [\n\t\t\t\t\"packer\",\n\t\t\t\t\"build\",\n\t\t\t\tself.__template_path\n\t\t\t]\n\t\t\tsubprocess.call(args)\n\t\tfinally:\n\t\t\tshutil.rmtree(\"output-*\", ignore_errors=True)\n\t\t\tos.chdir(current_dir)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nensure the migrations table is set up in the database.", "response": "def assure_migrations_table_setup(db):\n    \"\"\"\n    Make sure the migrations table is set up in the database.\n    \"\"\"\n    from mig.models import MigrationData\n\n    if not MigrationData.__table__.exists(db.bind):\n        MigrationData.metadata.create_all(\n            db.bind, tables=[MigrationData.__table__])"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef sorted_migrations(self):\n        if not self._sorted_migrations:\n            self._sorted_migrations = sorted(\n                self.migration_registry.items(),\n                # sort on the key... the migration number\n                key=lambda migration_tuple: migration_tuple[0])\n\n        return self._sorted_migrations", "response": "Sort migrations if necessary and store in self. _sorted_migrations"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the migration row associated with this object.", "response": "def migration_data(self):\n        \"\"\"\n        Get the migration row associated with this object, if any.\n        \"\"\"\n        return self.session.query(\n            self.migration_model).filter_by(name=self.name).first()"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns the current migration in the database.", "response": "def database_current_migration(self):\n        \"\"\"\n        Return the current migration in the database.\n        \"\"\"\n        # If the table doesn't even exist, return None.\n        if not self.migration_table.exists(self.session.bind):\n            return None\n\n        # Also return None if self.migration_data is None.\n        if self.migration_data is None:\n            return None\n\n        return self.migration_data.version"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_current_migration(self, migration_number=None):\n        self.migration_data.version = migration_number or self.latest_migration\n        self.session.commit()", "response": "Set the current migration in the database to migration_number or latest_migration_COOKIE."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting a list of migrations to run.", "response": "def migrations_to_run(self):\n        \"\"\"\n        Get a list of migrations to run still, if any.\n\n        Note that this will fail if there's no migration record for\n        this class!\n        \"\"\"\n        assert self.database_current_migration is not None\n\n        db_current_migration = self.database_current_migration\n\n        return [\n            (migration_number, migration_func)\n            for migration_number, migration_func in self.sorted_migrations\n            if migration_number > db_current_migration]"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating all tables relative to this package", "response": "def init_tables(self):\n        \"\"\"\n        Create all tables relative to this package\n        \"\"\"\n        # sanity check before we proceed, none of these should be created\n        for model in self.models:\n            # Maybe in the future just print out a \"Yikes!\" or something?\n            _log.debug('Checking for table {0}'.format(model))\n            assert not model.__table__.exists(self.session.bind)\n\n        _log.debug('Creating {0}'.format(self.models))\n        self.migration_model.metadata.create_all(\n            self.session.bind,\n            tables=[model.__table__ for model in self.models])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate a new migration record for this migration set.", "response": "def create_new_migration_record(self):\n        \"\"\"\n        Create a new migration record for this migration set\n        \"\"\"\n        migration_record = self.migration_model(\n            name=self.name,\n            version=self.latest_migration)\n        self.session.add(migration_record)\n        self.session.commit()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nprint out a dry run of what we would have upgraded.", "response": "def dry_run(self):\n        \"\"\"\n        Print out a dry run of what we would have upgraded.\n        \"\"\"\n        if self.database_current_migration is None:\n            self.printer(\n                    u'~> Woulda initialized: %s\\n' % self.name_for_printing())\n            return u'inited'\n\n        migrations_to_run = self.migrations_to_run()\n        if migrations_to_run:\n            self.printer(\n                u'~> Woulda updated %s:\\n' % self.name_for_printing())\n\n            for migration_number, migration_func in migrations_to_run():\n                self.printer(\n                    u'   + Would update %s, \"%s\"\\n' % (\n                        migration_number, migration_func.func_name))\n\n            return u'migrated'"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ninitializing the database or migrate if appropriate.", "response": "def init_or_migrate(self):\n        \"\"\"\n        Initialize the database or migrate if appropriate.\n\n        Returns information about whether or not we initialized\n        ('inited'), migrated ('migrated'), or did nothing (None)\n        \"\"\"\n        assure_migrations_table_setup(self.session)\n\n        # Find out what migration number, if any, this database data is at,\n        # and what the latest is.\n        migration_number = self.database_current_migration\n\n        # Is this our first time?  Is there even a table entry for\n        # this identifier?\n        # If so:\n        #  - create all tables\n        #  - create record in migrations registry\n        #  - print / inform the user\n        #  - return 'inited'\n        if migration_number is None:\n            self.printer(u\"-> Initializing %s... \" % self.name_for_printing())\n\n            self.init_tables()\n            # auto-set at latest migration number\n            self.create_new_migration_record()\n\n            self.printer(u\"done.\\n\")\n            self.set_current_migration()\n            return u'inited'\n\n        # Run migrations, if appropriate.\n        migrations_to_run = self.migrations_to_run()\n        if migrations_to_run:\n            self.printer(\n                u'-> Updating %s:\\n' % self.name_for_printing())\n            for migration_number, migration_func in migrations_to_run:\n                self.printer(\n                    u'   + Running migration %s, \"%s\"... ' % (\n                        migration_number, migration_func.func_name))\n                migration_func(self.session)\n                self.printer('done.\\n')\n\n            self.set_current_migration()\n            return u'migrated'\n\n        # Otherwise return None.  Well it would do this anyway, but\n        # for clarity... ;)\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a dictionary of login - > user - > user - > user - > user - > user - > user - > user - > user - > user - > user - > user - > user - > user - > user - > user - > user - > user - > user - > user - > user - > user - > user - > user - > user - > user - > user - > user - > user - > user - > user - > user", "response": "def _logins(users, user_attrs=None):\n    '''\n    FIXME: DOCS...\n    '''\n    # FIXME: check for support attrs\n    \n    # Supported attrs:\n    # login  # DEFAULT, no auth required\n    # email\n    # bio\n    # company\n    # created_at\n    # hireable\n    # location\n    # updated_at\n    # url\n\n    # 'login' will be the dict index key; remove it from user_attr columns\n    if 'login' in user_attrs:\n        if user_attrs.index('login') >= 0:\n            # get this out of the remaining attrs to parse\n            del user_attrs[user_attrs.index('login')]\n\n    _users = {}\n    for u in users:\n        l = u.login\n        logr.debug('LOGIN: {}'.format(l))\n        _users[l] = {}\n        for a in user_attrs:\n            logr.debug('user: {}'.format(u))\n            logr.debug('attr: {}'.format(a))\n            _users[l][a] = getattr(u, a)\n    return _users"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nextracting members from a GitHub repository.", "response": "def extract(repo_url=None, target=None, user=None, password=None, token=None,\n            user_attrs=None):\n    '''\n    FIXME: DOCS...\n    '''\n    if not repo_url:\n        raise RuntimeError(\"URI must be specified\")\n\n    if target not in TARGETS.keys():\n        raise RuntimeError(\"Unknown members target [{}]\".format(target))\n\n    # eg, login, email; user.ATTR to return as ['member', 'member', ... ']\n    user_attrs = user_attrs or []\n    # user_attrs can be a list (of strings) or a string\n    assert isinstance(user_attrs, (unicode, str, list))\n    # if we get a string, put convert it to a single item list\n    if isinstance(user_attrs, (unicode, str)):\n        user_attrs = [user_attrs]\n    # Should only have a list at this point... empty or with strings\n    assert isinstance(user_attrs, list)\n    logr.debug(\"user_attrs: {}\".format(user_attrs))\n\n    # use token if available, otherwise, password\n    if token:\n        logr.debug(\" ... USING AUTH TOKEN\")\n        password = token\n    else:\n        assert password != ''  # is not null\n\n    if user and password:\n        logr.debug(\"AUTHENTICATING USER (WITH PASSOWRD): {}\".format(user))\n        g = Github(user, password)\n    else:\n        if user:\n            logr.debug(\"NOT AUTHENTICATING USER: {}\".format(user))\n        else:\n            logr.debug(\"NO USER / PASSWORD set\")\n        g = Github()\n\n    repo = g.get_repo(repo_url)\n\n    # run the github api call for members depending on requested target\n    users = TARGETS[target](repo)\n\n    members = _logins(users=users, user_attrs=user_attrs)\n\n    return members"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nrun setup after a fresh Vagrant installation.", "response": "def cli(ctx):\n    \"\"\"\n    Run setup after a fresh Vagrant installation.\n    \"\"\"\n    log = logging.getLogger('ipsv.setup')\n    assert isinstance(ctx, Context)\n\n    lock_path = os.path.join(ctx.config.get('Paths', 'Data'), 'setup.lck')\n    if os.path.exists(lock_path):\n        raise Exception('Setup is locked, please remove the setup lock file to continue')\n\n    # Create our package directories\n    p = Echo('Creating IPS Vagrant system directories...')\n    dirs = ['/etc/ipsv', ctx.config.get('Paths', 'Data'), ctx.config.get('Paths', 'Log'),\n            ctx.config.get('Paths', 'NginxSitesAvailable'), ctx.config.get('Paths', 'NginxSitesEnabled'),\n            ctx.config.get('Paths', 'NginxSSL')]\n    for d in dirs:\n        if not os.path.exists(d):\n            os.makedirs(d, 0o755)\n    p.done()\n\n    p = Echo('Copying IPS Vagrant configuration files...')\n    with open('/etc/ipsv/ipsv.conf', 'w+') as f:\n        ctx.config.write(f)\n    p.done()\n\n    # Set up alembic\n    alembic_cfg = Config(os.path.join(ctx.basedir, 'alembic.ini'))\n    alembic_cfg.set_main_option(\"script_location\", os.path.join(ctx.basedir, 'migrations'))\n    alembic_cfg.set_main_option(\"sqlalchemy.url\", \"sqlite:////{path}\"\n                                .format(path=os.path.join(ctx.config.get('Paths', 'Data'), 'sites.db')))\n\n    command.current(alembic_cfg)\n    command.downgrade(alembic_cfg, 'base')\n    command.upgrade(alembic_cfg, 'head')\n\n    # Update the system\n    p = Echo('Updating package cache...')\n    cache = apt.Cache()\n    cache.update()\n    cache.open(None)\n    p.done()\n    p = Echo('Upgrading system packages...')\n    cache.upgrade()\n    cache.commit()\n    p.done()\n\n    # Install our required packages\n    requirements = ['nginx', 'php5-fpm', 'php5-curl', 'php5-gd', 'php5-imagick', 'php5-json', 'php5-mysql',\n                    'php5-readline', 'php5-apcu', 'php5-xdebug']\n\n    for requirement in requirements:\n        # Make sure the package is available\n        p = Echo('Marking package {pkg} for installation'.format(pkg=requirement))\n        if requirement not in cache:\n            log.warn('Required package {pkg} not available'.format(pkg=requirement))\n            p.done(p.FAIL)\n            continue\n\n        # Mark the package for installation\n        cache[requirement].mark_install()\n        p.done()\n\n    log.info('Committing package cache')\n    p = Echo('Downloading and installing packages...')\n    cache.commit()\n    p.done()\n\n    # Disable the default server block\n    p = Echo('Configuring Nginx...')\n    default_available = os.path.join(ctx.config.get('Paths', 'NginxSitesAvailable'), 'default')\n    default_enabled = os.path.join(ctx.config.get('Paths', 'NginxSitesEnabled'), 'default')\n    if os.path.isfile(default_available):\n        os.remove(default_available)\n    if os.path.islink(default_enabled):\n        os.unlink(default_enabled)\n    p.done()\n\n    # Restart Nginx\n    FNULL = open(os.devnull, 'w')\n    p = Echo('Restarting Nginx...')\n    subprocess.check_call(['service', 'nginx', 'restart'], stdout=FNULL, stderr=subprocess.STDOUT)\n    p.done()\n\n    # php.ini configuration\n    p = Echo('Configuring php...')\n    with open('/etc/php5/fpm/php.ini', 'a') as f:\n        f.write('\\n[XDebug]')\n        f.write('\\nxdebug.cli_color=1')\n\n    temp_fh, temp_path = mkstemp()\n    with open(temp_path, 'w') as nf:\n        with open('/etc/php5/fpm/php.ini') as of:\n            # Configuration options we are replacing\n            upload_max_filesize = re.compile( '^upload_max_filesize\\s+=\\s+(\\d+[a-zA-Z])\\s*$' )\n            post_max_size = re.compile( '^post_max_size\\s+=\\s+(\\d+[a-zA-Z])\\s*$' )\n\n            for line in of:\n                match = upload_max_filesize.match( line ) if upload_max_filesize is not True else False\n                if match:\n                    nf.write( 'upload_max_filesize = 1000M\\n' )\n                    upload_max_filesize = True\n                    continue\n\n                match = post_max_size.match( line ) if post_max_size is not True else False\n                if match:\n                    nf.write( 'post_max_size = 1000M\\n' )\n                    post_max_size = True\n                    continue\n\n                nf.write(line)\n    os.close(temp_fh)\n    os.remove('/etc/php5/fpm/php.ini')\n    shutil.move(temp_path, '/etc/php5/fpm/php.ini')\n    os.chmod('/etc/php5/fpm/php.ini', 0o644)\n    p.done()\n\n    # php5-fpm configuration\n    p = Echo('Configuring php5-fpm...')\n    if os.path.isfile('/etc/php5/fpm/pool.d/www.conf'):\n        os.remove('/etc/php5/fpm/pool.d/www.conf')\n\n    fpm_config = FpmPoolConfig().template\n    with open('/etc/php5/fpm/pool.d/ips.conf', 'w') as f:\n        f.write(fpm_config)\n    p.done()\n\n    # Restart php5-fpm\n    p = Echo('Restarting php5-fpm...')\n    subprocess.check_call(['service', 'php5-fpm', 'restart'], stdout=FNULL, stderr=subprocess.STDOUT)\n    p.done()\n\n    # Copy the man pages and rebuild the manual database\n    p = Echo('Writing manual pages...')\n    man_path = os.path.join(ctx.basedir, 'man', 'ipsv.1')\n    sys_man_path = '/usr/local/share/man/man1'\n    if not os.path.exists(sys_man_path):\n        os.makedirs(sys_man_path)\n\n    shutil.copyfile(man_path, os.path.join(sys_man_path, 'ipsv.1'))\n\n    subprocess.check_call(['mandb'], stdout=FNULL, stderr=subprocess.STDOUT)\n\n    # Enable the welcome message\n    log.debug('Writing welcome message')\n    wm_header = '## DO NOT REMOVE :: AUTOMATICALLY GENERATED BY IPSV ##'\n    wm_remove = False\n\n    # Remove old profile data\n    for line in fileinput.input('/etc/profile', inplace=True):\n        # Header / footer match?\n        if line == wm_header:\n            # Footer match (Stop removing)\n            if wm_remove:\n                wm_remove = False\n                continue\n\n            # Header match (Start removing)\n            wm_remove = True\n            continue\n\n        # Removing lines?\n        if wm_remove:\n            continue\n\n        # Print line and continue as normal\n        sys.stdout.write(line)\n\n    # Write new profile data\n    with open('/etc/profile', 'a') as f:\n        f.write(\"\\n\" + wm_header + \"\\n\")\n        fl_lock_path = os.path.join(ctx.config.get('Paths', 'Data'), 'first_login.lck')\n        f.write('if [ ! -f \"{lp}\" ]; then'.format(lp=fl_lock_path) + \"\\n\")\n        f.write('  less \"{wp}\"'.format(wp=os.path.join(ctx.basedir, 'WELCOME.rst')) + \"\\n\")\n        f.write('  sudo touch \"{lp}\"'.format(lp=fl_lock_path) + \"\\n\")\n        f.write('fi' + \"\\n\")\n        f.write(wm_header + \"\\n\")\n    p.done()\n\n    log.debug('Writing setup lock file')\n    with open(os.path.join(ctx.config.get('Paths', 'Data'), 'setup.lck'), 'w') as f:\n        f.write('1')"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef build_fault(cls, e, tb, include_traceback=False):\n    if hasattr(cls, '_amf_code'):\n        code = cls._amf_code\n    else:\n        code = cls.__name__\n\n    details = None\n\n    if include_traceback:\n        details = traceback.format_exception(cls, e, tb)\n\n    return remoting.ErrorFault(code=code, description=unicode(e), details=details)", "response": "Builds an error fault object based on the last exception raised."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef authenticateRequest(self, request, service_request, *args, **kwargs):\n        username = password = None\n\n        if 'Credentials' in request.headers:\n            cred = request.headers['Credentials']\n\n            username = cred['userid']\n            password = cred['password']\n\n        return self.gateway.authenticateRequest(service_request, username,\n            password, *args, **kwargs)", "response": "Authenticates the request against the service."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef buildErrorResponse(self, request, error=None):\n        if error is not None:\n            cls, e, tb = error\n        else:\n            cls, e, tb = sys.exc_info()\n\n        return remoting.Response(build_fault(cls, e, tb, self.gateway.debug),\n            status=remoting.STATUS_ERROR)", "response": "Builds an error response."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ntaking an object that fails with json. dumps and converts it to a json. dumpsable object. This is useful for debugging purposes when you want to dump an object that fails with json. dumps and converts it to a json. dumpsable object.", "response": "def dumpable_obj(obj):\n    ''' takes an object that fails with json.dumps and converts it to\n    a json.dumps dumpable object. This is useful for debuging code when\n    you want to dump an object for easy reading'''\n\n    if isinstance(obj, list):\n        _return_list = []\n        for item in obj:\n            if isinstance(item, list):\n                _return_list.append(dumpable_obj(item))\n            elif isinstance(item, set):\n                _return_list.append(list(item))\n            elif isinstance(item, dict):\n                _return_list.append(dumpable_obj(item))\n            else:\n                try:\n                    json.dumps(item)\n                    _return_list.append(item)\n                except:\n                    _return_list.append(str(type(item)))\n        return _return_list\n    elif isinstance(obj, set):\n        return list(obj)\n    elif isinstance(obj, dict):\n        _return_obj = {}\n        for key, item in obj.items():\n            if isinstance(item, list):\n                _return_obj[key] = dumpable_obj(item)\n            elif isinstance(item, set):\n                _return_obj[key] = list(item)\n            elif isinstance(item, dict):\n                _return_obj[key] = dumpable_obj(item)\n            else:\n                try:\n                    json.dumps(item)\n                    _return_obj[key] = item\n                except:\n                    _return_obj[key] = str(type(item))\n        return _return_obj\n    else:\n        try:\n            json.dumps(obj)\n            return obj\n        except:\n            return str(type(obj))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef table2dicts(html):\n    \n    def _get_headers_and_values(soup):\n        headers = [x.string or '' for x in soup.select('table tr th')]\n        if len(headers) == 0:\n            # maybe no th specified? just use the first row of td's\n            headers = [x.string or '' for x in soup.select('table tr')[0].select('td')]\n        values = [x or '' for x in soup.select('table tr')][1:]\n        return headers, values\n        \n    soup = BeautifulSoup(html)\n    headers, values = _get_headers_and_values(soup)\n    result = [\n        OrderedDict([\n            (str(headers[i]), str(y.decode_contents()))\n            for i, y in enumerate(x.select('td'))\n        ])\n        for x in values\n    ]\n    \n    return result", "response": "Converts a html table to a list of dictionaries"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef find_all_paths(G, start, end, path=[]):\r\n    path = path + [start]\r\n    if start == end:\r\n        return [path]\r\n    if start not in G.vertices:\r\n        raise GraphInsertError(\"Vertex %s doesn't exist.\" % (start,))\r\n    if end not in G.vertices:\r\n        raise GraphInsertError(\"Vertex %s doesn't exist.\" % (end,))\r\n    paths = []\r\n    for vertex in G.vertices[start]:\r\n        if vertex not in path:\r\n            newpaths = find_all_paths(G, vertex, end, path)\r\n            for newpath in newpaths:\r\n                paths.append(newpath)\r\n    return paths", "response": "Find all paths between vertices start and end in graph."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef system_call(command):\n  p = subprocess.Popen([command], stdout=subprocess.PIPE, shell=True)\n  return p.stdout.read()", "response": "Run a command and return stdout.\n Would be better to use subprocess. check_output but this works on CentOS 7."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_headers(self, session, **kwargs):\n\n        if self.auth_token is None:\n            try:\n                self._refresh_tokens(session)\n                self._fetch_credentials(session)\n            except:\n                raise AuthorizationFailure()\n\n        return {\n            'X-Auth-Token': self.auth_token,\n        }", "response": "Get the authentication header."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_endpoint(self, session, **kwargs):\n\n        if self.endpoint is None:\n            try:\n                self._refresh_tokens(session)\n                self._fetch_credentials(session)\n            except:\n                raise AuthorizationFailure()\n\n        return self.endpoint", "response": "Get the HubiC storage endpoint uri."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nrequesting an access and a refresh token from the HubiC API.", "response": "def _refresh_tokens(self, session):\n        \"\"\"Request an access and a refresh token from the HubiC API.\n\n        Those tokens are mandatory and will be used for subsequent file\n        operations. They are not returned and will be stored internaly.\n\n        :param keystoneclient.Session session: The session object to use for\n                                               queries.\n\n        :raises keystoneclient.exceptions.AuthorizationFailure: if something\n                                                                goes wrong.\n        \"\"\"\n\n        params = {\n            'client_id': self.client_id,\n            'client_secret': self.client_secret,\n        }\n\n        payload = {\n            'client_id': self.client_id,\n            'client_secret': self.client_secret,\n        }\n\n        if self.refresh_token is None:\n            # if we don't have a refresh token, we need an authorization token\n            # first\n            payload['grant_type']   = 'authorization_code'\n            payload['code']         = self._get_authorization_token(session)\n            payload['redirect_uri'] = self.redirect_uri\n        else:\n            # when we have a refresh token, we DON'T need an authorization\n            # token to request a new one\n            payload['grant_type']    = 'refresh_token'\n            payload['refresh_token'] = self.refresh_token\n\n        r = session.post(\"https://api.hubic.com/oauth/token\",\n                         params=params,\n                         data=payload,\n                         authenticated=False)\n        if r.status_code != 200 and self.refresh_token is not None:\n            # if we had a refresh token, try again without it\n            # (might be expired)\n            payload['grant_type']   = 'authorization_code'\n            payload['code']         = self._get_authorization_token(session)\n            payload['redirect_uri'] = self.redirect_uri\n            r = session.post(\"https://api.hubic.com/oauth/token\",\n                             params=params,\n                             data=payload,\n                             authenticated=False)\n\n        if r.status_code != 200:\n            raise AuthorizationFailure()\n\n        response = r.json()\n        if 'error' in response:\n            raise AuthorizationFailure()\n\n        self.access_token = response['access_token']\n\n        # refresh_token entry will not be there is we are just refreshing an\n        # old token.\n        if 'refresh_token' in response:\n            self.refresh_token = response['refresh_token']"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _fetch_credentials(self, session):\n\n        headers = {\n            'Authorization': 'Bearer {0}'.format(self.access_token),\n        }\n\n        r = session.get(\"https://api.hubic.com/1.0/account/credentials\",\n                        headers=headers,\n                        authenticated=False)\n        response = r.json()\n\n        # if we get an error here, the OpenStack SDK will take care to try\n        # again for us.\n        if 'error' in response:\n            raise AuthorizationFailure()\n\n        self.endpoint   = response['endpoint']\n        self.auth_token = response['token']", "response": "Fetch the endpoint URI and authorization token for this session."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _get_authorization_token(self, session):\n\n        request_scope = 'account.r,credentials.r'\n\n        params = {\n            'client_id': self.client_id,\n            'redirect_uri': self.redirect_uri,\n            'response_type': 'code',\n            'scope': request_scope,\n            'state': random_str_generator(),\n        }\n\n        r = session.get(\"https://api.hubic.com/oauth/auth\",\n                        params=params,\n                        authenticated=False)\n        if r.status_code != 200:\n            raise AuthorizationFailure()\n\n        oauth_match = re.search(r'name=\"oauth\" value=\"([0-9]+)\"', r.text)\n        if oauth_match is None:\n            raise AuthorizationFailure()\n\n        oauth_value = oauth_match.group(1)\n        if oauth_value is None:\n            AuthorizationFailure()\n\n        payload = {\n            'oauth': oauth_value,\n            'action': 'accepted',\n            'account': 'r',\n            'credentials': 'r',\n            'login': self.email,\n            'user_pwd': self.password,\n        }\n\n        # this is necessary because the API will return a 509 error\n        # (bandwidth exceeded) if we don't wait a little\n        time.sleep(2)\n\n        headers = {\n            'Referer': r.url,\n            'Content-Type': 'application/x-www-form-urlencoded',\n        }\n\n        r = session.post(\"https://api.hubic.com/oauth/auth\",\n                         headers=headers,\n                         data=payload,\n                         redirect=False,\n                         authenticated=False)\n        if r.status_code != 302:\n            raise AuthorizationFailure()\n\n        # location looks like this, and we need the code:\n        # http://localhost/?code=...&scope=account.r&state=randomstring\n        location_info = dict(\n            map(lambda item: item.split('='),\n                r.headers['location'].split('?')[1].split('&')\n            )\n        )\n        assert (\n            'code'  in location_info and\n            'scope' in location_info and location_info['scope'] == request_scope and\n            'state' in location_info and location_info['state'] == params['state']\n        )\n\n        return location_info['code']", "response": "Load the HubiC form and submit it and return an authorization token."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef append(self, obj):\n        h = self.func(obj)\n\n        self.list.append(obj)\n        idx = len(self.list) - 1\n        self.dict[h] = idx\n\n        return idx", "response": "Adds a new entry to the index."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget a class alias based on the supplied class object or string alias.", "response": "def getClassAlias(self, klass):\n        \"\"\"\n        Gets a class alias based on the supplied C{klass}. If one is not found\n        in the global context, one is created locally.\n\n        If you supply a string alias and the class is not registered,\n        L{pyamf.UnknownClassAlias} will be raised.\n\n        @param klass: A class object or string alias.\n        @return: The L{pyamf.ClassAlias} instance that describes C{klass}\n        \"\"\"\n        try:\n            return self._class_aliases[klass]\n        except KeyError:\n            pass\n\n        try:\n            alias = self._class_aliases[klass] = pyamf.get_class_alias(klass)\n        except pyamf.UnknownClassAlias:\n            if isinstance(klass, python.str_types):\n                raise\n\n            # no alias has been found yet .. check subclasses\n            alias = util.get_class_alias(klass) or pyamf.ClassAlias\n            meta = util.get_class_meta(klass)\n            alias = alias(klass, defer=True, **meta)\n\n            self._class_aliases[klass] = alias\n\n        return alias"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef getStringForBytes(self, s):\n        h = hash(s)\n        u = self._unicodes.get(h, None)\n\n        if u is not None:\n            return u\n\n        u = self._unicodes[h] = s.decode('utf-8')\n\n        return u", "response": "Returns the corresponding string for the supplied utf - 8 encoded bytes."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef getBytesForString(self, u):\n        h = hash(u)\n        s = self._unicodes.get(h, None)\n\n        if s is not None:\n            return s\n\n        s = self._unicodes[h] = u.encode('utf-8')\n\n        return s", "response": "Returns the corresponding utf - 8 encoded string for a given unicode\n        object."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef readElement(self):\n        pos = self.stream.tell()\n\n        try:\n            t = self.stream.read(1)\n        except IOError:\n            raise pyamf.EOStream\n\n        try:\n            func = self._func_cache[t]\n        except KeyError:\n            func = self.getTypeFunc(t)\n\n            if not func:\n                raise pyamf.DecodeError(\"Unsupported ActionScript type %s\" % (\n                    hex(ord(t)),))\n\n            self._func_cache[t] = func\n\n        try:\n            return func()\n        except IOError:\n            self.stream.seek(pos)\n\n            raise", "response": "Reads an AMF3 element from the data stream."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef writeSequence(self, iterable):\n        try:\n            alias = self.context.getClassAlias(iterable.__class__)\n        except (AttributeError, pyamf.UnknownClassAlias):\n            self.writeList(iterable)\n\n            return\n\n        if alias.external:\n            # a is a subclassed list with a registered alias - push to the\n            # correct method\n            self.writeObject(iterable)\n\n            return\n\n        self.writeList(iterable)", "response": "Writes an iterable to the internal buffer."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef writeGenerator(self, gen):\n        n = getattr(gen, 'next')\n\n        while True:\n            try:\n                self.writeElement(n())\n            except StopIteration:\n                break", "response": "Writes the contents of a generator object to the underlying output stream."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a callable that will encode the data to the stream.", "response": "def getTypeFunc(self, data):\n        \"\"\"\n        Returns a callable that will encode C{data} to C{self.stream}. If\n        C{data} is unencodable, then C{None} is returned.\n        \"\"\"\n        if data is None:\n            return self.writeNull\n\n        t = type(data)\n\n        # try types that we know will work\n        if t is str or issubclass(t, str):\n            return self.writeBytes\n        if t is unicode or issubclass(t, unicode):\n            return self.writeString\n        elif t is bool:\n            return self.writeBoolean\n        elif t is float:\n            return self.writeNumber\n        elif t in python.int_types:\n            return self.writeNumber\n        elif t in (list, tuple):\n            return self.writeList\n        elif isinstance(data, (list, tuple)):\n            return self.writeSequence\n        elif t is types.GeneratorType:\n            return self.writeGenerator\n        elif t is pyamf.UndefinedType:\n            return self.writeUndefined\n        elif t in (datetime.date, datetime.datetime, datetime.time):\n            return self.writeDate\n        elif xml.is_xml(data):\n            return self.writeXML\n\n        # check for any overridden types\n        for type_, func in pyamf.TYPE_MAP.iteritems():\n            try:\n                if isinstance(data, type_):\n                    return _CustomTypeFunc(self, func)\n            except TypeError:\n                if python.callable(type_) and type_(data):\n                    return _CustomTypeFunc(self, func)\n\n        # now try some types that won't encode\n        if t in python.class_types:\n            # can't encode classes\n            return None\n        elif isinstance(data, python.func_types):\n            # can't encode code objects\n            return None\n        elif isinstance(t, types.ModuleType):\n            # cannot encode module objects\n            return None\n\n        # well, we tried ..\n        return self.writeObject"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef writeElement(self, data):\n        key = type(data)\n        func = None\n\n        try:\n            func = self._func_cache[key]\n        except KeyError:\n            func = self.getTypeFunc(data)\n\n            if func is None:\n                raise pyamf.EncodeError('Unable to encode %r (type %r)' % (\n                    data, key))\n\n            self._func_cache[key] = func\n\n        func(data)", "response": "Encodes the data to AMF."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add_triple_pattern(tp, collector, args):\n    tp_parts = [part.strip() for part in tp.strip().split(' ')]\n    tp = ' '.join(tp_parts)\n    if tp not in __triple_patterns.keys():\n        __triple_patterns[tp] = set([])\n    if collector is not None:\n        __triple_patterns[tp].add((collector, args))", "response": "0\n    Manage the relations between triple patterns and collector functions\n   "}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nextract and bind the triple patterns contained in the search plan.", "response": "def __extract_pattern_nodes(graph):\n    \"\"\"\n    Extract and bind the triple patterns contained in the search plan, so as to be able to identify\n    to which pattern is associated each triple of the fragment.\n    :return:\n    \"\"\"\n    tp_nodes = graph.subjects(RDF.type, AGORA.TriplePattern)\n    for tpn in tp_nodes:\n        subject = list(graph.objects(tpn, AGORA.subject)).pop()\n        predicate = list(graph.objects(tpn, AGORA.predicate)).pop()\n        obj = list(graph.objects(tpn, AGORA.object)).pop()\n        subject_str = list(graph.objects(subject, RDFS.label)).pop().toPython()\n        predicate_str = graph.qname(predicate)\n        if (obj, RDF.type, AGORA.Variable) in graph:\n            object_str = list(graph.objects(obj, RDFS.label)).pop().toPython()\n        else:\n            object_str = list(graph.objects(obj, AGORA.value)).pop().toPython()\n        __plan_patterns[tpn] = '{} {} {}'.format(subject_str, predicate_str, object_str)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nexecute a search plan for the declared graph pattern and sends all obtained triples to the corresponding Taxonomy collector functions.", "response": "def collect_fragment(event, agora_host):\n    \"\"\"\n    Execute a search plan for the declared graph pattern and sends all obtained triples to the corresponding\n    collector functions (config\n    \"\"\"\n    agora = Agora(agora_host)\n    graph_pattern = \"\"\n    for tp in __triple_patterns:\n        graph_pattern += '{} . '.format(tp)\n    fragment, _, graph = agora.get_fragment_generator('{%s}' % graph_pattern, stop_event=event, workers=4)\n    __extract_pattern_nodes(graph)\n    log.info('querying { %s}' % graph_pattern)\n    for (t, s, p, o) in fragment:\n        collectors = __triple_patterns[str(__plan_patterns[t])]\n        for c, args in collectors:\n            log.debug('Sending triple {} {} {} to {}'.format(s.n3(graph.namespace_manager), graph.qname(p),\n                                                             o.n3(graph.namespace_manager), c))\n            c((s, p, o))\n            if event.isSet():\n                raise Exception('Abort collecting fragment')\n            yield (c.func_name, (t, s, p, o))"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\niterate over a DAVID result set and yeild GeneOntologyTerm objects that are in the same format as the original DAVID result set.", "response": "def david_results_iterator(fn, verbose=False):\n  \"\"\"\n  Iterate over a DAVID result set and yeild GeneOntologyTerm objects\n  representing each of the terms reported. The expected format for a DAVID\n  result file is tab-seperated format. The following fields should be present:\n\n  ===  ===============  ==========  ====================================\n  Num  Field                 Type        Example\n  ===  ===============  ==========  ====================================\n  0    Category         string      GOTERM_BP_FAT\n  1    Term             string      GO:0046907~intracellular transport\n  2    Count            int         43\n  3    Percent          float       11.345646437994723\n  4    PValue           float       1.3232857694449546E-9\n  5    Genes            string      ARSB, KPNA6, GNAS\n  6    List Total       int         310\n  7    Pop Hits         int         657\n  8    Pop Total        int         13528\n  9    Fold Enrichment  float       2.8561103746256196\n  10   Bonferroni       float       2.6293654579179204E-6\n  11   Benjamini        float       2.6293654579179204E-6\n  12   FDR              float       2.2734203852792234E-6\n  ===  ===============  ==========  ====================================\n\n  The first line is a header giving the field names -- this is ignored though,\n  and we expect them in the order given above.\n\n  Most of the fields are ignored at present; we take fields 0,1, and 11 (as the\n  significance/p-value). When parsing the term field, we try to extract a term\n  ID by splitting on tilde, but if we can't then this is set to None.\n\n  :param fn: the file to parse\n  :param verbose: if True, output progress to stderr.\n  \"\"\"\n  first = True\n  for line in open(fn):\n    line = line.strip()\n    if line == \"\":\n      continue\n    if first:\n      first = False\n      continue\n\n    parts = line.split(\"\\t\")\n    if len(parts) != NUM_FIELDS_IN_DAVID_RECORD:\n      raise IOError(\"failed to parse \" + fn + \" as DAVID result file. \"\n                    + \"Expected \" + str(NUM_FIELDS_IN_DAVID_RECORD) + \" \"\n                    + \"tab-separated fields, but found \"\n                    + str(len(parts)) + \" instead\")\n    n_parts = parts[1].split(\"~\")\n    name = n_parts[-1].strip()\n    identifier = n_parts[0] if len(n_parts) > 1 else None\n    catagory = parts[0].strip()\n    try:\n      p_val = float(parts[PVAL_FIELD_NUM])\n    except ValueError:\n      raise IOError(\"Failed to parse \" + fn + \" as DAVID result file. \"\n                    + \"Expected field \" + str(PVAL_FIELD_NUM) + \" \"\n                    + \"to contain a floating point number \"\n                    + \"(Benjamini), found this instead: \"\n                    + str(parts[PVAL_FIELD_NUM]))\n    yield GeneOntologyEnrichmentResult(name, p_val, identifier, catagory)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets a single option from a section", "response": "def get(key, section='main'):\n    \"\"\" Get a single option from \"\"\"\n    return nago.settings.get_option(option_name=key, section_name=section)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef getattribute(value, arg):\n    \n    if callable(getattr(value, arg)):\n        return str(getattr(value, arg)())\n    elif hasattr(value, str(arg)):\n        return getattr(value, arg)\n    elif hasattr(value, 'has_key') and value.has_key(arg):\n        return value[arg]\n    elif numeric_test.match(str(arg)) and len(value) > int(arg):\n        return value[int(arg)]\n    elif arg in dir(value):\n        return getattr(value, arg)()\n    else:\n        return settings.TEMPLATE_STRING_IF_INVALID", "response": "Gets an attribute of an object dynamically from a string name"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _read_wave(self, path):\n        with contextlib.closing(wave.open(path, 'rb')) as wf:\n            num_channels = wf.getnchannels()\n            assert num_channels == 1\n            sample_width = wf.getsampwidth()\n            assert sample_width == 2\n            sample_rate = wf.getframerate()\n            assert sample_rate in (8000, 16000, 32000)\n            pcm_data = wf.readframes(wf.getnframes())\n            return pcm_data, sample_rate", "response": "Reads a. wav file. Returns the PCM audio data and sample rate."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ngenerate audio frames from the PCM audio data.", "response": "def _frame_generator(self, frame_duration_ms, audio, sample_rate):\n        \"\"\"Generates audio frames from PCM audio data.\n        Takes the desired frame duration in milliseconds, the PCM data, and\n        the sample rate.\n        Yields Frames of the requested duration.\n        \"\"\"\n        n = int(sample_rate * (frame_duration_ms / 1000.0) * 2)\n        offset = 0\n        timestamp = 0.0\n        duration = (float(n) / sample_rate) / 2.0\n        while offset + n < len(audio):\n            yield self.Frame(audio[offset:offset + n], timestamp, duration)\n            timestamp += duration\n            offset += n"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _vad_collector(self, sample_rate, frame_duration_ms,\n                       padding_duration_ms, vad, frames):\n        \"\"\"Filters out non-voiced audio frames.\n        Given a webrtcvad.Vad and a source of audio frames, yields only\n        the voiced audio.\n        Uses a padded, sliding window algorithm over the audio frames.\n        When more than 90% of the frames in the window are voiced (as\n        reported by the VAD), the collector triggers and begins yielding\n        audio frames. Then the collector waits until 90% of the frames in\n        the window are unvoiced to detrigger.\n        The window is padded at the front and back to provide a small\n        amount of silence or the beginnings/endings of speech around the\n        voiced frames.\n        Arguments:\n        sample_rate - The audio sample rate, in Hz.\n        frame_duration_ms - The frame duration in milliseconds.\n        padding_duration_ms - The amount to pad the window, in milliseconds.\n        vad - An instance of webrtcvad.Vad.\n        frames - a source of audio frames (sequence or generator).\n        Returns: A generator that yields PCM audio data.\n        \"\"\"\n        num_padding_frames = int(padding_duration_ms / frame_duration_ms)\n        # We use a deque for our sliding window/ring buffer.\n        ring_buffer = collections.deque(maxlen=num_padding_frames)\n        # We have two states: TRIGGERED and NOTTRIGGERED. We start in the\n        # NOTTRIGGERED state.\n        triggered = False\n\n        voiced_frames = []\n        for frame in frames:\n            is_speech = vad.is_speech(frame.bytes, sample_rate)\n\n            if not triggered:\n                ring_buffer.append((frame, is_speech))\n                num_voiced = len([f for f, speech in ring_buffer if speech])\n                # If we're NOTTRIGGERED and more than 90% of the frames in\n                # the ring buffer are voiced frames, then enter the\n                # TRIGGERED state.\n                if num_voiced > 0.9 * ring_buffer.maxlen:\n                    triggered = True\n                    # We want to yield all the audio we see from now until\n                    # we are NOTTRIGGERED, but we have to start with the\n                    # audio that's already in the ring buffer.\n                    for f, s in ring_buffer:\n                        voiced_frames.append(f)\n                    ring_buffer.clear()\n            else:\n                # We're in the TRIGGERED state, so collect the audio data\n                # and add it to the ring buffer.\n                voiced_frames.append(frame)\n                ring_buffer.append((frame, is_speech))\n                num_unvoiced = len([f for f, speech in ring_buffer if not speech])\n                # If more than 90% of the frames in the ring buffer are\n                # unvoiced, then enter NOTTRIGGERED and yield whatever\n                # audio we've collected.\n                if num_unvoiced > 0.9 * ring_buffer.maxlen:\n                    triggered = False\n                    voiced_frames = voiced_frames[0:len(voiced_frames)-len(ring_buffer)]\n                    yield voiced_frames\n                    ring_buffer.clear()\n                    voiced_frames = []\n        if voiced_frames:\n            yield voiced_frames", "response": "A generator that yields PCM audio data from a VAD."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nfinalise the request. @param request: The HTTP Request. @type request: C{http.Request} @param status: The HTTP status code. @type status: C{int} @param content: The content of the response. @type content: C{str} @param mimetype: The MIME type of the request. @type mimetype: C{str}", "response": "def _finaliseRequest(self, request, status, content, mimetype='text/plain'):\n        \"\"\"\n        Finalises the request.\n\n        @param request: The HTTP Request.\n        @type request: C{http.Request}\n        @param status: The HTTP status code.\n        @type status: C{int}\n        @param content: The content of the response.\n        @type content: C{str}\n        @param mimetype: The MIME type of the request.\n        @type mimetype: C{str}\n        \"\"\"\n        request.setResponseCode(status)\n\n        request.setHeader(\"Content-Type\", mimetype)\n        request.setHeader(\"Content-Length\", str(len(content)))\n        request.setHeader(\"Server\", gateway.SERVER_NAME)\n\n        request.write(content)\n        request.finish()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nhandling the HTTP POST request.", "response": "def render_POST(self, request):\n        \"\"\"\n        Read remoting request from the client.\n\n        @type request: The HTTP Request.\n        @param request: C{twisted.web.http.Request}\n        \"\"\"\n        def handleDecodeError(failure):\n            \"\"\"\n            Return HTTP 400 Bad Request.\n            \"\"\"\n            errMesg = \"%s: %s\" % (failure.type, failure.getErrorMessage())\n\n            if self.logger:\n                self.logger.error(errMesg)\n                self.logger.error(failure.getTraceback())\n\n            body = \"400 Bad Request\\n\\nThe request body was unable to \" \\\n                \"be successfully decoded.\"\n\n            if self.debug:\n                body += \"\\n\\nTraceback:\\n\\n%s\" % failure.getTraceback()\n\n            self._finaliseRequest(request, 400, body)\n\n        request.content.seek(0, 0)\n        timezone_offset = self._get_timezone_offset()\n\n        d = threads.deferToThread(remoting.decode, request.content.read(),\n            strict=self.strict, logger=self.logger,\n            timezone_offset=timezone_offset)\n\n        def cb(amf_request):\n            if self.logger:\n                self.logger.debug(\"AMF Request: %r\" % amf_request)\n\n            x = self.getResponse(request, amf_request)\n\n            x.addCallback(self.sendResponse, request)\n\n        # Process the request\n        d.addCallback(cb).addErrback(handleDecodeError)\n\n        return server.NOT_DONE_YET"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nprocess the AMF request and returns an AMF L { Response.", "response": "def getResponse(self, http_request, amf_request):\n        \"\"\"\n        Processes the AMF request, returning an AMF L{Response}.\n\n        @param http_request: The underlying HTTP Request\n        @type http_request: C{twisted.web.http.Request}\n        @param amf_request: The AMF Request.\n        @type amf_request: L{Envelope<pyamf.remoting.Envelope>}\n        \"\"\"\n        response = remoting.Envelope(amf_request.amfVersion)\n        dl = []\n\n        def cb(body, name):\n            response[name] = body\n\n        for name, message in amf_request:\n            processor = self.getProcessor(message)\n\n            http_request.amf_request = message\n\n            d = defer.maybeDeferred(\n                processor, message, http_request=http_request)\n\n            dl.append(d.addCallback(cb, name))\n\n        def cb2(result):\n            return response\n\n        def eb(failure):\n            \"\"\"\n            Return 500 Internal Server Error.\n            \"\"\"\n            errMesg = \"%s: %s\" % (failure.type, failure.getErrorMessage())\n\n            if self.logger:\n                self.logger.error(errMesg)\n                self.logger.error(failure.getTraceback())\n\n            body = \"500 Internal Server Error\\n\\nThe request was unable to \" \\\n                \"be successfully processed.\"\n\n            if self.debug:\n                body += \"\\n\\nTraceback:\\n\\n%s\" % failure.getTraceback()\n\n            self._finaliseRequest(http_request, 500, body)\n\n        d = defer.DeferredList(dl)\n\n        return d.addCallback(cb2).addErrback(eb)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nprocess an authentication request.", "response": "def authenticateRequest(self, service_request, username, password, **kwargs):\n        \"\"\"\n        Processes an authentication request. If no authenticator is supplied,\n        then authentication succeeds.\n\n        @return: C{Deferred}.\n        @rtype: C{twisted.internet.defer.Deferred}\n        \"\"\"\n        authenticator = self.getAuthenticator(service_request)\n\n        if self.logger:\n            self.logger.debug('Authenticator expands to: %r' % authenticator)\n\n        if authenticator is None:\n            return defer.succeed(True)\n\n        args = (username, password)\n\n        if hasattr(authenticator, '_pyamf_expose_request'):\n            http_request = kwargs.get('http_request', None)\n            args = (http_request,) + args\n\n        return defer.maybeDeferred(authenticator, *args)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding new log entries to the current log level", "response": "def addNewLvls(self):\n        \"\"\"\n        +---------------------+----------------------+\n        |    Standard Levels  |        New Levels    |\n        +---------------+-----+----------------+-----+\n        |    Name       |Level|  Name          |Level|\n        +===============+=====+================+=====+\n        |               |     |RAISEMSG        | 99  |\n        +---------------+-----+----------------+-----+\n        |CRITICAL       |  50 |                |     | \n        +---------------+-----+----------------+-----+\n        |ERROR          |  40 |                |     |\n        +---------------+-----+----------------+-----+\n        |WARNING        |  30 |                |     |\n        +---------------+-----+----------------+-----+\n        |               |     |IMPORTANTINFO   | 25  |\n        +---------------+-----+----------------+-----+\n        |INFO           |  20 |                |     |\n        +---------------+-----+----------------+-----+\n        |DEBUG          |  10 |                |     |\n        +---------------+-----+----------------+-----+\n        |               |     |FILEONLY        |  1  |\n        +---------------+-----+----------------+-----+\n        |NOTSET         |  0  |                |     |\n        +---------------+-----+----------------+-----+\n        \"\"\"\n        # Level for raise message to print to file (File only)\n        RAISEMSG = 99\n        logging.addLevelName(RAISEMSG, 'RAISEMSG')\n        def raisemsg(self,msg,lvl=RAISEMSG, *args, **kws):\n            self.log(lvl,msg, *args, **kws)\n        logging.Logger.raisemsg = raisemsg\n        # Level for minimal info more important than standard INFO level\n        IMPORTANTINFO = 25\n        logging.addLevelName(IMPORTANTINFO, 'IMPORTANTINFO')\n        def importantinfo(self,msg,lvl=IMPORTANTINFO, *args, **kws):\n            self.log(lvl,msg, *args, **kws)\n        logging.Logger.importantinfo = importantinfo\n        # Level for message to ONLY be written to file and not the screen\n        FILEONLY = 1\n        logging.addLevelName(FILEONLY, 'FILEONLY')\n        def fileonly(self,msg,lvl=FILEONLY, *args, **kws):\n            self.log(lvl,msg, *args, **kws)\n        logging.Logger.fileonly = fileonly"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting the level of the stream handler for a logging object.", "response": "def setStreamLevel(self,lvl=20):\n        \"\"\"\n        Set/change the level for the stream handler for a logging object.\n        Any file handlers will be left alone.\n        All messages of a higher severity level than 'lvl' will be printed \n        to the screen.\n        \n        Args:    \n            lvl (int): The severity level of messages printed to the screen with \n                    the stream handler, default = 20.\n        \"\"\"\n        # Kill off the old handlers and reset them with the setHandlers func\n        for i in range(0,len(self.handlers)):\n            h = self.handlers[i]\n            if isinstance(h,logging.StreamHandler):\n                self.removeHandler(h)\n                break\n        self.addStreamHandler(lvl)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget and return current stream handler s level.", "response": "def getStreamLevel(self):\n        \"\"\"\n        Get and return current stream handler's level.\n        \"\"\"\n        shlvl = 0\n        for i in range(0,len(self.handlers)):\n            h = self.handlers[i]\n            if isinstance(h,logging.StreamHandler):\n                shlvl = h.level\n        return shlvl"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef addStreamHandler(self,lvl=20):\n        sh = logging.StreamHandler(sys.stdout)\n        sh.setLevel(lvl)\n        sFrmt = logging.Formatter('%(message)s')\n        if False:\n            #Another format example\n            sFrmt = logging.Formatter('%(name)s - %(levelname)s - %(message)s')\n        sh.setFormatter(sFrmt)\n        self.addHandler(sh)", "response": "This function will add a stream handler to the log with the provided severity level."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef logSystemInfo(self):\n        t = datetime.date.today()\n        infoStr = 'Date KMlogger object instantiated: '+t.strftime('%b %d, %Y')+'\\n\\n'\n        infoStr+=\"\\n\"+\"=\"*11+' System Information Summary '+'='*11\n        infoStr+=\"\\n\"+'OS type = '+platform.uname()[0]\n        infoStr+=\"\\n\"+'OS Version = '+platform.uname()[2]\n        infoStr+=\"\\n\"+'Machine UserName = '+platform.uname()[1]\n        infoStr+=\"\\n\"+'Machine Processor Type = '+platform.processor()\n        multiprocessing.cpu_count()\n        ## Some Macs have issues installing psutil, so I will remove it as a dependency for now.\n        #import psutil \n        #totMem = int(round(psutil.virtual_memory()[0]/1073741824.0))\n        #percentMem = int(round(psutil.virtual_memory()[2]))\n        infoStr+=\"\\n\"+'Python Version = '+repr(platform.python_version())\n        infoStr+=\"\\n\"+'='*50\n        self.fileonly(infoStr)", "response": "A function that creates a log file with the information about the computer it is running on and the software version of the computer it is running on."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nlogs all Key = value for every key in a dictionary.", "response": "def logDict(self,d):\n        \"\"\"\n        Log all Key=value for every key in a dictionary.\n          \n        Args:\n            d (dictionary): A standard python dictionary.\n        \"\"\"\n        keys = list(d.keys())\n        keys.sort()\n        s = \"\\n\"+\"-\"*78+\"\\n\"+\" \"*20+\"dictionary provided contains:\\n\"+\"-\"*78+\"\\n\"\n        for key in keys:\n            s+=key+\" = \"+repr(d[key])+\"\\n\"\n        self.fileonly(s+\"-\"*78+\"\\n\")"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nchecking if we authorised the token", "response": "def check_auth():\n    \"\"\"\n    Check are we authorised\n    :return: True if we authorised\n        False if no auth provided\n        exception if provided auth is wrong\n    \"\"\"\n    if get_oauth_token():\n        auth_info = get_auth_info()\n        if not auth_info:\n            raise MissingTokenInfoException(\"Could not get token info\")\n        if datetime.now() >= auth_info['expires_at']:\n            msg = (\n                'Token is expired. Now %s but valid until %s',\n                datetime.now(), auth_info['expires_at']\n            )\n\n            log.warn(\n                msg[0], *msg[1:]\n            )\n            raise TokenIsExpired(msg[0] % msg[1:])\n    else:\n        raise MissingTokenException()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef install_wrapper(cls, install, new_class):\n        def _wrapped(self, *args, **kwargs):\n            if self.installed:\n                raise AssertionError('Module %s is already installed'\n                                     % self.verbose_name)\n\n            logger.info(\"Installing %s module\" % self.verbose_name)\n            pre_install.send(sender=self)\n            res = install(self, *args, **kwargs)\n            post_install.send(sender=self)\n\n            info = self._info\n            info.status = ModuleInfo.DISABLED\n            info.save()\n\n            logger.info(\"Installed %s module\" % self.verbose_name)\n            return res\n\n        return _wrapped", "response": "Wrap the install method to call pre and post enable signals and update\n            module status"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nwrapping the enable method to call pre and post enable signals and update the module status", "response": "def enable_wrapper(cls, enable, new_class):\n        \"\"\"\n        Wrap the enable method to call pre and post enable signals and update\n        module status\n        \"\"\"\n        def _wrapped(self, *args, **kwargs):\n            if not self.installed:\n                raise AssertionError('Module %s cannot be enabled'\n                                     ', you should install it first'\n                                     % self.verbose_name)\n\n            if self.enabled:\n                raise AssertionError('Module %s is already enabled'\n                                     % self.verbose_name)\n\n            logger.info(\"Enabling %s module\" % self.verbose_name)\n            pre_enable.send(sender=self)\n            res = enable(self, *args, **kwargs)\n\n            # Register interfaces (if present)\n            if isinstance(self, DropletInterface):\n                self.register()\n\n            post_enable.send(sender=self)\n\n            info = self._info\n            info.status = ModuleInfo.ENABLED\n            info.save()\n\n            logger.info(\"Enabled %s module\" % self.verbose_name)\n            return res\n\n        return _wrapped"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nwrapping the save method to call pre and post enable signals and update module status alid", "response": "def save_wrapper(cls, save, new_class):\n        \"\"\"\n        Wrap the save method to call pre and post enable signals and update\n        module status\n        \"\"\"\n        def _wrapped(self, *args, **kwargs):\n            if not self.installed:\n                raise AssertionError('Module %s is not installed' %\n                                     self.verbose_name)\n\n            logger.info(\"Saving %s module\" % self.verbose_name)\n            pre_save.send(sender=self)\n            res = save(self, *args, **kwargs)\n            post_save.send(sender=self)\n            logger.info(\"Saved %s module\" % self.verbose_name)\n\n            return res\n\n        return _wrapped"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nwraps the disable method to call pre and post disable signals and update module status", "response": "def disable_wrapper(cls, disable, new_class):\n        \"\"\"\n        Wrap the disable method to call pre and post disable signals and update\n        module status\n        \"\"\"\n        def _wrapped(self, *args, **kwargs):\n            if not self.enabled:\n                raise AssertionError('Module %s is already disabled'\n                                     % self.verbose_name)\n\n            logger.info(\"Disabling %s module\" % self.verbose_name)\n            pre_disable.send(sender=self)\n            res = disable(self, *args, **kwargs)\n\n            # Unregister interfaces (if present)\n            if isinstance(self, DropletInterface):\n                self.unregister()\n\n            post_disable.send(sender=self)\n\n            info = self._info\n            info.status = ModuleInfo.DISABLED\n            info.save()\n\n            logger.info(\"Disabled %s module\" % self.verbose_name)\n            return res\n\n        return _wrapped"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _info(self):\n        name = self.__class__.__module__ + '.' + self.__class__.__name__\n        info, created = ModuleInfo.objects.get_or_create(name=name)\n        if created:\n            # Do not set as changed\n            info.commit()\n        return info", "response": "Return a ModuleInfo object for this object."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ntells if the module configuration has been changed", "response": "def changed(self):\n        \"\"\"\n        Tells if module configuration has been changed (it needs to be saved)\n        \"\"\"\n        # Not installed modules cannot issue a change to save\n        if not self.installed:\n            return False\n\n        # Check if module status changed\n        if self._info._changed:\n            return True\n\n        # Check model changes\n        for model in self.models():\n            if model.objects.changed().count() or \\\n               model.objects.deleted().count():\n                return True\n\n        # Nothing passed, module not changed\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef models(self):\n        app = get_app(self.__class__.__module__.split('.')[-2])\n        return get_models(app)", "response": "Return all the models defined for this module"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef conf_files(self):\n        for attr in dir(self):\n            field = getattr(self, attr)\n            if isinstance(field, ConfFile):\n                yield field", "response": "Yields all configuration files for this module."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef restart(self):\n        # Call stop & start if any of them was overriden\n        if self.__class__.stop != Module.stop or \\\n           self.__class__.start != Module.start:\n            self.stop()\n            self.start()\n        else:\n            # If not, restart is better\n            for daemon in self.daemons():\n                daemon.restart()", "response": "Restarts the module based on its current state."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nyield all daemons for this module", "response": "def daemons(self):\n        \"\"\"\n        List of daemons for this module\n        \"\"\"\n        for attr in dir(self):\n            field = getattr(self, attr)\n            if isinstance(field, Daemon):\n                yield field"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting an endpoint by endpoint id", "response": "def get_endpoint_by_endpoint_id(self, endpoint_id):\n        \"\"\"\n        Get an endpoint by endpoint id\n        \"\"\"\n        self._validate_uuid(endpoint_id)\n\n        url = \"/notification/v1/endpoint/{}\".format(endpoint_id)\n\n        response = NWS_DAO().getURL(url, self._read_headers)\n        if response.status != 200:\n            raise DataFailureException(url, response.status, response.data)\n\n        data = json.loads(response.data)\n        return self._endpoint_from_json(data.get(\"Endpoint\"))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets an endpoint by subscriber_id and protocol", "response": "def get_endpoint_by_subscriber_id_and_protocol(\n            self, subscriber_id, protocol):\n        \"\"\"\n        Get an endpoint by subscriber_id and protocol\n        \"\"\"\n        self._validate_subscriber_id(subscriber_id)\n        self._validate_endpoint_protocol(protocol)\n\n        url = \"/notification/v1/endpoint?subscriber_id={}&protocol={}\".format(\n            subscriber_id, protocol)\n\n        response = NWS_DAO().getURL(url, self._read_headers)\n\n        if response.status != 200:\n            raise DataFailureException(url, response.status, response.data)\n\n        data = json.loads(response.data)\n        try:\n            return self._endpoint_from_json(data.get(\"Endpoints\")[0])\n        except IndexError:\n            raise DataFailureException(url, 404, \"No SMS endpoint found\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets an endpoint by address", "response": "def get_endpoint_by_address(self, endpoint_addr):\n        \"\"\"\n        Get an endpoint by address\n        \"\"\"\n        url = \"/notification/v1/endpoint?endpoint_address={}\".format(\n            endpoint_addr)\n\n        response = NWS_DAO().getURL(url, self._read_headers)\n\n        if response.status != 200:\n            raise DataFailureException(url, response.status, response.data)\n\n        data = json.loads(response.data)\n        try:\n            return self._endpoint_from_json(data.get(\"Endpoints\")[0])\n        except IndexError:\n            raise DataFailureException(url, 404, \"No SMS endpoint found\")"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_endpoints_by_subscriber_id(self, subscriber_id):\n        self._validate_subscriber_id(subscriber_id)\n\n        url = \"/notification/v1/endpoint?subscriber_id={}\".format(\n            subscriber_id)\n\n        response = NWS_DAO().getURL(url, self._read_headers)\n\n        if response.status != 200:\n            raise DataFailureException(url, response.status, response.data)\n\n        data = json.loads(response.data)\n\n        endpoints = []\n        for datum in data.get(\"Endpoints\", []):\n            endpoints.append(self._endpoint_from_json(datum))\n        return endpoints", "response": "Search for all endpoints by a given subscriber_id"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nre-sends SMS verification message to endpoint s phone number", "response": "def resend_sms_endpoint_verification(self, endpoint_id):\n        \"\"\"\n        Calls NWS function to resend verification message to endpoint's\n        phone number\n        \"\"\"\n        self._validate_uuid(endpoint_id)\n\n        url = \"/notification/v1/endpoint/{}/verification\".format(endpoint_id)\n\n        response = NWS_DAO().postURL(url, None, None)\n\n        if response.status != 202:\n            raise DataFailureException(url, response.status, response.data)\n        return response.status"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef delete_endpoint(self, endpoint_id):\n        self._validate_uuid(endpoint_id)\n\n        url = \"/notification/v1/endpoint/{}\".format(endpoint_id)\n        response = NWS_DAO().deleteURL(url, self._write_headers())\n\n        if response.status != 204:\n            raise DataFailureException(url, response.status, response.data)\n        return response.status", "response": "Delete an existing endpoint"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nupdate an existing endpoint", "response": "def update_endpoint(self, endpoint):\n        \"\"\"\n        Update an existing endpoint\n        :param endpoint: is the updated endpoint the client wants to update\n        \"\"\"\n        self._validate_uuid(endpoint.endpoint_id)\n        self._validate_subscriber_id(endpoint.subscriber_id)\n\n        url = \"/notification/v1/endpoint/{}\".format(endpoint.endpoint_id)\n        response = NWS_DAO().putURL(\n            url, self._write_headers(), self._json_body(endpoint.json_data()))\n\n        if response.status != 204:\n            raise DataFailureException(url, response.status, response.data)\n        return response.status"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating a new endpoint in the cluster.", "response": "def create_endpoint(self, endpoint):\n        \"\"\"\n        Create a new endpoint\n        :param endpoint: is the new endpoint that the client wants to create\n        \"\"\"\n        self._validate_subscriber_id(endpoint.subscriber_id)\n\n        url = \"/notification/v1/endpoint\"\n        response = NWS_DAO().postURL(\n            url, self._write_headers(), self._json_body(endpoint.json_data()))\n\n        if response.status != 201:\n            raise DataFailureException(url, response.status, response.data)\n        return response.status"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef delete_subscription(self, subscription_id):\n        self._validate_uuid(subscription_id)\n\n        url = \"/notification/v1/subscription/{}\".format(subscription_id)\n        response = NWS_DAO().deleteURL(url, self._write_headers())\n\n        if response.status != 204:\n            raise DataFailureException(url, response.status, response.data)\n\n        return response.status", "response": "Delete an existing subscription"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate a new subscription", "response": "def create_subscription(self, subscription):\n        \"\"\"\n        Create a new subscription\n        :param subscription: the new subscription the client wants to create\n        \"\"\"\n        if subscription.subscription_id is not None:\n            self._validate_uuid(subscription.subscription_id)\n\n        if subscription.endpoint is not None:\n            if subscription.endpoint.subscriber_id is not None:\n                self._validate_subscriber_id(\n                    subscription.endpoint.subscriber_id)\n\n            if subscription.endpoint.endpoint_id is not None:\n                self._validate_uuid(subscription.endpoint.endpoint_id)\n\n        if subscription.channel is not None:\n            self._validate_uuid(subscription.channel.channel_id)\n\n        url = \"/notification/v1/subscription\"\n        response = NWS_DAO().postURL(url, self._write_headers(),\n                                     self._json_body(subscription.json_data()))\n\n        if response.status != 201:\n            raise DataFailureException(url, response.status, response.data)\n\n        return response.status"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nsearch for all subscriptions by a given subscriber_id", "response": "def get_subscriptions_by_subscriber_id(\n            self, subscriber_id, max_results=10):\n        \"\"\"\n        Search for all subscriptions by a given subscriber\n        \"\"\"\n        return self.search_subscriptions(\n            subscriber_id=subscriber_id, max_results=max_results)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_subscriptions_by_channel_id_and_subscriber_id(\n            self, channel_id, subscriber_id):\n        \"\"\"\n        Search for all subscriptions by a given channel and subscriber\n        \"\"\"\n        return self.search_subscriptions(\n            channel_id=channel_id, subscriber_id=subscriber_id)", "response": "Search for all subscriptions by a given channel and subscriber."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_subscriptions_by_channel_id_and_person_id(\n            self, channel_id, person_id):\n        \"\"\"\n        Search for all subscriptions by a given channel and person\n        \"\"\"\n        return self.search_subscriptions(\n            channel_id=channel_id, person_id=person_id)", "response": "Search for all subscriptions by a given channel and person."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsearches for a subscription by a given channel and endpoint ID.", "response": "def get_subscription_by_channel_id_and_endpoint_id(\n            self, channel_id, endpoint_id):\n        \"\"\"\n        Search for subscription by a given channel and endpoint\n        \"\"\"\n        subscriptions = self.search_subscriptions(\n            channel_id=channel_id, endpoint_id=endpoint_id)\n\n        try:\n            return subscriptions[0]\n        except IndexError:\n            raise DataFailureException(url, 404, \"No subscription found\")"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nsearch for all subscriptions by parameters", "response": "def search_subscriptions(self, **kwargs):\n        \"\"\"\n        Search for all subscriptions by parameters\n        \"\"\"\n        params = [(key, kwargs[key]) for key in sorted(kwargs.keys())]\n        url = \"/notification/v1/subscription?{}\".format(\n            urlencode(params, doseq=True))\n\n        response = NWS_DAO().getURL(url, self._read_headers)\n\n        if response.status != 200:\n            raise DataFailureException(url, response.status, response.data)\n\n        data = json.loads(response.data)\n        subscriptions = []\n        for datum in data.get(\"Subscriptions\", []):\n            subscriptions.append(self._subscription_from_json(datum))\n        return subscriptions"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_channel_by_channel_id(self, channel_id):\n        self._validate_uuid(channel_id)\n\n        url = \"/notification/v1/channel/{}\".format(channel_id)\n\n        response = NWS_DAO().getURL(url, self._read_headers)\n\n        if response.status != 200:\n            raise DataFailureException(url, response.status, response.data)\n\n        data = json.loads(response.data)\n        return self._channel_from_json(data.get(\"Channel\"))", "response": "Get a channel by channel id"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_channels_by_sln(self, channel_type, sln):\n        return self.search_channels(type=channel_type, tag_sln=sln)", "response": "Search for all channels by sln"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsearches for all channels by sln year and quarter.", "response": "def get_channels_by_sln_year_quarter(\n            self, channel_type, sln, year, quarter):\n        \"\"\"\n        Search for all channels by sln, year and quarter\n        \"\"\"\n        return self.search_channels(\n            type=channel_type, tag_sln=sln, tag_year=year, tag_quarter=quarter)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nsearch for all active channels by year and quarter.", "response": "def get_active_channels_by_year_quarter(\n            self, channel_type, year, quarter, expires=None):\n        \"\"\"\n        Search for all active channels by year and quarter\n        \"\"\"\n        if expires is None:\n            # Set expires_after to midnight of current day\n            expires = datetime.combine(datetime.utcnow().date(), time.min)\n\n        return self.search_channels(\n            type=channel_type, tag_year=year, tag_quarter=quarter,\n            expires_after=expires.isoformat())"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef search_channels(self, **kwargs):\n        params = [(key, kwargs[key]) for key in sorted(kwargs.keys())]\n        url = \"/notification/v1/channel?{}\".format(\n            urlencode(params, doseq=True))\n\n        response = NWS_DAO().getURL(url, self._read_headers)\n\n        if response.status != 200:\n            raise DataFailureException(url, response.status, response.data)\n\n        data = json.loads(response.data)\n        channels = []\n        for datum in data.get(\"Channels\", []):\n            channels.append(self._channel_from_json(datum))\n        return channels", "response": "Search for all channels by parameters\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef create_person(self, person):\n        self._validate_subscriber_id(person.surrogate_id)\n\n        url = \"/notification/v1/person\"\n        response = NWS_DAO().postURL(\n            url, self._write_headers(), self._json_body(person.json_data()))\n\n        if response.status != 201:\n            raise DataFailureException(url, response.status, response.data)\n\n        return response.status", "response": "Create a new person in the cluster."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef update_person(self, person):\n        self._validate_regid(person.person_id)\n        self._validate_subscriber_id(person.surrogate_id)\n\n        for attr in MANAGED_ATTRIBUTES:\n            person.attributes.pop(attr, None)\n\n        url = \"/notification/v1/person/{}\".format(person.person_id)\n        response = NWS_DAO().putURL(\n            url, self._write_headers(), self._json_body(person.json_data()))\n\n        if response.status != 204:\n            raise DataFailureException(url, response.status, response.data)\n\n        return response.status", "response": "Update an existing person s attributes."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef create_new_dispatch(self, dispatch):\n        self._validate_uuid(dispatch.dispatch_id)\n\n        # Create new dispatch\n        url = \"/notification/v1/dispatch\"\n        post_response = NWS_DAO().postURL(\n            url, self._write_headers(), self._json_body(dispatch.json_data()))\n\n        if post_response.status != 200:\n            raise DataFailureException(\n                url, post_response.status, post_response.data)\n        return post_response.status", "response": "Create a new dispatch"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ndelete an existing dispatch.", "response": "def delete_dispatch(self, dispatch_id):\n        \"\"\"\n        Deleting an existing dispatch\n        :param dispatch_id: is the dispatch that the client wants to delete\n        \"\"\"\n        self._validate_uuid(dispatch_id)\n\n        url = \"/notification/v1/dispatch/{}\".format(dispatch_id)\n        response = NWS_DAO().deleteURL(url, self._write_headers())\n\n        if response.status != 204:\n            raise DataFailureException(url, response.status, response.data)\n        return response.status"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets a message type by its ID", "response": "def get_message_type_by_id(self, message_type_id):\n        \"\"\"\n        Get a message type by message type ID\n        :param message_type_id: is the message type that\n                                the client wants to retrieve\n        \"\"\"\n        self._validate_uuid(message_type_id)\n\n        url = \"/notification/v1/message-type/{}\".format(message_type_id)\n        response = NWS_DAO().getURL(url, self._write_headers())\n        if response.status != 200:\n            raise DataFailureException(url, response.status, response.data)\n\n        data = json.loads(response.data)\n        return self._message_type_from_json(data.get(\"MessageType\"))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nupdates an existing message type", "response": "def update_message_type(self, message_type):\n        \"\"\"\n        Update an existing message type\n        :param message_type: is the updated message type that the\n                             client wants to update\n        \"\"\"\n        self._validate_uuid(message_type.message_type_id)\n\n        url = \"/notification/v1/message-type/{}\".format(\n            message_type.message_type_id)\n        response = NWS_DAO().putURL(\n            url, self._write_headers(), self._json_body(\n                message_type.json_data()))\n\n        if response.status != 204:\n            raise DataFailureException(url, response.status, response.data)\n        return response.status"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndelete an existing message type", "response": "def delete_message_type(self, message_type_id):\n        \"\"\"\n        Delete an existing message type\n        :param message_type_id: is the id of the message type the\n                                client wants to delete\n        \"\"\"\n        self._validate_uuid(message_type_id)\n\n        url = \"/notification/v1/message-type/{}\".format(message_type_id)\n        response = NWS_DAO().deleteURL(url, self._write_headers())\n\n        if response.status != 204:\n            raise DataFailureException(url, response.status, response.data)\n        return response.status"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _get_first_last(details):\n    if \"first_name\" in details and \"last_name\" in details:\n        return details[\"first_name\"], details[\"last_name\"]\n    elif \"first_name\" in details:\n        lst = details[\"first_name\"].rsplit(\" \", 1)\n        if len(lst) == 2:\n            return lst\n        else:\n            return lst[0], \"\"\n    elif \"last_name\" in details:\n        return \"\", details[\"last_name\"]\n\n    return \"\", \"\"", "response": "Gets a user s first and last name from details."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ntake a path to a field like yacms. pages. models. Page and return a model key which is a tuple of the form ( app_label model_name field_name", "response": "def parse_field_path(field_path):\n    \"\"\"\n    Take a path to a field like \"yacms.pages.models.Page.feature_image\"\n    and return a model key, which is a tuple of the form ('pages', 'page'),\n    and a field name, e.g. \"feature_image\".\n    \"\"\"\n    model_path, field_name = field_path.rsplit(\".\", 1)\n    app_name, model_name = model_path.split('.models.')\n    _, app_label = app_name.rsplit('.', 1)\n    return (app_label, model_name.lower()), field_name"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nimport a field by its dotted class path prepending django. db. models if it is not already imported.", "response": "def import_field(field_classpath):\n    \"\"\"\n    Imports a field by its dotted class path, prepending \"django.db.models\"\n    to raw class names and raising an exception if the import fails.\n    \"\"\"\n    if '.' in field_classpath:\n        fully_qualified = field_classpath\n    else:\n        fully_qualified = \"django.db.models.%s\" % field_classpath\n    try:\n        return import_dotted_path(fully_qualified)\n    except ImportError:\n        raise ImproperlyConfigured(\"The EXTRA_MODEL_FIELDS setting contains \"\n                                   \"the field '%s' which could not be \"\n                                   \"imported.\" % field_classpath)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nparsing the value of EXTRA_MODEL_FIELDS into a dictionary of tuples of model_key model_name and list of field_instances.", "response": "def parse_extra_model_fields(extra_model_fields):\n    \"\"\"\n    Parses the value of EXTRA_MODEL_FIELDS, grouping the entries by model\n    and instantiating the extra fields. Returns a sequence of tuples of\n    the form (model_key, fields) where model_key is a pair of app_label,\n    model_name and fields is a list of (field_name, field_instance) pairs.\n    \"\"\"\n    fields = defaultdict(list)\n    for entry in extra_model_fields:\n        model_key, field_name = parse_field_path(entry[0])\n        field_class = import_field(entry[1])\n        field_args, field_kwargs = entry[2:]\n        try:\n            field = field_class(*field_args, **field_kwargs)\n        except TypeError as e:\n            raise ImproperlyConfigured(\n                \"The EXTRA_MODEL_FIELDS setting contains arguments for the \"\n                \"field '%s' which could not be applied: %s\" % (entry[1], e))\n        fields[model_key].append((field_name, field))\n    return fields"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add_extra_model_fields(sender, **kwargs):\n    model_key = sender._meta.app_label, sender._meta.model_name\n    for field_name, field in fields.get(model_key, {}):\n        field.contribute_to_class(sender, field_name)", "response": "Adds custom fields to the given sender model."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef tail(\n    filepath = \"log.txt\",\n    lines    = 50\n    ):\n    \"\"\"\n    Return a specified number of last lines of a specified file. If there is an\n    error or the file does not exist, return False.\n    \"\"\"\n    try:\n        filepath = os.path.expanduser(os.path.expandvars(filepath))\n        if os.path.isfile(filepath):\n            text = subprocess.check_output([\"tail\", \"-\" + str(lines), filepath])\n            if text:\n                return text\n            else:\n                return False\n        else:\n            return False\n    except:\n        return False", "response": "Return a specified number of last lines of a specified file."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef select_spread(\n    list_of_elements   = None,\n    number_of_elements = None\n    ):\n    \"\"\"\n    This function returns the specified number of elements of a list spread\n    approximately evenly.\n    \"\"\"\n    if len(list_of_elements) <= number_of_elements:\n        return list_of_elements\n    if number_of_elements == 0:\n        return []\n    if number_of_elements == 1:\n        return [list_of_elements[int(round((len(list_of_elements) - 1) / 2))]]\n    return \\\n        [list_of_elements[int(round((len(list_of_elements) - 1) /\\\n        (2 * number_of_elements)))]] +\\\n        select_spread(list_of_elements[int(round((len(list_of_elements) - 1) /\\\n        (number_of_elements))):], number_of_elements - 1)", "response": "This function returns the specified number of elements of a list spread\n    approximately evenly."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the edges of the range of the available resources.", "response": "def ranges_edge_pairs(\n    extent       = None,\n    range_length = None\n    ):\n    \"\"\"\n    Return the edges of ranges within an extent of some length. For example, to\n    separate 76 variables into groups of at most 20 variables, the ranges of the\n    variables could be 0 to 20, 21 to 41, 42 to 62 and 63 to 76. These range\n    edges could be returned by this function as a list of tuples:\n\n    >>> ranges_edge_pairs(\n    ...     extent       = 76, # number of variables\n    ...     range_length = 20  # maximum number of variables per plot\n    ... )\n    [(0, 20), (21, 41), (42, 62), (63, 76)]\n    \"\"\"\n    number_of_ranges = int(math.ceil(extent / range_length))\n    return [\n        (\n            index * range_length + index,\n            min((index + 1) * range_length + index, extent)\n        )\n        for index in range(0, number_of_ranges)\n    ]"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef ustr(text):\n    if text is not None:\n        if sys.version_info >= (3, 0):\n            return str(text)\n        else:\n            return unicode(text)\n    else:\n        return text", "response": "Convert a string to Python 2 unicode or Python 3 string as appropriate to the version of Python in use."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef replace_contractions_with_full_words_and_replace_numbers_with_digits(\n    text            = None,\n    remove_articles = True\n    ):\n    \"\"\"\n    This function replaces contractions with full words and replaces numbers\n    with digits in specified text. There is the option to remove articles.\n    \"\"\"\n    words = text.split()\n    text_translated = \"\"\n    for word in words:\n        if remove_articles and word in [\"a\", \"an\", \"the\"]:\n            continue\n        contractions_expansions = {\n            \"ain't\":       \"is not\",\n            \"aren't\":      \"are not\",\n            \"can't\":       \"can not\",\n            \"could've\":    \"could have\",\n            \"couldn't\":    \"could not\",\n            \"didn't\":      \"did not\",\n            \"doesn't\":     \"does not\",\n            \"don't\":       \"do not\",\n            \"gonna\":       \"going to\",\n            \"gotta\":       \"got to\",\n            \"hadn't\":      \"had not\",\n            \"hasn't\":      \"has not\",\n            \"haven't\":     \"have not\",\n            \"he'd\":        \"he would\",\n            \"he'll\":       \"he will\",\n            \"he's\":        \"he is\",\n            \"how'd\":       \"how did\",\n            \"how'll\":      \"how will\",\n            \"how's\":       \"how is\",\n            \"I'd\":         \"I would\",\n            \"I'll\":        \"I will\",\n            \"I'm\":         \"I am\",\n            \"I've\":        \"I have\",\n            \"isn't\":       \"is not\",\n            \"it'd\":        \"it would\",\n            \"it'll\":       \"it will\",\n            \"it's\":        \"it is\",\n            \"mightn't\":    \"might not\",\n            \"might've\":    \"might have\",\n            \"mustn't\":     \"must not\",\n            \"must've\":     \"must have\",\n            \"needn't\":     \"need not\",\n            \"oughtn't\":    \"ought not\",\n            \"shan't\":      \"shall not\",\n            \"she'd\":       \"she would\",\n            \"she'll\":      \"she will\",\n            \"she's\":       \"she is\",\n            \"shouldn't\":   \"should not\",\n            \"should've\":   \"should have\",\n            \"somebody's\":  \"somebody is\",\n            \"someone'd\":   \"someone would\",\n            \"someone'll\":  \"someone will\",\n            \"someone's\":   \"someone is\",\n            \"that'll\":     \"that will\",\n            \"that's\":      \"that is\",\n            \"that'd\":      \"that would\",\n            \"there'd\":     \"there would\",\n            \"there're\":    \"there are\",\n            \"there's\":     \"there is\",\n            \"they'd\":      \"they would\",\n            \"they'll\":     \"they will\",\n            \"they're\":     \"they are\",\n            \"they've\":     \"they have\",\n            \"wasn't\":      \"was not\",\n            \"we'd\":        \"we would\",\n            \"we'll\":       \"we will\",\n            \"we're\":       \"we are\",\n            \"we've\":       \"we have\",\n            \"weren't\":     \"were not\",\n            \"what'd\":      \"what did\",\n            \"what'll\":     \"what will\",\n            \"what're\":     \"what are\",\n            \"what's\":      \"what is\",\n            \"whats\":       \"what is\",\n            \"what've\":     \"what have\",\n            \"when's\":      \"when is\",\n            \"when'd\":      \"when did\",\n            \"where'd\":     \"where did\",\n            \"where's\":     \"where is\",\n            \"where've\":    \"where have\",\n            \"who'd\":       \"who would\",\n            \"who'd've\":    \"who would have\",\n            \"who'll\":      \"who will\",\n            \"who're\":      \"who are\",\n            \"who's\":       \"who is\",\n            \"who've\":      \"who have\",\n            \"why'd\":       \"why did\",\n            \"why're\":      \"why are\",\n            \"why's\":       \"why is\",\n            \"won't\":       \"will not\",\n            \"won't've\":    \"will not have\",\n            \"would've\":    \"would have\",\n            \"wouldn't\":    \"would not\",\n            \"wouldn't've\": \"would not have\",\n            \"y'all\":       \"you all\",\n            \"ya'll\":       \"you all\",\n            \"you'd\":       \"you would\",\n            \"you'd've\":    \"you would have\",\n            \"you'll\":      \"you will\",\n            \"y'aint\":      \"you are not\",\n            \"y'ain't\":     \"you are not\",\n            \"you're\":      \"you are\",\n            \"you've\":      \"you have\"\n        }\n        if word in list(contractions_expansions.keys()):\n            word = contractions_expansions[word]\n        numbers_digits = {\n            \"zero\":       \"0\",\n            \"one\":        \"1\",\n            \"two\":        \"2\",\n            \"three\":      \"3\",\n            \"four\":       \"4\",\n            \"five\":       \"5\",\n            \"six\":        \"6\",\n            \"seven\":      \"7\",\n            \"eight\":      \"8\",\n            \"nine\":       \"9\",\n            \"ten\":       \"10\",\n            \"eleven\":    \"11\",\n            \"twelve\":    \"12\",\n            \"thirteen\":  \"13\",\n            \"fourteen\":  \"14\",\n            \"fifteen\":   \"15\",\n            \"sixteen\":   \"16\",\n            \"seventeen\": \"17\",\n            \"eighteen\":  \"18\",\n            \"nineteen\":  \"19\",\n            \"twenty\":    \"20\"\n        }\n        if word in list(numbers_digits.keys()):\n            word = numbers_digits[word]\n        text_translated += \" \" + word\n        text_translated = text_translated.strip()\n    return text_translated", "response": "This function replaces contractions with full words and replaces numbers with digits in specified text."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding time variables to a DataFrame.", "response": "def add_time_variables(df, reindex = True):\n    \"\"\"\n    Return a DataFrame with variables for weekday index, weekday name, timedelta\n    through day, fraction through day, hours through day and days through week\n    added, optionally with the index set to datetime and the variable `datetime`\n    removed. It is assumed that the variable `datetime` exists.\n    \"\"\"\n    if not \"datetime\" in df.columns:\n        log.error(\"field datetime not found in DataFrame\")\n        return False\n    df[\"datetime\"]             = pd.to_datetime(df[\"datetime\"])\n    df[\"month\"]                = df[\"datetime\"].dt.month\n    df[\"month_name\"]           = df[\"datetime\"].dt.strftime(\"%B\")\n    df[\"weekday\"]              = df[\"datetime\"].dt.weekday\n    df[\"weekday_name\"]         = df[\"datetime\"].dt.weekday_name\n    df[\"time_through_day\"]     = df[\"datetime\"].map(\n                                     lambda x: x - datetime.datetime.combine(\n                                         x.date(),\n                                         datetime.time()\n                                     )\n                                 )\n    df[\"fraction_through_day\"] = df[\"time_through_day\"].map(\n                                     lambda x: x / datetime.timedelta(hours = 24)\n                                 )\n    df[\"hour\"]                 = df[\"datetime\"].dt.hour\n    df[\"hours_through_day\"]    = df[\"fraction_through_day\"] * 24\n    df[\"days_through_week\"]    = df.apply(\n                                     lambda row: row[\"weekday\"] + row[\"fraction_through_day\"],\n                                     axis = 1\n                                 )\n    df[\"days_through_year\"]    = df[\"datetime\"].dt.dayofyear\n    df.index                   = df[\"datetime\"]\n    #del df[\"datetime\"]\n    return df"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef daily_plots(\n    df,\n    variable,\n    renormalize = True,\n    plot        = True,\n    scatter     = False,\n    linestyle   = \"-\",\n    linewidth   = 1,\n    s           = 1\n    ):\n    \"\"\"\n    Create daily plots of a variable in a DataFrame, optionally renormalized. It\n    is assumed that the DataFrame index is datetime.\n    \"\"\"\n    if not df.index.dtype in [\"datetime64[ns]\", \"<M8[ns]\", \">M8[ns]\"]:\n        log.error(\"index is not datetime\")\n        return False\n    days = []\n    for group in df.groupby(df.index.day):\n        days.append(group[1])\n    scaler = MinMaxScaler()\n    plt.xlabel(\"hours\")\n    plt.ylabel(variable);\n    for day in days:\n        if renormalize:\n            values = scaler.fit_transform(day[[variable]])\n        else:\n            values = day[variable]\n        if plot:\n            plt.plot(day[\"hours_through_day\"], values, linestyle = linestyle, linewidth = linewidth)\n        if scatter:\n            plt.scatter(day[\"hours_through_day\"], values, s = s)", "response": "Create daily plots of a variable in a DataFrame."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating weekly plots of a variable in a DataFrame.", "response": "def weekly_plots(\n    df,\n    variable,\n    renormalize = True,\n    plot        = True,\n    scatter     = False,\n    linestyle   = \"-\",\n    linewidth   = 1,\n    s           = 1\n    ):\n    \"\"\"\n    Create weekly plots of a variable in a DataFrame, optionally renormalized.\n    It is assumed that the variable `days_through_week` exists.\n    \"\"\"\n    if not \"days_through_week\" in df.columns:\n        log.error(\"field days_through_week not found in DataFrame\")\n        return False\n    weeks = []\n    for group in df.groupby(df.index.week):\n        weeks.append(group[1])\n    scaler = MinMaxScaler()\n    plt.ylabel(variable);\n    for week in weeks:\n        if renormalize:\n            values = scaler.fit_transform(week[[variable]])\n        else:\n            values = week[variable]\n        if plot:\n            plt.plot(week[\"days_through_week\"], values, linestyle = linestyle, linewidth = linewidth)\n        if scatter:\n            plt.scatter(week[\"days_through_week\"], values, s = s)\n    plt.xticks(\n        [     0.5,       1.5,         2.5,        3.5,      4.5,        5.5,      6.5],\n        [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"]\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate yearly plots of a variable in a DataFrame.", "response": "def yearly_plots(\n    df,\n    variable,\n    renormalize                   = True,\n    horizontal_axis_labels_days   = False,\n    horizontal_axis_labels_months = True,\n    plot                          = True,\n    scatter                       = False,\n    linestyle                     = \"-\",\n    linewidth                     = 1,\n    s                             = 1\n    ):\n    \"\"\"\n    Create yearly plots of a variable in a DataFrame, optionally renormalized.\n    It is assumed that the DataFrame index is datetime.\n    \"\"\"\n    if not df.index.dtype in [\"datetime64[ns]\", \"<M8[ns]\", \">M8[ns]\"]:\n        log.error(\"index is not datetime\")\n        return False\n    years = []\n    for group in df.groupby(df.index.year):\n        years.append(group[1])\n    scaler = MinMaxScaler()\n    plt.xlabel(\"days\")\n    plt.ylabel(variable);\n    for year in years:\n        if renormalize:\n            values = scaler.fit_transform(year[[variable]])\n        else:\n            values = year[variable]\n        if plot:\n            plt.plot(year[\"days_through_year\"], values, linestyle = linestyle, linewidth = linewidth, label = year.index.year.values[0])\n        if scatter:\n            plt.scatter(year[\"days_through_year\"], values, s = s)\n    if horizontal_axis_labels_months:\n        plt.xticks(\n            [     15.5,         45,    74.5,     105, 135.5,    166,  196.5,    227.5,         258,     288.5,        319,      349.5],\n            [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"]\n        )\n    plt.legend()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd rolling statistics variables derived from a specified variable in a DataFrame.", "response": "def add_rolling_statistics_variables(\n    df           = None,\n    variable     = None,\n    window       = 20,\n    upper_factor = 2,\n    lower_factor = 2\n    ):\n    \"\"\"\n    Add rolling statistics variables derived from a specified variable in a\n    DataFrame.\n    \"\"\"\n    df[variable + \"_rolling_mean\"]               = pd.stats.moments.rolling_mean(df[variable], window)\n    df[variable + \"_rolling_standard_deviation\"] = pd.stats.moments.rolling_std(df[variable], window)\n    df[variable + \"_rolling_upper_bound\"]        = df[variable + \"_rolling_mean\"] + upper_factor * df[variable + \"_rolling_standard_deviation\"]\n    df[variable + \"_rolling_lower_bound\"]        = df[variable + \"_rolling_mean\"] - lower_factor * df[variable + \"_rolling_standard_deviation\"]\n    return df"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef histogram_hour_counts(\n    df,\n    variable\n    ):\n    \"\"\"\n    Create a day-long histogram of counts of the variable for each hour. It is\n    assumed that the DataFrame index is datetime and that the variable\n    `hour` exists.\n    \"\"\"\n    if not df.index.dtype in [\"datetime64[ns]\", \"<M8[ns]\", \">M8[ns]\"]:\n        log.error(\"index is not datetime\")\n        return False\n    counts = df.groupby(df.index.hour)[variable].count()\n    counts.plot(kind = \"bar\", width = 1, rot = 0, alpha = 0.7)", "response": "Create a day - long histogram of counts of the variable for each hour."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef histogram_day_counts(\n    df,\n    variable\n    ):\n    \"\"\"\n    Create a week-long histogram of counts of the variable for each day. It is\n    assumed that the DataFrame index is datetime and that the variable\n    `weekday_name` exists.\n    \"\"\"\n    if not df.index.dtype in [\"datetime64[ns]\", \"<M8[ns]\", \">M8[ns]\"]:\n        log.error(\"index is not datetime\")\n        return False\n    counts = df.groupby(df.index.weekday_name)[variable].count().reindex(calendar.day_name[0:])\n    counts.plot(kind = \"bar\", width = 1, rot = 0, alpha = 0.7)", "response": "Create a week - long histogram of counts of the variable for each day."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef histogram_month_counts(\n    df,\n    variable\n    ):\n    \"\"\"\n    Create a year-long histogram of counts of the variable for each month. It is\n    assumed that the DataFrame index is datetime and that the variable\n    `month_name` exists.\n    \"\"\"\n    if not df.index.dtype in [\"datetime64[ns]\", \"<M8[ns]\", \">M8[ns]\"]:\n        log.error(\"index is not datetime\")\n        return False\n    counts = df.groupby(df.index.strftime(\"%B\"))[variable].count().reindex(calendar.month_name[1:])\n    counts.plot(kind = \"bar\", width = 1, rot = 0, alpha = 0.7)", "response": "Create a year - long histogram of counts of the variable for each month."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsets up a Jupyter notebook with a few defaults.", "response": "def setup_Jupyter():\n    \"\"\"\n    Set up a Jupyter notebook with a few defaults.\n    \"\"\"\n    sns.set(context = \"paper\", font = \"monospace\")\n    warnings.filterwarnings(\"ignore\")\n    pd.set_option(\"display.max_rows\",    500)\n    pd.set_option(\"display.max_columns\", 500)\n    plt.rcParams[\"figure.figsize\"] = (17, 10)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\npost the listnig - internal information to Ensembl.", "response": "def post(self):\n        server = 'ftp.ensembl.org'\n        #go_dir = 'pub/current_gtf'\n        go_dir = 'pub'\n        user = 'anonymous'\n\n        # get directory listnig\n        ftp = ftplib.FTP(server)\n        ftp.login(user)\n\n        data = []\n        #ftp.cwd(go_dir)\n        ftp.dir(go_dir, data.append)\n        #ftp.quit()\n\n        # find everything that ends in release-xx\n        pat = re.compile(r'.* release-(\\d+)$')\n        release_numbers = []\n        for d in data:\n            m = pat.match(d)\n            if m is not None:\n                release_numbers.append(m.group(1))\n\n        release_numbers = np.int64(release_numbers)\n        latest = np.amax(release_numbers)\n\n        \"\"\"\n        for sp in self.species:\n            sc = self.scientific_names[sp].lower()\n            spdir = 'pub/release-%d/gtf/%s' %(latest,sc)\n            data = []\n            #ftp.dir(spdir,data.append)\n            cs_url = 'ftp://' + '/'.join([server,spdir,'CHECKSUMS'])\n            print cs_url\n            checksum = None\n            with closing(urllib2.urlopen(cs_url)) as uh:\n                checksum = uh.read()\n            print sp,checksum; sys.stdout.flush()\n        \"\"\"\n        for spec in self.species:\n\n            spec_name = self.species_names[spec]\n\n            # find the precise name of the GTF file that we're interested in\n            spdir = 'pub/release-%d/gtf/%s' %(latest,spec.lower())\n            data = []\n            ftp.dir(spdir,data.append)\n            gtf_file = []\n            for d in data:\n                i = d.rindex(' ')\n                fn = d[(i+1):]\n                if fn.endswith('.%d.gtf.gz' %(latest)):\n                    gtf_file.append(fn)\n            assert len(gtf_file) == 1\n            gtf_file = gtf_file[0]\n            #self.logger.debug(gtf_file)\n\n            # download the CHECKSUMS file and create a mapping of file names to checksums\n            data = []\n            cs_path = '/'.join([spdir,'CHECKSUMS'])\n            data = []\n            ftp.retrbinary('RETR %s' %(cs_path),data.append)\n            data = ''.join(data).split('\\n')[:-1]\n            checksums = {}\n            for d in data:\n                s,fn = d.split('\\t')\n                checksums[fn] = s\n\n            # compare checksums to see if we need to download the file\n            output_file = self.data_dir + os.sep + gtf_file\n            if self.test_checksums(output_file,checksums[gtf_file]):\n                logger.debug('Checksums agree!')\n            else:\n                logger.debug('Downloading %s...', output_file)\n                gtf_path = '/'.join([spdir,gtf_file])\n                with open(output_file,'w') as ofh:\n                    ftp.retrbinary('RETR %s' %(gtf_path),ofh.write)\n\n                logger.debug('done!')\n                if not self.test_checksums(output_file,checksums[gtf_file]):\n                    logger.debug('ERROR: Checksums don''t agree! Deleting downloaded file...')\n                    if os.path.isfile(output_file): # race condition?\n                        os.remove(output_file)\n            \n        # update gene annotations\n        self.data['gene_annotations'] = GeneAnnotationData.find_gene_annotations(self.data_dir)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nset initial logging configurations.", "response": "def logger_initial_config(service_name=None,\n                          log_level=None,\n                          logger_format=None,\n                          logger_date_format=None):\n    '''Set initial logging configurations.\n\n    :param service_name: Name of the service\n    :type logger: String\n\n    :param log_level: A string or integer corresponding to a Python logging level\n    :type log_level: String\n\n    :param logger_format: A string defining the format of the logs\n    :type log_level: String\n\n    :param logger_date_format: A string defining the format of the date/time in the logs\n    :type log_level: String\n\n    :rtype: None\n\n    '''\n    if not log_level:\n        log_level = os.getenv('LOGGING_LEVEL', 'DEBUG')\n    if not logger_format:\n        logger_format = (\n            \"%(asctime)s.%(msecs)06dZ|\"\n            \"%(levelname)s: {}: %(message)s\"\n        ).format(service_name)\n    if not logger_date_format:\n        logger_date_format = os.getenv('LOGGING_DATE_FORMAT', \"%Y-%m-%dT%H:%M:%S\")\n\n    logging.basicConfig(level=log_level,\n                        format=logger_format,\n                        datefmt=logger_date_format)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncoloring | Styles | --------|--------------------| black | bold | red | dark | green | underline | yellow | negative | blue | hide | magenta | | cyan | | white | | PythonColorize.colorize(text=[text], color=[color], style=[style], light=[True|False], background=[True|False])", "response": "def colorize(text=None, color=None, style=None, light=None, background=None):\n\t'''\n\tColors  | Styles             |\n\t--------|--------------------|\n\tblack   | bold               |\n\tred     | dark               |\n\tgreen   | underline          |\n\tyellow  | negative           |\n\tblue    | hide               |\n\tmagenta |                    |\n\tcyan    |                    |\n\twhite   |                    |\n\n\tPythonColorize.colorize(text=[text], color=[color], style=[style], light=[True|False], background=[True|False])\n\t'''\n\n\tparam = colors.color\n\tparam_color = 7\n\tparam_style = 0\n\tif text == None:\n\t\ttext = ''\n\t\t\n\tif color:\n\t\tif color == 'black':\n\t\t\tparam_color = colors.b\n\t\telif color == 'red':\n\t\t\tparam_color = colors.r\n\t\telif color == 'green':\n\t\t\tparam_color = colors.g\n\t\telif color == 'yellow':\n\t\t\tparam_color = colors.y\n\t\telif color == 'blue':\n\t\t\tparam_color = colors.bl\n\t\telif color == 'magenta':\n\t\t\tparam_color = colors.m\n\t\telif color == 'cyan':\n\t\t\tparam_color = colors.c\n\t\telif color == 'white':\n\t\t\tparam_color = colors.w\n\t\telse:\n\t\t\tparam_color = color\n\n\tif style:\n\t\tif style == 'bold':\n\t\t\tparam_style = colors.bold\n\t\telif style == 'dark':\n\t\t\tparam_style = colors.dark\n\t\telif style == 'underline':\n\t\t\tparam_style = colors.underline\n\t\telif style == 'negative':\n\t\t\tparam_style = colors.negative\n\t\telif param_style == 'hide':\n\t\t\tparam_style == colors.hide\n\t\telse:\n\t\t\tparam_style = style\n\n\tif light:\n\t\tif background:\n\t\t\tparam = colors.bg_light\n\t\telse:\n\t\t\tparam = colors.light\n\telif background:\n\t\tparam = colors.bg_color\n\n\tapply_text = '{n1}{text}{n2}'.format(n1=colors.prefix + str(param_style) +\\\n\t\t\t\t\t\t\t\t\t\t';' + str(param + param_color) + 'm',\n\t\t\t\t\t\t\t\t\t\ttext=text, n2=colors.nocolor)\n\n\treturn apply_text"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef cidr_notation(ip_address, netmask):\n    try:\n        inet_aton(ip_address)\n    except:\n        raise Exception(\"Invalid ip address '%s'\" % ip_address)\n    try:\n        inet_aton(netmask)\n    except:\n        raise Exception(\"Invalid netmask '%s'\" % netmask)\n\n    ip_address_split = ip_address.split('.')\n    netmask_split = netmask.split('.')\n    \n    # calculate network start\n    net_start = [str(int(ip_address_split[x]) & int(netmask_split[x]))\n                    for x in range(0,4)]\n    \n    return '.'.join(net_start) + '/' + get_net_size(netmask_split)", "response": "Retrieve the cidr notation given an ip address and netmask"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\nasync def inject_request_id(app, handler):\n\n    async def trace_request(request):\n        request['x-request-id'] = \\\n            request.headers.get('x-request-id') or str(uuid.uuid4())\n        return await handler(request)\n\n    return trace_request", "response": "Aiohttp middleware that ensures each request has a unique request ID."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\nasync def access_log_middleware(app, handler):\n\n    event_log = app.get('smartmob.event_log') or structlog.get_logger()\n    clock = app.get('smartmob.clock') or timeit.default_timer\n\n    # Keep the request arrival time to ensure we get intuitive logging of\n    # events.\n    arrival_time = datetime.utcnow().replace(tzinfo=timezone.utc)\n\n    async def access_log(request):\n        ref = clock()\n        try:\n            response = await handler(request)\n            event_log.info(\n                'http.access',\n                path=request.path,\n                outcome=response.status,\n                duration=(clock()-ref),\n                request=request.get('x-request-id', '?'),\n                **{'@timestamp': arrival_time}\n            )\n            return response\n        except web.HTTPException as error:\n            event_log.info(\n                'http.access',\n                path=request.path,\n                outcome=error.status,\n                duration=(clock()-ref),\n                request=request.get('x-request-id', '?'),\n                **{'@timestamp': arrival_time}\n            )\n            raise\n        except Exception:\n            event_log.info(\n                'http.access',\n                path=request.path,\n                outcome=500,\n                duration=(clock()-ref),\n                request=request.get('x-request-id', '?'),\n                **{'@timestamp': arrival_time}\n            )\n            raise\n\n    return access_log", "response": "A middleware that logs each request in structured event log."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef unpack_archive(archive_format, archive_path, source_path):\n    if archive_format not in ('zip', 'tar'):\n        raise ValueError('Unknown archive format \"%s\".' % archive_format)\n    if archive_format == 'zip':\n        with zipfile.ZipFile(archive_path) as archive:\n            archive.extractall(source_path)\n    if archive_format == 'tar':\n        with tarfile.open(archive_path) as archive:\n            archive.extractall(source_path)", "response": "Unpack a. zip. tar. gz archive to a folder."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nstarts a new responder.", "response": "def start_responder(host='127.0.0.1', port=8080, event_log=None, loop=None):\n    \"\"\".\"\"\"\n\n    loop = loop or asyncio.get_event_loop()\n    event_log = event_log or structlog.get_logger()\n\n    # Prepare a web application.\n    app = web.Application(loop=loop, middlewares=[\n        inject_request_id,\n        access_log_middleware,\n    ])\n    app.on_response_prepare.append(echo_request_id)\n    app.router.add_route('GET', '/', index)\n    app.router.add_route('POST', '/create-process',\n                         create_process, name='create-process')\n    app.router.add_route('GET', '/process-status/{slug}',\n                         process_status, name='process-status')\n    app.router.add_route('POST', '/delete-process/{slug}',\n                         delete_process, name='delete-process')\n    app.router.add_route('GET', '/attach-console/{slug}',\n                         attach_console, name='attach-console')\n    app.router.add_route('GET', '/list-processes',\n                         list_processes, name='list-processes')\n\n    # Create storage folders.\n    archives_path = os.path.join(\n        '.', '.smartmob', 'archives',\n    )\n    if not os.path.isdir(archives_path):\n        os.makedirs(archives_path)\n    sources_path = os.path.join(\n        '.', '.smartmob', 'sources',\n    )\n    if not os.path.isdir(sources_path):\n        os.makedirs(sources_path)\n    envs_path = os.path.join(\n        '.', '.smartmob', 'envs',\n    )\n    if not os.path.isdir(envs_path):\n        os.makedirs(envs_path)\n\n    event_log.info('bind', transport='tcp', host=host, port=port)\n\n    # Start accepting connections.\n    handler = app.make_handler()\n    server = yield from loop.create_server(handler, host, port)\n    return app, handler, server"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nmerges the head of a branch into the base branch.", "response": "def merge(profile, head, base, commit_message=None):\n    \"\"\"Merge the head of a branch into the base branch.\n\n    Args:\n\n        profile\n            A profile generated from ``simplygithub.authentication.profile``.\n            Such profiles tell this module (i) the ``repo`` to connect to,\n            and (ii) the ``token`` to connect with.\n\n        head\n            The head to merge. It can be a SHA, or a branch name.\n\n        base\n            The name of the branch to merge the specified head into.\n\n        commit_message\n            The message to give for the commit.\n\n    Returns:\n        A dict with data about the merge.\n\n    \"\"\"\n    if not commit_message:\n        commit_message = \"Merged \" + head + \" into \" + base + \".\"\n    payload = {\n        \"base\": base,\n        \"head\": head,\n        \"commit_message\": commit_message,\n        }\n    response = api.post_merge_request(profile, payload)\n    data = None\n    if response.status_code == 201:\n        json_data = response.json()\n        data = prepare(json_data)\n    return data"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nparses a DSN string and return a dictionary of the keys.", "response": "def parse_dsn(dsn):\n    \"\"\"Parse dsn string.\"\"\"\n    parsed_dsn = urlparse(dsn)\n    parsed_path = parse_path(parsed_dsn.path)\n    return {\n        'scheme': parsed_dsn.scheme,\n        'sender': parsed_dsn.username,\n        'token': parsed_dsn.password,\n        'domain': parsed_dsn.hostname,\n        'port': parsed_dsn.port or 80,\n        'version': parsed_path.get('version'),\n        'project': parsed_path.get('project'),\n    }"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _get_dataruns(self):\n        '''Returns a list of dataruns, in order.\n        '''\n        if self._data_runs is None:\n            raise DataStreamError(\"Resident datastream don't have dataruns\")\n\n        if not self._data_runs_sorted:\n            self._data_runs.sort(key=_itemgetter(0))\n            self._data_runs_sorted = True\n\n        return [data[1] for data in self._data_runs]", "response": "Returns a list of dataruns in order."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef add_data_attribute(self, data_attr):\n        '''Interprets a DATA attribute and add it to the datastream.'''\n        if data_attr.header.attr_type_id is not AttrTypes.DATA:\n            raise DataStreamError(\"Invalid attribute. A Datastream deals only with DATA attributes\")\n        if data_attr.header.attr_name != self.name:\n            raise DataStreamError(f\"Data from a different stream '{data_attr.header.attr_name}' cannot be add to this stream\")\n\n        if data_attr.header.non_resident:\n            nonr_header = data_attr.header\n            if self._data_runs is None:\n                self._data_runs = []\n            if nonr_header.end_vcn > self.cluster_count:\n                self.cluster_count = nonr_header.end_vcn\n            if not nonr_header.start_vcn: #start_vcn == 0\n                self.size = nonr_header.curr_sstream\n                self.alloc_size = nonr_header.alloc_sstream\n            self._data_runs.append((nonr_header.start_vcn, nonr_header.data_runs))\n            self._data_runs_sorted = False\n        else: #if it is resident\n            self.size = self.alloc_size = data_attr.header.content_len\n            self._pending_processing = None\n            #respects mft_config[\"load_data\"]\n            self._content = data_attr.content.content", "response": "Interprets a DATA attribute and add it to the datastream."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds information from another datastream. Verifies if the datastream added is correct and copy the relevant fields if necessary.", "response": "def add_from_datastream(self, source_ds):\n        '''Add information from another datastream. Verifies if the datastream\n        added is correct and copy the relevant fields if necessary.'''\n        if source_ds.name != self.name:\n            raise DataStreamError(\"Data from a different stream 'f{source_ds.name}' cannot be add to this stream\")\n        if self._data_runs is None:\n            raise DataStreamError(\"Cannot add data to a resident datastream.\")\n\n        if self.cluster_count < source_ds.cluster_count:\n            self.cluster_count = source_ds.cluster_count\n        if self.size == 0 and source_ds.size:\n            self.size = source_ds.size\n            self.alloc_size = source_ds.alloc_size\n        if source_ds._data_runs:\n            self._data_runs += source_ds._data_runs\n            self._data_runs_sorted = False"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create_from_binary(cls, mft_config, binary_data, entry_number):\n        #TODO test carefully how to find the correct index entry, specially with NTFS versions < 3\n        '''Creates a MFTEntry from a binary stream. It correctly process\n        the binary data extracting the MFTHeader, all the attributes and the\n        slack information from the binary stream.\n\n        The binary data WILL be changed to apply the fixup array.\n\n        Args:\n            mft_config (:obj:`MFTConfig`) - An instance of MFTConfig, as this tells\n                how the library will interpret data.\n            binary_data (bytearray) - A binary stream with the data to extract.\n                This has to be a writeable and support the memoryview call\n            entry_number (int) - The entry number for this entry\n\n        Returns:\n            MFTEntry: If the object is empty, returns None, otherwise, new object MFTEntry\n        '''\n        bin_view = memoryview(binary_data)\n        entry = None\n\n        #test if the entry is empty\n        if bin_view[0:4] != b\"\\x00\\x00\\x00\\x00\":\n            try:\n                header = MFTHeader.create_from_binary(mft_config.ignore_signature_check,\n                            bin_view[:MFTHeader.get_representation_size()])\n            except HeaderError as e:\n                e.update_entry_number(entry_number)\n                e.update_entry_binary(binary_data)\n                raise\n            entry = cls(header, _defaultdict(list))\n\n            if header.mft_record != entry_number:\n                _MOD_LOGGER.warning(\"The MFT entry number doesn't match. %d != %d\", entry_number, header.mft_record)\n            if len(binary_data) != header.entry_alloc_len:\n                _MOD_LOGGER.error(\"Expected MFT size is different than entry size.\")\n                raise EntryError(f\"Expected MFT size ({len(binary_data)}) is different than entry size ({header.entry_alloc_len}).\", binary_data, entry_number)\n            if mft_config.apply_fixup_array:\n                apply_fixup_array(bin_view, header.fx_offset, header.fx_count, header.entry_alloc_len)\n\n            entry._load_attributes(mft_config, bin_view[header.first_attr_offset:])\n\n        bin_view.release() #release the underlying buffer\n\n        return entry", "response": "Creates a MFTEntry from a binary stream. It correctly processes the binary data and creates a MFTEntry object."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nfinds and return if a datastream exists by name.", "response": "def _find_datastream(self, name):\n        \"\"\"Find and return if a datastream exists, by name.\"\"\"\n        for stream in self.data_streams: #search to see if this is a new datastream or a known one\n            if stream.name == name:\n                return stream\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding a data attribute to the datastream structure.", "response": "def _add_data_attribute(self, data_attr):\n        \"\"\"Add a data attribute to the datastream structure.\n\n        Data attributes require processing before they can be interpreted as\n        datastream. This function grants that it is adding the attribute to\n        the correct datastream or creating a new datastream if necessary.\n        \"\"\"\n        attr_name = data_attr.header.attr_name\n\n        stream = self._find_datastream(attr_name)\n        if stream is None:\n            stream = Datastream(attr_name)\n            self.data_streams.append(stream)\n        stream.add_data_attribute(data_attr)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nload all the attributes of an entry.", "response": "def _load_attributes(self, mft_config, attrs_view):\n        '''Loads all the attributes of an entry.\n\n        Once executed, all the attributes should have been loaded in the\n        attribute *attrs* instance attribute.\n\n        Args:\n            mft_config (:obj:`MFTConfig`) - An instance of MFTConfig, as this tells\n                how the library will interpret data.\n            attrs_view (memoryview(bytearray)) - A binary stream that starts at\n                the first attribute until the end of the entry\n        '''\n        offset = 0\n        load_attrs = mft_config.attribute_load_list\n\n        while (attrs_view[offset:offset+4] != b'\\xff\\xff\\xff\\xff'):\n            attr_type, attr_len, non_resident = _get_attr_info(attrs_view[offset:])\n            if attr_type in load_attrs:\n                # pass all the information to the attr, as we don't know how\n                # much content the attribute has\n                attr = Attribute.create_from_binary(non_resident, mft_config.load_dataruns, attrs_view[offset:])\n                if not attr.header.attr_type_id is AttrTypes.DATA:\n                    self.attrs[attr.header.attr_type_id].append(attr) #add an attribute\n                else:\n                    self._add_data_attribute(attr)\n            offset += attr_len"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nallows the merging of two entries. This method will merge the attributes and data streams of the MFTEntry into the correct MFTEntry place and the datastreams of the MFTEntry.", "response": "def merge_entries(self, source_entry):\n        '''Merge two entries.\n\n        Allow the merging of two MFTEntries copying the attributes to the correct\n        place and the datastreams.\n\n        Args:\n            source_entry (:obj:`MFTEntry`) - Source entry where the data will be\n                copied from\n        '''\n        #TODO should we change this to an overloaded iadd?\n        #TODO I really don't like this. We are spending cycles to load things that are going to be discarted. Check another way.\n        #copy the attributes\n        for list_attr in source_entry.attrs.values():\n            for attr in list_attr:\n                self.attrs[attr.header.attr_type_id].append(attr) #add an attribute\n        #copy data_streams\n        for stream in source_entry.data_streams:\n            dest_stream = self._find_datastream(stream.name)\n            if dest_stream is not None:\n                dest_stream.add_from_datastream(stream)\n            else:\n                self.data_streams.append(stream)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_datastream_names(self):\n        '''Returns a set with the datastream names. If there is no datastream,\n        returns None\n        '''\n        ads_names = set()\n\n        for stream in self.data_streams:\n            ads_names.add(stream.name)\n\n        if len(ads_names):\n            return ads_names\n        else:\n            return None", "response": "Returns a set with the datastream names."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_main_filename_attr(self):\n        '''Returns the main filename attribute of the entry.\n\n        As an entry can have multiple FILENAME attributes, this function allows\n        to return the main one, i.e., the one with the lowest attribute id and\n        the \"biggest\" namespace.\n        '''\n        fn_attrs = self.get_attributes(AttrTypes.FILE_NAME)\n        high_attr_id = 0xFFFFFFFF\n        main_fn = None\n\n        if fn_attrs is not None:\n            #search for the lowest id, that will give the first FILE_NAME\n            for fn_attr in fn_attrs:\n                if fn_attr.header.attr_id < high_attr_id:\n                    main_fn = fn_attr\n                    high_attr_id = fn_attr.header.attr_id\n\n            #TODO is this necessary? Maybe the first name is always the with with the biggest namespace\n            # after we have the lowest, search for same name, but the biggest namespace\n            for fn_attr in fn_attrs:\n                if main_fn.content.parent_ref == fn_attr.content.parent_ref and \\\n                    main_fn.content.parent_seq == fn_attr.content.parent_seq and \\\n                    fn_attr.content.name_type.value < main_fn.content.name_type.value:\n                        main_fn = fn_attr\n\n        return main_fn", "response": "Returns the main filename attribute of the entry."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nload the relationship between the parent and child entries of the current entry.", "response": "def _load_relationship_info(self):\n        \"\"\"Maps parent and child entries in the MFT.\n\n        Because the library expects the MFT file to be provided, it doesn't\n        have access to anything non-resident. Because of that, if we want all\n        the information related to the entry, it is necessary to visit all the\n        entries and map the relationship between each of them.\n\n        Note:\n            Because the data necessary to do this should always happen before\n            the first fixup entry, we don't need to apply it.\n        \"\"\"\n        mft_entry_size = self.mft_entry_size\n        fp = self.file_pointer\n        record_n = 0\n        #define the minimum amount that needs to be read\n        base_struct = struct.Struct(\"<Q\")\n        base_struct_offset = 32\n        seq_struct = struct.Struct(\"<H\")\n        seq_struct_offset = 16\n\n        buffer_base = bytearray(base_struct.size)\n        buffer_seq = bytearray(seq_struct.size)\n        #go over the file using the entry size as setp\n        for i in range(0, _get_file_size(self.file_pointer), mft_entry_size):\n            record_n = int(i/mft_entry_size)\n            fp.seek(i + base_struct_offset)\n            fp.readinto(buffer_base)\n            base_ref, base_seq = get_file_reference(base_struct.unpack(buffer_base)[0])\n            if base_ref:\n                #calculate and prepare to read the sequence number\n                fp.seek((base_ref * mft_entry_size) + seq_struct_offset)\n                fp.readinto(buffer_seq)\n                seq, = seq_struct.unpack(buffer_seq)\n                if seq == base_seq: #entries are related\n                    self._entries_parent_child[base_ref].append(record_n)\n                    self._entries_child_parent[record_n] = base_ref\n                else:\n                    self._number_valid_entries += 1\n            else:\n                self._number_valid_entries += 1"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncomputing the full path of the canon entry with the given parent reference and sequence number.", "response": "def _compute_full_path(self, fn_parent_ref, fn_parent_seq):\n        '''Based on the parent reference and sequence, computes the full path.\n\n        The majority of the files in a filesystem has a very small amount of\n        parent directories. By definition, a filesystem is expected to have\n        much smaller amount of directories than files. As such we use a function\n        with the minimal amount of arguments to find a parent, that way we can\n        cache the results easily and speed up the overall code.\n\n        Args:\n            fn_parent_ref (int): Parent reference number\n            fn_parent_seq (int): Parent sequence number\n\n        Returns:\n            tuple(bool, str): A tuple where the first element is a boolean that\n                is ``True`` if the the file is orphan and ``False`` if not. The\n                second element is a string with the full path without the file name\n        '''\n        names = []\n        root_id = 5\n        index, seq = fn_parent_ref, fn_parent_seq\n        is_orphan = False\n\n        #search until hit the root entry\n        while index != root_id:\n            try:\n                parent_entry = self[index]\n                #if the sequence number is wrong, something changed = orphan\n                if seq != parent_entry.header.seq_number:\n                    is_orphan = True\n                    break\n                else:\n                    parent_fn_attr = parent_entry.get_main_filename_attr()\n                    index, seq = parent_fn_attr.content.parent_ref, parent_fn_attr.content.parent_seq\n                    names.append(parent_fn_attr.content.name)\n            except ValueError as e:\n                #if the entry itself no longer exists = orphan\n                is_orphan = True\n                break\n\n        return (is_orphan, \"\\\\\".join(reversed(names)))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the full path of a FILENAME.", "response": "def get_full_path(self, fn_attr):\n        '''Returns the full path of a FILENAME.\n\n        The NTFS filesystem allows for things called hardlinks. Hard links are\n        saved, internally, as different filename attributes. Because of this,\n        an entry can, when dealing with full paths, have multiple full paths.\n\n        As such, this function receives a fn_attr and uses it to compute\n        the full path for this particular attribute.\n\n        Also, the MFT entry might still exist, but the file has been deleted,\n        depending on the state of the MFT, the path might not be fully reconstructable,\n        these entries are called \"orphan\".\n\n        Args:\n            fn_attr (:obj:`Attribute`): An attribute that has a FILENAME as content\n\n        Returns:\n            tuple(bool, str): A tuple where the first element is a boolean that\n                is ``True`` if the the file is orphan and ``False`` if not. The\n                second element is a string with the full path\n        '''\n        if fn_attr.header.attr_type_id is not AttrTypes.FILE_NAME:\n            raise MFTError(\"Need a filename attribute to compute full path.\")\n\n        orphan, path = self._compute_full_path(fn_attr.content.parent_ref, fn_attr.content.parent_seq)\n        return (orphan, \"\\\\\".join([path, fn_attr.content.name]))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef setFullscreen(self, fullscreen):\r\n        if not fullscreen:\r\n            self.ckBox_fullscreen.setChecked(False)\r\n            self.parent().showNormal()\r\n        else:\r\n            self.ckBox_fullscreen.setChecked(True)\r\n            self.parent().showFullScreen()", "response": "toggle between fullscreen and normal window"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nmatch a string against the template.", "response": "def match(self, string):\n        \"\"\"Match a string against the template.\n\n        If the string matches the template, return a dict mapping template\n        parameter names to converted values, otherwise return ``None``.\n\n        >>> t = Template('Hello my name is {name}!')\n        >>> t.match('Hello my name is David!')\n        {'name': 'David'}\n        >>> t.match('This string does not match.')\n        \"\"\"\n        m = self.regex.match(string)\n        if m:\n            c = self.type_converters\n            return dict((k, c[k](v) if k in c else v)\n                        for k, v in m.groupdict().iteritems())\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ntagging to determine if a link is to the current page and if it is to the current page and if it is to the current page sets link_active to True in the context.", "response": "def active(parser, token):\n    \"\"\" tag to determine if a link is to the current page, and if it is, sets 'link_active'\n        to True in the context.\n\n        Use:\n            {% active path view strict[True,False] arg1 arg2 arg3 %}\n\n            path:   the path to check. Generally this is just 'request.path'\n            view:   the view that you want to check against the path. (uses reverse)\n            strict: if strict is true, then the two paths need to be exactly the same.\n                    if strict is false, then a path of /some/path/ and a view with the url\n                    /some/ will match.\n            args:   args needed by the given view to get its path using reverse.\n\n        Example:\n            {% active request.path \"settings\" True %}\n            <a href=\"{% url settings %}\" class=\"{% if link_active %} active{% endif %}\">\n\n        \"\"\"\n    args = token.split_contents()\n    path = args[1]\n    view = args[2].replace('\"', '').replace(\"'\", '')\n    strict = args[3].replace('\"', '').replace(\"'\", '')\n\n    arg1 = None; arg2 = None; arg3 = None\n    if len(args) > 4:\n        arg1 = args[4]\n    if len(args) > 5:\n        arg2 = args[5]\n    if len(args) > 6:\n        arg3 = args[6]\n    if not view:\n        raise template.TemplateSyntaxError, \"%r tag requires at least one view argument\" % token.contents.split()[0]\n    return ActiveTag(view, path, strict, arg1, arg2, arg3)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef do_truncate(parser, token):\n    _, count = token.split_contents()\n\n    nodelist = parser.parse(('more', 'endtruncate',))\n    token = parser.next_token()\n    if token.contents == 'more':\n        nodelist_more = parser.parse(('endtruncate',))\n        parser.delete_first_token()\n    else:\n        nodelist_more = None\n    return TruncateNode(count, nodelist, nodelist_more)", "response": "Truncates given text (html-aware)\n    Sample usage::\n\n        {% truncate 60 %}\n             {{ some_text }}\n        {% more %}\n             <a href=\"asdasd\">Read more..</a>\n        {% endtruncate %}"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef overextends(parser, token):\n    if DJANGO_VERSION >= (1, 9):\n        warnings.warn(\n            \"The `overextends` template tag is deprecated in favour of \"\n            \"Django's built-in `extends` tag, which supports recursive \"\n            \"extension in Django 1.9 and above.\",\n            DeprecationWarning, stacklevel=2\n        )\n\n    bits = token.split_contents()\n    if len(bits) != 2:\n        raise TemplateSyntaxError(\"'%s' takes one argument\" % bits[0])\n    parent_name = parser.compile_filter(bits[1])\n    nodelist = parser.parse()\n    if nodelist.get_nodes_by_type(ExtendsNode):\n        raise TemplateSyntaxError(\"'%s' cannot appear more than once \"\n                                  \"in the same template\" % bits[0])\n    return OverExtendsNode(nodelist, parent_name, None)", "response": "A template tag that allows circular inheritance of Django s extended classes."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nfind a template in the given context.", "response": "def find_template(self, name, context, peeking=False):\n        \"\"\"\n        Replacement for Django's ``find_template`` that uses the current\n        template context to keep track of which template directories it\n        has used when finding a template. This allows multiple templates\n        with the same relative name/path to be discovered, so that\n        circular template inheritance can occur.\n        \"\"\"\n\n        # These imports want settings, which aren't available when this\n        # module is imported to ``add_to_builtins``, so do them here.\n        import django.template.loaders.app_directories as app_directories\n\n        from yacms.conf import settings\n\n        # Store a dictionary in the template context mapping template\n        # names to the lists of template directories available to\n        # search for that template. Each time a template is loaded, its\n        # origin directory is removed from its directories list.\n        context_name = \"OVEREXTENDS_DIRS\"\n        if context_name not in context:\n            context[context_name] = {}\n        if name not in context[context_name]:\n            all_dirs = (\n                list(chain.from_iterable(\n                    [template_engine.get('DIRS', [])\n                     for template_engine in settings.TEMPLATES])) +\n                list(app_directories.get_app_template_dirs('templates')))\n            # os.path.abspath is needed under uWSGI, and also ensures we\n            # have consistent path separators across different OSes.\n            context[context_name][name] = list(map(os.path.abspath, all_dirs))\n\n        # Build a list of template loaders to use. For loaders that wrap\n        # other loaders like the ``cached`` template loader, unwind its\n        # internal loaders and add those instead.\n        loaders = []\n        for loader in context.template.engine.template_loaders:\n            loaders.extend(getattr(loader, \"loaders\", [loader]))\n\n        # Go through the loaders and try to find the template. When\n        # found, removed its absolute path from the context dict so\n        # that it won't be used again when the same relative name/path\n        # is requested.\n        for loader in loaders:\n            dirs = context[context_name][name]\n            try:\n                source, path = loader.load_template_source(name, dirs)\n            except TemplateDoesNotExist:\n                pass\n            else:\n                # Only remove the absolute path for the initial call in\n                # get_parent, and not when we're peeking during the\n                # second call.\n                if not peeking:\n                    remove_path = os.path.abspath(path[:-len(name) - 1])\n                    context[context_name][name].remove(remove_path)\n                return Template(source)\n        raise TemplateDoesNotExist(name)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef open(self):\n        self._connection = paramiko.SSHClient()\n        self._connection.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n        try:\n            self._connection.connect(hostname=self._hostname,\n                                     username=self._username,\n                                     password=self._password,\n                                     timeout=self._timeout,\n                                     port=self._port)\n            self._connection.get_transport().set_keepalive(self._keepalive)\n            self.connected = True\n            self.config = PluribusConfig(self)\n        except paramiko.ssh_exception.AuthenticationException:\n            raise pyPluribus.exceptions.ConnectionError(\"Unable to open connection with {hostname}: \\\n                invalid credentials!\".format(hostname=self._hostname))\n        except socket_error as sockerr:\n            raise pyPluribus.exceptions.ConnectionError(\"Cannot open connection: {skterr}. \\\n                Wrong port?\".format(skterr=sockerr.message))\n        except socket_gaierror as sockgai:\n            raise pyPluribus.exceptions.ConnectionError(\"Cannot open connection: {gaierr}. \\\n                Wrong hostname?\".format(gaierr=sockgai.message))", "response": "Opens a SSH connection with a Pluribus machine."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef close(self):\n        if not self.connected:\n            return None\n        if self.config is not None:\n            if self.config.changed() and not self.config.committed():\n                try:\n                    self.config.discard()  # if configuration changed and not committed, will rollback\n                except pyPluribus.exceptions.ConfigurationDiscardError as discarderr:  # bad luck.\n                    raise pyPluribus.exceptions.ConnectionError(\"Could not discard the configuration: \\\n                        {err}\".format(err=discarderr))\n        self._connection.close()  # close SSH connection\n        self.config = None  # reset config object\n        self._connection = None  #\n        self.connected = False", "response": "Closes the SSH connection if the connection is UP."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nexecuting a command on the device and returns raw output from the CLI.", "response": "def cli(self, command):\n        \"\"\"\n        Executes a command and returns raw output from the CLI.\n\n        :param command: Command to be executed on the CLI.\n        :raise pyPluribus.exceptions.TimeoutError: when execution of the command exceeds the timeout\n        :raise pyPluribus.exceptions.CommandExecutionError: when not able to retrieve the output\n        :return: Raw output of the command\n\n        CLI Example:\n\n        .. code-block:: python\n\n            device.cli('switch-poweroff')\n        \"\"\"\n        if not self.connected:\n            raise pyPluribus.exceptions.ConnectionError(\"Not connected to the deivce.\")\n\n        cli_output = ''\n\n        ssh_session = self._connection.get_transport().open_session()  # opens a new SSH session\n        ssh_session.settimeout(self._timeout)\n\n        ssh_session.exec_command(command)\n\n        ssh_output = ''\n        err_output = ''\n\n        ssh_output_makefile = ssh_session.makefile()\n        ssh_error_makefile = ssh_session.makefile_stderr()\n\n        for byte_output in ssh_output_makefile:\n            ssh_output += byte_output\n\n        for byte_error in ssh_error_makefile:\n            err_output += byte_error\n\n        if not ssh_output:\n            if err_output:\n                raise pyPluribus.exceptions.CommandExecutionError(err_output)\n\n        cli_output = '\\n'.join(ssh_output.split(self._ssh_banner)[-1].splitlines()[1:])\n\n        if cli_output == 'Please enter username and password:':  # rare cases when connection is lost :(\n            self.open()  # retry to open connection\n            return self.cli(command)\n\n        return cli_output"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nexecutes show - type commands on the CLI and returns parsable output usinng ';' as delimitor.", "response": "def execute_show(self, show_command, delim=';'):\n        \"\"\"\n        Executes show-type commands on the CLI and returns parsable output usinng ';' as delimitor.\n\n        :param show_command: Show command to be executed\n        :param delim: Will use specific delimitor. Default: ';'\n        :raise pyPluribus.exceptions.TimeoutError: when execution of the command exceeds the timeout\n        :raise pyPluribus.exceptions.CommandExecutionError: when not able to retrieve the output\n        :return: Parsable output\n\n        CLI Example:\n\n        .. code-block:: python\n\n            device.execute_show('switch-info-show')\n            device.execute_show('node-show', '$$')\n        \"\"\"\n\n        if not show_command.endswith('-show'):\n            raise pyPluribus.exceptions.CommandExecutionError('All show commands must end with \"-show\"!')\n\n        if not delim or delim is None:\n            delim = ';'\n\n        format_command = '{command} parsable-delim {delim}'.format(\n            command=show_command,\n            delim=delim\n        )\n\n        return self.cli(format_command)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef show(self, command, delim=';'):\n\n        if not command.endswith('-show'):\n            command += '-show'\n        command = command.replace(' ', '-')\n\n        return self.execute_show(command, delim)", "response": "Executes show - type commands on the CLI and returns parsable output usinng ';' as delimitor."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef read(file_name, file_contents=None, on_demand=False):\n    '''\n    Loads an arbitrary file type (xlsx, xls, or csv like) and returns\n    a list of 2D tables. For csv files this will be a list of one table,\n    but excel formats can have many tables/worksheets.\n\n    TODO:\n        Add wrapper which can be closed/exited on each file type which cleans\n        up the file handler.\n\n    Args:\n        file_name: The name of the local file, or the holder for the\n            extension type when the file_contents are supplied.\n        file_contents: The file-like object holding contents of file_name.\n            If left as None, then file_name is directly loaded.\n        on_demand: Requests that a yielder be used in place of a full data\n            copy.\n    '''\n    try:\n        if re.search(XML_EXT_REGEX, file_name):\n            return get_data_excel_xml(file_name, file_contents=file_contents, on_demand=on_demand)\n        if re.search(XLSX_EXT_REGEX, file_name):\n            return get_data_xlsx(file_name, file_contents=file_contents, on_demand=on_demand)\n        elif re.search(XLS_EXT_REGEX, file_name):\n            return get_data_xls(file_name, file_contents=file_contents, on_demand=on_demand)\n        elif re.search(CSV_EXT_REGEX, file_name):\n            return get_data_csv(file_name, file_contents=file_contents, on_demand=on_demand)\n        else:\n            try:\n                return get_data_csv(file_name, file_contents=file_contents, on_demand=on_demand)\n            except:\n                raise ValueError(\"Unable to load file '{}' as csv\".format(file_name))\n    except xlrd.XLRDError as e:\n        if \"<?xml\" in str(e):\n            return get_data_excel_xml(file_name, file_contents=file_contents, on_demand=on_demand)\n        raise", "response": "Reads an arbitrary file type xlsx xls or csv and returns a list of 2D tables."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_data_xlsx(file_name, file_contents=None, on_demand=False):\n    '''\n    Loads the new excel format files. Old format files will automatically get loaded as well.\n\n    Args:\n        file_name: The name of the local file, or the holder for the\n            extension type when the file_contents are supplied.\n        file_contents: The file-like object holding contents of file_name.\n            If left as None, then file_name is directly loaded.\n        on_demand: Requests that a yielder be used in place of a full data\n            copy.\n    '''\n    return get_data_xls(file_name, file_contents=file_contents, on_demand=on_demand)", "response": "Loads the new excel format files."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_data_xls(file_name, file_contents=None, on_demand=False):\n    '''\n    Loads the old excel format files. New format files will automatically\n    get loaded as well.\n\n    Args:\n        file_name: The name of the local file, or the holder for the\n            extension type when the file_contents are supplied.\n        file_contents: The file-like object holding contents of file_name.\n            If left as None, then file_name is directly loaded.\n        on_demand: Requests that a yielder be used in place of a full data\n            copy.\n    '''\n    def tuple_to_iso_date(tuple_date):\n        '''\n        Turns a gregorian (year, month, day, hour, minute, nearest_second) into a\n        standard YYYY-MM-DDTHH:MM:SS ISO date.  If the date part is all zeros, it's\n        assumed to be a time; if the time part is all zeros it's assumed to be a date;\n        if all of it is zeros it's taken to be a time, specifically 00:00:00 (midnight).\n\n        Note that datetimes of midnight will come back as date-only strings.  A date\n        of month=0 and day=0 is meaningless, so that part of the coercion is safe.\n        For more on the hairy nature of Excel date/times see\n        http://www.lexicon.net/sjmachin/xlrd.html\n        '''\n        (y,m,d, hh,mm,ss) = tuple_date\n        non_zero = lambda n: n!=0\n        date = \"%04d-%02d-%02d\"  % (y,m,d)    if list(filter(non_zero, (y,m,d)))               else ''\n        time = \"T%02d:%02d:%02d\" % (hh,mm,ss) if list(filter(non_zero, (hh,mm,ss))) or not date else ''\n        return date+time\n\n    def format_excel_val(book, val_type, value, want_tuple_date):\n        '''Cleans up the incoming excel data'''\n        #  Data val_type Codes:\n        #  EMPTY   0\n        #  TEXT    1 a Unicode string\n        #  NUMBER  2 float\n        #  DATE    3 float\n        #  BOOLEAN 4 int; 1 means TRUE, 0 means FALSE\n        #  ERROR   5\n        if   val_type == 2: # TEXT\n            if value == int(value): value = int(value)\n        elif val_type == 3: # NUMBER\n            datetuple = xlrd.xldate_as_tuple(value, book.datemode)\n            value = datetuple if want_tuple_date else tuple_to_iso_date(datetuple)\n        elif val_type == 5: # ERROR\n            value = xlrd.error_text_from_code[value]\n        return value\n\n    def xlrd_xsl_to_array(file_name, file_contents=None):\n        '''\n        Returns:\n            A list of 2-D tables holding the converted cells of each sheet\n        '''\n        book = xlrd.open_workbook(file_name, file_contents=file_contents, on_demand=on_demand)\n        formatter = lambda t_v: format_excel_val(book, t_v[0], t_v[1], False)\n        row_builder = lambda s, r: list(map(formatter, zip(s.row_types(r), s.row_values(r))))\n\n        data = [SheetYielder(book, index, row_builder) for index in range(book.nsheets)]\n        if not on_demand:\n            for sheet in data:\n                sheet.load()\n            book.release_resources()\n        return data\n\n    return xlrd_xsl_to_array(file_name, file_contents)", "response": "Loads the old excel format files."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nloading xml excel format files.", "response": "def get_data_excel_xml(file_name, file_contents=None, on_demand=False):\n    '''\n    Loads xml excel format files.\n\n    Args:\n        file_name: The name of the local file, or the holder for the\n            extension type when the file_contents are supplied.\n        file_contents: The file-like object holding contents of file_name.\n            If left as None, then file_name is directly loaded.\n        on_demand: Requests that a yielder be used in place of a full data\n            copy (will be ignored).\n    '''\n    # NOTE this method is inefficient and uses code that's not of the highest quality\n    if file_contents:\n        xml_file = BytesIO(file_contents)\n    else:\n        xml_file = file_name\n    book = xmlparse.ParseExcelXMLFile(xml_file)\n    row_builder = lambda s, r: list(s.row_values(r))\n    return [XMLSheetYielder(book, index, row_builder) for index in range(len(book))]"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn good old csv data from a file.", "response": "def get_data_csv(file_name, encoding='utf-8', file_contents=None, on_demand=False):\n    '''\n    Gets good old csv data from a file.\n\n    Args:\n        file_name: The name of the local file, or the holder for the\n            extension type when the file_contents are supplied.\n        encoding: Loads the file with the specified cell encoding.\n        file_contents: The file-like object holding contents of file_name.\n            If left as None, then file_name is directly loaded.\n        on_demand: Requests that a yielder be used in place of a full data\n            copy.\n    '''\n    def yield_csv(csv_contents, csv_file):\n        try:\n            for line in csv_contents:\n                yield line\n        finally:\n            try:\n                csv_file.close()\n            except:\n                pass\n\n    def process_csv(csv_contents, csv_file):\n        return [line for line in yield_csv(csv_contents, csv_file)]\n\n    if file_contents:\n        csv_file = BytesIO(file_contents)\n    else:\n        # Don't use 'open as' format, as on_demand loads shouldn't close the file early\n        csv_file = open(file_name, 'rb')\n    reader = csv.reader(csv_file, dialect=csv.excel, encoding=encoding)\n\n    if on_demand:\n        table = yield_csv(reader, csv_file)\n    else:\n        table = process_csv(reader, csv_file)\n\n    return [table]"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef write(data, file_name, worksheet_names=None):\n    '''\n    Writes 2D tables to file.\n\n    Args:\n        data: 2D list of tables/worksheets.\n        file_name: Name of the output file (determines type).\n        worksheet_names: A list of worksheet names (optional).\n    '''\n    if re.search(XML_EXT_REGEX, file_name):\n        return write_xml(data, file_name, worksheet_names=worksheet_names)\n    elif re.search(XLSX_EXT_REGEX, file_name):\n        return write_xlsx(data, file_name, worksheet_names=worksheet_names)\n    elif re.search(XLS_EXT_REGEX, file_name):\n        return write_xls(data, file_name, worksheet_names=worksheet_names)\n    elif re.search(CSV_EXT_REGEX, file_name):\n        return write_csv(data, file_name)\n    else:\n        return write_csv(data, file_name)", "response": "Writes 2D tables to file."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nwrite out to an old excel format.", "response": "def write_xls(data, file_name, worksheet_names=None):\n    '''\n    Writes out to old excel format.\n\n    Args:\n        data: 2D list of tables/worksheets.\n        file_name: Name of the output file.\n        worksheet_names: A list of worksheet names (optional).\n    '''\n    workbook = xlwt.Workbook()\n    for sheet_index, sheet_data in enumerate(data):\n        if worksheet_names and sheet_index < len(worksheet_names) and worksheet_names[sheet_index]:\n            name = worksheet_names[sheet_index]\n        else:\n            name = 'Worksheet {}'.format(sheet_index)\n        sheet = workbook.add_sheet(name)\n        for row_index, row in enumerate(sheet_data):\n            for col_index, value in enumerate(row):\n                sheet.write(row_index, col_index, value)\n    workbook.save(file_name)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef write_csv(data, file_name, encoding='utf-8'):\n    '''\n    Writes out to csv format.\n\n    Args:\n        data: 2D list of tables/worksheets.\n        file_name: Name of the output file.\n    '''\n    name_extension = len(data) > 1\n    root, ext = os.path.splitext(file_name)\n\n    for i, sheet in enumerate(data):\n        fname = file_name if not name_extension else root+\"_\"+str(i)+ext\n        with open(fname, 'wb') as date_file:\n            csv_file = csv.writer(date_file, encoding=encoding)\n            for line in sheet:\n                csv_file.writerow(line)", "response": "Writes out to csv format."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the model class that is used as profile.", "response": "def get_profile_model():\n    \"\"\"\n    Return the model class for the currently-active user profile\n    model, as defined by the ``AUTH_PROFILE_MODULE`` setting.\n\n    :return: The model that is used as profile.\n    \"\"\"\n    if (not hasattr(settings, 'AUTH_PROFILE_MODULE') or\n            not settings.AUTH_PROFILE_MODULE):\n        raise SiteProfileNotAvailable\n\n    profile_mod = get_model(*settings.AUTH_PROFILE_MODULE.split('.'))\n    if profile_mod is None:\n        raise SiteProfileNotAvailable\n    return profile_mod"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets group with given name if it exists.", "response": "def get_group(name):\n    \"\"\"\n    Return group with given name, if it exists. Check cache first.\n    \"\"\"\n    group = cache.get('bits.general.group_%s' % name)\n    if not group:\n        group = Group.objects.get(name=name)\n        cache.set('bits.general.group_%s' % name, group, 365 * 24 * 60 * 60)\n    return group"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef evalop(op,left,right):\n  \"this takes evaluated left and right (i.e. values not expressions)\"\n  if op in ('=','!=','>','<'): return threevl.ThreeVL.compare(op,left,right)\n  elif op in ('+','-','*','/'): # todo: does arithmetic require threevl?\n    if op=='/': raise NotImplementedError('todo: spec about int/float division')\n    return (left + right) if op=='+' else (left - right) if op=='-' else (left * right) if op=='*' else (left/right)\n  elif op=='in': return (tuple(left) in right) if isinstance(left,list) and isinstance(right[0],tuple) else (left in right)\n  elif op in ('and','or'): return threevl.ThreeVL.andor(op,left,right)\n  elif op in ('is not','is'):\n    if right is not None: raise NotImplementedError('can null be on either side? what if neither value is null?')\n    return (left is not None) if (op=='is not') else (left is None)\n  elif op=='@>':\n    # todo: support a TextSearchDoc that will overload a lot of these operators\n    if not all(isinstance(x,list) for x in (left,right)): raise TypeError('non-array-args',op,left,right)\n    return set(left)>=set(right)\n  elif op=='||':\n    if not all(isinstance(x,list) for x in (left,right)): raise TypeError('non-array-args',op,left,right)\n    return left+right\n  elif op=='@@':\n    if not all(isinstance(x,set) for x in (left,right)): raise TypeError('non_set_args',op,type(left),type(right))\n    return bool(left&right)\n  else: raise NotImplementedError(op,left,right)", "response": "this takes evaluated left and right ( i. e. values not expressions"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef uniqify(list_):\n  \"inefficient on long lists; short lists only. preserves order.\"\n  a=[]\n  for x in list_:\n    if x not in a: a.append(x)\n  return a", "response": "inefficient on long lists ; short lists only. preserves order."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef infer_columns(selectx,tables_dict):\n  # todo: support CTEs -- with all this plumbing, might as well\n  table2fields = {}\n  table_order = []\n  for t in selectx.tables:\n    if isinstance(t,basestring):\n      table2fields[t]=tables_dict[t].fields\n      table_order.append(t)\n    elif isinstance(t,sqparse2.AliasX):\n      if isinstance(t.name,basestring):\n        table2fields[t]=tables_dict[t]\n        table_order.append(t.name)\n      elif isinstance(t.name,sqparse2.SelectX): raise NotImplementedError('todo: inner subquery')\n      else: raise TypeError('AliasX.name',type(t.name))\n    else: raise TypeError('table',type(t))\n  # the forms are: *, x.*, x.y, y. expressions are anonymous unless they have an 'as' (which I don't support)\n  table_order=uniqify(table_order)\n  cols=[]\n  used_name_collision = collections.Counter()\n  for col in selectx.cols.children:\n    if isinstance(col,sqparse2.AsterX):\n      for t in table_order:\n        cols.extend(table2fields[t])\n    elif isinstance(col,sqparse2.BaseX):\n      all_paths = treepath.sub_slots(col, lambda x:isinstance(x,(sqparse2.AttrX,sqparse2.NameX,sqparse2.AliasX)), match=True)\n      paths = eliminate_sequential_children(all_paths) # this eliminates NameX under AttrX\n      for p in paths:\n        x = col[p]\n        if isinstance(x,sqparse2.AttrX):\n          if not isinstance(x.parent,sqparse2.NameX): raise TypeError('parent_not_name',type(x.parent))\n          if isinstance(x.attr,sqparse2.NameX): raise NotImplementedError # todo\n          elif isinstance(x.attr,sqparse2.AsterX): cols.extend(table2fields[x.parent.name])\n          else: raise TypeError('attr_unk_type',type(x.attr))\n        elif isinstance(x,sqparse2.NameX):\n          matching_fields = filter(None,(next((f for f in table2fields[t] if f.name==x.name),None) for t in table_order))\n          if len(matching_fields)!=1: raise sqparse2.SQLSyntaxError('missing_or_dupe_field',x,matching_fields)\n          cols.append(matching_fields[0])\n        elif isinstance(x,sqparse2.AliasX): cols.append(sqparse2.ColX(x.alias,None,None,None,None,None))\n        else: raise TypeError('unk_item_type',type(x)) # pragma: no cover\n    else: raise TypeError('unk_col_type',type(col)) # pragma: no cover\n  return cols", "response": "infer the columns for a subselect that creates an implicit table."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef decompose_select(selectx):\n  \"return [(parent,setter) for scalar_subquery], wherex_including_on, NameIndexer. helper for run_select\"\n  nix = NameIndexer.ctor_fromlist(selectx.tables)\n  where = []\n  for fromx in selectx.tables:\n    if isinstance(fromx,sqparse2.JoinX) and fromx.on_stmt is not None:\n      # todo: what happens if on_stmt columns are non-ambiguous in the context of the join tables but ambiguous overall? yuck.\n      where.append(fromx.on_stmt)\n  if selectx.where: where.append(selectx.where)\n  return nix, where", "response": "return [ parent setter for scalar_subquery wherex_including_on NameIndexer. helper for run_select"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\njoining - friendly whereclause evaluator. composite_row is a list or tuple of row lists. where_list is the thing from decompose_select.", "response": "def eval_where(where_list,composite_row,nix,tables_dict):\n  \"join-friendly whereclause evaluator. composite_row is a list or tuple of row lists. where_list is the thing from decompose_select.\"\n  # todo: do I need to use 3vl instead of all() to merge where_list?\n  evaluator = Evaluator(composite_row,nix,tables_dict)\n  return all(evaluator.eval(w) for w in where_list)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef replace_subqueries(ex,tables,table_ctor):\n  \"this mutates passed in ex (any BaseX), replacing nested selects with their (flattened) output\"\n  # http://www.postgresql.org/docs/9.1/static/sql-expressions.html#SQL-SYNTAX-SCALAR-SUBQUERIES\n  # see here for subquery conditions that *do* use multi-rows. ug. http://www.postgresql.org/docs/9.1/static/functions-subquery.html\n  if isinstance(ex,sqparse2.SelectX):\n    old_tables, ex.tables = ex.tables, [] # we *don't* recurse into tables because selects in here get transformed into tables\n  for path in treepath.sub_slots(ex, lambda x:isinstance(x,sqparse2.SelectX)):\n    ex[path] = sqparse2.Literal(flatten_scalar(run_select(ex[path], tables, table_ctor)))\n  if isinstance(ex,sqparse2.SelectX): ex.tables = old_tables\n  return ex", "response": "this mutates passed in ex with nested selects with their ( flattened ) output"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncollapsing columns matching the group expression. I m sure this is buggy ; look at a real DB s imp of this.", "response": "def collapse_group_expr(groupx,cols,ret_row):\n  \"collapses columns matching the group expression. I'm sure this is buggy; look at a real DB's imp of this.\"\n  for i,col in enumerate(cols.children):\n    if col==groupx: ret_row[i]=ret_row[i][0]\n  return ret_row"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreplace SubLit with literals in expr. ( expr is mutated.", "response": "def depth_first_sub(expr,values):\n  \"replace SubLit with literals in expr. (expr is mutated).\"\n  arr=treepath.sub_slots(expr,lambda elt:elt is sqparse2.SubLit)\n  if len(arr)!=len(values): raise ValueError('len',len(arr),len(values))\n  for path,val in zip(arr,values):\n    # todo: does ArrayLit get us anything? tree traversal?\n    if isinstance(val,(basestring,int,float,type(None),dict)): expr[path] = sqparse2.Literal(val)\n    elif isinstance(val,(list,tuple)): expr[path] = sqparse2.ArrayLit(val)\n    else: raise TypeError('unk_sub_type',type(val),val) # pragma: no cover\n  return expr"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef update_aliases(aliases,aonly,x):\n    \"helper for ctor. takes AliasX or string as second arg\"\n    if isinstance(x,basestring): aliases[x]=x\n    elif isinstance(x,sqparse2.AliasX):\n      if not isinstance(x.alias,basestring): raise TypeError('alias not string',type(x.alias))\n      if isinstance(x.name,sqparse2.NameX): aliases.update({x.alias:x.name.name,x.name.name:x.name.name})\n      elif isinstance(x.name,sqparse2.SelectX):\n        aliases.update({x.alias:x.alias})\n        aonly[x.alias]=x.name\n      else: raise TypeError('aliasx_unk_thing',type(x.name)) # pragma: no cover\n    else: raise TypeError(type(x)) # pragma: no cover", "response": "helper for ctor. takes AliasX or string as second arg"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef resolve_aonly(self,tables_dict,table_ctor):\n    \"circular depends on pgmock.Table. refactor.\"\n    for alias,selectx in self.aonly.items():\n      table = table_ctor(alias,infer_columns(selectx,tables_dict),None)\n      table.rows = run_select(selectx,tables_dict,table_ctor)\n      self.aonly[alias] = table\n    self.aonly_resolved = True", "response": "circular depends on pgmock. Table. refactor."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef index_tuple(self,tables_dict,index,is_set):\n    \"helper for rowget/rowset\"\n    if not self.aonly_resolved: raise RuntimeError('resolve_aonly() before querying nix')\n    with tables_dict.tempkeys():\n      tables_dict.update(self.aonly) # todo: find spec support for aliases overwriting existing tables. (more likely, it's an error)\n      index = index.name if isinstance(index,sqparse2.NameX) else index\n      if isinstance(index,basestring):\n        candidates = [t for t in self.table_order if any(f.name==index for f in tables_dict[t].fields)]\n        if len(candidates)!=1: raise ColumnNameError((\"ambiguous_column\" if candidates else \"no_such_column\"),index)\n        tname, = candidates\n        return self.table_order.index(tname), tables_dict[tname].lookup(index).index\n      elif isinstance(index,sqparse2.AttrX):\n        if index.parent.name not in self.aliases: raise TableNameError('table_notin_x',index.parent,self.aliases)\n        tname = self.aliases[index.parent.name]\n        tindex = self.table_order.index(tname)\n        if isinstance(index.attr,sqparse2.AsterX):\n          if is_set: raise ValueError('cant_set_asterisk') # todo: better error class\n          else: return (tindex,)\n        else: return (tindex,tables_dict[tname].lookup(index.attr).index)\n        # todo: stronger typing here. make sure both fields of the AttrX are always strings.\n      else: raise TypeError(type(index)) # pragma: no cover", "response": "helper for rowget / rowset"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef rowget(self,tables_dict,row_list,index):\n    \"row_list in self.row_order\"\n    tmp=row_list\n    for i in self.index_tuple(tables_dict,index,False): tmp=tmp[i]\n    return tmp", "response": "row_list in self. row_order"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef eval_agg_call(self, exp):\n    \"helper for eval_callx; evaluator for CallX that consume multiple rows\"\n    if not isinstance(self.c_row,list): raise TypeError('aggregate function expected a list of rows')\n    if len(exp.args.children)!=1: raise ValueError('aggregate function expected a single value',exp.args)\n    arg,=exp.args.children # intentional: error if len!=1\n    vals=[Evaluator(c_r,self.nix,self.tables).eval(arg) for c_r in self.c_row]\n    if not vals: return None\n    if exp.f=='min': return min(vals)\n    elif exp.f=='max': return max(vals)\n    elif exp.f=='count': return len(vals)\n    else: raise NotImplementedError('unk_func',exp.f)", "response": "helper for eval_callx ; evaluator for CallX that consume multiple rows"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef validate(schema, handler=None, status=400, **kw):\n    def deco(f):\n\n        def wrapped(*args, **kwargs):\n            request.validation_error = None\n\n            if request.method in ('POST', 'PUT'):\n                try:\n                    body = request.body.decode()\n                    if not body:\n                        raise ValueError('No JSON object could be decoded')\n                    data = json.loads(body)\n                    notario.validate(data, schema)\n                except (Invalid, ValueError) as error:\n                    # TODO: It would be nice if we could have a sane default\n                    # here where we set the response body instead of requiring\n                    # a handler\n                    request.validation_error = error\n                    if handler:\n                        redirect_to_handler(error, handler)\n                    # a controller can say `handler=False` to signal they don't\n                    # want to delegate, not even to the fallback\n                    if handler is None:\n                        headers = {'Content-Type': 'application/json'}\n                        raise JSONValidationException(\n                            detail=error,\n                            headers=headers\n                        )\n\n            return f(*args, **kwargs)\n\n        return wrapped\n\n    return deco", "response": "Decorator that validates the request body against the given schema."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef redirect_to_handler(error, location):\n    if callable(location):\n        location = location()\n    request.environ['REQUEST_METHOD'] = 'GET'\n    redirect(location, internal=True)", "response": "Redirect the user to the handler for the current resource."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef assess_fitting_results(basename, cormap_alpha=0.01):\n    plt.figure(figsize=(12, 4))\n    plt.subplot2grid((1, 4), (0, 0), colspan=2)\n    fir = np.loadtxt(basename + '.fir', skiprows=1)  # q, Iexp, Errexp, Ifitted\n    # do a cormap test to compare the raw data and the model.\n    pvalf, Cf, cormapf = cormaptest(fir[:, 1], fir[:, 3])\n    cormapstatusf = ['Reject', 'Accept'][pvalf >= cormap_alpha]\n\n    plt.errorbar(fir[:, 0], fir[:, 1], fir[:, 2], None, 'bo-', label='Raw data')\n    plt.plot(fir[:, 0], fir[:, 3], 'r-', label='Fitted')\n    chi2 = calc_chi2(fir[:, 1], fir[:, 2], fir[:, 3])\n    R2 = calc_R2(fir[:, 1], fir[:, 3])\n    try:\n        skiprows = 0\n        while True:\n            try:\n                fit = np.loadtxt(basename + '.fit', skiprows=skiprows)  # q, Ismoothed, Ifitted\n                break\n            except ValueError as ve:\n                if ve.args[0].startswith('could not convert string to float'):\n                    skiprows += 1\n                    continue\n                else:\n                    raise\n        # do a cormap test to compare the raw data to the smoothed data\n        smoothed = fit[(fit[:, 0] >= fir[:, 0].min()) & (fit[:, 0] <= fir[:, 0].max()), 1]\n        pvals, Cs, cormaps = cormaptest(fir[:, 1], smoothed)\n        cormapstatuss = ['Reject', 'Accept'][pvals >= cormap_alpha]\n        plt.plot(fit[:, 0], fit[:, 1], 'g.-', label='Smoothed, extrapolated')\n        plt.plot(fit[:, 0], fit[:, 2], 'm-', label='Fitted to smoothed, extrapolated')\n    except ValueError as ve:\n        print('Error while loading file: {}.fit: {}'.format(basename, ve))\n    except FileNotFoundError:\n        fit = None\n        cormaps = cormapstatuss = pvals = Cs = None\n    plt.xscale('log')\n    plt.yscale('log')\n    plt.legend(loc='best')\n    plt.grid(which='both')\n    if fit is not None:\n        plt.subplot2grid((1, 4), (0, 2))\n        plt.imshow(cormaps, cmap='gray', interpolation='nearest')\n        plt.title('CorMap of the smoothing')\n    plt.subplot2grid((1, 4), (0, 3))\n    plt.imshow(cormapf, cmap='gray', interpolation='nearest')\n    plt.title('CorMap of the fitting')\n    print('R2: ', R2)\n    print('Chi2: ', chi2)\n    if fit is not None:\n        print('Cormap test of the smoothing: {} (p={}, C={}, N={})'.format(cormapstatuss, pvals, Cs, cormaps.shape[0]))\n    print('Cormap test of fit: {} (p={}, C={}, N={})'.format(cormapstatusf, pvalf, Cf, cormapf.shape[0]))", "response": "Assess the results of a fit based on the. fir files created by the ATSAS suite."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ntransferring string to remote file", "response": "def _transfer_str(self, conn, tmp, name, data):\n        ''' transfer string to remote file '''\n\n        if type(data) == dict:\n            data = utils.jsonify(data)\n\n        afd, afile = tempfile.mkstemp()\n        afo = os.fdopen(afd, 'w')\n        try:\n            afo.write(data.encode('utf8'))\n        except:\n            raise errors.AnsibleError(\"failure encoding into utf-8\")\n        afo.flush()\n        afo.close()\n\n        remote = os.path.join(tmp, name)\n        try:\n            conn.put_file(afile, remote)\n        finally:\n            os.unlink(afile)\n        return remote"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nrun a module that has already been transferred", "response": "def _execute_module(self, conn, tmp, module_name, args,\n        async_jid=None, async_module=None, async_limit=None, inject=None):\n\n        ''' runs a module that has already been transferred '''\n\n        # hack to support fireball mode\n        if module_name == 'fireball':\n            args = \"%s password=%s\" % (args, base64.b64encode(str(utils.key_for_hostname(conn.host))))\n            if 'port' not in args:\n                args += \" port=%s\" % C.ZEROMQ_PORT\n\n        (remote_module_path, is_new_style, shebang) = self._copy_module(conn, tmp, module_name, args, inject)\n\n        cmd_mod = \"\"\n        if self.sudo and self.sudo_user != 'root':\n            # deal with possible umask issues once sudo'ed to other user\n            cmd_chmod = \"chmod a+r %s\" % remote_module_path\n            self._low_level_exec_command(conn, cmd_chmod, tmp, sudoable=False)\n\n        cmd = \"\"\n        if not is_new_style:\n            args = utils.template(self.basedir, args, inject)\n            argsfile = self._transfer_str(conn, tmp, 'arguments', args)\n            if async_jid is None:\n                cmd = \"%s %s\" % (remote_module_path, argsfile)\n            else:\n                cmd = \" \".join([str(x) for x in [remote_module_path, async_jid, async_limit, async_module, argsfile]])\n        else:\n            if async_jid is None:\n                cmd = \"%s\" % (remote_module_path)\n            else:\n                cmd = \" \".join([str(x) for x in [remote_module_path, async_jid, async_limit, async_module]])\n\n        if not shebang:\n            raise errors.AnsibleError(\"module is missing interpreter line\")\n\n        cmd = shebang.replace(\"#!\",\"\") + \" \" + cmd\n        if tmp.find(\"tmp\") != -1 and C.DEFAULT_KEEP_REMOTE_FILES != '1':\n            cmd = cmd + \"; rm -rf %s >/dev/null 2>&1\" % tmp\n        res = self._low_level_exec_command(conn, cmd, tmp, sudoable=True)\n        return ReturnData(conn=conn, result=res['stdout'])"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _executor(self, host):\n        ''' handler for multiprocessing library '''\n\n        try:\n            exec_rc = self._executor_internal(host)\n            #if type(exec_rc) != ReturnData and type(exec_rc) != ansible.runner.return_data.ReturnData:\n            #    raise Exception(\"unexpected return type: %s\" % type(exec_rc))\n            # redundant, right?\n            if not exec_rc.comm_ok:\n                self.callbacks.on_unreachable(host, exec_rc.result)\n            return exec_rc\n        except errors.AnsibleError, ae:\n            msg = str(ae)\n            self.callbacks.on_unreachable(host, msg)\n            return ReturnData(host=host, comm_ok=False, result=dict(failed=True, msg=msg))\n        except Exception:\n            msg = traceback.format_exc()\n            self.callbacks.on_unreachable(host, msg)\n            return ReturnData(host=host, comm_ok=False, result=dict(failed=True, msg=msg))", "response": "handler for multiprocessing library"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nexecute any module one or more times", "response": "def _executor_internal(self, host):\n        ''' executes any module one or more times '''\n\n        host_variables = self.inventory.get_variables(host)\n        if self.transport in [ 'paramiko', 'ssh' ]:\n            port = host_variables.get('ansible_ssh_port', self.remote_port)\n            if port is None:\n                port = C.DEFAULT_REMOTE_PORT\n        else:\n            # fireball, local, etc\n            port = self.remote_port\n\n        inject = {}\n        inject.update(host_variables)\n        inject.update(self.module_vars)\n        inject.update(self.setup_cache[host])\n        inject['hostvars'] = HostVars(self.setup_cache, self.inventory)\n        inject['group_names'] = host_variables.get('group_names', [])\n        inject['groups'] = self.inventory.groups_list()\n\n        # allow with_foo to work in playbooks...\n        items = None\n        items_plugin = self.module_vars.get('items_lookup_plugin', None)\n        if items_plugin is not None and items_plugin in utils.plugins.lookup_loader:\n            items_terms = self.module_vars.get('items_lookup_terms', '')\n            items_terms = utils.template_ds(self.basedir, items_terms, inject)\n            items = utils.plugins.lookup_loader.get(items_plugin, runner=self, basedir=self.basedir).run(items_terms, inject=inject)\n            if type(items) != list:\n                raise errors.AnsibleError(\"lookup plugins have to return a list: %r\" % items)\n\n            if len(items) and self.module_name in [ 'apt', 'yum' ]:\n                # hack for apt and soon yum, with_items maps back into a single module call\n                inject['item'] = \",\".join(items)\n                items = None\n\n        # logic to decide how to run things depends on whether with_items is used\n\n        if items is None:\n            return self._executor_internal_inner(host, self.module_name, self.module_args, inject, port)\n        elif len(items) > 0:\n            # executing using with_items, so make multiple calls\n            # TODO: refactor\n            aggregrate = {}\n            all_comm_ok = True\n            all_changed = False\n            all_failed = False\n            results = []\n            for x in items:\n                inject['item'] = x\n                result = self._executor_internal_inner(host, self.module_name, self.module_args, inject, port)\n                results.append(result.result)\n                if result.comm_ok == False:\n                    all_comm_ok = False\n                    all_failed = True\n                    break\n                for x in results:\n                    if x.get('changed') == True:\n                        all_changed = True\n                    if (x.get('failed') == True) or (('rc' in x) and (x['rc'] != 0)):\n                        all_failed = True\n                        break\n            msg = 'All items completed'\n            if all_failed:\n                msg = \"One or more items failed.\"\n            rd_result = dict(failed=all_failed, changed=all_changed, results=results, msg=msg)\n            if not all_failed:\n                del rd_result['failed']\n            return ReturnData(host=host, comm_ok=all_comm_ok, result=rd_result)\n        else:\n            self.callbacks.on_skipped(host, None)\n            return ReturnData(host=host, comm_ok=True, result=dict(skipped=True))"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ndecide how to invoke a module", "response": "def _executor_internal_inner(self, host, module_name, module_args, inject, port, is_chained=False):\n        ''' decides how to invoke a module '''\n\n        # allow module args to work as a dictionary\n        # though it is usually a string\n        new_args = \"\"\n        if type(module_args) == dict:\n            for (k,v) in module_args.iteritems():\n                new_args = new_args + \"%s='%s' \" % (k,v)\n            module_args = new_args\n\n        module_name = utils.template(self.basedir, module_name, inject)\n        module_args = utils.template(self.basedir, module_args, inject, expand_lists=True)\n\n        if module_name in utils.plugins.action_loader:\n            if self.background != 0:\n                raise errors.AnsibleError(\"async mode is not supported with the %s module\" % module_name)\n            handler = utils.plugins.action_loader.get(module_name, self)\n        elif self.background == 0:\n            handler = utils.plugins.action_loader.get('normal', self)\n        else:\n            handler = utils.plugins.action_loader.get('async', self)\n\n        conditional = utils.template(self.basedir, self.conditional, inject)\n        if not getattr(handler, 'BYPASS_HOST_LOOP', False) and not utils.check_conditional(conditional):\n            result = utils.jsonify(dict(skipped=True))\n            self.callbacks.on_skipped(host, inject.get('item',None))\n            return ReturnData(host=host, result=result)\n\n        conn = None\n        actual_host = inject.get('ansible_ssh_host', host)\n        actual_port = port\n        if self.transport in [ 'paramiko', 'ssh' ]:\n            actual_port = inject.get('ansible_ssh_port', port)\n\n        # the delegated host may have different SSH port configured, etc\n        # and we need to transfer those, and only those, variables\n        delegate_to = inject.get('delegate_to', None)\n        if delegate_to is not None:\n            delegate_to = utils.template(self.basedir, delegate_to, inject)\n            inject = inject.copy()\n            interpreters = []\n            for i in inject:\n                if i.startswith(\"ansible_\") and i.endswith(\"_interpreter\"):\n                    interpreters.append(i)\n            for i in interpreters:\n                del inject[i]\n            port = C.DEFAULT_REMOTE_PORT\n            try:\n                delegate_info = inject['hostvars'][delegate_to]\n                actual_host = delegate_info.get('ansible_ssh_host', delegate_to)\n                actual_port = delegate_info.get('ansible_ssh_port', port)\n                for i in delegate_info:\n                    if i.startswith(\"ansible_\") and i.endswith(\"_interpreter\"):\n                        inject[i] = delegate_info[i]\n            except errors.AnsibleError:\n                actual_host = delegate_to\n                actual_port = port\n\n        try:\n            if actual_port is not None:\n                actual_port = int(actual_port)\n        except ValueError, e:\n            result = dict(failed=True, msg=\"FAILED: Configured port \\\"%s\\\" is not a valid port, expected integer\" % actual_port)\n            return ReturnData(host=host, comm_ok=False, result=result)\n\n        try:\n            conn = self.connector.connect(actual_host, actual_port)\n            if delegate_to or host != actual_host:\n                conn.delegate = host\n\n\n        except errors.AnsibleConnectionFailed, e:\n            result = dict(failed=True, msg=\"FAILED: %s\" % str(e))\n            return ReturnData(host=host, comm_ok=False, result=result)\n\n        tmp = ''\n        # all modules get a tempdir, action plugins get one unless they have NEEDS_TMPPATH set to False\n        if getattr(handler, 'NEEDS_TMPPATH', True):\n            tmp = self._make_tmp_path(conn)\n\n        result = handler.run(conn, tmp, module_name, module_args, inject)\n\n        conn.close()\n\n        if not result.comm_ok:\n            # connection or parsing errors...\n            self.callbacks.on_unreachable(host, result.result)\n        else:\n            data = result.result\n            if 'item' in inject:\n                result.result['item'] = inject['item']\n\n            result.result['invocation'] = dict(\n                module_args=module_args,\n                module_name=module_name\n            )\n\n            if is_chained:\n                # no callbacks\n                return result\n            if 'skipped' in data:\n                self.callbacks.on_skipped(host)\n            elif not result.is_successful():\n                ignore_errors = self.module_vars.get('ignore_errors', False)\n                self.callbacks.on_failed(host, data, ignore_errors)\n            else:\n                self.callbacks.on_ok(host, data)\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _low_level_exec_command(self, conn, cmd, tmp, sudoable=False, executable=None):\n        ''' execute a command string over SSH, return the output '''\n\n        if executable is None:\n            executable = '/bin/sh'\n\n        sudo_user = self.sudo_user\n        rc, stdin, stdout, stderr = conn.exec_command(cmd, tmp, sudo_user, sudoable=sudoable, executable=executable)\n\n        if type(stdout) not in [ str, unicode ]:\n            out = ''.join(stdout.readlines())\n        else:\n            out = stdout\n\n        if type(stderr) not in [ str, unicode ]:\n            err = ''.join(stderr.readlines())\n        else:\n            err = stderr\n\n        if rc != None:\n            return dict(rc=rc, stdout=out, stderr=err )\n        else:\n            return dict(stdout=out, stderr=err )", "response": "execute a command string over SSH return the output"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _remote_md5(self, conn, tmp, path):\n        ''' takes a remote md5sum without requiring python, and returns 0 if no file '''\n\n        test = \"rc=0; [ -r \\\"%s\\\" ] || rc=2; [ -f \\\"%s\\\" ] || rc=1\" % (path,path)\n        md5s = [\n            \"(/usr/bin/md5sum %s 2>/dev/null)\" % path,  # Linux\n            \"(/sbin/md5sum -q %s 2>/dev/null)\" % path,  # ?\n            \"(/usr/bin/digest -a md5 %s 2>/dev/null)\" % path,   # Solaris 10+\n            \"(/sbin/md5 -q %s 2>/dev/null)\" % path,     # Freebsd\n            \"(/usr/bin/md5 -n %s 2>/dev/null)\" % path,  # Netbsd\n            \"(/bin/md5 -q %s 2>/dev/null)\" % path       # Openbsd\n        ]\n\n        cmd = \" || \".join(md5s)\n        cmd = \"%s; %s || (echo \\\"${rc}  %s\\\")\" % (test, cmd, path)\n        data = self._low_level_exec_command(conn, cmd, tmp, sudoable=False)\n        data2 = utils.last_non_blank_line(data['stdout'])\n        try:\n            return data2.split()[0]\n        except IndexError:\n            sys.stderr.write(\"warning: md5sum command failed unusually, please report this to the list so it can be fixed\\n\")\n            sys.stderr.write(\"command: %s\\n\" % md5s)\n            sys.stderr.write(\"----\\n\")\n            sys.stderr.write(\"output: %s\\n\" % data)\n            sys.stderr.write(\"----\\n\")\n            # this will signal that it changed and allow things to keep going\n            return \"INVALIDMD5SUM\"", "response": "returns the md5sum of the remote file"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nmakes and return a temporary path on a remote box", "response": "def _make_tmp_path(self, conn):\n        ''' make and return a temporary path on a remote box '''\n\n        basefile = 'ansible-%s-%s' % (time.time(), random.randint(0, 2**48))\n        basetmp = os.path.join(C.DEFAULT_REMOTE_TMP, basefile)\n        if self.sudo and self.sudo_user != 'root':\n            basetmp = os.path.join('/tmp', basefile)\n\n        cmd = 'mkdir -p %s' % basetmp\n        if self.remote_user != 'root':\n            cmd += ' && chmod a+rx %s' % basetmp\n        cmd += ' && echo %s' % basetmp\n\n        result = self._low_level_exec_command(conn, cmd, None, sudoable=False)\n        rc = utils.last_non_blank_line(result['stdout']).strip() + '/'\n        return rc"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ntransferring a module over SFTP does not run it", "response": "def _copy_module(self, conn, tmp, module_name, module_args, inject):\n        ''' transfer a module over SFTP, does not run it '''\n\n        if module_name.startswith(\"/\"):\n            raise errors.AnsibleFileNotFound(\"%s is not a module\" % module_name)\n\n        # Search module path(s) for named module.\n        in_path = utils.plugins.module_finder.find_plugin(module_name)\n        if in_path is None:\n            raise errors.AnsibleFileNotFound(\"module %s not found in %s\" % (module_name, utils.plugins.module_finder.print_paths()))\n\n        out_path = os.path.join(tmp, module_name)\n\n        module_data = \"\"\n        is_new_style=False\n\n        with open(in_path) as f:\n            module_data = f.read()\n            if module_common.REPLACER in module_data:\n                is_new_style=True\n            module_data = module_data.replace(module_common.REPLACER, module_common.MODULE_COMMON)\n            encoded_args = \"\\\"\\\"\\\"%s\\\"\\\"\\\"\" % module_args.replace(\"\\\"\",\"\\\\\\\"\")\n            module_data = module_data.replace(module_common.REPLACER_ARGS, encoded_args)\n            encoded_lang = \"\\\"\\\"\\\"%s\\\"\\\"\\\"\" % C.DEFAULT_MODULE_LANG\n            module_data = module_data.replace(module_common.REPLACER_LANG, encoded_lang)\n            if is_new_style:\n                facility = C.DEFAULT_SYSLOG_FACILITY\n                if 'ansible_syslog_facility' in inject:\n                    facility = inject['ansible_syslog_facility']\n                module_data = module_data.replace('syslog.LOG_USER', \"syslog.%s\" % facility)\n\n        lines = module_data.split(\"\\n\")\n        shebang = None\n        if lines[0].startswith(\"#!\"):\n            shebang = lines[0]\n            args = shlex.split(str(shebang[2:]))\n            interpreter = args[0]\n            interpreter_config = 'ansible_%s_interpreter' % os.path.basename(interpreter)\n\n            if interpreter_config in inject:\n                lines[0] = shebang = \"#!%s %s\" % (inject[interpreter_config], \" \".join(args[1:]))\n                module_data = \"\\n\".join(lines)\n\n        self._transfer_str(conn, tmp, module_name, module_data)\n\n        return (out_path, is_new_style, shebang)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _parallel_exec(self, hosts):\n        ''' handles mulitprocessing when more than 1 fork is required '''\n        if not hosts:\n            return\n        p = multiprocessing.Pool(self.forks)\n        results = []\n        #results = p.map(multiprocessing_runner, hosts) # can't handle keyboard interrupt\n        results = p.map_async(multiprocessing_runner, hosts).get(9999999)\n        p.close()\n        p.join()\n        return results", "response": "handles mulitprocessing when more than one fork is required"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\npartitioning results by hosts we contacted & ones we didn t", "response": "def _partition_results(self, results):\n        ''' seperate results by ones we contacted & ones we didn't '''\n\n        if results is None:\n            return None\n        results2 = dict(contacted={}, dark={})\n\n        for result in results:\n            host = result.host\n            if host is None:\n                raise Exception(\"internal error, host not set\")\n            if result.communicated_ok():\n                results2[\"contacted\"][host] = result.result\n            else:\n                results2[\"dark\"][host] = result.result\n\n        # hosts which were contacted but never got a chance to return\n        for host in self.inventory.list_hosts(self.pattern):\n            if not (host in results2['dark'] or host in results2['contacted']):\n                results2[\"dark\"][host] = {}\n        return results2"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef run(self):\n        ''' xfer & run module on all matched hosts '''\n\n        # find hosts that match the pattern\n        hosts = self.inventory.list_hosts(self.pattern)\n        if len(hosts) == 0:\n            self.callbacks.on_no_hosts()\n            return dict(contacted={}, dark={})\n\n        global multiprocessing_runner\n        multiprocessing_runner = self\n        results = None\n\n        # Check if this is an action plugin. Some of them are designed\n        # to be ran once per group of hosts. Example module: pause,\n        # run once per hostgroup, rather than pausing once per each\n        # host.\n        p = utils.plugins.action_loader.get(self.module_name, self)\n        if p and getattr(p, 'BYPASS_HOST_LOOP', None):\n            # Expose the current hostgroup to the bypassing plugins\n            self.host_set = hosts\n            # We aren't iterating over all the hosts in this\n            # group. So, just pick the first host in our group to\n            # construct the conn object with.\n            result_data = self._executor(hosts[0]).result\n            # Create a ResultData item for each host in this group\n            # using the returned result. If we didn't do this we would\n            # get false reports of dark hosts.\n            results = [ ReturnData(host=h, result=result_data, comm_ok=True) \\\n                           for h in hosts ]\n            del self.host_set\n        elif self.forks > 1:\n            try:\n                results = self._parallel_exec(hosts)\n            except IOError, ie:\n                print ie.errno\n                if ie.errno == 32:\n                    # broken pipe from Ctrl+C\n                    raise errors.AnsibleError(\"interupted\")\n                raise\n        else:\n            results = [ self._executor(h) for h in hosts ]\n        return self._partition_results(results)", "response": "xfer & run module on all matched hosts"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef run_async(self, time_limit):\n        ''' Run this module asynchronously and return a poller. '''\n\n        self.background = time_limit\n        results = self.run()\n        return results, poller.AsyncPoller(results, self)", "response": "Run this module asynchronously and return a poller."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nruns an interactive Lua interpreter on the specified source_x and source_y.", "response": "def run_interactive(\n        source_x, source_o, timeout=None, memlimit=None, cgroup=None,\n        cgroup_path=None):\n    \"\"\"Challenges source_x vs source_y under time/memory constraints\n\n    memlimit = memory limit in bytes (for Lua interpreter and everything under)\n    cgroup = existing cgroup where to put this contest\n    \"\"\"\n\n    msg = msgpack.packb([source_x, source_o])\n    run_lua = os.path.join(os.path.dirname(__file__), 'run.lua')\n    server = [os.getenv(\"LUA\", \"lua\"), run_lua, '--server']\n    args = dict(bufsize=0xffff, stdin=subprocess.PIPE, stdout=subprocess.PIPE)\n\n    if timeout is not None:\n        server = ['timeout', '%.3f' % timeout] + server\n\n    with limit_ram(memlimit, cgroup, cgroup_path) as cg:\n        if cg is not None:\n            server = ['cgexec', '-g', cg] + server\n\n        with subprocess.Popen(server, **args) as f:\n            send_payload(f.stdin, msg)\n            xo, stop = 'o', False\n            while not stop:\n                msg = get_payload(f.stdout)\n                if msg == b'':\n                    xo = flip(xo)  # because bad thing happened during next exec\n                    f.wait()  # it has to shutdown properly first\n                    if f.returncode == 124:\n                        yield xo, ('error', \"timeout\"), \"\"\n                    else:\n                        errmsg = \"probably OOM (%d)\" % f.returncode\n                        yield xo, ('error', errmsg), \"\"\n                    stop = True\n                else:\n                    [xo, moveresult, log] = msgpack.unpackb(msg)\n                    xo, log = xo.decode('utf8'), log.decode('utf8')\n                    if moveresult[0] == b'error':\n                        yield xo, ('error', moveresult[1].decode('utf8')), \"\"\n                        stop = True\n                    elif moveresult[0] == b'state_coords':\n                        state = moveresult[1][0].decode('utf8')\n                        coords = moveresult[1][1]\n                        if state == 'draw' or state == 'x' or state == 'o':\n                            stop = True\n                        yield xo, ['state_coords', [state, coords]], \"\""}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef image_by_id(self, id):\n        if not id:\n            return None\n        return next((image for image in self.images() if image['Id'] == id),\n                    None)", "response": "Return image with given Id"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning image with given tag", "response": "def image_by_tag(self, tag):\n        \"\"\"\n        Return image with given tag\n        \"\"\"\n        if not tag:\n            return None\n\n        return next((image for image in self.images() if tag\n                     in image['RepoTags']), None)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncheck if specified image exists in the cache.", "response": "def image_exists(self, id=None, tag=None):\n        \"\"\"\n        Check if specified image exists\n        \"\"\"\n        exists = False\n        if id and self.image_by_id(id):\n            exists = True\n        elif tag and self.image_by_tag(tag):\n            exists = True\n\n        return exists"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef container_by_id(self, id):\n        if not id:\n            return None\n        return next((container for container in self.containers(all=True)\n                     if container['Id'] == id), None)", "response": "Returns container with given id"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef container_by_name(self, name):\n        if not name:\n            return None\n\n        # docker prepends a '/' to container names in the container dict\n        name = '/'+name\n        return next((container for container in self.containers(all=True)\n                     if name in container['Names']), None)", "response": "Returns container with given name"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef container_exists(self, id=None, name=None):\n        exists = False\n        if id and self.container_by_id(id):\n            exists = True\n        elif name and self.container_by_name(name):\n            exists = True\n\n        return exists", "response": "Checks if a container exists already"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef container_running(self, id=None, name=None):\n        running = False\n        if id:\n            running = self.inspect_container(id)['State']['Running']\n        elif name:\n            running = self.inspect_container(name)['State']['Running']\n        return running", "response": "Checks if a container is running"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the internal ip of the container if available", "response": "def get_container_ip(self, container):\n        \"\"\"\n        Returns the internal ip of the container if available\n        \"\"\"\n        info = self.inspect_container(container)\n        if not info:\n            return None\n\n        netInfo = info['NetworkSettings']\n        if not netInfo:\n            return None\n\n        ip = netInfo['IPAddress']\n        if not ip:\n            return None\n\n        return ip"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nparsing a file object for a shebang.", "response": "def _parse(fileobj):\n    \"\"\"Parse fileobj for a shebang.\"\"\"\n    fileobj.seek(0)\n    try:\n        part = fileobj.read(2)\n    except UnicodeDecodeError:\n        part = \"\"\n\n    if part == \"#!\":\n        shebang = shlex.split(fileobj.readline().strip())\n        if (platform.system() == \"Windows\" and\n                len(shebang) and\n                os.path.basename(shebang[0]) == \"env\"):\n            return shebang[1:]\n\n        return shebang\n\n    return []"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncheck file_to_parse for a shebang and return its components.", "response": "def parse(file_to_parse):  # suppress(unused-function)\n    \"\"\"Check file_to_parse for a shebang and return its components.\n\n    :file_to_parse: can be either a filename or an open file object.\n\n    If file_to_parse's extension exists in PATHEXT then an empty list\n    will be returned, as it is assumed that the operating system knows\n    how to handle files of this type. All other files will be opened\n    and read.\n    \"\"\"\n    if hasattr(file_to_parse, \"read\"):\n        return _parse(file_to_parse)\n    elif isinstance(file_to_parse, six.string_types):\n        if \"PATHEXT\" in os.environ:\n            path_ext = os.environ[\"PATHEXT\"].split(os.pathsep)\n        else:\n            path_ext = ()\n        if os.path.splitext(file_to_parse)[1] in path_ext:\n            return []\n\n        with open(file_to_parse, \"r\") as fileobj:\n            return _parse(fileobj)\n\n    raise RuntimeError(\"\"\"{} was not a file-like \"\"\"\n                       \"\"\"object.\"\"\".format(repr(file_to_parse)))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngenerating a function to send the content to the file specified in path", "response": "def generate_output_file(path):\n        \"\"\"\n        Generate a function to send the content to the file specified in 'path'\n        :param path:\n        :return:\n        \"\"\"\n\n        def write_file(content):\n            \"\"\"\n            Function to do write_file operation\n            :param content:\n            :return:\n            \"\"\"\n            with open(path, 'w+') as output:\n                output.write(content)\n\n        return write_file"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef generate_file_template_load(path):\n        path = os.path.expanduser(os.path.abspath(\n                path\n        ))\n\n        def read_file():\n            \"\"\"\n            Read file from path and return file contents\n            :return:\n            \"\"\"\n            with open(path) as template:\n                return template.read()\n\n        return read_file", "response": "Generate a function that reads a file from disk and returns the content of the template on disk."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a dictionary of public and private hostnames and ips.", "response": "def response(self):\n        \"\"\"\n        Dictionary of public and private, hostnames and ips.\n        :rtype: dict\n        \"\"\"\n        describe_request_params = {}\n        if self.filter is not None:\n            if type(self.filter) is not dict:\n                try:\n                    filters = json.loads(self.filter)\n                except TypeError:\n                    filters = self._parse_cli_filters(self.filter)\n            else:\n                filters = self.filter\n\n            describe_request_params['Filters'] = filters\n        if self.vpc_ids is not None:\n            if 'Filters' not in describe_request_params:\n                describe_request_params['Filters'] = []\n            describe_request_params['Filters'].append({\n                'Name': 'vpc-id',\n                'Values': self.vpc_ids.split(',')\n            })\n        reservations = self.session().client('ec2').describe_instances(**describe_request_params)\n\n        return self._process_reservations(reservations)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngives a dict with the structure of a response from boto3. ec2. describe_instances(... ) find the public and private ips.", "response": "def _process_reservations(self, reservations):\n        \"\"\"\n        Given a dict with the structure of a response from boto3.ec2.describe_instances(...),\n        find the public/private ips.\n        :param reservations:\n        :return:\n        \"\"\"\n\n        reservations = reservations['Reservations']\n\n        private_ip_addresses = []\n        private_hostnames = []\n        public_ips = []\n        public_hostnames = []\n        for reservation in reservations:\n            for instance in reservation['Instances']:\n                private_ip_addresses.append(instance['PrivateIpAddress'])\n                private_hostnames.append(instance['PrivateDnsName'])\n\n                if 'PublicIpAddress' in instance:\n                    public_ips.append(instance['PublicIpAddress'])\n                elif not self.remove_nones:\n                    public_ips.append(None)\n\n                if ('PublicDnsName' in instance) & (not self.remove_nones):\n                    public_hostnames.append(instance['PublicDnsName'])\n                elif not self.remove_nones:\n                    public_hostnames.append(None)\n\n        return {\n            'private': {\n                'ips': private_ip_addresses,\n                'hostnames': private_hostnames\n            },\n            'public': {\n                'ips': public_ips,\n                'hostnames': public_hostnames\n            },\n            'reservations': reservations\n        }"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _parse_cli_filters(filters):\n        parsed_filters = []\n        for filter_entry in filters:\n            filter_parts = re.match('^Name=(?P<name_value>[^,]+),Values=\\[?(?P<key_values>[^\\]]+)\\]?', filter_entry)\n            parsed_filters.append({\n                'Name': filter_parts.group('name_value'),\n                'Values': filter_parts.group('key_values').split(',')\n            })\n        return parsed_filters", "response": "Parse the filters from the CLI and turn them into a list of dict for boto."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef run(self, port=5000, background=False):\n        target = os.path.dirname(os.path.abspath(sys.argv[0]))\n        driver = Driver(self, port, target, 1)\n        if background:\n            driver.run_background()\n\n        else:\n            driver.run()", "response": "Runs this application with builtin server for testing."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nbinding a handler to the key argspec", "response": "def bind(self, handler, argspec):\n        \"\"\"\n        :param handler: a function with\n        :param argspec:\n        :return:\n        \"\"\"\n        self.handlers[argspec.key].append((handler, argspec))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef unbind(self, handler, argspec):\n        self.handlers[argspec.key].remove((handler, argspec))\n        if not len(self.handlers[argspec.key]):\n            del self.handlers[argspec.key]", "response": "Unbinds a handler from the set of handlers."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef dispatch(self, *args, **kwargs):\n        called_handlers = set()\n        for handler_list in self.handlers.values():\n            for handler, argspec in handler_list:\n                accept_args, accept_kwargs = argspec.accepts\n                if handler in called_handlers and False:\n                    continue\n                else:\n                    if args_match(accept_args, accept_kwargs, self.default, *args, **kwargs):\n                        called_handlers.add(handler)\n                        handler(*args, **kwargs)\n        \n        return called_handlers", "response": "Call handlers that match args or kwargs"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_sorted_tags(self, pattern):\n        matcher = re.compile(pattern)\n        tags = []\n        for tag in self.get_repo().git.tag().split('\\n'):\n            m = matcher.match(tag)\n            if m:\n                numbers = []\n                for k, v in m.groupdict().items():\n                    if k.startswith('cmp'):\n                        numbers.append((int(k[3:]), int(v)))\n                numbers.sort()\n\n                tags.append((tag, numbers))\n        return map(lambda t: t[0], sorted(tags, key=lambda t: t[1], reverse=True))", "response": "returns a list of sorted tags from a pattern"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef iterencode(self, o, _one_shot=False):\n        if self.check_circular:\n            markers = {}\n        else:\n            markers = None\n        if self.ensure_ascii:\n            _encoder = encode_basestring_ascii\n        else:\n            _encoder = encode_basestring\n        if self.encoding != 'utf-8':\n            def _encoder(o, _orig_encoder=_encoder, _encoding=self.encoding):\n                if isinstance(o, str):\n                    o = o.decode(_encoding)\n                return _orig_encoder(o)\n\n        def floatstr(o, allow_nan=self.allow_nan,\n                     _repr=FLOAT_REPR, _inf=INFINITY, _neginf=-INFINITY):\n            # Check for specials.  Note that this type of test is processor\n            # and/or platform-specific, so do tests which don't depend on the\n            # internals.\n\n            if o != o:\n                text = 'NaN'\n            elif o == _inf:\n                text = 'Infinity'\n            elif o == _neginf:\n                text = '-Infinity'\n            else:\n                return _repr(o)\n\n            if not allow_nan:\n                raise ValueError(\n                    \"Out of range float values are not JSON compliant: \" +\n                    repr(o))\n\n            return text\n\n        _iterencode = _make_iterencode(\n            markers, self.default, _encoder, self.indent, floatstr,\n            self.key_separator, self.item_separator, self.sort_keys,\n            self.skipkeys, _one_shot, self._order)\n\n        return _iterencode(o, 0)", "response": "Encode the given object and yield each string\n            representation as available."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the size of the lazy cell", "response": "def size(self):\n        \"\"\"\n        Size of LazyCell:  the size of the intension plus accounting for\n        excluded and included additions.\n\n        The exclusions are assumed to be part of the set\n        The inclusions are assumed to NOT be part of the intension\n        \"\"\"\n        return self._size_full_intension \\\n                    - len(self.exclude)\\\n                    + len(self.include)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef update(self):\n        # updates intension\n        self.update_intension()\n        self._size_known_intension = len(self.members)\n        self._update_members = False", "response": "Updates intension and then adds or includes extension\n       "}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn True if this instance is entailed by other.", "response": "def is_entailed_by(self, other):\n        \"\"\"\n        Means merging other with self does not produce any new information.\n        \"\"\"\n        if not set(self.include.keys()).issubset(set(other.include.keys())):\n            return False\n        if not self.exclude.isuperset(other.exclude):\n            return False\n        if not self.prototype.is_entailed_by(other.prototype):\n            return False\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef is_equal(self, other):\n        print type(self.prototype), type(other.prototype)\n        if not self.prototype.is_equal(other.prototype):\n            print \"Different prototypes\"\n            return False\n        if self.exclude != other.exclude:\n            print \"Different excludes\"\n            return False\n        if self.include != other.include:\n            print \"Different includes\"\n            return False\n        return True", "response": "Returns True if the two sets of attributes are equal."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the members of the LazyDict", "response": "def get_instances(self):\n        \"\"\"\n        Returns the members of the LazyDict\n        \"\"\"\n        if self._update_members: self.update()\n        return iter(sorted(self.members.iteritems()))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a list of Bots for the current user", "response": "def bots_list(self):\n        \"\"\"\n        List all user's bots\n\n        :rtype: list of Bot\n        :return: user's bots\n        \"\"\"\n        data = self.client.bots()\n        return [Bot(item) for item in data]"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef bots_create(self, bot):\n        self.client.bots(_method=\"POST\", _json=bot.to_json(), _params=dict(userToken=self.token))", "response": "Save new bot\n\n        :param bot: bot object to save\n        :type bot: Bot"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef bots_get(self, bot):\n        data = self.client.bots.__getattr__(bot.name).__call__()\n        return Bot(data)", "response": "Fetch and fill Bot object with bot s data"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef bots_update(self, bot):\n        self.client.bots.__getattr__(bot.name).__call__(_method=\"PUT\", _json=bot.to_json(), _params=dict(botName=bot.name))", "response": "Update the current version of the bot s cache."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef bots_delete(self, bot):\n        self.client.bots.__getattr__(bot.name).__call__(_method=\"DELETE\", _params=dict(botName=bot.name))", "response": "Delete existing bot\n\n        :param bot: bot to delete\n        :type bot: Bot"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef talk(self, bot, message):\n        data = self.client.talk(_method=\"POST\", _params=dict(botName=bot.name), _json=message.to_json())\n        return ActionResponse(data)", "response": "Talk to bot and get response based\n       "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef push(self, bot, channel_type, ar, user_id):\n        self.client.push.__getattr__(bot.name).__call__(_method=\"POST\",\n                                                        _params=dict(id=user_id, channel=channel_type),\n                                                        _json=ar.to_json())", "response": "Push a message to a user of a given bot."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsend a message to all users of a given bot.", "response": "def broadcast(self, bot, channel_type, text):\n        \"\"\"\n        Use this method to broadcast text message to all users of bot.\n\n        :param bot: bot that will push user\n        :type bot: Bot\n        :param channel_type: one of [telegram, facebook, slack]\n        :type channel_type: str\n        :param text: text message\n        :type text: str\n        \"\"\"\n        self.client.broadcast.__getattr__(bot.name).__call__(_method=\"POST\",\n                                                        _params=dict(channel=channel_type),\n                                                        _json=dict(message=text))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nparsing a list of lines and creates a internal property dictionary.", "response": "def __parse(self, lines):\n        \"\"\" Parse a list of lines and create\n        an internal property dictionary \"\"\"\n\n        # Every line in the file must consist of either a comment\n        # or a key-value pair. A key-value pair is a line consisting\n        # of a key which is a combination of non-white space characters\n        # The separator character between key-value pairs is a '=',\n        # ':' or a whitespace character not including the newline.\n        # If the '=' or ':' characters are found, in the line, even\n        # keys containing whitespace chars are allowed.\n\n        # A line with only a key according to the rules above is also\n        # fine. In such case, the value is considered as the empty string.\n        # In order to include characters '=' or ':' in a key or value,\n        # they have to be properly escaped using the backslash character.\n\n        # Some examples of valid key-value pairs:\n        #\n        # key     value\n        # key=value\n        # key:value\n        # key     value1,value2,value3\n        # key     value1,value2,value3 \\\n        #         value4, value5\n        # key\n        # This key= this value\n        # key = value1 value2 value3\n\n        # Any line that starts with a '#' or '!' is considerered a comment\n        # and skipped. Also any trailing or preceding whitespaces\n        # are removed from the key/value.\n\n        # This is a line parser. It parses the\n        # contents like by line.\n\n        lineno=0\n        i = iter(lines)\n\n        for line in i:\n            lineno += 1\n            line = line.strip()\n            # Skip null lines\n            if not line: continue\n            # Skip lines which are comments\n            if line[0] in ('#','!'): continue\n            # Some flags\n            escaped=False\n            # Position of first separation char\n            sepidx = -1\n            # A flag for performing wspace re check\n            flag = 0\n            # Check for valid space separation\n            # First obtain the max index to which we\n            # can search.\n            m = self.othercharre.search(line)\n            if m:\n                first, last = m.span()\n                start, end = 0, first\n                flag = 1\n                wspacere = re.compile(r'(?<![\\\\\\=\\:])(\\s)')\n            else:\n                if self.othercharre2.search(line):\n                    # Check if either '=' or ':' is present\n                    # in the line. If they are then it means\n                    # they are preceded by a backslash.\n\n                    # This means, we need to modify the\n                    # wspacere a bit, not to look for\n                    # : or = characters.\n                    wspacere = re.compile(r'(?<![\\\\])(\\s)')\n                start, end = 0, len(line)\n\n            m2 = wspacere.search(line, start, end)\n            if m2:\n                # print 'Space match=>',line\n                # Means we need to split by space.\n                first, last = m2.span()\n                sepidx = first\n            elif m:\n                # print 'Other match=>',line\n                # No matching wspace char found, need\n                # to split by either '=' or ':'\n                first, last = m.span()\n                sepidx = last - 1\n                # print line[sepidx]\n\n\n            # If the last character is a backslash\n            # it has to be preceded by a space in which\n            # case the next line is read as part of the\n            # same property\n            while line[-1] == '\\\\':\n                # Read next line\n                nextline = next(i)\n                nextline = nextline.strip()\n                lineno += 1\n                # This line will become part of the value\n                line = line[:-1] + nextline\n\n            # Now split to key,value according to separation char\n            if sepidx != -1:\n                key, value = line[:sepidx], line[sepidx+1:]\n            else:\n                key,value = line,''\n            self._keyorder.append(key)\n            self.process_pair(key, value)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nprocesses a key value pair", "response": "def process_pair(self, key, value):\n        \"\"\" Process a (key, value) pair \"\"\"\n\n        old_key = key\n        old_value = value\n\n        # Create key intelligently\n        keyparts = self.bspacere.split(key)\n        # print keyparts\n\n        strippable = False\n        lastpart = keyparts[-1]\n\n        if lastpart.find('\\\\ ') != -1:\n            keyparts[-1] = lastpart.replace('\\\\','')\n\n        # If no backspace is found at the end, but empty\n        # space is found, strip it\n        elif lastpart and lastpart[-1] == ' ':\n            strippable = True\n\n        key = ''.join(keyparts)\n        if strippable:\n            key = key.strip()\n            old_key = old_key.strip()\n\n        old_value = self.unescape(old_value)\n        value = self.unescape(value)\n\n        # Patch from N B @ ActiveState\n        curlies = re.compile(r'\\$?\\{.+?\\}')\n        found_variables = curlies.findall(value)\n\n        for found_variable in found_variables:\n            if found_variable.startswith('$'):\n                source_key = found_variable[2:-1]\n            else:\n                source_key = found_variable[1:-1]\n\n            if source_key in self._properties:\n                value = value.replace(found_variable, self._properties[source_key], 1)\n\n        self._properties[key] = value.strip()\n\n        # Check if an entry exists in pristine keys\n        if key in self._keymap:\n            old_key = self._keymap.get(key)\n            self._origprops[old_key] = old_value.strip()\n        else:\n            self._origprops[old_key] = old_value.strip()\n            # Store entry in keymap\n            self._keymap[key] = old_key\n\n        if key not in self._keyorder:\n            self._keyorder.append(key)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef load(self, stream):\n\n        # For the time being only accept file input streams\n        if not _is_file(stream):\n            raise TypeError('Argument should be a file object!')\n        # Check for the opened mode\n        if stream.mode != 'r':\n            raise ValueError('Stream should be opened in read-only mode!')\n\n        try:\n            lines = stream.readlines()\n            self.__parse(lines)\n        except IOError:\n            raise", "response": "Load properties from an open file stream"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the property for the given key to the given value.", "response": "def set_property(self, key, value):\n        \"\"\" Set the property for the given key \"\"\"\n\n        if type(key) is str and type(value) is str:\n            self.process_pair(key, value)\n        else:\n            raise TypeError('Both key and value should be strings!')"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef list(self, out=sys.stdout):\n\n        out.write('-- listing properties --\\n')\n        for key,value in self._properties.items():\n            out.write(''.join((key,'=',value,'\\n')))", "response": "Prints a listing of the properties of the current object to the given stream out which defaults to the standard output"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef store(self, out, header=\"\"):\n\n        if out.mode[0] != 'w':\n            raise ValueError('Steam should be opened in write mode!')\n\n        try:\n            out.write(''.join(('#',header,'\\n')))\n            # Write timestamp\n            tstamp = time.strftime('%a %b %d %H:%M:%S %Z %Y', time.localtime())\n            out.write(''.join(('#',tstamp,'\\n')))\n            # Write properties from the pristine dictionary\n            for prop in self._keyorder:\n                if prop in self._origprops:\n                    val = self._origprops[prop]\n                    out.write(''.join((prop,'=',self.escape(val),'\\n')))\n\n            out.close()\n        except IOError:\n            raise", "response": "Write the properties list to the stream out along with the optional header."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_random(self):\n        num_kittens = self.count()\n        new_cutoff = (num_kittens / (num_kittens + constants.KITTEN_FRESHNESS))\n        if random.random() < new_cutoff:\n            return self._rand_inst()\n        else:\n            return self.create_new()", "response": "Get a random entry from the database or create a new one."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create_new(self):\n        kitten = reddit_kitten()\n        if self.filter(url=kitten.url).exists():\n            return self.get(url=kitten.url)\n        else:\n            kitten_obj = self.create(\n                url=kitten.url,\n                thumbnail=kitten.thumbnail,\n                title=kitten.title,\n            )\n            return kitten_obj", "response": "Create a new kitten by querying reddit_kitten."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef to_python(self,value):\r\n        if value==self.emptyValue or value in EMPTY_VALUES:\r\n            return self.emptyValue\r\n\r\n        try:\r\n            value=self.coerce(value)\r\n        except(ValueError,TypeError,ValidationError):\r\n            raise ValidationError(self.error_messages['invalid_choice']%{'value':value})\r\n\r\n        return value", "response": "Converts the value to the correct type."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreads configuration files initialize glin and run main loop", "response": "def boot():\n    \"\"\"Read configuration files, initialize glin and run main loop\"\"\"\n    argparser = argparse.ArgumentParser(\n        description=\"Controller for LED stripes (WS2801, WS2811 an similar)\")\n    argparser.add_argument(\"-c\", \"--config\", metavar=\"CONFIGFILE\", dest=\"configfiles\", action='append',\n                           help='Configuration File. May be repeated multiple times. Later configuration files override previous ones.')\n    argparser.add_argument(\"-d\", \"--debug\", dest=\"log_debug\", action='store_const', const=True, help='Set log level to debug. Overrides -i/--info')\n    argparser.add_argument(\"-i\", \"--info\", dest=\"log_info\", action='store_const', const=True, help='Set log level to info.')\n\n    args = argparser.parse_args()\n\n    if args.log_debug:\n        logging.basicConfig(level=logging.DEBUG)\n    elif args.log_info:\n        logging.basicConfig(level=logging.INFO)\n\n    cfg = configparser.ConfigParser()\n    cfgpath = os.path.join(os.path.dirname(__file__), \"default.conf\")\n    cfg.read(cfgpath)\n    if args.configfiles is not None:\n        cfg.read(args.configfiles)\n\n    if \"core\" not in cfg:\n        logging.critical(\"No [core] section found in configurations files\")\n        sys.exit()\n    if \"leds\" not in cfg[\"core\"]:\n        logging.critical(\"No leds value found in [core] section in configurations files\")\n        sys.exit()\n    led_count = int(cfg[\"core\"][\"leds\"])\n    if \"hwbackend\" not in cfg[\"core\"]:\n        logging.critical(\"No hwbackend value found in [core] section in configurations files\")\n        sys.exit()\n    backend_name = cfg[\"core\"][\"hwbackend\"]\n\n    hwbackends = list(iter_entry_points(group='glin.hwbackend', name=backend_name))\n    if len(hwbackends) != 1:\n        logging.critical(\"Found multiple hwbackend with same name. Cant decide upon one. Quitting.\")\n        sys.exit()\n    backend_class = hwbackends[0].load()\n    backend_configuration = dict(cfg[backend_name]) if backend_name in cfg else {}\n    backend = backend_class(led_count=led_count, config=backend_configuration)\n\n    app = glin.app.GlinApp(led_count, hw_backend=backend)\n\n    for entry_point in iter_entry_points(group='glin.animation', name=None):\n        animation_class = entry_point.load()\n        try:\n            if issubclass(animation_class, glin.animations.AbstractAnimation):\n                app.register_animation(animation_class)\n            else:\n                logging.error(\"This is not a valid animation class. Has to be subclass of glin.animations:AbstraktAnimation. Ignoring.: {ep}\"\n                              .format(ep=entry_point))\n        except TypeError:\n            logging.error(\"This is not a Class. Ignoring.: {ep}\".format(ep=entry_point))\n\n    app.execute()"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nshells the sound file with the provided filename.", "response": "def _play_sound(self, filename):\n        \"\"\" Shells player with the provided filename.\n\n            `filename`\n                Filename for sound file.\n            \"\"\"\n\n        command = self._get_external_player()\n        if not command:\n            return  # no player found\n\n        if common.IS_MACOSX:\n            command += ' \"{0}\"'.format(filename)\n        else:\n            # append quiet flag and filename\n            is_play = (command == 'play')\n            command += ' -q \"{0}\"'.format(filename)\n\n            # HACK: play can default to using pulseaudio. here, we\n            # check if pulse command exists and delegate to alsa if\n            # not\n            if is_play and not common.which('pulseaudio'):\n                command += ' -t alsa'\n\n        # play sound file, ignore if it fails\n        common.shell_process(command, background=True)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nparses options for play end_play and timer_play.", "response": "def parse_option(self, option, block_name, *values):\n        \"\"\" Parse options for play, end_play, and timer_play.\n            \"\"\"\n\n        if len(values) != 1:\n            raise TypeError\n        value = os.path.realpath(os.path.expanduser(values[0]))\n\n        if not os.path.isfile(value) and not os.path.islink(value):\n            raise ValueError(u'Sound file \"{0}\" does not exist'\n                             .format(value))\n\n        # special extension check for aplay player\n        ext = os.path.splitext(value)[1].lower()\n        if ext != 'wav' and self._get_external_player() == 'aplay':\n            raise ValueError(u\"Only WAV sound file \"\n                             \"supported for 'aplay'\")\n\n        if option == 'play':\n            option = 'start_' + option\n\n        key = option.split('_', 1)[0]\n        self.files[key] = value"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef on_taskend(self, task):\n        key = 'timer' if task.elapsed else 'end'\n        filename = self.files.get(key)\n\n        if filename:\n            self._play_sound(filename)", "response": "Play sounds at task end."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _fixpath(root, base):\n    return os.path.abspath(os.path.normpath(os.path.join(root, base)))", "response": "Return absolute normalized joined paths"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a list of paths sorted by dirname & basename.", "response": "def _sorter(generated):\n    \"\"\"Return a list of paths sorted by dirname & basename.\"\"\"\n    pairs = [(os.path.dirname(f), os.path.basename(f))\n             for f in set(list(generated))]\n\n    pairs.sort()\n\n    return [os.path.join(pair[0], pair[1]) for pair in pairs]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a recursive or non - recursive directory walker", "response": "def _walk(recursion):\n    \"\"\"Returns a recursive or non-recursive directory walker\"\"\"\n    try:\n        from scandir import walk as walk_function\n    except ImportError:\n        from os import walk as walk_function\n\n    if recursion:\n        walk = partial(walk_function)\n    else:\n        def walk(path):  # pylint: disable=C0111\n            try:\n                yield next(walk_function(path))\n            except NameError:\n                yield walk_function(path)\n    return walk"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef isvalid(path, access=None, extensions=None, filetype=None, minsize=None):\n    return ((access is None or os.access(path, access)) and\n            (extensions is None or checkext(path, extensions)) and\n            (((filetype == 'all' and os.path.exists(path)) or\n              (filetype == 'dir' and os.path.isdir(path)) or\n              (filetype == 'file' and os.path.isfile(path))) or\n             filetype is None) and\n            (minsize is None or (not os.path.isfile(path) or\n                                 os.path.getsize(path) > minsize)))", "response": "Check whether a file is valid."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _generator_file(self):\n        for path in self.paths:\n            if os.path.isfile(path):\n                if isvalid(path, self.access, self.extensions,\n                           minsize=self.minsize):\n                    yield os.path.abspath(path)\n            elif os.path.isdir(path):\n                for root, _, fnames in self._walker(path):\n                    yield from self._generator_rebase(fnames, root)", "response": "Generator for file files and directories."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nwalk a directory tree and yield a tuple of the root directory names and filenames.", "response": "def _walker(self, path):\n        \"\"\"Walk a directory tree (optionally recursively)\"\"\"\n        for root, dnames, fnames in _walk(self.recursion)(path):\n            yield (root, dnames, fnames)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a list of all the entries in paths that meet the access criteria.", "response": "def all(self, paths, access=None, recursion=False):\n        \"\"\"\n        Iterates over `paths` (which may consist of files and/or directories).\n        Removes duplicates and returns list of valid paths meeting access\n        criteria.\n        \"\"\"\n        self.__init__()\n        self.access = access\n        self.filetype = 'all'\n        self.paths = paths\n        self.recursion = recursion\n\n        return _sorter(self._generator_other())"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a list of files in the specified paths.", "response": "def files(self, paths, access=None, extensions=None,\n              minsize=None, recursion=False):\n        \"\"\"\n        Iterates over `paths` (which may consist of files and/or directories).\n        Removes duplicates and returns list of valid files meeting access,\n        extension, and minimum size criteria.\n        \"\"\"\n        self.__init__()\n        self.access = access\n        self.filetype = 'file'\n        self.extensions = extensions\n        self.minsize = minsize\n        self.paths = paths\n        self.recursion = recursion\n\n        return _sorter(self._generator_file())"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nverifying list of paths", "response": "def all(self, paths, access=None):\n        \"\"\"Verify list of paths\"\"\"\n        self.failures = [path for path in paths if not\n                         isvalid(path, access, filetype='all')]\n\n        return not self.failures"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nverify list of directories", "response": "def dirs(self, paths, access=None):\n        \"\"\"Verify list of directories\"\"\"\n        self.failures = [path for path in paths if not\n                         isvalid(path, access, filetype='dir')]\n\n        return not self.failures"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef files(self, paths, access=None, extensions=None, minsize=None):\n        self.failures = [path for path in paths if not\n                         isvalid(path, access, extensions, 'file', minsize)]\n\n        return not self.failures", "response": "Verify list of files"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nvalidates the document object with current values.", "response": "def validate(self):\n        \"\"\"Validates the document object with current values, always called\n        within :meth:`couchbasekit.document.Document.save` method.\n\n        :returns: Always True, or raises\n            :exc:`couchbasekit.errors.StructureError` exception.\n        :raises: :exc:`couchbasekit.errors.StructureError` if\n            any validation problem occurs.\n        \"\"\"\n        # __key_field__ value must be provided if defined\n        if self.__key_field__ and self.__key_field__ not in self:\n            raise self.StructureError(msg=\"Key field '%s' is defined \"\n                                          \"but not provided.\" % self.__key_field__)\n        # check the required fields first\n        for required in self.required_fields:\n            log.debug(\"required_field: %s\" % required)\n            if (required not in self and required not in self.default_values) or \\\n               (required in self and self[required] is None):\n                raise self.StructureError(\n                    msg = \"Required field for '%s' is missing.\" % required\n                )\n        return self._validate(self.structure, self)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting a Manhole Factory", "response": "def get_manhole_factory(namespace, **passwords):\n    \"\"\"Get a Manhole Factory\n    \"\"\"\n\n    realm = manhole_ssh.TerminalRealm()\n    realm.chainedProtocolFactory.protocolFactory = (\n        lambda _: EnhancedColoredManhole(namespace)\n    )\n\n    p = portal.Portal(realm)\n    p.registerChecker(\n        checkers.InMemoryUsernamePasswordDatabaseDontUse(**passwords)\n    )\n    return manhole_ssh.ConchFactory(p)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nfinding common parts in a list of items ex. abcd abce abf", "response": "def find_common(self, l):\n        \"\"\"\n        Find common parts in thelist items ex: 'ab' for ['abcd','abce','abf']\n        requires an ordered list\n        \"\"\"\n        if len(l) == 1:\n            return l[0]\n\n        init = l[0]\n        for item in l[1:]:\n            for i, (x, y) in enumerate(zip(init, item)):\n                if x != y:\n                    init = \"\".join(init[:i])\n                    break\n\n            if not init:\n                return None\n        return init"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef find_cluster(cid=None, name=None):\n        LOGGER.debug(\"ClusterService.find_cluster\")\n        ret = None\n        if (cid is None or not cid) and (name is None or not name):\n            raise exceptions.ArianeCallParametersError('id or name')\n\n        if (cid is not None and cid) and (name is not None and name):\n            LOGGER.debug('ClusterService.find_cluster - Both id and name are defined. Will give you search on id.')\n            # traceback.print_stack()\n            name = None\n\n        params = None\n        if cid is not None and cid:\n            params = SessionService.complete_transactional_req({'ID': cid})\n            if MappingService.driver_type != DriverFactory.DRIVER_REST:\n                params['OPERATION'] = 'getCluster'\n        elif name is not None and name:\n            params = SessionService.complete_transactional_req({'name': name})\n            if MappingService.driver_type != DriverFactory.DRIVER_REST:\n                params['OPERATION'] = 'getClusterByName'\n\n        if MappingService.driver_type != DriverFactory.DRIVER_REST:\n            args = {'properties': params}\n        else:\n            args = {'http_operation': 'GET', 'operation_path': 'get', 'parameters': params}\n\n        response = ClusterService.requester.call(args)\n\n        if MappingService.driver_type != DriverFactory.DRIVER_REST:\n            response = response.get()\n\n        if response.rc == 0:\n            ret = Cluster.json_2_cluster(response.response_content)\n        elif response.rc != 404:\n            err_msg = 'ClusterService.find_cluster - Problem while finding cluster (id:' + str(cid) + '). ' + \\\n                      'Reason: ' + str(response.response_content) + ' - ' + str(response.error_message) + \\\n                      \" (\" + str(response.rc) + \")\"\n            LOGGER.warning(err_msg)\n            if response.rc == 500 and ArianeMappingOverloadError.ERROR_MSG in response.error_message:\n                raise ArianeMappingOverloadError(\"ClusterService.find_cluster\", ArianeMappingOverloadError.ERROR_MSG)\n            # traceback.print_stack()\n        return ret", "response": "find the cluster according to provided ID or name"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_clusters():\n        LOGGER.debug(\"ClusterService.get_clusters\")\n        params = SessionService.complete_transactional_req(None)\n        if MappingService.driver_type != DriverFactory.DRIVER_REST:\n            if params is None:\n                params = {}\n            params['OPERATION'] = 'getClusters'\n            args = {'properties': params}\n        else:\n            if params is None:\n                args = {'http_operation': 'GET', 'operation_path': ''}\n            else:\n                args = {'http_operation': 'GET', 'operation_path': '', 'parameters': params}\n\n        response = ClusterService.requester.call(args)\n\n        if MappingService.driver_type != DriverFactory.DRIVER_REST:\n            response = response.get()\n\n        ret = None\n        if response.rc == 0:\n            ret = []\n            for datacenter in response.response_content['clusters']:\n                ret.append(Cluster.json_2_cluster(datacenter))\n        elif response.rc != 404:\n            err_msg = 'ClusterService.get_clusters - Problem while getting clusters. ' \\\n                      'Reason: ' + str(response.response_content) + ' - ' + str(response.error_message) + \\\n                      \" (\" + str(response.rc) + \")\"\n            LOGGER.warning(err_msg)\n            if response.rc == 500 and ArianeMappingOverloadError.ERROR_MSG in response.error_message:\n                raise ArianeMappingOverloadError(\"ClusterService.get_clusters\", ArianeMappingOverloadError.ERROR_MSG)\n            # traceback.print_stack()\n        return ret", "response": "get all available clusters from Ariane server"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef json_2_cluster(json_obj):\n        LOGGER.debug(\"Cluster.json_2_cluster\")\n        return Cluster(\n            cid=json_obj['clusterID'],\n            name=json_obj['clusterName'],\n            containers_id=json_obj['clusterContainersID'],\n            ignore_sync=True\n        )", "response": "Transform json from Ariane server to local object"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ntransforms this local object ot Ariane server JSON object", "response": "def cluster_2_json(self):\n        \"\"\"\n        transform this local object ot Ariane server JSON object\n        :return: the JSON object\n        \"\"\"\n        LOGGER.debug(\"Cluster.cluster_2_json\")\n        json_obj = {\n            'clusterID': self.id,\n            'clusterName': self.name,\n            'clusterContainersID': self.containers_id\n        }\n        return json_obj"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add_container(self, container, sync=True):\n        LOGGER.debug(\"Cluster.add_container\")\n        if not sync or self.id is None:\n            self.containers_2_add.append(container)\n        else:\n            if container.id is None:\n                container.save()\n            if container.id is not None:\n                params = SessionService.complete_transactional_req({\n                    'ID': self.id,\n                    'containerID': container.id\n                })\n                if MappingService.driver_type != DriverFactory.DRIVER_REST:\n                    params['OPERATION'] = 'addClusterContainer'\n                    args = {'properties': params}\n                else:\n                    args = {'http_operation': 'GET', 'operation_path': 'update/containers/add', 'parameters': params}\n\n                response = ClusterService.requester.call(args)\n\n                if MappingService.driver_type != DriverFactory.DRIVER_REST:\n                    response = response.get()\n\n                if response.rc != 0:\n                    LOGGER.warning(\n                        'Cluster.add_container - Problem while updating cluster ' + self.name +\n                        '. Reason: ' + str(response.response_content) + ' - ' + str(response.error_message) +\n                        \" (\" + str(response.rc) + \")\"\n                    )\n                    if response.rc == 500 and ArianeMappingOverloadError.ERROR_MSG in response.error_message:\n                        raise ArianeMappingOverloadError(\"Cluster.add_container\", ArianeMappingOverloadError.ERROR_MSG)\n                    # traceback.print_stack()\n                else:\n                    self.containers_id.append(container.id)\n                    container.cluster_id = self.id\n            else:\n                LOGGER.warning(\n                    'Cluster.add_container - Problem while updating cluster ' + self.name + '. Reason: container ' +\n                    container.gate_uri + ' id is None'\n                )", "response": "add a container to this cluster"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef save(self):\n        LOGGER.debug(\"Cluster.save\")\n        post_payload = {}\n        consolidated_containers_id = []\n\n        if self.id is not None:\n            post_payload['clusterID'] = self.id\n\n        if self.name is not None:\n            post_payload['clusterName'] = self.name\n\n        if self.containers_id is not None:\n            consolidated_containers_id = copy.deepcopy(self.containers_id)\n        if self.containers_2_rm is not None:\n            for container_2_rm in self.containers_2_rm:\n                if container_2_rm.id is None:\n                    container_2_rm.sync()\n                consolidated_containers_id.remove(container_2_rm.id)\n        if self.containers_2_add is not None:\n            for container_2_add in self.containers_2_add:\n                if container_2_add.id is None:\n                    container_2_add.save()\n                consolidated_containers_id.append(container_2_add.id)\n        post_payload['clusterContainersID'] = consolidated_containers_id\n\n        params = SessionService.complete_transactional_req({'payload': json.dumps(post_payload)})\n        if MappingService.driver_type != DriverFactory.DRIVER_REST:\n            params['OPERATION'] = 'createCluster'\n            args = {'properties': params}\n        else:\n            args = {\n                'http_operation': 'POST',\n                'operation_path': '',\n                'parameters': params\n            }\n\n        response = ClusterService.requester.call(args)\n\n        if MappingService.driver_type != DriverFactory.DRIVER_REST:\n            response = response.get()\n\n        if response.rc != 0:\n            LOGGER.warning('Cluster.save - Problem while saving cluster' + self.name +\n                           '. Reason: ' + str(response.response_content) + ' - ' + str(response.error_message) +\n                           \" (\" + str(response.rc) + \")\")\n            if response.rc == 500 and ArianeMappingOverloadError.ERROR_MSG in response.error_message:\n                raise ArianeMappingOverloadError(\"Cluster.save\", ArianeMappingOverloadError.ERROR_MSG)\n            # traceback.print_stack()\n        else:\n            self.id = response.response_content['clusterID']\n            if self.containers_2_add is not None:\n                for container_2_add in self.containers_2_add:\n                    container_2_add.sync()\n            if self.containers_2_rm is not None:\n                for container_2_rm in self.containers_2_rm:\n                    container_2_rm.sync()\n            self.sync(json_obj=response.response_content)\n        self.containers_2_add.clear()\n        self.containers_2_rm.clear()", "response": "Save or update this cluster in Ariane Server."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef remove(self):\n        LOGGER.debug(\"Cluster.remove - \" + self.name)\n        if self.id is None:\n            return None\n        else:\n            params = SessionService.complete_transactional_req({\n                'name': self.name\n            })\n\n            if MappingService.driver_type != DriverFactory.DRIVER_REST:\n                params['OPERATION'] = 'deleteCluster'\n                args = {'properties': params}\n            else:\n                args = {'http_operation': 'GET', 'operation_path': 'delete', 'parameters': params}\n\n            response = ClusterService.requester.call(args)\n\n            if MappingService.driver_type != DriverFactory.DRIVER_REST:\n                response = response.get()\n\n            if response.rc != 0:\n                LOGGER.warning(\n                    'Cluster.remove - Problem while deleting cluster ' + self.name +\n                    '. Reason: ' + str(response.response_content) + ' - ' + str(response.error_message) +\n                    \" (\" + str(response.rc) + \")\"\n                )\n                if response.rc == 500 and ArianeMappingOverloadError.ERROR_MSG in response.error_message:\n                    raise ArianeMappingOverloadError(\"Cluster.remove\", ArianeMappingOverloadError.ERROR_MSG)\n                # traceback.print_stack()\n                return self\n            else:\n                return None", "response": "Removes this object from Ariane server."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfinds container according ID or primary admin gate url.", "response": "def find_container(cid=None, primary_admin_gate_url=None):\n        \"\"\"\n        find container according ID or primary admin gate url. If both are defined this will return container\n        according container ID.\n        :param cid: container ID\n        :param primary_admin_gate_url: container primary admin gate url\n        :return:\n        \"\"\"\n        LOGGER.debug(\"ContainerService.find_container\")\n        ret = None\n        if (cid is None or not cid) and (primary_admin_gate_url is None or not primary_admin_gate_url):\n            raise exceptions.ArianeCallParametersError('id and primary_admin_gate_url')\n\n        if (cid is not None and cid) and (primary_admin_gate_url is not None and primary_admin_gate_url):\n            LOGGER.debug('ContainerService.find_container - Both id and primary admin gate url are defined. '\n                         'Will give you search on id.')\n            # traceback.print_stack()\n            primary_admin_gate_url = None\n\n        params = None\n        if cid is not None and cid:\n            params = SessionService.complete_transactional_req({'ID': cid})\n            if MappingService.driver_type != DriverFactory.DRIVER_REST:\n                params['OPERATION'] = 'getContainer'\n        elif primary_admin_gate_url is not None and primary_admin_gate_url:\n            params = SessionService.complete_transactional_req({'primaryAdminURL': primary_admin_gate_url})\n            if MappingService.driver_type != DriverFactory.DRIVER_REST:\n                params['OPERATION'] = 'getContainerByPrimaryAdminURL'\n\n        if params is not None:\n            if MappingService.driver_type != DriverFactory.DRIVER_REST:\n                args = {\"properties\": params}\n            else:\n                args = {'http_operation': 'GET', 'operation_path': 'get', 'parameters': params}\n\n            response = ContainerService.requester.call(args)\n\n            if MappingService.driver_type != DriverFactory.DRIVER_REST:\n                response = response.get()\n\n            if response.rc == 0:\n                ret = Container.json_2_container(response.response_content)\n            elif response.rc != 404:\n                err_msg = 'ContainerService.find_container - Problem while finding container (id:' + \\\n                          str(cid) + ', primary admin gate url '\\\n                          + str(primary_admin_gate_url) + ' ). ' + \\\n                          'Reason: ' + str(response.response_content) + ' - ' + str(response.error_message) + \\\n                          \" (\" + str(response.rc) + \")\"\n                LOGGER.warning(err_msg)\n                if response.rc == 500 and ArianeMappingOverloadError.ERROR_MSG in response.error_message:\n                    raise ArianeMappingOverloadError(\"ContainerService.find_container\",\n                                                     ArianeMappingOverloadError.ERROR_MSG)\n                # traceback.print_stack()\n        return ret"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_containers():\n        LOGGER.debug(\"ContainerService.get_containers\")\n        params = SessionService.complete_transactional_req(None)\n        if params is None:\n            if MappingService.driver_type != DriverFactory.DRIVER_REST:\n                params = {'OPERATION': 'getContainers'}\n                args = {'properties': params}\n            else:\n                args = {'http_operation': 'GET', 'operation_path': ''}\n        else:\n            if MappingService.driver_type != DriverFactory.DRIVER_REST:\n                params[\"OPERATION\"] = \"getContainers\"\n                args = {'properties': params}\n            else:\n                args = {'http_operation': 'GET', 'operation_path': '', 'parameters': params}\n\n        response = ContainerService.requester.call(args)\n\n        if MappingService.driver_type != DriverFactory.DRIVER_REST:\n            response = response.get()\n\n        ret = None\n        if response.rc == 0:\n            ret = []\n            for container in response.response_content['containers']:\n                ret.append(Container.json_2_container(container))\n        elif response.rc != 404:\n            err_msg = 'ContainerService.get_containers - Problem while getting containers. ' \\\n                      'Reason: ' + str(response.response_content) + ' - ' + str(response.error_message) + \\\n                      \" (\" + str(response.rc) + \")\"\n            LOGGER.warning(err_msg)\n            if response.rc == 500 and ArianeMappingOverloadError.ERROR_MSG in response.error_message:\n                raise ArianeMappingOverloadError(\"ContainerService.get_containers\",\n                                                 ArianeMappingOverloadError.ERROR_MSG)\n            # traceback.print_stack()\n        return ret", "response": "Get all known containers from Ariane Server"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef json_2_container(json_obj):\n        LOGGER.debug(\"Container.json_2_container\")\n        if MappingService.driver_type != DriverFactory.DRIVER_REST:\n            if 'containerProperties' in json_obj:\n                properties = DriverTools.json2properties(json_obj['containerProperties'])\n            else:\n                properties = None\n        else:\n            properties = json_obj['containerProperties'] if 'containerProperties' in json_obj else None\n\n        return Container(\n            cid=json_obj['containerID'],\n            name=json_obj['containerName'],\n            gate_uri=json_obj['containerGateURI'],\n            primary_admin_gate_id=json_obj['containerPrimaryAdminGateID'],\n            cluster_id=json_obj['containerClusterID'] if 'containerClusterID' in json_obj else None,\n            parent_container_id=json_obj['containerParentContainerID'] if 'containerParentContainerID' is json_obj else\n            None,\n            child_containers_id=json_obj['containerChildContainersID'],\n            gates_id=json_obj['containerGatesID'],\n            nodes_id=json_obj['containerNodesID'],\n            company=json_obj['containerCompany'],\n            product=json_obj['containerProduct'],\n            c_type=json_obj['containerType'],\n            properties=properties,\n            ignore_sync=True\n        )", "response": "Transform json from Ariane server to local object"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef container_2_json(self):\n        LOGGER.debug(\"Container.container_2_json\")\n        json_obj = {\n            'containerID': self.id,\n            'containerName': self.name,\n            'containerGateURI': self.gate_uri,\n            'containerPrimaryAdminGateID': self.primary_admin_gate_id,\n            'containerParentContainerID': self.parent_container_id,\n            'containerClusterID': self.child_containers_id,\n            'containerChildContainersID': self.child_containers_id,\n            'containerGatesID': self.gates_id,\n            'containerNodesID': self.nodes_id,\n            'containerCompany': self.company,\n            'containerProduct': self.product,\n            'containerType': self.type,\n            'containerProperties': self.properties\n        }\n        return json_obj", "response": "transform this local object ot Ariane server JSON object\n           "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef sync(self, json_obj=None):\n        LOGGER.debug(\"Container.sync\")\n        if json_obj is None:\n            params = None\n            if self.id is not None:\n                params = SessionService.complete_transactional_req({'ID': self.id})\n\n            if params is not None:\n                if MappingService.driver_type != DriverFactory.DRIVER_REST:\n                    params['OPERATION'] = 'getContainer'\n                    args = {'properties': params}\n                else:\n                    args = {'http_operation': 'GET', 'operation_path': 'get', 'parameters': params}\n\n                response = ContainerService.requester.call(args)\n\n                if MappingService.driver_type != DriverFactory.DRIVER_REST:\n                    response = response.get()\n\n                if response.rc == 0:\n                    json_obj = response.response_content\n                else:\n                    err_msg = 'Container.sync - Problem while syncing container (id: ' + str(self.id) + '). ' \\\n                              'Reason: ' + str(response.response_content) + ' - ' + str(response.error_message) + \\\n                              \" (\" + str(response.rc) + \")\"\n                    LOGGER.warning(err_msg)\n                    if response.rc == 500 and ArianeMappingOverloadError.ERROR_MSG in response.error_message:\n                        raise ArianeMappingOverloadError(\"Container.sync\", ArianeMappingOverloadError.ERROR_MSG)\n                    # traceback.print_stack()\n        elif 'containerID' not in json_obj:\n            err_msg = 'Container.sync - Problem while syncing container (id: ' + str(self.id) + '). ' \\\n                      'Reason: inconsistent json_obj' + str(json_obj) + \" from : \\n\"\n            LOGGER.warning(err_msg)\n            # traceback.print_stack()\n\n        if json_obj is not None:\n            self.id = json_obj['containerID']\n            self.name = json_obj['containerName']\n            self.gate_uri = json_obj['containerGateURI']\n            self.primary_admin_gate_id = json_obj['containerPrimaryAdminGateID']\n            self.cluster_id = json_obj['containerClusterID'] if 'containerClusterID' in json_obj else None\n            self.parent_container_id = json_obj['containerParentContainerID'] if 'containerParentContainerID' \\\n                                                                                 in json_obj else None\n            self.child_containers_id = json_obj['containerChildContainersID']\n            self.gates_id = json_obj['containerGatesID']\n            self.nodes_id = json_obj['containerNodesID']\n            self.company = json_obj['containerCompany']\n            self.product = json_obj['containerProduct']\n            self.type = json_obj['containerType']\n            if MappingService.driver_type != DriverFactory.DRIVER_REST:\n                if 'containerProperties' in json_obj:\n                    self.properties = DriverTools.json2properties(json_obj['containerProperties'])\n                else:\n                    self.properties = None\n            else:\n                self.properties = json_obj['containerProperties'] if 'containerProperties' in json_obj else None", "response": "Synchronizes this container from Ariane server according its id\n           ."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add_property(self, c_property_tuple, sync=True):\n        LOGGER.debug(\"Container.add_property\")\n        if c_property_tuple[1] is None:\n            LOGGER.debug(\"Property \" + c_property_tuple[0] + \" has None value. Ignore.\")\n            return\n\n        if not sync or self.id is None:\n            self.properties_2_add.append(c_property_tuple)\n        else:\n            property_param = DriverTools.property_params(c_property_tuple[0], c_property_tuple[1])\n            params = SessionService.complete_transactional_req({'ID': self.id})\n            if MappingService.driver_type != DriverFactory.DRIVER_REST:\n                params['OPERATION'] = 'addContainerProperty'\n                params['propertyField'] = json.dumps(property_param)\n                args = {'properties': params}\n            else:\n                params['propertyName'] = property_param['propertyName']\n                params['propertyValue'] = property_param['propertyValue']\n                if 'propertyType' in property_param:\n                    params['propertyType'] = property_param['propertyType']\n                args = {'http_operation': 'GET', 'operation_path': 'update/properties/add', 'parameters': params}\n\n            response = ContainerService.requester.call(args)\n\n            if MappingService.driver_type != DriverFactory.DRIVER_REST:\n                response = response.get()\n\n            if response.rc != 0:\n                LOGGER.warning(\n                    'Container.add_property - Problem while updating container ' + self.name +\n                    '.Reason: ' + str(response.response_content) + ' - ' + str(response.error_message) +\n                    \" (\" + str(response.rc) + \")\"\n                )\n                if response.rc == 500 and ArianeMappingOverloadError.ERROR_MSG in response.error_message:\n                    raise ArianeMappingOverloadError(\"Container.add_property\", ArianeMappingOverloadError.ERROR_MSG)\n                # traceback.print_stack()\n            else:\n                self.sync()", "response": "Add a property to this container."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef save(self):\n        LOGGER.debug(\"Container.save\")\n        if self.cluster is not None:\n            if self.cluster.id is None:\n                self.cluster.save()\n            self.cluster_id = self.cluster.id\n\n        if self.parent_container is not None:\n            if self.parent_container.id is None:\n                self.parent_container.save()\n            self.parent_container_id = self.parent_container.id\n\n        if self.primary_admin_gate is not None:\n            if self.primary_admin_gate.id is None:\n                self.primary_admin_gate.save()\n            self.primary_admin_gate_id = self.primary_admin_gate.id\n\n        post_payload = {}\n        consolidated_child_containers_id = []\n        consolidated_child_nodes_id = []\n        consolidated_child_gates_id = []\n        consolidated_properties = {}\n        consolidated_container_properties = []\n\n        if self.id is not None:\n            post_payload['containerID'] = self.id\n\n        if self.name is not None:\n            post_payload['containerName'] = self.name\n\n        if self.company is not None:\n            post_payload['containerCompany'] = self.company\n\n        if self.product is not None:\n            post_payload['containerProduct'] = self.product\n\n        if self.type is not None:\n            post_payload['containerType'] = self.type\n\n        if self.primary_admin_gate_id is not None:\n            post_payload['containerPrimaryAdminGateID'] = self.primary_admin_gate_id\n\n        if self.primary_admin_gate_name is not None:\n            post_payload['containerGateName'] = self.primary_admin_gate_name\n\n        if self.gate_uri is not None:\n            post_payload['containerGateURI'] = self.gate_uri\n\n        if self.cluster_id is not None:\n            post_payload['containerClusterID'] = self.cluster_id\n\n        if self.parent_container_id is not None:\n            post_payload['containerParentContainerID'] = self.parent_container_id\n\n        if self.child_containers_id is not None:\n            consolidated_child_containers_id = copy.deepcopy(self.child_containers_id)\n        if self.child_containers_2_rm is not None:\n            for child_container_2_rm in self.child_containers_2_rm:\n                if child_container_2_rm.id is None:\n                    child_container_2_rm.sync()\n                consolidated_child_containers_id.remove(child_container_2_rm.id)\n        if self.child_containers_2_add is not None:\n            for child_container_2_add in self.child_containers_2_add:\n                if child_container_2_add.id is None:\n                    child_container_2_add.save()\n                consolidated_child_containers_id.append(child_container_2_add.id)\n        post_payload['containerChildContainersID'] = consolidated_child_containers_id\n\n        if self.gates_id is not None:\n            consolidated_child_gates_id = copy.deepcopy(self.gates_id)\n        if self.gates_2_rm is not None:\n            for gate_2_rm in self.gates_2_rm:\n                if gate_2_rm.id is None:\n                    gate_2_rm.sync()\n                consolidated_child_gates_id.remove(gate_2_rm.id)\n        if self.gates_2_add is not None:\n            for gate_2_add in self.gates_2_add:\n                if gate_2_add.id is None:\n                    gate_2_add.sync()\n                consolidated_child_gates_id.append(gate_2_add.id)\n        post_payload['containerGatesID'] = consolidated_child_gates_id\n\n        if self.nodes_id is not None:\n            consolidated_child_nodes_id = copy.deepcopy(self.nodes_id)\n        if self.nodes_2_rm is not None:\n            for node_2_rm in self.nodes_2_rm:\n                if node_2_rm.id is None:\n                    node_2_rm.sync()\n                consolidated_child_nodes_id.remove(node_2_rm.id)\n        if self.nodes_2_add is not None:\n            for node_2_add in self.nodes_2_add:\n                if node_2_add.id is None:\n                    node_2_add.sync()\n                consolidated_child_nodes_id.append(node_2_add.id)\n        post_payload['containerNodesID'] = consolidated_child_nodes_id\n\n        if self.properties is not None:\n            consolidated_properties = copy.deepcopy(self.properties)\n        if self.properties_2_rm is not None:\n            for n_property_name in self.properties_2_rm:\n                consolidated_properties.pop(n_property_name, 0)\n        if self.properties_2_add is not None:\n            for n_property_tuple in self.properties_2_add:\n                consolidated_properties[n_property_tuple[0]] = n_property_tuple[1]\n        if consolidated_properties.__len__() > 0:\n            for key, value in consolidated_properties.items():\n                consolidated_container_properties.append(DriverTools.property_params(key, value))\n        post_payload['containerProperties'] = consolidated_container_properties\n\n        params = SessionService.complete_transactional_req({'payload': json.dumps(post_payload)})\n        if MappingService.driver_type != DriverFactory.DRIVER_REST:\n            params['OPERATION'] = 'createContainer'\n            args = {'properties': params}\n            pass\n        else:\n            args = {\n                'http_operation': 'POST',\n                'operation_path': '',\n                'parameters': params\n            }\n\n        response = ContainerService.requester.call(args)\n\n        if MappingService.driver_type != DriverFactory.DRIVER_REST:\n            response = response.get()\n\n        if response.rc != 0:\n            LOGGER.warning('Container.save - Problem while saving container' + self.name +\n                           '. Reason: ' + str(response.response_content) + ' - ' + str(response.error_message) +\n                           \" (\" + str(response.rc) + \")\")\n            if response.rc == 500 and ArianeMappingOverloadError.ERROR_MSG in response.error_message:\n                raise ArianeMappingOverloadError(\"Container.save\",\n                                                 ArianeMappingOverloadError.ERROR_MSG)\n            # traceback.print_stack()\n        else:\n            self.id = response.response_content['containerID']\n            if self.child_containers_2_add is not None:\n                for child_container_2_add in self.child_containers_2_add:\n                    child_container_2_add.sync()\n            if self.child_containers_2_rm is not None:\n                for child_container_2_rm in self.child_containers_2_rm:\n                    child_container_2_rm.sync()\n            if self.nodes_2_add is not None:\n                for node_2_add in self.nodes_2_add:\n                    node_2_add.sync()\n            if self.nodes_2_rm is not None:\n                for node_2_rm in self.nodes_2_rm:\n                    node_2_rm.sync()\n            if self.gates_2_add is not None:\n                for gate_2_add in self.gates_2_add:\n                    gate_2_add.sync()\n            if self.gates_2_rm is not None:\n                for gate_2_rm in self.gates_2_rm:\n                    gate_2_rm.sync()\n            if self.parent_container is not None:\n                self.parent_container.sync()\n            if self.primary_admin_gate is not None:\n                self.primary_admin_gate.sync()\n            if self.cluster is not None:\n                self.cluster.sync()\n            self.sync(json_obj=response.response_content)\n        self.child_containers_2_add.clear()\n        self.child_containers_2_rm.clear()\n        self.nodes_2_add.clear()\n        self.nodes_2_rm.clear()\n        self.gates_2_add.clear()\n        self.gates_2_rm.clear()\n        self.properties_2_add.clear()\n        self.properties_2_rm.clear()", "response": "Save or update this container in Ariane Server."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef find_node(endpoint_url=None, nid=None, selector=None, name=None, cid=None, pnid=None):\n        LOGGER.debug(\"NodeService.find_node\")\n        ret = None\n        if (nid is None or not nid) and (endpoint_url is None or not endpoint_url) and \\\n                (selector is None or not selector) and (name is None or not name):\n            raise exceptions.ArianeCallParametersError('id and endpoint_url and selector and name')\n\n        if (nid is not None and nid) and \\\n                ((endpoint_url is not None and endpoint_url) or (selector is not None and selector) or\n                 (name is not None and name and ((cid is not None and cid) or (pnid is not None and pnid)))):\n            LOGGER.debug('NodeService.find_node - Both id and other search params are defined. '\n                         'Will give you search on id.')\n            # traceback.print_stack()\n            endpoint_url = None\n            selector = None\n            name = None\n            cid = None\n            pnid = None\n\n        if (endpoint_url is not None and endpoint_url) and \\\n                ((selector is not None and selector) or\n                 (name is not None and name and ((cid is not None and cid) or (pnid is not None and pnid)))):\n            LOGGER.warning('NodeService.find_node - Both endpoint url other search params are defined. '\n                           'Will give you search based on endpoint url')\n            # traceback.print_stack()\n            selector = None\n            name = None\n            cid = None\n            pnid = None\n\n        if (selector is not None and selector) and \\\n                (name is not None and name and ((cid is not None and cid) or (pnid is not None and pnid))):\n            LOGGER.warning('NodeService.find_node - Both selector other search params are defined. '\n                           'Will give you search based on selector')\n            # traceback.print_stack()\n            name = None\n            cid = None\n            pnid = None\n\n        if (name is not None and name) and ((cid is not None and cid) and (pnid is not None and pnid)):\n            LOGGER.warning('NodeService.find_node - search node by name : '\n                           'both container ID and parent node ID are defined. '\n                           'Will give you search based on parent node id')\n            # traceback.print_stack()\n            cid = None\n\n        if (name is not None and name) and ((cid is None or not cid) and (pnid is None or not pnid)):\n            raise exceptions.ArianeCallParametersError('cid and pnid')\n\n        params = None\n        return_set_of_nodes = False\n        if nid is not None and nid:\n            params = SessionService.complete_transactional_req({'ID': nid})\n            if MappingService.driver_type != DriverFactory.DRIVER_REST:\n                params['OPERATION'] = 'getNode'\n        elif endpoint_url is not None and endpoint_url:\n            params = SessionService.complete_transactional_req({'endpointURL': endpoint_url})\n            if MappingService.driver_type != DriverFactory.DRIVER_REST:\n                params['OPERATION'] = 'getNodeByEndpointURL'\n        elif selector is not None and selector:\n            params = SessionService.complete_transactional_req({'selector': selector})\n            if MappingService.driver_type != DriverFactory.DRIVER_REST:\n                params['OPERATION'] = 'getNodes'\n            return_set_of_nodes = True\n        elif name is not None and name:\n            if cid is not None and cid:\n                params = SessionService.complete_transactional_req({'name': name, 'containerID': cid})\n                if MappingService.driver_type != DriverFactory.DRIVER_REST:\n                    params['OPERATION'] = 'getNodeByName'\n            elif pnid is not None and pnid:\n                params = SessionService.complete_transactional_req({'name': name, 'parentNodeID': pnid})\n                if MappingService.driver_type != DriverFactory.DRIVER_REST:\n                    params['OPERATION'] = 'getNodeByName'\n\n        if params is not None:\n            if MappingService.driver_type != DriverFactory.DRIVER_REST:\n                args = {'properties': params}\n            else:\n                args = {'http_operation': 'GET', 'operation_path': 'get', 'parameters': params}\n\n            if MappingService.driver_type != DriverFactory.DRIVER_REST:\n                if cid is not None:\n                    response = MappingService.requester.call(args)\n                else:\n                    response = NodeService.requester.call(args)\n            else:\n                response = NodeService.requester.call(args)\n\n            if MappingService.driver_type != DriverFactory.DRIVER_REST:\n                response = response.get()\n\n            if response.rc == 0:\n                if return_set_of_nodes:\n                    ret = []\n                    for node in response.response_content['nodes']:\n                        ret.append(Node.json_2_node(node))\n                else:\n                    ret = Node.json_2_node(response.response_content)\n            elif response.rc != 404:\n                err_msg = 'NodeService.find_node - Problem while searching node (id:' + str(nid) + \\\n                          ', primary admin gate url ' \\\n                          + str(endpoint_url) + ' ). ' + \\\n                          'Reason: ' + str(response.response_content) + ' - ' + str(response.error_message) + \\\n                          \" (\" + str(response.rc) + \")\"\n                LOGGER.warning(err_msg)\n                if response.rc == 500 and ArianeMappingOverloadError.ERROR_MSG in response.error_message:\n                    raise ArianeMappingOverloadError(\"NodeService.find_node\",\n                                                     ArianeMappingOverloadError.ERROR_MSG)\n                # traceback.print_stack()\n        return ret", "response": "find node according to endpoint url selector name cid and pnid"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_nodes():\n        LOGGER.debug(\"NodeService.get_nodes\")\n        params = SessionService.complete_transactional_req(None)\n        if params is None:\n            if MappingService.driver_type != DriverFactory.DRIVER_REST:\n                params = {'OPERATION': 'getNodes'}\n                args = {'properties': params}\n            else:\n                args = {'http_operation': 'GET', 'operation_path': ''}\n        else:\n            if MappingService.driver_type != DriverFactory.DRIVER_REST:\n                params['OPERATION'] = 'getNodes'\n                args = {'properties': params}\n            else:\n                args = {'http_operation': 'GET', 'operation_path': '', 'parameters': params}\n\n        response = NodeService.requester.call(args)\n\n        if MappingService.driver_type != DriverFactory.DRIVER_REST:\n            response = response.get()\n\n        ret = None\n        if response.rc == 0:\n            ret = []\n            for node in response.response_content['nodes']:\n                ret.append(Node.json_2_node(node))\n        elif response.rc != 404:\n            err_msg = 'NodeService.get_nodes - Problem while getting nodes. ' \\\n                      'Reason: ' + str(response.response_content) + ' - ' + str(response.error_message) + \\\n                      \" (\" + str(response.rc) + \")\"\n            LOGGER.warning(err_msg)\n            if response.rc == 500 and ArianeMappingOverloadError.ERROR_MSG in response.error_message:\n                raise ArianeMappingOverloadError(\"NodeService.get_nodes\",\n                                                 ArianeMappingOverloadError.ERROR_MSG)\n            # traceback.print_stack()\n        return ret", "response": "Get all nodes known on the Ariane server."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ntransforms json payload coming from Ariane server to local object", "response": "def json_2_node(json_obj):\n        \"\"\"\n        transform json payload coming from Ariane server to local object\n        :param json_obj: the json payload coming from Ariane server\n        :return: local node object\n        \"\"\"\n        LOGGER.debug(\"Node.json_2_node\")\n        if MappingService.driver_type != DriverFactory.DRIVER_REST:\n            if 'nodeProperties' in json_obj:\n                properties = DriverTools.json2properties(json_obj['nodeProperties'])\n            else:\n                properties = None\n        else:\n            properties = json_obj['nodeProperties'] if 'nodeProperties' in json_obj else None\n\n        return Node(\n            nid=json_obj['nodeID'],\n            name=json_obj['nodeName'],\n            container_id=json_obj['nodeContainerID'] if 'nodeContainerID' in json_obj else None,\n            parent_node_id=json_obj['nodeParentNodeID'] if 'nodeParentNodeID' in json_obj else None,\n            child_nodes_id=json_obj['nodeChildNodesID'],\n            twin_nodes_id=json_obj['nodeTwinNodesID'],\n            endpoints_id=json_obj['nodeEndpointsID'],\n            properties=properties,\n            ignore_sync=True\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ntransforming local object to JSON object", "response": "def node_2_json(self):\n        \"\"\"\n        transform local object to JSON\n        :return: JSON object\n        \"\"\"\n        LOGGER.debug(\"Node.node_2_json\")\n        json_obj = {\n            'nodeID': self.id,\n            'nodeName': self.name,\n            'nodeContainerID': self.container_id,\n            'nodeParentNodeID': self.parent_node_id,\n            'nodeChildNodesID': self.child_nodes_id,\n            'nodeTwinNodesID': self.twin_nodes_id,\n            'nodeEndpointsID': self.endpoints_id,\n            'nodeProperties': self.properties\n        }\n        return json_obj"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsaving or update this node in Ariane server.", "response": "def save(self):\n        \"\"\"\n        save or update this node in Ariane server\n        :return:\n        \"\"\"\n        LOGGER.debug(\"Node.save\")\n        if self.container is not None:\n            if self.container.id is None:\n                self.container.save()\n            self.container_id = self.container.id\n\n        if self.parent_node is not None:\n            if self.parent_node.id is None:\n                self.parent_node.save()\n            self.parent_node_id = self.parent_node.id\n\n        post_payload = {}\n        consolidated_twin_nodes_id = []\n        consolidated_properties = {}\n        consolidated_node_properties = []\n\n        if self.id is not None:\n            post_payload['nodeID'] = self.id\n\n        if self.name is not None:\n            post_payload['nodeName'] = self.name\n\n        if self.container_id is not None:\n            post_payload['nodeContainerID'] = self.container_id\n\n        if self.parent_node_id is not None:\n            post_payload['nodeParentNodeID'] = self.parent_node_id\n\n        if self.child_nodes_id is not None:\n            post_payload['nodeChildNodesID'] = self.child_nodes_id\n\n        if self.twin_nodes_id is not None:\n            consolidated_twin_nodes_id = copy.deepcopy(self.twin_nodes_id)\n        if self.twin_nodes_2_rm is not None:\n            for twin_node_2_rm in self.twin_nodes_2_rm:\n                if twin_node_2_rm.id is None:\n                    twin_node_2_rm.sync()\n                consolidated_twin_nodes_id.remove(twin_node_2_rm.id)\n        if self.twin_nodes_2_add is not None:\n            for twin_node_2_add in self.twin_nodes_2_add:\n                if twin_node_2_add.id is None:\n                    twin_node_2_add.save()\n                consolidated_twin_nodes_id.append(twin_node_2_add.id)\n        post_payload['nodeTwinNodesID'] = consolidated_twin_nodes_id\n\n        if self.endpoints_id is not None:\n            post_payload['nodeEndpointsID'] = self.endpoints_id\n\n        if self.properties is not None:\n            consolidated_properties = copy.deepcopy(self.properties)\n        if self.properties_2_rm is not None:\n            for n_property_name in self.properties_2_rm:\n                consolidated_properties.pop(n_property_name, 0)\n        if self.properties_2_add is not None:\n            for n_property_tuple in self.properties_2_add:\n                consolidated_properties[n_property_tuple[0]] = n_property_tuple[1]\n        if consolidated_properties.__len__() > 0:\n            for key, value in consolidated_properties.items():\n                    consolidated_node_properties.append(DriverTools.property_params(key, value))\n        post_payload['nodeProperties'] = consolidated_node_properties\n\n        params = SessionService.complete_transactional_req({'payload': json.dumps(post_payload)})\n        if MappingService.driver_type != DriverFactory.DRIVER_REST:\n            params['OPERATION'] = 'createNode'\n            args = {'properties': params}\n        else:\n            args = {\n                'http_operation': 'POST',\n                'operation_path': '',\n                'parameters': params\n            }\n\n        response = NodeService.requester.call(args)\n\n        if MappingService.driver_type != DriverFactory.DRIVER_REST:\n            response = response.get()\n\n        if response.rc != 0:\n            LOGGER.warning('Node.save - Problem while saving node' + self.name +\n                           '. Reason: ' + str(response.response_content) + ' - ' + str(response.error_message) +\n                           \" (\" + str(response.rc) + \")\")\n            if response.rc == 500 and ArianeMappingOverloadError.ERROR_MSG in response.error_message:\n                raise ArianeMappingOverloadError(\"Node.save\",\n                                                 ArianeMappingOverloadError.ERROR_MSG)\n            # traceback.print_stack()\n        else:\n            self.id = response.response_content['nodeID']\n            if self.twin_nodes_2_add is not None:\n                for twin_node_2_add in self.twin_nodes_2_add:\n                    twin_node_2_add.sync()\n            if self.twin_nodes_2_rm is not None:\n                for twin_node_2_rm in self.twin_nodes_2_rm:\n                    twin_node_2_rm.sync()\n            if self.container is not None:\n                self.container.sync()\n            if self.parent_node is not None:\n                self.parent_node.sync()\n            self.sync(json_obj=response.response_content)\n        self.twin_nodes_2_add.clear()\n        self.twin_nodes_2_rm.clear()\n        self.properties_2_add.clear()\n        self.properties_2_rm.clear()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nfinding gate according node ID.", "response": "def find_gate(nid=None):\n        \"\"\"\n        find gate according node ID.\n        :param nid: node id\n        :return: the gate if found or None if not found\n        \"\"\"\n        LOGGER.debug(\"GateService.find_gate\")\n        ret = None\n        if nid is None or not nid:\n            raise exceptions.ArianeCallParametersError('id')\n        params = SessionService.complete_transactional_req({'ID': nid})\n\n        if MappingService.driver_type != DriverFactory.DRIVER_REST:\n            params['OPERATION'] = 'getGate'\n            args = {'properties': params}\n        else:\n            args = {'http_operation': 'GET', 'operation_path': 'get', 'parameters': params}\n\n        response = GateService.requester.call(args)\n\n        if MappingService.driver_type != DriverFactory.DRIVER_REST:\n            response = response.get()\n\n        if response.rc == 0:\n            ret = Gate.json_2_gate(response.response_content)\n        elif response.rc != 404:\n            err_msg = 'GateService.find_gate - Problem while searching gate (id:' + str(nid) + ' ). ' + \\\n                      '. Reason: ' + str(response.response_content) + ' - ' + str(response.error_message) + \\\n                      \" (\" + str(response.rc) + \")\"\n            LOGGER.warning(err_msg)\n            if response.rc == 500 and ArianeMappingOverloadError.ERROR_MSG in response.error_message:\n                raise ArianeMappingOverloadError(\"GateService.find_gate\",\n                                                 ArianeMappingOverloadError.ERROR_MSG)\n            # traceback.print_stack()\n        return ret"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_gates():\n        LOGGER.debug(\"GateService.get_gates\")\n        params = SessionService.complete_transactional_req(None)\n        if params is None:\n            if MappingService.driver_type != DriverFactory.DRIVER_REST:\n                params = {'OPERATION': 'getGates'}\n                args = {'properties': params}\n            else:\n                args = {'http_operation': 'GET', 'operation_path': ''}\n        else:\n            if MappingService.driver_type != DriverFactory.DRIVER_REST:\n                params['OPERATION'] = 'getGates'\n                args = {'properties': params}\n            else:\n                args = {'http_operation': 'GET', 'operation_path': '', 'parameters': params}\n\n        response = GateService.requester.call(args)\n\n        if MappingService.driver_type != DriverFactory.DRIVER_REST:\n            response = response.get()\n\n        ret = None\n        if response.rc == 0:\n            ret = []\n            for gate in response.response_content['gates']:\n                ret.append(Gate.json_2_gate(gate))\n        elif response.rc != 404:\n            err_msg = 'GateService.get_gates - Problem while getting nodes. ' \\\n                      '. Reason: ' + str(response.response_content) + ' - ' + str(response.error_message) + \\\n                      \" (\" + str(response.rc) + \")\"\n            LOGGER.warning(err_msg)\n            if response.rc == 500 and ArianeMappingOverloadError.ERROR_MSG in response.error_message:\n                raise ArianeMappingOverloadError(\"GateService.get_gates\",\n                                                 ArianeMappingOverloadError.ERROR_MSG)\n            # traceback.print_stack()\n        return ret", "response": "Get all gates known on the Ariane server."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef find_endpoint(url=None, eid=None, selector=None, cid=None, nid=None, local_cache=True):\n        LOGGER.debug(\"EndpointService.find_endpoint\")\n        ret = None\n        if (eid is None or not eid) and (url is None or not url) and (selector is None or not selector):\n            raise exceptions.ArianeCallParametersError('id, endpoint_url and selector')\n\n        if (eid is not None and eid) and ((url is not None and url) or (selector is not None and selector)):\n            LOGGER.debug('EndpointService.find_endpoint - '\n                         'Both id and (endpoint url or selector) are defined. Will give you search on id.')\n            # traceback.print_stack()\n            url = None\n            selector = None\n\n        if (url is not None and url) and (selector is not None and selector):\n            LOGGER.warning('EndpointService.find_endpoint - '\n                           'Both endpoint url and selector are defined. Will give you search on url.')\n            # traceback.print_stack()\n            selector = None\n\n        params = None\n        search_params = None\n        mapping_service_call = False\n        return_set_of_endpoints = False\n        if eid is not None and eid:\n            search_params = {'ID': eid}\n            params = SessionService.complete_transactional_req({'ID': eid})\n            if MappingService.driver_type != DriverFactory.DRIVER_REST:\n                params['OPERATION'] = 'getEndpoint'\n        elif url is not None and url:\n            search_params = {'URL': url}\n            params = SessionService.complete_transactional_req({'URL': url})\n            if MappingService.driver_type != DriverFactory.DRIVER_REST:\n                params['endpointURL'] = url\n                params['OPERATION'] = 'getEndpointByURL'\n        elif selector is not None and selector:\n            if cid is None and nid is None:\n                search_params = {'selector': selector}\n                params = SessionService.complete_transactional_req({'selector': selector})\n                if MappingService.driver_type != DriverFactory.DRIVER_REST:\n                    params['OPERATION'] = 'getEndpoints'\n            else:\n                if nid is not None and nid:\n                    search_params = {'nodeID': nid, 'selector': selector}\n                    params = SessionService.complete_transactional_req({'nodeID': nid, 'selector': selector})\n                    if MappingService.driver_type != DriverFactory.DRIVER_REST:\n                        params['OPERATION'] = 'getEndpointsBySelector'\n                        mapping_service_call = True\n                elif cid is not None and cid:\n                    search_params = {'containerID': cid, 'selector': selector}\n                    params = SessionService.complete_transactional_req({'containerID': cid, 'selector': selector})\n                    if MappingService.driver_type != DriverFactory.DRIVER_REST:\n                        params['OPERATION'] = 'getEndpointsBySelector'\n                        mapping_service_call = True\n            return_set_of_endpoints = True\n\n        if params is not None:\n            if str(search_params) in EndpointService.local_cache_by_params.keys():\n                ret = EndpointService.local_cache_by_params[str(search_params)]\n            else:\n                if MappingService.driver_type != DriverFactory.DRIVER_REST:\n                    args = {'properties': params}\n                else:\n                    args = {'http_operation': 'GET', 'operation_path': 'get', 'parameters': params}\n\n                if mapping_service_call:\n                    response = MappingService.requester.call(args)\n                else:\n                    response = EndpointService.requester.call(args)\n\n                if MappingService.driver_type != DriverFactory.DRIVER_REST:\n                    response = response.get()\n\n                if response.rc == 0:\n                    if return_set_of_endpoints:\n                        ret = []\n                        for endpoint in response.response_content['endpoints']:\n                            ep = Endpoint.json_2_endpoint(endpoint)\n                            ret.append(ep)\n                            if local_cache:\n                                if ep.id not in EndpointService.local_cache_by_id:\n                                    EndpointService.local_cache_by_id[ep.id] = []\n                                eid_search_params = {'ID': ep.id}\n                                EndpointService.local_cache_by_params[str(eid_search_params)] = ep\n                                EndpointService.local_cache_by_id[ep.id].append(str(eid_search_params))\n                    else:\n                        ret = Endpoint.json_2_endpoint(response.response_content)\n                        if local_cache:\n                            if ret.id not in EndpointService.local_cache_by_id.keys():\n                                EndpointService.local_cache_by_id[ret.id] = []\n                            EndpointService.local_cache_by_params[str(search_params)] = ret\n                            EndpointService.local_cache_by_id[ret.id].append(str(search_params))\n                            if eid is None or not eid:\n                                eid_search_params = {'ID': ret.id}\n                                EndpointService.local_cache_by_params[str(eid_search_params)] = ret\n                                EndpointService.local_cache_by_id[ret.id].append(str(eid_search_params))\n\n                elif response.rc != 404:\n                    err_msg = 'EndpointService.find_endpoint - Problem while searching endpoint (id:' + \\\n                              str(eid) + ', primary admin gate url: ' + str(url) + ', selector: ' + str(selector) + \\\n                              ', cid: ' + str(cid) + ', nid: ' + str(nid) + '). ' + \\\n                              'Reason: ' + str(response.response_content) + ' - ' + str(response.error_message) + \\\n                              \" (\" + str(response.rc) + \")\"\n                    LOGGER.warning(err_msg)\n                    if response.rc == 500 and ArianeMappingOverloadError.ERROR_MSG in response.error_message:\n                        raise ArianeMappingOverloadError(\"EndpointService.find_endpoint\",\n                                                         ArianeMappingOverloadError.ERROR_MSG)\n                    # traceback.print_stack()\n\n        return ret", "response": "find endpoint according to endpoint url eid selector cid nid local_cache is True if found in cache otherwise returns None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting all endpoints known on the Ariane server.", "response": "def get_endpoints():\n        \"\"\"\n        get all endpoints known on the Ariane server\n        :return:\n        \"\"\"\n        LOGGER.debug(\"EndpointService.get_endpoints\")\n        params = SessionService.complete_transactional_req(None)\n        if params is None:\n            if MappingService.driver_type != DriverFactory.DRIVER_REST:\n                params = {'OPERATION': 'getEndpoints'}\n                args = {'properties': params}\n            else:\n                args = {'http_operation': 'GET', 'operation_path': ''}\n        else:\n            if MappingService.driver_type != DriverFactory.DRIVER_REST:\n                params['OPERATION'] = 'getEndpoints'\n                args = {'properties': params}\n            else:\n                args = {'http_operation': 'GET', 'operation_path': '', 'parameters': params}\n\n        response = EndpointService.requester.call(args)\n\n        if MappingService.driver_type != DriverFactory.DRIVER_REST:\n            response = response.get()\n\n        ret = None\n        if response.rc == 0:\n            ret = []\n            for endpoint in response.response_content['endpoints']:\n                ret.append(Endpoint.json_2_endpoint(endpoint))\n        elif response.rc != 404:\n            err_msg = 'EndpointService.get_endpoints - Problem while getting nodes. ' \\\n                      'Reason: ' + str(response.response_content) + ' - ' + str(response.error_message) + \\\n                      \" (\" + str(response.rc) + \")\"\n            LOGGER.warning(err_msg)\n            if response.rc == 500 and ArianeMappingOverloadError.ERROR_MSG in response.error_message:\n                raise ArianeMappingOverloadError(\"EndpointService.get_endpoints\",\n                                                 ArianeMappingOverloadError.ERROR_MSG)\n            # traceback.print_stack()\n        return ret"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ntransform json payload coming from Ariane server to local object", "response": "def json_2_endpoint(json_obj):\n        \"\"\"\n        transform json payload coming from Ariane server to local object\n        :param json_obj: the json payload coming from Ariane server\n        :return: local endpoint object\n        \"\"\"\n        LOGGER.debug(\"Endpoint.json_2_endpoint\")\n        if MappingService.driver_type != DriverFactory.DRIVER_REST:\n            if 'endpointProperties' in json_obj:\n                properties = DriverTools.json2properties(json_obj['endpointProperties'])\n            else:\n                properties = None\n        else:\n            properties = json_obj['endpointProperties'] if 'endpointProperties' in json_obj else None\n\n        return Endpoint(\n            eid=json_obj['endpointID'],\n            url=json_obj['endpointURL'],\n            parent_node_id=json_obj['endpointParentNodeID'] if 'endpointParentNodeID' in json_obj else None,\n            twin_endpoints_id=json_obj['endpointTwinEndpointsID'],\n            properties=properties,\n            ignore_sync=True\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef endpoint_2_json(self):\n        LOGGER.debug(\"Endpoint.endpoint_2_json\")\n        json_obj = {\n            \"endpointID\": self.id,\n            \"endpointURL\": self.url,\n            \"endpointParentNodeID\": self.parent_node_id,\n            \"endpointTwinEndpointsID\": self.twin_endpoints_id,\n            \"endpointProperties\": self.properties\n        }\n        return json_obj", "response": "transform local object to JSON object"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef save(self):\n        LOGGER.debug(\"Endpoint.save\")\n        if self.parent_node is not None:\n            if self.parent_node.id is None:\n                self.parent_node.save()\n            self.parent_node_id = self.parent_node.id\n\n        post_payload = {}\n        consolidated_twin_endpoints_id = []\n        consolidated_properties = {}\n        consolidated_endpoint_properties = []\n\n        if self.id is not None:\n            post_payload['endpointID'] = self.id\n\n        if self.url is not None:\n            post_payload['endpointURL'] = self.url\n\n        if self.parent_node_id is not None:\n            post_payload['endpointParentNodeID'] = self.parent_node_id\n\n        if self.twin_endpoints_id is not None:\n            consolidated_twin_endpoints_id = copy.deepcopy(self.twin_endpoints_id)\n        if self.twin_endpoints_2_rm is not None:\n            for twin_node_2_rm in self.twin_endpoints_2_rm:\n                if twin_node_2_rm.id is None:\n                    twin_node_2_rm.sync()\n                consolidated_twin_endpoints_id.remove(twin_node_2_rm.id)\n        if self.twin_endpoints_2_add is not None:\n            for twin_endpoint_2_add in self.twin_endpoints_2_add:\n                if twin_endpoint_2_add.id is None:\n                    twin_endpoint_2_add.save()\n                consolidated_twin_endpoints_id.append(twin_endpoint_2_add.id)\n        post_payload['endpointTwinEndpointsID'] = consolidated_twin_endpoints_id\n\n        if self.properties is not None:\n            consolidated_properties = copy.deepcopy(self.properties)\n        if self.properties_2_rm is not None:\n            for n_property_name in self.properties_2_rm:\n                consolidated_properties.pop(n_property_name, 0)\n        if self.properties_2_add is not None:\n            for n_property_tuple in self.properties_2_add:\n                consolidated_properties[n_property_tuple[0]] = n_property_tuple[1]\n        if consolidated_properties.__len__() > 0:\n            for key, value in consolidated_properties.items():\n                consolidated_endpoint_properties.append(DriverTools.property_params(key, value))\n        post_payload['endpointProperties'] = consolidated_endpoint_properties\n\n        params = SessionService.complete_transactional_req({'payload': json.dumps(post_payload)})\n        if MappingService.driver_type != DriverFactory.DRIVER_REST:\n            params['OPERATION'] = 'createEndpoint'\n            args = {'properties': params}\n        else:\n            args = {\n                'http_operation': 'POST',\n                'operation_path': '',\n                'parameters': params\n            }\n\n        response = EndpointService.requester.call(args)\n\n        if MappingService.driver_type != DriverFactory.DRIVER_REST:\n            response = response.get()\n\n        if response.rc != 0:\n            LOGGER.warning('Endpoint.save - Problem while saving endpoint ' + self.url +\n                           '. Reason: ' + str(response.response_content) + ' - ' + str(response.error_message) +\n                           \" (\" + str(response.rc) + \")\")\n            if response.rc == 500 and ArianeMappingOverloadError.ERROR_MSG in response.error_message:\n                raise ArianeMappingOverloadError(\"Endpoint.save\",\n                                                 ArianeMappingOverloadError.ERROR_MSG)\n            # traceback.print_stack()\n        else:\n            self.id = response.response_content['endpointID']\n            if self.twin_endpoints_2_add is not None:\n                for twin_endpoint_2_add in self.twin_endpoints_2_add:\n                    twin_endpoint_2_add.sync()\n            if self.twin_endpoints_2_rm is not None:\n                for twin_node_2_rm in self.twin_endpoints_2_rm:\n                    twin_node_2_rm.sync()\n            if self.parent_node is not None:\n                self.parent_node.sync()\n            self.sync(json_obj=response.response_content)\n        self.twin_endpoints_2_add.clear()\n        self.twin_endpoints_2_rm.clear()\n        self.properties_2_add.clear()\n        self.properties_2_rm.clear()", "response": "Save or update the current Endpoint to Ariane server."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef remove(self):\n        LOGGER.debug(\"Endpoint.remove - \" + self.id + \" - \" + self.url)\n        if self.id is None:\n            return None\n        else:\n            if self.id in EndpointService.local_cache_by_id:\n                for search_params in EndpointService.local_cache_by_id[self.id]:\n                    if search_params in EndpointService.local_cache_by_params.keys():\n                        EndpointService.local_cache_by_params.pop(search_params)\n                EndpointService.local_cache_by_id.pop(self.id)\n\n            params = SessionService.complete_transactional_req({\n                'ID': self.id\n            })\n\n            if MappingService.driver_type != DriverFactory.DRIVER_REST:\n                params['OPERATION'] = 'deleteEndpoint'\n                args = {'properties': params}\n            else:\n                args = {'http_operation': 'GET', 'operation_path': 'delete', 'parameters': params}\n\n            response = EndpointService.requester.call(args)\n\n            if MappingService.driver_type != DriverFactory.DRIVER_REST:\n                response = response.get()\n\n            if response.rc != 0:\n                LOGGER.warning(\n                    'Endpoint.remove - Problem while deleting endpoint ' + str(self.id) +\n                    'Reason: ' + str(response.response_content) + ' - ' + str(response.error_message) +\n                    \" (\" + str(response.rc) + \")\"\n                )\n                if response.rc == 500 and ArianeMappingOverloadError.ERROR_MSG in response.error_message:\n                    raise ArianeMappingOverloadError(\"Endpoint.remove\",\n                                                     ArianeMappingOverloadError.ERROR_MSG)\n                # traceback.print_stack()\n                return self\n            else:\n                if self.parent_node is not None:\n                    self.parent_node.sync()\n                return None", "response": "Removes this endpoint from Ariane server."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef find_link(lid=None, sep_id=None, tep_id=None):\n        LOGGER.debug(\"LinkService.find_link\")\n        ret = None\n        if (lid is None or not lid) and (sep_id is None or not sep_id) and (tep_id is None or not tep_id):\n            raise exceptions.ArianeCallParametersError('id, source endpoint ID, target endpoint ID')\n\n        if (lid is not None and lid) and ((sep_id is not None and sep_id) or (tep_id is not None and tep_id)):\n            LOGGER.warning('LinkService.find_link - Both lid and sep_id and tep_id are defined. '\n                           'Will give you search on id.')\n            # traceback.print_stack()\n            sep_id = None\n            tep_id = None\n\n        if lid is not None and lid:\n            params = SessionService.complete_transactional_req({'ID': lid})\n            if MappingService.driver_type != DriverFactory.DRIVER_REST:\n                params['OPERATION'] = 'getLink'\n        elif sep_id is not None and sep_id and tep_id is not None and tep_id:\n            params = SessionService.complete_transactional_req({'SEPID': sep_id, 'TEPID': tep_id})\n            if MappingService.driver_type != DriverFactory.DRIVER_REST:\n                params['OPERATION'] = 'getLinkBySourceEPandDestinationEP'\n        elif sep_id is not None and sep_id and (tep_id is None or not tep_id):\n            params = SessionService.complete_transactional_req({'SEPID': sep_id})\n            if MappingService.driver_type != DriverFactory.DRIVER_REST:\n                params['OPERATION'] = 'getLinksBySourceEP'\n        else:\n            params = SessionService.complete_transactional_req({'TEPID': tep_id})\n            if MappingService.driver_type != DriverFactory.DRIVER_REST:\n                params['OPERATION'] = 'getLinksByDestinationEP'\n\n        if MappingService.driver_type != DriverFactory.DRIVER_REST:\n            args = {'properties': params}\n        else:\n            args = {'http_operation': 'GET', 'operation_path': 'get', 'parameters': params}\n\n        if MappingService.driver_type != DriverFactory.DRIVER_REST:\n            if lid is not None and lid:\n                response = LinkService.requester.call(args)\n            else:\n                response = MappingService.requester.call(args)\n        else:\n            response = LinkService.requester.call(args)\n\n        if MappingService.driver_type != DriverFactory.DRIVER_REST:\n            response = response.get()\n\n        if response.rc == 0:\n            if (lid is not None and lid) or (sep_id is not None and sep_id and tep_id is not None and tep_id):\n                ret = Link.json_2_link(response.response_content)\n            else:\n                ret = []\n                for link in response.response_content['links']:\n                    ret.append(Link.json_2_link(link))\n        elif response.rc != 404:\n            err_msg = 'LinkService.find_link - Problem while searching link (id:' + str(lid) + '). ' + \\\n                      'Reason: ' + str(response.response_content) + ' - ' + str(response.error_message) + \\\n                      \" (\" + str(response.rc) + \")\"\n            if response.rc == 500 and ArianeMappingOverloadError.ERROR_MSG in response.error_message:\n                raise ArianeMappingOverloadError(\"LinkService.find_link\",\n                                                 ArianeMappingOverloadError.ERROR_MSG)\n            LOGGER.warning(err_msg)\n            # traceback.print_stack()\n        return ret", "response": "find a link according to link ID."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets all known links from Ariane Server.", "response": "def get_links():\n        \"\"\"\n        get all known links from Ariane Server\n        :return:\n        \"\"\"\n        LOGGER.debug(\"LinkService.get_links\")\n        params = SessionService.complete_transactional_req(None)\n        if params is None:\n            if MappingService.driver_type != DriverFactory.DRIVER_REST:\n                params = {'OPERATION': 'getLinks'}\n                args = {'properties': params}\n            else:\n                args = {'http_operation': 'GET', 'operation_path': ''}\n        else:\n            if MappingService.driver_type != DriverFactory.DRIVER_REST:\n                params['OPERATION'] = 'getLinks'\n                args = {'properties': params}\n            else:\n                args = {'http_operation': 'GET', 'operation_path': '', 'parameters': params}\n\n        response = LinkService.requester.call(args)\n\n        if MappingService.driver_type != DriverFactory.DRIVER_REST:\n            response = response.get()\n\n        ret = None\n        if response.rc == 0:\n            ret = []\n            for link in response.response_content['links']:\n                ret.append(Link.json_2_link(link))\n        elif response.rc != 404:\n            err_msg = 'LinkService.get_links - Problem while getting links. ' \\\n                      'Reason: ' + str(response.response_content) + ' - ' + str(response.error_message) + \\\n                      \" (\" + str(response.rc) + \")\"\n            LOGGER.warning(err_msg)\n            if response.rc == 500 and ArianeMappingOverloadError.ERROR_MSG in response.error_message:\n                raise ArianeMappingOverloadError(\"LinkService.get_links\",\n                                                 ArianeMappingOverloadError.ERROR_MSG)\n            # traceback.print_stack()\n        return ret"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef find_transport(tid=None):\n        LOGGER.debug(\"TransportService.find_transport\")\n        ret = None\n        if tid is None or not tid:\n            raise exceptions.ArianeCallParametersError('id')\n\n        params = SessionService.complete_transactional_req({\n            'ID': tid\n        })\n\n        if MappingService.driver_type != DriverFactory.DRIVER_REST:\n            params['OPERATION'] = 'getTransport'\n            args = {'properties': params}\n        else:\n            args = {'http_operation': 'GET', 'operation_path': 'get', 'parameters': params}\n\n        response = TransportService.requester.call(args)\n\n        if MappingService.driver_type != DriverFactory.DRIVER_REST:\n            response = response.get()\n\n        if response.rc == 0:\n            ret = Transport.json_2_transport(response.response_content)\n        elif response.rc != 404:\n            err_msg = 'TransportService.find_transport - Problem while searching transport (id:' + str(tid) + '). ' + \\\n                      'Reason: ' + str(response.response_content) + ' - ' + str(response.error_message) + \\\n                      \" (\" + str(response.rc) + \")\"\n            LOGGER.warning(err_msg)\n            if response.rc == 500 and ArianeMappingOverloadError.ERROR_MSG in response.error_message:\n                raise ArianeMappingOverloadError(\"Transport.find_transport\",\n                                                 ArianeMappingOverloadError.ERROR_MSG)\n            # traceback.print_stack()\n        return ret", "response": "find the transport according to the id."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_transports():\n        LOGGER.debug(\"TransportService.get_transports\")\n        params = SessionService.complete_transactional_req(None)\n        if params is None:\n            if MappingService.driver_type != DriverFactory.DRIVER_REST:\n                params = {'OPERATION': 'getTransports'}\n                args = {'properties': params}\n            else:\n                args = {'http_operation': 'GET', 'operation_path': ''}\n        else:\n            if MappingService.driver_type != DriverFactory.DRIVER_REST:\n                params['OPERATION'] = 'getTransports'\n                args = {'properties': params}\n            else:\n                args = {'http_operation': 'GET', 'operation_path': '', 'parameters': params}\n\n        response = TransportService.requester.call(args)\n\n        if MappingService.driver_type != DriverFactory.DRIVER_REST:\n            response = response.get()\n\n        ret = None\n        if response.rc == 0:\n            ret = []\n            for transport in response.response_content['transports']:\n                ret.append(Transport.json_2_transport(transport))\n        elif response.rc != 404:\n            err_msg = 'TransportService.get_transports - Problem while getting transports. ' \\\n                      'Reason: ' + str(response.response_content) + ' - ' + str(response.error_message) + \\\n                      \" (\" + str(response.rc) + \")\"\n            LOGGER.warning(err_msg)\n            if response.rc == 500 and ArianeMappingOverloadError.ERROR_MSG in response.error_message:\n                raise ArianeMappingOverloadError(\"Transport.get_transports\",\n                                                 ArianeMappingOverloadError.ERROR_MSG)\n            # traceback.print_stack()\n        return ret", "response": "Get all known transports from Ariane Server."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef sync(self, json_obj=None):\n        LOGGER.debug(\"Transport.sync\")\n        if json_obj is None:\n            params = None\n            if self.id is not None:\n                params = SessionService.complete_transactional_req({'ID': self.id})\n\n            if params is not None:\n                if MappingService.driver_type != DriverFactory.DRIVER_REST:\n                    params['OPERATION'] = 'getTransport'\n                    args = {'properties': params}\n                else:\n                    args = {'http_operation': 'GET', 'operation_path': 'get', 'parameters': params}\n\n                response = TransportService.requester.call(args)\n\n                if MappingService.driver_type != DriverFactory.DRIVER_REST:\n                    response = response.get()\n\n                if response.rc == 0:\n                    json_obj = response.response_content\n                else:\n                    err_msg = 'Transport.sync - Problem while syncing transport (id: ' + str(self.id) + '). ' \\\n                              'Reason: ' + str(response.response_content) + ' - ' + str(response.error_message) + \\\n                              \" (\" + str(response.rc) + \")\"\n                    LOGGER.warning(err_msg)\n                    if response.rc == 500 and ArianeMappingOverloadError.ERROR_MSG in response.error_message:\n                        raise ArianeMappingOverloadError(\"Transport.sync\",\n                                                         ArianeMappingOverloadError.ERROR_MSG)\n                    # traceback.print_stack()\n        elif 'transportID' not in json_obj:\n            err_msg = 'Transport.sync - Problem while syncing transport (id: ' + str(self.id) + '). ' \\\n                      'Reason: inconsistent json_obj' + str(json_obj) + \" from : \\n\"\n            LOGGER.warning(err_msg)\n            # traceback.print_stack()\n\n        if json_obj is not None:\n            self.id = json_obj['transportID']\n            self.name = json_obj['transportName']\n            if MappingService.driver_type != DriverFactory.DRIVER_REST:\n                if 'transportProperties' in json_obj:\n                    self.properties = DriverTools.json2properties(json_obj['transportProperties'])\n                else:\n                    self.properties = None\n            else:\n                self.properties = json_obj['transportProperties'] if 'transportProperties' in json_obj else None", "response": "Synchronizes this transport with the Ariane server."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef del_property(self, t_property_name, sync=True):\n        LOGGER.debug(\"Transport.del_property\")\n        if not sync or self.id is None:\n            self.properties_2_rm.append(t_property_name)\n        else:\n            params = SessionService.complete_transactional_req({\n                'ID': self.id,\n                'propertyName': t_property_name\n            })\n\n            if MappingService.driver_type != DriverFactory.DRIVER_REST:\n                params['OPERATION'] = 'removeTransportProperty'\n                args = {'properties': params}\n            else:\n                args = {'http_operation': 'GET', 'operation_path': 'update/properties/delete', 'parameters': params}\n\n            response = TransportService.requester.call(args)\n\n            if MappingService.driver_type != DriverFactory.DRIVER_REST:\n                response = response.get()\n\n            if response.rc != 0:\n                LOGGER.warning(\n                    'Transport.del_property - Problem while updating transport ' + self.name + ' properties. ' +\n                    'Reason: ' + str(response.response_content) + ' - ' + str(response.error_message) +\n                    \" (\" + str(response.rc) + \")\"\n                )\n                if response.rc == 500 and ArianeMappingOverloadError.ERROR_MSG in response.error_message:\n                    raise ArianeMappingOverloadError(\"Transport.del_property\",\n                                                     ArianeMappingOverloadError.ERROR_MSG)\n                # traceback.print_stack()\n            else:\n                self.sync()", "response": "Delete a property from this transport."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate a new entity.", "response": "def create_entity(self):\n        \"\"\"Create a new entity.\n\n        The entity will have a higher UID than any previously associated\n        with this world.\n\n        :return: the new entity\n        :rtype: :class:`essence.Entity`\"\"\"\n        self._highest_id_seen += 1\n        entity = Entity(self._highest_id_seen, self)\n        self._entities.append(entity)\n        return entity"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef destroy_entitiy(self, entity):\n        for relation in self._database.values():\n            relation.pop(entity, None)\n        for l in self._entities_by_component.values():\n            l.discard(entity)\n        self._entities.remove(entity)", "response": "Remove the entity and all connected components from the world."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadd a component to an entity.", "response": "def add_component(self, entity, component):\n        \"\"\"Add component to entity.\n\n        Long-hand for :func:`essence.Entity.add`.\n\n        :param entity: entity to associate\n        :type entity: :class:`essence.Entity`\n        :param component: component to add to the entity\n        :type component: :class:`essence.Component`\"\"\"\n        component_type = type(component)\n        relation = self._get_relation(component_type)\n        if entity in relation:\n            # PYTHON2.6: Numbers required in format string.\n            msg = \"Component {0} can't be added to entity {1} since it already has a component of type {2}.\".format(component, entity, component_type)\n            raise DuplicateComponentError(msg)\n        relation[entity] = component\n        self._entities_with(component_type).add(entity)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the component of type component_type associated with entity.", "response": "def get_component(self, entity, component_type, missing=MISSING):\n        \"\"\"Get the component of type component_type associated with entity.\n\n        Long-hand for :func:`essence.Entity.get`.\n\n        :param entity: entity to query\n        :type entity: :class:`essence.Entity`\n        :param component_type: component to add to the entity\n        :type component_type: The :class:`type` of a :class:`Component` subclass\n        :param missing: value to return if\n        :type missing: :class:`essence.Component`\n        :raises:\"\"\"\n        relation = self._get_relation(component_type)\n        if entity not in relation:\n            if missing is MISSING:\n                raise NoSuchComponentError()\n            else:\n                return missing\n        return relation[entity]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef remove_component(self, entity, component_type):\n        relation = self._get_relation(component_type)\n        del relation[entity]\n        self._entities_with(component_type).remove(entity)", "response": "Removes the component of component_type from entity."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef update(self, *args, **kwargs):\n        for system in self.systems:\n            system.update(self, *args, **kwargs)", "response": "Calls update on each of the system s attributes."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a new instance of a new Domain object.", "response": "def domain(host, port, username, password, avail_timeout=240.):\n\t\n\t\"\"\"\n\tEndpoint domain.\n\t\n\t:param str host:\n\t   Endpoint host.\n\t:param int port:\n\t   Endpoint port.\n\t:param str username:\n\t   Endpoint username.\n\t:param str password:\n\t   Endpoint password.\n\t:param float avail_timeout:\n\t   Availability check timeout in seconds.\n\t:rtype:\n\t   Domain\n\t:return:\n\t   Domain for the given endpoint parameters.\n\t\"\"\"\n\t\n\treturn Domain(Endpoint(host, port, username, password), avail_timeout)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef props_value(props):\n\n\t\"\"\"\n\tProperties value.\n\t\n\t:param dict props:\n\t   Properties dictionary.\n\t:rtype:\n\t   str\n\t:return:\n\t   Properties as string.\n\t\"\"\"\n\t\n\tsep = \"\"\n\tresult_value = \"\"\n\tfor prop_key, prop_value in props.items():\n\t\tresult_value = \"{}{}{}={}\".format(\n\t\t\tresult_value,\n\t\t\tsep,\n\t\t\tprop_key,\n\t\t\tprop_value\n\t\t)\n\t\tsep = \":\"\n\treturn result_value", "response": "returns the value of the properties dictionary as string."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget operation. :param str res_path: Resource path. :param float timeout: Timeout in seconds. :rtype: tuple :return: Tuple with status code and response body.", "response": "def get(self, res_path, timeout=10.):\n\t\n\t\t\"\"\"\n\t\tGet operation.\n\t\t\n\t\t:param str res_path:\n\t\t   Resource path.\n\t\t:param float timeout:\n\t\t   Timeout in seconds.\n\t\t:rtype:\n\t\t   tuple\n\t\t:return:\n\t\t   Tuple with status code and response body.\n\t\t\"\"\"\n\t\t\n\t\tresp = requests.get(\n\t\t\tself.__res_uri(res_path),\n\t\t\theaders=self.__headers(),\n\t\t\tverify=False,\n\t\t\tauth=self.__auth(),\n\t\t\ttimeout=timeout\n\t\t)\n\t\treturn (\n\t\t\tresp.status_code,\n\t\t\tjson.loads(resp.text) if resp.status_code == 200 else {}\n\t\t)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef post(self, res_path, data=None, files=None, timeout=10.):\n\t\n\t\t\"\"\"\n\t\tPost operation.\n\t\t\n\t\t:param str res_path:\n\t\t   Resource path.\n\t\t:param list data:\n\t\t   Request parameters for data.\n\t\t:param list files:\n\t\t   Request parameters for files.\n\t\t:param float timeout:\n\t\t   Timeout in seconds.\n\t\t:rtype:\n\t\t   tuple\n\t\t:return:\n\t\t   Tuple with status code and response body.\n\t\t\"\"\"\n\t\t\n\t\tresp = requests.post(\n\t\t\tself.__res_uri(res_path),\n\t\t\tdata=data,\n\t\t\tfiles=files,\n\t\t\theaders=self.__headers(),\n\t\t\tverify=False,\n\t\t\tauth=self.__auth(),\n\t\t\ttimeout=timeout\n\t\t)\n\t\treturn (\n\t\t\tresp.status_code,\n\t\t\tjson.loads(resp.text)\n\t\t)", "response": "This method performs a POST request to the specified resource path."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning True if the current domain is available False otherwise.", "response": "def available(self, context):\n\t\n\t\t\"\"\"\n\t\tDomain availability.\n\t\t\n\t\t:param resort.engine.execution.Context context:\n\t\t   Current execution context.\n\t\t\"\"\"\n\t\t\n\t\ttry:\n\t\t\tif self.__available is None:\n\t\t\t\tstatus_code, msg = self.__endpoint.get(\"\")\n\t\t\t\tself.__available = status_code == 200\n\t\texcept:\n\t\t\tself.__available = False\n\t\t\t\n\t\treturn self.__available"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef insert(self, context):\n\t\n\t\t\"\"\"\n\t\tWait domain to be available.\n\t\t\n\t\t:param resort.engine.execution.Context context:\n\t\t   Current execution context.\n\t\t:raise Exception:\n\t\t   Domain could not been inserted.\n\t\t\"\"\"\n\t\t\n\t\tstatus_code, msg = self.__endpoint.get(\"\", self.__avail_timeout)\n\t\tif status_code != 200:\n\t\t\traise Exception(\"GlassFish domain could not been inserted\")\n\t\tself.__available = True", "response": "Insert a new domain into the queue."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef application(self, name, context_root, path):\n\t\n\t\t\"\"\"\n\t\tDomain application.\n\t\t\n\t\t:param str name:\n\t\t   Application name.\n\t\t:param str context_root:\n\t\t   Appliaction context root. May be ``None``.\n\t\t:param Contextual path:\n\t\t   File path.\n\t\t:rtype:\n\t\t   Application\n\t\t\"\"\"\n\t\t\n\t\treturn Application(self.__endpoint, name, context_root, path)", "response": "Creates a new application with the given name and context root and path."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef mail_session(self, name, host, username, mail_from, props):\n\t\n\t\t\"\"\"\n\t\tDomain mail session.\n\t\t\n\t\t:param str name:\n\t\t   Mail session name.\n\t\t:param str host:\n\t\t   Mail host.\n\t\t:param str username:\n\t\t   Mail username.\n\t\t:param str mail_from:\n\t\t   Mail \"from\" address.\n\t\t:param dict props:\n\t\t   Extra properties.\n\t\t:rtype:\n\t\t   MailSession\n\t\t\"\"\"\n\t\t\n\t\treturn MailSession(self.__endpoint, name, host, username, mail_from,\n\t\t\t\tprops)", "response": "Creates a new mail session."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef custom_resource(self, name, restype, factclass, props):\n\t\n\t\t\"\"\"\n\t\tDomain custom resource.\n\t\t\n\t\t:param str name:\n\t\t   Resource name.\n\t\t:param str restype:\n\t\t   Resource type.\n\t\t:param str factclass:\n\t\t   Resource factory class.\n\t\t:param dict props:\n\t\t   Resource properties.\n\t\t:rtype:\n\t\t   CustomResource\n\t\t\"\"\"\n\t\t\n\t\treturn CustomResource(self.__endpoint, name, restype, factclass, props)", "response": "This method creates a new custom resource."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef jdbc_connection_pool(self, name, res_type, ds_classname, props):\n\t\t\t\n\t\t\"\"\"\n\t\tDomain JDBC connection pool.\n\t\t\n\t\t:param str name:\n\t\t   Resource name.\n\t\t:param str res_type:\n\t\t   Resource type.\n\t\t:param str ds_classname:\n\t\t   Data source class name.\n\t\t:param dict props:\n\t\t   Connection pool properties.\n\t\t:rtype:\n\t\t   JDBCConnectionPool\n\t\t\"\"\"\n\t\t\n\t\treturn JDBCConnectionPool(self.__endpoint, name, res_type,\n\t\t\t\tds_classname, props)", "response": "This method creates a new JDBC Connection Pool."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate a new connector connection pool.", "response": "def connector_connection_pool(self, name, res_adapter_name, conn_def_name,\n\t\t\tprops):\n\t\t\t\n\t\t\"\"\"\n\t\tDomain connector connection pool.\n\t\t\n\t\t:param str name:\n\t\t   Resource name.\n\t\t:param str res_adapter_name:\n\t\t   Resource adapter name.\n\t\t:param str conn_def_name:\n\t\t   Resource connection definition name.\n\t\t:param dict props:\n\t\t   Connection pool properties.\n\t\t:rtype:\n\t\t   ConnectorConnectionPool\n\t\t\"\"\"\n\t\t\n\t\treturn ConnectorConnectionPool(self.__endpoint, name, res_adapter_name,\n\t\t\t\tconn_def_name, props)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef insert(self, context):\n\t\n\t\t\"\"\"\n\t\tDeploy application.\n\t\t\n\t\t:param resort.engine.execution.Context context:\n\t\t   Current execution context.\n\t\t\"\"\"\n\t\t\n\t\tmodule_file = open(context.resolve(self.__path), \"rb\")\n\t\tdata = {\n\t\t\t\"name\": self.__name\n\t\t}\n\t\tif self.__context_root is not None:\n\t\t\tdata[\"contextroot\"] = self.__context_root\n\t\tstatus_code, msg = self.__endpoint.post(\n\t\t\t\"/applications/application\",\n\t\t\tdata=data,\n\t\t\tfiles={\n\t\t\t\t\"id\": module_file\n\t\t\t},\n\t\t\ttimeout=60.\n\t\t)\n\t\tmodule_file.close()\n\t\tself.__available = True", "response": "Insert the application into the database."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ninserting a new resource into the pool.", "response": "def insert(self, context):\n\t\n\t\t\"\"\"\n\t\tCreate resource.\n\t\t\n\t\t:param resort.engine.execution.Context context:\n\t\t   Current execution context.\n\t\t\"\"\"\n\t\t\n\t\tstatus_code, msg = self.__endpoint.post(\n\t\t\t\"/resources/connector-resource\",\n\t\t\tdata={\n\t\t\t\t\"id\": self.__name,\n\t\t\t\t\"poolname\": self.__pool_name\n\t\t\t}\n\t\t)\n\t\tself.__available = True"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate a new mail session.", "response": "def insert(self, context):\n\t\n\t\t\"\"\"\n\t\tCreate mail session.\n\t\t\n\t\t:param resort.engine.execution.Context context:\n\t\t   Current execution context.\n\t\t\"\"\"\n\t\t\n\t\tstatus_code, msg = self.__endpoint.post(\n\t\t\t\"/resources/mail-resource\",\n\t\t\tdata={\n\t\t\t\t\"id\": self.__name,\n\t\t\t\t\"host\": self.__host,\n\t\t\t\t\"user\": self.__username,\n\t\t\t\t\"from\": self.__mail_from,\n\t\t\t\t\"property\": props_value(self.__props)\n\t\t\t}\n\t\t)\n\t\tself.__available = True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nchecking if the resource is available.", "response": "def available(self, context):\n\t\n\t\t\"\"\"\n\t\tResource availability.\n\t\t\n\t\t:param resort.engine.execution.Context context:\n\t\t   Current execution context.\n\t\t\"\"\"\n\t\t\n\t\ttry:\n\t\t\tif self.__available is None:\n\t\t\t\tencoded_name = urllib.parse.quote_plus(self.__name)\n\t\t\t\tstatus_code, msg = self.__endpoint.get(\n\t\t\t\t\t\"/resources/custom-resource/{}\".format(encoded_name)\n\t\t\t\t)\n\t\t\t\tself.__available = status_code == 200\n\t\texcept:\n\t\t\tself.__available = False\n\t\t\t\n\t\treturn self.__available"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef insert(self, context):\n\t\n\t\t\"\"\"\n\t\tCreate resource.\n\t\t\n\t\t:param resort.engine.execution.Context context:\n\t\t   Current execution context.\n\t\t\"\"\"\n\t\t\n\t\tstatus_code, msg = self.__endpoint.post(\n\t\t\t\"/resources/custom-resource\",\n\t\t\tdata={\n\t\t\t\t\"id\": self.__name,\n\t\t\t\t\"restype\": self.__restype,\n\t\t\t\t\"factoryclass\": self.__factclass,\n\t\t\t\t\"property\": props_value(self.__props)\n\t\t\t}\n\t\t)\n\t\tself.__available = True", "response": "Insert a new custom resource into the database."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndelete the custom resource.", "response": "def delete(self, context):\n\t\n\t\t\"\"\"\n\t\tRemove resource.\n\t\t\n\t\t:param resort.engine.execution.Context context:\n\t\t   Current execution context.\n\t\t\"\"\"\n\t\t\n\t\tencoded_name = urllib.parse.quote_plus(self.__name)\n\t\tstatus_code, msg = self.__endpoint.delete(\n\t\t\t\"/resources/custom-resource/{}\".format(encoded_name)\n\t\t)\n\t\tself.__available = False"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef insert(self, context):\n\t\n\t\t\"\"\"\n\t\tCreate connection pool.\n\t\t\n\t\t:param resort.engine.execution.Context context:\n\t\t   Current execution context.\n\t\t\"\"\"\n\t\t\n\t\tstatus_code, msg = self.__endpoint.post(\n\t\t\t\"/resources/jdbc-connection-pool\",\n\t\t\tdata={\n\t\t\t\t\"id\": self.__name,\n\t\t\t\t\"resType\": self.__res_type,\n\t\t\t\t\"datasourceClassname\": self.__ds_classname,\n\t\t\t\t\"property\": props_value(self.__props)\n\t\t\t}\n\t\t)\n\t\tself.__available = True", "response": "Insert a new connection pool."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ninserting a new connection pool.", "response": "def insert(self, context):\n\t\n\t\t\"\"\"\n\t\tCreate connection pool.\n\t\t\n\t\t:param resort.engine.execution.Context context:\n\t\t   Current execution context.\n\t\t\"\"\"\n\t\t\n\t\tstatus_code, msg = self.__endpoint.post(\n\t\t\t\"/resources/connector-connection-pool\",\n\t\t\tdata={\n\t\t\t\t\"id\": self.__name,\n\t\t\t\t\"resourceAdapterName\": self.__res_adapter_name,\n\t\t\t\t\"connectiondefinitionname\": self.__conn_def_name,\n\t\t\t\t\"property\": props_value(self.__props)\n\t\t\t}\n\t\t)\n\t\tself.__available = True"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef auto_discover():\n    urls = [\n        url(r'^admin/', admin.site.urls),\n    ]\n\n    # TODO: we can create python package to have a lot of controllers\n    # in separate files\n    def get_controllers(module_name):\n        \"\"\"Return list of controllers in a module.\"\"\"\n        module = import_module('app.controllers.{}'.format(module_name))\n        controllers = []\n        for obj_name in dir(module):\n            # we ignore import of Controller and hidden names\n            if obj_name.startswith('_') or obj_name == 'Controller':\n                continue\n            obj = getattr(module, obj_name)\n            # include only controllers\n            if issubclass(obj, Controller):\n                controllers.append(obj)\n        return controllers\n\n    def controller_to_path(controller):\n        \"\"\"\n        Convert controller's name to a valid path.\n\n        Make url in lower case by replace capital letters to small\n        and adding underscore between words.\n        \"\"\"\n        words = re.findall('[A-Z][a-z]*', controller.__name__)\n        if words[-1] == 'Controller':\n            del words[-1]\n        # transform words to a url address\n        url_path = '_'.join(words).lower()\n        # main controller is a root handler\n        # TODO: root address inside the file should always come last\n        if url_path == 'main':\n            url_path = ''\n        return url_path\n\n    # load all controllers (excluding main controllers)\n    for file_name in listdir('controllers', get_files=True, hide_ignored=True):\n        # remove .py extension from file name\n        app_name = file_name.split('.', 1)[0]\n        # we will include main controller at the end\n        if app_name == 'main':\n            continue\n        # add url for each controller\n        for controller in get_controllers(app_name):\n            url_path = controller_to_path(controller)\n            urls.append(url(\n                r'^{}/{}$'.format(app_name, url_path),\n                controller.as_view()\n            ))\n\n    # add urls for main controllers\n    for controller in get_controllers('main'):\n        url_path = controller_to_path(controller)\n        # map urls to a root path\n        urls.append(url(\n            r'^{}$'.format(url_path),\n            controller.as_view()\n        ))\n\n    return urls", "response": "Auto - discover all controllers and return a list of urls."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef envvar_constructor(loader, node):\n    value = loader.construct_python_unicode(node)\n    data = value.split(':=', 1)\n    if len(data) == 2:\n        var, default = data\n        return os.environ.get(var, default)\n    else:\n        return os.environ[value]", "response": "Tag constructor to use environment variables in YAML files."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef download_file(url, suffix=''):\n    r = urllib2.urlopen(url)\n    # Save attached file in temp file and return path to temp file\n    fd, f_path = tempfile.mkstemp(suffix=suffix)\n    os.write(fd, r.read())\n    os.close(fd)\n    return f_path, suffix", "response": "Download a file from a SCO - API and return the path to it and the suffix."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef references_to_dict(elements):\n    dictionary = {}\n    for kvp in elements:\n        dictionary[str(kvp['rel'])] = str(kvp['href'])\n    return dictionary", "response": "Convery a list of HATEOAS reference objects into a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef to_local_time(timestamp):\n    utc = dt.datetime.strptime(timestamp, '%Y-%m-%dT%H:%M:%S.%f')\n    # Get UTC and local time zone\n    from_zone = tz.gettz('UTC')\n    to_zone = tz.tzlocal()\n\n    # Tell the utc object that it is in UTC time zone\n    utc = utc.replace(tzinfo=from_zone)\n\n    # Convert time zone\n    return utc.astimezone(to_zone)", "response": "Convert a datatime object from UTC time to local time."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _load_secret(self, creds_file):\n        '''read the oauth secrets and account ID from a credentials configuration file'''\n        try:\n            with open(creds_file) as fp:\n                creds = json.load(fp)\n            return creds\n        except Exception as e:\n            sys.stderr.write(\"Error loading oauth secret from local file called '{0}'\\n\".format(creds_file))\n            sys.stderr.write(\"\\tThere should be a local OAuth credentials file \\n\")\n            sys.stderr.write(\"\\twhich has contents like this:\\n\")\n            sys.stderr.write(\"\"\"\n                {\n                \"account_id\": \"1234567890001\",\n                \"client_id\": \"30ff0909-0909-33d3-ae88-c9887777a7b7\",\n                \"client_secret\": \"mzKKjZZyeW5YgsdfBD37c5730g397agU35-Dsgeox6-73giehbt0996nQ\"\n                }\n\n              \"\"\")\n            sys.stderr.write(\"\\n\")\n            raise e", "response": "read the oauth secrets and account ID from a credentials configuration file"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_video_count(self, search_q=None):\n        '''Return the number of videos in the account'''\n        if search_q is not None:\n            params = {'q': search_q}\n        else:\n            params = None\n\n        url = \"/counts/videos\"\n        result = self._make_request(self.CMS_Server, 'GET', url, params=params)\n        return result['count']", "response": "Return the number of videos in the account"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_all_videos(self, search_q=None):\n        '''\n        Gets all the videos in an account by automatically paginating through getVideos().\n        WARNING: Use with caution if you have thousands of videos!\n        WARNING: If deletes are being done during this iteration, the list may be missing videos.\n        '''\n        page_size = 10\n        current_page = 0\n        total_count = self.get_video_count(search_q=search_q)\n        total_page = math.ceil(total_count / page_size)\n        # We sort by 'created_at' so any newly added videos will be on the last page.\n        # We don't currently handle deletes during the iteration which could cause videos to be missed.\n        sort = 'created_at'\n        result = []\n        while current_page < total_page:\n            page_result = self.get_videos(limit=page_size, offset=current_page * page_size,\n                                          search_q=search_q, sort=sort)\n            result += page_result\n            current_page += 1\n        return result", "response": "Get all the videos in an account by automatically paginating through getVideos."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nposts and optionally ingest media from the specified URL", "response": "def post_video(self, videoUrl, name=None, ingestMedia=True):\n        '''Post and optionally ingest media from the specified URL'''\n        if name is None:\n            name = os.path.basename(videoUrl)\n\n        url = '/videos'\n        data = {'name': name}\n        new_video = self._make_request(self.CMS_Server, 'POST', url, data=data)\n        if ingestMedia:\n            self.ingest_video(new_video['id'], videoUrl)\n        return new_video"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning something like {'id': 'e99451a5-1a09-4258-8e73-798c9b58f126'}", "response": "def ingest_video(self, bcVideoId, videoUrl):\n        '''Returns something like {'id': 'e99451a5-1a09-4258-8e73-798c9b58f126'}'''\n\n        ingestData = {\n            \"master\": {\"url\": videoUrl},\n            \"profile\": \"balanced-nextgen-player\"  # \"balanced-high-definition\"\n        }\n        url = '/videos/' + bcVideoId + '/ingest-requests'\n        result = self._make_request(self.Ingest_Server, 'POST', url, data=ingestData)\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef connect(self):\n        key = paramiko.RSAKey(data=base64.b64decode(\n            app.config['SSH_HOST_KEY']\n        ))\n        client = paramiko.SSHClient()\n        client.get_host_keys().add(\n            app.config['SSH_HOST'],\n            'ssh-rsa',\n            key\n        )\n        client.connect(\n            app.config['SSH_HOST'],\n            username=app.config['SSH_USER'],\n            password=app.config['SSH_PASSWORD'],\n        )\n        return client", "response": "Connects the client to the server and returns it."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreading the server rules from the client and returns it.", "response": "def server_rules(self):\n        \"\"\"\n        Reads the server rules from the client\n        and returns it.\n        \"\"\"\n        sftp = self.client.open_sftp()\n        try:\n            rule_path = self.rule_location\n            try:\n                stat_entry = sftp.stat(rule_path)\n                if stat.S_ISDIR(stat_entry.st_mode):\n                    sftp.rmdir(rule_path)\n                    return []\n            except IOError:\n                return []\n            with sftp.open(rule_path, 'r') as file_handle:\n                data = file_handle.read()\n            return self._parse(data)\n        finally:\n            sftp.close()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _parse(data: str) -> list:\n        if isinstance(data, bytes):\n            data = data.decode('utf-8')\n        lines = (\n            item for item in\n            (item.strip() for item in data.split('\\n'))\n            if len(item) and not item.startswith('#')\n        )\n        rules = []\n        for line in lines:\n            rules.append(\n                Rule.parse(line)\n            )\n        return rules", "response": "Parses the given data string and returns a list of rule objects."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef sync(self, rules: list):\n        self.client = self.connect()\n        try:\n            server_rules = set(self.server_rules)\n            rules = set(rules)\n            to_remove_rules = server_rules.difference(rules)\n            to_add_rules = rules.difference(server_rules)\n            for to_remove_rule in to_remove_rules:\n                stdin, stdout, stderr = self.client.exec_command(\n                    to_remove_rule.remove_command\n                )\n                stdout.read()\n                stderr.read()\n            for to_add_rule in to_add_rules:\n                stdin, stdout, stderr = self.client.exec_command(\n                    to_add_rule.add_command\n                )\n                stdout.read()\n                stderr.read()\n\n            if len(to_remove_rules) or len(to_add_rules):\n                self._write_to_server(rules)\n                stdin, stdout, stderr = self.client.exec_command(\n                    'ip route flush cache'\n                )\n                stdout.read()\n                stderr.read()\n        finally:\n            self.client.close()", "response": "Synchronizes the given ruleset with the server and adds the not yet - available rules to the server."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nwrite the given ruleset to the the server configuration file.", "response": "def _write_to_server(self, rules: list):\n        \"\"\"\n        Writes the given ruleset to the\n        server configuration file.\n        :type rules: collections.Iterable[Rule]\n        \"\"\"\n        self._create_directory_structure()\n        config_data = '\\n'.join(rule.config_string for rule in rules)\n        sftp = self.client.open_sftp()\n        try:\n            with sftp.open(self.rule_location, 'w') as file_handle:\n                file_handle.write(config_data)\n                file_handle.write('\\n')\n        finally:\n            sftp.close()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef jaccardIndex(s1, s2, stranded=False):\n\n  def count(s):\n    \"\"\" sum the size of regions in s. \"\"\"\n    tot = 0\n    for r in s:\n      tot += len(r)\n    return tot\n\n  if stranded:\n    raise GenomicIntervalError(\"Sorry, stranded mode for computing Jaccard \" +\n                               \"index hasn't been implemented yet.\")\n\n  s1 = collapseRegions(s1)\n  s2 = collapseRegions(s2)\n  intersection = regionsIntersection(s1, s2)\n  c_i = count(intersection)\n  return c_i / float(count(s1) + count(s2) - c_i)", "response": "Compute the Jaccard index for two genomic intervals s1 and s2."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nbuild a dictionary indexed by chrom name of interval trees for each genomic interval.", "response": "def intervalTreesFromList(inElements, verbose=False, openEnded=False):\n  \"\"\"\n  build a dictionary, indexed by chrom name, of interval trees for each chrom.\n\n  :param inElements: list of genomic intervals. Members of the list must have\n                     chrom, start and end fields; no other restrictions.\n  :param verbose: output progress messages to sys.stderr if True\n  \"\"\"\n  elements = {}\n  if verbose:\n    totalLines = len(inElements)\n    pind = ProgressIndicator(totalToDo=totalLines,\n                             messagePrefix=\"completed\",\n                             messageSuffix=\"of parsing\")\n\n  for element in inElements:\n    if element.chrom not in elements:\n      elements[element.chrom] = []\n    elements[element.chrom].append(element)\n    if verbose:\n      pind.done += 1\n      pind.showProgress()\n\n  # create an interval tree for each list\n  trees = {}\n  if verbose:\n    totalLines = len(elements)\n    pind = ProgressIndicator(totalToDo=totalLines,\n                             messagePrefix=\"completed\",\n                             messageSuffix=\"of making interval trees\")\n  for chrom in elements:\n    trees[chrom] = IntervalTree(elements[chrom], openEnded)\n    if verbose:\n      pind.done += 1\n      pind.showProgress()\n\n  return trees"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the union of a list of genomic intervals.", "response": "def collapseRegions(s, stranded=False, names=False, verbose=False):\n  \"\"\"\n  Get the union of a set of genomic intervals.\n\n  given a list of genomic intervals with chromosome, start and end field,\n  collapse into a set of non-overlapping intervals. Intervals must be sorted by\n  chromosome and then start coordinate.\n\n  :note: O(n) time, O(n) space\n  :return:  list of intervals that define the collapsed regions. Note that\n            these are all new objects, no existing object from s is returned\n            or altered. Returned regions will all have name \"X\" and score 0\n  :param s:        list of genomic regions to collapse\n  :param stranded: if True, regions on positive and negative strands are\n                   collapsed separately. Otherwise, strand is ignored and all\n                   output regions are on positive strand.\n  :raise GenomicIntervalError: if the input regions are not correctly sorted\n                               (chromosome then start)\n  \"\"\"\n  if stranded:\n    return (__collapse_stranded(s, set(\"+\"), names, verbose) +\n            __collapse_stranded(s, set(\"-\"), names, verbose))\n  else:\n    return __collapse_stranded(s, set([\"+\", \"-\"]), names, verbose)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef __collapse_stranded(s, proc_strands, names=False, verbose=False):\n  def get_first_matching_index(s, proc_strands):\n    for i in range(0, len(s)):\n      if s[i].strand in proc_strands:\n        return i\n    return None\n\n  if proc_strands not in [set(\"+\"), set(\"-\"), set([\"+\", \"-\"])]:\n    raise GenomicIntervalError(\"failed collapsing intervals on strands '\" +\n                               \",\".join(proc_strands) + \"''; unrecognised \" +\n                               \"strand symbols\")\n\n  first_index = get_first_matching_index(s, proc_strands)\n  if first_index is None:\n    return []\n\n  res = []\n  current = copy.copy(s[first_index])\n  current.strand = '+' if (proc_strands == set(\"+\") or\n                           proc_strands == set([\"+\", \"-\"])) else '-'\n  current.score = 0\n  current.name = \"X\" if not names else set(s[first_index].name)\n  for i in range(first_index + 1, len(s)):\n    if s[i].strand not in proc_strands:\n      continue\n\n    # make sure things are sorted..\n    if (s[i].chrom < s[i - 1].chrom) or \\\n       (s[i].chrom == s[i - 1].chrom and s[i].start < s[i - 1].start):\n      raise GenomicIntervalError(\"collapsing regions failed. saw this \" +\n                                 \"region: \" + str(s[i - 1]) + \" before this \" +\n                                 \"one: \" + str(s[i]))\n\n    # because of sorting order, we know that nothing else exists with\n    # start less than s[i] which we haven't already seen.\n    if s[i].start > current.end or s[i].chrom != current.chrom:\n      if names:\n        current.name = \";\".join(current.name)\n      res.append(current)\n      current = copy.copy(s[i])\n      current.strand = '+' if (proc_strands == set(\"+\") or\n                               proc_strands == set([\"+\", \"-\"])) else '-'\n      current.score = 0\n      current.name = \"X\" if not names else set(s[i].name)\n    else:\n      current.end = max(s[i].end, current.end)\n      if names:\n        current.name.add(s[i].name)\n\n  # don't forget the last one...\n  if names:\n    current.name = \";\".join(current.name)\n  res.append(current)\n\n  return res", "response": "This function is used to get the union of a set of genomic intervals."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ngive two lists of genomic regions with chromosome, start and end coordinates, return a new list of regions which is the intersection of those two sets. Lists must be sorted by chromosome and start index :return: new list that represents the intersection of the two input lists. output regions will all have name \"X\", be on strand \"+\" and have score 0 :param s1: first list of genomic regions :param s2: second list of genomic regions :raise GenomicIntervalError: if the input regions are not sorted correctly (by chromosome and start index) :note: O(n) time, O(n) space; informally, might use up to 3x space of input", "response": "def regionsIntersection(s1, s2, collapse=True):\n  \"\"\"\n  given two lists of genomic regions with chromosome, start and end\n  coordinates, return a new list of regions which is the intersection of those\n  two sets. Lists must be sorted by chromosome and start index\n\n  :return: new list that represents the intersection of the two input lists.\n           output regions will all have name \"X\", be on strand \"+\" and have\n           score 0\n  :param s1: first list of genomic regions\n  :param s2: second list of genomic regions\n  :raise GenomicIntervalError: if the input regions are not sorted correctly\n                               (by chromosome and start index)\n  :note: O(n) time, O(n) space; informally, might use up to 3x space of input\n  \"\"\"\n  debug = False\n\n  # we don't need to explicitly check for sorting because sorted order is\n  # a post-condition of the collapsing function\n  s1_c = collapseRegions(s1)\n  s2_c = collapseRegions(s2)\n\n  if len(s1_c) == 0 or len(s2_c) == 0:\n    return []\n\n  res = []\n  j = 0\n  for i in range(0, len(s1_c)):\n    if debug:\n      sys.stderr.write(\"processing from s1_c : \" + str(s1_c[i]) + \"\\n\")\n\n    # find first thing in s2_c with end in or after s1_c[i]\n    if debug:\n      sys.stderr.write(\"i = \" + str(i) + \" and j = \" + str(j) + \"\\n\")\n    while (j < len(s2_c) and\n           (s2_c[j].chrom < s1_c[i].chrom or\n           (s2_c[j].chrom == s1_c[i].chrom and s2_c[j].end <= s1_c[i].start))):\n      j += 1\n    # nothing intersects if we hit the end of s2, or the end of the chrom,\n    # or we're still on the same chrom but start after the end of s2_c[i]\n    if j >= len(s2_c) or s2_c[j].chrom > s1_c[i].chrom or \\\n       (s2_c[j].chrom == s1_c[i].chrom and s2_c[j].start >= s1_c[i].end):\n      continue\n\n    # now everything at or after j in s2_c that starts before\n    # the end of s1_c must overlap with it\n    while s2_c[j].start < s1_c[i].end:\n      s = max(s1_c[i].start, s2_c[j].start)\n      e = min(s1_c[i].end, s2_c[j].end)\n      overlap = GenomicInterval(s1_c[i].chrom, s, e, \"X\", 0, \"+\")\n      if debug:\n        sys.stderr.write(\"\\tadding to overlaps: \" + str(overlap) + \"\\n\")\n      res.append(overlap)\n      j += 1\n      if j >= len(s2_c) or s2_c[j].chrom != s1_c[i].chrom:\n        break\n\n    # it's possible the last intersecting element runs on to the\n    # next element from s1_c, so...\n    j -= 1\n    if debug:\n      sys.stderr.write(\"\\tmoving s2_c index back to \" + str(s2_c[j]) + \"\\n\")\n\n  return res"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning an iterator that yields the elements from the given genomic intervals.", "response": "def bucketIterator(elements, buckets):\n  \"\"\"\n  For each bucket in buckets, yield it and any elements that overlap it.\n\n  :param elements: the genomic intervals to place into the buckets. Must be\n                   sorted by chromosome and start index. This could be a\n                   list, or an iterator.\n  :param buckets: the buckets into which genomic intervals should be binned.\n                  Must be sorted by chromosome and start index. This could be\n                  a list, or an iterator\n  :return: iterator that will yeild a tuple of 1 bucket and 1 list of elements\n           in the bucket for each call to __next__().\n  \"\"\"\n  def check_sorted(current, previous):\n    if (previous is not None) and \\\n       ((previous.chrom > current.chrom) or\n        ((previous.chrom == current.chrom) and\n         (previous.start > current.start))):\n      raise GenomicIntervalError(\"elements not sorted. Saw \" +\n                                 str(previous) + \" before \" + str(current))\n\n  def updateOpen(openHeap, elementIterator, bucketChrom,\n                 bucketStart, bucketEnd):\n    \"\"\"\n    Drop elements from heap which start earlier than current bucket.\n\n    Update the open heap so that it contains only elements that end after the\n    start of the current bucket. Note that the heap may already contain some\n    elements that start after the end of the current bucket, if a previous\n    bucket ended after the end of this one and brought them into the set.\n\n    :param openHeap: a min heap of elements; uses the default sorting order\n                     for the genomic intervals, which is by end index. This\n                     is what we're updating.\n    :param elementIterator: an iterator from which we will pull new elements.\n                            Elements yielded by this iterator must be sorted\n                            by start index. Must be 'peakable'\n    :param bucketChrom: the chromosome of the current bucket.\n    :param bucketStart: the start index of the current bucket.\n    :param bucketEnd: the end index of the current bucket.\n    \"\"\"\n    # first, we're going to pop elements from the heap which can no longer\n    # overalp this or any future buckets. Buckets are sorted by start, so\n    # we'll never see another bucket that starts earlier than this one --\n    # hence any elements that end before the start of this bucket will never be\n    # used again and can be dropped. Elements in the heap are ordered by end\n    # index, so once we reach an element in the heap that does not end before\n    # the start of this bucket, we are sure that no others will come after it\n    # which do end before the start of this bucket. So we can stop dropping.\n    while len(openHeap) > 0 and ((openHeap[0].chrom < bucketChrom) or\n                                 ((openHeap[0].chrom == bucketChrom) and\n                                 (openHeap[0].end <= bucketStart))):\n      heappop(openHeap)\n\n    # now we're going to add new elements from the iterator to the heap. As\n    # we know that elements in the iterator are sorted by start index, we know\n    # that once we see an element that has a start index greater than the end\n    # of this bucket, we can stop -- everything else after it will also start\n    # after the end of this bucket.\n    while (elementIterator.peek() is not None) and \\\n          ((elementIterator.peek().chrom < bucketChrom) or\n           ((elementIterator.peek().chrom == bucketChrom) and\n            (elementIterator.peek().start < bucketEnd))):\n      e = elementIterator.__next__()\n      # if e falls before this bucket, we can skip it; buckets are sorted by\n      # start, so no other buckets start earlier than this one and so it\n      # cannot intersect any others.\n      if (e.chrom < bucketChrom) or \\\n         (e.chrom == bucketChrom and e.end <= bucketStart):\n         continue\n      # now we know e intersects this bucket..\n      heappush(openHeap, e)\n\n  openElems = []\n  prevBucket = None\n  elementIter = AutoApplyIterator(elements, check_sorted)\n  for bucket in buckets:\n    # make sure the buckets are sorted by start index\n    if prevBucket is not None and ((bucket.chrom < prevBucket.chrom) or\n                                   (bucket.chrom == prevBucket.chrom and\n                                    bucket.start < prevBucket.start)):\n      raise GenomicIntervalError(\"regions-of-interest are not sorted. Saw \" +\n                                 str(prevBucket) + \" before \" + str(bucket))\n    updateOpen(openElems, elementIter, bucket.chrom, bucket. start, bucket.end)\n\n    # be careful here not to leak a reference to the heap; if the caller\n    # decides to mess with that list, it'll screw us up. Anyway, we need a\n    # final check here to make sure we trim off any elements that exceed the\n    # end of this bucket.\n    yield bucket, [x for x in openElems if x.start < bucket.end]\n    prevBucket = bucket"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nparse a string in simple Wig format and return a GenomicInterval object.", "response": "def parseWigString(line, scoreType=int):\n  \"\"\"\n  Parse a string in simple Wig format and return a GenomicInterval.\n\n  :param line: the string to be parsed\n  :param scoreType: treat the score field as having this type.\n  :return: GenomicInterval object representing this wig line; the name of the\n           interval will be set to 'X', and it's strand to the default.\n  \"\"\"\n  parts = line.split(\"\\t\")\n  if (len(parts) < 4):\n    raise GenomicIntervalError(\"failed to parse \" + line +\n                               \" as wig format, too few fields\")\n  return GenomicInterval(parts[0].strip(), int(parts[1]), int(parts[2]), None,\n                         scoreType(parts[3]))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nparse a string in BED format and return a GenomicInterval object.", "response": "def parseBEDString(line, scoreType=int, dropAfter=None):\n  \"\"\"\n  Parse a string in BED format and return a GenomicInterval object.\n\n  :param line: the string to be parsed\n  :param dropAfter: an int indicating that any fields after and including\n                    this field should be ignored as they don't conform to\n                    the BED format. By default, None, meaning we use all\n                    fields. Index from zero.\n  :return: GenomicInterval object built from the BED string representation\n  \"\"\"\n  peices = line.split(\"\\t\")\n  if dropAfter is not None:\n    peices = peices[0:dropAfter]\n  if len(peices) < 3:\n    raise GenomicIntervalError(\"BED elements must have at least chrom, \" +\n                               \"start and end; found only \" +\n                               str(len(peices)) + \" in \" + line)\n  chrom = peices[0]\n  start = peices[1]\n  end = peices[2]\n\n  name = None\n  score = None\n  strand = None\n\n  if len(peices) >= 4 is not None:\n    name = peices[3]\n  if len(peices) >= 5 is not None:\n    score = peices[4]\n  if len(peices) >= 6 is not None:\n    strand = peices[5]\n\n  return GenomicInterval(chrom, start, end, name, score, strand, scoreType)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef sameRegion(self, e):\n    if e is None:\n      return False\n    return (self.chrom == e.chrom and self.start == e.start and\n            self.end == e.end and self.name == e.name and\n            self.strand == e.strand)", "response": "Check whether self represents the same DNA region as e."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef distance(self, e):\n    if e.chrom != self.chrom:\n      raise GenomicIntervalError(\"cannot get distance from \" + str(self) +\n                                 \" to \" + str(e) + \" as they're on \" +\n                                 \"different chromosomes\")\n    dist = 0\n    if not e.intersects(self):\n      dist = max(self.start, e.start) - min(self.end, e.end)\n    return dist", "response": "Returns the distance between this genomic interval and e."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the signed distance between this genomic interval and e.", "response": "def signedDistance(self, e):\n    \"\"\"\n    Signed distance between this interval and e -- number of nucleotides.\n\n    Get the signed distance from this genomic interval to another one. We\n    consider intervals that overlap to have a distance of 0 to each other. The\n    distance between two intervals on different chromosomes is considered\n    undefined, and causes an exception to be raised. If e comes earlier than\n    self, the distance will be negative.\n\n    :return: the signed distance from this GenomicInterval to e.\n    :param e: the other genomic interval to find the distance to.\n    :raise GenomicIntervalError: if self and e are on different chromosomes.\n    \"\"\"\n    dist = self.distance(e)\n    if e < self:\n      dist = dist * -1\n    return dist"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef __singleIntersect(self, e):\n    if e.chrom != self.chrom or e.end < self.start or e.start > self.end:\n      # no intersection\n      return [copy.copy(self)]\n    if e.start <= self.start and e.end >= self.end:\n      # whole self is removed.\n      return []\n    if e.start > self.start and e.end < self.end:\n      # splits self in two\n      r1 = copy.copy(self)\n      r2 = copy.copy(self)\n      r1.end = e.start\n      r2.start = e.end\n      return [r1, r2]\n    if e.start <= self.start:\n      # cuts off start of self\n      r = copy.copy(self)\n      r.start = e.end\n      return [r]\n    if e.end >= self.end:\n      # cuts off end of self\n      r = copy.copy(self)\n      r.end = e.start\n      return [r]\n    # oops, we screwed up if we got to here..\n    raise GenomicIntervalError(\"fatal error - failed BED subtraction of \" +\n                               str(e) + \" from \" + str(self))", "response": "This function subtracts e from self and returns a list of regions that represent the result of subtracting e from self."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsubtracts the BED elements in es from self.", "response": "def subtract(self, es):\n    \"\"\"\n    Subtract the BED elements in es from self.\n\n    :param es: a list of BED elements (or anything with chrom, start, end)\n    :return: a list of BED elements which represent what is left of\n             self after the subtraction. This might be an empty list.\n    \"\"\"\n    workingSet = [self]\n    for e in es:\n      newWorkingSet = []\n      for w in workingSet:\n        newWorkingSet += w.__singleIntersect(e)\n      workingSet = newWorkingSet\n    return workingSet"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the size of the overlap between self and e.", "response": "def sizeOfOverlap(self, e):\n    \"\"\"\n    Get the size of the overlap between self and e.\n\n    :return: the number of bases that are shared in common between self and e.\n    \"\"\"\n    # no overlap\n    if not self.intersects(e):\n      return 0\n\n    # complete inclusion..\n    if e.start >= self.start and e.end <= self.end:\n      return len(e)\n    if self.start >= e.start and self.end <= e.end:\n      return len(self)\n\n    # partial overlap\n    if e.start > self.start:\n      return (self.end - e.start)\n    if self.start > e.start:\n      return (e.end - self.start)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef intersects(self, e):\n    if self.chrom != e.chrom:\n      return False\n\n    if e.start >= self.start and e.start < self.end:\n      return True\n    if e.end > self.start and e.end <= self.end:\n      return True\n    if e.start < self.start and e.end > self.end:\n      return True\n    return False", "response": "Check whether this element intersects the element e\n   "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nchecking if this element is on the positive strand.", "response": "def isPositiveStrand(self):\n    \"\"\"\n    Check if this genomic region is on the positive strand.\n\n    :return: True if this element is on the positive strand\n    \"\"\"\n    if self.strand is None and self.DEFAULT_STRAND == self.POSITIVE_STRAND:\n      return True\n    return self.strand == self.POSITIVE_STRAND"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nchecks if this element is on the negative strand.", "response": "def isNegativeStrand(self):\n    \"\"\"\n    Check if this genomic interval is on the negative strand.\n\n    :return: True if this element is on the negative strand\n    \"\"\"\n    if self.strand is None and self.DEFAULT_STRAND == self.NEGATIVE_STRAND:\n      return True\n    return self.strand == self.NEGATIVE_STRAND"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef save_model(self, request, obj, form, change):\n        must_send_verification_mail_after_save = False\n        if change and settings.ACCOUNTS_APPROVAL_REQUIRED:\n            if obj.is_active and not User.objects.get(id=obj.id).is_active:\n                if settings.ACCOUNTS_VERIFICATION_REQUIRED:\n                    # Accounts verification requires an inactive account\n                    obj.is_active = False\n                    # The token generated by send_verification_mail()\n                    # must match the _saved_ User object,\n                    # so postpone send_verification_mail() until later\n                    must_send_verification_mail_after_save = True\n                else:\n                    send_approved_mail(request, obj)\n        super(UserProfileAdmin, self).save_model(request, obj, form, change)\n        if must_send_verification_mail_after_save:\n            user = User.objects.get(id=obj.id)\n            send_verification_mail(request, user, \"signup_verify\")", "response": "Override save_model to send an approved email to the user if the ACCOUNTS_APPROVAL_REQUIRED setting is True."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef refresh(func):\n    \n    @wraps(func)\n    def inner(self, *args, **kwargs):\n        # Refresh the model instance - see https://github.com/planop/django/blob/ticket_901/django/db/models/base.py#L1012\n        new_self = self.__class__._base_manager.using(self._state.db).get(pk=self.pk)\n        for f in self.__class__._meta.fields:\n            setattr(self, f.name, getattr(new_self, f.name))\n        return func(self, *args, **kwargs)\n    return inner", "response": "Decorator that ensures that the model instance is refreshed."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndeploy a new machine.", "response": "def deploy(self, machine):\n        \"\"\"Deploy service.\"\"\"\n\n        log.debug(\"machine id: %s.\" % machine)\n\n        path = self.path + \"/machines\"\n        value, metadata = yield self.client.get(path)\n        machines = json.loads(value)\n        machines.append(machine)\n\n        yield self.client.set(path, json.dumps(machines))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add(self):\n\n        yield self.client.create(self.path)\n        yield self.client.create(self.path + \"/type\", self.name)\n        yield self.client.create(self.path + \"/state\")\n        yield self.client.create(self.path + \"/machines\", \"[]\")\n\n        log.debug(\"registered service '%s' at %s.\" % (self.name, self.path))", "response": "Add service definition to hierarchy."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_news_content(self, url):\n        res = WyuNews.__wyu_news_content(url)\n        soup = BeautifulSoup(res, from_encoding='utf-8')\n        tag_table = soup.find(self.__get_tag_table)\n\n        tr = tag_table.findAll('tr')[4]\n\n        return tr.decode()", "response": "get_news_content - Get the content of a news page"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _insert_cache(self, key, val, read):\r\n        '''\r\n        Does an insert into the cache such that the cache\r\n        will have an updated entry for the key,value,read\r\n        tuple. Any changes to those values will both update\r\n        the local cache and queue any required writes to the\r\n        database.\r\n        '''\r\n        if key != None and self.stringify_keys:\r\n            key = str(key)\r\n        cval = self._cache.get(key)\r\n        if cval == None:\r\n            self._cur_size += 1\r\n        if cval == None or val != cval:\r\n            self._cache[key] = val\r\n            # Force a write if it's a write or if it's\r\n            # unclear that the item was modified\r\n            if not self.read_only and (not self._immutable_vals or not read):\r\n                self._wqueue.add(key)", "response": "Inserts a new entry into the local cache such that the local cache has an updated entry for the key value read\r\n           ."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nflush the write queue", "response": "def _sync_writes(self):\r\n        '''\r\n        Flushes the write queue\r\n        '''\r\n        for key in self._wqueue:\r\n            val = self._cache[key]\r\n            self._database[key] = val\r\n        del self._wqueue\r\n        self._wqueue = set()\r\n        self._database.sync()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef drop_cache(self):\r\n        '''\r\n        Drops all changes in the cache.\r\n        '''\r\n        del self._cache\r\n        self._cache  = {}\r\n        del self._wqueue\r\n        self._wqueue = set()\r\n        self._cur_size = 0", "response": "Drops all changes in the cache."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nupdate the set to include all arguments passed in.", "response": "def update(self, *args, **kwargs):\r\n        '''\r\n        Updates the set to include all arguments passed in. If the keyword\r\n        argument preprocess is passed, then each element is preprocessed\r\n        before being added.\r\n        '''\r\n        preprocess = kwargs.get('preprocess')\r\n        for s in args:\r\n            for e in s:\r\n                self._dict_set(preprocess(e) if preprocess else e, True)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting the value of the given key in the dictionary.", "response": "def _dict_set(self, key, val):\r\n        '''\r\n        These allow for direct access to the dictionary holding\r\n        the set under a different naming convention (to prevent\r\n        dictionary like syntax from working on external interface).\r\n        '''\r\n        if key != None and self.stringify_keys:\r\n            key = str(key)\r\n        db = self._keyed_db[self.split_func(key)]\r\n        db._dict_set(key, val)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef request_anime(client, aid: int) -> 'Anime':\n    response = api.httpapi_request(client, request='anime', aid=aid)\n    etree = api.unpack_xml(response.text)\n    return _unpack_anime(etree.getroot())", "response": "Make an anime API request."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the episode number.", "response": "def get_episode_number(episode: Episode) -> int:\n    \"\"\"Get the episode number.\n\n    The episode number is unique for an anime and episode type, but not\n    across episode types for the same anime.\n    \"\"\"\n    match = _NUMBER_SUFFIX.search(episode.epno)\n    return int(match.group(1))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the episode title.", "response": "def get_episode_title(episode: Episode) -> int:\n    \"\"\"Get the episode title.\n\n    Japanese title is prioritized.\n    \"\"\"\n    for title in episode.titles:\n        if title.lang == 'ja':\n            return title.title\n    else:\n        return episode.titles[0].title"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nfinding a matching subelement and return its text.", "response": "def _find_element_text(element, match, default=None):\n    \"\"\"Find a matching subelement and return its text.\n\n    If default is given, return it if a matching subelement is not\n    found.  Otherwise, ValueError is raised.\n    \"\"\"\n    child = element.find(match)\n    try:\n        return child.text\n    except AttributeError:\n        if default is not None:\n            return default\n        else:\n            raise MissingElementError(element, match)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _unpack_episode(element: ET.Element):\n    return Episode(\n        epno=element.find('epno').text,\n        type=int(element.find('epno').get('type')),\n        length=int(element.find('length').text),\n        titles=tuple(_unpack_episode_title(title)\n                     for title in element.iterfind('title')),\n    )", "response": "Unpack Episode from episode XML element."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nunpacks EpisodeTitle from title XML element.", "response": "def _unpack_episode_title(element: ET.Element):\n    \"\"\"Unpack EpisodeTitle from title XML element.\"\"\"\n    return EpisodeTitle(title=element.text,\n                        lang=element.get(f'{XML}lang'))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef format_error(invalid, doc_type):\n    # using string for checking is probably not ideal,\n    # but voluptuous does not have specific sub error\n    # types for these errors\n    if invalid.error_message == 'extra keys not allowed':\n        msg = \"Key '{}' is not allowed\".format(invalid.path[0])\n    elif invalid.error_message == 'required key not provided':\n        msg = \"{} '{}' is missing\".format(doc_type, invalid.path[0])\n    else:\n        msg = invalid.message\n    return {'message': msg, 'field': str(invalid.path[0])}", "response": "format the error message using the voluptuous. Invalid object"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nvalidating the resource using its voluptuous schema", "response": "def validate(self):\n        \"\"\"Validate the resource using its voluptuous schema\"\"\"\n        try:\n            # update _resource to have default values from the schema\n            self._resource = self.schema(self._resource)\n        except MultipleInvalid as e:\n            errors = [format_error(err, self.resource_type) for err in e.errors]\n            raise exceptions.ValidationError({'errors': errors})\n\n        yield self.check_unique()"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get(cls, resource_id, include_deactivated=False):\n        resource = yield cls.db_client().get_doc(resource_id)\n\n        if resource.get('type') != cls.resource_type:\n            raise exceptions.NotFound()\n\n        if not include_deactivated and resource.get('state') == State.deactivated.name:\n            raise exceptions.NotFound()\n\n        raise Return(cls(**resource))", "response": "Get a resource s ID\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef all(cls, include_deactivated=False):\n        if include_deactivated:\n            resources = yield cls.view.get(include_docs=True)\n        else:\n            resources = yield cls.active_view.get(include_docs=True)\n        raise Return([cls(**resource['doc']) for resource in resources['rows']])", "response": "Get all resources in CouchDB."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nvalidates whether user can transition resource from start state to end state.", "response": "def validate_state_transition(self, user, start_state, end_state, **kwargs):\n        \"\"\"\n        Validate whether user can transition resource from start state to end state\n        :param user\n        :param start_state\n        :param end_state\n        :return: bool\n        \"\"\"\n        if start_state == end_state:\n            raise Return(True)\n\n        transitions = self.state_transitions.get(start_state, [])\n\n        approved_transitions = []\n        can_approve = yield self.can_approve(user, **kwargs)\n        if can_approve:\n            approved_transitions = self.approval_state_transitions.get(start_state, [])\n\n        if end_state not in transitions and end_state not in approved_transitions:\n            raise Return(False)\n\n        raise Return(True)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nsave the resource with the user s identity.", "response": "def _save(self):\n        \"\"\"\n        Save the resource\n\n        It's better to use the create, updated & delete methods intsead of\n        modifying an instance and calling save, because then we call the\n        can_create, can_update & can_delete methods to check whether a user\n        is permitted to make the changes.\n        \"\"\"\n        yield self.validate()\n\n        db = self.db_client()\n        saved = yield db.save_doc(self._resource)\n\n        # Allow couch to create Document IDs\n        if '_id' not in self._resource:\n            self._resource['_id'] = saved['id']"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsaving the subresource s ID and parent_key attributes.", "response": "def save_subresource(self, subresource):\n        \"\"\"\n        Save the sub-resource\n\n        NOTE: Currently assumes subresources are stored within a dictionary,\n        keyed with the subresource's ID\n        \"\"\"\n        data = deepcopy(subresource._resource)\n        data.pop('id', None)\n        data.pop(self.resource_type + '_id', None)\n\n        subresources = getattr(self, subresource.parent_key, {})\n        subresources[subresource.id] = data\n        setattr(self, subresource.parent_key, subresources)\n\n        yield self._save()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef delete_subresource(self, subresource):\n        subresources = getattr(self, subresource.parent_key, {})\n        del subresources[subresource.id]\n        yield self._save()", "response": "Delete the subresource from the cache."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef clean(self):\n        doc = self._resource\n        result = {k: v for k, v in doc.iteritems() if k not in\n                  self.internal_fields}\n\n        if '_id' in doc and 'id' not in result:\n            result['id'] = doc['_id']\n\n        return result", "response": "Remove internal fields from resource"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef state(self):\n        state = self._resource.get('state', self.default_state)\n\n        if state in State:\n            return state\n        else:\n            return getattr(State, state)", "response": "Get the Document s state"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting the parent resource from the database.", "response": "def get_parent(self):\n        \"\"\"\n        Get the parent resource from the database\n\n        The get, create & update methods will populate the parent for you. Use\n        this method in the cases where parent has not been populated.\n        \"\"\"\n        if not self._parent:\n            self._parent = yield self.parent_resource.get(self.parent_id)\n\n        raise Return(self._parent)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef parent_resources(cls):\n        parent = cls.parent_resource\n        parents = [parent]\n\n        try:\n            while True:\n                parent = parent.parent_resource\n                parents.append(parent)\n        except AttributeError:\n            pass\n\n        parents.reverse()\n        return parents", "response": "Get a list of parent resources starting from the Document"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create(cls, user, **kwargs):\n        parent_id = kwargs.get(cls.parent_resource.resource_type + '_id')\n        try:\n            parent = yield cls.parent_resource.get(parent_id)\n        except couch.NotFound:\n            msg = 'Parent {} with id {} not found'.format(\n                cls.parent_resource.resource_type,\n                parent_id)\n            raise exceptions.ValidationError(msg)\n\n        if not parent.editable:\n            err = 'Cannot create child of {} resource'.format(parent.state.name)\n            raise exceptions.Unauthorized(err)\n\n        resource = yield super(SubResource, cls).create(user, **kwargs)\n        resource._parent = parent\n\n        raise Return(resource)", "response": "Create a new child resource."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nupdates the parent resource.", "response": "def update(self, user, **kwargs):\n        \"\"\"If parent resource is not an editable state, should not be able to update\"\"\"\n        yield self.get_parent()\n\n        if not self.parent.editable:\n            err = 'Cannot update child of {} resource'.format(self.parent.state.name)\n            raise exceptions.Unauthorized(err)\n\n        yield super(SubResource, self).update(user, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nsaves the sub - resource within the parent resource.", "response": "def _save(self):\n        \"\"\"Save the sub-resource within the parent resource\"\"\"\n        yield self.validate()\n\n        try:\n            self._parent = yield self.parent_resource.get(self.parent_id)\n        except couch.NotFound:\n            msg = '{}_id {} not found'.format(\n                self.parent_resource.resource_type,\n                self.parent_id)\n            raise exceptions.ValidationError(msg)\n\n        yield self._parent.save_subresource(self)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get(cls, resource_id, include_deactivated=False):\n        if include_deactivated:\n            resource = yield cls.view.first(key=resource_id, include_docs=True)\n        else:\n            resource = yield cls.active_view.first(key=resource_id, include_docs=True)\n        parent = cls.parent_resource(**resource['doc'])\n\n        raise Return(cls(parent=parent, **resource['value']))", "response": "Get a resource by its ID."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef all(cls, include_deactivated=False):\n        if include_deactivated:\n            resources = yield cls.view.get(include_docs=True)\n        else:\n            resources = yield cls.active_view.get(include_docs=True)\n\n        result = []\n\n        for resource in resources['rows']:\n            parent = cls.parent_resource(**resource['doc'])\n            result.append(cls(parent=parent, **resource['value']))\n\n        raise Return(result)", "response": "Get all sub - resources."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndeleting a sub - resource.", "response": "def delete(self, user):\n        \"\"\"Delete a sub-resource\"\"\"\n        if user:\n            can_delete = yield self.can_delete(user)\n        else:\n            can_delete = False\n\n        if not can_delete:\n            raise exceptions.Unauthorized('User may not delete the resource')\n\n        try:\n            parent = yield self.get_parent()\n        except couch.NotFound:\n            msg = '{}_id {} not found'.format(\n                self.parent_resource.resource_type,\n                self.parent_id)\n            raise exceptions.ValidationError(msg)\n\n        yield parent.delete_subresource(self)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef state(self):\n        state = self._resource.get('state', self.default_state)\n        if state not in State:\n            state = getattr(State, state)\n\n        if not self.parent:\n            raise Exception('Unable to check the parent state')\n\n        parent_state = self.parent.state\n\n        return max([state, parent_state], key=attrgetter('value'))", "response": "Get the state of the current state of the current resource."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn if a signature is indeed a list and all objects are intact", "response": "def list_sig_ok(self, signature: str):\n        \"\"\"\n        return if a signature is indeed a list and all objects are intact\n        :param signature:\n        :return:\n        \"\"\"\n        list_filename = self.get_list_filename(signature)\n        if list_filename not in self.name_cache:\n            return False\n        for _object_name, sig in Cache.iterate_objects(list_filename):\n            if not self.get_object_filename(sig):\n                return False\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget all the tasks for a release.", "response": "def schedule_tasks(self):\n        \"\"\"\n        Get all the tasks for a release.\n\n        :param release_id: int, release id number.\n        :returns: deferred that when fired returns a list of Munch (dict-like)\n                  objects representing all tasks.\n        \"\"\"\n        url = 'api/v6/releases/%d/schedule-tasks' % self.id\n        tasks = yield self.connection._get(url)\n        defer.returnValue(munchify(tasks))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget a datetime. date object for the last task that matches a regex.", "response": "def task_date(self, task_re):\n        \"\"\" Get a datetime.date object for the last task that matches a regex.\n\n        :param task_re: regex, eg re.compile('Development Freeze').\n                        See txproductpages.milestones for some useful regex\n                        constants to pass in here.\n        :returns: deferred that when fired returns a datetime.date object\n        :raises: TaskNotFoundException if no tasks matched.\n        \"\"\"\n        tasks = yield self.schedule_tasks()\n        task_date = None\n        for task in tasks:\n            if task_re.match(task['name']):\n                (y, m, d) = task['date_finish'].split('-')\n                task_date = date(int(y), int(m), int(d))\n        if task_date:\n            defer.returnValue(task_date)\n        raise TaskNotFoundException()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef Show(self, value = True):\r\n  self.Bind(wx.EVT_BUTTON, lambda event: self.Close(True), wx.Button(self.pane, label = '&Cancel')) # Add a cancel button\r\n  ok = wx.Button(self.pane, label = '&OK') # Add the ok button\r\n  ok.SetDefault() # When the user presses enter, this is the button which gets activated\r\n  self.Bind(wx.EVT_BUTTON, self.onOk, ok) # Bind it\r\n  self.Bind(wx.EVT_BUTTON, self.apply, wx.Button(self.pane, label = '&Apply')) # Apply the configuration changes to the ConfigParser object, but don't close the window\r\n  help = wx.Button(self.pane, label = '&Help')\r\n  if not callable(self.config.helpFunc):\r\n   help.Disable()\r\n  help.Bind(wx.EVT_BUTTON, self.config.helpFunc) # Add a help button\r\n  return super(ConfFrame, self).Show(value)", "response": "Before we show the frame, we need to add the finishing touches:"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef apply(self, event = None):\r\n  for section in self.config.sections():\r\n   # Run through the sections to check all the option values:\r\n   for option, o in self.config.config[section].items():\r\n    # Check the actual values against the validators and complain if necessary:\r\n    if not o['include']:\r\n     continue # This value is hidden, so there's no control for it.\r\n    control = self._controls[section][option] # Get the actual control for GetValue\r\n    try:\r\n     value = type(o['value'])(control.GetValue()) # Try and convert the value\r\n    except ValueError as msg:\r\n     self.displayError(section, option, str(msg)) # Woops, something went wrong\r\n     return False # Tells self.onOk not to close the window\r\n    problem = None # Set up the problem variable.\r\n    try:\r\n     problem = o['validate'](value) # See if it passes the test\r\n    except Exception as e:\r\n     problem = str(e) # The lambda raised an exception.\r\n    if problem:\r\n     self.displayError(section, option, problem) # It didn't\r\n     return False # Tells self.onOk not to close the window\r\n    self.config.set(section, option, value) # All clear\r\n  return True", "response": "Apply the settings to the config and return True if the settings have changed"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef displayError(self, section, option, message):\r\n  self.notebook.SetSelection(self.config.sections().index(section)) # Jump pages, using the position of section to find the relevant page number\r\n  self._controls[section][option].SetFocus() # Set focus on the offending control\r\n  wx.MessageBox(message, 'Error')", "response": "Displays an error message in the notebook"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef dict_merge(a, b):\n    if not isinstance(b, dict):\n        return b\n    result = deepcopy(a)\n    for k, v in b.iteritems():\n        if k in result and isinstance(result[k], dict):\n                result[k] = dict_merge(result[k], v)\n        else:\n            result[k] = deepcopy(v)\n    return result", "response": "Recursively merges dict s."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _detect_notebook():\n    try:\n        from IPython import get_ipython\n        from ipykernel import zmqshell\n    except ImportError:\n        return False\n    kernel = get_ipython()\n    return isinstance(kernel, zmqshell.ZMQInteractiveShell)", "response": "Detects if this is a notebook"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef json_conversion(obj):\n    try:\n        # numpy isn't an explicit dependency of bowtie\n        # so we can't assume it's available\n        import numpy as np\n        if isinstance(obj, (np.ndarray, np.generic)):\n            return obj.tolist()\n    except ImportError:\n        pass\n\n    try:\n        # pandas isn't an explicit dependency of bowtie\n        # so we can't assume it's available\n        import pandas as pd\n        if isinstance(obj, pd.Index):\n            return obj.tolist()\n    except ImportError:\n        pass\n\n    if isinstance(obj, (datetime, time, date)):\n        return obj.isoformat()\n    raise TypeError('Not sure how to serialize {} of type {}'.format(obj, type(obj)))", "response": "Encode additional objects to JSON."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _simple_chart(x=None, y=None, name=None, color=None, width=None, dash=None, opacity=None,\n                  mode='lines+markers', yaxis=1, fill=None, text='', style='line',\n                  markersize=6):\n    \"\"\"Draws connected dots.\n\n    Parameters\n    ----------\n    x : array-like, optional\n    y : array-like, optional\n    label : array-like, optional\n\n    Returns\n    -------\n    Chart\n\n    \"\"\"\n    assert x is not None or y is not None, \"x or y must be something\"\n    if y is None:\n        y = x\n        x = None\n    if x is None:\n        x = np.arange(len(y))\n    else:\n        x = _try_pydatetime(x)\n    x = np.atleast_1d(x)\n    y = np.atleast_1d(y)\n    assert x.shape[0] == y.shape[0]\n    xtype = check_type(x[0])\n    ytype = check_type(y[0])\n\n    return Chart(dict(\n        xAxis=[\n            dict(\n                type=xtype,\n            )\n        ],\n        yAxis=[\n            dict(\n                type=ytype,\n            )\n        ],\n        series=[dict(\n            type=style,\n            name=name,\n            data=np.stack((x, y)).T\n        )]\n    ))", "response": "Draws a simple chart of the n - grams."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset xaxis limits Parameters ---------- low : number high : number Returns ------- Chart", "response": "def xlim(self, low, high):\n        \"\"\"Set xaxis limits\n\n        Parameters\n        ----------\n        low : number\n        high : number\n\n        Returns\n        -------\n        Chart\n\n        \"\"\"\n        self.chart['xAxis'][0]['min'] = low\n        self.chart['xAxis'][0]['max'] = high\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef ylim(self, low, high):\n        self.chart['yAxis'][0]['min'] = low\n        self.chart['yAxis'][0]['max'] = high\n        return self", "response": "Set yaxis limits\n\n        Parameters\n        ----------\n        low : number\n        high : number\n        index : int, optional\n\n        Returns\n        -------\n        Chart"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_val(source, extract=None, transform=None):\n  if extract is None:\n    raw_value = source\n  else:\n    raw_value = extract(source)\n\n  if transform is None:\n    return raw_value\n  else:\n    return transform(raw_value)", "response": "Extract a value from a source transform and return it."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nmapping an object based on a key - > extractor child_transform dict.", "response": "def get_obj(source, extract=None, child_transform=None, transform=None):\n  \"\"\"Maps an object based on a key->extractor child_transform dict.\"\"\"\n  if extract is None:\n    obj = source\n  else:\n    obj = extract(source)\n\n  if child_transform is None:\n    data = obj\n  else:\n    data = dict()\n    for k, v in child_transform.items():\n      try:\n        data[k] = v(obj)\n      except Exception as ex:\n        raise Exception(\"An error occurred with child {0}\".format(k)) from ex\n\n  if transform is None:\n    return data\n  else:\n    return transform(data)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nextract a list from a source transform each item and return the result.", "response": "def get_lst(source, extract=None, transform=None):\n  \"\"\"Extract a list from a source, transform each item, and return the result.\"\"\"\n  if extract is None:\n    raw_list = source\n  else:\n    raw_list = extract(source)\n\n  if transform is None:\n    return raw_list\n  else:\n    tlist = []\n    for idx, item in enumerate(raw_list):\n      try:\n        tlist.append(transform(item))\n      except Exception as ex:\n        raise Exception(\"An error occurred with item #{0}\".format(idx)) from ex\n    return tlist"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_composition(source, *fxns):\n  val = source\n  for fxn in fxns:\n    val = fxn(val)\n  return val", "response": "Compose several extractors together on a source."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nflattening a child dicts whose resulting keys are joined by path_joiner.", "response": "def get_flattened(dct, names, path_joiner=\"_\"):\n  \"\"\"Flatten a child dicts, whose resulting keys are joined by path_joiner.\n\n  E.G. { \"valuation\": { \"currency\": \"USD\", \"amount\": \"100\" } } ->\n       { \"valuation_currency\": \"USD\", \"valuation_amount\": \"100\" }\n  \"\"\"\n  new_dct = dict()\n  for key, val in dct.items():\n    if key in names:\n      child = {path_joiner.join(k): v for k, v in flatten_dict(val, (key, ))}\n      new_dct.update(child)\n    else:\n      new_dct[key] = dct[key]\n  return new_dct"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\npull all of a child s keys up to the parent with the names unchanged.", "response": "def get_hoisted(dct, child_name):\n  \"\"\"Pulls all of a child's keys up to the parent, with the names unchanged.\"\"\"\n  child = dct[child_name]\n  del dct[child_name]\n  dct.update(child)\n  return dct"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef obj(extract=None, child_transform=None, transform=None):\n  return lambda source: get_obj(source, extract, child_transform, transform)", "response": "Returns a partial of get_obj that only needs a source argument."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_xml_attr(source, name, path=None):\n  if path is None:\n    return source.attrib[name]\n  else:\n    return get_xml_attr(get_xml_child(source, path), name)", "response": "Get the XML attribute with name from source."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_xml_text(source, path=None):\n  if path is None:\n    return source.text\n  else:\n    return get_xml_text(get_xml_child(source, path))", "response": "Get the text of the XML node."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_xml_child(source, path):\n  if isinstance(path, (tuple, list)):\n    return source.find(*path)\n  else:\n    return source.find(path)", "response": "Get the first descendant of source identified by path."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_xml_children(source, path):\n  if isinstance(path, (tuple, list)):\n    return source.findall(*path)\n  else:\n    return source.findall(path)", "response": "Get all the descendants of source identified by path."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the nested value identified by the json path rooted at source.", "response": "def get_json_val(source, path, *, ignore_bad_path=False):\n  \"\"\"Get the nested value identified by the json path, rooted at source.\"\"\"\n  try:\n    return JP.find(source, path)\n  except JP.JSONPathError as ex:\n    if ignore_bad_path:\n      return None\n    else:\n      raise"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef json_val(path, *, ignore_bad_path=False):\n  return lambda source: get_json_val(source, path, ignore_bad_path=ignore_bad_path)", "response": "Returns a partial of get_json_val that only needs a source argument."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef install():\n    reactor = ThreadedSelectReactor()\n    from twisted.internet.main import installReactor\n    installReactor(reactor)\n    return reactor", "response": "Configure the twisted mainloop to be run using the select reactor."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nruns one iteration of the I/O monitor loop. This will run all selectables who had input or output readiness waiting for them.", "response": "def _doSelectInThread(self, timeout):\n        \"\"\"Run one iteration of the I/O monitor loop.\n\n        This will run all selectables who had input or output readiness\n        waiting for them.\n        \"\"\"\n        reads = self.reads\n        writes = self.writes\n        while 1:\n            try:\n                r, w, ignored = _select(reads.keys(),\n                                        writes.keys(),\n                                        [], timeout)\n                break\n            except ValueError, ve:\n                # Possibly a file descriptor has gone negative?\n                log.err()\n                self._preenDescriptorsInThread()\n            except TypeError, te:\n                # Something *totally* invalid (object w/o fileno, non-integral\n                # result) was passed\n                log.err()\n                self._preenDescriptorsInThread()\n            except (select.error, IOError), se:\n                # select(2) encountered an error\n                if se.args[0] in (0, 2):\n                    # windows does this if it got an empty list\n                    if (not reads) and (not writes):\n                        return\n                    else:\n                        raise\n                elif se.args[0] == EINTR:\n                    return\n                elif se.args[0] == EBADF:\n                    self._preenDescriptorsInThread()\n                else:\n                    # OK, I really don't know what's going on.  Blow up.\n                    raise\n        self._sendToMain('Notify', r, w)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef interleave(self, waker, *args, **kw):\n        self.startRunning(*args, **kw)\n        loop = self._interleave()\n        def mainWaker(waker=waker, loop=loop):\n            #print >>sys.stderr, \"mainWaker()\"\n            waker(loop.next)\n        self.mainWaker = mainWaker\n        loop.next()\n        self.ensureWorkerThread()", "response": "Interleaves the reactor with the current application by moving the blocking parts of the reactor with the next blocking part of the reactor with the next blocking part of the reactor."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding a FileDescriptor for notification of data available to read.", "response": "def addReader(self, reader):\n        \"\"\"Add a FileDescriptor for notification of data available to read.\n        \"\"\"\n        self._sendToThread(self.reads.__setitem__, reader, 1)\n        self.wakeUp()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd a FileDescriptor for notification of data available to write.", "response": "def addWriter(self, writer):\n        \"\"\"Add a FileDescriptor for notification of data available to write.\n        \"\"\"\n        self._sendToThread(self.writes.__setitem__, writer, 1)\n        self.wakeUp()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef register_defs(self, def_list, **kwargs):\n        for item in def_list:\n            if isinstance(item, tuple):\n                self.register_rml_def(*item, **kwargs)\n            elif isinstance(item, dict):\n                cp_kwargs = kwargs.copy()\n                item.update(kwargs)\n                self.register_rml_def(**item)", "response": "Registers a list of rml definitions objects"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef register_rml_def(self,\n                         location_type,\n                         location,\n                         filename=None,\n                         **kwargs):\n        \"\"\"\n        Registers the rml file locations for easy access\n\n        Args:\n        -----\n            location_type: ['package_all',\n                            'package_file',\n                            'directory',\n                            'filepath']\n            location: The correlated location string based on the location_type\n            filename: Optional, associated with 'package_file' location_type\n\n        kwargs:\n        -------\n            include_subfolders: Boolean\n        \"\"\"\n        if location_type == 'directory':\n            self.register_directory(location, **kwargs)\n        elif location_type == 'filepath':\n            if not os.path.exists(location):\n                raise OSError(\"File not found\", location)\n            if os.path.isfile(location):\n                self.register_rml(location)\n            elif filename:\n                new_loc = os.path.join(location, filename)\n                if not os.path.exists(new_loc):\n                    raise OSError(\"File not found\", new_loc)\n                elif os.path.isfile(new_loc):\n                    self.register_rml(new_loc)\n            else:\n                raise OSError(\"File not found\", location)\n        elif location_type.startswith('package'):\n            pkg_path = \\\n                    importlib.util.find_spec(\\\n                            location).submodule_search_locations[0]\n            if location_type.endswith('_all'):\n                self.register_directory(pkg_path, **kwargs)\n            elif location_type.endswith('_file'):\n                filepath = os.path.join(pkg_path, filename)\n                self.register_rml(filepath, **kwargs)\n            else:\n                raise NotImplementedError", "response": "This function registers the rml file locations for easy access."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nregisters the filepath for an rml mapping.", "response": "def register_rml(self, filepath, **kwargs):\n        \"\"\"\n        Registers the filepath for an rml mapping\n\n        Args:\n        -----\n            filepath: the path the rml file\n        \"\"\"\n        name = os.path.split(filepath)[-1]\n        if name in self.rml_maps and self.rml_maps[name] != filepath:\n            raise Exception(\"RML name already registered. Filenames must be \"\n                            \"unique.\",\n                            (self.rml_maps[name], filepath))\n        self.rml_maps[name] = filepath"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef register_directory(self, dirpath, **kwargs):\n\n        kwargs['file_extensions'] = kwargs.get(\"file_extensions\",\n                                               self.rdf_formats)\n        files = list_files(file_directory=dirpath, **kwargs)\n        for fileinfo in files:\n            self.register_rml(fileinfo[-1], **kwargs)", "response": "Registers all of the files in the directory dirpath"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate a new RmlProcessor and registers it in the manager.", "response": "def make_processor(self, name, mappings, processor_type, **kwargs):\n        \"\"\"\n        Instantiates a RmlProcessor and registers it in the manager\n\n        Args:\n        -----\n            name: the name to register the processor\n            mappings: the list RML mapping definitions to use\n            processor_type: the name of the RML processor to use\n        \"\"\"\n        from .processor import Processor\n        if self.processors.get(name):\n            raise LookupError(\"processor has already been created\")\n        if isinstance(mappings, list):\n            mappings = [self.get_rml(item) for item in mappings]\n        else:\n            mappings = [self.get_rml(mappings)]\n        self.processors[name] = Processor[processor_type](mappings, **kwargs)\n        self.processors[name].name = name\n        return self.processors[name]"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the specified RML Processor object.", "response": "def get_processor(self,\n                      name,\n                      mappings=None,\n                      processor_type=None,\n                      **kwargs):\n        \"\"\"\n        Returns the specified RML Processor\n        \"\"\"\n        try:\n            return self.processors[name]\n        except KeyError:\n            return  self.make_processor(name,\n                                        mappings,\n                                        processor_type,\n                                        **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the rml mapping filepath", "response": "def get_rml(self, rml_name, rtn_format=\"filepath\"):\n        \"\"\" returns the rml mapping filepath\n\n        rml_name(str): Name of the rml mapping to retrieve\n        rtn_format: ['filepath', 'data']\n        \"\"\"\n\n        try:\n            rml_path = self.rml_maps[rml_name]\n        except KeyError:\n            if rml_name in self.rml_maps.values() or os.path.exists(rml_name):\n                rml_path = rml_name\n            else:\n                raise LookupError(\"rml_name '%s' is not registered\" % rml_name)\n        if rtn_format == \"data\":\n            with open(rml_path, \"rb\") as fo:\n                return fo.read()\n        return rml_path"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef memoize(Class, *args, **kwargs):\n        '''\n        Memoize/record a function inside this vlermv. ::\n\n            @Vlermv.cache('~/.http')\n            def get(url):\n                return requests.get(url, auth = ('username', 'password'))\n\n        The args and kwargs get passed to the Vlermv with some slight changes.\n        Here are the changes.\n\n        First, the default ``key_transformer`` is the tuple key_transformer\n        rather than the simple key_transformer.\n\n        Second, it is valid for cache to be called without arguments.\n        Vlermv would ordinarily fail if no arguments were passed to it.\n        If you pass no arguments to cache, the Vlermv directory argument\n        (the one required argument) will be set to the name of the function.\n\n        Third, you are more likely to use the ``cache_exceptions`` keyword\n        argument; see :py:class:`~vlermv.Vlermv` for documentation on that.\n        '''\n        def decorator(func):\n            if len(args) == 0:\n                if hasattr(func, '__name__'): \n                    _args = (func.__name__,)\n                else:\n                    raise ValueError('You must specify the location to store the vlermv.')\n            else:\n                _args = args\n            v = Class(*_args, **kwargs)\n            v.func = func\n            return v\n        return decorator", "response": "Memoize a function inside this vlermv."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the absolute filename corresponding to a key.", "response": "def filename(self, index):\n        '''\n        Get the absolute filename corresponding to a key; run the\n        key_transformer on the key and do a few other small things.\n\n        :raises TypeError: if the key_transformer returns something other than\n            a :py:class:`tuple` of :py:class:`strings <str>`\n        :raises KeyError: if the key_transformer returns an empty path\n        :returns: the filename\n        :rtype: str\n        '''\n        subpath = self.key_transformer.to_path(index)\n        if not isinstance(subpath, tuple):\n            msg = 'subpath is a %s, but it should be a tuple.'\n            raise TypeError(msg % type(subpath).__name__)\n        elif len(subpath) == 0:\n            raise KeyError('You specified an empty key.')\n        elif not all(isinstance(x, str) for x in subpath):\n            msg = 'Elements of subpath should all be str; here is subpath:\\n%s' % repr(subpath)\n            raise TypeError(msg)\n        return os.path.join(self.base_directory, *safe_path(subpath)) + self.extension"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconvert an absolute filename into a key.", "response": "def from_filename(self, filename):\n        '''\n        Convert an absolute filename into key.\n        '''\n        i = len(self.base_directory)\n        if filename[:i] != self.base_directory:\n            raise ValueError('Filename needs to start with \"%s\";\\nyou passed \"%s\".' % (self.base_directory, filename))\n\n        if filename.endswith(self.extension):\n            if len(self.extension) > 0:\n                j = -len(self.extension)\n            else:\n                j = None\n            return self.key_transformer.from_path(tuple(filename[i:j].strip('/').split('/')))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef main(self, spin, data):\n        data  = data.decode(self.encoding)\n        field = re.match(RFC_REG, data)\n        \n        if not field:\n            return\n    \n        prefix  = self.extract_prefix(field.group('prefix'))\n        command = field.group('command').upper()\n        args    = self.extract_args(field.group('arguments'))\n        spawn(spin, command, *(prefix + args))", "response": "This function is used to extract the basic arguments from the message."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef extract_prefix(self, prefix):\n\n        field = re.match(PREFIX_REG, prefix if prefix else '')\n        \n        return (prefix,) if not field else field.group(1, 2, 3)", "response": "It extracts an irc msg prefix chunk \n       "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef extract_ctcp(self, spin, nick, user, host, target, msg):\n    \n        # The ctcp delimiter token.\n        DELIM = '\\001'\n    \n        if not msg.startswith(DELIM) or not msg.endswith(DELIM):\n            return\n    \n        ctcp_args = msg.strip(DELIM).split(' ') \n        \n        spawn(spin, ctcp_args[0], (nick, user, host,  target, msg), *ctcp_args[1:])", "response": "This function extracts ctcp requests into pieces."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef patch(self, spin, header, *args):\n\n        spawn(spin, 'DCC %s' % args[0], header, *args[1:])", "response": "This is a wrapper for the spawns DCC TYPE as event. \n        It spawns DCC TYPE as event. \n        It spawns DCC TYPE as event. \n        It spawns DCC TYPE as event. \n        It spawns DCC TYPE as event. \n        It spawns DCC TYPE as event. \n        It spawns DCC TYPE as event. \n        It spawns DCC TYPE as event."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef print_commands(self, out=sys.stdout):\n        '''\n        utility method to print commands\n        and descriptions for @BotFather\n        '''\n        cmds = self.list_commands()\n        for ck in cmds:\n            if ck.printable:\n                out.write('%s\\n' % ck)", "response": "utility method to print commands and descriptions for the current user."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef request(self, method, uri, **kw):\n        expect = kw.pop(\"expect\", [])\n        mime_body = kw.pop(\"mime_body\", None)\n\n        headers = kw.pop(\"headers\", {})\n        data = kw.pop(\"data\", None)\n\n        if mime_body:\n            mimevalues = self.mimeobjects.get(mime_body.__class__)\n\n            if not mimevalues:\n                raise ClientException(\n                    (\"Cannot handle object of type \"\n                     \"{0!r}\").format(mime_body.__class__))\n\n            mapping = mimevalues[0]\n\n            document_type, mimetype, validator = mapping\n\n            data = document_type.render(validator, mime_body)\n            headers[\"Content-Type\"] = mimetype\n\n        if uri[0] != '/':\n            uri = '/' + uri\n\n        url = \"{self.scheme}://{self.host}{uri}\".format(self=self, uri=uri)\n\n        response = self.session.request(\n            method, url,\n            headers=headers,\n            data=data,\n            **kw)\n\n        content_type = response.headers.get(\"Content-Type\")\n\n        if content_type is None or not response.content:\n            return response, None\n\n        mimetype, opts = werkzeug.http.parse_options_header(content_type)\n\n        if mimetype not in self.mimetypes:\n            raise ClientException(\n                \"Cannot handle response type: {0}\".format(mimetype))\n\n        document_type, document_class, validator = self.mimetypes.get(mimetype)\n\n        if expect and document_class not in expect:\n            raise ClientException(\n                \"Unexpected response type: {0}\".format(mimetype))\n\n        try:\n            obj = document_type.parse(validator,\n                                      document_class,\n                                      response.content)\n        except MimeValidationError as e:\n            raise ClientException(\n                \"Response format invalid: {0}\".format(str(e)))\n        except:\n            log.error(\n                \"Failed to parse content of type: {0}\".format(mimetype),\n                exc_info=sys.exc_info())\n            raise ClientException(\n                \"Failed to parse content of type: {0}\".format(mimetype))\n\n        return response, obj", "response": "This method is used to make a request to the ACS API."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef update_user(self, username, profile, owner_privkey):\n\n        url = self.base_url + \"/users/\" + username + \"/update\"\n\n        owner_pubkey = get_pubkey_from_privkey(owner_privkey)\n\n        payload = {\n            'profile': profile,\n            'owner_pubkey': owner_pubkey\n            }\n\n        resp = self._post_request(url, payload)\n\n        try:\n            unsigned_tx = resp['unsigned_tx']\n        except:\n            return resp\n\n        dht_resp = write_dht_profile(profile)\n        dht_resp = dht_resp[0]\n\n        if not dht_resp['status'] == 'success':\n            return {\"error\": \"DHT write failed\"}\n\n        # sign all unsigned inputs\n        signed_tx = sign_all_unsigned_inputs(owner_privkey, unsigned_tx)\n\n        return self.broadcast_transaction(signed_tx)", "response": "Update user profile on blockchain"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nsend a transfer request to the blockchain.", "response": "def transfer_user(self, username, transfer_address, owner_privkey):\n        \"\"\"\n            Transfer name on blockchain\n        \"\"\"\n\n        url = self.base_url + \"/users/\" + username + \"/update\"\n\n        owner_pubkey = get_pubkey_from_privkey(owner_privkey)\n\n        payload = {\n            'transfer_address': transfer_address,\n            'owner_pubkey': owner_pubkey\n            }\n\n        resp = self._post_request(url, payload)\n\n        try:\n            unsigned_tx = resp['unsigned_tx']\n        except:\n            return resp\n\n        # sign all unsigned inputs\n        signed_tx = sign_all_unsigned_inputs(owner_privkey, unsigned_tx)\n\n        return self.broadcast_transaction(signed_tx)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nturn class into a kervi controller", "response": "def create(controller_id, name):\n        \"\"\"Turn class into a kervi controller\"\"\"\n        def _decorator(cls):\n            class _ControllerClass(cls, Controller):\n                def __init__(self):\n                    Controller.__init__(self, controller_id, name)\n                    for key in cls.__dict__.keys():\n                        prop = cls.__dict__[key]\n                        if isinstance(prop, KerviValue):\n                            if prop.is_input:\n                                self.inputs._add_internal(key, prop)\n                            else:\n                                self.outputs._add_internal(key, prop)\n                    cls.__init__(self)\n            return _ControllerClass\n        return _decorator"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds input to controller", "response": "def input(input_id, name, value_class=NumberValue):\n        \"\"\"Add input to controller\"\"\"\n        def _init():\n            return value_class(\n                name,\n                input_id=input_id,\n                is_input=True,\n                index=-1\n            )\n        def _decorator(cls):\n            setattr(cls, input_id, _init())\n            return cls\n        return _decorator"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds output to controller", "response": "def output(output_id, name, value_class=NumberValue):\n        \"\"\"Add output to controller\"\"\"\n        def _init():\n            return value_class(\n                name,\n                input_id=output_id,\n                is_input=False,\n                index=-1\n            )\n        def _decorator(cls):\n            setattr(cls, output_id, _init())\n            return cls\n        return _decorator"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ntrue if subset is a subset of superset.", "response": "def _subset(subset, superset):\n    \"\"\"True if subset is a subset of superset.\n\n    :param dict subset: subset to compare.\n    :param dict superset: superset to compare.\n    :return: True iif all pairs (key, value) of subset are in superset.\n    :rtype: bool\n    \"\"\"\n\n    result = True\n    for k in subset:\n        result = k in superset and subset[k] == superset[k]\n        if not result:\n            break\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef button_with_image(size='medium', icon=None, text=None, title=None, button=False, \n                      name=None, target=False, disabled=False, extra_css=None, modal=None, \n                      data_target='#modal', viewname=None, next=None, extra_href=False, href=False,\n                      fancyajax=False, viewargs=[], **kwargs):\n    \"\"\"\n    Output a button using Bingo's button html.\n    \n    @param size: The size that refers to the icon css class.\n    @param icon: A css class that refers to an icon - for example 'send_mail'\n    @param text: Text to display on the button\n    @param title: Title parameter for the button or if button=False the data-tip for an a tag. \n    @param button: If true a button tag will be returned.\n    @param name: A name for the button\n    @param target: A target for the a tag\n    @param disabled: If true, css class 'disabled' will be added to the container div.\n    @param extra_css: A string of extra css classes.\n    @param model: If True the class 'model' is placed on the a tag.\n    @param viewname: The django viewname as defined in a urls.py file.\n    @param **kwargs: Remaining keyword args are supplied to django.core.urlresolvers.reverse\n    @param next: If specified ?next=[NEXT] will be appended to any generated link.\n    @return string \n    \"\"\"\n    html = '<div class=\"button-std'\n    \n    if disabled:\n        html += ' disabled'\n    \n    html += '\">'\n    \n    if button:\n        html += '<button type=\"submit\" name=\"%s\" value=\"%s\" class=\"%s\">' % (name, title, icon)\n        if icon:\n            html += '<span class=\"icon-%s icon-%s-%s\"></span>' % (size, size, icon)\n        html += '<span>%s</span></button>' % (title)\n    else:\n        html += '<a class=\"%s' % (icon)\n        if fancyajax:\n            html += ' fancybox fancybox.ajax'\n        if extra_css:\n            html += ' %s' % (extra_css)\n        html += '\"'\n        if modal:\n            html += ' role=\"button\" data-toggle=\"modal\" data-remoteinbody=\"false\"'\n            if data_target:\n                html += ' data-target=\"#modal\"'\n        if fancyajax:\n            html += ' data-spinner-append=\"1\"'\n        if viewname:\n            html += ' href=\"%s' % (reverse(viewname, args=viewargs, kwargs=kwargs))\n        elif href:\n            html += ' href=\"%s' % (href)\n        if viewname or href:\n            if next:\n                if next.startswith('/'):\n                    html += '?next=%s' % next\n                else:\n                    html += '?next=%s' % reverse(next)\n            if extra_href:\n                html += extra_href\n            html += '\"'\n        if not title and text:\n            title = text\n        if title:\n            html += ' data-tip=\"%s\"' % (title)\n        if target:\n            html += ' target=\"%s\"' % (target)\n        html += '>'\n        \n        if icon:\n            html += '<span class=\"icon-%s icon-%s-%s\"></span>' % (size, size, icon)\n        \n        if text:\n            html += '<span class=\"title\">%s</span>' % (text)\n    \n        html += '</a></div>'\n    \n    return html", "response": "Return a string containing a button with an image."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef init_parser():\n    parser = argparse.ArgumentParser(\n        description=\"Automated development environment initialization\")\n\n    parser.add_argument('--version', action='version',\n        version='%(prog)s ' + __version__)\n\n    subparsers = parser.add_subparsers(title=\"commands\")\n\n    # List command\n    parser_list = subparsers.add_parser(\"list\",\n        help=\"list all the available environment types\")\n\n    # New command\n    parser_new = subparsers.add_parser(\"new\",\n        help=\"define a new environment type\")\n    parser_new.add_argument(\"environment\", help=\"name for the environment\")\n\n    # Remove command\n    parser_remove = subparsers.add_parser(\"remove\",\n        help=\"remove an environment type from the configuration file\")\n    parser_remove.add_argument(\"environment\", help=\"name of the environment\")\n\n    # Show command\n    parser_show = subparsers.add_parser(\"show\",\n        help=\"show the commands performed for a specific environment\")\n    parser_show.add_argument(\"environment\", help=\"name of the environment\")\n\n    # Start command\n    parser_start = subparsers.add_parser(\"start\",\n        help=\"start a new environment\")\n    parser_start.add_argument(\"environment\", help=\"name of the environment\")\n    parser_start.add_argument(\"path\", nargs=\"?\",\n        help=\"path in which to initialize the environment\")\n\n    return parser", "response": "Initialize the arguments parser."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates a new environment in the configuration and ask the user for the commands for this specific environment.", "response": "def new_env(environment):\n    \"\"\" Create a new environment in the configuration and ask the\n        user for the commands for this specific environment.\n    \"\"\"\n    if not environment:\n        print(\"You need to supply an environment name\")\n        return\n\n    parser = read_config()\n\n    if environment in parser.sections():\n        print(\"Environment '%s' already exists\" % environment)\n        return\n\n    print(\"Please introduce (in order) the commands for '%s'\\n\" % environment)\n    print(\"Press RETURN to end command and RETURN with empty line to finish\\n\")\n\n    commands = []\n    cmd = \"\"\n\n    while True:\n        try:\n            cmd = raw_input(\"> \")\n\n            if not cmd:\n                break\n\n            commands.append(cmd)\n\n        except KeyboardInterrupt:\n            return\n\n    parser.add_section(environment)\n    parser.set(environment, \"cmd\", \"\\n\".join(commands))\n\n    write_config(parser)\n\n    print(\"Added environment '%s'\" % environment)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nremoving an environment from the configuration.", "response": "def remove_env(environment):\n    \"\"\" Remove an environment from the configuration. \"\"\"\n    if not environment:\n        print(\"You need to supply an environment name\")\n        return\n\n    parser = read_config()\n\n    if not parser.remove_section(environment):\n        print(\"Unknown environment type '%s'\" % environment)\n        return\n\n    write_config(parser)\n\n    print(\"Removed environment '%s'\" % environment)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef show_env(environment):\n    if not environment:\n        print(\"You need to supply an environment name\")\n        return\n\n    parser = read_config()\n\n    try:\n        commands = parser.get(environment, \"cmd\").split(\"\\n\")\n\n    except KeyError:\n        print(\"Unknown environment type '%s'\" % environment)\n        return\n\n    print(\"Environment: %s\\n\" % environment)\n\n    for cmd in commands:\n        print(cmd)", "response": "Show the commands for a given environment."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ninitialize a new environment in specified directory.", "response": "def start_env(environment, path):\n    \"\"\" Initialize a new environment in specified directory.\n\n        If path does not exist, will try to create the directory structure\n        recursively.\n\n        If the path is not provided, will use current working directory.\n    \"\"\"\n    parser = read_config()\n\n    if environment not in parser.sections():\n        print(\"Unknown environment type '%s'\" % environment)\n        return\n\n    if path and not os.path.isdir(path):\n        try:\n            os.makedirs(path)\n        except os.error:\n            print(\"Could not create directory structure\")\n            return\n\n    init_path = path if path else os.getcwd()\n\n    commands = parser.get(environment, \"cmd\").split(\"\\n\")\n\n    print(\"Working in directory: \" + init_path)\n\n    for cmd in commands:\n        proc = subprocess.Popen(cmd , cwd=init_path, shell=True)\n        proc.wait()\n\n    print(\"Initialized '%s' environment\" % environment)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef read_config():\n    if not os.path.isfile(CONFIG):\n        with open(CONFIG, \"w\"):\n            pass\n\n    parser = ConfigParser()\n    parser.read(CONFIG)\n\n    return parser", "response": "Read the configuration file and parse the different environments."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nparsing the action to execute.", "response": "def parse_action(action, parsed):\n    \"\"\" Parse the action to execute. \"\"\"\n    if action == \"list\":\n        list_env()\n\n    elif action == \"new\":\n        new_env(parsed.environment)\n\n    elif action == \"remove\":\n        remove_env(parsed.environment)\n\n    elif action == \"show\":\n        show_env(parsed.environment)\n\n    elif action == \"start\":\n        start_env(parsed.environment, parsed.path)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _init_pdf(style_path, header=None, footer=FOOTER):\n    return RstToPdf(\n        language=\"cs\",\n        font_path=[\n            \"/usr/share/fonts\",\n            \"/usr/share/fonts/truetype/\",\n            '.',\n            '/usr/local/lib/python2.7/dist-packages/rst2pdf/fonts'\n        ],\n        stylesheets=[\n            style_path\n        ],\n        breaklevel=0,\n        splittables=True,\n        header=header,\n        footer=footer\n    )", "response": "Initialize the RSTToPdf object."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef gen_pdf(rst_content, style_text, header=None, footer=FOOTER):\n    out_file_obj = StringIO()\n\n    with NamedTemporaryFile() as f:\n        f.write(style_text)\n        f.flush()\n\n        pdf = _init_pdf(f.name, header, footer)\n\n    # create PDF\n    pdf.createPdf(text=rst_content, output=out_file_obj, compressed=True)\n\n    # rewind file pointer to begin\n    out_file_obj.seek(0)\n\n    return out_file_obj", "response": "Generate a PDF file from a RST file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef define_parameters(**parameters):\n    params = []\n    for key, value in parameters.items():\n        param = dict(ParameterKey=key, ParameterValue=value)\n        params.append(param)\n    return params", "response": "Get a list of parameters to pass to AWS boto call."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a cluster on Amazon s EKS Service configured for Jupyterhub Deployments.", "response": "def create(self):\n        \"\"\"Deploy a cluster on Amazon's EKS Service configured\n        for Jupyterhub Deployments.\n        \"\"\"\n        steps = [\n            (self.create_role, (), {}),\n            (self.create_vpc, (), {}),\n            (self.create_cluster, (), {}),\n            (self.create_node_group, (), {}),\n            (self.create_spot_nodes, (), {}),\n            (self.create_utilities, (), {}),\n        ]\n        # Execute creation.\n        for step in tqdm.tqdm(steps, ncols=70):\n            method, args, kwargs = step\n            method(*args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef delete(self):\n        stacks = [\n            self.utilities_name,\n            self.spot_nodes_name,\n            self.node_group_name,\n            self.cluster_name,\n            self.vpc_name,\n            self.role_name\n        ]\n        # Execute creation.\n        for stack in tqdm.tqdm(stacks, ncols=70):\n            self.delete_stack(stack)", "response": "Delete a running cluster."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the Authorization Config Map for this cluster.", "response": "def get_auth_config(self):\n        \"\"\"Return the Authorization Config Map (in yaml format) \n        for this cluster.\n        \"\"\"\n        return self.get_template(\n            'amazon-auth-cm.yaml',\n            arn=self.node_arn,\n            users=self.admins\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_template(self, template_name, **parameters):\n        template_path = pathlib.Path(self.template_dir).joinpath(template_name)\n        return get_template(template_path, **parameters)", "response": "Pulls templates from the AWS templates folder"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef create_stack(\n        self, \n        stack_name,\n        stack_template_name,\n        parameters=None,\n        capabilities=None\n        ):\n        \"\"\"Create a stack using Amazon's Cloud formation\"\"\"\n        # Build template_path\n        stack_template_path = pathlib.Path(\n            self.template_dir).joinpath(stack_template_name)\n\n        # Create stack\n        create_stack(\n            stack_name,\n            stack_template_path,\n            parameters=parameters,\n            capabilities=capabilities\n        )", "response": "Create a stack using Amazon s Cloud Formation."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate a virtual private cloud on Amazon s Web services configured for deploying JupyterHubs.", "response": "def create_vpc(self):\n        \"\"\"Create a virtual private cloud on Amazon's Web services configured\n        for deploying JupyterHubs.\n        \"\"\"\n        self.create_stack(\n            self.vpc_name,\n            'amazon-eks-vpc.yaml',\n            parameters=define_parameters(\n                VpcBlock=\"10.42.0.0/16\",\n                Subnet01Block=\"10.42.1.0/24\",\n                Subnet02Block=\"10.42.2.0/24\",\n                Subnet03Block=\"10.42.3.0/24\"\n            )\n        )"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate a cluster on Amazon EKS.", "response": "def create_cluster(self):\n        \"\"\"Creates a cluster on Amazon EKS .\n        \"\"\"\n        self.create_stack(\n            self.cluster_name,\n            'amazon-eks-cluster.yaml',\n            parameters=define_parameters(\n                ClusterName=self.cluster_name,\n                ControlPlaneSecurityGroup=self.security_groups,\n                Subnets=self.subnet_ids\n            )\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating on - demand node group on Amazon EKS.", "response": "def create_node_group(self):\n        \"\"\"Create on-demand node group on Amazon EKS.\n        \"\"\"\n        self.create_stack(\n            self.node_group_name,\n            'amazon-eks-nodegroup.yaml',\n            capabilities=['CAPABILITY_IAM'],\n            parameters=define_parameters(\n                ClusterName=self.cluster_name,\n                ClusterControlPlaneSecurityGroup=self.security_groups,\n                Subnets=self.subnet_ids,\n                VpcId=self.vpc_ids,\n                KeyName=self.ssh_key_name,\n                NodeAutoScalingGroupMaxSize=\"1\",\n                NodeVolumeSize=\"100\",\n                NodeImageId=\"ami-0a54c984b9f908c81\",\n                NodeGroupName=f\"{self.name} OnDemand Nodes\"\n            )\n        )"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef debugtoolbar_middleware_factory(app, handler):\n    dbtb = app.ps.debugtoolbar\n\n    @asyncio.coroutine\n    def debugtoolbar_middleware(request):\n        \"\"\"Integrate to application.\"\"\"\n\n        # Check for debugtoolbar is enabled for the request\n        if not dbtb.cfg.enabled or any(map(request.path.startswith, dbtb.cfg.exclude)):\n            return (yield from handler(request))\n\n        remote_host, remote_port = request.transport.get_extra_info('peername')\n        for host in dbtb.cfg.hosts:\n            if ip.ip_address(remote_host) in ip.ip_network(host):\n                break\n        else:\n            return (yield from handler(request))\n\n        # Initialize a debugstate for the request\n        state = DebugState(app, request)\n        dbtb.history[state.id] = state\n        context_switcher = state.wrap_handler(handler)\n\n        # Make response\n        try:\n            response = yield from context_switcher(handler(request))\n            state.status = response.status\n        except HTTPException as exc:\n            response = exc\n            state.status = response.status\n\n        except Exception as exc:\n            # Store traceback for unhandled exception\n            state.status = 500\n            if not dbtb.cfg.intercept_exc:\n                raise\n            tb = get_traceback(\n                info=sys.exc_info(), skip=1, show_hidden_frames=False,\n                ignore_system_exceptions=True, exc=exc)\n            dbtb.exceptions[tb.id] = request['pdbt_tb'] = tb\n            for frame in tb.frames:\n                dbtb.frames[id(frame)] = frame\n            response = Response(text=tb.render_full(request), content_type='text/html')\n\n        # Intercept http redirect codes and display an html page with a link to the target.\n        if dbtb.cfg.intercept_redirects and response.status in REDIRECT_CODES \\\n                and 'Location' in response.headers:\n\n            response = yield from app.ps.jinja2.render(\n                'debugtoolbar/redirect.html', response=response)\n            response = Response(text=response, content_type='text/html')\n\n        yield from state.process_response(response)\n\n        if isinstance(response, Response) and response.content_type == 'text/html' and \\\n                RE_BODY.search(response.body):\n            return (yield from dbtb.inject(state, response))\n\n        return response\n\n    return debugtoolbar_middleware", "response": "Create a middleware that returns a coroutine that will check for debugtoolbar is enabled for the request and then dispatches the handler to the response."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ninject Debug Toolbar code to response body.", "response": "def inject(self, state, response):\n        \"\"\" Inject Debug Toolbar code to response body. \"\"\"\n        html = yield from self.app.ps.jinja2.render(\n            'debugtoolbar/inject.html',\n            static_path=self.cfg.prefix + 'static',\n            toolbar_url=self.cfg.prefix + state.id,\n        )\n        html = html.encode(state.request.charset or 'utf-8')\n        response.body = RE_BODY.sub(html + b'</body>', response.body)\n        return response"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef view(self, request):\n        auth = yield from self.authorize(request)\n        if not auth:\n            raise HTTPForbidden()\n\n        request_id = request.match_info.get('request_id')\n        state = self.history.get(request_id, None)\n\n        response = yield from self.app.ps.jinja2.render(\n            'debugtoolbar/toolbar.html',\n            debugtoolbar=self,\n            state=state,\n            static_path=self.cfg.prefix + 'static',\n            panels=state and state.panels or [],\n            global_panels=self.global_panels,\n            request=state and state.request or None,\n        )\n        return Response(text=response, content_type='text/html')", "response": "View the debug toolbar."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _format_dict(self, info_dict):\n        for key, value in info_dict.items():\n            if not value:\n                info_dict[key] = \"NA\"\n        return info_dict", "response": "Formats the dictionary to be used in the API."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nconvert a string containing comma separated email addresses into a list of email addresses.", "response": "def split_addresses(email_string_list):\n    \"\"\"\n    Converts a string containing comma separated email addresses\n    into a list of email addresses.\n    \"\"\"\n    return [f for f in [s.strip() for s in email_string_list.split(\",\")] if f]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef subject_template(template, context):\n    subject = loader.get_template(template).render(Context(context))\n    return \" \".join(subject.splitlines()).strip()", "response": "Loads and renders an email subject template returning the resulting string."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef send_mail_template(subject, template, addr_from, addr_to, context=None,\n                       attachments=None, fail_silently=None, addr_bcc=None,\n                       headers=None):\n    \"\"\"\n    Send email rendering text and html versions for the specified\n    template name using the context dictionary passed in.\n    \"\"\"\n    if context is None:\n        context = {}\n    if attachments is None:\n        attachments = []\n    if fail_silently is None:\n        fail_silently = settings.EMAIL_FAIL_SILENTLY\n    # Add template accessible settings from yacms to the context\n    # (normally added by a context processor for HTTP requests).\n    context.update(context_settings())\n    # Allow for a single address to be passed in.\n    # Python 3 strings have an __iter__ method, so the following hack\n    # doesn't work: if not hasattr(addr_to, \"__iter__\"):\n    if isinstance(addr_to, str) or isinstance(addr_to, bytes):\n        addr_to = [addr_to]\n    if addr_bcc is not None and (isinstance(addr_bcc, str) or\n                                 isinstance(addr_bcc, bytes)):\n        addr_bcc = [addr_bcc]\n    # Loads a template passing in vars as context.\n    render = lambda type: loader.get_template(\"%s.%s\" %\n                          (template, type)).render(Context(context))\n    # Create and send email.\n    msg = EmailMultiAlternatives(subject, render(\"txt\"),\n                                 addr_from, addr_to, addr_bcc,\n                                 headers=headers)\n    msg.attach_alternative(render(\"html\"), \"text/html\")\n    for attachment in attachments:\n        msg.attach(*attachment)\n    msg.send(fail_silently=fail_silently)", "response": "Send an email using the specified template name."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsending an email to users when ACCOUNTS_VERIFICATION_REQUIRED is True and the user s password has changed.", "response": "def send_verification_mail(request, user, verification_type):\n    \"\"\"\n    Sends an email with a verification link to users when\n    ``ACCOUNTS_VERIFICATION_REQUIRED`` is ```True`` and they're signing\n    up, or when they reset a lost password.\n    The ``verification_type`` arg is both the name of the urlpattern for\n    the verification link, as well as the names of the email templates\n    to use.\n    \"\"\"\n    verify_url = reverse(verification_type, kwargs={\n        \"uidb36\": int_to_base36(user.id),\n        \"token\": default_token_generator.make_token(user),\n    }) + \"?next=\" + (next_url(request) or \"/\")\n    context = {\n        \"request\": request,\n        \"user\": user,\n        \"verify_url\": verify_url,\n    }\n    subject_template_name = \"email/%s_subject.txt\" % verification_type\n    subject = subject_template(subject_template_name, context)\n    send_mail_template(subject, \"email/%s\" % verification_type,\n                       settings.DEFAULT_FROM_EMAIL, user.email,\n                       context=context)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nsending an email to staff in listed in the settings. ACCOUNTS_APPROVAL_EMAILS setting.", "response": "def send_approve_mail(request, user):\n    \"\"\"\n    Sends an email to staff in listed in the setting\n    ``ACCOUNTS_APPROVAL_EMAILS``, when a new user signs up and the\n    ``ACCOUNTS_APPROVAL_REQUIRED`` setting is ``True``.\n    \"\"\"\n    approval_emails = split_addresses(settings.ACCOUNTS_APPROVAL_EMAILS)\n    if not approval_emails:\n        return\n    context = {\n        \"request\": request,\n        \"user\": user,\n        \"change_url\": admin_url(user.__class__, \"change\", user.id),\n    }\n    subject = subject_template(\"email/account_approve_subject.txt\", context)\n    send_mail_template(subject, \"email/account_approve\",\n                       settings.DEFAULT_FROM_EMAIL, approval_emails,\n                       context=context)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef send_approved_mail(request, user):\n    context = {\"request\": request, \"user\": user}\n    subject = subject_template(\"email/account_approved_subject.txt\", context)\n    send_mail_template(subject, \"email/account_approved\",\n                       settings.DEFAULT_FROM_EMAIL, user.email,\n                       context=context)", "response": "Sends an email to a user when their is_active status goes to False to True to indicate that the user is not authorized to approve their account."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nmerges two dictionary objects into dst", "response": "def merge (dst, src):\r\n        \"\"\"put key/value pairs that exist in src but not in dst into dst\"\"\"\r\n        for key in src.keys():\r\n                if key not in dst:\r\n                        dst[key] = src[key]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconvert index to column. Eg. 2 B 2 AB", "response": "def IndexToColumn (ndx):\r\n        \"\"\"convert index to column. Eg: IndexToColumn(2) = \"B\", IndexToColumn(28) = \"AB\" \"\"\"\r\n        ndx -= 1\r\n        col  = chr(ndx % 26 + 65)\r\n        while (ndx > 25):\r\n                ndx  = ndx // 26\r\n                col  = chr(ndx % 26 + 64) + col\r\n        return col"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nconverting column to index. Eg. ConvertInIndex = 28", "response": "def ColumnToIndex (col):\r\n        \"\"\"convert column to index. Eg: ConvertInIndex(\"AB\") = 28\"\"\"\r\n        ndx = 0\r\n        for c in col:\r\n                ndx = ndx * 26 + ord(c.upper()) - 64\r\n        return ndx"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef ParseCellSpec (spec):\r\n        m = __specRe.match(spec)\r\n        (column, row) = m.groups()\r\n        return (int(row), ColumnToIndex(column))", "response": "parse cell spec to row col. Eg. 2 5"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef ParseExcelXMLFile(filename):\r\n\r\n        excelfile = ExcelFile()\r\n        excelHandler = ExcelToSparseArrayHandler(excelfile)\r\n        parse(filename, excelHandler)\r\n        return excelfile", "response": "parse an Excel file"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef GetCellValue (self, column, default = None):\r\n                if isinstance(column, str):\r\n                        column = ColumnToIndex(column)\r\n                if column in self:\r\n                        if \"content\" in UserDict.__getitem__(self, column):\r\n                                return UserDict.__getitem__(self, column)[\"content\"]\r\n                return default", "response": "get a cell from the UserDict"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef GetCellValueNoFail (self, column):\r\n                cell = GetCellValue(self, column)\r\n                if cell == None:\r\n                        raise ValueError(\"cell %d does not exist\" % (column,))\r\n                return cell", "response": "get a cell from the table with the given column name raise an exception if it does not exist"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget the style of a cell", "response": "def GetCellStyle (self, column):\r\n                \"\"\" get the \"style\" of a cell\r\n                        note: this merges default, column, row and the cell's style into the actual style for you returning a dictionary of styles\r\n                        The values directly from excel with the relavent XML element appended to the name. Examples of style key/value pairs\r\n\r\n                        --key--------------------value-----------------------\r\n                        Alignment_ss:Vertical : Bottom\r\n                        Font_ss:Color         : #0000FF\r\n                        Font_x:Family             : Decorative\r\n                        Font_ss:Size          : 11\r\n                        Font_ss:FontName      : Algerian\r\n                        Interior_ss:Pattern   : Solid\r\n                        Interior_ss:Color     : #808000\r\n                \"\"\"\r\n                if isinstance(column, str):\r\n                        column = ColumnToIndex(column)\r\n                style = { }\r\n                # get style for cell\r\n                if column in self:\r\n                        if \"style\" in UserDict.__getitem__(self, column):\r\n                                merge(style, UserDict.__getitem__(self, column)[\"style\"])\r\n                return style"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef friend_addRow(self, rowNum, row):\r\n                self[rowNum] = row\r\n                if (rowNum > self.maxRow):\r\n                        self.maxRow = rowNum\r\n\r\n                for cellNum in row.keys():\r\n                        if cellNum > self.maxColumn:\r\n                                self.maxColumn = cellNum\r\n\r\n                return row.friend_Finalize()", "response": "used only by parser"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets a cell from a row", "response": "def GetCellValue (self, column, row = None, default = None):\r\n                \"\"\" get a cell, return default if that cell does not exist\r\n                        note that column and row START AT 1 same as excel\r\n                \"\"\"\r\n                if row == None:\r\n                        (row, column) = ParseCellSpec(column)\r\n                if row in self:\r\n                        return self[row].GetCellValue(column, default)\r\n                return default"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting a cell from the table with the given column and row number", "response": "def GetCellValueNoFail (self, column, row = None):\r\n                \"\"\" get a cell, if it does not exist fail\r\n                note that column at row START AT 1 same as excel\r\n                \"\"\"\r\n                if row == None:\r\n                        (row, column) = ParseCellSpec(column)\r\n                cell = GetCellValue(self, column, row)\r\n                if cell == None:\r\n                        raise ValueError(\"cell %d:%d does not exist\" % (column, row))\r\n                return cell"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef GetCellStyle (self, column, row = None):\r\n                if row == None:\r\n                        (row, column) = ParseCellSpec(column)\r\n                style = { }\r\n                # get style for cell\r\n                if row in self:\r\n                        merge(style, self[row].GetCellStyle(column))\r\n                # merge with row style\r\n                if row in self.rowStyles:\r\n                        merge(style, self.rowStyles[row])\r\n                # merge with column style\r\n                if isinstance(column, str):\r\n                        column = ColumnToIndex(column)\r\n                if column in self.columnStyles:\r\n                        merge(style, self.columnStyles[column])\r\n                # merge with default style\r\n                merge(style, self.defaultStyle)\r\n                return style", "response": "get the style of a cell"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the column number for a given column heading name 0 if not found", "response": "def GetColumnNumber (self, columnName):\r\n                \"\"\"returns the column number for a given column heading name, 0 if not found\"\"\"\r\n                for row in range(1, self.maxRow + 1):\r\n                        for column in range(1, self.maxColumn + 1):\r\n                                if self.GetCellValue(column, row, \"\") == columnName:\r\n                                        return column\r\n                return 0"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ndump as a comma separated value file", "response": "def DumpAsCSV (self, separator=\",\", file=sys.stdout):\r\n                \"\"\"dump as a comma separated value file\"\"\"\r\n                for row in range(1, self.maxRow + 1):\r\n                        sep = \"\"\r\n                        for column in range(1, self.maxColumn + 1):\r\n                                file.write(\"%s\\\"%s\\\"\" % (sep, self.GetCellValue(column, row, \"\")))\r\n                                sep = separator\r\n                        file.write(\"\\n\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets a sheet by name or number", "response": "def GetWorksheet(self, nameOrNumber):\r\n                \"\"\"get a sheet by number\"\"\"\r\n                if isinstance(nameOrNumber, int):\r\n                        return self.worksheets[nameOrNumber]\r\n                else:\r\n                        return self.worksheetsByName[nameOrNumber]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncalling by the XML parser when an element is opened.", "response": "def startElement (self, name, attrs):\r\n                '''if there's a start method for this element, call it\r\n                '''\r\n                func = getattr(self, 'start_' + name, None)\r\n                if func:\r\n                        func(attrs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef handle_request(request):\n    connector = request['connector']\n    hostname = connector['host']\n    port = connector['port']\n    virtual_host = connector['virtualHost']\n    queue = connector['queue']\n    user = connector['user']\n    password = connector['password']\n    # Establish connection with RabbitMQ server\n    logging.info('Connect : [HOST=' + hostname + ', QUEUE=' + queue + ']')\n    done = False\n    attempts = 0\n    while not done and attempts < 100:\n        try:\n            credentials = pika.PlainCredentials(user, password)\n            con = pika.BlockingConnection(pika.ConnectionParameters(\n                host=hostname,\n                port=port,\n                virtual_host=virtual_host,\n                credentials=credentials\n            ))\n            channel = con.channel()\n            channel.queue_declare(queue=queue, durable=True)\n            req = request['request']\n            logging.info('Run : [EXPERIMENT=' + req['experiment_id'] + ', RUN=' + req['run_id'] + ']')\n            channel.basic_publish(\n                exchange='',\n                routing_key=queue,\n                body=json.dumps(req),\n                properties=pika.BasicProperties(\n                    delivery_mode = 2, # make message persistent\n                )\n            )\n            con.close()\n            done = True\n        except pika.exceptions.ConnectionClosed as ex:\n            attempts += 1\n            logging.exception(ex)", "response": "Convert a model run request from the buffer into a RabbitMQ\nridge queue."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a dictionary with the default locations for the current language.", "response": "def get_locations():\n    '''\n    Compiles default locations\n\n    :returns:\n        A dictionary with folders as values:\n\n    * 'home_dir': Your home-directory (:file:`~`)\n\n    * 'call_dir': Where you called the first Python script from. (``argv[0]``)\n\n    * 'conf_dir': The :envvar:`XDG_CONFIG_HOME`-directory + \\\n    ``photon`` (:file:`~/.config/photon`)\n\n    * 'data_dir': The :envvar:`XDG_DATA_HOME`-directory + \\\n    ``photon`` (:file:`~/.local/share/photon`)\n\n    .. note::\n\n        * Both :func:`search_location` and :func:`make_locations` \\\n        have the argument `locations`.\n\n        * |param_locations_none|\n    '''\n\n    home_dir = _path.expanduser('~')\n    conf_dir = _path.join(\n        _environ.get(\n            'XDG_CONFIG_HOME',\n            _path.join(home_dir, '.config')\n        ),\n        IDENT\n    )\n    data_dir = _path.join(\n        _environ.get(\n            'XDG_DATA_HOME',\n            _path.join(home_dir, '.local', 'share')\n        ),\n        IDENT\n    )\n\n    return {\n        'home_dir': home_dir,\n        'call_dir': _path.dirname(_path.abspath(_argv[0])),\n        'conf_dir': conf_dir,\n        'data_dir': data_dir\n    }"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef make_locations(locations=None, verbose=True):\n    '''\n    Creates folders\n\n    :param locations:\n        A list of folders to create (can be a dictionary, see note below)\n    :param verbose:\n        Warn if any folders were created\n\n    .. note::\n\n        * |params_locations_dict|\n        * |param_locations_none|\n    '''\n\n    from photon.util.structures import to_list\n    from photon.util.system import shell_notify\n\n    if not locations:\n        locations = get_locations().values()\n    locations = to_list(locations)\n\n    r = list()\n    for p in reversed(sorted(locations)):\n        if not _path.exists(p):\n            _makedirs(p)\n            r.append(p)\n    if verbose and r:\n        shell_notify('path created', state=None, more=r)\n    return r", "response": "Creates folders for the specified locations."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef search_location(loc, locations=None,\n                    critical=False, create_in=None, verbose=True):\n    '''\n    Locates files with a twist:\n\n        * Check the existence of a file using the full path in `loc`\n\n        * Search for the filename `loc` in `locations`\n\n        * Create it's enclosing folders if the file does not exist. \\\n        use `create_in`\n\n    :param loc:\n        Filename to search\n    :param locations:\n        A list of possible locations to search within\n        (can be a dictionary, see note below)\n    :param critical:\n        |appteardown| if file was not found\n    :param create_in:\n        If `loc` was not found, the folder `create_in` is created.\n        If `locations` is a dictionary, `create_in` can also specify\n        a key of `locations`. The value will be used then.\n    :param verbose:\n        Pass verbose flag to :func:`make_locations`\n    :returns:\n        The full path of `loc` in matched location\n\n    .. note::\n        * |params_locations_dict|\n\n        * |param_locations_none|\n    '''\n\n    from photon.util.structures import to_list\n    from photon.util.system import shell_notify\n\n    if not locations:\n        locations = get_locations()\n\n    for p in reversed(sorted(to_list(locations))):\n        f = _path.join(p, loc)\n        if _path.exists(f):\n            return f\n\n    if _path.exists(_path.abspath(_path.expanduser(loc))):\n        return _path.abspath(_path.expanduser(loc))\n\n    if critical:\n        shell_notify('could not locate', state=True, more=dict(\n            file=loc, locations=locations\n        ))\n\n    if create_in:\n        if isinstance(locations, dict):\n            create_in = locations.get(create_in, create_in)\n        make_locations(locations=[create_in], verbose=verbose)\n        return _path.join(create_in, loc)", "response": "Search for a file in a set of locations."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncopy source and target location to target location.", "response": "def change_location(src, tgt, move=False, verbose=True):\n    '''\n    Copies/moves/deletes locations\n\n    :param src:\n        Source location where to copy from\n    :param tgt:\n        Target location where to copy to\n\n        * To backup `src`, set `tgt` explicitly to ``True``. \\\n        `tgt` will be set to `src` + '_backup_' + \\\n        :func:`util.system.get_timestamp` then\n\n    :param move:\n        Deletes original location after copy (a.k.a. move)\n\n        * To delete `src` , set `tgt` explicitly to ``False`` \\\n        and `move` to ``True`` (be careful!!1!)\n\n    :param verbose:\n        Show warnings\n    '''\n\n    from photon.util.system import shell_notify\n\n    if _path.exists(src):\n        if tgt:\n            if _path.isfile(src):\n                _copy2(src, search_location(\n                    tgt, create_in=_path.dirname(tgt), verbose=verbose)\n                )\n            else:\n                for l in _listdir(src):\n                    change_location(\n                        _path.abspath(_path.join(src, l)),\n                        _path.abspath(_path.join(tgt, l))\n                    )\n        if move:\n            if _path.isdir(src) and not _path.islink(src):\n                _rmtree(src)\n            else:\n                _remove(src)\n        if verbose:\n            shell_notify(\n                '%s location' % (\n                    'deleted'\n                    if not tgt and move else\n                    'moved'\n                    if move else\n                    'copied'\n                ),\n                more=dict(src=src, tgt=tgt)\n            )"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef backup_location(src, loc=None):\n    '''\n    Writes Backups of locations\n\n    :param src:\n        The source file/folder to backup\n    :param loc:\n        The target folder to backup into\n\n        The backup will be called `src` + :func:`util.system.get_timestamp`.\n        * If `loc` left to none, the backup gets written in the same \\\n        folder like `src` resides in\n\n        * Otherwise the specified path will be used.\n    '''\n\n    from photon.util.system import get_timestamp\n\n    src = _path.realpath(src)\n    if not loc or not loc.startswith(_sep):\n        loc = _path.dirname(src)\n\n    pth = _path.join(_path.basename(src), _path.realpath(loc))\n    out = '%s_backup_%s' % (_path.basename(src), get_timestamp())\n\n    change_location(src, search_location(out, create_in=pth))", "response": "Writes a backup of the specified location into the specified location."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef make_path(*args):\n    paths = unpack_args(*args)\n    return os.path.abspath(os.path.join(*[p for p in paths if p is not None]))", "response": "Make a path from a list of arguments."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef generate(command,\n             name,\n             init_system,\n             overwrite,\n             deploy,\n             start,\n             verbose,\n             **params):\n    \"\"\"Create a service.\n\n    `COMMAND` is the path to the executable to run\n    \"\"\"\n    # TODO: Add a `prefix` flag which can be used to prefix\n    # `COMMAND` with `su -c`, etc..\n    try:\n        Serv(init_system, verbose=verbose).generate(\n            command, name, overwrite, deploy, start, **params)\n    except ServError as ex:\n        sys.exit(ex)", "response": "Generate a new service."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef status(name, init_system, verbose):\n    try:\n        status = Serv(init_system, verbose=verbose).status(name)\n    except ServError as ex:\n        sys.exit(ex)\n    click.echo(json.dumps(status, indent=4, sort_keys=True))", "response": "Get the status of a single object."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nstarting a service on the specified name", "response": "def start(name, init_system, verbose):\n    \"\"\"Start a service\n    \"\"\"\n    try:\n        Serv(init_system, verbose=verbose).start(name)\n    except ServError as ex:\n        sys.exit(ex)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nparse the environment variables in a service environment.", "response": "def _parse_service_env_vars(self, env_vars):\n        \"\"\"Return a dict based on `key=value` pair strings.\n        \"\"\"\n        env = {}\n        for var in env_vars:\n            # Yeah yeah.. it's less performant.. splitting twice.. who cares.\n            k, v = var.split('=')\n            env.update({k: v})\n        return env"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _set_service_name_from_command(self, cmd):\n        # TODO: Consider assign incremental integers to the name if a service\n        # with the same name already exists.\n        name = os.path.basename(cmd)\n        logger.info(\n            'Service name not supplied. Assigning name according to '\n            'executable: %s', name)\n        return name", "response": "Set the name of a service according to the command."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef generate(self,\n                 cmd,\n                 name='',\n                 overwrite=False,\n                 deploy=False,\n                 start=False,\n                 **params):\n        \"\"\"Generate service files and returns a list of the generated files.\n\n        It will generate configuration file(s) for the service and\n        deploy them to the tmp dir on your os.\n\n        If `deploy` is True, the service will be configured to run on the\n        current machine.\n        If `start` is True, the service will be started as well.\n        \"\"\"\n        # TODO: parsing env vars and setting the name should probably be under\n        # `base.py`.\n        name = name or self._set_service_name_from_command(cmd)\n        self.params.update(**params)\n        self.params.update(dict(\n            cmd=cmd,\n            name=name,\n            env=self._parse_service_env_vars(params.get('var', '')))\n        )\n        if 'var' in params:\n            self.params.pop('var')\n        init = self.implementation(logger=logger, **self.params)\n\n        logger.info(\n            'Generating %s files for service %s...',\n            self.init_system, name)\n        files = init.generate(overwrite=overwrite)\n        for f in files:\n            logger.info('Generated %s', f)\n\n        if deploy or start:\n            init.validate_platform()\n            logger.info('Deploying %s service %s...', self.init_system, name)\n            init.install()\n\n            if start:\n                logger.info(\n                    'Starting %s service %s...',\n                    self.init_system, name)\n                init.start()\n            logger.info('Service created')\n        return files", "response": "Generate the service files and return a list of the generated files."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nremoves a service completely.", "response": "def remove(self, name):\n        \"\"\"Remove a service completely.\n\n        It will try to stop the service and then uninstall it.\n        The implementation is, of course, system specific.\n        For instance, for upstart, it will `stop <name` and then\n        delete /etc/init/<name>.conf.\n        \"\"\"\n        init = self._get_implementation(name)\n        self._assert_service_installed(init, name)\n        logger.info('Removing %s service %s...', self.init_system, name)\n        init.stop()\n        init.uninstall()\n        logger.info('Service removed')"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a list containing a single service s info. If name is supplied returns a list containing a single service s info. Otherwise returns a list of all services info.", "response": "def status(self, name=''):\n        \"\"\"Return a list containing a single service's info if `name`\n        is supplied, else returns a list of all services' info.\n        \"\"\"\n        logger.warn(\n            'Note that `status` is currently not so robust and may break on '\n            'different systems')\n        init = self._get_implementation(name)\n        if name:\n            self._assert_service_installed(init, name)\n        logger.info('Retrieving status...')\n        return init.status(name)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nstop a service by name.", "response": "def stop(self, name):\n        \"\"\"Stop a service\n        \"\"\"\n        init = self._get_implementation(name)\n        self._assert_service_installed(init, name)\n        logger.info('Stopping service: %s...', name)\n        init.stop()"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nstarts a service with the given name.", "response": "def start(self, name):\n        \"\"\"Start a service\n        \"\"\"\n        init = self._get_implementation(name)\n        self._assert_service_installed(init, name)\n        logger.info('Starting service: %s...', name)\n        init.start()"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nrestarts a service by name.", "response": "def restart(self, name):\n        \"\"\"Restart a service\n        \"\"\"\n        init = self._get_implementation(name)\n        self._assert_service_installed(init, name)\n        logger.info('Restarting service: %s...', name)\n        init.stop()\n        # Here we would use status to verify that the service stopped\n        # before restarting. If only status was stable. eh..\n        # The arbitrarity of this sleep time is making me sick...\n        time.sleep(3)\n        init.start()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef lookup_init_systems(self):\n        if utils.IS_WIN:\n            logger.debug(\n                'Lookup is not supported on Windows. Assuming nssm...')\n            return ['nssm']\n        if utils.IS_DARWIN:\n            logger.debug(\n                'Lookup is not supported on OS X, Assuming launchd...')\n            return ['launchd']\n\n        logger.debug('Looking up init method...')\n        return self._lookup_by_mapping() \\\n            or self._init_sys_auto_lookup()", "response": "Return the relevant init system and its version."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a list of tuples of available init systems on the current machine.", "response": "def _init_sys_auto_lookup(self):\n        \"\"\"Return a list of tuples of available init systems on the\n        current machine.\n\n        Note that in some situations (Ubuntu 14.04 for instance) more than\n        one init system can be found.\n        \"\"\"\n        # TODO: Instead, check for executables for systemd and upstart\n        # systemctl for systemd and initctl for upstart.\n        # An alternative might be to check the second answer here:\n        # http://unix.stackexchange.com/questions/196166/how-to-find-out-if-a-system-uses-sysv-upstart-or-systemd-initsystem\n        # TODO: Move to each system's implementation\n        init_systems = []\n        if self._is_init_system_installed('/usr/lib/systemd'):\n            init_systems.append('systemd')\n        if self._is_init_system_installed('/usr/share/upstart'):\n            init_systems.append('upstart')\n        if self._is_init_system_installed('/etc/init.d'):\n            init_systems.append('sysv')\n        return init_systems"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _lookup_by_mapping():\n        like = distro.like().lower()\n        distribution_id = distro.id().lower()\n        version = distro.major_version()\n        if 'arch' in (distribution_id, like):\n            version = 'any'\n        init_sys = constants.DIST_TO_INITSYS.get(\n            distribution_id, constants.DIST_TO_INITSYS.get(like))\n        if init_sys:\n            system = init_sys.get(version)\n            return [system] if system else []", "response": "Return a list of init system objects based on a constant mapping of distribution + version to init system."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns all files under file_or_directory.", "response": "def all_files(file_or_directory):\n    'return all files under file_or_directory.'\n    if os.path.isdir(file_or_directory):\n        return [os.path.join(dirname, filename)\n                for dirname, dirnames, filenames in os.walk(file_or_directory)\n                for filename in filenames]\n    else:\n        return [file_or_directory]"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef super_glob(pattern):\n    'glob that understands **/ for all sub-directories recursively.'\n    pieces = pattern.split('/')\n    if '**' in pieces:\n        prefix = '/'.join(pieces[:pieces.index('**')])\n        postfix = '/'.join(pieces[pieces.index('**') + 1:])\n        roots = [dirname\n                 for dirname, dirnames, filenames in os.walk(prefix)]\n        patterns = [root + '/' + postfix for root in roots]\n    else:\n        patterns = ['/'.join(pieces)]\n    return chain.from_iterable(glob(pattern) for pattern in patterns)", "response": "glob that understands **/ for all sub - directories recursively."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add_context(request):\n    # Whether the user has president privileges\n    try:\n        PRESIDENT = Manager.objects.filter(\n            incumbent__user=request.user,\n            president=True,\n        ).count() > 0\n    except TypeError:\n        PRESIDENT = False\n\n    # If the user is logged in as an anymous user\n    if request.user.username == ANONYMOUS_USERNAME:\n        request.session[\"ANONYMOUS_SESSION\"] = True\n\n    ANONYMOUS_SESSION = request.session.get(\"ANONYMOUS_SESSION\", False)\n\n    # A list with items of form (RequestType, number_of_open_requests)\n    request_types = list()\n    if request.user.is_authenticated():\n        for request_type in RequestType.objects.filter(enabled=True):\n            requests = Request.objects.filter(\n                request_type=request_type,\n                status=Request.OPEN,\n            )\n            if not request_type.managers.filter(incumbent__user=request.user):\n                requests = requests.exclude(\n                    ~Q(owner__user=request.user),\n                    private=True,\n                )\n            request_types.append((request_type, requests.count()))\n\n    profile_requests_count = ProfileRequest.objects.all().count()\n    admin_unread_count = profile_requests_count\n\n    return {\n        \"REQUEST_TYPES\": request_types,\n        \"HOUSE\": settings.HOUSE_NAME,\n        \"ANONYMOUS_USERNAME\": ANONYMOUS_USERNAME,\n        \"SHORT_HOUSE\": settings.SHORT_HOUSE_NAME,\n        \"ADMIN\": settings.ADMINS[0],\n        \"NUM_OF_PROFILE_REQUESTS\": profile_requests_count,\n        \"ADMIN_UNREAD_COUNT\": admin_unread_count,\n        \"ANONYMOUS_SESSION\": ANONYMOUS_SESSION,\n        \"PRESIDENT\": PRESIDENT,\n    }", "response": "Add variables to all dictionaries passed to templates."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef my_profile_view(request):\n    ''' The view of the profile page. '''\n    page_name = \"Profile Page\"\n    if request.user.username == ANONYMOUS_USERNAME:\n        return red_home(request, MESSAGES['SPINELESS'])\n    userProfile = UserProfile.objects.get(user=request.user)\n    change_password_form = PasswordChangeForm(\n        request.user,\n        request.POST if \"submit_password_form\" in request.POST else None,\n        )\n    update_email_form = UpdateEmailForm(\n        request.POST if \"submit_profile_form\" in request.POST else None,\n        instance=request.user,\n        prefix=\"user\",\n        )\n    update_profile_form = UpdateProfileForm(\n        request.POST if \"submit_profile_form\" in request.POST else None,\n        instance=userProfile,\n        prefix=\"profile\",\n        )\n    if change_password_form.is_valid():\n        change_password_form.save()\n        messages.add_message(request, messages.SUCCESS,\n                             \"Your password was successfully changed.\")\n        return HttpResponseRedirect(reverse('my_profile'))\n    if update_email_form.is_valid() and update_profile_form.is_valid():\n        update_email_form.save()\n        update_profile_form.save()\n        messages.add_message(request, messages.SUCCESS,\n                             \"Your profile has been successfully updated.\")\n        return HttpResponseRedirect(reverse('my_profile'))\n    return render_to_response('my_profile.html', {\n        'page_name': page_name,\n        \"update_email_form\": update_email_form,\n        'update_profile_form': update_profile_form,\n        'change_password_form': change_password_form,\n        }, context_instance=RequestContext(request))", "response": "The view of the profile page."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef notifications_view(request):\n    page_name = \"Your Notifications\"\n    # Copy the notifications so that they are still unread when we render the page\n    notifications = list(request.user.notifications.all())\n    request.user.notifications.mark_all_as_read()\n    return render_to_response(\"list_notifications.html\", {\n        \"page_name\": page_name,\n        \"notifications\": notifications,\n        }, context_instance=RequestContext(request))", "response": "Show a user their notifications."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef member_profile_view(request, targetUsername):\n    ''' View a member's Profile. '''\n    if targetUsername == request.user.username and targetUsername != ANONYMOUS_USERNAME:\n        return HttpResponseRedirect(reverse('my_profile'))\n    page_name = \"{0}'s Profile\".format(targetUsername)\n    targetUser = get_object_or_404(User, username=targetUsername)\n    targetProfile = get_object_or_404(UserProfile, user=targetUser)\n    number_of_threads = Thread.objects.filter(owner=targetProfile).count()\n    number_of_messages = Message.objects.filter(owner=targetProfile).count()\n    number_of_requests = Request.objects.filter(owner=targetProfile).count()\n    rooms = Room.objects.filter(current_residents=targetProfile)\n    prev_rooms = PreviousResident.objects.filter(resident=targetProfile)\n    return render_to_response('member_profile.html', {\n        'page_name': page_name,\n        'targetUser': targetUser,\n        'targetProfile': targetProfile,\n        'number_of_threads': number_of_threads,\n        'number_of_messages': number_of_messages,\n        'number_of_requests': number_of_requests,\n        \"rooms\": rooms,\n        \"prev_rooms\": prev_rooms,\n        }, context_instance=RequestContext(request))", "response": "View a member s Profile."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef request_profile_view(request):\n    ''' The page to request a user profile on the site. '''\n    page_name = \"Profile Request Page\"\n    redirect_to = request.GET.get('next', reverse('homepage'))\n    if request.user.is_authenticated() and request.user.username != ANONYMOUS_USERNAME:\n        return HttpResponseRedirect(redirect_to)\n    form = ProfileRequestForm(\n        request.POST or None,\n        )\n    if form.is_valid():\n        username = form.cleaned_data['username']\n        first_name = form.cleaned_data['first_name']\n        last_name = form.cleaned_data['last_name']\n        email = form.cleaned_data['email']\n        if User.objects.filter(username=username).count():\n            reset_url = request.build_absolute_uri(reverse('reset_pw'))\n            form_add_error(form, 'username',\n                           MESSAGES[\"USERNAME_TAKEN\"].format(username=username))\n            messages.add_message(request, messages.INFO,\n                                 MESSAGES['RESET_MESSAGE'].format(reset_url=reset_url))\n        elif User.objects.filter(email=email).count():\n            reset_url = request.build_absolute_uri(reverse('reset_pw'))\n            messages.add_message(request, messages.INFO,\n                                 MESSAGES['RESET_MESSAGE'].format(reset_url=reset_url))\n            form_add_error(form, \"email\", MESSAGES[\"EMAIL_TAKEN\"])\n        elif ProfileRequest.objects.filter(first_name=first_name, last_name=last_name).count():\n            form_add_error(\n                form, '__all__',\n                MESSAGES[\"PROFILE_TAKEN\"].format(first_name=first_name,\n                                                 last_name=last_name))\n        elif User.objects.filter(first_name=first_name, last_name=last_name).count():\n            reset_url = request.build_absolute_uri(reverse('reset_pw'))\n            messages.add_message(request, messages.INFO, MESSAGES['PROFILE_REQUEST_RESET'].format(reset_url=reset_url))\n        else:\n            form.save()\n            messages.add_message(request, messages.SUCCESS, MESSAGES['PROFILE_SUBMITTED'])\n            if settings.SEND_EMAILS and (email not in settings.EMAIL_BLACKLIST):\n                submission_subject = SUBMISSION_SUBJECT.format(house=settings.HOUSE_NAME)\n                submission_email = SUBMISSION_EMAIL.format(house=settings.HOUSE_NAME, full_name=first_name + \" \" + last_name, admin_name=settings.ADMINS[0][0],\n                    admin_email=settings.ADMINS[0][1])\n                try:\n                    send_mail(submission_subject, submission_email, settings.EMAIL_HOST_USER, [email], fail_silently=False)\n                    # Add logging here\n                except SMTPException:\n                    pass # Add logging here\n            return HttpResponseRedirect(redirect_to)\n    return render(request, 'request_profile.html', {\n        'form': form,\n        'page_name': page_name,\n        'oauth_providers': _get_oauth_providers(),\n        'redirect_to': redirect_to,\n        })", "response": "The page to request a user profile on the site."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef custom_modify_user_view(request, targetUsername):\n    ''' The page to modify a user. '''\n    if targetUsername == ANONYMOUS_USERNAME:\n        messages.add_message(request, messages.WARNING, MESSAGES['ANONYMOUS_EDIT'])\n    page_name = \"Admin - Modify User\"\n    targetUser = get_object_or_404(User, username=targetUsername)\n    targetProfile = get_object_or_404(UserProfile, user=targetUser)\n\n    update_user_form = UpdateUserForm(\n        request.POST if \"update_user_profile\" in request.POST else None,\n        instance=targetUser,\n        profile = UserProfile.objects.get(user=request.user),\n        prefix=\"user\",\n        )\n    update_profile_form = FullProfileForm(\n        request.POST if \"update_user_profile\" in request.POST else None,\n        instance=targetProfile,\n        prefix=\"profile\",\n        )\n    change_user_password_form = AdminPasswordChangeForm(\n        targetUser,\n        request.POST if \"change_user_password\" in request.POST else None,\n        )\n    delete_user_form = DeleteUserForm(\n        request.POST if \"delete_user\" in request.POST else None,\n        user=targetUser,\n        request=request,\n        )\n    if update_user_form.is_valid() and update_profile_form.is_valid():\n        update_user_form.save()\n        update_profile_form.save()\n        messages.add_message(\n            request, messages.SUCCESS,\n            MESSAGES['USER_PROFILE_SAVED'].format(username=targetUser.username),\n            )\n        return HttpResponseRedirect(reverse(\n            'custom_modify_user', kwargs={'targetUsername': targetUsername}\n            ))\n    if change_user_password_form.is_valid():\n        change_user_password_form.save()\n        messages.add_message(\n            request, messages.SUCCESS,\n            MESSAGES['USER_PW_CHANGED'].format(username=targetUser.username),\n            )\n        return HttpResponseRedirect(reverse(\n            'custom_modify_user', kwargs={'targetUsername': targetUsername})\n            )\n    if delete_user_form.is_valid():\n        delete_user_form.save()\n        messages.add_message(\n            request, messages.SUCCESS,\n            MESSAGES['USER_DELETED'].format(username=targetUser.username),\n            )\n        return HttpResponseRedirect(reverse(\"custom_manage_users\"))\n\n    template_dict = {\n        'targetUser': targetUser,\n        'targetProfile': targetProfile,\n        'page_name': page_name,\n        'update_user_form': update_user_form,\n        'update_profile_form': update_profile_form,\n        'change_user_password_form': change_user_password_form,\n        'delete_user_form': delete_user_form,\n        }\n\n    if \"wiki\" in settings.INSTALLED_APPS:\n        from wiki.models import Revision\n        template_dict[\"revision_count\"] = \\\n          Revision.objects.filter(created_by=targetUser).count()\n\n    template_dict['thread_count'] = \\\n      Thread.objects.filter(owner=targetProfile).count()\n    template_dict['message_count'] = \\\n      Message.objects.filter(owner=targetProfile).count()\n    template_dict['request_count'] = \\\n      Request.objects.filter(owner=targetProfile).count()\n    template_dict['response_count'] = \\\n      Response.objects.filter(owner=targetProfile).count()\n    template_dict['announcement_count'] = \\\n      Announcement.objects.filter(incumbent=targetProfile).count()\n    template_dict['event_count'] = \\\n      Event.objects.filter(owner=targetProfile).count()\n\n    return render_to_response(\n        'custom_modify_user.html',\n        template_dict,\n        context_instance=RequestContext(request),\n        )", "response": "The page to modify a user."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef reset_pw_confirm_view(request, uidb64=None, token=None):\n    return password_reset_confirm(request,\n        template_name=\"reset_confirmation.html\",\n        uidb64=uidb64, token=token, post_reset_redirect=reverse('login'))", "response": "View to confirm resetting password."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef recount_view(request):\n    requests_changed = 0\n    for req in Request.objects.all():\n        recount = Response.objects.filter(request=req).count()\n        if req.number_of_responses != recount:\n            req.number_of_responses = recount\n            req.save()\n            requests_changed += 1\n    threads_changed = 0\n    for thread in Thread.objects.all():\n        recount = Message.objects.filter(thread=thread).count()\n        if thread.number_of_messages != recount:\n            thread.number_of_messages = recount\n            thread.save()\n            threads_changed += 1\n    dates_changed = 0\n    for thread in Thread.objects.all():\n        if thread.change_date != thread.message_set.latest('post_date').post_date:\n            thread.change_date = thread.message_set.latest('post_date').post_date\n            thread.save()\n            dates_changed += 1\n    messages.add_message(request, messages.SUCCESS, MESSAGES['RECOUNTED'].format(\n        requests_changed=requests_changed,\n        request_count=Request.objects.all().count(),\n        threads_changed=threads_changed,\n        thread_count=Thread.objects.all().count(),\n        dates_changed=dates_changed,\n        ))\n    return HttpResponseRedirect(reverse('utilities'))", "response": "Recount number_of_messages for all requests and number_of_responses for all threads and number_of_messages for every thread."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nview of the archives page.", "response": "def archives_view(request):\n    \"\"\" View of the archives page. \"\"\"\n    page_name = \"Archives\"\n    nodes, render_list = [], []\n    for add_context_str in settings.BASE_ARCHIVE_FUNCTIONS:\n        module, fun = add_context_str.rsplit(\".\", 1)\n        add_context_fun = getattr(import_module(module), fun)\n        # add_context should return list of (title, url icon, number)\n        node_lst, icon_list = add_context_fun(request)\n        nodes += node_lst\n        render_list += icon_list\n\n    return render_to_response('archives.html', {\n        \"page_name\": page_name,\n        \"render_list\": render_list,\n        \"nodes\": nodes,\n        }, context_instance=RequestContext(request))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a user s updates. AJAX.", "response": "def get_updates_view(request):\n    \"\"\"Return a user's updates. AJAX.\"\"\"\n    if not request.is_ajax():\n        raise Http404\n\n    if not request.user.is_authenticated():\n        return HttpResponse(json.dumps(dict()),\n                            content_type=\"application/json\")\n\n    try:\n        user_profile = UserProfile.objects.get(user=request.user)\n    except UserProfile.DoesNotExist:\n        return HttpResponse(json.dumps(dict()),\n                            content_type=\"application/json\")\n\n    response = dict()\n    if request.user.is_superuser:\n        num_of_profile_requests = ProfileRequest.objects.all().count()\n\n        if num_of_profile_requests == 0:\n            response['profile_requests_link'] = '''\n                <span class=\"glyphicon glyphicon-inbox\"></span>\n                Profile Requests\n            '''\n\n        else:\n            response['profile_requests_link'] = \"\"\"\n                <span title=\"{req_num} open profile request{mult}\"\n                    class=\"badge pull-right\">{req_num}</span>\n                <span class=\"glyphicon glyphicon-inbox\"></span>\n                Profile Requests\n            \"\"\".format(\n                req_num=num_of_profile_requests,\n                mult='s' if num_of_profile_requests > 1 else '',\n            )\n\n    notification_count = request.user.notifications.unread().count()\n\n    if notification_count == 0:\n        response['notifications_link'] = '''\n            <span class=\"glyphicon glyphicon-bell\"></span>\n            Notifications\n        '''\n\n        response['profile_dropdown_link'] = '''\n            <span><span class=\"pull-right\"><b class=\"caret\"></b></span>\n            <span class=\"glyphicon glyphicon-user\"></span>\n            {first_name}&nbsp;</span>\n        '''.format(first_name=request.user.first_name)\n\n    else:\n        response['notifications_link'] = \"\"\"\n            <span title=\"{n_num} unread notification{mult}\"\n                class=\"badge pull-right\">{n_num}</span>\n            <span class=\"glyphicon glyphicon-bell\"></span>\n            Notifications\n        \"\"\".format(\n            n_num=notification_count,\n            mult='s' if notification_count > 1 else '',\n        )\n\n        response['profile_dropdown_link'] = '''\n            <span><span class=\"pull-right\"><b class=\"caret\"></b></span><span\n            title=\"You have {n_num} unread notification{mult}.\"\n            class=\"badge pull-right\">{n_num}</span>\n            <span class=\"glyphicon glyphicon-user\"></span>\n            {first_name}&nbsp;</span>\n        '''.format(\n            n_num=notification_count,\n            mult='s' if notification_count > 1 else '',\n            first_name=request.user.first_name,\n        )\n\n    req_dict = dict()\n    for req_type in RequestType.objects.filter(enabled=True):\n        open_reqs = Request.objects.filter(request_type=req_type,\n                                          status=Request.OPEN)\n        if not req_type.managers.filter(incumbent__user=request.user):\n            open_reqs = open_reqs.exclude(\n                ~Q(owner__user=request.user), private=True,\n                )\n        num_open = open_reqs.count()\n        if num_open == 0:\n            req_dict['{rtype}_requests_link'.format(rtype=req_type.url_name)] \\\n                = \"\"\"\n                    <span class=\"glyphicon glyphicon-{icon}\"></span>\n                    {name}\n                \"\"\".format(\n                    icon=req_type.glyphicon if req_type.glyphicon else 'inbox',\n                    name=req_type.name\n                )\n\n        else:\n            req_dict['{rtype}_requests_link'.format(rtype=req_type.url_name)] \\\n                = \"\"\"\n                    <span title=\"{num} open request{mult}\"\n                        class=\"badge pull-right\">{num}</span>\n                    <span class=\"glyphicon glyphicon-{icon}\"></span>\n                    {name}\n                \"\"\".format(\n                    num=num_open,\n                    mult='s' if num_open > 1 else '',\n                    icon=req_type.glyphicon if req_type.glyphicon else 'inbox',\n                    name=req_type.name,\n                )\n\n    if req_dict.keys():\n        response['requests_dict'] = req_dict\n\n    request_pk_list = request.GET.get('request_pk_list', False)\n    if request_pk_list:\n        request_pk_list = request_pk_list.split(',')\n        for request_pk in request_pk_list:\n            try:\n                req = Request.objects.get(pk=request_pk)\n            except Request.DoesNotExist:\n                continue\n\n            response['vote_count_{pk}'.format(pk=req.pk)] = req.upvotes.all().count()\n\n            list_string = 'vote_list_{pk}'.format(pk=request_pk)\n            vote_string = 'in_votes_{pk}'.format(pk=request_pk)\n            count_string = 'vote_count_{pk}'.format(pk=request_pk)\n            response[list_string], response[vote_string], \\\n                response[count_string] = build_ajax_votes(\n                    req,\n                    user_profile\n                )\n\n    event_pk_list = request.GET.get('event_pk_list', False)\n    if event_pk_list:\n        event_pk_list = event_pk_list.split(',')\n        for event_pk in event_pk_list:\n            try:\n                event = Event.objects.get(pk=event_pk)\n            except Event.DoesNotExist:\n                continue\n\n            link_string = 'rsvp_link_{pk}'.format(pk=event.pk)\n            list_string = 'rsvp_list_{pk}'.format(pk=event.pk)\n            response[link_string], response[list_string] = build_ajax_rsvps(\n                event,\n                user_profile\n            )\n\n    thread_pk = request.GET.get('thread_pk', False)\n    if thread_pk:\n        try:\n            thread = Thread.objects.get(pk=thread_pk)\n        except Thread.DoesNotExist:\n            pass\n        else:\n            response['following'] = user_profile in thread.followers.all()\n            response['num_of_followers'] = thread.followers.all().count()\n\n    return HttpResponse(json.dumps(response),\n                        content_type=\"application/json\")"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef connect(self):\n        if self._sStatus != 'opened':\n            print \"Netconf Connection: Invalid Status, Could not connect to %s:%s\" % (self._sHost, self._uPort)\n            sys.exit()\n        # establish ssh connection\n        if self._sType == 'ssh':\n            # setup transport connection base on socket\n            self._hSsh = paramiko.Transport(self._iSock) \n            try:\n                self._hSsh.start_client()\n            except paramiko.SSHException:\n                print 'Netconf Connection: Connect negotiation failed'\n                self._iSock.close()\n                sys.exit()\n            except:\n                print 'Netconf Connection: Connect failed'\n                try:\n                    self._iSock.close()\n                except:\n                    pass\n                sys.exit()\n            # auth check\n            if self._sPswd != '':\n                try:\n                    self._hSsh.auth_password(self._sUser, self._sPswd)\n                except:\n                    print \"Netconf Connection: Auth SSH username/password fail\"\n                    self._iSock.close()\n                    sys.exit()\n            # open channel for netconf ssh subsystem\n            try:\n                self._hSshChn = self._hSsh.open_session()\n                self._hSshChn.settimeout(5)\n                self._hSshChn.set_name(\"netconf\")\n                self._hSshChn.invoke_subsystem(\"netconf\")\n                self._hSshChn.setblocking(1)\n            except:\n                print \"Netconf Connection: Open SSH Netconf SubSystem fail\"\n                self._iSock.close()\n                sys.exit()\n        else:\n            print \"Netconf Connection: Unsupport Connection Type, Could not connect to %s:%s\" % (self._sHost, self._uPort)\n            sys.exit()\n\n        self._sStatus = 'connected'\n\n        \"\"\" end of function connect \"\"\"", "response": "Establish connection to the specified object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _index_idiom(el_name, index, alt=None):\n    el_index = \"%s[%d]\" % (el_name, index)\n\n    if index == 0:\n        cond = \"%s\" % el_name\n    else:\n        cond = \"len(%s) - 1 >= %d\" % (el_name, index)\n\n    output = IND + \"# pick element from list\\n\"\n\n    return output + IND + \"%s = %s if %s else %s\\n\\n\" % (\n        el_name,\n        el_index,\n        cond,\n        repr(alt)\n    )", "response": "Generate string where el_name is indexed by index if there are enough\n            items or alt is returned."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngenerates code which make sure that tag_name has enoug items.", "response": "def _required_idiom(tag_name, index, notfoundmsg):\n    \"\"\"\n    Generate code, which make sure that `tag_name` has enoug items.\n\n    Args:\n        tag_name (str): Name of the container.\n        index (int): Index of the item you want to obtain from container.\n        notfoundmsg (str): Raise :class:`.UserWarning` with debug data and\n                           following message.\n\n    Returns:\n        str: Python code.\n    \"\"\"\n    cond = \"\"\n    if index > 0:\n        cond = \" or len(el) - 1 < %d\" % index\n\n    tag_name = str(tag_name)\n\n    output = IND + \"if not el%s:\\n\" % cond\n    output += IND + IND + \"raise UserWarning(\\n\"\n    output += IND + IND + IND + \"%s +\\n\" % repr(notfoundmsg.strip() + \"\\n\")\n    output += IND + IND + IND + repr(\"Tag name: \" + tag_name) + \" + '\\\\n' +\\n\"\n    output += IND + IND + IND + \"'El:' + str(el) + '\\\\n' +\\n\"\n    output += IND + IND + IND + \"'Dom:' + str(dom)\\n\"\n    output += IND + IND + \")\\n\\n\"\n\n    return output + IND + \"el = el[%d]\\n\\n\" % index"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ngenerate a template for the item in the node list.", "response": "def _find_template(parameters, index, required=False, notfoundmsg=None):\n    \"\"\"\n    Generate ``.find()`` call for HTMLElement.\n\n    Args:\n        parameters (list): List of parameters for ``.find()``.\n        index (int): Index of the item you want to get from ``.find()`` call.\n        required (bool, default False): Use :func:`_required_idiom` to returned\n                 data.\n        notfoundmsg (str, default None): Message which will be used for\n                    :func:`_required_idiom` if the item is not found.\n\n    Returns:\n        str: Python code.\n\n    Live example::\n        >>> print g._find_template([\"<xex>\"], 3)\n            el = dom.find('<xex>')\n            # pick element from list\n            el = el[3] if len(el) - 1 >= 3 else None\n    \"\"\"\n    output = IND + \"el = dom.find(%s)\\n\\n\" % repr(parameters)[1:-1]\n\n    if required:\n        return output + _required_idiom(parameters[0], index, notfoundmsg)\n\n    return output + _index_idiom(\"el\", index)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _wfind_template(use_dom, parameters, index, required=False,\n                                                notfoundmsg=None):\n    \"\"\"\n    Generate ``.wfind()`` call for HTMLElement.\n\n    Args:\n        use_dom (bool): Use ``dom`` as tag name. If ``False``, ``el`` is used.\n        parameters (list): List of parameters for ``.wfind()``.\n        index (int): Index of the item you want to get from ``.wfind()`` call.\n        required (bool, default False): Use :func:`_required_idiom` to returned\n                 data.\n        notfoundmsg (str, default None): Message which will be used for\n                    :func:`_required_idiom` if the item is not found.\n\n    Returns:\n        str: Python code.\n\n    Live example::\n        >>> print g._wfind_template(True, [\"<xex>\"], 3)\n            el = dom.wfind('<xex>').childs\n            # pick element from list\n            el = el[3] if len(el) - 1 >= 3 else None\n    \"\"\"\n    tag_name = \"dom\" if use_dom else \"el\"\n    output = IND + \"el = %s.wfind(%s).childs\\n\\n\" % (\n        tag_name,\n        repr(parameters)[1:-1]\n    )\n\n    if required:\n        return output + _required_idiom(parameters[0], index, notfoundmsg)\n\n    return output + _index_idiom(\"el\", index)", "response": "Generate a template for the. wfind method."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngenerating neighbour matching call for HTMLElement which returns only elements with required neighbours.", "response": "def _neigh_template(parameters, index, left=True, required=False,\n                                                  notfoundmsg=None):\n    \"\"\"\n    Generate neighbour matching call for HTMLElement, which returns only\n    elements with required neighbours.\n\n    Args:\n        parameters (list): List of parameters for ``.match()``.\n        index (int): Index of the item you want to get from ``.match()`` call.\n        left (bool, default True): Look for neigbour in the left side of el.\n        required (bool, default False): Use :func:`_required_idiom` to returned\n                 data.\n        notfoundmsg (str, default None): Message which will be used for\n                    :func:`_required_idiom` if the item is not found.\n\n    Returns:\n        str: Python code.\n    \"\"\"\n    fn_string = \"has_neigh(%s, left=%s)\" % (\n        repr(parameters.fn_params)[1:-1],\n        repr(left)\n    )\n\n    output = IND + \"el = dom.find(\\n\"\n    output += IND + IND + \"%s,\\n\" % repr(parameters.tag_name)\n\n    if parameters.params:\n        output += IND + IND + \"%s,\\n\" % repr(parameters.params)\n\n    output += IND + IND + \"fn=%s\\n\" % fn_string\n    output += IND + \")\\n\\n\"\n\n    if required:\n        return output + _required_idiom(\n            parameters.fn_params[0],\n            index,\n            notfoundmsg\n        )\n\n    return output + _index_idiom(\"el\", index)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _generate_parser(name, path, required=False, notfoundmsg=None):\n    output = \"def %s(dom):\\n\" % _get_parser_name(name)\n\n    dom = True  # used specifically in _wfind_template\n    parser_table = {\n        \"find\": lambda path:\n            _find_template(path.params, path.index, required, notfoundmsg),\n        \"wfind\": lambda path:\n            _wfind_template(\n                dom,\n                path.params,\n                path.index,\n                required,\n                notfoundmsg\n            ),\n        \"match\": lambda path:\n            _match_template(path.params, path.index, required, notfoundmsg),\n        \"left_neighbour_tag\": lambda path:\n            _neigh_template(\n                path.params,\n                path.index,\n                True,\n                required,\n                notfoundmsg\n            ),\n        \"right_neighbour_tag\": lambda path:\n            _neigh_template(\n                path.params,\n                path.index,\n                False,\n                required,\n                notfoundmsg\n            ),\n    }\n\n    if isinstance(path, path_patterns.PathCall):\n        output += parser_table[path.call_type](path)\n    elif isinstance(path, path_patterns.Chained):\n        for path in path.chain:\n            output += parser_table[path.call_type](path)\n            dom = False\n    else:\n        raise UserWarning(\n            \"Unknown type of path parameters! (%s)\" % str(path)\n        )\n\n    output += IND + \"return el\\n\"\n    output += \"\\n\\n\"\n\n    return output", "response": "Generate parser function for given path."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef generate_parsers(config, paths):\n    output = \"\"\"#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n#\n# Interpreter version: python 2.7\n#\n# HTML parser generated by Autoparser\n# (https://github.com/edeposit/edeposit.amqp.harvester)\n#\nimport os\nimport os.path\n\nimport httpkie\nimport dhtmlparser\n\n\n# Utilities\n\"\"\"\n    # add source of neighbour picking functions from utils.py\n    output += inspect.getsource(conf_reader._get_source) + \"\\n\\n\"\n    output += inspect.getsource(utils._get_encoding) + \"\\n\\n\"\n    output += inspect.getsource(utils.handle_encodnig) + \"\\n\\n\"\n    output += inspect.getsource(utils.is_equal_tag) + \"\\n\\n\"\n    output += inspect.getsource(utils.has_neigh) + \"\\n\\n\"\n    output += \"# Generated parsers\\n\"\n\n    for name, path in paths.items():\n        path = path[0]  # pick path with highest priority\n\n        required = config[0][\"vars\"][name].get(\"required\", False)\n        notfoundmsg = config[0][\"vars\"][name].get(\"notfoundmsg\", \"\")\n\n        output += _generate_parser(name, path, required, notfoundmsg)\n\n    output += \"# Unittest\\n\"\n    output += _unittest_template(config)\n\n    output += \"# Run tests of the parser\\n\"\n    output += \"if __name__ == '__main__':\\n\"\n    output += IND + \"test_parsers()\"\n\n    return output", "response": "Generate all parsers for all paths."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nload the config value from various arguments.", "response": "def load_config(path):\n    \"\"\"Load the config value from various arguments.\"\"\"\n    config = ConfigParser()\n\n    if len(config.read(path)) == 0:\n        stderr_and_exit(\"Couldn't load config {0}\\n\".format(path))\n    if not config.has_section('walls'):\n        stderr_and_exit('Config missing [walls] section.\\n')\n\n    # Print out all of the missing keys\n    keys = ['api_key', 'api_secret', 'tags', 'image_dir', 'width', 'height']\n    for key in set(keys):\n        if config.has_option('walls', key):\n            keys.remove(key)\n    if keys:\n        stderr_and_exit(\"Missing config keys: '{0}'\\n\"\n                        .format(\"', '\".join(keys)))\n\n    # Parse integer values\n    int_keys = ['width', 'height']\n    for key in set(int_keys):\n        try:\n            config.getint('walls', key)\n            int_keys.remove(key)\n        except ValueError:\n            pass\n    if int_keys:\n        stderr_and_exit(\"The following must be integers: '{0}'\\n\"\n                        .format(\"', '\".join(int_keys)))\n\n    # Check destination directory\n    path = os.path.expanduser(config.get('walls', 'image_dir'))\n    if not os.path.isdir(path):\n        stderr_and_exit('The directory {0} does not exist.\\n'\n                        .format(config.get('walls', 'image_dir')))\n\n    return config"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef clear_dir(path):\n    for f in os.listdir(path):\n        f_path = os.path.join(path, f)\n        if os.path.isfile(f_path) or os.path.islink(f_path):\n            os.unlink(f_path)", "response": "Empty out the image directory."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the url of the smallest photo above the dimensions.", "response": "def smallest_url(flickr, pid, min_width, min_height):\n    \"\"\"Return the url of the smallest photo above the dimensions.\n\n    If no such photo exists, return None.\n    \"\"\"\n    sizes = flickr.photos_getSizes(photo_id=pid, format='parsed-json')\n    smallest_url = None\n    smallest_area = None\n    for size in sizes['sizes']['size']:\n        width = int(size['width'])\n        height = int(size['height'])\n        # Enforce a minimum height and width\n        if width >= min_width and height >= min_height:\n            if not smallest_url or height * width < smallest_area:\n                smallest_area = height * width\n                smallest_url = size['source']\n    return smallest_url"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ndownloads the image to disk.", "response": "def download(url, dest):\n    \"\"\"Download the image to disk.\"\"\"\n    path = os.path.join(dest, url.split('/')[-1])\n    r = requests.get(url, stream=True)\n    r.raise_for_status()\n    with open(path, 'wb') as f:\n        for chunk in r.iter_content(chunk_size=1024):\n            if chunk:\n                f.write(chunk)\n    return path"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nfinds an image and download it.", "response": "def run(config, clear_opt=False):\n    \"\"\"Find an image and download it.\"\"\"\n    flickr = flickrapi.FlickrAPI(config.get('walls', 'api_key'),\n                                 config.get('walls', 'api_secret'))\n    width = config.getint('walls', 'width')\n    height = config.getint('walls', 'height')\n\n    # Clear out the destination dir\n    if clear_opt:\n        clear_dir(os.path.expanduser(config.get('walls', 'image_dir')))\n\n    # Find an image\n    tags = config.get('walls', 'tags')\n    for photo in flickr.walk(tags=tags, format='etree'):\n        try:\n            photo_url = smallest_url(flickr, photo.get('id'), width, height)\n            if photo_url:\n                break\n        except (KeyError, ValueError, TypeError):\n            stderr_and_exit('Unexpected data from Flickr.\\n')\n    else:\n        stderr_and_exit('No matching photos found.\\n')\n\n    # Download the image\n    dest = os.path.expanduser(config.get('walls', 'image_dir'))\n    try:\n        download(photo_url, dest)\n    except IOError:\n        stderr_and_exit('Error downloading image.\\n')"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nparses the arguments and pass the config object on to run.", "response": "def main(args=sys.argv):\n    \"\"\"Parse the arguments, and pass the config object on to run.\"\"\"\n    # Don't make changes to sys.argv\n    args = list(args)\n\n    # Remove arg[0]\n    args.pop(0)\n\n    # Pop off the options\n    clear_opt = False\n    if '-c' in args:\n        args.remove('-c')\n        clear_opt = True\n    elif '--clear' in args:\n        args.remove('--clear')\n        clear_opt = True\n\n    if len(args) == 0:\n        cfg_path = os.path.expanduser('~/.wallsrc')\n    elif len(args) == 1:\n        cfg_path = args[0]\n    else:\n        stderr_and_exit('Usage: walls [-c] [config_file]\\n')\n\n    config = load_config(cfg_path)\n\n    run(config, clear_opt)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nruns a pipeline over a generator of strings.", "response": "def run(pipeline, input_gen, options={}):\n    \"\"\" Run a pipeline over a input generator\n\n    >>> # if we have a simple component\n    >>> from reliure.pipeline import Composable\n    >>> @Composable\n    ... def print_each(letters):\n    ...     for letter in letters:\n    ...         print(letter)\n    ...         yield letter\n    >>> # that we want to run over a given input:\n    >>> input = \"abcde\"\n    >>> # we just have to do :\n    >>> res = run(print_each, input)\n    a\n    b\n    c\n    d\n    e\n    \n    it is also possible to run any reliure pipeline this way:\n    >>> import string\n    >>> pipeline = Composable(lambda letters: (l.upper() for l in letters)) | print_each\n    >>> res = run(pipeline, input)\n    A\n    B\n    C\n    D\n    E\n    \"\"\"\n    logger = logging.getLogger(\"reliure.run\")\n    t0 = time()\n    res = [output for output in pipeline(input_gen, **options)]\n    logger.info(\"Pipeline executed in %1.3f sec\" % (time() - t0))\n    return res"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef run_parallel(pipeline, input_gen, options={}, ncpu=4, chunksize=200):\n    t0 = time()\n    #FIXME: there is a know issue when pipeline results are \"big\" object, the merge is bloking... to be investigate\n    #TODO: add get_pipeline args to prodvide a fct to build the pipeline (in each worker)\n    logger = logging.getLogger(\"reliure.run_parallel\")\n    jobs = []\n    results = []\n    Qdata = mp.JoinableQueue(ncpu*2)  # input queue\n    Qresult = mp.Queue()              # result queue\n    # ensure input_gen is realy an itertor not a list\n    if hasattr(input_gen, \"__len__\"):\n        input_gen = iter(input_gen)\n    for wnum in range(ncpu):\n        logger.debug(\"create worker #%s\" % wnum)\n        worker = mp.Process(target=_reliure_worker, args=(wnum, Qdata, Qresult, pipeline, options))\n        worker.start()\n        jobs.append(worker)\n    while True:\n        # consume chunksize elements from input_gen\n        chunk = tuple(islice(input_gen, chunksize))\n        if not len(chunk):\n            break\n        logger.info(\"send a chunk of %s elemets to a worker\" % len(chunk))\n        Qdata.put(chunk)\n    logger.info(\"all data has beed send to workers\")\n    # wait until all task are done\n    Qdata.join()\n    logger.debug(\"wait for workers...\")\n    for worker in jobs:\n        worker.terminate()\n    logger.debug(\"merge results\")\n    try:\n        while not Qresult.empty():\n            logger.debug(\"result queue still have %d elements\" % Qresult.qsize())\n            res = Qresult.get_nowait()\n            results.append(res)\n    except mp.Queue.Empty:\n        logger.debug(\"result queue is empty\")\n        pass\n    logger.info(\"Pipeline executed in %1.3f sec\" % (time() - t0))\n    return results", "response": "Run a pipeline in parallel over a list of strings."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef el_to_path_vector(el):\n    path = []\n    while el.parent:\n        path.append(el)\n        el = el.parent\n\n    return list(reversed(path + [el]))", "response": "Convert an element to vector of foregoing elements."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef common_vector_root(vec1, vec2):\n    root = []\n    for v1, v2 in zip(vec1, vec2):\n        if v1 == v2:\n            root.append(v1)\n        else:\n            return root\n\n    return root", "response": "Returns the common root of two vectors."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef find_common_root(elements):\n    if not elements:\n        raise UserWarning(\"Can't find common root - no elements suplied.\")\n\n    root_path = el_to_path_vector(elements.pop())\n\n    for el in elements:\n        el_path = el_to_path_vector(el)\n\n        root_path = common_vector_root(root_path, el_path)\n\n        if not root_path:\n            raise UserWarning(\n                \"Vectors without common root:\\n%s\" % str(el_path)\n            )\n\n    return root_path", "response": "Find root which is common for all elements."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndo a list of valid dailies and yields each result", "response": "def doDailies(usr, dailyList):\n        \"\"\" Does a list of dailies and yields each result\n        \n        Takes a list of valid dailies, initiates each one, and then proceeds\n        to play each one and yield it's resulting message. Note that the names\n        given in the list must be the same as the daily's class file. \n        \n        Parameters\n           usr (User) - User to do the dailies with\n           dailyList (list) - List of all daily names to perform\n        \"\"\"\n        # Load all supported dailies\n        dailies = []\n        for daily in Daily.__subclasses__():\n            dailies.append(daily.__name__)\n            \n        # Verify the list is accurate\n        for daily in dailyList:\n            if not daily in dailies:\n                raise invalidDaily\n                \n        for daily in Daily.__subclasses__():\n            if not daily.__name__ in dailyList: continue\n            \n            inst = daily(usr)\n            try:\n                inst.play()\n                yield daily.__name__ + \": \" + inst.getMessage()\n            except dailyAlreadyDone:\n                yield daily.__name__ + \": This daily is already done!\"\n            except parseException:\n                yield daily.__name__ + \": A serious error has occurred. Please refer to the logs.\"\n            except marrowNotAvailable:\n                yield daily.__name__ + \": Not available at this time!\"\n            except tombolaClosed:\n                yield daily.__name__ + \": Tombola is currently closed!\""}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating an AudioSegment with the data from the given file", "response": "def instantiateSong(fileName):\n    \"\"\"Create an AudioSegment with the data from the given file\"\"\"\n    ext = detectFormat(fileName)\n    if(ext == \"mp3\"):\n        return pd.AudioSegment.from_mp3(fileName)\n    elif(ext == \"wav\"):\n        return pd.AudioSegment.from_wav(fileName)\n    elif(ext == \"ogg\"):\n        return pd.AudioSegment.from_ogg(fileName)\n    elif(ext == \"flv\"):\n        return pd.AudioSegment.from_flv(fileName)\n    elif(ext == \"m4a\"):\n        return pd.AudioSegment.from_file(fileName, \"mp4\")\n    else:\n        return pd.AudioSegment.from_file(fileName, ext)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the position of silence in a song", "response": "def findGap(song):\n    \"\"\"Return the position of silence in a song\"\"\"\n    try:\n        silence = pd.silence.detect_silence(song)\n    except IOError:\n        print(\"There isn't a song there!\")\n\n    maxlength = 0\n\n    for pair in silence:\n        length = pair[1] - pair[0]\n        if length >= maxlength:\n            maxlength = length\n            gap = pair\n\n    return gap"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef splitSong(songToSplit, start1, start2):\n    print \"start1 \" + str(start1)\n    print \"start2 \" + str(start2)\n    # songs = [songToSplit[:start1+2000], songToSplit[start2-2000:]]\n    songs = [songToSplit[:start1], songToSplit[start2:]]\n    return songs", "response": "Split a song into two parts starting at start1 and ending at start2"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsaves songs to files", "response": "def saveFiles(fileName1, fileName2, songs):\n    \"\"\"Save songs to files\"\"\"\n    songs[0].export(fileName1, format=detectFormat(fileName1))\n    songs[1].export(fileName2, format=detectFormat(fileName2))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef saveFiles(fileName1, fileName2, songs, artist, album, trackNum):\n    songs[0].export(fileName1, format=detectFormat(fileName1), tags={'artist': artist, 'album': album, 'track': trackNum})\n    songs[1].export(fileName2, format=detectFormat(fileName2), tags={'artist': artist, 'album': album, 'track': str(int(trackNum) + 1)})", "response": "Save songs to files"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef trackSeek(path, artist, album, track, trackNum, fmt):\n    hiddenName = \"(Hidden Track).{}\".format(fmt)\n    trackName = track + \".{}\".format(fmt)\n    songIn = instantiateSong(path)\n    times = findGap(songIn)\n    saveFiles(trackName, hiddenName, splitSong(songIn, times[0], times[1]), artist, album, trackNum)\n    # return [path, track.rsplit('/',1)[0] +'/{}'.format(hiddenName)]\n    return [trackName, hiddenName]", "response": "Actually runs the program"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nparsing the arguments passed in via the command line", "response": "def parseArgs():\n    \"\"\"Parses arguments passed in via the command line\"\"\"\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"name\", help=\"the file you want to split\")\n    parser.add_argument(\"out1\", help=\"the name of the first file you want to output\")\n    parser.add_argument(\"out2\", help=\"the name of the second file you want to output\")\n    return parser.parse_args()"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget or create a sub resource", "response": "def _sub_resource(self, path):\n        \"\"\"\n        get or create sub resource\n        \"\"\"\n        if path not in self.resource_map:\n            self.resource_map[path] = Resource(\n                path, self.fetch, self.resource_map,\n                default_headers=self.default_headers)\n        return self.resource_map[path]"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef prepare_request(self, *args, **kw):\n        self.http_request = self.request_class(self.path, *args, **kw)", "response": "Creates a full featured HTTPRequest object"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the token from the header", "response": "def token(self):\n        \"\"\"\n        get the token\n        \"\"\"\n        header = self.default_headers.get('Authorization', '')\n        prefex = 'Bearer '\n        if header.startswith(prefex):\n            token = header[len(prefex):]\n        else:\n            token = header\n        return token"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nretrieving the caller frame extract the parameters from and fire the request", "response": "def _request(self):\n        \"\"\"\n        retrieve the caller frame, extract the parameters from\n        the caller function, find the matching function,\n        and fire the request\n        \"\"\"\n        caller_frame = inspect.getouterframes(inspect.currentframe())[1]\n        args, _, _, values = inspect.getargvalues(caller_frame[0])\n        caller_name = caller_frame[3]\n        kwargs = {arg: values[arg] for arg in args if arg != 'self'}\n        func = reduce(\n            lambda resource, name: resource.__getattr__(name),\n            self.mappings[caller_name].split('.'), self)\n        return func(**kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nlogs-in using email and password", "response": "def login(self, email, password):\n        \"\"\"\n        login using email and password\n        :param email: email address\n        :param password: password\n        \"\"\"\n        rsp = self._request()\n        self.default_headers['Authorization'] = rsp.data['token']\n        return rsp"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef listdir(dir_name, get_dirs=None, get_files=None, hide_ignored=False):\n    if get_dirs is None and get_files is None:\n        get_dirs = True\n        get_files = True\n\n    source_dir = os.path.join(settings.BASE_DIR, 'app', dir_name)\n\n    dirs = []\n\n    for dir_or_file_name in os.listdir(source_dir):\n        path = os.path.join(source_dir, dir_or_file_name)\n        if hide_ignored and dir_or_file_name.startswith('_'):\n            continue\n        is_dir = os.path.isdir(path)\n        if get_dirs and is_dir or get_files and not is_dir:\n            dirs.append(dir_or_file_name)\n\n    return dirs", "response": "Return list of all dirs and files inside given dir."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_types(obj, **kwargs):\n    max_iterable_length = kwargs.get('max_iterable_length', 100000)\n\n    it, = itertools.tee(obj, 1)\n    s = set()\n\n    too_big = False\n\n    for i, v in enumerate(it):\n        if i <= max_iterable_length:\n            s.add(type(v))\n        else:\n            too_big = True\n            break\n\n    return {\"types\": s, \"too_big\": too_big}", "response": "Get the types of an iterable."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nextract the type string from str ( type ( obj ) to remove the \"<class... bit.", "response": "def extract_type(s):\n    \"\"\"Extract the type string from str(type(obj)) to remove the \"<class...\" bit.\"\"\"\n    r = re.compile(r\"<class '(.*)'>\", re.MULTILINE | re.IGNORECASE)\n    try:\n        m = r.match(str(s)).group(1)\n    except (IndexError, AttributeError) as e:\n        m = None\n\n    return m"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nencrypts the given binary data", "response": "def encrypt_binary(self, binary, *args, **kwargs):\n        \"\"\"\n        input: bytes, output: bytes\n        \"\"\"\n        return self.encrypt(binary, *args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ninput bytes, output: bytes", "response": "def decrypt_binary(self, binary, *args, **kwargs):\n        \"\"\"\n        input: bytes, output: bytes\n        \"\"\"\n        return self.decrypt(binary, *args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef encrypt_text(self, text, *args, **kwargs):\n        b = text.encode(\"utf-8\")\n        token = self.encrypt(b, *args, **kwargs)\n        return base64.b64encode(token).decode(\"utf-8\")", "response": "Encrypt a string.\n\n        input: unicode str, output: unicode str"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef decrypt_text(self, text, *args, **kwargs):\n        b = text.encode(\"utf-8\")\n        token = base64.b64decode(b)\n        return self.decrypt(token, *args, **kwargs).decode(\"utf-8\")", "response": "Decrypt a string.\n\n        input: unicode str, output: unicode str"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nprints a message to stdout.", "response": "def _show(self, message, indent=0, enable_verbose=True):  # pragma: no cover\n        \"\"\"Message printer.\n        \"\"\"\n        if enable_verbose:\n            print(\"    \" * indent + message)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef encrypt_file(self,\n                     path,\n                     output_path=None,\n                     overwrite=False,\n                     stream=True,\n                     enable_verbose=True,\n                     **kwargs):\n        \"\"\"\n        Encrypt a file. If output_path are not given, then try to use the\n        path with a surfix appended. The default automatical file path handling\n        is defined here :meth:`windtalker.files.get_encrypted_file_path`\n\n        :param path: path of the file you need to encrypt\n        :param output_path: encrypted file output path\n        :param overwrite: if True, then silently overwrite output file if exists\n        :param stream: if it is a very big file, stream mode can avoid using\n          too much memory\n        :param enable_verbose: boolean, trigger on/off the help information\n        \"\"\"\n        path, output_path = files.process_dst_overwrite_args(\n            src=path, dst=output_path, overwrite=overwrite,\n            src_to_dst_func=files.get_encrpyted_path,\n        )\n\n        self._show(\"Encrypt '%s' ...\" % path, enable_verbose=enable_verbose)\n        st = time.clock()\n        files.transform(path, output_path, converter=self.encrypt,\n                        overwrite=overwrite, stream=stream,\n                        chunksize=self._encrypt_chunk_size)\n        self._show(\"    Finished! Elapse %.6f seconds\" % (time.clock() - st,),\n                   enable_verbose=enable_verbose)\n\n        return output_path", "response": "Encrypt a file with the specified key."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nencrypting all files in a directory.", "response": "def encrypt_dir(self,\n                    path,\n                    output_path=None,\n                    overwrite=False,\n                    stream=True,\n                    enable_verbose=True):\n        \"\"\"\n        Encrypt everything in a directory.\n\n        :param path: path of the dir you need to encrypt\n        :param output_path: encrypted dir output path\n        :param overwrite: if True, then silently overwrite output file if exists\n        :param stream: if it is a very big file, stream mode can avoid using\n          too much memory\n        :param enable_verbose: boolean, trigger on/off the help information\n        \"\"\"\n        path, output_path = files.process_dst_overwrite_args(\n            src=path, dst=output_path, overwrite=overwrite,\n            src_to_dst_func=files.get_encrpyted_path,\n        )\n\n        self._show(\"--- Encrypt directory '%s' ---\" % path,\n                   enable_verbose=enable_verbose)\n        st = time.clock()\n        for current_dir, _, file_list in os.walk(path):\n            new_dir = current_dir.replace(path, output_path)\n            if not os.path.exists(new_dir):  # pragma: no cover\n                os.mkdir(new_dir)\n            for basename in file_list:\n                old_path = os.path.join(current_dir, basename)\n                new_path = os.path.join(new_dir, basename)\n                self.encrypt_file(old_path, new_path,\n                                  overwrite=overwrite,\n                                  stream=stream,\n                                  enable_verbose=enable_verbose)\n        self._show(\"Complete! Elapse %.6f seconds\" % (time.clock() - st,),\n                   enable_verbose=enable_verbose)\n        return output_path"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a valid ICachedItemMapper. map for schema", "response": "def schema_map(schema):\n    \"\"\"Return a valid ICachedItemMapper.map for schema\"\"\"\n    mapper = {}\n    for name in getFieldNames(schema):\n        mapper[name] = name\n    return mapper"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef from_comm(cls, pub):\n        '''\n        Convert communication namedtuple to this class.\n\n        Args:\n            pub (obj): :class:`.Archive` instance which will be converted.\n\n        Returns:\n            obj: :class:`DBArchive` instance.\n        '''\n        filename = None\n        if pub.b64_data:\n            filename = cls._save_to_unique_filename(pub)\n\n        return cls(\n            isbn=pub.isbn,\n            uuid=pub.uuid,\n            aleph_id=pub.aleph_id,\n\n            dir_pointer=filename\n        )", "response": "Convert a communication namedtuple to this class."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef to_comm(self, light_request=False):\n        '''\n        Convert `self` to :class:`.Archive`.\n\n        Returns:\n            obj: :class:`.Archive` instance.\n        '''\n        data = None\n        if not light_request:\n            tmp_fn = path_to_zip(self.dir_pointer)\n            data = read_as_base64(tmp_fn)\n            os.unlink(tmp_fn)\n\n        return Archive(\n            isbn=self.isbn,\n            uuid=self.uuid,\n            aleph_id=self.aleph_id,\n\n            b64_data=data,\n            dir_pointer=self.dir_pointer,\n        )", "response": "Convert self to Comm object."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nparses a YAML file and return the docstring.", "response": "def get_docstring(filename, verbose=False):\n    \"\"\"\n    Search for assignment of the DOCUMENTATION variable in the given file.\n    Parse that from YAML and return the YAML doc or None.\n    \"\"\"\n\n    doc = None\n\n    try:\n        # Thank you, Habbie, for this bit of code :-)\n        M = ast.parse(''.join(open(filename)))\n        for child in M.body:\n            if isinstance(child, ast.Assign):\n                if 'DOCUMENTATION' in (t.id for t in child.targets):\n                    doc = yaml.load(child.value.s)\n    except:\n        if verbose == True:\n            traceback.print_exc()\n            print \"unable to parse %s\" % filename\n    return doc"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nnormalizes params and calculate aspect.", "response": "def _normalize_params(image, width, height, crop):\n    \"\"\"\n    Normalize params and calculate aspect.\n    \"\"\"\n    if width is None and height is None:\n        raise ValueError(\"Either width or height must be set. Otherwise \"\n                         \"resizing is useless.\")\n\n    if width is None or height is None:\n        aspect = float(image.width) / float(image.height)\n\n        if crop:\n            raise ValueError(\"Cropping the image would be useless since only \"\n                             \"one dimention is give to resize along.\")\n\n        if width is None:\n            width = int(round(height * aspect))\n        else:\n            height = int(round(width / aspect))\n\n    return (width, height, crop)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _get_resized_name(image, width, height, crop, namespace):\n    path, name = os.path.split(image.name)\n    name_part = \"%s/%ix%i\" % (namespace, width, height)\n    if crop:\n        name_part += \"_cropped\"\n\n    return os.path.join(path, name_part, name)", "response": "Get the name of the resized file when assumed it exists."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _resize(image, width, height, crop):\n    ext = os.path.splitext(image.name)[1].strip(\".\")\n\n    with Image(file=image, format=ext) as b_image:\n        # Account for orientation\n        if ORIENTATION_TYPES.index(b_image.orientation) > 4:\n            # Flip\n            target_aspect = float(width) / float(height)\n            aspect = float(b_image.height) / float(b_image.width)\n        else:\n            target_aspect = float(width) / float(height)\n            aspect = float(b_image.width) / float(b_image.height)\n\n        # Fix rotation\n        b_image.auto_orient()\n\n        # Calculate target size\n        target_aspect = float(width) / float(height)\n        aspect = float(b_image.width) / float(b_image.height)\n\n        if ((target_aspect > aspect and not crop) or\n                (target_aspect <= aspect and crop)):\n            # target is wider than image, set height as maximum\n            target_height = height\n\n            # calculate width\n            # -  iw / ih = tw / th (keep aspect)\n            # => th ( iw / ih ) = tw\n            target_width = float(target_height) * aspect\n\n            if crop:\n                # calculate crop coords\n                # -  ( tw - w ) / 2\n                target_left = (float(target_width) - float(width)) / 2\n                target_left = int(round(target_left))\n                target_top = 0\n\n            # correct floating point error, and convert to int, round in the\n            # direction of the requested width\n            if width >= target_width:\n                target_width = int(math.ceil(target_width))\n            else:\n                target_width = int(math.floor(target_width))\n        else:\n            # image is wider than target, set width as maximum\n            target_width = width\n\n            # calculate height\n            # -  iw / ih = tw / th (keep aspect)\n            # => tw / ( iw / ih ) = th\n            target_height = float(target_width) / aspect\n\n            if crop:\n                # calculate crop coords\n                # -  ( th - h ) / 2\n                target_top = (float(target_height) - float(height)) / 2\n                target_top = int(round(target_top))\n                target_left = 0\n\n            # correct floating point error and convert to int\n            if height >= target_height:\n                target_height = int(math.ceil(target_height))\n            else:\n                target_height = int(math.floor(target_height))\n\n        # strip color profiles\n        b_image.strip()\n\n        # Resize\n        b_image.resize(target_width, target_height)\n\n        if crop:\n            # Crop to target\n            b_image.crop(left=target_left, top=target_top, width=width,\n                         height=height)\n\n        # Save to temporary file\n        temp_file = tempfile.TemporaryFile()\n        b_image.save(file=temp_file)\n        # Rewind the file\n        temp_file.seek(0)\n        return temp_file", "response": "Resize the image with respect to the aspect ratio."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef resize(image, width=None, height=None, crop=False):\n    # First normalize params to determine which file to get\n    width, height, crop = _normalize_params(image, width, height, crop)\n\n    try:\n        # Check the image file state for clean close\n        is_closed = image.closed\n\n        if is_closed:\n            image.open()\n\n        # Create the resized file\n        # Do resize and crop\n        resized_image = _resize(image, width, height, crop)\n    finally:\n        # Re-close if received a closed file\n        if is_closed:\n            image.close()\n\n    return ImageFile(resized_image)", "response": "Resize an image and return the resized file."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef resize_lazy(image, width=None, height=None, crop=False, force=False,\n                namespace=\"resized\", storage=default_storage,\n                as_url=False):\n    \"\"\"\n    Returns the name of the resized file. Returns the url if as_url is True\n    \"\"\"\n    # First normalize params to determine which file to get\n    width, height, crop = _normalize_params(image, width, height, crop)\n    # Fetch the name of the resized image so i can test it if exists\n    name = _get_resized_name(image, width, height, crop, namespace)\n\n    # Fetch storage if an image has a specific storage\n    try:\n        storage = image.storage\n    except AttributeError:\n        pass\n\n    # Test if exists or force\n    if force or not storage.exists(name):\n        resized_image = None\n        try:\n            resized_image = resize(image, width, height, crop)\n            name = storage.save(name, resized_image)\n        finally:\n            if resized_image is not None:\n                resized_image.close()\n\n    if as_url:\n        return storage.url(name)\n\n    return name", "response": "Resizes an image and returns the name of the resized file."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef resized(*args, **kwargs):\n    resized_image = None\n    try:\n        resized_image = resize(*args, **kwargs)\n        yield resized_image\n    finally:\n        if resized_image is not None:\n            resized_image.close()", "response": "A context manager that closes the file and resizes the image."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the conesearch object", "response": "def get(self):\n        \"\"\"\n        *get the conesearch object*\n\n        **Return:**\n            - ``conesearch``\n\n        .. todo::\n\n            - @review: when complete, clean get method\n            - @review: when complete add logging\n        \"\"\"\n        self.log.info('starting the ``get`` method')\n\n        # SEARCH NED WITH SINGLE CONESEARCHES TO RETURN LIST OF MATCHED NAMES\n        names, searchParams = self.get_crossmatch_names(\n            listOfCoordinates=self.listOfCoordinates,\n            radiusArcsec=self.arcsec\n        )\n\n        # NOW PERFORM A NAME SEARCH AGAINST THE MATCHED NAMES\n        search = namesearch.namesearch(\n            log=self.log,\n            names=names,\n            quiet=False,\n            searchParams=searchParams,\n            verbose=self.verbose,\n            outputFilePath=self.outputFilePath\n        )\n        search.get()\n\n        self.log.info('completed the ``get`` method')\n        return conesearch"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _get_ned_query_url(\n            self,\n            raDeg,\n            decDeg,\n            arcsec):\n        \"\"\"\n        *single ned conesearch*\n\n        **Key Arguments:**\n            # -\n\n        **Return:**\n            - None\n\n        .. todo::\n\n            - @review: when complete, clean _get_ned_query_url method\n            - @review: when complete add logging\n        \"\"\"\n        self.log.info('starting the ``_get_ned_query_url`` method')\n\n        radArcMin = float(arcsec) / (60.)\n\n        if self.redshift == True:\n            z_constraint = \"Available\"\n        else:\n            z_constraint = \"Unconstrained\"\n\n        url = \"http://ned.ipac.caltech.edu/cgi-bin/objsearch\"\n        params = {\n            \"in_csys\": \"Equatorial\",\n            \"in_equinox\": \"J2000.0\",\n            \"lon\": \"%(raDeg)0.6fd\" % locals(),\n            \"lat\": \"%(decDeg)0.6fd\" % locals(),\n            \"radius\": \"%(radArcMin)0.6s\" % locals(),\n            \"hconst\": \"73\",\n            \"omegam\": \"0.27\",\n            \"omegav\": \"0.73\",\n            \"corr_z\": \"1\",\n            \"z_constraint\": z_constraint,\n            \"z_value1\": \"\",\n            \"z_value2\": \"\",\n            \"z_unit\": \"z\",\n            \"ot_include\": \"ANY\",\n            \"nmp_op\": \"ANY\",\n            \"out_csys\": \"Equatorial\",\n            \"out_equinox\": \"J2000.0\",\n            \"obj_sort\": \"Distance to search center\",\n            \"of\": \"ascii_bar\",\n            \"zv_breaker\": \"30000.0\",\n            \"list_limit\": \"500\",\n            \"img_stamp\": \"NO\",\n            \"search_type\": \"Near Position Search\",\n\n        }\n\n        url = url + \"?\" + urllib.urlencode(params)\n        if not self.unclassified:\n            url = url + \"&\" + urllib.urlencode({\"ot_include\": \"ANY\"})\n            in_objtypes1 = [\"Galaxies\", \"GPairs\", \"GTriples\", \"GGroups\",\n                            \"GClusters\", \"QSO\", \"QSOGroups\", \"GravLens\", \"AbsLineSys\", \"EmissnLine\"]\n            for o in in_objtypes1:\n                url = url + \"&\" + urllib.urlencode({\"in_objtypes1\": o})\n            in_objtypes3 = [\"Supernovae\", \"HIIregion\", \"PN\", \"SNR\", \"StarAssoc\", \"StarClust\", \"MolCloud\", \"Nova\", \"VarStar\", \"WolfRayet\",\n                            \"CarbonStar\", \"PofG\", \"Other\", \"Star\", \"BlueStar\", \"RedStar\", \"Pulsar\", \"ReflNeb\", \"DblStar\", \"EmissnObj\", \"EmissnNeb\", \"WhiteDwarf\"]\n            for o in in_objtypes3:\n                url = url + \"&\" + urllib.urlencode({\"in_objtypes3\": o})\n\n        self.log.info('completed the ``_get_ned_query_url`` method')\n        return url", "response": "get the url of the ned conesearch object for a single ned conearch"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the cross - match names for a set of coordinates", "response": "def get_crossmatch_names(\n            self,\n            listOfCoordinates=False,\n            radiusArcsec=False):\n        \"\"\"\n        *get corssmatch names*\n\n        **Key Arguments:**\n            - ``listOfCoordinates`` -- list of the coordinates to conesearch\n            - ``radiusArcsec`` -- the search radius\n\n        **Return:**\n            - None\n\n        .. todo::\n\n            - @review: when complete, clean get_crossmatch_names method\n            - @review: when complete add logging\n        \"\"\"\n        self.log.info('starting the ``get_crossmatch_names`` method')\n\n        if listOfCoordinates == False:\n            listOfCoordinates = self.listOfCoordinates\n        if radiusArcsec == False:\n            radiusArcsec = self.arcsec\n\n        names = []\n        searchParams = []\n        nedUrls = []\n        for i, coord in enumerate(listOfCoordinates):\n            url = self._get_ned_query_url(\n                raDeg=coord[0],\n                decDeg=coord[1],\n                arcsec=radiusArcsec\n            )\n            nedUrls.append(url)\n\n        count = len(nedUrls)\n        if count:\n            print \"%(count)s NED conesearch URLs have been built. Requesting from NED ...\" % locals()\n\n        localUrls = multiobject_download(\n            urlList=nedUrls,\n            downloadDirectory=\"/tmp\",\n            log=self.log,\n            timeStamp=True,\n            timeout=3600,\n            concurrentDownloads=10,\n            resetFilename=False,\n            credentials=False,  # { 'username' : \"...\", \"password\", \"...\" }\n            longTime=True,\n            indexFilenames=True\n        )\n\n        count = len(localUrls)\n        if count:\n            print \"%(count)s conesearch results downloaded from NED\" % locals()\n\n        for ii, nedResults in enumerate(localUrls):\n            if nedResults == None:\n                thisUrl = nedUrls[ii]\n                self.log.error(\n                    'cound not download results for NED URL: %(thisUrl)s' % locals())\n                continue\n            i = int(nedResults.split(\"/\")[-1].split(\"_\")[0])\n            results, resultLen = self._parse_the_ned_position_results(\n                ra=listOfCoordinates[i][0],\n                dec=listOfCoordinates[i][1],\n                nedResults=nedResults\n            )\n            print \"  %(resultLen)s returned from single NED conesearch\" % locals()\n            if resultLen > 45000:\n                print \" To many results returned from single NED query ... aborting!\"\n                subnames, subsearchParams = self._oversized_subqueries(\n                    coordinate=listOfCoordinates[i],\n                    radiusArcsec=radiusArcsec\n                )\n                names += subnames\n                searchParams += subsearchParams\n            else:\n                for r in results:\n                    searchParams.append(\n                        {\"searchIndex\": i + 1, \"searchRa\": r[\"searchRa\"], \"searchDec\": r[\"searchDec\"]})\n                    names.append(r[\"matchName\"])\n            os.remove(nedResults)\n\n        self.log.info('completed the ``get_crossmatch_names`` method')\n        return names, searchParams"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_package(repo_url, pkg_name, timeout=1):\n    url = repo_url + \"/packages/\" + pkg_name\n    headers = {'accept': 'application/json'}\n    resp = requests.get(url, headers=headers, timeout=timeout)\n    if resp.status_code == 404:\n        return None\n    return resp.json()", "response": "Retrieve package information from a Bower registry at repo_url.\n\n       Returns a dict of package data."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef prepare(data):\n    message = data.get(\"message\")\n    sha = data.get(\"sha\")\n    tree = data.get(\"tree\")\n    tree_sha = tree.get(\"sha\")\n    return {\"message\": message, \"sha\": sha, \"tree\": {\"sha\": tree_sha}}", "response": "Restructure/prepare data about commits for output."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_commit(profile, sha):\n    resource = \"/commits/\" + sha\n    data = api.get_request(profile, resource)\n    return prepare(data)", "response": "Fetch a commit.\n\n    Args:\n\n        profile\n            A profile generated from ``simplygithub.authentication.profile``.\n            Such profiles tell this module (i) the ``repo`` to connect to,\n            and (ii) the ``token`` to connect with.\n\n        sha\n            The SHA of the commit to fetch.\n\n    Returns:\n        A dict with data about the commit."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate a commit. Args: profile A profile generated from ``simplygithub.authentication.profile``. Such profiles tell this module (i) the ``repo`` to connect to, and (ii) the ``token`` to connect with. message The commit message to give to the commit. tree The SHA of the tree to assign to the commit. parents A list enumerating the SHAs of the new commit's parent commits. Returns: A dict with data about the commit.", "response": "def create_commit(profile, message, tree, parents):\n    \"\"\"Create a commit.\n\n    Args:\n\n        profile\n            A profile generated from ``simplygithub.authentication.profile``.\n            Such profiles tell this module (i) the ``repo`` to connect to,\n            and (ii) the ``token`` to connect with.\n\n        message\n            The commit message to give to the commit.\n\n        tree\n            The SHA of the tree to assign to the commit.\n\n        parents\n            A list enumerating the SHAs of the new commit's parent commits.\n\n    Returns:\n        A dict with data about the commit.\n\n    \"\"\"\n    resource = \"/commits\"\n    payload = {\"message\": message, \"tree\": tree, \"parents\": parents}\n    data = api.post_request(profile, resource, payload)\n    return prepare(data)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nnormalize string converts non - alpha characters removes non - whitespace characters removes hyphens and converts hyphens to hyphens.", "response": "def slugify(self, value):\n        \"\"\"\n        Normalizes string, converts to lowercase, removes non-alpha characters,\n        and converts spaces to hyphens.\n        \"\"\"\n        value = unicodedata.normalize('NFKD', value).encode('ascii', 'ignore')\n        value = unicode(re.sub('[^\\w\\s-]', '', value).strip().lower())\n        return re.sub('[-\\s]+', '-', value)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef collect_publications(self):\n        pubs = list(self.sub_publications)\n\n        for sub_tree in self.sub_trees:\n            pubs.extend(sub_tree.collect_publications())\n\n        return pubs", "response": "Recursively collect list of all publications referenced in this node and all sub - trees."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef call(self, uri, params=None, access_token=None, api_version=None, timeout=None):\n        url = self.api_endpoint + uri\n        params = params or {}\n\n        headers = {\n            'Content-Type': 'application/json', \n            'User-Agent': 'Python WePay SDK (third party)'\n        }\n        access_token = access_token or self.access_token\n        headers['Authorization'] = 'Bearer %s' % access_token\n        api_version = api_version or self.api_version\n        if not api_version is None:\n            headers['Api-Version'] = api_version\n\n        timeout = timeout or self._timeout\n        return self._post(url, params, headers, timeout)", "response": "Calls wepay. com / v2 with params and returns the JSON response as documented per API call."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a specific option specific in a config file", "response": "def get_option(option_name, section_name=\"main\", default=_sentinel, cfg_file=cfg_file):\n    \"\"\" Returns a specific option specific in a config file\n\n    Arguments:\n        option_name  -- Name of the option (example host_name)\n        section_name -- Which section of the config (default: name)\n\n    examples:\n    >>> get_option(\"some option\", default=\"default result\")\n    'default result'\n    \"\"\"\n    defaults = get_defaults()\n\n    # As a quality issue, we strictly disallow looking up an option that does not have a default\n    # value specified in the code\n    #if option_name not in defaults.get(section_name, {}) and default == _sentinel:\n    #    raise ValueError(\"There is no default value for Option %s in section %s\" % (option_name, section_name))\n\n    # If default argument was provided, we set variable my_defaults to that\n    # otherwise use the global nago defaults\n    if default != _sentinel:\n        my_defaults = {option_name: default}\n    else:\n        my_defaults = defaults.get('section_name', {})\n\n    # Lets parse our configuration file and see what we get\n    parser = get_parser(cfg_file)\n    return parser.get(section_name, option_name, vars=my_defaults)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a ConfigParser object for our cfg_file", "response": "def get_parser(cfg_file=cfg_file):\n    \"\"\" Returns a ConfigParser.ConfigParser() object for our cfg_file \"\"\"\n    if not os.path.exists(cfg_file):\n        generate_configfile(cfg_file=cfg_file, defaults=defaults)\n    config = ConfigParser.ConfigParser()\n    config.read(cfg_file)\n    return config"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nchanging an option in our configuration file", "response": "def set_option(section='main', cfg_file=cfg_file, **kwargs):\n    \"\"\" Change an option in our configuration file \"\"\"\n    parser = get_parser(cfg_file=cfg_file)\n    if section not in parser.sections():\n        parser.add_section(section)\n\n    for k, v in kwargs.items():\n        parser.set(section=section, option=k, value=v)\n\n    with open(cfg_file, 'w') as f:\n        parser.write(f)\n    return \"Done\""}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_section(section_name, cfg_file=cfg_file):\n    parser = get_parser(cfg_file=cfg_file)\n    options = parser.options(section_name)\n    result = {}\n    for option in options:\n        result[option] = parser.get(section=section_name, option=option)\n    return result", "response": "Returns a dictionary of an entire section"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _mkdir_for_config(cfg_file=cfg_file):\n    dirname, filename = os.path.split(cfg_file)\n    try:\n        os.makedirs(dirname)\n    except OSError as exc:\n        if exc.errno == errno.EEXIST and os.path.isdir(dirname):\n            pass\n        else:\n            raise", "response": "Create a directory for the config file."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nwrites a new nago. ini config file from the defaults.", "response": "def generate_configfile(cfg_file,defaults=defaults):\n    \"\"\" Write a new nago.ini config file from the defaults.\n\n    Arguments:\n        cfg_file  -- File that is written to like /etc/nago/nago.ini\n        defaults  -- Dictionary with default values to use\n    \"\"\"\n    # Create a directory if needed and write an empty file\n    _mkdir_for_config(cfg_file=cfg_file)\n    with open(cfg_file, 'w') as f:\n        f.write('')\n    for section in defaults.keys():\n        set_option(section, cfg_file=cfg_file, **defaults[section])"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef filter_factory(global_conf, **local_conf):\n    conf = global_conf.copy()\n    conf.update(local_conf)\n\n    def block_resource(app):\n        return DefaultIPPolicy(app, conf)\n    return block_resource", "response": "Returns a WSGI filter app for use with paste. deploy."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nstrip a sequence of commands.", "response": "def strip_commands(commands):\n    \"\"\" Strips a sequence of commands.\n\n    Strips down the sequence of commands by removing comments and\n    surrounding whitespace around each individual command and then\n    removing blank commands.\n\n    Parameters\n    ----------\n    commands : iterable of strings\n        Iterable of commands to strip.\n\n    Returns\n    -------\n    stripped_commands : list of str\n        The stripped commands with blank ones removed.\n\n    \"\"\"\n    # Go through each command one by one, stripping it and adding it to\n    # a growing list if it is not blank. Each command needs to be\n    # converted to an str if it is a bytes.\n    stripped_commands = []\n    for v in commands:\n        if isinstance(v, bytes):\n            v = v.decode(errors='replace')\n        v = v.split(';')[0].strip()\n        if len(v) != 0:\n            stripped_commands.append(v)\n    return stripped_commands"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef to_motor_distance(self, distance):\n        if isinstance(distance, collections.Iterable):\n            return [(x * self._distance_to_motor) for x in distance]\n        else:\n            return distance * self._distance_to_motor", "response": "Converts distance to motor units."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nconverting velocity and acceleration to motor units.", "response": "def to_motor_velocity_acceleration(self, va):\n        \"\"\" Convert velocities/accelerations to motor units.\n\n        Converts velocity/ies and/or acceleration/s to units of motor\n        pitch per second (or second squared), which is what the drive\n        requires when given move instructions.\n\n        Parameters\n        ----------\n        va : int, float, or iterable of ints and floats\n            The velocities/accelerations to convert.\n\n        Returns\n        -------\n        converted_va : float or list of floats\n            The converted velocities/accelerations.\n\n        \"\"\"\n        if isinstance(va, collections.Iterable):\n            return [(x * self._va_to_motor) for x in va]\n        else:\n            return va * self._va_to_motor"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconvert distance to units of UnitConverter.", "response": "def to_unit_distance(self, distance):\n        \"\"\" Convert distance/s to units of UnitConverter.\n\n        Converts distance/s from motor encoder counts to that of this\n        UnitConverter.\n\n        Parameters\n        ----------\n        distance : int, float, or iterable of ints and floats\n            The distance/s to convert.\n\n        Returns\n        -------\n        converted_distance : float or list of floats\n            The converted distance/s.\n\n        \"\"\"\n        if isinstance(distance, collections.Iterable):\n            return [(x / self._distance_to_motor) for x in distance]\n        else:\n            return distance / self._distance_to_motor"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef to_unit_velocity_acceleration(self, va):\n        if isinstance(va, collections.Iterable):\n            return [(x / self._va_to_motor) for x in va]\n        else:\n            return va / self._va_to_motor", "response": "Converts velocity and acceleration to units of motor\n        pitch per second or squared."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _comment_type_from_line(line):\n    regex = re.compile(r\"^{0}\".format(_ALL_COMMENT))\n    match = regex.match(line)\n    if match:\n        return \"{0} \".format(line[match.start():match.end()])\n\n    raise RuntimeError(\"Unable to find comment header for {0}\".format(line))", "response": "Return the comment type from a line."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the comment footer", "response": "def _end_comment_type_from_line(line):\n    \"\"\"Return the \"comment footer\" (eg ' */'').\n\n    This header goes after the content of a start of the\n    line in a replacement that would be at the end of a header block.\n    \"\"\"\n    regex = re.compile(r\"^{0}\".format(_FTR_COMMENT))\n    match = regex.match(line)\n    if match:\n        return \" */\"\n\n    return \"\""}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns true if line is a shebang.", "response": "def _line_is_shebang(line):\n    \"\"\"Return true if line is a shebang.\"\"\"\n    regex = re.compile(r\"^(#!|@echo off).*$\")\n    if regex.match(line):\n        return True\n\n    return False"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _filename_in_headerblock(relative_path, contents, linter_options):\n    del linter_options\n    check_index = 0\n\n    if len(contents) > 0:\n        if _line_is_shebang(contents[0]):\n            check_index = 1\n\n    if len(contents) < check_index + 1:\n        description = (\"\"\"Document cannot have less than \"\"\"\n                       \"\"\"{0} lines\"\"\").format(check_index + 1)\n        return LinterFailure(description, 1, replacement=None)\n\n    header_path = relative_path.replace(\"\\\\\", \"/\")\n    regex = re.compile(r\"^{0} \\/{1}$\".format(_HDR_COMMENT,\n                                             re.escape(header_path)))\n    if not regex.match(contents[check_index]):\n        description = (\"\"\"The filename /{0} must be the \"\"\"\n                       \"\"\"first line of the header\"\"\")\n        return LinterFailure(description.format(header_path),\n                             check_index + 1,\n                             _comment_type_from_line(contents[check_index]) +\n                             \"/{0}\\n\".format(header_path))", "response": "Check if a filename is in a header block."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _match_space_at_line(line):\n    regex = re.compile(r\"^{0}$\".format(_MDL_COMMENT))\n    return regex.match(line)", "response": "Return a re. match object if an empty comment was found on line."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _space_in_headerblock(relative_path, contents, linter_options):\n    del relative_path\n    del linter_options\n\n    check_index = 1\n\n    if len(contents) > 0:\n        if _line_is_shebang(contents[0]):\n            check_index = 2\n\n    if len(contents) < check_index + 1:\n        description = (\"\"\"Document cannot have less \"\"\"\n                       \"\"\"than {0} lines\"\"\").format(check_index + 1)\n        return LinterFailure(description, 1, replacement=None)\n\n    candidate = contents[check_index]\n\n    if not _match_space_at_line(candidate):\n        description = \"\"\"The second line must be an empty comment\"\"\"\n        return LinterFailure(description, check_index + 1,\n                             _comment_type_from_line(candidate)[:-1] + \"\\n\" +\n                             candidate)", "response": "Check for space between the filename in a header block and a description."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfinds the last line of the headerblock in contents.", "response": "def _find_last_line_index(contents):\n    \"\"\"Find the last line of the headerblock in contents.\"\"\"\n    lineno = 0\n    headerblock = re.compile(r\"^{0}.*$\".format(_ALL_COMMENT))\n\n    if not len(contents):\n        raise RuntimeError(\"\"\"File does not not have any contents\"\"\")\n\n    while headerblock.match(contents[lineno]):\n        if lineno + 1 == len(contents):\n            raise RuntimeError(\"\"\"No end of headerblock in file\"\"\")\n        lineno = lineno + 1\n\n    if lineno < 2:\n        raise RuntimeError(\"\"\"Headerblock must have at least two lines\"\"\")\n\n    return lineno - 1"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _space_before_copyright(relative_path, contents, linter_options):\n    del relative_path\n    del linter_options\n\n    last_line = _find_last_line_index(contents)\n    if not _match_space_at_line(contents[last_line - 1]):\n        comment = _comment_type_from_line(contents[last_line])[:-1]\n        description = \"\"\"The second last line must be an empty comment\"\"\"\n        return LinterFailure(description, last_line + 1,\n                             comment + \"\\n\" + contents[last_line])", "response": "Check for a space between the last line and description."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nchecking for copyright notice at end of headerblock.", "response": "def _copyright_end_of_headerblock(relative_path, contents, linter_options):\n    \"\"\"Check for copyright notice at end of headerblock.\"\"\"\n    del relative_path\n    del linter_options\n\n    lineno = _find_last_line_index(contents)\n    notice = \"See /LICENCE.md for Copyright information\"\n    regex = re.compile(r\"^{0} {1}( .*$|$)\".format(_MDL_COMMENT, notice))\n    if not regex.match(contents[lineno]):\n        description = (\"\"\"The last of the header block line must have the \"\"\"\n                       \"\"\"following notice: {0}\"\"\")\n        replacement = None\n        comment = _comment_type_from_line(contents[lineno])\n        comment_footer = _end_comment_type_from_line(contents[lineno])\n        # If the last line has the words \"Copyright\" or \"/LICENCE.md\" the\n        # user probably attempted to add a notice, but failed, so just\n        # suggest replacing the whole line\n        if re.compile(r\"^.*(Copyright|LICENCE.md).*$\").match(contents[lineno]):\n            replacement = \"{0}{1}\\n\".format(comment, notice + comment_footer)\n        # Put the copyright notice on a new line\n        else:\n            # Strip off the footer and the \\n at the end of the line.\n            repl_contents = contents[lineno][:-(len(comment_footer) + 1)]\n            replacement = \"{0}\\n{1}{2}\\n\".format(repl_contents,\n                                                 comment,\n                                                 notice + comment_footer)\n\n        return LinterFailure(description.format(notice),\n                             lineno + 1,\n                             replacement)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _no_trailing_whitespace(relative_path, contents, linter_options):\n    del relative_path\n    del linter_options\n\n    trailing_whitespace = re.compile(r\"(?<![ \\t\\r\\n])[ \\t]+$\")\n\n    for index, line in enumerate(contents):\n        for space in trailing_whitespace.finditer(line):\n            assert space.end() == len(line) - 1\n            return LinterFailure(\"Trailing whitespace\",\n                                 index + 1,\n                                 line[:space.start()] + line[space.end():])", "response": "rCheck that every file ends with a single \\ n."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\npopulate a LinterFailure object for word.", "response": "def _populate_spelling_error(word,\n                             suggestions,\n                             contents,\n                             line_offset,\n                             column_offset,\n                             message_start):\n    \"\"\"Create a LinterFailure for word.\n\n    This function takes suggestions from :suggestions: and uses it to\n    populate the message and candidate replacement. The replacement will\n    be a line in :contents:, as determined by :line_offset: and\n    :column_offset:.\n    \"\"\"\n    error_line = contents[line_offset]\n    if len(suggestions):\n        char_word_offset = (column_offset + len(word))\n        replacement = (error_line[:column_offset] +\n                       suggestions[0] +\n                       error_line[char_word_offset:])\n    else:\n        replacement = None\n\n    if len(suggestions):\n        suggestions_text = (\"\"\", perhaps you meant \"\"\" +\n                            \" \".join(suggestions))\n    else:\n        suggestions_text = \"\"\n\n    format_desc = message_start + suggestions_text\n    return LinterFailure(format_desc,\n                         line_offset + 1,\n                         replacement)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _find_spelling_errors_in_chunks(chunks,\n                                    contents,\n                                    valid_words_dictionary=None,\n                                    technical_words_dictionary=None,\n                                    user_dictionary_words=None):\n    \"\"\"For each chunk and a set of valid and technical words, find errors.\"\"\"\n    for chunk in chunks:\n        for error in spellcheck_region(chunk.data,\n                                       valid_words_dictionary,\n                                       technical_words_dictionary,\n                                       user_dictionary_words):\n            col_offset = _determine_character_offset(error.line_offset,\n                                                     error.column_offset,\n                                                     chunk.column)\n            msg = _SPELLCHECK_MESSAGES[error.error_type].format(error.word)\n            yield _populate_spelling_error(error.word,\n                                           error.suggestions,\n                                           contents,\n                                           error.line_offset +\n                                           chunk.line,\n                                           col_offset,\n                                           msg)", "response": "Yields spelling errors in a set of valid and technical words."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating Dictionary at spellchecker_cache_path with technical words.", "response": "def _create_technical_words_dictionary(spellchecker_cache_path,\n                                       relative_path,\n                                       user_words,\n                                       shadow):\n    \"\"\"Create Dictionary at spellchecker_cache_path with technical words.\"\"\"\n    technical_terms_set = (user_words |\n                           technical_words_from_shadow_contents(shadow))\n    technical_words = Dictionary(technical_terms_set,\n                                 \"technical_words_\" +\n                                 relative_path.replace(os.path.sep, \"_\"),\n                                 [os.path.realpath(relative_path)],\n                                 spellchecker_cache_path)\n    return technical_words"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconstruct a dictionary with valid and user words to be cached on disk.", "response": "def _construct_user_dictionary(global_options, tool_options):\n    \"\"\"Cause dictionary with valid and user words to be cached on disk.\"\"\"\n    del global_options\n\n    spellchecker_cache_path = tool_options.get(\"spellcheck_cache\", None)\n    valid_words_dictionary_helper.create(spellchecker_cache_path)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nremoving all values from queue_to_drain and return as list.", "response": "def _drain(queue_to_drain, sentinel=None):\n    \"\"\"Remove all values from queue_to_drain and return as list.\n\n    This uses the trick from\n    http://stackoverflow.com/questions/\n    1540822/dumping-a-multiprocessing-queue-into-a-list in order to ensure that\n    the queue is fully drained.\n    \"\"\"\n    queue_to_drain.put(sentinel)\n    queued_items = [i for i in iter(queue_to_drain.get, None)]\n    return queued_items"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _maybe_log_technical_terms(global_options, tool_options):\n    log_technical_terms_to_path = global_options.get(\"log_technical_terms_to\",\n                                                     None)\n    log_technical_terms_to_queue = tool_options.get(\"log_technical_terms_to\",\n                                                    None)\n    if log_technical_terms_to_path:\n        assert log_technical_terms_to_queue is not None\n\n        try:\n            os.makedirs(os.path.dirname(log_technical_terms_to_path))\n        except OSError as error:\n            if error.errno != errno.EEXIST:\n                raise error\n\n        if not log_technical_terms_to_queue.empty():\n            with closing(os.fdopen(os.open(log_technical_terms_to_path,\n                                           os.O_RDWR | os.O_CREAT),\n                                   \"r+\")) as terms_file:\n                # pychecker can't see through the handle returned by closing\n                # so we need to suppress these warnings.\n                terms = set(terms_file.read().splitlines())\n                new_terms = set(freduce(lambda x, y: x | y,\n                                        _drain(log_technical_terms_to_queue)))\n\n                if not terms.issuperset(new_terms):\n                    terms_file.seek(0)\n                    terms_file.truncate(0)\n                    terms_file.write(\"\\n\".join(list(terms |\n                                                    set(new_terms))))", "response": "Log technical terms as appropriate if the user requested it."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _no_spelling_errors(relative_path, contents, linter_options):\n    block_regexps = linter_options.get(\"block_regexps\", None)\n    chunks, shadow = spellcheckable_and_shadow_contents(contents,\n                                                        block_regexps)\n    cache = linter_options.get(\"spellcheck_cache\", None)\n    user_words, valid_words = valid_words_dictionary_helper.create(cache)\n    technical_words = _create_technical_words_dictionary(cache,\n                                                         relative_path,\n                                                         user_words,\n                                                         shadow)\n\n    if linter_options.get(\"log_technical_terms_to\"):\n        linter_options[\"log_technical_terms_to\"].put(technical_words.words())\n\n    return [e for e in _find_spelling_errors_in_chunks(chunks,\n                                                       contents,\n                                                       valid_words,\n                                                       technical_words,\n                                                       user_words) if e]", "response": "No spelling errors in strings comments or anything of the like."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncheck if a line contains necessary content to suppress code.", "response": "def _line_suppresses_error_code(line, code):\n    \"\"\"Check if line contains necessary content to suppress code.\n\n    A line suppresses code if it is in the format suppress(code1,code2) etc.\n    \"\"\"\n    match = re.compile(r\"suppress\\((.*)\\)\").match(line)\n    if match:\n        codes = match.group(1).split(\",\")\n        return code in codes\n\n    return False"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning true if error is suppressed by an inline suppression.", "response": "def _error_is_suppressed(error, code, contents):\n    \"\"\"Return true if error is suppressed by an inline suppression.\"\"\"\n    if len(contents) == 0:\n        return False\n\n    if error.line > 1:\n        # Check above, and then to the side for suppressions\n        above = contents[error.line - 2].split(\"#\")\n        if len(above) and _line_suppresses_error_code(above[-1].strip(),\n                                                      code):\n            return True\n\n    aside = contents[error.line - 1].split(\"#\")\n    if len(aside) and _line_suppresses_error_code(aside[-1].strip(), code):\n        return True\n\n    return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef lint(relative_path_to_file,\n         contents,\n         linter_functions,\n         **kwargs):\n    r\"\"\"Actually lints some file contents.\n\n    relative_path_to_file should contain the relative path to the file being\n    linted from the root source directory. Contents should be a raw string\n    with \\n's.\n    \"\"\"\n    lines = contents.splitlines(True)\n\n    errors = list()\n    for (code, info) in linter_functions.items():\n        error = info.function(relative_path_to_file, lines, kwargs)\n        if error:\n            if isinstance(error, list):\n                errors.extend([(code, e) for e in error])\n            else:\n                errors.append((code, error))\n\n    errors = [e for e in errors if not _error_is_suppressed(e[1], e[0], lines)]\n    return sorted(errors, key=lambda e: e[1].line)", "response": "r Actually lints some file contents."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nyield tuples of _LinterFunction matching whitelist but not blacklist.", "response": "def linter_functions_from_filters(whitelist=None,\n                                  blacklist=None):\n    \"\"\"Yield tuples of _LinterFunction matching whitelist but not blacklist.\"\"\"\n    def _keyvalue_pair_if(dictionary, condition):\n        \"\"\"Return a key-value pair in dictionary if condition matched.\"\"\"\n        return {\n            k: v for (k, v) in dictionary.items() if condition(k)\n        }\n\n    def _check_list(check_list, cond):\n        \"\"\"Return function testing against a list if the list exists.\"\"\"\n        def _check_against_list(key):\n            \"\"\"Return true if list exists and condition passes.\"\"\"\n            return cond(check_list, key) if check_list is not None else True\n\n        return _check_against_list\n\n    linter_functions = LINTER_FUNCTIONS\n    linter_functions = _keyvalue_pair_if(linter_functions,\n                                         _check_list(whitelist,\n                                                     lambda l, k: k in l))\n    linter_functions = _keyvalue_pair_if(linter_functions,\n                                         _check_list(blacklist,\n                                                     lambda l, k: k not in l))\n\n    for code, linter_function in linter_functions.items():\n        yield (code, linter_function)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _parse_arguments(arguments=None):\n    dir_hash = hashlib.sha1(os.getcwd().encode(\"utf-8\")).hexdigest()\n\n    parser = argparse.ArgumentParser(description=\"\"\"Lint for Polysquare \"\"\"\n                                     \"\"\"style guide\"\"\")\n    parser.add_argument(\"--checks\",\n                        nargs=0,\n                        action=ShowAvailableChecksAction,\n                        help=\"\"\"list available checks\"\"\")\n    parser.add_argument(\"files\",\n                        nargs=\"*\",\n                        metavar=(\"FILE\"),\n                        help=\"\"\"read FILE\"\"\",\n                        type=str)\n    parser.add_argument(\"--whitelist\",\n                        nargs=\"*\",\n                        help=\"\"\"list of checks that should only be run\"\"\",\n                        default=None)\n    parser.add_argument(\"--blacklist\",\n                        nargs=\"*\",\n                        help=\"\"\"list of checks that should never be run\"\"\",\n                        default=None)\n    parser.add_argument(\"--fix-what-you-can\",\n                        action=\"store_const\",\n                        help=\"\"\"fix errors automatically\"\"\",\n                        const=True)\n    parser.add_argument(\"--spellcheck-cache\",\n                        help=\"\"\"path to spell-checking cache file\"\"\",\n                        default=None)\n    parser.add_argument(\"--log-technical-terms-to\",\n                        help=\"\"\"path to file to log technical terms to\"\"\",\n                        default=None)\n    parser.add_argument(\"--stamp-file-path\",\n                        help=\"\"\"path to directory to store cached results\"\"\",\n                        default=os.path.join(tempfile.gettempdir(),\n                                             \"jobstamps\",\n                                             \"spellcheck_linter\",\n                                             dir_hash))\n    parser.add_argument(\"--block-regexps\",\n                        help=\"\"\"Regular expressions to exclude from \"\"\"\n                             \"\"\"all checks.\"\"\",\n                        nargs=\"*\",\n                        default=None)\n\n    return parser.parse_args(arguments)", "response": "Parse command line arguments."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _report_lint_error(error, file_path):\n    line = error[1].line\n    code = error[0]\n    description = error[1].description\n    sys.stdout.write(\"{0}:{1} [{2}] {3}\\n\".format(file_path,\n                                                  line,\n                                                  code,\n                                                  description))", "response": "Report a linter error."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _apply_replacement(error, found_file, file_lines):\n    fixed_lines = file_lines\n    fixed_lines[error[1].line - 1] = error[1].replacement\n    concatenated_fixed_lines = \"\".join(fixed_lines)\n\n    # Only fix one error at a time\n    found_file.seek(0)\n    found_file.write(concatenated_fixed_lines)\n    found_file.truncate()", "response": "Apply a single replacement."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning queue type most appropriate for runtime model.", "response": "def _obtain_queue(num_jobs):\n    \"\"\"Return queue type most appropriate for runtime model.\n\n    If we are using multiprocessing, that should be\n    multiprocessing.Manager().Queue. If we are just using a\n    single process, then use a normal queue type.\n    \"\"\"\n    if _should_use_multiprocessing(num_jobs):\n        return ReprQueue(multiprocessing.Manager().Queue())\n\n    return ReprQueue(Queue())"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef tool_options_from_global(global_options, num_jobs):\n    internal_opt = [\"whitelist\", \"blacklist\", \"fix_what_you_can\"]\n    queue_object = _obtain_queue(num_jobs)\n    translate = defaultdict(lambda: (lambda x: x),\n                            log_technical_terms_to=lambda _: queue_object)\n\n    tool_options = OrderedDict()\n\n    for key in sorted(global_options.keys()):\n        if key not in internal_opt and global_options[key] is not None:\n            tool_options[key] = translate[key](global_options[key])\n\n    return tool_options", "response": "From an argparse namespace get a dict of options for the tools."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nrunning each function in linter_functions on file_path and return a list of FileLinterFailure objects.", "response": "def _run_lint_on_file(file_path,\n                      linter_functions,\n                      tool_options,\n                      fix_what_you_can):\n    \"\"\"Run each function in linter_functions on filename.\n\n    If fix_what_you_can is specified, then the first error that has a\n    possible replacement will be automatically fixed on this file.\n    \"\"\"\n    with io.open(file_path, \"r+\", encoding=\"utf-8\") as found_file:\n        file_contents = found_file.read()\n        file_lines = file_contents.splitlines(True)\n        try:\n            errors = lint(file_path[len(os.getcwd()) + 1:],\n                          file_contents,\n                          linter_functions,\n                          **tool_options)\n        except RuntimeError as err:\n            msg = (\"\"\"RuntimeError in processing \"\"\"\n                   \"\"\"{0} - {1}\"\"\".format(file_path, str(err)))\n            errors = [(\"polysquarelinter/failure\",\n                       LinterFailure(msg, 0, None))]\n\n        if fix_what_you_can:\n            for error_index, error in enumerate(errors):\n                if error[1].replacement is not None:\n                    _apply_replacement(error, found_file, file_lines)\n                    errors[error_index] = (error[0],\n                                           LinterFailure(error[1].description +\n                                                         \" ... FIXED\",\n                                                         error[1].line,\n                                                         error[1].replacement))\n                    break\n\n        return [FileLinterFailure(file_path, e) for e in errors]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _run_lint_on_file_exceptions(file_path,\n                                 linter_functions,\n                                 tool_options,\n                                 fix_what_you_can):\n    \"\"\"Run except function in :linter_functions: on file_path.\n\n    This function calls through to _run_lint_on_file, but prints a traceback\n    for any exceptions encountered. It is intended to be used with parmap.\n    \"\"\"\n    try:\n        return _run_lint_on_file(file_path,\n                                 linter_functions,\n                                 tool_options,\n                                 fix_what_you_can)\n    except Exception as exception:\n        sys.stderr.write(\"\"\"Encountered exception \"\"\"\n                         \"\"\"when processing {}\\n\"\"\".format(file_path))\n        traceback.print_exc()\n        raise exception", "response": "Run except function in file_path."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning tuple of args and kwargs that function would be called with.", "response": "def _run_lint_on_file_stamped_args(file_path,  # suppress(too-many-arguments)\n                                   stamp_file_path,\n                                   log_technical_terms_to,\n                                   linter_functions,\n                                   tool_options,\n                                   fix_what_you_can):\n    \"\"\"Return tuple of args and kwargs that function would be called with.\"\"\"\n    dictionary_path = os.path.abspath(\"DICTIONARY\")\n    dependencies = [file_path]\n\n    if os.path.exists(dictionary_path):\n        dependencies.append(dictionary_path)\n\n    kwargs = OrderedDict()\n    kwargs[\"jobstamps_dependencies\"] = dependencies\n    kwargs[\"jobstamps_cache_output_directory\"] = stamp_file_path\n\n    if log_technical_terms_to:\n        kwargs[\"jobstamps_output_files\"] = [log_technical_terms_to]\n\n    return ((file_path,\n             linter_functions,\n             tool_options,\n             fix_what_you_can),\n            kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _run_lint_on_file_stamped(*args):\n    # We pass an empty dictionary as keyword arguments here to work\n    # around a bug in frosted, which crashes when no keyword arguments\n    # are passed\n    #\n    # suppress(E204)\n    stamp_args, stamp_kwargs = _run_lint_on_file_stamped_args(*args,\n                                                              **{})\n\n    return jobstamp.run(_run_lint_on_file_exceptions,\n                        *stamp_args,\n                        **stamp_kwargs)", "response": "Run linter functions on file_path stamping in stamp_file_path."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _ordered(generator, *args, **kwargs):\n    unordered_dict = {k: v for k, v in generator(*args, **kwargs)}\n    keys = sorted(list(dict(unordered_dict).keys()))\n    result = OrderedDict()\n    for key in keys:\n        result[key] = unordered_dict[key]\n\n    return result", "response": "Sort keys of unordered_dict and store in OrderedDict."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ntrue if a linter function would be called on any of filenames.", "response": "def _any_would_run(func, filenames, *args):\n    \"\"\"True if a linter function would be called on any of filenames.\"\"\"\n    if os.environ.get(\"_POLYSQUARE_GENERIC_FILE_LINTER_NO_STAMPING\", None):\n        return True\n\n    for filename in filenames:\n        # suppress(E204)\n        stamp_args, stamp_kwargs = _run_lint_on_file_stamped_args(filename,\n                                                                  *args,\n                                                                  **{})\n        dependency = jobstamp.out_of_date(func,\n                                          *stamp_args,\n                                          **stamp_kwargs)\n\n        if dependency:\n            return True\n\n    return False"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nputs an item into the underlying queue.", "response": "def put(self, item, block=True, timeout=None):\n        \"\"\"Put item into underlying queue.\"\"\"\n        return self._queue.put(item, block, timeout)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets an item from the underlying queue.", "response": "def get(self, block=True, timeout=None):\n        \"\"\"Get item from underlying queue.\"\"\"\n        return self._queue.get(block, timeout)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef snake_to_camel(snake_str):\n    '''\n    Convert `snake_str` from snake_case to camelCase\n    '''\n    components = snake_str.split('_')\n    if len(components) > 1:\n        camel = (components[0].lower() +\n                 ''.join(x.title() for x in components[1:]))\n        return camel\n    # Not snake_case\n    return snake_str", "response": "Convert snake_str from snake_case to camelCase\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef snake_to_pascal(snake_str):\n    '''\n    Convert `snake_str` from snake_case to PascalCase\n    '''\n    components = snake_str.split('_')\n    if len(components) > 1:\n        camel = ''.join(x.title() for x in components)\n        return camel\n    # Not snake_case\n    return snake_str", "response": "Convert snake_str from snake_case to PascalCase\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef camel_to_snake(camel_str):\n    '''\n    Convert `camel_str` from camelCase to snake_case\n    '''\n    # Attribution: https://stackoverflow.com/a/1176023/633213\n    s1 = re.sub('(.)([A-Z][a-z]+)', r'\\1_\\2', camel_str)\n    return re.sub('([a-z0-9])([A-Z])', r'\\1_\\2', s1).lower()", "response": "Convert camel_str from camelCase to snake_case"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef morph_dict(d, convert_function):\n    # Attribution: https://stackoverflow.com/a/33668421/633213\n    new = {}\n    for k, v in six.iteritems(d):\n        new_v = v\n        if isinstance(v, dict):\n            new_v = morph_dict(v, convert_function)\n        elif isinstance(v, list):\n            new_v = list()\n            for x in v:\n                new_v.append(\n                    morph_dict(x, convert_function)\n                )\n        new[convert_function(k)] = new_v\n    return new", "response": "Convert a nested dictionary from one convention to another convention."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef set_logging(cfg_obj):\n    log_status = cfg_obj['LOGGING']['ENABLE_LOGGING']\n\n    if log_status:\n        logger.disabled = False\n    elif not log_status:\n        logger.info(\n            '%s: Logging disabled per local configuration file (%s) parameters.' %\n            (inspect.stack()[0][3], cfg_obj['PROJECT']['CONFIG_PATH'])\n            )\n        logger.disabled = True\n    return log_status", "response": "Enable or disable logging per config object parameter\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef precheck():\n    cfg_path = local_config['PROJECT']['CONFIG_PATH']\n    # enable or disable logging based on config/ defaults\n    logging = set_logging(local_config)\n\n    if os.path.exists(cfg_path):\n        logger.info('%s: config_path parameter: %s' % (inspect.stack()[0][3], cfg_path))\n        logger.info(\n            '%s: Existing configuration file found. precheck pass.' %\n            (inspect.stack()[0][3]))\n        return True\n    elif not os.path.exists(cfg_path) and logging is False:\n        logger.info(\n            '%s: No pre-existing configuration file found at %s. Using defaults. Logging disabled.' %\n            (inspect.stack()[0][3], cfg_path)\n            )\n        return True\n    if logging:\n        logger.info(\n            '%s: Logging enabled per config file (%s).' %\n            (inspect.stack()[0][3], cfg_path)\n            )\n        return True\n    return False", "response": "Verify project runtime dependencies\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef main(operation, profile, auto, debug, user_name=''):\n    if user_name:\n        logger.info('user_name parameter given (%s) as surrogate' % user_name)\n    try:\n        if operation in VALID_INSTALL:\n            print(operation)\n        elif operation == 'list':\n            print(operation)\n            return True\n        elif not operation:\n            msg_accent = (Colors.BOLD + 'list' + Colors.RESET + ' | ' + Colors.BOLD + 'up' + Colors.RESET)\n            msg = \"\"\"You must provide a valid OPERATION for --operation parameter:\n\n                    --operation { \"\"\" + msg_accent + \"\"\" }\n            \"\"\"\n            stdout_message(msg)\n            logger.warning('%s: No valid operation provided. Exit' % (inspect.stack()[0][3]))\n            sys.exit(exit_codes['E_MISC']['Code'])\n        else:\n            msg = 'Unknown operation. Exit'\n            stdout_message(msg)\n            logger.warning('%s: %s' % (msg, inspect.stack()[0][3]))\n            sys.exit(exit_codes['E_MISC']['Code'])\n    except KeyError as e:\n        logger.critical(\n            '%s: Cannot find Key %s' %\n            (inspect.stack()[0][3], str(e)))\n        return False\n    except OSError as e:\n        logger.critical(\n            '%s: problem writing to file %s. Error %s' %\n            (inspect.stack()[0][3], output_file, str(e)))\n        return False\n    except Exception as e:\n        logger.critical(\n            '%s: Unknown error. Error %s' %\n            (inspect.stack()[0][3], str(e)))\n        raise e", "response": "This function is the main function for the AWSCLI CLI. It is used to renew the access keys for a specific profile in the local awscli config file."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nparse command line options", "response": "def options(parser, help_menu=False):\n    \"\"\"\n    Summary:\n        parse cli parameter options\n    Returns:\n        TYPE: argparse object, parser argument set\n    \"\"\"\n    parser.add_argument(\"-p\", \"--profile\", nargs='?', default=\"default\",\n                              required=False, help=\"type (default: %(default)s)\")\n    parser.add_argument(\"-i\", \"--install\", dest='install', default='NA', type=str, choices=VALID_INSTALL, required=False)\n    parser.add_argument(\"-a\", \"--auto\", dest='auto', action='store_true', required=False)\n    parser.add_argument(\"-c\", \"--configure\", dest='configure', action='store_true', required=False)\n    parser.add_argument(\"-d\", \"--debug\", dest='debug', action='store_true', required=False)\n    parser.add_argument(\"-V\", \"--version\", dest='version', action='store_true', required=False)\n    parser.add_argument(\"-h\", \"--help\", dest='help', action='store_true', required=False)\n    return parser.parse_args()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef option_configure(debug=False, path=None):\n    if CONFIG_SCRIPT in sys.argv[0]:\n        debug = True    # set debug mode if invoked from CONFIG_SCRIPT\n    if path is None:\n        path = local_config['PROJECT']['CONFIG_PATH']\n    if debug:\n        if os.path.isfile(path):\n            debug_mode('local_config file: ', local_config, debug, halt=True)\n        else:\n            msg = \"\"\"  Local config file does not yet exist. Run:\n\n            $ metal --configure \"\"\"\n            debug_mode(msg, {'CONFIG_PATH': path}, debug, halt=True)\n    r = configuration.init(debug, path)\n    return r", "response": "This function is used to customize the metal runtime options. It is used to customize the metal runtime options."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef chooser_menu():\n    title = TITLE + \"The\" + Colors.ORANGE + \" Metal\" + Colors.RESET + TITLE + \" Menu\" + RESET\n    menu = \"\"\"\n        ________________________________________________________________\n\n            \"\"\" + title + \"\"\"\n        ________________________________________________________________\n\n\n                ( \"\"\" + TITLE + \"a\" + RESET + \"\"\" ) :  Install RKhunter Rootkit Scanner (v1.6)\n\n                ( \"\"\" + TITLE + \"b\" + RESET + \"\"\" ) :  Install Chkrootkit Rootkit Scanner (latest)\n\n                ( \"\"\" + TITLE + \"c\" + RESET + \"\"\" ) :  Run RKhunter Scan of Local Machine\n\n                ( \"\"\" + TITLE + \"d\" + RESET + \"\"\" ) :  Run Chkrootkit Scan of Local Machine\n\n    \"\"\"\n    print(menu)\n    answer: str = input(\"\\t\\tEnter Choice [quit]:  \") or ''\n\n    if answer == 'a':\n        return rkhunter()\n\n    elif answer == 'b':\n        print('\\t\\nrun chkrootkit installer\\n')\n        return chkrootkit.main()\n\n    elif answer == 'c':\n        print('\\t\\nrun rkhunter scan of local machine\\n')\n\n    elif answer == 'd':\n        return chkrootkit_exec()\n    return True", "response": "Master jump off point to ancillary functionality"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets the logging mode", "response": "def set(self, mode, disable):\n        \"\"\" create logger object, enable or disable logging \"\"\"\n        global logger\n        try:\n            if logger:\n                if disable:\n                    logger.disabled = True\n            else:\n                if mode in ('STREAM', 'FILE'):\n                    logger = logd.getLogger(mode, __version__)\n        except Exception as e:\n            logger.exception(\n                '%s: Problem incurred during logging setup' % inspect.stack()[0][3]\n                )\n            return False\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _translate(unistr, table):\n    '''Replace characters using a table.'''\n    if type(unistr) is str:\n        try:\n            unistr = unistr.decode('utf-8')\n        # Python 3 returns AttributeError when .decode() is called on a str\n        # This means it is already unicode.\n        except AttributeError:\n            pass\n    try:\n        if type(unistr) is not unicode:\n            return unistr\n    # Python 3 returns NameError because unicode is not a type.\n    except NameError:\n        pass\n\n    chars = []\n    for c in unistr:\n        replacement = table.get(c)\n        chars.append(replacement if replacement else c)\n    return u''.join(chars)", "response": "Replace characters using a table."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns numerator / denominator.", "response": "def div(numerator, denominator):\n    '''\n    Returns numerator / denominator, but instead of a ZeroDivisionError:\n        0 / 0 = 0.\n        x / 0 = float('inf')\n    This is not mathematically correct, but often practically OK.\n\n    Args:\n        numerator (float or int)\n        denominator (float or int)\n    Returns:\n        (float)\n    Raises:\n        -\n    '''\n    try:\n        return numerator/denominator\n    except ZeroDivisionError:\n        if numerator == 0:\n            return 0.\n        elif denominator == 0:\n            return float('inf')\n#            return None\n        else:\n            return numerator/denominator"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nevaluating the conditions and returns a boolean value.", "response": "def eval_conditions(conditions=None, data={}):\n    '''\n    Evaluates conditions and returns Boolean value.\n\n    Args:\n        conditions (tuple) for the format of the tuple, see below\n        data (dict) the keys of which can be used in conditions\n    Returns:\n        (boolea)\n    Raises:\n        ValueError if an invalid operator value is specified\n        TypeError if: \n                conditions are not a 3-item tuple\n                the arguments of the condition don't have the same type\n                    e.g. ('abc', 'eq', 3)\n                if a boolean operator does not get boolean arguments\n                    e.g. (True, 'and', 15)\n\n    The format of the condition tuple is:\n        (arg1, op, arg2)\n    where:\n        arg1, arg2 can be numerical values, strings or condition tuples\n        op is a valid operator from the operator module\n    If arg is a string, and the string is a key in <data> it is treated as\n    a variable with value data[arg].\n\n    Notes:\n        * If no conditions are specified True is returned.\n        * empty or 0 values do *not* evaluate to booleans\n    '''\n#CONSIDER: implementing addition/subtraction/multiplication/division\n    if not conditions:\n        return True\n    if isinstance(conditions, str) or isinstance(conditions, unicode):\n        conditions = str2tuple(conditions)\n    if not isinstance(conditions, tuple) or not len(conditions) == 3:\n        raise TypeError('conditions must be a tuple with 3 items.')\n    arg1 = conditions[0]\n    op = conditions[1]\n    arg2 = conditions[2]\n    if arg1 in data:\n        arg1 = data[arg1]\n    elif isinstance(arg1, tuple):\n        arg1 = eval_conditions(arg1, data)\n    if arg2 in data:\n        arg2 = data[arg2]\n    elif isinstance(arg2, tuple):\n        arg2 = eval_conditions(arg2, data)\n    if op in ('lt', 'le', 'eq', 'ne', 'ge', 'gt'):\n        if not (type(arg1) in (float, int) and type(arg2) in (float,int)) and \\\n                type(arg1) != type(arg2):\n            raise TypeError('both arguments must have the same type {}, {}'.\\\n                    format(arg1, arg2))\n    elif op in ('and', 'or'):\n        if not isinstance(arg1, bool) or not isinstance(arg2, bool):\n            raise TypeError('boolean operator {} needs boolean arguments {},'\\\n                    ' {}'.format(op, arg1, arg2))\n        op += '_'\n    else:\n        raise ValueError('operator {} not supported', op)\n    return getattr(operator, op)(arg1, arg2)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef build_settings_docs(docs_path, prefix=None):\n    # String to use instead of setting value for dynamic defaults\n    dynamic = \"[dynamic]\"\n    lines = [\".. THIS DOCUMENT IS AUTO GENERATED VIA conf.py\"]\n    for name in sorted(registry.keys()):\n        if prefix and not name.startswith(prefix):\n            continue\n        setting = registry[name]\n        settings_name = \"``%s``\" % name\n        settings_label = \".. _%s:\" % name\n        setting_default = setting[\"default\"]\n        if isinstance(setting_default, str):\n            if gethostname() in setting_default or (\n                setting_default.startswith(\"/\") and\n                    os.path.exists(setting_default)):\n                setting_default = dynamic\n        if setting_default != dynamic:\n            setting_default = repr(deep_force_unicode(setting_default))\n        lines.extend([\"\", settings_label])\n        lines.extend([\"\", settings_name, \"-\" * len(settings_name)])\n        lines.extend([\"\",\n            urlize(setting[\"description\"] or \"\").replace(\n                \"<a href=\\\"\", \"`\").replace(\n                \"\\\" rel=\\\"nofollow\\\">\", \" <\").replace(\n                \"</a>\", \">`_\")])\n        if setting[\"choices\"]:\n            choices = \", \".join([\"%s: ``%s``\" % (str(v), force_text(k))\n                                 for k, v in setting[\"choices\"]])\n            lines.extend([\"\", \"Choices: %s\" % choices, \"\"])\n        lines.extend([\"\", \"Default: ``%s``\" % setting_default])\n    with open(os.path.join(docs_path, \"settings.rst\"), \"w\") as f:\n        f.write(\"\\n\".join(lines).replace(\"u'\", \"'\").replace(\"yo'\",\n            \"you'\").replace(\"&#39;\", \"'\"))", "response": "Builds the RST file for use in the settings. py file."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nbuild a Mercurial changelog from a list of Mercurial commits.", "response": "def build_changelog(docs_path, package_name=\"yacms\"):\n    \"\"\"\n    Converts Mercurial commits into a changelog in RST format.\n    \"\"\"\n\n    project_path = os.path.join(docs_path, \"..\")\n    version_file = os.path.join(package_name, \"__init__.py\")\n    version_var = \"__version__\"\n    changelog_filename = \"CHANGELOG\"\n    changelog_file = os.path.join(project_path, changelog_filename)\n    versions = OrderedDict()\n    repo = None\n    ignore = (\"AUTHORS\", \"formatting\", \"typo\", \"pep8\", \"pep 8\",\n              \"whitespace\", \"README\", \"trans\", \"print debug\",\n              \"debugging\", \"tabs\", \"style\", \"sites\", \"ignore\",\n              \"tweak\", \"cleanup\", \"minor\", \"for changeset\",\n              \".com``\", \"oops\", \"syntax\")\n    hotfixes = {\n        \"40cbc47b8d8a\": \"1.0.9\",\n        \"a25749986abc\": \"1.0.10\",\n    }\n\n    # Load the repo.\n    try:\n        from mercurial import ui, hg, error\n        from mercurial.commands import tag\n    except ImportError:\n        pass\n    else:\n        try:\n            ui = ui.ui()\n            repo = hg.repository(ui, project_path)\n        except error.RepoError:\n            return\n    if repo is None:\n        return\n\n    # Go through each changeset and assign it to the versions dict.\n    changesets = [repo.changectx(changeset) for changeset in repo.changelog]\n    for cs in sorted(changesets, reverse=True, key=_changeset_date):\n        # Check if the file with the version number is in this changeset\n        # and if it is, pull it out and assign it as a variable.\n        files = cs.files()\n        new_version = False\n        # Commit message cleanup hacks.\n        description = cs.description().decode(\"utf-8\")\n        description = description.rstrip(\".\").replace(\"\\n\", \". \")\n        while \"  \" in description:\n            description = description.replace(\"  \", \" \")\n        description = description.replace(\". . \", \". \").replace(\"...\", \",\")\n        while \"..\" in description:\n            description = description.replace(\"..\", \".\")\n        description = description.replace(\":.\", \":\").replace(\"n'. t\", \"n't\")\n        words = description.split()\n        # Format var names in commit.\n        for i, word in enumerate(words):\n            if (set(\"._\") & set(word[:-1]) and set(letters) & set(word) and\n                    \"`\" not in word and not word[0].isdigit()):\n                last = \"\"\n                if word[-1] in \",.\":\n                    last, word = word[-1], word[:-1]\n                words[i] = \"``%s``%s\" % (word, last)\n        description = \" \".join(words)\n        if version_file in files:\n            for line in cs[version_file].data().split(\"\\n\"):\n                if line.startswith(version_var):\n                    exec(line)\n                    if locals()[version_var] == \"0.1.0\":\n                        locals()[version_var] = \"1.0.0\"\n                        break\n                    versions[locals()[version_var]] = {\n                        \"changes\": [],\n                        \"date\": _changeset_date(cs).strftime(\"%b %d, %Y\")\n                    }\n                    new_version = len(files) == 1\n\n        # Tag new versions.\n        hotfix = hotfixes.get(cs.hex()[:12])\n        if hotfix or new_version:\n            if hotfix:\n                version_tag = hotfix\n            else:\n                try:\n                    version_tag = locals()[version_var]\n                except KeyError:\n                    version_tag = None\n            if version_tag and version_tag not in cs.tags():\n                try:\n                    tag(ui, repo, version_tag, rev=cs.hex())\n                    print(\"Tagging version %s\" % version_tag)\n                except:\n                    pass\n\n        # Ignore changesets that are merges, bumped the version, closed\n        # a branch, regenerated the changelog itself, contain an ignore\n        # word, or contain too few words to be meaningful.\n        merge = len(cs.parents()) > 1\n        branch_closed = len(files) == 0\n        changelog_update = changelog_filename in files\n        ignored = [w for w in ignore if w.lower() in description.lower()]\n        too_few_words = len(description.split()) <= 3\n        if (merge or new_version or branch_closed or changelog_update or\n                ignored or too_few_words):\n            continue\n        # Ensure we have a current version and if so, add this changeset's\n        # description to it.\n        version = None\n        try:\n            version = locals()[version_var]\n        except KeyError:\n            if not hotfix:\n                continue\n        user = cs.user().decode(\"utf-8\").split(\"<\")[0].strip()\n        entry = \"%s - %s\" % (description, user)\n        if hotfix or entry not in versions[version][\"changes\"]:\n            if hotfix:\n                versions[hotfix] = {\n                    \"changes\": [entry],\n                    \"date\": _changeset_date(cs).strftime(\"%b %d, %Y\"),\n                }\n            else:\n                versions[version][\"changes\"].insert(0, entry)\n\n    # Write out the changelog.\n    with open(changelog_file, \"w\") as f:\n        for version, version_info in versions.items():\n            header = \"Version %s (%s)\" % (version, version_info[\"date\"])\n            f.write(\"%s\\n\" % header)\n            f.write(\"%s\\n\" % (\"-\" * len(header)))\n            f.write(\"\\n\")\n            if version_info[\"changes\"]:\n                for change in version_info[\"changes\"]:\n                    f.write(\"  * %s\\n\" % change)\n            else:\n                f.write(\"  * No changes listed.\\n\")\n            f.write(\"\\n\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef build_modelgraph(docs_path, package_name=\"yacms\"):\n    to_path = os.path.join(docs_path, \"img\", \"graph.png\")\n    build_path = os.path.join(docs_path, \"build\", \"_images\")\n    resized_path = os.path.join(os.path.dirname(to_path), \"graph-small.png\")\n    settings = import_dotted_path(package_name +\n                                  \".project_template.project_name.settings\")\n    apps = [a.rsplit(\".\")[1] for a in settings.INSTALLED_APPS\n            if a.startswith(\"yacms.\") or a.startswith(package_name + \".\")]\n    try:\n        from django_extensions.management.commands import graph_models\n    except ImportError:\n        warn(\"Couldn't build model_graph, django_extensions not installed\")\n    else:\n        options = {\"inheritance\": True, \"outputfile\": \"graph.png\",\n                   \"layout\": \"dot\"}\n        try:\n            graph_models.Command().execute(*apps, **options)\n        except Exception as e:\n            warn(\"Couldn't build model_graph, graph_models failed on: %s\" % e)\n        else:\n            try:\n                move(\"graph.png\", to_path)\n            except OSError as e:\n                warn(\"Couldn't build model_graph, move failed on: %s\" % e)\n    # docs/img/graph.png should exist in the repo - move it to the build path.\n    try:\n        if not os.path.exists(build_path):\n            os.makedirs(build_path)\n        copyfile(to_path, os.path.join(build_path, \"graph.png\"))\n    except OSError as e:\n        warn(\"Couldn't build model_graph, copy to build failed on: %s\" % e)\n    try:\n        from PIL import Image\n        image = Image.open(to_path)\n        image.width = 800\n        image.height = image.size[1] * 800 // image.size[0]\n        image.save(resized_path, \"PNG\", quality=100)\n    except Exception as e:\n        warn(\"Couldn't build model_graph, resize failed on: %s\" % e)\n        return\n    # Copy the dashboard screenshot to the build dir too. This doesn't\n    # really belong anywhere, so we do it here since this is the only\n    # spot we deal with doc images.\n    d = \"dashboard.png\"\n    copyfile(os.path.join(docs_path, \"img\", d), os.path.join(build_path, d))", "response": "Builds a model graph for the given package name."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef build_requirements(docs_path, package_name=\"yacms\"):\n    mezz_string = \"yacms==\"\n    project_path = os.path.join(docs_path, \"..\")\n    requirements_file = os.path.join(project_path, package_name,\n                                     \"project_template\", \"requirements.txt\")\n    with open(requirements_file, \"r\") as f:\n        requirements = f.readlines()\n    with open(requirements_file, \"w\") as f:\n        f.write(\"yacms==%s\\n\" % __version__)\n        for requirement in requirements:\n            if requirement.strip() and not requirement.startswith(mezz_string):\n                f.write(requirement)", "response": "Builds the requirements file for the current version of Yacms."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nwraps a state measure process function to create analysis collections for each state in the collection.", "response": "def _wrap_measure(individual_state_measure_process, state_measure, loaded_processes): \n    \"\"\"\n    Creates a function on a state_collection, which creates analysis_collections for each state in the collection.\n    \n    Optionally sorts the collection if the state_measure has a sort_by parameter (see funtool.lib.general.sort_states for details)\n    \"\"\"\n    def wrapped_measure(state_collection,overriding_parameters=None,loggers=None):\n        if loggers == None:\n            loggers = funtool.logger.set_default_loggers()\n        if loaded_processes != None :\n            if state_measure.grouping_selectors != None:\n                for grouping_selector_name in state_measure.grouping_selectors:\n                    state_collection= funtool.state_collection.add_grouping(state_collection, grouping_selector_name, loaded_processes) \n            states= state_collection.states\n            measure_parameters= get_measure_parameters(state_measure, overriding_parameters)\n            if 'sort_by' in measure_parameters.keys():\n                states= funtool.lib.general.sort_states(states, measure_parameters['sort_by'])\n            for state_index,state in enumerate(states):\n                step_size= len(states)//20\n                if state_index % step_size == 0:\n                    loggers.status_logger.warn(\"{}: {} %\".format( datetime.datetime.now(), round((state_index/len(states) * 100 ), 1) ) )\n                analysis_collection = funtool.analysis.AnalysisCollection(state,None,{},{})\n                if state_measure.analysis_selectors != None:\n                    for analysis_selector in state_measure.analysis_selectors:\n                        analysis_collection = loaded_processes[\"analysis_selector\"][analysis_selector].process_function(analysis_collection,state_collection)\n                if analysis_collection != None:\n                    individual_state_measure_process(analysis_collection,state_collection,overriding_parameters)\n        return state_collection\n    return wrapped_measure"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef analysis_collection_and_parameter_data(state_measure_function):\n    def wrapped_function(state_measure, analysis_collection, state_collection, overriding_parameters=None):\n        measure_parameters = get_measure_parameters(state_measure, overriding_parameters)\n        measure_value= state_measure_function(analysis_collection,measure_parameters)\n        analysis_collection.state.data[state_measure.name] = measure_value\n        return analysis_collection\n    return wrapped_function", "response": "Decorator for State Measures that only require the analysis_collection and parameters\n    Saves return value to analysis_collection. state. data with the State Measure s name as the key and the state measure s parameter values as the value"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef process_flagged_blocks(self, content: str) -> str:\n        '''Replace flagged blocks either with their contents or nothing, depending on the value\n        of ``FOLIANT_FLAGS`` environment variable and ``flags`` config value.\n\n        :param content: Markdown content\n\n        :returns: Markdown content without flagged blocks\n        '''\n\n        def _sub(flagged_block):\n            options = self.get_options(flagged_block.group('options'))\n\n            required_flags = {\n                flag.lower()\n                for flag in re.split(self._flag_delimiters, options.get('flags', ''))\n                if flag\n            } | {\n                f'target:{target.lower()}'\n                for target in re.split(self._flag_delimiters, options.get('targets', ''))\n                if target\n            } | {\n                f'backend:{backend.lower()}'\n                for backend in re.split(self._flag_delimiters, options.get('backends', ''))\n                if backend\n            }\n\n            env_flags = {\n                flag.lower()\n                for flag in re.split(self._flag_delimiters, getenv(self._flags_envvar, ''))\n                if flag\n            }\n\n            config_flags = {flag.lower() for flag in self.options['flags']}\n\n            set_flags = env_flags \\\n                | config_flags \\\n                | {f'target:{self.context[\"target\"]}', f'backend:{self.context[\"backend\"]}'}\n\n            kind = options.get('kind', 'all')\n\n            if (kind == 'all' and required_flags <= set_flags) \\\n                or (kind == 'any' and required_flags & set_flags) \\\n                or (kind == 'none' and not required_flags & set_flags):\n                return flagged_block.group('body').strip()\n\n            else:\n                return ''\n\n        return self.pattern.sub(_sub, content)", "response": "Replace flagged blocks either with their contents or nothing, depending on the value\n        of ``FOLIANT_FLAGS`` environment variable and ``flags`` config value.\n\n        :param content: Markdown content\n\n        :returns: Markdown content without flagged blocks"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a singleton instance of the class", "response": "def getInstance(cls, *args):\n        '''\n        Returns a singleton instance of the class\n        '''\n        if not cls.__singleton:\n            cls.__singleton = Openshift(*args)\n        return cls.__singleton"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _verify_or_create_domain(self):\n\n        # Get all domains registered with the user\n        r = requests.get(\n            url=self.server + \"/domains\",\n            auth=(self.username, self.password),\n            headers=self.headers,\n            json=self.data\n        )\n        if r.ok:\n            names = []\n            d = r.json()\n            rdata = d[\"data\"]\n            if rdata:\n                for d in rdata:\n                    names.append(d[\"name\"])\n            if self.domain in names:\n                return\n        else:\n            print \"Error querying for domains for the configured user\"\n            print r.status_code, r.text\n            return\n\n        print \"Domain %s is not created on rhcloud. Creating..\"\n\n        d = {\"id\": self.domain}\n        d.update(self.data)\n\n        r = requests.post(\n            url= self.server + \"/domains\",\n            auth= (self.username, self.password),\n            headers = self.headers,\n            json=d\n        )\n        if r.ok:\n            print \"Domain %s successfully created..\" % self.domain\n\n        else:\n            print \"Error creating domain for the configured user\"\n            print r.status_code, r.text\n            return\n\n        return r", "response": "Verify that a domain with the name self. domain exists. If it does not create it."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef sub_slots(x,match_fn,path=(),arr=None,match=False,recurse_into_matches=True):\n  # todo: rename match to topmatch for clarity\n  # todo: profiling suggests this getattr-heavy recursive process is the next bottleneck\n  if arr is None: arr=[]\n  if match and match_fn(x):\n    arr.append(path)\n    if not recurse_into_matches:\n      return arr\n  if isinstance(x, PathTree):\n    for attr in x.ATTRS:\n      val = getattr(x,attr)\n      if attr in x.VARLEN:\n        for i,elt in enumerate(val or ()):\n          nextpath = path + ((attr,i),)\n          sub_slots(elt,match_fn,nextpath,arr,True,recurse_into_matches)\n      else:\n        nextpath = path + (attr,)\n        sub_slots(val,match_fn,nextpath,arr,True,recurse_into_matches)\n  return arr", "response": "given a BaseX in x explore its ATTRS and return a list of tree - paths that match match_fn."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ntest is function(exp) >> bool. mapper is function(expression) >> list of subexpressions. returns [subexpression, ...].", "response": "def flatten_tree(test, enumerator, exp):\n  \"\"\"test is function(exp) >> bool.\n  mapper is function(expression) >> list of subexpressions.\n  returns [subexpression, ...].\n  \"\"\"\n  return sum((flatten_tree(test, enumerator, subx) for subx in enumerator(exp)), []) if test(exp) else [exp]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef child(self,index):\n    \"helper for __getitem__/__setitem__\"\n    if isinstance(index,tuple):\n      attr,i = index\n      return getattr(self,attr)[i]\n    else: return getattr(self,index)", "response": "helper for __getitem__ / __setitem__"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncreate a pipeline of IndexAPIs based on the given service and user identifier.", "response": "def get_index_api(self, service, docido_user_id, account_login, config):\n        \"\"\" Create a pipeline of :py:class:`docido_sdk.index.IndexAPIProcessor`\n        based on:\n\n        - The :py:class:`docido_sdk.index.IndexAPIConfigurationProvider`\n          which provides configuration to created\n          :py:class:`docido_sdk.index.IndexAPIProcessor`\n        - The :py:class:`docido_sdk.index.IndexPipelineConfig` which\n          provides the :py:class:`docido_sdk.index.IndexAPIProcessor`\n          list to link together.\n\n        :param basestring: service:\n          account service name (gmail, trello, ...)\n\n        :param basestring: docido_user_id:\n          the Docido user identifier for which the IndexAPI is meant form\n\n        :param basestring: account_login\n          the user account login for which the IndexAPI is meant for\n\n        :param :py:class:`docido_sdk.toolbox.collections_ext.nameddict`\n\n        :return: new pipeline of processors\n        :rtype: :py:class:`docido_sdk.index.IndexAPI`\n        \"\"\"\n        config = self.config.get_index_api_conf(\n            service, docido_user_id, account_login, config\n        )\n        index_providers = self.pipeline.get_pipeline(service)\n        index_api = IndexAPI()\n        for provider in reversed(index_providers):\n            index_api = provider.get_index_api(parent=index_api, **config)\n        return index_api"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef form(request):\n    if request.method == 'POST':\n        url = request.POST['url']\n        submit_url = '%s%shl=%s' % (\n            url,\n            '&' if '?' in url else '?',\n            request.LANGUAGE_CODE\n        )\n        params = urllib.urlencode(request.POST)\n        f = urllib2.urlopen(submit_url, params)\n        text = f.read()\n    else:\n        text = _('Error: request type has to be POST')\n\n    response = http.HttpResponse(text, mimetype=\"text/plain\")\n    return response", "response": "A Ajax handler for Google Form submition\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\noverrides allauth. account. views. signup Overrides allauth. account. views. signup", "response": "def signup(request, **kwargs):\n    \"\"\"\n    Overrides allauth.account.views.signup\n    \"\"\"\n    if not ALLAUTH:\n        return http.HttpResponse(_('allauth not installed...'))\n    if request.method == \"POST\" and 'login' in request.POST:\n        form_class = LoginForm\n        form = form_class(request.POST)\n        redirect_field_name = \"next\"\n        success_url = get_default_redirect(request, redirect_field_name)\n        if form.is_valid():\n            return form.login(request, redirect_url=success_url)\n    response = allauth_signup(request, **kwargs)\n    return response"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ninstalls a package from the local folder :return:", "response": "def main():\n    \"\"\"\n    Install a package from the local folder\n    :return:\n    \"\"\"\n    common.setup_main()\n    config = common.ConfigData()\n    dist_folder = 'dist'\n\n    if os.path.isdir(dist_folder):\n        shutil.rmtree(dist_folder)\n    args = [\n        '{}'.format(config.python),\n        'setup.py',\n        'sdist',\n    ]\n    if config.setup_quiet:\n        args.extend([\n            '--quiet',\n        ])\n    common.check_call_no_output(args)\n    files = list(os.listdir(dist_folder))\n    assert len(files) == 1, \"too many files in {}\".format(dist_folder)\n    new_file = os.path.join(dist_folder, files[0])\n    args = []\n    if config.use_sudo:\n        args.extend([\n            'sudo',\n            '-H',\n        ])\n    args.extend([\n        '{}'.format(config.pip),\n        'install',\n        '--quiet',\n        '--upgrade',\n        new_file,\n    ])\n    if config.pip_quiet:\n        args.extend([\n            '--quiet',\n        ])\n    if config.install_in_user_folder:\n        args.extend([\n            '--user',\n        ])\n    common.check_call_no_output(args)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nexecutes a Kubernetes operation against a path.", "response": "def execute_operation(self, method=\"GET\", ops_path=\"\", payload=\"\"):\n        \"\"\"\n        Executes a Kubernetes operation using the specified method against a path.\n        This is part of the low-level API.\n\n        :Parameters:\n           - `method`: The HTTP method to use, defaults to `GET`\n           - `ops_path`: The path of the operation, for example, `/api/v1/events` which would result in an overall: `GET http://localhost:8080/api/v1/events`\n           - `payload`: The optional payload which is relevant for `POST` or `PUT` methods only\n        \"\"\"\n        operation_path_URL = \"\".join([self.api_server, ops_path])\n        logging.debug(\"%s %s\" %(method, operation_path_URL))\n        if payload == \"\":\n            res = requests.request(method, operation_path_URL)\n        else:\n            logging.debug(\"PAYLOAD:\\n%s\" %(payload))\n            res = requests.request(method, operation_path_URL, data=payload)\n        logging.debug(\"RESPONSE:\\n%s\" %(res.json()))\n        return res"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef describe_resource(self, resource_path):\n        res = self.execute_operation(method=\"GET\", ops_path=resource_path)\n        return res", "response": "Describe a resource based on its resource path."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndelete a resource based on its resource path.", "response": "def delete_resource(self, resource_path):\n        \"\"\"\n        Deletes a resource based on its resource path (the URL path modulo host part).\n\n        :Parameters:\n           - `resource_path`: The path of the resource to delete, for example, `/api/v1/namespaces/default/replicationcontrollers/webserver-rc`\n        \"\"\"\n        res = self.execute_operation(method=\"DELETE\", ops_path=resource_path)\n        logging.info(\"Deleted resource %s\" %(resource_path))\n        return res"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncreates an RC based on a manifest file.", "response": "def create_rc(self, manifest_filename, namespace=\"default\"):\n        \"\"\"\n        Creates an RC based on a manifest.\n\n        :Parameters:\n           - `manifest_filename`: The manifest file containing the ReplicationController definition, for example: `manifest/nginx-webserver-rc.yaml`\n           - `namespace`: In which namespace the RC should be created, defaults to, well, `default`\n        \"\"\"\n        rc_manifest, rc_manifest_json  = util.load_yaml(filename=manifest_filename)\n        logging.debug(\"%s\" %(rc_manifest_json))\n        create_rc_path = \"\".join([\"/api/v1/namespaces/\", namespace, \"/replicationcontrollers\"])\n        res = self.execute_operation(method=\"POST\", ops_path=create_rc_path, payload=rc_manifest_json)\n        try:\n            rc_url = res.json()[\"metadata\"][\"selfLink\"]\n        except KeyError:\n            raise ResourceCRUDException(\"\".join([\"Sorry, can not create the RC: \", rc_manifest[\"metadata\"][\"name\"], \". Maybe it exists already?\"]))\n        logging.info(\"From %s I created the RC %s at %s\" %(manifest_filename, rc_manifest[\"metadata\"][\"name\"], rc_url))\n        return (res, rc_url)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nscale the replicas of an RC based on a manifest file.", "response": "def scale_rc(self, manifest_filename, namespace=\"default\", num_replicas=0):\n        \"\"\"\n        Changes the replicas of an RC based on a manifest.\n        Note that it defaults to 0, meaning to effectively disable this RC.\n\n        :Parameters:\n           - `manifest_filename`: The manifest file containing the ReplicationController definition, for example: `manifest/nginx-webserver-rc.yaml`\n           - `namespace`: In which namespace the RC is, defaulting to `default`\n           - `num_replicas`: How many copies of the pods that match the selector are supposed to run\n        \"\"\"\n        rc_manifest, rc_manifest_json = util.load_yaml(filename=manifest_filename)\n        logging.debug(\"%s\" %(rc_manifest_json))\n        rc_path = \"\".join([\"/api/v1/namespaces/\", namespace, \"/replicationcontrollers/\", rc_manifest[\"metadata\"][\"name\"]])\n        rc_manifest[\"spec\"][\"replicas\"] = num_replicas\n        res = self.execute_operation(method=\"PUT\", ops_path=rc_path, payload=util.serialize_tojson(rc_manifest))\n        try:\n            rc_url = res.json()[\"metadata\"][\"selfLink\"]\n        except KeyError:\n            raise ResourceCRUDException(\"\".join([\"Sorry, can not scale the RC: \", rc_manifest[\"metadata\"][\"name\"]]))\n        logging.info(\"I scaled the RC %s at %s to %d replicas\" %(rc_manifest[\"metadata\"][\"name\"], rc_url, num_replicas))\n        return (res, rc_url)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating a new service based on a manifest file.", "response": "def create_svc(self, manifest_filename, namespace=\"default\"):\n        \"\"\"\n        Creates a service based on a manifest.\n\n        :Parameters:\n           - `manifest_filename`: The manifest file containing the service definition, for example: `manifest/webserver-svc.yaml`\n           - `namespace`: In which namespace the service should be created, defaults to, well, `default`\n        \"\"\"\n        svc_manifest, svc_manifest_json  = util.load_yaml(filename=manifest_filename)\n        logging.debug(\"%s\" %(svc_manifest_json))\n        create_svc_path = \"\".join([\"/api/v1/namespaces/\", namespace, \"/services\"])\n        res = self.execute_operation(method=\"POST\", ops_path=create_svc_path, payload=svc_manifest_json)\n        try:\n            svc_url = res.json()[\"metadata\"][\"selfLink\"]\n        except KeyError:\n            raise ResourceCRUDException(\"\".join([\"Sorry, can not create the service: \", svc_manifest[\"metadata\"][\"name\"], \". Maybe it exists already?\"]))\n        logging.info(\"From %s I created the service %s at %s\" %(manifest_filename, svc_manifest[\"metadata\"][\"name\"], svc_url))\n        return (res, svc_url)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsetting a device name in a cookie when a user wants to go to the site for that device.", "response": "def set_device(request, device=\"\"):\n    \"\"\"\n    Sets a device name in a cookie when a user explicitly wants to go\n    to the site for a particular device (eg mobile).\n    \"\"\"\n    response = redirect(add_cache_bypass(next_url(request) or \"/\"))\n    set_cookie(response, \"yacms-device\", device, 60 * 60 * 24 * 365)\n    return response"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset the selected site ID into the session - posted to from the Select site drop - down in the header of the admin.", "response": "def set_site(request):\n    \"\"\"\n    Put the selected site ID into the session - posted to from\n    the \"Select site\" drop-down in the header of the admin. The\n    site ID is then used in favour of the current request's\n    domain in ``yacms.core.managers.CurrentSiteManager``.\n    \"\"\"\n    site_id = int(request.GET[\"site_id\"])\n    if not request.user.is_superuser:\n        try:\n            SitePermission.objects.get(user=request.user, sites=site_id)\n        except SitePermission.DoesNotExist:\n            raise PermissionDenied\n    request.session[\"site_id\"] = site_id\n    admin_url = reverse(\"admin:index\")\n    next = next_url(request) or admin_url\n    # Don't redirect to a change view for an object that won't exist\n    # on the selected site - go to its list view instead.\n    if next.startswith(admin_url):\n        parts = next.split(\"/\")\n        if len(parts) > 4 and parts[4].isdigit():\n            next = \"/\".join(parts[:4])\n    return redirect(next)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nprocesses the inline editing form.", "response": "def edit(request):\n    \"\"\"\n    Process the inline editing form.\n    \"\"\"\n    model = apps.get_model(request.POST[\"app\"], request.POST[\"model\"])\n    obj = model.objects.get(id=request.POST[\"id\"])\n    form = get_edit_form(obj, request.POST[\"fields\"], data=request.POST,\n                         files=request.FILES)\n    if not (is_editable(obj, request) and has_site_permission(request.user)):\n        response = _(\"Permission denied\")\n    elif form.is_valid():\n        form.save()\n        model_admin = ModelAdmin(model, admin.site)\n        message = model_admin.construct_change_message(request, form, None)\n        model_admin.log_change(request, obj, message)\n        response = \"\"\n    else:\n        response = list(form.errors.values())[0][0]\n    return HttpResponse(response)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndisplaying search results. Takes an optional \"contenttype\" GET parameter in the form \"app-name.ModelName\" to limit search results to a single model.", "response": "def search(request, template=\"search_results.html\", extra_context=None):\n    \"\"\"\n    Display search results. Takes an optional \"contenttype\" GET parameter\n    in the form \"app-name.ModelName\" to limit search results to a single model.\n    \"\"\"\n    query = request.GET.get(\"q\", \"\")\n    page = request.GET.get(\"page\", 1)\n    per_page = settings.SEARCH_PER_PAGE\n    max_paging_links = settings.MAX_PAGING_LINKS\n    try:\n        parts = request.GET.get(\"type\", \"\").split(\".\", 1)\n        search_model = apps.get_model(*parts)\n        search_model.objects.search  # Attribute check\n    except (ValueError, TypeError, LookupError, AttributeError):\n        search_model = Displayable\n        search_type = _(\"Everything\")\n    else:\n        search_type = search_model._meta.verbose_name_plural.capitalize()\n    results = search_model.objects.search(query, for_user=request.user)\n    paginated = paginate(results, page, per_page, max_paging_links)\n    context = {\"query\": query, \"results\": paginated,\n               \"search_type\": search_type}\n    context.update(extra_context or {})\n    return TemplateResponse(request, template, context)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nserve TinyMCE plugins inside the inline popups and the uploadify SWF, as these are normally static files, and will break with cross-domain JavaScript errors if ``STATIC_URL`` is an external host. URL for the file is passed in via querystring in the inline popup plugin template, and we then attempt to pull out the relative path to the file, so that we can serve it locally via Django.", "response": "def static_proxy(request):\n    \"\"\"\n    Serves TinyMCE plugins inside the inline popups and the uploadify\n    SWF, as these are normally static files, and will break with\n    cross-domain JavaScript errors if ``STATIC_URL`` is an external\n    host. URL for the file is passed in via querystring in the inline\n    popup plugin template, and we then attempt to pull out the relative\n    path to the file, so that we can serve it locally via Django.\n    \"\"\"\n    normalize = lambda u: (\"//\" + u.split(\"://\")[-1]) if \"://\" in u else u\n    url = normalize(request.GET[\"u\"])\n    host = \"//\" + request.get_host()\n    static_url = normalize(settings.STATIC_URL)\n    for prefix in (host, static_url, \"/\"):\n        if url.startswith(prefix):\n            url = url.replace(prefix, \"\", 1)\n    response = \"\"\n    (content_type, encoding) = mimetypes.guess_type(url)\n    if content_type is None:\n        content_type = \"application/octet-stream\"\n    path = finders.find(url)\n    if path:\n        if isinstance(path, (list, tuple)):\n            path = path[0]\n        if url.endswith(\".htm\"):\n            # Inject <base href=\"{{ STATIC_URL }}\"> into TinyMCE\n            # plugins, since the path static files in these won't be\n            # on the same domain.\n            static_url = settings.STATIC_URL + os.path.split(url)[0] + \"/\"\n            if not urlparse(static_url).scheme:\n                static_url = urljoin(host, static_url)\n            base_tag = \"<base href='%s'>\" % static_url\n            with open(path, \"r\") as f:\n                response = f.read().replace(\"<head>\", \"<head>\" + base_tag)\n        else:\n            try:\n                with open(path, \"rb\") as f:\n                    response = f.read()\n            except IOError:\n                return HttpResponseNotFound()\n    return HttpResponse(response, content_type=content_type)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef displayable_links_js(request):\n    links = []\n    if \"yacms.pages\" in settings.INSTALLED_APPS:\n        from yacms.pages.models import Page\n        is_page = lambda obj: isinstance(obj, Page)\n    else:\n        is_page = lambda obj: False\n    # For each item's title, we use its model's verbose_name, but in the\n    # case of Page subclasses, we just use \"Page\", and then sort the items\n    # by whether they're a Page subclass or not, then by their URL.\n    for url, obj in Displayable.objects.url_map(for_user=request.user).items():\n        title = getattr(obj, \"titles\", obj.title)\n        real = hasattr(obj, \"id\")\n        page = is_page(obj)\n        if real:\n            verbose_name = _(\"Page\") if page else obj._meta.verbose_name\n            title = \"%s: %s\" % (verbose_name, title)\n        links.append((not page and real, {\"title\": str(title), \"value\": url}))\n    sorted_links = sorted(links, key=lambda link: (link[0], link[1]['value']))\n    return HttpResponse(dumps([link[1] for link in sorted_links]))", "response": "Renders a list of url pairs for all Displayable subclass\n    instances into JSON that s used to populate a list of links in\n    TinyMCE."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nmimic Django s 404 handler but with a different template path.", "response": "def page_not_found(request, template_name=\"errors/404.html\"):\n    \"\"\"\n    Mimics Django's 404 handler but with a different template path.\n    \"\"\"\n    context = {\n        \"STATIC_URL\": settings.STATIC_URL,\n        \"request_path\": request.path,\n    }\n    t = get_template(template_name)\n    return HttpResponseNotFound(t.render(context, request))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef server_error(request, template_name=\"errors/500.html\"):\n    context = {\"STATIC_URL\": settings.STATIC_URL}\n    t = get_template(template_name)\n    return HttpResponseServerError(t.render(context, request))", "response": "Mimics Django s error handler but adds STATIC_URL to the context."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _runhook(ui, repo, hooktype, filename, kwargs):\n    hname = hooktype + \".autohooks.\" + os.path.basename(filename)\n    if filename.lower().endswith(\".py\"):\n        try:\n            mod = mercurial.extensions.loadpath(filename,\n                \"hghook.%s\" % hname)\n        except Exception:\n            ui.write(_(\"loading %s hook failed:\\n\") % hname)\n            raise\n        return mercurial.hook._pythonhook(ui, repo, hooktype, hname,\n            getattr(mod, hooktype.replace(\"-\", \"_\")), kwargs, True)\n    elif filename.lower().endswith(\".sh\"):\n        return mercurial.hook._exthook(ui, repo, hname, filename, kwargs, True)\n    return False", "response": "Run the hook in filename and return its result."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef autohook(ui, repo, hooktype, **kwargs):\n    cmd = hooktype.replace(\"-\", \"_\")\n    if not repo or not cmd.replace(\"_\", \"\").isalpha():\n        return False\n    result = False\n    trusted = ui.configlist(\"autohooks\", \"trusted\")\n    if \"\" not in trusted:\n        default_path = ui.config(\"paths\", \"default\")\n        if not default_path:\n            return False\n        for match in trusted:\n            if default_path.startswith(match):\n                break\n        else:\n            return False\n    for hookdir in (\"hg-autohooks\", \".hg-autohooks\"):\n        dirname = os.path.join(repo.root, hookdir)\n        if not os.path.exists(dirname):\n            continue\n        for leafname in os.listdir(dirname):\n            if not leafname.startswith(cmd + \".\"):\n                continue\n            filename = os.path.join(dirname, leafname)\n            result = _runhook(ui, repo, hooktype, filename, kwargs) or result\n    return result", "response": "Look for hooks inside the repository to run."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef i_batch(max_size, iterable):\n    iterable_items = iter(iterable)\n    for items_batch in iter(lambda: tuple(islice(iterable_items, max_size)),\n                            tuple()):\n        yield items_batch", "response": "Generator that iteratively batches items\n    to a max size and consumes the items iterable\n    as each batch is yielded."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nopening a file - like object over the decoded bytes.", "response": "def open(self, session=None):\n        \"\"\"\n        :param requests.Session session:\n          Optional requests session\n\n\n        :return:\n          file-like object over the decoded bytes\n        \"\"\"\n        self.__kwargs.update(stream=True)\n        session = session or requests\n        resp = session.request(self.__method, self.__url, **self.__kwargs)\n        try:\n            yield resp\n        finally:\n            resp.close()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nmount rate - limit adapters on the specified requests. Session object.", "response": "def mount_rate_limit_adapters(cls, session=None,\n                                  rls_config=None, **kwargs):\n        \"\"\"Mount rate-limits adapters on the specified `requests.Session`\n        object.\n\n        :param py:class:`requests.Session` session:\n          Session to mount. If not specified, then use the global\n          `HTTP_SESSION`.\n\n        :param dict rls_config:\n          Rate-limits configuration. If not specified, then\n          use the one defined at application level.\n\n        :param kwargs:\n          Additional keywords argument given to\n          py:class:`docido_sdk.toolbox.rate_limits.RLRequestAdapter`\n          constructor.\n        \"\"\"\n        session = session or HTTP_SESSION\n        if rls_config is None:\n            rls_config = RateLimiter.get_configs()\n        for name, rl_conf in rls_config.items():\n            urls = rl_conf.get('urls', [])\n            if not urls:\n                continue\n            rl_adapter = RLRequestAdapter(name, config=rls_config, **kwargs)\n            for url in urls:\n                session.mount(url, rl_adapter)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadd two columns that contain numbers as strings", "response": "def clean_add_strdec(*args, prec=28):\n    \"\"\"add two columns that contain numbers as strings\"\"\"\n\n    # load modules\n    import pandas as pd\n    import numpy as np\n    import re\n    from decimal import Decimal, getcontext\n    getcontext().prec = prec\n\n    # initialize result as 0.0\n    def proc_elem(*args):\n        t = Decimal('0.0')\n        for a in args:\n            if isinstance(a, str):\n                a = re.sub('[^0-9\\.\\-]+', '', a)\n\n            if a and pd.notnull(a):\n                t += Decimal(a)\n\n        return str(t)\n\n    def proc_list(arr):\n        return [proc_elem(*row) for row in arr]\n\n    def proc_ndarray(arr):\n        return np.array(proc_list(arr))\n\n    # transform depending on provided datatypes\n    if isinstance(args[0], (list, tuple)):\n        return proc_list(args[0])\n    elif isinstance(args[0], np.ndarray):\n        return proc_ndarray(args[0])\n    elif isinstance(args[0], pd.DataFrame):\n        return pd.DataFrame(proc_ndarray(args[0].values),\n                            index=args[0].index)\n    else:\n        return proc_elem(*args)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef load_module(self, module, module_uri=None):\n        # Check to see that module isn't availble in python path\n        try:\n            import_module(module)\n        except ImportError, e:\n            if module_uri is None:\n                raise e\n        else:\n            return module\n\n        if not CACHE_DOWNLOADS:\n            module_name = self._unique_module_name(module)\n        else:\n            module_name = self._sanitize_module_name(module)\n\n        # Check to see whether we've already downloaded, otherwise, download\n        try:\n            import_module(module_name)\n        except ImportError:\n            module_file = self.download_module(module_uri)\n            try:\n                load_source(module_name, module_file)\n            except Exception:\n                msg = \"Unable to load code module %s\" % module\n                self._log.exception(msg)\n                raise PIDanticExecutionException(msg)\n\n        return module_name", "response": "Loads a module by name."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nextract PID and parent PID from an output line from the PS command", "response": "def _ps_extract_pid(self, line):\n        \"\"\"\n        Extract PID and parent PID from an output line from the PS command\n        \"\"\"\n        this_pid = self.regex['pid'].sub(r'\\g<1>', line)\n        this_parent = self.regex['parent'].sub(r'\\g<1>', line)\n        \n        # Return the main / parent PIDs\n        return this_pid, this_parent"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the process information from the system PS command.", "response": "def ps(self):\n        \"\"\"\n        Get the process information from the system PS command.\n        \"\"\"\n        \n        # Get the process ID\n        pid = self.get()\n        \n        # Parent / child processes\n        parent   = None\n        children = []\n        \n        # If the process is running\n        if pid:\n            proc   = Popen(['ps', '-ef'], stdout=PIPE)\n            for _line in proc.stdout.readlines():\n                line = self.unicode(_line.rstrip())\n                \n                # Get the current PID / parent PID\n                this_pid, this_parent = self._ps_extract_pid(line)\n                try:\n                    \n                    # If scanning a child process\n                    if int(pid) == int(this_parent):\n                        children.append('{}; [{}]'.format(this_pid.rstrip(), re.sub(' +', ' ', line)))\n                    \n                    # If scanning the parent process\n                    if int(pid) == int(this_pid):\n                        parent = re.sub(' +', ' ', line)\n                        \n                # Ignore value errors\n                except ValueError:\n                    continue\n                \n        # Return the parent PID and any children processes\n        return (parent, children)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the age of the PID file.", "response": "def age(self):\n        \"\"\"\n        Get the age of the PID file.\n        \"\"\"\n        \n        # Created timestamp\n        created = self.created()\n        \n        # Age in seconds / minutes / hours / days\n        age_secs  = time() - created\n        age_mins  = 0 if (age_secs < 60) else (age_secs / 60)\n        age_hours = 0 if (age_secs < 3600) else (age_mins / 60)\n        age_days  = 0 if (age_secs < 86400) else (age_hours / 24)\n        \n        # Return the age tuple\n        return (\n            int(age_secs), \n            int(age_mins), \n            int(age_hours), \n            int(age_days)\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a string representing the age of the process.", "response": "def birthday(self):\n        \"\"\"\n        Return a string representing the age of the process.\n        \"\"\"\n        if isfile(self.pid_file):\n            \n            # Timestamp / timezone string\n            tstamp  = datetime.fromtimestamp(self.created())\n            tzone   = tzname[0] \n            weekday = WEEKDAY[tstamp.isoweekday()]\n            \n            # PID file age / age string\n            age     = self.age()\n            age_str = '{}s ago'.format(age[0]) \n            \n            # Birthday string\n            bday   = '{} {} {}; {}'.format(weekday, tstamp, tzone, age_str)\n            \n            # Return timestamp / timestamp string\n            return (self.created(), bday)\n        return (None, None)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef make(self, pnum):\n        try:\n                \n            # Create the PID file\n            self.mkfile(self.pid_file, pnum)\n        except Exception as e:\n            self.die('Failed to generate PID file: {}'.format(str(e)))", "response": "Make a PID file and populate with PID number."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef remove(self):\n        if isfile(self.pid_file):\n            try:\n                remove(self.pid_file)\n            except Exception as e:\n                self.die('Failed to remove PID file: {}'.format(str(e)))\n        else:\n            return True", "response": "Remove the PID file."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef kill(self):\n        try:\n            kill(int(self.get()), 9)\n            \n        # Failed to kill the process\n        except Exception as e:\n            self.die('Failed to kill process: {}'.format(str(e)))\n            \n        # Remove the stale PID file\n        self.remove()", "response": "Kill the running process and remove the PID file."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get(self):\n        self.log.info('starting the ``get`` method')\n\n        self._execute_sql_query()\n        self._append_separations_to_results()\n        self._generate_sdss_object_name()\n\n        self.log.info('completed the ``get`` method')\n        return self.results", "response": "get the results from the sdss square search"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nbuilds the sql query for the sdss square search", "response": "def _build_sql_query(\n            self):\n        \"\"\"\n        *build sql query for the sdss square search*\n\n        **Key Arguments:**\n            # -\n\n        **Return:**\n            - None\n\n        .. todo::\n\n        \"\"\"\n        self.log.info('starting the ``_build_sql_query`` method')\n\n        ra1, ra2, dec1, dec2 = self.ra1, self.ra2, self.dec1, self.dec2\n\n        if self.galaxyType == \"all\":\n            self.sqlQuery = u\"\"\"\n                SELECT p.objiD, p.ra, p.dec, s.z as specz, s.zerr as specz_err, z.z as photoz, z.zerr as photoz_err, p.type\n                    FROM PhotoObjAll p\n                    LEFT JOIN SpecObjAll AS s ON s.bestobjid = p.objid\n                    LEFT JOIN Photoz AS z ON z.objid = p.objid \n                    WHERE (p.ra between %(ra1)s and %(ra2)s) and (p.dec between %(dec1)s and %(dec2)s) and p.clean = 1 and p.type = 3\n            \"\"\" % locals()\n        elif self.galaxyType == \"specz\":\n            self.sqlQuery = u\"\"\"\n                SELECT p.objiD, p.ra, p.dec, s.z as specz, s.zerr as specz_err, p.type\n                    FROM PhotoObjAll p, SpecObjAll s\n                    WHERE (s.bestobjid = p.objid) and (p.ra between %(ra1)s and %(ra2)s) and (p.dec between %(dec1)s and %(dec2)s) and p.type = 3\n            \"\"\" % locals()\n        elif self.galaxyType == \"photoz\":\n            self.sqlQuery = u\"\"\"\n                SELECT p.objiD, p.ra, p.dec, z.z as photoz, z.zerr as photoz_err, p.type\n                    FROM PhotoObjAll p, Photoz z\n                    WHERE (z.objid = p.objid) and (p.ra between %(ra1)s and %(ra2)s) and (p.dec between %(dec1)s and %(dec2)s) and p.clean = 1 and p.type = 3\n            \"\"\" % locals()\n        elif self.galaxyType == False or not self.galaxyType:\n            self.sqlQuery = u\"\"\"\n                SELECT p.objiD, p.ra, p.dec, s.z as specz, s.zerr as specz_err, z.z as photoz, z.zerr as photoz_err, p.type\n                    FROM PhotoObjAll p\n                    LEFT JOIN SpecObjAll AS s ON s.bestobjid = p.objid\n                    LEFT JOIN Photoz AS z ON z.objid = p.objid \n                    WHERE (p.ra between %(ra1)s and %(ra2)s) and (p.dec between %(dec1)s and %(dec2)s) and p.clean = 1 and (p.type = 3 or p.type = 6)\n            \"\"\" % locals()\n\n        self.sqlQuery = self.sqlQuery.strip()\n\n        self.log.info('completed the ``_build_sql_query`` method')\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _execute_sql_query(\n            self):\n        \"\"\"\n        *execute sql query using the sdss API*\n\n        **Key Arguments:**\n            # -\n\n        **Return:**\n            - None\n\n        .. todo::\n\n        \"\"\"\n        self.log.info('starting the ``_execute_sql_query`` method')\n\n        # generate the api call url\n        params = urllib.urlencode({'cmd': self.sqlQuery, 'format': \"json\"})\n        # grab the results\n        results = urllib.urlopen(self.sdssUrl + '?%s' % params)\n\n        # report any errors\n        ofp = sys.stdout\n        results = results.read()\n        if results.startswith(\"ERROR\"):  # SQL Statement Error -> stderr\n            ofp = sys.stderr\n            ofp.write(string.rstrip(line) + os.linesep)\n\n        # clean up the json response so it can be parsed\n        results = results.replace(\n            \": ,\", ': \"NULL\",')\n        regex = re.compile(r'\"photoz_err\"\\:\\s*(\\n\\s*})')\n        newString = regex.sub('\"photoz_err\": \"NULL\"\\g<1>', results)\n        results = newString\n\n        # parse the json results\n        results = json.loads(results)[0]\n        self.results = results[\"Rows\"]\n\n        self.log.info('completed the ``_execute_sql_query`` method')\n        return", "response": "Execute the sql query using the sdss API and return the result as a dict."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _append_separations_to_results(\n            self):\n        \"\"\"\n        *append angular separations to results*\n\n        **Key Arguments:**\n            # -\n\n        **Return:**\n            - None\n\n        .. todo::\n\n        \"\"\"\n        self.log.info('starting the ``_append_separations_to_results`` method')\n\n        for row in self.results:\n            if \"ra\" not in row:\n                print row\n                exit(0)\n\n            # CALCULATE SEPARATION IN ARCSEC\n            calculator = separations(\n                log=self.log,\n                ra1=self.ra,\n                dec1=self.dec,\n                ra2=row[\"ra\"],\n                dec2=row[\"dec\"],\n            )\n            angularSeparation, northSep, eastSep = calculator.get()\n\n            row[\"separation_arcsec\"] = angularSeparation\n            row[\"separation_north_arcsec\"] = northSep\n            row[\"separation_east_arcsec\"] = eastSep\n\n        self.log.info(\n            'completed the ``_append_separations_to_results`` method')\n        return None", "response": "Append angular separations to results"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngenerates the SDSS object name for the current object.", "response": "def _generate_sdss_object_name(\n            self):\n        \"\"\"\n        *generate sdss object names for the results*\n\n        **Key Arguments:**\n            # -\n\n        **Return:**\n            - None\n\n        .. todo::\n\n        \"\"\"\n        self.log.info('starting the ``_generate_sdss_object_name`` method')\n\n        converter = unit_conversion(\n            log=self.log\n        )\n\n        # Names should be of the format `SDSS JHHMMSS.ss+DDMMSS.s`\n        # where the coordinates are truncated, not rounded.\n        for row in self.results:\n\n            raSex = converter.ra_decimal_to_sexegesimal(\n                ra=row[\"ra\"],\n                delimiter=\":\"\n            )\n            decSex = converter.dec_decimal_to_sexegesimal(\n                dec=row[\"dec\"],\n                delimiter=\":\"\n            )\n            raSex = raSex.replace(\":\", \"\")[:9]\n            decSex = decSex.replace(\":\", \"\")[:9]\n            sdssName = \"SDSS J%(raSex)s%(decSex)s\" % locals()\n            row[\"sdss_name\"] = sdssName\n\n            wordType = [\"unknown\", \"cosmic_ray\", \"defect\", \"galaxy\",\n                        \"ghost\", \"knownobj\", \"star\", \"trail\", \"sky\", \"notatype\", ]\n            numberType = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n            row[\"type\"] = wordType[row[\"type\"]]\n\n        self.log.info('completed the ``_generate_sdss_object_name`` method')\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nfilters out unwanted to show users", "response": "def role_settings(self):\n        \"\"\" Filter out unwanted to show groups \"\"\"\n        result = super(SharingView, self).role_settings()\n        uid = self.context.UID()\n        filter_func = lambda x: not any((\n            x[\"id\"].endswith(uid),\n            x[\"id\"] == \"AuthenticatedUsers\",\n            x[\"id\"] == INTRANET_USERS_GROUP_ID,\n            ))\n        return filter(filter_func, result)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding [ member ] to a user title if user is a member of current workspace", "response": "def user_search_results(self):\n        \"\"\" Add [member] to a user title if user is a member\n        of current workspace\n        \"\"\"\n        results = super(SharingView, self).user_search_results()\n        ws = IWorkspace(self.context)\n        roles_mapping = ws.available_groups\n        roles = roles_mapping.get(self.context.participant_policy.title())\n\n        for result in results:\n            if result[\"id\"] in ws.members:\n                groups = ws.get(result[\"id\"]).groups\n                for role in roles:\n                    result[\"roles\"][role] = \"acquired\"\n                if \"Admins\" in groups:\n                    title = \"administrator\"\n                    result[\"roles\"][\"TeamManager\"] = \"acquired\"\n                else:\n                    title = \"member\"\n                result[\"title\"] = \"%s [%s]\" % (result[\"title\"], title)\n\n        return results"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef run_python_file(filename, args, package=None, collector=None):\n    # Create a module to serve as __main__\n    old_main_mod = sys.modules['__main__']\n    main_mod = imp.new_module('__main__')\n    sys.modules['__main__'] = main_mod\n    main_mod.__file__ = filename\n    if package:\n        main_mod.__package__ = package\n    main_mod.__builtins__ = sys.modules['__builtin__']\n\n    # Set sys.argv and the first path element properly.\n    old_argv = sys.argv\n    old_path0 = sys.path[0]\n    sys.argv = args\n    if package:\n        sys.path[0] = ''\n    else:\n        sys.path[0] = os.path.abspath(os.path.dirname(filename))\n\n    try:\n        # Open the source file.\n        try:\n            source_file = open(filename, 'rU')\n        except IOError:\n            raise NoSource(\"No file to run: %r\" % filename)\n\n        try:\n            source = source_file.read()\n        finally:\n            source_file.close()\n\n        # We have the source.  `compile` still needs the last line to be clean,\n        # so make sure it is, then compile a code object from it.\n        if source[-1] != '\\n':\n            source += '\\n'\n        code = compile(source, filename, \"exec\")\n\n        # Execute the source file.\n        try:\n            exec code in main_mod.__dict__\n        except SystemExit:\n            # The user called sys.exit().  Just pass it along to the upper\n            # layers, where it will be handled.\n            raise\n        except:\n            # Something went wrong while executing the user code.\n            # Get the exc_info, and pack them into an exception that we can\n            # throw up to the outer loop.  We peel two layers off the traceback\n            # so that the coverage.py code doesn't appear in the final printed\n            # traceback.\n            typ, err, tb = sys.exc_info()\n            raise ExceptionDuringRun(typ, err, tb.tb_next.tb_next)\n    finally:\n        # Restore the old __main__\n        sys.modules['__main__'] = old_main_mod\n\n        # Restore the old argv and path\n        sys.argv = old_argv\n        sys.path[0] = old_path0", "response": "Runs a python file as if it were the main program on the command line."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ninitializes database settings by using config from. ini file.", "response": "def initdb(config):\n    \"\"\" Initializing database settings by using config from .ini file.\n    \"\"\"\n    engine = sa.engine_from_config(config, 'sqlalchemy.')\n    Session.configure(bind=engine)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef on_chanmsg(self, from_, channel, message):\n        if message == 'hello':\n            self.privmsg(channel, 'Hello, %s!' % from_[0])\n            print('%s said hello!' % from_[0])\n        elif message == '!quit':\n            self.quit('Bye!')", "response": "Event handler for channel messages."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _get_package_data():\n    from os import listdir as ls\n    from os.path import join as jn\n\n    x = 'init'\n    b = jn('serv', x)\n    dr = ['binaries', 'templates']\n    return [jn(x, d, f) for d in ls(b) if d in dr for f in ls(jn(b, d))]", "response": "Iterate over the init dir for directories and returns\n    all files within them."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef path_for_import(name):\n    return os.path.dirname(os.path.abspath(import_module(name).__file__))", "response": "Returns the absolute path to the given module or package."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _make_the_call(self, method, url, body=None):\n        self.log.debug(\"%s call to %s with body = %s\" % (method, url, body))\n        params = {\"url\": url, \"headers\": self.headers, \"verify\": self.verify}\n        if body is not None:\n            params[\"data\"] = body\n        func = getattr(requests, method.lower())\n        try:\n            resp = func(**params)\n        except Exception as e:\n            self.log.error(\"Call to %s failed with %s, %s\" % (url, repr(e),\n                                                              e.message))\n            return None, e\n        else:\n            self.log.debug(\"Call to %s returned with status %s and body \"\n                           \"%s\" % (url, resp.status, resp.text))\n        return resp.status_code, resp.json()", "response": "Make the call to the specified url and return the status code and the response."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreduce a multiline string to a single line of text.", "response": "def reduce_multiline(string):\n    \"\"\"\n    reduces a multiline string to a single line of text.\n\n\n    args:\n        string: the text to reduce\n    \"\"\"\n    string = str(string)\n    return \" \".join([item.strip()\n                     for item in string.split(\"\\n\")\n                     if item.strip()])"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ntakes a list or multline text string and formats it.", "response": "def format_multiline(text, params={}, **kwargs):\n    \"\"\"\n    Takes a list or multline text string and formats it.\n        * multiline text strings get converted to a single line\n        * list entries are joined by a carriage return\n        * params are passed into the sting with a python format call\n\n    args:\n        text: list or string to format\n        params: argments for formating the text\n\n    kwargs:\n        prepend: string to prepend to each line\n        max_width: int of max width for a line\n        indent: number of spaces to indent\n    \"\"\"\n\n\n    def format_kwargs(text, params={}, **kwargs):\n        if params:\n            if isinstance(params, dict):\n                kwargs.update(params)\n            else:\n                kwargs = params\n        try:\n            return text.format(**kwargs)\n        except (TypeError, IndexError):\n            if isinstance(kwargs, str):\n                return text.format(kwargs)\n            else:\n                return text.format(*kwargs)\n\n    if isinstance(text, list):\n        new_text = \"\\n\".join([format_max_width(\n                                format_kwargs(\n                                    reduce_multiline(item), params, **kwargs),\n                                               **kwargs)\n                              for item in text])\n    else:\n        new_text = format_max_width(format_kwargs(reduce_multiline(text),\n                                                             params,\n                                                             **kwargs),\n                                    **kwargs)\n    return new_text"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef format_max_width(text, max_width=None, **kwargs):\n\n    ind = ''\n    if kwargs.get(\"indent\"):\n        ind = ''.ljust(kwargs['indent'], ' ')\n    prepend = ind + kwargs.get(\"prepend\", \"\")\n    if not max_width:\n        return \"{}{}\".format(prepend, text)\n\n    len_pre = len(kwargs.get(\"prepend\", \"\")) + kwargs.get(\"indent\", 0)\n    test_words = text.split(\" \")\n    word_limit = max_width - len_pre\n    if word_limit < 3:\n        word_limit = 3\n        max_width = len_pre + word_limit\n    words = []\n    for word in test_words:\n        if len(word) + len_pre > max_width:\n            n = max_width - len_pre\n            words += [word[i:i + word_limit]\n                      for i in range(0, len(word), word_limit)]\n        else:\n            words.append(word)\n    idx = 0\n    lines = []\n    idx_limit = len(words) - 1\n    sub_idx_limit = idx_limit\n    while idx < idx_limit:\n        current_len = len_pre\n        line = prepend\n        for i, word in enumerate(words[idx:]):\n            if (current_len + len(word)) == max_width and line == prepend:\n                idx += i or 1\n                line += word\n                lines.append(line)\n                if idx == idx_limit:\n                    idx -= 1\n                    sub_idx_limit -= 1\n                    del words[0]\n                break\n            if (current_len + len(word) + 1) > max_width:\n                idx += i\n                if idx == idx_limit:\n                    idx -= 1\n                    sub_idx_limit -= 1\n                    del words[0]\n                if idx == 0:\n                    del words[0]\n                lines.append(line)\n                break\n            if (i + idx) == sub_idx_limit:\n                idx += i or 1\n                if line != prepend:\n                    line = \" \".join([line, word])\n                elif word:\n                    line += word\n                lines.append(line)\n            else:\n                if line != prepend:\n                    line = \" \".join([line, word])\n                elif word:\n                    line += word\n                current_len = len(line)\n    return \"\\n\".join(lines)", "response": "Takes a string and formats it to a max width seperated by carriage\n    returns a string that is a max width seperated by carriage\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_details(app_url=defaults.APP_URL):\n    url = '%s/environment' % app_url\n    response = requests.get(url)\n\n    if response.status_code == 200:\n        return response.json()\n    else:\n        raise JutException('Unable to retrieve environment details from %s, got %s: %s' %\n                           (url, response.status_code, response.text))", "response": "Returns environment details for the app url specified"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef accept(self, evt):\r\n        # determine if application is a script file or frozen exe (pyinstaller)\r\n        frozen = getattr(sys, 'frozen', False)\r\n        if frozen:\r\n            app_file = sys.executable\r\n        else:\r\n            app_file = PathStr(__main__.__file__).abspath()\r\n\r\n        if self.cb_startmenu.isChecked():\r\n            # TODO: allow only logo location\r\n            # icon = app_file.dirname().join('media', 'logo.ico')\r\n            StartMenuEntry(self.name, app_file, icon=self.icon,\r\n                           console=False).create()\r\n\r\n        if self.cb_mime.isChecked():\r\n            # get admin rights\r\n            if not isAdmin():\r\n                try:\r\n                    # run this file as __main__ with admin rights:\r\n                    if frozen:\r\n                        cmd = \"from %s import embeddIntoOS\\nembeddIntoOS('%s', '%s', '%s')\" % (\r\n                            __name__, '', self.ftype, self.name)\r\n                        # in this case there is no python.exe and no moduly.py to call\r\n                        # thats why we have to import the method and execute it\r\n                        runAsAdmin((sys.executable, '-exec', cmd))\r\n                    else:\r\n                        runAsAdmin((sys.executable, __file__,\r\n                                    app_file, self.ftype, self.name))\r\n                except:\r\n                    print('needs admin rights to work')\r\n            else:\r\n                embeddIntoOS(app_file, self.ftype, self.name)\r\n\r\n        QtWidgets.QDialog.accept(self)", "response": "accepts the user to select a new entry"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef hash_count(self, line, pound=None):\n        if pound is None:\n            pound = '#'\n            \n        count = 0\n        for c in line:\n            if c != pound:\n                break\n            count += 1\n\n        return count", "response": "Count the number of hashes in a line."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef generate_lines(self, infile):\n        pound = '#'\n        \n        for line in infile:\n\n            heading = self.hash_count(line)\n\n            indent = self.hash_count(line, pound=' ')\n\n            yield dict(line=line.strip(),\n                       heading=heading,\n                       indent=indent)", "response": "Split file into lines\n        \n            return dict with line = input depth = n\n        "}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nprocesses a file of rest and yield dictionaries", "response": "def generate_slides(self, infile):\n        \"\"\" Process a file of rest and yield dictionaries \"\"\"\n\n        state = 0\n\n        # each slide is a dict\n        slide = {}\n\n        last_heading = 0\n\n        for item in self.generate_lines(infile):\n\n            line = item['line']\n            heading = item['heading']\n            indent = item['indent']\n\n            # Any heading is the heading for a new slide\n            if heading:\n\n                if slide and last_heading <= 1:\n                    yield slide\n\n                last_heading = heading\n                    \n                rows = []\n                slide = {}\n                if heading < 2:\n                    slide.update(dict(\n                        heading = dict(text=line.strip('#')),\n                        rows = rows))\n\n                continue\n\n            # Any block with more than one hash is a comment\n            if last_heading > 1:\n                continue\n\n            if indent == 0 and line:\n                # at a potential image\n                rows.append(self.build_row(line))\n\n            else:\n                # Just add the line of text\n                items = [dict(text=(' ' * indent) + line)]\n                rows.append(dict(items=items))\n\n        if slide:\n            yield slide"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef build_row(self, line):\n\n        items = []\n        row = dict(items=items)\n        fields = line.split(' ')\n\n        image_exts = ['.png', '.jpg']\n\n        # nothing there, carry on\n        if not fields: return row\n\n        for field in fields:\n\n            ext = os.path.splitext(field)[-1]\n\n            if ext.lower() in image_exts:\n                items.append(\n                    dict(image=field))\n\n            else:\n                items.append(\n                    dict(text=field))\n\n        return row", "response": "Build a row of items from a line of text."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef dict(self):\n        post_dict = {\n            'id': self.id,\n            'link': self.link,\n            'permalink': self.permalink,\n            'content_type': self.content_type,\n            'slug': self.slug,\n            'updated': self.updated, #.strftime(conf.GOSCALE_ATOM_DATETIME_FORMAT),\n            'published': self.published, #.strftime(conf.GOSCALE_ATOM_DATETIME_FORMAT),\n            'title': self.title,\n            'description': self.description,\n            'author': self.author,\n            'categories': self.categories[1:-1].split(',') if self.categories else None,\n            'summary': self.summary,\n            }\n        if self.attributes:\n            attributes = simplejson.loads(self.attributes)\n            post_dict.update(attributes)\n        return post_dict", "response": "Returns a dictionary of fields and attributes of the object."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef json(self, dict=None, indent=None):\n        if not dict:\n            dict = self.dict()\n        for key, value in dict.iteritems():\n            if type(value) == datetime.datetime:\n                dict[key] = value.strftime(conf.GOSCALE_ATOM_DATETIME_FORMAT)\n        return simplejson.dumps(dict, indent=indent)", "response": "Returns the post JSON representation of the object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_cache_key(self, offset=0, limit=0, order=None, post_slug=''):\n        return hashlib.sha1(\n            '.'.join([\n                str(self._get_data_source_url()),\n                str(offset),\n                str(limit),\n                str(order),\n                str(post_slug),\n                ])\n        ).hexdigest()", "response": "The return of Get\n        is the key for the cache."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_post(self, slug):\n        cache_key = self.get_cache_key(post_slug=slug)\n        content = cache.get(cache_key)\n        if not content:\n            post = Post.objects.get(slug=slug)\n            content = self._format(post)\n            cache_duration = conf.GOSCALE_CACHE_DURATION if post else 1\n            cache.set(cache_key, content, cache_duration)\n        return content", "response": "This method returns a single post by slug"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef up_to_date(self):\n#        return False\n        if not self.updated:\n            return False\n        return (utils.get_datetime_now() - self.updated).seconds < conf.GOSCALE_POSTS_UPDATE_FREQUENCY", "response": "Returns True if the plugin posts are up to date False otherwise."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nformat a list of posts into a dictionary", "response": "def _format(self, posts):\n        \"\"\" This method is called by get_content() method\"\"\"\n        if posts.__class__ == Post:\n            # format a single post\n            return posts.dict()\n        formated_posts = []\n        for post in posts:\n            formated_posts.append(post.dict())\n        return formated_posts"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _store_post(self, stored_entry, entry=None):\n        #        stored_entry.content_type = utils.get_source_setting(ds.type, 'type')\n        if stored_entry.published is None:\n            stored_entry.published = self._get_dummy_datetime()\n        if stored_entry.updated is None:\n            stored_entry.updated = self._get_dummy_datetime()\n        #        print 'Post: %s' % stored_entry.title\n        #        print 'Attributes: %s' % stored_entry.attributes\n        stored_entry.save()\n        self.posts.add(stored_entry)\n        return None", "response": "This method stores a post in the internal list of post objects."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef dispatch(args):\n  prog_name = args[0]\n  if prog_name not in dispatchers:\n    raise NoSuchScriptError(\"No such pyokit script: \" + prog_name + \"\\n\")\n  else:\n    dispatchers[prog_name](args[1:])", "response": "Dispatches a pyokit script to the appropriate module."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef __refund(self, subscription_charge_id, **kwargs):\n        params = {\n            'subscription_charge_id': subscription_charge_id\n        }\n        return self.make_call(self.__refund, params, kwargs)", "response": "Refund the current state of a wePay instance."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef export(self, contentType):\n        cls = munge.get_codec(contentType)\n        codec = cls()\n        return codec.dumps(self.__dict__())", "response": "Export the current object to specified contentType via munge. get_codec"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nparsing args returns a tuple of a parser and ParsedArgs object containing parsed args and parsed args object holding the current namespace and defaults", "response": "def parse_args(self, args=None, namespace=None, defaults=None):\n        \"\"\"Parse args, returns a tuple of a parser and ParsedArgs object\n        Args:\n            args      -- sequence of strings representing the arguments to parse\n            namespace -- object to use for holding arguments\n            defaults  -- lazily loaded dict like object of default arguments\n        Returns: (parser, ParsedArgs)\n        parser supports a .error message for displaying an error and exiting with usage\n        If a default key is callable then it is called with the current namespace,\n        and then returned.\n        \"\"\"\n        epilog = self.subparsers_summary()\n        epilog += self.epilog\n        return self(RootParser, epilog=epilog).parse_args(args, namespace, defaults)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef build_ajax_votes(request, user_profile):\n    vote_list = ''\n    for profile in request.upvotes.all():\n        vote_list += \\\n            '<li><a title=\"View Profile\" href=\"{url}\">{name}</a></li>'.format(\n                url=reverse(\n                    'member_profile',\n                    kwargs={'targetUsername': profile.user.username}\n                ),\n                name='You' if profile.user == user_profile.user \\\n                    else profile.user.get_full_name(),\n            )\n\n    in_votes = user_profile in request.upvotes.all()\n    count = request.upvotes.all().count()\n\n    return (vote_list, in_votes, count)", "response": "Build vote information for the request."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef setup(argv):\n    parser = argparse.ArgumentParser(\n        description='Compute Jekyl- and prose-aware wordcounts',\n        epilog='Accepted filetypes: plaintext, markdown, markdown (Jekyll)')\n    parser.add_argument('-S', '--split-hyphens', action='store_true',\n                        dest='split_hyphens',\n                        help='split hyphenated words rather than counting '\n                        'them as one word (\"non-trivial\" counts as two words '\n                        'rather than one)')\n    parser.add_argument('-u', '--update', action='store_true',\n                        help='update the jekyll file in place with the counts.'\n                        ' Does nothing if the file is not a Jekyll markdown '\n                        'file. Implies format=yaml, invalid with input '\n                        'from STDIN and non-Jekyll files.')\n    parser.add_argument('-f', '--format', nargs='?',\n                        choices=['yaml', 'json', 'default'], default='default',\n                        help='output format.')\n    parser.add_argument('-i', '--indent', type=int, nargs='?', default=4,\n                        help='indentation depth (default: 4).')\n    parser.add_argument('file', type=argparse.FileType('rb'),\n                        help='file to parse (or - for STDIN)')\n    return parser.parse_args(argv)", "response": "Sets up the ArgumentParser."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef prose_wc(args):\n    if args.file is None:\n        return 1\n    if args.split_hyphens:\n        INTERSTITIAL_PUNCTUATION.append(re.compile(r'-'))\n    content = args.file.read().decode('utf-8')\n    filename = args.file.name\n    body = strip_frontmatter(content)\n    parsed = markdown_to_text(body)\n    result = wc(filename, body, parsed=parsed,\n                is_jekyll=(body != content))\n    if (args.update and\n            filename != '_stdin_' and\n            result['counts']['type'] == 'jekyll'):\n        update_file(filename, result, content, args.indent)\n    else:\n        _mockable_print({\n            'yaml': yaml.safe_dump(result, default_flow_style=False,\n                              indent=args.indent),\n            'json': json.dumps(result, indent=args.indent),\n            'default': default_dump(result),\n        }[args.format])\n    return 0", "response": "Processes data provided to print a count object or update a file."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef markdown_to_text(body):\n    # Turn our input into HTML\n    md = markdown.markdown(body, extensions=[\n        'markdown.extensions.extra'\n    ])\n\n    # Safely parse HTML so that we don't have to parse it ourselves\n    soup = BeautifulSoup(md, 'html.parser')\n\n    # Return just the text of the parsed HTML\n    return soup.get_text()", "response": "Converts markdown to text."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncount the words characters and paragraphs in a string.", "response": "def wc(filename, contents, parsed=None, is_jekyll=False):\n    \"\"\"Count the words, characters, and paragraphs in a string.\n\n    Args:\n        contents: the original string to count\n        filename (optional): the filename as provided to the CLI\n        parsed (optional): a parsed string, expected to be plaintext only\n        is_jekyll: whether the original contents were from a Jekyll file\n\n    Returns:\n        An object containing the various counts\n    \"\"\"\n    if is_jekyll:\n        fmt = 'jekyll'\n    else:\n        fmt = 'md/txt'\n    body = parsed.strip() if parsed else contents.strip()\n\n    # Strip the body down to just words\n    words = re.sub(r'\\s+', ' ', body, re.MULTILINE)\n    for punctuation in INTERSTITIAL_PUNCTUATION:\n        words = re.sub(punctuation, ' ', words)\n    punct = re.compile('[^\\w\\s]', re.U)\n    words = punct.sub('', words)\n\n    # Retrieve only non-space characters\n    real_characters = re.sub(r'\\s', '', words)\n\n    # Count paragraphs in an intelligent way\n    paragraphs = [1 if len(x) == 0 else 0 for x in\n                  contents.strip().splitlines()]\n    for index, paragraph in enumerate(paragraphs):\n        if paragraph == 1 and paragraphs[index + 1] == 1:\n            paragraphs[index] = 0\n\n    return {\n        'counts': {\n            'file': filename,\n            'type': fmt,\n            'paragraphs': sum(paragraphs) + 1,\n            'words': len(re.split('\\s+', words)),\n            'characters_real': len(real_characters),\n            'characters_total': len(words),\n        }\n    }"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef update_file(filename, result, content, indent):\n    # Split the file into frontmatter and content\n    parts = re.split('---+', content, 2)\n\n    # Load the frontmatter into an object\n    frontmatter = yaml.safe_load(parts[1])\n\n    # Add the counts entry in the results object to the frontmatter\n    frontmatter['counts'] = result['counts']\n\n    # Set the frontmatter part backed to the stringified version of the\n    # frontmatter object\n    parts[1] = '\\n{}'.format(\n        yaml.safe_dump(frontmatter, default_flow_style=False, indent=indent))\n    result = '---'.join(parts)\n\n    # Write everything back to the file\n    with open(filename, 'wb') as f:\n        f.write(result.encode('utf-8'))\n    print('{} updated.'.format(filename))", "response": "Updates a Jekyll file to contain the counts form an object containing the counts entry in the content of the original file."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef log(message, level=\"info\"):\n    now = time.time()\n    entry = {}\n    entry['level'] = level\n    entry['message'] = message\n    entry['timestamp'] = now\n    _log_entries.append(entry)", "response": "Add a new log entry to the nago log."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef nago_access(access_required=\"master\", name=None):\n    def real_decorator(func):\n        func.nago_access = access_required\n        func.nago_name = name or func.__name__\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            return func(*args, **kwargs)\n        return wrapper\n    return real_decorator", "response": "Decorate other functions with this one to allow access\n\n    Arguments:\n        nago_access -- Type of access required to call this function\n                       By default only master is allowed to make that call\n\n        nago_name   -- What name this function will have to remote api\n                       Default is the same as the name of the function being\n                       decorated."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns all nodes in a list of dicts format", "response": "def get_nodes():\n    \"\"\" Returns all nodes in a list of dicts format\n    \"\"\"\n    cfg_file = \"/etc/nago/nago.ini\"\n    config = ConfigParser.ConfigParser()\n    config.read(cfg_file)\n    result = {}\n    for section in config.sections():\n        if section in ['main']:\n            continue\n        token = section\n        node = Node(token)\n        for key, value in config.items(token):\n            node[key] = value\n        result[token] = node\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ngenerate a random security token.", "response": "def generate_token():\n    \"\"\" Generate a new random security token.\n\n     >>> len(generate_token()) == 50\n     True\n\n     Returns:\n       string\n    \"\"\"\n    length = 50\n    stringset = string.ascii_letters + string.digits\n    token = ''.join([stringset[i % len(stringset)] for i in [ord(x) for x in os.urandom(length)]])\n    return token"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns basic information about this node", "response": "def get_my_info():\n    \"\"\" Return general information about this node\n    \"\"\"\n    result = {}\n    result['host_name'] = platform.node()\n    result['real_host_name'] = platform.node()\n    result['dist'] = platform.dist()\n    result['nago_version'] = nago.get_version()\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef delete(self):\n        cfg_file = \"/etc/nago/nago.ini\"\n        config = ConfigParser.ConfigParser()\n        config.read(cfg_file)\n        result = {}\n        token = self.data.pop(\"token\", self.token)\n        if token not in config.sections():\n            raise Exception(\"Cannot find node in config. Delete aborted.\")\n        config.remove_section(self.token)\n        with open(cfg_file, 'w') as f:\n            return config.write(f)", "response": "Delete this node from config files"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nsaving this node to config file", "response": "def save(self):\n        \"\"\" Save this node (and all its attributes) to config \"\"\"\n        cfg_file = \"/etc/nago/nago.ini\"\n        config = ConfigParser.ConfigParser()\n        config.read(cfg_file)\n        result = {}\n        token = self.data.pop(\"token\", self.token)\n        if token != self._original_token:\n            config.remove_section(self._original_token)\n            config.add_section(token)\n\n        if token not in config.sections():\n            config.add_section(token)\n        for key, value in self.data.items():\n            config.set(token, key, value)\n        for key, value in config.items(token):\n            if key not in self.data:\n                config.set(token, key, None)\n        with open(cfg_file, 'w') as f:\n            return config.write(f)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning all posted info about this node", "response": "def get_info(self, key=None):\n        \"\"\" Return all posted info about this node \"\"\"\n        node_data = nago.extensions.info.node_data.get(self.token, {})\n        if key is None:\n            return node_data\n        else:\n            return node_data.get(key, {})"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef include(pattern, matching):\n    matching.matching_records = [\n        MatchingRecord(\n            PathTemplate(pattern) + child_path_template,\n            case,\n            child_name\n        ) for child_path_template, case, child_name in matching.matching_records\n    ]\n    return matching", "response": "Including a other matching pattern to get as matching pattern s child paths."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef make_wsgi_app(matching, not_found_app=not_found_app):\n    def wsgi_app(environ, start_response):\n        environ['matcha.matching'] = matching\n        try:\n            matched_case, matched_dict = matching(environ)\n        except NotMatched:\n            return not_found_app(environ, start_response)\n        else:\n            environ['matcha.matched_dict'] = matched_dict\n            return matched_case(environ, start_response)\n    return wsgi_app", "response": "Makes a WSGI application from Matching object\n    registered other applications on each case argument."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets a matching name and URL args and return a corresponded URL", "response": "def reverse(self, matching_name, **kwargs):\n        \"\"\" Getting a matching name and URL args and return a corresponded URL\n        \"\"\"\n        for record in self.matching_records:\n            if record.name == matching_name:\n                path_template = record.path_template\n                break\n        else:\n            raise NotReversed\n\n        if path_template.wildcard_name:\n            l = kwargs.get(path_template.wildcard_name)\n            if not l:\n                raise NotReversed\n            additional_path = '/'.join(l)\n            extra_path_elements = path_template.pattern.split('/')[:-1]\n            pattern = join_paths('/'.join(extra_path_elements), additional_path)\n        else:\n            pattern = path_template.pattern\n\n        try:\n            url = pattern.format(**kwargs)\n        except KeyError:\n            raise NotReversed\n        return url"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the next version number.", "response": "def nextversion(current_version):\n    \"\"\"Returns incremented module version number.\n\n    :param current_version: version string to increment\n    :returns:               Next version string (PEP 386 compatible) if possible.\n                            If impossible (since `current_version` is too far from PEP 386),\n                            `None` is returned.\n    \"\"\"\n    norm_ver = verlib.suggest_normalized_version(current_version)\n    if norm_ver is None:\n        return None\n    norm_ver = verlib.NormalizedVersion(norm_ver)\n\n    # increment last version figure\n    parts = norm_ver.parts   # see comments of `verlib.py` to get the idea of `parts`\n    assert(len(parts) == 3)\n    if len(parts[2]) > 1:    # postdev\n        if parts[2][-1] == 'f':  # when `post` exists but `dev` doesn't\n            parts = _mk_incremented_parts(parts, part_idx=2, in_part_idx=-2, incval=1)\n        else:                    # when both `post` and `dev` exist\n            parts = _mk_incremented_parts(parts, part_idx=2, in_part_idx=-1, incval=1)\n    elif len(parts[1]) > 1:  # prerel\n        parts = _mk_incremented_parts(parts, part_idx=1, in_part_idx=-1, incval=1)\n    else:                    # version & extraversion\n        parts = _mk_incremented_parts(parts, part_idx=0, in_part_idx=-1, incval=1)\n    norm_ver.parts = parts\n\n    return str(norm_ver)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nextract date from URL page if exists.", "response": "def find_date(url):\n    \"Extract date from URL page if exists.\"\n    def _clean_split(div_str):\n        sl = []\n        for div in div_str.split('/'):\n            div = div.strip().lower()\n            if div != '':\n                sl.append(div)\n        return sl\n        \n    url_path = find_path(url)\n    url_path_parts = _clean_split(url_path)\n    date_parts = []\n    for part in url_path_parts:\n        try:\n            _dateparse(part) # is part date-like?\n            date_parts.append(part)\n        except ValueError:\n            continue\n    if len(date_parts) == 0:\n        return\n    date_str = '/'.join(date_parts)\n    return _dateparse(date_str)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef compute_coordinate(self, index):\n        '''Compute two-dimension coordinate from one-dimension list'''\n        j = index%self.board_size\n        i = (index - j) // self.board_size\n        return (i, j)", "response": "Compute two - dimension coordinate from one - dimension list"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets a chess position", "response": "def set_pos(self, pos, check=False):\n        '''Set a chess'''\n        self.validate_pos(pos)\n        x, y = pos\n        user = self.get_player()\n        self.history[self._game_round] = copy.deepcopy(self.pos)\n        self.pos[x][y] = user\n        pos_str = self._cal_key(pos)\n        self._pos_dict[pos_str] = user\n        self._user_pos_dict[user].append(pos)\n        self._game_round += 1\n        if check:\n            winning = self.check_win_by_step(x, y, user)\n            return winning\n        else:\n            return (x, y)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ntransfer user input to valid chess position", "response": "def handle_input(self, input_str, place=True, check=False):\n        '''Transfer user input to valid chess position'''\n        user = self.get_player()\n        pos = self.validate_input(input_str)\n        if pos[0] == 'u':\n            self.undo(pos[1])\n            return pos\n        if place:\n            result = self.set_pos(pos, check)\n            return result\n        else:\n            return pos"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef distance(self, piecex, piecey):\n        '''Return the distance of chess piece X and Y (Chebyshev Distance)'''\n        return max(abs(piecex[0] - piecey[0]), abs(piecex[1], piecey[1]))", "response": "Return the distance of chess piece X and Y ( Chebyshev Distance"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef check_win_by_step(self, x, y, user, line_number=None):\n        '''Check winners by current step'''\n        if not line_number:\n            line_number = self.win\n        for ang in self.angle:\n            self.win_list = [(x, y)]\n            angs = [ang, ang + math.pi]\n            line_num = 1\n            radius = 1\n            direction = [1, 1]\n            while True:\n                if line_num == line_number:\n                    return True\n                if direction == [0, 0]:\n                    break\n                for ind, a in enumerate(angs):\n                    target_x = int(x + radius*(sign(math.cos(a)))) if direction[ind] else -1\n                    target_y = int(y - radius*(sign(math.sin(a)))) if direction[ind] else -1\n                    if target_x < 0 or target_y < 0 or target_x > self.board_size - 1 or target_y > self.board_size - 1:\n                        direction[ind] = 0\n                    elif self.pos[target_x][target_y] == user:\n                        self.win_list.append((target_x, target_y))\n                        line_num += 1\n                    else:\n                        direction[ind] = 0\n                else:\n                    radius += 1\n        else:\n            return (x, y)", "response": "Check winners by current step"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nfind the index of first non num element in sequence", "response": "def get_not_num(self, seq, num=0):\n        '''Find the index of first non num element'''\n        ind = next((i for i, x in enumerate(seq) if x != num), None)\n        if ind == None:\n            return self.board_size\n        else:\n            return ind"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nrotating the chessboard for a specific angle", "response": "def rotate_board(self, angle, unit='radian'):\n        '''Rotate the chessboard for a specific angle,\n        angle must be integral multiple of pi/2(90 degree)'''\n        if unit == 'angle':\n            angle = angle*math.pi/180\n\n        angle %= 2*math.pi\n        if angle not in [0, math.pi/2, math.pi, math.pi*3/2]:\n            raise ValueError('Angle must be integral multiple of pi/2(90 degree)')\n\n        new_pos = [[0 for _ in self.pos_range] for _ in self.pos_range]\n        cos_ang = math.cos(angle)\n        sin_ang = math.sin(angle)\n        center = (self.board_size - 1)/2\n        for x, y in comb(self.pos_range, 2):\n            xt = int((x - center)*cos_ang - (y - center)*sin_ang + center)\n            yt = int((x - center)*sin_ang + (y - center)*cos_ang + center)\n            new_pos[xt][yt] = self.pos[x][y]\n        return new_pos"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef reduce_number(num):\n  parts = str(num).split(\".\")\n  if len(parts) == 1 or parts[1] == \"0\":\n    return int(parts[0])\n  else:\n    match = _REPEATING_NUMBER_TRIM_RE.search(parts[1])\n    if match:\n      from_index, _ = match.span()\n      if from_index == 0 and match.group(2) == \"0\":\n        return int(parts[0])\n      else:\n        return Decimal(parts[0] + \".\" + parts[1][:from_index] + match.group(2))\n    else:\n      return num", "response": "Reduces the string representation of a number."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_cell_value(self, row, index, value):\n    if self._set_cell_value:\n      self._set_cell_value(row, index, value)\n    else:\n      row[index] = value", "response": "Sets the value for the cell at row [ index ]."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef is_cell_empty(self, cell):\n    if cell is None:\n      return True\n    elif self._is_cell_empty:\n      return self._is_cell_empty(cell)\n    else:\n      return cell is None", "response": "Checks if the cell is empty."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn True if every cell in the row is empty.", "response": "def is_row_empty(self, row):\n    \"\"\"Returns True if every cell in the row is empty.\"\"\"\n    for cell in row:\n      if not self.is_cell_empty(cell):\n        return False\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef serialize(self, serialize_cell=None):\n    if serialize_cell is None:\n      serialize_cell = self.get_cell_value\n    return [[serialize_cell(cell) for cell in row] for row in self.rows]", "response": "Returns a list of all rows with serialize_cell called on the cells of\n    each."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef headers(self, serialize_cell=None):\n    if serialize_cell is None:\n      serialize_cell = self.get_cell_value\n    return [serialize_cell(cell) for cell in self.rows[0]]", "response": "Gets the first row of the data table with serialize_cell is called on\n    each cell."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef rows_to_dicts(self, serialize_cell=None):\n    if serialize_cell is None:\n      serialize_cell = self.get_cell_value\n    # keys = [serialize_cell(cell) for cell in self.rows[0]]\n    keys = self.headers(serialize_cell)\n    for row in self.rows[1:]:\n      yield dict(zip(keys, [serialize_cell(cell) for cell in row]))", "response": "Generates a sequence of dictionaries of header [ i ] = row [ i ] for each row."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef trim_empty_rows(self):\n    if self.nrows != 0:\n      row_index = 0\n      for row_index, row in enumerate(reversed(self.rows)):\n        if not self.is_row_empty(row):\n          break\n      self.nrows = len(self.rows) - row_index\n      self.rows = self.rows[:self.nrows]\n    return self", "response": "Removes all trailing empty rows."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nremove all trailing empty columns.", "response": "def trim_empty_columns(self):\n    \"\"\"Removes all trailing empty columns.\"\"\"\n    if self.nrows != 0 and self.ncols != 0:\n      last_col = -1\n      for row in self.rows:\n        for i in range(last_col + 1, len(row)):\n          if not self.is_cell_empty(row[i]):\n            last_col = i\n      ncols = last_col + 1\n      self.rows = [row[:ncols] for row in self.rows]\n      self.ncols = ncols\n    return self"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncleaning the values in each cell. Calls either the user provided clean_value or the class defined clean value.", "response": "def clean_values(self):\n    \"\"\"Cleans the values in each cell. Calls either the user provided clean_value, or the\n    class defined clean value.\n    \"\"\"\n    for row in self.rows:\n      for index, cell in enumerate(row):\n        self.set_cell_value(row, index, self.clean_value(self.get_cell_value(cell)))\n    return self"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef clean_value(self, value):\n    if self._clean_value:\n      return self._clean_value(value)\n    else:\n      return self.reduce_value(value)", "response": "Cleans a value using either the user provided clean_value or cls. reduce_value."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncleans the value by either compressing it if it is a string or reducing it if it is a number.", "response": "def reduce_value(cls, value):\n    \"\"\"Cleans the value by either compressing it if it is a string, or reducing it if it is a\n    number.\n    \"\"\"\n    if isinstance(value, str):\n      return to_compressed_string(value)\n    elif isinstance(value, bool):\n      return value\n    elif isinstance(value, Number):\n      return reduce_number(value)\n    else:\n      return value"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef about_time(fn=None, it=None):\n\n    # has to be here to be mockable.\n    if sys.version_info >= (3, 3):\n        timer = time.perf_counter\n    else:  # pragma: no cover\n        timer = time.time\n\n    @contextmanager\n    def context():\n        timings[0] = timer()\n        yield handle\n        timings[1] = timer()\n\n    timings = [0.0, 0.0]\n    handle = Handle(timings)\n\n    if it is None:\n        # use as context manager.\n        if fn is None:\n            return context()\n\n        # use as callable handler.\n        with context():\n            result = fn()\n        return HandleResult(timings, result)\n\n    # use as counter/throughput iterator.\n    if fn is None or not callable(fn):  # handles inversion of parameters.\n        raise UserWarning('use as about_time(callback, iterable) in counter/throughput mode.')\n\n    def counter():\n        i = -1\n        with context():\n            for i, elem in enumerate(it):\n                yield elem\n        fn(HandleStats(timings, i + 1))\n\n    return counter()", "response": "A simple function that returns the execution time of a block of code and also counts iterations and throughput of them always with a beautiful human representation."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get(self, name, default=\"\", parent_search=False, multikeys_search=False, __settings_temp=None, __rank_recursion=0):\n\t\t# configuration des settings temporaire pour traitement local\n\t\tif __settings_temp is None:\n\t\t\t__settings_temp = self.settings\n\n\t\t# check si le chemin commence par / auquel cas on le supprime\n\t\tif name.startswith(\"/\"):\n\t\t\tname = name[1:]\n\n\t\t# check si le chemin termine par / auquel cas on le supprime\n\t\tif name.endswith(\"/\"):\n\t\t\tname = name[:-1]\n\n\t\t# check s'il s'agit d'un chemin complet\n\t\tif \"/\" in name:\n\t\t\t# r\u00e9cup\u00e9ration du nom de la sous configuraiton\n\t\t\tname_master = name.split(\"/\")[0]\n\n\t\t\t# r\u00e9cup\u00e9ration de l'indice si le nom obtenu contient []\n\t\t\tindice_master = -1\n\t\t\tindices_master = re.findall(r\"\\[\\d+\\]\", name_master)\n\t\t\tif len(indices_master) > 0:\n\t\t\t\ttry:\n\t\t\t\t\tindice_master = int(indices_master[0].replace(\"[\", \"\").replace(\"]\", \"\"))\n\t\t\t\texcept:\n\t\t\t\t\tpass\n\n\t\t\t# suppression de l'indice dans le nom du chemin courant (ie: data[0] devient data)\n\t\t\tname_master = name_master.replace(\"[{}]\".format(indice_master), \"\")\n\n\t\t\t# recherche si la clef est pr\u00e9sente dans le chemin courant\n\t\t\tif name_master not in __settings_temp.keys():\n\t\t\t\treturn None\n\n\t\t\t# r\u00e9cup\u00e9ration de la sous configuration\n\t\t\tif indice_master < 0:\n\t\t\t\t# la sous configuration n'est pas une liste\n\t\t\t\t__settings_temp = __settings_temp[name_master]\n\n\t\t\telse:\n\t\t\t\t# la sous configuration est une liste (SI JSON !!)\n\t\t\t\t__settings_temp = __settings_temp[name_master][indice_master] if self.is_json else __settings_temp[name]\n\n\t\t\t# recursion sur le chemin en dessous\n\t\t\tname_split = name.split(\"/\")[1:]\n\t\t\tsearch_path = \"/\".join(name_split)\n\t\t\treturn_value = self.get(\n\t\t\t\tsearch_path, default, parent_search, multikeys_search, __settings_temp, __rank_recursion + 1)\n\n\t\t\t# pas de valeur trouv\u00e9, on cherche sur la r\u00e9cursion inverse\n\t\t\tif len(name_split) > 1 and return_value is None:\n\t\t\t\ti = len(name_split)\n\t\t\t\twhile i >= 0:\n\t\t\t\t\t# on d\u00e9cr\u00e9mente le curseur de recherche\n\t\t\t\t\ti -= 1\n\n\t\t\t\t\t# \u00e9tablissement du nouveau chemin en supprimant le niveau sup\u00e9rieur\n\t\t\t\t\tnew_search_path = \"/\".join(name_split[i-len(name_split):])\n\t\t\t\t\treturn_value = self.get(\n\t\t\t\t\t\tnew_search_path, default, parent_search, multikeys_search, __settings_temp, __rank_recursion + 1)\n\n\t\t\t\t\t# pas de recherche multi clef\n\t\t\t\t\tif not multikeys_search:\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\t# une valeur a \u00e9t\u00e9 trouv\u00e9e\n\t\t\t\t\tif not return_value is None:\n\t\t\t\t\t\tbreak\n\n\t\t\t# pas de valeur trouv\u00e9 et on est \u00e0 la racine du chemin\n\t\t\tif return_value is None and __rank_recursion == 0:\n\t\t\t\t# on change le nom du master et on cherche\n\t\t\t\tname = name_split[-1]\n\t\t\t\treturn_value = self.get(\n\t\t\t\t\tname, default, parent_search, multikeys_search, self.settings, 0)\n\n\t\t\t\t# toujours pas de valeur, on garde le d\u00e9faut\n\t\t\t\tif return_value is None:\n\t\t\t\t\treturn_value = default\n\n\t\t\t# retour de la valeur r\u00e9cup\u00e9r\u00e9e\n\t\t\treturn return_value\n\n\t\t# r\u00e9cup\u00e9ration de l'indice si le nom obtenu contient []\n\t\tindice_master = -1\n\t\tindices_master = re.findall(r\"\\[\\d+\\]\", name)\n\t\tif len(indices_master) > 0:\n\t\t\ttry:\n\t\t\t\tindice_master = int(indices_master[0].replace(\"[\", \"\").replace(\"]\", \"\"))\n\t\t\texcept:\n\t\t\t\tpass\n\n\t\t# suppression de l'indice dans le nom du chemin courant (ie: data[0] devient data)\n\t\tname = name.replace(\"[{}]\".format(indice_master), \"\")\n\n\t\t# check de la pr\u00e9cense de la clef\n\t\tif type(__settings_temp) is str or name not in __settings_temp.keys():\n\t\t\t# le hash n'est pas pr\u00e9sent !\n\t\t\t# si la recherche r\u00e9cursive inverse est activ\u00e9e et pas de valeur trouv\u00e9e,\n\t\t\t# on recherche plus haut\n\t\t\tif parent_search:\n\t\t\t\treturn None\n\n\t\t\treturn default\n\n\t\t# r\u00e9cup\u00e9ration de la valeur\n\t\tif indice_master < 0:\n\t\t\t# la sous configuration n'est pas une liste\n\t\t\tvalue = __settings_temp[name]\n\n\t\telse:\n\t\t\t# la sous configuration est une liste (SI JSON !!)\n\t\t\tvalue = __settings_temp[name][indice_master] if self.is_json else __settings_temp[name]\n\n\t\t# interdiction de la valeur \"None\"\n\t\tif value is None:\n\t\t\t# si la recherche r\u00e9cursive inverse est activ\u00e9e et pas de valeur trouv\u00e9e,\n\t\t\t# on recherche plus haut\n\t\t\tif parent_search:\n\t\t\t\treturn None\n\n\t\t\t# valeur par d\u00e9faut\n\t\t\tvalue = default\n\n\t\t# trim si value est un str\n\t\tif isinstance(value, str):\n\t\t\tvalue = value.strip()\n\n\t\t# retour de la valeur\n\t\treturn value", "response": "get a configuration value"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef getFloat(self, name, default=0.0, parent_search=False, multikeys_search=False):\n\t\ttry:\n\t\t\tvalue = self.get(name, default, parent_search, multikeys_search)\n\t\t\treturn float(value)\n\n\t\texcept:\n\t\t\t# pas de configuration trouv\u00e9 ou convertion impossible ?\n\t\t\treturn default", "response": "r\u00e9cup\u00e9ration d un \u00e9l\u00e9ment float"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef getEnable(self, name, default=False, parent_search=False, multikeys_search=False):\n\t\t# valeur\n\t\tvalue = self.get(name, default, parent_search, multikeys_search)\n\t\tif type(value) != str:\n\t\t\treturn (value == 1 or value)\n\n\t\t# test de retour\n\t\treturn value.lower() in [\"true\", \"t\", \"1\", \"oui\", \"vrai\", \"v\", \"on\", \"o\", \"yes\", \"y\", \"si\", \"s\", \"da\", \"d\", \"ja\", \"j\"]", "response": "r\u00e9cup\u00e9ration d un \u00e9l\u00e9ment vrai ou faux ( transformation en bool )"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget a value with a format", "response": "def getWithDateFormat(self, name, default=\"\", parent_search=False, multikeys_search=False):\n\t\t\"\"\" \n\t\t\tr\u00e9cup\u00e9ration d'un \u00e9l\u00e9ment de configuration et interpr\u00e9tation des valeurs de dates\n\t\t\tvariables accept\u00e9s : {dd}, {mm}, {yyyy}, {H}, {M} et {S}\n\t\t\t{mm_human} donne le nom du mois\n\t\t\"\"\"\n\t\t# r\u00e9cup\u00e9ration de la valeur\n\t\tvalue = self.get(name, default, parent_search, multikeys_search)\n\n\t\t# r\u00e9cup\u00e9ration d'un delta dans le nom\n\t\t#  {dd-10} donne 10 jours avant le jour d'aujourd'hui\n\t\t#  {H+12} donne 12 heures apr\u00e8s l'heure courante\n\t\t# delta_d = int(re.findall(r\"[+|-]\\d+\", value)[0]) if value.startswith(\"{dd\") else 0\n\n\t\t# objet de date interne\n\t\td = FastDate()\n\n\t\t# r\u00e9cupation des dates\n\t\tnow = d.convert()\n\n\t\ttomorrow = d.tomorrow()\n\t\tyesterday = d.yesterday()\n\n\t\tweekday_tomorrow = d.weekday_tomorrow()\n\t\tweekday_yesterday = d.weekday_yesterday()\n\n\t\tweekend_tomorrow = d.weekend_tomorrow()\n\t\tweekend_yesterday = d.weekend_yesterday()\n\n\t\tworking_tomorrow = d.working_tomorrow()\n\t\tworking_yesterday = d.working_yesterday()\n\n\t\t# formatage de la valeur\n\t\treturn value.format(\n\t\t\tyyyy=now.year,\n\t\t\tmm=now.strftime(\"%m\"),\n\t\t\tdd=now.strftime(\"%d\"),\n\t\t\tH=now.strftime(\"%H\"),\n\t\t\tM=now.strftime(\"%M\"),\n\t\t\tS=now.strftime(\"%S\"),\n\t\t\tmm_human=now.strftime(\"%B\"),\n\n\t\t\ttomorrow_yyyy=tomorrow.year,\n\t\t\ttomorrow_mm=tomorrow.strftime(\"%m\"),\n\t\t\ttomorrow_dd=tomorrow.strftime(\"%d\"),\n\t\t\ttomorrow_H=tomorrow.strftime(\"%H\"),\n\t\t\ttomorrow_M=tomorrow.strftime(\"%M\"),\n\t\t\ttomorrow_S=tomorrow.strftime(\"%S\"),\n\t\t\ttomorrow_mm_human=tomorrow.strftime(\"%B\"),\n\n\t\t\tyesterday_yyyy=yesterday.year,\n\t\t\tyesterday_mm=yesterday.strftime(\"%m\"),\n\t\t\tyesterday_dd=yesterday.strftime(\"%d\"),\n\t\t\tyesterday_H=yesterday.strftime(\"%H\"),\n\t\t\tyesterday_M=yesterday.strftime(\"%M\"),\n\t\t\tyesterday_S=yesterday.strftime(\"%S\"),\n\t\t\tyesterday_mm_human=yesterday.strftime(\"%B\"),\n\n\t\t\tweekday_yesterday_yyyy=weekday_yesterday.year,\n\t\t\tweekday_yesterday_mm=weekday_yesterday.strftime(\"%m\"),\n\t\t\tweekday_yesterday_dd=weekday_yesterday.strftime(\"%d\"),\n\t\t\tweekday_yesterday_H=weekday_yesterday.strftime(\"%H\"),\n\t\t\tweekday_yesterday_M=weekday_yesterday.strftime(\"%M\"),\n\t\t\tweekday_yesterday_S=weekday_yesterday.strftime(\"%S\"),\n\t\t\tweekday_yesterday_mm_human=weekday_yesterday.strftime(\"%B\"),\n\n\t\t\tweekday_tomorrow_yyyy=weekday_tomorrow.year,\n\t\t\tweekday_tomorrow_mm=weekday_tomorrow.strftime(\"%m\"),\n\t\t\tweekday_tomorrow_dd=weekday_tomorrow.strftime(\"%d\"),\n\t\t\tweekday_tomorrow_H=weekday_tomorrow.strftime(\"%H\"),\n\t\t\tweekday_tomorrow_M=weekday_tomorrow.strftime(\"%M\"),\n\t\t\tweekday_tomorrow_S=weekday_tomorrow.strftime(\"%S\"),\n\t\t\tweekday_tomorrow_mm_human=weekday_tomorrow.strftime(\"%B\"),\n\n\t\t\tweekend_yesterday_yyyy=weekend_yesterday.year,\n\t\t\tweekend_yesterday_mm=weekend_yesterday.strftime(\"%m\"),\n\t\t\tweekend_yesterday_dd=weekend_yesterday.strftime(\"%d\"),\n\t\t\tweekend_yesterday_H=weekend_yesterday.strftime(\"%H\"),\n\t\t\tweekend_yesterday_M=weekend_yesterday.strftime(\"%M\"),\n\t\t\tweekend_yesterday_S=weekend_yesterday.strftime(\"%S\"),\n\t\t\tweekend_yesterday_mm_human=weekend_yesterday.strftime(\"%B\"),\n\n\t\t\tweekend_tomorrow_yyyy=weekend_tomorrow.year,\n\t\t\tweekend_tomorrow_mm=weekend_tomorrow.strftime(\"%m\"),\n\t\t\tweekend_tomorrow_dd=weekend_tomorrow.strftime(\"%d\"),\n\t\t\tweekend_tomorrow_H=weekend_tomorrow.strftime(\"%H\"),\n\t\t\tweekend_tomorrow_M=weekend_tomorrow.strftime(\"%M\"),\n\t\t\tweekend_tomorrow_S=weekend_tomorrow.strftime(\"%S\"),\n\t\t\tweekend_tomorrow_mm_human=weekend_tomorrow.strftime(\"%B\"),\n\n\t\t\tworking_tomorrow_yyyy=working_tomorrow.year,\n\t\t\tworking_tomorrow_mm=working_tomorrow.strftime(\"%m\"),\n\t\t\tworking_tomorrow_dd=working_tomorrow.strftime(\"%d\"),\n\t\t\tworking_tomorrow_H=working_tomorrow.strftime(\"%H\"),\n\t\t\tworking_tomorrow_M=working_tomorrow.strftime(\"%M\"),\n\t\t\tworking_tomorrow_S=working_tomorrow.strftime(\"%S\"),\n\t\t\tworking_tomorrow_mm_human=working_tomorrow.strftime(\"%B\"),\n\n\t\t\tworking_yesterday_yyyy=working_yesterday.year,\n\t\t\tworking_yesterday_mm=working_yesterday.strftime(\"%m\"),\n\t\t\tworking_yesterday_dd=working_yesterday.strftime(\"%d\"),\n\t\t\tworking_yesterday_H=working_yesterday.strftime(\"%H\"),\n\t\t\tworking_yesterday_M=working_yesterday.strftime(\"%M\"),\n\t\t\tworking_yesterday_S=working_yesterday.strftime(\"%S\"),\n\t\t\tworking_yesterday_mm_human=working_yesterday.strftime(\"%B\"),\n\t\t)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef getFileFormat(self, name, args):\n\t\t# r\u00e9cup\u00e9ration du nom du fichier\n\t\ttemplate_pathname = self.get(name, \"--\")\n\t\tif not os.path.isfile(template_pathname):\n\t\t\treturn False\n\n\t\t# configuration\n\t\tcontent = \"\"\n\t\twith open(template_pathname) as fp:\n\t\t\t# Create a text/plain message\n\t\t\tcontent = fp.read().format(**args)\n\n\t\t# retour ok\n\t\treturn content", "response": "Returns a string with the format of the file"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef setLevel(self, level):\n\t\tif isinstance(level, int):\n\t\t\tself.logger.setLevel(level)\n\t\t\treturn\n\n\t\t# level en tant que string\n\t\tlevel = level.lower()\n\t\tif level == \"debug\":\n\t\t\tself.logger.setLevel(logging.DEBUG)\n\n\t\telif level == \"info\":\n\t\t\tself.logger.setLevel(logging.INFO)\n\n\t\telif level == \"warning\" or level == \"warning\":\n\t\t\tself.logger.setLevel(logging.WARN)\n\n\t\telif level == \"error\":\n\t\t\tself.logger.setLevel(logging.ERROR)\n\n\t\telse:\n\t\t\t# par d\u00e9faut\n\t\t\tself.logger.setLevel(logging.INFO)", "response": "Changement du niveau du Log"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef warn(self, text):\n\t\tself.logger.warn(\"{}{}\".format(self.message_prefix, text))", "response": "Ajout de un message de log de type WARN"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef warning(self, text):\n\t\tself.logger.warning(\"{}{}\".format(self.message_prefix, text))", "response": "Ajout de un message de type WARN"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef error(self, text):\n\t\tself.logger.error(\"{}{}\".format(self.message_prefix, text))", "response": "Ajout de un message de log de type ERROR"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef convert(self, date_from=None, date_format=None):\n\t\ttry:\n\t\t\tif date_format is None:\n\t\t\t\t# on d\u00e9termine la date avec dateutil\n\t\t\t\treturn dateutil.parser.parse(date_from)\n\n\t\t\t# il y a un format de date pr\u00e9d\u00e9fini\n\t\t\treturn datetime.strptime(date_from, date_format)\n\n\t\texcept:\n\t\t\t# \u00e9chec, on prend la date courante\n\t\t\treturn datetime.now()", "response": "convert date to dateutil. parser. parse"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef yesterday(self, date_from=None, date_format=None):\n\t\t# date d'hier\n\t\treturn self.delta(date_from=date_from, date_format=date_format, days=-1)", "response": "retourne la date d hier depuis maintenant ou depuis une date fournie\n\t"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef weekday_yesterday(self, date_from=None, date_format=None):\n\t\t# date d'hier que sur les jours de semaine\n\t\treturn self.delta(days=-1, date_from=date_from, date_format=date_format, days_range=[1, 2, 3, 4, 5])", "response": "get a datetime object that is a weekday yesterday"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef working_yesterday(self, date_from=None, date_format=None):\n\t\t# date d'hier que sur les jours de week-end\n\t\treturn self.delta(days=-1, date_from=date_from, date_format=date_format, days_range=[1, 2, 3, 4, 5, 6])", "response": "retourne la date d hier depuis maintenant ou depuis maintenant ou depuis une date fournie\n\t. date_from date de r\u00e9f\u00e9rence\n\t. date_format date de r\u00e9f\u00e9rence\n\t. date_from date de r\u00e9f\u00e9rence\n\t. date_from date de r\u00e9f\u00e9rence\n\t. date_format date_from date_format date_from date_format date_from date_format"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef tomorrow(self, date_from=None, date_format=None):\n\t\t# date de demain\n\t\treturn self.delta(date_from=date_from, date_format=date_format, days=1)", "response": "Retourne la date de demain depuis maintenant ou depuis maintenant ou depuis une date fournie\n\t"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget a datetime object that is the weekday tomorrow", "response": "def weekday_tomorrow(self, date_from=None, date_format=None):\n\t\t\"\"\"\n\t\tRetourne la date de demain depuis maintenant ou depuis une date fournie\n\t\tseulement sur les jours de semaine.\n\t\tAinsi vendredi devient jeudi et lundi devient vendredi\n\n\t\t:param: :date_from date de r\u00e9f\u00e9rence\n\t\t:return datetime\n\t\t\"\"\"\n\t\t# date de demain que sur les jours de semaine\n\t\treturn self.delta(days=1, date_from=date_from, date_format=date_format, days_range=[1, 2, 3, 4, 5])"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning a datetime object that is working toorrow.", "response": "def working_tomorrow(self, date_from=None, date_format=None):\n\t\t\"\"\"\n\t\tRetourne la date de demain depuis maintenant ou depuis une date fournie\n\t\tseulement sur les jours ouvrableq.\n\t\tAinsi lundi devient samedi et samedi devient vendredi\n\n\t\t:param: :date_from date de r\u00e9f\u00e9rence\n\t\t:return datetime\n\t\t\"\"\"\n\t\t# date de demain que sur les jours de week-end\n\t\treturn self.delta(days=1, date_from=date_from, date_format=date_format, days_range=[1, 2, 3, 4, 5, 6])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef main(arguments=None):\n    # setup the command-line util settings\n    su = tools(\n        arguments=arguments,\n        docString=__doc__,\n        logLevel=\"ERROR\",\n        options_first=True\n    )\n    arguments, settings, log, dbConn = su.setup()\n\n    # tab completion for raw_input\n    readline.set_completer_delims(' \\t\\n;')\n    readline.parse_and_bind(\"tab: complete\")\n    readline.set_completer(tab_complete)\n\n    # unpack remaining cl arguments using `exec` to setup the variable names\n    # automatically\n    for arg, val in arguments.iteritems():\n        if arg[0] == \"-\":\n            varname = arg.replace(\"-\", \"\") + \"Flag\"\n        else:\n            varname = arg.replace(\"<\", \"\").replace(\">\", \"\")\n        if isinstance(val, str) or isinstance(val, unicode):\n            exec(varname + \" = '%s'\" % (val,))\n        else:\n            exec(varname + \" = %s\" % (val,))\n        if arg == \"--dbConn\":\n            dbConn = val\n        log.debug('%s = %s' % (varname, val,))\n\n    ## START LOGGING ##\n    startTime = times.get_now_sql_datetime()\n    log.info(\n        '--- STARTING TO RUN THE cl_utils.py AT %s' %\n        (startTime,))\n\n    # set options interactively if user requests\n    if \"interactiveFlag\" in locals() and interactiveFlag:\n\n        # load previous settings\n        moduleDirectory = os.path.dirname(__file__) + \"/resources\"\n        pathToPickleFile = \"%(moduleDirectory)s/previousSettings.p\" % locals()\n        try:\n            with open(pathToPickleFile):\n                pass\n            previousSettingsExist = True\n        except:\n            previousSettingsExist = False\n        previousSettings = {}\n        if previousSettingsExist:\n            previousSettings = pickle.load(open(pathToPickleFile, \"rb\"))\n\n        # x-raw-input\n        # x-boolean-raw-input\n        # x-raw-input-with-default-value-from-previous-settings\n\n        # save the most recently used requests\n        pickleMeObjects = []\n        pickleMe = {}\n        theseLocals = locals()\n        for k in pickleMeObjects:\n            pickleMe[k] = theseLocals[k]\n        pickle.dump(pickleMe, open(pathToPickleFile, \"wb\"))\n\n    # call the worker function\n    # x-if-settings-or-database-credientials\n    if cone and filelist:\n        import codecs\n        pathToReadFile = pathToCoordinateList\n        readFile = codecs.open(pathToReadFile, encoding='utf-8', mode='r')\n\n        listOfCoordinates = []\n        for line in readFile.readlines():\n            line = line.strip()\n            [ra, dec] = line.split()\n            listOfCoordinates.append(str(ra) + \" \" + str(dec))\n        search = conesearch(\n            log=log,\n            radiusArcsec=radiusArcsec,\n            nearestOnly=nearestFlag,\n            unclassified=unclassifiedFlag,\n            listOfCoordinates=listOfCoordinates,\n            outputFilePath=outPutFile,\n            verbose=verboseFlag,\n            redshift=redshiftFlag)\n    elif cone:\n        search = conesearch(\n            log=log,\n            ra=ra,\n            dec=dec,\n            radiusArcsec=radiusArcsec,\n            nearestOnly=nearestFlag,\n            unclassified=unclassifiedFlag,\n            outputFilePath=outPutFile,\n            verbose=verboseFlag,\n            redshift=redshiftFlag\n        )\n    elif obj:\n        search = namesearch(\n            log=log,\n            names=objectName,\n            verbose=verboseFlag,\n            outputFilePath=outPutFile\n        )\n    search.get()\n\n    if \"dbConn\" in locals() and dbConn:\n        dbConn.commit()\n        dbConn.close()\n    ## FINISH LOGGING ##\n    endTime = times.get_now_sql_datetime()\n    runningTime = times.calculate_time_difference(startTime, endTime)\n    log.info('-- FINISHED ATTEMPT TO RUN THE cl_utils.py AT %s (RUNTIME: %s) --' %\n             (endTime, runningTime, ))\n\n    return", "response": "This function is the main function used by the cl_utils. py module. It is used by the cl_utils. py module to run the cl_utils. py script."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef handle(self, handler):\n        with self._hlock:\n            self._handler_list.append(handler)\n        return self", "response": "register a handler function"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nexecutes all handlers in the background and return a list of tuples", "response": "def fire(self, *args, **kargs):\n        \"\"\" collects results of all executed handlers \"\"\"\n\n        self._time_secs_old = time.time()\n        # allow register/unregister while execution\n        # (a shallowcopy should be okay.. https://docs.python.org/2/library/copy.html )\n        with self._hlock:\n            handler_list = copy.copy(self._handler_list)\n        result_list = []\n        for handler in handler_list:\n            if self._sync_mode:\n                # grab results of all handlers\n                result = self._execute(handler, *args, **kargs)\n                if isinstance(result, tuple) and len(result) == 3 and isinstance(result[1], Exception):\n                    # error occurred\n                    one_res_tuple = (False, self._error(result), handler)\n                else:\n                    one_res_tuple = (True, result, handler)\n            else:\n                # execute handlers in background, ignoring result\n                EventSystem._async_queue.put((handler, args, kargs))\n                one_res_tuple = (None, None, handler)\n            result_list.append(one_res_tuple)\n\n        # update statistics\n        time_secs_new = time.time()\n        self.duration_secs = time_secs_new - self._time_secs_old\n        self._time_secs_old = time_secs_new\n\n        return result_list"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _execute(self, handler, *args, **kwargs):\n        # difference to Axel Events: we don't use a timeout and execute all handlers in same thread\n        # FIXME: =>possible problem:\n        #                       blocking of event firing when user gives a long- or infinitly-running callback function\n        # (in Python it doesn't seem possible to forcefully kill a thread with clean ressource releasing,\n        #  a thread has to cooperate und behave nice...\n        #  execution and killing a process would be possible, but has data corruption problems with queues\n        #  and possible interprocess communication problems with given handler/callback function)\n\n        result = None\n        exc_info = None\n\n        try:\n            result = handler(*args, **kwargs)\n        except Exception:\n            exc_info = sys.exc_info()\n        if exc_info:\n            return exc_info\n        return result", "response": "execute one callback function"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _error(self, exc_info):\n        if self._exc_info:\n            if self._traceback:\n                return exc_info\n            return exc_info[:2]\n        return exc_info[1]", "response": "Retrieves the error info from the exception info."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn column index whose name is colname", "response": "def colindex_by_colname(self, colname):\n        \"\"\"Return column index whose name is :param:`column`\n\n        :raises: `ValueError` when no column with :param:`colname` found\n        \"\"\"\n        for i, coldef in enumerate(self):    # iterate each column's definition\n            if coldef.name == colname:\n                return i\n        raise ValueError('No column named \"%s\" found' % (colname))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a url to the busters. json file for cache invalidation.", "response": "def bridge(filename):\n    \"\"\" Add hash to filename for cache invalidation.\n\n    Uses gulp-buster for cache invalidation. Adds current file hash as url arg.\n    \"\"\"\n    if not hasattr(settings, 'BASE_DIR'):\n        raise Exception(\"You must provide BASE_DIR in settings for bridge\")\n    file_path = getattr(settings, 'BUSTERS_FILE', os.path.join('static',\n                                                               'busters.json'))\n    buster_file = os.path.join(settings.BASE_DIR, file_path)\n    fp = file(buster_file, 'r')\n    # TODO: may be store it somewhere to not load file every time\n    busters_json = json.loads(fp.read())\n    fp.close()\n    file_hash = busters_json.get(\"static/%s\" % filename)\n    path = static(filename)\n    return \"%s?%s\" % (path, file_hash) if file_hash is not None else path"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef run(self, in_batches):\n        if len(in_batches) != len(self._batcmd.batch_to_file_s):\n            BaseShellOperator._rm_process_input_tmpfiles(self._batcmd.batch_to_file_s)  # [todo] - Removing tmpfiles can be easily forgot. Less lifetime for tmpfile.\n            raise AttributeError('len(in_batches) == %d, while %d IN_BATCH* are specified in command below:%s$ %s' %\n                                 (len(in_batches), len(self._batcmd.batch_to_file_s), os.linesep, self._batcmd.sh_cmd))\n\n        # prepare & start process\n        BaseShellOperator._batches_to_tmpfile(self._in_record_sep, self._in_column_sep, in_batches, self._batcmd.batch_to_file_s)\n        process = BaseShellOperator._start_process(self._batcmd, self._cwd, self._env)\n        BaseShellOperator._batch_to_stdin(process, self._in_record_sep, self._in_column_sep, in_batches, self._batcmd.batch_to_file_s)\n\n        # wait process & get its output\n        BaseShellOperator._close_process_input_stdin(self._batcmd.batch_to_file_s)\n        BaseShellOperator._wait_process(process, self._batcmd.sh_cmd, self._success_exitcodes)\n        BaseShellOperator._rm_process_input_tmpfiles(self._batcmd.batch_to_file_s)\n\n        if self._batcmd.batch_from_file.is_stdout():\n            out_str = self._batcmd.batch_from_file.read_stdout(process.stdout)\n        elif self._batcmd.batch_from_file.is_tmpfile():\n            out_str = self._batcmd.batch_from_file.read_tmpfile()\n        else:  # pragma: no cover\n            assert(False)\n\n        out_batch = BaseShellOperator._out_str_to_batch(out_str, self._out_recdef, self._out_col_patterns)\n        self._batcmd.batch_from_file.finish()\n        return out_batch", "response": "Runs the shell operator synchronously to eat in_batches."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nappend the calibration parameters as variables of the netcdf file. Keyword arguments: filename -- the name of a netcdf file.", "response": "def calibrate(filename):\n    \"\"\"\n    Append the calibration parameters as variables of the netcdf file.\n\n    Keyword arguments:\n    filename -- the name of a netcdf file.\n    \"\"\"\n    params = calibration_to(filename)\n    with nc.loader(filename) as root:\n        for key, value in params.items():\n            nc.getdim(root, 'xc_1', 1)\n            nc.getdim(root, 'yc_1', 1)\n            if isinstance(value, list):\n                for i in range(len(value)):\n                    nc.getvar(root, '%s_%i' % (key, i), 'f4', ('time', 'yc_1', 'xc_1' ))[:] = value[i]\n            else:\n                nc.getvar(root, key, 'f4', ('time', 'yc_1', 'xc_1'))[:] = value"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreading YAML file and return as python dictionary", "response": "def read_yaml(file_path, Loader=yaml.Loader, object_pairs_hook=OrderedDict):\n    '''Read YAML file and return as python dictionary'''\n    # http://stackoverflow.com/a/21912744/943773\n\n    class OrderedLoader(Loader):\n        pass\n\n    def construct_mapping(loader, node):\n        loader.flatten_mapping(node)\n        return object_pairs_hook(loader.construct_pairs(node))\n\n    OrderedLoader.add_constructor(\n        yaml.resolver.BaseResolver.DEFAULT_MAPPING_TAG,\n        construct_mapping)\n\n    with open(file_path, 'r') as f:\n\n        return yaml.load(f, OrderedLoader)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nwrites python dictionary to YAML", "response": "def write_yaml(data, out_path, Dumper=yaml.Dumper, **kwds):\n    '''Write python dictionary to YAML'''\n    import errno\n    import os\n\n    class OrderedDumper(Dumper):\n        pass\n    def _dict_representer(dumper, data):\n        return dumper.represent_mapping(\n            yaml.resolver.BaseResolver.DEFAULT_MAPPING_TAG,\n            data.items())\n\n    OrderedDumper.add_representer(OrderedDict, _dict_representer)\n\n    # Make directory for calibration file if does not exist\n    base_path, file_name = os.path.split(out_path)\n    try:\n        os.makedirs(base_path)\n    except OSError as exc: # Python >2.5\n        if exc.errno == errno.EEXIST and os.path.isdir(base_path):\n            pass\n        else: raise\n\n    # Write dictionary to YAML\n    with open(out_path, 'w') as f:\n        return yaml.dump(data, f, OrderedDumper, default_flow_style=False, **kwds)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns list of named patterns", "response": "def _get_named_patterns():\n    \"\"\"Returns list of (pattern-name, pattern) tuples\"\"\"\n    resolver = urlresolvers.get_resolver(None)\n    patterns = sorted([(key, value[0][0][0])\n                       for key, value in resolver.reverse_dict.items()\n                       if isinstance(key, string_types)\n                       ])\n    return patterns"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef join_state_collections( collection_a, collection_b):\n    \n    return StateCollection(\n            (collection_a.states + collection_b.states), \n            { grouping_name:_combined_grouping_values(grouping_name, collection_a,collection_b)\n                for grouping_name in set( list(collection_a.groupings.keys()) + list(collection_b.groupings.keys()) ) })", "response": "Join two state collections."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding a grouping to a state collection by using the process selected by grouping_name", "response": "def add_grouping(state_collection, grouping_name, loaded_processes, overriding_parameters=None):\n    \"\"\"\n    Adds a grouping to a state collection by using the process selected by the grouping name\n    \n    Does not override existing groupings\n    \"\"\"\n    if (\n        grouping_name not in state_collection.groupings and\n        loaded_processes != None and\n        loaded_processes[\"grouping_selector\"].get(grouping_name) != None\n    ):\n        state_collection = loaded_processes[\"grouping_selector\"][grouping_name].process_function(state_collection,overriding_parameters)\n    return state_collection"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding a group to the named grouping", "response": "def add_group_to_grouping(state_collection, grouping_name, group, group_key=None):\n    \"\"\"\n    Adds a group to the named grouping, with a given group key\n\n    If no group key is given, the lowest available integer becomes the group key\n\n    If no grouping exists by the given name a new one will be created\n\n    Replaces any group with the same grouping_name and the same group_key\n    \"\"\"\n    if state_collection.groupings.get(grouping_name) is None:\n        state_collection.groupings[grouping_name]= {}\n    if group_key is None:\n        group_key= _next_lowest_integer(state_collection.groupings[grouping_name].keys())\n    state_collection.groupings[grouping_name][group_key]= group\n    return state_collection"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _combined_grouping_values(grouping_name,collection_a,collection_b):\n    new_grouping= collection_a.groupings.get(grouping_name,{}).copy()\n    new_grouping.update(collection_b.groupings.get(grouping_name,{}))\n    return new_grouping", "response": "Returns a dict with values from both collections for a given grouping name"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the next available integer in a set of keys", "response": "def _next_lowest_integer(group_keys):\n    \"\"\"\n    returns the lowest available integer in a set of dict keys\n    \"\"\"\n    try: #TODO Replace with max default value when dropping compatibility with Python < 3.4\n        largest_int= max([ int(val) for val in group_keys if _is_int(val)])\n    except:\n        largest_int= 0\n    return largest_int + 1"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nbuilding a uref and fetches an access list for the user with the given email and matching uid.", "response": "def get_access_list( self, email, uid ):\n        '''\n            Takes and email and matching uid, builds a uref and fetches an access structure that looks like:\n\n            {\n              \"count\": 1, \n              \"code\": 0, \n              \"ts\": 1428522205, \n              \"limit\": 100, \n              \"offset\": 0, \n              \"total\": 1, \n              \"data\": [\n                {\n                  \"granted\": true, \n                  \"resource\": {\n                    \"aid\": \"J8MY0Bu8Xs\", \n                    \"rid\": \"RESOURCE_MONTHLY\", \n                    \"image_url\": \"/images2/default/file-document.png\", \n                    \"name\": \"Month\", \n                    \"description\": \"\"\n                  }, \n                  \"user\": {\n                    \"first_name\": \"WackoJacko\", \n                    \"last_name\": \"AndDot\", \n                    \"email\": \"dotswill@echo.net\", \n                    \"api_token\": \"CDEADBEEFcafebabe0x1337KxYzCiuIHaX0Ri3GH\"\n                  }, \n                  \"access_id\": \"1VShIZzLeIod\"\n                }\n              ]\n            }\n\n        '''\n        path = '/api/v3/access/list'\n\n        # package the user\n        userRef = {\n            'uid': uid,\n            'email': email,\n            'timestamp': int(time.time())\n        }\n        serialized = json.dumps(userRef)#, indent=2)\n        user_ref = utinypass.crypto.aesencrypt(self.private_key, serialized)\n\n        # prepare the request        \n        data = {\n            'aid': self.app_id,\n            'user_ref': user_ref, \n        }\n\n        # doit\n        r = requests.get( self.base_url + path, data=data )\n\n        if r.status_code != 200:\n            raise ValueError( path + \":\" + r.reason )\n\n        access_struct = json.loads( r.content )\n\n        return access_struct"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngranting access to a user.", "response": "def grant_user_access( self, uid, rid, expire_datetime = None, send_email=False ):\n        '''\n            Takes a user id and resource id and records a grant of access to that reseource for the user.\n            If no expire_date is set, we'll default to 24 hours.\n            If send_email is set to True, Tinypass will send an email related to the grant.\n            No return value, raises ValueError.\n        '''\n        path =  \"/api/v3/publisher/user/access/grant\"\n        \n        # convert expire_date to gmt seconds\n        if expire_datetime:\n            expires_seconds = calendar.timegm(expires_datetime.timetuple())\n        else:\n            expires_seconds = calendar.timegm(datetime.datetime.now().timetuple()) + (60*60*24)\n\n        data = {\n            'api_token': self.api_token, \n            'aid': self.app_id,\n            'rid': rid,\n            'uid': uid,\n            'expire_date': expires_seconds,\n            'send_email': send_email,\n        }\n\n        r = requests.get( self.base_url + path, data=data )\n\n        if r.status_code != 200:\n            raise ValueError( path + \":\" + r.reason )"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef revoke_user_access( self, access_id ):\n        '''\n            Takes an access_id, probably obtained from the get_access_list structure, and revokes that access.\n            No return value, but may raise ValueError.\n        ''' \n        path = \"/api/v3/publisher/user/access/revoke\"\n\n        data = {\n            'api_token': self.api_token, \n            'access_id': access_id,\n        }\n\n        r = requests.get( self.base_url + path, data=data )\n\n        if r.status_code != 200:\n            raise ValueError( path + \":\" + r.reason )", "response": "Revokes a user s access from a user s list."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_user( self, uid, disabled=False ):\n        ''' given a uid, returns\n        {\n        first_name (string): User's first name,\n        image1 (string): User's profile image,\n        email (string): User's email address,\n        create_date (string): The creation date,\n        last_name (string): User's last name,\n        uid (string): User's UID\n        }\n\n        You can pass disabled=True if you'd like to get the user even if the user has been disabled.\n        '''\n        path = \"/api/v3/publisher/user/get\"\n\n        data = {\n            'api_token': self.api_token,\n            'aid': self.app_id,\n            'uid': uid,\n            'disabled': disabled,\n        }\n\n        r = requests.get( self.base_url + path, data=data )\n\n        if r.status_code == 2:\n            raise ValueError( path + \":\" + r.reason )  # An Auth issue\n\n        if r.status_code == 2004:\n            return None # no user found\n\n        res = json.loads( r.content )\n\n        # great the error could be in the json\n        if res.has_key( 'code' ):\n            if res['code'] != 0:\n                # 403 == auth error, 2004 = not found, 2 = access denied\n                if res['code'] == 2:\n                    raise ValueError( path + \":\" + res['message'] )  # An Auth issue\n                print res\n                return None\n\n        return res['user']", "response": "given a uid returns a user object"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _send_head(self):\n        self._transport.write(\"{} {} HTTP/1.1\\r\\n\".format(self._method, self._url).encode())\n        for header in self._headers:\n            self._transport.write(\"{}:{}\\r\\n\".format(header, self._headers[header]).encode())\n        self._transport.write(b\"\\r\\n\")\n        print(\"Sent head\")\n#        self._request_future = asyncio.async(self._send_body())\n\n#        self._event_loop.run_until_complete(self._conn_coroutine)\n\n        \"\"\"\n        if method == \"POST\":\n            headers[\"Expect\"] = \"100-continue\"\n#            headers[\"Content-Length\"] = str(len(body))\n            headers[\"Transfer-Encoding\"] = \"chunked\"\n        self._ready_to_send_body = False\n        self._eof_received = False\n        self.body = body\n        self.response = b\"\"\n        self.transport.write(\"{} {} HTTP/1.1\\r\\n\".format(method, url).encode())\n        for header in headers:\n            self.transport.write(\"{}:{}\\r\\n\".format(header, headers[header]).encode())\n        self.transport.write(b\"\\r\\n\")\n        self._send_body()\n        return self.response\n        \"\"\"", "response": "Send the HTTP HEAD request."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ndelivers the results in a pretty text output.", "response": "def deliverTextResults(self):\n        \"\"\"\n        Deliver the results in a pretty text output.\n\n        @return: Pretty text output!\n        \"\"\"\n\n        output = \"=======================\\ntxctools Hotspot Report\\n\"\\\n        \"=======================\\n\\n\"\n\n        fileResults = sorted(self.fileCounts.items(),\n            key=lambda x: x[1][\"warning_count\"], reverse=True)\n\n        output += \"Warnings per File\\n=================\\n\"\n        count = 0\n\n        for item in fileResults:\n            count += 1\n            output += \"#%s - %s - %s\\n\" % (count, item[0],\n                item[1][\"warning_count\"])\n\n        output += \"\\nWarnings Breakdown\\n==================\\n\"\n        count = 0\n        warningCount = 0\n\n        warningResults = sorted(self.warningCounts.items(),\n            key=lambda x: x[1][\"count\"], reverse=True)\n\n        for item in warningResults:\n            warningCount += item[1][\"count\"]\n\n        for warning, winfo in warningResults:\n            count += 1\n            output += \"#%s - %s - %s (%s%%) - %s\\n\" % (count, warning,\n                winfo[\"count\"], int(winfo[\"count\"] / warningCount * 100),\n                tools.cleanupMessage(warning, winfo))\n\n        return output"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _warnCount(self, warnings, warningCount=None):\n        if not warningCount:\n            warningCount = {}\n\n        for warning in warnings:\n            wID = warning[\"warning_id\"]\n            if not warningCount.get(wID):\n                warningCount[wID] = {}\n                warningCount[wID][\"count\"] = 1\n                warningCount[wID][\"message\"] = warning.get(\"warning_message\")\n            else:\n                warningCount[wID][\"count\"] += 1\n\n        return warningCount", "response": "Calculate the count of each warning being given a list of them."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nchecks if you are in a channel.", "response": "def is_in_channel(self, channel, should_be=True):\n        \"\"\"\n        Find out if you are in a channel.\n        Required arguments:\n        * channel - Channel to check whether you are in it or not.\n        * should_be - If True, raise an exception if you aren't in the channel;\n                    If False, raise an exception if you are in the channel.\n        \"\"\"\n        with self.lock:\n            for channel_ in self.channels:\n                if self.compare(channel_, channel):\n                    if not should_be:\n                        raise \\\n                    self.AlreadyInChannel('LurklibError: AlreadyInChannel')\n                    return None\n            if should_be:\n                raise self.NotInChannel('LurklibError: NotInChannel')"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef join_(self, channel, key=None, process_only=False):\n\n        with self.lock:\n            topic = ''\n            users = []\n            set_by = ''\n            time_set = ''\n            self.is_in_channel(channel, False)\n            if not process_only:\n                if key:\n                    self.send('JOIN %s %s' % (channel, key))\n                else:\n                    self.send('JOIN %s' % channel)\n\n            while self.readable(4):\n                msg = self._recv(rm_colon=True, \\\n                                 expected_replies=('332', '333', \\\n                                                   '353', 'JOIN', '366'))\n\n                if msg[0] == '332':\n                    topic = msg[2].split(':', 1)[1]\n                elif msg[0] == '333':\n                    set_by, time_set = msg[2].split(' ', 3)[1:]\n                    if not self.UTC:\n                        time_set = self._m_time.localtime(int(time_set))\n                    else:\n                        time_set = self._m_time.gmtime(int(time_set))\n                    set_by = self._from_(set_by)\n\n                elif msg[0] == '353':\n                    users.extend(msg[2].split(':', 1)[1].split())\n                elif msg[0] == 'JOIN':\n                    channel = msg[1]\n                    self.channels[channel] = {}\n                    if not self.hide_called_events:\n                        self.stepback(append=True)\n                elif msg[0] == '366':\n                    break\n            self.channels[channel] = {}\n            self.channels[channel]['USERS'] = {}\n            for user in users:\n                prefix = ''\n                if user[0] in self.priv_types:\n                    prefix = user[0]\n                    user = user[1:]\n                if prefix == '~':\n                    self.channels[channel]['USERS'][user] = \\\n                    ['~', '', '', '', '']\n                elif prefix == '&':\n                    self.channels[channel]['USERS'][user] = \\\n                    ['', '&', '', '', '']\n                elif prefix == '@':\n                    self.channels[channel]['USERS'][user] = \\\n                    ['', '', '@', '', '']\n                elif prefix == '%':\n                    self.channels[channel]['USERS'][user] = \\\n                    ['', '', '', '%', '']\n                elif prefix == '+':\n                    self.channels[channel]['USERS'][user] = \\\n                    ['', '', '', '', '+']\n                else:\n                    self.channels[channel]['USERS'][user] = \\\n                    ['', '', '', '', '']\n        return users, topic, set_by, time_set", "response": "Joins a channel.\n        Returns a tuple of information regarding the channel.\n        Channel Information:\n        * [0] - A tuple containing /NAMES.\n        * [1] - Channel topic.\n        * [2] - Tuple containing information regarding of whom set the topic.\n        * [3] - Time object about when the topic was set.\n        Required arguments:\n        * channel - The channel to join.\n        Optional arguments:\n        * key=None - Channel key.\n        * process_only=False - Only process a join, don't request one."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\npart a channel. Required arguments: * channel - Channel to part. Optional arguments: * reason='' - Reason for parting.", "response": "def part(self, channel, reason=''):\n        \"\"\"\n        Part a channel.\n        Required arguments:\n        * channel - Channel to part.\n        Optional arguments:\n        * reason='' - Reason for parting.\n        \"\"\"\n        with self.lock:\n            self.is_in_channel(channel)\n\n            self.send('PART %s :%s' % (channel, reason))\n            msg = self._recv(expected_replies=('PART',))\n            if msg[0] == 'PART':\n                del self.channels[msg[1]]\n                if not self.hide_called_events:\n                    self.stepback()"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset or gets the channel mode.", "response": "def cmode(self, channel, modes=''):\n        \"\"\"\n        Sets or gets the channel mode.\n        Required arguments:\n        * channel - Channel to set/get modes of.\n        Optional arguments:\n        * modes='' - Modes to set.\n            If not specified return the modes of the channel.\n        \"\"\"\n        with self.lock:\n            self.is_in_channel(channel)\n\n            if not modes:\n                    self.send('MODE %s' % channel)\n                    modes = ''\n                    mode_set_time = None\n                    while self.readable():\n                        msg = self._recv(rm_colon=True, \\\n                        expected_replies=('324', '329'))\n                        if msg[0] == '324':\n                            modes = msg[2].split()[1].replace('+', '', 1)\n                        elif msg[0] == '329':\n                            mode_set_time = self._m_time.localtime( \\\n                                                        int(msg[2].split()[1]))\n                    return modes, mode_set_time\n            else:\n                self.send('MODE %s %s' % (channel, modes))\n\n                if self.readable():\n                    msg = self._recv(expected_replies=('MODE',), \\\n                                         ignore_unexpected_replies=True)\n                    if msg[0]:\n                        mode = msg[2]\n                        self.parse_cmode_string(mode, msg[1])\n                        if not self.hide_called_events:\n                            self.stepback()"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the banlist for a specific channel.", "response": "def banlist(self, channel):\n        \"\"\"\n        Get the channel banlist.\n        Required arguments:\n        * channel - Channel of which to get the banlist for.\n        \"\"\"\n        with self.lock:\n            self.is_in_channel(channel)\n\n            self.send('MODE %s b' % channel)\n            bans = []\n\n            while self.readable():\n                msg = self._recv(expected_replies=('367', '368'))\n                if msg[0] == '367':\n                    banmask, who, timestamp = msg[2].split()[1:]\n                    bans.append((self._from_(banmask), who, \\\n                                 self._m_time.localtime(int(timestamp))))\n                elif msg[0] == '368':\n                    break\n            return bans"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef exceptlist(self, channel):\n        with self.lock:\n            self.is_in_channel(channel)\n\n            self.send('MODE %s e' % channel)\n            excepts = []\n\n            while self.readable():\n                msg = self._recv(expected_replies=('348', '349'))\n\n                if msg[0] == '348':\n                    exceptmask, who, timestamp = msg[2].split()[1:]\n                    excepts.append((self._from_(exceptmask), who, \\\n                                    self._m_time.localtime(int(timestamp))))\n                elif msg[0] == '349':\n                    break\n\n            return excepts", "response": "Get the exceptlist for a specific channel."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets the list of invitelist for a specific channel.", "response": "def invitelist(self, channel):\n        \"\"\"\n        Get the channel invitelist.\n        Required arguments:\n        * channel - Channel of which to get the invitelist for.\n        \"\"\"\n        with self.lock:\n            self.is_in_channel(channel)\n\n            self.send('MODE %s i' % channel)\n            invites = []\n\n            while self.readable():\n                msg = self._recv(expected_replies=('346', '347'))\n\n                if msg[0] == '346':\n                    invitemask, who, timestamp = msg[2].split()[1:]\n                    invites.append((self._from_(invitemask), who, \\\n                                    self._m_time.localtime(int(timestamp))))\n                elif msg[0] == '347':\n                    break\n\n            return invites"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets or gets the topic for a specific channel.", "response": "def topic(self, channel, topic=None):\n        \"\"\"\n        Sets/gets the channel topic.\n        Required arguments:\n        * channel - Channel to set/get the topic for.\n        Optional arguments:\n        * topic - Topic to set.\n            If not specified the current channel topic will be returned.\n        \"\"\"\n        with self.lock:\n            self.is_in_channel(channel)\n\n            if topic:\n                self.send('TOPIC %s :%s' % (channel, topic))\n                if self.readable():\n                    msg = self._recv(expected_replies=('TOPIC',))\n                    if msg[0] == 'TOPIC' and self.hide_called_events:\n                        channel = msg[1]\n                        self.channels[channel]['TOPIC'] = \\\n                        msg[2].replace(':', '', 1)\n                        if not self.hide_called_events:\n                            self.stepback()\n            else:\n                topic = ''\n                set_by = ''\n                time_set = ''\n                self.send('TOPIC %s' % channel)\n                while self.readable():\n                    msg = self._recv(expected_replies=('332', '333', '331'))\n                    if msg[0] == '332':\n                        topic = msg[2].split(':', 1)[1]\n                    elif msg[0] == '333':\n                        set_by, time_set = msg[2].split()[1:]\n                        if self.UTC == False:\n                            time_set = self._m_time.localtime(int(time_set))\n                        else:\n                            time_set = self._m_time.gmtime(int(time_set))\n                        set_by = self._from_(set_by)\n                    elif msg[0] == '331':\n                        topic = ''\n\n                return topic, set_by, time_set"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef names(self, channel):\n        with self.lock:\n            self.is_in_channel(channel)\n\n            self.send('NAMES %s' % channel)\n            names = []\n\n            while self.readable():\n                msg = self._recv(expected_replies=('353', '366'))\n\n                if msg[0] == '353':\n                    new_names = msg[2].split()[2:]\n                    new_names[0] = new_names[0].replace(':', '', 1)\n                    names.extend(new_names)\n                elif msg[0] == '366':\n                    channel = msg[2].split()[0]\n                    break\n\n            for name in names:\n                prefix = ''\n                if name[0] in self.priv_types:\n                    prefix = name[0]\n                    name = name[1:]\n                if prefix == '~':\n                    self.channels[channel]['USERS'][name] = \\\n                    ['~', '', '', '', '']\n                elif prefix == '&':\n                    self.channels[channel]['USERS'][name] = \\\n                    ['', '&', '', '', '']\n                elif prefix == '@':\n                    self.channels[channel]['USERS'][name] = \\\n                    ['', '', '@', '', '']\n                elif prefix == '%':\n                    self.channels[channel]['USERS'][name] = \\\n                    ['', '', '', '%', '']\n                elif prefix == '+':\n                    self.channels[channel]['USERS'][name] = \\\n                    ['', '', '', '', '+']\n                else:\n                    self.channels[channel]['USERS'][name] = \\\n                    ['', '', '', '', '']\n            return names", "response": "Get a list of users in a channel."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a list of channels on the server.", "response": "def list_(self):\n        \"\"\" Gets a list of channels on the server. \"\"\"\n        with self.lock:\n            self.send('LIST')\n            list_ = {}\n\n            while self.readable():\n                msg = self._recv(expected_replies=('322', '321', '323'))\n\n                if msg[0] == '322':\n                    channel, usercount, modes, topic = msg[2].split(' ', 3)\n                    modes = modes.replace(':', '', 1).replace(':', '', 1)\n                    modes = modes.replace('[', '').replace( \\\n                                                    ']', '').replace('+', '')\n                    list_[channel] = usercount, modes, topic\n                elif msg[0] == '321':\n                    pass\n                elif msg[0] == '323':\n                    break\n\n            return list_"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef invite(self, channel, nick):\n        with self.lock:\n            self.is_in_channel(channel)\n\n            self.send('INVITE %s %s' % (nick, channel))\n\n            while self.readable():\n                    msg = self._recv(expected_replies=('341', '301'))\n\n                    if msg[0] == '341':\n                        pass\n                    elif msg[0] == '301':\n                        away_msg = msg[2].split()[1].replace(':', '', 1)\n                        return 'AWAY', away_msg", "response": "Invite someone to a channel."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nkicking someone from a channel.", "response": "def kick(self, channel, nick, reason=''):\n        \"\"\"\n        Kick someone from a channel.\n        Required arguments:\n        * channel - Channel to kick them from.\n        * nick - Nick to kick.\n        Optional arguments:\n        * reason - Reason for the kick.\n        \"\"\"\n        with self.lock:\n            self.is_in_channel(channel)\n\n            self.send('KICK %s %s :%s' % (channel, nick, reason))\n\n            if self.readable():\n                msg = self._recv(expected_replies=('KICK',))\n\n                if msg[0] == 'KICK':\n                    channel = msg[1]\n                    if not self.hide_called_events:\n                        self.stepback()\n\n            if self.compare(self.current_nick, nick):\n                del self.channels[channel]"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef parse_cmode_string(self, mode_string, channel):\n        with self.lock:\n            modes = mode_string.split()\n            targets = modes[1:]\n            modes = modes[0][1:].split()\n\n            if mode_string[0] == '+':\n                plus_mode = True\n            else:\n                plus_mode = False\n            for mode in modes:\n                if mode in self.priv_types:\n                    target = targets[modes.index(mode)]\n                    if plus_mode:\n                        if mode == 'q':\n                            self.channels[channel]['USERS'][target][0] = '~'\n                        elif mode == 'a':\n                            self.channels[channel]['USERS'][target][1] = '&'\n                        elif mode == 'o':\n                            self.channels[channel]['USERS'][target][2] = '@'\n                        elif mode == 'h':\n                            self.channels[channel]['USERS'][target][3] = '%'\n                        elif mode == 'v':\n                            self.channels[channel]['USERS'][target][4] = '+'\n                    else:\n                        if mode == 'q':\n                            self.channels[channel]['USERS'][target][0] = ''\n                        elif mode == 'a':\n                            self.channels[channel]['USERS'][target][1] = ''\n                        elif mode == 'o':\n                            self.channels[channel]['USERS'][target][2] = ''\n                        elif mode == 'h':\n                            self.channels[channel]['USERS'][target][3] = ''\n                        elif mode == 'v':\n                            self.channels[channel]['USERS'][target][4] = ''", "response": "Parse a mode string and update the IRC. channels dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef read_config(cls):\n\t\tWAppsGlobals.config = WConfig()\n\n\t\tdef load(filename):\n\t\t\tif os.path.isfile(filename) is False:\n\t\t\t\traise RuntimeError(\"Invalid configuration: '%s'\" % filename)\n\t\t\tWAppsGlobals.config.merge(filename)\n\t\t\tWAppsGlobals.log.info('Configuration loaded from file: %s' % os.path.abspath(filename))\n\n\t\tload(cls.__configuration_default__)\n\n\t\tif cls.__environment_file_var__ in os.environ:\n\t\t\tWAppsGlobals.log.info('Variable %s was set' % cls.__environment_file_var__)\n\t\t\tload(os.environ[cls.__environment_file_var__])\n\n\t\tif cls.__environment_dir_var__ in os.environ:\n\t\t\tWAppsGlobals.log.info('Variable %s was set' % cls.__environment_dir_var__)\n\t\t\tconfig_dir = os.environ[cls.__environment_dir_var__]\n\t\t\tif os.path.isdir(config_dir) is False:\n\t\t\t\tWAppsGlobals.log.error(\n\t\t\t\t\t'Invalid configuration directory was specified: \"%s\"' % config_dir\n\t\t\t\t)\n\n\t\t\tentries = list(os.listdir(config_dir))\n\t\t\tentries.sort()\n\t\t\tfor entry in entries:\n\t\t\t\tconfig_file = os.path.join(config_dir, entry)\n\t\t\t\tif os.path.isfile(config_file) is False:\n\t\t\t\t\tWAppsGlobals.log.error(\n\t\t\t\t\t\t'Invalid configuration \"%s\" in the directory \"%s\"' %\n\t\t\t\t\t\t(config_file, config_dir)\n\t\t\t\t\t)\n\t\t\t\t\tcontinue\n\n\t\t\t\tload(config_file)", "response": "Setup :attr:`wasp_launcher.apps.WAppsGlobals.log` configuration. Reads defaults and\n\t\toverride it by a file given via :attr:`WConfigApp.__environment_file_var__` environment variable.\n\t\tAfter that configuration files are applied from :attr:`WConfigApp.__environment_dir_var__`\n\n\t\t:return: None"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef servers_with_roles(self, roles, env=None, match_all=False):\n        result = []\n        roles = set(roles)\n        for instance in self.server_details():\n            instroles = set(instance['roles'])\n            envmatches = (env is None) or (instance['environment'] == env)\n            if envmatches and match_all and roles <= instroles:\n                result.append(instance)\n            elif envmatches and not match_all and len(roles & instroles) > 0:\n                result.append(instance)\n        return result", "response": "Get servers with the given roles."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a function that returns a list of servers with the given roles.", "response": "def ips_with_roles(self, roles, env=None, match_all=False):\n        \"\"\"\n        Returns a function that, when called, gets servers with the given roles.\n        If env is given, then the environment must match as well.  If match_all is True,\n        then only return servers who have all of the given roles.  Otherwise, return\n        servers that have one or more of the given roles.\n        \"\"\"\n        def func():\n            return [s['external_ip'] for s in self.servers_with_roles(roles, env, match_all)]\n        return func"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef filter_factory(global_conf, **local_conf):\n    conf = global_conf.copy()\n    conf.update(local_conf)\n\n    def check_last_ip(app):\n        return LastIpCheck(app, conf)\n    return check_last_ip", "response": "Returns a WSGI filter app for use with paste. deploy."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate a Dictionary at spellchecker_cache_path with valid words.", "response": "def create(spellchecker_cache_path):\n    \"\"\"Create a Dictionary at spellchecker_cache_path with valid words.\"\"\"\n    user_dictionary = os.path.join(os.getcwd(), \"DICTIONARY\")\n    user_words = read_dictionary_file(user_dictionary)\n\n    valid_words = Dictionary(valid_words_set(user_dictionary, user_words),\n                             \"valid_words\",\n                             [user_dictionary],\n                             spellchecker_cache_path)\n\n    return (user_words, valid_words)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef process_event(self, event):\n        if not isinstance(event, KindleEvent):\n            pass\n        elif isinstance(event, AddEvent):\n            self._data[event.asin] = BookSnapshot(event.asin)\n        elif isinstance(event, SetReadingEvent):\n            self._data[event.asin].status = ReadingStatus.CURRENT\n            self._data[event.asin].progress = event.initial_progress\n        elif isinstance(event, ReadEvent):\n            self._data[event.asin].progress += event.progress\n        elif isinstance(event, SetFinishedEvent):\n            self._data[event.asin].status = ReadingStatus.COMPLETED\n        else:\n            raise TypeError", "response": "Apply an event to the snapshot instance"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef calc_update_events(self, asin_to_progress):\n        new_events = []\n        for asin, new_progress in asin_to_progress.iteritems():\n            try:\n                book_snapshot = self.get_book(asin)\n            except KeyError:\n                new_events.append(AddEvent(asin))\n            else:\n                if book_snapshot.status == ReadingStatus.CURRENT:\n                    change = new_progress - book_snapshot.progress\n                    if change > 0:\n                        new_events.append(ReadEvent(asin, change))\n        return new_events", "response": "Calculate and return an iterable of KindleEvent s which when when\n        applied to the current snapshot result in the current snapshot\n        reflecting the progress of the current snapshot."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nrebuilding the structure for AST and resets internal data.", "response": "def _reset(self):\n        \"\"\" Rebuilds structure for AST and resets internal data.\n            \"\"\"\n\n        self._filename = None\n        self._block_map = {}\n        self._ast = []\n        self._ast.append(None)  # header\n        self._ast.append([])    # options list\n        self._ast.append([])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nconsuming the next token in the token stream.", "response": "def _get_token(self, regex=None):\n        \"\"\" Consumes the next token in the token stream.\n\n            `regex`\n                Validate against the specified `re.compile()` regex instance.\n\n            Returns token string.\n\n            * Raises a ``ParseError`` exception if stream is empty or regex\n              match fails.\n            \"\"\"\n\n        item = self._lexer.get_token()\n\n        if not item:\n            raise ParseError(u'Unexpected end of file')\n        else:\n            line_no, token = item\n            if regex and not regex.match(token):\n                pattern = u\"Unexpected format in token '{0}' on line {1}\"\n                token_val = common.from_utf8(token.strip())\n                raise ParseError(pattern.format(token_val, line_no))\n\n            return token"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\npeeking into the token stream up to the specified number of tokens without consuming any tokens from the stream. ``count`` Look ahead in stream up to a maximum number of tokens. Returns string token or ``None``.", "response": "def _lookahead_token(self, count=1):\n        \"\"\" Peeks into the token stream up to the specified number of tokens\n            without consuming any tokens from the stream.\n\n            ``count``\n                Look ahead in stream up to a maximum number of tokens.\n\n            Returns string token or ``None``.\n            \"\"\"\n\n        stack = []\n        next_token = None\n\n        # fetch the specified number of tokens ahead in stream\n        while count > 0:\n            item = self._lexer.get_token()\n            if not item:\n                break\n            stack.append(item)\n            count -= 1\n\n        # store the latest token and push the tokens back on the\n        # lexer stack so we don't consume them\n        while stack:\n            line_no, token = stack.pop()\n\n            if not next_token:\n                next_token = token\n            self._lexer.push_token(line_no, token)\n\n        return next_token"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _expect_token(self, expected):\n\n        item = self._lexer.get_token()\n\n        if not item:\n            raise ParseError(u'Unexpected end of file')\n\n        else:\n            line_no, token = item\n\n        if token != expected:\n            raise ParseError(u\"Unexpected token '{0}', \"\n                             u\"expecting '{1}' on line {2}\"\n                             .format(common.from_utf8(token.strip()), expected,\n                                     line_no))", "response": "Compare the next token in the stream to the specified token."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _expect_empty(self):\n\n        item = self._lexer.get_token()\n        if item:\n            line_no, token = item\n            raise ParseError(u\"Unexpected token '{0}' on line {1}\"\n                             .format(common.from_utf8(token.strip()), line_no))", "response": "Checks if the token stream is empty."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nparsing the production rule :: container.", "response": "def _rule_container(self):\n        \"\"\" Parses the production rule::\n                container : NAME '{' (option | block)* '}' EOF\n\n            Returns tuple (type_name, options_list, blocks_list).\n            \"\"\"\n\n        type_name = self._get_token(self.RE_NAME)\n        self._expect_token('{')\n\n        # consume elements if available\n        options = []\n        blocks = []\n        dupe_blocks = {}\n\n        while self._lookahead_token() != '}':\n            # is it a block?\n            if self._lookahead_token(count=2) == '{':\n                block = self._rule_block()\n                name = block[0]\n\n                # duplicate found, hold for replace\n                if name in self._block_map:\n                    dupe_blocks[name] = block\n                else:\n                    # update block index and add to block list\n                    self._block_map[name] = len(blocks)\n                    blocks.append(block)\n\n            else:\n                # otherwise, let's go with non-block option\n                options.append(self._rule_option())\n\n        # replace duplicate block definitions\n        if dupe_blocks:\n            for name, block in dupe_blocks.iteritems():\n                block_idx = self._block_map[name]\n                blocks[block_idx] = block\n\n        self._expect_token('}')\n        self._expect_empty()\n\n        return [type_name, options, blocks]"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nparses the production rule :: option NAME value ; returns list of name and value.", "response": "def _rule_option(self):\n        \"\"\" Parses the production rule::\n                option : NAME value ';'\n\n            Returns list (name, value_list).\n            \"\"\"\n\n        name = self._get_token(self.RE_NAME)\n        value = self._rule_value()\n        self._expect_token(';')\n        return [name, value]"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nparses the production rule :: value returns a list of string terms.", "response": "def _rule_value(self):\n        \"\"\" Parses the production rule::\n                value : TERM (',' TERM)*\n\n            Returns list of string terms.\n            \"\"\"\n\n        terms = [self._get_token()]\n\n        # consume additional terms if available\n        while self._lookahead_token() == ',':\n            self._get_token()  # chomp the comma\n            terms.append(self._get_token())\n\n        return terms"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nparses the production rule :: block returns the name and options_list.", "response": "def _rule_block(self):\n        \"\"\" Parses the production rule::\n                block : NAME '{' option* '}'\n\n            Returns tuple (name, options_list).\n            \"\"\"\n\n        name = self._get_token(self.RE_NAME)\n        self._expect_token('{')\n\n        # consume additional options if available\n        options = []\n        while self._lookahead_token() != '}':\n            options.append(self._rule_option())\n\n        self._expect_token('}')\n        return [name, options]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _parse(self):\n        try:\n            # parse token stream into abstract syntax tree (AST)\n            self._ast = self._rule_container()\n\n        except ParseError:\n            raise\n\n        except Exception as exc:\n            raise ParseError(u'Unexpected error: {0}'.format(unicode(exc)))", "response": "Performs parsing process against token stream and generates the internal abstract syntax tree."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef readstream(self, stream):\n\n        self._reset()\n\n        try:\n            # tokenize input stream\n            self._lexer = SettingLexer()\n            self._lexer.readstream(stream)\n\n            # parse tokens into AST\n            self._parse()\n            return True\n\n        except IOError:\n            self._reset()\n            return False", "response": "Reads the specified stream and parses the token elements generated by the tokenizing function."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nwrites the AST as a configuration file.", "response": "def write(self, filename, header=None):\n        \"\"\" Writes the AST as a configuration file.\n\n            `filename`\n                Filename to save configuration file to.\n            `header`\n                Header string to use for the file.\n\n            Returns boolean.\n            \"\"\"\n\n        origfile = self._filename\n\n        try:\n            with open(filename, 'w') as _file:\n                self.writestream(_file, header)\n                self._filename = filename\n            return True\n\n        except IOError:\n            self._filename = origfile\n            return False"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadd an option to the AST.", "response": "def add_option(self, block, name, *values):\n        \"\"\" Adds an option to the AST, either as a non-block option or for an\n            existing block.\n\n            `block`\n                Block name. Set to ``None`` for non-block option.\n            `name`\n                Option name.\n            `*values`\n                String values for the option.\n\n            * Raises a ``ValueError`` exception if `values` is empty, `name`\n              is invalid, or `block` doesn't exist.\n            \"\"\"\n\n        if not self.RE_NAME.match(name):\n            raise ValueError(u\"Invalid option name '{0}'\"\n                             .format(common.from_utf8(name)))\n\n        if not values:\n            raise ValueError(u\"Must provide a value\")\n        else:\n            values = list(values)\n\n        if block:\n            # block doesn't exist\n            if not block in self._block_map:\n                raise ValueError(u\"Block '{0}' does not exist\"\n                                 .format(common.from_utf8(block)))\n\n            # lookup block index and append\n            block_idx = self._block_map[block]\n\n            # 0: block name, 1: option_list\n            self._ast[2][block_idx][1].append([name, values])\n\n        else:\n            # non-block option\n            self._ast[1].append([name, values])"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef remove_option(self, block, name):\n\n        if block:\n            # block doesn't exist\n            if not self._ast or not block in self._block_map:\n                raise ValueError(u\"Block '{0}' does not exist\"\n                                 .format(common.from_utf8(block)))\n\n            # lookup block index and remove\n            block_idx = self._block_map[block]\n\n            for i, opt in enumerate(self._ast[2][block_idx][1]):\n                if opt[0] == name:\n                    item_idx = i\n                    break\n            else:\n                raise ValueError(u\"Option '{0}' does not exist\"\n                                 .format(common.from_utf8(name)))\n\n            # pop off the block option\n            options = self._ast[2][block_idx][1]\n            options.pop(item_idx)\n\n        else:\n            if not self._ast:\n                raise ValueError(u\"Option '{0}' does not exist\"\n                                 .format(common.from_utf8(name)))\n\n            # non-block option\n            for i, opt in enumerate(self._ast[1]):\n                if opt[0] == name:\n                    item_idx = i\n                    break\n            else:\n                raise ValueError(u\"Option '{0}' does not exist\"\n                                 .format(common.from_utf8(name)))\n\n            # pop off non-block option\n            self._ast[1].pop(item_idx)", "response": "Removes first matching option that exists from the AST."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add_block(self, name):\n\n        if not self.RE_NAME.match(name):\n            raise ValueError(u\"Invalid block name '{0}'\"\n                             .format(common.from_utf8(name)))\n\n        if name in self._block_map:\n            raise ValueError(u\"Block '{0}' already exists\"\n                             .format(common.from_utf8(name)))\n\n        # add new block and index mapping\n        self._block_map[name] = len(self._ast[2])  # must come first\n        option_list = []\n        block = [name, option_list]\n        self._ast[2].append(block)", "response": "Adds a new block to the AST."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef remove_block(self, name):\n\n        if not self._ast or not name in self._block_map:\n            raise ValueError(u\"Block '{0}' does not exist\"\n                             .format(common.from_utf8(name)))\n\n        block_idx = self._block_map[name]\n\n        # remove block\n        self._ast[2].pop(block_idx)\n        del self._block_map[name]", "response": "Removes an existing block from the AST."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef init(db_url, alembic_ini=None, debug=False, create=False):\n    engine = create_engine(db_url, echo=debug)\n\n    if create:\n        BASE.metadata.create_all(engine)\n\n    # This... \"causes problems\"\n    #if db_url.startswith('sqlite:'):\n    #    def _fk_pragma_on_connect(dbapi_con, con_record):\n    #        dbapi_con.execute('pragma foreign_keys=ON')\n    #    sa.event.listen(engine, 'connect', _fk_pragma_on_connect)\n\n    if alembic_ini is not None:  # pragma: no cover\n        # then, load the Alembic configuration and generate the\n        # version table, \"stamping\" it with the most recent rev:\n        from alembic.config import Config\n        from alembic import command\n        alembic_cfg = Config(alembic_ini)\n        command.stamp(alembic_cfg, \"head\")\n\n    scopedsession = scoped_session(sessionmaker(bind=engine))\n    return scopedsession", "response": "Initialize the database with the information from the database."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a random hash for a confirmation secret.", "response": "def hash_producer(*args, **kwargs):\n    \"\"\" Returns a random hash for a confirmation secret. \"\"\"\n    return hashlib.md5(six.text_type(uuid.uuid4()).encode('utf-8')).hexdigest()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef validate_code_path(valid_paths, code_path, **kw):\n\n        root, name = code_path.split(':', 1)\n        if name not in valid_paths[root]:\n            raise ValueError(\"%r is not a valid code_path\" % code_path)", "response": "Validate that the code_path is one of our valid_paths."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nfunctions finds all the python packages under a folder and writes the packages and package_dir entries for a python setup. py script", "response": "def hlp_source_under(folder):\n    \"\"\"\n    this function finds all the python packages under a folder and\n    write the 'packages' and 'package_dir' entries for a python setup.py\n    script\n    \"\"\"\n    # walk the folder and find the __init__.py entries for packages.\n    packages = []\n    package_dir = dict()\n    for root, dirs, files in os.walk(folder):\n        for file in files:\n            if file != '__init__.py':\n                continue\n            full = os.path.dirname(os.path.join(root, file))\n            relative = os.path.relpath(full, folder)\n            packages.append(relative)\n            package_dir[relative] = full\n    # we use pprint because we want the order to always remain the same\n    return 'packages={0},\\npackage_dir={1}'.format(sorted(packages), pprint.pformat(package_dir))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef show(self):\n        for entry in self._entries:\n            print \"{'%s': %s, 'records': %s}\" % (\n                entry._record_type, entry.host, entry.records)\n        print", "response": "Print the entries in the log file."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add_record(self, record):\n        rec = self.get_record(record._record_type, record.host)\n        if rec:\n            rec = record\n            for i,r in enumerate(self._entries):\n                if r._record_type == record._record_type \\\n                        and r.host == record.host:\n                            self._entries[i] = record\n        else:\n            self._entries.append(record)\n        self.sort()\n        return True", "response": "Add or update a given DNS record"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef diff_record(self, record):\n        rec = self.get_record(record._record_type, record.host)\n        if rec is not None and record is not None:\n            return {'removed': tuple(set(rec.results) - set(record.results)),\n                    'added': tuple(set(record.results) - set(rec.recults))}\n        else:\n            return False", "response": "Return the removed and added diffs of a record"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nfetch a DNS record", "response": "def get_record(self, dns_record_type, host):\n        \"\"\"Fetch a DNS record\"\"\"\n        record_list = self._entries\n        for record in record_list:\n            if record._record_type == dns_record_type \\\n                    and record.host == host:\n                return record\n        return False"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef del_record(self, dns_record_type, host):\n        rec = self.get_record(dns_record_type, host)\n        if rec:\n            self._entries = list(set(self._entries) - set([rec]))\n        return True", "response": "Remove a DNS record from the cache."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncreates a record of type record_type and fill it with the given results dict.", "response": "def CreateRecord(record_type, host, results):\n        \"\"\"\n        Create a record of type (record_type) and fill it with the given\n        dict of results\n        \"\"\"\n        record_class = dns_tag_lookup[record_type]\n        record = etree.Element(\"a\")\n        record.set(\"host\", host)\n        for params in results:\n            result = etree.Element(\"result\")\n            for k,v in params.iteritems():\n                result.set(k, v)\n            record.append(result)\n\n        return record_class(record)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating the finalized configuration of the resource record set.", "response": "def config(self):\n        \"\"\"Create the finalized configuration\"\"\"\n        root = etree.Element(\"xml\")\n        resource_records = etree.SubElement(root, \"resource_records\")\n\n        # Append SOA and NS records\n        resource_records.append(SOARecord()._etree)\n        resource_records.append(NSRecord()._etree)\n\n        # Append the rest\n        for record in self._entries:\n            resource_records.append(record._etree)\n\n        return etree.tostring(root, encoding=\"utf-8\",\n                              pretty_print=True)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nparsing a port specification in two forms into a tuple of two - element integers.", "response": "def parsePortSpec(spec, separator='-'):\n    '''\n    Parses a port specification in two forms into the same form.\n\n    In the first form the specification is just an integer. In this case a\n    tuple is returned containing the same integer twice.\n\n    In the second form the specification is two numbers separated by a hyphen\n    ('-' by default, specifiable with :param separator:). The two numbers are\n    parsed as integers and returned in the same order as a tuple of two\n    integers.\n\n    Example:\n\n    .. code-block: python\n\n       parsePortSpec('12345') # -> (12345, 12345)\n       parsePortSpec('12345-56789') # -> (12345, 56789)\n    '''\n    x = list(map(lambda x: x.strip(), spec.split(separator)))\n    return tuple(map(int, x * (3 - len(x))))"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate a UDP socket bound to any interface with the specified port.", "response": "def _createSocket(self, port):\n        '''\n        Creates a UDP socket bound to any interface (empty string host address)\n        but to the specified port.\n        '''\n        self._logger.info(\n            'Setting up UDP socket to listen to port {:}'.format(port))\n        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n\n        sock.settimeout(self._timeout)\n        self._logger.info(\n            'Successfully set socket timeout to {_timeout}'\n            .format(**self.__dict__))\n\n        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        self._logger.info('Successfully set socket option to SO_REUSEADDR')\n\n        sock.bind(('', port))\n        self._logger.info(\n            'Successfully bound socket to (\"\", {port})'\n            .format(port=port, **self.__dict__))\n\n        return sock"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nhandling a readable socket.", "response": "def _handleReadableSocket(self, src_socket):\n        '''\n        :returns: :data:`python:True` if the connect has been disconnected and\n                  :data:`python:False` if the connection is still alive and\n                  everything was processed normally\n        '''\n        msg = src_socket.recv(self._max_message_size)\n        return self._handleMessage(src_socket, msg)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _handleMessage(self, src_socket, msg):\n        '''\n        :returns: :data:`python:True` if the connect has been disconnected and\n                  :data:`python:False` if the connection is still alive and\n                  everything was processed normally\n        '''\n        self._logger.debug('Message received: {!r}'.format(msg))\n\n        # Check where the message came from and determine where it's going\n        if src_socket is self._socket_a:\n            src_name, src_host, src_port = 'A', self._host_a, self._port_a\n            dst_name, dst_host, dst_port = 'B', self._host_b, self._port_b\n            dst_socket = self._socket_b\n        elif src_socket is self._socket_b:\n            src_name, src_host, src_port = 'B', self._host_b, self._port_b\n            dst_name, dst_host, dst_port = 'A', self._host_a, self._port_a\n            dst_socket = self._socket_a\n        else:\n            self._logger.warning(\n                'Message received from unknown socket! How is '\n                'this possible?! Ignoring.')\n            return False\n\n        self._logger.debug(\n            'Message received from host {:} ({!s}:{!s}), routing to host {:} '\n            '({!s}:{!s})'\n            .format(\n                src_name, src_host, src_port,\n                dst_name, dst_host, dst_port))\n\n        # If the message is empty or non-existent then the connection has\n        # closed\n        if not msg or msg == '':\n            self._logger.info(\n                'Connection to host {:} closed'.format(src_name))\n            return True\n\n        # Apply middleware to the message if middleware exists\n        if self._message_middleware is not None:\n            msg = self._message_middleware(\n                msg,\n                src_name, src_host, src_port,\n                dst_name, dst_host, dst_port)\n\n        # Finally send the message\n        dst_socket.send(msg)\n\n        return False", "response": "Handles a message from the specified socket and sends it to the destination socket."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndumping the provided message to this dump.", "response": "def dump(self, msg):\n        '''\n        Dumps the provided message to this dump.\n        '''\n        msg_size = len(msg)\n\n        # We start a new batch if the resulting batch file is larger than the\n        # max batch file size. However, if the current batch file size is zero\n        # then that means the message alone is larger than the max batch file\n        # size. In this case instead of splitting up the message across files\n        # which would greatly increase complexity we simply dump that message\n        # into a file of its own even though it will be larger than the max\n        # batch file size.\n        if self._batch_size + msg_size > self._max_batch_file_size \\\n                and self._batch_size > 0:\n            self._startNewBatch()\n\n        # Write the time stamp and information on how to retrieve the message\n        # from the batch files (batch filename, byte offset, and byte size)\n        global getTime\n        index_file_entry = '{:},{:09d},{:},{:}\\n'.format(\n            getTime(), self._batch_index, self._batch_size, msg_size)\n        if sys.version_info >= (3,):\n            self._index_file.write(index_file_entry.encode('utf-8'))\n        else:\n            self._index_file.write(index_file_entry)\n\n        # Dump the message itself to the current batch file\n        self._batch_file.write(msg)\n        self._batch_size += msg_size\n\n        # Increment message count\n        self._message_count += 1"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef api_client(connection, client_class=xbahn.api.Client):\n\n    return client_class(\n        link=xbahn.connection.link.Link(\n            # use the connection receive messages (server responses)\n            receive=connection,\n            # use the connection to send messages (initiate requests to server)\n            send=connection\n        )\n    )", "response": "Establishes an API client for one - way communication with an API Server"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef api_client_two_way(connection, connection_responder, client_class=xbahn.api.Client):\n\n    # create connection link instance\n    link = xbahn.connection.link.Link()\n\n    # main wire\n    link.wire(\n        \"main\",\n        receive=connection,\n        send=connection,\n        # in order to let the server know how to send messages to client\n        # we include the \"remote\" property in the message meta\n        meta={\n            \"remote\":connection_responder.remote\n        }\n    )\n\n    # response wire\n    link.wire(\n        \"responder\",\n        receive=connection_responder,\n        respond=connection_responder\n    )\n\n    # run api client on connection\n    return client_class(link=link)", "response": "Establishes an API client for a two - way communication with an API Server"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef api_server(connection, server_class):\n\n    # run api server on connection\n    return server_class(\n        link=xbahn.connection.link.Link(\n            # use the connection to receive messages\n            receive=connection,\n            # use the connection to respond to received messages\n            respond=connection\n        )\n    )", "response": "Establishes an API Server on the supplied connection"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nlist all connected nodes", "response": "def list_nodes(search=\"unsigned\"):\n    \"\"\" List all connected nodes\n    \"\"\"\n    nodes = nago.core.get_nodes()\n    if search == \"all\":\n        return map(lambda x: {x[0]: x[1].data}, nodes.items())\n    elif search == 'unsigned':\n        result = {}\n        for token, node in nodes.items():\n            if node.get('access') is None:\n                result[token] = node.data\n        return result\n    else:\n        result = {}\n        for token, node in nodes.items():\n            host_name = node.get('host_name')\n            if search in (token, host_name):\n                result[token] = node.data\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add(node_name, **kwargs):\n    result = {}\n    kwargs = kwargs.copy()\n    overwrite = kwargs.pop('overwrite', False)\n    node = nago.core.get_node(node_name)\n    if not node:\n        node = nago.core.Node()\n    elif not overwrite:\n        result['status'] = 'error'\n        result['message'] = \"node %s already exists. add argument overwrite=1 to overwrite it.\" % (node_name)\n        return result\n    else:\n        node.delete()\n        node = nago.core.Node()\n    node['host_name'] = node_name\n    for k, v in kwargs.items():\n        node[k] = v\n    node.save()\n    result['message'] = \"node successfully saved\"\n    result['node_data'] = node.data\n    return result", "response": "Create a new node and generate a token for it"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef delete(node_name):\n    result = {}\n    node = nago.core.get_node(node_name)\n    if not node:\n        result['status'] = 'error'\n        result['message'] = \"node not found.\"\n    else:\n        node.delete()\n        result['status'] = 'success'\n        result['message'] = 'node deleted.'\n    return result", "response": "Delete a specific node"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsign a specific node to grant it access returns the nodes that were signed", "response": "def sign(node=None):\n    \"\"\" Sign a specific node to grant it access\n\n     you can specify \"all\" to sign all nodes\n\n     returns the nodes that were signed\n    \"\"\"\n    if not node:\n        raise Exception(\"Specify either 'all' your specify token/host_name of node to sign. \")\n    if node == 'all':\n        node = 'unsigned'\n    nodes = list_nodes(search=node)\n    result = {}\n    for token, i in nodes.items():\n        i['access'] = 'node'\n        i.save()\n        result[token] = i\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nchanging the attributes of a connected node", "response": "def set_attribute(token_or_hostname, **kwargs):\n    \"\"\" Change the attributes of a connected node \"\"\"\n    node = nago.core.get_node(token_or_hostname) or {}\n    if not kwargs:\n        return \"No changes made\"\n    for k, v in kwargs.items():\n        node[k] = v\n    node.save()\n    return \"Saved %s changes\" % len(kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nsend an echo request to a nago host.", "response": "def ping(token_or_hostname=None):\n    \"\"\" Send an echo request to a nago host.\n\n    Arguments:\n        token_or_host_name  -- The remote node to ping\n                            If node is not provided, simply return pong\n                            You can use the special nodenames \"server\" or \"master\"\n     \"\"\"\n    if not token_or_hostname:\n        return \"Pong!\"\n    node = nago.core.get_node(token_or_hostname)\n    if not node and token_or_hostname in ('master', 'server'):\n        token_or_hostname = nago.settings.get_option('server')\n        node = nago.core.get_node(token_or_hostname)\n    if not node:\n        try:\n            address = socket.gethostbyname(token_or_hostname)\n            node = nago.core.Node()\n            node['host_name'] = token_or_hostname\n            node['address'] = address\n            node['access'] = 'node'\n            if token_or_hostname == nago.settings.get_option('server'):\n                node['access'] = 'master'\n            node.save()\n        except Exception:\n            raise Exception(\"'%s' was not found in list of known hosts, and does not resolve to a valid address\" % token_or_hostname)\n    return node.send_command('nodes', 'ping')"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nconnect to remote host and show our status", "response": "def connect(remote_host):\n    \"\"\" Connect to remote host and show our status \"\"\"\n    if remote_host in ('master', 'server'):\n        remote_host = nago.settings.get_option('server')\n    node = nago.core.get_node(remote_host)\n    if not node:\n        try:\n            address = socket.gethostbyname(remote_host)\n            node = nago.core.Node()\n            node['host_name'] = remote_host\n            node['address'] = address\n            node['access'] = 'node'\n            if token_or_hostname == nago.settings.get_option('server'):\n                node['access'] = 'master'\n            node.save()\n        except Exception:\n            raise Exception(\"'%s' was not found in list of known hosts, and does not resolve to a valid address\" % remote_host)\n    ping_result = node.send_command('nodes', 'ping')\n    if 'Pong' in ping_result.get('result', ''):\n        return \"Connection with %s ok\" % remote_host\n    else:\n        return ping_result.get('result', ping_result)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nchecks if the service is running.", "response": "def is_running(self):\n        \"\"\"\n        Check if the service is running.\n        \"\"\"\n        try:\n            kill(int(self.pid.get()), 0)\n            return True\n        \n        # Process not running, remove PID/lock file if it exists\n        except:\n            self.pid.remove()\n            self.lock.remove()\n            return False"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef set_output(self):\n        if not self.output:\n            return open(devnull, 'w')\n        \n        # Get the output file path\n        output_dir = dirname(self.output)\n        \n        # Make the path exists\n        if not isdir(output_dir):\n            try:\n                makedirs(output_dir)\n            except Exception as e:\n                self.die('Failed to create output directory \"{}\": {}'.format(output_dir, str(e)))\n        return open(self.output, 'a')", "response": "Set the output for the service command."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nprints the status of the service.", "response": "def do_status(self):\n        \"\"\"\n        Get the status of the service.\n        \"\"\"\n        \n        # Get the PID of the service\n        pid    = self.pid.get()\n        \n        # Status color / attributes\n        status_color  = 'green' if pid else 'red'\n        status_dot    = self._colorize(UNICODE['dot'], status_color, encode=True)\n        \n        # Active text\n        active_txt    = {\n            'active':   '{} since {}'.format(self._colorize('active (running)', 'green'), self.pid.birthday()[1]),\n            'inactive': 'inactive (dead)'\n        }\n        \n        # Print the status message\n        print(status_dot, end=' ')\n        print('{}.service - LSB: {}'.format(self.name, self.desc))\n        print('   Loaded: loaded (/etc/init.d/{})'.format(self.name))\n        print('   Active: {}'.format(active_txt['active' if pid else 'inactive']))\n        \n        # Extra information if running\n        if pid:\n            ps = self.pid.ps()\n            print('  Process: {}; [{}]'.format(pid, ps[0]))\n            if ps[1]:\n                for c in ps[1]:\n                    print('    Child: {}'.format(c))\n        print('')"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef interface(self):\n        \n        # Possible control arguments\n        controls = {\n            'start': self.do_start,\n            'stop': self.do_stop,\n            'status': self.do_status,\n            'restart': self.do_restart,\n            'reload': self.do_restart    \n        }\n        \n        # Process the control argument\n        try:\n            controls[self.command]()\n        except KeyError:\n            self.write_stdout('Usage: {} {{start|stop|status|restart|reload}}'.format(self.name), 3)\n        exit(0)", "response": "Handles the service command argument."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef parse_cell(self, cell, coords, cell_mode=CellMode.cooked):\n    try:\n      return int(cell)\n    except ValueError:\n      pass\n    try:\n      return float(cell)\n    except ValueError:\n      pass\n    # TODO Check for dates?\n    return cell", "response": "Tries to convert the value first to an int then a float then returns the string value."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef iterate_sheets(self, *args, **kwargs):\n    if isinstance(self.filename, str):\n      if self.filename.endswith(\".gz\") or self.is_gzipped:\n        with gzip.open(self.filename, \"rt\") as rfile:\n          reader = csv.reader(rfile, *args, **kwargs)\n          yield list(reader)\n      else:\n        with open(self.filename, \"r\") as rfile:\n          reader = csv.reader(rfile, *args, **kwargs)\n          yield list(reader)\n    else:\n      reader = csv.reader(self.filename, *args, **kwargs)\n      yield list(reader)", "response": "Iterate over the sheets in the archive."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the most common bits in the given number", "response": "def get_bit_values(number, size=32):\r\n\t\"\"\"\r\n\tGet bit values as a list for a given number\r\n\r\n\t>>> get_bit_values(1) == [0]*31 + [1]\r\n\tTrue\r\n\r\n\t>>> get_bit_values(0xDEADBEEF)\r\n\t[1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, \\\r\n1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1]\r\n\r\n\tYou may override the default word size of 32-bits to match your actual\r\n\tapplication.\r\n\r\n\t>>> get_bit_values(0x3, 2)\r\n\t[1, 1]\r\n\r\n\t>>> get_bit_values(0x3, 4)\r\n\t[0, 0, 1, 1]\r\n\t\"\"\"\r\n\tnumber += 2**size\r\n\treturn list(map(int, bin(number)[-size:]))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef coalesce(bits):\r\n\tdef operation(a, b):\r\n\t\treturn a << 1 | b\r\n\treturn reduce(operation, bits)", "response": "Coalesce a sequence of bits into a number."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconfigure the metrics server.", "response": "def configure(host=DEFAULT_HOST, port=DEFAULT_PORT, prefix=''):\n    \"\"\"\n    >>> configure()\n    >>> configure('localhost', 8125, 'mymetrics')\n    \"\"\"\n    global _client\n    logging.info(\"Reconfiguring metrics: {}:{}/{}\".format(host, port, prefix))\n    _client = statsdclient.StatsdClient(host, port, prefix)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef timed(prefix=None):\n    def decorator(func):\n        \"\"\"wrap func so it is timed\"\"\"\n        metricname = func.__name__\n\n        if prefix:\n            metricname = prefix + '.' + metricname\n\n        def wrapped(*args, **kwargs):\n            \"\"\"wrapped function\"\"\"\n            return timeit(metricname, func, *args, **kwargs)\n        return wrapped\n\n    return decorator", "response": "Decorator to time execution of a function."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef time_methods(obj, methods, prefix=None):\n    if prefix:\n        prefix = prefix + '.'\n    else:\n        prefix = ''\n\n    for method in methods:\n        current_method = getattr(obj, method)\n        new_method = timed(prefix)(current_method)\n        setattr(obj, method, new_method)", "response": "Patch obj so that all methods in methods are timed."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nvalidate that all values of the arguments are types", "response": "def validate_all_types(kwargs):\n        \"\"\" validates that all values of the arguments are types \"\"\"\n        for key in kwargs:\n            assert isinstance(kwargs[key], type), \"\"\"\\n\n    Typedtuple needs its arguments to be types. Argument \"{k:}\" was {type_name:}({val_repr}).\n    You might want to try:\n        {k:} = {type_name:}\\n\\n\"\"\".format(k=key, type_name=type(kwargs[key]).__name__, val_repr=kwargs[key].__repr__())"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef validate_fields(self, **kwargs):\n        for field in self.fields:\n            value = kwargs[field]\n            required_type = self.fields[field]\n            if type(value) != required_type:\n                raise TypeError('{}.{} needs to be a {}, recieved: {}({})'.format(\n                    self.name,\n                    field,\n                    required_type.__name__,\n                    type(value).__name__,\n                    value.__repr__()))", "response": "Validates that all incoming fields are of the correct type"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nuploads a new config resource to the slicing service", "response": "def upload(self, path, engine, description=None):\n        \"\"\"Create a new config resource in the slicing service and upload the path contents to it\"\"\"\n\n        if description is None:\n            head, tail = ntpath.split(path)\n            description = tail or ntpath.basename(head)\n\n        url = \"http://quickslice.{}/config/raw/\".format(self.config.host)\n\n        with open(path) as config_file:\n            content = config_file.read()\n\n        payload = {\"engine\": engine,\n                   \"description\": description,\n                   \"content\": content}\n\n        post_resp = requests.post(url, json=payload, cookies={\"session\": self.session})\n        if not post_resp.ok:\n            raise errors.ResourceError(\"config upload to slicing service failed\")\n\n        self.description = description\n\n        self.location = post_resp.headers[\"Location\"]"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ndownload a config resource to the path", "response": "def download(self, path):\n        \"\"\"downloads a config resource to the path\"\"\"\n\n        service_get_resp = requests.get(self.location, cookies={\"session\": self.session})\n        payload = service_get_resp.json()\n\n        download_get_resp = requests.get(payload[\"content\"])\n        with open(path, \"wb\") as config_file:\n            config_file.write(download_get_resp.content)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef scan_file(path):\n    path = os.path.abspath(path)\n    if settings.USE_CLAMD:\n        return clamd.scan_file(path)\n    else:\n        return clamscan.scan_file(path)", "response": "Scan path for viruses using clamd or clamscan."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsaving b64_data to temporary file and scan it for viruses.", "response": "def save_and_scan(filename, b64_data):\n    \"\"\"\n    Save `b64_data` to temporary file and scan it for viruses.\n\n    Args:\n        filename (str): Name of the file - used as basename for tmp file.\n        b64_data (str): Content of the file encoded in base64.\n\n    Returns:\n        dict: ``{filename: (\"FOUND\", \"virus type\")}`` or blank dict.\n    \"\"\"\n    with NTFile(suffix=\"_\"+os.path.basename(filename), mode=\"wb\") as ifile:\n        ifile.write(\n            b64decode(b64_data)\n        )\n        ifile.flush()\n\n        os.chmod(ifile.name, 0755)\n\n        return scan_file(ifile.name)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nbuilds the URI from the original uriparts and kwargs. Modifies kwargs.", "response": "def build_uri(orig_uriparts, kwargs):\n    \"\"\"\n    Build the URI from the original uriparts and kwargs. Modifies kwargs.\n    \"\"\"\n    uriparts = []\n    for uripart in orig_uriparts:\n        # If this part matches a keyword argument (starting with _), use\n        # the supplied value. Otherwise, just use the part.\n        if uripart.startswith(\"_\"):\n            part = (str(kwargs.pop(uripart, uripart)))\n        else:\n            part = uripart\n        uriparts.append(part)\n    uri = '/'.join(uriparts)\n\n    # If an id kwarg is present and there is no id to fill in in\n    # the list of uriparts, assume the id goes at the end.\n    id = kwargs.pop('id', None)\n    if id:\n        uri += \"/%s\" % (id)\n\n    return uri"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nloading |path| and recursively expand any includes.", "response": "def load(path):\n    \"\"\"Load |path| and recursively expand any includes.\"\"\"\n    with open(path) as rfile:\n        steps = MODEL.parse(rfile.read())\n\n    new_steps = []\n    for step in steps:\n        new_steps += expand_includes(step, path)\n\n    return new_steps"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconvert JSON parse output to self - aware objects", "response": "def translate_update(blob):\n  \"converts JSON parse output to self-aware objects\"\n  # note below: v will be int or null\n  return {translate_key(k):parse_serialdiff(v) for k,v in blob.items()}"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nwrapping for do_* funcs to call process_* with missing handler. Unpacks the FieldKey.", "response": "def fkapply(models,pool,fn,missing_fn,(nombre,pkey,field),*args):\n  \"wrapper for do_* funcs to call process_* with missing handler. Unpacks the FieldKey.\"\n  if (nombre,pkey) in models: return fn(pool,models[nombre,pkey],field,*args)\n  else: return missing_fn(pool,field,*args) if missing_fn else ['missing']"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef merge_null_missing(request,name,field,pkeys):\n  \"helper for add_missing_children. sets k:None for the field for pkeys not already in request.\"\n  request.update({rk:None for rk in [FieldKey(name,pkey,field) for pkey in pkeys] if rk not in request})", "response": "helper for add_missing_children. sets k : None for the field for pkeys not already in request."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add_missing_children(models,request,include_children_for,modelgb):\n  \"helper for do_check. mutates request\"\n  for (nombre,pkey),model in models.items():\n    for modelclass,pkeys in model.refkeys(include_children_for.get(nombre,())).items():\n      # warning: this is defaulting to all fields of child object. don't give clients a way to restrict that until there's a reason to.\n      childname=modelgb['row',modelclass].name\n      for childfield,cftype in modelclass.FIELDS:\n        if not isinstance(cftype,basestring) and inspect.isclass(cftype) and issubclass(cftype,syncschema.Syncable):\n          merge_null_missing(request,childname,childfield,pkeys)\n        elif childfield in modelclass.SENDRAW: merge_null_missing(request,childname,childfield,pkeys)\n        else: pass # intentional: ignore the field\n  return request # the in-place updated original", "response": "helper for do_check. mutates request"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef do_check(pool,request,models,include_children_for,modelgb):\n  \"request is the output of translate_check. models a dict of {(model_name,pkey_tuple):model}.\\\n  ICF is a {model_name:fields_list} for which we want to add nulls in request for missing children. see AMC for how it's used.\\\n  The caller should have gone through the same ICF logic when looking up models so the arg has all the refs the DB knows.\\\n  modelgb is misc.GetterBy<ModelInfo>, used by AMC for resolution.\"\n  add_missing_children(models,request,include_children_for,modelgb)\n  return {k:fkapply(models,pool,process_check,None,k,v) for k,v in request.items()}", "response": "request is the output of translate_check. models a dict of models."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef parse_args():\n    parser = argparse.ArgumentParser(description=\"Uploads specified VMDK file to AWS s3 bucket, and converts to AMI\")\n    parser.add_argument('-r', '--aws_regions', type=str, nargs='+', required=True,\n                        help='list of AWS regions where uploaded ami should be copied. Available'\n                             ' regions: {}.'.format(AWSUtilities.aws_regions))\n    parser.add_argument('-a', '--aws_profile', type=str, required=True, help='AWS profile name to use for aws cli commands')\n    parser.add_argument('-b', '--s3_bucket', type=str, required=True,\n                        help='The aws_bucket of the profile to upload and save vmdk to')\n    parser.add_argument('-f', '--vmdk_upload_file', type=str, required=True,\n                        help=\"The file to upload if executing \")\n    parser.add_argument('-n', '--ami_name', type=str, required=False, help='The name to give to the uploaded ami. '\n                                                                           'Defaults to the name of the file')\n    parser.add_argument('-d', '--directory', type=str, default=tempfile.mkdtemp(),\n                        help='Directory to save temp aws config upload files')\n    args = parser.parse_args()\n\n    if not args.ami_name:\n        args.ami_name = os.path.basename(args.vmdk_upload_file)\n\n    validate_args(args)\n\n    return args", "response": "Parse command line arguments and return a dictionary of arguments."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nperform necessary validation checks", "response": "def validate_args(args):\n    \"\"\"\n    Perform necessary validation checks\n    :param args:\n    :return:\n    \"\"\"\n    # print size of vm to be dl, if dl dir exists, check that file to uplad is a vmdk\n    if not os.path.isdir(args.directory):\n        print \"Directory {} does not exist\".format(args.directory)\n        sys.exit(5)\n\n    try:\n        args.vmdk_upload_file = args.vmdk_upload_file\n    except AttributeError:\n        args.vmdk_upload_file = None\n\n    if args.vmdk_upload_file and not os.path.isfile(args.vmdk_upload_file):\n        print \"Specified file: {} does not exist\".format(args.vmdk_upload_file)\n        sys.exit(5)\n\n    aws_importer = AWSUtilities.AWSUtils(args.directory, args.aws_profile, args.s3_bucket,\n                                         args.aws_regions, args.ami_name, args.vmdk_upload_file)\n    aws_importer.validate()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncalling methods to perform vmdk import", "response": "def vmdk_to_ami(args):\n    \"\"\"\n    Calls methods to perform vmdk import\n    :param args:\n    :return:\n    \"\"\"\n    aws_importer = AWSUtilities.AWSUtils(args.directory, args.aws_profile, args.s3_bucket,\n                                         args.aws_regions, args.ami_name, args.vmdk_upload_file)\n    aws_importer.import_vmdk()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef R_rot_2d(th):\n    s, = np.sin(th).T\n    c, = np.cos(th).T\n    R = np.empty((len(th), 2, 2), dtype=np.float)\n\n    R[:, 0, 0] = c\n    R[:, 0, 1] = -s\n\n    R[:, 1, 0] = s\n    R[:, 1, 1] = c\n\n    return R", "response": "Return a 2 - dimensional rotation matrix."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef R_rot_3d(th):\n    sx, sy, sz = np.sin(th).T\n    cx, cy, cz = np.cos(th).T\n    R = np.empty((len(th), 3, 3), dtype=np.float)\n\n    R[:, 0, 0] = cy * cz\n    R[:, 0, 1] = -cy * sz\n    R[:, 0, 2] = sy\n\n    R[:, 1, 0] = sx * sy * cz + cx * sz\n    R[:, 1, 1] = -sx * sy * sz + cx * cz\n    R[:, 1, 2] = -sx * cy\n\n    R[:, 2, 0] = -cx * sy * cz + sx * sz\n    R[:, 2, 1] = cx * sy * sz + sx * cz\n    R[:, 2, 2] = cx * cy\n    return R", "response": "Return a 3 - dimensional rotation matrix."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef R_rot(th):\n    try:\n        dof = th.shape[-1]\n    # If th is a python float\n    except AttributeError:\n        dof = 1\n        th = np.array([th])\n    except IndexError:\n        dof = 1\n        th = np.array([th])\n    # If th is a numpy float, i.e. 0d array\n    if dof == 1:\n        return R_rot_2d(th)\n    elif dof == 3:\n        return R_rot_3d(th)\n    else:\n        raise Exception('Rotation matrix not implemented in this dimension')", "response": "Return a rotation matrix."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a new array with the given angles about the next set of freedom s components.", "response": "def rotate(a, th):\n    \"\"\"Return cartesian vectors, after rotation by specified angles about\n    each degree of freedom.\n\n    Parameters\n    ----------\n    a: array, shape (n, d)\n        Input d-dimensional cartesian vectors, left unchanged.\n    th: array, shape (n, m)\n        Angles by which to rotate about each m rotational degree of freedom\n        (m=1 in 2 dimensions, m=3 in 3 dimensions).\n\n    Returns\n    -------\n    ar: array, shape of a\n        Rotated cartesian vectors.\n    \"\"\"\n    return np.sum(a[..., np.newaxis] * R_rot(th), axis=-2)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef render(self, name=None, template=None, context={}):\n        ''''Render Template meta from jinja2 templates.\n\n        '''\n\n        if isinstance(template, Template):\n            _template = template\n        else:\n            _template = Template.objects.get(name=name)\n\n        # Maybe cache or save local ?\n        response = self.env.from_string(\n            _template.content).render(context)\n\n        return response", "response": "Render a template and return the response."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef parse_args(args=None):\r\n    '''\r\n    Parses arguments, returns ``(options, args)``.\r\n\r\n    .. versionchanged:: 0.24.1\r\n        Fix handling of optional :data:`args`.\r\n    '''\r\n    if args is None:\r\n        args = sys.argv[1:]\r\n\r\n    parser = argparse.ArgumentParser(description='MicroDrop plugin '\r\n                                     'Conda recipe builder')\r\n    parser.add_argument('-s', '--source-dir', type=ph.path, nargs='?')\r\n    parser.add_argument('-t', '--target-dir', type=ph.path, nargs='?')\r\n    parser.add_argument('-p', '--package-name', nargs='?')\r\n    # Use `-V` for version (from [common Unix flags][1]).\r\n    #\r\n    # [1]: https://unix.stackexchange.com/a/108141/187716\r\n    parser.add_argument('-V', '--version-number', nargs='?')\r\n\r\n    parsed_args = parser.parse_args()\r\n    if not parsed_args.source_dir:\r\n        parsed_args.source_dir = ph.path(os.environ['SRC_DIR'])\r\n    if not parsed_args.target_dir:\r\n        prefix_dir = ph.path(os.environ['PREFIX'])\r\n        # Extract module name from Conda package name.\r\n        #\r\n        # For example, the module name for a package named\r\n        # `microdrop.droplet_planning_plugin` would be\r\n        # `droplet_planning_plugin`.\r\n        module_name = os.environ['PKG_NAME'].split('.')[-1].replace('-', '_')\r\n        parsed_args.target_dir = prefix_dir.joinpath('share', 'microdrop',\r\n                                                     'plugins', 'available',\r\n                                                     module_name)\r\n    if not parsed_args.package_name:\r\n        parsed_args.package_name = os.environ['PKG_NAME']\r\n\r\n    return parsed_args", "response": "Parses arguments and returns parsed options."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nbuild a new release of a MicroDrop plugin source directory into a target directory.", "response": "def build(source_dir, target_dir, package_name=None, version_number=None):\r\n    '''\r\n    Create a release of a MicroDrop plugin source directory in the target\r\n    directory path.\r\n\r\n    Skip the following patterns:\r\n\r\n     - ``bld.bat``\r\n     - ``.conda-recipe/*``\r\n     - ``.git/*``\r\n\r\n    .. versionchanged:: 0.24.1\r\n        Remove temporary archive after extraction.\r\n\r\n        Change directory into source directory before running ``git archive``.\r\n\r\n    .. versionchanged:: 0.25\r\n        Add optional :data:`version_number` argument.\r\n\r\n    Parameters\r\n    ----------\r\n    source_dir : str\r\n        Source directory.\r\n    target_dir : str\r\n        Target directory.\r\n    package_name : str, optional\r\n        Name of plugin Conda package (defaults to name of :data:`target_dir`).\r\n    version_number : str, optional\r\n        Package version number.\r\n\r\n        If not specified, assume version package exposes version using\r\n        `versioneer <https://github.com/warner/python-versioneer>`_.\r\n    '''\r\n    source_dir = ph.path(source_dir).realpath()\r\n    target_dir = ph.path(target_dir).realpath()\r\n    target_dir.makedirs_p()\r\n    source_archive = source_dir.joinpath(source_dir.name + '.zip')\r\n    if package_name is None:\r\n        package_name = str(target_dir.name)\r\n    logger.info('Source directory: %s', source_dir)\r\n    logger.info('Source archive: %s', source_archive)\r\n    logger.info('Target directory: %s', target_dir)\r\n    logger.info('Package name: %s', package_name)\r\n\r\n    # Export git archive, which substitutes version expressions in\r\n    # `_version.py` to reflect the state (i.e., revision and tag info) of the\r\n    # git repository.\r\n    original_dir = ph.path(os.getcwd())\r\n    try:\r\n        os.chdir(source_dir)\r\n        sp.check_call(['git', 'archive', '-o', source_archive, 'HEAD'],\r\n                      shell=True)\r\n    finally:\r\n        os.chdir(original_dir)\r\n\r\n    # Extract exported git archive to Conda MicroDrop plugins directory.\r\n    with zipfile.ZipFile(source_archive, 'r') as zip_ref:\r\n        zip_ref.extractall(target_dir)\r\n    # Extraction is complete.  Remove temporary archive.\r\n    source_archive.remove()\r\n\r\n    # Delete Conda build recipe from installed package.\r\n    target_dir.joinpath('.conda-recipe').rmtree()\r\n    # Delete Conda build recipe from installed package.\r\n    for p in target_dir.files('.git*'):\r\n        p.remove()\r\n\r\n    # Write package information to (legacy) `properties.yml` file.\r\n    original_dir = ph.path(os.getcwd())\r\n    try:\r\n        os.chdir(source_dir)\r\n        if version_number is None:\r\n            # Assume versioneer is being used for managing version.\r\n            import _version as v\r\n\r\n            version_info = {'version': v.get_versions()['version'],\r\n                            'versioneer': v.get_versions()}\r\n        else:\r\n            # Version number was specified explicitly.\r\n            version_info = {'version': version_number}\r\n    finally:\r\n        os.chdir(original_dir)\r\n\r\n    # Create properties dictionary object (cast types, e.g., `ph.path`, to\r\n    # strings for cleaner YAML dump).\r\n    properties = {'package_name': package_name,\r\n                  'plugin_name': str(target_dir.name)}\r\n    properties.update(version_info)\r\n\r\n    with target_dir.joinpath('properties.yml').open('w') as properties_yml:\r\n        # Dump properties to YAML-formatted file.\r\n        # Setting `default_flow_style=False` writes each property on a separate\r\n        # line (cosmetic change only).\r\n        yaml.dump(properties, properties_yml, default_flow_style=False)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get(self):\n        output = helm(\"get\", self.release)\n        if output.returncode != 0:\n            print(\"Something went wrong!\")\n            print(output.stderr)\n        else:\n            print(output.stdout)", "response": "Get specific information about this hub."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncreating a single instance of notebook.", "response": "def create(self):\n        \"\"\"Create a single instance of notebook.\"\"\"\n        # Point to chart repo.\n        out = helm(\n            \"repo\",\n            \"add\",\n            \"jupyterhub\",\n            self.helm_repo\n        )\n        out = helm(\"repo\", \"update\")\n\n        # Get token to secure Jupyterhub\n        secret_yaml = self.get_security_yaml()\n\n        # Get Jupyterhub.\n        out = helm(\n            \"upgrade\",\n            \"--install\",\n            self.release,\n            \"jupyterhub/jupyterhub\",\n            namespace=self.namespace,\n            version=self.version,\n            input=secret_yaml\n        )\n        if out.returncode != 0:\n            print(out.stderr)\n        else:\n            print(out.stdout)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndeleting a Helm Release and Kubernetes namespace.", "response": "def delete(self):\n        \"\"\"Delete a Jupyterhub.\"\"\"\n        # Delete the Helm Release\n        out = helm(\n            \"delete\",\n            self.release,\n            \"--purge\"\n        )\n        if out.returncode != 0:\n            print(out.stderr)\n        else:\n            print(out.stdout)\n\n        # Delete the Kubernetes namespace\n        out = kubectl(\n            \"delete\",\n            \"namespace\",\n            self.namespace\n        )\n        if out.returncode != 0:\n            print(out.stderr)\n        else:\n            print(out.stdout)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _parse_description(self, description_text):\n        text = description_text\n        text = text.strip()\n        lines = text.split('\\n')\n\n        data = {}\n        for line in lines:\n            if \":\" in line:\n                idx = line.index(\":\")\n                key = line[:idx]\n                value = line[idx+1:].lstrip().rstrip()\n                data[key] = value\n            else:\n                if isinstance(value, list) is False:\n                    value = [value]\n                value.append(line.lstrip().rstrip())\n                data[key] = value\n        return data", "response": "Turn description to dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets description as dictionary", "response": "def get_description(self):\n        \"\"\"Get description (as dictionary)\"\"\"\n        message = self._get_description_message()\n        data = self._parse_description(message)\n        return data"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef socketpair(family=socket.AF_INET, type=socket.SOCK_STREAM, proto=0):\n    # We create a connected TCP socket. Note the trick with setblocking(0)\n    # that prevents us from having to create a thread.\n    lsock = socket.socket(family, type, proto)\n    lsock.bind(('localhost', 0))\n    lsock.listen(1)\n    addr, port = lsock.getsockname()\n    csock = socket.socket(family, type, proto)\n    csock.setblocking(False)\n    try:\n        csock.connect((addr, port))\n    except socket.error as e:\n        if e.errno != errno.WSAEWOULDBLOCK:\n            lsock.close()\n            csock.close()\n            raise\n    ssock, _ = lsock.accept()\n    csock.setblocking(True)\n    lsock.close()\n    return (ssock, csock)", "response": "Emulate the Unix socketpair function on Windows."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nvalidates the given data and raises an error if any non - allowed keys are provided or any required keys are missing.", "response": "def _validate_data(data):\n    \"\"\"Validates the given data and raises an error if any non-allowed keys are\n    provided or any required keys are missing.\n\n    :param data: Data to send to API\n    :type data: dict\n    \"\"\"\n    data_keys = set(data.keys())\n    extra_keys = data_keys - set(ALLOWED_KEYS)\n    missing_keys = set(REQUIRED_KEYS) - data_keys\n\n    if extra_keys:\n        raise ValueError(\n            'Invalid data keys {!r}'.format(', '.join(extra_keys))\n        )\n\n    if missing_keys:\n        raise ValueError(\n            'Missing keys {!r}'.format(', '.join(missing_keys))\n        )"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _send(data):\n    url = data.get('url', CLOWDER_API_URL)\n\n    _validate_data(data)\n\n    if api_key is not None:\n        data['api_key'] = api_key\n\n    if 'value' not in data:\n        data['value'] = data.get('status', 1)\n\n    if 'frequency' in data:\n        data['frequency'] = _clean_frequency(data['frequency'])\n\n    try:\n        requests.post(url, data=data, timeout=TIMEOUT).text\n\n    # This confirms you that the request has reached server\n    # And that the request has been sent\n    # Because we don't care about the response, we set the timeout\n    # value to be low and ignore read exceptions\n    except requests.exceptions.ReadTimeout as err:\n        pass\n\n    # Allow a wildcard expection for any other type of processing error\n    except requests.exceptions.RequestException as err:\n        logging.error('Clowder expection %s', err)", "response": "Send data to the Clowder API."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef submit(**kwargs):\n    if 'alert' not in kwargs:\n        raise ValueError('Alert required')\n\n    if 'value' not in kwargs:\n        raise ValueError('Value required')\n\n    alert = kwargs.pop('alert')\n    value = kwargs['value']\n\n    if alert(value):\n        fail(kwargs)\n    else:\n        ok(kwargs)", "response": "Shortcut that takes an alert to evaluate and makes the appropriate API\n    call based on the results."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _clean_frequency(frequency):\n    if isinstance(frequency, int):\n        return frequency\n    elif isinstance(frequency, datetime.timedelta):\n        return int(frequency.total_seconds())\n\n    raise ValueError('Invalid frequency {!r}'.format(frequency))", "response": "Converts a frequency value to an integer. Raises an error if an invalid\n    type is given."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a unique filename for a nouveau file.", "response": "def get_unique_filename(filename, new_filename=None, new_extension=None):\n    \"\"\"\n    G\u00e9n\u00e8re un nouveau nom pour un fichier en gardant son extension\n    \n    Soit le nouveau nom est g\u00e9n\u00e9r\u00e9 \u00e0 partir de la date \n    (heures+minutes+secondes+microsecondes) soit un nouveau nom est sp\u00e9cifi\u00e9 et on \n    l'utilise tel quel.\n    \n    :type filename: string\n    :param filename: Nom du fichier original\n    \n    :type new_filename: string\n    :param new_filename: (optional) Nouveau nom de fichier personnalis\u00e9, ceci implique que \n                         la date ne sera pas ins\u00e9r\u00e9e dans le nouveau nom\n    \n    :type new_extension: string\n    :param new_extension: (optional) Force une nouvelle extension de fichier au lieu de \n                          celle de l'original. \u00c0 sp\u00e9cifier sans le \"point\" de d\u00e9but d'une \n                          extension.\n    \n    :rtype: string\n    :return: Nouveau nom de fichier\n    \"\"\"\n    if new_extension:\n        extension = new_extension\n    else:\n        extension = splitext(filename)[1][1:]\n    if not new_filename:\n        now = real_datetime.now()\n        return '%s%s%s%s.%s' % (unicode(now.hour).zfill(2), unicode(now.minute).zfill(2), unicode(now.second).zfill(2), unicode(now.microsecond).zfill(6), extension)\n    else:\n        return '%s.%s' % (new_filename, extension)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef generate_valid_path(filename, path, create_it=True, root_base=settings.MEDIA_ROOT, permissions=settings.FILE_UPLOAD_PERMISSIONS):\n    if not permissions:\n        permissions = 0744\n    # Forme le chemin absolu vers le nouvo fichier cr\u00e9\u00e9\n    relative_path = strftime(real_datetime.now(), path)\n    absolute_path = join(root_base, relative_path)\n    # Cr\u00e9ation du r\u00e9pertoire\n    if create_it:\n        if not exists( absolute_path ):\n            makedirs(absolute_path, permissions)\n        elif not isdir( absolute_path ):\n            # Le chemin existe et n'est pas un r\u00e9pertoire\n            raise IOError(\"'%s' exists and is not a directory.\" % absolute_path)\n    \n    return join(relative_path, filename), join(absolute_path, filename)", "response": "Generate a valid path for a file."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncheck if a message belongs to a particular Koschei group.", "response": "def koschei_group(config, message, group=None):\n    \"\"\" Particular Koschei package groups\n\n    This rule limits message to particular\n    `Koschei <https://apps.fedoraproject.org/koschei/>`_ groups.\n    You can specify more groups separated by commas.\n    \"\"\"\n    if not group or 'koschei' not in message['topic']:\n        return False\n    groups = set([item.strip() for item in group.split(',')])\n    return bool(groups.intersection(message['msg'].get('groups', [])))"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ninitializes the project for use with EasyCI.", "response": "def init(ctx):\n    \"\"\"Initialize the project for use with EasyCI. This installs the necessary\n    git hooks (pre-commit + pre-push) and add a config file if one does not\n    already exists.\n    \"\"\"\n    # install hooks\n    git = ctx.obj['vcs']\n    click.echo(\"Installing hooks...\", nl=False)\n    for old in ['commit-msg']:\n        path = os.path.join(git.path, '.git/hooks', old)\n        if os.path.exists(path):\n            os.remove(path)\n    for new in ['pre-commit', 'pre-push']:\n        git.install_hook(new, hooks_manager.get_hook(new))\n    click.echo(\"Done.\")\n\n    # add a config file if one does not exist\n    config_path = os.path.join(git.path, 'eci.yaml')\n    if not os.path.exists(config_path):\n        click.echo(\"Placing a trivial config file in your project...\", nl=False)\n        with open(config_path, 'w') as f:\n            f.write(yaml.safe_dump(\n                {'tests': ['echo please modify to run your tests', 'true']}))\n        click.echo(\"Done.\")\n\n    # initialize lock\n    locking.init(git)\n\n    # update installed version\n    click.echo(\"Updating installed version...\", nl=False)\n    set_installed_version(git, easyci.__version__)\n    click.echo(\"Done.\")"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef on_start(self):\n        LOGGER.debug(\"rabbitmq.Requester.on_start\")\n        if not self.fire_and_forget:\n            self.channel.basic_consume(self.on_response, no_ack=True,\n                                       queue=self.callback_queue)", "response": "Called when the requester is starting."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncall when the broker is stopping.", "response": "def on_stop(self):\n        \"\"\"\n        stop requester\n        \"\"\"\n        LOGGER.debug(\"rabbitmq.Requester.on_stop\")\n        try:\n            self.channel.close()\n        except Exception as e:\n            LOGGER.warn(\"rabbitmq.Requester.on_stop - Exception raised while closing channel\")\n        try:\n            self.connection.close()\n        except Exception as e:\n            LOGGER.warn(\"rabbitmq.Requester.on_stop - Exception raised while closing connection\")"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncall when a response is received from the broker.", "response": "def on_response(self, ch, method_frame, props, body):\n        \"\"\"\n        setup response is correlation id is the good one\n        \"\"\"\n        LOGGER.debug(\"rabbitmq.Requester.on_response\")\n        if self.corr_id == props.correlation_id:\n            self.response = {'props': props, 'body': body}\n        else:\n            LOGGER.warn(\"rabbitmq.Requester.on_response - discarded response : \" +\n                        str(props.correlation_id))\n            LOGGER.debug(\"natsd.Requester.on_response - discarded response : \" + str({\n                'properties': props,\n                'body': body\n            }))"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef call(self, my_args=None):\n        LOGGER.debug(\"rabbitmq.Requester.call\")\n        if my_args is None:\n            raise exceptions.ArianeConfError(\"requestor call arguments\")\n        if 'properties' not in my_args or my_args['properties'] is None:\n            raise exceptions.ArianeConfError('requestor call properties')\n        if 'body' not in my_args or my_args['body'] is None:\n            my_args['body'] = ''\n        if 'MSG_CORRELATION_ID' not in my_args['properties']:\n            self.corr_id = str(uuid.uuid4())\n            my_args['properties']['MSG_CORRELATION_ID'] = self.corr_id\n        else:\n            self.corr_id = my_args['properties']['MSG_CORRELATION_ID']\n\n        self.response = None\n        self.corr_id = str(uuid.uuid4())\n\n        props = my_args['properties']\n        if 'sessionID' in props and props['sessionID'] is not None and props['sessionID']:\n            request_q = str(props['sessionID']) + '-' + self.requestQ\n        else:\n            request_q = self.requestQ\n\n        if self.trace:\n            props['MSG_TRACE'] = True\n\n        if not self.fire_and_forget:\n            properties = pika.BasicProperties(content_type=None, content_encoding=None,\n                                              headers=props, delivery_mode=None,\n                                              priority=None, correlation_id=self.corr_id,\n                                              reply_to=self.callback_queue, expiration=None,\n                                              message_id=None, timestamp=None,\n                                              type=None, user_id=None,\n                                              app_id=None, cluster_id=None)\n        else:\n            properties = pika.BasicProperties(content_type=None, content_encoding=None,\n                                              headers=props, delivery_mode=None,\n                                              priority=None, expiration=None,\n                                              message_id=None, timestamp=None,\n                                              type=None, user_id=None,\n                                              app_id=None, cluster_id=None)\n\n        self.channel.basic_publish(exchange='',\n                                   routing_key=request_q,\n                                   properties=properties,\n                                   body=str(my_args['body']))\n\n        LOGGER.debug(\"rabbitmq.Requester.call - published msg {\"+str(my_args['body'])+\",\"+str(properties)+\"}\")\n\n        if not self.fire_and_forget:\n            start_time = timeit.default_timer()\n            timeout = self.rpc_timeout if self.rpc_timeout > 0 else 0\n            while self.response is None and timeout >= 0:\n                timeout_id = None\n                if timeout > 0:\n                    timeout_id = self.connection.add_timeout(timeout, self.on_response)\n                self.connection.process_data_events()\n                if timeout_id is not None:\n                    self.connection.remove_timeout(timeout_id)\n                timeout = round(self.rpc_timeout - (timeit.default_timer() - start_time))\n            rpc_time = timeit.default_timer() - start_time\n\n            if self.response is None:\n                if self.rpc_retry > 0:\n                    if 'retry_count' not in my_args:\n                        my_args['retry_count'] = 1\n                        LOGGER.debug(\"rabbitmq.Requester.call - Retry (\" + str(my_args['retry_count']) + \")\")\n                        return self.call(my_args)\n                    elif 'retry_count' in my_args and (self.rpc_retry - my_args['retry_count']) > 0:\n                        LOGGER.warn(\"rabbitmq.Requester.call - No response returned from request on \" + request_q +\n                                    \" queue after \" + str(self.rpc_timeout) + '*' +\n                                    str(self.rpc_retry) + \" sec ...\")\n                        self.trace = True\n                        my_args['retry_count'] += 1\n                        LOGGER.warn(\"rabbitmq.Requester.call - Retry (\" + str(my_args['retry_count']) + \")\")\n                        return self.call(my_args)\n                    else:\n                        raise ArianeMessagingTimeoutError('rabbitmq.Requester.call',\n                                                          'Request timeout (' + str(self.rpc_timeout) + '*' +\n                                                          str(self.rpc_retry) + ' sec) occured')\n                else:\n                    raise ArianeMessagingTimeoutError('rabbitmq.Requester.call',\n                                                      'Request timeout (' + str(self.rpc_timeout) + '*' +\n                                                      str(self.rpc_retry) + ' sec) occured')\n            else:\n                if self.rpc_timeout > 0 and rpc_time > self.rpc_timeout*3/5:\n                    LOGGER.debug('rabbitmq.Requester.call - slow RPC time (' + str(rpc_time) + ') on request ' +\n                                 str(properties))\n                self.trace = False\n\n                rc_ = self.response['props'].headers['RC']\n                if rc_ != 0:\n                    try:\n                        content = json.loads(self.response['body'].decode(\"UTF-8\"))\n                    except ValueError:\n                        content = self.response['body'].decode(\"UTF-8\")\n                    return DriverResponse(\n                        rc=rc_,\n                        error_message=self.response['props'].headers['SERVER_ERROR_MESSAGE']\n                        if 'SERVER_ERROR_MESSAGE' in self.response['props'].headers else '',\n                        response_content=content\n                    )\n                else:\n                    try:\n                        if 'MSG_PROPERTIES' in self.response['props'].headers:\n                            props = json.loads(self.response['props'].headers['MSG_PROPERTIES'])\n                        else:\n                            props = None\n                    except ValueError:\n                        if 'MSG_PROPERTIES' in self.response['props'].headers:\n                            props = self.response['props'].headers['MSG_PROPERTIES']\n                        else:\n                            props = None\n                    try:\n                        content = json.loads(self.response['body'].decode(\"UTF-8\"))\n                    except ValueError:\n                        content = self.response['body'].decode(\"UTF-8\")\n                    return DriverResponse(\n                        rc=rc_,\n                        response_properties=props,\n                        response_content=content\n                    )", "response": "Setup the request and call the remote service."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef run(self):\n        LOGGER.debug(\"rabbitmq.Service.run\")\n        try:\n            self.channel.start_consuming()\n        except Exception as e:\n            LOGGER.warn(\"rabbitmq.Service.run - Exception raised while consuming\")", "response": "Start consuming the message from the channel."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef on_request(self, ch, method_frame, props, body):\n        LOGGER.debug(\"rabbitmq.Service.on_request - request \" + str(props) + \" received\")\n        try:\n            properties = props.headers.copy()\n            properties['app_id'] = props.app_id\n            properties['cluster_id'] = props.cluster_id\n            properties['content_encoding'] = props.content_encoding\n            properties['content_type'] = props.content_type\n            properties['correlation_id'] = props.correlation_id\n            properties['delivery_mode'] = props.delivery_mode\n            properties['expiration'] = props.expiration\n            properties['message_id'] = props.message_id\n            properties['priority'] = props.priority\n            properties['reply_to'] = props.reply_to\n            properties['timestamp'] = props.timestamp\n            properties['type'] = props.type\n            properties['user_id'] = props.user_id\n            self.cb(properties, body)\n        except Exception as e:\n            LOGGER.warn(\"rabbitmq.Service.on_request - Exception raised while treating msg {\" +\n                        str(props) + \",\" + str(body) + \"}\")\n        LOGGER.debug(\"rabbitmq.Service.on_request - request \" + str(props) + \" treated\")\n        ch.basic_ack(delivery_tag=method_frame.delivery_tag)\n        LOGGER.debug(\"rabbitmq.Service.on_request - request \" + str(props) + \" acked\")", "response": "This method is called when a request is received from the broker. It is called when a message is received from the broker and is ready to be sent to the broker."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nstops the service consuming the related resources.", "response": "def on_stop(self):\n        \"\"\"\n        stop the service\n        \"\"\"\n        LOGGER.debug(\"rabbitmq.Service.on_stop\")\n        self.is_started = False\n        try:\n            self.channel.stop_consuming()\n        except Exception as e:\n            LOGGER.warn(\"rabbitmq.Service.on_stop - Exception raised while stoping consuming\")\n\n        try:\n            self.channel.close()\n        except Exception as e:\n            LOGGER.warn(\"rabbitmq.Service.on_stop - Exception raised while closing channel\")\n\n        try:\n            self.connection.close()\n        except Exception as e:\n            LOGGER.warn(\"rabbitmq.Service.on_stop - Exception raised while closing connection\")"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nstopping all services and requestors and then connection.", "response": "def stop(self):\n        \"\"\"\n        Stop services and requestors and then connection.\n        :return: self\n        \"\"\"\n        LOGGER.debug(\"rabbitmq.Driver.stop\")\n        for requester in self.requester_registry:\n            requester.stop()\n        self.requester_registry.clear()\n\n        for service in self.services_registry:\n            if service.is_started:\n                service.stop()\n        self.services_registry.clear()\n\n        pykka.ActorRegistry.stop_all()\n\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nprinting an error message", "response": "def error(message, *args, **kwargs):\n    \"\"\" print an error message \"\"\"\n\n    print('[!] ' + message.format(*args, **kwargs))\n    sys.exit(1)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef parse_changes():\n\n    with open('CHANGES') as changes:\n        for match in re.finditer(RE_CHANGES, changes.read(1024), re.M):\n            if len(match.group(1)) != len(match.group(3)):\n                error('incorrect underline in CHANGES')\n\n            date = datetime.datetime.strptime(match.group(4),\n                                              '%Y-%m-%d').date()\n\n            if date != datetime.date.today():\n                error('release date is not today')\n\n            return match.group(2)\n\n    error('invalid release entry in CHANGES')", "response": "parse CHANGES and validate entry"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef increment_version(version):\n\n    parts = [int(v) for v in version.split('.')]\n    parts[-1] += 1\n    parts.append('dev0')\n\n    return '.'.join(map(str, parts))", "response": "increment the next version"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_version(version):\n\n    with open(FILENAME) as pythonfile:\n        content = pythonfile.read()\n\n    output = re.sub(RE_VERSION, r\"\\1'{}'\".format(version), content)\n\n    if content == output:\n        error('failed updating {}'.format(FILENAME))\n\n    with open(FILENAME, 'w') as pythonfile:\n        pythonfile.write(output)", "response": "set the version in the projects root module"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nbuild the files and upload them to pypi", "response": "def upload():\n    \"\"\" build the files and upload to pypi \"\"\"\n\n    def twine(*args):\n        \"\"\" run a twine command \"\"\"\n        process = run(sys.executable, '-m', 'twine', *args)\n\n        return process.wait() != 0\n\n    if run(sys.executable, 'setup.py', 'sdist', 'bdist_wheel').wait() != 0:\n        error('failed building packages')\n\n    if twine('register', glob.glob('dist/*')[0]):\n        error('register failed')\n\n    if twine('upload', '-s', '-i', 'CB164668', '--skip-existing', 'dist/*'):\n        error('upload failed')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef check_tag(version):\n\n    output = run('git', 'tag', stdout=subprocess.PIPE).communicate()[0]\n    tags = set(output.decode('utf-8').splitlines())\n\n    if 'v{}'.format(version) in tags:\n        error('version already exists')", "response": "check if the version is already a tag"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the MOTD of the current instance of the class.", "response": "def get_motd(self, server=None):\n        \"\"\"\n        Gets the server's MOTD.\n        Optional arguments:\n        * server=None - Server to get the MOTD of.\n        \"\"\"\n        with self.lock:\n            if not server:\n                self.send('MOTD')\n            else:\n                self.send('MOTD %s' % server)\n\n            motd = []\n            while self.readable():\n                msg = self._recv(expected_replies=('375', '372', '376', '422'))\n                if msg[0] == '375':\n                    pass\n                elif msg[0] == '372':\n                    motd.append(msg[2].replace(':', '', 1))\n                elif msg[0] == '376':\n                    break\n                elif msg[0] == '422':\n                    break\n            self.motd = tuple(motd)\n            return self.motd"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the LUSERS information of a specific class.", "response": "def get_lusers(self, mask=None, target=None):\n        \"\"\"\n        Get the LUSERS information.\n        Optional arguments:\n        * mask=None - Mask to get LUSERS information of.\n        * target=None - Forward the query.\n        \"\"\"\n        with self.lock:\n            if not mask:\n                self.send('LUSERS')\n            elif not target and mask:\n                self.send('LUSERS %s' % mask)\n            else:\n                self.send('LUSERS %s %s' % (mask, target))\n            while self.readable():\n                msg = self._recv(expected_replies=('250', '251', '252', \\\n                                            '254', '255', '265', '266'))\n                segments = msg[2].split()\n                if msg[0] == '250':\n                    self.lusers['HIGHESTCONNECTIONS'] = segments[3]\n                    self.lusers['TOTALCONNECTIONS'] = segments[9][1:]\n                elif msg[0] == '251':\n                    self.lusers['USERS'] = segments[2]\n                    self.lusers['INVISIBLE'] = segments[5]\n                    self.lusers['SERVERS'] = segments[8]\n\n                elif msg[0] == '252':\n                    self.lusers['OPERATORS'] = segments[0]\n\n                elif msg[0] == '254':\n                    self.lusers['CHANNELS'] = segments[0]\n\n                elif msg[0] == '255':\n                    self.lusers['CLIENTS'] = segments[2]\n                    self.lusers['LSERVERS'] = segments[5]\n\n                elif msg[0] == '265':\n                    self.lusers['LOCALUSERS'] = segments[3]\n                    self.lusers['LOCALMAX'] = segments[5]\n\n                elif msg[0] == '266':\n                    self.lusers['GLOBALUSERS'] = segments[3]\n                    self.lusers['GLOBALMAX'] = segments[5]\n                    break\n            return self.lusers"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_version(self, target=None):\n        with self.lock:\n            if not target:\n                self.send('VERSION')\n            else:\n                self.send('VERSION %s' % target)\n\n            while self.readable():\n                msg = self._recv(expected_replies=('351', '005'))\n                version = msg[2].replace(' :are supported by this server', '')\n                version = version.split()\n                for info in version:\n                        try:\n                            info = info.split('=')\n                            name = info[0]\n                            value = info[1]\n                            self.version[name] = value\n\n                            if name == 'CHARSET':\n                                self.encoding = value\n                        except IndexError:\n                            self.version[info[0]] = True\n\n            return self.version", "response": "Get the servers VERSION information."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets the server s STATS information.", "response": "def stats(self, query=None, target=None):\n        \"\"\"\n        Get the server's STATS information.\n        Optional arguments:\n        * query=None - STATS Query.\n        * target=None - Target server.\n        \"\"\"\n        with self.lock:\n            if not query:\n                self.send('STATS')\n            elif not target and query:\n                self.send('STATS %s' % query)\n            else:\n                self.send('STATS %s %s' % (query, target))\n            stat_lines = []\n            while self.readable():\n                msg = self._recv()\n                if msg[1] == '219':\n                    break\n                else:\n                    stat_lines.append(msg[3].replace(':', '', 1))\n            return stat_lines"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef links(self, r_server=None, mask=None):\n        with self.lock:\n            if not r_server:\n                self.send('LINKS')\n            elif not mask and r_server:\n                self.send('LINKS %s' % r_server)\n            else:\n                self.send('LINKS %s %s' % (r_server, mask))\n            links = {}\n            while self.readable():\n                msg = self._recv(expected_replies=('364', '365'))\n                segments = msg[2].split()\n                if msg[0] == '364':\n                    server = segments[0]\n                    desc = ' '.join(segments[3:])\n                    links[server] = desc\n                elif msg[0] == '365':\n                    break\n            return links", "response": "Get the LINKS information for a specific server."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget server time. Optional arguments: * target=None - Target server.", "response": "def time(self, target=None):\n        \"\"\"\n        Get server time.\n        Optional arguments:\n        * target=None - Target server.\n        \"\"\"\n        with self.lock:\n            if target:\n                self.send('TIME %s' % target)\n            else:\n                self.send('TIME')\n            time = ''\n            msg = self._recv(rm_colon=True, expected_replies=('391',))\n            if msg[0] == '391':\n                time = msg[2].split(':', 1)[1]\n            return time"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nlinking a server with a specific port.", "response": "def s_connect(self, server, port, r_server=None):\n        \"\"\"\n        Link a server.\n        Required arguments:\n        * server - Server to link with.\n        * port - Port to use.\n        Optional arguments:\n        * r_server=None - Link r_server with server.\n        \"\"\"\n        with self.lock:\n            if not r_server:\n                self.send('CONNECT %s %s' % (server, port), error_check=True)\n            else:\n                self.send('CONNECT %s %s %s' % (server, port, \\\n                                    r_server), error_check=True)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets the admin information for a specific server.", "response": "def admin(self, server=None):\n        \"\"\"\n        Get the admin information.\n        Optional arguments:\n        * server=None - Get admin information for -\n            server instead of the current server.\n        \"\"\"\n        with self.lock:\n            if not server:\n                self.send('ADMIN')\n            else:\n                self.send('ADMIN %s' % server)\n            rvalue = []\n            while self.readable():\n                admin_ncodes = '257', '258', '259'\n                msg = self._recv(expected_replies=('256',) + admin_ncodes)\n                if msg[0] == '256':\n                    pass\n                elif msg[0]  in admin_ncodes:\n                    rvalue.append(' '.join(msg[2:])[1:])\n\n            return rvalue"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef s_info(self, server=None):\n        with self.lock:\n            if not server:\n                self.send('INFO')\n            else:\n                self.send('INFO %s' % server)\n            sinfo = []\n            while self.readable():\n                msg = self._recv(expected_replies=('371', '374'))\n                if msg[0] == '371':\n                    sinfo.append(' '.join(msg[2:])[1:])\n                elif msg[0] == '374':\n                    break\n\n            return sinfo", "response": "Runs the INFO command on a server."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsends a SQUERY message to a specific service.", "response": "def squery(self, sname, msg):\n        \"\"\"\n        Send a SQUERY.\n        Required arguments:\n        * sname - Service name.\n        * msg - Message to send.\n        \"\"\"\n        with self.lock:\n            self.send('SQUERY %s :%s' % (sname, msg), error_check=True)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef kill(self, nick, reason=''):\n        with self.lock:\n            self.send('KILL ' + nick + ' :' + reason, error_check=True)", "response": "Kills the specified user."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncoerces a dictionary to a bottle. MultiDict", "response": "def as_multi_dict(d):\n    'Coerce a dictionary to a bottle.MultiDict'\n    if isinstance(d, bottle.MultiDict):\n        return d\n    md = bottle.MultiDict()\n    for k, v in d.iteritems():\n        if isinstance(v, list):\n            for x in v:\n                md[k] = x\n        else:\n            md[k] = v\n    return md"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef set_query_params(self, query_params):\n        '''Set the query parameters.\n\n        The query parameters should be a dictionary mapping keys to\n        strings or lists of strings.\n\n        :param query_params: query parameters\n        :type query_params: ``name |--> (str | [str])``\n        :rtype: :class:`Queryable`\n        '''\n        self.query_params = as_multi_dict(query_params)\n        self.apply_param_schema()\n        return self", "response": "Set the query parameters."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\noverwriting the given query parameters.", "response": "def add_query_params(self, query_params):\n        '''Overwrite the given query parameters.\n\n        This is the same as :meth:`Queryable.set_query_params`,\n        except it overwrites existing parameters individually\n        whereas ``set_query_params`` deletes all existing key in\n        ``query_params``.\n        '''\n        query_params = as_multi_dict(query_params)\n        for k in query_params:\n            self.query_params.pop(k, None)\n            for v in query_params.getlist(k):\n                self.query_params[k] = v\n        self.apply_param_schema()\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\napply the schema defined to the given parameters. This applies the schema defined to the given parameters. This applies the schema defined to the given parameters.", "response": "def apply_param_schema(self):\n        '''Applies the schema defined to the given parameters.\n\n        This combines the values in ``config_params`` and\n        ``query_params``, and converts them to typed Python values per\n        ``param_schema``.\n\n        This is called automatically whenever the query parameters are\n        updated.\n        '''\n        def param_str(name, cons, default):\n            try:\n                v = self.query_params.get(name, default)\n                if v is None:\n                    return v\n                if len(v) == 0:\n                    return default\n                return cons(v)\n            except (TypeError, ValueError):\n                return default\n\n        def param_num(name, cons, default, minimum, maximum):\n            try:\n                n = cons(self.query_params.get(name, default))\n                return min(maximum, max(minimum, n))\n            except (TypeError, ValueError):\n                return default\n\n        for name, schema in getattr(self, 'param_schema', {}).iteritems():\n            default = self.config_params.get(name, schema.get('default', None))\n            v = None\n            if schema['type'] == 'bool':\n                v = param_str(name, lambda s: bool(int(s)), False)\n            elif schema['type'] == 'int':\n                v = param_num(\n                    name, int, default=default,\n                    minimum=schema.get('min', 0),\n                    maximum=schema.get('max', 1000000))\n            elif schema['type'] == 'float':\n                v = param_num(\n                    name, float, default=default,\n                    minimum=schema.get('min', 0),\n                    maximum=schema.get('max', 1000000))\n            elif schema['type'] is 'bytes':\n                v = param_str(name, schema.get('cons', str), default)\n            elif schema['type'] is 'unicode':\n                encoding = schema.get('encoding', 'utf-8')\n                v = param_str(name, lambda s: s.decode(encoding), default)\n            self.params[name] = v"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef create_filter_predicate(self):\n        '''Creates a filter predicate.\n\n        The list of available filters is given by calls to\n        ``add_filter``, and the list of filters to use is given by\n        parameters in ``params``.\n\n        In this default implementation, multiple filters can be\n        specified with the ``filter`` parameter. Each filter is\n        initialized with the same set of query parameters given to the\n        search engine.\n\n        The returned function accepts a ``(content_id, FC)`` and\n        returns ``True`` if and only if every selected predicate\n        returns ``True`` on the same input.\n        '''\n        assert self.query_content_id is not None, \\\n            'must call SearchEngine.set_query_id first'\n\n        filter_names = self.query_params.getlist('filter')\n        if len(filter_names) == 0 and 'already_labeled' in self._filters:\n            filter_names = ['already_labeled']\n        init_filters = [(n, self._filters[n]) for n in filter_names]\n        preds = [lambda _: True]\n        for name, p in init_filters:\n            preds.append(p.set_query_id(self.query_content_id)\n                          .set_query_params(self.query_params)\n                          .create_predicate())\n        return lambda (cid, fc): fc is not None and all(p((cid, fc))\n                                                        for p in preds)", "response": "Creates a filter predicate that returns True if all available filters are set to True."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef results(self):\n        '''Returns results as a JSON encodable Python value.\n\n        This calls :meth:`SearchEngine.recommendations` and converts\n        the results returned into JSON encodable values. Namely,\n        feature collections are slimmed down to only features that\n        are useful to an end-user.\n        '''\n        results = self.recommendations()\n        transformed = []\n        for t in results['results']:\n            if len(t) == 2:\n                cid, fc = t\n                info = {}\n            elif len(t) == 3:\n                cid, fc, info = t\n            else:\n                bottle.abort(500, 'Invalid search result: \"%r\"' % t)\n            result = info\n            result['content_id'] = cid\n            if not self.params['omit_fc']:\n                result['fc'] = util.fc_to_json(fc)\n            transformed.append(result)\n        results['results'] = transformed\n        return results", "response": "Returns results as a JSON encodable Python value."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _get_entry_link(self, entry):\n        entry_link = None\n        for link in entry.link:\n            if '/data/' not in link.href and '/lh/' not in link.href:\n                entry_link = link.href\n                break\n        return entry_link or entry.link[0].href", "response": "Returns a unique link for an entry"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef find(value):\n        value = str(value).lower()\n        rtn_dict = RegistryDictionary()\n        for attr in dir(MODULE.rdfclass):\n            if value in attr.lower():\n                try:\n                    item = getattr(MODULE.rdfclass, attr)\n                    if issubclass(item, RdfClassBase):\n                        rtn_dict[attr] = item\n                except TypeError:\n                    pass\n        return rtn_dict", "response": "returns a dictionary of rdfclasses based on the a lowercase search\n        value"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a dictionary of properties assigned to the class", "response": "def list_base_properties(bases):\n    \"\"\" returns a dictionary of properties assigned to the class\"\"\"\n    rtn_dict = {}\n    for base in bases:\n        if hasattr(base, 'properties'):\n            rtn_dict.update(base.properties)\n    return rtn_dict"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a list of the class hierarchy for the current class_name and bases", "response": "def list_hierarchy(class_name, bases):\n    \"\"\"\n    Creates a list of the class hierarchy\n\n    Args:\n    -----\n        class_name: name of the current class\n        bases: list/tuple of bases for the current class\n    \"\"\"\n\n    class_list = [Uri(class_name)]\n    for base in bases:\n        if base.__name__ not in IGNORE_CLASSES:\n            class_list.append(Uri(base.__name__))\n    return list([i for i in set(class_list)])"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef es_get_class_defs(cls_def, cls_name):\n    rtn_dict = {key: value for key, value in cls_def.items() \\\n                if key.startswith(\"kds_es\")}\n    for key in rtn_dict:\n        del cls_def[key]\n    return rtn_dict", "response": "Reads through the class defs and gets the related es class\n   "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_rml_processors(es_defs):\n    proc_defs = es_defs.get(\"kds_esRmlProcessor\", [])\n    if proc_defs:\n        new_defs = []\n        for proc in proc_defs:\n            params = proc['kds_rmlProcessorParams'][0]\n            proc_kwargs = {}\n            if params.get(\"kds_rtn_format\"):\n                proc_kwargs[\"rtn_format\"] = params.get(\"kds_rtn_format\")[0]\n            new_def = dict(name=proc['rdfs_label'][0],\n                           subj=params[\"kds_subjectKwarg\"][0],\n                           proc_kwargs=proc_kwargs,\n                           force=proc.get('kds_forceNested',[False])[0],\n                           processor=CFG.rml.get_processor(\\\n                                proc['rdfs_label'][0],\n                                proc['kds_esRmlMapping'],\n                                proc['rdf_type'][0]))\n            new_defs.append(new_def)\n        es_defs['kds_esRmlProcessor'] = new_defs\n    return es_defs", "response": "Returns the es_defs with the instaniated rml_processor"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef list_properties(cls):\n    rtn_dict = {}\n    for attr in dir(cls):\n        if attr not in [\"properties\", \"__doc__\", \"doc\"]:\n            attr_val = getattr(cls, attr)\n\n            if isinstance(attr_val, MODULE.rdfclass.RdfPropertyMeta):\n                rtn_dict[attr] = attr_val\n    return rtn_dict", "response": "returns a dictionary of properties assigned to the class"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef remove_parents(bases):\n    if len(bases) < 2:\n        return bases\n    remove_i = []\n    bases = list(bases)\n    for i, base in enumerate(bases):\n        for j, other in enumerate(bases):\n            # print(i, j, base, other, remove_i)\n            if j != i and (issubclass(other, base) or base == other):\n                remove_i.append(i)\n    remove_i = set(remove_i)\n    remove_i = [i for i in remove_i]\n    remove_i.sort(reverse=True)\n    for index in remove_i:\n        try:\n            del bases[index]\n        except IndexError:\n            print(\"Unable to delete base: \", bases)\n    return bases", "response": "Removes the parents of the base classes if one base is subclass of another."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_query_kwargs(es_defs):\n    rtn_dict = {}\n    if es_defs:\n        if es_defs.get(\"kds_esSpecialUnion\"):\n            rtn_dict['special_union'] = \\\n                    es_defs[\"kds_esSpecialUnion\"][0]\n        if es_defs.get(\"kds_esQueryFilter\"):\n            rtn_dict['filters'] = \\\n                    es_defs[\"kds_esQueryFilter\"][0]\n    return rtn_dict", "response": "Reads the es_defs and returns a dict of special kwargs to use when\n    query for data of an instance of a class\n ArcGIS class"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add_property(self, pred, obj):\n        pred = Uri(pred)\n        try:\n            self[pred].append(obj)\n        # except AttributeError:\n        #     new_list = [self[pred]]\n        #     new_list.append(obj)\n        #     self[pred] = new_list\n        except KeyError:\n            try:\n                new_prop = self.properties[pred]\n            except AttributeError:\n                self.properties = {}\n                self.add_property(pred, obj)\n                return\n            except KeyError:\n                try:\n                    new_prop = MODULE.rdfclass.properties[pred]\n                except KeyError:\n                    new_prop = MODULE.rdfclass.make_property({},\n                                                      pred, self.class_names)\n                try:\n                    self.properties[pred] = new_prop\n                except AttributeError:\n                    self.properties = {pred: new_prop}\n            init_prop = new_prop(self, get_attr(self, \"dataset\"))\n            setattr(self,\n                    pred,\n                    init_prop)\n            self[pred] = init_prop\n            self[pred].append(obj)\n        if self.dataset:\n            self.dataset.add_rmap_item(self, pred, obj)", "response": "Adds a property and its value to the class instance."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef conv_json(self, uri_format=\"sparql_uri\", add_ids=False):\n        def convert_item(ivalue):\n            \"\"\" converts an idividual value to a json value\n\n            Args:\n                ivalue: value of the item to convert\n\n            Returns:\n                JSON serializable value\n            \"\"\"\n            nvalue = ivalue\n            if isinstance(ivalue, BaseRdfDataType):\n                if ivalue.type == 'uri':\n                    if ivalue.startswith(\"pyuri\") and uri_format == \"pyuri\":\n                        nvalue = getattr(ivalue, \"sparql\")\n                    else:\n                        nvalue = getattr(ivalue, uri_format)\n                else:\n                    nvalue = ivalue.to_json\n            elif isinstance(ivalue, RdfClassBase):\n                if ivalue.subject.type == \"uri\":\n                    nvalue = ivalue.conv_json(uri_format, add_ids)\n                elif ivalue.subject.type == \"bnode\":\n                    nvalue = ivalue.conv_json(uri_format, add_ids)\n            elif isinstance(ivalue, list):\n                nvalue = []\n                for item in ivalue:\n                    temp = convert_item(item)\n                    nvalue.append(temp)\n            return nvalue\n\n        rtn_val = {key: convert_item(value) for key, value in self.items()}\n        #pdb.set_trace()\n        if add_ids:\n\n            if self.subject.type == 'uri':\n                rtn_val['uri'] = self.subject.sparql_uri\n                rtn_val['id'] = sha1(rtn_val['uri'].encode()).hexdigest()\n        #return {key: convert_item(value) for key, value in self.items()}\n        return rtn_val", "response": "converts the class to a json compatable python dictionary"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef es_mapping(cls, base_class=None, role='rdf_class', **kwargs):\n\n        def _prop_filter(prop, value, **kwargs):\n            \"\"\" filters out props that should not be used for es_mappings:\n            These include props that of the owl:inverseOf the parent_props.\n            Use of these props will cause a recursion depth error\n\n            Args:\n                prop: the name of the prop\n                value: the prop value(an instance of the prop's class)\n\n            Returns:\n                bool: whether the prop should be used\n            \"\"\"\n\n            try:\n                use_prop = len(set(value.owl_inverseOf) - parent_props) > 0\n            except AttributeError:\n                use_prop = True\n            # if not use_prop:\n            #     print(prop)\n            if prop in nested_props and use_prop:\n                return True\n            return False\n        if not base_class:\n            base_class = cls\n        es_map = {}\n        # pdb.set_trace()\n        if kwargs.get(\"depth\"): # and kwargs.get('class') == cls.__name__:\n            kwargs['depth'] += 1\n            initial = False\n        else:\n            initial = True\n            kwargs['depth'] = 1\n            kwargs['class'] = cls.__name__\n            kwargs['class_obj'] = cls\n        if kwargs.get('class_obj'):\n            parent_props = set(cls.properties)\n        else:\n            parent_props = set()\n        if role == 'rdf_class':\n            es_map = {}\n            es_map = {prop: value.es_mapping(base_class) \\\n                      for prop, value in cls.properties.items()}\n\n        elif role == 'es_Nested':\n            # print(locals())\n            # pdb.set_trace()\n            if cls == base_class:\n                nested_props = LABEL_FIELDS\n            else:\n                nested_props = cls.es_defs.get('kds_esNestedProps',\n                                               list(cls.properties.keys()))\n            es_map = {prop: value.es_mapping(base_class, **kwargs) \\\n                      for prop, value in cls.properties.items() \\\n                      if _prop_filter(prop, value, **kwargs)}\n        ref_map = {\n            \"type\" : \"keyword\"\n        }\n        lower_map = {\n            \"type\": \"text\",\n            \"fields\": {\n                \"lower\": es_idx_types['es_Lower']['lower'],\n                'keyword': {'type': 'keyword'}\n            }\n        }\n        ignore_map = {\n            \"index\": False,\n            \"type\": \"text\"\n        }\n        if cls == base_class:\n            es_map['label'] = ref_map\n            es_map['value'] = lower_map\n\n        if cls.cls_defs.get('kds_storageType',[None])[0] != \"blanknode\" \\\n                and cls == base_class:\n            es_map['id'] = ref_map\n            es_map['uri'] = ref_map\n        rml_procs = cls.es_defs.get(\"kds_esRmlProcessor\", [])\n        rml_procs = [proc for proc in rml_procs\n                     if role == 'rdf_class' or\n                     proc['force']]\n        if rml_procs:\n            rml_maps = {}\n            for rml in rml_procs:\n                rml_maps[rml['name']] = ignore_map\n            if rml_maps:\n                es_map['rml_map'] = {\"properties\": rml_maps}\n                # es_map['turtle'] = ignore_map\n        return es_map", "response": "Returns the es mapping for the class"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef es_indexers(cls, base_class=None, role='rdf_class', **kwargs):\n\n        def _prop_filter(prop, value, **kwargs):\n            \"\"\" filters out props that should not be used for es_mappings:\n            These include props that of the owl:inverseOf the parent_props.\n            Use of these props will cause a recursion depth error\n\n            Args:\n                prop: the name of the prop\n                value: the prop value(an instance of the prop's class)\n\n            Returns:\n                bool: whether the prop should be used\n            \"\"\"\n\n            try:\n                use_prop = len(set(value.owl_inverseOf) - parent_props) > 0\n            except AttributeError:\n                use_prop = True\n            if prop in nested_props and use_prop:\n                return True\n            return False\n        if not base_class:\n            base_class = cls\n        rtn_list = []\n        # pdb.set_trace()\n        if kwargs.get(\"depth\"): # and kwargs.get('class') == cls.__name__:\n            kwargs['depth'] += 1\n            initial = False\n        else:\n            initial = True\n            kwargs['depth'] = 1\n            kwargs['class'] = cls.__name__\n            kwargs['class_obj'] = cls\n        if kwargs.get('class_obj'):\n            parent_props = set(cls.properties)\n        else:\n            parent_props = set()\n        if role == 'rdf_class':\n            for value in cls.properties.values():\n                # pdb.set_trace()\n                rtn_list += value.es_indexers(base_class, **kwargs)\n\n        elif role == 'es_Nested':\n            if cls == base_class:\n                nested_props = LABEL_FIELDS\n            else:\n                nested_props = cls.es_defs.get('kds_esNestedProps',\n                                               list(cls.properties.keys()))\n            used_props = [value\n                          for prop, value in cls.properties.items() \\\n                          if _prop_filter(prop, value, **kwargs)]\n            for value in cls.properties.values():\n                # pdb.set_trace()\n                rtn_list += value.es_indexers(base_class, **kwargs)\n\n        if cls.es_defs.get('kds_esIndex',[None])[0]:\n            rtn_list += [cls]\n        return list(set(rtn_list))", "response": "Returns the es mapping for the class with the given role"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef bnode_id(self):\n        if self.subject.type != 'bnode':\n            return self.subject\n        rtn_list = []\n        for prop in sorted(self):\n            for value in sorted(self[prop]):\n                rtn_list.append(\"%s%s\" % (prop, value))\n        return sha1(\"\".join(rtn_list).encode()).hexdigest()", "response": "Calculates the bnode id for the class\n       "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a JSON object of the class for insertion into es", "response": "def es_json(self, role='rdf_class', remove_empty=True, **kwargs):\n        \"\"\" Returns a JSON object of the class for insertion into es\n\n        args:\n            role: the role states how the class data should be returned\n                  depending upon whether it is used as a subject of an object.\n                  options are kds_esNested or rdf_class\n            remove_empty: True removes empty items from es object\n        \"\"\"\n        def test_idx_status(cls_inst, **kwargs):\n            \"\"\"\n            Return True if the class has already been indexed in elastisearch\n\n            Args:\n            -----\n                cls_inst: the rdfclass instance\n\n            Kwargs:\n            -------\n                force[boolean]: True will return false to force a reindex of the\n                        class\n            \"\"\"\n            if kwargs.get(\"force\") == True:\n                return False\n            idx_time = cls_inst.get(\"kds_esIndexTime\", [None])[0]\n            mod_time = cls_inst.get(\"dcterm_modified\", [None])[0]\n            error_msg = cls_inst.get(\"kds_esIndexError\", [None])[0]\n            if (not idx_time) or \\\n               error_msg or \\\n               (idx_time and mod_time and idx_time < mod_time):\n               return False\n            return True\n\n        # if self.__class__.__name__ == 'rdf_type':\n        #     pdb.set_trace()\n        rtn_obj = {}\n        if kwargs.get(\"depth\"):\n            kwargs['depth'] += 1\n        else:\n            kwargs['depth'] = 1\n        if role == 'rdf_class':\n            if test_idx_status(self, **kwargs):\n                return None\n            for prop, value in self.items():\n                if prop in ['kds_esIndexTime', 'kds_esIndexError']:\n                    continue\n                new_val = value.es_json()\n                rtn_method = get_attr(self[prop], 'kds_esObjectType', [])\n                if 'kdr_Array' in rtn_method:\n                    rtn_obj[prop] = new_val\n                elif (remove_empty and new_val) or not remove_empty:\n                    if len(new_val) == 1:\n                        rtn_obj[prop] = new_val[0]\n                    else:\n                        rtn_obj[prop] = new_val\n            nested_props = None\n        else:\n            try:\n                nested_props = self.es_defs.get('kds_esNestedProps',\n                                                list(self.keys())).copy()\n            except AttributeError:\n                nested_props = list(self.keys())\n            for prop, value in self.items():\n                # if prop == 'bf_hasInstance':\n                #     pdb.set_trace()\n                if prop in ['kds_esIndexTime', 'kds_esIndexError']:\n                    continue\n                new_val = value.es_json(**kwargs)\n                rtn_method = get_attr(self[prop], 'kds_esObjectType', [])\n                if 'kdr_Array' in rtn_method:\n                    rtn_obj[prop] = new_val\n                elif (remove_empty and new_val) or not remove_empty:\n                    if len(new_val) == 1:\n                        rtn_obj[prop] = new_val[0] \\\n                                if not isinstance(new_val, dict) \\\n                                else new_val\n                    else:\n                        rtn_obj[prop] = new_val\n        # if 'bf_Work' in self.hierarchy:\n        #     pdb.set_trace()\n\n        rtn_obj = get_es_label(rtn_obj, self)\n        rtn_obj = get_es_value(rtn_obj, self)\n        rtn_obj = get_es_ids(rtn_obj, self)\n        if nested_props:\n            nested_props += ['value', 'id', 'uri']\n            rtn_obj = {key: value\n                       for key, value in rtn_obj.items()\n                       if key in nested_props}\n        # rml_procs = self.es_defs.get(\"kds_esRmlProcessor\", [])\n        # # if role == 'rdf_class':\n        # #     pdb.set_trace()\n        # rml_procs = [proc for proc in rml_procs\n        #              if role == 'rdf_class' or\n        #              proc['force']]\n        # if rml_procs:\n        #     rml_maps = {}\n        #     for rml in rml_procs:\n        #         proc_kwargs = {rml['subj']: self.subject,\n        #                        \"dataset\": self.dataset}\n        #         proc_kwargs.update(rml['proc_kwargs'])\n        #         rml_maps[rml['name']] = rml['processor'](**proc_kwargs)\n        #     if rml_maps:\n        #         rtn_obj['rml_map'] = rml_maps\n        rml_maps = self.get_all_rml(role=role)\n        if rml_maps:\n                rtn_obj['rml_map'] = rml_maps\n        # if self.get('bf_contribution'):\n        #     pdb.set_trace()\n        return rtn_obj"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_rml(self, rml_def, **kwargs):\n        if isinstance(rml_def, str):\n            rml_procs = self.es_defs.get(\"kds_esRmlProcessor\", [])\n            for item in rml_procs:\n                if item['name'] == rml_def:\n                    rml_def = item\n                    break\n        proc_kwargs = {rml_def['subj']: self.subject,\n                       \"dataset\": self.dataset}\n        proc_kwargs.update(rml_def['proc_kwargs'])\n        return rml_def['processor'](**proc_kwargs)", "response": "Returns the rml mapping output for the specified mapping or a dictionary definition."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a dictionary with the output of all the rml processors", "response": "def get_all_rml(self, **kwargs):\n        \"\"\"\n        Returns a dictionary with the output of all the rml procceor results\n        \"\"\"\n        rml_procs = self.es_defs.get(\"kds_esRmlProcessor\", [])\n        role = kwargs.get('role')\n        if role:\n            rml_procs = [proc for proc in rml_procs\n                         if role == 'rdf_class' or\n                         proc['force']]\n        rml_maps = {}\n        for rml in rml_procs:\n            rml_maps[rml['name']] = self.get_rml(rml, **kwargs)\n        return rml_maps"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nset the subject value for the class instance", "response": "def _set_subject(self, subject):\n        \"\"\" sets the subject value for the class instance\n\n        Args:\n            subject(dict, Uri, str): the subject for the class instance\n        \"\"\"\n        # if not subject:\n        #     self.subject =\n        def test_uri(value):\n            \"\"\" test to see if the value is a uri or bnode\n\n            Returns: Uri or Bnode \"\"\"\n            # .__wrapped__\n            if not isinstance(value, (Uri, BlankNode)):\n                try:\n                    if value.startswith(\"_:\"):\n                        return BlankNode(value)\n                    else:\n                        return Uri(value)\n                except:\n                    return BlankNode()\n            else:\n                return value\n\n        if isinstance(subject, dict):\n            self.subject = test_uri(subject['s'])\n            if isinstance(subject['o'], list):\n                for item in subject['o']:\n                    self.add_property(subject['p'],\n                                      item)\n            else:\n                self.add_property(subject['p'],\n                                  subject['o'])\n        else:\n            self.subject = test_uri(subject)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _initilize_props(self):\n        # if self.subject == \"pyuri_aHR0cDovL3R1dHQuZWR1Lw==_\":\n        #     pdb.set_trace()\n        try:\n            # pdb.set_trace()\n            for prop in self.es_props:\n                self[prop] = self.properties[prop](self, self.dataset)\n                setattr(self, prop, self[prop])\n\n            self[__a__] = self.properties[__a__](self, self.dataset)\n            setattr(self, __a__, self[__a__])\n            # for prop, prop_class in self.properties.items():\n            #     # passing in the current dataset tie\n            #     self[prop] = prop_class(self, self.dataset)\n            #     setattr(self, prop, self[prop])\n            # bases = remove_parents((self.__class__,) +\n            #                         self.__class__.__bases__)\n            # for base in bases:\n            #     if base.__name__ not in IGNORE_CLASSES:\n            #         base_name = Uri(base.__name__)\n            #         try:\n            #             self['rdf_type'].append(base_name)\n            #         except KeyError:\n            #             self[Uri('rdf_type')] = MODULE.rdfclass.make_property({},\n            #                     'rdf_type',\n            #                     self.__class__.__name__)(self, self.dataset)\n            #             self['rdf_type'].append(base_name)\n        except (AttributeError, TypeError):\n            pass", "response": "Adds an intialized property to the class dictionary"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nswitches to a new state", "response": "def switch_to(self, newstate):\r\n        \"\"\"Switch to a new state\r\n        \r\n        newstate : int or string\r\n            Can be either the value of the state, or the label of the state\"\"\"\r\n        if type(newstate) is int:\r\n            if newstate in self._states:\r\n                self._curcode = newstate\r\n            else:\r\n                raise Exception(\"The state value \" + str(newstate) + \" does not exist.\")            \r\n        else:\r\n            if newstate in self._scodes:\r\n                self._curcode = self._scodes[newstate]\r\n            else:\r\n                raise Exception(\"The state \" + newstate + \" does not exist.\")"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_serializer_class(self, action=None):\n        if action is not None:\n            return getattr(self, '%s_serializer_class' % action)\n        else:\n            return super(GenericViewSet, self).get_serializer_class()", "response": "Returns the serializer class depending on request method."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_serializer(self, *args, **kwargs):\n        action = kwargs.pop('action', None)\n\n        serializer_class = self.get_serializer_class(action)\n\n        kwargs['context'] = self.get_serializer_context()\n        return serializer_class(*args, **kwargs)", "response": "Returns the serializer instance that should be used to the\n        given action."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef open(self, autocommit=False):\n    self.data_access.open(autocommit=autocommit)\n    return self", "response": "Call - through to data_access. open."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncalls - through to data_access. close.", "response": "def close(self, commit=True):\n    \"\"\"Call-through to data_access.close.\"\"\"\n    self.data_access.close(commit=commit)\n    return self"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates the default relations and transfers tables.", "response": "def setup(self):\n    \"\"\"Creates the default relations and transfers tables. The SQL used may not work on all\n    databases. (It was written for SQLite3)\n    \"\"\"\n    cmds = [\n      \"\"\"\n        create table if not exists relations (\n          id integer not null primary key,\n          name text not null unique,\n          completed_at datetime\n        );\n      \"\"\",\n      \"\"\"\n        create table if not exists transfers (\n          relation_id integer not null references relations (id) on delete cascade,\n          old_id text not null,\n          new_id text,\n          primary key (relation_id, old_id)\n        );\n      \"\"\",\n      \"\"\"\n        create index if not exists transfers_relation_id_idx on transfers (relation_id);\n      \"\"\"\n    ]\n\n    for cmd in cmds:\n      self.data_access.execute(cmd)\n    self.data_access.commit()\n    return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef reset(self, relation_name=None):\n    if relation_name is not None:\n      self.data_access.delete(\"relations\", dict(name=relation_name))\n    else:\n      self.data_access.delete(\"relations\", \"1=1\")\n    return self", "response": "Reset the transfer info for a particular relation."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nwrites records to the data source indicating that a transfer has been started for a particular relation.", "response": "def start_transfer(self, relation_name):\n    \"\"\"Write records to the data source indicating that a transfer has been started for a particular\n    relation.\n    \"\"\"\n    self.reset(relation_name)\n    relation = Relation(name=relation_name)\n    self.data_access.insert_model(relation)\n    return relation"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef register_transfer(self, relation, old_id, new_id):\n    transfer = Transfer(relation_id=relation.id, old_id=old_id, new_id=new_id)\n    self.data_access.insert_model(transfer)\n    return transfer", "response": "Register the old and new ids for a particular record in a relation."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nwrites records to the data source indicating that a transfer has been completed for a particular relation.", "response": "def complete_transfer(self, relation, cleanup=True):\n    \"\"\"Write records to the data source indicating that a transfer has been completed for a\n    particular relation.\n    \"\"\"\n    relation.completed_at = utc_now().isoformat()\n    self.data_access.update_model(relation)\n    if cleanup:\n      self.cleanup()\n    return relation"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef is_transfer_complete(self, relation_name):\n    phold = self.data_access.sql_writer.to_placeholder()\n    return self.data_access.find_model(\n      Relation,\n      (\"name = {0} and completed_at is not null\".format(phold), [relation_name])) is not None", "response": "Checks to see if a tansfer has been completed."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngiving a relation name and its old ID get the new ID for a relation.", "response": "def get_new_id(self, relation_name, old_id, strict=False):\n    \"\"\"Given a relation name and its old ID, get the new ID for a relation. If strict is true, an\n    error is thrown if no record is found for the relation and old ID.\n    \"\"\"\n    record = self.data_access.find(\n      \"relations as r inner join transfers as t on r.id = t.relation_id\",\n      ((\"r.name\", relation_name), (\"t.old_id\", old_id)),\n      columns=\"new_id\")\n    if record:\n      return record[0]\n    else:\n      if strict:\n        raise KeyError(\"{0} with id {1} not found\".format(relation_name, old_id))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef id_getter(self, relation_name, strict=False):\n    def get_id(old_id):\n      \"\"\"Get the new ID for the enclosed relation, given an old ID.\"\"\"\n      return self.get_new_id(relation_name, old_id, strict)\n    return get_id", "response": "Returns a function that accepts an old_id and returns the new ID for the enclosed relation."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef requires_loaded(func):\n        def _wrapper(self, *args, **kwargs):\n            # If we don't have data, go load it.\n            if self._loaded_data is None:\n                self._loaded_data = self.loader.load(self.service_name)\n\n            return func(self, *args, **kwargs)\n\n        return _wrapper", "response": "A decorator to ensure the resource data is loaded."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef result_key_for(self, op_name):\n        ops = self.collection_data.get('operations', {})\n        op = ops.get(op_name, {})\n        key = op.get('result_key', None)\n        return key", "response": "Returns the key for the result_key of the given operation name."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef full_update_params(self, conn_method_name, params):\n        # We'll check for custom methods to do addition, specific work.\n        custom_method_name = 'update_params_{0}'.format(conn_method_name)\n        custom_method = getattr(self, custom_method_name, None)\n\n        if custom_method:\n            # Let the specific method further process the data.\n            params = custom_method(params)\n\n        # Now that all the method-specific data is there, apply any further\n        # service-wide changes here.\n        params = self.update_params(conn_method_name, params)\n        return params", "response": "This method is called by the underlying connection class to update the parameters of the current object."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef full_post_process(self, conn_method_name, result):\n        result = self.post_process(conn_method_name, result)\n\n        # We'll check for custom methods to do addition, specific work.\n        custom_method_name = 'post_process_{0}'.format(conn_method_name)\n        custom_method = getattr(self, custom_method_name, None)\n\n        if custom_method:\n            # Let the specific method further process the data.\n            result = custom_method(result)\n\n        return result", "response": "This method is called by the server - side to process the response from the API method."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef post_process_create(self, result):\n        # We need to possibly drill into the response & get out the data here.\n        # Check for a result key.\n        result_key = self._details.result_key_for('create')\n\n        if not result_key:\n            return self.build_resource(result)\n\n        return self.build_resource(result[result_key])", "response": "This method is called when the API is called to create a new resource."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef post_process_each(self, result):\n        # We need to possibly drill into the response & get out the data here.\n        # Check for a result key.\n        result_key = self._details.result_key_for('each')\n\n        if not result_key:\n            return result\n\n        return [self.build_resource(res) for res in result[result_key]]", "response": "This method is called by the resource manager when the API returns a list of set of Resource instances."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nbuilds a correct Resource subclass for the Collection.", "response": "def build_resource(self, data):\n        \"\"\"\n        Given some data, builds the correct/matching ``Resource`` subclass\n        for the ``Collection``. Useful in things like ``create`` & ``each``.\n\n        :param result: The data for an instance handed back from the API.\n        :type result: dict\n\n        :returns: A ``Resource`` subclass\n        \"\"\"\n        if self._res_class is None:\n            self._res_class = self._details.session.get_resource(\n                self._details.service_name,\n                self._details.resource\n            )\n\n        final_data = {}\n\n        # Lightly post-process the data, to look more Pythonic.\n        for key, value in data.items():\n            final_data[to_snake_case(key)] = value\n\n        return self._res_class(connection=self._connection, **final_data)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nconstructs a new specialized Collection class for a given service and collection.", "response": "def construct_for(self, service_name, collection_name, base_class=None):\n        \"\"\"\n        Builds a new, specialized ``Collection`` subclass as part of a given\n        service.\n\n        This will load the ``ResourceJSON``, determine the correct\n        mappings/methods & constructs a brand new class with those methods on\n        it.\n\n        :param service_name: The name of the service to construct a resource\n            for. Ex. ``sqs``, ``sns``, ``dynamodb``, etc.\n        :type service_name: string\n\n        :param collection_name: The name of the ``Collection``. Ex.\n            ``QueueCollection``, ``NotificationCollection``,\n            ``TableCollection``, etc.\n        :type collection_name: string\n\n        :returns: A new collection class for that service\n        \"\"\"\n        details = self.details_class(\n            self.session,\n            service_name,\n            collection_name,\n            loader=self.loader\n        )\n\n        attrs = {\n            '_details': details,\n        }\n\n        # Determine what we should call it.\n        klass_name = self._build_class_name(collection_name)\n\n        # Construct what the class ought to have on it.\n        attrs.update(self._build_methods(details))\n\n        if base_class is None:\n            base_class = self.base_collection_class\n\n        # Create the class.\n        return type(\n            klass_name,\n            (base_class,),\n            attrs\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef BFS(G, start):\r\n    if start not in G.vertices:\r\n        raise GraphInsertError(\"Vertex %s doesn't exist.\" % (start,))\r\n    color = {}\r\n    pred = {}\r\n    dist = {}\r\n    queue = Queue()\r\n    queue.put(start)\r\n    for vertex in G.vertices:\r\n        color[vertex] = 'white'\r\n        pred[vertex] = None\r\n        dist[vertex] = 0\r\n    while queue.qsize() > 0:\r\n        current = queue.get()\r\n        for neighbor in G.vertices[current]:\r\n            if color[neighbor] == 'white':\r\n                color[neighbor] = 'grey'\r\n                pred[neighbor] = current\r\n                dist[neighbor] = dist[current] + 1\r\n                queue.put(neighbor)\r\n        color[current] = 'black'\r\n    return pred", "response": "Returns a tuple of the color and distance between start and end vertices in a graph."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns an oriented tree constructed from bfs starting at start.", "response": "def BFS_Tree(G, start):\r\n    \"\"\"\r\n    Return an oriented tree constructed from bfs starting at 'start'.\r\n    \"\"\"\r\n    if start not in G.vertices:\r\n        raise GraphInsertError(\"Vertex %s doesn't exist.\" % (start,))\r\n    pred = BFS(G, start)\r\n    T = digraph.DiGraph()\r\n    queue = Queue()\r\n    queue.put(start)\r\n    while queue.qsize() > 0:\r\n        current = queue.get()\r\n        for element in pred:\r\n            if pred[element] == current:\r\n                T.add_edge(current, element)\r\n                queue.put(element)\r\n    return T"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef DFS_Tree(G):\r\n    if not G.vertices:\r\n        raise GraphInsertError(\"This graph have no vertices.\")\r\n    pred = {}\r\n    T = digraph.DiGraph()\r\n    vertex_data = DFS(G)\r\n    for vertex in vertex_data:\r\n        pred[vertex] = vertex_data[vertex][0]\r\n    queue = Queue()\r\n    for vertex in pred:\r\n        if pred[vertex] == None:\r\n            queue.put(vertex)\r\n    while queue.qsize() > 0:\r\n        current = queue.get()\r\n        for element in pred:\r\n            if pred[element] == current:\r\n                T.add_edge(current, element)\r\n                queue.put(element)\r\n    return T", "response": "Returns an oriented tree constructed from DFS."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef exception_handler_v20(status_code, error_content):\n    error_dict = None\n    request_ids = error_content.request_ids\n    if isinstance(error_content, dict):\n        error_dict = error_content.get('NeutronError')\n    # Find real error type\n    client_exc = None\n    if error_dict:\n        # If Neutron key is found, it will definitely contain\n        # a 'message' and 'type' keys?\n        try:\n            error_type = error_dict['type']\n            error_message = error_dict['message']\n            if error_dict['detail']:\n                error_message += \"\\n\" + error_dict['detail']\n            # If corresponding exception is defined, use it.\n            client_exc = getattr(exceptions, '%sClient' % error_type, None)\n        except Exception:\n            error_message = \"%s\" % error_dict\n    else:\n        error_message = None\n        if isinstance(error_content, dict):\n            error_message = error_content.get('message')\n        if not error_message:\n            # If we end up here the exception was not a neutron error\n            error_message = \"%s-%s\" % (status_code, error_content)\n\n    # If an exception corresponding to the error type is not found,\n    # look up per status-code client exception.\n    if not client_exc:\n        client_exc = exceptions.HTTP_EXCEPTION_MAP.get(status_code)\n    # If there is no exception per status-code,\n    # Use NeutronClientException as fallback.\n    if not client_exc:\n        client_exc = exceptions.NeutronClientException\n\n    raise client_exc(message=error_message,\n                     status_code=status_code,\n                     request_ids=request_ids)", "response": "This function generates a Neutron exception according to the status code and the error_content."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd request_ids as an attribute to the object", "response": "def _append_request_ids(self, resp):\n        \"\"\"Add request_ids as an attribute to the object\n\n        :param resp: Response object or list of Response objects\n        \"\"\"\n        if isinstance(resp, list):\n            # Add list of request_ids if response is of type list.\n            for resp_obj in resp:\n                self._append_request_id(resp_obj)\n        elif resp is not None:\n            # Add request_ids if response contains single object.\n            self._append_request_id(resp)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef serialize(self, data):\n        if data is None:\n            return None\n        elif isinstance(data, dict):\n            return serializer.Serializer().serialize(data)\n        else:\n            raise Exception(_(\"Unable to serialize object of type = '%s'\") %\n                            type(data))", "response": "Serializes a dictionary into JSON."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncalls do_request with the default retry configuration.", "response": "def retry_request(self, method, action, body=None,\n                      headers=None, params=None):\n        \"\"\"Call do_request with the default retry configuration.\n\n        Only idempotent requests should retry failed connection attempts.\n        :raises: ConnectionFailed if the maximum # of retries is exceeded\n        \"\"\"\n        max_attempts = self.retries + 1\n        for i in range(max_attempts):\n            try:\n                return self.do_request(method, action, body=body,\n                                       headers=headers, params=params)\n            except exceptions.ConnectionFailed:\n                # Exception has already been logged by do_request()\n                if i < self.retries:\n                    _logger.debug('Retrying connection to Neutron service')\n                    time.sleep(self.retry_interval)\n                elif self.raise_errors:\n                    raise\n\n        if self.retries:\n            msg = (_(\"Failed to connect to Neutron server after %d attempts\")\n                   % max_attempts)\n        else:\n            msg = _(\"Failed to connect Neutron server\")\n\n        raise exceptions.ConnectionFailed(reason=msg)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef show_ext(self, path, id, **_params):\n        return self.get(path % id, params=_params)", "response": "Client extension hook for show."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nfetch information of a certain project s quotas.", "response": "def show_quota(self, project_id, **_params):\n        \"\"\"Fetch information of a certain project's quotas.\"\"\"\n        return self.get(self.quota_path % (project_id), params=_params)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef update_quota(self, project_id, body=None):\n        return self.put(self.quota_path % (project_id), body=body)", "response": "Update a project s quotas."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef show_extension(self, ext_alias, **_params):\n        return self.get(self.extension_path % ext_alias, params=_params)", "response": "Fetches information of a certain extension."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef list_ports(self, retrieve_all=True, **_params):\n        # Pass filters in \"params\" argument to do_request\n        return self.list('ports', self.ports_path, retrieve_all,\n                         **_params)", "response": "Fetches a list of all ports for a project."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfetches information of a certain port.", "response": "def show_port(self, port, **_params):\n        \"\"\"Fetches information of a certain port.\"\"\"\n        return self.get(self.port_path % (port), params=_params)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef list_networks(self, retrieve_all=True, **_params):\n        # Pass filters in \"params\" argument to do_request\n        return self.list('networks', self.networks_path, retrieve_all,\n                         **_params)", "response": "Fetches a list of all networks for a project."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfetches information of a certain network.", "response": "def show_network(self, network, **_params):\n        \"\"\"Fetches information of a certain network.\"\"\"\n        return self.get(self.network_path % (network), params=_params)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nfetching a list of all subnets for a project.", "response": "def list_subnets(self, retrieve_all=True, **_params):\n        \"\"\"Fetches a list of all subnets for a project.\"\"\"\n        return self.list('subnets', self.subnets_path, retrieve_all,\n                         **_params)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nfetch information of a certain subnet.", "response": "def show_subnet(self, subnet, **_params):\n        \"\"\"Fetches information of a certain subnet.\"\"\"\n        return self.get(self.subnet_path % (subnet), params=_params)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef list_subnetpools(self, retrieve_all=True, **_params):\n        return self.list('subnetpools', self.subnetpools_path, retrieve_all,\n                         **_params)", "response": "Fetches a list of all subnetpools for a project."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nfetch information of a certain subnetpool.", "response": "def show_subnetpool(self, subnetpool, **_params):\n        \"\"\"Fetches information of a certain subnetpool.\"\"\"\n        return self.get(self.subnetpool_path % (subnetpool), params=_params)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef list_routers(self, retrieve_all=True, **_params):\n        # Pass filters in \"params\" argument to do_request\n        return self.list('routers', self.routers_path, retrieve_all,\n                         **_params)", "response": "Fetches a list of all routers for a project."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nfetches information of a certain router.", "response": "def show_router(self, router, **_params):\n        \"\"\"Fetches information of a certain router.\"\"\"\n        return self.get(self.router_path % (router), params=_params)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef list_address_scopes(self, retrieve_all=True, **_params):\n        return self.list('address_scopes', self.address_scopes_path,\n                         retrieve_all, **_params)", "response": "Fetches a list of all address scopes for a project."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef show_address_scope(self, address_scope, **_params):\n        return self.get(self.address_scope_path % (address_scope),\n                        params=_params)", "response": "Fetches information of a certain address scope."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef update_address_scope(self, address_scope, body=None):\n        return self.put(self.address_scope_path % (address_scope), body=body)", "response": "Updates a address scope."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds an internal network interface to the specified router.", "response": "def add_interface_router(self, router, body=None):\n        \"\"\"Adds an internal network interface to the specified router.\"\"\"\n        return self.put((self.router_path % router) + \"/add_router_interface\",\n                        body=body)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nremoving an internal network interface from the specified router.", "response": "def remove_interface_router(self, router, body=None):\n        \"\"\"Removes an internal network interface from the specified router.\"\"\"\n        return self.put((self.router_path % router) +\n                        \"/remove_router_interface\", body=body)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add_gateway_router(self, router, body=None):\n        return self.put((self.router_path % router),\n                        body={'router': {'external_gateway_info': body}})", "response": "Adds an external network gateway to the specified router."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef list_floatingips(self, retrieve_all=True, **_params):\n        # Pass filters in \"params\" argument to do_request\n        return self.list('floatingips', self.floatingips_path, retrieve_all,\n                         **_params)", "response": "Fetches a list of all floatingips for a project."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nfetching information of a certain floatingip.", "response": "def show_floatingip(self, floatingip, **_params):\n        \"\"\"Fetches information of a certain floatingip.\"\"\"\n        return self.get(self.floatingip_path % (floatingip), params=_params)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nupdate a security group.", "response": "def update_security_group(self, security_group, body=None):\n        \"\"\"Updates a security group.\"\"\"\n        return self.put(self.security_group_path %\n                        security_group, body=body)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nfetching a list of all security groups for a project.", "response": "def list_security_groups(self, retrieve_all=True, **_params):\n        \"\"\"Fetches a list of all security groups for a project.\"\"\"\n        return self.list('security_groups', self.security_groups_path,\n                         retrieve_all, **_params)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef show_security_group(self, security_group, **_params):\n        return self.get(self.security_group_path % (security_group),\n                        params=_params)", "response": "Fetches information of a certain security group."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nfetching a list of all security group rules for a project.", "response": "def list_security_group_rules(self, retrieve_all=True, **_params):\n        \"\"\"Fetches a list of all security group rules for a project.\"\"\"\n        return self.list('security_group_rules',\n                         self.security_group_rules_path,\n                         retrieve_all, **_params)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef show_security_group_rule(self, security_group_rule, **_params):\n        return self.get(self.security_group_rule_path % (security_group_rule),\n                        params=_params)", "response": "Fetches information of a certain security group rule."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nfetching a list of all VPN endpoint groups for a project.", "response": "def list_endpoint_groups(self, retrieve_all=True, **_params):\n        \"\"\"Fetches a list of all VPN endpoint groups for a project.\"\"\"\n        return self.list('endpoint_groups', self.endpoint_groups_path,\n                         retrieve_all, **_params)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef show_endpoint_group(self, endpointgroup, **_params):\n        return self.get(self.endpoint_group_path % endpointgroup,\n                        params=_params)", "response": "Fetches information for a specific VPN endpoint group."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nupdates a VPN endpoint group.", "response": "def update_endpoint_group(self, endpoint_group, body=None):\n        \"\"\"Updates a VPN endpoint group.\"\"\"\n        return self.put(self.endpoint_group_path % endpoint_group, body=body)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef list_vpnservices(self, retrieve_all=True, **_params):\n        return self.list('vpnservices', self.vpnservices_path, retrieve_all,\n                         **_params)", "response": "Fetches a list of all configured VPN services for a project."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef show_vpnservice(self, vpnservice, **_params):\n        return self.get(self.vpnservice_path % (vpnservice), params=_params)", "response": "Fetches information of a specific VPN service."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nupdates a VPN service.", "response": "def update_vpnservice(self, vpnservice, body=None):\n        \"\"\"Updates a VPN service.\"\"\"\n        return self.put(self.vpnservice_path % (vpnservice), body=body)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef list_ipsec_site_connections(self, retrieve_all=True, **_params):\n        return self.list('ipsec_site_connections',\n                         self.ipsec_site_connections_path,\n                         retrieve_all,\n                         **_params)", "response": "Fetches all configured IPsecSiteConnections for a project."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nfetch information of a specific IPsecSiteConnection.", "response": "def show_ipsec_site_connection(self, ipsecsite_conn, **_params):\n        \"\"\"Fetches information of a specific IPsecSiteConnection.\"\"\"\n        return self.get(\n            self.ipsec_site_connection_path % (ipsecsite_conn), params=_params\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef list_ikepolicies(self, retrieve_all=True, **_params):\n        return self.list('ikepolicies', self.ikepolicies_path, retrieve_all,\n                         **_params)", "response": "Fetches a list of all configured IKEPolicies for a project."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nfetching information of a specific IKEPolicy.", "response": "def show_ikepolicy(self, ikepolicy, **_params):\n        \"\"\"Fetches information of a specific IKEPolicy.\"\"\"\n        return self.get(self.ikepolicy_path % (ikepolicy), params=_params)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nfetching a list of all configured IPsecPolicies for a project.", "response": "def list_ipsecpolicies(self, retrieve_all=True, **_params):\n        \"\"\"Fetches a list of all configured IPsecPolicies for a project.\"\"\"\n        return self.list('ipsecpolicies',\n                         self.ipsecpolicies_path,\n                         retrieve_all,\n                         **_params)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nfetches information of a specific IPsecPolicy.", "response": "def show_ipsecpolicy(self, ipsecpolicy, **_params):\n        \"\"\"Fetches information of a specific IPsecPolicy.\"\"\"\n        return self.get(self.ipsecpolicy_path % (ipsecpolicy), params=_params)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef list_loadbalancers(self, retrieve_all=True, **_params):\n        return self.list('loadbalancers', self.lbaas_loadbalancers_path,\n                         retrieve_all, **_params)", "response": "Fetches a list of all loadbalancers for a project."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef show_loadbalancer(self, lbaas_loadbalancer, **_params):\n        return self.get(self.lbaas_loadbalancer_path % (lbaas_loadbalancer),\n                        params=_params)", "response": "Fetches information for a load balancer."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nupdate a load balancer.", "response": "def update_loadbalancer(self, lbaas_loadbalancer, body=None):\n        \"\"\"Updates a load balancer.\"\"\"\n        return self.put(self.lbaas_loadbalancer_path % (lbaas_loadbalancer),\n                        body=body)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef retrieve_loadbalancer_stats(self, loadbalancer, **_params):\n        return self.get(self.lbaas_loadbalancer_path_stats % (loadbalancer),\n                        params=_params)", "response": "Retrieves stats for a certain load balancer."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef retrieve_loadbalancer_status(self, loadbalancer, **_params):\n        return self.get(self.lbaas_loadbalancer_path_status % (loadbalancer),\n                        params=_params)", "response": "Retrieves the status of a certain load balancer."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef list_listeners(self, retrieve_all=True, **_params):\n        return self.list('listeners', self.lbaas_listeners_path,\n                         retrieve_all, **_params)", "response": "Fetches a list of all lbaas_listeners for a project."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef show_listener(self, lbaas_listener, **_params):\n        return self.get(self.lbaas_listener_path % (lbaas_listener),\n                        params=_params)", "response": "Fetches information for a lbaas_listener."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef list_lbaas_l7policies(self, retrieve_all=True, **_params):\n        return self.list('l7policies', self.lbaas_l7policies_path,\n                         retrieve_all, **_params)", "response": "Fetches a list of all L7 policies for a listener."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef show_lbaas_l7policy(self, l7policy, **_params):\n        return self.get(self.lbaas_l7policy_path % l7policy,\n                        params=_params)", "response": "Fetches information of a certain listener s L7 policy."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef update_lbaas_l7policy(self, l7policy, body=None):\n        return self.put(self.lbaas_l7policy_path % l7policy,\n                        body=body)", "response": "Updates the L7 policy."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef list_lbaas_l7rules(self, l7policy, retrieve_all=True, **_params):\n        return self.list('rules', self.lbaas_l7rules_path % l7policy,\n                         retrieve_all, **_params)", "response": "Fetches a list of all rules for L7 policy."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef show_lbaas_l7rule(self, l7rule, l7policy, **_params):\n        return self.get(self.lbaas_l7rule_path % (l7policy, l7rule),\n                        params=_params)", "response": "Fetches information of a certain L7 policy s rule."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef create_lbaas_l7rule(self, l7policy, body=None):\n        return self.post(self.lbaas_l7rules_path % l7policy, body=body)", "response": "Creates a new L7 rule for a certain L7 policy."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nupdates a L7 rule.", "response": "def update_lbaas_l7rule(self, l7rule, l7policy, body=None):\n        \"\"\"Updates L7 rule.\"\"\"\n        return self.put(self.lbaas_l7rule_path % (l7policy, l7rule),\n                        body=body)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef delete_lbaas_l7rule(self, l7rule, l7policy):\n        return self.delete(self.lbaas_l7rule_path % (l7policy, l7rule))", "response": "Deletes the specified L7 rule."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nfetching a list of all lbaas_pools for a project.", "response": "def list_lbaas_pools(self, retrieve_all=True, **_params):\n        \"\"\"Fetches a list of all lbaas_pools for a project.\"\"\"\n        return self.list('pools', self.lbaas_pools_path,\n                         retrieve_all, **_params)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nfetch information for a lbaas_pool.", "response": "def show_lbaas_pool(self, lbaas_pool, **_params):\n        \"\"\"Fetches information for a lbaas_pool.\"\"\"\n        return self.get(self.lbaas_pool_path % (lbaas_pool),\n                        params=_params)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef list_lbaas_healthmonitors(self, retrieve_all=True, **_params):\n        return self.list('healthmonitors', self.lbaas_healthmonitors_path,\n                         retrieve_all, **_params)", "response": "Fetches a list of all lbaas_healthmonitors for a project."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nfetch information for a lbaas_healthmonitor.", "response": "def show_lbaas_healthmonitor(self, lbaas_healthmonitor, **_params):\n        \"\"\"Fetches information for a lbaas_healthmonitor.\"\"\"\n        return self.get(self.lbaas_healthmonitor_path % (lbaas_healthmonitor),\n                        params=_params)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nfetches a list of all lbaas_loadbalancers for a project.", "response": "def list_lbaas_loadbalancers(self, retrieve_all=True, **_params):\n        \"\"\"Fetches a list of all lbaas_loadbalancers for a project.\"\"\"\n        return self.list('loadbalancers', self.lbaas_loadbalancers_path,\n                         retrieve_all, **_params)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef list_lbaas_members(self, lbaas_pool, retrieve_all=True, **_params):\n        return self.list('members', self.lbaas_members_path % lbaas_pool,\n                         retrieve_all, **_params)", "response": "Fetches a list of all lbaas_members for a project."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef show_lbaas_member(self, lbaas_member, lbaas_pool, **_params):\n        return self.get(self.lbaas_member_path % (lbaas_pool, lbaas_member),\n                        params=_params)", "response": "Fetches information of a certain lbaas_member."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ndelete the specified lbaas_member.", "response": "def delete_lbaas_member(self, lbaas_member, lbaas_pool):\n        \"\"\"Deletes the specified lbaas_member.\"\"\"\n        return self.delete(self.lbaas_member_path % (lbaas_pool, lbaas_member))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef list_vips(self, retrieve_all=True, **_params):\n        # Pass filters in \"params\" argument to do_request\n        return self.list('vips', self.vips_path, retrieve_all,\n                         **_params)", "response": "Fetches a list of all load balancer vips for a project."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nfetching information of a certain load balancer vip.", "response": "def show_vip(self, vip, **_params):\n        \"\"\"Fetches information of a certain load balancer vip.\"\"\"\n        return self.get(self.vip_path % (vip), params=_params)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef update_vip(self, vip, body=None):\n        return self.put(self.vip_path % (vip), body=body)", "response": "Updates a load balancer vip."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfetches a list of all load balancer pools for a project.", "response": "def list_pools(self, retrieve_all=True, **_params):\n        \"\"\"Fetches a list of all load balancer pools for a project.\"\"\"\n        # Pass filters in \"params\" argument to do_request\n        return self.list('pools', self.pools_path, retrieve_all,\n                         **_params)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef show_pool(self, pool, **_params):\n        return self.get(self.pool_path % (pool), params=_params)", "response": "Fetches information of a certain load balancer pool."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef update_pool(self, pool, body=None):\n        return self.put(self.pool_path % (pool), body=body)", "response": "Updates a load balancer pool."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef retrieve_pool_stats(self, pool, **_params):\n        return self.get(self.pool_path_stats % (pool), params=_params)", "response": "Retrieves stats for a certain load balancer pool."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nfetching a list of all load balancer members for a project.", "response": "def list_members(self, retrieve_all=True, **_params):\n        \"\"\"Fetches a list of all load balancer members for a project.\"\"\"\n        # Pass filters in \"params\" argument to do_request\n        return self.list('members', self.members_path, retrieve_all,\n                         **_params)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nfetches information of a certain load balancer member.", "response": "def show_member(self, member, **_params):\n        \"\"\"Fetches information of a certain load balancer member.\"\"\"\n        return self.get(self.member_path % (member), params=_params)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nupdates a load balancer member.", "response": "def update_member(self, member, body=None):\n        \"\"\"Updates a load balancer member.\"\"\"\n        return self.put(self.member_path % (member), body=body)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef list_health_monitors(self, retrieve_all=True, **_params):\n        # Pass filters in \"params\" argument to do_request\n        return self.list('health_monitors', self.health_monitors_path,\n                         retrieve_all, **_params)", "response": "Fetches a list of all load balancer health monitors for a project."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef show_health_monitor(self, health_monitor, **_params):\n        return self.get(self.health_monitor_path % (health_monitor),\n                        params=_params)", "response": "Fetches information of a certain load balancer health monitor."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef update_health_monitor(self, health_monitor, body=None):\n        return self.put(self.health_monitor_path % (health_monitor), body=body)", "response": "Updates a load balancer health monitor."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef associate_health_monitor(self, pool, body):\n        return self.post(self.associate_pool_health_monitors_path % (pool),\n                         body=body)", "response": "Associate specified load balancer health monitor and pool."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef disassociate_health_monitor(self, pool, health_monitor):\n        path = (self.disassociate_pool_health_monitors_path %\n                {'pool': pool, 'health_monitor': health_monitor})\n        return self.delete(path)", "response": "Disassociate specified load balancer health monitor and pool."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nfetching information of a certain queue.", "response": "def show_qos_queue(self, queue, **_params):\n        \"\"\"Fetches information of a certain queue.\"\"\"\n        return self.get(self.qos_queue_path % (queue),\n                        params=_params)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef show_agent(self, agent, **_params):\n        return self.get(self.agent_path % (agent), params=_params)", "response": "Fetches information of a certain agent."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef show_network_gateway(self, gateway_id, **_params):\n        return self.get(self.network_gateway_path % gateway_id, params=_params)", "response": "Fetch a network gateway."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nupdates a network gateway.", "response": "def update_network_gateway(self, gateway_id, body=None):\n        \"\"\"Update a network gateway.\"\"\"\n        return self.put(self.network_gateway_path % gateway_id, body=body)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef connect_network_gateway(self, gateway_id, body=None):\n        base_uri = self.network_gateway_path % gateway_id\n        return self.put(\"%s/connect_network\" % base_uri, body=body)", "response": "Connect a network gateway to the specified network."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndisconnect a network from the specified gateway.", "response": "def disconnect_network_gateway(self, gateway_id, body=None):\n        \"\"\"Disconnect a network from the specified gateway.\"\"\"\n        base_uri = self.network_gateway_path % gateway_id\n        return self.put(\"%s/disconnect_network\" % base_uri, body=body)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef show_gateway_device(self, gateway_device_id, **_params):\n        return self.get(self.gateway_device_path % gateway_device_id,\n                        params=_params)", "response": "Fetch a gateway device."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nupdates a gateway device.", "response": "def update_gateway_device(self, gateway_device_id, body=None):\n        \"\"\"Updates a new gateway device.\"\"\"\n        return self.put(self.gateway_device_path % gateway_device_id,\n                        body=body)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nfetching a list of dhcp agents hosting a network.", "response": "def list_dhcp_agent_hosting_networks(self, network, **_params):\n        \"\"\"Fetches a list of dhcp agents hosting a network.\"\"\"\n        return self.get((self.network_path + self.DHCP_AGENTS) % network,\n                        params=_params)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfetches a list of dhcp agents hosting a network.", "response": "def list_networks_on_dhcp_agent(self, dhcp_agent, **_params):\n        \"\"\"Fetches a list of dhcp agents hosting a network.\"\"\"\n        return self.get((self.agent_path + self.DHCP_NETS) % dhcp_agent,\n                        params=_params)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef add_network_to_dhcp_agent(self, dhcp_agent, body=None):\n        return self.post((self.agent_path + self.DHCP_NETS) % dhcp_agent,\n                         body=body)", "response": "Adds a network to a dhcp agent."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nremoves a network from a dhcp agent.", "response": "def remove_network_from_dhcp_agent(self, dhcp_agent, network_id):\n        \"\"\"Remove a network from dhcp agent.\"\"\"\n        return self.delete((self.agent_path + self.DHCP_NETS + \"/%s\") % (\n            dhcp_agent, network_id))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef list_l3_agent_hosting_routers(self, router, **_params):\n        return self.get((self.router_path + self.L3_AGENTS) % router,\n                        params=_params)", "response": "Fetches a list of L3 agents hosting a router."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nfetching a list of L3 agents hosting a router.", "response": "def list_routers_on_l3_agent(self, l3_agent, **_params):\n        \"\"\"Fetches a list of L3 agents hosting a router.\"\"\"\n        return self.get((self.agent_path + self.L3_ROUTERS) % l3_agent,\n                        params=_params)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add_router_to_l3_agent(self, l3_agent, body):\n        return self.post((self.agent_path + self.L3_ROUTERS) % l3_agent,\n                         body=body)", "response": "Adds a router to an L3 agent."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nfetching a list of Dynamic Routing agents hosting a BGP speaker.", "response": "def list_dragents_hosting_bgp_speaker(self, bgp_speaker, **_params):\n        \"\"\"Fetches a list of Dynamic Routing agents hosting a BGP speaker.\"\"\"\n        return self.get((self.bgp_speaker_path + self.BGP_DRAGENTS)\n                        % bgp_speaker, params=_params)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef add_bgp_speaker_to_dragent(self, bgp_dragent, body):\n        return self.post((self.agent_path + self.BGP_DRINSTANCES)\n                         % bgp_dragent, body=body)", "response": "Adds a BGP speaker to Dynamic Routing agent."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nremoves a BGP speaker from Dynamic Routing agent.", "response": "def remove_bgp_speaker_from_dragent(self, bgp_dragent, bgpspeaker_id):\n        \"\"\"Removes a BGP speaker from Dynamic Routing agent.\"\"\"\n        return self.delete((self.agent_path + self.BGP_DRINSTANCES + \"/%s\")\n                           % (bgp_dragent, bgpspeaker_id))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nfetch a list of BGP speakers hosted by Dynamic Routing agent.", "response": "def list_bgp_speaker_on_dragent(self, bgp_dragent, **_params):\n        \"\"\"Fetches a list of BGP speakers hosted by Dynamic Routing agent.\"\"\"\n        return self.get((self.agent_path + self.BGP_DRINSTANCES)\n                        % bgp_dragent, params=_params)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef list_firewall_rules(self, retrieve_all=True, **_params):\n        # Pass filters in \"params\" argument to do_request\n\n        return self.list('firewall_rules', self.firewall_rules_path,\n                         retrieve_all, **_params)", "response": "Fetches a list of all firewall rules for a project."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef show_firewall_rule(self, firewall_rule, **_params):\n        return self.get(self.firewall_rule_path % (firewall_rule),\n                        params=_params)", "response": "Fetches information of a certain firewall rule."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef update_firewall_rule(self, firewall_rule, body=None):\n        return self.put(self.firewall_rule_path % (firewall_rule), body=body)", "response": "Updates a firewall rule."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef list_firewall_policies(self, retrieve_all=True, **_params):\n        # Pass filters in \"params\" argument to do_request\n\n        return self.list('firewall_policies', self.firewall_policies_path,\n                         retrieve_all, **_params)", "response": "Fetches a list of all firewall policies for a project."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nfetch information of a certain firewall policy.", "response": "def show_firewall_policy(self, firewall_policy, **_params):\n        \"\"\"Fetches information of a certain firewall policy.\"\"\"\n        return self.get(self.firewall_policy_path % (firewall_policy),\n                        params=_params)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nupdating a firewall policy.", "response": "def update_firewall_policy(self, firewall_policy, body=None):\n        \"\"\"Updates a firewall policy.\"\"\"\n        return self.put(self.firewall_policy_path % (firewall_policy),\n                        body=body)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ninserting specified rule into firewall policy.", "response": "def firewall_policy_insert_rule(self, firewall_policy, body=None):\n        \"\"\"Inserts specified rule into firewall policy.\"\"\"\n        return self.put(self.firewall_policy_insert_path % (firewall_policy),\n                        body=body)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nremove specified rule from firewall policy.", "response": "def firewall_policy_remove_rule(self, firewall_policy, body=None):\n        \"\"\"Removes specified rule from firewall policy.\"\"\"\n        return self.put(self.firewall_policy_remove_path % (firewall_policy),\n                        body=body)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef list_firewalls(self, retrieve_all=True, **_params):\n        # Pass filters in \"params\" argument to do_request\n\n        return self.list('firewalls', self.firewalls_path, retrieve_all,\n                         **_params)", "response": "Fetches a list of all firewalls for a project."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef show_firewall(self, firewall, **_params):\n        return self.get(self.firewall_path % (firewall), params=_params)", "response": "Fetches information of a certain firewall."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nremove a router from a l3 agent.", "response": "def remove_router_from_l3_agent(self, l3_agent, router_id):\n        \"\"\"Remove a router from l3 agent.\"\"\"\n        return self.delete((self.agent_path + self.L3_ROUTERS + \"/%s\") % (\n            l3_agent, router_id))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_lbaas_agent_hosting_pool(self, pool, **_params):\n        return self.get((self.pool_path + self.LOADBALANCER_AGENT) % pool,\n                        params=_params)", "response": "Fetches a loadbalancer agent hosting a pool."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef list_pools_on_lbaas_agent(self, lbaas_agent, **_params):\n        return self.get((self.agent_path + self.LOADBALANCER_POOLS) %\n                        lbaas_agent, params=_params)", "response": "Fetches a list of pools hosted by the load balancer agent."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nfetch a loadbalancer agent hosting a loadbalancer.", "response": "def get_lbaas_agent_hosting_loadbalancer(self, loadbalancer, **_params):\n        \"\"\"Fetches a loadbalancer agent hosting a loadbalancer.\"\"\"\n        return self.get((self.lbaas_loadbalancer_path +\n                         self.LOADBALANCER_HOSTING_AGENT) % loadbalancer,\n                        params=_params)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nfetches a list of loadbalancers hosted by the loadbalancer agent.", "response": "def list_loadbalancers_on_lbaas_agent(self, lbaas_agent, **_params):\n        \"\"\"Fetches a list of loadbalancers hosted by the loadbalancer agent.\"\"\"\n        return self.get((self.agent_path + self.AGENT_LOADBALANCERS) %\n                        lbaas_agent, params=_params)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nfetches a list of all metering labels for a project.", "response": "def list_metering_labels(self, retrieve_all=True, **_params):\n        \"\"\"Fetches a list of all metering labels for a project.\"\"\"\n        return self.list('metering_labels', self.metering_labels_path,\n                         retrieve_all, **_params)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef show_metering_label(self, metering_label, **_params):\n        return self.get(self.metering_label_path %\n                        (metering_label), params=_params)", "response": "Fetches information of a certain metering label."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nfetch a list of all metering label rules for a label.", "response": "def list_metering_label_rules(self, retrieve_all=True, **_params):\n        \"\"\"Fetches a list of all metering label rules for a label.\"\"\"\n        return self.list('metering_label_rules',\n                         self.metering_label_rules_path, retrieve_all,\n                         **_params)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nfetches information of a certain metering label rule.", "response": "def show_metering_label_rule(self, metering_label_rule, **_params):\n        \"\"\"Fetches information of a certain metering label rule.\"\"\"\n        return self.get(self.metering_label_rule_path %\n                        (metering_label_rule), params=_params)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nupdating a RBAC policy.", "response": "def update_rbac_policy(self, rbac_policy_id, body=None):\n        \"\"\"Update a RBAC policy.\"\"\"\n        return self.put(self.rbac_policy_path % rbac_policy_id, body=body)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef list_rbac_policies(self, retrieve_all=True, **_params):\n        return self.list('rbac_policies', self.rbac_policies_path,\n                         retrieve_all, **_params)", "response": "Fetch a list of all RBAC policies for a project."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef show_rbac_policy(self, rbac_policy_id, **_params):\n        return self.get(self.rbac_policy_path % rbac_policy_id,\n                        params=_params)", "response": "Fetch information of a certain RBAC policy."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef list_qos_policies(self, retrieve_all=True, **_params):\n        # Pass filters in \"params\" argument to do_request\n        return self.list('policies', self.qos_policies_path,\n                         retrieve_all, **_params)", "response": "Fetches a list of all qos policies for a project."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nfetching information of a certain qos policy.", "response": "def show_qos_policy(self, qos_policy, **_params):\n        \"\"\"Fetches information of a certain qos policy.\"\"\"\n        return self.get(self.qos_policy_path % qos_policy,\n                        params=_params)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nupdates a qos policy.", "response": "def update_qos_policy(self, qos_policy, body=None):\n        \"\"\"Updates a qos policy.\"\"\"\n        return self.put(self.qos_policy_path % qos_policy,\n                        body=body)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef list_qos_rule_types(self, retrieve_all=True, **_params):\n        return self.list('rule_types', self.qos_rule_types_path,\n                         retrieve_all, **_params)", "response": "List available qos rule types."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nfetch a list of all bandwidth limit rules for the given policy.", "response": "def list_bandwidth_limit_rules(self, policy_id,\n                                   retrieve_all=True, **_params):\n        \"\"\"Fetches a list of all bandwidth limit rules for the given policy.\"\"\"\n        return self.list('bandwidth_limit_rules',\n                         self.qos_bandwidth_limit_rules_path % policy_id,\n                         retrieve_all, **_params)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef show_bandwidth_limit_rule(self, rule, policy, body=None):\n        return self.get(self.qos_bandwidth_limit_rule_path %\n                        (policy, rule), body=body)", "response": "Fetches information of a certain bandwidth limit rule."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef create_bandwidth_limit_rule(self, policy, body=None):\n        return self.post(self.qos_bandwidth_limit_rules_path % policy,\n                         body=body)", "response": "Creates a new bandwidth limit rule."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nupdating a bandwidth limit rule.", "response": "def update_bandwidth_limit_rule(self, rule, policy, body=None):\n        \"\"\"Updates a bandwidth limit rule.\"\"\"\n        return self.put(self.qos_bandwidth_limit_rule_path %\n                        (policy, rule), body=body)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef delete_bandwidth_limit_rule(self, rule, policy):\n        return self.delete(self.qos_bandwidth_limit_rule_path %\n                           (policy, rule))", "response": "Deletes a bandwidth limit rule."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nfetch a list of all DSCP marking rules for the given policy.", "response": "def list_dscp_marking_rules(self, policy_id,\n                                retrieve_all=True, **_params):\n        \"\"\"Fetches a list of all DSCP marking rules for the given policy.\"\"\"\n        return self.list('dscp_marking_rules',\n                         self.qos_dscp_marking_rules_path % policy_id,\n                         retrieve_all, **_params)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nshows information of a certain DSCP marking rule.", "response": "def show_dscp_marking_rule(self, rule, policy, body=None):\n        \"\"\"Shows information of a certain DSCP marking rule.\"\"\"\n        return self.get(self.qos_dscp_marking_rule_path %\n                        (policy, rule), body=body)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating a new DSCP marking rule.", "response": "def create_dscp_marking_rule(self, policy, body=None):\n        \"\"\"Creates a new DSCP marking rule.\"\"\"\n        return self.post(self.qos_dscp_marking_rules_path % policy,\n                         body=body)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef update_dscp_marking_rule(self, rule, policy, body=None):\n        return self.put(self.qos_dscp_marking_rule_path %\n                        (policy, rule), body=body)", "response": "Updates a DSCP marking rule."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndeleting a DSCP marking rule.", "response": "def delete_dscp_marking_rule(self, rule, policy):\n        \"\"\"Deletes a DSCP marking rule.\"\"\"\n        return self.delete(self.qos_dscp_marking_rule_path %\n                           (policy, rule))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef list_flavors(self, retrieve_all=True, **_params):\n        return self.list('flavors', self.flavors_path, retrieve_all,\n                         **_params)", "response": "Fetches a list of all Neutron service flavors for a project."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef show_flavor(self, flavor, **_params):\n        return self.get(self.flavor_path % (flavor), params=_params)", "response": "Fetches information for a certain Neutron service flavor."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nupdating a Neutron service flavor.", "response": "def update_flavor(self, flavor, body):\n        \"\"\"Update a Neutron service flavor.\"\"\"\n        return self.put(self.flavor_path % (flavor), body=body)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef associate_flavor(self, flavor, body):\n        return self.post(self.flavor_profile_bindings_path %\n                         (flavor), body=body)", "response": "Associate a Neutron service flavor with a profile."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef disassociate_flavor(self, flavor, flavor_profile):\n        return self.delete(self.flavor_profile_binding_path %\n                           (flavor, flavor_profile))", "response": "Disassociate a Neutron service flavor with a profile."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef list_service_profiles(self, retrieve_all=True, **_params):\n        return self.list('service_profiles', self.service_profiles_path,\n                         retrieve_all, **_params)", "response": "Fetches a list of all Neutron service flavor profiles."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nfetch information for a certain Neutron service flavor profile.", "response": "def show_service_profile(self, flavor_profile, **_params):\n        \"\"\"Fetches information for a certain Neutron service flavor profile.\"\"\"\n        return self.get(self.service_profile_path % (flavor_profile),\n                        params=_params)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef update_service_profile(self, service_profile, body):\n        return self.put(self.service_profile_path % (service_profile),\n                        body=body)", "response": "Update a Neutron service profile."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nfetches a list of all availability zones.", "response": "def list_availability_zones(self, retrieve_all=True, **_params):\n        \"\"\"Fetches a list of all availability zones.\"\"\"\n        return self.list('availability_zones', self.availability_zones_path,\n                         retrieve_all, **_params)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nfetches information about a project s auto - allocated topology.", "response": "def get_auto_allocated_topology(self, project_id, **_params):\n        \"\"\"Fetch information about a project's auto-allocated topology.\"\"\"\n        return self.get(\n            self.auto_allocated_topology_path % project_id,\n            params=_params)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef list_bgp_speakers(self, retrieve_all=True, **_params):\n        return self.list('bgp_speakers', self.bgp_speakers_path, retrieve_all,\n                         **_params)", "response": "Fetches a list of all BGP speakers for a project."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nfetches information of a certain BGP speaker.", "response": "def show_bgp_speaker(self, bgp_speaker_id, **_params):\n        \"\"\"Fetches information of a certain BGP speaker.\"\"\"\n        return self.get(self.bgp_speaker_path % (bgp_speaker_id),\n                        params=_params)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nupdate a BGP speaker.", "response": "def update_bgp_speaker(self, bgp_speaker_id, body=None):\n        \"\"\"Update a BGP speaker.\"\"\"\n        return self.put(self.bgp_speaker_path % bgp_speaker_id, body=body)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds a peer to BGP speaker.", "response": "def add_peer_to_bgp_speaker(self, speaker_id, body=None):\n        \"\"\"Adds a peer to BGP speaker.\"\"\"\n        return self.put((self.bgp_speaker_path % speaker_id) +\n                        \"/add_bgp_peer\", body=body)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef remove_peer_from_bgp_speaker(self, speaker_id, body=None):\n        return self.put((self.bgp_speaker_path % speaker_id) +\n                        \"/remove_bgp_peer\", body=body)", "response": "Removes a peer from BGP speaker."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add_network_to_bgp_speaker(self, speaker_id, body=None):\n        return self.put((self.bgp_speaker_path % speaker_id) +\n                        \"/add_gateway_network\", body=body)", "response": "Adds a network to BGP speaker."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef remove_network_from_bgp_speaker(self, speaker_id, body=None):\n        return self.put((self.bgp_speaker_path % speaker_id) +\n                        \"/remove_gateway_network\", body=body)", "response": "Removes a network from BGP speaker."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef list_route_advertised_from_bgp_speaker(self, speaker_id, **_params):\n        return self.get((self.bgp_speaker_path % speaker_id) +\n                        \"/get_advertised_routes\", params=_params)", "response": "Fetches a list of all routes advertised by BGP speaker."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef show_bgp_peer(self, peer_id, **_params):\n        return self.get(self.bgp_peer_path % peer_id,\n                        params=_params)", "response": "Fetches information of a certain BGP peer."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nupdate a BGP peer.", "response": "def update_bgp_peer(self, bgp_peer_id, body=None):\n        \"\"\"Update a BGP peer.\"\"\"\n        return self.put(self.bgp_peer_path % bgp_peer_id, body=body)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef list_network_ip_availabilities(self, retrieve_all=True, **_params):\n        return self.list('network_ip_availabilities',\n                         self.network_ip_availabilities_path,\n                         retrieve_all, **_params)", "response": "Fetches IP availibility information for all networks."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nfetching IP availability information for a specified network", "response": "def show_network_ip_availability(self, network, **_params):\n        \"\"\"Fetches IP availability information for a specified network\"\"\"\n        return self.get(self.network_ip_availability_path % (network),\n                        params=_params)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add_tag(self, resource_type, resource_id, tag, **_params):\n        return self.put(self.tag_path % (resource_type, resource_id, tag))", "response": "Add a tag on the resource."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef replace_tag(self, resource_type, resource_id, body, **_params):\n        return self.put(self.tags_path % (resource_type, resource_id), body)", "response": "Replace tags on the resource."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nremoves a tag on the resource.", "response": "def remove_tag(self, resource_type, resource_id, tag, **_params):\n        \"\"\"Remove a tag on the resource.\"\"\"\n        return self.delete(self.tag_path % (resource_type, resource_id, tag))"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nremove all tags on the resource.", "response": "def remove_tag_all(self, resource_type, resource_id, **_params):\n        \"\"\"Remove all tags on the resource.\"\"\"\n        return self.delete(self.tags_path % (resource_type, resource_id))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nshortening a URL by chopping out the middle of the URL.", "response": "def shorten_url(url, length=32, strip_www=True, strip_path=True, ellipsis=False):\n    \"\"\"\n    Shorten a URL by chopping out the middle.\n\n    For example if supplied with http://subdomain.example.com.au and length 16\n    the following would be returned.\n\n    sub...le.com.au\n    \"\"\"\n    if '://' not in url:\n        # Ensure we have a protocol\n        url = 'http://%s' % url\n\n    parsed_url = urlparse(url)\n    ext = tldextract.extract(parsed_url.netloc)\n    if ext.subdomain and (not strip_www or (strip_www and ext.subdomain != 'www')):\n        shortened = u'%s.%s' % (ext.subdomain, ext.domain)\n    else:\n        shortened = u'%s' % ext.domain\n\n    if ext.tld:\n        shortened = u'%s.%s' % (shortened, ext.tld)\n\n    if not strip_path:\n        if parsed_url.path:\n            shortened += parsed_url.path\n\n    if len(shortened) <= length:\n        return shortened\n    else:\n        domain = shortened\n        i = length + 1 - 3\n        left = right = int(i/2)\n        if not i % 2:\n            right -= 1\n        if ellipsis:\n            shortened = u\"%s\\u2026%s\" % (domain[:left], domain[-right:])\n        else:\n            shortened = '%s...%s' % (domain[:left], domain[-right:])\n\n        return shortened"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the netloc with any www. striped.", "response": "def netloc_no_www(url):\n    \"\"\"\n    For a given URL return the netloc with any www. striped.\n    \"\"\"\n    ext = tldextract.extract(url)\n    if ext.subdomain and ext.subdomain != 'www':\n        return '%s.%s.%s' % (ext.subdomain, ext.domain, ext.tld) \n    else:\n        return '%s.%s' % (ext.domain, ext.tld)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncall function using a greenlet from the given pool and return the result as a Deferred", "response": "def deferToGreenletPool(*args, **kwargs):\n    \"\"\"Call function using a greenlet from the given pool and return the result as a Deferred\"\"\"\n    reactor = args[0]\n    pool = args[1]\n    func = args[2]\n    d = defer.Deferred()\n\n    def task():\n        try:\n            reactor.callFromGreenlet(d.callback, func(*args[3:], **kwargs))\n        except:\n            reactor.callFromGreenlet(d.errback, failure.Failure())\n    pool.add(spawn(task))\n    return d"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef deferToGreenlet(*args, **kwargs):\n    from twisted.internet import reactor\n    assert reactor.greenlet == getcurrent(), \"must invoke this in the reactor greenlet\"\n    return deferToGreenletPool(reactor, reactor.getGreenletPool(), *args, **kwargs)", "response": "Call function using a greenlet and return the result as a Deferred"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef callMultipleInGreenlet(tupleList):\n    from twisted.internet import reactor\n    assert reactor.greenlet == getcurrent(), \"must invoke this in the reactor greenlet\"\n    reactor.callInGreenlet(_runMultiple, tupleList)", "response": "Call a list of functions in the same thread"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef waitForGreenlet(g):\n    from twisted.internet import reactor\n    assert reactor.greenlet == getcurrent(), \"must invoke this in the reactor greenlet\"\n    d = defer.Deferred()\n\n    def cb(g):\n        try:\n            d.callback(g.get())\n        except:\n            d.errback(failure.Failure())\n\n    g.link(d)\n    return d", "response": "Link greenlet completion to Deferred"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef waitForDeferred(d, result=None):\n    from twisted.internet import reactor\n    assert reactor.greenlet != getcurrent(), \"can't invoke this in the reactor greenlet\"\n    if result is None:\n        result = AsyncResult()\n\n    def cb(res):\n        if isinstance(res, defer.Deferred):\n            waitForDeferred(res, result)\n        else:\n            result.set(res)\n\n    def eb(res):\n        result.set_exception(res)\n\n    d.addCallbacks(cb, eb)\n    try:\n        return result.get()\n    except failure.Failure, ex:\n        ex.raiseException()", "response": "Block current greenlet for Deferred and wait until result is not a Deferred"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncall function in reactor greenlet and block current greenlet waiting for the result", "response": "def blockingCallFromGreenlet(*args, **kwargs):\n    \"\"\"Call function in reactor greenlet and block current greenlet waiting for the result\"\"\"\n    reactor = args[0]\n    assert reactor.greenlet != getcurrent(), \"can't invoke this in the reactor greenlet\"\n    func = args[1]\n    result = AsyncResult()\n\n    def task():\n        try:\n            result.set(func(*args[2:], **kwargs))\n        except Exception, ex:\n            result.set_exception(ex)\n\n    reactor.callFromGreenlet(task)\n    value = result.get()\n    if isinstance(value, defer.Deferred):\n        return waitForDeferred(value)\n    else:\n        return value"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef addReader(self, selectable):\n        try:\n            self._reads[selectable].resume()\n        except KeyError:\n            self._reads[selectable] = g = Stream.spawn(self, selectable, 'doRead')\n            self.addToGreenletPool(g)", "response": "Add a FileDescriptor for notification of data available to read."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding a FileDescriptor for notification of data available to write.", "response": "def addWriter(self, selectable):\n        \"\"\"Add a FileDescriptor for notification of data available to write.\"\"\"\n        try:\n            self._writes[selectable].resume()\n        except KeyError:\n            self._writes[selectable] = g = Stream.spawn(self, selectable, 'doWrite')\n            self.addToGreenletPool(g)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nremove a FileDescriptor for notification of data available to read.", "response": "def removeReader(self, selectable):\n        \"\"\"Remove a FileDescriptor for notification of data available to read.\"\"\"\n        try:\n            if selectable.disconnected:\n                self._reads[selectable].kill(block=False)\n                del self._reads[selectable]\n            else:\n                self._reads[selectable].pause()\n        except KeyError:\n            pass"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef removeWriter(self, selectable):\n        try:\n            if selectable.disconnected:\n                self._writes[selectable].kill(block=False)\n                del self._writes[selectable]\n            else:\n                self._writes[selectable].pause()\n        except KeyError:\n            pass", "response": "Remove a FileDescriptor for notification of data available to write."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nresolving the URL to an actual track from the SoundCloud API.", "response": "def resolve(track_url):\n    \"\"\"\n    Resolves the URL to an actual track from the SoundCloud API.\n\n    If the track resolves to more than one possible track, it takes the first search result.\n\n    :returns: The track dictionary from the SoundCloud API\n    \"\"\"\n    try:\n        path = urlparse.urlparse(track_url).path\n        tracks = client.get('/tracks', q=path)\n\n        if tracks:\n            return tracks[0]\n        else:\n            raise ValueError('Track not found for URL {}'.format(track_url))\n    except Exception as e:\n        raise ValueError('Error obtaining track by url: {}'.format(str(e)))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef filename_for_track(track):\n    artist = track.user['permalink']\n    title = track.title\n\n    return '{}-{}.mp3'.format(artist, title).lower().replace(' ', '_').replace('/', '_')", "response": "Returns a safe filename for the given track"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndownload a file from a URL to a file.", "response": "def download(url, target_file, chunk_size=4096):\n    \"\"\"\n    Simple requests downloader\n    \"\"\"\n    r = requests.get(url, stream=True)\n\n    with open(target_file, 'w+') as out:\n        # And this is why I love Armin Ronacher:\n        with click.progressbar(r.iter_content(chunk_size=chunk_size),\n                               int(r.headers['Content-Length'])/chunk_size,\n                               label='Downloading...') as chunks:\n            for chunk in chunks:\n                out.write(chunk)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds artist and title from the track data and downloads the cover and embeds it in the MP3 tags.", "response": "def add_metadata(track_file, track_data):\n    \"\"\"\n    Adds artist and title from the track data, and downloads the cover and embeds it in the MP3 tags.\n    \"\"\"\n    # This needs some exception handling!\n    # We don't always know what type the cover is!\n    mp3 = mutagen.mp3.MP3(track_file)\n\n    mp3['TPE1'] = mutagen.id3.TPE1(encoding=3, text=track_data.user['username'])\n    mp3['TIT2'] = mutagen.id3.TIT2(encoding=3, text=track_data.title)\n\n    cover_bytes = requests.get(track_data.artwork_url, stream=True).raw.read()\n    mp3.tags.add(mutagen.id3.APIC(encoding=3, mime='image/jpeg', type=3, desc='Front cover', data=cover_bytes))\n\n    mp3.save()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nridging Regression with Gradient Optimization methods", "response": "def linreg_ridge_gd(y, X, lam, algorithm='L-BFGS-B', debug=False):\n    \"\"\"Ridge Regression with Gradient Optimization methods\n\n    Parameters:\n    -----------\n    y : ndarray\n        target variable with N observations\n\n    X : ndarray\n        The <N x C> design matrix with C independent\n        variables, features, factors, etc.\n\n    algorithm : str\n        Optional. The algorithm used in scipy.optimize.minimize\n        and 'L-BFGS-B' (Limited BFGS) as default.\n\n        Eligible algorithms are 'CG', 'BFGS', 'Newton-CG', 'L-BFGS-B',\n        'TNC', and 'SLSQP' as these use the supplied gradient function.\n\n        This is an unconstrained optimization problem. Thus, the 'L-BFGS-B',\n        'TNC' and 'SLSQP' options does not make use of constraints.\n\n        'TNC' (Truncated Newton) seems to be suited to for larger datasets\n        and 'L-BFGS-B' (Limited BFGS) if computing powever becomes an issue.\n\n    debug : bool\n        Optional.\n\n    Returns:\n    --------\n    beta : ndarray\n        Estimated regression coefficients.\n\n    results : scipy.optimize.optimize.OptimizeResult\n        Optional. If debug=True then only scipy's\n        optimization result variable is returned.\n    \"\"\"\n    import numpy as np\n    import scipy.optimize as sopt\n\n    def objective_pssr(theta, y, X, lam):\n        return np.sum((y - np.dot(X, theta))**2) + lam * np.sum(theta**2)\n\n    def gradient_pssr(theta, y, X, lam):\n        return -2.0 * np.dot(X.T, (y - np.dot(X, theta))) + 2.0 * lam * theta\n\n    # check eligible algorithm\n    if algorithm not in ('CG', 'BFGS', 'Newton-CG',\n                         'L-BFGS-B', 'TNC', 'SLSQP'):\n        raise Exception('Optimization Algorithm not supported.')\n\n    # set start values\n    theta0 = np.ones((X.shape[1],))\n\n    # run solver\n    results = sopt.minimize(\n        objective_pssr,\n        theta0,\n        jac=gradient_pssr,\n        args=(y, X, lam),\n        method=algorithm,\n        options={'disp': False})\n\n    # debug?\n    if debug:\n        return results\n\n    # done\n    return results.x"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngives an image and a tile size triangulizes it into a single node.", "response": "def triangulize(image, tile_size):\n    \"\"\"Processes the given image by breaking it down into tiles of the given\n    size and applying a triangular effect to each tile. Returns the processed\n    image as a PIL Image object.\n\n    The image can be given as anything suitable for passing to `Image.open`\n    (ie, the path to an image or as a file-like object containing image data).\n\n    If tile_size is 0, the tile size will be guessed based on the image\n    size. It will also be adjusted to be divisible by 2 if it is not already.\n    \"\"\"\n    if isinstance(image, basestring) or hasattr(image, 'read'):\n        image = Image.open(image)\n    assert isinstance(tile_size, int)\n\n    # Make sure we have a usable tile size, by guessing based on image size\n    # and making sure it's a multiple of two.\n    if tile_size == 0:\n        tile_size = guess_tile_size(image)\n    if tile_size % 2 != 0:\n        tile_size = (tile_size / 2) * 2\n\n    logging.info('Input image size: %r', image.size)\n    logging.info('Tile size: %r', tile_size)\n\n    # Preprocess image to make sure it's at a size we can handle\n    image = prep_image(image, tile_size)\n    logging.info('Prepped image size: %r', image.size)\n\n    # Get pixmap (for direct pixel access) and draw objects for the image.\n    pix = image.load()\n    draw = ImageDraw.Draw(image)\n\n    # Process the image, tile by tile\n    for x, y in iter_tiles(image, tile_size):\n        process_tile(x, y, tile_size, pix, draw, image)\n    return image"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef process_tile(tile_x, tile_y, tile_size, pix, draw, image):\n    logging.debug('Processing tile (%d, %d)', tile_x, tile_y)\n\n    # Calculate average color for each \"triangle\" in the given tile\n    n, e, s, w = triangle_colors(tile_x, tile_y, tile_size, pix)\n\n    # Calculate distance between triangle pairs\n    d_ne = get_color_dist(n, e)\n    d_nw = get_color_dist(n, w)\n    d_se = get_color_dist(s, e)\n    d_sw = get_color_dist(s, w)\n\n    # Figure out which pair is the closest, which will determine the direction\n    # we'll split this tile into triangles. A 'right' split runs from top left\n    # to bottom right. A 'left' split runs bottom left to top right.\n    closest = sorted([d_ne, d_nw, d_se, d_sw])[0]\n    if closest in (d_ne, d_sw):\n        split = 'right'\n    elif closest in (d_nw, d_se):\n        split = 'left'\n\n    # Figure out the average color for each side of the \"split\"\n    if split == 'right':\n        top_color = get_average_color([n, e])\n        bottom_color = get_average_color([s, w])\n    else:\n        top_color = get_average_color([n, w])\n        bottom_color = get_average_color([s, e])\n\n    draw_triangles(tile_x, tile_y, tile_size, split, top_color, bottom_color,\n                   draw)", "response": "Process a tile and draw the triangles."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nextracting the average color for each triangle in the given tile.", "response": "def triangle_colors(tile_x, tile_y, tile_size, pix):\n    \"\"\"Extracts the average color for each triangle in the given tile. Returns\n    a 4-tuple of colors for the triangles in this order: North, East, South,\n    West (clockwise).\n    \"\"\"\n    quad_size = tile_size / 2\n\n    north = []\n    for y in xrange(tile_y, tile_y + quad_size):\n        x_off = y - tile_y\n        for x in xrange(tile_x + x_off, tile_x + tile_size - x_off):\n            north.append(pix[x, y])\n\n    south = []\n    for y in xrange(tile_y + quad_size, tile_y + tile_size):\n        x_off = tile_y + tile_size - y\n        for x in xrange(tile_x + x_off, tile_x + tile_size - x_off):\n            south.append(pix[x, y])\n\n    east = []\n    for x in xrange(tile_x, tile_x + quad_size):\n        y_off = x - tile_x\n        for y in xrange(tile_y + y_off, tile_y + tile_size - y_off):\n            east.append(pix[x, y])\n\n    west = []\n    for x in xrange(tile_x + quad_size, tile_x + tile_size):\n        y_off = tile_x + tile_size - x\n        for y in xrange(tile_y + y_off, tile_y + tile_size - y_off):\n            west.append(pix[x, y])\n\n    return map(get_average_color, [north, east, south, west])"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef draw_triangles(tile_x, tile_y, tile_size, split, top_color, bottom_color,\n                   draw):\n    \"\"\"Draws a triangle on each half of the tile with the given coordinates\n    and size.\n    \"\"\"\n    assert split in ('right', 'left')\n\n    # The four corners of this tile\n    nw = (tile_x, tile_y)\n    ne = (tile_x + tile_size - 1, tile_y)\n    se = (tile_x + tile_size - 1, tile_y + tile_size)\n    sw = (tile_x, tile_y + tile_size)\n\n    if split == 'left':\n        # top right triangle\n        draw_triangle(nw, ne, se, top_color, draw)\n        # bottom left triangle\n        draw_triangle(nw, sw, se, bottom_color, draw)\n    else:\n        # top left triangle\n        draw_triangle(sw, nw, ne, top_color, draw)\n        # bottom right triangle\n        draw_triangle(sw, se, ne, bottom_color, draw)", "response": "Draws a triangle on each half of the tile with the given coordinates tile_x tile_y and tile_size and size."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndrawing a triangle with the given vertices in the given color.", "response": "def draw_triangle(a, b, c, color, draw):\n    \"\"\"Draws a triangle with the given vertices in the given color.\"\"\"\n    draw.polygon([a, b, c], fill=color)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncalculating the average color from the list of colors.", "response": "def get_average_color(colors):\n    \"\"\"Calculate the average color from the list of colors, where each color\n    is a 3-tuple of (r, g, b) values.\n    \"\"\"\n    c = reduce(color_reducer, colors)\n    total = len(colors)\n    return tuple(v / total for v in c)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ncalculates the distance between two colors where the distance is the absolute value of the difference between each component of the two colors.", "response": "def get_color_dist(c1, c2):\n    \"\"\"Calculates the \"distance\" between two colors, where the distance is\n    another color whose components are the absolute values of the difference\n    between each component of the input colors.\n    \"\"\"\n    return tuple(abs(v1 - v2) for v1, v2 in itertools.izip(c1, c2))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef prep_image(image, tile_size):\n    w, h = image.size\n    x_tiles = w / tile_size  # floor division\n    y_tiles = h / tile_size\n    new_w = x_tiles * tile_size\n    new_h = y_tiles * tile_size\n    if new_w == w and new_h == h:\n        return image\n    else:\n        crop_bounds = (0, 0, new_w, new_h)\n        return image.crop(crop_bounds)", "response": "Takes an image and a tile size and returns a possibly cropped version\n    of the image that is evenly divisible in both dimensions by the tile size."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nyielding x y coordinates pairs for each tile in the given image.", "response": "def iter_tiles(image, tile_size):\n    \"\"\"Yields (x, y) coordinate pairs for the top left corner of each tile in\n    the given image, based on the given tile size.\n    \"\"\"\n    w, h = image.size\n    for y in xrange(0, h, tile_size):\n        for x in xrange(0, w, tile_size):\n            yield x, y"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nchecks if the request should be permitted for a given parent object. Raises an appropriate exception if the request is not permitted.", "response": "def check_parent_object_permissions(self, request, obj):\n        \"\"\"\n        Check if the request should be permitted for a given parent object.\n        Raises an appropriate exception if the request is not permitted.\n        \"\"\"\n        for permission in self.get_parent_permissions():\n            if not permission.has_object_permission(request, self, obj):\n                self.permission_denied(request)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting the list of parent items for this view.", "response": "def get_parent_queryset(self):\n        \"\"\"\n        Get the list of parent items for this view.\n        This must be an iterable, and may be a queryset.\n        Defaults to using `self.parent_queryset`.\n        You may want to override this if you need to provide different\n        querysets depending on the incoming request.\n        (Eg. return a list of items that is specific to the user)\n        \"\"\"\n        if self.parent_queryset is not None:\n            return self.parent_queryset._clone()\n\n        if self.parent_model is not None:\n            return self.parent_model._default_manager.all()\n\n        raise ImproperlyConfigured(\n            \"'%s' must define 'parent_queryset' or \"\n            \"'parent_model'\" % self.__class__.__name__\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn the parent object of the view is displaying.", "response": "def get_parent_object(self, parent_queryset=None):\n        \"\"\"\n        Returns the parent object the view is displaying.\n        You may want to override this if you need to provide non-standard\n        queryset lookups.  Eg if parent objects are referenced using multiple\n        keyword arguments in the url conf.\n        \"\"\"\n        if self._parent_object_cache is not None:\n            return self._parent_object_cache\n\n        if parent_queryset is None:\n            parent_queryset = self.get_parent_queryset()\n\n        if self.parent_model is None:\n            raise ImproperlyConfigured(\n                \"'%s' must define 'parent_model'\" % self.__class__.__name__\n            )\n\n        if self.parent_lookup_field is None:\n            raise ImproperlyConfigured(\n                \"'%s' must define 'parent_lookup_field'\" % self.__class__.__name__  # noqa\n            )\n\n        lookup_url_kwarg = '_'.join([\n            self.parent_model_name or self.parent_model._meta.model_name,\n            self.parent_lookup_field\n        ])\n\n        lookup = self.kwargs.get(lookup_url_kwarg, None)\n\n        if lookup is not None:\n            filter_kwargs = {self.parent_lookup_field: lookup}\n\n        else:\n            raise ImproperlyConfigured(\n                'Expected view %s to be called with a URL keyword argument '\n                'named \"%s\". Fix your URL conf, or set the '\n                '`parent_lookup_field` attribute on the view correctly.' %\n                (self.__class__.__name__, lookup_url_kwarg)\n            )\n\n        obj = get_object_or_404(parent_queryset, **filter_kwargs)\n\n        self.check_parent_object_permissions(self.request, obj)\n        self._parent_object_cache = obj\n\n        return obj"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add_subcommands(self, command, *args, **kwargs):\n        subcommands = kwargs.pop('subcommands', None)\n        try:\n            cmd = self[command]\n        except KeyError:\n            if 'formatter_class' not in kwargs:\n                kwargs['formatter_class'] = self.formatter_class\n\n            cmd = self.add_parser(command, *args, **kwargs)\n            args, kwargs = tuple(), dict()\n\n        if subcommands is not None:\n            kwargs = subcommands\n\n        child = CommandDecorator(\n            argparser = self.argparser,\n            commands  = cmd.add_subparsers(*args, **kwargs),\n            parent = self,\n            name   = command,\n            )\n        self.children.append(child)\n\n        return child", "response": "add subcommands.\n\n        If command already defined, pass args and kwargs to add_subparsers()\n        method, else to add_parser() method.  This behaviour is for convenience,\n        because I mostly use the sequence:\n\n        >>> p = parser.add_parser('foo', help=\"some help\")\n        >>> subparser = p.add_subparsers()\n\n        If you want to configure your sub_parsers, you can do it with:\n\n        >>> command.add_subcommands('cmd',\n                help = \"cmd help\"\n                subcommands = dict(\n                    title = \"title\"\n                    description = \"subcommands description\"\n                )\n            )"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nupdates data which is usually passed in ArgumentParser initialization e. g. command. update", "response": "def update(self, command=None, **kwargs):\n        \"\"\"update data, which is usually passed in ArgumentParser initialization\n\n        e.g. command.update(prog=\"foo\")\n        \"\"\"\n        if command is None:\n            argparser = self.argparser\n        else:\n            argparser = self[command]\n\n        for k,v in kwargs.items():\n            setattr(argparser, k, v)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget the name for configuration", "response": "def get_config_name(self, action, name=None):\n        '''get the name for configuration\n\n        This returns a name respecting commands and subcommands.  So if you\n        have a command name \"index\" with subcommand \"ls\", which has option\n        \"--all\", you will pass the action for subcommand \"ls\"  and the options's\n        dest name (\"all\" in this case), then this function will return\n        \"index.ls.all\" as configuration name for this option.\n        '''\n\n        _name = None\n\n        if name is None:\n            if '.' in action:\n                action, name = action.rsplit('.', 1)\n            else:\n                _name = ''\n                name = action\n\n        if _name is None:\n            if isinstance(action, basestring):\n                action = self.get_action(action)\n            _name = action.argdeco_name\n\n        logger.debug(\"_name=%s\", _name)\n\n        config_name = Undefined\n        while True:\n            logger.debug(\"check _name=%s, name=%s\", repr(_name), repr(name))\n\n            if _name in self.config_map:\n                if name in self.config_map[_name]:\n                    config_name = self.config_map[_name][name]\n                    if config_name is not None:\n                        if config_name.startswith('.'):\n                            config_name = _name + config_name\n                    break\n\n            if _name == '':\n                break\n\n            if '.' not in _name:\n                _name = ''\n                continue\n\n            _name = _name.rsplit('.', 1)[0]\n\n        assert config_name is not Undefined, \"could not determine config name for %s\" % name\n        return config_name"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add_command(self, command, *args, **kwargs):\n        cmd = self.add_parser(command, *args, **kwargs)", "response": "add a command.\n        This is basically a wrapper for add_parser"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef execute(self, argv=None, compile=None, preprocessor=None, compiler_factory=None):\n\n        action, args, kwargs = self.compile_args(argv=argv, compile=compile, preprocessor=preprocessor, compiler_factory=compiler_factory)\n        return action(*args, **kwargs)", "response": "Parse arguments and execute decorated function\nTaxonomy"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nsend the request to the API.", "response": "def _request(self, typ, id=0, method='GET', params=None, data=None, url=None):\n        \"\"\"\n        send the request, return response obj\n        \"\"\"\n\n        headers = { \"Accept\": \"application/json\" }\n        auth = None\n\n        if self.user:\n            auth = (self.user, self.password)\n\n        if not url:\n            if id:\n                url = \"%s/%s/%s\" % (self.url, typ, id)\n            else:\n                url = \"%s/%s\" % (self.url, typ)\n\n        return requests.request(method, url, params=params, data=data, auth=auth, headers=headers)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef all(self, typ, **kwargs):\n        return self._load(self._request(typ, params=kwargs))", "response": "Get all of the records of a specific type"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create(self, typ, data, return_response=False):\n        res = self._request(typ, method='POST', data=data)\n        if res.status_code != 201:\n            try:\n                data = res.json()\n                self._throw(res, data)\n            except ValueError as e:\n                if not isinstance(e, InvalidRequestException):\n                    self._throw(res, {})\n                else:\n                    raise\n\n        loc = res.headers.get(\"location\", None)\n        if loc and loc.startswith('/'):\n            return self._load(self._request(None, url=self.url_update(path=loc)))\n        if return_response:\n            return res.json()\n\n        return self._load(self._request(None, url=loc))", "response": "Create new type of record"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef update(self, typ, id, **kwargs):\n        return self._load(self._request(typ, id=id, method='PUT', data=kwargs))", "response": "update just fields sent by keyword args\n       "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef save(self, typ, data):\n        if 'id' in data:\n            return self._load(self._request(typ, id=data['id'], method='PUT', data=data))\n\n        return self.create(typ, data)", "response": "Save the dataset pointed to by data"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef rm(self, typ, id):\n        return self._load(self._request(typ, id=id, method='DELETE'))", "response": "remove typ by id\n       "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _merge_fields(a, b):\n\n    a_names = set(x[0] for x in a)\n    b_names = set(x[0] for x in b)\n    a_keep = a_names - b_names\n\n    fields = []\n\n    for name, field in a:\n        if name in a_keep:\n            fields.append((name, field))\n\n    fields.extend(b)\n\n    return fields", "response": "Merge two lists of fields."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef getInstance(cls, *args):\n        '''\n        Returns a singleton instance of the class\n        '''\n        if not cls.__singleton:\n            cls.__singleton = Config(*args)\n        return cls.__singleton", "response": "Returns a singleton instance of the class\n           "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nregistering a new setting in the registry.", "response": "def register_setting(name=None, label=None, editable=False, description=None,\n                     default=None, choices=None, append=False,\n                     translatable=False):\n    \"\"\"\n    Registers a setting that can be edited via the admin. This mostly\n    equates to storing the given args as a dict in the ``registry``\n    dict by name.\n    \"\"\"\n    if name is None:\n        raise TypeError(\"yacms.conf.register_setting requires the \"\n                        \"'name' keyword argument.\")\n    if editable and default is None:\n        raise TypeError(\"yacms.conf.register_setting requires the \"\n                        \"'default' keyword argument when 'editable' is True.\")\n\n    # append is True when called from an app (typically external)\n    # after the setting has already been registered, with the\n    # intention of appending to its default value.\n    if append and name in registry:\n        registry[name][\"default\"] += default\n        return\n\n    # If an editable setting has a value defined in the\n    # project's settings.py module, it can't be editable, since\n    # these lead to a lot of confusion once its value gets\n    # defined in the db.\n    if hasattr(django_settings, name):\n        editable = False\n    if label is None:\n        label = name.replace(\"_\", \" \").title()\n\n    # Python 2/3 compatibility. isinstance() is overridden by future\n    # on Python 2 to behave as Python 3 in conjunction with either\n    # Python 2's native types or the future.builtins types.\n    if isinstance(default, bool):\n        # Prevent bools treated as ints\n        setting_type = bool\n    elif isinstance(default, int):\n        # An int or long or subclass on Py2\n        setting_type = int\n    elif isinstance(default, (str, Promise)):\n        # A unicode or subclass on Py2\n        setting_type = str\n    elif isinstance(default, bytes):\n        # A byte-string or subclass on Py2\n        setting_type = bytes\n    else:\n        setting_type = type(default)\n    registry[name] = {\"name\": name, \"label\": label, \"editable\": editable,\n                      \"description\": description, \"default\": default,\n                      \"choices\": choices, \"type\": setting_type,\n                      \"translatable\": translatable}"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _get_editable(self, request):\n        try:\n            editable_settings = self._editable_caches[request]\n        except KeyError:\n            editable_settings = self._editable_caches[request] = self._load()\n        return editable_settings", "response": "Get the dictionary of editable settings for a given request."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nconvert a value stored in the database for a particular setting to its correct type.", "response": "def _to_python(cls, setting, raw_value):\n        \"\"\"\n        Convert a value stored in the database for a particular setting\n        to its correct type, as determined by ``register_setting()``.\n        \"\"\"\n\n        type_fn = cls.TYPE_FUNCTIONS.get(setting[\"type\"], setting[\"type\"])\n\n        try:\n            value = type_fn(raw_value)\n        except ValueError:\n            # Shouldn't occur, but just a safeguard in case\n            # the db value somehow ended up as an invalid type.\n            warn(\"The setting %s should be of type %s, but the value \"\n                 \"retrieved from the database (%s) could not be converted. \"\n                 \"Using the default instead: %s\"\n                 % (setting[\"name\"], setting[\"type\"].__name__,\n                    repr(raw_value), repr(setting[\"default\"])))\n            value = setting[\"default\"]\n\n        return value"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _load(self):\n        from yacms.conf.models import Setting\n\n        removed_settings = []\n        conflicting_settings = []\n        new_cache = {}\n\n        for setting_obj in Setting.objects.all():\n\n            # Check that the Setting object corresponds to a setting that has\n            # been declared in code using ``register_setting()``. If not, add\n            # it to a list of items to be deleted from the database later.\n            try:\n                setting = registry[setting_obj.name]\n            except KeyError:\n                removed_settings.append(setting_obj.name)\n                continue\n\n            # Convert a string from the database to the correct Python type.\n            setting_value = self._to_python(setting, setting_obj.value)\n\n            # If a setting is defined both in the database and in settings.py,\n            # raise a warning and use the value defined in settings.py.\n            if hasattr(django_settings, setting[\"name\"]):\n                if setting_value != setting[\"default\"]:\n                    conflicting_settings.append(setting_obj.name)\n                    continue\n\n            # If nothing went wrong, use the value from the database!\n            new_cache[setting[\"name\"]] = setting_value\n\n        if removed_settings:\n            Setting.objects.filter(name__in=removed_settings).delete()\n\n        if conflicting_settings:\n            warn(\"These settings are defined in both settings.py and \"\n                 \"the database: %s. The settings.py values will be used.\"\n                 % \", \".join(conflicting_settings))\n\n        return new_cache", "response": "Load editable settings from the database and return them as a dict."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef untar(tarpath, outfolder, owners=None, overwrite=True, fixperms=True):\n\n    # We don't use fixperms at all\n    _ignored = fixperms  # noqa\n\n    # make a folder to untar to\n    with tmpdir():\n        _, _, ext = tarpath.rpartition('.')\n\n        if ext not in ('gz', 'bz2', 'xz'):\n            raise ValueError('tarpath must point to a .gz, .bz2, or .xz file')\n\n        tf = tarfile.open(tarpath, 'r:' + ext)\n        try:\n            os.mkdir('contents')\n            tf.extractall('contents')\n        finally:\n            tf.close()\n\n        if owners is not None:\n            contents = path.Path('contents')\n            for item in contents.walk():\n                if item.isdir():\n                    # chown user:group\n                    item.chown(*owners)\n                    # chmod ug+xr\n                    item.chmod('ug+xr')\n                if item.isfile() and not item.islink():\n                    # chown user:group\n                    item.chown(*owners)\n                    # chmod ug+rw\n                    item.chmod('ug+rw')\n\n        if os.path.isdir(outfolder):\n            if overwrite:\n                shutil.rmtree(outfolder)\n            else:\n                raise IOError(\n                    ('Cannot untar %s because %s already exists and '\n                     'overwrite=False') % (tarfile, outfolder))\n        shutil.move('contents', outfolder)", "response": "Unpack tarpath to outfolder."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef ensure_file(url, path, md5sum=None):\n\n    if not os.path.isfile(path) or (md5sum and md5sum != file_md5(path)):\n        download_file(url, path)", "response": "Ensure file is already at path."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_template(name):\n    path = pkg_resources.resource_filename('vr.runners', 'templates/' + name)\n    with open(path, 'r') as f:\n        return f.read()", "response": "Get the contents of a named template in the vr. runners. templates folder."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef write_proc_sh(self):\n        print(\"Writing proc.sh\")\n        context = {\n            'tmp': '/tmp',\n            'home': '/app',\n            'settings': '/settings.yaml',\n            'envsh': '/env.sh',\n            'port': self.config.port,\n            'cmd': self.get_cmd(),\n        }\n        sh_path = os.path.join(get_container_path(self.config), 'proc.sh')\n        rendered = get_template('proc.sh') % context\n        with open(sh_path, 'w') as f:\n            f.write(rendered)\n        st = os.stat(sh_path)\n        os.chmod(\n            sh_path, st.st_mode | stat.S_IXUSR | stat.S_IXGRP | stat.S_IXOTH)", "response": "Write the proc. sh file that is the first thing called inside the the\n            container."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreads the Procfile inside the build code and pull out the command for self. config. proc_name.", "response": "def get_cmd(self):\n        \"\"\"\n        If self.config.cmd is not None, return that.\n\n        Otherwise, read the Procfile inside the build code, parse it\n        (as yaml), and pull out the command for self.config.proc_name.\n        \"\"\"\n        if self.config.cmd is not None:\n            return self.config.cmd\n\n        procfile_path = os.path.join(get_app_path(self.config), 'Procfile')\n        with open(procfile_path, 'r') as f:\n            procs = yaml.safe_load(f)\n        return procs[self.config.proc_name]"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nmakes sure container exists. It s only needed on newer LXC versions of LXC.", "response": "def ensure_container(self, name=None):\n        \"\"\"Make sure container exists. It's only needed on newer\n        versions of LXC.\"\"\"\n        if get_lxc_version() < pkg_resources.parse_version('2.0.0'):\n            # Nothing to do for old versions of LXC\n            return\n\n        if name is None:\n            name = self.container_name\n\n        args = [\n            'lxc-create',\n            '--name', name,\n            '--template', 'none',\n            '>', '/dev/null', '2>&1',\n        ]\n        os.system(' '.join(args))"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nensures that the build file is downloaded to the build folder.", "response": "def ensure_build(self):\n        \"\"\"\n        If self.config.build_url is set, ensure it's been downloaded to the\n        builds folder.\n        \"\"\"\n        if self.config.build_url:\n            path = get_buildfile_path(self.config)\n\n            # Ensure that builds_root has been created.\n            mkdir(BUILDS_ROOT)\n            build_md5 = getattr(self.config, 'build_md5', None)\n            ensure_file(self.config.build_url, path, build_md5)\n\n            # Now untar.\n            self.untar()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef teardown(self):\n        proc_path = get_proc_path(self.config)\n        if os.path.isdir(proc_path):\n            shutil.rmtree(proc_path)", "response": "Delete the proc path where everything has been put."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nresolves contextual value. :param value: Contextual value. :return: If value is a function with a single parameter, which is a read-only dictionary, the return value of the function called with context properties as its parameter. If not, the value itself.", "response": "def resolve(self, value):\n\t\n\t\t\"\"\"\n\t\tResolve contextual value.\n\n\t\t:param value:\n\t\t   Contextual value.\n\t\t:return:\n\t\t   If value is a function with a single parameter, which is a read-only\n\t\t   dictionary, the return value of the function called with context\n\t\t   properties as its parameter. If not, the value itself.\n\t\t\"\"\"\n\t\t\n\t\tif isinstance(value, collections.Callable):\n\t\t\treturn value({\n\t\t\t\t\"base_dir\": self.__base_dir,\n\t\t\t\t\"profile_dir\": self.__prof_dir,\n\t\t\t\t\"profile_name\": self.__prof_name\n\t\t\t})\n\t\treturn value"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting a list of hub names. Returns ------- hubs list", "response": "def get_hubs(self):\n        \"\"\"Get a list of hubs names.\n        \n        Returns\n        -------\n        hubs : list\n            List of hub names\n        \"\"\"\n        # Use helm to get a list of hubs.\n        output = helm(\n            'list',\n            '-q'\n        )\n        # Check if an error occurred.\n        if output.returncode != 0:\n            print(\"Something went wrong!\")\n            print(output.stderr)\n        else:\n            hubs = output.stdout.split()\n            return hubs"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get(self, name=None):\n        # Print a list of hubs.\n        if name is None:\n            hubs = self.get_hubs()\n            print(\"Running Jupyterhub Deployments (by name):\")\n            for hub_name in hubs:\n                hub = Hub(namespace=hub_name)\n                data = hub.get_description()\n                url = data['LoadBalancer Ingress']\n                print(f'  - Name: {hub_name}')\n                print(f'    Url: {url}')\n        else:\n            hub = Hub(namespace=name)\n            hub.get()", "response": "Print a list of all jupyterHubs."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef main(args, prog_name):\n  # get options and arguments\n  ui = getUI(args, prog_name)\n\n  if ui.optionIsSet(\"test\"):\n    # just run unit tests\n    unittest.main(argv=[sys.argv[0]])\n  elif ui.optionIsSet(\"help\"):\n    # just show help\n    ui.usage()\n  else:\n    verbose = (ui.optionIsSet(\"verbose\") is True) or DEFAULT_VERBOSITY\n\n    # how to handle strand, names, and whether to collapse only regions with\n    # exactly matching genomic loci?\n    stranded = ui.optionIsSet(\"stranded\")\n    names = ui.optionIsSet(\"accumulate_names\")\n    exact = ui.optionIsSet(\"exact\")\n\n    # get output handle\n    out_fh = sys.stdout\n    if ui.optionIsSet(\"output\"):\n      out_fh = open(ui.getValue(\"output\"), \"w\")\n\n    # get input file-handle\n    in_fh = sys.stdin\n    if ui.hasArgument(0):\n      in_fh = open(ui.getArgument(0))\n\n    # load data -- TODO at the moment we load everying; need to think about\n    # whether it is possible to do this using a single pass of the data, but not\n    # loading it all first.\n    regions = [x for x in BEDIterator(in_fh, verbose)]\n\n    if exact:\n      collapse_exact(regions, stranded, names, out_fh)\n    else:\n      for x in collapseRegions(regions, stranded, names, verbose):\n        out_fh.write(str(x) + \"\\n\")", "response": "main entry point for the script."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _pull_all(command):\n\tpage = requests.get(BASE_URL,verify=False)\n\tsoup = BeautifulSoup(page.text,\"lxml\")\n\ttable = soup.find('table',{'class':'list'})\n\trows = table.findAll(\"tr\")\n\trows = rows[1:-1]\n\tl = []\n\tname_max = 0\n\n\tfor row in rows:\n\t\telements = row.findAll('td')\n\t\tdate = elements[0].string\n\t\tname = elements[1].string\n\t\tn = _ascii_checker(name)\n\t\tversion = n.split(' ')[1]\n\t\tname = n.split(' ')[0]\n\t\tif name_max < len(name):\n\t\t\tname_max = len(name)\n\t\tlink = elements[1].find('a')['href']\n\t\tlink = urlparse.urljoin(BASE_URL,link)\n\t\tdesc = elements[2].string\n\t\tli = (name,desc,link,date,version)\n\t\tl.append(li)\n\n\tprint u\"\\n\\033[1m\\033[1m\\033[4m PACKAGES \\033[0m\\n\"\n\tif command == 'ls':\n\t\tfor li in l:\n\t\t\tprint u\"\\033[1m \\u25E6 %s \\033[0m   \\033[93m%s \\033[0m\"%(li[0],li[4])\n\tif command == 'list':\n\t\tfor li in l:\n\t\t\tname = li[0] + \"\".join(\" \" for i in range(name_max-len(li[0])))\n\t\t\tdesc = li[1]\n\t\t\tif len(li[1]) > 56:\n\t\t\t\tdesc = desc[:56] + \" ..\"\n\t\t\tprint u\"\\033[1m \\u25D8  %s \\033[0m   \\033[93m%s \\033[0m\"%(name,desc)", "response": "Get all the info from the table content"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nprint information about a particular package version.", "response": "def _release_info(jsn,VERSION):\n\t\"\"\"Gives information about a particular package version.\"\"\"\n\ttry:\n\t\trelease_point = jsn['releases'][VERSION][0]\n\texcept KeyError:\n\t\tprint \"\\033[91m\\033[1mError: Release not found.\"\n\t\texit(1)\n\tpython_version = release_point['python_version']\n\tfilename = release_point['filename']\n\tmd5 = release_point['md5_digest']\n\tdownload_url_for_release = release_point['url']\n\tdownload_num_for_release = release_point['downloads']\n\tdownload_size_for_release = _sizeof_fmt(int(release_point['size']))\n\tprint \"\"\"\n\t\\033[1m\\033[1m        \\033[4mPACKAGE VERSION INFO\\033[0m\n\n\t\\033[1m\tmd5                  :\\033[0m   \\033[93m%s  \\033[0m\n\t\\033[1m\tpython version       :\\033[0m   \\033[93m%s  \\033[0m\t\n\t\\033[1m\tdownload url         :\\033[0m   \\033[93m%s  \\033[0m\t\n\t\\033[1m\tdownload number      :\\033[0m   \\033[93m%s  \\033[0m\n\t\\033[1m\tsize                 :\\033[0m   \\033[93m%s  \\033[0m\t\n\t\\033[1m\tfilename             :\\033[0m   \\033[93m%s  \\033[0m\t\n\t\"\"\"%(md5,python_version,download_url_for_release,\\\n\t     download_num_for_release,download_size_for_release,filename)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nconstructs the information part from the API.", "response": "def _construct(PACKAGE,VERSION):\n\t\"\"\"Construct the information part from the API.\"\"\"\n\tjsn  = _get_info(PACKAGE)\n\tpackage_url = jsn['info']['package_url']\n\tauthor = jsn['info']['author']\n\tauthor_email = jsn['info']['author_email']\n\tdescription = jsn['info']['description'] \n\tlast_month = jsn['info']['downloads']['last_month']\n\tlast_week = jsn['info']['downloads']['last_week']\n\tlast_day = jsn['info']['downloads']['last_day']\n\tclassifiers = jsn['info']['classifiers']\n\tlicense = jsn['info']['license']\n\tsummary = jsn['info']['summary']\n\thome_page = jsn['info']['home_page']\n\treleases = reversed(jsn['releases'].keys())\n\treleases = ' | '.join(releases)[:56]\n\tdownload_url = jsn['urls'][0]['url']\n\tfilename = jsn['urls'][0]['filename']\n\tsize = _sizeof_fmt(int(jsn['urls'][0]['size']))\n\t\n\tif VERSION:\n\n\t\ttry:\n\t\t\t_release_info(jsn,VERSION)\n\t\texcept IndexError:\n\t\t\tprint \"\\033[91m\\033[1mError: Try the Command:\\n\\033[1m\\033[0m\\033[1m$ cheesy <PACKAGE> <VERSION>\"\n\t\treturn None\n\n\tprint \"\"\"\n\t\\n\\033[1m\\033[4mDESCRIPTION\\n\\n\\033[0m\\033[93m%s  \\033[0m\n\t\n\t\\033[1m\\033[1m        \\033[4mPACKAGE INFO\\033[0m\n\t\\n\n\t\\033[1m\tpackage url          :\\033[0m   \\033[93m%s  \\033[0m\n\t\\033[1m\tauthor name          :\\033[0m   \\033[93m%s  \\033[0m\n\t\\033[1m\tauthor email         :\\033[0m   \\033[93m%s  \\033[0m\n\t\\033[1m\tdownloads last month :\\033[0m   \\033[93m%s  \\033[0m\n\t\\033[1m\tdownloads last week  :\\033[0m   \\033[93m%s  \\033[0m\n\t\\033[1m\tdownloads last day   :\\033[0m   \\033[93m%s  \\033[0m\n\t\\033[1m\thomepage             :\\033[0m   \\033[93m%s  \\033[0m\n\t\\033[1m\treleases             :\\033[0m   \\033[93m%s  \\033[0m\t\n\t\\033[1m\tdownload url         :\\033[0m   \\033[93m%s  \\033[0m\t\n\t\\033[1m\tfilename             :\\033[0m   \\033[93m%s  \\033[0m\t\n\t\\033[1m\tsize                 :\\033[0m   \\033[93m%s  \\033[0m\t\n\t\"\"\"%(description,package_url,author,author_email,last_month,last_week,\\\n\t     last_day,home_page,releases,download_url,filename,size)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef main():\n    '''cheesy gives you the news for today's cheese pipy factory from command line'''\n    arguments = docopt(__doc__, version=__version__)\n    if arguments['ls']:\n        _pull_all('ls')\n    elif arguments['list']:\n        _pull_all('list')\n    elif arguments['<PACKAGE>']:\n\t\ttry:\n\t\t\tif arguments['<VERSION>']:\n\t\t\t\t_construct(arguments['<PACKAGE>'],arguments['<VERSION>'])\n\t\t\telse:\n\t\t\t\t_construct(arguments['<PACKAGE>'],None)\n\t\texcept ValueError:\n\t\t\tprint \"\\033[91m\\033[1mError: package not found try.. \\033[0m\\033[1m\\n$ cheese ls \\nto view pacakages\"\n    else:\n        print(__doc__)", "response": "cheesy gives you the news for today s cheese pipy factory from command line"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef compile_binary(source):\n    cmd = 'make sense'\n    src = '/usr/local/bin/chkrootkit'\n    dst = '/usr/local/chkrootkit/chkrootkit'\n    # Tar Extraction\n    t = tarfile.open(source, 'r')\n    t.extractall(TMPDIR)\n    if isinstance(t.getnames(), list):\n        extract_dir = t.getnames()[0].split('/')[0]\n        os.chdir(TMPDIR + '/' + extract_dir)\n        logger.info('make output: \\n%s' % subprocess.getoutput(cmd))\n        # move directory in place\n        mv_cmd = 'sudo mv %s /usr/local/chkrootkit' % (TMPDIR + '/' + extract_dir)\n        subprocess.getoutput(mv_cmd)\n        # create symlink to binary in directory\n        os.symlink(dst, src)\n        return True\n    return False", "response": "Compile a binary into a chkrootkit binary"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ninstalling operating system dependent packages", "response": "def os_packages(metadata):\n    \"\"\" Installs operating system dependent packages \"\"\"\n    family = metadata[0]\n    release = metadata[1]\n    #\n    if 'Amazon' in family and '2' not in release:\n        stdout_message('Identified Amazon Linux 1 os distro')\n        commands = [\n            'sudo yum -y update', 'sudo yum -y groupinstall \"Development tools\"'\n        ]\n        for cmd in commands:\n            stdout_message(subprocess.getoutput(cmd))\n        return True\n    elif 'Amazon' in family and '2' in release:\n        stdout_message('Identified Amazon Linux 2 os distro')\n        commands = [\n            'sudo yum -y update', 'sudo yum -y groupinstall \"Development tools\"'\n        ]\n        for cmd in commands:\n            stdout_message(subprocess.getoutput(cmd))\n        return True\n    elif 'Redhat' in family:\n        stdout_message('Identified Redhat Enterprise Linux os distro')\n        commands = [\n            'sudo yum -y update', 'sudo yum -y groupinstall \"Development tools\"'\n        ]\n        for cmd in commands:\n            stdout_message(subprocess.getoutput(cmd))\n    elif 'Ubuntu' or 'Mint' in family:\n        stdout_message('Identified Ubuntu Linux os distro')\n        commands = [\n            'sudo apt -y update', 'sudo apt -y upgrade',\n            'sudo yum -y groupinstall \"Development tools\"'\n        ]\n        for cmd in commands:\n            stdout_message(subprocess.getoutput(cmd))\n        return True\n    return False"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef stdout_message(message, prefix='INFO', quiet=False,\n                                    multiline=False, tabspaces=4, severity=''):\n    \"\"\" Prints message to cli stdout while indicating type and severity\n\n    Args:\n        :message (str): text characters to be printed to stdout\n        :prefix (str):  4-letter string message type identifier.\n        :quiet (bool):  Flag to suppress all output\n        :multiline (bool): indicates multiline message; removes blank lines on\n         either side of printed message\n        :tabspaces (int): left justified number of spaces\n        :severity (str): header msg determined color instead of prefix\n\n    .. code-block:: python\n\n        # Examples:\n\n            - INFO (default)\n            - ERROR (error, problem occurred)\n            - WARN (warning)\n            - NOTE (important to know)\n\n    Returns:\n        TYPE: bool, Success (printed) | Failure (no output)\n    \"\"\"\n    prefix = prefix.upper()\n    tabspaces = int(tabspaces)\n    # prefix color handling\n    choices = ('RED', 'BLUE', 'WHITE', 'GREEN', 'ORANGE')\n    critical_status = ('ERROR', 'FAIL', 'WTF', 'STOP', 'HALT', 'EXIT', 'F*CK')\n\n    if quiet:\n        return False\n    else:\n        if prefix in critical_status or severity.upper() == 'CRITICAL':\n            header = (Colors.YELLOW + '\\t[ ' + Colors.RED + prefix +\n                      Colors.YELLOW + ' ]' + Colors.RESET + ': ')\n        elif severity.upper() == 'WARNING':\n            header = (Colors.YELLOW + '\\t[ ' + Colors.ORANGE + prefix +\n                      Colors.YELLOW + ' ]' + Colors.RESET + ': ')\n        else:    # default color scheme\n            header = (Colors.YELLOW + '\\t[ ' + Colors.DARKCYAN + prefix +\n                      Colors.YELLOW + ' ]' + Colors.RESET + ': ')\n        if multiline:\n            print(header.expandtabs(tabspaces) + str(message))\n        else:\n            print('\\n' + header.expandtabs(tabspaces) + str(message) + '\\n')\n    return True", "response": "Prints a message to the cli stdout while indicating type and severity."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nchecks Dependencies, download files, integrity check", "response": "def main():\n    \"\"\"\n    Check Dependencies, download files, integrity check\n    \"\"\"\n    # vars\n    tar_file = TMPDIR + '/' + BINARY_URL.split('/')[-1]\n    chksum = TMPDIR + '/' + MD5_URL.split('/')[-1]\n    # pre-run validation + execution\n    if precheck() and os_packages(distro.linux_distribution()):\n        stdout_message('begin download')\n        download()\n        stdout_message('begin valid_checksum')\n        valid_checksum(tar_file, chksum)\n        return compile_binary(tar_file)\n    logger.warning('%s: Pre-run dependency check fail - Exit' % inspect.stack()[0][3])\n    return False"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nrunning housekeeping tasks to free up space.", "response": "def gc(ctx):\n    \"\"\"Runs housekeeping tasks to free up space.\n\n    For now, this only removes saved but unused (unreachable) test results.\n    \"\"\"\n    vcs = ctx.obj['vcs']\n    count = 0\n    with locking.lock(vcs, locking.Lock.tests_history):\n        known_signatures = set(get_committed_signatures(vcs) + get_staged_signatures(vcs))\n        for signature in get_signatures_with_results(vcs):\n            if signature not in known_signatures:\n                count += 1\n                remove_results(vcs, signature)\n    click.echo('Removed {} saved results.'.format(count))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef clone_repo(pkg_name, repo_url):\n    new_repo = ClonedRepo(name=pkg_name, origin=repo_url)\n    new_repo.save()\n    return new_repo", "response": "Create a new cloned repo with the given parameters."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\npulling from origin for repo_name.", "response": "def pull_repo(repo_name):\n    \"\"\"Pull from origin for repo_name.\"\"\"\n    repo = ClonedRepo.objects.get(pk=repo_name)\n    repo.pull()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\npull origin updates for all repos with origins.", "response": "def pull_all_repos():\n    \"\"\"Pull origin updates for all repos with origins.\"\"\"\n    repos = ClonedRepo.objects.all()\n    for repo in repos:\n        if repo.origin is not None:\n            pull_repo.delay(repo_name=repo.name)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the IPv4 addresses associated with this NIC.", "response": "def _get_ipv4_addrs(self):\n        \"\"\"\n        Returns the IPv4 addresses associated with this NIC. If no IPv4\n        addresses are used, then empty dictionary is returned.\n        \"\"\"\n        addrs = self._get_addrs()\n        ipv4addrs = addrs.get(netifaces.AF_INET)\n        if not ipv4addrs:\n            return {}\n        return ipv4addrs[0]"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the IPv6 addresses associated with this NIC.", "response": "def _get_ipv6addrs(self):\n        \"\"\"\n        Returns the IPv6 addresses associated with this NIC. If no IPv6\n        addresses are used, empty dict is returned.\n        \"\"\"\n        addrs = self._get_addrs()\n        ipv6addrs = addrs.get(netifaces.AF_INET6)\n        if not ipv6addrs:\n            return {}\n        return ipv6addrs[0]"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _get_default_gateway(self, ip=4):\n        net_type = netifaces.AF_INET if ip == 4 else netifaces.AF_INET6\n        gw = netifaces.gateways()['default'].get(net_type, (None, None))\n        if gw[1] == self.name:\n            return gw[0]", "response": "Returns the default gateway for given IP version."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef switch(stage):\n    stage = stage.lower()\n    local(\"git pull\")\n    if stage in ['dev', 'devel', 'develop']:\n        branch_name = 'develop'\n    elif stage in ['qa', 'release']:\n        branches = local('git branch -r', capture=True)\n        possible_branches = []\n        for b in branches.split(\"\\n\"):\n            b_parts = b.split('/')\n            if b_parts[1] == 'release':\n                possible_branches.append(b_parts[2])\n        if len(possible_branches) == 0:\n            raise Exception('No release branches found. Please create a new release first.')\n        possible_branches = sorted(possible_branches, reverse=True)\n        branch_name = 'release/%s' % possible_branches[0]\n    elif stage in ['production', 'master']:\n        branch_name = 'master'\n    else:\n        raise NotImplemented\n    local(\"git checkout %s\" % branch_name)\n    local(\"git pull\")", "response": "Switches the current version of the current release to given stage."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef release_qa(quietly=False):\n    name = prompt(red('Sprint name?'), default='Sprint 1').lower().replace(' ', \"_\")\n    release_date = prompt(red('Sprint start date (Y-m-d)?'), default='2013-01-20').replace('-', '')\n    release_name = '%s_%s' % (release_date, name)\n    local('git flow release start %s' % release_name)\n    local('git flow release publish %s' % release_name)\n    if not quietly:\n        print(red('PLEASE DEPLOY CODE: fab deploy:all'))", "response": "Get QA release code to QA server"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef update_qa(quietly=False):\n    switch('dev')\n    switch('qa')\n    local('git merge --no-edit develop')\n    local('git push')\n    if not quietly:\n        print(red('PLEASE DEPLOY CODE: fab deploy:all'))", "response": "Update the code from develop to qa"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget database from server", "response": "def _get_db():\n    \"\"\"\n        Get database from server\n    \"\"\"\n    with cd(env.remote_path):\n        file_path = '/tmp/' + _sql_paths('remote', str(base64.urlsafe_b64encode(uuid.uuid4().bytes)).replace('=', ''))\n        run(env.python + ' manage.py dump_database | gzip > ' + file_path)\n        local_file_path = './backups/' + _sql_paths('remote', datetime.now())\n    get(file_path, local_file_path)\n    run('rm ' + file_path)\n    return local_file_path"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef command(command):\n    with cd(env.remote_path):\n        sudo(env.python + ' manage.py %s' % command, user=env.remote_user)", "response": "Run custom Django management command"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef setup_server(clear_old=False, repo=\"github\", python=\"/usr/bin/python3.6\"):\n\n    if repo == 'github':\n        url_keys = 'https://github.com/ArabellaTech/%s/settings/keys' % env.repo_name\n        url_clone = 'git@github.com:ArabellaTech/%s.git' % env.repo_name\n    elif repo == 'bitbucket':\n        url_keys = 'https://bitbucket.org/arabellatech/%s/admin/deploy-keys/' % env.repo_name\n        url_clone = 'git@bitbucket.org:arabellatech/%s.git' % env.repo_name\n    else:\n        raise NotImplementedError('Unknown repo type')\n\n    if clear_old:\n        sudo('userdel -r %s' % env.remote_user)\n\n    sudo('useradd --shell /bin/bash --create-home %s' % env.remote_user, user='root')\n    sudo('ssh-keygen -t rsa -P \"\" -f /home/%s/.ssh/id_rsa' % env.remote_user, user=env.remote_user)\n    sudo('cp -f /home/%s/.ssh/id_rsa.pub ~/key.tmp' % env.remote_user, user='root')\n    key = sudo('cat ~/key.tmp', user='root')\n    sudo('rm ~/key.tmp', user='root')\n    print(red('Please put following deploy key in %s' % url_keys))\n    print (key)\n    prompt(red('Press any key to continue'))\n    sudo('export WORKON_HOME=/home/%s/Envs &&\\\n         source /usr/local/bin/virtualenvwrapper_lazy.sh &&\\\n         mkvirtualenv %s --no-site-packages -p %s' % (env.remote_user, env.app_dir, python),\n         warn_only=True, user=env.remote_user)\n    sudo('cd /home/%s/ && git clone %s www' % (env.remote_user, url_clone), user=env.remote_user)\n    with cd(env.remote_path):\n        sudo('git checkout %s' % env.branch, user=env.remote_user)\n        sudo('git pull', user=env.remote_user)\n        sudo('cd %s && ln -sf ../config/%s/yd_local_settings.py local_settings.py' % (env.app_dir, env.environment),\n             user=env.remote_user)\n        sudo(env.pip + ' install -r requirements.txt --no-cache-dir', user=env.remote_user)\n        if django.VERSION >= (1, 8):\n            sudo(env.python + ' manage.py migrate', user=env.remote_user)\n        else:\n            sudo(env.python + ' manage.py syncdb --migrate', user=env.remote_user)\n\n        sudo('cd config && ln -sf %s/logrotate.conf logrotate.conf' % (env.environment))\n\n        # try installing npm\n        # install npm modules\n        # sudo('/bin/bash ./scripts/fab_build_bower_npm.sh ' + env.remote_user, user=env.remote_user, warn_only=True)\n        # fix angular for webkit\n\n        # sudo('/home/' + env.remote_user + '/www/node_modules/.bin/webkit-assign /home/' + env.remote_user +\n        #      '/www/nutrimom/static/libs/bower_components/angular/angular.js', user=env.remote_user, warn_only=True)\n\n        # build js\n        # sudo('grunt build-js', warn_only=True)\n\n        sudo(env.python + ' manage.py collectstatic -v0 --noinput', user=env.remote_user)\n        sudo(env.python + ' manage.py compress -f', user=env.remote_user)\n\n        params = (env.remote_user, env.environment, env.remote_user)\n        sudo('cd /etc/nginx/sites-enabled && ln -sf /home/%s/www/config/%s/nginx.conf %s.conf' % params, user='root')\n        sudo('cd /etc/supervisor/conf.d/ && ln -sf /home/%s/www/config/%s/supervisord.conf %s.conf' % params,\n             user='root')\n        sudo('/etc/init.d/nginx reload', user='root')\n        sudo('supervisorctl reread && supervisorctl update', user='root')\n\n    update_cron()", "response": "Setup server for Arabella Tech"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncopying db between two servers ie develop to qa", "response": "def copy_db(source_env, destination_env):\n    \"\"\"\n        Copies Db betweem servers, ie develop to qa.\n        Should be called by function from function defined in project fabfile.\n        Example usage:\n\n        def copy_db_between_servers(source_server, destination_server):\n\n            source_env = {}\n            destination_env = {}\n\n            def populate_env_dict(server, local_env):\n                app_dir = 'nutrimom'\n                if server == 'nm-dev':\n                    user = 'nutrimom-dev'\n                    prefix = \"dev\"\n                    environment = 'devel'\n                    host_string = 'dev.arabel.la'\n                elif server == 'nm-qa':\n                    user = 'nutrimom-qa'\n                    prefix = \"qa\"\n                    environment = 'qa'\n                    host_string = 'qa.arabel.la'\n                elif server.startswith('nm-f'):\n                    if server in ['nm-f1', 'nm-f2', 'nm-f3', 'nm-f4', 'nm-f5']:\n                        user = 'nutrimom-' + server.split('-')[1]\n                        prefix = user.split('-')[1]\n                        environment = prefix\n                        host_string = 'dev.arabel.la'\n                else:\n                    print (\"supported params: nm-dev, nm-qa, nm-fx\")\n                    sys.exit()\n\n                local_env['app_dir'] = app_dir\n                local_env['remote_user'] = user\n                local_env['remote_path'] = '/home/%s/www/' % (user)\n                local_env['dir'] = '/home/%s/Envs/%s' % (user, app_dir)\n                local_env['python'] = '/home/%s/Envs/%s/bin/python' % (user, app_dir)\n                local_env['pip'] = '/home/%s/Envs/%s/bin/pip' % (user, app_dir)\n                local_env['prefix'] = prefix\n                local_env['environment'] = environment\n                local_env['host_string'] = host_string\n                local_env['is_feature'] = False\n                return local_env\n\n            source_env = populate_env_dict(source_server, source_env)\n            destination_env = populate_env_dict(destination_server, destination_env)\n\n            copy_db(source_env, destination_env)\n    \"\"\"\n    env.update(source_env)\n    local_file_path = _get_db()\n\n    # put the file on external file system\n    # clean external db\n    # load database into external file system\n    env.update(destination_env)\n\n    with cd(env.remote_path):\n        sudo('mkdir -p backups', user=env.remote_user)\n        sudo(env.python + ' manage.py dump_database | gzip > backups/' + _sql_paths('local', datetime.now()))\n        put(local_file_path, 'backups', use_sudo=True)\n        sudo(env.python + ' manage.py clear_database', user=env.remote_user)\n        if local_file_path.endswith('.gz'):  # the path is the same here and there\n            sudo('gzip -dc %s | %s manage.py dbshell' % (local_file_path, env.python), user=env.remote_user)\n        else:\n            sudo('%s manage.py dbshell < %s ' % (env.python, local_file_path), user=env.remote_user)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef copy_s3_bucket(src_bucket_name, src_bucket_secret_key, src_bucket_access_key,\n                   dst_bucket_name, dst_bucket_secret_key, dst_bucket_access_key):\n    \"\"\" Copy S3 bucket directory with CMS data between environments. Operations are done on server. \"\"\"\n    with cd(env.remote_path):\n        tmp_dir = \"s3_tmp\"\n        sudo('rm -rf %s' % tmp_dir, warn_only=True, user=env.remote_user)\n        sudo('mkdir %s' % tmp_dir, user=env.remote_user)\n        sudo('s3cmd --recursive get s3://%s/upload/ %s --secret_key=%s --access_key=%s' % (\n            src_bucket_name, tmp_dir, src_bucket_secret_key, src_bucket_access_key),\n            user=env.remote_user)\n        sudo('s3cmd --recursive put %s/ s3://%s/upload/ --secret_key=%s --access_key=%s' % (\n            tmp_dir, dst_bucket_name, dst_bucket_secret_key, dst_bucket_access_key),\n            user=env.remote_user)\n\n        sudo('s3cmd setacl s3://%s/upload --acl-public --recursive --secret_key=%s --access_key=%s' % (\n             dst_bucket_name, dst_bucket_secret_key, dst_bucket_access_key),\n             user=env.remote_user)\n        # cleanup\n        sudo('rm -rf %s' % tmp_dir, warn_only=True, user=env.remote_user)", "response": "Copy S3 bucket with CMS data between environments."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef send_point_data(events, additional):\n    bodies = {}\n    for (site, content_id), count in events.items():\n        if not len(site) or not len(content_id):\n            continue\n\n        # influxdb will take an array of arrays of values, cutting down on the number of requests\n        # needed to be sent to it wo write data\n        bodies.setdefault(site, [])\n\n        # get additional info\n        event, path = additional.get((site, content_id), (None, None))\n\n        # append the point\n        bodies[site].append([content_id, event, path, count])\n\n    for site, points in bodies.items():\n        # send payload to influxdb\n        try:\n            data = [{\n                \"name\": site,\n                \"columns\": [\"content_id\", \"event\", \"path\", \"value\"],\n                \"points\": points,\n            }]\n            INFLUXDB_CLIENT.write_points(data)\n        except Exception as e:\n            LOGGER.exception(e)", "response": "creates data point payloads and sends them to influxdb"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate data point payloads for trending data to influxdb", "response": "def send_trending_data(events):\n    \"\"\"creates data point payloads for trending data to influxdb\n    \"\"\"\n    bodies = {}\n\n    # sort the values\n    top_hits = sorted(\n        [(key, count) for key, count in events.items()],\n        key=lambda x: x[1],\n        reverse=True\n    )[:100]\n\n    # build up points to be written\n    for (site, content_id), count in top_hits:\n        if not len(site) or not re.match(CONTENT_ID_REGEX, content_id):\n            continue\n\n        # add point\n        bodies.setdefault(site, [])\n        bodies[site].append([content_id, count])\n\n    for site, points in bodies.items():\n        # create name\n        name = \"{}_trending\".format(site)\n        # send payload to influxdb\n        try:\n            data = [{\n                \"name\": name,\n                \"columns\": [\"content_id\", \"value\"],\n                \"points\": points,\n            }]\n            INFLUXDB_CLIENT.write_points(data)\n        except Exception as e:\n            LOGGER.exception(e)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\npulling data from the queue and tabulates it and spawns a send event", "response": "def count_events():\n    \"\"\"pulls data from the queue, tabulates it and spawns a send event\n    \"\"\"\n    # wait loop\n    while 1:\n        # sleep and let the queue build up\n        gevent.sleep(FLUSH_INTERVAL)\n\n        # init the data points containers\n        events = Counter()\n        additional = {}\n\n        # flush the queue\n        while 1:\n            try:\n                site, content_id, event, path = EVENTS_QUEUE.get_nowait()\n                events[(site, content_id)] += 1\n                if event and path:\n                    additional[(site, content_id)] = (event, path)\n            except queue.Empty:\n                break\n            except Exception as e:\n                LOGGER.exception(e)\n                break\n\n        # after tabulating, spawn a new thread to send the data to influxdb\n        if len(events):\n            gevent.spawn(send_point_data, events, additional)\n            gevent.spawn(send_trending_data, events)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ntaking a couple query parameters and queries influxdb and sends a modified response", "response": "def pageviews(params):\n    \"\"\"takes a couple (optional) query parameters and queries influxdb and sends a modified response\n    \"\"\"\n    # set up default values\n    default_from, default_to, yesterday, _ = make_default_times()\n\n    # get params\n    try:\n        series = params.get(\"site\", [DEFAULT_SERIES])[0]\n        from_date = params.get(\"from\", [default_from])[0]\n        to_date = params.get(\"to\", [default_to])[0]\n        group_by = params.get(\"group_by\", [DEFAULT_GROUP_BY])[0]\n    except Exception as e:\n        LOGGER.exception(e)\n        return json.dumps({\"error\": e.message}), \"500 Internal Error\"\n\n    # check the cache\n    cache_key = \"{}:{}:{}:{}:{}:{}\".format(memcached_prefix, \"pageviews.json\", series, from_date, to_date, group_by)\n    try:\n        data = MEMCACHED_CLIENT.get(cache_key)\n        if data:\n            return data, \"200 OK\"\n    except Exception as e:\n        LOGGER.exception(e)\n\n    # parse from date\n    from_date = parse_datetime(from_date)\n    if from_date is None:\n        LOGGER.error(\"could not parse 'from'\")\n        return json.dumps({\"error\": \"could not parse 'from'\"}), \"400 Bad Request\"\n\n    # parse to date\n    to_date = parse_datetime(to_date)\n    if to_date is None:\n        LOGGER.error(\"could not parse 'to'\")\n        return json.dumps({\"error\": \"could not parse 'to'\"}), \"400 Bad Request\"\n\n    # influx will only keep non-aggregated data for a day, so if the from param is beyond that point\n    # we need to update the series name to use the rolled up values\n    rollup_query = False\n    if from_date < yesterday:\n        series = update_series(series, \"pageviews\")\n        rollup_query = True\n\n    # format times\n    from_date = format_datetime(from_date)\n    to_date = format_datetime(to_date)\n\n    # build out the query\n    if not rollup_query:\n        query = \"SELECT sum(value) as value \" \\\n                \"FROM {series} \" \\\n                \"WHERE time > '{from_date}' \" \\\n                \"AND time < '{to_date}' \" \\\n                \"AND event =~ /^pageview$/ \" \\\n                \"GROUP BY time({group_by}) \" \\\n                \"fill(0);\"\n    else:\n        query = \"SELECT sum(value) as value \" \\\n                \"FROM {series} \" \\\n                \"WHERE time > '{from_date}' \" \\\n                \"AND time < '{to_date}' \" \\\n                \"GROUP BY time({group_by}) \" \\\n                \"fill(0);\"\n    args = {\"series\": series, \"from_date\": from_date, \"to_date\": to_date, \"group_by\": group_by}\n\n    # send the request\n    try:\n        res = INFLUXDB_CLIENT.query(query.format(**args))\n\n    # capture errors and send them back along with the query (for inspection/debugging)\n    except Exception as e:\n        LOGGER.error(\"query: {}\".format(query.format(**args)))\n        LOGGER.exception(e)\n        return json.dumps({\"error\": e.message, \"query\": query.format(**args)}), \"500 Internal Error\"\n\n    # build the response object\n    response = flatten_response(res)\n    res = json.dumps(response)\n\n    # cache the response\n    try:\n        MEMCACHED_CLIENT.set(cache_key, res, time=MEMCACHED_EXPIRATION)\n    except Exception as e:\n        LOGGER.exception(e)\n\n    return res, \"200 OK\""}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef content_ids(params):\n    # set up default values\n    default_from, default_to, yesterday, _ = make_default_times()\n\n    # get params\n    try:\n        series = params.get(\"site\", [DEFAULT_SERIES])[0]\n        from_date = params.get(\"from\", [default_from])[0]\n        to_date = params.get(\"to\", [default_to])[0]\n        group_by = params.get(\"group_by\", [DEFAULT_GROUP_BY])[0]\n        ids = params.get(\"content_id\", [])\n    except Exception as e:\n        LOGGER.exception(e)\n        return json.dumps({\"error\": e.message}), \"500 Internal Error\"\n\n    # check the cache\n    cache_key = \"{}:{}:{}:{}:{}:{}:{}\".format(\n        memcached_prefix, \"contentids.json\", series, from_date, to_date, group_by, ids)\n    try:\n        data = MEMCACHED_CLIENT.get(cache_key)\n        if data:\n            return data, \"200 OK\"\n    except Exception as e:\n        LOGGER.exception(e)\n\n    # enforce content ids\n    if not len(ids):\n        return json.dumps({\"error\": \"you must pass at least one content id'\"}), \"400 Bad Request\"\n\n    # parse from date\n    from_date = parse_datetime(from_date)\n    if from_date is None:\n        LOGGER.error(\"could not parse 'from'\")\n        return json.dumps({\"error\": \"could not parse 'from'\"}), \"400 Bad Request\"\n\n    # parse to date\n    to_date = parse_datetime(to_date)\n    if to_date is None:\n        LOGGER.error(\"could not parse 'to'\")\n        return json.dumps({\"error\": \"could not parse 'to'\"}), \"400 Bad Request\"\n\n    # influx will only keep non-aggregated data for a day, so if the from param is beyond that point\n    # we need to update the series name to use the rolled up values\n    if from_date < yesterday:\n        series = update_series(series, \"pageviews\", \"content_id\")\n\n    # format times\n    from_date = format_datetime(from_date)\n    to_date = format_datetime(to_date)\n\n    # start building the query\n    query = \"SELECT content_id, sum(value) as value \" \\\n            \"FROM {series} \" \\\n            \"WHERE time > '{from_date}' AND time < '{to_date}' \" \\\n            \"GROUP BY content_id, time({group_by}) \" \\\n            \"fill(0);\"\n    args = {\"series\": series, \"from_date\": from_date, \"to_date\": to_date, \"group_by\": group_by}\n\n    # send the request\n    try:\n        res = INFLUXDB_CLIENT.query(query.format(**args))\n\n    # capture errors and send them back along with the query (for inspection/debugging)\n    except Exception as e:\n        LOGGER.exception(e)\n        return json.dumps({\"error\": e.message, \"query\": query.format(**args)}), \"500 Internal Error\"\n\n    # build the response object\n    response = flatten_response(res)\n\n    # filter by content ids\n    if len(ids):\n        for site, points in response.items():\n            filtered = filter(lambda p: p[\"content_id\"] in ids, points)\n            response[site] = filtered\n    res = json.dumps(response)\n\n    # cache the response\n    try:\n        MEMCACHED_CLIENT.set(cache_key, res, time=MEMCACHED_EXPIRATION)\n    except Exception as e:\n        LOGGER.exception(e)\n\n    return res, \"200 OK\"", "response": "returns a list of content ids for a pageview"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef trending(params):\n    # get params\n    try:\n        series = params.get(\"site\", [DEFAULT_SERIES])[0]\n        offset = params.get(\"offset\", [DEFAULT_GROUP_BY])[0]\n        limit = params.get(\"limit\", [20])[0]\n    except Exception as e:\n        LOGGER.exception(e)\n        return json.dumps({\"error\": e.message}), \"500 Internal Error\"\n\n    # check the cache\n    cache_key = \"{}:{}:{}:{}:{}\".format(memcached_prefix, \"trending.json\", series, offset, limit)\n    try:\n        data = MEMCACHED_CLIENT.get(cache_key)\n        if data:\n            return data, \"200 OK\"\n    except Exception as e:\n        LOGGER.exception(e)\n\n    # update series name\n    series = update_trending_series(series)\n\n    # parse the limit\n    try:\n        limit = int(limit)\n    except ValueError:\n        LOGGER.error(\"limit param must be an integer\")\n        return json.dumps({\"error\": \"limit param must be an integer\"}), \"400 Bad Request\"\n\n    # build the query\n    query = \"SELECT content_id, sum(value) as value \" \\\n            \"FROM {series} \" \\\n            \"WHERE time > now() - {offset} \" \\\n            \"GROUP BY content_id;\"\n    args = {\"series\": series, \"offset\": offset}\n\n    # send the request\n    try:\n        res = INFLUXDB_CLIENT.query(query.format(**args))\n\n    # capture errors and send them back along with the query (for inspection/debugging)\n    except Exception as e:\n        LOGGER.exception(e)\n        return json.dumps({\"error\": e.message, \"query\": query.format(**args)}), \"500 Internal Error\"\n\n    # build the response object\n    response = flatten_response(res)\n\n    # limit the number of content per site\n    for site, points in response.items():\n        sorted_content = sorted(points, key=lambda p: p[\"value\"], reverse=True)[:limit]\n        response[site] = sorted_content\n\n    clean_response = {}\n    for site, values in response.items():\n        clean_name = site.split(\"-\")[0]\n        clean_response[clean_name] = values\n    res = json.dumps(clean_response)\n\n    # cache the response\n    try:\n        MEMCACHED_CLIENT.set(cache_key, res, time=MEMCACHED_EXPIRATION)\n    except Exception as e:\n        LOGGER.exception(e)\n\n    return res, \"200 OK\"", "response": "gets trending content values\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef application(env, start_response):\n    path = env[\"PATH_INFO\"]\n\n    if path == \"/influx.gif\":\n        # send response\n        start_response(\"200 OK\", [(\"Content-Type\", \"image/gif\")])\n        yield GIF\n        # parse the query params and stick them in the queue\n        params = parse_qs(env[\"QUERY_STRING\"])\n        try:\n            site = params.get(\"site\", [\"\"])[0]\n            content_id = params.get(\"content_id\", [\"\"])[0]\n            event = params.get(\"event\", [\"\"])[0]\n            path = params.get(\"path\", [\"\"])[0]\n            EVENTS_QUEUE.put((site, content_id, event, path))\n        except Exception as e:\n            LOGGER.exception(e)\n\n    elif path == \"/pageviews.json\":\n        params = parse_qs(env[\"QUERY_STRING\"])\n        data, status = pageviews(params)\n        start_response(status, [(\"Content-Type\", \"application/json\")])\n        yield data\n\n    elif path == \"/embedviews.json\":\n        params = parse_qs(env[\"QUERY_STRING\"])\n        data, status = embedviews(params)\n        start_response(status, [(\"Content-Type\", \"application/json\")])\n        yield data\n\n    elif path == \"/contentids.json\":\n        params = parse_qs(env[\"QUERY_STRING\"])\n        data, status = content_ids(params)\n        start_response(status, [(\"Content-Type\", \"application/json\")])\n        yield data\n\n    elif path == \"/trending.json\":\n        params = parse_qs(env[\"QUERY_STRING\"])\n        data, status = trending(params)\n        start_response(status, [(\"Content-Type\", \"application/json\")])\n        yield data\n\n    elif path == \"/videoplays.json\":\n        params = parse_qs(env[\"QUERY_STRING\"])\n        data, status = videoplays(params)\n        start_response(status, [(\"Content-Type\", \"application/json\")])\n        yield data\n\n    elif path == \"/embedplays.json\":\n        params = parse_qs(env[\"QUERY_STRING\"])\n        data, status = embedplays(params)\n        start_response(status, [(\"Content-Type\", \"application/json\")])\n        yield data\n\n    else:\n        start_response(\"404 Not Found\", [(\"Content-Type\", \"text/plain\")])\n        yield \"Nothing Here\"", "response": "WSGI application that returns a generator that yields the content of the current application."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef create_namespace(self, name, ignore_errors=False):\r\n        if not self.has_namespace(name):\r\n            self.namespaces[name] = ConjunctiveGraph()\r\n            return True\r\n        elif ignore_errors:\r\n            return True\r\n        else:\r\n            raise RuntimeError(\"namespace '%s' already exists\" % name)", "response": "creates a namespace if it does not exist"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef delete_namespace(self, name, ignore_errors=False):\r\n        if self.has_namespace(name):\r\n            del self.namespaces[name]\r\n            return True\r\n        elif ignore_errors:\r\n            return True\r\n        else:\r\n            raise RuntimeError(\"namespace '%s' does not exist\" % name)", "response": "Deletes a namespace from the list of namespaces."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef query(self,\r\n              sparql,\r\n              mode=\"get\",\r\n              namespace=None,\r\n              rtn_format=\"json\",\r\n              **kwargs):\r\n        \"\"\" runs a sparql query and returns the results\r\n\r\n            args:\r\n                sparql: the sparql query to run\r\n                namespace: the namespace to run the sparql query against\r\n                mode: ['get'(default), 'update'] the type of sparql query\r\n                rtn_format: ['json'(default), 'xml'] format of query results\r\n        \"\"\"\r\n        if kwargs.get(\"debug\"):\r\n            log.setLevel(logging.DEBUG)\r\n        conn = self.conn\r\n        if namespace and namespace != self.namespace:\r\n            conn = self.tstore.get_namespace(namespace)\r\n        else:\r\n            namespace = self.namespace\r\n        if rtn_format not in self.qry_results_formats:\r\n            raise KeyError(\"rtn_format was '%s'. Allowed values are %s\" % \\\r\n                           (rtn_format, self.qry_results_formats))\r\n        if not sparql.strip().lower().startswith(\"prefix\"):\r\n            sparql = \"%s\\n%s\" % (NSM.prefix(), sparql)\r\n        start = datetime.datetime.now()\r\n        if mode == \"get\":\r\n            try:\r\n                result = json.loads( \\\r\n                         conn.query(sparql).serialize(\\\r\n                         format=rtn_format).decode()).get('results',\r\n                                                          {}).get('bindings', [])\r\n            except:\r\n                print(sparql)\r\n                raise\r\n        if mode == \"update\":\r\n            try:\r\n                result = conn.update(sparql)\r\n            except:\r\n                print(sparql)\r\n                raise\r\n        log.debug(\"\\nmode='%s', namespace='%s', rtn_format='%s'\\n**** SPAQRL QUERY \\n%s\\nQuery Time: %s\",\r\n                  mode,\r\n                  namespace,\r\n                  rtn_format,\r\n                  sparql,\r\n                  (datetime.datetime.now()-start))\r\n        return result", "response": "runs a sparql query against the specified namespace and returns the results"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nrunning a sparql update query and returns the results", "response": "def update_query(self, sparql, namespace=None, **kwargs):\r\n        \"\"\" runs a sparql update query and returns the results\r\n\r\n            args:\r\n                sparql: the sparql query to run\r\n                namespace: the namespace to run the sparql query against\r\n        \"\"\"\r\n        return self.query(sparql, \"update\", namespace, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nloading data via file stream to blazegraph", "response": "def load_data(self,\r\n                  data,\r\n                  datatype=\"ttl\",\r\n                  namespace=None,\r\n                  graph=None,\r\n                  is_file=False,\r\n                  **kwargs):\r\n        \"\"\" loads data via file stream from python to triplestore\r\n\r\n        Args:\r\n          data: The data or filepath to load\r\n          datatype(['ttl', 'xml', 'rdf']): the type of data to load\r\n          namespace: the namespace to use\r\n          graph: the graph to load the data to.\r\n          is_file(False): If true python will read the data argument as a\r\n              filepath, determine the datatype from the file extension,\r\n              read the file and send it to blazegraph as a datastream\r\n        \"\"\"\r\n        if kwargs.get('debug'):\r\n            log.setLevel(logging.DEBUG)\r\n        time_start = datetime.datetime.now()\r\n        datatype_map = {\r\n            'ttl': 'turtle',\r\n            'xml': 'xml',\r\n            'rdf': 'xml',\r\n            'nt': 'nt',\r\n            'n3': 'n3',\r\n            'nquads': 'nquads',\r\n            'hturtle': 'hturtle'\r\n        }\r\n        if is_file:\r\n            datatype = data.split(os.path.extsep)[-1]\r\n            file_name = data\r\n            log.debug('starting data load of %s', file_name)\r\n            data = open(data, 'rb').read()\r\n        try:\r\n            content_type = datatype_map[datatype]\r\n        except KeyError:\r\n            raise NotImplementedError(\"'%s' is not an implemented data fromat\",\r\n                                      datatype)\r\n        conn = self.conn\r\n        if namespace:\r\n            conn = self.tstore.get_namespace(namespace)\r\n        else:\r\n            namespace = self.namespace\r\n        graph = pick(graph, self.graph)\r\n        start = datetime.datetime.now()\r\n        try:\r\n            result = conn.parse(data=data, publicID=graph, format=content_type)\r\n        except:\r\n            if is_file:\r\n                print(\"Datafile \", file_name)\r\n            raise\r\n        if is_file:\r\n            log.info (\" loaded %s into rdflib namespace '%s'\",\r\n                      file_name,\r\n                      namespace)\r\n        else:\r\n            log.info(\" loaded data into rdflib namespace '%s' in time: %s\",\r\n                     namespace,\r\n                     (datetime.datetime.now() - start))\r\n            return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef load_directory(self, method='data_stream', **kwargs):\r\n\r\n        if kwargs.get('reset') == True:\r\n            self.reset_namespace()\r\n        namespace = kwargs.get('namespace', self.namespace)\r\n        container_dir = kwargs.get('container_dir', self.container_dir)\r\n        graph = kwargs.get('graph')\r\n        time_start = datetime.datetime.now()\r\n        include_root = kwargs.get('include_root', False)\r\n        if method == 'data_stream':\r\n            include_root = True\r\n        file_directory = kwargs.get('file_directory', self.local_directory)\r\n        file_extensions = kwargs.get('file_extensions', self.rdf_formats)\r\n        file_list = list_files(file_directory,\r\n                               file_extensions,\r\n                               kwargs.get('include_subfolders', True),\r\n                               include_root=include_root,\r\n                               root_dir=kwargs.get('root_dir',\r\n                                                   self.local_directory))\r\n        log.info(\" starting load of '%s' files into namespace '%s'\",\r\n                 len(file_list),\r\n                 self.namespace)\r\n        if kwargs.get('create_namespace') and namespace:\r\n            if not self.has_namespace(namespace):\r\n                self.create_namespace(namespace)\r\n        if not self.has_namespace(namespace):\r\n            msg = \"\".join([\"Namespace '%s' does not exist. \" % namespace,\r\n                           \"Pass kwarg 'create_namespace=True' to \",\r\n                           \"auto-create the namespace.\"])\r\n            raise ValueError(msg)\r\n        params = {}\r\n        for file in file_list:\r\n            if kwargs.get('use_threading') == True:\r\n                if method == 'data_stream':\r\n                    th = threading.Thread(name=file[1],\r\n                                          target=self.load_data,\r\n                                          args=(file[1],\r\n                                                None,\r\n                                                namespace,\r\n                                                graph,\r\n                                                True,))\r\n                else:\r\n                    th = threading.Thread(name=file[1],\r\n                                          target=self.load_local_file,\r\n                                          args=(file[1],\r\n                                                namespace,\r\n                                                graph,))\r\n                th.start()\r\n            else:\r\n              if method == 'data_stream':\r\n                  self.load_data(data=file[1],\r\n                                 namespace=namespace,\r\n                                 graph=graph,\r\n                                 is_file=True)\r\n              else:\r\n                  self.load_local_file(file[1], namespace, graph)\r\n        if kwargs.get('use_threading') == True:\r\n            main_thread = threading.main_thread()\r\n            for t in threading.enumerate():\r\n                if t is main_thread:\r\n                    continue\r\n                t.join()\r\n        log.info(\"%s file(s) loaded in: %s\",\r\n                 len(file_list),\r\n                 datetime.datetime.now() - time_start)", "response": "Uploads data to the Blazegraph Triplestore that is stored in a local directory"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nuploading data to the Triplestore that is stored in files in a local directory.", "response": "def load_local_file(self, file_path, namespace=None, graph=None, **kwargs):\r\n        \"\"\" Uploads data to the Blazegraph Triplestore that is stored in files\r\n            in  a local directory\r\n\r\n            args:\r\n                file_path: full path to the file\r\n                namespace: the Blazegraph namespace to load the data\r\n                graph: uri of the graph to load the data. Default is None\r\n        \"\"\"\r\n        return self.load_data(file_path,\r\n                              namespace=namespace,\r\n                              graph=graph,\r\n                              is_file=True,\r\n                              **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ninitializing the tiered instance of from the contents of the file referenced in Configuration. path and creates the default configuration if it doesn t exist.", "response": "def initialize():\n        \"\"\" Attempts to load default configuration from Configuration.path, returns status\n        \n        Loads the contents of the file referenced in Configuration.path and\n        parses it's JSON contents. Iterates over the contents of the resulting\n        dictionary and converts the contents into a tiered instance of \n        Configuration classes. If no file is found in Configuration.path,\n        automatically generates and sets a default configuration. The loaded\n        configuration content can be accessed via Configuration.getConfig().\n           \n        Returns\n           bool - True if successful, False otherwise\n        \"\"\"\n        try:\n            f = open(Configuration.path, 'r')\n            data = f.read()\n            f.close()\n        except Exception:\n            Configuration._createDefault() # Assumes the file does not exist or is not readable\n            return True\n            \n        try:\n            Configuration._config = Configuration(json.loads(data))\n            Configuration._makeConfig(Configuration._config)\n        except Exception as e:\n            logging.getLogger(\"neolib.config\").exception(\"Failed to read configuration file: \" + Configuration.path)\n            return False\n            \n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef maha_dist(df):\n    mean = df.mean()\n    S_1 = np.linalg.inv(df.cov())\n    \n    def fun(row):\n        A = np.dot((row.T - mean), S_1)\n        return np.dot(A, (row-mean))\n    \n    return df.apply(fun, axis=1)", "response": "Compute the squared Mahalanobis Distance for each row in the dataframe \n\n   "}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef within_n_sds(n, series):\n    z_score = (series - series.mean()) / series.std()\n    return (z_score.abs() <= n).all()", "response": "Return True if all values in sequence are within n SDs"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef within_n_mads(n, series):\n    mad_score = (series - series.mean()) / series.mad()\n    return (mad_score.abs() <= n).all()", "response": "Return True if all values in sequence are within n MADs"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef open(filename, flag='c', protocol=None, writeback=False,\n         maxsize=DEFAULT_MAXSIZE, timeout=DEFAULT_TIMEOUT):\n    \"\"\"Open a database file as a persistent dictionary.\n\n    The persistent dictionary file is opened using :func:`dbm.open`, so\n    performance will depend on which :mod:`dbm` modules are installed.\n\n    :func:`open` chooses to open a :class:`Shelf <shelve.Shelf>`,\n    :class:`LRUShelf`, :class:`TimeoutShelf`, or :class:`LRUTimeoutShelf`\n    depending on the values of keyword arguments *maxsize* and *timeout*.\n    A :data:`None` value for *maxsize* and *timeout* will disable the LRU\n    cache management and automatic data timeout features respectively.\n\n    :param filename: The base filename for the underlying database that is\n        passed to :func:`dbm.open`.\n    :param flag: The flag to pass to :func:`dbm.open`.\n    :param protocol: The pickle protocol to pass to :func:`pickle.dump`.\n    :param writeback: Whether or not to write back all accessed entries on\n        :meth:`Shelf.sync <shelve.Shelf.sync>` and\n        :meth:`Shelf.close <shelve.Shelf.close>`\n    :type writeback: bool\n    :param maxsize: The maximum size the container is allowed to grow to.\n        ``0`` means that no size limit is enforced. :data:`None` means that\n        LRU cache management is disabled.\n    :type maxsize: integer or :data:`None`\n    :param timeout: The default timeout value for data (in seconds). ``0``\n        means that the data never expires. :data:`None` means that automatic\n        timeout features will be disabled.\n    :type timeout: integer or :data:`None`\n    :return: A shelf\n    :rtype: :class:`~shelve.Shelf`, :class:`LRUShelf`, :class:`TimeoutShelf`,\n        or :class:`LRUTimeoutShelf`\n\n    \"\"\"\n    import dbm\n    dict = dbm.open(filename, flag)\n    if maxsize is None and timeout is None:\n        return Shelf(dict, protocol, writeback)\n    elif maxsize is None:\n        return TimeoutShelf(dict, protocol, writeback, timeout=timeout)\n    elif timeout is None:\n        return LRUShelf(dict, protocol, writeback, maxsize=maxsize)\n    return LRUTimeoutShelf(dict, protocol, writeback, timeout=timeout,\n                           maxsize=maxsize)", "response": "Open a database file as a persistent dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _remove_add_key(self, key):\n        if not hasattr(self, '_queue'):\n            return  # haven't initialized yet, so don't bother\n        if key in self._queue:\n            self._queue.remove(key)\n        self._queue.append(key)\n        if self.maxsize == 0:\n            return\n        while len(self._queue) > self.maxsize:\n            del self[self._queue[0]]", "response": "Move a key to the end of the linked list and discard old entries."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nchecks if a key is expired. Delete the key.", "response": "def _is_expired(self, key):\n        \"\"\"Check if a key is expired. If so, delete the key.\"\"\"\n        if not hasattr(self, '_index'):\n            return False  # haven't initalized yet, so don't bother\n        try:\n            timeout = self._index[key]\n        except KeyError:\n            if self.timeout:\n                self._index[key] = int(time() + self.timeout)\n            else:\n                self._index[key] = None\n            return False\n        if timeout is None or timeout >= time():\n            return False\n        del self[key]  # key expired, so delete it from container\n        return True"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting a value for a key in the cache.", "response": "def set(self, key, func, *args, **kwargs):\n        \"\"\"Return key's value if it exists, otherwise call given function.\n\n        :param key: The key to lookup/set.\n        :param func: A function to use if the key doesn't exist.\n\n        All other arguments and keyword arguments are passed to *func*.\n\n        \"\"\"\n        if key in self:\n            return self[key]\n        self[key] = value = func(*args, **kwargs)\n        return value"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nset a key s timeout value in seconds.", "response": "def settimeout(self, key, value, timeout):\n        \"\"\"Set a key with a timeout value (in seconds).\n\n        :meth:`settimeout` is used to override the shelf's timeout value.\n\n        :param timeout: The timeout value in seconds for the given key.\n            ``0`` means that the key will never expire.\n        :type timeout: integer\n\n        \"\"\"\n        self[key] = value\n        if not hasattr(self, '_index'):\n            return  # don't update index if __init__ hasn't completed\n        self._index[key] = int(time() + timeout) if timeout else None"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nsave model for every language so that field auto - population is done for every language.", "response": "def save_model(self, request, obj, form, change):\n        \"\"\"\n        Save model for every language so that field auto-population\n        is done for every each of it.\n        \"\"\"\n        super(DisplayableAdmin, self).save_model(request, obj, form, change)\n        if settings.USE_MODELTRANSLATION:\n            lang = get_language()\n            for code in OrderedDict(settings.LANGUAGES):\n                if code != lang:  # Already done\n                    try:\n                        activate(code)\n                    except:\n                        pass\n                    else:\n                        obj.save()\n            activate(lang)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nadding _order to the list of fields.", "response": "def get_fields(self, request, obj=None):\n        \"\"\"\n        For subclasses of ``Orderable``, the ``_order`` field must\n        always be present and be the last field.\n        \"\"\"\n        fields = super(BaseDynamicInlineAdmin, self).get_fields(request, obj)\n        if issubclass(self.model, Orderable):\n            fields = list(fields)\n            try:\n                fields.remove(\"_order\")\n            except ValueError:\n                pass\n            fields.append(\"_order\")\n        return fields"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a list of fieldsets for the current object.", "response": "def get_fieldsets(self, request, obj=None):\n        \"\"\"\n        Same as above, but for fieldsets.\n        \"\"\"\n        fieldsets = super(BaseDynamicInlineAdmin, self).get_fieldsets(\n                                                            request, obj)\n        if issubclass(self.model, Orderable):\n            for fieldset in fieldsets:\n                fields = [f for f in list(fieldset[1][\"fields\"])\n                          if not hasattr(f, \"translated_field\")]\n                try:\n                    fields.remove(\"_order\")\n                except ValueError:\n                    pass\n                fieldset[1][\"fields\"] = fields\n            fieldsets[-1][1][\"fields\"].append(\"_order\")\n        return fieldsets"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsets the object s owner as the logged in user.", "response": "def save_form(self, request, form, change):\n        \"\"\"\n        Set the object's owner as the logged in user.\n        \"\"\"\n        obj = form.save(commit=False)\n        if obj.user_id is None:\n            obj.user = request.user\n        return super(OwnableAdmin, self).save_form(request, form, change)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_queryset(self, request):\n        opts = self.model._meta\n        model_name = (\"%s.%s\" % (opts.app_label, opts.object_name)).lower()\n        models_all_editable = settings.OWNABLE_MODELS_ALL_EDITABLE\n        models_all_editable = [m.lower() for m in models_all_editable]\n        qs = super(OwnableAdmin, self).get_queryset(request)\n        if request.user.is_superuser or model_name in models_all_editable:\n            return qs\n        return qs.filter(user__id=request.user.id)", "response": "Filter the change list by currently logged in user."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef base_concrete_modeladmin(self):\n        candidates = [self.__class__]\n        while candidates:\n            candidate = candidates.pop()\n            if ContentTypedAdmin in candidate.__bases__:\n                return candidate\n            candidates.extend(candidate.__bases__)\n\n        raise Exception(\"Can't find base concrete ModelAdmin class.\")", "response": "The base concrete ModelAdmin class."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef change_view(self, request, object_id, **kwargs):\n        instance = get_object_or_404(self.concrete_model, pk=object_id)\n        content_model = instance.get_content_model()\n\n        self.check_permission(request, content_model, \"change\")\n\n        if content_model.__class__ != self.model:\n            change_url = admin_url(content_model.__class__, \"change\",\n                                   content_model.id)\n            return HttpResponseRedirect(change_url)\n\n        return super(ContentTypedAdmin, self).change_view(\n            request, object_id, **kwargs)", "response": "Redirect to the admin change view."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef changelist_view(self, request, extra_context=None):\n        if self.model is not self.concrete_model:\n            return HttpResponseRedirect(\n                admin_url(self.concrete_model, \"changelist\"))\n\n        extra_context = extra_context or {}\n        extra_context[\"content_models\"] = self.get_content_models()\n\n        return super(ContentTypedAdmin, self).changelist_view(\n            request, extra_context)", "response": "Redirect to the changelist view for subclasses."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_content_models(self):\n        models = []\n\n        for model in self.concrete_model.get_content_models():\n            try:\n                admin_url(model, \"add\")\n            except NoReverseMatch:\n                continue\n            else:\n                setattr(model, \"meta_verbose_name\", model._meta.verbose_name)\n                setattr(model, \"add_url\", admin_url(model, \"add\"))\n                models.append(model)\n\n        return models", "response": "Return all subclasses that are admin registered."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nproviding a warning if the user is an active admin with no admin access.", "response": "def save_model(self, request, obj, form, change):\n        \"\"\"\n        Provides a warning if the user is an active admin with no admin access.\n        \"\"\"\n        super(SitePermissionUserAdmin, self).save_model(\n            request, obj, form, change)\n        user = self.model.objects.get(id=obj.id)\n        has_perms = len(user.get_all_permissions()) > 0\n        has_sites = SitePermission.objects.filter(user=user).count() > 0\n        if user.is_active and user.is_staff and not user.is_superuser and not (\n                has_perms and has_sites):\n            error(request, \"The user is active but won't be able to access \"\n                           \"the admin, due to no edit/site permissions being \"\n                           \"selected\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef bind(self, args, kwargs):\n        spec = self._spec\n        resolution = self.resolve(args, kwargs)\n        params = dict(zip(spec.args, resolution.slots))\n        if spec.varargs:\n            params[spec.varargs] = resolution.varargs\n        if spec.varkw:\n            params[spec.varkw] = resolution.varkw\n        if spec.kwonlyargs:\n            params.update(resolution.kwonlyargs)\n        return params", "response": "Bind arguments and keyword arguments to the encapsulated function."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef apply(self, args, kwargs):\n        # Construct helper locals that only contain the function to call as\n        # 'func', all positional arguments as 'argX' and all keyword arguments\n        # as 'kwX'\n        _locals = {'func': self._func}\n        if args is not None:\n            _locals.update({\n                \"arg{}\".format(index): args[index]\n                for index, value in enumerate(args)})\n        if kwargs is not None:\n            # Explicitly build a list of keyword arguments so that we never\n            # traverse kwargs more than once\n            kw_list = list(kwargs.keys())\n            _locals.update({\n                \"kw{}\".format(index): kwargs[key]\n                for index, key in enumerate(kw_list)})\n        # Construct the call expression string by carefully\n        # placing each positional and keyword arguments in right\n        # order that _exactly_ matches how apply() was called.\n        params = []\n        if args is not None:\n            params.extend([\n                \"arg{}\".format(index)\n                for index in range(len(args))])\n        if kwargs is not None:\n            params.extend([\n                \"{}=kw{}\".format(key, index)\n                for index, key in enumerate(kw_list)])\n        expr = \"func({})\".format(\", \".join(params))\n        return eval(expr, globals(), _locals)", "response": "This function is used to apply a function to the internal dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nupdate the related attributes of a specific resource.", "response": "def update(self, **kwargs):\n        \"\"\"\n        Add, remove or modify a share's title.\n\n        Input:\n            * ``title`` The share title, if any (optional)\n\n        **NOTE**: Passing ``None`` or calling this method with an empty argument list will remove the share's title.\n\n        Output:\n            * None\n\n        Example::\n\n            share = client.get_share(\"4ddfds\")\n            share.update(title=\"Example\") # Set title to Example\n            share.update()                # Remove title\n        \"\"\"\n        if 'title' in kwargs:\n            params = {\"title\": kwargs['title']}\n        else:\n            params = {\"title\": None}\n\n        response = GettRequest().post(\"/shares/%s/update?accesstoken=%s\" % (self.sharename, self.user.access_token()), params)\n\n        if response.http_status == 200:\n            self.__init__(self.user, **response.response)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef refresh(self):\n        response = GettRequest().get(\"/shares/%s\" % self.sharename)\n\n        if response.http_status == 200:\n            self.__init__(self.user, **response.response)", "response": "This method refreshes the object with current metadata from the Gett service."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_current_traceback(*, ignore_system_exceptions=False,\n                          show_hidden_frames=False, skip=0, exc):\n    \"\"\"Get the current exception info as `Traceback` object.  Per default\n    calling this method will reraise system exceptions such as generator exit,\n    system exit or others.  This behavior can be disabled by passing `False`\n    to the function as first parameter.\n    \"\"\"\n    info = sys.exc_info()\n    return get_traceback(info,\n                         ignore_system_exceptions=ignore_system_exceptions,\n                         show_hidden_frames=show_hidden_frames, skip=skip,\n                         exc=exc)", "response": "Get the current traceback as Traceback object."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef render_summary(self, include_title=True, request=None):\n        title = ''\n        frames = []\n        classes = ['traceback']\n        if not self.frames:\n            classes.append('noframe-traceback')\n\n        if include_title:\n            if self.is_syntax_error:\n                title = text_('Syntax Error')\n            else:\n                title = text_('Traceback <small>(most recent call last)'\n                              '</small>')\n\n        for frame in self.frames:\n            frames.append(\n                text_('<li%s>%s') % (\n                    frame.info and text_(' title=\"%s\"' % escape(frame.info)) or\n                    text_(''),\n                    frame.render()\n                ))\n\n        if self.is_syntax_error:\n            description_wrapper = text_('<pre class=syntaxerror>%s</pre>')\n        else:\n            description_wrapper = text_('<blockquote>%s</blockquote>')\n\n        vars = {\n            'classes': text_(' '.join(classes)),\n            'title': title and text_('<h3 class=\"traceback\">%s</h3>'\n                                     % title) or text_(''),\n            'frames': text_('\\n'.join(frames)),\n            'description': description_wrapper % escape(self.exception),\n        }\n        app = request.app\n        template = app.ps.jinja2.env.get_template('debugtoolbar/exception_summary.html')\n        return template.render(app=app, request=request, **vars)", "response": "Render the traceback for the interactive console."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nrenders the Full HTML page with the traceback info.", "response": "def render_full(self, request, lodgeit_url=None):\n        \"\"\"Render the Full HTML page with the traceback info.\"\"\"\n        app = request.app\n        root_path = request.app.ps.debugtoolbar.cfg.prefix\n        exc = escape(self.exception)\n        summary = self.render_summary(include_title=False, request=request)\n        token = request.app['debugtoolbar']['pdbt_token']\n\n        vars = {\n            'evalex': app.ps.debugtoolbar.cfg.intercept_exc == 'debug' and 'true' or 'false',\n            'console': 'console',\n            'lodgeit_url': lodgeit_url and escape(lodgeit_url) or '',\n            'title': exc,\n            'exception': exc,\n            'exception_type': escape(self.exception_type),\n            'summary': summary,\n            'plaintext': self.plaintext,\n            'plaintext_cs': re.sub('-{2,}', '-', self.plaintext),\n            'traceback_id': self.id,\n            'static_path': root_path + 'static/',\n            'token': token,\n            'root_path': root_path,\n            'url': root_path + 'exception?token=%s&tb=%s' % (token, self.id),\n        }\n        template = app.ps.jinja2.env.get_template('debugtoolbar/exception.html')\n        return template.render(app=app, request=request, **vars)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef code_timer(reset=False):\n    '''Sets a global variable for tracking the timer accross multiple\n    files '''\n\n    global CODE_TIMER\n    if reset:\n        CODE_TIMER = CodeTimer()\n    else:\n        if CODE_TIMER is None:\n            return CodeTimer()\n        else:\n            return CODE_TIMER", "response": "Sets a global variable for tracking the timer accross multiple\n    files"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef log(self, timer_name, node):\n        ''' logs a event in the timer '''\n        timestamp = time.time()\n        if hasattr(self, timer_name):\n            getattr(self, timer_name).append({\n                \"node\":node,\n                \"time\":timestamp})\n        else:\n            setattr(self, timer_name, [{\"node\":node, \"time\":timestamp}])", "response": "logs an event in the timer"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef print_timer(self, timer_name, **kwargs):\n        ''' prints the timer to the terminal\n\n            keyword args:\n                delete -> True/False  -deletes the timer after printing\n        '''\n        if hasattr(self, timer_name):\n            _delete_timer = kwargs.get(\"delete\", False)\n            print(\"|-------- {} [Time Log Calculation]-----------------|\".format(\\\n                    timer_name))\n            print(\"StartDiff\\tLastNodeDiff\\tNodeName\")\n            time_log = getattr(self, timer_name)\n            start_time = time_log[0]['time']\n            previous_time = start_time\n            for entry in time_log:\n                time_diff = (entry['time'] - previous_time) *1000\n                time_from_start = (entry['time'] - start_time) * 1000\n                previous_time = entry['time']\n                print(\"{:.1f}\\t\\t{:.1f}\\t\\t{}\".format(time_from_start,\n                                                      time_diff,\n                                                      entry['node']))\n            print(\"|--------------------------------------------------------|\")\n            if _delete_timer:\n                self.delete_timer(timer_name)", "response": "prints the timer to the terminal"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef check_cluster_exists(self, name):\n        self.kubeconf.open()\n        clusters = self.kubeconf.get_clusters()\n        names = [c['name'] for c in clusters]\n        if name in names:\n            return True\n        return False", "response": "Check if cluster exists."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef create(self, name, provider='AwsEKS'):\n        # ----- Create K8s cluster on provider -------\n        # Create cluster object\n        Cluster = getattr(providers, provider)\n        cluster = Cluster(name=name, ssh_key_name='zsailer')\n        cluster.create()\n\n        # -------- Add cluster to kubeconf -----------\n\n        # Add cluster to kubeconf\n        self.kubeconf.open()\n        self.kubeconf.add_cluster(\n            cluster.cluster_name,\n            server=cluster.endpoint_url,\n            certificate_authority_data=cluster.ca_cert\n        )\n\n        # Add a user to kubeconf\n        self.kubeconf.add_user(name)\n\n        # Add a user exec call for this provider.\n        self.kubeconf.add_to_user(\n            name,\n            **cluster.kube_user_data\n        )\n\n        # Add context mapping user to cluster.\n        self.kubeconf.add_context(\n            name,\n            cluster_name=cluster.cluster_name,\n            user_name=cluster.name\n        )\n\n        # Switch contexts.\n        self.kubeconf.set_current_context(name)\n\n        # Commit changes to file.\n        self.kubeconf.close()\n        \n        # ------ Setup autorization -------\n        kubectl('apply', input=cluster.get_auth_config())\n\n        # -------- Setup Storage ----------\n        kubectl('delete', 'storageclass', 'gp2')        \n        kubectl('apply', input=cluster.get_storage_config())\n\n        # ------- setup helm locally ------\n        kubectl(\n            '--namespace',\n            'kube-system',\n            'create',\n            'serviceaccount',\n            'tiller'\n        )\n\n        kubectl(\n            'create',\n            'clusterrolebinding',\n            'tiller',\n            '--clusterrole=cluster-admin',\n            '--serviceaccount=kube-system:tiller'\n        )\n\n        # -------- Initialize Helm -----------\n        helm(\n            'init',\n            '--service-account',\n            'tiller'\n        )\n\n        # --------- Secure Helm --------------\n        kubectl(\n            'patch',\n            'deployment',\n            'tiller-deploy',\n            namespace='kube-system',\n            type='json',\n            patch='[{\"op\": \"add\", \"path\": \"/spec/template/spec/containers/0/command\", \"value\": [\"/tiller\", \"--listen=localhost:44134\"]}]'\n        )", "response": "Create a Kubernetes cluster on a given provider."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ndelete a Kubernetes cluster.", "response": "def delete(self, name, provider='AwsEKS'):\n        \"\"\"Delete a Kubernetes cluster.\n        \"\"\"\n        # if self.check_cluster_exists(name) is False:\n        #     raise JhubctlError(\"Cluster name not found in availabe clusters.\")\n\n        # Create cluster object\n        Cluster = getattr(providers, provider)\n        cluster = Cluster(name)\n        cluster.delete()\n\n        # Remove from kubeconf\n        self.kubeconf.open()\n        self.kubeconf.remove_context(name)\n        self.kubeconf.remove_user(name)\n        self.kubeconf.remove_cluster(cluster.cluster_name)\n        self.kubeconf.close()"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nissues a GET request to IASystem with the given url and return a response in Collection + json format.", "response": "def __get_resource(dao, url):\n    \"\"\"\n    Issue a GET request to IASystem with the given url\n    and return a response in Collection+json format.\n    :returns: http response with content in json\n    \"\"\"\n    headers = {\"Accept\": \"application/vnd.collection+json\"}\n    response = dao.getURL(url, headers)\n    status = response.status\n    logger.debug(\"{} ==status==> {}\".format(url, status))\n\n    if status != 200:\n        message = str(response.data)\n\n        if status == 404:\n            # the URL not exists on the specific domain\n            return None\n\n        if status == 400:\n            if \"Term is out of range\" in message:\n                raise TermEvalNotCreated(url, status, message)\n\n        raise DataFailureException(url, status, message)\n\n    return json.loads(response.data)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef random_string(length=8, charset=None):\n    '''\n    Generates a string with random characters. If no charset is specified, only\n    letters and digits are used.\n\n    Args:\n        length (int) length of the returned string\n        charset (string) list of characters to choose from\n    Returns:\n        (str) with random characters from charset\n    Raises:\n        -\n    '''\n    if length < 1:\n        raise ValueError('Length must be > 0')\n    if not charset:\n        charset = string.letters + string.digits\n    return ''.join(random.choice(charset) for unused in xrange(length))", "response": "Generates a random string from the charset."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef str2dict(str_in):\n    '''\n    Extracts a dict from a string.\n\n    Args:\n        str_in (string) that contains python dict\n    Returns:\n        (dict) or None if no valid dict was found\n    Raises:\n        -\n    '''\n    dict_out = safe_eval(str_in)\n    if not isinstance(dict_out, dict):\n        dict_out = None\n    return dict_out", "response": "Extracts a dict from a string that contains python dict\n   "}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nextracts a tuple from a string that contains python tuple", "response": "def str2tuple(str_in):\n    '''\n    Extracts a tuple from a string.\n\n    Args:\n        str_in (string) that contains python tuple\n    Returns:\n        (dict) or None if no valid tuple was found\n    Raises:\n        -\n    '''\n    tuple_out = safe_eval(str_in)\n    if not isinstance(tuple_out, tuple):\n        tuple_out = None\n    return tuple_out"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nextracts the keys from a string that represents a dict and returns them sorted by key.", "response": "def str2dict_keys(str_in):\n    '''\n    Extracts the keys from a string that represents a dict and returns them\n    sorted by key.\n\n    Args:\n        str_in (string) that contains python dict\n    Returns:\n        (list) with keys or None if no valid dict was found\n    Raises:\n        -\n    '''\n    tmp_dict = str2dict(str_in)\n    if tmp_dict is None:\n        return None\n    return sorted([k for k in tmp_dict])"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nextracting the values from a string that represents a dict and returns them sorted by key.", "response": "def str2dict_values(str_in):\n    '''\n    Extracts the values from a string that represents a dict and returns them\n    sorted by key.\n\n    Args:\n        str_in (string) that contains python dict\n    Returns:\n        (list) with values or None if no valid dict was found\n    Raises:\n        -\n    '''\n    tmp_dict = str2dict(str_in)\n    if tmp_dict is None:\n        return None\n    return [tmp_dict[key] for key in sorted(k for k in tmp_dict)]"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconvert a decimal string to an integer", "response": "def decstr2int(dec_str, decimals):\n    '''\n    Returns an integer that has the value of the decimal string:\n        dec_str*10^decimals\n\n    Arguments:\n        dec_str (string) that represents a decimal number\n        decimals (int): number of decimals for creating the integer output\n    Returns:\n        (int)\n    Raises:\n        ValueError if dec_string is not a valid decimal string\n        TypeError if decimals is not an integer\n    Note: values may be truncated (not rounded).\n    '''\n    if not isinstance(decimals, int):\n        raise TypeError('decimals must be an integer')\n    try:\n        dollars, cents = dec_str.split('.')\n    except ValueError:\n        if '.' not in dec_str:\n            dollars = dec_str\n            cents = '0'\n        else:\n            raise ValueError('Invalid decimal string')\n    else:\n        if len(cents) < decimals:\n            cents = cents.ljust(decimals, '0')\n        elif decimals < 1:\n            cents = '0'\n        elif len(cents) > decimals:\n            cents = cents[:decimals]\n    try:\n        cents = int(cents)\n    except:\n        cents = 0\n    try:\n        return int(int(dollars) * (10 ** decimals)) + cents\n    except:\n        raise ValueError('Invalid decimal string')"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef expr_to_str(n, l=None):\n    op = n[0]\n    if op.startswith('_') and op.endswith('_'):\n        op = op.strip('_')\n        if op == 'var':\n            return n[1]\n        elif op == 'literal':\n            if isinstance(n[1], basestring):\n                return \"'%s'\" % n[1]\n            return str(n[1])\n        elif op == 'cast':\n            return \"(%s)::%s\" % (expr_to_str(n[1]), n[2])\n    elif op in '+-*/':\n        return \"(%s) %s (%s)\" % (expr_to_str(n[1]), op, expr_to_str(n[2]))\n    elif op == \"extract\":\n        return \"extract( %s from %s )\" % (n[1], expr_to_str(n[2]))\n    else:\n        arg = ','.join(map(expr_to_str, n[1:]))\n        return \"%s(%s)\" % (op, arg)", "response": "construct SQL string from expression node n"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_vars(n):\n    op = n[0]\n    if op.startswith('_') and op.endswith('_'):\n        op = op.strip('_')\n        if op == 'var':\n            return [n[1]]\n        return []\n    else:\n        ret = []\n        for c in n[1:]:\n            vs = get_vars(c)\n            if vs:\n                ret.extend(vs)\n        return ret", "response": "extract variables from expression node\n   "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef construct_func_expr(n):\n    op = n[0]\n    if op.startswith('_') and op.endswith('_'):\n        op = op.strip('_')\n        if op == 'var':\n            return Var(str(n[1]))\n        elif op == 'literal':\n            if isinstance(n[1], basestring):\n                raise \"not implemented\"\n            return Constant(n[1])\n        elif op == 'cast':\n            raise \"not implemented\"\n    elif op in '+-/*':\n        return ArithErrFunc(op, *map(construct_func_expr,n[1:]))\n    else:\n        klass = __agg2f__.get(op, None)\n        if klass:\n            return klass(map(construct_func_expr, n[1:]))\n        raise \"no klass\"", "response": "construct the function expression for a single element"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nfetches an api record by its name", "response": "def fetch_api_by_name(api_name):\n    \"\"\" Fetch an api record by its name \"\"\"\n    api_records = console.get_rest_apis()['items']\n    matches = filter(lambda x: x['name'] == api_name, api_records)\n    if not matches:\n        return None\n    return matches[0]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef fetch_method(api_id, resource_id, verb):\n    return console.get_method(\n            restApiId=api_id,\n            resourceId=resource_id,\n            httpMethod=verb)", "response": "Fetch extra metadata for this particular method"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the effective HTTP method of a request.", "response": "def request_method(request):\n    '''Returns the effective HTTP method of a request. To support the entire range of HTTP methods\n    from HTML forms (which only support GET and POST), an HTTP method may be emulated by\n    setting a POST parameter named \"_method\" to the name of the HTTP method to be emulated.\n    \n    Example HTML:\n        <!-- Submits a form using the PUT method -->\n        \n        <form>\n            <input type=\"text\" name=\"name\" value=\"value\" />\n            <button type=\"submit\" name=\"_method\" value=\"put\">Update</button>\n        </form>\n    \n    Args:\n        request: an HttpRequest\n    \n    Returns:\n        An upper-case string naming the HTTP method (like django.http.HttpRequest.method)\n    '''\n    \n    # For security reasons POST is the only method that supports HTTP method emulation.\n    # For example, if POST requires csrf_token, we don't want POST methods to be called via\n    # GET (thereby bypassing CSRF protection). POST has the most limited semantics, and it\n    # is therefore safe to emulate HTTP methods with less-limited semantics. See\n    # http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html (\"Safe and Idempotent Methods\")\n    # for details.\n\n    if request.method == 'POST' and '_method' in request.POST:\n        method = request.POST['_method'].upper()\n    else:\n        method = request.method\n        \n    return method"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning voltage in mV", "response": "def battery_voltage(self):\n        \"\"\" Returns voltage in mV \"\"\"\n        msb = self.bus.read_byte_data(AXP209_ADDRESS, BATTERY_VOLTAGE_MSB_REG)\n        lsb = self.bus.read_byte_data(AXP209_ADDRESS, BATTERY_VOLTAGE_LSB_REG)\n        voltage_bin = msb << 4 | lsb & 0x0f\n        return voltage_bin * 1.1"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef battery_charge_current(self):\n        msb = self.bus.read_byte_data(AXP209_ADDRESS, BATTERY_CHARGE_CURRENT_MSB_REG)\n        lsb = self.bus.read_byte_data(AXP209_ADDRESS, BATTERY_CHARGE_CURRENT_LSB_REG)\n        # (12 bits)\n        charge_bin = msb << 4 | lsb & 0x0f\n        # 0 mV -> 000h,\t0.5 mA/bit\tFFFh -> 1800 mA\n        return charge_bin * 0.5", "response": "Returns current in mA"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef battery_discharge_current(self):\n        msb = self.bus.read_byte_data(AXP209_ADDRESS, BATTERY_DISCHARGE_CURRENT_MSB_REG)\n        lsb = self.bus.read_byte_data(AXP209_ADDRESS, BATTERY_DISCHARGE_CURRENT_LSB_REG)\n        # 13bits\n        discharge_bin = msb << 5 | lsb & 0x1f\n        # 0 mV -> 000h,\t0.5 mA/bit\t1FFFh -> 1800 mA\n        return discharge_bin * 0.5", "response": "Returns current in mA"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef internal_temperature(self):\n        temp_msb = self.bus.read_byte_data(AXP209_ADDRESS, INTERNAL_TEMPERATURE_MSB_REG)\n        temp_lsb = self.bus.read_byte_data(AXP209_ADDRESS, INTERNAL_TEMPERATURE_LSB_REG)\n        # MSB is 8 bits, LSB is lower 4 bits\n        temp = temp_msb << 4 | temp_lsb & 0x0f\n        # -144.7c -> 000h,\t0.1c/bit\tFFFh -> 264.8c\n        return temp*0.1-144.7", "response": "Returns the internal temperature in celsius C"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef copen(fileobj, mode='rb', **kwargs):\n\n    algo = io.open  # Only used as io.open in write mode\n    mode = mode.lower().strip()\n    modules = {}  # Later populated by compression algorithms\n    write_mode = False if mode.lstrip('U')[0] == 'r' else True\n    kwargs['mode'] = mode\n\n    # Currently supported compression algorithms\n    modules_to_import = {\n        'bz2': 'BZ2File',\n        'gzip': 'GzipFile',\n        'lzma': 'LZMAFile'\n    }\n\n    # Dynamically import compression libraries and warn about failures\n    for mod, _class in modules_to_import.items():\n        try:\n            modules[_class] = getattr(import_module(mod), _class)\n        except (ImportError, AttributeError) as e:\n            modules[_class] = open\n            warn('Cannot process {0} files due to following error:'\n                 '{1}{2}{1}You will need to install the {0} library to '\n                 'properly use these files. Currently, such files will '\n                 'open in \"text\" mode.'.format(mod, linesep, e))\n\n    # Write mode\n    if write_mode is True:\n\n        # Map file extensions to decompression classes\n        algo_map = {\n            'bz2': modules['BZ2File'],\n            'gz':  modules['GzipFile'],\n            'xz':  modules['LZMAFile']\n        }\n\n        # Determine the compression algorithm via the file extension\n        ext = fileobj.split('.')[-1]\n        try:\n            algo = algo_map[ext]\n        except KeyError:\n            pass\n\n    # Read mode\n    else:\n\n        algo = io.TextIOWrapper  # Default to plaintext buffer\n\n        # Magic headers of encryption formats\n        file_sigs = {\n            b'\\x42\\x5a\\x68': modules['BZ2File'],\n            b'\\x1f\\x8b\\x08': modules['GzipFile'],\n            b'\\xfd7zXZ\\x00': modules['LZMAFile']\n        }\n\n        # Open the file, buffer it, and identify the compression algorithm\n        fileobj = io.BufferedReader(io.open(fileobj, 'rb'))\n        max_len = max(len(x) for x in file_sigs.keys())\n        start = fileobj.peek(max_len)\n        for sig in file_sigs.keys():\n            if start.startswith(sig):\n                algo = file_sigs[sig]\n                break  # Stop iterating once a good signature is found\n\n    # Filter all **kwargs by the args accepted by the compression algorithm\n    algo_args = set(getfullargspec(algo).args)\n    good_args = set(kwargs.keys()).intersection(algo_args)\n    _kwargs = {arg: kwargs[arg] for arg in good_args}\n\n    # Open the file using parameters defined above and store in namespace\n    if write_mode is True:\n        handle = algo(fileobj, **_kwargs)\n    else:\n        try:  # For algorithms that need to be explicitly given a fileobj\n            handle = algo(fileobj=fileobj, **_kwargs)\n        except TypeError:  # For algorithms that detect file objects\n            handle = algo(fileobj, **_kwargs)\n\n    return handle", "response": "Detects and opens compressed file for reading and writing."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the names of security groups referred in the retrieved rules.", "response": "def _get_sg_name_dict(self, data, page_size, no_nameconv):\n        \"\"\"Get names of security groups referred in the retrieved rules.\n\n        :return: a dict from secgroup ID to secgroup name\n        \"\"\"\n        if no_nameconv:\n            return {}\n        neutron_client = self.get_client()\n        search_opts = {'fields': ['id', 'name']}\n        if self.pagination_support:\n            if page_size:\n                search_opts.update({'limit': page_size})\n        sec_group_ids = set()\n        for rule in data:\n            for key in self.replace_rules:\n                if rule.get(key):\n                    sec_group_ids.add(rule[key])\n        sec_group_ids = list(sec_group_ids)\n\n        def _get_sec_group_list(sec_group_ids):\n            search_opts['id'] = sec_group_ids\n            return neutron_client.list_security_groups(\n                **search_opts).get('security_groups', [])\n\n        try:\n            secgroups = _get_sec_group_list(sec_group_ids)\n        except exceptions.RequestURITooLong as uri_len_exc:\n            # Length of a query filter on security group rule id\n            # id=<uuid>& (with len(uuid)=36)\n            sec_group_id_filter_len = 40\n            # The URI is too long because of too many sec_group_id filters\n            # Use the excess attribute of the exception to know how many\n            # sec_group_id filters can be inserted into a single request\n            sec_group_count = len(sec_group_ids)\n            max_size = ((sec_group_id_filter_len * sec_group_count) -\n                        uri_len_exc.excess)\n            chunk_size = max_size // sec_group_id_filter_len\n            secgroups = []\n            for i in range(0, sec_group_count, chunk_size):\n                secgroups.extend(\n                    _get_sec_group_list(sec_group_ids[i: i + chunk_size]))\n\n        return dict([(sg['id'], sg['name'])\n                     for sg in secgroups if sg['name']])"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef load(self):\n        pg = self.usr.getPage(\"http://www.neopets.com/bank.phtml\")\n        \n        # Verifies account exists\n        if not \"great to see you again\" in pg.content:\n            logging.getLogger(\"neolib.user\").info(\"Could not load user's bank. Most likely does not have an account.\", {'pg': pg})\n            raise noBankAcct\n            \n        self.__loadDetails(pg)", "response": "Loads the user s account details and \n            Raises parseException\n       "}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef deposit(self, amount):\n        pg = self.usr.getPage(\"http://www.neopets.com/bank.phtml\")\n        \n        if self.usr.nps < int(amount):\n            raise notEnoughNps\n            \n        form = pg.form(action=\"process_bank.phtml\")\n        form.update({'type': 'deposit', 'amount': str(amount)})\n        form.usePin = True\n        pg = form.submit()\n        \n        # Success redirects to bank page\n        if \"It's great to see you again\" in pg.content:\n            self.__loadDetails(pg)\n            return True\n        else:\n            logging.getLogger(\"neolib.user\").info(\"Failed to deposit NPs for unknown reason. User NPs: \" + str(self.usr.nps) + \". Amount: \" + str(amount), {'pg': pg})\n            return False", "response": "Deposit specified neopoints into the user s account returns result\n           "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef withdraw(self, amount):\n        pg = self.usr.getPage(\"http://www.neopets.com/bank.phtml\")\n        \n        try:\n            results = pg.find(text = \"Account Type:\").parent.parent.parent.find_all(\"td\", align=\"center\")\n            self.balance = results[1].text.replace(\" NP\", \"\")\n        except Exception:\n            logging.getLogger(\"neolib.user\").exception(\"Could not parse user's bank balance.\", {'pg': pg})\n        \n        if int(amount) > int(self.balance.replace(\",\", \"\")):\n            raise notEnoughBalance\n            \n        form = pg.form(action=\"process_bank.phtml\")\n        form.update({'type': 'withdraw', 'amount': str(amount)})\n        form.usePin = True\n        pg = form.submit()\n        \n        # Success redirects to bank page\n        if \"It's great to see you again\" in pg.content:\n            self.__loadDetails(pg)\n            return True\n        else:\n            logging.getLogger(\"neolib.user\").info(\"Failed to withdraw NPs for unknown reason. User NPs: \" + str(self.usr.nps) + \". Amount: \" + str(amount), {'pg': pg})\n            return False", "response": "Withdraws specified neopoints from the user s account returns result\n          "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncollecting user s daily interest returns result alid", "response": "def collectInterest(self):\n        \"\"\" Collects user's daily interest, returns result\n           \n        Returns\n           bool - True if successful, False otherwise\n        \"\"\"\n        if self.collectedInterest:\n            return False\n            \n        pg = self.usr.getPage(\"http://www.neopets.com/bank.phtml\")\n        \n        form = pg.form(action=\"process_bank.phtml\")\n        form['type'] = \"interest\"\n        pg = form.submit()\n        \n        # Success redirects to bank page\n        if \"It's great to see you again\" in pg.content:\n            self.__loadDetails(pg)\n            return True\n        else:\n            logging.getLogger(\"neolib.user\").info(\"Failed to collect daily interest for unknown reason.\", {'pg': pg})\n            return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nchecks if G is connected and return list of sets.", "response": "def connected_components(G):\r\n    \"\"\"\r\n    Check if G is connected and return list of sets. Every\r\n    set contains all vertices in one connected component.\r\n    \"\"\"\r\n    result = []\r\n    vertices = set(G.vertices)\r\n    while vertices:\r\n        n = vertices.pop()\r\n        group = {n}\r\n        queue = Queue()\r\n        queue.put(n)\r\n        while not queue.empty():\r\n            n = queue.get()\r\n            neighbors = set(G.vertices[n])\r\n            neighbors.difference_update(group)\r\n            vertices.difference_update(neighbors)\r\n            group.update(neighbors)\r\n            for element in neighbors:\r\n                queue.put(element)\r\n        result.append(group)\r\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a tree that is a weighted undirected graph where the minimum spanning tree is at least start and the minimum spanning tree is at least weight.", "response": "def prim(G, start, weight='weight'):\r\n    \"\"\"\r\n    Algorithm for finding a minimum spanning\r\n    tree for a weighted undirected graph.\r\n    \"\"\"\r\n    if len(connected_components(G)) != 1:\r\n        raise GraphInsertError(\"Prim algorithm work with connected graph only\")\r\n    if start not in G.vertices:\r\n        raise GraphInsertError(\"Vertex %s doesn't exist.\" % (start,))\r\n    pred = {}\r\n    key = {}\r\n    pqueue = {}\r\n    lowest = 0\r\n    for edge in G.edges:\r\n        if G.edges[edge][weight] > lowest:\r\n            lowest = G.edges[edge][weight]\r\n    for vertex in G.vertices:\r\n        pred[vertex] = None\r\n        key[vertex] = 2 * lowest\r\n    key[start] = 0\r\n    for vertex in G.vertices:\r\n        pqueue[vertex] = key[vertex]\r\n    while pqueue:\r\n        current = popmin(pqueue, lowest)\r\n        for neighbor in G.vertices[current]:\r\n            if (neighbor in pqueue and\r\n                    G.edges[(current, neighbor)][weight] < key[neighbor]):\r\n                pred[neighbor] = current\r\n                key[neighbor] = G.edges[(current, neighbor)][weight]\r\n                pqueue[neighbor] = G.edges[(current, neighbor)][weight]\r\n    return pred"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nupdating the anomalous scores and products summaries.", "response": "def update(self):\n        \"\"\"Update reviewers' anomalous scores and products' summaries.\n\n        Returns:\n          maximum absolute difference between old summary and new one, and\n          old anomalous score and new one.\n        \"\"\"\n        if self.updated:\n            return 0\n\n        res = super(BipartiteGraph, self).update()\n        self.updated = True\n        return res"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef find(cls, api_name):\n        if api_name in cls.apis_by_name:\n            return cls.apis_by_name[api_name]\n        api = cls(api_name)\n        api._fetch_from_aws()\n        if api.exists_in_aws:\n            api._fetch_resources()\n        cls.apis_by_name[api_name] = api\n        return api", "response": "Find or create an API model object by name"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_instance(in_memory=False, config_path=None, config_name=None):\n  global __conf\n\n  if __conf is None:\n    __conf = Configuration(in_memory=in_memory, custom_cfg_path=config_path, config_name=config_name)\n\n  return __conf", "response": "Returns a Configuration instance."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _load_from_configs(self, filename):\n    config_filename = os.path.join(self._config_path, filename)\n    if os.path.exists(config_filename):\n      try:\n        f = open(config_filename, 'r')\n        content = ''.join(f.readlines())\n        f.close()\n        return content\n      except Exception as err:\n        raise err\n    else:\n      raise IOError(\"File not found: {}\".format(config_filename))", "response": "Load content of file from configuration directory"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nload application configuration and modules", "response": "def load(self):\n    \"\"\"\n     Load application configuration\n    \"\"\"\n    try:\n      if not self.__in_memory:\n        self._json = json.loads(self._load_from_configs(self._main_config))\n        # ToDo: make this via extension for root logger\n        # self._log = aLogger.getLogger(__name__, cfg=self)  # reload logger using loaded configuration\n        self._load_modules()\n      else:\n        self._json = {}\n      # parse command line, currently used for re-assign settings in configuration, but can't be used as replacement\n      self._load_from_commandline()\n    except Exception as err:\n      self._json = None\n      raise"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef exists(self, path):\n    if self._json is None:\n      return False\n\n    node = self._json\n    path_arr = path.split('.')\n    while len(path_arr) > 0:\n      path_item = path_arr.pop(0)\n      if path_item in node and len(path_arr) == 0:\n        return True\n      elif path_item in node and len(path_arr) > 0:\n        node = node[path_item]\n      else:\n        return False\n\n    return False", "response": "Check if a property exists in the object"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get(self, path, default=None, check_type=None, module_name=None):\n    if self._json is not None:\n      # process whole json or just concrete module\n      node = self._json if module_name is None else self.get_module_config(module_name)\n      path_data = path.split('.')\n      try:\n        while len(path_data) > 0:\n          node = node[path_data.pop(0)]\n\n        if check_type is not None:\n          return check_type(node)\n        else:\n          return node\n      except KeyError:\n        if default is not None:\n          return default\n        else:\n          raise KeyError(\"Key {} not present\".format(path))\n      except ValueError:\n        if default is not None:\n          return default\n        else:\n          raise KeyError(\"Key {} has a wrong format\".format(path))\n    else:\n      return \"\"", "response": "Get option property\n\n    :param path: full path to the property with name\n    :param default: default value if original is not present\n    :param check_type: cast param to passed type, if fail, default will returned\n    :param module_name: get property from module name\n    :return:"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets module configuration from separate file or None if not found.", "response": "def get_module_config(self, name):\n    \"\"\"\n     Return module configuration loaded from separate file or None\n    \"\"\"\n    if self.exists(\"modules\"):\n      if name in self._json[\"modules\"] and not isinstance(self._json[\"modules\"][name], str):\n        return self._json[\"modules\"][name]\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn the content of the specified hook.", "response": "def get_hook(hook_name):\n    \"\"\"Returns the specified hook.\n\n    Args:\n        hook_name (str)\n\n    Returns:\n        str - (the content of) the hook\n\n    Raises:\n        HookNotFoundError\n    \"\"\"\n    if not pkg_resources.resource_exists(__name__, hook_name):\n        raise HookNotFoundError\n    return pkg_resources.resource_string(__name__, hook_name)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nprint the end banner and raises ProgressOK exception.", "response": "def end(self, s=None, post=None, noraise=False):\n        \"\"\" Prints the end banner and raises ``ProgressOK`` exception\n\n        When ``noraise`` flag is set to ``True``, then the exception is not\n        raised, and progress is allowed to continue.\n\n        If ``post`` function is supplied it is invoked with no arguments after\n        the close banner is printed, but before exceptions are raised. The\n        ``post`` function takes no arguments.\n        \"\"\"\n        s = s or self.end_msg\n        self.printer(self.color.green(s))\n        if post:\n            post()\n        if noraise:\n            return\n        raise ProgressOK()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef abrt(self, s=None, post=None, noraise=False):\n        s = s or self.abrt_msg\n        self.printer(self.color.red(s))\n        if post:\n            post()\n        if noraise:\n            return\n        raise ProgressAbrt()", "response": "Prints the abrt banner and raises ProgressAbrt exception."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nprints the progress indicator", "response": "def prog(self, s=None):\n        \"\"\" Prints the progress indicator \"\"\"\n        s = s or self.prog_msg\n        self.printer(s, end='')"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ngenerate argument pairs for queries like where ( id = 1 2 )", "response": "def _in_items(self, restrictions):\n        \"\"\"Generate argument pairs for queries like where(id=[1, 2])\"\"\"\n        def build_in(table, name, value):\n            return \"{}.{} IN ({})\".format(table, name,\n                                          \", \".join([\"?\"] * len(value)))\n\n        in_items = self._build_where(restrictions, for_in=True)\n        names = [build_in(*restriction) for restriction in in_items]\n        values = list(chain(*[item[2] for item in in_items]))\n        return (names, values)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _custom_items(self, restrictions):\n        def scope_name(query, table):\n            # The first entry in the query is the column\n            # If the column already has a \".\", that means that the table has\n            # already been chosen\n            for splitter in (\" and \", \" or \"):\n                split_query = re.split(splitter, query, re.IGNORECASE)\n                query = splitter.join(\"{}.{}\".format(table, entry)\n                                      if \".\" not in entry else entry\n                                      for entry in split_query)\n            return query\n\n        names = [scope_name(restriction[0], self.table_name)\n                 for restriction in restrictions]\n        values = list(chain(\n            *[restriction[1:] for restriction in restrictions]))\n        return (names, values)", "response": "Generate argument pairs for queries like where."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _standard_items(self, restrictions):\n        standard_items = self._build_where(restrictions, for_in=False)\n        names = [\"{}.{} == ?\".format(pair[0], pair[1])\n                 for pair in standard_items]\n        values = [item[2] for item in standard_items]\n        return (names, values)", "response": "Generate argument pairs for queries like where ( id = 2 )"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef order_by(self, **kwargs):\n        if kwargs:\n            col, order = kwargs.popitem()\n            self.order_clause = \"order by {col} {order} \".format(\n                col=col, order=order)\n        return self", "response": "Analog to SQL ORDER BY."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef select(self, *attributes):\n        namespaced_attributes = [\n            \"{table}.{attr}\".format(table=self.table_name, attr=attr)\n            for attr in attributes\n        ]\n        cmd = ('select {attrs} from {table} '\n               '{join_clause}{where_clause}{order_clause}'\n               '{group_clause}{having_clause}{limit_clause}').format(\n            table=self.table_name,\n            attrs=\", \".join(namespaced_attributes),\n            where_clause=self.where_clause,\n            join_clause=self.join_clause,\n            order_clause=self.order_clause,\n            group_clause=self.group_clause,\n            having_clause=self.having_clause,\n            limit_clause=self.limit_clause,\n        ).rstrip()\n        return Repo.db.execute(cmd, self.where_values + self.having_values + \\\n                               self.limit_value)", "response": "Select the passed +attributes + from the table."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncounting the number of records in the table subject to the query.", "response": "def count(self):\n        \"\"\"\n        Count the number of records in the table, subject to the query.\n        \"\"\"\n        cmd = (\"select COUNT(*) from {table} \"\n               \"{join_clause}{where_clause}{order_clause}\").format(\n                    table=self.table_name,\n                    where_clause=self.where_clause,\n                    join_clause=self.join_clause,\n                    order_clause=self.order_clause).rstrip()\n        return Repo.db.execute(cmd, self.where_values)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ninserting the passed data into the table.", "response": "def insert(self, **data):\n        \"\"\"\n        Insert the passed +data+ into the table. Raises Invalid if a where\n        clause is present (i.e. no INSERT INTO table WHERE)\n        \"\"\"\n        if self.where_clause:\n            raise Invalid(\"Cannot insert with 'where' clause.\")\n        # Ensure that order is preserved\n        data = data.items()\n        cmd = \"insert into {table} ({attrs}) values ({values})\".format(\n            table=self.table_name,\n            attrs=\", \".join(entry[0] for entry in data),\n            values=\", \".join([\"?\"] * len(data)),\n        )\n        handle = Repo.db.execute(cmd, [entry[1] for entry in data])\n        # Return the id of the added row\n        return handle.lastrowid"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nupdates all records in the table with + data +. Often combined with where + self. where_values +.", "response": "def update(self, **data):\n        \"\"\"\n        Update records in the table with +data+. Often combined with `where`,\n        as it acts on all records in the table unless restricted.\n\n        ex)\n\n        >>> Repo(\"foos\").update(name=\"bar\")\n        UPDATE foos SET name = \"bar\"\n        \"\"\"\n        data = data.items()\n        update_command_arg = \", \".join(\"{} = ?\".format(entry[0])\n                                       for entry in data)\n        cmd = \"update {table} set {update_command_arg} {where_clause}\".format(\n            update_command_arg=update_command_arg,\n            where_clause=self.where_clause,\n            table=self.table_name).rstrip()\n        Repo.db.execute(cmd, [entry[1] for entry in data] + self.where_values)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nremoving entries from the table. Often combined with where.", "response": "def delete(self):\n        \"\"\"\n        Remove entries from the table. Often combined with `where`, as it acts\n        on all records in the table unless restricted.\n        \"\"\"\n        cmd = \"delete from {table} {where_clause}\".format(\n            table=self.table_name,\n            where_clause=self.where_clause\n        ).rstrip()\n        Repo.db.execute(cmd, self.where_values)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef connect_db(Repo, database=\":memory:\"):\n        Repo.db = sqlite3.connect(database,\n                                  detect_types=sqlite3.PARSE_DECLTYPES)\n        return Repo.db", "response": "Connect a Repo to a database with path + database."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef _trace(self, frame, event, arg_unused):\n        cur_time = time.time()\n\n        lineno = frame.f_lineno\n        depth = self.depth\n\n        filename = inspect.getfile(frame)\n\n        if self.last_exc_back:\n            if frame == self.last_exc_back:\n                self.data['time_spent'] += (cur_time - self.start_time)\n                self.depth -= 1\n\n                self.data = self.data_stack.pop()\n\n            self.last_exc_back = None\n\n        if event == 'call':\n            # Update our state\n            self.depth += 1\n\n            if self.log:\n                print >> sys.stdout, '%s >> %s:%s' % (' ' * (depth - 1), filename, frame.f_code.co_name)\n\n            # origin line number (where it was called from)\n            o_lineno = frame.f_back.f_lineno\n\n            if self.pause_until is not None:\n                if depth == self.pause_until:\n                    self.pause_until = None\n                else:\n                    return self._trace\n\n            if o_lineno not in self.data['lines']:\n                self.pause_until = depth\n\n                return self._trace\n\n            # Append it to the stack\n            self.data_stack.append(self.data)\n\n            call_sig = '%s:%s' % (inspect.getfile(frame), frame.f_code.co_name)\n\n            if call_sig not in self.data['children']:\n                self.data['children'][o_lineno][call_sig] = self._get_struct(frame, event)\n\n            self.data = self.data['children'][o_lineno][call_sig]\n\n            self.data['num_calls'] += 1\n\n        elif event == 'line':\n            # Record an executed line.\n            if self.pause_until is None and lineno in self.data['lines']:\n                self.data['lines'][lineno]['num_calls'] += 1\n                self.data['lines'][lineno]['time_spent'] += (cur_time - self.start_time)\n\n            if self.log:\n                print >> sys.stdout, '%s -- %s:%s executing line %d' % (' ' * (depth - 1), filename, frame.f_code.co_name, lineno)\n\n        elif event == 'return':\n            timing = (cur_time - self.start_time)\n\n            # Leaving this function, pop the filename stack.\n            if self.pause_until is None:\n                self.data['time_spent'] += timing\n                self.data = self.data_stack.pop()\n                self.data['time_spent'] += timing\n                # self.data['lines'][lineno]['num_calls'] += 1\n                # self.data['lines'][lineno]['time_spent'] += (cur_time - self.start_time)\n\n            if self.log:\n                print >> sys.stdout, '%s << %s:%s %.3fs' % (' ' * (depth - 1), filename, frame.f_code.co_name, timing)\n\n            self.depth -= 1\n\n        elif event == 'exception':\n            self.last_exc_back = frame.f_back\n            self.last_exc_firstlineno = frame.f_code.co_firstlineno\n\n        return self._trace", "response": "Trace the current state of the object."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nstarting this Tracer. Return a Python function suitable for use with sys.settrace().", "response": "def start(self, origin):\n        \"\"\"\n        Start this Tracer.\n\n        Return a Python function suitable for use with sys.settrace().\n        \"\"\"\n        self.start_time = time.time()\n        self.pause_until = None\n        self.data.update(self._get_struct(origin, 'origin'))\n        self.data_stack.append(self.data)\n        sys.settrace(self._trace)\n        return self._trace"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nresolve dotted names in function arguments Usage: >>> @resolver('obj') >>> def func(param, obj): >>> assert isinstance(param, str) >>> assert not isinstance(obj, str) >>> >>> func('os.path', 'sys.exit')", "response": "def resolver(*for_resolve, attr_package='__package_for_resolve_deco__'):\n    \"\"\" Resolve dotted names in function arguments\n\n    Usage:\n\n        >>> @resolver('obj')\n        >>> def func(param, obj):\n        >>>     assert isinstance(param, str)\n        >>>     assert not isinstance(obj, str)\n        >>>\n        >>> func('os.path', 'sys.exit')\n    \"\"\"\n    def decorator(func):\n        spec = inspect.getargspec(func).args\n        if set(for_resolve) - set(spec):\n            raise ValueError('bad arguments')\n\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            args = list(args)\n\n            if args and attr_package:\n                package = getattr(args[0], attr_package, None)\n            else:\n                package = None\n\n            for item in for_resolve:\n                n = spec.index(item)\n                if n >= len(args):\n                    continue\n\n                if n is not None and isinstance(args[n], str):\n                    args[n] = resolve(args[n], package)\n\n            for kw, value in kwargs.copy().items():\n                if kw in for_resolve and isinstance(value, str):\n                    kwargs[kw] = resolve(value, package)\n\n            return func(*args, **kwargs)\n\n        return wrapper\n\n    return decorator"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef append(self, name, value=None, sublist=None, seq=None):\n        if sublist is None:\n            sublist = []\n        new_seq = lib._seq(self, seq)\n        new_tuple = (name, value, sublist, new_seq)\n        self.data.append(new_tuple)\n        return", "response": "Add one name value entry to the main context of the rolne."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding one name value entry to the main context of the rolne and return the index number for the newly inserted entry.", "response": "def append_index(self, name, value=None, sublist=None, seq=None):\n        \"\"\"Add one name/value entry to the main context of the rolne and\n        return the index number for the new entry.\n\n        If you are wanting to \"append\" another rolne, see the 'extend'\n        method instead.\n\n        Example of use:\n\n        >>> # setup an example rolne first\n        >>> my_var = rolne()\n        >>> index = my_var.append_index(\"item\", \"zing\")\n        >>> print index\n        0\n        >>> my_var[\"item\", \"zing\", index].append(\"size\", \"4\")\n        >>> my_var[\"item\", \"zing\", index].append(\"color\", \"red\")\n        >>> print my_var\n        %rolne:\n        item = zing\n            size = 4\n            color = red\n        <BLANKLINE>\n        >>> index = my_var.append_index(\"item\", \"zing\")\n        >>> print index\n        1\n        >>> my_var[\"item\", \"zing\", index].append(\"size\", \"2\")\n        >>> my_var[\"item\", \"zing\", index].append(\"color\", \"blue\")\n        >>> print my_var\n        %rolne:\n        item = zing\n            size = 4\n            color = red\n        item = zing\n            size = 2\n            color = blue\n        <BLANKLINE>\n\n        .. versionadded:: 0.1.4\n        \n        :param name:\n           The key name of the name/value pair.\n        :param value:\n           The key value of the name/value pair. If not passed, then the value\n           is assumed to be None.\n        :param sublist:\n           An optional parameter that also appends a subtending list of entries.\n           It is not recommended that this parameter be used.\n        :returns:\n           An integer representing the index of the newly inserted name/pair.\n        \"\"\"\n        if sublist is None:\n            sublist = []\n        new_tuple = (name, value, sublist, lib._seq(self, seq))\n        self.data.append(new_tuple)\n        index = len(self.list_values(name, value)) - 1\n        return index"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef upsert(self, name, value=None, seq=None):\n        for ctr, entry in enumerate(self.data):\n            if entry[TNAME]==name:\n                new_tuple = (name, value, entry[TLIST], entry[TSEQ])\n                self.data[ctr]=new_tuple\n                return False\n        new_tuple = (name, value, [], lib._seq(self, seq))\n        self.data.append(new_tuple)\n        return True", "response": "Add one name value entry to the main context of the rolne but\n        only if the entry with that name does not already exist. Returns True if the entry was inserted otherwise False."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef register_view(design_doc, full_set=True):\n    def _injector(doc):\n        if not isinstance(doc, type) or not issubclass(doc, Document):\n            raise TypeError(\"Class must be a cbwrapper 'Document' subclass.\")\n        doc.__view_name__ = design_doc\n        doc.full_set = full_set\n        ViewSync._documents.add(doc)\n        return doc\n    return _injector", "response": "Decorator to register a model document view"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef download(cls):\n        cls._check_folder()\n        os.chdir(cls.VIEWS_PATH)\n        # iterate documents\n        for doc in cls._documents:\n            design_doc = doc().view()\n            if design_doc is None:\n                continue\n            bucket_name = design_doc.bucket.name\n            # iterate viewtypes (i.e. spatial and views)\n            for view_type, views in design_doc.ddoc.iteritems():\n                save_dir = '%s/%s/%s' % (bucket_name, design_doc.name, view_type)\n                try:\n                    # remove and recreate the dir\n                    shutil.rmtree(save_dir, ignore_errors=True)\n                    os.makedirs(save_dir)\n                except OSError:\n                    pass\n                for name, view in views.iteritems():\n                    if isinstance(view, unicode) and view_type=='spatial':\n                        spatial_file = '%s/%s.spatial.js' % (save_dir, name)\n                        with open(spatial_file, 'w') as f:\n                            f.write(view)\n                        print('Downloaded: %s' % spatial_file)\n                    if isinstance(view, dict) and 'map' in view:\n                        map_file = '%s/%s.map.js' % (save_dir, name)\n                        with open(map_file, 'w') as f:\n                            f.write(view['map'])\n                        print('Downloaded: %s' % map_file)\n                    if isinstance(view, dict) and 'reduce' in view:\n                        reduce_file = '%s/%s.reduce.js' % (save_dir, name)\n                        with open(reduce_file, 'w') as f:\n                            f.write(view['reduce'])\n                        print('Downloaded: %s' % reduce_file)\n        pass", "response": "Downloads all the views from the server for the registered model and stores them into the defined VIEW_PATHS directory. This method removes the previous views directory and creates the directory structure."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nuploads all the local views from the VIEW_PATHS directory to CouchBase server.", "response": "def upload(cls):\n        \"\"\"Uploads all the local views from :attr:`VIEW_PATHS` directory\n        to CouchBase server\n\n        This method **over-writes** all the server-side views with the same\n        named ones coming from :attr:`VIEW_PATHS` folder.\n        \"\"\"\n        cls._check_folder()\n        os.chdir(cls.VIEWS_PATH)\n        buckets = dict()\n        # iterate local folders\n        for bucket_name in os.listdir(cls.VIEWS_PATH):\n            if not os.path.isdir(bucket_name):\n                continue\n            # get bucket object\n            if bucket_name not in buckets:\n                try:\n                    bucket = Connection.bucket(bucket_name)\n                except BucketNotFoundError as why:\n                    print(\"[WARNING] %s\" % str(why))\n                    continue\n                else:\n                    buckets[bucket_name] = bucket\n            else:\n                bucket = buckets[bucket_name]\n            # go through design docs\n            for ddoc_name in os.listdir(bucket_name):\n                views_path = '%s/%s/views' % (bucket_name, ddoc_name)\n                spatial_path = '%s/%s/spatial' % (bucket_name, ddoc_name)\n                if not (os.path.exists(views_path) and os.path.isdir(views_path)) and \\\n                   not (os.path.exists(spatial_path) and os.path.isdir(spatial_path)):\n                    continue\n                # initialize design doc\n                new_ddoc = {\n                    'views': {},\n                    'spatial': {},\n                }\n                # map and reduces\n                if os.path.exists(views_path) and os.path.isdir(views_path):\n                    for filename in os.listdir(views_path):\n                        if not os.path.isfile('%s/%s' % (views_path, filename)) or \\\n                           not filename.endswith(('.map.js', '.reduce.js')):\n                            continue\n                        view_name, view_type, js = filename.rsplit('.', 2)\n                        if view_name not in new_ddoc['views']:\n                            new_ddoc['views'][view_name] = {}\n                        with open('%s/%s' % (views_path, filename), 'r') as f:\n                            new_ddoc['views'][view_name][view_type] = f.read()\n                # spatial views\n                if os.path.exists(spatial_path) and os.path.isdir(spatial_path):\n                    for filename in os.listdir(spatial_path):\n                        if not os.path.isfile('%s/%s' % (spatial_path, filename)) or \\\n                           not filename.endswith('.spatial.js'):\n                            continue\n                        view_name = filename.rsplit('.', 2)[0]\n                        with open('%s/%s' % (spatial_path, filename), 'r') as f:\n                            new_ddoc['spatial'][view_name] = f.read()\n                bucket['_design/%s' % ddoc_name] = new_ddoc\n                print('Uploaded design document: %s' % ddoc_name)\n        pass"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncalculates the minimum distance to reach any iterable of entities with a loc", "response": "def relateObjectLocs(obj, entities, selectF):\n    \"\"\"calculate the minimum distance to reach any iterable of entities with a loc\"\"\"\n    #if obj in entities: return 0 # is already one of the entities\n    try:                    obj = obj.loc # get object's location, if it has one\n    except AttributeError:  pass # assume obj is already a MapPoint\n    try:                    func = obj.direct2dDistance # assume obj is a MapPoint\n    except AttributeError:  raise ValueError(\"object %s (%s) does not possess and is not a %s\"%(obj, type(obj), MapPoint))\n    try:                    return selectF([(func(b.loc), b) for b in entities])\n    except AttributeError:  return selectF([(func(b)    , b) for b in entities])"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncause the given point to snap to nearest X / Y grid point", "response": "def gridSnap(point, grid=1.0):\n    \"\"\"cause the given point to snap to nearest X/Y grid point\"\"\"\n    def snapFunc(value):\n        value += 0.000001 # ensure values that are close to a half grid value round up\n        remainder = value%grid\n        value -= remainder\n        newAdd = round(remainder/grid)*grid\n        return value + newAdd\n    return MapPoint( snapFunc(point.x) ,\n                     snapFunc(point.y) )"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef convertToMapPic(byteString, mapWidth):\n    data = []\n    line = \"\"\n    for idx,char in enumerate(byteString):\n        line += str(ord(char))\n        if ((idx+1)%mapWidth)==0:\n            data.append(line)\n            line = \"\"\n    return data", "response": "convert a bytestring into a 2D row x column array representing an existing map of fog - of - war creep etc."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef Dumper(obj, indent=0, increase=4, encoding='utf-8'):\n    ##############################################################################\n    def p(given):\n        \"\"\"ensure proper decoding from unicode, if necessary\"\"\"\n        if isinstance(given, str):  return given.encode(encoding)\n        else:                       return given\n    ##############################################################################\n    try:\n        if isinstance(obj, dict):\n            for k,v in obj.items():\n                if hasattr(v, \"__iter__\"):\n                    print(\"%s%s\"%(\" \"*(indent), p(k)))\n                    Dumper(v, indent=indent+increase, increase=increase)\n                else: print(\"%s%s=%s\"%(\" \"*(indent), p(k), p(v)))\n        elif isinstance(obj, list):\n            for o in obj:\n                Dumper(o, indent=indent, increase=increase) # didn't print anything this go-round\n        elif isinstance(obj, tuple):\n            print(\"%s%s\"%(\" \"*(indent), p(obj[0])))\n            next = list(obj)[1:]\n            if len(next) == 1:  next = next[0]\n            else:               next = tuple(next)\n            Dumper(next, indent=indent+increase, increase=increase)\n        elif isinstance(obj, str):\n            print(\"%s%s\"%(\" \"*(indent), p(obj))) # universally convert back to str for printing\n        elif obj!=None:\n            print(\"%s%s\"%(\" \"*(indent), p(obj)))\n    except Exception:\n        print(type(obj), obj)", "response": "dumper function for a given dict list tuple or object data structure"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef quadraticEval(a, b, c, x):\n    return a*(x**2) + b*x + c", "response": "given all params return the result of quadratic equation a b c x"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a list of solution for a given set of resources", "response": "def quadraticSolver(a, b, c):\n    \"\"\"return solution(s) for x, to the quadratic equation a*x^2 + b*x + c\n    when it equals zero using the quadratic formula\"\"\"\n    if a == 0:\n        if b == 0:  return [] # attempting to solve an equation with infinite (0=0) or impossible (0=3) solutions for x\n        else:       return [-c / float(b)]\n    else:\n        d = b**2.0 - 4*a*c # calculate the discriminant\n        if d < 0:   return [] # would require math.sqrt a negative number, yielding a complex number\n        solvedPart0 = 1/(2.0*a)\n        solvedPart1 = -b * solvedPart0\n        if d == 0:  return [ solvedPart1 ] # two values at same 'x'\n        else: # i.e. d > 0   apply full quadratic formula\n            solvedPart2 = math.sqrt(d)*solvedPart0\n            return [ solvedPart1+solvedPart2, solvedPart1-solvedPart2 ]"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get(self, mail):\n        users = (v for v in self.list() if v.get('mail') == mail)\n        for i in users:\n            self.log.debug(i)\n            return i\n        return None", "response": "Get one document store into LinShare."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding a ComponentDefinition to the document", "response": "def add_component_definition(self, definition):\n        \"\"\"\n        Add a ComponentDefinition to the document\n        \"\"\"\n        # definition.identity = self._to_uri_from_namespace(definition.identity)\n        if definition.identity not in self._components.keys():\n            self._components[definition.identity] = definition\n        else:\n            raise ValueError(\"{} has already been defined\".format(definition.identity))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef assemble_component(self, into_component, using_components):\n        if not isinstance(using_components, list) or len(using_components) == 0:\n            raise Exception('Must supply list of ComponentDefinitions')\n\n        components = []\n        sequence_annotations = []\n        seq_elements = ''\n\n        for k, c in enumerate(using_components):\n            try:\n                self._components[c.identity]\n            except KeyError:\n                raise Exception('Must already have defined ComponentDefinition in document')\n            else:\n                identity = into_component.identity + '/' + c.identity\n\n                # All components are initially public, this can be changed later\n                component = Component(identity,\n                                      c,\n                                      'public',\n                                      display_id=c.identity)\n                components.append(component)\n\n                # If there is a sequence on the ComponentDefinition use the first element\n                if len(c.sequences) > 0:\n                    # Add the sequence to the document\n                    self._add_sequence(c.sequences[0])\n                    # Get start/end points of sequence\n                    start = len(seq_elements) + 1 # The sequence is usually 1 indexed\n                    end = start + len(c.sequences[0].elements)\n                    # Add to the component sequence element\n                    seq_elements += c.sequences[0].elements\n                    # Create a Range object to hold seq range\n                    range_identity = identity + '_sequence_annotation/range'\n                    seq_range = Range(range_identity, start, end, display_id='range')\n                    # Create a SequenceAnnotation object to hold the range\n                    annot_identity = identity + '_sequence_annotation'\n                    seq_annot = SequenceAnnotation(annot_identity,\n                                                   component=component,\n                                                   locations=[seq_range],\n                                                   display_id=c.identity + '_sequence_annotation')\n                    sequence_annotations.append(seq_annot)\n\n        if seq_elements != '':\n            seq_encoding = using_components[0].sequences[0].encoding\n            seq_identity = '{}_sequence'.format(into_component.identity)\n            seq = Sequence(seq_identity, seq_elements, encoding=seq_encoding)\n            self._add_sequence(seq)\n            into_component.sequences.append(seq)\n\n        into_component.components = components\n        into_component.sequence_annotations = sequence_annotations", "response": "Assemble a list of already defined components into a structual hirearchy Component object"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _add_sequence(self, sequence):\n        if sequence.identity not in self._sequences.keys():\n            self._sequences[sequence.identity] = sequence\n        else:\n            raise ValueError(\"{} has already been defined\".format(sequence.identity))", "response": "Add a Sequence to the document"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add_model(self, model):\n        if model.identity not in self._models.keys():\n            self._models[model.identity] = model\n        else:\n            raise ValueError(\"{} has already been defined\".format(model.identity))", "response": "Add a model to the document."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef add_module_definition(self, module_definition):\n        if module_definition.identity not in self._module_definitions.keys():\n            self._module_definitions[module_definition.identity] = module_definition\n        else:\n            raise ValueError(\"{} has already been defined\".format(module_definition.identity))", "response": "Adds a ModuleDefinition to the document."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget components from a component definition in order", "response": "def get_components(self, uri):\n        \"\"\"\n        Get components from a component definition in order\n        \"\"\"\n        try:\n            component_definition = self._components[uri]\n        except KeyError:\n            return False\n\n        sorted_sequences = sorted(component_definition.sequence_annotations,\n                                  key=attrgetter('first_location'))\n        return [c.component for c in sorted_sequences]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef clear_document(self):\n        self._components.clear()\n        self._sequences.clear()\n        self._namespaces.clear()\n        self._models.clear()\n        self._modules.clear()\n        self._collections.clear()\n        self._annotations.clear()\n        self._functional_component_store.clear()\n        self._collection_store.clear()", "response": "Clears all items from document"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _get_triplet_value(self, graph, identity, rdf_type):\n        value = graph.value(subject=identity, predicate=rdf_type)\n        return value.toPython() if value is not None else value", "response": "Get a value from an RDF triple in the graph"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets a list of values from RDF triples when more than one may be present", "response": "def _get_triplet_value_list(self, graph, identity, rdf_type):\n        \"\"\"\n        Get a list of values from RDF triples when more than one may be present\n        \"\"\"\n        values = []\n        for elem in graph.objects(identity, rdf_type):\n            values.append(elem.toPython())\n        return values"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreads graph and add sequences to document", "response": "def _read_sequences(self, graph):\n        \"\"\"\n        Read graph and add sequences to document\n        \"\"\"\n        for e in self._get_elements(graph, SBOL.Sequence):\n            identity = e[0]\n            c = self._get_rdf_identified(graph, identity)\n            c['elements'] = self._get_triplet_value(graph, identity, SBOL.elements)\n            c['encoding'] = self._get_triplet_value(graph, identity, SBOL.encoding)\n            seq = Sequence(**c)\n            self._sequences[identity.toPython()] = seq\n            self._collection_store[identity.toPython()] = seq"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreads graph and add component definitions to document", "response": "def _read_component_definitions(self, graph):\n        \"\"\"\n        Read graph and add component defintions to document\n        \"\"\"\n        for e in self._get_elements(graph, SBOL.ComponentDefinition):\n            identity = e[0]\n            # Store component values in dict\n            c = self._get_rdf_identified(graph, identity)\n            c['roles'] = self._get_triplet_value_list(graph, identity, SBOL.role)\n            c['types'] = self._get_triplet_value_list(graph, identity, SBOL.type)\n            obj = ComponentDefinition(**c)\n            self._components[identity.toPython()] = obj\n            self._collection_store[identity.toPython()] = obj"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _extend_component_definitions(self, graph):\n        for def_uri, comp_def in self._components.items():\n            # Store created components indexed for later lookup\n            component_index = {}\n            identity = URIRef(def_uri)\n\n            # Get components\n            for comp in graph.triples((identity, SBOL.component, None)):\n                comp_identity = comp[2]\n                ci = self._get_rdf_identified(graph, comp_identity)\n                ci['maps_to'] = self._get_triplet_value(graph, comp_identity, SBOL.mapTo)\n                ci['access'] = self._get_triplet_value(graph, comp_identity, SBOL.access)\n\n                component_comp_def = self._get_triplet_value(graph, comp_identity, SBOL.definition)\n                ci['definition'] = self._components[component_comp_def]\n\n                c = Component(**ci)\n                component_index[ci['identity']] = c\n            self._components[def_uri].components = list(component_index.values())\n\n            # Get sequence annotations\n            if (identity, SBOL.sequenceAnnotation, None) in graph:\n                find_annotation_using = (identity, SBOL.sequenceAnnotation, None)\n            else:\n                find_annotation_using = (identity, SBOL.SequenceAnnotation, None)\n            sequence_annotations = []\n            for seq_annot in graph.triples(find_annotation_using):\n                seq_identity = seq_annot[2]\n                sa = self._get_rdf_identified(graph, seq_identity)\n                component_to_use = self._get_triplet_value(graph, seq_identity, SBOL.component)\n                sa['component'] = component_index[component_to_use]\n                sa['roles'] = self._get_triplet_value_list(graph, seq_identity, SBOL.role)\n                locations = []\n                for loc in graph.triples((seq_identity, SBOL.location, None)):\n                    loc_identity = loc[2]\n                    location = self._get_rdf_identified(graph, loc_identity)\n                    location['orientation'] = self._get_triplet_value(graph, loc_identity,\n                                                                      SBOL.orientation)\n                    location_type = URIRef(self._get_triplet_value(graph, loc_identity, RDF.type))\n                    if location_type == SBOL.Range:\n                        location['start'] = self._get_triplet_value(graph, loc_identity, SBOL.start)\n                        location['end'] = self._get_triplet_value(graph, loc_identity, SBOL.end)\n                        locations.append(Range(**location))\n                    elif location_type == SBOL.Cut:\n                        location['at'] = self._get_triplet_value(graph, loc_identity, SBOL.at)\n                        locations.append(Cut(**location))\n                    else:\n                        locations.append(GenericLocation(**location))\n                sa_obj = SequenceAnnotation(locations=locations, **sa)\n                sequence_annotations.append(sa_obj)\n            self._components[def_uri].sequence_annotations = sequence_annotations\n\n            # Get sequence constraints\n            if (identity, SBOL.sequenceConstraint, None) in graph:\n                find_constraint_using = (identity, SBOL.sequenceConstraint, None)\n            else:\n                find_constraint_using = (identity, SBOL.SequenceConstraint, None)\n            sequence_constraints = []\n            for seq_constraint in graph.triples(find_constraint_using):\n                seq_identity = seq_constraint[2]\n                sc = self._get_rdf_identified(graph, seq_identity)\n                sc['restriction'] = self._get_triplet_value(graph, seq_identity, SBOL.restriction)\n                subject_id = self._get_triplet_value(graph, seq_identity, SBOL.subject)\n                sc['subject'] = component_index[subject_id]\n                object_id = self._get_triplet_value(graph, seq_identity, SBOL.object)\n                # Object is a reserved word so call it obj to prevent clashes\n                sc['obj'] = component_index[object_id]\n                sc_obj = SequenceConstraint(**sc)\n                sequence_constraints.append(sc_obj)\n            self._components[def_uri].sequence_constraints = sequence_constraints", "response": "Read graph and update component definitions with related elements"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreading graph and add models to document", "response": "def _read_models(self, graph):\n        \"\"\"\n        Read graph and add models to document\n        \"\"\"\n        for e in self._get_elements(graph, SBOL.Model):\n            identity = e[0]\n            m = self._get_rdf_identified(graph, identity)\n            m['source'] = self._get_triplet_value(graph, identity, SBOL.source)\n            m['language'] = self._get_triplet_value(graph, identity, SBOL.language)\n            m['framework'] = self._get_triplet_value(graph, identity, SBOL.framework)\n            obj = Model(**m)\n            self._models[identity.toPython()] = obj\n            self._collection_store[identity.toPython()] = obj"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreading graph and add module defintions to document", "response": "def _read_module_definitions(self, graph):\n        \"\"\"\n        Read graph and add module defintions to document\n        \"\"\"\n        for e in self._get_elements(graph, SBOL.ModuleDefinition):\n            identity = e[0]\n            m = self._get_rdf_identified(graph, identity)\n            m['roles'] = self._get_triplet_value_list(graph, identity, SBOL.role)\n            functional_components = {}\n            for func_comp in graph.triples((identity, SBOL.functionalComponent, None)):\n                func_identity = func_comp[2]\n                fc = self._get_rdf_identified(graph, func_identity)\n                definition = self._get_triplet_value(graph, func_identity, SBOL.definition)\n                fc['definition'] = self._components[definition]\n                fc['access'] = self._get_triplet_value(graph, func_identity, SBOL.access)\n                fc['direction'] = self._get_triplet_value(graph, func_identity, SBOL.direction)\n                functional_components[func_identity.toPython()] = FunctionalComponent(**fc)\n                self._functional_component_store[func_identity.toPython()] = \\\n                        functional_components[func_identity.toPython()]\n            interactions = []\n            for inter in graph.triples((identity, SBOL.interaction, None)):\n                inter_identity = inter[2]\n                it = self._get_rdf_identified(graph, inter_identity)\n                it['types'] = self._get_triplet_value_list(graph, inter_identity, SBOL.types)\n                participations = []\n                for p in graph.triples((inter_identity, SBOL.participation, None)):\n                    pc = self._get_rdf_identified(graph, p[2])\n                    roles = self._get_triplet_value_list(graph, p[2], SBOL.role)\n                    # Need to use one of the functional component created above\n                    participant_id = self._get_triplet_value(graph, p[2], SBOL.participant)\n                    participant = functional_components[participant_id]\n                    participations.append(Participation(roles=roles, participant=participant, **pc))\n                interactions.append(Interaction(participations=participations, **it))\n            obj = ModuleDefinition(functional_components=functional_components.values(),\n                                   interactions=interactions,\n                                   **m)\n            self._modules[identity.toPython()] = obj\n            self._collection_store[identity.toPython()] = obj"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _extend_module_definitions(self, graph):\n        for mod_id in self._modules:\n            mod_identity = self._get_triplet_value(graph, URIRef(mod_id), SBOL.module)\n            modules = []\n            for mod in graph.triples((mod_identity, SBOL.module, None)):\n                md = self._get_rdf_identified(graph, mod[2])\n                definition_id = self._get_triplet_value(graph, mod[2], SBOL.definition)\n                md['definition'] = self._modules[definition_id]\n                maps_to = []\n                for m in graph.triples((mod[2], SBOL.mapsTo, None)):\n                    mt = self._get_rdf_identified(graph, m[2])\n                    mt['refinement'] = self._get_triplet_value(graph, m[2], SBOL.refinement)\n                    local_id = self._get_triplet_value(graph, m[2], SBOL.local)\n                    remote_id = self._get_triplet_value(graph, m[2], SBOL.remote)\n                    mt['local'] = self._functional_component_store[local_id]\n                    mt['remote'] = self._functional_component_store[remote_id]\n                    maps_to.append(MapsTo(**mt))\n                modules.append(Module(maps_to=maps_to, **md))\n            self._modules[mod_id].modules = modules", "response": "Extends the list of module definitions based on the graph."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nfinds any non - defined elements at TopLevel and create annotations at CollectionStore", "response": "def _read_annotations(self, graph):\n        \"\"\"\n        Find any non-defined elements at TopLevel and create annotations\n        \"\"\"\n        flipped_namespaces = {v: k for k, v in self._namespaces.items()}\n        for triple in graph.triples((None, RDF.type, None)):\n            namespace, obj = split_uri(triple[2])\n            prefix = flipped_namespaces[namespace]\n            as_string = '{}:{}'.format(prefix, obj)\n            if as_string not in VALID_ENTITIES:\n                identity = triple[0]\n                gt = self._get_rdf_identified(graph, identity)\n                q_name = QName(namespace=namespace, local_name=obj, prefix=prefix)\n                gt['rdf_type'] = q_name\n                gt_obj = GenericTopLevel(**gt)\n                self._annotations[identity.toPython()] = gt_obj\n                self._collection_store[identity.toPython()] = gt_obj"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreads graph and add collections to document", "response": "def _read_collections(self, graph):\n        \"\"\"\n        Read graph and add collections to document\n        \"\"\"\n        for e in self._get_elements(graph, SBOL.Collection):\n            identity = e[0]\n            c = self._get_rdf_identified(graph, identity)\n            members = []\n            # Need to handle other non-standard TopLevel objects first\n            for m in graph.triples((identity, SBOL.member, None)):\n                members.append(self._collection_store[m[2].toPython()])\n            obj = Collection(members=members, **c)\n            self._collections[identity.toPython()] = obj"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef read(self, f):\n        self.clear_document()\n\n        g = Graph()\n        g.parse(f, format='xml')\n\n        for n in g.namespaces():\n            ns = n[1].toPython()\n            if not ns.endswith(('#', '/', ':')):\n                ns = ns + '/'\n            self._namespaces[n[0]] = ns\n            # Extend the existing namespaces available\n            XML_NS[n[0]] = ns\n\n        self._read_sequences(g)\n        self._read_component_definitions(g)\n        self._extend_component_definitions(g)\n        self._read_models(g)\n        self._read_module_definitions(g)\n        self._extend_module_definitions(g)\n        self._read_annotations(g)\n        # Last as this needs all other top level objects created\n        self._read_collections(g)", "response": "Read in an SBOL file and populate the internal dictionary with the current state of the current object."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef write(self, f):\n        rdf = ET.Element(NS('rdf', 'RDF'), nsmap=XML_NS)\n\n        # TODO: TopLevel Annotations\n        sequence_values = sorted(self._sequences.values(), key=lambda x: x.identity)\n        self._add_to_root(rdf, sequence_values)\n        component_values = sorted(self._components.values(), key=lambda x: x.identity)\n        self._add_to_root(rdf, component_values)\n        model_values = sorted(self._models.values(), key=lambda x: x.identity)\n        self._add_to_root(rdf, model_values)\n        module_values = sorted(self._modules.values(), key=lambda x: x.identity)\n        self._add_to_root(rdf, module_values)\n        collection_values = sorted(self._collections.values(), key=lambda x: x.identity)\n        self._add_to_root(rdf, collection_values)\n        annotation_values = sorted(self._annotations.values(), key=lambda x: x.identity)\n        self._add_to_root(rdf, annotation_values)\n\n        f.write(ET.tostring(rdf,\n                            pretty_print=True,\n                            xml_declaration=True,\n                            encoding='utf-8'))", "response": "Write an SBOL file from the current document contents to the given file object f"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get(cls, dname):\n        Domain = cls\n        dname = dname.hostname if hasattr(dname, 'hostname') else dname.lower()\n        return Session.query(Domain).filter(Domain.name == dname).first()", "response": "Get the requested domain\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_or_create(cls, dname):\n        Domain = cls\n        dname = dname.hostname if hasattr(dname, 'hostname') else dname\n        extras = 'www.{dn}'.format(dn=dname) if dname not in ('localhost', ) and not \\\n            re.match('^(?:[0-9]{1,3}\\.){3}[0-9]{1,3}$', dname) else None\n        # Fetch the domain entry if it already exists\n        logging.getLogger('ipsv.sites.domain').debug('Checking if the domain %s has already been registered', dname)\n        domain = Session.query(Domain).filter(Domain.name == dname).first()\n\n        # Otherwise create it now\n        if not domain:\n            logging.getLogger('ipsv.sites.domain')\\\n                .debug('Domain name does not yet exist, creating a new database entry')\n            domain = Domain(name=dname, extras=extras)\n            Session.add(domain)\n            Session.commit()\n\n        return domain", "response": "Get the requested domain or create it if it doesn t exist already."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef all(cls, domain=None):\n        Site = cls\n        site = Session.query(Site)\n        if domain:\n            site.filter(Site.domain == domain)\n        return site.all()", "response": "Return all sites in the current domain"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get(cls, domain, name):\n        Site = cls\n        return Session.query(Site).filter(Site.domain == domain).filter(collate(Site.name, 'NOCASE') == name).first()", "response": "Get the requested site entry\n       "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef delete(self, drop_database=True):\n        self.disable()\n        Session.delete(self)\n\n        if drop_database and self.db_name:\n            mysql = create_engine('mysql://root:secret@localhost')\n            mysql.execute('DROP DATABASE IF EXISTS `{db}`'.format(db=self.db_name))\n            try:\n                mysql.execute('DROP USER `{u}`'.format(u=self.db_user))\n            except SQLAlchemyError:\n                pass", "response": "Delete the site entry with the given ID."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ngenerate the Site s name", "response": "def name(self, value):\n        \"\"\"\n        Generate the Site's slug (for file paths, URL's, etc.)\n        \"\"\"\n        self._name = value\n        self.slug = re.sub('[^0-9a-zA-Z_-]+', '_', str(value).lower())\n        self.root = os.path.abspath(os.path.join(_cfg.get('Paths', 'HttpRoot'), self.domain.name, self.slug))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsave the Site s version from a string or version tuple", "response": "def version(self, value):\n        \"\"\"\n        Save the Site's version from a string or version tuple\n        @type   value:  tuple or str\n        \"\"\"\n        if isinstance(value, tuple):\n            value = unparse_version(value)\n\n        self._version = value"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef enable(self, force=False):\n        log = logging.getLogger('ipsv.models.sites.site')\n        log.debug('Disabling all other sites under the domain %s', self.domain.name)\n        Session.query(Site).filter(Site.id != self.id).filter(Site.domain == self.domain).update({'enabled': 0})\n\n        sites_enabled_path = _cfg.get('Paths', 'NginxSitesEnabled')\n        server_config_path = os.path.join(_cfg.get('Paths', 'NginxSitesAvailable'), self.domain.name)\n        server_config_path = os.path.join(server_config_path, '{fn}.conf'.format(fn=self.slug))\n        symlink_path = os.path.join(sites_enabled_path, '{domain}-{fn}'.format(domain=self.domain.name,\n                                                                               fn=os.path.basename(server_config_path)))\n        links = glob(os.path.join(sites_enabled_path, '{domain}-*'.format(domain=self.domain.name)))\n        for link in links:\n            if os.path.islink(link):\n                log.debug('Removing existing configuration symlink: %s', link)\n                os.unlink(link)\n            else:\n                if not force:\n                    log.error('Configuration symlink path already exists, but it is not a symlink')\n                    raise Exception('Misconfiguration detected: symlink path already exists, but it is not a symlink '\n                                    'and --force was not passed. Unable to continue')\n                log.warn('Configuration symlink path already exists, but it is not a symlink. Removing anyways '\n                         'since --force was set')\n                if os.path.isdir(symlink_path):\n                    shutil.rmtree(symlink_path)\n                else:\n                    os.remove(symlink_path)\n\n        log.info('Enabling Nginx configuration file')\n        os.symlink(server_config_path, symlink_path)\n\n        self.enabled = 1\n        Session.commit()", "response": "Enable this site and enable all other sites under the domain."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nwrite the Nginx configuration file for this site.", "response": "def write_nginx_config(self):\n        \"\"\"\n        Write the Nginx configuration file for this Site\n        \"\"\"\n        log = logging.getLogger('ipsv.models.sites.site')\n        if not os.path.exists(self.root):\n            log.debug('Creating HTTP root directory: %s', self.root)\n            os.makedirs(self.root, 0o755)\n\n        # Generate our server block configuration\n        server_block = ServerBlock(self)\n\n        server_config_path = os.path.join(_cfg.get('Paths', 'NginxSitesAvailable'), self.domain.name)\n        if not os.path.exists(server_config_path):\n            log.debug('Creating new configuration path: %s', server_config_path)\n            os.makedirs(server_config_path, 0o755)\n\n        server_config_path = os.path.join(server_config_path, '{fn}.conf'.format(fn=self.slug))\n        if os.path.exists(server_config_path):\n            log.info('Server block configuration file already exists, overwriting: %s', server_config_path)\n            os.remove(server_config_path)\n\n        log.info('Writing Nginx server block configuration file')\n        with open(server_config_path, 'w') as f:\n            f.write(server_block.template)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding subnet information to a network list.", "response": "def extend_list(self, data, parsed_args):\n        \"\"\"Add subnet information to a network list.\"\"\"\n        neutron_client = self.get_client()\n        search_opts = {'fields': ['id', 'cidr']}\n        if self.pagination_support:\n            page_size = parsed_args.page_size\n            if page_size:\n                search_opts.update({'limit': page_size})\n        subnet_ids = []\n        for n in data:\n            if 'subnets' in n:\n                subnet_ids.extend(n['subnets'])\n\n        def _get_subnet_list(sub_ids):\n            search_opts['id'] = sub_ids\n            return neutron_client.list_subnets(\n                **search_opts).get('subnets', [])\n\n        try:\n            subnets = _get_subnet_list(subnet_ids)\n        except exceptions.RequestURITooLong as uri_len_exc:\n            # The URI is too long because of too many subnet_id filters\n            # Use the excess attribute of the exception to know how many\n            # subnet_id filters can be inserted into a single request\n            subnet_count = len(subnet_ids)\n            max_size = ((self.subnet_id_filter_len * subnet_count) -\n                        uri_len_exc.excess)\n            chunk_size = max_size // self.subnet_id_filter_len\n            subnets = []\n            for i in range(0, subnet_count, chunk_size):\n                subnets.extend(\n                    _get_subnet_list(subnet_ids[i: i + chunk_size]))\n\n        subnet_dict = dict([(s['id'], s) for s in subnets])\n        for n in data:\n            if 'subnets' in n:\n                n['subnets'] = [(subnet_dict.get(s) or {\"id\": s})\n                                for s in n['subnets']]"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef bump(self, bump_part):\n\n        major, minor, patch, stage, n = tuple(self)\n\n        # stage bump\n        if bump_part not in {\"major\", \"minor\", \"patch\"}:\n\n            if bump_part not in self.stages:\n                raise ValueError(f\"Unknown {bump_part} stage\")\n\n            # We can not bump from final stage to final again.\n            if self.stage == \"final\" and bump_part == \"final\":\n                raise ValueError(f\"{self} is already in final stage.\")\n\n            # bump in the same stage (numeric part)\n            if bump_part == self.stage:\n                n += 1\n            else:\n                new_stage_number = tuple(self.stages).index(bump_part)\n\n                # We can not bump to a previous stage\n                if new_stage_number < self._stage_number:\n                    raise ValueError(f\"{bump_part} stage is previous to {self}\")\n\n                stage = bump_part\n                n = 0\n        else:\n            # major, minor, or patch bump\n\n            # Only version in final stage can do a major, minor or patch\n            # bump\n            if self.stage != \"final\":\n                raise ValueError(\n                    f\"{self} is a pre-release version.\"\n                    f\" Can't do a {bump_part} version bump\"\n                )\n\n            if bump_part == \"major\":\n                major += 1\n                minor, patch = 0, 0\n            elif bump_part == \"minor\":\n                minor += 1\n                patch = 0\n            else:\n                patch += 1\n\n        return Version(major=major, minor=minor, patch=patch, stage=stage, n=n)", "response": "Return a new bumped version instance."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create_task(self, target: Callable[..., Any], *args: Any)\\\n            -> asyncio.tasks.Task:\n        \"\"\"Create task and add to our collection of pending tasks.\"\"\"\n        if asyncio.iscoroutine(target):\n            task = self._loop.create_task(target)\n        elif asyncio.iscoroutinefunction(target):\n            task = self._loop.create_task(target(*args))\n        else:\n            raise ValueError(\"Expected coroutine as target\")\n        self._pending_tasks.append(task)\n        return task", "response": "Create task and add to our collection of pending tasks."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncancel all pending tasks.", "response": "def cancel_pending_tasks(self):\n        \"\"\"Cancel all pending tasks.\"\"\"\n        for task in self._pending_tasks:\n            task.cancel()\n            if not self._loop.is_running():\n                try:\n                    self._loop.run_until_complete(task)\n                except asyncio.CancelledError:\n                    pass\n                except Exception: # pylint: disable=broad-except\n                    _LOGGER.error(\"Unhandled exception from async task\",\n                                  exc_info=True)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef start(self, fork=True):\n        if not fork:\n            distributed_logger.info('Starting metrics aggregator, not forking')\n            _registry_aggregator(self.reporter, self.socket_addr)\n        else:\n            distributed_logger.info('Starting metrics aggregator, forking')\n            p = Process(target=_registry_aggregator, args=(self.reporter, self.socket_addr, ))\n            p.start()\n            distributed_logger.info('Started metrics aggregator as PID %s', p.pid)\n            self.process = p", "response": "Starts the registry aggregator."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nterminate the forked process. Only valid if started as a fork.", "response": "def stop(self):\n        \"\"\"Terminates the forked process.\n\n        Only valid if started as a fork, because... well you wouldn't get here otherwise.\n        :return:\n        \"\"\"\n        distributed_logger.info('Stopping metrics aggregator')\n        self.process.terminate()\n        self.process.join()\n        distributed_logger.info('Stopped metrics aggregator')"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nconnecting to the 0MQ socket and starts publishing.", "response": "def connect(self):\n        \"\"\"Connects to the 0MQ socket and starts publishing.\"\"\"\n        distributed_logger.info('Connecting registry proxy to ZMQ socket %s', self.socket_addr)\n        self.zmq_context = zmq.Context()\n        sock = self.zmq_context.socket(zmq.PUB)\n        sock.set_hwm(0)\n        sock.setsockopt(zmq.LINGER, 0)\n        sock.connect(self.socket_addr)\n        distributed_logger.info('Connected registry proxy to ZMQ socket %s', self.socket_addr)\n\n        def _reset_socket(values):\n            for value in values:\n                try:\n                    _reset_socket(value.values())\n                except AttributeError:\n                    value.socket = sock\n\n        distributed_logger.debug('Resetting socket on metrics proxies')\n        _reset_socket(self.stats.values())\n        self.socket = sock\n        distributed_logger.debug('Reset socket on metrics proxies')"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_version(*file_paths):\n    filename = os.path.join(os.path.dirname(__file__), *file_paths)\n    print(\"Looking for version in: {}\".format(filename))\n    version_file = open(filename).read()\n    version_match = re.search(r\"^__version__ = ['\\\"]([^'\\\"]*)['\\\"]\", version_file, re.M)\n    if version_match:\n        return version_match.group(1)\n    raise RuntimeError('Unable to find version string.')", "response": "Retrieves the version from the file path"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef resolve_str(name_or_func, module, default):\n    assert isinstance(name_or_func, str)\n    resolved = resolve(name_or_func, module=module)\n\n    if isinstance(resolved, ModuleType):\n        if not hasattr(resolved, default):\n            raise ImportError(\"{}.{}\".format(resolved.__name__, default))\n\n        resolved = getattr(resolved, default)\n\n    if not callable(resolved):\n        raise TypeError(\"{!r} is not callable\"\n                        \"\".format(resolved))\n\n    return resolved", "response": "Resolve and return object from dotted name\n   "}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nresolves and call functions \\'' + _name_or_func + '\\'", "response": "def include(_name_or_func, *args,\n            _module=None, _default='includeme', **kwargs):\n    \"\"\" Resolve and call functions\n    \"\"\"\n    if callable(_name_or_func):\n        resolved = _name_or_func\n    else:\n        resolved = resolve_str(_name_or_func, _module, _default)\n\n    resolved(*args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef reset(target, settings):\n    target_settings = _import_module(target)\n    for k, v in settings.items():\n        if hasattr(target_settings, k):\n            setattr(target_settings, k, _get_value(getattr(target_settings, k), v))\n        else:\n            logger.debug('AttributeError {target} has no attribute {k}'.format(target=target, k=k))\n    return target_settings", "response": "Reset the object with the given settings."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nloading a single package from a directory.", "response": "def load_package(package_dir, package=None, exclude=None, default_section=_DEFAULT_SECTION):\n    \"\"\"\n    \u4ece\u76ee\u5f55\u4e2d\u8f7d\u5165\u914d\u7f6e\u6587\u4ef6\n    :param package_dir:\n    :param package:\n    :param exclude:\n    :param default_section:\n    :return:\n    \"\"\"\n    init_py = '__init__.py'\n    py_ext = '.py'\n    files = os.listdir(package_dir)\n    if init_py in files:\n        files = [f for f in files if f != init_py]\n        if package:\n            files.insert(0, package)\n\n    def init_package(item):\n        if str(item).endswith(py_ext):\n            item = item[:-3]\n            if package:\n                item = '{package}.{item}'.format(package=package, item=item)\n        elif _is_conf(item):\n            item = '{package_dir}/{item}'.format(package_dir=package_dir, item=item)\n        else:\n            item = package\n        return str(item)\n\n    logger.debug(files)\n    files = [init_package(f) for f in files]\n    if exclude:\n        files = [f for f in files if f not in exclude]\n\n    settings = load(files, default_section)\n    return merge(settings)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef load(items, default_section=_DEFAULT_SECTION):\n    settings = []\n\n    assert isinstance(items, list), 'items\u5fc5\u987b\u4e3alist'\n\n    logger.debug(items)\n    for item in items:\n        if _is_conf(item):\n            settings.append(load_from_ini(item, default_section))\n        else:\n            settings.append(load_from_name(item))\n    logger.debug(settings)\n    return merge(settings)", "response": "Load a list of items into a single object."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nmerges a list of dicts into a single dict", "response": "def merge(settings_list):\n    \"\"\"\n    \u5408\u5e76\u914d\u7f6e\n    :param settings_list:\n    :return:\n    \"\"\"\n    if not isinstance(settings_list, list):\n        return settings_list\n    settings = OrderedDict()\n    for item in settings_list:\n        for k, v in item.items():\n            if settings.get(k) and isinstance(v, OrderedDict):\n                settings[k].update(v)\n            else:\n                settings[k] = v\n    return settings"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef config(settings):\n    parameter_settings = Parameter()\n    for k, v in settings.items():\n        if isinstance(v, OrderedDict):\n            k_settings = Parameter()\n            for ki, vi in v.items():\n                k_settings[ki] = vi\n        else:\n            k_settings = v\n        parameter_settings[k] = k_settings\n\n    return parameter_settings", "response": "\u5c06\u914d\u7f6e\u6587\u4ef6\u8f6c\u4e3aParameter\n    :param settings:\n    :return:"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nload a node from a module.", "response": "def load_from_name(module_name):\n    \"\"\"\n    \u4ecepython module\u6587\u4ef6\u4e2d\u83b7\u53d6\u914d\u7f6e\n    :param module_name:\n    :return:\n    \"\"\"\n    global _CONFIG_CACHE\n    if module_name not in _CONFIG_CACHE:\n        settings = OrderedDict()\n        if isinstance(module_name, six.string_types):\n            settings = _load_from_module(_import_module(module_name))\n        _CONFIG_CACHE[module_name] = settings\n    return _CONFIG_CACHE[module_name]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef load_from_ini(ini, default_section=_DEFAULT_SECTION):\n    global _CONFIG_CACHE\n    if ini not in _CONFIG_CACHE:\n        if six.PY3:\n            logger.debug(\"PY3........\")\n            _CONFIG_CACHE[ini] = _load_from_ini_py3(ini, default_section)\n        else:\n            _CONFIG_CACHE[ini] = _load_from_ini_py2(ini)\n\n    logger.debug(_CONFIG_CACHE[ini])\n    return _CONFIG_CACHE[ini]", "response": "Load a node from an INI file."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _load_from_ini_py2(ini):\n    logger.debug('\u4f7f\u7528PY2\u4e0d\u652f\u6301\u81ea\u5b9a\u4e49default_section\uff0c\u5176\u9ed8\u8ba4\u503c\u662f:%s' % _DEFAULT_SECTION)\n    cf = configparser.ConfigParser()\n    cf.read(ini)\n    settings = OrderedDict()\n    for k, v in cf.defaults().items():\n        settings[k.upper()] = convert_value(v)\n    cf._defaults = {}\n    for section in cf.sections():\n        section_dict = OrderedDict()\n        for option in cf.items(section):\n            section_dict[option[0]] = option[1]\n        settings[section] = section_dict\n    return settings", "response": "Load settings from ini file py2."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nconverting value to object", "response": "def convert_value(v):\n    \"\"\"\n    \u9ed8\u8ba4\u4f7f\u7528Json\u8f6c\u5316\u6570\u636e,\u51e1\u4ee5[\u6216{\u5f00\u59cb\u7684,\u5747\u8f7d\u5165json\n    :param v:\n    :return:\n    \"\"\"\n    if v and isinstance(v, six.string_types):\n        v = v.strip()\n        if (v.startswith('{') and v.endswith('}')) or (v.startswith('[') and v.endswith(']')):\n            try:\n                return json.loads(v)\n            except Exception as e:\n                logger.error(e)\n\n    return v"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nload the configuration from an ini file.", "response": "def _load_from_ini_py3(ini, default_section=_DEFAULT_SECTION):\n    \"\"\"\n    py3\u4ece\u5355\u4e2a\u914d\u7f6e\u6587\u4ef6\u4e2d,\u83b7\u53d6\u8bbe\u7f6e\n    :param default_section:\n    :param ini:\n    :return:\n    \"\"\"\n\n    cf = configparser.ConfigParser(default_section=default_section)\n    cf.read(ini, encoding=\"UTF8\")\n    settings = OrderedDict()\n    for item in cf.items():\n        logger.debug(item[0])\n        settings[item[0].upper()] = OrderedDict(item[1])\n\n    logger.debug(settings)\n    for k, v in cf.items(default_section):\n    # for k, v in cf.items():\n        logger.debug(v)\n        logger.debug(settings)\n        logger.debug(settings.get(k))\n        settings[k.upper()] = convert_value(v)\n        logger.debug(settings)\n        if k.lower() in settings:\n            del settings[k.lower()]\n\n    if default_section in settings:\n        del settings[default_section]\n\n    logger.debug(settings)\n    return settings"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _load_from_module(module):\n    settings = OrderedDict()\n\n    for key in dir(module):\n        if key.isupper():\n            settings[key] = getattr(module, key)\n    return settings", "response": "Load the settings from a module."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _import_module(name, package=None):\n    if name.startswith('.'):\n        name = '{package}.{module}'.format(package=package, module=str(name).strip('.'))\n    __import__(name)\n    return sys.modules[name]", "response": "\u6839\u636e\u6a21\u5757\u540d\u8f7d\u5165\u6a21\u5757\n    :param name:\n    :param package:\n    :return:"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget value from two items.", "response": "def _get_value(first, second):\n    \"\"\"\n    \u6570\u636e\u8f6c\u5316\n    :param first:\n    :param second:\n    :return:\n    >>> _get_value(1,'2')\n    2\n    >>> _get_value([1,2],[2,3])\n    [1, 2, 3]\n    \"\"\"\n\n    if isinstance(first, list) and isinstance(second, list):\n        return list(set(first).union(set(second)))\n    elif isinstance(first, dict) and isinstance(second, dict):\n        first.update(second)\n        return first\n    elif first is not None and second is not None and not isinstance(first, type(second)):\n        return type(first)(second)\n    else:\n        return second"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef replace_requirements(self, infilename, outfile_initial=None):\n\n        infile = open(infilename, 'r')\n\n        # extract the requirements for this file that were not skipped from the global database\n        _indexes = tuple(z[0] for z in filter(lambda x: x[1] == infilename, enumerate(self.req_parents)))\n        req_paths = tuple(z[1] for z in filter(lambda x: x[0] in _indexes, enumerate(self.req_paths)))\n        req_linenos = tuple(z[1] for z in filter(lambda x: x[0] in _indexes, enumerate(self.req_linenos)))\n\n        if outfile_initial:\n            outfile = outfile_initial\n        else:\n            outfile = tempfile.TemporaryFile('w+')\n\n        # write the input file to the output, replacing\n        # the requirement statements with the requirements themselves\n        for i, line in enumerate(infile.readlines()):\n            if i in req_linenos:\n                req_path = req_paths[req_linenos.index(i)]\n\n                # skip unresolved requirement\n                if not req_path:\n                    continue\n\n                # recursion\n                req_file = self.replace_requirements(req_path)\n\n                # insert something at cursor position\n                self.insert_requirement(outfile, req_file, req_path)\n\n                req_file.close()\n            else:\n                outfile.write(line)\n\n        infile.close()\n\n        if not outfile_initial:\n            outfile.seek(0)\n\n        return outfile", "response": "Recursively replaces the requirements in the files with the content of the requirements."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a fatal error message", "response": "def fatal(self, i: int=None) -> str:\n        \"\"\"\n        Returns a fatal error message\n        \"\"\"\n        head = \"[\" + colors.red(\"\\033[1mfatal error\") + \"]\"\n        if i is not None:\n            head = str(i) + \" \" + head\n        return head"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef error(self, i: int=None) -> str:\n        head = \"[\" + colors.red(\"error\") + \"]\"\n        if i is not None:\n            head = str(i) + \" \" + head\n        return head", "response": "Returns an error message for the current locale."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn a warning message", "response": "def warning(self, i: int=None) -> str:\n        \"\"\"\n        Returns a warning message\n        \"\"\"\n        head = \"[\" + colors.purple(\"\\033[1mwarning\") + \"]\"\n        if i is not None:\n            head = str(i) + \" \" + head\n        return head"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning an info message for the current locale.", "response": "def info(self, i: int=None) -> str:\n        \"\"\"\n        Returns an info message\n        \"\"\"\n        head = \"[\" + colors.blue(\"info\") + \"]\"\n        if i is not None:\n            head = str(i) + \" \" + head\n        return head"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef via(self, i: int=None) -> str:\n        head = \"[\" + colors.green(\"via\") + \"]\"\n        if i is not None:\n            head = str(i) + \" \" + head\n        return head", "response": "Returns an via message"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a debug message", "response": "def debug(self, i: int=None) -> str:\n        \"\"\"\n        Returns a debug message\n        \"\"\"\n        head = \"[\" + colors.yellow(\"debug\") + \"]\"\n        if i is not None:\n            head = str(i) + \" \" + head\n        return head"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nanalyze state and queue tasks.", "response": "def scan(self):\n        \"\"\"Analyze state and queue tasks.\"\"\"\n\n        log.debug(\"scanning machine: %s...\" % self.name)\n\n        deployed = set()\n        services = yield self.client.get_children(self.path + \"/services\")\n\n        for name in services:\n            log.debug(\"checking service: '%s'...\" % name)\n\n            try:\n                value, metadata = yield self.client.get(\n                    self.path + \"/services/\" + name + \"/machines\"\n                    )\n            except NoNodeException:\n                log.warn(\n                    \"missing machines declaration for service: %s.\" %\n                    name\n                    )\n                machines = []\n            else:\n                machines = json.loads(value)\n\n            if machines:\n                log.debug(\"machines: %s.\" % \", \".join(machines))\n\n                if self.name in machines:\n                    deployed.add(name)\n            else:\n                log.debug(\"service not configured for any machine.\")\n\n        count = len(deployed)\n        log.debug(\"found %d service(s) configured for this machine.\" % count)\n\n        running = yield self.client.get_children(\n            self.path + \"/machines/\" + self.name\n            )\n\n        self.stopped = deployed - set(running)\n\n        if self.stopped:\n            log.debug(\"services not running: %s.\" % \", \".join(\n                map(repr, self.stopped)))\n        elif running:\n            log.debug(\"all services are up.\")"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ninitialize a new database connection and return the pool object.", "response": "def initialize(name='', pool_size=10, host='localhost', password='', port=5432, user=''):\n    \"\"\"Initialize a new database connection and return the pool object.\n\n    Saves a reference to that instance in a module-level variable, so applications with only one database\n    can just call this function and not worry about pool objects.\n    \"\"\"\n\n    global pool\n    instance = Pool(name=name, pool_size=pool_size, host=host, password=password, port=port, user=user)\n    pool = instance\n    return instance"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef query(self, sql: str, args: tuple = None):\n\n        with self._cursor() as cursor:\n            log.debug('Running SQL: ' + str((sql, args)))\n            cursor.execute(sql, args)\n            return cursor.fetchall()", "response": "Execute a SQL query with a return value."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a generator of available ICachableItem in the ICachableSource", "response": "def items(self):\n        \"\"\"Returns a generator of available ICachableItem in the ICachableSource\n        \"\"\"\n        for dictreader in self._csv_dictreader_list:\n            for entry in dictreader:\n                item = self.factory()\n                item.key = self.key()\n                item.attributes = entry\n                try:\n                    item.validate()\n                except Exception as e:\n                    logger.debug(\"skipping entry due to item validation exception: %s\", str(e))\n                    continue\n                logger.debug(\"found validated item in CSV source, key: %s\", str(item.attributes[self.key()]))\n                yield item"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning ICachableItem that matches id Returns None if no item is found", "response": "def getById(self, Id):\n        \"\"\"Returns ICachableItem that matches id\n        \n        Args:\n            id: String that identifies the item to return whose key matches\n        \"\"\"\n        # we need to create a new object to insure we don't corrupt the generator count\n        csvsource = CSVSource(self.source, self.factory, self.key())\n        try:\n            for item in csvsource.items():\n                if Id == item.getId():\n                    return item\n        except StopIteration:\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef first(self):\n        # we need to create a new object to insure we don't corrupt the generator count\n        csvsource = CSVSource(self.source, self.factory, self.key())\n        try:\n            item = csvsource.items().next()\n            return item\n        except StopIteration:\n            return None", "response": "Returns the first ICachableItem in the ICachableSource"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets a single object from the database", "response": "def get(self, request,pk):\n        \"\"\"\n        If the user requests his profile return it, else return a 403 (Forbidden)\n        \"\"\"    \n        requested_profile = Profile.objects.get(user=pk)\n        \n        if requested_profile.user == self.request.user:\n            \n            return render(request, self.template_name, {'profile' : requested_profile})\n        \n        else:\n            \n            return HttpResponse(status = 403)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nregistering an expression resolver.", "response": "def register(name=None, exprresolver=None, params=None, reg=None):\n    \"\"\"Register an expression resolver.\n\n    Can be used such as a decorator.\n\n    For example all remainding expressions are the same.\n\n    .. code-block:: python\n\n        @register('myresolver')\n        def myresolver(**kwargs): pass\n\n    .. code-block:: python\n\n        def myresolver(**kwargs): pass\n\n        register('myresolver', myresolver)\n\n    .. code-block:: python\n\n        @register('myresolver')\n        class MyResolver():\n            def __call__(**kwargs): pass\n\n    .. code-block:: python\n\n        class MyResolver():\n            def __call__(**kwargs): pass\n\n        register('myresolver', MyResolver)\n\n    .. code-block:: python\n\n        class MyResolver():\n            def __call__(**kwargs): pass\n\n        register('myresolver', MyResolver())\n\n\n    :param str name: register name to use. Default is the function/class\n        name.\n    :param exprresolver: function able to resolve an expression.\n    :param dict kwargs: parameters of resolver instanciation if exprresolver\n        is a class and this function is used such as a decorator.\n    :param ResolverRegistry reg: registry to use. Default is the global registry\n    .\n    \"\"\"\n\n    def _register(exprresolver, _name=name, _params=params):\n        \"\"\"Local registration for better use in a decoration context.\n\n        :param exprresolver: function/class able to resolve an expression.\n        :param str _name: private parameter used to set the name.\n        :param dict _params: private parameter used to set resolver class\n            constructor parameters.\"\"\"\n\n        _exprresolver = exprresolver\n\n        if isclass(exprresolver):  # try to instanciate exprresolver\n            if _params is None:\n                _params = {}\n\n            _exprresolver = _exprresolver(**_params)\n\n        if _name is None:\n            _name = getname(exprresolver)\n\n        reg[_name] = _exprresolver\n\n        if reg.default is None:\n            reg.default = _name\n\n        return exprresolver\n\n    if name is None:\n        name = getname(exprresolver)\n\n    if reg is None:\n        reg = _RESOLVER_REGISTRY\n\n    if exprresolver is None:\n        result = _register\n\n    else:\n        result = name\n        _register(exprresolver)\n\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef defaultname(name=None):\n\n    if name is None:\n        name = _RESOLVER_REGISTRY.default\n\n    else:\n        _RESOLVER_REGISTRY.default = name\n\n    return name", "response": "Get default resolver name."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nresolves an expression with possibly a dedicated expression resolver.", "response": "def resolve(\n        expr, name=None,\n        safe=DEFAULT_SAFE, tostr=DEFAULT_TOSTR, scope=DEFAULT_SCOPE,\n        besteffort=DEFAULT_BESTEFFORT\n):\n    \"\"\"Resolve an expression with possibly a dedicated expression resolvers.\n\n    :param str name: expression resolver registered name. Default is the\n        first registered expression resolver.\n    :param bool safe: if True (Default), resolve in a safe context\n        (without I/O).\n    :param bool tostr: if True (False by default), transform the result into\n        a string format.\n    :param dict scope: scope execution resolution.\n    :param bool besteffort: if True (default) auto import unknown var.\n\n    :raises: KeyError if no expression resolver has been registered or if\n        name does not exist in expression resolvers.\n    \"\"\"\n\n    return _RESOLVER_REGISTRY.resolve(\n        expr=expr, name=name, safe=safe, tostr=tostr, scope=scope,\n        besteffort=besteffort\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting expression resolver name.", "response": "def getname(exprresolver):\n    \"\"\"Get expression resolver name.\n\n    Expression resolver name is given by the attribute __resolver__.\n    If not exist, then the it is given by the attribute __name__.\n    Otherwise, given by the __class__.__name__ attribute.\n\n    :raises: TypeError if exprresolver is not callable.\"\"\"\n\n    result = None\n\n    if not callable(exprresolver):\n        raise TypeError('Expression resolver must be a callable object.')\n\n    result = getattr(\n        exprresolver, __RESOLVER__, getattr(\n            exprresolver, '__name__', getattr(\n                exprresolver.__class__, '__name__'\n            )\n        )\n    )\n\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget default resolver name.", "response": "def default(self):\n        \"\"\"Get default resolver name.\"\"\"\n\n        if self._default is None or self._default not in self:\n            self._default = list(self.keys())[0] if self else None\n\n        return self._default"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef default(self, value):\n\n        if value is None:\n            if self:\n                value = list(self.keys())[0]\n\n        elif not isinstance(value, string_types):\n            value = register(exprresolver=value, reg=self)\n\n        elif value not in self:\n            raise KeyError(\n                '{0} not registered in {1}'.format(value, self)\n            )\n\n        self._default = value", "response": "Change of resolver name."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef resolve(\n            self, expr, name,\n            safe=DEFAULT_SAFE, tostr=DEFAULT_TOSTR, scope=DEFAULT_SCOPE,\n            besteffort=DEFAULT_BESTEFFORT\n    ):\n        \"\"\"Resolve an expression with possibly a dedicated expression resolvers.\n\n        :param str name: expression resolver registered name. Default is the\n            first registered expression resolver.\n        :param bool safe: if True (Default), resolve in a safe context\n            (without I/O).\n        :param bool tostr: if True (False by default), transform the result into\n            a string format.\n        :param dict scope: scope execution resolution.\n        :return: a string if tostr, otherwise, a python object.\n\n        :raises: KeyError if no expression resolver has been registered or if\n            name does not exist in expression resolvers.\n        \"\"\"\n\n        resolver = None\n\n        if name is None:\n            name = self.default\n\n        resolver = self[name]\n\n        result = resolver(\n            expr=expr,\n            safe=safe, tostr=tostr, scope=scope, besteffort=besteffort\n        )\n\n        return result", "response": "Resolve an expression with possibly a dedicated expression resolver."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nfixing our names to wkhtmltopdf s args", "response": "def wkhtmltopdf_args_mapping(data):\n    \"\"\"\n    fix our names to wkhtmltopdf's args\n    \"\"\"\n    mapping = {\n        'cookies': 'cookie',\n        'custom-headers': 'custom-header',\n        'run-scripts': 'run-script'\n    }\n\n    return {mapping.get(k, k): v for k, v in data.items()}"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ninitialising an application with whitenoise.", "response": "def init_app(application):\n    \"\"\"\n    Initialise an application\n\n    Set up whitenoise to handle static files.\n    \"\"\"\n    config = {k: v for k, v in application.config.items() if k in SCHEMA}\n\n    kwargs = {'autorefresh': application.debug}\n\n    kwargs.update((k[11:].lower(), v) for k, v in config.items())\n\n    instance = whitenoise.WhiteNoise(application.wsgi_app, **kwargs)\n\n    instance.add_files(application.static_folder, application.static_url_path)\n\n    if not hasattr(application, 'extensions'):\n        application.extensions = {}\n\n    application.extensions['whitenoise'] = instance\n\n    application.wsgi_app = instance"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef env(key, default=_NOT_PROVIDED, cast=str, force=False, **kwargs):\n    boolmap = kwargs.get('boolmap', None)\n    sticky = kwargs.get('sticky', False)\n\n    value = os.environ.get(key, default)\n    if value is _NOT_PROVIDED:\n        raise KeyError(_ENV_ERROR_MSG.format(key))\n\n    if sticky and value == default:\n        try:\n            os.environ[key] = value\n        except TypeError:\n            os.environ[key] = str(value)\n\n    if force or (value != default and type(value) != cast):\n        if cast is bool and boolmap is not None:\n            value = boolean(value, boolmap=boolmap)\n        elif cast is bool:\n            value = boolean(value)\n        else:\n            value = cast(value)\n\n    return value", "response": "Retrieve environment variables and specify default and options."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef main(arguments):\n    formatter_class = argparse.ArgumentDefaultsHelpFormatter\n    parser = argparse.ArgumentParser(description=__doc__,\n                                     formatter_class=formatter_class)\n    parser.add_argument('infile', help=\"Input file\",\n                        type=argparse.FileType('r'))\n    parser.add_argument('-o', '--outfile', help=\"Output file\",\n                        default=sys.stdout, type=argparse.FileType('w'))\n    args = parser.parse_args(arguments)\n\n    urls = args.infile.read().splitlines()\n\n    api_token = keyring.get_password('pushover', 'api_token')\n    pushover_user = keyring.get_password('pushover', 'user')\n    pushover = Pushover(api_token, pushover_user)\n\n    for url in urls:\n        domain = urlparse(url).netloc\n        urlpath = urlparse(url).path\n        url_dashes = re.sub(r'/', '-', urlpath)\n\n        cache = os.path.expanduser(\"~/.urlmon-cache\")\n        if not os.path.isdir(cache):\n            os.mkdir(cache, mode=0o755)\n        filename = domain + url_dashes + '.html'\n        filepath = os.path.join(cache, filename)\n\n        html = requests.get(url).text\n\n        if os.path.isfile(filepath):\n            with open(filepath) as r:\n                before = r.read()\n            if html == before:\n                logger.info(\"{} is unchanged\".format(url))\n            else:\n                msg = \"{} changed\".format(url)\n                logger.info(msg)\n                logger.debug(diff(before, html))\n                response = pushover.push(msg)\n                logger.debug(\"Pushover notification sent: \"\n                             \"{}\".format(response.status_code))\n\n        else:\n            logger.info(\"New url: {}\".format(filename))\n            with open(filepath, 'w') as w:\n                w.write(html)\n            logger.info(\"Wrote file to cache: {}\".format(filename))", "response": "Parse arguments request the urls notify if different."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef validate(self):\n\n        validate_url = \"https://api.pushover.net/1/users/validate.json\"\n\n        payload = {\n            'token': self.api_token,\n            'user': self.user,\n        }\n\n        return requests.post(validate_url, data=payload)", "response": "Validate the user and token returns the Requests response."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\npush a new message to the device.", "response": "def push(self, message, device=None, title=None, url=None, url_title=None,\n             priority=None, timestamp=None, sound=None):\n        \"\"\"Pushes the notification, returns the Requests response.\n\n        Arguments:\n            message -- your message\n\n        Keyword arguments:\n            device -- your user's device name to send the message directly to\n                that device, rather than all of the user's devices\n            title -- your message's title, otherwise your app's name is used\n            url -- a supplementary URL to show with your message\n            url_title -- a title for your supplementary URL, otherwise just the\n                URL is shown\n            priority -- send as --1 to always send as a quiet notification, 1\n                to display as high--priority and bypass the user's quiet hours,\n                or 2 to also require confirmation from the user\n            timestamp -- a Unix timestamp of your message's date and time to\n                display to the user, rather than the time your message is\n                received by our API\n            sound -- the name of one of the sounds supported by device clients\n                to override the user's default sound choice.\n        \"\"\"\n\n        api_url = 'https://api.pushover.net/1/messages.json'\n\n        payload = {\n            'token': self.api_token,\n            'user': self.user,\n            'message': message,\n            'device': device,\n            'title': title,\n            'url': url,\n            'url_title': url_title,\n            'priority': priority,\n            'timestamp': timestamp,\n            'sound': sound\n        }\n\n        return requests.post(api_url, params=payload)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ntake output from git log - oneline and extracts bug numbers", "response": "def extract_bugs(changelog):\n    \"\"\"Takes output from git log --oneline and extracts bug numbers\"\"\"\n    bug_regexp = re.compile(r'\\bbug (\\d+)\\b', re.IGNORECASE)\n    bugs = set()\n    for line in changelog:\n        for bug in bug_regexp.findall(line):\n            bugs.add(bug)\n\n    return sorted(list(bugs))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef __resolve_path(cls, obj, path):\n        path = filter(lambda s: s, path)\n        if any(path):\n            pathes = len(path)\n            i = 0\n            while i < pathes:\n                # _get_obj_attr can supersede `i` because it might\n                # evaluate the entire expression by itself.\n                obj, i = cls._get_obj_attr(obj, path, i)\n                i += 1\n        else:\n            raise Exception(\"Nothing to do\")\n        return obj", "response": "Follow a kwargsql expression starting from a given object\n        and return the deduced object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nresolve one kwargsql expression for a given object and returns the object s attribute.", "response": "def _get_obj_attr(cls, obj, path, pos):\n        \"\"\"Resolve one kwargsql expression for a given object and returns\n        its result.\n\n        :param obj: the object to evaluate\n        :param path: the list of all kwargsql expression, including those\n                     previously evaluated.\n        :param int pos: provides index of the expression to evaluate in the\n                        `path` parameter.\n        \"\"\"\n        field = path[pos]\n        if isinstance(obj, (dict, Mapping)):\n            return obj[field], pos\n        elif isinstance(obj, (list, Sequence)):\n            join_operation = cls.SEQUENCE_OPERATIONS.get(field)\n            if join_operation is not None:\n                return (\n                    AnySequenceResult(\n                        cls._sequence_map(obj, path[pos + 1:]),\n                        join_operation\n                    ),\n                    len(path) + 1,\n                )\n            else:\n                return obj[int(field)], pos\n        else:\n            return getattr(obj, field, None), pos"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get(ns, dburl=None):\n    '''\n    Get a default dones object for ns.  If no dones object exists for ns yet,\n    a DbDones object will be created, cached, and returned.\n    '''\n    if dburl is None:\n        dburl = DONES_DB_URL\n\n    cache_key = (ns, dburl)\n    if ns not in DONES_CACHE:\n        dones_ns = 'dones_{}'.format(ns)\n        DONES_CACHE[cache_key] = DbDones(ns=dones_ns, dburl=dburl)\n\n    return DONES_CACHE[cache_key]", "response": "Get a default dones object for ns."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef open_conn(host, db, user, password, retries=0, sleep=0.5):\n    '''\n    Return an open mysql db connection using the given credentials.  Use\n    `retries` and `sleep` to be robust to the occassional transient connection\n    failure.\n\n    retries: if an exception when getting the connection, try again at most this many times.\n    sleep: pause between retries for this many seconds.  a float >= 0.\n    '''\n    assert retries >= 0\n\n    try:\n        return MySQLdb.connect(host=host, user=user, passwd=password, db=db)\n    except Exception:\n        if retries > 0:\n            time.sleep(sleep)\n            return open_conn(host, db, user, password, retries - 1, sleep)\n        else:\n            raise", "response": "Open a mysql db connection."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef open_url(url, retries=0, sleep=0.5):\n    '''\n    Open a mysql connection to a url.  Note that if your password has\n    punctuation characters, it might break the parsing of url.\n\n    url: A string in the form \"mysql://username:password@host.domain/database\"\n    '''\n    return open_conn(retries=retries, sleep=sleep, **parse_url(url))", "response": "Open a mysql connection to a url."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef doTransaction(conn, start=True, startSQL='START TRANSACTION'):\n    '''\n    wrap a connection in a transaction.  starts a transaction, yields the conn, and then if an exception occurs, calls rollback().  otherwise calls commit().\n    start: if True, executes 'START TRANSACTION' sql before yielding conn.  Useful for connections that are autocommit by default.\n    startSQL: override if 'START TRANSACTION' does not work for your db server.\n    '''\n    try:\n        if start:\n            executeSQL(conn, startSQL)\n        yield conn\n    except:\n        if conn is not None:\n            conn.rollback()\n        raise\n    else:\n        conn.commit()", "response": "wrap a connection in a transaction yields the conn"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ninserts a new record into the database.", "response": "def insertSQL(conn, sql, args=None):\n    '''\n    args: if sql has parameters defined with either %s or %(key)s then args should be a either list or dict of parameter\n    values respectively.\n    returns the insert id\n    '''\n    with doCursor(conn) as cursor:\n        cursor.execute(sql, args)\n        id = conn.insert_id()\n        return id"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef executeSQL(conn, sql, args=None):\n    '''\n    args: if sql has parameters defined with either %s or %(key)s then args should be a either list or dict of parameter\n    values respectively.\n    executes sql statement.  useful for executing statements like CREATE TABLE or RENAME TABLE,\n    which do not have an result like insert id or a rowset.\n    returns: the number of rows affected by the sql statement if any.\n    '''\n    with doCursor(conn) as cursor:\n        numRowsAffected = cursor.execute(sql, args)\n        return numRowsAffected", "response": "Executes a sql statement and returns the number of rows affected by the sql statement."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\naccessing self. k indirectly allows for creating the kvstore table .", "response": "def _get_k(self):\n        '''\n        Accessing self.k indirectly allows for creating the kvstore table\n        if necessary.\n        '''\n        if not self.ready:\n            self.k.create() # create table if it does not exist.\n            self.ready = True\n\n        return self.k"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef clear(self):\n        '''\n        Remove all existing done markers and the file used to store the dones.\n        '''\n        if os.path.exists(self.path):\n            os.remove(self.path)", "response": "Remove all existing dones and the file used to store the dones."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef done(self, key):\n        '''\n        return True iff key is marked done.\n\n        :param key: a json-serializable object.\n        '''\n        # key is not done b/c the file does not even exist yet\n        if not os.path.exists(self.path):\n            return False\n\n        is_done = False\n        done_line = self._done_line(key)\n        undone_line = self._undone_line(key)\n        with open(self.path) as fh:\n            for line in fh:\n                if line == done_line:\n                    is_done = True\n                elif line == undone_line:\n                    is_done = False\n\n        return is_done", "response": "return True iff the key is marked done."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef are_done(self, keys):\n        '''\n        Return a list of boolean values corresponding to whether or not each\n        key in keys is marked done.  This method can be faster than\n        individually checking each key, depending on how many keys you\n        want to check.\n\n        :param keys: a list of json-serializable keys\n        '''\n        # No keys are done b/c the file does not even exist yet.\n        if not os.path.exists(self.path):\n            return [False] * len(keys)\n\n        done_lines = set([self._done_line(key) for key in keys])\n        undone_lines = set([self._undone_line(key) for key in keys])\n        status = {}\n        with open(self.path) as fh:\n            for line in fh:\n                if line in done_lines:\n                    # extract serialized key\n                    status[line[5:-1]] = True\n                elif line in undone_lines:\n                    status[line[5:-1]] = False\n        serialized_keys = [self._serialize(key) for key in keys]\n        return [status.get(sk, False) for sk in serialized_keys]", "response": "Return a list of boolean values corresponding to whether or not each key in keys is marked done."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nadd a key to the namespace", "response": "def add(self, key):\n        '''\n        add key to the namespace.  it is fine to add a key multiple times.\n        '''\n        encodedKey = json.dumps(key)\n        with self.connect() as conn:\n            with doTransaction(conn):\n                sql = 'INSERT IGNORE INTO ' + self.table + ' (name) VALUES (%s)'\n                return insertSQL(conn, sql, args=[encodedKey])"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nremoves a key from the namespace", "response": "def remove(self, key):\n        '''\n        remove key from the namespace.  it is fine to remove a key multiple times.\n        '''\n        encodedKey = json.dumps(key)\n        sql = 'DELETE FROM ' + self.table + ' WHERE name = %s'\n        with self.connect() as conn:\n            with doTransaction(conn):\n                return executeSQL(conn, sql, args=[encodedKey])"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef load_machine(self, descriptor):\n\t\tdef get_cfg(name):\n\t\t\tif(name in descriptor):\n\t\t\t\treturn descriptor[name]\n\t\t\telse:\n\t\t\t\treturn defaults[name]\n\t\tself.processor = Processor(width = get_cfg(\"width\"))\n\t\tself.rom = ROM(get_cfg(\"rom_size\"), get_cfg(\"rom_width\"))\n\t\tself.processor.register_memory_device(self.rom)\n\t\tself.registers = []\n\n\t\tif(get_cfg(\"ram_enable\")):\n\t\t\tself.ram = RAM(get_cfg(\"ram_size\"), get_cfg(\"ram_width\"))\n\t\t\tself.processor.register_memory_device(self.ram)\n\t\telse:\n\t\t\tself.ram = None\n\n\t\tif(get_cfg(\"flash_enable\")):\n\t\t\tself.flash = Flash(get_cfg(\"flash_size\"), get_cfg(\"flash_width\"))\n\t\t\tself.processor.register_device(self.flash)\n\t\telse:\n\t\t\tself.flash = None\n\n\t\tfor register in get_cfg(\"registers\"):\n\t\t\tself.processor.add_register(register)\n\t\t\tself.registers.append(register)\n\t\tfor command in get_cfg(\"commands\"):\n\t\t\tself.processor.register_command(command)\n\t\tself.processor.setup_done()", "response": "Load a complete register machine."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nassemble the given code and program the ROM.", "response": "def assemble_rom_code(self, asm):\n\t\t\"\"\"\n\t\t\tassemble the given code and program the ROM\n\t\t\"\"\"\n\t\tstream = StringIO(asm)\n\t\tworker = assembler.Assembler(self.processor, stream)\n\t\ttry:\n\t\t\tresult = worker.assemble()\n\t\texcept BaseException as e:\n\t\t\treturn e, None\n\t\tself.rom.program(result)\n\t\treturn None, result"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nassemble the given code and program the Flash", "response": "def assemble_flash_code(self, asm):\n\t\t\"\"\"\n\t\t\tassemble the given code and program the Flash\n\t\t\"\"\"\n\t\tstream = StringIO(asm)\n\t\tworker = assembler.Assembler(self.processor, stream)\n\t\ttry:\n\t\t\tresult = worker.assemble()\n\t\texcept BaseException as e:\n\t\t\treturn e, None\n\t\tself.flash.program(result)\n\t\treturn None, result"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef flush_devices(self):\n\t\tself.rom.program([0 for i in range(self.rom.size)])\n\t\tself.flash.program([0 for i in range(self.flash.size)])\n\t\tfor i in range(self.ram.size):\n\t\t\tself.ram.write(i, 0)", "response": "Flush all devices in the memory."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_rom(self, format_ = \"nl\"):\n\t\trom = [self.rom.read(i) for i in range(self.rom.size)]\n\t\treturn self._format_mem(rom, format_)", "response": "get_rom returns a string representations of the rom"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_ram(self, format_ = \"nl\"):\n\t\tram = [self.ram.read(i) for i in range(self.ram.size)]\n\t\treturn self._format_mem(ram, format_)", "response": "get_ram returns a string representation of the RAM"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting a string representation of the flash", "response": "def get_flash(self, format_ = \"nl\"):\n\t\t\"\"\"\n\t\t\treturn a string representations of the flash\n\t\t\"\"\"\n\t\tflash = [self.flash.read(i) for i in range(self.flash.size)]\n\t\treturn self._format_mem(flash, format_)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef emit(self, action, payload=None, retry=0):\n        payload = payload or {}\n\n        if retry:\n            _retry = self.transport.retry(retry)\n            emit = _retry(self.transport.emit)\n        else:\n            emit = self.transport.emit\n\n        return emit(action, payload)", "response": "Emit action with payload."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets upcoming PythonKC meetup events.", "response": "def get_upcoming_events(self):\n        \"\"\"\n        Get upcoming PythonKC meetup events.\n\n        Returns\n        -------\n        List of ``pythonkc_meetups.types.MeetupEvent``, ordered by event time,\n        ascending.\n\n        Exceptions\n        ----------\n        * PythonKCMeetupsBadJson\n        * PythonKCMeetupsBadResponse\n        * PythonKCMeetupsMeetupDown\n        * PythonKCMeetupsNotJson\n        * PythonKCMeetupsRateLimitExceeded\n\n        \"\"\"\n\n        query = urllib.urlencode({'key': self._api_key,\n                                  'group_urlname': GROUP_URLNAME})\n        url = '{0}?{1}'.format(EVENTS_URL, query)\n        data = self._http_get_json(url)\n        events = data['results']\n        return [parse_event(event) for event in events]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_past_events(self):\n\n        def get_attendees(event):\n            return [attendee for event_id, attendee in events_attendees\n                    if event_id == event['id']]\n\n        def get_photos(event):\n            return [photo for event_id, photo in events_photos\n                    if event_id == event['id']]\n\n        params = {'key': self._api_key,\n                  'group_urlname': GROUP_URLNAME,\n                  'status': 'past',\n                  'desc': 'true'}\n        if self._num_past_events:\n            params['page'] = str(self._num_past_events)\n        query = urllib.urlencode(params)\n        url = '{0}?{1}'.format(EVENTS_URL, query)\n        data = self._http_get_json(url)\n\n        events = data['results']\n        event_ids = [event['id'] for event in events]\n\n        events_attendees = self.get_events_attendees(event_ids)\n        events_photos = self.get_events_photos(event_ids)\n\n        return [parse_event(event, get_attendees(event), get_photos(event))\n                for event in events]", "response": "Get past PythonKC meetup events."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_events_attendees(self, event_ids):\n        query = urllib.urlencode({'key': self._api_key,\n                                  'event_id': ','.join(event_ids)})\n        url = '{0}?{1}'.format(RSVPS_URL, query)\n        data = self._http_get_json(url)\n        rsvps = data['results']\n        return [(rsvp['event']['id'], parse_member_from_rsvp(rsvp))\n                for rsvp in rsvps\n                if rsvp['response'] != \"no\"]", "response": "Get the attendees of the identified events."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_event_attendees(self, event_id):\n        query = urllib.urlencode({'key': self._api_key,\n                                  'event_id': event_id})\n        url = '{0}?{1}'.format(RSVPS_URL, query)\n        data = self._http_get_json(url)\n        rsvps = data['results']\n        return [parse_member_from_rsvp(rsvp) for rsvp in rsvps\n                if rsvp['response'] != \"no\"]", "response": "Get the attendees of the identified event."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_events_photos(self, event_ids):\n        query = urllib.urlencode({'key': self._api_key,\n                                  'event_id': ','.join(event_ids)})\n        url = '{0}?{1}'.format(PHOTOS_URL, query)\n        data = self._http_get_json(url)\n        photos = data['results']\n        return [(photo['photo_album']['event_id'], parse_photo(photo))\n                for photo in photos]", "response": "Get photos for the identified events."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_event_photos(self, event_id):\n        query = urllib.urlencode({'key': self._api_key,\n                                  'event_id': event_id})\n        url = '{0}?{1}'.format(PHOTOS_URL, query)\n        data = self._http_get_json(url)\n        photos = data['results']\n        return [parse_photo(photo) for photo in photos]", "response": "Get photos for the identified event."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _http_get_json(self, url):\n        response = self._http_get(url)\n\n        content_type = response.headers['content-type']\n        parsed_mimetype = mimeparse.parse_mime_type(content_type)\n        if parsed_mimetype[1] not in ('json', 'javascript'):\n            raise PythonKCMeetupsNotJson(content_type)\n\n        try:\n            return json.loads(response.content)\n        except ValueError as e:\n            raise PythonKCMeetupsBadJson(e)", "response": "Make an HTTP GET request to the specified URL and return the parsed JSON response."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nmaking an HTTP GET request to the specified URL and return the response.", "response": "def _http_get(self, url):\n        \"\"\"\n        Make an HTTP GET request to the specified URL and return the response.\n\n        Retries\n        -------\n        The constructor of this class takes an argument specifying the number\n        of times to retry a GET. The statuses which are retried on are: 408,\n        500, 502, 503, and 504.\n\n        Returns\n        -------\n        An HTTP response, containing response headers and content.\n\n        Exceptions\n        ----------\n        * PythonKCMeetupsBadResponse\n        * PythonKCMeetupsMeetupDown\n        * PythonKCMeetupsRateLimitExceeded\n\n        \"\"\"\n        for try_number in range(self._http_retries + 1):\n            response = requests.get(url, timeout=self._http_timeout)\n            if response.status_code == 200:\n                return response\n\n            if (try_number >= self._http_retries or\n                    response.status_code not in (408, 500, 502, 503, 504)):\n\n                if response.status_code >= 500:\n                    raise PythonKCMeetupsMeetupDown(response, response.content)\n                if response.status_code == 400:\n                    try:\n                        data = json.loads(response.content)\n                        if data.get('code', None) == 'limit':\n                            raise PythonKCMeetupsRateLimitExceeded\n                    except:  # Don't lose original error when JSON is bad\n                        pass\n                raise PythonKCMeetupsBadResponse(response, response.content)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsave all the modules that have changed", "response": "def save():\n    \"\"\"\n    Apply configuration changes on all the modules\n    \"\"\"\n    from .models import ModuleInfo\n\n    logger = logging.getLogger(__name__)\n    logger.info(\"Saving changes\")\n\n    # Save + restart\n    for module in modules():\n        if module.enabled:\n            if module.changed:\n                module.save()\n                module.restart()\n                module.commit()\n            else:\n                logger.debug('Not saving unchanged module: %s' %\n                             module.verbose_name)\n        else:\n            logger.debug('Not saving disabled module: %s' %\n                         module.verbose_name)\n\n    # Commit\n    ModuleInfo.commit()\n\n    logger.info(\"Changes saved\")"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns the default menus for this field.", "response": "def get_default(self):\n        \"\"\"\n        If the user provided a default in the field definition, returns it,\n        otherwise determines the default menus based on available choices and\n        ``PAGE_MENU_TEMPLATES_DEFAULT``. Ensures the default is not mutable.\n        \"\"\"\n        if self._overridden_default:\n            # Even with user-provided default we'd rather not have it\n            # forced to text. Compare with Field.get_default().\n            if callable(self.default):\n                default = self.default()\n            else:\n                default = self.default\n        else:\n            # Depending on PAGE_MENU_TEMPLATES_DEFAULT:\n            # * None or no value: all choosable menus;\n            # * some sequence: specified menus;\n            # (* empty sequence: no menus).\n            default = getattr(settings, \"PAGE_MENU_TEMPLATES_DEFAULT\", None)\n            if default is None:\n                choices = self.get_choices(include_blank=False)\n                default = (c[0] for c in choices)\n        # Default can't be mutable, as references to it are shared among\n        # model instances; all sane values should be castable to a tuple.\n        return tuple(default)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a list of menus specified in PAGE_MENU_TEMPLATES unless you provide a custom choices in the field definition.", "response": "def _get_choices(self):\n        \"\"\"\n        Returns menus specified in ``PAGE_MENU_TEMPLATES`` unless you provide\n        some custom choices in the field definition.\n        \"\"\"\n        if self._overridden_choices:\n            # Note: choices is a property on Field bound to _get_choices().\n            return self._choices\n        else:\n            menus = getattr(settings, \"PAGE_MENU_TEMPLATES\", [])\n            return (m[:2] for m in menus)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the job data with its scheduled timestamp.", "response": "def job_details(job_id, connection=None):\n    \"\"\"Returns the job data with its scheduled timestamp.\n\n    :param job_id: the ID of the job to retrieve.\"\"\"\n    if connection is None:\n        connection = r\n    data = connection.hgetall(job_key(job_id))\n\n    job_data = {'id': job_id, 'schedule_at': int(connection.zscore(REDIS_KEY,\n                                                                   job_id))}\n    for key, value in data.items():\n        try:\n            decoded = value.decode('utf-8')\n        except UnicodeDecodeError:\n            decoded = value\n        if decoded.isdigit():\n            decoded = int(decoded)\n        job_data[key.decode('utf-8')] = decoded\n    return job_data"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef schedule_job(job_id, schedule_in, connection=None, **kwargs):\n    if not isinstance(schedule_in, int):  # assumed to be a timedelta\n        schedule_in = schedule_in.days * 3600 * 24 + schedule_in.seconds\n    schedule_at = int(time.time()) + schedule_in\n\n    if connection is None:\n        connection = r\n\n    if 'id' in kwargs:\n        raise RuntimeError(\"'id' is a reserved key for the job ID\")\n\n    with connection.pipeline() as pipe:\n        if schedule_at is not None:\n            args = (schedule_at, job_id)\n            if isinstance(connection, redis.Redis):\n                # StrictRedis or Redis don't have the same argument order\n                args = (job_id, schedule_at)\n            pipe.zadd(REDIS_KEY, *args)\n        delete = []\n        hmset = {}\n        for key, value in kwargs.items():\n            if value is None:\n                delete.append(key)\n            else:\n                hmset[key] = value\n        if hmset:\n            pipe.hmset(job_key(job_id), hmset)\n        if len(delete) > 0:\n            pipe.hdel(job_key(job_id), *delete)\n        pipe.execute()", "response": "Schedules a job in the order that it is in the job tree."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef delete_job(job_id, connection=None):\n    if connection is None:\n        connection = r\n    with connection.pipeline() as pipe:\n        pipe.delete(job_key(job_id))\n        pipe.zrem(REDIS_KEY, job_id)\n        pipe.execute()", "response": "Deletes a job.\n\n    :param job_id: unique identifier for this job\n\n    >>> delete_job('http://example.com/test')"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a generator that yields all the pending jobs in the current node.", "response": "def pending_jobs(reschedule_in=None, limit=None, connection=None):\n    \"\"\"Gets the job needing execution.\n\n    :param reschedule_in: number of seconds in which returned jobs should be\n    auto-rescheduled. If set to None (default), jobs are not auto-rescheduled.\n    :param limit: max number of jobs to retrieve. If set to None (default),\n    retrieves all pending jobs with no limit.\n    \"\"\"\n    if connection is None:\n        connection = r\n    start = None if limit is None else 0\n    job_ids = connection.zrangebyscore(REDIS_KEY, 0, int(time.time()),\n                                       start=start, num=limit)\n\n    with connection.pipeline() as pipe:\n        if reschedule_in is None:\n            for job_id in job_ids:\n                pipe.zrem(REDIS_KEY, job_id)\n        else:\n            schedule_at = int(time.time()) + reschedule_in\n            for job_id in job_ids:\n                args = (schedule_at, job_id)\n                if isinstance(connection, redis.Redis):\n                    # StrictRedis or Redis don't have the same argument order\n                    args = (job_id, schedule_at)\n                pipe.zadd(REDIS_KEY, *args)\n        pipe.execute()\n\n    with connection.pipeline() as pipe:\n        for job_id in job_ids:\n            pipe.hgetall(job_key(job_id.decode('utf-8')))\n        jobs = pipe.execute()\n    for job_id, data in izip(job_ids, jobs):\n        job_data = {'id': job_id.decode('utf-8')}\n        for key, value in data.items():\n            try:\n                decoded = value.decode('utf-8')\n            except UnicodeDecodeError:\n                decoded = value\n            if decoded.isdigit():\n                decoded = int(decoded)\n            job_data[key.decode('utf-8')] = decoded\n        yield job_data"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef scheduled_jobs(with_times=False, connection=None):\n    if connection is None:\n        connection = r\n    jobs = connection.zrangebyscore(REDIS_KEY, 0, sys.maxsize,\n                                    withscores=with_times)\n    for job in jobs:\n        if with_times:\n            yield job[0].decode('utf-8'), job[1]\n        else:\n            yield job.decode('utf-8')", "response": "Gets all jobs in the scheduler."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef run(self, host=None, port=None, debug=None, **options):\n\n        tasks = options.get('tasks', [])\n        for task in tasks:\n            if task is not None and hasattr(task, '__call__'):\n                _batch_tasks.append(task)\n\n        thread = Thread(target=self.batch_work)\n        thread.start()\n\n        try:\n            super(AgoraApp, self).run(host='0.0.0.0', port=self.config['PORT'], debug=True, use_reloader=False)\n        except Exception, e:\n            print e.message\n        self._stop_event.set()\n        if thread.isAlive():\n            thread.join()", "response": "Start the AgoraApp expecting the provided config to have at least REDIS and PORT fields."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _handle_exc(exception):\n    # Set the description to a familiar string with the exception\n    # message. Add the stack trace to extra.\n    bugzscout.ext.celery_app.submit_error.delay(\n        'http://fogbugz/scoutSubmit.asp',\n        'error-user',\n        'MyAppProject',\n        'Errors',\n        'An error occurred in MyApp: {0}'.format(exception.message),\n        extra=traceback.extract_tb(*sys.exc_info()))\n\n    # Return an empty body.\n    return ['']", "response": "Handle uncaught exception in app\n   ."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef app(environ, start_response):\n    try:\n        if environ['REQUEST_METHOD'] == 'GET':\n            start_response('200 OK', [('content-type', 'text/html')])\n            return ['Hellow world!']\n        else:\n            start_response(\n                '405 Method Not Allowed', [('content-type', 'text/html')])\n            return ['']\n    except Exception as ex:\n        # Call start_response with exception info.\n        start_response(\n            '500 Internal Server Error',\n            [('content-type', 'text/html')],\n            sys.exc_info())\n\n        # Record the error to FogBugz and this will return the body for the\n        # error response.\n        return _handle_exc(ex)", "response": "Simple WSGI application that returns a list of the content of the current object."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nadd the cookbook management command and arguments.", "response": "def add_cookbook_mgmt_options(parser):\n    \"\"\"Add the cookbook management command and arguments.\n\n    :rtype: argparse.ArgumentParser\n\n    \"\"\"\n    cookbook = parser.add_parser('cookbook', help='Invoke in a Jenkins job to '\n                                                  'update a cookbook in '\n                                                  'chef-repo')\n    cookbook.add_argument('repo', action='store',\n                          help='Git URL for chef-repo')\n    cookbook.set_defaults(func='process_cookbook')"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef add_github_hook_options(parser):\n    cookbook = parser.add_parser('github', help='Install the Jenkins callback '\n                                                'hook in a GitHub repository')\n    cookbook.add_argument('owner', action='store',\n                          help='The owner of the GitHub repo')\n    cookbook.add_argument('repo', action='store',\n                          help='The GitHub repository name')\n    domain = socket.gethostname()\n    example = 'jenkins.%s' % domain\n    cookbook.add_argument('jenkins_hook_url', action='store',\n                          help='The jenkins hook URL. For example %s' % example)\n\n    cookbook.add_argument('-g', '--github-host',\n                          action='store',\n                          dest='github',\n                          default=github.GITHUB_HOST,\n                          help='Override github.com for a '\n                               'GitHub::Enterprise host')\n    cookbook.add_argument('-u', '--username',\n                          action='store',\n                          dest='username',\n                          help='Specify a different username than the repo '\n                               'owner')\n\n    cookbook.set_defaults(func='github_hooks')", "response": "Adds the github jenkins hook command and arguments."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add_jenkins_job_options(parser):\n    cookbook = parser.add_parser('jenkins', help='Add a new cookbook job to '\n                                                 'Jenkins')\n    cookbook.add_argument('jenkins', action='store',\n                          help='The jenkins server hostname')\n    cookbook.add_argument('name', action='store',\n                          help='The cookbook name')\n    cookbook.add_argument('cookbook', action='store',\n                          help='The cookbook git repository URL')\n    cookbook.add_argument('chef_repo', action='store',\n                          help='The chef-repo git repository URL')\n    cookbook.add_argument('-u', '--username',\n                          action='store',\n                          dest='username',\n                          default=pwd.getpwuid(os.getuid())[0],\n                          help='Specify a different username than the repo '\n                               'owner')\n    cookbook.add_argument('-n', '--hipchat-notification',\n                          action='store',\n                          dest='hipchat',\n                          help='Hipchat room for notifications')\n    cookbook.set_defaults(func='new_job')", "response": "Adds the options needed to create a new job to Jenkins for updating chef - repo"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nbuilding the argument parser", "response": "def argparser():\n    \"\"\"Build the argument parser\n\n    :rtype: argparse.ArgumentParser\n\n    \"\"\"\n    parser = argparse.ArgumentParser(description=__description__)\n    sparser = parser.add_subparsers()\n    add_cookbook_mgmt_options(sparser)\n    add_role_options(sparser)\n    add_github_hook_options(sparser)\n    add_jenkins_job_options(sparser)\n    return parser"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nregisters a callable to be executed when a module is imported.", "response": "def register_adapter(mod, func):\n    \"\"\"\n    Registers a callable to be executed when a module is imported. If the\n    module already exists then the callable will be executed immediately.\n    You can register the same module multiple times, the callables will be\n    executed in the order they were registered. The root module must exist\n    (i.e. be importable) otherwise an `ImportError` will be thrown.\n\n    @param mod: The fully qualified module string, as used in the imports\n        statement. E.g. 'foo.bar.baz'. The string must map to a module\n        otherwise the callable will not fire.\n    @param func: The function to call when C{mod} is imported. This function\n        must take one arg, the newly imported C{module} object.\n    @type func: callable\n    @raise TypeError: C{func} must be callable\n    \"\"\"\n    if not hasattr(func, '__call__'):\n        raise TypeError('func must be callable')\n\n    imports.when_imported(mod, func)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nrender field errors as html.", "response": "def render_field_errors(field):\n    \"\"\"\n    Render field errors as html.\n    \"\"\"\n    if field.errors:\n        html = \"\"\"<p class=\"help-block\">Error: {errors}</p>\"\"\".format(\n            errors='. '.join(field.errors)\n        )\n        return HTMLString(html)\n\n    return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef render_field_description(field):\n    if hasattr(field, 'description') and field.description != '':\n        html = \"\"\"<p class=\"help-block\">{field.description}</p>\"\"\"\n        html = html.format(\n            field=field\n        )\n        return HTMLString(html)\n    \n    return ''", "response": "Render a field description as HTML."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef form_group_wrapped(f):\n    @wraps(f)\n    def wrapped(self, field, *args, **kwargs):\n        classes = ['form-group']\n        if field.errors:\n            classes.append('has-error')\n\n        html = \"\"\"<div class=\"{classes}\">{rendered_field}</div>\"\"\".format(\n            classes=' '.join(classes),\n            rendered_field=f(self, field, *args, **kwargs)\n        )\n        return HTMLString(html)\n\n    return wrapped", "response": "Decorator that wraps a field within a bootstrap form - group."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd a field label, errors, and a description (if it exists) to a field.", "response": "def meta_wrapped(f):\n    \"\"\"\n    Add a field label, errors, and a description (if it exists) to \n    a field. \n    \"\"\"\n    @wraps(f)\n    def wrapped(self, field, *args, **kwargs):\n        html = \"{label}{errors}{original}<small>{description}</small>\".format(\n            label=field.label(class_='control-label'),\n            original=f(self, field, *args, **kwargs),\n            errors=render_field_errors(field) or '',\n            description=render_field_description(field)\n        )\n        return HTMLString(html)\n    return wrapped"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef bootstrap_styled(cls=None, add_meta=True, form_group=True, \n    input_class='form-control'):\n    \"\"\"\n    Wrap a widget to conform with Bootstrap's html control design.\n    \n    \n    Args:\n        input_class: Class to give to the rendered <input> control.\n        add_meta: bool: \n    \"\"\"\n\n    def real_decorator(cls):\n        class NewClass(cls): pass\n        NewClass.__name__ = cls.__name__\n        NewClass = custom_widget_wrapper(NewClass)\n\n        _call = NewClass.__call__\n\n        def call(*args, **kwargs):\n            if input_class:\n                kwargs.setdefault('class', input_class)\n\n            return _call(*args, **kwargs)\n\n        if add_meta: call = meta_wrapped(call)\n        if form_group: call = form_group_wrapped(call)\n\n        NewClass.__call__ = call\n        return NewClass\n\n    if cls:\n        # Allow calling decorator(cls) instead of decorator()(cls)\n        rv = real_decorator(cls)\n        return rv\n\n    return real_decorator", "response": "Decorator for Bootstrap s html control design."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _batches_to_tmpfile(in_record_sep, in_column_sep, in_batches, batch_to_file_s):\n        for i, b2f in enumerate(batch_to_file_s):\n            if b2f.is_tmpfile():\n                input_str = BaseShellOperator._input_str(in_batches[i], in_record_sep, in_column_sep)\n                b2f.write_tmpfile(input_str)", "response": "Write in - batches to a temporary file."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nwrite in - batch contents to process s stdin.", "response": "def _batch_to_stdin(process, in_record_sep, in_column_sep, in_batches, batch_to_file_s):\n        \"\"\"Write in-batch contents to `process` 's stdin (if necessary)\n        \"\"\"\n        for i, b2f in enumerate(batch_to_file_s):\n            if b2f.is_stdin():\n                input_str = BaseShellOperator._input_str(in_batches[i], in_record_sep, in_column_sep)\n                b2f.write_stdin(process.stdin, input_str)\n                break"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef update_post_relations(user, topic, deleting=False):\n    if deleting:\n        user.post_count = user.post_count - 1\n    else:\n        user.post_count += 1\n    user.save(update_fields=['post_count'])\n\n    topic.modified     = datetime.now()\n    topic.modified_int = time.time()\n    topic.save(update_fields=['modified', 'modified_int'])", "response": "helper function to update user post count and topic post count."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a reference to the C { django_objects } on the context.", "response": "def getDjangoObjects(context):\n    \"\"\"\n    Returns a reference to the C{django_objects} on the context. If it doesn't\n    exist then it is created.\n\n    @rtype: Instance of L{DjangoReferenceCollection}\n    @since: 0.5\n    \"\"\"\n    c = context.extra\n    k = 'django_objects'\n\n    try:\n        return c[k]\n    except KeyError:\n        c[k] = DjangoReferenceCollection()\n\n    return c[k]"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef writeDjangoObject(obj, encoder=None):\n    s = obj.pk\n\n    if s is None:\n        encoder.writeObject(obj)\n\n        return\n\n    django_objects = getDjangoObjects(encoder.context)\n    kls = obj.__class__\n\n    try:\n        referenced_object = django_objects.getClassKey(kls, s)\n    except KeyError:\n        referenced_object = obj\n        django_objects.addClassKey(kls, s, obj)\n\n    encoder.writeObject(referenced_object)", "response": "Writes a django object to the encoder."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef getClassKey(self, klass, key):\n        d = self._getClass(klass)\n\n        return d[key]", "response": "Returns an instance based on klass and key."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef addClassKey(self, klass, key, obj):\n        d = self._getClass(klass)\n\n        d[key] = obj", "response": "Adds an object to the collection based on the class and key."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nparse an ISO8601 formatted duration.", "response": "def parse_duration(duration, start=None, end=None):\n    \"\"\"\n    Attepmt to parse an ISO8601 formatted duration.\n\n    Accepts a ``duration`` and optionally a start or end ``datetime``.\n    ``duration`` must be an ISO8601 formatted string.\n\n    Returns a ``datetime.timedelta`` object.\n    \"\"\"\n    if not start and not end:\n        return parse_simple_duration(duration)\n\n    if start:\n        return parse_duration_with_start(start, duration)\n\n    if end:\n        return parse_duration_with_end(duration, end)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef parse_simple_duration(duration):\n    elements = _parse_duration_string(_clean(duration))\n\n    if not elements:\n        raise ParseError()\n\n    return _timedelta_from_elements(elements)", "response": "A simple duration parser that parses an ISO8601 formatted string and returns a datetime. timedelta object."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nconvert an integer to a bitcoin variable length integer as a bytearray", "response": "def int_to_var_bytes(x):\n    \"\"\"Converts an integer to a bitcoin variable length integer as a bytearray\n\n    :param x: the integer to convert\n    \"\"\"\n    if x < 253:\n        return intbytes.to_bytes(x, 1)\n    elif x < 65536:\n        return bytearray([253]) + intbytes.to_bytes(x, 2)[::-1]\n    elif x < 4294967296:\n        return bytearray([254]) + intbytes.to_bytes(x, 4)[::-1]\n    else:\n        return bytearray([255]) + intbytes.to_bytes(x, 8)[::-1]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef bitcoin_sig_hash(message):\n    padded = b'\\x18Bitcoin Signed Message:\\n' +\\\n        int_to_var_bytes(len(message)) +\\\n        message\n    return double_sha256(padded)", "response": "Hash a bitcoin - signed message."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef verify_signature(message, signature, address):\n    if (len(signature) != SIGNATURE_LENGTH):\n        return False\n\n    try:\n        binsig = base64.b64decode(signature)\n    except:\n        return False\n\n    r = intbytes.from_bytes(binsig[1:33])\n\n    s = intbytes.from_bytes(binsig[33:65])\n\n    val = intbytes.from_bytes(bitcoin_sig_hash(message.encode()))\n\n    pubpairs = possible_public_pairs_for_signature(\n        generator_secp256k1,\n        val,\n        (r, s))\n\n    addr_hash160 = bitcoin_address_to_hash160_sec(address)\n\n    for pair in pubpairs:\n        if (public_pair_to_hash160_sec(pair, True) == addr_hash160):\n            return True\n        if (public_pair_to_hash160_sec(pair, False) == addr_hash160):\n            return True\n\n    return False", "response": "This function verifies a bitcoin signed message."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef query(self, query):\n        return query((self._deserialised_value(x) for x in self.container.get_objects(prefix=query.key)))", "response": "Returns an iterable of objects matching criteria expressed in query."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef save(self, force_insert=False, force_update=False):\n        if force_insert and force_update:\n            raise ValueError(\"Cannot force both insert and updating in resource saving.\")\n\n        data = {}\n\n        for name, field in self._meta.fields.items():\n            if field.serialize:\n                data[name] = field.dehydrate(getattr(self, name, None))\n\n        insert = True if force_insert or self.resource_uri is None else False\n\n        if insert:\n            resp = self._meta.api.http_resource(\"POST\", self._meta.resource_name, data=self._meta.api.resource_serialize(data))\n        else:\n            resp = self._meta.api.http_resource(\"PUT\", self.resource_uri, data=self._meta.api.resource_serialize(data))\n\n        if \"Location\" in resp.headers:\n            resp = self._meta.api.http_resource(\"GET\", resp.headers[\"Location\"])\n        elif resp.status_code == 204:\n            resp = self._meta.api.http_resource(\"GET\", self.resource_uri)\n        else:\n            return\n\n        data = self._meta.api.resource_deserialize(resp.text)\n\n        # Update local values from the API Response\n        self.__init__(**data)", "response": "Saves the current instance of the current object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef delete(self):\n        if self.resource_uri is None:\n            raise ValueError(\"{0} object cannot be deleted because resource_uri attribute cannot be None\".format(self._meta.resource_name))\n\n        self._meta.api.http_resource(\"DELETE\", self.resource_uri)", "response": "Delete the current instance of the resource."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nspawning an actor using the given factory with the specified name.", "response": "def spawn_actor(self, factory, name=None):\n        \"\"\"Spawns an actor using the given `factory` with the specified `name`.\n\n        Returns an immediately usable `Ref` to the newly created actor, regardless of the location of the new actor, or\n        when the actual spawning will take place.\n        \"\"\"\n        if name and '/' in name:  # pragma: no cover\n            raise TypeError(\"Actor names cannot contain slashes\")\n        if not self._children:\n            self._children = {}\n        uri = self.uri / name if name else None\n        if name:\n            if name.startswith('$'):\n                raise ValueError(\"Unable to spawn actor at path %s; name cannot start with '$', it is reserved for auto-generated names\" % (uri.path,))\n            if name in self._children:\n                raise NameConflict(\"Unable to spawn actor at path %s; actor %r already sits there\" % (uri.path, self._children[name]))\n        if not uri:\n            name = self._generate_name(factory)\n            uri = self.uri / name\n        assert name not in self._children  # XXX: ordering??\n        child = self._children[name] = Cell.spawn(parent_actor=self.ref, factory=factory, uri=uri, node=self.node).ref\n        return child"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nlook up a local actor by its location relative to this actor.", "response": "def lookup_cell(self, uri):\n        \"\"\"Looks up a local actor by its location relative to this actor.\"\"\"\n        steps = uri.steps\n        if steps[0] == '':\n            found = self.root\n            steps.popleft()\n        else:\n            found = self\n        for step in steps:\n            assert step != ''\n            found = found.get_child(step)\n            if not found:\n                break\n            found = found._cell\n        return found"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef r_num(obj):\n    if isinstance(obj, (list, tuple)):\n        it = iter\n    else:\n        it = LinesIterator\n    dataset = Dataset([Dataset.FLOAT])\n    return dataset.load(it(obj))", "response": "Read list of numbers."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreading date - value table.", "response": "def r_date_num(obj, multiple=False):\n    \"\"\"Read date-value table.\"\"\"\n    if isinstance(obj, (list, tuple)):\n        it = iter\n    else:\n        it = LinesIterator\n    if multiple:\n        datasets = {}\n        for line in it(obj):\n            label = line[2]\n            if label not in datasets:\n                datasets[label] = Dataset([Dataset.DATE, Dataset.FLOAT])\n                datasets[label].name = label\n            datasets[label].parse_elements(line[0:2])\n        return datasets.values()\n    dataset = Dataset([Dataset.DATE, Dataset.FLOAT])\n    return dataset.load(it(obj))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef command(self, rule, **options):\n        options.setdefault(\"direct\", False)\n        options.setdefault(\"override\", True)\n        options.setdefault(\"inject\", False)\n        options.setdefault(\"flags\", 0)\n        if not options[\"direct\"]:\n            rule = self.regexy(rule)\n        regex = re.compile(rule, flags=options[\"flags\"])\n        self.handlers.setdefault(regex, [])\n        def handler(f):\n            if f == noop:\n                f.options = {}\n            else:\n                f.options = options\n            if options[\"override\"]:\n                self.handlers[regex] = [f]\n            else:\n                self.handlers[regex].append(f)\n            f.no_args = self.no_args(f)\n            return f\n        return handler", "response": "A function to create a handler function that will be called when a new entry is created."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef parse(self, line, **options):\n        line = line.strip()\n        if not line:\n            return (False, (), {})\n        split = line.split()\n        cmd, args = split[0], split[1:]\n        return (cmd, args, {})", "response": "Parse a line of text and return a tuple of cmd args kwargs"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef authorize_client_credentials(\n        self, client_id, client_secret=None, scope=\"private_agent\"\n    ):\n        \"\"\"Authorize to platform with client credentials\n\n        This should be used if you posses client_id/client_secret pair\n        generated by platform.\n        \"\"\"\n        self.auth_data = {\n            \"grant_type\": \"client_credentials\",\n            \"scope\": [ scope ],\n            \"client_id\": client_id,\n            \"client_secret\": client_secret\n        }\n\n        self._do_authorize()", "response": "Authorize to platform with client credentials"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef authorize_password(self, client_id, username, password):\n\n        self.auth_data = {\n            \"grant_type\": \"password\",\n            \"username\": username,\n            \"password\": password,\n            \"client_id\": client_id,\n            \"scope\": [\"regular_user\"]\n        }\n\n        self._do_authorize()", "response": "Authorize to platform as regular user"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _do_request(self, method, endpoint, data=None):\n        # No token - authorize\n        if self.token is None:\n            self._do_authorize()\n\n        r = requests.request(\n            method,\n            \"{0}{1}\".format(self.base_url, endpoint),\n            headers={\n                \"Authorization\": \"Bearer {0}\".format(self.token),\n                \"Content-Type\": \"application/json\"\n            },\n            json=data,\n            verify=self.verify_certificate,\n            timeout=self.timeout\n        )\n\n        if r.status_code == 401:\n            self._do_authorize()\n            r = requests.request(\n                method,\n                \"{0}{1}\".format(self.base_url, endpoint),\n                headers={\n                    \"Authorization\": \"Bearer {0}\".format(self.token),\n                    \"Content-Type\": \"application/json\"\n                },\n                json=data,\n                verify=self.verify_certificate,\n                timeout=self.timeout\n            )\n\n        return r", "response": "Perform one request possibly solving unauthorized return code\n           "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a list of possible typos for the given word.", "response": "def spellchecker(word):\n    \"\"\"\n    Looks for possible typos, i.e., deletion, insertion, transposition and\n    alteration. If the target is 'audreyr': deletion is 'adreyr', insertion is\n    'audreeyr', transposition is 'aurdeyr' and alteration is 'audriyr'.\n\n    Returns a list of possible words sorted by matching the same length.\n    \"\"\"\n    splits = [(word[:i], word[i:]) for i in range(len(word) + 1)]\n    deletes = [a + b[1:] for a, b in splits if b]\n    transposes = [a + b[1] + b[0] + b[2:] for a, b in splits if len(b) > 1]\n    replaces = [a + c + b[1:] for a, b in splits for c in ALPHABET if b]\n    inserts = [a + c + b for a, b in splits for c in ALPHABET]\n    guesses = set(deletes + transposes + replaces + inserts)\n    sorted_guesses = sorted(guesses, key=lambda w: len(w) == len(word),\n                            reverse=True)\n    return sorted_guesses"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef check_license(package_info, *args):\n    classifiers = package_info.get('classifiers')\n    reason = \"No License\"\n    result = False\n\n    if len([c for c in classifiers if c.startswith('License ::')]) > 0:\n        result = True\n\n    return result, reason, HAS_LICENSE", "response": "Checks if the package has a license classifier."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncheck if the package has a homepage listed?", "response": "def check_homepage(package_info, *args):\n    \"\"\"\n    Does the package have a homepage listed?\n    :param package_info: package_info dictionary\n    :return: Tuple (is the condition True or False?, reason if it is False else None)\n    \"\"\"\n    reason = \"Home page missing\"\n    result = False\n\n    if package_info.get('home_page') not in BAD_VALUES:\n        result = True\n\n    return result, reason, HAS_HOMEPAGE"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef check_summary(package_info, *args):\n    reason = \"Summary missing\"\n    result = False\n\n    if package_info.get('summary') not in BAD_VALUES:\n        result = True\n\n    return result, reason, HAS_SUMMARY", "response": "Checks if the package has a summary listed?"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nchecks if the package has a description listed?", "response": "def check_description(package_info, *args):\n    \"\"\"\n    Does the package have a description listed?\n    :param package_info: package_info dictionary\n    :return: Tuple (is the condition True or False?, reason if it is False else None)\n    \"\"\"\n    reason = \"Description missing\"\n    result = False\n\n    if package_info.get('description') not in BAD_VALUES:\n        result = True\n\n    return result, reason, HAS_DESCRIPTION"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef check_python_classifiers(package_info, *args):\n    classifiers = package_info.get('classifiers')\n    reason = \"Python classifiers missing\"\n    result = False\n\n    if len([c for c in classifiers if c.startswith('Programming Language :: Python ::')]) > 0:\n        result = True\n\n    return result, reason, HAS_PYTHON_CLASSIFIERS", "response": "Checks if the package has Python classifiers."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef check_author_info(package_info, *args):\n    reason = \"Author name or email missing\"\n    result = False\n\n    if package_info.get('author') not in BAD_VALUES or package_info.get('author_email') not in BAD_VALUES:\n        result = True\n\n    return result, reason, HAS_AUTHOR_INFO", "response": "Check if the package has author information listed?"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef check_release_files(package_info, *args):\n    reason = \"No release files uploaded\"\n    result = False\n\n    release_urls = args[0]\n    if len(release_urls) > 0:\n        result = True\n\n    return result, reason, HAS_RELEASE_FILES", "response": "Checks if the package has release files"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef check_stale(package_info, *args):\n    reason = 'Package not updated in {} days'.format(DAYS_STALE)\n    result = False\n\n    now = datetime.utcnow()\n\n    release_urls = args[0]\n    if len(release_urls) > 0:\n        package_uploaded_time = release_urls[0]['upload_time']\n        if now - timedelta(days=DAYS_STALE) <= package_uploaded_time:\n            result = True\n\n    return result, reason, NOT_STALE", "response": "Check if a package is stale."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef main():\n    setup_main()\n    config = ConfigData(clean=True)\n    try:\n        config.upload()\n    finally:\n        config.clean_after_if_needed()", "response": "upload a package to pypi or gemfury\n   "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef queryHTML(self, path):\n        if etree is None:\n            raise Exception(\"lxml not available\")\n        document = etree.HTML(self.contents)\n        for node in document.xpath(path):\n            if isinstance(node, basestring):\n                print node\n            else:\n                print etree.tostring(node, pretty_print=True).strip()", "response": "Run an XPath query on the HTML document and print matches."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn an array indented according to indent level", "response": "def array_indented(level: int, l: List[str], quote_char='\\'', comma_after=False) -> str:\n    \"\"\"\n    return an array indented according to indent level\n    :param level:\n    :param l:\n    :param quote_char:\n    :param comma_after:\n    :return:\n    \"\"\"\n    out = \"[\\n\"\n    for x in l:\n        out += (((level+1) * 4) * \" \") + '{}{}{}'.format(quote_char, x, quote_char) + \",\\n\"\n    out += ((level * 4) * \" \") + \"]\"\n    if comma_after:\n        out += \",\"\n    return out"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef clean_text(self):\n        text = self.cleaned_data.get(\"text\")\n        validation_helper = safe_import_module(settings.FORUM_TEXT_VALIDATOR_HELPER_PATH)\n        if validation_helper is not None:\n            return validation_helper(self, text)\n        else:\n            return text", "response": "Clean the text content of the user."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef pipeline_repr(obj):\n\n    if not hasattr(repr_state, 'in_repr'):\n        repr_state.in_repr = 0\n    repr_state.in_repr += 1\n    try:\n        return standard_repr(obj)\n    finally:\n        repr_state.in_repr -= 1", "response": "Returns a string representation of an object including pieshell\n    pipelines."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef run(self, redirects = []):\n        if not isinstance(redirects, redir.Redirects):\n            redirects = redir.Redirects(self._env._redirects, *redirects)\n        with copy.copy_session() as sess:\n            self = copy.deepcopy(self)\n            processes = self._run(redirects, sess)\n        pipeline = RunningPipeline(processes, self)\n        self._env.last_pipeline = pipeline\n        return pipeline", "response": "Runs the pipelines with the specified redirects and returns\n        a RunningPipeline instance."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a string of the name of the items that are preludeed by the rule.", "response": "def digest_prelude(self, rule):\n        \"\"\"\n        Walk on rule prelude (aka CSS selector) tokens to return a string of\n        the value name (from css selector).\n\n        Actually only simple selector and selector with descendant combinator\n        are supported. Using any other selector kind may leads to unexpected\n        issues.\n\n        Arguments:\n            rule (tinycss2.ast.QualifiedRule): Qualified rule object as\n                returned by  tinycss2.\n\n        Returns:\n            string: Selector name. If it's a descendant combinator, items are\n                joined with ``__``.\n        \"\"\"\n        name = []\n\n        for token in rule.prelude:\n            if token.type == 'ident':\n                name.append(token.value)\n\n        return \"__\".join(name)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef digest_content(self, rule):\n        data = OrderedDict()\n\n        current_key = None\n\n        for token in rule.content:\n            # Assume first identity token is the property name\n            if token.type == 'ident':\n                # Ignore starting '-' from css variables\n                name = token.value\n                if name.startswith('-'):\n                    name = name[1:]\n\n                current_key = name\n                data[current_key] = None\n\n            # Assume first following string token is the property value.\n            if token.type == 'string':\n                data[current_key] = token.value\n\n        return data", "response": "This method is used to digest the content of a rule."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef consume(self, source):\n        manifest = OrderedDict()\n\n        rules = parse_stylesheet(\n            source,\n            skip_comments=True,\n            skip_whitespace=True,\n        )\n\n        for rule in rules:\n            # Gather rule selector+properties\n            name = self.digest_prelude(rule)\n\n            # Ignore everything out of styleguide namespace\n            if not name.startswith(RULE_BASE_PREFIX):\n                continue\n\n            properties = self.digest_content(rule)\n            manifest[name] = properties\n\n        return manifest", "response": "Parse source and consume tokens from tinycss2."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef post_comment(request, next=None, using=None):\n    # Fill out some initial data fields from an authenticated user, if present\n    data = request.POST.copy()\n    if request.user.is_authenticated:\n        data[\"user\"] = request.user\n    else:\n        return CommentPostBadRequest(\"You must be logged in to comment\")\n\n    # Look up the object we're trying to comment about\n    ctype = data.get(\"content_type\")\n    object_pk = data.get(\"object_pk\")\n    if ctype is None or object_pk is None:\n        return CommentPostBadRequest(\"Missing content_type or object_pk field.\")\n    try:\n        model = models.get_model(*ctype.split(\".\", 1))\n        target = model._default_manager.using(using).get(pk=object_pk)\n    except TypeError:\n        return CommentPostBadRequest(\n            \"Invalid content_type value: %r\" % escape(ctype))\n    except AttributeError:\n        return CommentPostBadRequest(\n            \"The given content-type %r does not resolve to a valid model.\" % \\\n                escape(ctype))\n    except ObjectDoesNotExist:\n        return CommentPostBadRequest(\n            \"No object matching content-type %r and object PK %r exists.\" % \\\n                (escape(ctype), escape(object_pk)))\n    except (ValueError, ValidationError) as e:\n        return CommentPostBadRequest(\n            \"Attempting go get content-type %r and object PK %r exists raised %s\" % \\\n                (escape(ctype), escape(object_pk), e.__class__.__name__))\n\n    # Construct the comment form\n    form = comments.get_form()(target, data=data)\n\n    # Check security information\n    if form.security_errors():\n        return CommentPostBadRequest(\n            \"The comment form failed security verification: %s\" % \\\n                escape(str(form.security_errors())))\n\n    # Check for next\n    if not next:\n        next = data.get(\"next\")\n\n    # If there are errors show the comment\n    if form.errors:\n        template_list = [\n            \"comments/%s/%s/form.html\" % (model._meta.app_label, model._meta.module_name),\n            \"comments/%s/form.html\" % model._meta.app_label,\n            \"comments/form.html\",\n        ]\n        return render_to_response(\n            template_list, {\n                \"comment\": form.data.get(\"comment\", \"\"),\n                \"form\": form,\n                \"next\": data.get(\"next\", next),\n            },\n            RequestContext(request, {})\n        )\n\n    # Otherwise create the comment\n    comment = form.get_comment_object()\n    comment.ip_address = request.META.get(\"REMOTE_ADDR\", None)\n    if request.user.is_authenticated:\n        comment.user = request.user\n\n    # Signal that the comment is about to be saved\n    responses = signals.comment_will_be_posted.send(\n        sender=comment.__class__,\n        comment=comment,\n        request=request\n    )\n\n    for (receiver, response) in responses:\n        if response == False:\n            return CommentPostBadRequest(\n                \"comment_will_be_posted receiver %r killed the comment\" % receiver.__name__)\n\n    # Save the comment and signal that it was saved\n    comment.save()\n    signals.comment_was_posted.send(\n        sender=comment.__class__,\n        comment=comment,\n        request=request\n    )\n    messages.success(request, 'Your comment was saved.')\n    return redirect(next)", "response": "Post a comment to the object."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nstreams sample. Iterate over seq (once!) keeping k random elements with uniform distribution. As a special case, if ``k`` is ``None``, then ``list(seq)`` is returned. :param seq: iterable of things to sample from :param k: size of desired sample :param limit: stop reading ``seq`` after considering this many :return: list of elements from seq, length k (or less if seq is short)", "response": "def streaming_sample(seq, k, limit=None):\n    '''Streaming sample.\n\n    Iterate over seq (once!) keeping k random elements with uniform\n    distribution.\n\n    As a special case, if ``k`` is ``None``, then ``list(seq)`` is\n    returned.\n\n    :param seq: iterable of things to sample from\n    :param k: size of desired sample\n    :param limit: stop reading ``seq`` after considering this many\n    :return: list of elements from seq, length k (or less if seq is\n             short)\n    '''\n    if k is None:\n        return list(seq)\n\n    seq = iter(seq)\n    if limit is not None:\n        k = min(limit, k)\n        limit -= k\n    result = list(islice(seq, k))\n    for count, x in enumerate(islice(seq, limit), len(result)):\n        if rand.random() < (1.0 / count):\n            result[rand.randint(0, k-1)] = x\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the yacms profile model defined in settings. ACCOUNTS_PROFILE_MODEL or None if no profile model is defined.", "response": "def get_profile_model():\n    \"\"\"\n    Returns the yacms profile model, defined in\n    ``settings.ACCOUNTS_PROFILE_MODEL``, or ``None`` if no profile\n    model is configured.\n    \"\"\"\n\n    if not getattr(settings, \"ACCOUNTS_PROFILE_MODEL\", None):\n        raise ProfileNotConfigured\n\n    try:\n        return apps.get_model(settings.ACCOUNTS_PROFILE_MODEL)\n    except ValueError:\n        raise ImproperlyConfigured(\"ACCOUNTS_PROFILE_MODEL must be of \"\n                                   \"the form 'app_label.model_name'\")\n    except LookupError:\n        raise ImproperlyConfigured(\"ACCOUNTS_PROFILE_MODEL refers to \"\n                                   \"model '%s' that has not been installed\"\n                                   % settings.ACCOUNTS_PROFILE_MODEL)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns the profile form defined by ACCOUNTS_PROFILE_FORM_CLASS.", "response": "def get_profile_form():\n    \"\"\"\n    Returns the profile form defined by\n    ``settings.ACCOUNTS_PROFILE_FORM_CLASS``.\n    \"\"\"\n    from yacms.conf import settings\n    try:\n        return import_dotted_path(settings.ACCOUNTS_PROFILE_FORM_CLASS)\n    except ImportError:\n        raise ImproperlyConfigured(\"Value for ACCOUNTS_PROFILE_FORM_CLASS \"\n                                   \"could not be imported: %s\" %\n                                   settings.ACCOUNTS_PROFILE_FORM_CLASS)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the name of the first field on the profile model that points to the auth. User model.", "response": "def get_profile_user_fieldname(profile_model=None, user_model=None):\n    \"\"\"\n    Returns the name of the first field on the profile model that\n    points to the ``auth.User`` model.\n    \"\"\"\n    Profile = profile_model or get_profile_model()\n    User = user_model or get_user_model()\n    for field in Profile._meta.fields:\n        if field.rel and field.rel.to == User:\n            return field.name\n    raise ImproperlyConfigured(\"Value for ACCOUNTS_PROFILE_MODEL does not \"\n                               \"contain a ForeignKey field for auth.User: %s\"\n                               % Profile.__name__)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef gameValue(self):\n        allowed = type(self).ALLOWED_TYPES\n        try:\n            if isinstance(allowed, dict): # if ALLOWED_TYPES is not a dict, there is no-internal game value mapping defined\n                return allowed.get(self.type.name)\n        except: pass # None .type values are okay -- such result in a None gameValue() result\n        return None", "response": "identify the correpsonding internal SC2 game value for self. type s value"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconsiders the distance between two mapPoints ignoring all terrain pathing issues", "response": "def direct2dDistance(self, point):\n        \"\"\"consider the distance between two mapPoints, ignoring all terrain, pathing issues\"\"\"\n        if not isinstance(point, MapPoint): return 0.0\n        return  ((self.x-point.x)**2 + (self.y-point.y)**2)**(0.5) # simple distance formula"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef midPoint(self, point):\n        x = (self.x + point.x)/2.0\n        y = (self.y + point.y)/2.0\n        z = (self.z + point.z)/2.0\n        return MapPoint(x,y,z)", "response": "identify the midpoint between two mapPoints"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef magnitude(self, allow3d=True):\n        ret = self.x**2 + self.y**2\n        if allow3d: ret += self.z**2\n        return ret**0.5 # square root", "response": "determine the magnitude of this location from the origin"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ndetermines the angle of this point on a circle measured in radians", "response": "def angle2d(self):\n        \"\"\"determine the angle of this point on a circle, measured in radians (presume values represent a Vector)\"\"\"\n        if self.x==0:\n            if   self.y<0:  return       math.pi/2.0*3\n            elif self.y>0:  return       math.pi/2.0\n            else:           return 0\n        elif self.y==0:\n            if   self.x<0:  return       math.pi\n           #elif self.x>0:  return 0\n            else:           return 0\n        ans = math.atan( self.y / self.x )\n        if self.x > 0:\n            if self.y>0:    return ans\n            else:           return ans + math.pi*2.0\n        else:               return ans + math.pi"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nmerges other_hash into to_hash", "response": "def merge_conf(to_hash, other_hash, path=[]):\n    \"merges other_hash into to_hash\"\n    for key in other_hash:\n        if (key in to_hash and isinstance(to_hash[key], dict)\n                and isinstance(other_hash[key], dict)):\n            merge_conf(to_hash[key], other_hash[key], path + [str(key)])\n        else:\n            to_hash[key] = other_hash[key]\n    return to_hash"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nchecking if the input files exist and return a boolean.", "response": "def check_inputs(self):\n        \"\"\" Check for the existence of input files \"\"\"\n        self.inputs = self.expand_filenames(self.inputs)\n        result = False\n        if len(self.inputs) == 0 or self.files_exist(self.inputs):\n            result = True\n        else:\n            print(\"Not executing task. Input file(s) do not exist.\")\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nchecking if the output files exist and if they are newer than inputs.", "response": "def check_outputs(self):\n        \"\"\" Check for the existence of output files \"\"\"\n        self.outputs = self.expand_filenames(self.outputs)\n        result = False\n        if self.files_exist(self.outputs):\n            if self.dependencies_are_newer(self.outputs, self.inputs):\n                result = True\n                print(\"Dependencies are newer than outputs.\")\n                print(\"Running task.\")\n            elif self.force:\n                print(\"Dependencies are older than inputs, but 'force' option present.\")\n                print(\"Running task.\")\n                result = True\n            else:\n                print(\"Dependencies are older than inputs.\")\n        else:\n            print(\"No ouput file(s).\")\n            print(\"Running task.\")\n            result = True\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nexpands variables in the task code.", "response": "def expand_variables(self):\n        \"\"\"\n        Expand variables in the task code.\n        Only variables who use the $[<variable name>] format are expanded.\n        Variables using the $<variable name> and ${<variable name>} formats\n        are expanded by the shell (in the cases where bash is the interpreter.\n        \"\"\"\n        self.environment[\"INPUTS\"] = \" \".join(self.inputs)\n        self.environment[\"OUTPUTS\"] = \" \".join(self.outputs)\n        for n, input_file in enumerate(self.inputs):\n            self.environment[\"INPUT{}\".format(n +1)] = input_file\n        for n, output_file in enumerate(self.outputs):\n            self.environment[\"OUTPUT{}\".format(n +1)] = output_file\n        for n, line in enumerate(self.code):\n            match = self.__variable_pattern.findall(line)\n            if len(match) > 0:\n                for item in match:\n                    value = self.environment.get(item)\n                    if value is not None:\n                        self.code[n] = self.code[n].replace(\"$[\" + item + \"]\", value)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef expand_filenames(self, filenames):\n        results = []\n        for filename in filenames:\n            result = filename\n            if \"$\" in filename:\n                template = Template(filename)\n                result = template.substitute(**self.environment)\n                logging.debug(\n                    \"Expanding {} to {}.\".format(filename, result))\n            if any([pattern in result for pattern in \"*[]?\"]):\n                expanded = glob.glob(result)\n                if len(expanded) > 0:\n                    result = expanded\n                else:\n                    result = \"NONEXISTENT\"\n            if isinstance(result, list):\n                results.extend(result)\n            else:\n                results.append(result)\n        return sorted(list(set(results)))", "response": "Expand a list of filenames using environment variables followed by expansion of shell - style wildcards."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef files_exist(self, filenames):\n        return all([os.path.exists(os.path.abspath(filename)) and os.path.isfile(os.path.abspath(filename))\n                    for filename in filenames])", "response": "Check if all files in a given list exist."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nchecks if any file in the second list is newer than any file in the first list.", "response": "def dependencies_are_newer(self, files, dependencies):\n        \"\"\"\n        For two lists of files, check if any file in the\n        second list is newer than any file of the first.\n        \"\"\"\n        dependency_mtimes = [\n            os.path.getmtime(filename) for filename in dependencies]\n        file_mtimes = [os.path.getmtime(filename) for filename in files]\n        result = False\n        for file_mtime in file_mtimes:\n            for dependency_mtime in dependency_mtimes:\n                if dependency_mtime > file_mtime:\n                    result = True\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef mktemp_file(self):\n        if not(os.path.exists(self.__dirname)):\n            logging.debug(\"Creating directory {}\".format(self.__dirname))\n            os.mkdir(self.__dirname)\n        elif not(os.path.isdir(self.__dirname)):\n            raise TempDirIsFileException(\n                \"There is a file called %s in this directory!!!\" %\n                self.__dirname)\n        #self.fdesc, self.fname = tempfile.mkstemp(dir=self.__dirname, text=True)\n        self.f = tempfile.NamedTemporaryFile(dir=self.__dirname, delete=False, mode=\"wt\")\n        logging.debug(\"Creating file {}\".format(self.f.name))", "response": "Create a temporary file in the. faz directory for\n            the code to feed to the interpreter."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _get_max_page(dom):\n    div = dom.find(\"div\", {\"class\": \"razeniKnihListovani\"})\n\n    if not div:\n        return 1\n\n    # isolate only page numbers from links\n    links = div[0].find(\"a\")\n    max_page = filter(\n        lambda x: \"href\" in x.params and \"pageindex=\" in x.params[\"href\"],\n        links\n    )\n    max_page = map(\n        lambda x: x.params[\"href\"].split(\"pageindex=\")[-1],\n        max_page\n    )\n    max_page = filter(lambda x: x.isdigit(), max_page)\n    max_page = map(lambda x: int(x), max_page)\n\n    if not max_page:\n        return 1\n\n    return max(max_page)", "response": "Try to guess how much pages are in book listing."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nparse links to the details about publications from page with book list.", "response": "def _parse_book_links(dom):\n    \"\"\"\n    Parse links to the details about publications from page with book list.\n\n    Args:\n        dom (obj): HTMLElement container of the page with book list.\n\n    Returns:\n        list: List of strings / absolute links to book details.\n    \"\"\"\n    links = []\n    picker = lambda x: x.params.get(\"class\", \"\").startswith(\"boxProKnihy\")\n\n    for el in dom.find(None, fn=picker):\n        book_ref = el.find(\"a\")\n\n        if not book_ref or \"href\" not in book_ref[0].params:\n            continue\n\n        links.append(book_ref[0].params[\"href\"])\n\n    return links"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_book_links(links):\n    book_links = []\n\n    for link in links:\n        data = DOWNER.download(link + \"1\")\n        dom = dhtmlparser.parseString(data)\n\n        book_links.extend(_parse_book_links(dom))\n\n        max_page = _get_max_page(dom)\n        if max_page == 1:\n            continue\n\n        for i in range(max_page - 1):\n            data = DOWNER.download(link + str(i + 2))\n\n            book_links.extend(\n                _parse_book_links(\n                    dhtmlparser.parseString(data)\n                )\n            )\n\n    return book_links", "response": "Go thru links to categories and return list to all publications in all\n    given categories."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _parse_authors(authors):\n    link = authors.find(\"a\")\n    link = link[0].params.get(\"href\") if link else None\n\n    author_list = _strip_content(authors)\n\n    if \"(\" in author_list:\n        author_list = author_list.split(\"(\")[0]\n\n    if not author_list.strip():\n        return []\n\n    return map(\n        lambda author: Author(author.strip(), link),\n        author_list.strip().split(\",\")\n    )", "response": "Parse informations about authors of the book."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndownload and parse available informations about book from the publishers webpages.", "response": "def _process_book(link):\n    \"\"\"\n    Download and parse available informations about book from the publishers\n    webpages.\n\n    Args:\n        link (str): URL of the book at the publishers webpages.\n\n    Returns:\n        obj: :class:`.Publication` instance with book details.\n    \"\"\"\n    # download and parse book info\n    data = DOWNER.download(link)\n    dom = dhtmlparser.parseString(\n        utils.handle_encodnig(data)\n    )\n    dhtmlparser.makeDoubleLinked(dom)\n\n    # some books are without price in expected elements, this will try to get\n    # it from elsewhere\n    price = None\n    try:\n        price = _strip_content(zapi.get_price(dom))\n    except UserWarning:\n        price = dom.find(\"p\", {\"class\": \"vaseCena\"})\n\n        if price:\n            price = price[0].getContent().replace(\"&nbsp;\", \" \")\n            price = filter(lambda x: x.isdigit(), price.strip())\n\n            if price:\n                price = price[0] + \"k\u010d\"\n            else:\n                price = \"-1\"\n        else:\n            price = \"-1\"\n\n    # required informations\n    pub = Publication(\n        title=_strip_content(zapi.get_title(dom)),\n        authors=_parse_authors(zapi.get_author(dom)),\n        price=price,\n        publisher=_strip_content(zapi.get_publisher(dom))\n    )\n\n    # optional informations\n    pub.optionals.URL = link\n    pub.optionals.pages = _strip_content(zapi.get_pages(dom))\n    pub.optionals.pub_date = _strip_content(zapi.get_pub_date(dom))\n    pub.optionals.ISBN = _strip_content(zapi.get_ISBN(dom))\n    pub.optionals.binding = _strip_content(zapi.get_binding(dom))\n\n    # post checks\n    if pub.title.startswith(\"E-kniha:\"):\n        pub.title = pub.title.replace(\"E-kniha:\", \"\", 1).strip()\n        pub.optionals.is_ebook = True\n\n    if pub.optionals.ISBN:\n        if \" \" in pub.optionals.ISBN:\n            pub.optionals.ISBN = pub.optionals.ISBN.split(\" \")[0]\n\n        if \"(\" in pub.optionals.ISBN:\n            pub.optionals.ISBN = pub.optionals.ISBN.split(\"(\")[0]\n\n    return pub"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting list of publication offered by ben. cz.", "response": "def get_publications():\n    \"\"\"\n    Get list of publication offered by ben.cz.\n\n    Returns:\n        list: List of :class:`structures.Publication` objects.\n    \"\"\"\n    books = []\n    for link in get_book_links(LINKS):\n        books.append(\n            _process_book(link)\n        )\n\n    return books"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nparsing the response text into an instance of the appropriate child class.", "response": "def parse(text) -> Optional['Response']:\n        \"\"\"Parse response into an instance of the appropriate child class.\"\"\"\n\n        # Trim the start and end markers, and ensure only lowercase is used\n        if text.startswith(MARKER_START) and text.endswith(MARKER_END):\n            text = text[1:len(text)-1].lower()\n\n        # No-op; can just ignore these\n        if not text:\n            return None\n\n        if text.startswith(CMD_DATETIME):\n            return DateTimeResponse(text)\n\n        elif text.startswith(CMD_OPMODE):\n            return OpModeResponse(text)\n\n        elif text.startswith(CMD_DEVBYIDX_PREFIX):\n            if RESPONSE_ERROR == text[2:] or text[2:4] == '00':\n                return DeviceNotFoundResponse(text)\n            return DeviceInfoResponse(text)\n\n        elif text.startswith(CMD_DEVICE_PREFIX):\n            action = next((a for a in [ACTION_ADD, ACTION_DEL, ACTION_SET]\n                           if a == text[2:3]), ACTION_NONE)\n            args = text[2+len(action):]\n            if RESPONSE_ERROR == args:\n                return DeviceNotFoundResponse(text)\n            elif action == ACTION_ADD:\n                if not args:\n                    return DeviceAddingResponse(text)\n                return DeviceAddedResponse(text)\n            elif action == ACTION_SET:\n                return DeviceChangedResponse(text)\n            elif action == ACTION_DEL:\n                return DeviceDeletedResponse(text)\n            else:\n                return DeviceInfoResponse(text)\n\n        elif text.startswith(CMD_CLEAR_STATUS):\n            return ClearedStatusResponse(text)\n\n        elif text.startswith(CMD_ROMVER):\n            return ROMVersionResponse(text)\n\n        elif text.startswith(CMD_EXIT_DELAY):\n            return ExitDelayResponse(text)\n\n        elif text.startswith(CMD_ENTRY_DELAY):\n            return EntryDelayResponse(text)\n\n        elif text.startswith(CMD_SWITCH_PREFIX) and is_ascii_hex(text[1:2]):\n            return SwitchResponse(text)\n\n        elif text.startswith(CMD_EVENT_LOG):\n            if RESPONSE_ERROR == text[2:]:\n                return EventLogNotFoundResponse(text)\n            return EventLogResponse(text)\n\n        elif text.startswith(CMD_SENSOR_LOG):\n            if RESPONSE_ERROR == text[2:]:\n                return SensorLogNotFoundResponse(text)\n            return SensorLogResponse(text)\n\n        else:\n            raise ValueError(\"Response not recognised: \" + text)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning True if Closed False if Open.", "response": "def is_closed(self) -> Optional[bool]:\n        \"\"\"For Magnet Sensor; True if Closed, False if Open.\"\"\"\n        if self._device_type is not None and self._device_type == DeviceType.DoorMagnet:\n            return bool(self._current_status & 0x01)\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef rssi_bars(self) -> int:\n        rssi_db = self.rssi_db\n        if rssi_db < 45:\n            return 0\n        elif rssi_db < 60:\n            return 1\n        elif rssi_db < 75:\n            return 2\n        elif rssi_db < 90:\n            return 3\n        return 4", "response": "Return the number of signal strength indicators in the current system."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef zone(self) -> Optional[str]:\n        if self._device_category == DC_BASEUNIT:\n            return None\n        return '{:02x}-{:02x}'.format(self._group_number, self._unit_number)", "response": "Zone the device is assigned to."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef workspace_added(ob, event):\n    # Whoever creates the workspace should be added as an Admin\n    creator = ob.Creator()\n    IWorkspace(ob).add_to_team(\n        user=creator,\n        groups=set(['Admins']),\n    )\n\n    # Configure our placeful workflow\n    cmfpw = 'CMFPlacefulWorkflow'\n    ob.manage_addProduct[cmfpw].manage_addWorkflowPolicyConfig()\n\n    # Set the policy for the config\n    pc = getattr(ob, WorkflowPolicyConfig_id)\n    pc.setPolicyIn('')\n    pc.setPolicyBelow('ploneintranet_policy')", "response": "When a workspace is created we add the creator to the admin group and then setup our placeful workflow\n   "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nmoving all the existing users to a new group", "response": "def participation_policy_changed(ob, event):\n    \"\"\" Move all the existing users to a new group \"\"\"\n    workspace = IWorkspace(ob)\n    old_group_name = workspace.group_for_policy(event.old_policy)\n    old_group = api.group.get(old_group_name)\n    for member in old_group.getAllGroupMembers():\n        groups = workspace.get(member.getId()).groups\n        groups -= set([event.old_policy.title()])\n        groups.add(event.new_policy.title())"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef user_deleted_from_site_event(event):\n    userid = event.principal\n\n    catalog = api.portal.get_tool('portal_catalog')\n    query = {'object_provides': WORKSPACE_INTERFACE}\n\n    query['workspace_members'] = userid\n    workspaces = [\n        IWorkspace(b._unrestrictedGetObject())\n        for b in catalog.unrestrictedSearchResults(query)\n        ]\n    for workspace in workspaces:\n        workspace.remove_from_team(userid)", "response": "Remove deleted user from all the workspaces where he\n    is a member"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets an object reference for use within a comment.", "response": "def get_object_comment_reference(instance, title=None):\n    \"\"\"\n    Get an object reference for use within a comment so that it can be programatically\n    referenced in the future (by a machine parsing the HTML...).\n    \"\"\"\n    span = '<span data-object-type=\"%s.%s\" data-object-pk=\"%s\">%s</span>' % (\n        instance.__module__,\n        instance.__class__.__name__,\n        instance.pk,\n        instance if title is None else title\n    )\n    try:\n        return '<a href=\"%s\">%s</a>' % (\n            instance.get_absolute_url(),\n            span\n        )\n    except AttributeError:\n        return span"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncompressing file under tar mode which type more popular use in Unix operating system when compress failed with return source path", "response": "def tarFile(source):\n    \"\"\"Compress file under tar mode\n        which type more popular use in Unix operating system\n        when compress failed with return source path\n    :param source: source file path\n    :return: zip file path\n    \"\"\"\n    # source = source.decode('UTF-8')\n    target = source[0:source.rindex('.')] + '.tar.gz'\n\n    try:\n        with tarfile.open(target, \"w:gz\") as tar_file:\n            tar_file.add(source, arcname=source[source.startswith(\"/\"):])\n            __cps_rate__(source, target)\n    except IOError as e:\n        logger.error('Compress file[%s] with zip mode failed. Case: %s', source, str(e))\n        target = source\n\n    return target"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef data_context_name(fn):\n    return os.path.join(os.path.dirname(__file__), \"template_data\", fn)", "response": "Return the fn in absolute path in template_data directory."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns the content of the fn from the template_data directory.", "response": "def data_context(fn, mode=\"r\"):\n    \"\"\"\n    Return content fo the `fn` from the `template_data` directory.\n    \"\"\"\n    with open(data_context_name(fn), mode) as f:\n        return f.read()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef tmp_context(fn, mode=\"r\"):\n    with open(tmp_context_name(fn), mode) as f:\n        return f.read()", "response": "Return the content of the fn from the temporary directory."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef generate_environment():\n    global TMP_PATH\n    TMP_PATH = tempfile.mkdtemp()\n\n    # write ZEO server config to  temp directory\n    zeo_conf_path = os.path.join(TMP_PATH, \"zeo.conf\")\n    with open(zeo_conf_path, \"w\") as f:\n        f.write(\n            Template(data_context(\"zeo.conf\")).substitute(\n                path=TMP_PATH,\n                server=ZEO_SERVER,\n                port=ZEO_PORT,\n            )\n        )\n\n    # write client config to temp directory\n    client_config_path = os.path.join(TMP_PATH, \"zeo_client.conf\")\n    with open(client_config_path, \"w\") as f:\n        f.write(\n            Template(data_context(\"zeo_client.conf\")).substitute(\n                server=ZEO_SERVER,\n                port=ZEO_PORT,\n            )\n        )\n\n    # run the ZEO server\n    def run_zeo():\n        global SERV\n        SERV = subprocess.Popen([\"runzeo\", \"-C\", zeo_conf_path])\n\n    serv = threading.Thread(target=run_zeo)\n    serv.setDaemon(True)\n    serv.start()", "response": "Generate the environment in the temporary directory and run the ZEO server process in another thread."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_auth_settings():\n    from yacms.conf import settings\n    try:\n        auth_settings = (settings.TWITTER_CONSUMER_KEY,\n                         settings.TWITTER_CONSUMER_SECRET,\n                         settings.TWITTER_ACCESS_TOKEN_KEY,\n                         settings.TWITTER_ACCESS_TOKEN_SECRET)\n    except AttributeError:\n        return None\n    else:\n        return auth_settings if all(auth_settings) else None", "response": "Returns all the key - secret settings for Twitter access"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef stringify(obj):\n    out = obj\n    if isinstance(obj, uuid.UUID):\n        out = str(obj)\n    elif hasattr(obj, 'strftime'):\n        out = obj.strftime('%Y-%m-%dT%H:%M:%S.%f%z')\n    elif isinstance(obj, memoryview):\n        out = obj.tobytes()\n    elif isinstance(obj, bytearray):\n        out = bytes(obj)\n    elif sys.version_info[0] < 3 and isinstance(obj, buffer):\n        out = bytes(obj)\n\n    if isinstance(out, bytes):\n        out = out.decode('utf-8')\n\n    return out", "response": "Returns the string representation of an object."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef normalize_collection(coll):\n\n    #\n    # The recursive version of this algorithm is something like:\n    #\n    #    if isinstance(coll, dict):\n    #        return dict((stringify(k), normalize_collection(v))\n    #                    for k, v in coll.items())\n    #    if isinstance(obj, (list, tuple)):\n    #        return [normalize_collection(item) for item in obj]\n    #    raise RuntimeError('non-container root')\n    #\n    # Since this is NOT simply a tail-recursive function, unrolling\n    # the recursion requires that we store intermediate \"frame info\"\n    # somewhere while processing.  I chose to use two stacks for\n    # this:\n    #\n    #  value_stack: contains the produced values.  The while loop\n    #    appends a new container to this stack when it encounters a\n    #    container on the work stack.  When the algorithm terminates,\n    #    we return the first (oldest) value on the stack.\n    #  work_stack: contains the items that need to be processed and\n    #    a function to call when the value is completed.  Initially,\n    #    we place the input collection onto work stack without a\n    #    processing function.\n    #\n    # The algorithm starts with the input collection on the work\n    # stack.  Each iteration pops the top of the stack which contains\n    # a value and a completion function (inserter).  If the value is\n    # a collection, then we push a new container onto the value stack,\n    # iterate over the container, and push each item onto the work\n    # stack with a function that will insert it into the new container.\n    #\n\n    value_stack = []\n    work_stack = [(coll, None)]\n\n    def create_container(container_type, inserter):\n        clone = container_type()\n        if inserter:\n            inserter(clone)\n        value_stack.append(clone)\n        return clone\n\n    while work_stack:\n        value, inserter = work_stack.pop()\n        if isinstance(value, (frozenset, list, set, tuple)):\n            target = create_container(list, inserter)\n            inserter = functools.partial(target.insert, 0)\n            for item in value:\n                work_stack.append((item, inserter))\n        elif isinstance(value, dict):\n            target = create_container(dict, inserter)\n            for key, item in value.items():\n                inserter = functools.partial(target.__setitem__,\n                                             stringify(key))\n                work_stack.append((item, inserter))\n        else:\n            if inserter is None:\n                raise RuntimeError(\n                    'non-container root - type %r' % value.__class__)\n            inserter(stringify(value))\n\n    return value_stack[0]", "response": "Normalizes all elements in a collection."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn a set of integers giving the available versions.", "response": "def available(self):\n        \"\"\"\n        Returns a set of the available versions.\n\n        :returns: A set of integers giving the available versions.\n        \"\"\"\n\n        # Short-circuit\n        if not self._schema:\n            return set()\n\n        # Build up the set of available versions\n        avail = set(self._schema.__vers_downgraders__.keys())\n        avail.add(self._schema.__version__)\n\n        return avail"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef parse_args_to_dict(values_specs):\n\n    # values_specs for example: '-- --tag x y --key1 type=int value1'\n    # -- is a pseudo argument\n    values_specs_copy = values_specs[:]\n    if values_specs_copy and values_specs_copy[0] == '--':\n        del values_specs_copy[0]\n    # converted ArgumentParser arguments for each of the options\n    _options = {}\n    # the argument part for current option in _options\n    current_arg = None\n    # the string after remove meta info in values_specs\n    # for example, '--tag x y --key1 value1'\n    _values_specs = []\n    # record the count of values for an option\n    # for example: for '--tag x y', it is 2, while for '--key1 value1', it is 1\n    _value_number = 0\n    # list=true\n    _list_flag = False\n    # action=clear\n    _clear_flag = False\n    # the current item in values_specs\n    current_item = None\n    # the str after 'type='\n    current_type_str = None\n    for _item in values_specs_copy:\n        if _item.startswith('--'):\n            # Deal with previous argument if any\n            _process_previous_argument(\n                current_arg, _value_number, current_type_str,\n                _list_flag, _values_specs, _clear_flag, values_specs)\n\n            # Init variables for current argument\n            current_item = _item\n            _list_flag = False\n            _clear_flag = False\n            current_type_str = None\n            if \"=\" in _item:\n                _value_number = 1\n                _item = _item.split('=')[0]\n            else:\n                _value_number = 0\n            if _item in _options:\n                raise exceptions.CommandError(\n                    _(\"Duplicated options %s\") % ' '.join(values_specs))\n            else:\n                _options.update({_item: {}})\n            current_arg = _options[_item]\n            _item = current_item\n        elif _item.startswith('type='):\n            if current_arg is None:\n                raise exceptions.CommandError(\n                    _(\"Invalid values_specs %s\") % ' '.join(values_specs))\n            if 'type' not in current_arg:\n                current_type_str = _item.split('=', 2)[1]\n                current_arg.update({'type': eval(current_type_str)})\n                if current_type_str == 'bool':\n                    current_arg.update({'type': utils.str2bool})\n                elif current_type_str == 'dict':\n                    current_arg.update({'type': utils.str2dict})\n                continue\n        elif _item == 'list=true':\n            _list_flag = True\n            continue\n        elif _item == 'action=clear':\n            _clear_flag = True\n            continue\n\n        if not _item.startswith('--'):\n            # All others are value items\n            # Make sure '--' occurs first and allow minus value\n            if (not current_item or '=' in current_item or\n                    _item.startswith('-') and not is_number(_item)):\n                raise exceptions.CommandError(\n                    _(\"Invalid values_specs %s\") % ' '.join(values_specs))\n            _value_number += 1\n\n        if _item.startswith('---'):\n            raise exceptions.CommandError(\n                _(\"Invalid values_specs %s\") % ' '.join(values_specs))\n\n        _values_specs.append(_item)\n\n    # Deal with last one argument\n    _process_previous_argument(\n        current_arg, _value_number, current_type_str,\n        _list_flag, _values_specs, _clear_flag, values_specs)\n\n    # Populate the parser with arguments\n    _parser = argparse.ArgumentParser(add_help=False)\n    for opt, optspec in six.iteritems(_options):\n        _parser.add_argument(opt, **optspec)\n    _args = _parser.parse_args(_values_specs)\n\n    result_dict = {}\n    for opt in six.iterkeys(_options):\n        _opt = opt.split('--', 2)[1]\n        _opt = _opt.replace('-', '_')\n        _value = getattr(_args, _opt)\n        result_dict.update({_opt: _value})\n    return result_dict", "response": "This function parses the arguments of a command line into a dictionary."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nmerge arguments from _extra_values into parsed_args.", "response": "def _merge_args(qCmd, parsed_args, _extra_values, value_specs):\n    \"\"\"Merge arguments from _extra_values into parsed_args.\n\n    If an argument value are provided in both and it is a list,\n    the values in _extra_values will be merged into parsed_args.\n\n    @param parsed_args: the parsed args from known options\n    @param _extra_values: the other parsed arguments in unknown parts\n    @param values_specs: the unparsed unknown parts\n    \"\"\"\n    temp_values = _extra_values.copy()\n    for key, value in six.iteritems(temp_values):\n        if hasattr(parsed_args, key):\n            arg_value = getattr(parsed_args, key)\n            if arg_value is not None and value is not None:\n                if isinstance(arg_value, list):\n                    if value and isinstance(value, list):\n                        if (not arg_value or\n                                isinstance(arg_value[0], type(value[0]))):\n                            arg_value.extend(value)\n                            _extra_values.pop(key)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef update_dict(obj, dict, attributes):\n    for attribute in attributes:\n        if hasattr(obj, attribute) and getattr(obj, attribute) is not None:\n            dict[attribute] = getattr(obj, attribute)", "response": "Update dict with fields from obj. attributes.\nAppsheets"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nretrieves a list of resources from Neutron server.", "response": "def retrieve_list(self, parsed_args):\n        \"\"\"Retrieve a list of resources from Neutron server.\"\"\"\n        neutron_client = self.get_client()\n        _extra_values = parse_args_to_dict(self.values_specs)\n        _merge_args(self, parsed_args, _extra_values,\n                    self.values_specs)\n        search_opts = self.args2search_opts(parsed_args)\n        search_opts.update(_extra_values)\n        if self.pagination_support:\n            page_size = parsed_args.page_size\n            if page_size:\n                search_opts.update({'limit': page_size})\n        if self.sorting_support:\n            keys = parsed_args.sort_key\n            if keys:\n                search_opts.update({'sort_key': keys})\n            dirs = parsed_args.sort_dir\n            len_diff = len(keys) - len(dirs)\n            if len_diff > 0:\n                dirs += ['asc'] * len_diff\n            elif len_diff < 0:\n                dirs = dirs[:len(keys)]\n            if dirs:\n                search_opts.update({'sort_dir': dirs})\n        data = self.call_server(neutron_client, search_opts, parsed_args)\n        collection = _get_resource_plural(self.resource, neutron_client)\n        return data.get(collection, [])"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating a lock ID where the lower bits are the group ID and the upper bits are the item ID.", "response": "def lock_key(group_id, item_id, group_width=8):\n  \"\"\"Creates a lock ID where the lower bits are the group ID and the upper bits\n  are the item ID. This allows the use of a bigint namespace for items, with a\n  limited space for grouping.\n\n  :group_id: an integer identifying the group. Must be less than\n             2 ^ :group_width:\n  :item_id: item_id an integer. must be less than 2 ^ (63 - :group_width:) - 1\n  :gropu_width: the number of bits to reserve for the group ID.\n  \"\"\"\n  if group_id >= (1 << group_width):\n    raise Exception(\"Group ID is too big\")\n  if item_id >= (1 << (63 - group_width)) - 1:\n    raise Exception(\"Item ID is too big\")\n  return (item_id << group_width) | group_id"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _lock_fxn(direction, lock_mode, xact):\n  if direction == \"unlock\" or lock_mode == LockMode.wait:\n    try_mode = \"\"\n  else:\n    try_mode = \"_try\"\n\n  if direction == \"lock\" and xact:\n    xact_mode = \"_xact\"\n  else:\n    xact_mode = \"\"\n\n  return \"pg{}_advisory{}_{}\".format(try_mode, xact_mode, direction)", "response": "Builds a pg advisory lock function name based on various options."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncheck if a file exists in the directory", "response": "def fileExists(fName, dire=pDir()):\n    \"\"\"\n    Check if a file exists\n    \"\"\"\n    if os.path.isfile(os.path.join(dire, fName)):\n        return True\n    return False"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_hash(fName, readSize, dire=pDir()):\n    if not fileExists(fName, dire):\n        return -1\n    readSize = readSize * 1024 # bytes to be read\n    fName = os.path.join(dire, fName) # name coupled with path\n    with open(fName, 'rb') as f:\n        size = os.path.getsize(fName)\n        if size < readSize * 2:\n            return -1\n        data = f.read(readSize)\n        f.seek(-readSize, os.SEEK_END)\n        data += f.read(readSize)\n    return md5(data).hexdigest()", "response": "returns the hash of the file fName"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef download_file(fName, time, dire=pDir()):\n    # hash\n    gen_hash = get_hash(fName, 64, dire)\n    if gen_hash == -1:\n        return -1\n\n    # making request\n    user_agent = {'User-agent': 'SubDB/1.0 (sub/0.1; http://github.com/leosartaj/sub)'}\n    param = {'action': 'download', 'hash': gen_hash, 'language': 'en'} # Specification for the request\n    try:\n        r = requests.get(\"http://api.thesubdb.com/\", headers = user_agent, params = param, timeout=time) # Get Request\n    except (requests.exceptions.Timeout, socket.error):\n        return 'Timeout Error'\n    if r.status_code != 200:\n        return r.status_code\n\n    # save file\n    fName, fExt = os.path.splitext(fName)\n    fName += '.srt' # replace extension with srt\n    fName = os.path.join(dire, fName) # name coupled with path\n    with open(fName, 'wb') as f:\n        f.write(r.text.encode('ascii', 'ignore'))\n\n    return r.status_code", "response": "download the required subtitle\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef file_downloaded(dwn, fName, verbose=False):\n    if verbose:\n        if dwn == 200:\n            fName, fExt = os.path.splitext(fName)\n            print 'Downloaded ' + fName + '.srt'\n            return True\n        elif dwn != -1:\n            print 'Tried downloading got ' + str(dwn) + ' for ' + fName\n            return False", "response": "Check if a file is downloaded and return True if it is."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef download(name, options):\n    dire = os.path.dirname(name) # returns the directory name\n    fName = os.path.basename(name) # returns the filename\n    fNameOnly, fExt = os.path.splitext(fName)\n\n    dwn = 0\n\n    if fileExists(fName, dire) and not fileExists((fNameOnly + '.srt'), dire): # skip if already downloaded\n        if file_downloaded(download_file(fName, options.timeout, dire), fName, options.verbose):\n            dwn += 1\n    elif dirExists(name):\n        for filename in os.listdir(name):\n            if options.recursive:\n                dwn += download(os.path.join(name, filename), options)\n            else:\n                if file_downloaded(download_file(filename, options.timeout, name), filename, options.verbose):\n                    dwn += 1\n    return dwn", "response": "download a file or all files in a directory"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nconvert a Pandas Timestamp object or datetime object to a string", "response": "def clean_dateobject_to_string(x):\n    \"\"\"Convert a Pandas Timestamp object or datetime object\n    to 'YYYY-MM-DD' string\n\n    Parameters\n    ----------\n    x : str, list, tuple, numpy.ndarray, pandas.DataFrame\n        A Pandas Timestamp object or datetime object,\n        or an array of these objects\n\n    Returns\n    -------\n    y : str, list, tuple, numpy.ndarray, pandas.DataFrame\n        A string 'YYYY-MM-DD' or array of date strings.\n\n    Example\n    -------\n    The function aims to convert a string as follows\n\n        Timestamp('2014-09-23 00:00:00') => '2014-09-23'\n        datetime.datetime(2014,9,23,0,0) => '2014-09-23'\n\n    Code Example\n    ------------\n        print(clean_dateobject_to_string(pd.Timestamp('2014-09-23 00:00:00')))\n        '2014-09-23'\n\n        print(clean_dateobject_to_string(datetime(2014,9,23,0,0)))\n        '2014-09-23'\n\n    Behavior\n    --------\n    - If it is not an object with strftime function the None is return\n\n    \"\"\"\n    import numpy as np\n    import pandas as pd\n\n    def proc_elem(e):\n        try:\n            return e.strftime(\"%Y-%m-%d\")\n        except Exception as e:\n            print(e)\n            return None\n\n    def proc_list(x):\n        return [proc_elem(e) for e in x]\n\n    def proc_ndarray(x):\n        tmp = proc_list(list(x.reshape((x.size,))))\n        return np.array(tmp).reshape(x.shape)\n\n    # transform string, list/tuple, numpy array, pandas dataframe\n    if \"strftime\" in dir(x):\n        return proc_elem(x)\n    elif isinstance(x, (list, tuple)):\n        return proc_list(x)\n    elif isinstance(x, np.ndarray):\n        return proc_ndarray(x)\n    elif isinstance(x, pd.DataFrame):\n        return pd.DataFrame(proc_ndarray(x.values),\n                            columns=x.columns,\n                            index=x.index)\n    else:\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef AND(*args, **kwargs):\n    for arg in args:\n        try:\n            arg()\n        except CertifierError as e:\n            exc = kwargs.get('exc', None)\n            if exc is not None:\n                raise exc(e)\n            raise", "response": "A simple AND operation that returns a new object."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef NAND(*args, **kwargs):\n    errors = []\n\n    for arg in args:\n        try:\n            arg()\n        except CertifierError as e:\n            errors.append(e)\n\n    if (len(errors) != len(args)) and len(args) > 1:\n        exc = kwargs.get(\n            'exc',\n            CertifierValueError('Expecting no certified values'),\n        )\n        if exc is not None:\n            raise exc", "response": "This function is used to call a function on a sequence of certifiers."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngets a loaded database", "response": "def db(self):\n        \"\"\"\n        Get a loaded database session\n        \"\"\"\n        if self.database is NotImplemented:\n            self.database = Session\n\n        return self.database"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nload the configuration file", "response": "def load_config(self, path):\n        \"\"\"\n        (Re-)load the configuration file\n        \"\"\"\n        self.config_path = path\n        self.config.read(self.config_path)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_login(self, use_session=True):\n        # Should we try and return an existing login session?\n        if use_session and self._login.check():\n            self.cookiejar = self._login.cookiejar\n            return self.cookiejar\n\n        # Prompt the user for their login credentials\n        username = click.prompt('IPS Username')\n        password = click.prompt('IPS Password', hide_input=True)\n        remember = click.confirm('Save login session?', True)\n\n        # Process the login\n        cookiejar = self._login.process(username, password, remember)\n        if remember:\n            self.cookiejar = cookiejar\n\n        return cookiejar", "response": "Get an active login session"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nlist CLI commands @type ctx: Context @rtype: list", "response": "def list_commands(self, ctx):\n        \"\"\"\n        List CLI commands\n        @type   ctx:    Context\n        @rtype: list\n        \"\"\"\n        commands_path = os.path.join(os.path.dirname(os.path.realpath(__file__)), 'commands')\n        command_list = [name for __, name, ispkg in pkgutil.iter_modules([commands_path]) if ispkg]\n        command_list.sort()\n        return command_list"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_command(self, ctx, name):\n        try:\n            mod = importlib.import_module('ips_vagrant.commands.{name}'.format(name=name))\n            return mod.cli\n        except (ImportError, AttributeError):\n            return", "response": "Get a bound command method\n       "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\noverwriting argv[1:] with argv, restore on exit.", "response": "def _custom_argv(argv):\n    \"\"\"Overwrite argv[1:] with argv, restore on exit.\"\"\"\n    backup_argv = sys.argv\n    sys.argv = backup_argv[:1] + argv\n    try:\n        yield\n    finally:\n        sys.argv = backup_argv"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nmonkey - patch pep257 after imports to avoid info logging.", "response": "def _patched_pep257():\n    \"\"\"Monkey-patch pep257 after imports to avoid info logging.\"\"\"\n    import pep257\n\n    if getattr(pep257, \"log\", None):\n        def _dummy(*args, **kwargs):\n            del args\n            del kwargs\n\n        old_log_info = pep257.log.info\n        pep257.log.info = _dummy  # suppress(unused-attribute)\n    try:\n        yield\n    finally:\n        if getattr(pep257, \"log\", None):\n            pep257.log.info = old_log_info"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _stamped_deps(stamp_directory, func, dependencies, *args, **kwargs):\n    if not isinstance(dependencies, list):\n        jobstamps_dependencies = [dependencies]\n    else:\n        jobstamps_dependencies = dependencies\n\n    kwargs.update({\n        \"jobstamps_cache_output_directory\": stamp_directory,\n        \"jobstamps_dependencies\": jobstamps_dependencies\n    })\n    return jobstamp.run(func, dependencies, *args, **kwargs)", "response": "Run func with dependencies as its first argument."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _debug_linter_status(linter, filename, show_lint_files):\n    if show_lint_files:\n        print(\"{linter}: {filename}\".format(linter=linter, filename=filename))", "response": "Indicate that we are running this linter if required."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _run_flake8(filename, stamp_file_name, show_lint_files):\n    _debug_linter_status(\"flake8\", filename, show_lint_files)\n    return _stamped_deps(stamp_file_name,\n                         _run_flake8_internal,\n                         filename)", "response": "Run flake8 on a file."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _run_prospector_on(filenames,\n                       tools,\n                       disabled_linters,\n                       show_lint_files,\n                       ignore_codes=None):\n    \"\"\"Run prospector on filename, using the specified tools.\n\n    This function enables us to run different tools on different\n    classes of files, which is necessary in the case of tests.\n    \"\"\"\n    from prospector.run import Prospector, ProspectorConfig\n\n    assert tools\n\n    tools = list(set(tools) - set(disabled_linters))\n    return_dict = dict()\n    ignore_codes = ignore_codes or list()\n\n    # Early return if all tools were filtered out\n    if not tools:\n        return return_dict\n\n    # pylint doesn't like absolute paths, so convert to relative.\n    all_argv = ([\"-F\", \"-D\", \"-M\", \"--no-autodetect\", \"-s\", \"veryhigh\"] +\n                (\"-t \" + \" -t \".join(tools)).split(\" \"))\n\n    for filename in filenames:\n        _debug_linter_status(\"prospector\", filename, show_lint_files)\n\n    with _custom_argv(all_argv + [os.path.relpath(f) for f in filenames]):\n        prospector = Prospector(ProspectorConfig())\n        prospector.execute()\n        messages = prospector.get_messages() or list()\n        for message in messages:\n            message.to_absolute_path(os.getcwd())\n            loc = message.location\n            code = message.code\n\n            if code in ignore_codes:\n                continue\n\n            key = _Key(loc.path, loc.line, code)\n            return_dict[key] = message\n\n    return return_dict", "response": "Run prospector on a list of files."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _run_prospector(filename,\n                    stamp_file_name,\n                    disabled_linters,\n                    show_lint_files):\n    \"\"\"Run prospector.\"\"\"\n    linter_tools = [\n        \"pep257\",\n        \"pep8\",\n        \"pyflakes\"\n    ]\n\n    if can_run_pylint():\n        linter_tools.append(\"pylint\")\n\n    # Run prospector on tests. There are some errors we don't care about:\n    # - invalid-name: This is often triggered because test method names\n    #                 can be quite long. Descriptive test method names are\n    #                 good, so disable this warning.\n    # - super-on-old-class: unittest.TestCase is a new style class, but\n    #                       pylint detects an old style class.\n    # - too-many-public-methods: TestCase subclasses by definition have\n    #                            lots of methods.\n    test_ignore_codes = [\n        \"invalid-name\",\n        \"super-on-old-class\",\n        \"too-many-public-methods\"\n    ]\n\n    kwargs = dict()\n\n    if _file_is_test(filename):\n        kwargs[\"ignore_codes\"] = test_ignore_codes\n    else:\n        if can_run_frosted():\n            linter_tools += [\"frosted\"]\n\n    return _stamped_deps(stamp_file_name,\n                         _run_prospector_on,\n                         [filename],\n                         linter_tools,\n                         disabled_linters,\n                         show_lint_files,\n                         **kwargs)", "response": "Run prospector on a file."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _run_polysquare_style_linter(matched_filenames,\n                                 cache_dir,\n                                 show_lint_files):\n    \"\"\"Run polysquare-generic-file-linter on matched_filenames.\"\"\"\n    from polysquarelinter import linter as lint\n    from prospector.message import Message, Location\n\n    return_dict = dict()\n\n    def _custom_reporter(error, file_path):\n        key = _Key(file_path, error[1].line, error[0])\n        loc = Location(file_path, None, None, error[1].line, 0)\n        return_dict[key] = Message(\"polysquare-generic-file-linter\",\n                                   error[0],\n                                   loc,\n                                   error[1].description)\n\n    for filename in matched_filenames:\n        _debug_linter_status(\"style-linter\", filename, show_lint_files)\n\n    # suppress(protected-access,unused-attribute)\n    lint._report_lint_error = _custom_reporter\n    lint.main([\n        \"--spellcheck-cache=\" + os.path.join(cache_dir, \"spelling\"),\n        \"--stamp-file-path=\" + os.path.join(cache_dir,\n                                            \"jobstamps\",\n                                            \"polysquarelinter\"),\n        \"--log-technical-terms-to=\" + os.path.join(cache_dir,\n                                                   \"technical-terms\"),\n    ] + matched_filenames + [\n        \"--block-regexps\"\n    ] + _BLOCK_REGEXPS)\n\n    return return_dict", "response": "Run polysquare - generic - file - linter on matched_filenames."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nrun spellcheck - linter on matched_filenames.", "response": "def _run_spellcheck_linter(matched_filenames, cache_dir, show_lint_files):\n    \"\"\"Run spellcheck-linter on matched_filenames.\"\"\"\n    from polysquarelinter import lint_spelling_only as lint\n    from prospector.message import Message, Location\n\n    for filename in matched_filenames:\n        _debug_linter_status(\"spellcheck-linter\", filename, show_lint_files)\n\n    return_dict = dict()\n\n    def _custom_reporter(error, file_path):\n        line = error.line_offset + 1\n        key = _Key(file_path, line, \"file/spelling_error\")\n        loc = Location(file_path, None, None, line, 0)\n        # suppress(protected-access)\n        desc = lint._SPELLCHECK_MESSAGES[error.error_type].format(error.word)\n        return_dict[key] = Message(\"spellcheck-linter\",\n                                   \"file/spelling_error\",\n                                   loc,\n                                   desc)\n\n    # suppress(protected-access,unused-attribute)\n    lint._report_spelling_error = _custom_reporter\n    lint.main([\n        \"--spellcheck-cache=\" + os.path.join(cache_dir, \"spelling\"),\n        \"--stamp-file-path=\" + os.path.join(cache_dir,\n                                            \"jobstamps\",\n                                            \"polysquarelinter\"),\n        \"--technical-terms=\" + os.path.join(cache_dir, \"technical-terms\"),\n    ] + matched_filenames)\n\n    return return_dict"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nrunning markdownlint on matched_filenames.", "response": "def _run_markdownlint(matched_filenames, show_lint_files):\n    \"\"\"Run markdownlint on matched_filenames.\"\"\"\n    from prospector.message import Message, Location\n\n    for filename in matched_filenames:\n        _debug_linter_status(\"mdl\", filename, show_lint_files)\n\n    try:\n        proc = subprocess.Popen([\"mdl\"] + matched_filenames,\n                                stdout=subprocess.PIPE,\n                                stderr=subprocess.PIPE)\n        lines = proc.communicate()[0].decode().splitlines()\n    except OSError as error:\n        if error.errno == errno.ENOENT:\n            return []\n\n    lines = [\n        re.match(r\"([\\w\\-.\\/\\\\ ]+)\\:([0-9]+)\\: (\\w+) (.+)\", l).groups(1)\n        for l in lines\n    ]\n    return_dict = dict()\n    for filename, lineno, code, msg in lines:\n        key = _Key(filename, int(lineno), code)\n        loc = Location(filename, None, None, int(lineno), 0)\n        return_dict[key] = Message(\"markdownlint\", code, loc, msg)\n\n    return return_dict"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _get_cache_dir(candidate):\n    if candidate:\n        return candidate\n\n    import distutils.dist  # suppress(import-error)\n    import distutils.command.build  # suppress(import-error)\n    build_cmd = distutils.command.build.build(distutils.dist.Distribution())\n    build_cmd.finalize_options()\n    cache_dir = os.path.abspath(build_cmd.build_temp)\n\n    # Make sure that it is created before anyone tries to use it\n    try:\n        os.makedirs(cache_dir)\n    except OSError as error:\n        if error.errno != errno.EEXIST:\n            raise error\n\n    return cache_dir", "response": "Get the current cache directory."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets all files matching ext from start directory.", "response": "def _all_files_matching_ext(start, ext):\n    \"\"\"Get all files matching :ext: from :start: directory.\"\"\"\n    md_files = []\n    for root, _, files in os.walk(start):\n        md_files += fnfilter([os.path.join(root, f) for f in files],\n                             \"*.\" + ext)\n\n    return md_files"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _is_excluded(filename, exclusions):\n    for exclusion in exclusions:\n        if fnmatch(filename, exclusion):\n            return True\n\n    return False", "response": "Return True if filename matches any of exclusions."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget lines for filename caching opened files.", "response": "def _file_lines(self, filename):\n        \"\"\"Get lines for filename, caching opened files.\"\"\"\n        try:\n            return self._file_lines_cache[filename]\n        except KeyError:\n            if os.path.isfile(filename):\n                with open(filename) as python_file:\n                    self._file_lines_cache[filename] = python_file.readlines()\n            else:\n                self._file_lines_cache[filename] = \"\"\n\n            return self._file_lines_cache[filename]"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _suppressed(self, filename, line, code):\n        if code in self.suppress_codes:\n            return True\n\n        lines = self._file_lines(filename)\n\n        # File is zero length, cannot be suppressed\n        if not lines:\n            return False\n\n        # Handle errors which appear after the end of the document.\n        while line > len(lines):\n            line = line - 1\n\n        relevant_line = lines[line - 1]\n\n        try:\n            suppressions_function = relevant_line.split(\"#\")[1].strip()\n            if suppressions_function.startswith(\"suppress(\"):\n                return code in _parse_suppressions(suppressions_function)\n        except IndexError:\n            above_line = lines[max(0, line - 2)]\n            suppressions_function = above_line.strip()[1:].strip()\n            if suppressions_function.startswith(\"suppress(\"):\n                return code in _parse_suppressions(suppressions_function)\n        finally:\n            pass", "response": "Return True if code is suppressed inline."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _get_md_files(self):\n        all_f = _all_files_matching_ext(os.getcwd(), \"md\")\n        exclusions = [\n            \"*.egg/*\",\n            \"*.eggs/*\",\n            \"*build/*\"\n        ] + self.exclusions\n        return sorted([f for f in all_f if not _is_excluded(f, exclusions)])", "response": "Get all markdown files."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _get_files_to_lint(self, external_directories):\n        all_f = []\n\n        for external_dir in external_directories:\n            all_f.extend(_all_files_matching_ext(external_dir, \"py\"))\n\n        packages = self.distribution.packages or list()\n        for package in packages:\n            all_f.extend(_all_files_matching_ext(package, \"py\"))\n\n        py_modules = self.distribution.py_modules or list()\n        for filename in py_modules:\n            all_f.append(os.path.realpath(filename + \".py\"))\n\n        all_f.append(os.path.join(os.getcwd(), \"setup.py\"))\n\n        # Remove duplicates which may exist due to symlinks or repeated\n        # packages found by /setup.py\n        all_f = list(set([os.path.realpath(f) for f in all_f]))\n\n        exclusions = [\n            \"*.egg/*\",\n            \"*.eggs/*\"\n        ] + self.exclusions\n        return sorted([f for f in all_f if not _is_excluded(f, exclusions)])", "response": "Get files to lint."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nrun mapper over passed in files returning a list of results.", "response": "def _map_over_linters(self,\n                          py_files,\n                          non_test_files,\n                          md_files,\n                          stamp_directory,\n                          mapper):\n        \"\"\"Run mapper over passed in files, returning a list of results.\"\"\"\n        dispatch = [\n            (\"flake8\", lambda: mapper(_run_flake8,\n                                      py_files,\n                                      stamp_directory,\n                                      self.show_lint_files)),\n            (\"pyroma\", lambda: [_stamped_deps(stamp_directory,\n                                              _run_pyroma,\n                                              \"setup.py\",\n                                              self.show_lint_files)]),\n            (\"mdl\", lambda: [_run_markdownlint(md_files,\n                                               self.show_lint_files)]),\n            (\"polysquare-generic-file-linter\", lambda: [\n                _run_polysquare_style_linter(py_files,\n                                             self.cache_directory,\n                                             self.show_lint_files)\n            ]),\n            (\"spellcheck-linter\", lambda: [\n                _run_spellcheck_linter(md_files,\n                                       self.cache_directory,\n                                       self.show_lint_files)\n            ])\n        ]\n\n        # Prospector checks get handled on a case sub-linter by sub-linter\n        # basis internally, so always run the mapper over prospector.\n        #\n        # vulture should be added again once issue 180 is fixed.\n        prospector = (mapper(_run_prospector,\n                             py_files,\n                             stamp_directory,\n                             self.disable_linters,\n                             self.show_lint_files) +\n                      [_stamped_deps(stamp_directory,\n                                     _run_prospector_on,\n                                     non_test_files,\n                                     [\"dodgy\"],\n                                     self.disable_linters,\n                                     self.show_lint_files)])\n\n        for ret in prospector:\n            yield ret\n\n        for linter, action in dispatch:\n            if linter not in self.disable_linters:\n                try:\n                    for ret in action():\n                        yield ret\n                except Exception as error:\n                    traceback.print_exc()\n                    sys.stderr.write(\"\"\"Encountered error '{}' whilst \"\"\"\n                                     \"\"\"running {}\"\"\".format(str(error),\n                                                             linter))\n                    raise error"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef run(self):  # suppress(unused-function)\n        import parmap\n        from prospector.formatters.pylint import PylintFormatter\n\n        cwd = os.getcwd()\n        files = self._get_files_to_lint([os.path.join(cwd, \"test\")])\n\n        if not files:\n            sys_exit(0)\n            return\n\n        use_multiprocessing = (not os.getenv(\"DISABLE_MULTIPROCESSING\",\n                                             None) and\n                               multiprocessing.cpu_count() < len(files) and\n                               multiprocessing.cpu_count() > 2)\n\n        if use_multiprocessing:\n            mapper = parmap.map\n        else:\n            # suppress(E731)\n            mapper = lambda f, i, *a: [f(*((x, ) + a)) for x in i]\n\n        with _patched_pep257():\n            keyed_messages = dict()\n\n            # Certain checks, such as vulture and pyroma cannot be\n            # meaningfully run in parallel (vulture requires all\n            # files to be passed to the linter, pyroma can only be run\n            # on /setup.py, etc).\n            non_test_files = [f for f in files if not _file_is_test(f)]\n            if self.stamp_directory:\n                stamp_directory = self.stamp_directory\n            else:\n                stamp_directory = os.path.join(self.cache_directory,\n                                               \"polysquare_setuptools_lint\",\n                                               \"jobstamps\")\n\n            # This will ensure that we don't repeat messages, because\n            # new keys overwrite old ones.\n            for keyed_subset in self._map_over_linters(files,\n                                                       non_test_files,\n                                                       self._get_md_files(),\n                                                       stamp_directory,\n                                                       mapper):\n                keyed_messages.update(keyed_subset)\n\n        messages = []\n        for _, message in keyed_messages.items():\n            if not self._suppressed(message.location.path,\n                                    message.location.line,\n                                    message.code):\n                message.to_relative_path(cwd)\n                messages.append(message)\n\n        sys.stdout.write(PylintFormatter(dict(),\n                                         messages,\n                                         None).render(messages=True,\n                                                      summary=False,\n                                                      profile=False) + \"\\n\")\n\n        if messages:\n            sys_exit(1)", "response": "Run all the linters."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef initialize_options(self):  # suppress(unused-function)\n        self._file_lines_cache = dict()\n        self.suppress_codes = list()\n        self.exclusions = list()\n        self.cache_directory = \"\"\n        self.stamp_directory = \"\"\n        self.disable_linters = list()\n        self.show_lint_files = 0", "response": "Set all options to their initial values."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncreate the schema for the top list of items and modules.", "response": "def create_top_schema(self):\n        \"\"\"\n        (Category --->) Item <---> Module <---> LogEntry\n\n        <---> is a many-to-many relationship\n         ---> is a foreign key relationship\n\n        (- Category: represents a group of Items which form a top list)\n         - Item: something that can be played multiple times and is grouped by to build a top list\n         - Module: an instance of a module on the queue\n         - LogEntry: an act performed on the queue and logged\n        \"\"\"\n        self.execute(\"\"\"CREATE TABLE IF NOT EXISTS top_module (\n            uuid TEXT,\n            add_timestamp DATETIME\n        );\"\"\")\n        self.execute(\"\"\"CREATE TABLE IF NOT EXISTS top_category (\n            pk INTEGER PRIMARY KEY,\n            slug TEXT,\n            description TEXT\n        );\"\"\")\n        self.execute(\"\"\"CREATE TABLE IF NOT EXISTS top_item (\n            pk INTEGER PRIMARY KEY,\n            canonical_id TEXT,\n            category_pk INTEGER,\n            requeue_command TEXT,\n            url TEXT,\n            description TEXT\n        );\"\"\")\n        self.execute(\"\"\"CREATE TABLE IF NOT EXISTS top_item_module (\n            pk INTEGER PRIMARY KEY,\n            item_pk INTEGER,\n            module_uuid TEXT\n        );\"\"\")\n        self.execute(\"\"\"CREATE TABLE IF NOT EXISTS top_log_entry (\n            pk INTEGER,\n            uid TEXT,\n            namespace TEXT,\n            timestamp DATETIME,\n            input_json TEXT,\n            output_json TEXT\n        );\"\"\")\n        self.execute(\"\"\"CREATE TABLE IF NOT EXISTS top_module_log_entry (\n            pk INTEGER PRIMARY KEY,\n            log_pk INTEGER,\n            module_uuid TEXT,\n            log_type TEXT\n        );\"\"\")\n        self.commit()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconvert backslashes in path patterns to forward slashes.", "response": "def normalize_pattern(pattern):\n    \"\"\"Converts backslashes in path patterns to forward slashes.\n\n    Doesn't normalize regular expressions - they may contain escapes.\n    \"\"\"\n    if not (pattern.startswith('RE:') or pattern.startswith('!RE:')):\n        pattern = _slashes.sub('/', pattern)\n    if len(pattern) > 1:\n        pattern = pattern.rstrip('/')\n    return pattern"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add_replacer(self, replacer):\n        self._pat = None\n        self._pats.extend(replacer._pats)\n        self._funs.extend(replacer._funs)", "response": "r Add all patterns and replacements from another replacer."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nsearch for a pattern that matches the given filename.", "response": "def match(self, filename):\n        \"\"\"Searches for a pattern that matches the given filename.\n\n        :return A matching pattern or None if there is no matching pattern.\n        \"\"\"\n\n        try:\n            for regex, patterns in self._regex_patterns:\n                match = regex.match(filename)\n\n                debug_template = \"%s against %s: %%s\" % (filename, regex._real_regex.pattern)\n\n                if match:\n                    if self.debug:\n                        logger.info(debug_template % \"hit\")\n                    return patterns[match.lastindex -1]\n\n                if self.debug:\n                    logger.info(debug_template % \"miss\")\n\n        except Exception as e:\n            # We can't show the default e.msg to the user as thats for\n            # the combined pattern we sent to regex. Instead we indicate to\n            # the user that an ignore file needs fixing.\n            logger.error('Invalid pattern found in regex: %s.', e.msg)\n            e.msg = \"File ~/.bazaar/ignore or .bzrignore contains error(s).\"\n            bad_patterns = ''\n            for _, patterns in self._regex_patterns:\n                for p in patterns:\n                    if not Globster.is_pattern_valid(p):\n                        bad_patterns += ('\\n  %s' % p)\n            e.msg += bad_patterns\n            raise e\n        \n\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn True if pattern is valid.", "response": "def is_pattern_valid(pattern):\n        \"\"\"Returns True if pattern is valid.\n\n        :param pattern: Normalized pattern.\n        is_pattern_valid() assumes pattern to be normalized.\n        see: globbing.normalize_pattern\n        \"\"\"\n        result = True\n        translator = Globster.pattern_info[Globster.identify(pattern)][\"translator\"]\n        tpattern = '(%s)' % translator(pattern)\n        try:\n            re_obj = lazy_regex.lazy_compile(tpattern, re.UNICODE)\n            re_obj.search(\"\") # force compile\n        except Exception as e:\n            result = False\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef match(self, filename):\n            \n        double_neg = self._ignores[2].match(filename)\n        if double_neg:\n            return \"!!%s\" % double_neg\n        elif self._ignores[1].match(filename):\n            #print(\"Ignores\")\n            return None\n        else:\n            #print(\"Normal match\")\n            return self._ignores[0].match(filename)", "response": "Searches for a pattern that matches the given filename."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nupdates the device resource with the name.", "response": "def put(self, device_id: int) -> Device:\n        \"\"\"\n        Updates the Device Resource with the\n        name.\n        \"\"\"\n        device = self._get_or_abort(device_id)\n        self.update(device)\n        session.commit()\n        session.add(device)\n        return device"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef delete(self, device_id: int):\n        device = self._get_or_abort(device_id)\n        session.delete(device)\n        session.commit()\n        return '', 204", "response": "Deletes the resource with the given name."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncreating a new object of the specified class with default context.", "response": "def with_default_context(cls,\n        use_empty_init=False,\n        global_default_factory=None):\n    \"\"\"\n    :param use_empty_init: If set to True, object constructed without\n            arguments will be a global default object of the class.\n    :param global_default_factory: Function that constructs a global\n            default object of the class.\n\n    N.B. Either `use_empty_init` should be set to True, or the\n    `global_default_factory` should be passed, but not both.\n    \"\"\"\n\n    if use_empty_init:\n        if global_default_factory is not None:\n            warnings.warn(\"Either factory or use_empty_init should be set. \"\n                          \"Assuming use_empty_init=True.\")\n        global_default_factory = lambda: cls()\n\n    class_attrs = dict(_default_stack=DefaultStack(),\n                       _global_default_factory=global_default_factory)\n    class_attrs.update(cls.__dict__)\n    return type(cls.__name__, (cls, _DefaultContextMixin), class_attrs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ninstructs xross to handle AJAX calls right from the moment it is called.", "response": "def xross_listener(http_method=None, **xross_attrs):\n    \"\"\"Instructs xross to handle AJAX calls right from the moment it is called.\n\n    This should be placed in a view decorated with `@xross_view()`.\n\n    :param str http_method: GET or POST. To be used as a source of data for xross.\n\n    :param dict xross_attrs: xross handler attributes.\n        Those attributes will be available in operation functions in `xross` keyword argument.\n\n    \"\"\"\n    handler = currentframe().f_back.f_locals['request']._xross_handler\n    handler.set_attrs(**xross_attrs)\n    if http_method is not None:\n        handler.http_method = http_method\n    handler.dispatch()"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ndecorating a function and handles any exceptions that may rise. Args: actions: A dictionary ``<exception type>: <action>``. Available actions\\ are :class:`raises` and :class:`returns`. Returns: Any value declared using a :class:`returns` action. Raises: AnyException: if AnyException is declared together with a :class:`raises` action. InterceptorError: if the decorator is called with something different from a :class:`returns` or :class:`raises` action. Interceptors can be declared inline to return a value or raise an exception when the declared exception is risen: >>> @intercept({ ... TypeError: returns('intercepted!') ... }) ... def fails(foo): ... if foo: ... raise TypeError('inner exception') ... return 'ok' >>> fails(False) 'ok' >>> fails(True) 'intercepted!' >>> @intercept({ ... TypeError: raises(Exception('intercepted!')) ... }) ... def fail(): ... raise TypeError('inner exception') >>> fail() Traceback (most recent call last): ... Exception: intercepted! But they can also be declared and then used later on: >>> intercept0r = intercept({ ... TypeError: returns('intercepted!') ... }) >>> @intercept0r ... def fail(): ... raise TypeError('raising error') >>> fail() 'intercepted!' You can declare also an action that captures the risen exception by passing a callable to the action. This is useful to create a custom error message: >>> @intercept({ ... TypeError: returns(lambda e: 'intercepted {}'.format(e)) ... }) ... def fail(): ... raise TypeError('inner exception') >>> fail() 'intercepted inner exception' Or to convert captured exceptions into custom errors: >>> class CustomError(Exception): ... pass >>> @intercept({ ... TypeError: raises(lambda e: CustomError(e)) ... }) ... def fail(): ... raise TypeError('inner exception') >>> fail() Traceback (most recent call last): ... intercept.CustomError: inner exception", "response": "def intercept(actions: dict={}):\n    \"\"\"\n    Decorates a function and handles any exceptions that may rise.\n\n    Args:\n        actions: A dictionary ``<exception type>: <action>``. Available actions\\\n            are :class:`raises` and :class:`returns`.\n\n    Returns:\n        Any value declared using a :class:`returns` action.\n\n    Raises:\n        AnyException: if AnyException is declared together with a\n            :class:`raises` action.\n        InterceptorError: if the decorator is called with something different\n            from a :class:`returns` or :class:`raises` action.\n\n    Interceptors can be declared inline to return a value or raise an exception\n    when the declared exception is risen:\n\n    >>> @intercept({\n    ...    TypeError: returns('intercepted!')\n    ... })\n    ... def fails(foo):\n    ...     if foo:\n    ...         raise TypeError('inner exception')\n    ...     return 'ok'\n    >>> fails(False)\n    'ok'\n    >>> fails(True)\n    'intercepted!'\n\n    >>> @intercept({\n    ...    TypeError: raises(Exception('intercepted!'))\n    ... })\n    ... def fail():\n    ...     raise TypeError('inner exception')\n    >>> fail()\n    Traceback (most recent call last):\n    ...\n    Exception: intercepted!\n\n    But they can also be declared and then used later on:\n\n    >>> intercept0r = intercept({\n    ...    TypeError: returns('intercepted!')\n    ... })\n    >>> @intercept0r\n    ... def fail():\n    ...     raise TypeError('raising error')\n    >>> fail()\n    'intercepted!'\n\n    You can declare also an action that captures the risen exception by passing\n    a callable to the action. This is useful to create a custom error message:\n\n    >>> @intercept({\n    ...    TypeError: returns(lambda e: 'intercepted {}'.format(e))\n    ... })\n    ... def fail():\n    ...     raise TypeError('inner exception')\n    >>> fail()\n    'intercepted inner exception'\n\n    Or to convert captured exceptions into custom errors:\n\n    >>> class CustomError(Exception):\n    ...     pass\n    >>> @intercept({\n    ...    TypeError: raises(lambda e: CustomError(e))\n    ... })\n    ... def fail():\n    ...     raise TypeError('inner exception')\n    >>> fail()\n    Traceback (most recent call last):\n    ...\n    intercept.CustomError: inner exception\n    \"\"\"\n\n    for action in actions.values():\n        if type(action) is not returns and type(action) is not raises:\n            raise InterceptorError('Actions must be declared as `returns` or `raises`')\n\n    def decorated(f):\n        def wrapped(*args, **kargs):\n            try:\n                return f(*args, **kargs)\n            except Exception as e:\n                if e.__class__ in actions:\n                    return actions[e.__class__](e)\n                else:\n                    raise\n\n        return wrapped\n\n    return decorated"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef dump(self, fp=sys.stdout, **kwargs):\n        fp.write(FILE_HEADER)\n        fp.write(self.to_json(**kwargs))\n        fp.write('\\n')", "response": "Serialize this keymap as a JSON formatted stream to the fp."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nappending the given bindings to the current keymap.", "response": "def extend(self, *bindings):\n        \"\"\" Append the given bindings to this keymap.\n\n        Arguments:\n            *bindings (Binding): Bindings to be added.\n        Returns:\n            Keymap: self\n        \"\"\"\n        self._bindings.extend(self._preprocess(bindings))\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef to(self, command, **args):\n        self.command = command\n        self.args = args\n        return self", "response": "Bind the keys to the specified command with some args."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nspecifies context i. e. condition that must be met.", "response": "def when(self, key):\n        \"\"\" Specify context, i.e. condition that must be met.\n\n        Arguments:\n            key (str): Name of the context whose value you want to query.\n        Returns:\n            Context:\n        \"\"\"\n        ctx = Context(key, self)\n        self.context.append(ctx)\n        return ctx"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef cli(ctx, dname, site):\n    assert isinstance(ctx, Context)\n\n    if dname:\n        dname = domain_parse(dname).hostname\n        domain = Session.query(Domain).filter(Domain.name == dname).first()\n\n        # No such domain\n        if not domain:\n            click.secho('No such domain: {dn}'.format(dn=dname), fg='red', bold=True, err=True)\n            return\n\n    if site:\n        site_name = site\n        site = Site.get(domain, site)\n        if not site:\n            click.secho('No such site: {site}'.format(site=site_name), fg='red', bold=True, err=True)\n            return\n\n        click.secho('Name: {n}'.format(n=site.name), bold=True)\n        click.secho('Domain: {dn}'.format(dn=site.domain.name), bold=True)\n        click.secho('Version: {v}'.format(v=site.version), bold=True)\n        click.secho('License Key: {lk}'.format(lk=site.license_key), bold=True)\n        click.secho('Status: {s}'.format(s=styled_status(site.enabled)), bold=True)\n        click.secho('IN_DEV: {id}'.format(id=styled_status(site.in_dev)), bold=True)\n        click.secho('SSL: {s}'.format(s=styled_status(site.ssl)), bold=True)\n        click.secho('SPDY: {s}'.format(s=styled_status(site.spdy)), bold=True)\n        click.secho('GZIP: {g}'.format(g=styled_status(site.gzip)), bold=True)\n        click.secho('MySQL Database: {db}'.format(db=site.db_name), bold=True)\n        click.secho('MySQL User: {u}'.format(u=site.db_user), bold=True)\n        click.secho('MySQL Password: {u}'.format(u=site.db_pass), bold=True)\n        return\n\n    # Print sites\n    if dname:\n        # Get sites\n        sites = Site.all(domain)\n        if not sites:\n            click.secho('No sites active under domain: {dn}'.format(dn=dname), fg='red', bold=True, err=True)\n            return\n\n        # Display site data\n        for site in sites:\n            prefix = '[DEV] ' if site.in_dev else ''\n            fg = 'green' if site.enabled else 'white'\n            click.secho('{pre}{name} ({ver})'.format(pre=prefix, name=site.name, ver=site.version), fg=fg, bold=True)\n\n        return\n\n    # Print domains\n    domains = Domain.all()\n    for domain in domains:\n        # Extra domains\n        extras = ''\n        if domain.extras:\n            extras = ' ({dnames})'.format(dnames=str(domain.extras).replace(',', ', '))\n\n        click.secho('{dname}{extras}'.format(dname=domain.name, extras=extras), bold=True)", "response": "List all domains hosted under a domain and site."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsplits the source file text by triple - dashed lines.", "response": "def _split_source_page(self, path):\n        \"\"\"Split the source file texts by triple-dashed lines.\n\n        shit code\n        \"\"\"\n        with codecs.open(path, \"rb\", \"utf-8\") as fd:\n            textlist = fd.readlines()\n\n        metadata_notation = \"---\\n\"\n        if textlist[0] != metadata_notation:\n            logging.error(\n                \"{} first line must be triple-dashed!\".format(path)\n            )\n            sys.exit(1)\n\n        metadata_textlist = []\n        metadata_end_flag = False\n        idx = 1\n        max_idx = len(textlist)\n        # TODO(crow): BE PYTHONIC!!!\n        while not metadata_end_flag:\n            metadata_textlist.append(textlist[idx])\n            idx += 1\n            if idx >= max_idx:\n                logging.error(\n                    \"{} doesn't have end triple-dashed!\".format(path)\n                )\n                sys.exit(1)\n            if textlist[idx] == metadata_notation:\n                metadata_end_flag = True\n        content = textlist[idx + 1:]\n\n        return metadata_textlist, content"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _get_feed_data(self, file_paths):\n        rv = {}\n        for i in file_paths:\n            # TODO(crow): only support first category\n            _ = i.split('/')\n            category = _[-2]\n            name = _[-1].split('.')[0]\n            page_config, md = self._get_config_and_content(i)\n            parsed_md = tools.parse_markdown(md, self.site_config)\n            rv.setdefault(category, {})\n            rv[category].update(\n                {\n                    i: {\n                        'title': page_config.get('title', ''),\n                        'name': name.decode('utf-8'),\n                        'content': parsed_md,\n                        'date': page_config.get('date', '')\n                        }\n                    }\n                )\n        return rv", "response": "get data to display in feed file"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nrender feed file with data", "response": "def _generate_feed(self, feed_data):\n        \"\"\" render feed file with data\n        \"\"\"\n        atom_feed = self._render_html('atom.xml', feed_data)\n\n        feed_path = os.path.join(os.getcwd(), 'public', 'atom.xml')\n\n        with codecs.open(feed_path, 'wb', 'utf-8') as f:\n            f.write(atom_feed)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef parse_date(val, fmt=None):\n  if isinstance(val, date):\n    return val\n  else:\n    return parse_datetime(val, fmt).date()", "response": "Parses a date object from a string."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns a time object parsed from val.", "response": "def parse_time(val, fmt=None):\n  \"\"\"Returns a time object parsed from :val:.\n\n  :param val: a string to be parsed as a time\n  :param fmt: a format string, a tuple of format strings, or None. If None a built in list of format\n              strings will be used to try to parse the time.\n  \"\"\"\n  if isinstance(val, time):\n    return val\n  else:\n    return parse_datetime(val, fmt).time()"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef parse_datetime(val, fmt=None):\n  if isinstance(val, datetime):\n    return val\n  else:\n    return _parse_datetime(_normalize_tz(str(val)), fmt)", "response": "Parses a string into a datetime object."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _parse_datetime(val, fmt=None):\n  if fmt is None:\n    fmt = _DEFAULT_FORMATS\n\n  if isinstance(fmt, str):\n    return datetime.strptime(val, fmt)\n  else:\n    for opt in fmt:\n      try:\n        return _parse_datetime(val, opt)\n      except ValueError:\n        continue\n    raise ValueError(\"Unable to parse string '{}' as a timestamp\".format(val))", "response": "Parses a string as a date and returns a datetime object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nnormalize all valid ISO8601 time zone variants to one python will parse.", "response": "def _normalize_tz(val):\n  \"\"\"Normalizes all valid ISO8601 time zone variants to the one python will\n  parse.\n\n  :val: a timestamp string without a timezone, or with a timezone in one of the ISO8601 accepted\n        formats.\n  \"\"\"\n  match = _TZ_RE.match(val)\n  if match:\n    ts, tz = match.groups()\n    if len(tz) == 5:\n      # If the length of the tz is 5 then it is of the form (+|-)dddd, which is exactly what python\n      # wants, so just return it.\n      return ts + tz\n    if len(tz) == 6:\n      # If the length of the tz is 6 then it is of the form (+|-)dd:dd, just remove the colon\n      return ts + tz[:3] + tz[4:]\n    if tz == \"Z\" or tz == \"z\":\n      # If the tz is \"Z\" or 'z', return a timezone of +0000\n      return ts + \"+0000\"\n    else:\n      # Otherwise, the timzone must be of the format (+|-)dd, in which case we just need to add two\n      # \"0\" to it, and it will be in the proper format.\n      return ts + tz + \"00\"\n  else:\n    return val"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a tuple of all date and time format strings joined together by", "response": "def _join_date_and_time(dates, times, joiner):\n  \"\"\"Returns a tuple of all date and time format strings joined together by\n  :joiner:.\n\n  :dates: an enumerable of date format strings\n  :times: an enumerable of time format strings\n  :joiner: a string to join a date and time format together\n  \"\"\"\n  return tuple(\"{}{}{}\".format(d, joiner, t) for (d, t) in itertools.product(dates, times))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef node(self, nodeid):\n        _assert_valid_nodeid(nodeid)\n        # addr = 'tcp://' + nodeid\n        # insock = MockInSocket(addEndpoints=lambda endpoints: self.bind(addr, insock, endpoints))\n        # outsock = lambda: MockOutSocket(addr, self)\n\n        return Node(hub=Hub(nodeid=nodeid))", "response": "Create a new node with the specified name with MockSocket instances as incoming and outgoing sockets."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef transmit(self):\n        if not self.queue:\n            return\n\n        deliverable = []\n\n        for src, dst, msg in self.queue:\n            _assert_valid_addr(src)\n            _assert_valid_addr(dst)\n\n            # assert (src, dst) in self.connections, \"Hubs should only send messages to addresses they have previously connected to\"\n\n            if random.random() <= self._packet_loss.get((src, dst), 0.0):\n                dbg(\"packet lost: %r  %s \u2192 %s\" % (msg, src, dst))\n                continue\n\n            if dst not in self.listeners:\n                pass  # dbg(u\"%r \u21dd \u21b4\" % (_dumpmsg(msg),))\n            else:\n                # dbg(u\"%r \u2192 %s\" % (_dumpmsg(msg), dst))\n                sock = self.listeners[dst]\n                deliverable.append((msg, src, sock))\n\n        del self.queue[:]\n\n        for msg, src, sock in deliverable:\n            sock.gotMultipart(msg)", "response": "Puts all currently pending messages to the insock buffer of the recipient of the message."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nopens the connection to the database based on the configuration file.", "response": "def _get_db(self):\n        \"\"\"\n        Open the connection to the database based on the configuration file.\n        \"\"\"\n        if self._connection:\n            try:\n                self._connection.close()\n            except Exception:\n                pass\n\n        return DB(storageFromFile(open(self.conf_path)))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating plot and plot the current state of the object.", "response": "def do_plot_and_bestfit(self):\n        \"\"\"\n        Create plot\n        \"\"\"\n        # Plot\n        fmt = str(self.kwargs.get(\"fmt\", \"k.\"))\n        if \"errors\" in self.kwargs:\n            errors = self.kwargs[\"errors\"]\n            if isinstance(errors, dict):\n                self.subplot.errorbar(self.x, self.y, fmt=fmt,\n                                      xerr=errors.get(\"xerr\", None),\n                                      yerr=errors.get(\"yerr\", None))\n            elif isinstance(errors, (collections.Sequence, np.ndarray, float)):\n                self.subplot.errorbar(self.x, self.y, fmt=fmt, yerr=errors)\n            else:\n                self.subplot.plot(self.x, self.y, fmt)\n        else:\n            self.subplot.plot(self.x, self.y, fmt)\n\n        # bestfit\n        bestfit = self.kwargs.get(\"bestfit\", None)\n        if bestfit is not None:\n            bestfitlim = self.kwargs.get(\"bestfitlim\", None)\n            if bestfitlim is None:\n                bestfitlim = self.kwargs.get(\"xlim\", None)\n            if bestfitlim is None:\n                bestfitlim = (min(self.x), max(self.x))\n            fit_args = bestfit.do_bestfit()\n            bestfit_line = bestfit.get_bestfit_line(\n                x_min=bestfitlim[0], x_max=bestfitlim[1])\n            self.subplot.plot(\n                bestfit_line[0], bestfit_line[1],\n                self.kwargs.get(\"bestfitfmt\", \"k-\")\n            )\n            self.outputdict[\"fit_args\"] = fit_args\n            self.outputdict[\"rmse\"] = bestfit.get_rmse()\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef do_label(self):\n        outputdict = self.outputdict\n        xlabel_options = self.kwargs.get(\"xlabel_options\", {})\n        self.subplot.set_xlabel(\n            self.kwargs.get(\"xlabel\", \"\").format(**outputdict),\n            **xlabel_options)\n        ylabel_options = self.kwargs.get(\"ylabel_options\", {})\n        self.subplot.set_ylabel(\n            self.kwargs.get(\"ylabel\", \"\").format(**outputdict),\n            **ylabel_options)\n        suptitle = self.kwargs.get(\"suptitle\", None)\n        if suptitle is not None:\n            suptitle_options = self.kwargs.get(\"suptitle_options\", {})\n            self.figure.suptitle(\n                suptitle.format(**outputdict),\n                fontsize=int(self.kwargs.get(\"suptitle_fontsize\", 15)),\n                **suptitle_options)\n        title = self.kwargs.get(\"title\", None)\n        if title is not None:\n            title_options = self.kwargs.get(\"title_options\", {})\n            self.subplot.set_title(\n                title.format(**outputdict),\n                fontsize=int(self.kwargs.get(\"title_fontsize\", 12)),\n                **title_options)\n        xlim = self.kwargs.get(\"xlim\", None)\n        ylim = self.kwargs.get(\"ylim\", None)\n        if xlim is not None:\n            self.subplot.set_xlim(xlim)\n        if ylim is not None:\n            self.subplot.set_ylim(ylim)\n        # axis format\n        self.subplot.ticklabel_format(\n            style=\"sci\", useOffset=False,\n            scilimits=self.kwargs.get(\"scilimits\", (-4, 4))\n        )\n        return self", "response": "Create label for x and y axis title and suptitle"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef plot(self):\n        self.before_plot()\n        self.do_plot_and_bestfit()\n        self.after_plot()\n        self.do_label()\n        self.after_label()\n        self.save()\n        self.close()\n        return self.outputdict", "response": "Plot the log file and return a dictionary of the output dictionary."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef extant_item(arg, arg_type):\n    if arg_type == \"file\":\n        if not os.path.isfile(arg):\n            raise argparse.ArgumentError(\n                None,\n                \"The file {arg} does not exist.\".format(arg=arg))\n        else:\n            # File exists so return the filename\n            return arg\n    elif arg_type == \"directory\":\n        if not os.path.isdir(arg):\n            raise argparse.ArgumentError(\n                None,\n                \"The directory {arg} does not exist.\".format(arg=arg))\n        else:\n            # Directory exists so return the directory name\n            return arg", "response": "Determine if parser argument is an existing file or directory."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nparsing the args using the config_file input_dir output_dir pattern", "response": "def parse_config_input_output(args=sys.argv):\n    \"\"\"Parse the args using the config_file, input_dir, output_dir pattern\n\n    Args:\n        args: sys.argv\n\n    Returns:\n        The populated namespace object from parser.parse_args().\n\n    Raises:\n        TBD\n    \"\"\"\n    parser = argparse.ArgumentParser(\n        description='Process the input files using the given config')\n    parser.add_argument(\n        'config_file',\n        help='Configuration file.',\n        metavar='FILE', type=extant_file)\n    parser.add_argument(\n        'input_dir',\n        help='Directory containing the input files.',\n        metavar='DIR', type=extant_dir)\n    parser.add_argument(\n        'output_dir',\n        help='Directory where the output files should be saved.',\n        metavar='DIR', type=extant_dir)\n    return parser.parse_args(args[1:])"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nparsing the args using the config_file pattern", "response": "def parse_config(args=sys.argv):\n    \"\"\"Parse the args using the config_file pattern\n\n    Args:\n        args: sys.argv\n\n    Returns:\n        The populated namespace object from parser.parse_args().\n\n    Raises:\n        TBD\n    \"\"\"\n    parser = argparse.ArgumentParser(\n        description='Read in the config file')\n    parser.add_argument(\n        'config_file',\n        help='Configuration file.',\n        metavar='FILE', type=extant_file)\n    return parser.parse_args(args[1:])"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef parse_args(args=None):\n    from argparse import ArgumentParser\n\n    if args is None:\n        args = sys.argv[1:]\n\n    parser = ArgumentParser(description='Demonstrate drawing SVG on Clutter '\n                            'stage')\n    parser.add_argument('svg_path')\n    parser.add_argument('shape', nargs='?', default=None)\n\n    args = parser.parse_args(args)\n    return args", "response": "Parses arguments returns options and args."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef lookup(self, mbid, include=()):\n\n        if include:\n            for included in include:\n                if included not in self.available_includes:\n                    raise ValueError(\n                        \"{0!r} is not an includable entity for {1}\".format(\n                            included, self.path,\n                        ),\n                    )\n            query_string = \"?\" + urlencode([(\"inc\", \" \".join(include))])\n        else:\n            query_string = \"\"\n\n        path = \"{0}/{1}{2}\".format(self.path, mbid, query_string)\n        return self.client.request(path)", "response": "Lookup an entity directly from a specified MusicBrainz ID."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef search(self, query):\n\n        return self.client.request(\n            self.path + \"?\" + urlencode([(\"query\", query)]),\n        )", "response": "Perform a Lucene search of the entity."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get(self, CachableItem):\n        return self.session.\\\n                        query(self.mapper.factory().__class__).\\\n                        filter(self.mapper.factory().__class__.__dict__[self.mapper.key()]==CachableItem.getId()).\\\n                        first()", "response": "Returns the current ICachedItem for ICachableItem"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef cache(self, CachableItem):\n        _cachedItem = self.get(CachableItem)\n        if not _cachedItem:\n            _dirtyCachedItem = self.mapper.get(CachableItem)\n            logger.debug(\"new cachable item added to sql cache area {id: %s, type: %s}\", str(_dirtyCachedItem.getId()), str(_dirtyCachedItem.__class__))\n            cached_item = self.session.merge(_dirtyCachedItem)\n            notify(CacheObjectCreatedEvent(cached_item, self))\n            return cached_item\n        else:\n            _newCacheItem = self.mapper.get(CachableItem)\n            if _cachedItem != _newCacheItem:\n                logger.debug(\"Cachable item modified in sql cache area {id: %s, type: %s}\", str(_newCacheItem.getId()), str(_newCacheItem.__class__))\n                cached_item = self.session.merge(_newCacheItem)\n                notify(CacheObjectModifiedEvent(cached_item, self))\n                return cached_item\n        return False", "response": "Updates the cache area with latest information\n           "}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef import_source(self, CachableSource):\n        _count = 0\n        for item in CachableSource.items():\n            if self.cache(item):\n                _count += 1\n        return _count", "response": "Updates cache area and returns number of items updated with all available entries in CachableSource"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ndeleting all entries in the cache area", "response": "def reset(self):\n        \"\"\"Deletes all entries in the cache area\"\"\"\n        self.Base.metadata.drop_all(self.session.bind)\n        self.initialize()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef initialize(self):\n        self.Base.metadata.create_all(self.session.bind)\n        logger.debug(\"initialized sqlalchemy orm tables\")", "response": "Instantiates the cache area to be ready for updates"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef format_json(item, **kwargs):\n    try:\n        json.dumps(item.value)\n        return item.value\n    except TypeError:\n        if 'time' in item.class_type.lower() \\\n                or 'date' in item.class_type.lower():\n            return item.value.isoformat()\n        raise", "response": "formats a datatype object to a json value"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef format_sparql(item, dt_format='turtle', **kwargs):\n    try:\n        rtn_val = json.dumps(item.value)\n        rtn_val = item.value\n    except:\n        if 'time' in item.class_type.lower() \\\n                or 'date' in item.class_type.lower():\n            rtn_val = item.value.isoformat()\n        else:\n            rtn_val = str(item.value)\n    if hasattr(item, \"datatype\"):\n        if hasattr(item, \"lang\") and item.lang:\n            rtn_val = '%s@%s' % (json.dumps(rtn_val), item.lang)\n        else:\n            dt = item.datatype\n            if dt_format == \"uri\":\n                dt = item.datatype.sparql_uri\n            if item.datatype in [\"xsd_string\",\n                                 \"xsd_dateTime\",\n                                 \"xsd_time\",\n                                 \"xsd_date\"]:\n                rtn_val = json.dumps(rtn_val)\n            else:\n                rtn_val = '\"%s\"' % json.dumps(rtn_val)\n            rtn_val = '%s^^%s' % (rtn_val, dt.sparql)\n    return rtn_val", "response": "Formats a datatype value to a SPARQL representation of the object."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _format(self, method=\"sparql\", dt_format=\"turtle\"):\n\n        try:\n            return __FORMAT_OPTIONS__[method](self, dt_format=dt_format)\n        except KeyError:\n            raise NotImplementedError(\"'{}' is not a valid format method\"\n                                      \"\".format(method))", "response": "Returns the value in various formats"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef bind(self, prefix, namespace, *args, **kwargs):\n        # RdfNamespace(prefix, namespace, **kwargs)\n        setattr(self, prefix, RdfNamespace(prefix, namespace, **kwargs))\n        if kwargs.pop('calc', True):\n            self.__make_dicts__", "response": "Adds an attribute to the class for each\n        added namespace to allow for use of dot notation."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef prefix(self, format=\"sparql\"):\n        ''' Generates a string of the rdf namespaces listed used in the\n            framework\n\n            format: \"sparql\" or \"turtle\"\n        '''\n\n        lg = logging.getLogger(\"%s.%s\" % (self.ln, inspect.stack()[0][3]))\n        lg.setLevel(self.log_level)\n\n        _return_str = \"\"\n        if format.lower() == \"sparql\":\n            return \"\\n\".join([ns._sparql_ for ns in self.namespaces])\n        elif format.lower() in [\"turtle\", \"ttl\"]:\n            return \"\\n\".join([ns._ttl_ for ns in self.namespaces])\n        elif format.lower() in [\"rdf\", \"xml\", \"rdf/xml\"]:\n            return \"<rdf:RDF %s>\" % \\\n                    \" \".join([ns._xml_ for ns in self.namespaces])\n        else:\n            raise NotImplementedError(\"'%s' is not a valid prefix type.\" %\n                                      format)", "response": "Generates a string of the rdf namespaces listed in the the\n            framework\n            format is sparql or turtle"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreads the beginning of a turtle file and sets the prefix s used in that file and sets the prefix attribute in that file.", "response": "def load(self, filepath, file_encoding=None):\n        \"\"\" Reads the the beginning of a turtle file and sets the prefix's used\n        in that file and sets the prefix attribute\n\n        Args:\n            filepath: the path to the turtle file\n            file_encoding: specify a specific encoding if necessary\n        \"\"\"\n        with open(filepath, encoding=file_encoding) as inf:\n            for line in inf:\n                current_line = str(line).strip()\n                if current_line.startswith(\"@prefix\"):\n                    self._add_ttl_ns(current_line.replace(\"\\n\",\"\"))\n                elif len(current_line) > 10:\n                    break\n        self.__make_dicts__"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreads a dictionary of namespaces and binds them to the manager", "response": "def dict_load(self, ns_dict):\n        \"\"\" Reads a dictionary of namespaces and binds them to the manager\n\n        Args:\n            ns_dict: dictionary with the key as the prefix and the value\n                     as the uri\n        \"\"\"\n        for prefix, uri in ns_dict.items():\n            self.bind(prefix, uri, override=False, calc=False)\n        self.__make_dicts__"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nadds the namespace to the class holding the turtle", "response": "def _add_ttl_ns(self, line):\n        \"\"\" takes one prefix line from the turtle file and binds the namespace\n        to the class\n\n        Args:\n            line: the turtle prefix line string\n        \"\"\"\n        lg = logging.getLogger(\"%s.%s\" % (self.ln, inspect.stack()[0][3]))\n        lg.setLevel(self.log_level)\n\n        lg.debug(\"line:\\n%s\", line)\n        line = str(line).strip()\n        # if the line is not a prefix line exit\n        if line is None or line == 'none' or line == '' \\\n                or not line.lower().startswith('@prefix'):\n            return\n        # parse the turtle line\n        line = line.replace(\"@prefix\",\"\",1).strip()\n        if line.endswith(\".\"):\n            line = line[:-1]\n        prefix = line[:line.find(\":\")].strip()\n        uri = self.clean_iri(line[line.find(\":\")+1:].strip())\n        # add the namespace to the class\n        lg.debug(\"\\nprefix: %s  uri: %s\", prefix, uri)\n        self.bind(prefix, uri, override=False, calc=False)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef uri(self, value, strip_iri=True):\n\n        return self.convert_to_uri(value, strip_iri=strip_iri)", "response": "Converts a py_uri or ttl uri to a http... full uri"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef convert_to_uri(self, value, strip_iri=True):\n        ''' converts a prefixed rdf ns equivalent value to its uri form.\n            If not found returns the value as is\n\n            args:\n                value: the URI/IRI to convert\n                strip_iri: removes the < and > signs\n                rdflib_uri: returns an rdflib URIRef\n            '''\n        parsed = self.parse_uri(str(value))\n\n        try:\n            new_uri = \"%s%s\" % (self.ns_dict[parsed[0]], parsed[1])\n            if not strip_iri:\n                return self.iri(new_uri)\n            return new_uri\n        except KeyError:\n            return self.rpyhttp(value)", "response": "converts a prefixed rdf ns equivalent value to its uri form."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ntake an value and returns a tuple of the parts", "response": "def get_uri_parts(self, value):\n        \"\"\"takes an value and returns a tuple of the parts\n\n        args:\n            value: a uri in any form pyuri, ttl or full IRI\n        \"\"\"\n        if value.startswith('pyuri_'):\n            value = self.rpyhttp(value)\n        parts = self.parse_uri(value)\n        try:\n            return (self.ns_dict[parts[0]], parts[1])\n        except KeyError:\n            try:\n                return (self.ns_dict[parts[0].lower()], parts[1])\n            except KeyError:\n                return ((None, parts[0]), parts[1])"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef rpyhttp(value):\n        if value.startswith(\"http\"):\n            return value\n        try:\n            parts = value.split(\"_\")\n            del parts[0]\n            _uri = base64.b64decode(parts.pop(0)).decode()\n            return _uri + \"_\".join(parts)\n        except (IndexError, UnicodeDecodeError, binascii.Error):\n            # if the value is not a pyuri return the value\n            return value", "response": "Converts a no namespace pyuri back to a standard uri"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef pyhttp(self, value):\n        if value.startswith(\"pyuri_\"):\n            return value\n        parts = self.parse_uri(value)\n        return \"pyuri_%s_%s\" % (base64.b64encode(bytes(parts[0],\n                                                       \"utf-8\")).decode(),\n                                parts[1])", "response": "converts a no namespaces uri to a python excessable name"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef iri(uri_string):\n        uri_string = str(uri_string)\n        if uri_string[:1] == \"?\":\n            return uri_string\n        if uri_string[:1] == \"[\":\n            return uri_string\n        if uri_string[:1] != \"<\":\n            uri_string = \"<{}\".format(uri_string.strip())\n        if uri_string[len(uri_string)-1:] != \">\":\n            uri_string = \"{}>\".format(uri_string.strip())\n        return uri_string", "response": "converts a string to an IRI or returns an IRI if already formated\n            is True"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef convert_to_ttl(self, value):\n        ''' converts a value to the prefixed rdf ns equivalent. If not found\n            returns the value as is.\n\n        args:\n            value: the value to convert\n        '''\n\n        parsed = self.parse_uri(value)\n\n        try:\n            rtn_val = \"%s:%s\" % (self.uri_dict[parsed[0]], parsed[1])\n        except KeyError:\n            rtn_val = self.iri(self.rpyhttp(value))\n\n        return rtn_val", "response": "converts a value to the prefixed rdf ns equivalent."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nconvert a value to the prefixed rdf ns equivalent. If not found returns the value as is", "response": "def convert_to_ns(self, value):\n        ''' converts a value to the prefixed rdf ns equivalent. If not found\n            returns the value as is\n\n        args:\n            value: the value to convert\n        '''\n        parsed = self.parse_uri(value)\n\n        try:\n            rtn_val = \"%s_%s\" % (self.uri_dict[parsed[0]], parsed[1])\n        except KeyError:\n            rtn_val = self.pyhttp(value)\n        return rtn_val"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef parse_uri(value):\n        value = RdfNsManager.clean_iri(value)\n        lookup = None\n        end = None\n\n        try:\n            lookup = value[:value.rindex('#')+1]\n            end = value[value.rindex('#')+1:]\n        except ValueError:\n            try:\n                lookup = value[:value.rindex('/')+1]\n                end = value[value.rindex('/')+1:]\n            except ValueError:\n                try:\n                    lookup = value[:value.index(':')]\n                    end = value[value.rindex(':')+1:]\n                except ValueError:\n                    try:\n                        lookup = value[:value.index('_')]\n                        end = value[value.index('_')+1:]\n                    except ValueError:\n                        lookup = value\n                        end = \"\"\n\n        return (lookup, end)", "response": "Parses a value into a head and tail pair based on the finding the\n            last '#' or '/' or _."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef warn_explicit(message, category, filename, lineno,\n                      module=None, registry=None, module_globals=None,\n                      emit_module=None):\n    \"\"\"\n    Low level implementation of the warning functionality.\n    Duplicate of the standard library `warnings.warn_explicit`,\n    except it accepts the following arguments:\n\n    `emit_module`: regular expression that should match the module the warnings\n                   are emitted from.\n\n\n    \"\"\"\n    lineno = int(lineno)\n    if module is None:\n        module = filename or \"<unknown>\"\n        if module[-3:].lower() == \".py\":\n            module = module[:-3]  # XXX What about leading pathname?\n    if registry is None:\n        registry = {}\n    if registry.get('version', 0) != warnings._filters_version:\n        registry.clear()\n        registry['version'] = warnings._filters_version\n    if isinstance(message, Warning):\n        text = str(message)\n        category = message.__class__\n    else:\n        text = message\n        message = category(message)\n    key = (text, category, lineno)\n    # Quick test for common case\n    if registry.get(key):\n        return\n    # Search the filters\n    for item in warnings.filters:\n        item = _get_proxy_filter(item)\n        if len(item) == 5:\n            action, msg, cat, mod, ln = item\n            emod = None\n        else:\n            action, msg, cat, mod, ln, emod = item\n        if ((msg is None or msg.match(text)) and\n           issubclass(category, cat) and\n           (mod is None or mod.match(module)) and\n           (emod is None or emod.match(emit_module)) and\n           (ln == 0 or lineno == ln)):\n            break\n    else:\n        action = defaultaction\n    # Early exit actions\n    if action == \"ignore\":\n        registry[key] = 1\n        return\n\n    # Prime the linecache for formatting, in case the\n    # \"file\" is actually in a zipfile or something.\n    import linecache\n    linecache.getlines(filename, module_globals)\n\n    if action == \"error\":\n        raise message\n    # Other actions\n    if action == \"once\":\n        registry[key] = 1\n        oncekey = (text, category)\n        if onceregistry.get(oncekey):\n            return\n        onceregistry[oncekey] = 1\n    elif action == \"always\":\n        pass\n    elif action == \"module\":\n        registry[key] = 1\n        altkey = (text, category, 0)\n        if registry.get(altkey):\n            return\n        registry[altkey] = 1\n    elif action == \"default\":\n        registry[key] = 1\n    else:\n        # Unrecognized actions are errors\n        raise RuntimeError(\n            \"Unrecognized action (%r) in warnings.filters:\\n %s\" %\n            (action, item))\n    if not callable(warnings.showwarning):\n        raise TypeError(\"warnings.showwarning() must be set to a \"\n                        \"function or method\")\n    # Print message and context\n    warnings.showwarning(message, category, filename, lineno)", "response": "A simple warning message handler that returns a new object that can be used to create a new warning message."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _get_stack_frame(stacklevel):\n    stacklevel = stacklevel + 1\n    if stacklevel <= 1 or _is_internal_frame(sys._getframe(1)):\n        # If frame is too small to care or if the warning originated in\n        # internal code, then do not try to hide any frames.\n        frame = sys._getframe(stacklevel)\n    else:\n        frame = sys._getframe(1)\n        # Look for one frame less since the above line starts us off.\n        for x in range(stacklevel-1):\n            frame = _next_external_frame(frame)\n            if frame is None:\n                raise ValueError\n    return frame", "response": "Utility function to get a stackframe from sys. _getframe."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef warn(message, category=None, stacklevel=1, emitstacklevel=1):\n    # Check if message is already a Warning object\n\n    ####################\n    ### Get category ###\n    ####################\n    if isinstance(message, Warning):\n        category = message.__class__\n    # Check category argument\n    if category is None:\n        category = UserWarning\n    if not (isinstance(category, type) and issubclass(category, Warning)):\n        raise TypeError(\"category must be a Warning subclass, \"\n                        \"not '{:s}'\".format(type(category).__name__))\n    # Get context information\n    try:\n        frame = _get_stack_frame(stacklevel)\n    except ValueError:\n        globals = sys.__dict__\n        lineno = 1\n    else:\n        globals = frame.f_globals\n        lineno = frame.f_lineno\n\n    try:\n        eframe = _get_stack_frame(emitstacklevel)\n    except ValueError:\n        eglobals = sys.__dict__\n    else:\n        eglobals = eframe.f_globals\n    if '__name__' in eglobals:\n        emodule = eglobals['__name__']\n    else:\n        emodule = \"<string>\"\n\n    ####################\n    ### Get Filename ###\n    ####################\n    if '__name__' in globals:\n        module = globals['__name__']\n    else:\n        module = \"<string>\"\n    ####################\n    ### Get Filename ###\n    ####################\n    filename = globals.get('__file__')\n    if filename:\n        fnl = filename.lower()\n        if fnl.endswith(\".pyc\"):\n            filename = filename[:-1]\n    else:\n        if module == \"__main__\":\n            try:\n                filename = sys.argv[0]\n            except AttributeError:\n                # embedded interpreters don't have sys.argv, see bug #839151\n                filename = '__main__'\n        if not filename:\n            filename = module\n    registry = globals.setdefault(\"__warningregistry__\", {})\n    warn_explicit(message, category, filename, lineno, module, registry,\n                  globals, emit_module=emodule)", "response": "Issue a warning or raise an exception."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _set_proxy_filter(warningstuple):\n\n    if len(warningstuple) > 5:\n        key = len(_proxy_map)+1\n        _proxy_map[key] = warningstuple\n        # always is pass-through further in the code.\n        return ('always', re_matchall, ProxyWarning, re_matchall, key)\n    else:\n        return warningstuple", "response": "set up a proxy that store too long warnings in a separate map"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef filterwarnings(action, message=\"\", category=Warning, module=\"\", lineno=0,\n                   append=False, emodule=\"\"):\n    \"\"\"Insert an entry into the list of warnings filters (at the front).\n\n    'action' -- one of \"error\", \"ignore\", \"always\", \"default\", \"module\",\n                or \"once\"\n    'message' -- a regex that the warning message must match\n    'category' -- a class that the warning must be a subclass of\n    'module' -- a regex that the module name must match\n    'lineno' -- an integer line number, 0 matches all warnings\n    'append' -- if true, append to the list of filters\n    'emodule' -- a regex that the module emitting the warning must match.\n\n    \"\"\"\n    assert action in (\"error\", \"ignore\", \"always\", \"default\", \"module\",\n                      \"once\"), \"invalid action: %r\" % (action,)\n    assert isinstance(message, str), \"message must be a string\"\n    assert isinstance(category, type), \"category must be a class\"\n    assert issubclass(category, Warning), \"category must be a Warning subclass\"\n    assert isinstance(module, str), \"module must be a string\"\n    assert isinstance(lineno, int) and lineno >= 0, \\\n        \"lineno must be an int >= 0\"\n    if emodule:\n        item = (action, re.compile(message, re.I), category,\n            re.compile(module), lineno, re.compile(emodule, ))\n    else:\n        item = (action, re.compile(message, re.I), category,\n            re.compile(module), lineno)\n    if append:\n        warnings.filters.append(_set_proxy_filter(item))\n    else:\n        warnings.filters.insert(0, _set_proxy_filter(item))\n    warnings._filters_mutated()", "response": "Add a new entry to the list of filters that can be applied to the warnings."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef release(ctx, deploy=False, test=False, version=''):\n    if test:\n        run(\"python setup.py check\")\n        run(\"python setup.py register sdist upload --dry-run\")\n\n    if deploy:\n        run(\"python setup.py check\")\n        if version:\n            run(\"git checkout master\")\n            run(\"git tag -a v{ver} -m 'v{ver}'\".format(ver=version))\n            run(\"git push\")\n            run(\"git push origin --tags\")\n            run(\"python setup.py sdist bdist_wheel\")\n            run(\"twine upload --skip-existing dist/*\")\n    else:\n        print(\"- Have you updated the version?\")\n        print(\"- Have you updated CHANGELOG.md, README.md, and AUTHORS.md?\")\n        print(\"- Have you fixed any last minute bugs?\")\n        print(\"- Have you merged changes for release into the master branch?\")\n        print(\"If you answered yes to all of the above questions,\")\n        print(\"then run `inv release --deploy -vX.YY.ZZ` to:\")\n        print(\"- Checkout master\")\n        print(\"- Tag the git release with provided vX.YY.ZZ version\")\n        print(\"- Push the master branch and tags to repo\")", "response": "Tag the release with provided version and deploy to PyPI"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef squarify_table(table):\n    '''\n    Updates a table so that all rows are the same length by filling smaller\n    rows with 'None' objects up to the length of the largest row.\n    '''\n    max_length = 0\n    min_length = maxsize\n    for row in table:\n        row_len = len(row)\n        if row_len > max_length:\n            max_length = row_len\n        if row_len < min_length:\n            min_length = row_len\n    if max_length != min_length:\n        for row in table:\n            row_len = len(row)\n            if row_len < max_length:\n                row.extend([None]*(max_length-row_len))", "response": "Squarify a table so that all rows are the same length by filling smaller rows with None objects up to the length of the largest row."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef authenticate(self):\n        self.log.info('starting the ``authenticate`` method')\n\n        if not self.settings[\"flickr\"] or \"consumer_key\" not in self.settings[\"flickr\"] or \"consumer_secret\" not in self.settings[\"flickr\"]:\n            print \"Navigate here <https://www.flickr.com/services/apps/create/apply/> and request a 'non-commerial key'\"\n            time.sleep(2)\n            # open in webbrowser\n            webbrowser.open_new_tab(\n                \"https://www.flickr.com/services/apps/create/apply/\")\n\n            consumer_key = raw_input(\"What is your new API key value? \\n  >  \")\n            consumer_secret = raw_input(\n                \"What is your new API secret value? \\n  >  \")\n\n        else:\n            consumer_key = str(self.settings[\"flickr\"][\"consumer_key\"])\n            consumer_secret = str(self.settings[\"flickr\"][\"consumer_secret\"])\n\n        auth = OAuth1(consumer_key, consumer_secret)\n\n        try:\n            response = requests.get(\n                url=\"http://www.flickr.com/services/oauth/request_token\",\n                params={\n                    \"oauth_callback\": \"http://www.thespacedoctor.co.uk\",\n                },\n                auth=auth\n            )\n        except requests.exceptions.RequestException:\n            print('HTTP Request failed')\n\n        oauthList = response.content.split(\"&\")\n        oauth_token = str(oauthList[1].split(\"=\")[1])\n        oauth_token_secret = str(oauthList[2].split(\"=\")[1])\n\n        print \"Now to authorize picaxe against your personal flickr account\"\n        print \"Navigate to https://www.flickr.com/services/oauth/authorize?perms=write&oauth_token=\" + oauth_token + \" and click on 'OK, I'LL AUTHOURIZE IT'\"\n        time.sleep(1)\n        webbrowser.open_new_tab(\n            \"https://www.flickr.com/services/oauth/authorize?perms=write&oauth_token=\" + oauth_token)\n\n        oauth_verifier = raw_input(\n            \"What is the oauth_verifier value in URL you where redirected to? \\n  >  \")\n        oauth_verifier = str(oauth_verifier.strip())\n\n        auth = OAuth1(consumer_key, consumer_secret,\n                      oauth_token, oauth_token_secret)\n\n        try:\n            response = requests.get(\n                url=\"https://www.flickr.com/services/oauth/access_token\",\n                params={\n                    \"oauth_verifier\": oauth_verifier,\n                    \"oauth_callback\": \"http://www.thespacedoctor.co.uk\"\n                },\n                auth=auth\n            )\n        except requests.exceptions.RequestException:\n            print('HTTP Request failed')\n\n        oauthList = response.content.split(\"&\")\n        oauth_token = oauthList[1].split(\"=\")[1]\n        oauth_token_secret = oauthList[2].split(\"=\")[1]\n        user_nsid = oauthList[3].split(\"=\")[1]\n        username = oauthList[4].split(\"=\")[1]\n\n        if not self.pathToSettingsFile:\n            self.pathToSettingsFile = expanduser(\n                \"~\") + \"/.config/picaxe/picaxe.yaml\"\n\n        stream = file(self.pathToSettingsFile, 'r')\n        yamlContent = yaml.load(stream)\n        stream.close()\n\n        yamlContent[\"flickr\"] = {}\n        yamlContent[\"flickr\"][\"consumer_key\"] = consumer_key\n        yamlContent[\"flickr\"][\"consumer_secret\"] = consumer_secret\n        yamlContent[\"flickr\"][\"oauth_token\"] = oauth_token\n        yamlContent[\"flickr\"][\"oauth_token_secret\"] = oauth_token_secret\n        yamlContent[\"flickr\"][\"user_nsid\"] = user_nsid\n        yamlContent[\"flickr\"][\"username\"] = username\n\n        stream = file(self.pathToSettingsFile, 'w')\n        yaml.dump(yamlContent, stream, default_flow_style=False)\n        stream.close()\n\n        self.log.info('completed the ``authenticate`` method')\n        return None", "response": "authenticate a user against a Flickr account"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting useful image metadata for a given flickr image at a give Flcikr share URL", "response": "def get_photo_metadata(\n            self,\n            url):\n        \"\"\"*get useful image metadata for the image found at a give Flickr share URL*\n\n        **Key Arguments:**\n            - ``url`` -- the share URL for the flickr image (or just the unique photoid)\n\n        **Return:**\n            - ``images`` -- a dictionary of the various image sizes that can be accessed (key is the width in pixels and value is the direct image URL)\n            - ``title`` -- the title of the image as set by the user\n            - ``desc`` -- the description of the image as set by the user\n            - ``photoId`` -- the unique photoID of the image\n\n        **Usage:**\n\n            To get some associated metadata related to the image at a given Flcikr share URL run the `get_photo_metadata` method. Note the URL can be any of the various Flickr URL flavours.\n\n            .. code-block:: python\n\n                from picaxe import picaxe\n                flickr = picaxe(\n                    log=log,\n                    settings=settings\n                )\n                images, title, desc, photoId = flickr.get_photo_metadata(\n                    url=\"https://www.flickr.com/photos/92344046@N06/30455210056\")\n\n                images, title, desc, photoId= flickr.get_photo_metadata(\n                    url=\"https://www.flickr.com/gp/923440134@N06/0930a6\")\n\n                images, title, desc, photoId = flickr.get_photo_metadata(\n                    url=\"http://flic.kr/p/NpdUV5\")\n\n                images, title, desc, photoId = flickr.get_photo_metadata(\n                    url=30455210056)\n\n        \"\"\"\n        self.log.info('starting the ``get_photo_metadata`` method')\n\n        photoid = None\n        if \"flic\" not in url and \"/\" not in url:\n            photoid = url.strip()\n        elif \"flic.kr\" in url:\n            base58 = url.split(\"/\")[-1]\n            alphabet = '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'\n            base_count = len(alphabet)\n            photoid = 0\n            multi = 1\n            base58 = base58[::-1]\n            for char in base58:\n                photoid += multi * alphabet.index(char)\n                multi = multi * base_count\n        else:\n            regex = re.compile(\n                r'http(s)?\\:\\/\\/www\\.flickr\\.com/photos/[^/]*/(?P<photoid>\\d*)(/)?', re.S)\n            matchObject = regex.match(url)\n\n            if not matchObject:\n                response = requests.get(url)\n                matchObject = regex.match(response.url)\n                if not matchObject:\n                    if response.history:\n                        for resp in response.history:\n                            matchObject = regex.match(resp.url)\n                            if matchObject:\n                                break\n            if not matchObject:\n                self.log.error(\n                    'cound not get flickr photoid from the URL, can\\'t continue' % locals())\n            else:\n                photoid = matchObject.group(\"photoid\")\n\n        if not photoid:\n            return \"Could not get photoId\"\n\n        try:\n            response = requests.get(\n                url=\"https://api.flickr.com/services/rest/\",\n                params={\n                    \"method\": \"flickr.photos.getSizes\",\n                    \"photo_id\": photoid,\n                    \"format\": \"json\",\n                    \"nojsoncallback\": \"1\",\n                },\n                auth=self.auth,\n            )\n        except requests.exceptions.RequestException:\n            print('HTTP Request failed')\n\n        data = response.json()\n\n        images = {}\n        for image in data[\"sizes\"][\"size\"]:\n            images[image[\"width\"]] = image[\"source\"]\n            if image[\"label\"].lower() == \"original\":\n                images[\"original\"] = image[\"source\"]\n\n        try:\n            response = requests.get(\n                url=\"https://api.flickr.com/services/rest/\",\n                params={\n                    \"method\": \"flickr.photos.getInfo\",\n                    \"photo_id\": photoid,\n                    \"format\": \"json\",\n                    \"nojsoncallback\": \"1\",\n                },\n                auth=self.auth,\n            )\n        except requests.exceptions.RequestException:\n            print('HTTP Request failed')\n\n        data = response.json()\n        title = data[\"photo\"][\"title\"][\"_content\"]\n        desc = data[\"photo\"][\"description\"][\"_content\"]\n        photoId = data[\"photo\"][\"id\"]\n\n        self.log.info('completed the ``get_photo_metadata`` method')\n        return images, title, desc, photoId"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ngenerates a multi - markdown image link viewable anywhere at a given Flickr share URL and width.", "response": "def md(\n            self,\n            url,\n            width=\"original\"):\n        \"\"\"*generate a multimarkdown image link viewable anywhere (no sign-in needed for private photos)*\n\n        **Key Arguments:**\n            - ``url`` -- the share URL for the flickr image  (or just the unique photoid)\n            - ``width`` -- the pixel width of the fully resolved image. Default *original*. [75, 100, 150, 240, 320, 500, 640, 800, 1024, 1600, 2048]\n\n        **Return:**\n            - ``md`` -- the image reference link in multi-markdown syntax\n\n        **Usage:**\n\n            To return the markdown markup for an image at a given Flickr share URL:\n\n            .. code-block:: python\n\n                from picaxe import picaxe\n                Flickr = picaxe(\n                    log=log,\n                    settings=settings\n                )\n                mdLink = Flickr.md(\n                    url=\"https://www.flickr.com/photos/92344916@N06/30455211086\"\n                    width=1024\n                )\n        \"\"\"\n        self.log.info('starting the ``md_image`` method')\n\n        images, title, desc, photoId = self.get_photo_metadata(url)\n\n        if len(title) == 0:\n            tag = photoId\n        else:\n            tag = \"%(title)s %(photoId)s\" % locals()\n\n        image = images[str(width)]\n\n        if width == \"original\":\n            pxWidth = 1024\n        else:\n            pxWidth = width\n\n        md = \"\"\"![%(title)s][%(tag)s]\n\n[%(tag)s]: %(image)s title=\"%(title)s\" width=600px\n\"\"\" % locals()\n\n        self.log.info('completed the ``md_image`` method')\n        return md"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef upload(\n            self,\n            imagePath,\n            title=False,\n            private=True,\n            tags=False,\n            description=False,\n            imageType=\"photo\",\n            album=False,\n            openInBrowser=False):\n        \"\"\"*upload*\n\n        **Key Arguments:**\n            - ``imagePath`` -- path to the image to upload\n            - ``title`` -- title of the image. Default **False** to just use filename\n            - ``private`` -- is photo private?, Default **True**\n            - ``tags`` -- a comma separated string. Default **False**\n            - ``description`` -- the description for the image/photo. Default **False**\n            - ``imageType`` -- image type. Default **photo** [photo|screengrab|image]\n            - ``album`` -- add the photo to a specific album/photoset. If the album does not exist it will be created for you. Default *False*.\n            - ``openInBrowser`` -- view the photo in flickr webapp once uploaded *Default: False*\n\n        **Return:**\n            - ``photoid`` -- the unique flickr-assigned ID of the uploaded image\n\n        **Usage:**\n\n            To upload an image to flickr from your local file-system, use the following:\n\n            .. code-block:: python\n\n                from picaxe import picaxe\n                flickr = picaxe(\n                    log=log,\n                    settings=settings\n                )\n                photoid = flickr.upload(\n                    imagePath=\"/path/to/image.png\",\n                    title=\"my lovely image\",\n                    private=False,\n                    tags=\"lovely, icon\",\n                    description=\"this is a test image\",\n                    imageType=\"image\",\n                    album=\"my icons\",\n                    openInBrowser=True\n                )\n                print photoid\n\n            This will upload an image to the \"my icons\" album (creating the album if it doens't exist yet) and open the image in the flickr web-app whenever upload is complete. Note title, description, tags and album are optional.\n\n        \"\"\"\n        self.log.info('starting the ``upload`` method')\n\n        basename = os.path.basename(imagePath)\n        basename = os.path.splitext(basename)[0]\n\n        if title == False or title == None:\n            title = basename\n\n        if private == True:\n            is_public = 0\n        else:\n            is_public = 1\n\n        if imageType == \"image\":\n            content_type = 3\n        elif imageType == \"screengrab\":\n            content_type = 2\n        else:\n            content_type = 1\n\n        if tags is not False and tags != None:\n            tags = tags.replace(\",\", \" \").replace(\"  \", \" \")\n        else:\n            tags = \"\"\n\n        if description == False or description == None:\n            description = \"\"\n\n        files = {\n            'photo': (basename, open(imagePath))\n        }\n\n        params = {\n            \"title\": title,\n            \"description\": description,\n            \"tags\": tags,\n            \"is_public\": is_public,\n            \"content_type\": content_type,\n            \"format\": \"json\"\n        }\n\n        url = 'https://up.flickr.com/services/upload/'\n        raw = requests.Request('POST', url, data=params, auth=self.auth)\n        prepared = raw.prepare()\n        headers = {'Authorization': prepared.headers.get('Authorization')}\n\n        try:\n            response = requests.post(\n                url=url,\n                data=params,\n                headers=headers,\n                files=files\n            )\n        except requests.exceptions.RequestException:\n            print('HTTP Request failed')\n\n        matchObject = re.search(\n            r\"<photoid>(\\d*)</photoid>\", response.content, re.S)\n        photoid = matchObject.group(1)\n\n        photoURL = \"https://www.flickr.com/photos/\" + \\\n            self.settings[\"flickr\"][\"user_nsid\"] + \"/\" + photoid\n\n        if album:\n            self._add_photo_to_album(\n                photoId=photoid,\n                album=album\n            )\n\n        if openInBrowser:\n            ## open in webbrowser\n            import webbrowser\n            webbrowser.open_new_tab(photoURL)\n\n        self.log.info('completed the ``upload`` method')\n        return photoid", "response": "Uploads an image to flickr"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nlisting all of the albums in the Flickr account", "response": "def list_album_titles(\n            self):\n        \"\"\"*list all of the albums (photosets) in the Flickr account*\n\n        **Return:**\n            - ``albumList`` -- the list of album names\n\n        **Usage:**\n\n            .. code-block:: python \n\n                from picaxe import picaxe\n                flickr = picaxe(\n                    log=log,\n                    settings=settings\n                )\n                albumList = flickr.list_album_titles()\n\n            and, if you print the list of albums:\n\n            .. code-block:: text\n\n                [u'Auto Upload', u'home movies', u'projects: thespacedoctor', u'notes: images and screengrabs']\n        \"\"\"\n        self.log.info('starting the ``list_album_titles`` method')\n\n        albumList = []\n\n        try:\n            response = requests.get(\n                url=\"https://api.flickr.com/services/rest/\",\n                params={\n                    \"method\": \"flickr.photosets.getList\",\n                    \"format\": \"json\",\n                    \"nojsoncallback\": \"1\",\n                },\n                auth=self.auth,\n            )\n        except requests.exceptions.RequestException:\n            print('HTTP Request failed')\n\n        albumList = []\n        albumList[:] = [i[\"title\"][\"_content\"]\n                        for i in response.json()[\"photosets\"][\"photoset\"]]\n\n        self.log.info('completed the ``list_album_titles`` method')\n        return albumList"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _add_photo_to_album(\n            self,\n            photoId,\n            album):\n        \"\"\"*add a photo with the given photo ID to a named album*\n\n        **Key Arguments:**\n            - ``photoId`` -- the ID of the photo to add to the album\n            - ``album`` -- the name of the album to add the photo to\n\n        **Return:**\n            - None\n\n        **Usage:**\n            ..  todo::\n\n                - add usage info\n                - create a sublime snippet for usage\n                - update package tutorial if needed\n\n            .. code-block:: python \n\n                usage code \n\n        \"\"\"\n        self.log.info('starting the ``_add_photo_to_album`` method')\n\n        try:\n            response = requests.get(\n                url=\"https://api.flickr.com/services/rest/\",\n                params={\n                    \"method\": \"flickr.photosets.getList\",\n                    \"format\": \"json\",\n                    \"nojsoncallback\": \"1\",\n                },\n                auth=self.auth,\n            )\n        except requests.exceptions.RequestException:\n            print('HTTP Request failed')\n\n        albumId = False\n        for s in response.json()[\"photosets\"][\"photoset\"]:\n            if s[\"title\"][\"_content\"].lower().strip() == album.strip():\n                albumId = s[\"id\"]\n\n        if albumId:\n            try:\n                response = requests.post(\n                    url=\"https://api.flickr.com/services/rest/\",\n                    params={\n                        \"method\": \"flickr.photosets.addPhoto\",\n                        \"photoset_id\": albumId,\n                        \"photo_id\": photoId,\n                        \"format\": \"json\",\n                        \"nojsoncallback\": \"1\",\n                    },\n                    auth=self.auth,\n                )\n            except requests.exceptions.RequestException:\n                print('HTTP Request failed')\n\n        else:\n            try:\n                response = requests.post(\n                    url=\"https://api.flickr.com/services/rest/\",\n                    params={\n                        \"method\": \"flickr.photosets.create\",\n                        \"title\": album,\n                        \"primary_photo_id\": photoId,\n                        \"format\": \"json\",\n                        \"nojsoncallback\": \"1\",\n                    },\n                    auth=self.auth,\n                )\n            except requests.exceptions.RequestException:\n                print('HTTP Request failed')\n\n        self.log.info('completed the ``_add_photo_to_album`` method')\n        return None", "response": "add a photo to an album"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef section(request):\n    # If SECTIONS setting is not specified, don't do anything.\n    try:\n        sections = settings.SECTIONS\n    except AttributeError:\n        return {}\n\n    # Default return is first section.\n    section = sections[0]['name']\n\n    try:\n        pattern_name = resolve_to_name(request.path_info)\n    except Resolver404:\n        pattern_name = None\n\n    if pattern_name:\n        for option in settings.SECTIONS:\n            if pattern_name in option['matching_pattern_names']:\n                section = option['name']\n\n    return {'section': section}", "response": "Determines the current site section from resolved view pattern and adds it to context['section']"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _get_process_cwd(pid):\n\n    cmd = 'lsof -a -p {0} -d cwd -Fn'.format(pid)\n\n    data = common.shell_process(cmd)\n\n    if not data is None:\n        lines = str(data).split('\\n')\n\n        # the cwd is the second line with 'n' prefix removed from value\n        if len(lines) > 1:\n            return lines[1][1:] or None\n\n    return None", "response": "Returns the working directory for the provided process identifier."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ngenerate a md5 checksum of the file at the specified path.", "response": "def _get_checksum(path):\n    \"\"\" Generates a md5 checksum of the file at the specified path.\n\n        `path`\n            Path to file for checksum.\n\n        Returns string or ``None``\n        \"\"\"\n\n    # md5 uses a 512-bit digest blocks, let's scale by defined block_size\n    _md5 = hashlib.md5()\n    chunk_size = 128 * _md5.block_size\n\n    try:\n        with open(path, 'rb') as _file:\n            for chunk in iter(lambda: _file.read(chunk_size), ''):\n                _md5.update(chunk)\n        return _md5.hexdigest()\n\n    except IOError:\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _get_user_processes():\n\n    uid = os.getuid()\n\n    for proc in psutil.process_iter():\n        try:\n            # yield processes that match current user\n            if proc.uids.real == uid:\n                yield (proc, proc.exe)\n\n        except psutil.AccessDenied:\n            # work around for suid/sguid processes and MacOS X restrictions\n            try:\n                path = common.which(proc.name)\n\n                # psutil doesn't support MacOS X relative paths,\n                # let's use a workaround to merge working directory with\n                # process relative path\n                if not path and common.IS_MACOSX:\n                    cwd = _get_process_cwd(proc.pid)\n                    if not cwd:\n                        continue\n                    path = os.path.join(cwd, proc.cmdline[0])\n\n                yield (proc, path)\n\n            except (psutil.AccessDenied, OSError):\n                pass\n\n        except psutil.NoSuchProcess:\n            pass", "response": "Yields processes owned by the current user."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nstops processes matching paths AttributeNames specified.", "response": "def _stop_processes(paths):\n    \"\"\" Scans process list trying to terminate processes matching paths\n        specified. Uses checksums to identify processes that are duplicates of\n        those specified to terminate.\n\n        `paths`\n            List of full paths to executables for processes to terminate.\n        \"\"\"\n\n    def cache_checksum(path):\n        \"\"\" Checksum provided path, cache, and return value.\n            \"\"\"\n        if not path:\n            return None\n\n        if not path in _process_checksums:\n            checksum = _get_checksum(path)\n            _process_checksums[path] = checksum\n\n        return _process_checksums[path]\n\n    if not paths:\n        return\n\n    target_checksums = dict((cache_checksum(p), 1) for p in paths)\n    if not target_checksums:\n        return\n\n    for proc, path in _get_user_processes():\n        # path's checksum matches targets, attempt to terminate\n        if cache_checksum(path) in target_checksums:\n            try:\n                proc.terminate()\n\n            except (psutil.AccessDenied, psutil.NoSuchProcess):\n                pass"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _run_apps(self, paths):\n\n        for path in paths:\n            common.shell_process(path, background=True)\n            time.sleep(0.2)", "response": "Runs apps for the provided paths."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nparse option. and store them in self. paths.", "response": "def parse_option(self, option, block_name, *values):\n        \"\"\" Parse app path values for option.\n            \"\"\"\n        if option == 'run':\n            option = 'start_' + option\n\n        key = option.split('_', 1)[0]\n        self.paths[key] = set(common.extract_app_paths(values))"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nparsing option. and store the app paths in self. paths.", "response": "def parse_option(self, option, block_name, *values):\n        \"\"\" Parse app path values for option.\n            \"\"\"\n\n        # treat arguments as part of the program name (support spaces in name)\n        values = [x.replace(' ', '\\\\ ') if not x.startswith(os.sep) else x\n                  for x in [str(v) for v in values]]\n\n        if option == 'close':\n            option = 'start_' + option\n\n        key = option.split('_', 1)[0]\n        self.paths[key] = set(common.extract_app_paths(values))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nestimating Mean and Std. Dev of the Normal distribution.", "response": "def norm_mle(data, algorithm='Nelder-Mead', debug=False):\n    \"\"\"Estimate Mean and Std.Dev. of the Normal Distribution\n\n    Parameters:\n    -----------\n    data : list, tuple, ndarray\n        vector with samples, observations that are\n        assumed to follow a Normal distribution.\n\n    algorithm : str\n        Optional. Default 'Nelder-Mead' (Simplex).\n        The algorithm used in scipy.optimize.minimize\n\n    debug : bool\n        Optional.\n\n    Returns:\n    --------\n    mu : float\n        Mean, 1st moment, location parameter of the\n            Normal distribution.\n\n    sd : float\n        Standard Deviation, 2nd moment, scale parameter\n            of the Normal distribution\n\n    results : scipy.optimize.optimize.OptimizeResult\n        Optional. If debug=True then only scipy's\n        optimization result variable is returned.\n\n    \"\"\"\n    import scipy.stats as sstat\n    import scipy.optimize as sopt\n\n    def objective_nll_norm_uni(theta, data):\n        return -1.0 * sstat.norm.logpdf(\n            data, loc=theta[0], scale=theta[1]).sum()\n\n    # check eligible algorithm\n    if algorithm not in ('Nelder-Mead', 'CG', 'BFGS'):\n        raise Exception('Optimization Algorithm not supported.')\n\n    # set start values\n    theta0 = [1.0, 1.0]  # mu and sigma\n\n    # run solver\n    results = sopt.minimize(\n        objective_nll_norm_uni, theta0,\n        args=(data),\n        method=algorithm,\n        options={'disp': False})\n\n    # debug?\n    if debug:\n        return results\n\n    # done\n    return results.x[0], results.x[1]"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nqueries the database and returns that status of the item.", "response": "def get(self, status_item):\n        \"\"\" queries the database and returns that status of the item.\n\n        args:\n            status_item: the name of the item to check\n        \"\"\"\n        lg = logging.getLogger(\"%s.%s\" % (self.ln, inspect.stack()[0][3]))\n        lg.setLevel(self.log_level)\n\n        sparql = '''\n            SELECT ?loaded\n            WHERE {{\n                kdr:{0} kds:{1} ?loaded .\n            }}'''\n        value = self.conn.query(sparql=sparql.format(self.group, status_item))\n        if len(value) > 0 and \\\n                cbool(value[0].get('loaded',{}).get(\"value\",False)):\n            return True\n        else:\n            return False"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsetting the status item to the passed in paramaters", "response": "def set(self, status_item, status):\n        \"\"\" sets the status item to the passed in paramaters\n\n        args:\n            status_item: the name if the item to set\n            status: boolean value to set the item\n        \"\"\"\n        lg = logging.getLogger(\"%s.%s\" % (self.ln, inspect.stack()[0][3]))\n        lg.setLevel(self.log_level)\n        sparql = '''\n            DELETE {{\n                kdr:{0} kds:{1} ?o\n            }}\n            INSERT {{\n                kdr:{0} kds:{1} \"{2}\"^^xsd:boolean\n            }}\n            WHERE {{\n                OPTIONAL {{ kdr:{0} kds:{1} ?o }}\n            }}'''\n        return self.conn.query(sparql=sparql.format(self.group,\n                                                     status_item,\n                                                     str(status).lower()),\n                                mode='update')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nread the contents of a file.", "response": "def _read_file(name, encoding='utf-8'):\n    \"\"\"\n    Read the contents of a file.\n\n    :param name: The name of the file in the current directory.\n    :param encoding: The encoding of the file; defaults to utf-8.\n    :return: The contents of the file.\n    \"\"\"\n    with codecs.open(name, encoding=encoding) as f:\n        return f.read()"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef local_machine_uuid():\n\n    result = subprocess.check_output(\n        'hal-get-property --udi '\n        '/org/freedesktop/Hal/devices/computer '\n        '--key system.hardware.uuid'.split()\n        ).strip()\n\n    return uuid.UUID(hex=result)", "response": "Return local machine unique identifier."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef read(self, required=False):\n        self._pristine_cache = {}\n        self._cache = {}\n        try:\n            data, stat = yield self._client.get(self._path)\n            data = yaml.load(data)\n            if data:\n                self._pristine_cache = data\n                self._cache = data.copy()\n        except NoNodeException:\n            if required:\n                raise StateNotFound(self._path)", "response": "Read in the current Zookeeper state."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef write(self):\n        self._check()\n        cache = self._cache\n        pristine_cache = self._pristine_cache\n        self._pristine_cache = cache.copy()\n\n        # Used by `apply_changes` function to return the changes to\n        # this scope.\n        changes = []\n\n        def apply_changes(content, stat):\n            \"\"\"Apply the local state to the Zookeeper node state.\"\"\"\n            del changes[:]\n            current = yaml.load(content) if content else {}\n            missing = object()\n            for key in set(pristine_cache).union(cache):\n                old_value = pristine_cache.get(key, missing)\n                new_value = cache.get(key, missing)\n                if old_value != new_value:\n                    if new_value != missing:\n                        current[key] = new_value\n                        if old_value != missing:\n                            changes.append(\n                                ModifiedItem(key, old_value, new_value))\n                        else:\n                            changes.append(AddedItem(key, new_value))\n                    elif key in current:\n                        del current[key]\n                        changes.append(DeletedItem(key, old_value))\n            return yaml.safe_dump(current)\n\n        # Apply the change till it takes.\n        yield retry_change(self._client, self._path, apply_changes)\n        returnValue(changes)", "response": "Write the state of the object to Zookeeper."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef set_default_headers(context):\n    headers = row_table(context)\n\n    def default_headers_function():\n        return headers\n\n    requestsdefaulter.default_headers(default_headers_function)", "response": "Set the default headers for the current context."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef assert_headers(context):\n    expected_headers = [(k, v) for k, v in row_table(context).items()]\n    request = httpretty.last_request()\n    actual_headers = request.headers.items()\n\n    for expected_header in expected_headers:\n        assert_in(expected_header, actual_headers)", "response": "Assert that the headers of the context are the same as the ones in the context."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nmaking a request to the mock url with the headers", "response": "def make_request_with_headers(context):\n    \"\"\"\n       :type context: behave.runner.Context\n    \"\"\"\n    headers = row_table(context)\n    requests.get(context.mock_url, headers=headers)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting data from the data_en_intervalo method.", "response": "def __get_data_en_intervalo(self, d0=None, df=None):\n        \"\"\"\n        Obtiene los datos en bruto de la red realizando m\u00faltiples requests al tiempo\n        Procesa los datos en bruto obtenidos de la red convirtiendo a Pandas DataFrame\n        \"\"\"\n\n        params = {'date_fmt': self.DATE_FMT,\n                  'usar_multithread': self.USAR_MULTITHREAD, 'max_threads_requests': self.MAX_THREADS_REQUESTS,\n                  'timeout': self.TIMEOUT, 'num_retries': self.NUM_RETRIES,\n                  'func_procesa_data_dia': self.procesa_data_dia, 'func_url_data_dia': self.url_data_dia,\n                  'max_act_exec': self.MAX_ACT_EXEC,\n                  'data_extra_request': {'headers': self.HEADERS,\n                                         'json_req': self.JSON_REQUESTS,\n                                         'params_request': self.PARAMS_REQUESTS},\n                  'verbose': self.verbose}\n        data_get, hay_errores, str_import = get_data_en_intervalo(d0, df, **params)\n        if not hay_errores:\n            self.integridad_data(data_get)\n            self.printif(str_import, 'ok')\n            if type(data_get) is pd.DataFrame:\n                data_get = {self.masterkey: data_get}\n            return data_get\n        else:\n            return None"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning the last entry in the base de datos.", "response": "def last_entry(self, data_revisar=None, key_revisar=None):\n        \"\"\"\n        Obtiene el Timestamp del \u00faltimo valor de la base de datos seleecionada,\n        junto con el n\u00ba de entradas (filas) total de dicho paquete de datos.\n\n        :param data_revisar: (OPC) Se puede pasar un dataframe espec\u00edfico\n        :param key_revisar: (OPC) Normalmente, para utilizar 'dem'\n        :return: tmax, num_entradas\n        \"\"\"\n        key_revisar = key_revisar or self.masterkey\n        data_revisar = self.data if data_revisar is None else data_revisar\n        # return tmax, num_entradas\n        if key_revisar in data_revisar.keys():\n            data_rev = data_revisar[key_revisar]\n            return data_rev.index[-1].to_pydatetime(), len(data_rev)\n        else:\n            return pd.Timestamp(dt.datetime.strptime(self.DATE_INI, self.DATE_FMT), tz=self.TZ).to_pydatetime(), 0"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef printif(self, obj_print, tipo_print=None):\n        if self.verbose:\n            print(obj_print)\n        if tipo_print == 'ok':\n            logging.info(obj_print)\n        elif tipo_print == 'error':\n            logging.error(obj_print)\n        elif tipo_print == 'warning':\n            logging.warning(obj_print)", "response": "Color output & logging."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nupdating the data of the base de datos hdf en disco.", "response": "def update_data(self, forzar_update=False):\n        \"\"\"Check/Lectura de base de datos hdf en disco (local).\"\"\"\n        try:\n            if forzar_update:\n                self.printif('Se procede a actualizar TODOS los datos (force update ON)', 'info')\n                assert()\n            self.load_data()\n            tmax, num_entradas = self.last_entry()\n            if num_entradas > 0:\n                data_ant = self.data\n                self.printif('''* BASE DE DATOS LOCAL HDF:\\n\\tN\u00ba entradas:\\t%lu mediciones\\n\\t\u00daltima:     \\t%s'''\n                             % (num_entradas, tmax.strftime('%d-%m-%Y %H:%M')), 'info')\n            else:\n                data_ant = None\n        except Exception as e:\n            if not forzar_update:\n                self.printif('--> NO SE LEE DB_HDF (Exception: {}:{})'.format(type(e).__name__, str(e)), 'warning')\n                self.printif('--> Se procede a realizar la captura de TODOS los datos existentes:', 'warning')\n            data_ant, tmax = None, None\n        # Actualizaci\u00f3n de la base de datos\n        data_act, hay_nueva_info = self.__actualiza_datos(data_ant, tmax)\n        self.data = data_act\n        if hay_nueva_info:  # Grabaci\u00f3n de la base de datos hdf en disco (local)\n            # Posibilidad de procesar todos los datos al final del update, antes de grabar a disco:\n            self.post_update_data()\n            self.save_data()\n            tmax, num_entradas = self.last_entry()\n            self.printif('\\tN\u00ba rows:\\t{} samples\\n\\t\u00daltima:\\t{:%d-%m-%Y %H:%M}'.format(num_entradas, tmax), 'ok')\n        return hay_nueva_info"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef integridad_data(self, data_integr=None, key=None):\n        def _assert_integridad(df):\n            if df is not None and not df.empty:\n                assert(df.index.is_unique and df.index.is_monotonic_increasing and df.index.is_all_dates)\n\n        if data_integr is None:\n            data_integr = self.data\n        if type(data_integr) is dict:\n            if key is None:\n                keys = data_integr.keys()\n            else:\n                keys = [key]\n            [_assert_integridad(data_integr[k]) for k in keys]\n        else:\n            _assert_integridad(data_integr)", "response": "A helper method to check if data_integr is None or a key is provided"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef save_data(self, dataframe=None, key_data=None):\n\n        def _save_data_en_key(store, key_save, data_save, func_err):\n            try:\n                # TODO Revisar errores grabaci\u00f3n HDF5 mode table vs fixed:\n                # TypeError: unorderable types: NoneType() >= tuple() al grabar HDF5 como 'table'\n                # store.put(key_save, data_save, format='table', mode='w')\n                store.put(key_save, data_save, mode='w')\n            except TypeError as e:\n                func_err('ERROR SALVANDO INFO: {}\\nKEY: {}; DATA:\\n{}'.format(e, key_save, data_save), 'error')\n\n        self.integridad_data()\n        self.store.open()\n        if dataframe is None:\n            if key_data is None:\n                # Se elimina (backup) el fichero h5 anterior\n                self._backup_last_store()\n                for k in self.data.keys():\n                    _save_data_en_key(self.store, k, self.data[k], self.printif)\n            else:\n                _save_data_en_key(self.store, key_data, self.data[key_data], self.printif)\n        else:\n            _save_data_en_key(self.store, key_data or self.masterkey, dataframe, self.printif)\n        self.store.close()", "response": "Guarda en disco la informaci\u00f3n."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef load_data(self, key=None, **kwargs):\n        self.store.open()\n        if key:\n            return pd.read_hdf(self.PATH_DATABASE, key, **kwargs)\n        else:\n            data_load = dict()\n            for k in self.store.keys():\n                k = k.replace('/', '')\n                # **kwargs ej:= where=['index > 2009','index < 2010'],columns=['ordinal']\n                data_load[k] = pd.read_hdf(self.PATH_DATABASE, k, **kwargs)\n            self.data = data_load\n        self.store.close()\n        self.integridad_data()", "response": "Load data from the database."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef append_delta_index(self, ts_data=None, data_delta=None, key=KEY_DATA):\n        reasign = False\n        if data_delta is None:\n            if self.data is not None:\n                data_delta = self.data[key]\n            else:\n                self.printif('NO HAY DATOS PARA A\u00d1ADIR DELTA', 'error')\n                return None\n            reasign = True\n        data_delta['delta'] = data_delta.index.tz_convert('UTC')\n        if ts_data is not None:\n            data_delta['delta'] = (data_delta['delta'] - data_delta['delta'].shift(1)).fillna(ts_data)\n            data_delta['delta_T'] = data_delta['delta'].apply(lambda x: pd.Timedelta(x).seconds) / ts_data\n        else:\n            data_delta['delta'] = (data_delta['delta'] - data_delta['delta'].shift(1)).fillna(0)\n        if reasign:\n            self.data[key] = data_delta\n        else:\n            return data_delta", "response": "Append columns with \u2206T between rows to data."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create(mcs, name, dict=None, object_name=None):\n        if dict is None:\n            dict = {}\n        _repr = name + '()' if object_name is None else object_name\n\n        def __repr__(self=None):\n            return _repr\n        dict.setdefault('__repr__', __repr__)\n        return mcs(name, (object,), dict)", "response": "Create a new singleton class."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nusing this class as a decorator for Python 2 / 3 compatibility", "response": "def as_decorator(mcs, cls):\n        \"\"\"\n        Use :class:`Singleton` as a decorator for Python 2/3 compatibility::\n\n            @Singleton.as_decorator\n            class SingletonType(object):\n                def __repr__(self):\n                    return 'singleton'\n\n            singleton = SingletonType()\n\n        :param cls: Class to become a singleton\n        :type cls: type\n        :return: The new singleton\n        :rtype: Singleton\n        \"\"\"\n        return mcs(cls.__name__, cls.__bases__, cls.__dict__.copy())"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns list of available services", "response": "def list_services():\n    \"\"\" returns list of available services \"\"\"\n    for importer, modname, ispkg in pkgutil.iter_modules(services.__path__):\n        if ispkg is False:\n            importer.find_module(modname).load_module(modname)\n\n    services_list = list()\n    for s in services.serviceBase.__subclasses__():\n        services_list.append(s.__name__.lower())\n\n    return services_list"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets the dynamic settings for a single base project based on the settings module s settings dict.", "response": "def set_dynamic_settings(s):\n    \"\"\"\n    Called at the end of the project's settings module, and is passed\n    its globals dict for updating with some final tweaks for settings\n    that generally aren't specified, but can be given some better\n    defaults based on other settings that have been specified. Broken\n    out into its own function so that the code need not be replicated\n    in the settings modules of other project-based apps that leverage\n    yacms's settings module.\n    \"\"\"\n\n    # Moves an existing list setting value to a different position.\n    move = lambda n, k, i: s[n].insert(i, s[n].pop(s[n].index(k)))\n    # Add a value to the end of a list setting if not in the list.\n    append = lambda n, k: s[n].append(k) if k not in s[n] else None\n    # Add a value to the start of a list setting if not in the list.\n    prepend = lambda n, k: s[n].insert(0, k) if k not in s[n] else None\n    # Remove a value from a list setting if in the list.\n    remove = lambda n, k: s[n].remove(k) if k in s[n] else None\n\n    # Django 1.10 middleware compatibility\n    MIDDLEWARE_SETTING_NAME = 'MIDDLEWARE' if 'MIDDLEWARE' in s \\\n                            and s['MIDDLEWARE'] is not None \\\n                            else 'MIDDLEWARE_CLASSES'\n\n    if not s.get(\"ALLOWED_HOSTS\", []):\n        warn(\"You haven't defined the ALLOWED_HOSTS settings, which \"\n             \"Django requires. Will fall back to the domains \"\n             \"configured as sites.\")\n        s[\"ALLOWED_HOSTS\"] = SitesAllowedHosts()\n\n    if s.get(\"TIME_ZONE\", None) is None:\n        tz = get_best_local_timezone()\n        s[\"TIME_ZONE\"] = tz\n        warn(\"TIME_ZONE setting is not set, using closest match: %s\" % tz)\n\n    # Define some settings based on management command being run.\n    management_command = sys.argv[1] if len(sys.argv) > 1 else \"\"\n    # Some kind of testing is running via test or testserver.\n    s[\"TESTING\"] = management_command in (\"test\", \"testserver\")\n    # Some kind of development server is running via runserver,\n    # runserver_plus or harvest (lettuce)\n    s[\"DEV_SERVER\"] = management_command.startswith((\"runserver\", \"harvest\"))\n\n    # Change tuple settings to lists for easier manipulation.\n    s.setdefault(\"AUTHENTICATION_BACKENDS\", defaults.AUTHENTICATION_BACKENDS)\n    s.setdefault(\"STATICFILES_FINDERS\", defaults.STATICFILES_FINDERS)\n    tuple_list_settings = [\"AUTHENTICATION_BACKENDS\", \"INSTALLED_APPS\",\n                           MIDDLEWARE_SETTING_NAME, \"STATICFILES_FINDERS\",\n                           \"LANGUAGES\", \"TEMPLATE_CONTEXT_PROCESSORS\"]\n    for setting in tuple_list_settings[:]:\n        if not isinstance(s.get(setting, []), list):\n            s[setting] = list(s[setting])\n        else:\n            # Setting is already a list, so we'll exclude it from\n            # the list of settings we'll revert back to tuples.\n            tuple_list_settings.remove(setting)\n\n    # Set up cookie messaging if none defined.\n    storage = \"django.contrib.messages.storage.cookie.CookieStorage\"\n    s.setdefault(\"MESSAGE_STORAGE\", storage)\n\n    # If required, add django-modeltranslation for both tests and deployment\n    if not s.get(\"USE_MODELTRANSLATION\", False) or s[\"TESTING\"]:\n        s[\"USE_MODELTRANSLATION\"] = False\n        remove(\"INSTALLED_APPS\", \"modeltranslation\")\n    else:\n        try:\n            __import__(\"modeltranslation\")\n        except ImportError:\n            # django-modeltranslation is not installed, remove setting so\n            # admin won't try to import it\n            s[\"USE_MODELTRANSLATION\"] = False\n            remove(\"INSTALLED_APPS\", \"modeltranslation\")\n            warn(\"USE_MODETRANSLATION setting is set to True but django-\"\n                    \"modeltranslation is not installed. Disabling it.\")\n        else:\n            # Force i18n so we are assured that modeltranslation is active\n            s[\"USE_I18N\"] = True\n            append(\"INSTALLED_APPS\", \"modeltranslation\")\n\n    # Setup for optional apps.\n    optional = list(s.get(\"OPTIONAL_APPS\", []))\n    for app in optional:\n        if app not in s[\"INSTALLED_APPS\"]:\n            try:\n                __import__(app)\n            except ImportError:\n                pass\n            else:\n                s[\"INSTALLED_APPS\"].append(app)\n\n    if s[\"TESTING\"]:\n        # Triggers interactive superuser creation and some pyc/pyo tests\n        # fail with standard permissions.\n        remove(\"INSTALLED_APPS\", \"django_extensions\")\n\n    if \"debug_toolbar\" in s[\"INSTALLED_APPS\"]:\n        # We need to configure debug_toolbar manually otherwise it\n        # breaks in conjunction with modeltranslation. See the\n        # \"Explicit setup\" section in debug_toolbar docs for more info.\n        s[\"DEBUG_TOOLBAR_PATCH_SETTINGS\"] = False\n        debug_mw = \"debug_toolbar.middleware.DebugToolbarMiddleware\"\n        append(MIDDLEWARE_SETTING_NAME, debug_mw)\n        s.setdefault(\"INTERNAL_IPS\", (\"127.0.0.1\",))\n\n    # If compressor installed, ensure it's configured and make\n    # yacms's settings available to its offline context,\n    # since jQuery is configured via a setting.\n    if \"compressor\" in s[\"INSTALLED_APPS\"]:\n        append(\"STATICFILES_FINDERS\", \"compressor.finders.CompressorFinder\")\n        s.setdefault(\"COMPRESS_OFFLINE_CONTEXT\", {\n            \"MEDIA_URL\": s.get(\"MEDIA_URL\", \"\"),\n            \"STATIC_URL\": s.get(\"STATIC_URL\", \"\"),\n        })\n\n        def yacms_settings():\n            from yacms.conf import settings\n            return settings\n        s[\"COMPRESS_OFFLINE_CONTEXT\"][\"settings\"] = yacms_settings\n\n    # Ensure the yacms auth backend is enabled if\n    # yacms.accounts is being used.\n    if \"yacms.accounts\" in s[\"INSTALLED_APPS\"]:\n        auth_backend = \"yacms.core.auth_backends.YaCmsBackend\"\n        s.setdefault(\"AUTHENTICATION_BACKENDS\", [])\n        prepend(\"AUTHENTICATION_BACKENDS\", auth_backend)\n\n    # Ensure Grappelli is after yacms in app order so that\n    # admin templates are loaded in the correct order.\n    grappelli_name = s.get(\"PACKAGE_NAME_GRAPPELLI\")\n    try:\n        move(\"INSTALLED_APPS\", grappelli_name, len(s[\"INSTALLED_APPS\"]))\n    except ValueError:\n        s[\"GRAPPELLI_INSTALLED\"] = False\n    else:\n        s[\"GRAPPELLI_INSTALLED\"] = True\n\n    # Ensure admin is at the bottom of the app order so that admin\n    # templates are loaded in the correct order, and that staticfiles\n    # is also at the end so its runserver can be overridden.\n    for app in [\"django.contrib.admin\", \"django.contrib.staticfiles\"]:\n        try:\n            move(\"INSTALLED_APPS\", app, len(s[\"INSTALLED_APPS\"]))\n        except ValueError:\n            pass\n\n    # Add missing apps if existing apps depend on them.\n    if \"yacms.blog\" in s[\"INSTALLED_APPS\"]:\n        append(\"INSTALLED_APPS\", \"yacms.generic\")\n    if \"yacms.generic\" in s[\"INSTALLED_APPS\"]:\n        s.setdefault(\"COMMENTS_APP\", \"yacms.generic\")\n        append(\"INSTALLED_APPS\", \"django_comments\")\n\n    # Ensure yacms.boot is first.\n    try:\n        move(\"INSTALLED_APPS\", \"yacms.boot\", 0)\n    except ValueError:\n        pass\n\n    # Remove caching middleware if no backend defined.\n    if not (s.get(\"CACHE_BACKEND\") or s.get(\"CACHES\")):\n        s[MIDDLEWARE_SETTING_NAME] = [mw for mw in s[MIDDLEWARE_SETTING_NAME]\n                                   if not\n                                   (mw.endswith(\"UpdateCacheMiddleware\") or\n                                    mw.endswith(\"FetchFromCacheMiddleware\"))]\n\n    # If only LANGUAGE_CODE has been defined, ensure the other required\n    # settings for translations are configured.\n    if (s.get(\"LANGUAGE_CODE\") and len(s.get(\"LANGUAGES\", [])) == 1 and\n            s[\"LANGUAGE_CODE\"] != s[\"LANGUAGES\"][0][0]):\n        s[\"USE_I18N\"] = True\n        s[\"LANGUAGES\"] = [(s[\"LANGUAGE_CODE\"], \"\")]\n\n    # Ensure required middleware is installed, otherwise admin\n    # becomes inaccessible.\n    mw = \"django.middleware.locale.LocaleMiddleware\"\n    if s[\"USE_I18N\"] and mw not in s[MIDDLEWARE_SETTING_NAME]:\n        session = s[MIDDLEWARE_SETTING_NAME].index(\n            \"django.contrib.sessions.middleware.SessionMiddleware\")\n        s[MIDDLEWARE_SETTING_NAME].insert(session + 1, mw)\n\n    # Revert tuple settings back to tuples.\n    for setting in tuple_list_settings:\n        s[setting] = tuple(s[setting])\n\n    # Some settings tweaks for different DB engines.\n    for (key, db) in s[\"DATABASES\"].items():\n        shortname = db[\"ENGINE\"].split(\".\")[-1]\n        if shortname == \"sqlite3\":\n            # If the Sqlite DB name doesn't contain a path, assume\n            # it's in the project directory and add the path to it.\n            if \"NAME\" in db and os.sep not in db[\"NAME\"]:\n                db_path = os.path.join(s.get(\"PROJECT_ROOT\", \"\"), db[\"NAME\"])\n                db[\"NAME\"] = db_path\n        elif shortname == \"mysql\":\n            # Required MySQL collation for tests.\n            db.setdefault(\"TEST\", {})[\"COLLATION\"] = \"utf8_general_ci\""}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef create_model_class(cls, name, table_name, attrs, validations=None, *, otherattrs=None,\n                         other_bases=None):\n    \"\"\"Creates a new class derived from ModelBase.\"\"\"\n    members = dict(table_name=table_name, attrs=attrs, validations=validations or [])\n    if otherattrs:\n      members.update(otherattrs)\n    return type(name, other_bases or (), members)", "response": "Creates a new class derived from ModelBase."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef has_attr(cls, attr_name):\n    if attr_name in cls.attrs:\n      return True\n\n    if isinstance(cls.primary_key_name, str) and cls.primary_key_name == attr_name:\n      return True\n\n    if isinstance(cls.primary_key_name, tuple) and attr_name in cls.primary_key_name:\n      return True\n\n    if cls.timestamps is not None and attr_name in cls.timestamps:\n      return True\n\n    return False", "response": "Check to see if an attribute is defined for the model."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef primary_key(self):\n    pkname = self.primary_key_name\n    if pkname is None:\n      return None\n    elif isinstance(pkname, str):\n      return getattr(self, pkname)\n    else:\n      return tuple((getattr(self, pkn) for pkn in pkname))", "response": "Returns either the primary key value or a tuple containing the primary key values in the\n    case of a composite primary key."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef validate(self, data_access=None):\n    self.clear_errors()\n    self.before_validation()\n    self.validator.validate(self, data_access)\n    return not self.has_errors", "response": "Run the class validations against the instance."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nadd an error for the given property.", "response": "def add_error(self, property_name, message):\n    \"\"\"Add an error for the given property.\"\"\"\n    if property_name not in self.errors:\n      self.errors[property_name] = []\n    self.errors[property_name].append(message)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef all_errors(self, joiner=\"; \"):\n    parts = []\n    for pname, errs in self.errors.items():\n      for err in errs:\n        parts.append(\"{0}: {1}\".format(pname, err))\n    return joiner.join(parts)", "response": "Returns a string representation of all errors recorded for the instance."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nconverting the class to a dictionary.", "response": "def to_dict(self, *, include_keys=None, exclude_keys=None, use_default_excludes=True):\n    \"\"\"Converts the class to a dictionary.\n\n    :include_keys: if not None, only the attrs given will be included.\n    :exclude_keys: if not None, all attrs except those listed will be included, with respect to\n    use_default_excludes.\n    :use_default_excludes: if True, then the class-level exclude_keys_serialize will be combined\n    with exclude_keys if given, or used in place of exlcude_keys if not given.\n    \"\"\"\n    data = self.__dict__\n\n    if include_keys:\n      return pick(data, include_keys, transform=self._other_to_dict)\n    else:\n      skeys = self.exclude_keys_serialize if use_default_excludes else None\n      ekeys = exclude_keys\n\n      return exclude(\n        data,\n        lambda k: (skeys is not None and k in skeys) or (ekeys is not None and k in ekeys),\n        transform=self._other_to_dict)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef to_json(self, *, include_keys=None, exclude_keys=None, use_default_excludes=True,\n              pretty=False):\n    \"\"\"Converts the response from to_dict to a JSON string. If pretty is True then newlines,\n    indentation and key sorting are used.\n    \"\"\"\n    return to_json(\n      self.to_dict(\n        include_keys=include_keys,\n        exclude_keys=exclude_keys,\n        use_default_excludes=use_default_excludes),\n      pretty=pretty)", "response": "Converts the response from to_dict to a JSON string."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef update(self, data_=None, **kwargs):\n    if data_ is None:\n      data_ = dict()\n    else:\n      data_ = dict(data_)\n    data_.update(**kwargs)\n    changes = set()\n    for attr_name in data_:\n      if hasattr(self, attr_name):\n        if getattr(self, attr_name) != data_[attr_name]:\n          changes.add(attr_name)\n          setattr(self, attr_name, data_[attr_name])\n      else:\n        if self.strict_attrs:\n          raise Exception(\"Unknown attribute for {}: {}\".format(self.__class__.__name__, attr_name))\n    return changes", "response": "Update the object with the given data object and with any other key - value args. Returns a set containing all the property names that were changed."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _initialize_attributes(self, data):\n    attrs = dict(self.attrs)\n\n    if self.primary_key_name is None:\n      pass\n    elif isinstance(self.primary_key_name, str):\n      if self.primary_key_name not in attrs:\n        attrs[self.primary_key_name] = None\n    else:\n      for pkey in self.primary_key_name:\n        if pkey not in attrs:\n          attrs[pkey] = None\n\n    if self.timestamps:\n      for ts_name in self.timestamps:\n        if ts_name is not None and ts_name not in attrs:\n          attrs[ts_name] = None\n\n    for attr_name in attrs:\n      setattr(self, attr_name, get_value(data, attr_name, attrs[attr_name]))", "response": "Initializes the class with the given data. Used by __init__."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _other_to_dict(self, other):\n    if isinstance(other, ModelBase):\n      return other.to_dict()\n    elif isinstance(other, list):\n      # TODO: what if it's not a list?\n      return [self._other_to_dict(i) for i in other]\n    else:\n      return other", "response": "When serializing models this allows attached models to also be\n    serialized."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncall proper method depending on command - line arguments.", "response": "def dispatch(self, args):\n        \"\"\"\n        Calls proper method depending on command-line arguments.\n        \"\"\"\n        if not args.list and not args.group:\n            if not args.font and not args.char and not args.block:\n                self.info()\n                return\n            else:\n                args.list = args.group = True\n        self._display = {k: args.__dict__[k] for k in ('list', 'group', 'omit_summary')}\n        if args.char:\n            char = self._getChar(args.char)\n            if args.font:\n                self.fontChar(args.font, char)\n            else:\n                self.char(char)\n        else:\n            block = self._getBlock(args.block)\n            self.chars(args.font, block)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nanalyse characters in a single font or all fonts.", "response": "def chars(self, font, block):\n        \"\"\"\n        Analyses characters in single font or all fonts.\n        \"\"\"\n        if font:\n            font_files = self._getFont(font)\n        else:\n            font_files = fc.query()\n        code_points = self._getFontChars(font_files)\n\n        if not block:\n            blocks = all_blocks\n            ranges_column = map(itemgetter(3), blocks)\n            overlapped = Ranges(code_points).getOverlappedList(ranges_column)\n        else:\n            blocks = [block]\n            overlapped = [Ranges(code_points).getOverlapped(block[3])]\n\n        if self._display['group']:\n            char_count = block_count = 0\n            for i, block in enumerate(blocks):\n                o_count = len(overlapped[i])\n                if o_count:\n                    block_count += 1\n                    char_count += o_count\n                    total = sum(len(r) for r in block[3])\n                    percent = 0 if total == 0 else o_count / total\n                    print(\"{0:>6}  {1:47} {2:>4.0%} ({3}/{4})\".format(block[0], block[2], percent, o_count, total))\n                    if self._display['list']:\n                        for point in overlapped[i]:\n                            self._charInfo(point, padding=9)\n            self._charSummary(char_count, block_count)\n        else:\n            for point in code_points:\n                self._charInfo(point, padding=7)\n            self._charSummary(len(code_points))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nshow all system fonts that contain given character.", "response": "def char(self, char):\n        \"\"\"\n        Shows all system fonts that contain given character.\n        \"\"\"\n        font_files = fc.query()\n        if self._display['group']:\n            font_files = self._getCharFont(font_files, char)\n            font_families = self._groupFontByFamily(font_files)\n            for font_family in sorted(font_families):\n                print(font_family)\n                if self._display['list']:\n                    for font_file in font_families[font_family]:\n                        print('  '+font_file)\n            self._fontSummary(len(font_files), len(font_families))\n        else:\n            font_files = self._getCharFont(font_files, char)\n            for font_file in sorted(font_files):\n                print(font_file)\n            self._fontSummary(len(font_files))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncheck if characters occurs in the given font.", "response": "def fontChar(self, font, char):\n        \"\"\"\n        Checks if characters occurs in the given font.\n        \"\"\"\n        font_files = self._getCharFont(self._getFont(font), char)\n        print('The character is {0}present in this font.'.format('' if font_files else 'not '))"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ndisplay the character summary.", "response": "def _charSummary(self, char_count, block_count=None):\n        \"\"\"\n        Displays characters summary.\n        \"\"\"\n        if not self._display['omit_summary']:\n            if block_count is None:\n                print('Total code points:', char_count)\n            else:\n                print('Total {0} code point{1} in {2} block{3}'.format(\n                    char_count,\n                    's' if char_count != 1 else '',\n                    block_count,\n                    's' if block_count != 1 else ''\n                ))"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _getChar(self, char_spec):\n        if len(char_spec) >= 4 and all(c in string.hexdigits for c in char_spec):\n            char_number = int(char_spec, 16)\n            if char_number not in range(0x110000):\n                raise ValueError('No such character')\n            return chr(char_number)\n        elif len(char_spec) == 1:\n            return char_spec\n        else:\n            raise ValueError('No such character')", "response": "Returns a character from given code point or character."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns block info from given block start code point or block name.", "response": "def _getBlock(self, block_spec):\n        \"\"\"\n        Returns block info from given block start code point or block name.\n        \"\"\"\n        if block_spec is None:\n            return\n        if all(c in string.hexdigits for c in block_spec):\n            block_spec = block_spec.upper()\n            ix = 0\n        else:\n            ix = 2\n        for block in all_blocks:\n            if block[ix] == block_spec:\n                return block\n        raise ValueError('No such block')"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nreturn font paths from font name or path", "response": "def _getFont(self, font):\n        \"\"\"\n        Returns font paths from font name or path\n        \"\"\"\n        if os.path.isfile(font):\n            font_files = [font]\n        else:\n            font_files = fc.query(family=font)\n            if not font_files:\n                raise ValueError('No such font')\n        return font_files"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a list of code points of characters included in given font files.", "response": "def _getFontChars(self, font_files):\n        \"\"\"\n        Returns code points of characters included in given font files.\n        \"\"\"\n        code_points = set()\n        for font_file in font_files:\n            face = ft.Face(font_file)\n            charcode, agindex = face.get_first_char()\n            while agindex != 0:\n                code_points.add(charcode)\n                charcode, agindex = face.get_next_char(charcode, agindex)\n        return sorted(code_points)"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreturns font files containing given code point.", "response": "def _getCharFont(self, font_files, code_point):\n        \"\"\"\n        Returns font files containing given code point.\n        \"\"\"\n        return_font_files = []\n        for font_file in font_files:\n            face = ft.Face(font_file)\n            if face.get_char_index(code_point):\n                return_font_files.append(font_file)\n        return return_font_files"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _groupFontByFamily(self, font_files):\n        font_families = defaultdict(list)\n        for font_file in font_files:\n            font = fc.FcFont(font_file)\n            font_families[font.family[0][1]].append(font_file)\n        return font_families", "response": "Groups font files by font family."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_from_instance(self, instance):\n        # walk the attribute path to get the value. Similarly to Django, first\n        # try getting the value from a dict, then as a attribute lookup, and\n        # then as a list index\n        for attr in self._path:\n            try: # dict lookup\n                instance = instance[attr]\n            except (TypeError, AttributeError, KeyError, ValueError, IndexError):\n                try: # attr lookup\n                    instance = getattr(instance, attr)\n                except (TypeError, AttributeError):\n                    try:  # list-index lookup\n                        instance = instance[int(attr)]\n                    except (IndexError,  # list index out of range\n                            ValueError,  # invalid literal for int()\n                            KeyError,    # current is a dict without `int(bit)` key\n                            TypeError):  # unsubscriptable object\n                                raise VariableLookupError(\"Failed lookup for key [%s] in %r\" % (attr, instance))\n\n            if callable(instance):\n                instance = instance()\n            elif instance is None:  # no sense walking down the path any further\n                return None\n\n        return instance", "response": "Given an object to index with ES return the value that should be put\n        into ES for this field."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\niterates through a list of queries and runs them through the connection", "response": "def run_query_series(queries, conn):\n    \"\"\"\n    Iterates through a list of queries and runs them through the connection\n\n    Args:\n    -----\n        queries: list of strings or tuples containing (query_string, kwargs)\n        conn: the triplestore connection to use\n    \"\"\"\n    results = []\n    for item in queries:\n        qry = item\n        kwargs = {}\n        if isinstance(item, tuple):\n            qry = item[0]\n            kwargs = item[1]\n        result = conn.update_query(qry, **kwargs)\n        # pdb.set_trace()\n        results.append(result)\n    return results"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_all_item_data(items, conn, graph=None, output='json', **kwargs):\n    # set the jinja2 template to use\n    if kwargs.get('template'):\n        template = kwargs.pop('template')\n    else:\n        template = \"sparqlAllItemDataTemplate.rq\"\n    # build the keyword arguments for the templace\n    template_kwargs = {\"prefix\": NSM.prefix(), \"output\": output}\n    if isinstance(items, list):\n        template_kwargs['uri_list'] = items\n    else:\n        template_kwargs['item_uri'] = Uri(items).sparql\n    if kwargs.get(\"special_union\"):\n        template_kwargs['special_union'] = kwargs.get(\"special_union\")\n    if kwargs.get('rdfclass'):\n        # pdb.set_trace()\n        template_kwargs.update(kwargs['rdfclass'].query_kwargs)\n    if kwargs.get(\"filters\"):\n        template_kwargs['filters'] = make_sparql_filter(kwargs.get('filters'))\n    sparql = render_without_request(template, **template_kwargs)\n    return conn.query(sparql, **kwargs)", "response": "queries a triplestore with the provided template or uses a generic template that returns triples 3 edges out in either direction from the item_uri tuple"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_graph(graph, conn, **kwargs):\n    sparql = render_without_request(\"sparqlGraphDataTemplate.rq\",\n                                    prefix=NSM.prefix(),\n                                    graph=graph)\n    return conn.query(sparql, **kwargs)", "response": "Returns all the triples for a specific resource in the rdfframework triplestore"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef make_sparql_filter(filters):\n    def make_filter_str(variable, operator, union_type, values):\n        \"\"\" generates a filter string for a sparql query\n\n        args:\n            variable: the variable to reference\n            operator: '=' or '!='\n            union_type\" '&&' or '||'\n            values: list of values to apply the filter\n        \"\"\"\n        formated_vals = UniqueList()\n        for val in values:\n            try:\n                formated_vals.append(val.sparql)\n            except AttributeError:\n                formated_vals.append(val)\n        pre_str = \"?%s%s\" % (variable.replace(\"?\", \"\"), operator)\n        union = \"%s\\n\\t\\t\" % union_type\n        return \"\\tFilter( %s) .\\n\" % union.join([pre_str + val\n                                                      for val in formated_vals])\n\n    if not filters:\n        return \"\"\n    rtn_str = \"\"\n    for param in filters:\n        rtn_str += make_filter_str(**param)\n    return rtn_str", "response": "Make the filter section for a query template"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef add_sparql_line_nums(sparql):\n    lines = sparql.split(\"\\n\")\n    return \"\\n\".join([\"%s %s\" % (i + 1, line) for i, line in enumerate(lines)])", "response": "Returns a sparql query with line numbers prepended"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ncomputes the string - value of a node.", "response": "def string_value(node):\n    \"\"\"Compute the string-value of a node.\"\"\"\n    if (node.nodeType == node.DOCUMENT_NODE or\n        node.nodeType == node.ELEMENT_NODE):\n        s = u''\n        for n in axes['descendant'](node):\n            if n.nodeType == n.TEXT_NODE:\n                s += n.data\n        return s\n\n    elif node.nodeType == node.ATTRIBUTE_NODE:\n        return node.value\n\n    elif (node.nodeType == node.PROCESSING_INSTRUCTION_NODE or\n          node.nodeType == node.COMMENT_NODE or\n          node.nodeType == node.TEXT_NODE):\n        return node.data"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef document_order(node):\n\n    # Attributes: parent-order + [-1, attribute-name]\n    if node.nodeType == node.ATTRIBUTE_NODE:\n        order = document_order(node.ownerElement)\n        order.extend((-1, node.name))\n        return order\n\n    # The document root (hopefully): []\n    if node.parentNode is None:\n        return []\n\n    # Determine which child this is of its parent.\n    sibpos = 0\n    sib = node\n    while sib.previousSibling is not None:\n        sibpos += 1\n        sib = sib.previousSibling\n\n    # Order: parent-order + [sibling-position]\n    order = document_order(node.parentNode)\n    order.append(sibpos)\n    return order", "response": "Compute a document order value for the given node."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nconverting a value to a string.", "response": "def string(v):\n    \"\"\"Convert a value to a string.\"\"\"\n    if nodesetp(v):\n        if not v:\n            return u''\n        return string_value(v[0])\n    elif numberp(v):\n        if v == float('inf'):\n            return u'Infinity'\n        elif v == float('-inf'):\n            return u'-Infinity'\n        elif str(v) == 'nan':\n            return u'NaN'\n        elif int(v) == v and v <= 0xffffffff:\n            v = int(v)\n        return unicode(v)\n    elif booleanp(v):\n        return u'true' if v else u'false'\n    return v"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconvert a value to a boolean.", "response": "def boolean(v):\n    \"\"\"Convert a value to a boolean.\"\"\"\n    if nodesetp(v):\n        return len(v) > 0\n    elif numberp(v):\n        if v == 0 or v != v:\n            return False\n        return True\n    elif stringp(v):\n        return v != ''\n    return v"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef number(v):\n    if nodesetp(v):\n        v = string(v)\n    try:\n        return float(v)\n    except ValueError:\n        return float('NaN')", "response": "Convert a value to a number."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef numberp(v):\n    return (not(isinstance(v, bool)) and\n            (isinstance(v, int) or isinstance(v, float)))", "response": "Return true iff v is a number."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef axisfn(reverse=False, principal_node_type=xml.dom.Node.ELEMENT_NODE):\n    def decorate(f):\n        f.__name__ = f.__name__.replace('_', '-')\n        f.reverse = reverse\n        f.principal_node_type = principal_node_type\n        return f\n    return decorate", "response": "A function decorator that returns a sequence of functions that can be used to generate the sequence of nodes along an XPath axis."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef make_axes():\n\n    @axisfn()\n    def child(node):\n        return node.childNodes\n\n    @axisfn()\n    def descendant(node):\n        for child in node.childNodes:\n            for node in descendant_or_self(child):\n                yield node\n\n    @axisfn()\n    def parent(node):\n        if node.parentNode is not None:\n            yield node.parentNode\n\n    @axisfn(reverse=True)\n    def ancestor(node):\n        while node.parentNode is not None:\n            node = node.parentNode\n            yield node\n\n    @axisfn()\n    def following_sibling(node):\n        while node.nextSibling is not None:\n            node = node.nextSibling\n            yield node\n\n    @axisfn(reverse=True)\n    def preceding_sibling(node):\n        while node.previousSibling is not None:\n            node = node.previousSibling\n            yield node\n\n    @axisfn()\n    def following(node):\n        while node is not None:\n            while node.nextSibling is not None:\n                node = node.nextSibling\n                for n in descendant_or_self(node):\n                    yield n\n            node = node.parentNode\n\n    @axisfn(reverse=True)\n    def preceding(node):\n        while node is not None:\n            while node.previousSibling is not None:\n                node = node.previousSibling\n                # Could be more efficient here.\n                for n in reversed(list(descendant_or_self(node))):\n                    yield n\n            node = node.parentNode\n\n    @axisfn(principal_node_type=xml.dom.Node.ATTRIBUTE_NODE)\n    def attribute(node):\n        if node.attributes is not None:\n            return (node.attributes.item(i)\n                    for i in xrange(node.attributes.length))\n        return ()\n\n    @axisfn()\n    def namespace(node):\n        raise XPathNotImplementedError(\"namespace axis is not implemented\")\n\n    @axisfn()\n    def self(node):\n        yield node\n\n    @axisfn()\n    def descendant_or_self(node):\n        yield node\n        for child in node.childNodes:\n            for node in descendant_or_self(child):\n                yield node\n\n    @axisfn(reverse=True)\n    def ancestor_or_self(node):\n        return chain([node], ancestor(node))\n\n    # Place each axis function defined here into the 'axes' dict.\n    for axis in locals().values():\n        axes[axis.__name__] = axis", "response": "Define functions to walk each of the possible XPath axes."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef merge_into_nodeset(target, source):\n    if len(target) == 0:\n        target.extend(source)\n        return\n\n    source = [n for n in source if n not in target]\n    if len(source) == 0:\n        return\n\n    # If the last node in the target set comes before the first node in the\n    # source set, then we can just concatenate the sets.  Otherwise, we\n    # will need to sort.  (We could also check to see if the last node in\n    # the source set comes before the first node in the target set, but this\n    # situation is very unlikely in practice.)\n    if document_order(target[-1]) < document_order(source[0]):\n        target.extend(source)\n    else:\n        target.extend(source)\n        target.sort(key=document_order)", "response": "Place all the nodes from the source node - set into the target node - set preserving document order."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nfunction decorator that returns a function that accepts minargs and maxargs.", "response": "def function(minargs, maxargs, implicit=False, first=False, convert=None):\n        \"\"\"Function decorator.\n\n        minargs -- Minimum number of arguments taken by the function.\n        maxargs -- Maximum number of arguments taken by the function.\n        implicit -- True for functions which operate on a nodeset consisting\n                    of the current context node when passed no argument.\n                    (e.g., string() and number().)\n        convert -- When non-None, a function used to filter function arguments.\n        \"\"\"\n        def decorator(f):\n            def new_f(self, node, pos, size, context):\n                if implicit and len(self.args) == 0:\n                    args = [[node]]\n                else:\n                    args = [x.evaluate(node, pos, size, context)\n                            for x in self.args]\n                if first:\n                    args[0] = nodeset(args[0])\n                    if len(args[0]) > 0:\n                        args[0] = args[0][0]\n                    else:\n                        args[0] = None\n                if convert is not None:\n                    args = [convert(x) for x in args]\n                return f(self, node, pos, size, context, *args)\n\n            new_f.minargs = minargs\n            new_f.maxargs = maxargs\n            new_f.__name__ = f.__name__\n            new_f.__doc__ = f.__doc__\n            return new_f\n        return decorator"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef reactToAMQPMessage(message, sender):\n    if _instanceof(message, GenerateContract):\n        return pdf_from_file(  # TODO: rewrite to decorator\n            get_contract(**message._asdict())\n        )\n    elif _instanceof(message, RST2PDF):\n        return pdf_from_file(\n            gen_pdf(**message._asdict())\n        )\n    elif _instanceof(message, GenerateReview):\n        return pdf_from_file(\n            get_review(message)\n        )\n\n    raise ValueError(\n        \"Unknown type of request: '\" + str(type(message)) + \"'!\"\n    )", "response": "React to given message."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef on_stop(self):\n        LOGGER.debug(\"natsd.Requester.on_stop\")\n        self.is_started = False\n        try:\n            LOGGER.debug(\"natsd.Requester.on_stop - unsubscribe from \" + str(self.responseQS))\n            next(self.nc.unsubscribe(self.responseQS))\n        except StopIteration as e:\n            pass\n        try:\n            LOGGER.debug(\"natsd.Requester.on_stop - close nats connection\")\n            next(self.nc.close())\n        except StopIteration as e:\n            pass\n        LOGGER.debug(\"natsd.Requester.on_stop - nc is closed: \" + str(self.nc.is_closed))\n        try:\n            LOGGER.debug(\"natsd.Requester.on_stop - cancelling aio tasks loop\")\n            loop_to_stop = self.loop\n            for task in asyncio.Task.all_tasks(loop_to_stop):\n                LOGGER.debug(\"natsd.Requester.on_stop - cancelling task \" + str(task))\n                task.cancel()\n            LOGGER.debug(\"natsd.Requester.on_stop - stopping aio loop stop\")\n            loop_to_stop.stop()\n            count = 0\n            while loop_to_stop.is_running():\n                count += 1\n                if count % 10 == 0:\n                    LOGGER.debug(\"natsd.Requester.on_stop - waiting aio loop to be stopped (\" +\n                                 str(asyncio.Task.all_tasks(loop_to_stop).__len__()) + \" tasks left; \" +\n                                 \"current task: \" + str(asyncio.Task.current_task(loop_to_stop)) + \")\")\n                    for task in asyncio.Task.all_tasks(loop_to_stop):\n                        LOGGER.debug(\"natsd.Requester.on_stop - cancelling task \" + str(task))\n                        task.cancel()\n                time.sleep(1)\n                if count == 120:\n                    LOGGER.error(\"natsd.Requester.on_stop - unable to stop aio loop after 120 sec (\" +\n                                 str(asyncio.Task.all_tasks(loop_to_stop).__len__()) + \" tasks left; \" +\n                                 \"current task: \" + str(asyncio.Task.current_task(loop_to_stop)) + \")\")\n                    break\n            if not loop_to_stop.is_running():\n                LOGGER.debug(\"natsd.Requester.on_stop - close aio loop\")\n                loop_to_stop.close()\n        except Exception as e:\n            LOGGER.warn(\"natsd.Requester.on_stop - exception on aio clean : \"\n                        + traceback.format_exc())", "response": "Stop the requester and cancel all tasks in the loop."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ncalling when a response is received from the server.", "response": "def on_response(self, msg):\n        \"\"\"\n        setup response if correlation id is the good one\n        \"\"\"\n        LOGGER.debug(\"natsd.Requester.on_response: \" + str(sys.getsizeof(msg)) + \" bytes received\")\n        working_response = json.loads(msg.data.decode())\n        working_properties = DriverTools.json2properties(working_response['properties'])\n        working_body = b''+bytes(working_response['body'], 'utf8') if 'body' in working_response else None\n        if DriverTools.MSG_CORRELATION_ID in working_properties:\n            if self.corr_id == working_properties[DriverTools.MSG_CORRELATION_ID]:\n                if DriverTools.MSG_SPLIT_COUNT in working_properties and \\\n                        int(working_properties[DriverTools.MSG_SPLIT_COUNT]) > 1:\n                    working_body_decoded = base64.b64decode(working_body) if working_body is not None else None\n                    if self.split_responses is None:\n                        self.split_responses = []\n                        self.split_responses_mid = working_properties[DriverTools.MSG_SPLIT_MID]\n                    if working_properties[DriverTools.MSG_SPLIT_MID] == self.split_responses_mid:\n                        response = {\n                            'properties': working_properties,\n                            'body': working_body_decoded\n                        }\n                        self.split_responses.insert(int(working_properties[DriverTools.MSG_SPLIT_OID]), response)\n\n                        if self.split_responses.__len__() == int(working_properties[DriverTools.MSG_SPLIT_COUNT]):\n                            properties = {}\n                            body = b''\n                            for num in range(0, self.split_responses.__len__()):\n                                properties.update(self.split_responses[num]['properties'])\n                                body += self.split_responses[num]['body']\n                            self.response = {\n                                'properties': properties,\n                                'body': body\n                            }\n                            self.split_responses = None\n                            self.split_responses_mid = None\n\n                    else:\n                        LOGGER.warn(\"natsd.Requester.on_response - discarded response : (\" +\n                                    str(working_properties[DriverTools.MSG_CORRELATION_ID]) + \",\" +\n                                    str(working_properties[DriverTools.MSG_SPLIT_MID]) + \")\")\n                        LOGGER.debug(\"natsd.Requester.on_response - discarded response : \" + str({\n                            'properties': working_properties,\n                            'body': working_body_decoded\n                        }))\n                else:\n                    working_body_decoded = base64.b64decode(working_body) if working_body is not None else \\\n                        bytes(json.dumps({}), 'utf8')\n                    self.response = {\n                        'properties': working_properties,\n                        'body': working_body_decoded\n                    }\n            else:\n                working_body_decoded = base64.b64decode(working_body) if working_body is not None else None\n                LOGGER.warn(\"natsd.Requester.on_response - discarded response : \" +\n                            str(working_properties[DriverTools.MSG_CORRELATION_ID]))\n                LOGGER.debug(\"natsd.Requester.on_response - discarded response : \" + str({\n                    'properties': working_properties,\n                    'body': working_body_decoded\n                }))\n        else:\n            working_body_decoded = base64.b64decode(working_body) if working_body is not None else None\n            LOGGER.warn(\"natsd.Requester.on_response - discarded response (no correlation ID)\")\n            LOGGER.debug(\"natsd.Requester.on_response - discarded response : \" + str({\n                'properties': working_properties,\n                'body': working_body_decoded\n            }))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef on_request(self, msg):\n        LOGGER.debug(\"natsd.Service.on_request - request \" + str(msg) + \" received\")\n        try:\n            working_response = json.loads(msg.data.decode())\n            working_properties = DriverTools.json2properties(working_response['properties'])\n            working_body = b''+bytes(working_response['body'], 'utf8') if 'body' in working_response else None\n            working_body_decoded = base64.b64decode(working_body) if working_body is not None else \\\n                bytes(json.dumps({}), 'utf8')\n            self.cb(working_properties, working_body_decoded)\n        except Exception as e:\n            LOGGER.warn(\"natsd.Service.on_request - Exception raised while treating msg {\"+str(msg)+\",\"+str(msg)+\"}\")\n        LOGGER.debug(\"natsd.Service.on_request - request \" + str(msg) + \" treated\")", "response": "message consumed treatment through provided callback and basic ack"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nstart the service thread", "response": "def on_start(self):\n        \"\"\"\n        start the service\n        \"\"\"\n        LOGGER.debug(\"natsd.Service.on_start\")\n        self.service = threading.Thread(target=self.run_event_loop, name=self.serviceQ + \" service thread\")\n        self.service.start()\n        while not self.is_started:\n            time.sleep(0.01)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef stop(self):\n        LOGGER.debug(\"natsd.Driver.stop\")\n        for requester in self.requester_registry:\n            requester.stop()\n        self.requester_registry.clear()\n\n        for service in self.services_registry:\n            if service.is_started:\n                service.stop()\n        self.services_registry.clear()\n\n        return self", "response": "Stop all services and requestors and then connection."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef make_service(self, my_args=None):\n        LOGGER.debug(\"natsd.Driver.make_service\")\n        if my_args is None:\n            raise exceptions.ArianeConfError('service factory arguments')\n        if not self.configuration_OK or self.connection_args is None:\n            raise exceptions.ArianeConfError('NATS connection arguments')\n        service = Service.start(my_args, self.connection_args).proxy()\n        self.services_registry.append(service)\n        return service", "response": "make a new service instance and handle it from driver\n       "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef make_requester(self, my_args=None):\n        LOGGER.debug(\"natsd.Driver.make_requester\")\n        if my_args is None:\n            raise exceptions.ArianeConfError('requester factory arguments')\n        if not self.configuration_OK or self.connection_args is None:\n            raise exceptions.ArianeConfError('NATS connection arguments')\n        requester = Requester.start(my_args, self.connection_args).proxy()\n        self.requester_registry.append(requester)\n        return requester", "response": "make a new requester instance and handle it from driver\n       "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef ttl(self):\n\n        # result is self ts\n        result = getattr(self, Annotation.__TS, None)\n        # if result is not None\n        if result is not None:\n            # result is now - result\n            now = time()\n            result = result - now\n\n        return result", "response": "Get actual ttl in seconds."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef ttl(self, value):\n\n        # get timer\n        timer = getattr(self, Annotation.__TIMER, None)\n\n        # if timer is running, stop the timer\n        if timer is not None:\n            timer.cancel()\n\n        # initialize timestamp\n        timestamp = None\n\n        # if value is None\n        if value is None:\n            # nonify timer\n            timer = None\n\n        else:  # else, renew a timer\n            # get timestamp\n            timestamp = time() + value\n            # start a new timer\n            timer = Timer(value, self.__del__)\n            timer.start()\n            # set/update attributes\n\n        setattr(self, Annotation.__TIMER, timer)\n        setattr(self, Annotation.__TS, timestamp)", "response": "Change self ttl with input value."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nchecks if this object is in global memory of annotations.", "response": "def in_memory(self):\n        \"\"\"\n        :return: True if self is in a global memory of annotations.\n        \"\"\"\n\n        self_class = self.__class__\n        # check if self class is in global memory\n        memory = Annotation.__ANNOTATIONS_IN_MEMORY__.get(self_class, ())\n        # check if self is in memory\n        result = self in memory\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef in_memory(self, value):\n\n        self_class = self.__class__\n        memory = Annotation.__ANNOTATIONS_IN_MEMORY__\n\n        if value:\n            annotations_memory = memory.setdefault(self_class, set())\n            annotations_memory.add(self)\n\n        else:\n            if self_class in memory:\n                annotations_memory = memory[self_class]\n                while self in annotations_memory:\n                    annotations_memory.remove(self)\n                if not annotations_memory:\n                    del memory[self_class]", "response": "Add or remove self from global memory."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef bind_target(self, target, ctx=None):\n\n        # process self _bind_target\n        result = self._bind_target(target=target, ctx=ctx)\n\n        # fire on bind target event\n        self.on_bind_target(target=target, ctx=ctx)\n\n        return result", "response": "Bind self annotation to target."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef _bind_target(self, target, ctx=None):\n\n        result = target\n\n        try:\n            # get annotations from target if exists.\n            local_annotations = get_local_property(\n                target, Annotation.__ANNOTATIONS_KEY__, [], ctx=ctx\n            )\n        except TypeError:\n            raise TypeError('target {0} must be hashable.'.format(target))\n\n        # if local_annotations do not exist, put them in target\n        if not local_annotations:\n            put_properties(\n                target,\n                properties={Annotation.__ANNOTATIONS_KEY__: local_annotations},\n                ctx=ctx\n            )\n\n        # insert self at first position\n        local_annotations.insert(0, self)\n\n        # add target to self targets\n        if target not in self.targets:\n            self.targets.append(target)\n\n        return result", "response": "Method to bind target to a specific context."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ninvoke after target is bound to self. Taxonomy.", "response": "def on_bind_target(self, target, ctx=None):\n        \"\"\"Fired after target is bound to self.\n\n        :param target: newly bound target.\n        :param ctx: target ctx.\n        \"\"\"\n\n        _on_bind_target = getattr(self, Annotation._ON_BIND_TARGET, None)\n\n        if _on_bind_target is not None:\n            _on_bind_target(self, target=target, ctx=ctx)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef remove_from(self, target, ctx=None):\n\n        annotations_key = Annotation.__ANNOTATIONS_KEY__\n\n        try:\n            # get local annotations\n            local_annotations = get_local_property(\n                target, annotations_key, ctx=ctx\n            )\n        except TypeError:\n            raise TypeError('target {0} must be hashable'.format(target))\n\n        # if local annotations exist\n        if local_annotations is not None:\n            # if target in self.targets\n            if target in self.targets:\n                # remove target from self.targets\n                self.targets.remove(target)\n                # and remove all self annotations from local_annotations\n                while self in local_annotations:\n                    local_annotations.remove(self)\n                # if target is not annotated anymore, remove the empty list\n                if not local_annotations:\n                    del_properties(target, annotations_key)", "response": "Remove self annotation from target annotations."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef free_memory(cls, exclude=None):\n\n        annotations_in_memory = Annotation.__ANNOTATIONS_IN_MEMORY__\n\n        exclude = () if exclude is None else exclude\n\n        for annotation_cls in list(annotations_in_memory.keys()):\n\n            if issubclass(annotation_cls, exclude):\n                continue\n\n            if issubclass(annotation_cls, cls):\n                del annotations_in_memory[annotation_cls]", "response": "Free global annotation memory."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_memory_annotations(cls, exclude=None):\n\n        result = set()\n\n        # get global dictionary\n        annotations_in_memory = Annotation.__ANNOTATIONS_IN_MEMORY__\n\n        exclude = () if exclude is None else exclude\n\n        # iterate on annotation classes\n        for annotation_cls in annotations_in_memory:\n\n            # if annotation class is excluded, continue\n            if issubclass(annotation_cls, exclude):\n                continue\n\n            # if annotation class inherits from self, add it in the result\n            if issubclass(annotation_cls, cls):\n                result |= annotations_in_memory[annotation_cls]\n\n        return result", "response": "Get annotations in memory which inherits from cls."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget a list of local target annotations in the order of their respective local target annotations.", "response": "def get_local_annotations(\n            cls, target, exclude=None, ctx=None, select=lambda *p: True\n    ):\n        \"\"\"Get a list of local target annotations in the order of their\n            definition.\n\n        :param type cls: type of annotation to get from target.\n        :param target: target from where get annotations.\n        :param tuple/type exclude: annotation types to exclude from selection.\n        :param ctx: target ctx.\n        :param select: selection function which takes in parameters a target,\n            a ctx and an annotation and returns True if the annotation has to\n            be selected. True by default.\n\n        :return: target local annotations.\n        :rtype: list\n        \"\"\"\n\n        result = []\n\n        # initialize exclude\n        exclude = () if exclude is None else exclude\n\n        try:\n            # get local annotations\n            local_annotations = get_local_property(\n                target, Annotation.__ANNOTATIONS_KEY__, result, ctx=ctx\n            )\n            if not local_annotations:\n                if ismethod(target):\n                    func = get_method_function(target)\n                    local_annotations = get_local_property(\n                        func, Annotation.__ANNOTATIONS_KEY__,\n                        result, ctx=ctx\n                    )\n                    if not local_annotations:\n                        local_annotations = get_local_property(\n                            func, Annotation.__ANNOTATIONS_KEY__,\n                            result\n                        )\n                elif isfunction(target):\n                    local_annotations = get_local_property(\n                        target, Annotation.__ANNOTATIONS_KEY__,\n                        result\n                    )\n\n        except TypeError:\n            raise TypeError('target {0} must be hashable'.format(target))\n\n        for local_annotation in local_annotations:\n            # check if local annotation inherits from cls\n            inherited = isinstance(local_annotation, cls)\n            # and if not excluded\n            not_excluded = not isinstance(local_annotation, exclude)\n            # and if selected\n            selected = select(target, ctx, local_annotation)\n            # if three conditions, add local annotation to the result\n            if inherited and not_excluded and selected:\n                result.append(local_annotation)\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef remove(cls, target, exclude=None, ctx=None, select=lambda *p: True):\n\n        # initialize exclude\n        exclude = () if exclude is None else exclude\n\n        try:\n            # get local annotations\n            local_annotations = get_local_property(\n                target, Annotation.__ANNOTATIONS_KEY__\n            )\n\n        except TypeError:\n            raise TypeError('target {0} must be hashable'.format(target))\n\n        # if there are local annotations\n        if local_annotations is not None:\n\n            # get annotations to remove which inherits from cls\n            annotations_to_remove = [\n                annotation for annotation in local_annotations\n                if (\n                    isinstance(annotation, cls)\n                    and not isinstance(annotation, exclude)\n                    and select(target, ctx, annotation)\n                )\n            ]\n\n            # and remove annotations from target\n            for annotation_to_remove in annotations_to_remove:\n                annotation_to_remove.remove_from(target)", "response": "Remove from target annotations which inherit from cls."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_annotations(\n            cls, target,\n            exclude=None, ctx=None, select=lambda *p: True,\n            mindepth=0, maxdepth=0, followannotated=True, public=True,\n            _history=None\n    ):\n        \"\"\"Returns all input target annotations of cls type sorted\n        by definition order.\n\n        :param type cls: type of annotation to get from target.\n        :param target: target from where get annotations.\n        :param tuple/type exclude: annotation types to remove from selection.\n        :param ctx: target ctx.\n        :param select: bool function which select annotations after applying\n            previous type filters. Takes a target, a ctx and an annotation in\n            parameters. True by default.\n        :param int mindepth: minimal depth for searching annotations (default 0)\n        :param int maxdepth: maximal depth for searching annotations (default 0)\n        :param bool followannotated: if True (default) follow deeply only\n            annotated members.\n        :param bool public: if True (default) follow public members.\n        :param list _history: private parameter which save parsed elements.\n        :rtype: Annotation\n        \"\"\"\n\n        result = []\n\n        if mindepth <= 0:\n\n            try:\n                annotations_by_ctx = get_property(\n                    elt=target, key=Annotation.__ANNOTATIONS_KEY__, ctx=ctx\n                )\n\n            except TypeError:\n                annotations_by_ctx = {}\n\n            if not annotations_by_ctx:\n                if ismethod(target):\n                    func = get_method_function(target)\n                    annotations_by_ctx = get_property(\n                        elt=func,\n                        key=Annotation.__ANNOTATIONS_KEY__,\n                        ctx=ctx\n                    )\n                    if not annotations_by_ctx:\n                        annotations_by_ctx = get_property(\n                            elt=func, key=Annotation.__ANNOTATIONS_KEY__\n                        )\n                elif isfunction(target):\n                    annotations_by_ctx = get_property(\n                        elt=target,\n                        key=Annotation.__ANNOTATIONS_KEY__\n                    )\n\n            exclude = () if exclude is None else exclude\n\n            for elt, annotations in annotations_by_ctx:\n\n                for annotation in annotations:\n\n                    # check if annotation is a StopPropagation rule\n                    if isinstance(annotation, StopPropagation):\n                        exclude += annotation.annotation_types\n\n                    # ensure propagation\n                    if elt is not target and not annotation.propagate:\n                        continue\n\n                    # ensure overriding\n                    if annotation.override:\n                        exclude += (annotation.__class__, )\n\n                    # check for annotation\n                    if (isinstance(annotation, cls)\n                            and not isinstance(annotation, exclude)\n                            and select(target, ctx, annotation)):\n\n                        result.append(annotation)\n\n        if mindepth >= 0 or (maxdepth > 0 and (result or not followannotated)):\n\n            if _history is None:\n                _history = [target]\n\n            else:\n                _history.append(target)\n\n            for name, member in getmembers(target):\n                if (name[0] != '_' or not public) and member not in _history:\n\n                    if ismethod(target) and name.startswith('im_'):\n                        continue\n\n                    result += cls.get_annotations(\n                        target=member, exclude=exclude, ctx=ctx, select=select,\n                        mindepth=mindepth - 1, maxdepth=maxdepth - 1,\n                        followannotated=followannotated, _history=_history\n                    )\n\n        return result", "response": "Returns all input target annotations of cls type sorted by definition order."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nget dict of annotated fields by cls of input instance.", "response": "def get_annotated_fields(cls, instance, select=lambda *p: True):\n        \"\"\"Get dict of {annotated fields: annotations} by cls of\n        input instance.\n\n        :return: a set of (annotated fields, annotations).\n        :rtype: dict\n        \"\"\"\n\n        result = {}\n\n        for _, member in getmembers(instance):\n            try:\n                annotations = cls.get_annotations(\n                    target=member, ctx=instance, select=select\n                )\n\n            except TypeError:\n                pass\n\n            else:\n                try:\n                    if annotations:\n                        result[member] = annotations\n\n                except TypeError:  # if field is an object proxy\n                    pass\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef rand_chol(X, rho):\n    import numpy as np\n    return np.dot(X, np.linalg.cholesky(rho).T)", "response": "Transform C uncorrelated random variables into correlated data"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef login_required(func, permission=None):\n    @wraps(func)\n    def decorated_function(*args, **kwargs):\n        if not check_token():\n            return login()\n        elif not nago.core.has_access(session.get('token')):\n            return http403()\n        return func(*args, **kwargs)\n    return decorated_function", "response": "decorator for functions that require a valid token for any view"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning a list of all nodes", "response": "def list_nodes():\n    \"\"\" Return a list of all nodes \"\"\"\n    token = session.get('token')\n    node = nago.core.get_node(token)\n    if not node.get('access') == 'master':\n        return jsonify(status='error', error=\"You need master access to view this page\")\n\n    nodes = nago.core.get_nodes().values()\n    return render_template('nodes.html', **locals())"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nviewing one specific node", "response": "def node_detail(node_name):\n    \"\"\" View one specific node \"\"\"\n    token = session.get('token')\n    node = nago.core.get_node(token)\n    if not node.get('access') == 'master':\n        return jsonify(status='error', error=\"You need master access to view this page\")\n\n    node = nago.core.get_node(node_name)\n    return render_template('node_detail.html', node=node)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_filenames(dirname):\n    filenames = glob.glob('{}/*.pkl'.format(dirname))\n    return sorted(filenames, key=_f_to_i)", "response": "Returns all model output filenames inside a model output directory sorted by iteration number."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget how many iterations between outputs have been done in a directory run.", "response": "def get_output_every(dirname):\n    \"\"\"Get how many iterations between outputs have been done in a directory\n    run.\n\n    If there are multiple values used in a run, raise an exception.\n\n    Parameters\n    ----------\n    dirname: str\n        A path to a directory.\n\n    Returns\n    -------\n    output_every: int\n        The inferred number of iterations between outputs.\n\n    Raises\n    ------\n    TypeError\n        If there are multiple different values for `output_every` found. This\n        usually means a run has been resumed with a different value.\n    \"\"\"\n    fnames = get_filenames(dirname)\n    i_s = np.array([_f_to_i(fname) for fname in fnames])\n    everys = list(set(np.diff(i_s)))\n    if len(everys) > 1:\n        raise TypeError('Multiple values for `output_every` '\n                        'found, {}.'.format(everys))\n    return everys[0]"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ndumping a model instance to a pickle file.", "response": "def model_to_file(model, filename):\n    \"\"\"Dump a model to a file as a pickle file.\n\n    Parameters\n    ----------\n    model: Model\n        Model instance.\n    filename: str\n        A path to the file in which to store the pickle output.\n    \"\"\"\n    with open(filename, 'wb') as f:\n        pickle.dump(model, f)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nremove files from an output directory at regular interval so as to make it as if there had been more iterations between outputs.", "response": "def sparsify(dirname, output_every):\n    \"\"\"Remove files from an output directory at regular interval, so as to\n    make it as if there had been more iterations between outputs. Can be used\n    to reduce the storage size of a directory.\n\n    If the new number of iterations between outputs is not an integer multiple\n    of the old number, then raise an exception.\n\n    Parameters\n    ----------\n    dirname: str\n        A path to a directory.\n    output_every: int\n        Desired new number of iterations between outputs.\n\n    Raises\n    ------\n    ValueError\n        The directory cannot be coerced into representing `output_every`.\n    \"\"\"\n    fnames = get_filenames(dirname)\n    output_every_old = get_output_every(dirname)\n    if output_every % output_every_old != 0:\n        raise ValueError('Directory with output_every={} cannot be coerced to'\n                         'desired new value.'.format(output_every_old))\n    keep_every = output_every // output_every_old\n    fnames_to_keep = fnames[::keep_every]\n    fnames_to_delete = set(fnames) - set(fnames_to_keep)\n    for fname in fnames_to_delete:\n        os.remove(fname)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef make_url_args(params):\n\n    p = []\n    for key, value in params.iteritems():\n        if isinstance(value, (list, tuple)):\n            for v in value:\n                p.append((key, v))\n        elif isinstance(value, dict):\n            for k, v in value.items():\n                p.append(('%s[%s]' % (key, k), v))\n        elif isinstance(value, bool):\n            p.append((key, str(value).lower()))\n        elif value is None:\n            continue\n        else:\n            p.append((key, str(value)))\n    return urllib.urlencode(p).encode(\"UTF-8\")", "response": "Utility function for constructing a URL query string from a dictionary of parameters."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef post(self, url, body):\n\n        to_hit = urlparse.urljoin(self.base_url, url)\n        resp = self.pool.post(to_hit, data=body, auth=self.auth)\n        return resp", "response": "Perform a POST request to the given resource with the given body."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nperform a GET request to the given resource with the given URL.", "response": "def get(self, url):\n        \"\"\"Perform a GET request to the given resource with the given URL.  The\n        \"url\" argument will be joined to the base URL this object was\n        initialized with.\n\n        :param string url: the URL resource to hit\n        :rtype: requests.Response object\"\"\"\n\n        to_hit = urlparse.urljoin(self.base_url, url)\n        resp = self.pool.get(to_hit, auth=self.auth)\n        return resp"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nconvert the given floating point number into a scientific notation using unicode superscript characters to nicely render the exponent.", "response": "def sci(x, precision=2, base=10, exp_only=False):\n    \"\"\"\n    Convert the given floating point number into scientific notation, using \n    unicode superscript characters to nicely render the exponent.\n    \"\"\"\n\n    # Handle the corner cases of zero and non-finite numbers, which can't be \n    # represented using scientific notation.\n    if x == 0 or not math.isfinite(x):\n        return '{1:.{0}f}'.format(precision, x)\n\n    exponent = math.floor(math.log(abs(x), base))\n    mantissa = x / base**exponent\n\n    # Handle the corner case where the mantissa would round up to 10 (at the \n    # given level of precision) by incrementing the exponent.\n    if abs(mantissa) + base**-precision >= base:\n        exponent += 1\n        mantissa /= base\n\n    superscripts = str.maketrans('-0123456789', '\u207b\u2070\u00b9\u00b2\u00b3\u2074\u2075\u2076\u2077\u2078\u2079')\n    superscript_exponent = str(exponent).translate(superscripts)\n\n    if exp_only:\n        return '{0}{1}'.format(base, superscript_exponent)\n    else:\n        return '{1:.{0}f}\u00d7{2}{3}'.format(precision, mantissa, base, superscript_exponent)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef SWdensityFromCTD(SA, t, p, potential=False):\n    '''Calculate seawater density at CTD depth\n\n    Args\n    ----\n    SA: ndarray\n        Absolute salinity, g/kg\n    t: ndarray\n        In-situ temperature (ITS-90), degrees C\n    p: ndarray\n        Sea pressure (absolute pressure minus 10.1325 dbar), dbar\n\n    Returns\n    -------\n    rho: ndarray\n        Seawater density, in-situ or potential, kg/m^3\n    '''\n    import numpy\n    import gsw\n\n    CT = gsw.CT_from_t(SA, t, p)\n\n    # Calculate potential density (0 bar) instead of in-situ\n    if potential:\n        p = numpy.zeros(len(SA))\n\n    return gsw.rho(SA, CT, p)", "response": "Calculate seawater density at CTD depth"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef drop_empty_records(x, axis=1):\n    # load module\n    import numpy as np\n    # input args check\n    if not isinstance(x, np.ndarray or np.matrix):\n        raise ValueError(\"x is not a numpy.ndarray or numpy.matrix.\")\n\n    # index\n    idx = np.logical_not(np.all(np.logical_or(\n        np.isnan(x), np.isinf(x)), axis=axis))\n\n    if axis is 1:\n        return x[idx, :].copy()\n    elif axis is 0:\n        return x[:, idx].copy()\n    else:\n        raise ValueError(\"only 2-dimensional datasets are supported.\")", "response": "delete data items that contains only nan or inf"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn True if the object is editable for the request.", "response": "def is_editable(obj, request):\n    \"\"\"\n    Returns ``True`` if the object is editable for the request. First\n    check for a custom ``editable`` handler on the object, otherwise\n    use the logged in user and check change permissions for the\n    object's model.\n    \"\"\"\n    if hasattr(obj, \"is_editable\"):\n        return obj.is_editable(request)\n    else:\n        codename = get_permission_codename(\"change\", obj._meta)\n        perm = \"%s.%s\" % (obj._meta.app_label, codename)\n        return (request.user.is_authenticated() and\n                has_site_permission(request.user) and\n                request.user.has_perm(perm))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns True if the request is spam based on the Akismet API key.", "response": "def is_spam_akismet(request, form, url):\n    \"\"\"\n    Identifies form data as being spam, using the http://akismet.com\n    service. The Akismet API key should be specified in the\n    ``AKISMET_API_KEY`` setting. This function is the default spam\n    handler defined in the ``SPAM_FILTERS`` setting.\n\n    The name, email, url and comment fields are all guessed from the\n    form fields:\n\n    * name: First field labelled \"Name\", also taking i18n into account.\n    * email: First ``EmailField`` field.\n    * url: First ``URLField`` field.\n    * comment: First field with a ``Textarea`` widget.\n\n    If the actual comment can't be extracted, spam checking is passed.\n\n    The referrer field expects a hidden form field to pass the referrer\n    through, since the HTTP_REFERER will be the URL the form is posted\n    from. The hidden referrer field is made available by default with\n    the ``{% fields_for %}`` templatetag used for rendering form fields.\n    \"\"\"\n    if not settings.AKISMET_API_KEY:\n        return False\n    protocol = \"http\" if not request.is_secure() else \"https\"\n    host = protocol + \"://\" + request.get_host()\n    data = {\n        \"blog\": host,\n        \"user_ip\": ip_for_request(request),\n        \"user_agent\": request.META.get(\"HTTP_USER_AGENT\", \"\"),\n        \"referrer\": request.POST.get(\"referrer\", \"\"),\n        \"permalink\": host + url,\n        \"comment_type\": \"comment\" if \"comment\" in request.POST else \"form\",\n    }\n    for name, field in form.fields.items():\n        data_field = None\n        if field.label and field.label.lower() in (\"name\", _(\"Name\").lower()):\n            data_field = \"comment_author\"\n        elif isinstance(field, EmailField):\n            data_field = \"comment_author_email\"\n        elif isinstance(field, URLField):\n            data_field = \"comment_author_url\"\n        elif isinstance(field.widget, Textarea):\n            data_field = \"comment_content\"\n        if data_field and not data.get(data_field):\n            cleaned_data = form.cleaned_data.get(name)\n            try:\n                data[data_field] = cleaned_data.encode('utf-8')\n            except UnicodeEncodeError:\n                data[data_field] = cleaned_data\n    if not data.get(\"comment_content\"):\n        return False\n    api_url = (\"http://%s.rest.akismet.com/1.1/comment-check\" %\n               settings.AKISMET_API_KEY)\n    versions = (django.get_version(), yacms.__version__)\n    headers = {\"User-Agent\": \"Django/%s | Yacms/%s\" % versions}\n    try:\n        response = urlopen(Request(api_url, urlencode(data).encode('utf-8'),\n                                   headers)).read()\n    except Exception:\n        return False\n\n    # Python 3 returns response as a bytestring, Python 2 as a regular str\n    return response in (b'true', 'true')"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef is_spam(request, form, url):\n    for spam_filter_path in settings.SPAM_FILTERS:\n        spam_filter = import_dotted_path(spam_filter_path)\n        if spam_filter(request, form, url):\n            return True", "response": "Check if the request is a spam."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef paginate(objects, page_num, per_page, max_paging_links):\n    if not per_page:\n        return Paginator(objects, 0)\n    paginator = Paginator(objects, per_page)\n    try:\n        page_num = int(page_num)\n    except ValueError:\n        page_num = 1\n    try:\n        objects = paginator.page(page_num)\n    except (EmptyPage, InvalidPage):\n        objects = paginator.page(paginator.num_pages)\n    page_range = objects.paginator.page_range\n    if len(page_range) > max_paging_links:\n        start = min(objects.paginator.num_pages - max_paging_links,\n            max(0, objects.number - (max_paging_links // 2) - 1))\n        page_range = list(page_range)[start:start + max_paging_links]\n    objects.visible_page_range = page_range\n    return objects", "response": "Returns a paginated page for the given objects giving it a custom\n    visible_page_range attribute calculated from max_paging_links."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef render(request, templates, dictionary=None, context_instance=None,\n           **kwargs):\n    \"\"\"\n    Mimics ``django.shortcuts.render`` but uses a TemplateResponse for\n    ``yacms.core.middleware.TemplateForDeviceMiddleware``\n    \"\"\"\n\n    warnings.warn(\n        \"yacms.utils.views.render is deprecated and will be removed \"\n        \"in a future version. Please update your project to use Django's \"\n        \"TemplateResponse, which now provides equivalent functionality.\",\n        DeprecationWarning\n    )\n\n    dictionary = dictionary or {}\n    if context_instance:\n        context_instance.update(dictionary)\n    else:\n        context_instance = RequestContext(request, dictionary)\n    return TemplateResponse(request, templates, context_instance, **kwargs)", "response": "Mimics django. shortcuts. render but uses a TemplateResponse for the base class."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nset a cookie on the response.", "response": "def set_cookie(response, name, value, expiry_seconds=None, secure=False):\n    \"\"\"\n    Set cookie wrapper that allows number of seconds to be given as the\n    expiry time, and ensures values are correctly encoded.\n    \"\"\"\n    if expiry_seconds is None:\n        expiry_seconds = 90 * 24 * 60 * 60  # Default to 90 days.\n    expires = datetime.strftime(datetime.utcnow() +\n                                timedelta(seconds=expiry_seconds),\n                                \"%a, %d-%b-%Y %H:%M:%S GMT\")\n    # Django doesn't seem to support unicode cookie keys correctly on\n    # Python 2. Work around by encoding it. See\n    # https://code.djangoproject.com/ticket/19802\n    try:\n        response.set_cookie(name, value, expires=expires, secure=secure)\n    except (KeyError, TypeError):\n        response.set_cookie(name.encode('utf-8'), value, expires=expires,\n                            secure=secure)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef aes_encrypt(self, plain, sec_key, enable_b64=True):\n        plain = helper.to_str(plain)\n        sec_key = helper.to_str(sec_key)\n        # \u5982\u679cmsg\u957f\u5ea6\u4e0d\u4e3a16\u500d\u6570, \u9700\u8981\u8865\u4f4d '\\0'\n        plain += '\\0' * (self.bs - len(plain) % self.bs)\n        # \u4f7f\u7528\u751f\u6210\u7684 key, iv \u52a0\u5bc6\n        plain = helper.to_bytes(plain)\n        cipher = self.aes_obj(sec_key).encrypt(plain)\n        # \u662f\u5426\u8fd4\u56de base64 \u7f16\u7801\u6570\u636e\n        cip = base64.b64encode(cipher) if enable_b64 else cipher\n        return helper.to_str(cip)", "response": "AES \u52a0\u5bc6 plain - \u52a0\u5bc6 msg - \u52a0\u5bc6 msg - \u52a0\u5bc6 msg - \u52a0\u5bc6 msg - \u52a0\u5bc6 msg - \u52a0\u5bc6 msg - \u52a0\u5bc6 msg - \u52a0\u5bc6 msg - \u52a0\u5bc6 msg -"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef aes_decrypt(self, cipher, sec_key, enable_b64=True):\n        cipher = base64.b64decode(cipher) if enable_b64 else cipher\n\n        plain_ = self.aes_obj(sec_key).decrypt(cipher)\n        return helper.to_str(plain_).rstrip('\\0')", "response": "AES decrypt a message"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef rsa_base64_sign_str(self, plain, b64=True):\n        with open(self.key_file) as fp:\n            key_ = RSA.importKey(fp.read())\n            # h = SHA.new(plain if sys.version_info < (3, 0) else plain.encode('utf-8'))\n            plain = helper.to_bytes(plain)\n            # if hasattr(plain, 'encode'):\n            #     plain = plain.encode()\n            h = SHA.new(plain)\n            cipher = pkcs.new(key_).sign(h)\n            cip = base64.b64encode(cipher) if b64 else cipher\n            return helper.to_str(cip)", "response": "\u5bf9 msg rsa \u7b7e\u540d, \u7136\u540e\u4f7f\u7528 base64 encode \u7f16\u7801\u6570\u636e"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef getter(self, fget):\n        if getattr(self, '__doc__', None) is None:\n            self.__doc__ = getattr(fget, _FUNC_DOC, None)\n        if self.name is None:\n            self.name = getattr(fget, _FUNC_NAME, None)\n        self._getter = fget\n        return self", "response": "Change the getter for this descriptor to use to get the value\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef setter(self, can_set=None):\n        if can_set is None:\n            self._setter = not self._setter\n        else:\n            self._setter = bool(can_set)\n        # For use as decorator\n        return self", "response": "Sets the value of the object s key - value."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef deleter(self, can_delete=None):\n        if can_delete is None:\n            self._deleter = not self._deleter\n        else:\n            self._deleter = bool(can_delete)\n        # For use as decorator\n        return self", "response": "Change if this descriptor s can be invalidated through del obj. attr."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\napply a mapping of name - value - pairs to a template.", "response": "def apply(self, mapping):\n        \"\"\"Apply a mapping of name-value-pairs to a template.\"\"\"\n        mapping = {name: self.str(value, tolerant=self.tolerant)\n                   for name, value in mapping.items()\n                   if value is not None or self.tolerant}\n\n        if self.tolerant:\n            return self.template.safe_substitute(mapping)\n\n        return self.template.substitute(mapping)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nwrite the file forcing the proper permissions", "response": "def write(self):\n        \"\"\"\n        Write the file, forcing the proper permissions\n        \"\"\"\n        with root():\n            self._write_log()\n            with open(self.path, 'w') as f:\n                # file owner\n                os.chown(self.path, self.uid(), self.gid())\n\n                # mode\n                if self.mode:\n                    oldmask = os.umask(0)\n                    os.chmod(self.path, self.mode)\n                    os.umask(oldmask)\n\n                f.write(self.contents())"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nwriting log info for the current locale.", "response": "def _write_log(self):\n        \"\"\"\n        Write log info\n        \"\"\"\n        logger.info(\"Writing config file %s\" % self.path)\n\n        if settings.DEBUG:\n            try:\n                old_content = open(self.path, 'r').readlines()\n            except IOError:\n                old_content = ''\n\n            new_content = self.contents().splitlines(True)\n            diff = difflib.unified_diff(old_content, new_content,\n                                        fromfile=self.path, tofile=self.path)\n            if diff:\n                logger.debug('Diff:\\n' + ''.join(diff))\n            else:\n                logger.debug('File not changed')"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef gp_rapp():\n  inDir, outDir = getWorkDirs()\n  # prepare data\n  yields = {}\n  for infile in os.listdir(inDir):\n    energy = re.compile('\\d+').search(infile).group()\n    medium = np.loadtxt(open(os.path.join(inDir, infile), 'rb'))\n    getMassRangesSums(energy, medium, yields)\n  data = dict( # sort by energy\n    (k, np.array(sorted(v)))\n    for k, v in yields.iteritems()\n  )\n  for k in data: data[k][:,1] /= data[k][-1,1] # divide by 200\n  # make plot\n  nSets = len(data)\n  make_plot(\n    data = [ data[k][:-1] for k in data ],\n    properties = [\n      'with linespoints lt 1 lw 4 ps 1.5 lc %s pt 18' % default_colors[i]\n      for i in xrange(nSets)\n    ],\n    titles = data.keys(), # TODO: titles order correct?\n    name = os.path.join(outDir, 'rapp'),\n    xlabel = '{/Symbol \\326}s_{NN} (GeV)', ylabel = 'Rapp Ratio to 200 GeV',\n    lmargin = 0.1, key = ['left'], yr = [0.1, 0.8]\n  )\n  return 'done'", "response": "plot rho in - medium ratios by Rapp"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef info(data, cols):\n\n    \"\"\"\n    Compute min/max for all registered columns.\n\n    Parameters\n    ----------\n    data : list\n        List of points from tile.\n    cols : list\n        List of columns from tile header.\n\n    Returns\n    -------\n    dict\n        {\n            column: {\n                min: value,\n                max: value\n            }\n        }\n    \"\"\"\n\n    stats = {c['name']: [] for c in cols}\n    for point in data:\n        for c, v in point.items():\n            stats[c].append(v)\n    return {n: {'min': min(v), 'max': max(v)} for n, v in stats.items()}", "response": "Compute min max for all registered columns."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngetting an info report for a tile. Format is same as input tile but with min/max values for values under 'data'.", "response": "def main():\n\n    \"\"\"\n    Get an info report for a tile.  Format is same as input tile but with\n    min/max values for values under 'data'.\n    \"\"\"\n\n    arguments = docopt(__doc__, version='tileinfo 0.1')\n\n    src_name = arguments['SOURCE']\n    src_format = arguments['--srcformat']\n    indent = arguments['--indent']\n    if isinstance(indent, str) and indent.lower() == 'none':\n        indent = None\n    elif isinstance(indent, str):\n        indent = int(indent)\n    else:\n        indent = 4\n\n    with sys.stdin if src_name in ('-', None) else open(src_name, 'rb') as f:\n\n        # Guess input format if not given\n        if src_format is None:\n            if '.json' == f.name[-5:]:\n                src_format = 'json'\n            else:\n                src_format = 'tile'\n\n        if src_format == 'tile':\n            header, data = Tile(f.read()).unpack()\n        else:\n            header = json.loads(f.read())\n            data = header.pop('data')\n\n        # Generate the info report\n        report = info(data, header['cols'])\n\n        # Merge report with other tile attributes\n        out = {k: v for k, v in header.items() if k != 'data'}\n        out['data'] = {}\n        for field, vals in report.items():\n            out['data'][field + '_min'] = vals['min']\n            out['data'][field + '_max'] = vals['max']\n\n        print(json.dumps(out, indent=indent, sort_keys=True))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef GetAmi(ec2, ami_spec):\n    images = ec2.get_all_images(owners=[ami_spec.owner_id] )\n    requested_image = None\n    for image in images:\n      if image.name == ami_spec.ami_name:\n        requested_image = image\n        break\n    return requested_image", "response": "Get the ami object given a AmiSpecification object."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef Run(self):\n    template_instance = None\n    res = self.ec2.get_all_instances( \\\n            filters={'tag-key': 'spec', \n                     'tag-value' : self.ami_spec.ami_name,\n                     'instance-state-name' : 'running'})    \n    if res:\n      running_template_instances = res[0].instances\n      if running_template_instances:\n        assert(len(running_template_instances) == 1)\n        template_instance = running_template_instances[0]    \n    # if there is not a currently running template instance, start one\n    if not template_instance:\n      template_instance = self.__CreateTemplateInstance()\n      template_instance.add_tag('spec', self.ami_spec.ami_name)\n    assert(template_instance)  \n    if self.ami_spec.role == 'workstation':\n      self.__ConfigureAsWorkstation(template_instance)\n    elif self.ami_spec.role == 'master':\n      self.__ConfigureAsClusterMaster(template_instance)\n    elif self.ami_spec.role == 'worker':\n      self.__ConfigureAsClusterWorker(template_instance)\n    else: \n      raise RuntimeError('unknown role: %s' % (self.ami_spec.role))        \n    \n    \n    \n    print 'Please login and perform any custom manipulations before '\\\n          'snapshot is made!'\n    \n    raw_input('Press any key to shutdown and begin creating AMI. '\\\n              '(or ctrl-c to quit and re-run config process).')\n    \n    self.__SecurityScrub(template_instance)\n    \n    ami_id = None\n    if self.ami_spec.root_store_type == 'ebs':  \n      ami_id = self.__CreateEbsAmi(template_instance)\n    else:\n      logging.info('Support for creating instance-store backed images has been'\n                   ' disabled in this version because it required much greater'\n                   ' complexity.')\n      ami_id = self.__CreateEbsAmi(template_instance)\n    \n    logging.info('ami id: %s' % (ami_id))\n    # TODO(heathkh): implement these features...\n    \n    #self.__SetImagePermissions(ami_id)\n    #self.__DistributeImageToAllRegions(ami_id)\n      \n    print 'terminating template instance'\n    self.ec2.terminate_instances(instance_ids=[template_instance.id])\n    core.WaitForInstanceTerminated(template_instance)    \n    return", "response": "Builds the Amazon Machine Image."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncopy from source directory to destination", "response": "def copytree(src, dst, symlinks=False, ignore=None):\n    \"\"\"Copy from source directory to destination\"\"\"\n\n    # TODO(crow): OSError: [Errno 17] File exists\n    if not osp.exists(dst):\n        os.makedirs(dst)\n    for item in os.listdir(src):\n        s = osp.join(src, item)\n        d = osp.join(dst, item)\n        if osp.isdir(s):\n            shutil.copytree(s, d, symlinks, ignore)\n        else:\n            shutil.copy2(s, d)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef emptytree(directory):\n\n    for p in os.listdir(directory):\n        fp = osp.join(directory, p)\n        if osp.isdir(fp):\n            try:\n                shutil.rmtree(fp)\n                logger.info(\"Delete directory %s\" % fp)\n            except Exception, e:\n                logger.error(\"Unable to delete directory %s: %s\" % (fp, str(e)))\n        elif osp.isfile(fp):\n            try:\n                logging.info(\"Delete file %s\" % fp)\n                os.remove(fp)\n            except Exception, e:\n                logger.error(\"Unable to delete file %s: %s\" % (fp, str(e)))\n        else:\n            logger.error(\"Unable to delete %s, unknown filetype\" % fp)", "response": "Delete all the files and dirs under specified directory"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef listdir_nohidden(path):\n    for f in os.listdir(path):\n        if isinstance(f, str):\n            f = unicode(f, \"utf-8\")\n        if not f.startswith('.'):\n            yield f", "response": "List not hidden files or directories under path"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef check_config(data):\n\n    is_right = True\n\n    if \"title\" not in data:\n        logging.error(\"No 'title' in _config.yml\")\n        is_right = False\n\n    return is_right", "response": "Check if metadata is right."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_ymal_data(data):\n    try:\n        format_data = yaml.load(data)\n    except yaml.YAMLError, e:\n        msg = \"Yaml format error: {}\".format(\n            unicode(str(e), \"utf-8\")\n        )\n        logging.error(msg)\n        sys.exit(1)\n\n    if not check_config(format_data):\n        sys.exit(1)\n\n    return format_data", "response": "Get metadata and validate them\n           "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef parse_markdown(markdown_content, site_settings):\n    markdown_extensions = set_markdown_extensions(site_settings)\n\n    html_content = markdown.markdown(\n        markdown_content,\n        extensions=markdown_extensions,\n    )\n\n    return html_content", "response": "Parse markdown text to html."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef send_message(chat_id, text,\n                 parse_mode=None, disable_web_page_preview=None, reply_to_message_id=None, reply_markup=None,\n                 **kwargs):\n    \"\"\"\n    Use this method to send text messages.\n\n    :param chat_id: Unique identifier for the message recipient \u2014 User or GroupChat id\n    :param text: Text of the message to be sent\n    :param parse_mode: Send ``\"Markdown\"``, if you want Telegram apps to show bold,\n                       italic and inline URLs in your bot's message.\n    :param disable_web_page_preview: Disables link previews for links in this message\n    :param reply_to_message_id: If the message is a reply, ID of the original message\n    :param reply_markup: Additional interface options. A JSON-serialized object for a\n                         custom reply keyboard, instructions to hide keyboard or to\n                         force a reply from the user.\n    :param \\*\\*kwargs: Args that get passed down to :class:`TelegramBotRPCRequest`\n\n    :type chat_id: int\n    :type text: str\n    :type disable_web_page_preview: bool\n    :type reply_to_message_id: int\n    :type reply_markup: :class:`ReplyKeyboardMarkup` or :class:`ReplyKeyboardHide` or :class:`ForceReply`\n\n    :returns: On success, the sent Message is returned.\n    :rtype: Message\n\n    \"\"\"\n    # required args\n    params = dict(chat_id=chat_id, text=text)\n\n    # optional args\n    params.update(\n        _clean_params(\n            parse_mode=parse_mode,\n            disable_web_page_preview=disable_web_page_preview,\n            reply_to_message_id=reply_to_message_id,\n            reply_markup=reply_markup\n        )\n    )\n\n    return TelegramBotRPCRequest('sendMessage', params=params, on_result=Message.from_result, **kwargs)", "response": "Use this method to send a message to a group chat."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nuse this method to forward a message to another chat.", "response": "def forward_message(chat_id, from_chat_id, message_id,\n                    **kwargs):\n    \"\"\"\n    Use this method to forward messages of any kind.\n\n    :param chat_id: Unique identifier for the message recipient \u2014 User or GroupChat id\n    :param from_chat_id: Unique identifier for the chat where the original message was sent \u2014 User or\n                         GroupChat id\n    :param message_id: Unique message identifier\n    :param \\*\\*kwargs: Args that get passed down to :class:`TelegramBotRPCRequest`\n\n    :type chat_id: int\n    :type from_chat_id: int\n    :type message_id: int\n\n    :returns: On success, the sent Message is returned.\n    :rtype: Message\n    \"\"\"\n\n    # required args\n    params = dict(\n        chat_id=chat_id,\n        from_chat_id=from_chat_id,\n        message_id=message_id\n    )\n\n    return TelegramBotRPCRequest('forwardMessage', params=params, on_result=Message.from_result, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nuse this method to send a single file or file to the Telegram servers.", "response": "def send_document(chat_id, document,\n                  reply_to_message_id=None, reply_markup=None,\n                  **kwargs):\n    \"\"\"\n    Use this method to send general files.\n\n    :param chat_id: Unique identifier for the message recipient \u2014 User or GroupChat id\n    :param document: File to send. You can either pass a file_id as String to resend a file that is already on\n                     the Telegram servers, or upload a new file using multipart/form-data.\n    :param reply_to_message_id: If the message is a reply, ID of the original message\n    :param reply_markup: Additional interface options. A JSON-serialized object for a custom reply keyboard,\n                         instructions to hide keyboard or to force a reply from the user.\n    :param \\*\\*kwargs: Args that get passed down to :class:`TelegramBotRPCRequest`\n\n    :type chat_id: int\n    :type document: InputFile or str\n    :type reply_to_message_id: int\n    :type reply_markup: ReplyKeyboardMarkup or ReplyKeyboardHide or ForceReply\n\n    :returns: On success, the sent Message is returned.\n    :rtype: TelegramBotRPCRequest\n    \"\"\"\n    files = None\n    if isinstance(document, InputFile):\n        files = [document]\n        document = None\n    elif not isinstance(document, str):\n        raise Exception('document must be instance of InputFile or str')\n\n    # required args\n    params = dict(\n        chat_id=chat_id,\n        document=document\n    )\n\n    # optional args\n    params.update(\n        _clean_params(\n            reply_to_message_id=reply_to_message_id,\n            reply_markup=reply_markup\n        )\n    )\n\n    return TelegramBotRPCRequest('sendDocument', params=params, files=files, on_result=Message.from_result, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef send_sticker(chat_id, sticker,\n                 reply_to_message_id=None, reply_markup=None,\n                 **kwargs):\n    \"\"\"\n    :param chat_id: Unique identifier for the message recipient \u2014 User or GroupChat id\n    :param sticker: Sticker to send. You can either pass a file_id as String to resend a sticker\n                    that is already on the Telegram servers, or upload a new sticker using multipart/form-data.\n    :param reply_to_message_id: If the message is a reply, ID of the original message\n    :param reply_markup: Additional interface options. A JSON-serialized object for a custom reply keyboard,\n                         instructions to hide keyboard or to force a reply from the user.\n    :param \\*\\*kwargs: Args that get passed down to :class:`TelegramBotRPCRequest`\n\n    :type chat_id: int\n    :type sticker: InputFile or str\n    :type reply_to_message_id: int\n    :type reply_markup: ReplyKeyboardMarkup or ReplyKeyboardHide or ForceReply\n\n    :returns: On success, the sent Message is returned.\n    :rtype: TelegramBotRPCRequest\n    \"\"\"\n    files = None\n    if isinstance(sticker, InputFile):\n        files = [sticker]\n        sticker = None\n    elif not isinstance(sticker, str):\n        raise Exception('sticker must be instance of InputFile or str')\n\n    # required args\n    params = dict(\n        chat_id=chat_id,\n        sticker=sticker\n    )\n\n    # optional args\n    params.update(\n        _clean_params(\n            reply_to_message_id=reply_to_message_id,\n            reply_markup=reply_markup\n        )\n    )\n\n    return TelegramBotRPCRequest('sendSticker', params=params, files=files, on_result=Message.from_result, **kwargs)", "response": "Use this method to send a new sticker to the chat."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nuses this method to send a video file to the Telegram servers.", "response": "def send_video(chat_id, video,\n               duration=None, caption=None, reply_to_message_id=None, reply_markup=None,\n               **kwargs):\n    \"\"\"\n    Use this method to send video files, Telegram clients support mp4 videos (other formats may be sent as Document).\n\n    :param chat_id: Unique identifier for the message recipient \u2014 User or GroupChat id\n    :param video: Video to send. You can either pass a file_id as String to resend a\n                  video that is already on the Telegram servers, or upload a new video\n                  using multipart/form-data.\n    :param duration: Duration of sent video in seconds\n    :param caption: Video caption (may also be used when resending videos by file_id)\n    :param reply_to_message_id: If the message is a reply, ID of the original message\n    :param reply_markup: Additional interface options. A JSON-serialized object for a\n                         custom reply keyboard, instructions to hide keyboard or to\n                         force a reply from the user.\n    :param \\*\\*kwargs: Args that get passed down to :class:`TelegramBotRPCRequest`\n\n    :type chat_id: int\n    :type video: InputFile or str\n    :type duration: int\n    :type caption: str\n    :type reply_to_message_id: int\n    :type reply_markup: ReplyKeyboardMarkup or ReplyKeyboardHide or ForceReply\n\n    :returns: On success, the sent Message is returned.\n    :rtype:  TelegramBotRPCRequest\n    \"\"\"\n    files = None\n    if isinstance(video, InputFile):\n        files = [video]\n        video = None\n    elif not isinstance(video, str):\n        raise Exception('video must be instance of InputFile or str')\n\n    # required args\n    params = dict(\n        chat_id=chat_id,\n        video=video\n    )\n\n    # optional args\n    params.update(\n        _clean_params(\n            duration=duration,\n            caption=caption,\n            reply_to_message_id=reply_to_message_id,\n            reply_markup=reply_markup\n        )\n    )\n\n    return TelegramBotRPCRequest('sendVideo', params=params, files=files, on_result=Message.from_result, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef send_location(chat_id, latitude, longitude,\n                  reply_to_message_id=None, reply_markup=None,\n                  **kwargs):\n    \"\"\"\n    Use this method to send point on the map.\n\n    :param chat_id: Unique identifier for the message recipient \u2014 User or GroupChat id\n    :param latitude: Latitude of location.\n    :param longitude: Longitude of location.\n    :param reply_to_message_id: If the message is a reply, ID of the original message\n    :param reply_markup: Additional interface options. A JSON-serialized object for a\n                         custom reply keyboard, instructions to hide keyboard or to\n                         force a reply from the user.\n    :param \\*\\*kwargs: Args that get passed down to :class:`TelegramBotRPCRequest`\n\n    :type chat_id: int\n    :type latitude: float\n    :type longitude: float\n    :type reply_to_message_id: int\n    :type reply_markup: ReplyKeyboardMarkup or ReplyKeyboardHide or ForceReply\n\n    :returns: On success, the sent Message is returned.\n    :rtype:  TelegramBotRPCRequest\n    \"\"\"\n\n    # required args\n    params = dict(\n        chat_id=chat_id,\n        latitude=latitude,\n        longitude=longitude\n    )\n\n    # optional args\n    params.update(\n        _clean_params(\n            reply_to_message_id=reply_to_message_id,\n            reply_markup=reply_markup\n        )\n    )\n\n    return TelegramBotRPCRequest('sendLocation', params=params, on_result=Message.from_result, **kwargs)", "response": "Use this method to send a location on the map."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef answer_inline_query(inline_query_id, results, cache_time=None, is_personal=None, next_offset=None, **kwargs):\n\n    json_results = []\n    for result in results:\n        json_results.append(dict((k, v) for k, v in result.__dict__.items() if v))  # Don't serialize None keys.\n\n    # required args\n    params = dict(\n        inline_query_id=inline_query_id,\n        results=json.dumps(json_results)\n    )\n\n    # optional args\n    params.update(\n        _clean_params(\n            cache_time=cache_time,\n            is_personal=is_personal,\n            next_offset=next_offset\n        )\n    )\n\n    return TelegramBotRPCRequest('answerInlineQuery', params=params, **kwargs)", "response": "Use this method to send answers to an inline query."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef wait(self):\n        self.thread.join()\n        if self.error is not None:\n            return self.error\n        return self.result", "response": "Wait for the request to finish and return the result or error when finished\n            is not None"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef filter_objects_by_section(self, rels, section):\n\n        subtree = section.get_descendants(include_self=True)\n        kwargs_list = [{'%s__in' % rel.field.name: subtree} for rel in rels]\n        q = Q(**kwargs_list[0])\n        for kwargs in kwargs_list[1:]:\n            q |= Q(**kwargs)\n        return self.get_manager(get_item_model_class()).filter(q).distinct()", "response": "Build a queryset containing all objects in the section subtree."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nexecuting a function on the content of two operands.", "response": "def exec(self, operand1, operand2):\n\t\t\"\"\"\n\t\tUses two operands and performs a function on their content.::\n\n\t\t\toperand1 = function(operand1, operand2)\n\t\t\"\"\"\n\t\tin1 = self.register_interface.read(operand1)\n\t\tin2 = self.register_interface.read(operand2)\n\t\tout = self.function(in1, in2)\n\t\tself.register_interface.write(operand2, out)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _fullqualname_function_py3(obj):\n\n    if hasattr(obj, \"__wrapped__\"):\n        # Required for decorator.__version__ <= 4.0.0.\n        qualname = obj.__wrapped__.__qualname__\n    else:\n        qualname = obj.__qualname__\n\n    return obj.__module__ + '.' + qualname", "response": "Fully qualified name for function objects in Python 3."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef fullqualname_py2(obj):\n\n    if type(obj).__name__ == 'builtin_function_or_method':\n\n        return _fullqualname_builtin_py2(obj)\n\n    elif type(obj).__name__ == 'function':\n\n        return obj.__module__ + '.' + obj.__name__\n\n    elif type(obj).__name__ in ['member_descriptor', 'method_descriptor',\n                                'wrapper_descriptor']:\n\n        return (obj.__objclass__.__module__ + '.' +\n                obj.__objclass__.__name__ + '.' +\n                obj.__name__)\n\n    elif type(obj).__name__ == 'instancemethod':\n\n        return _fullqualname_method_py2(obj)\n\n    elif type(obj).__name__ == 'method-wrapper':\n\n        return fullqualname_py2(obj.__self__) + '.' + obj.__name__\n\n    elif type(obj).__name__ == 'module':\n\n        return obj.__name__\n\n    elif inspect.isclass(obj):\n\n        return obj.__module__ + '.' + obj.__name__\n\n    return obj.__class__.__module__ + '.' + obj.__class__.__name__", "response": "Fully qualified name for objects in Python 2."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _fullqualname_builtin_py2(obj):\n\n    if obj.__self__ is None:\n        # built-in functions\n        module = obj.__module__\n        qualname = obj.__name__\n    else:\n        # built-in methods\n        if inspect.isclass(obj.__self__):\n            cls = obj.__self__\n        else:\n            cls = obj.__self__.__class__\n        module = cls.__module__\n        qualname = cls.__name__ + '.' + obj.__name__\n\n    return module + '.' + qualname", "response": "Fully qualified name for builtin_function_or_method objects\n    in Python 2."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _fullqualname_method_py2(obj):\n\n    if obj.__self__ is None:\n        # unbound methods\n        module = obj.im_class.__module__\n        cls = obj.im_class.__name__\n    else:\n        # bound methods\n        if inspect.isclass(obj.__self__):\n            # methods decorated with @classmethod\n            module = obj.__self__.__module__\n            cls = obj.__self__.__name__\n        else:\n            module = obj.__self__.__class__.__module__\n            cls = obj.__self__.__class__.__name__\n\n    return module + '.' + cls + '.' + obj.__func__.__name__", "response": "Fully qualified name for instancemethod objects in Python 2."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nturns a TAR file into a frozen sample.", "response": "def parse(binary, **params):\n    \"\"\"Turns a TAR file into a frozen sample.\"\"\"\n    binary = io.BytesIO(binary)\n    collection = list()\n    with tarfile.TarFile(fileobj=binary, mode='r') as tar:\n        for tar_info in tar.getmembers():\n            content_type, encoding = mimetypes.guess_type(tar_info.name)\n            content = tar.extractfile(tar_info)\n            content = content_encodings.get(encoding).decode(content)\n            content = content_types.get(content_type).parse(content, **params)\n            collection.apppend((tar_info.name, content))\n    return collection"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef format(collection, **params):\n    binary = io.BytesIO()\n    with tarfile.TarFile(fileobj=binary, mode='w') as tar:\n        mode = params.get('mode', 0o640)\n        now = calendar.timegm(datetime.datetime.utcnow().timetuple())\n        for filename, content in collection:\n            content_type, encoding = mimetypes.guess_type(filename)\n            content = content_types.get(content_type).format(content, **params)\n            content = content_encodings.get(encoding).encode(content)\n            member_content = io.BytesIO(content)\n            member_info = tarfile.TarInfo(filename)\n            member_info.size = len(content)\n            member_info.mode = mode\n            member_info.mtime = now\n            tar.addfile(member_info, member_content)\n    binary.seek(0)\n    return binary.read()", "response": "Truns a frozen sample into a TAR file."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nparsing a SAM alignment and returns a SamRead object representation of the alignment.", "response": "def parse_sam_read(sam):\n    \"\"\"\n    Parses a SAM alignment and returns a SamFile object.\n    \n    Parameters\n    ----------\n    sam : str or list\n        Either a tab delimited SAM string, or an already tokenized \n        list of SAM fields.\n    \n    Returns\n    -------\n    SamRead\n        a SamRead object representation of the SAM alignment.\n    \"\"\"\n    \n    if isinstance(sam, str):\n        sam = sam.strip().split('\\t')\n        \n    if not isinstance(sam, list):\n        return None\n    \n    qname = sam[0]\n    flag = int(sam[1])\n    rname = sam[2]\n    pos = int(sam[3])\n    mapq = int(sam[4])\n    cigar = sam[5]\n    rnext = sam[6]\n    pnext = int(sam[7])\n    tlen = int(sam[8])\n    seq = sam[9]\n    qual = sam[10]\n    \n    tags = sam[11:]\n    \n    read = SamRead(qname, flag, rname, pos, mapq, cigar, rnext, pnext, tlen, seq, qual, tags)\n    \n    return read"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef header(self):\n        \n        cmd = [self.__samtools, 'view', '-H', self.__bam]\n\n        stdout = subprocess.Popen(cmd, stdout=subprocess.PIPE).stdout\n\n        for l in stdout:\n            yield l.decode('utf-8').strip()\n\n        stdout.close()", "response": "Return the BAM header of the current BAM or SAM instance"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef count_reads(self, l):\n        \n        if self.__paired:\n            cmd = [self.__samtools, 'view', '-c', '-f', '3', self.__bam, l]\n        else:\n            cmd = [self.__samtools, 'view', '-c', '-F', '4', self.__bam, l]\n         \n        #print(' '.join(cmd))\n        stdout = subprocess.Popen(cmd, stdout=subprocess.PIPE).stdout\n        \n        ret = int(stdout.readline().decode('utf-8').strip())\n        \n        stdout.close()\n    \n        return ret", "response": "Count the number of reads on a particular genome in the bam file."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef find_packages(path: str) -> List[str]:\n    ret = []\n    for root, _dir, files in os.walk(path):\n        if '__init__.py' in files:\n            ret.append(root.replace(\"/\", \".\"))\n    return sorted(ret)", "response": "A better version of find_packages than what setuptools offers\n    This function needs to be deterministic."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef login_required(method):\n    def wrapper(self, *arg, **karg):\n        if not self.user:\n            if self.request.method == \"GET\":\n                self.redirect(settings.LOGIN_PATH)\n            else:\n                self.error(403)\n        else:\n            method(self, *arg, **karg)\n    return wrapper", "response": "A decorator that control if a user is logged in."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef put(obj_dict, conn=None, **kwargs):\n    if kwargs.get(\"verify\", False):\n        verify(obj_dict, Binary())\n    inserted = RBF.insert(obj_dict).run(conn)\n    return inserted", "response": "This function inserts a new object into the database"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef delete(filename, conn=None):\n    return RBF.filter((r.row[PRIMARY_FIELD] == filename) | (r.row[PARENT_FIELD] == filename)).delete().run(conn)", "response": "Delete a file\n    filename being a value in the id key"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nchanges of pointcut. value", "response": "def pointcut(self, value):\n        \"\"\"Change of pointcut.\n        \"\"\"\n\n        pointcut = getattr(self, Interceptor.POINTCUT)\n\n        # for all targets\n        for target in self.targets:\n            # unweave old advices\n            unweave(target, pointcut=pointcut, advices=self.intercepts)\n            # weave new advices with new pointcut\n            weave(target, pointcut=value, advices=self.intercepts)\n\n        # and save new pointcut\n        setattr(self, Interceptor._POINTCUT, value)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _bind_target(self, target, ctx=None, *args, **kwargs):\n\n        result = super(Interceptor, self)._bind_target(\n            target=target, ctx=ctx, *args, **kwargs\n        )\n\n        pointcut = getattr(self, Interceptor.POINTCUT)\n\n        weave(result, pointcut=pointcut, advices=self.intercepts, ctx=ctx)\n\n        return result", "response": "Weave self. intercepts among target advices with pointcut."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nself target interception if self is enabled otherwise proceed.", "response": "def intercepts(self, joinpoint):\n        \"\"\"Self target interception if self is enabled\n\n        :param joinpoint: advices executor\n        \"\"\"\n\n        result = None\n\n        if self.enable:\n\n            interception = getattr(self, Interceptor.INTERCEPTION)\n\n            joinpoint.exec_ctx[Interceptor.INTERCEPTION] = self\n\n            result = interception(joinpoint)\n\n        else:\n            result = joinpoint.proceed()\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets enable to True for all Dis or En annotated interceptors.", "response": "def set_enable(cls, target, enable=True):\n        \"\"\"(Dis|En)able annotated interceptors.\"\"\"\n\n        interceptors = cls.get_annotations(target)\n\n        for interceptor in interceptors:\n            setattr(interceptor, Interceptor.ENABLE, enable)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef jwt_get_secret_key(payload=None):\n    User = get_user_model()  # noqa\n    if api_settings.JWT_GET_USER_SECRET_KEY:\n        user = User.objects.get(pk=payload.get('user_id'))\n        key = str(api_settings.JWT_GET_USER_SECRET_KEY(user))\n        return key\n\n    return api_settings.JWT_SECRET_KEY", "response": "Get secret key for user"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef onepara(R):\n    import numpy as np\n    import warnings\n\n    d = R.shape[0]\n\n    if d < 2:\n        raise Exception((\n            \"More than one variable is required.\"\n            \"Supply at least a 2x2 matrix.\"))\n\n    # the explicit solution\n    x = (np.sum(R) + np.trace(R)) / (d**2 - d)\n\n    if x < (-1. / (d - 1)) or x > 1:\n        warnings.warn(\"No analytic solution found x={:.8f}\".format(x))\n        return None\n    else:\n        C = np.eye(d)\n        C[np.logical_not(C)] = x\n        return C", "response": "Converts an ill - conditioned correlation matrix into well - conditioned matrix with one common coefficient for all other resources."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_charset(html):\n    regex = r'charset=([a-zA-Z0-9-]+)?'\n    pattern = re.compile(regex, re.IGNORECASE)\n    if len(pattern.findall(html)) == 0:\n        return 'UTF-8'\n    return pattern.findall(html)[0]", "response": "get charset in html page"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _load_rules(self):\n        with self._sftp_connection.open(self.RULE_PATH) as file:\n            data = file.read()\n        lines = (\n            line.strip()\n            for line in data.split('\\n')\n        )\n        rule_strings = (\n            line for line in lines\n            if len(line) > 0\n        )\n        rules = (\n            Rule.parse(rule_string)\n            for rule_string in rule_strings\n        )\n        self._rules = [\n            rule\n            for rule in rules\n            if rule is not None\n        ]", "response": "Loads the rules from the SSH - Connection and sets self. _rules"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nexecutes the command and closes the handles afterwards.", "response": "def _exec_command(self, command: str):\n        \"\"\"\n        Executes the command and closes the handles\n        afterwards.\n        \"\"\"\n        stdin, stdout, stderr = self._ssh.exec_command(command)\n        # Clearing the buffers\n        stdout.read()\n        stderr.read()\n        stdin.close()"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef sync(self, rules: list):\n        self._reset()\n        old_rules = self.rules\n        to_delete_rules = [\n            rule for rule in old_rules\n            if rule not in rules\n        ]\n        new_rules = [\n            rule for rule in rules\n            if rule not in old_rules\n        ]\n\n        for new_rule in new_rules:\n            assert isinstance(new_rule, Rule)\n            self._exec_command(new_rule.add_command)\n        for to_delete_rule in to_delete_rules:\n            assert isinstance(to_delete_rule, Rule)\n            self._exec_command(\n                to_delete_rule.remove_command\n            )\n        self._update(rules)", "response": "Synchronizes the given rules with the server and ensures that there are no old rules active\n        which are not in the given list."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nupdates the given rules and stores them on the router.", "response": "def _update(self, rules: list):\n        \"\"\"\n        Updates the given rules and stores\n        them on the router.\n        \"\"\"\n        self._rules = rules\n        to_store = '\\n'.join(\n            rule.config_string\n            for rule in rules\n        )\n        sftp_connection = self._sftp_connection\n        with sftp_connection.open(self.RULE_PATH, mode='w') as file_handle:\n            file_handle.write(to_store)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef help(self, *args):\n        if args:\n            self.messages.error(\n                            self.messages.command_does_not_accept_arguments)\n        else:\n            print(self.helpfull)", "response": "Help for the current user."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ncomplete the command line and returns a list of possible matches for the current command line.", "response": "def complete(self, sp_args, line, rl_prefix, rl_begidx, rl_endidx):\n        \"\"\"\n        Override in order to have command or argument completion.\n\n        It is necessary to return a 'list', i.e. not a tuple or other\n        sequences.\n        \"\"\"\n        # TODO: Optionally check that flags are not repeated (i.e. exclude\n        #       them from the possible matches if they are already in the\n        #       command line)\n        # TODO: Support groups of mutually-exclusive flags, i.e. if one is\n        #       already present, the others in the group are not accepted\n        if len(sp_args) == 0 or not line.endswith(sp_args[-1]):\n            # if line.endswith(sp_args[-1]) is False, it means that the last\n            # sp_args is already complete\n            return self.accepted_flags\n        else:\n            matches = []\n            for arg in self.accepted_flags:\n                if arg.startswith(sp_args[-1]):\n                    matches.append(arg)\n            if len(matches) == 1:\n                # In general, SPLIT_ARGS and readline use different word\n                #  delimiters, see e.g. the docs for\n                #  readline.get_completer_delims()\n                # If for example there's a 'foo-bar' argument, SPLIT_ARGS sees\n                #  it as a single word, but readline by default will split it\n                #  in two words, 'foo' and 'bar', and if 'foo-b' is entered in\n                #  the command line, and Tab is pressed, the word will be\n                #  completed as 'foo-bfoo-bar', unless we compensate here by\n                #  subtracting the rl_prefix from the found match\n                sub = len(sp_args[-1]) - len(rl_prefix)\n                return [matches[0][sub:]]\n            else:\n                return matches"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef iter_walk_menus(self):\n        yield self\n        for item in self.name_to_command.values():\n            if isinstance(item, _Menu):\n                # \"Generator delegation\" ;)\n                # https://docs.python.org/3/whatsnew/3.3.html#pep-380\n                yield from item.iter_walk_menus()", "response": "Iterate over all menu items in the tree."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef local_address(self):\n        if not self._local_address:\n            self._local_address = self.proto.reader._transport.get_extra_info('sockname')\n            if len(self._local_address) == 4:\n                self._local_address = self._local_address[:2]\n        return self._local_address", "response": "Local endpoint address as a tuple."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef peer_address(self):\n        if not self._peer_address:\n            self._peer_address = self.proto.reader._transport.get_extra_info('peername')\n            if len(self._peer_address) == 4:\n                self._peer_address = self._peer_address[:2]\n        return self._peer_address", "response": "Return the peer endpoint address as a tuple."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ncreating switch function which return the status from specified named argument Parameters ---------- argument_name : string or None An argument name which is used to judge the status. If ``None`` is specified, the value of ``tolerance.utils.DEFAULT_ARGUMENT_NAME`` will be used instead. default : boolean A default value of this switch function. It is used when specifid ``**kwargs`` does not have named argument reverse : boolean Reverse the status (Default: ``False``) keep : boolean If it is ``True``, keep named argument in ``**kwargs``. Returns ------- function A switch function which return status, args, and kwargs respectively. Examples -------- >>> # >>> # generate switch function with default parameters >>> # >>> fn = argument_switch_generator('fail_silently') >>> # return `default` value and specified *args and **kwargs when >>> # `fail_silently` is not specified in **kwargs >>> fn() == (True, tuple(), {}) True >>> # return `fail_silently` value when it is specified >>> fn(fail_silently=True) == (True, tuple(), {}) True >>> fn(fail_silently=False) == (False, tuple(), {}) True >>> # >>> # generate switch function with `default=False` >>> # >>> fn = argument_switch_generator('fail_silently', default=False) >>> # return `default` value so `False` is returned back >>> fn() == (False, tuple(), {}) True >>> # >>> # generate switch function with `reverse=True` >>> # >>> fn = argument_switch_generator('fail_silently', reverse=True) >>> # `default` value is independent from `reverse=True` >>> fn() == (True, tuple(), {}) True >>> # `fail_silently` value is influenced by `reverse=True` >>> fn(fail_silently=True) == (False, tuple(), {}) True >>> fn(fail_silently=False) == (True, tuple(), {}) True >>> # >>> # generate switch function with `keep=True` >>> # >>> fn = argument_switch_generator('fail_silently', keep=True) >>> # `fail_silently` attribute remains even in returned back kwargs >>> status, args, kwargs = fn(fail_silently=True) >>> 'fail_silently' in kwargs True", "response": "def argument_switch_generator(argument_name=None,\n                              default=True,\n                              reverse=False,\n                              keep=False):\n    \"\"\"\n    Create switch function which return the status from specified named\n    argument\n\n    Parameters\n    ----------\n    argument_name : string or None\n        An argument name which is used to judge the status.\n        If ``None`` is specified, the value of\n        ``tolerance.utils.DEFAULT_ARGUMENT_NAME`` will be used instead.\n    default : boolean\n        A default value of this switch function.\n        It is used when specifid ``**kwargs`` does not have named argument\n    reverse : boolean\n        Reverse the status (Default: ``False``)\n    keep : boolean\n        If it is ``True``, keep named argument in ``**kwargs``.\n\n    Returns\n    -------\n    function\n        A switch function which return status, args, and kwargs respectively.\n\n    Examples\n    --------\n    >>> #\n    >>> # generate switch function with default parameters\n    >>> #\n    >>> fn = argument_switch_generator('fail_silently')\n    >>> # return `default` value and specified *args and **kwargs when\n    >>> # `fail_silently` is not specified in **kwargs\n    >>> fn() == (True, tuple(), {})\n    True\n    >>> # return `fail_silently` value when it is specified\n    >>> fn(fail_silently=True) == (True, tuple(), {})\n    True\n    >>> fn(fail_silently=False) == (False, tuple(), {})\n    True\n    >>> #\n    >>> # generate switch function with `default=False`\n    >>> #\n    >>> fn = argument_switch_generator('fail_silently', default=False)\n    >>> # return `default` value so `False` is returned back\n    >>> fn() == (False, tuple(), {})\n    True\n    >>> #\n    >>> # generate switch function with `reverse=True`\n    >>> #\n    >>> fn = argument_switch_generator('fail_silently', reverse=True)\n    >>> # `default` value is independent from `reverse=True`\n    >>> fn() == (True, tuple(), {})\n    True\n    >>> # `fail_silently` value is influenced by `reverse=True`\n    >>> fn(fail_silently=True) == (False, tuple(), {})\n    True\n    >>> fn(fail_silently=False) == (True, tuple(), {})\n    True\n    >>> #\n    >>> # generate switch function with `keep=True`\n    >>> #\n    >>> fn = argument_switch_generator('fail_silently', keep=True)\n    >>> # `fail_silently` attribute remains even in returned back kwargs\n    >>> status, args, kwargs = fn(fail_silently=True)\n    >>> 'fail_silently' in kwargs\n    True\n    \"\"\"\n    def switch_function(*args, **kwargs):\n        if argument_name in kwargs:\n            if keep:\n                status = kwargs.get(argument_name)\n            else:\n                status = kwargs.pop(argument_name)\n            if reverse:\n                status = not status\n        else:\n            status = default\n        return bool(status), args, kwargs\n    if argument_name is None:\n        argument_name = DEFAULT_ARGUMENT_NAME\n    return switch_function"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef priceItems(items):\n        retItems = []\n        sendItems = []\n        for item in items:\n            sendItems.append(item.name)\n        \n        resp = CodexAPI.searchMany(sendItems)\n        \n        for respItem in resp:\n            retItems[respItem['name']].price = respItem['price']\n            \n        return retItems", "response": "Takes a list of items and returns a list of Item objects with respective prices modified\n           \n        Returns a list of modified items"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef command_line():\n    '''\n    Parses users command line arguments and returns the namespace\n    containing parsed values.\n    '''\n    description = 'Kan helps you find the book'\n    version     = ' '.join([__version__, __release__])\n    parser      = ArgumentParser(prog='kan', description=description)\n\n    subparser   = parser.add_subparsers(help='Search by')\n\n    by_title    = subparser.add_parser('title', help='Book title',)\n    by_title.add_argument('title', help='Book name')\n\n    by_isbn     = subparser.add_parser('isbn', help='ISBN code')\n    by_isbn.add_argument('code', help='Valid ISBN code')\n\n    by_author   = subparser.add_parser('author', help='Book author')\n    by_author.add_argument('author', help='Authors name')\n    by_author.add_argument('--recent', help='Search by most recent', action='store_true')\n    by_author.add_argument('--top', help='Search by best selling', action='store_true')\n\n    # Main Parser\n    parser.add_argument(\n        '-v', '--version', action='version',\n        version=\"%s v%s\" % ('kan', version),\n    )\n    parser.add_argument(\n        '--title',\n        help='Title of the book',\n        metavar='name',\n    )\n    parser.add_argument(\n        '--author',\n        default=None,\n        metavar='name',\n        help='Name of the author',\n    )\n    parser.add_argument(\n        '--subject',\n        type=str,\n        help='Specify subject matter by category',\n        metavar='topic',\n    )\n    parser.add_argument(\n        '--max',\n        type=int,\n        metavar='n',\n        default=3,\n        choices=range(41),\n        help='Maximum results to get per query: default=3, max=40',\n    )\n    parser.add_argument(\n        '--language',\n        type=str,\n        metavar='code',\n        default='',\n        help='Restrict the search results to those with a certain language code',\n    )\n    parser.add_argument(\n        '--verbose',\n        action='store_true',\n        help='Print out debug information',\n    )\n\n    return parser.parse_args()", "response": "Parses the user command line arguments and returns the namespace containing parsed values."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nwrapping text after columns characters.", "response": "def _wrap(text, columns=80):\n    \"\"\"\n    Own \"dumb\" reimplementation of textwrap.wrap().\n\n    This is because calling .wrap() on bigger strings can take a LOT of\n    processor power. And I mean like 8 seconds of 3GHz CPU just to wrap 20kB of\n    text without spaces.\n\n    Args:\n        text (str): Text to wrap.\n        columns (int): Wrap after `columns` characters.\n\n    Returns:\n        str: Wrapped text.\n    \"\"\"\n    out = []\n    for cnt, char in enumerate(text):\n        out.append(char)\n\n        if (cnt + 1) % columns == 0:\n            out.append(\"\\n\")\n\n    return \"\".join(out)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef convert(input_format, output_format, b64_data):\n    # checks\n    assert input_format in INPUT_FORMATS, \"Unsupported input format!\"\n    assert output_format in OUTPUT_FORMATS, \"Unsupported output format!\"\n\n    with NTFile(mode=\"wb\", suffix=\".\" + input_format, dir=\"/tmp\") as ifile:\n        ofilename = ifile.name + \".\" + output_format\n\n        # save received data to the temporary file\n        ifile.write(b64decode(b64_data))\n        ifile.flush()\n\n        # free memory from base64 data\n        b64_data = None\n        gc.collect()\n\n        # convert file\n        protocol = \"\"\n        try:\n            with NTFile(mode=\"wb\", suffix = \".stdout\", dir=\"/tmp\") as stdout:\n                sh.ebook_convert(ifile.name, ofilename, _out=stdout).wait()\n                stdout.flush()\n                protocol = open(stdout.name).read()\n                stdout.close()\n        except sh.ErrorReturnCode_1, e:\n            raise UserWarning(\n                \"Conversion failed:\\n\" +\n                e.message.encode(\"utf-8\", errors='ignore')\n            )\n\n        if output_format.upper() + \" output written to\" not in protocol:\n            raise UserWarning(\"Conversion failed:\\n\" + protocol)\n\n        # read the data from the converted file\n        output_data = None\n        with open(ofilename, \"rb\") as ofile:\n            output_data = _wrap(\n                b64encode(ofile.read())\n            )\n        gc.collect()  # we have experienced unplesant memory spikes\n\n        # remove temporary output file\n        os.remove(ofilename)\n\n        return ConversionResponse(\n            format=output_format,\n            b64_data=output_data,\n            protocol=protocol\n        )", "response": "Convert b64_data to input_format and output_format."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nsends a simple text message.", "response": "def send_sms(self, frm, to, text):\n        \"\"\"Sends a simple text message.\n\n        Example usage::\n\n            >>> msg = \"Cherie, n'oublie pas les gauffres !\"\n            >>> nexmo.send_sms('+33123456780', '+33987654321', msg)\n\n        :arg frm: The `from` field, a phone number (international format with\n            or without a leading \"+\" or alphanumerical).\n        :arg to: The `to` field, a phone number, same format as the `frm`\n            argument.\n        :arg text: The message body.\n\n        See :meth:`send_request` for return value and exceptions.\n\n        \"\"\"\n        frm = re.sub('[^\\d]', '', frm)\n        to = re.sub('[^\\d]', '', to)\n\n        api_url = '%s/sms/json' % API_ENDPOINT\n        params = {\n            'api_key': self.api_key,\n            'api_secret': self.api_secret,\n            'from': frm,\n            'to': to,\n            'text': text,\n        }\n        return self.send_request(api_url, params, method='POST')"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsend a raw request to the given api endpoint.", "response": "def send_request(self, url, params, method='GET'):\n        \"\"\"Sends a raw request to the given api endpoint.\n\n        :arg url: A Nexmpo api endpoint (json only)\n        :arg params: A parameter dictionnary\n\n        Returns a :class:`~libnexmo.NexmoResponse`.\n\n        Raises:\n\n            The library uses `Requests\n            <http://docs.python-requests.org/en/latest/>`_ to perform http\n            requests. `Requests exceptions\n            <http://docs.python-requests.org/en/latest/api/#requests.exceptions.RequestException>`_\n            won't be caught in case of connection error.\n\n            Any :class:`~libnexmo.exceptions.NexmoError` subclass.\n\n        \"\"\"\n        method = method.lower()\n\n        if method not in ['get', 'post']:\n            raise ValueError('The `method` parameter must be either `get` or `post`')\n\n        response = requests.request(method, url, data=params)\n        response_json = response.json()\n        status = int(response_json['messages'][0]['status'])\n\n        if status != 0:\n            ErrorClass = status_to_error(status)\n            error = response_json['messages'][0]['error-text']\n            raise ErrorClass(error)\n\n        return NexmoResponse(response_json)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef normalise(string):\n\tstring = unicodedata.normalize('NFD', string)\n\n\tfor char_c in ipa.get_precomposed_chars():\n\t\tchar_d = unicodedata.normalize('NFD', char_c)\n\t\tif char_d in string:\n\t\t\tstring = string.replace(char_d, char_c)\n\n\treturn string", "response": "normalise the string according to the IPA spec."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngrouping together the tokens for which the merge function returns true.", "response": "def group(merge_func, tokens):\n\t\"\"\"\n\tGroup together those of the tokens for which the merge function returns\n\ttrue. The merge function should accept two arguments/tokens and should\n\treturn a boolean indicating whether the strings should be merged or not.\n\n\tHelper for tokenise(string, ..).\n\t\"\"\"\n\toutput = []\n\n\tif tokens:\n\t\toutput.append(tokens[0])\n\n\t\tfor token in tokens[1:]:\n\t\t\tprev_token = output[-1]\n\n\t\t\tif merge_func(prev_token, token):\n\t\t\t\toutput[-1] += token\n\t\t\telse:\n\t\t\t\toutput.append(token)\n\n\treturn output"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef are_diphtong(tokenA, tokenB):\n\tis_short = lambda token: '\u25cc\u032f'[1] in token\n\tsubtokens = []\n\n\tfor char in tokenA+tokenB:\n\t\tif ipa.is_vowel(char):\n\t\t\tsubtokens.append(char)\n\t\telif ipa.is_diacritic(char) or ipa.is_length(char):\n\t\t\tif subtokens:\n\t\t\t\tsubtokens[-1] += char\n\t\t\telse:\n\t\t\t\tbreak\n\t\telse:\n\t\t\tbreak\n\telse:\n\t\tif len([x for x in subtokens if not is_short(x)]) < 2:\n\t\t\treturn True\n\n\treturn False", "response": "This function checks whether two tokens form a diphtong."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef tokenise_word(string,\n\t\t\t\t\tstrict=False, replace=False, tones=False, unknown=False):\n\t\"\"\"\n\tTokenise the string into a list of tokens or raise ValueError if it cannot\n\tbe tokenised (relatively) unambiguously. The string should not include\n\twhitespace, i.e. it is assumed to be a single word.\n\n\tIf strict=False, allow non-standard letters and diacritics, as well as\n\tinitial diacritic-only tokens (e.g. pre-aspiration). If replace=True,\n\treplace some common non-IPA symbols with their IPA counterparts. If\n\ttones=False, ignore tone symbols. If unknown=False, ignore symbols that\n\tcannot be classified into a relevant category.\n\n\tHelper for tokenise(string, ..).\n\t\"\"\"\n\tstring = normalise(string)\n\n\tif replace:\n\t\tstring = ipa.replace_substitutes(string)\n\n\ttokens = []\n\n\tfor index, char in enumerate(string):\n\t\tif ipa.is_letter(char, strict):\n\t\t\tif tokens and ipa.is_tie_bar(string[index-1]):\n\t\t\t\ttokens[-1] += char\n\t\t\telse:\n\t\t\t\ttokens.append(char)\n\n\t\telif ipa.is_tie_bar(char):\n\t\t\tif not tokens:\n\t\t\t\traise ValueError('The string starts with a tie bar: {}'.format(string))\n\t\t\ttokens[-1] += char\n\n\t\telif ipa.is_diacritic(char, strict) or ipa.is_length(char):\n\t\t\tif tokens:\n\t\t\t\ttokens[-1] += char\n\t\t\telse:\n\t\t\t\tif strict:\n\t\t\t\t\traise ValueError('The string starts with a diacritic: {}'.format(string))\n\t\t\t\telse:\n\t\t\t\t\ttokens.append(char)\n\n\t\telif tones and ipa.is_tone(char, strict):\n\t\t\tif unicodedata.combining(char):\n\t\t\t\tif not tokens:\n\t\t\t\t\traise ValueError('The string starts with an accent mark: {}'.format(string))\n\t\t\t\ttokens[-1] += char\n\t\t\telif tokens and ipa.is_tone(tokens[-1][-1], strict):\n\t\t\t\ttokens[-1] += char\n\t\t\telse:\n\t\t\t\ttokens.append(char)\n\n\t\telif ipa.is_suprasegmental(char, strict):\n\t\t\tpass\n\n\t\telse:\n\t\t\tif strict:\n\t\t\t\traise ValueError('Unrecognised char: {} ({})'.format(char, unicodedata.name(char)))\n\t\t\telif unknown:\n\t\t\t\ttokens.append(char)\n\t\t\telse:\n\t\t\t\tpass\n\n\treturn tokens", "response": "Tokenise a string into a list of tokens or raise ValueError."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreplaces the digits 1 - 5 with Chao tone letters.", "response": "def replace_digits_with_chao(string, inverse=False):\n\t\"\"\"\n\tReplace the digits 1-5 (also in superscript) with Chao tone letters. Equal\n\tconsecutive digits are collapsed into a single Chao letter.\n\n\tIf inverse=True, smaller digits are converted into higher tones; otherwise,\n\tthey are converted into lower tones (the default).\n\n\tPart of ipatok's public API.\n\t\"\"\"\n\tchao_letters = '\u02e9\u02e8\u02e7\u02e6\u02e5'\n\n\tif inverse:\n\t\tchao_letters = chao_letters[::-1]\n\n\tstring = string.translate(str.maketrans('\u00b9\u00b2\u00b3\u2074\u2075', '12345'))\n\tstring = string.translate(str.maketrans('12345', chao_letters))\n\n\tstring = ''.join([\n\t\tchar for index, char in enumerate(string)\n\t\tif not (index and char in chao_letters and string[index-1] == char)])\n\n\treturn string"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef verify_server_core(timeout=120, start_delay=90):\n    ''' checks to see if the server_core is running\n\n        args:\n            delay: will cycle till core is up.\n            timeout: number of seconds to wait\n    '''\n    timestamp = time.time()\n    last_check = time.time() + start_delay - 10\n    last_delay_notification = time.time() - 10\n    server_down = True\n    return_val = False\n    timeout += 1\n    # loop until the server is up or the timeout is reached\n    while((time.time()-timestamp) < timeout) and server_down:\n        # if delaying, the start of the check, print waiting to start\n        if start_delay > 0 and time.time() - timestamp < start_delay \\\n                and (time.time()-last_delay_notification) > 5:\n            print(\"Delaying server status check until %ss. Current time: %ss\" \\\n                    % (start_delay, int(time.time() - timestamp)))\n            last_delay_notification = time.time()\n        # send a request check every 10s until the server is up\n        while ((time.time()-last_check) > 10) and server_down:\n            print(\"Checking status of servers at %ss\" % \\\n                    int((time.time()-timestamp)))\n            last_check = time.time()\n            try:\n                repo = requests.get(CFG.REPOSITORY_URL)\n                repo_code = repo.status_code\n                print (\"\\t\", CFG.REPOSITORY_URL, \" - \", repo_code)\n            except:\n                repo_code = 400\n                print (\"\\t\", CFG.REPOSITORY_URL, \" - DOWN\")\n            try:\n                triple = requests.get(CFG.DATA_TRIPLESTORE.url)\n                triple_code = triple.status_code\n                print (\"\\t\", CFG.DATA_TRIPLESTORE.url, \" - \", triple_code)\n            except:\n                triple_code = 400\n                print (\"\\t\", CFG.DATA_TRIPLESTORE.url, \" - down\")\n            if repo_code == 200 and triple_code == 200:\n                server_down = False\n                return_val = True\n                print(\"**** Servers up at %ss\" % \\\n                    int((time.time()-timestamp)))\n                break\n    return return_val", "response": "checks to see if the server core is up and if it is down"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nload an rml mapping into memory", "response": "def load_rml(self, rml_name):\n        \"\"\" loads an rml mapping into memory\n\n        args:\n            rml_name(str): the name of the rml file\n        \"\"\"\n        conn = CFG.rml_tstore\n        cache_path = os.path.join(CFG.CACHE_DATA_PATH, 'rml_files', rml_name)\n        if not os.path.exists(cache_path):\n            results = get_graph(NSM.uri(getattr(NSM.kdr, rml_name), False),\n                                conn)\n            with open(cache_path, \"w\") as file_obj:\n                file_obj.write(json.dumps(results, indent=4))\n        else:\n            results = json.loads(open(cache_path).read())\n        self.rml[rml_name] = RdfDataset(results)\n        return self.rml[rml_name]"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nreturning the rml mapping for the specified rml_name", "response": "def get_rml(self, rml_name):\n        \"\"\" returns the rml mapping RdfDataset\n\n        rml_name(str): Name of the rml mapping to retrieve\n        \"\"\"\n\n        try:\n            return getattr(self, rml_name)\n        except AttributeError:\n            return self.load_rml(rml_name)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nload the RDF data into the triplestore", "response": "def _load_data(self, reset=False):\n        ''' loads the RDF/turtle application data to the triplestore\n\n        args:\n            reset(bool): True will delete the definition dataset and reload\n                    all of the datafiles.\n        '''\n\n        log = logging.getLogger(\"%s.%s\" % (self.log_name,\n                                           inspect.stack()[0][3]))\n        log.setLevel(self.log_level)\n        for attr, obj in self.datafile_obj.items():\n            if reset or obj['latest_mod'] > obj['last_json_mod']:\n                conn = obj['conn']\n                sparql = \"DROP ALL;\"\n                if os.path.isdir(obj['cache_path']):\n                    shutil.rmtree(obj['cache_path'], ignore_errors=True)\n                os.makedirs(obj['cache_path'])\n                drop_extensions = conn.update_query(sparql)\n                rdf_resource_templates = []\n                rdf_data = []\n                for path, files in obj['files'].items():\n                    for file in files:\n                        file_path = os.path.join(path, file)\n                        # data = open(file_path).read()\n                        # log.info(\" uploading file: %s | namespace: %s\",\n                        #          file,\n                        #          conn.namespace)\n                        # data_type = file.split('.')[-1]\n                        result = conn.load_data(file_path,\n                                                #datatype=data_type,\n                                                graph=str(getattr(NSM.kdr,\n                                                                  file)),\n                                                is_file=True)\n                        if result.status_code > 399:\n                            raise ValueError(\"Cannot load '{}' into {}\".format(\n                                file_name, conn))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsetting the data files in the data file list", "response": "def _set_data_filelist(self,\n                           start_path,\n                           attr_name,\n                           conn,\n                           file_exts=[],\n                           dir_filter=set()):\n        ''' does a directory search for data files '''\n\n        def filter_path(filter_terms, dir_path):\n            \"\"\" sees if any of the terms are present in the path if so returns\n                True\n\n            args:\n                filter_terms(list): terms to check\n                dir_path: the path of the directory\n            \"\"\"\n            if filter_terms.intersection(set(dir_path.split(os.path.sep))):\n                return True\n            else:\n                return False\n\n        data_obj = {}\n        files_dict = {}\n        latest_mod = 0\n        dir_filter = set(dir_filter)\n        for root, dirnames, filenames in os.walk(start_path):\n            if not dir_filter or filter_path(dir_filter, root):\n                if file_exts:\n                    filenames = [x for x in filenames\n                                 if x.split('.')[-1].lower() in file_exts]\n                files_dict[root] = filenames\n                for def_file in filenames:\n                    file_mod = os.path.getmtime(os.path.join(root,def_file))\n                    if file_mod > latest_mod:\n                        latest_mod = file_mod\n        data_obj['latest_mod'] = latest_mod\n        data_obj['files'] = files_dict\n        json_mod = 0\n        cache_path = os.path.join(CFG.CACHE_DATA_PATH, attr_name)\n        if cache_path:\n            for root, dirnames, filenames in os.walk(cache_path):\n                for json_file in filenames:\n                    file_mod = os.path.getmtime(os.path.join(root,json_file))\n                    if file_mod > json_mod:\n                        json_mod = file_mod\n        data_obj['last_json_mod'] = json_mod\n        data_obj['conn'] = conn\n        data_obj['cache_path'] = cache_path\n        self.datafile_obj[attr_name] = data_obj"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn a two - tuple of User and Token if a valid signature has been passed.", "response": "def authenticate(self, request):\n        \"\"\"\n        Returns a two-tuple of `User` and token if a valid signature has been\n        supplied using JWT-based authentication.  Otherwise returns `None`.\n        \"\"\"\n        jwt_value = self.get_jwt_value(request)\n        if jwt_value is None:\n            return None\n\n        try:\n            payload = jwt_decode_handler(jwt_value)\n        except jwt.ExpiredSignature:\n            msg = _('Signature has expired.')\n            raise exceptions.AuthenticationFailed(msg)\n        except jwt.DecodeError:\n            msg = _('Error decoding signature.')\n            raise exceptions.AuthenticationFailed(msg)\n        except jwt.InvalidTokenError:\n            raise exceptions.AuthenticationFailed()\n\n        user = self.authenticate_credentials(payload)\n\n        return (user, jwt_value)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn an active user that matches the payload s user id and email.", "response": "def authenticate_credentials(self, payload):\n        \"\"\"\n        Returns an active user that matches the payload's user id and email.\n        \"\"\"\n        User = get_user_model()  # noqa\n        username = jwt_get_username_from_payload_handler(payload)\n\n        if not username:\n            msg = _('Invalid payload.')\n            raise exceptions.AuthenticationFailed(msg)\n\n        try:\n            user = User.objects.get(email=username)\n        except User.DoesNotExist:\n            msg = _('Invalid signature.')\n            raise exceptions.AuthenticationFailed(msg)\n\n        return user"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nconverts an integer value to ASCII hex.", "response": "def to_ascii_hex(value: int, digits: int) -> str:\n    \"\"\"Converts an int value to ASCII hex, as used by LifeSOS.\n       Unlike regular hex, it uses the first 6 characters that follow\n       numerics on the ASCII table instead of A - F.\"\"\"\n    if digits < 1:\n        return ''\n    text = ''\n    for _ in range(0, digits):\n        text = chr(ord('0') + (value % 0x10)) + text\n        value //= 0x10\n    return text"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef from_ascii_hex(text: str) -> int:\n    value = 0\n    for index in range(0, len(text)):\n        char_ord = ord(text[index:index + 1])\n        if char_ord in range(ord('0'), ord('?') + 1):\n            digit = char_ord - ord('0')\n        elif char_ord in range(ord('a'), ord('f') + 1):\n            digit = 0xa + (char_ord - ord('a'))\n        else:\n            raise ValueError(\n                \"Response contains invalid character.\")\n        value = (value * 0x10) + digit\n    return value", "response": "Converts text from both ASCII and regular hex to an integer value."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef serializable(obj: Any, on_filter: Callable[[Any, str], bool] = None) -> Any:\n\n    # Will be called recursively when object has children\n    def _serializable(parent_obj: Any, obj: Any,\n                      on_filter: Callable[[Any, str], bool]) -> Any:\n        # None can be left as-is\n        if obj is None:\n            return obj\n\n        # IntFlag enums should be broken down to a list of names\n        elif isinstance(obj, IntFlag):\n            value = str(obj)\n            if value == '0':\n                return None\n            return value.split('|')\n\n        # Any other enum just use the name\n        elif isinstance(obj, Enum):\n            return str(obj)\n\n        # Simple types can be left as-is\n        elif isinstance(obj, (bool, int, float, str)):\n            return obj\n\n        # Class supports method to convert to serializable dictionary; use it\n        elif hasattr(obj, 'as_dict') and parent_obj is not None:\n            return obj.as_dict()\n\n        elif isinstance(obj, dict):\n            # Dictionaries will require us to check each key and value\n            new_dict = {}\n            for item in obj.items():\n                new_dict[_serializable(obj, item[0], on_filter=on_filter)] = \\\n                    _serializable(obj, item[1], on_filter=on_filter)\n            return new_dict\n\n        elif isinstance(obj, (list, Container)):\n            # Lists will require us to check each item\n            items = obj # type: Iterable\n            new_list = []\n            for item in items:\n                new_list.append(_serializable(obj, item, on_filter=on_filter))\n            return new_list\n\n        # Convert to a dictionary of property name/values\n        data = {}\n        for name in dir(obj.__class__):\n            if not isinstance(getattr(obj.__class__, name), property):\n                continue\n            elif on_filter and not on_filter(obj, name):\n                continue\n            value = getattr(obj, name)\n            data[name] = _serializable(obj, value, on_filter=on_filter)\n        return data\n\n    return _serializable(None, obj, on_filter)", "response": "Ensures the specified object is serializable."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef encode_value_using_ma(message_attribute: int, value: Optional[Union[int, float]]) -> int:\n    if message_attribute == MA_TX3AC_100A:\n        # TX-3AC in 100A mode; use value as-is, with 0xFE indicating null\n        if value is None:\n            return 0xfe\n        return int(value)\n    elif message_attribute == MA_TX3AC_10A:\n        # TX-3AC in 10A mode; shift decimal point, with 0xFE indicating null\n        if value is None:\n            return 0xfe\n        return int(value * 10)\n    else:\n        # Signed byte, with 0x80 indicating null\n        if value is None:\n            return 0x80\n        elif value < 0:\n            return 0x100 + int(value)\n        return int(value)", "response": "Encode special sensor value using the message attribute."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nset the default interface that PyAMF will use to deal with XML entities.", "response": "def set_default_interface(etree):\n    \"\"\"\n    Sets the default interface that PyAMF will use to deal with XML entities\n    (both objects and blobs).\n    \"\"\"\n    global types, ET, modules\n\n    t = _get_etree_type(etree)\n\n    _types = set(types or [])\n    _types.update([t])\n\n    types = tuple(_types)\n\n    modules[t] = etree\n\n    old, ET = ET, etree\n\n    return old"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef find_libs():\n    from pyamf.util import get_module\n\n    types = []\n    mapping = {}\n\n    for mod in ETREE_MODULES:\n        try:\n            etree = get_module(mod)\n        except ImportError:\n            continue\n\n        t = _get_etree_type(etree)\n\n        types.append(t)\n        mapping[t] = etree\n\n    return tuple(types), mapping", "response": "Find C { ElementTree } implementations so that any type can be encoded."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef tostring(element, *args, **kwargs):\n    global modules\n\n    _bootstrap()\n    t = _get_type(element)\n\n    etree = modules.get(t, None)\n\n    if not etree:\n        raise RuntimeError('Unable to find the etree implementation related '\n            'to %r (type %r)' % (element, t))\n\n    return etree.tostring(element, *args, **kwargs)", "response": "Convert an element to a string."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef validate_url(url):\n    schemes = ['http', 'https']\n    netloc_re = re.compile(\n        r'^'\n        r'(?:\\S+(?::\\S*)?@)?'  # user:pass auth\n        r'(?:[a-z0-9]|[a-z0-9][a-z0-9\\-]{0,61}[a-z0-9])'\n        r'(?:\\.(?:[a-z0-9]|[a-z0-9][a-z0-9\\-]{0,61}[a-z0-9]))*'  # host\n        r'(?::[0-9]{2,5})?'  # port\n        r'$', re.IGNORECASE\n    )\n\n    try:\n        scheme, netloc, path, query, fragment = urlsplit(url)\n    except ValueError:\n        raise Invalid('Invalid URL')\n\n    if scheme not in schemes:\n        raise Invalid('Missing URL scheme')\n\n    if not netloc_re.search(netloc):\n        raise Invalid('Invalid URL')\n\n    return url", "response": "Validate URL is valid\n   "}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nvalidating the given reference links data structure.", "response": "def validate_reference_links(reference_links):\n    \"\"\"\n    Vaidate reference links data structure\n\n    Expected data structure:\n        {\n            \"links\": {\n                id_type1: url1,\n                id_type2: url2\n            },\n            \"redirect_id_type\": id_type1 | id1_type2\n        }\n\n    where links is an optional key but must be a dictionary with id types to\n    URLs if it exists, and redirect_id_type is optional but if it exists,\n    it must point to one of the existing id types in the links object. It is\n    used to set a default redirect URL that is used by the resolution service.\n    \"\"\"\n    allowed_keys = ['links', 'redirect_id_type']\n\n    if not isinstance(reference_links, dict):\n        raise Invalid('Expected reference_links to be an object')\n\n    if 'links' in reference_links and not isinstance(reference_links['links'], dict):\n        raise Invalid('Expected links in reference_links to be an object')\n\n    links = reference_links.get('links', {})\n    redirect_id_type = reference_links.get('redirect_id_type')\n\n    for key in reference_links:\n        if key not in allowed_keys:\n            raise Invalid('Key {} is not allowed'.format(key))\n\n    if redirect_id_type and redirect_id_type not in links:\n        raise Invalid('Redirect ID type must point to one of the links\\' ID types')\n\n    [validate_url(url) for url in links.values()]\n\n    return reference_links"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nvalidate a state string", "response": "def _validate_state(state, valid_states):\n    \"\"\"Validate a state string\"\"\"\n    if state in State:\n        return state.name\n    elif state in valid_states:\n        return state\n    else:\n        raise Invalid('Invalid state')"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncheck if an object is filelike.", "response": "def is_filelike(ob):\n    \"\"\"Check for filelikeness of an object.\n\n    Needed to distinguish it from file names.\n    Returns true if it has a read or a write method.\n    \"\"\"\n    if hasattr(ob, 'read') and callable(ob.read):\n        return True\n\n    if hasattr(ob, 'write') and callable(ob.write):\n        return True\n\n    return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef parse_args(args=None):\n    # The argparse module provides a nice abstraction for argument parsing.\n    # It automatically builds up the help text, too.\n    parser = argparse.ArgumentParser(\n            prog=__package__,\n            description='Make substitutions in text files.',\n        )\n    parser.add_argument('-V', '--version',\n                        action='version',\n                        version=\"%%(prog)s %s\" % (__version__,),\n                        )\n\n    group = parser.add_argument_group(\"Engine\")\n    group.add_argument('-e', '--engine',\n                       dest='engine',\n                       default='string.Template',\n                       help=\"templating engine\",\n                       metavar=\"ENGINE\",\n                       )\n    group.add_argument('-t', '--tolerant',\n                       action='store_true',\n                       dest='tolerant',\n                       help=\"don't fail on missing names\",\n                       )\n\n    group = parser.add_argument_group(\"Output\")\n    group.add_argument('-s', '--stdout',\n                       action='append_const',\n                       dest='outfiles',\n                       const=sys.stdout,\n                       help=\"use standard output\",\n                       )\n    group.add_argument('-o', '--outfile',\n                       action='append',\n                       dest='outfiles',\n                       help=\"output file\",\n                       metavar=\"FILE\",\n                       )\n    group.add_argument('--vary',\n                       action='store_true',\n                       dest='vary',\n                       help=\"vary output file name according to template\",\n                       )\n    group.add_argument('-r', '--read-old',\n                       action='store_true',\n                       dest='read_old',\n                       help=\"read preexisting output files and\"\n                            \"hand the respective content to the template\",\n                       )\n    group.add_argument('-d', '--delete-empty',\n                       action='store_true',\n                       dest='delete_empty',\n                       help=\"delete file if output is empty\",\n                       )\n\n    group = parser.add_argument_group(\"Input\")\n    group.add_argument('--stdin',\n                       action='append_const',\n                       dest='infiles',\n                       const=sys.stdin,\n                       help=\"use standard input\",\n                       )\n    group.add_argument('-i', '--infile',\n                       action='append',\n                       dest='infiles',\n                       help=\"any number of input files\",\n                       metavar=\"FILE\",\n                       )\n    group.add_argument('-c', '--concatenate',\n                       action='store_true',\n                       dest='concatenate',\n                       help=\"concatenate multiple input files into one output\",\n                       )\n\n    group = parser.add_argument_group(\"Name-value pairs\")\n    group.add_argument('-a', '--arg',\n                       action='append',\n                       dest='args',\n                       help=\"any number of name-value pairs\",\n                       metavar=\"NAME=VALUE\",\n                       )\n    group.add_argument('-p', '--pyarg',\n                       action='append',\n                       dest='args',\n                       type=_PyArg,\n                       help=\"evaluate a python expression\",\n                       metavar=\"NAME=EXPRESSION\",\n                       )\n    group.add_argument('-n', '--next',\n                       action='append_const',\n                       dest='args',\n                       const='--',\n                       help=\"begin next argument group\",\n                       )\n\n    parser.add_argument(\n                        dest='remainder',\n                        nargs=argparse.REMAINDER,\n                        help=\"possible input files and name-value pair groups \"\n                             \"if not already specified through options\",\n                        )\n\n    args = parser.parse_args(args)\n\n    if args.engine == 'help':\n        dump_engines()\n        parser.exit(0)\n\n    if args.engine not in engines.engines:\n        parser.error(\"Engine '%s' is not available.\" % (args.engine,))\n\n    if args.vary:\n        if len(args.outfiles) != 1:\n            parser.error(\"need exactly one output file template\")\n        if is_filelike(args.outfiles[0]):\n            parser.error(\"vary requires an output file template\")\n    elif not args.outfiles:\n        args.outfiles = [sys.stdout]\n\n    if not args.infiles:\n        if args.args:\n            infiles = args.remainder\n            args.remainder = []\n            try:\n                infiles.remove('--')\n            except ValueError:\n                pass\n        else:\n            first = 1 if args.remainder and args.remainder[0] == '--' else 0\n            last = (len(args.remainder)\n                    if args.vary or args.concatenate\n                    else first + 1)\n            for split, infile in enumerate(args.remainder[first:last], first):\n                if infile == '--' or '=' in infile:\n                    break\n            else:\n                split = last\n\n            infiles = args.remainder[first:split]\n            args.remainder = args.remainder[split:]\n\n        args.infiles = [path if path != '-' else sys.stdin\n                        for path in infiles] if infiles else [sys.stdin]\n\n    if args.args:\n        flat_args = args.args\n    else:\n        flat_args = args.remainder\n        args.remainder = []\n        if flat_args and flat_args[0] == '--':\n            flat_args = flat_args[1:]\n\n    args.args = []\n    mapping = {}\n    for arg in flat_args:\n        if isinstance(arg, _PyArg):\n            name_value = arg.split('=', 1)\n            mapping[name_value[0]] = eval(name_value[1], {}, mapping)\n        elif arg == '--':\n            args.args.append(mapping)\n            mapping = {}\n        else:\n            name_value = arg.split('=', 1)\n            mapping[name_value[0]] = (name_value[1]\n                                      if len(name_value) > 1\n                                      else None)\n    args.args.append(mapping)\n\n    if args.remainder:\n        parser.error(\"extraneous arguments left over\")\n    else:\n        del args.remainder\n\n    return args", "response": "Parse command line arguments."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef dump_engines(target=sys.stderr):\n    print(\"Available templating engines:\", file=target)\n\n    width = max(len(engine) for engine in engines.engines)\n    for handle, engine in sorted(engines.engines.items()):\n        description = engine.__doc__.split('\\n', 0)[0]\n        print(\"  %-*s  -  %s\" % (width, handle, description), file=target)", "response": "Print successfully imported templating engines."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef check_engine(handle):\n    if handle == 'help':\n        dump_engines()\n        sys.exit(0)\n\n    if handle not in engines.engines:\n        print('Engine \"%s\" is not available.' % (handle,), file=sys.stderr)\n        sys.exit(1)", "response": "Check availability of requested template engine."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nmaking a mapping from the name = value pairs.", "response": "def make_mapping(args):\n    \"\"\"Make a mapping from the name=value pairs.\"\"\"\n    mapping = {}\n\n    if args:\n        for arg in args:\n            name_value = arg.split('=', 1)\n            mapping[name_value[0]] = (name_value[1]\n                                      if len(name_value) > 1\n                                      else None)\n\n    return mapping"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef make_path_properties(file_or_path, prefix=''):\n    is_std = file_or_path in (sys.stdin, sys.stdout, sys.stderr)\n\n    if is_std:\n        path = '-'\n    elif is_filelike(file_or_path):\n        try:\n            path = str(file_or_path.name)\n        except AttributeError:\n            path = None\n    else:\n        path = str(file_or_path)\n\n    if is_std or not path:\n        abspath = dirname = basename = stem = ext = None\n        realpath = realdrive = realdir = realbase = realstem = realext = None\n        numbers = num = None\n    else:\n        abspath = os.path.abspath(path)\n\n        dirname, basename = os.path.split(path)\n        stem, ext = os.path.splitext(basename)\n\n        if not dirname:\n            dirname = os.curdir\n\n        realpath = os.path.realpath(path)\n        realdrive, tail = os.path.splitdrive(realpath)\n        realdir, realbase = os.path.split(tail)\n        realstem, realext = os.path.splitext(realbase)\n\n        numbers = [int(s) for s in re.findall(r'\\d+', basename)]\n        num = numbers[-1] if numbers else None\n\n    return {\n            prefix + 'path':      path,\n            prefix + 'abspath':   abspath,\n            prefix + 'dirname':   dirname,\n            prefix + 'basename':  basename,\n            prefix + 'stem':      stem,\n            prefix + 'ext':       ext,\n            prefix + 'realpath':  realpath,\n            prefix + 'realdrive': realdrive,\n            prefix + 'realdir':   realdir,\n            prefix + 'realbase':  realbase,\n            prefix + 'realstem':  realstem,\n            prefix + 'realext':   realext,\n            prefix + 'numbers':   numbers,\n            prefix + 'num':       num,\n        }", "response": "Build useful properties from a file path."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef constant_outfile_iterator(outfiles, infiles, arggroups):\n    assert len(infiles) == 1\n    assert len(arggroups) == 1\n\n    return ((outfile, infiles[0], arggroups[0]) for outfile in outfiles)", "response": "Iterate over all output files."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef variable_outfile_iterator(outfiles, infiles, arggroups, engine):\n    assert len(outfiles) == 1\n\n    template = engine(outfiles[0], tolerant=False)\n\n    for infile in infiles:\n        properties = make_path_properties(infile, prefix='')\n\n        for arggroup in arggroups:\n            outfile = template.apply(dict(arggroup, **properties))\n            yield (outfile, infile, arggroup)", "response": "Iterate over variable output file name template."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nprocess outfile - infile - arggroup combinations.", "response": "def process_combinations(combinations, engine,\n                         tolerant=False,\n                         read_old=False,\n                         delete_empty=False,\n                         ):\n    \"\"\"Process outfile-infile-arggroup combinations.\"\"\"\n    outfiles = set()\n\n    templatereader = CachedTemplateReader(engine, tolerant=tolerant)\n\n    for outfile, infile, arggroup in combinations:\n        template = templatereader.read(infile)\n        properties = make_path_properties(outfile, prefix='ez_')\n\n        if read_old:\n            if is_filelike(outfile):\n                raise Exception(\"cannot read already open output streams\")\n            try:\n                with open(outfile, 'r') as f:\n                    properties['ez_content'] = f.read()\n            except IOError:\n                properties['ez_content'] = None\n\n        result = template.apply(dict(arggroup, **properties))\n\n        if is_filelike(outfile):\n            if result:\n                outfile.write(result)\n        elif result or not delete_empty:\n            if outfile in outfiles:\n                raise IOError(\"trying to write twice to the same file\")\n            outfiles.add(outfile)\n            with open(outfile, 'w') as f:\n                f.write(result)\n        else:\n            try:\n                os.remove(outfile)\n            except OSError as e:\n                if e.errno != errno.ENOENT:\n                    raise"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef perform_templating(args):\n    engine = engines.engines[args.engine]\n\n    if args.vary:\n        it = variable_outfile_iterator(args.outfiles,\n                                       args.infiles,\n                                       args.args,\n                                       engine)\n    else:\n        it = constant_outfile_iterator(args.outfiles,\n                                       args.infiles,\n                                       args.args)\n\n    process_combinations(it, engine,\n                         tolerant=args.tolerant,\n                         read_old=args.read_old,\n                         delete_empty=args.delete_empty,\n                         )", "response": "Perform templating according to the given arguments."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef read(self, file_or_path):\n        if file_or_path in self._cached_templates:\n            return self._cached_templates[file_or_path]\n\n        if is_filelike(file_or_path):\n            template = file_or_path.read()\n            dirname = None\n        else:\n            with open(file_or_path, 'r') as f:\n                template = f.read()\n            dirname = os.path.dirname(file_or_path)\n\n        template = self._engine(template,\n                                dirname=dirname,\n                                tolerant=self._tolerant)\n\n        self._cached_templates[file_or_path] = template\n        return template", "response": "Read template from cache or file."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting the merged config from the same sources", "response": "def get_config(cli_args=None, config_path=None):\n    \"\"\"\n    Perform standard setup - get the merged config\n\n    :param cli_args dict: A dictionary of CLI arguments\n    :param config_path string: Path to the config file to load\n\n    :return dict: A dictionary of config values drawn from different sources\n    \"\"\"\n    config = Config(app_name=\"MYAPP\",\n                    cli_args=cli_args,\n                    config_path=config_path)\n    config_dict = config.get_config()\n    return config_dict"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nrun the command in the current directory and returns the output as a string.", "response": "def run(self, shell=False, ignore_errors=False, stdin=False, check_output=False):\n        \"\"\"Run subcommand.\n\n        Args:\n            shell (Optional[bool]): Run command using shell (default False)\n            ignore_errors (Optional[bool]): If the command has a non-zero return code, don't raise an exception (default False)\n            stdin (Optional[bool]): Plug input from stdin when running command (default False)\n            check_output (Optional[bool]): Return command output as string (default False)\n\n        Returns:\n            String if check_output is True, else None.\n\n        Raises:\n            subprocess.CalledProcessError when the command has an error, unless ignore_errors is True.\n        \"\"\"\n        previous_directory = os.getcwd()\n        os.chdir(self.directory)\n        try:\n            kwargs = {\n                'stderr': sys.stderr,\n                'stdin': sys.stdin if stdin else None,\n                'env': self.env_vars,\n                'shell': shell,\n            }\n            if check_output:\n                return subprocess.check_output(self.command, **kwargs).decode(\"utf8\")\n            else:\n                kwargs['stdout'] = sys.stdout\n                return subprocess.check_call(self.command, **kwargs)\n        except subprocess.CalledProcessError:\n            if ignore_errors:\n                pass\n            else:\n                raise\n\n        # Return to previous directory\n        os.chdir(previous_directory)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget a subcommand acting on a service.", "response": "def subcommand(self, *args):\n        \"\"\"Get subcommand acting on a service. Subcommand will run in service directory\n           and with the environment variables used to run the service itself.\n\n        Args:\n            *args: Arguments to run command (e.g. \"redis-cli\", \"-n\", \"1\")\n\n        Returns:\n            Subcommand object.\n        \"\"\"\n        return Subcommand(*args, directory=self.directory, env_vars=self.env_vars)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nbase upon an extract from threading.Condition().wait(). Immediately tries to acquire the lock, and then sleeps for a period of time (going 1/2ms..1ms..2ms..4ms...50ms..50ms), repeating until the lock is acquired or the timeout limit is reached.", "response": "def _wait(self, timeout):\n        \"\"\"\n        Based upon an extract from threading.Condition().wait(). Immediately \n        tries to acquire the lock, and then sleeps for a period of time (going \n        1/2ms..1ms..2ms..4ms...50ms..50ms), repeating until the lock is \n        acquired or the timeout limit is reached.\n        \"\"\"\n        endtime = time.time() + timeout\n        # Initial delay of .5ms\n        delay = 0.0005\n        while 1:\n            if self._lock.acquire(0):\n                return\n            # Nope, let's see if we have some time left to sleep\n            remaining = endtime - time.time()\n            if remaining <= 0:\n                # Nope, let's break to the error\n                break\n            # Yes, let's increase the delay up to a maximum of 50ms, and \n            # limited to the remaining time\n            delay = min(delay * 2, remaining, .05)\n            time.sleep(delay)\n        raise ResyncWaitTimeout"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef set_result(self, res):\n        self.result = (True, res)\n        self._lock.release()", "response": "Set the result of this entry set to res."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nsets the result of the error.", "response": "def set_error(self, e):\n        \"\"\"\n        Rather than allowing unmanaged exceptions to explode, or raising errors \n        within thread, the worker thread should call this function with an \n        error class or instance.\n        \"\"\"\n        self.result = (False, e)\n        self._lock.release()"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ngets a result or raise an error.", "response": "def get(self, timeout=None):\n        \"\"\"\n        Get a result or raise an error. If `timeout` is not None, this function \n        will wait for only `timeout` seconds before raising ThreadTimeout().\n        \"\"\"\n        if timeout is None:\n            self._lock.acquire()\n        else:\n            self._wait(timeout)\n        \n        res = self.result\n        if res[0]:\n            return res[1]\n        else:\n            raise res[1]"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _wrapper(self):\n        try:\n            res = self.func(*self.args, **self.kw)\n        except Exception as e:\n            self.mediator.set_error(e)\n        else:\n            self.mediator.set_result(res)", "response": "Wraps around a few calls which need to be made in the same thread."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nadd string every n character. returns string", "response": "def addinterval(instr, add, interval):\n    '''\n        adds string every n character. returns string\n    '''\n    if not isinstance(instr, str):\n        instr = str(instr)\n\n    return add.join(\n        instr[i:i+interval]\n        for i in xrange(0,len(instr),interval))"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get(siren):\n    '''\n        renvoie un tuple (str, str, str, rs)\n            un siren\n            une categorie d'entreprise\n            une annee\n            une raison sociale\n        param: un siren (str)\n\n        :Example:\n\n        >>> get('444465736')\n        (u'2013', u'444465736', u'entreprise de taille interm\\xe9diaire', u'NOVACAP')\n        >>> get('this intended to fail')\n\n    '''\n\n    # format siren\n    siren = addinterval(siren, ' ', 3)\n    # send request\n    res = requests.get(api.format(siren))\n\n    try:\n        # if request is ok\n        assert res.status_code == 200\n        # check if ok\n        soup = BeautifulSoup(res.text, 'html.parser')\n        colcentre = soup.find_all('div', id='col-centre')[0]\n        l1, l2, l3 = colcentre.find_all('p')[1:4]\n\n        if 'existe plus' in l1.text:\n            return parse_obsolete(l1, l3)\n\n        elif 'existe pas' in l1.text:\n            return parse_invalid()\n\n        elif 'hors champ' in l2.text:\n            return parse_nocat()\n        \n        elif 'pas pu attribuer' in l1.text:\n            return parse_new(l1, l2, l3)\n        \n        else:\n            return parse_ok(l1, l3)\n\n    except AssertionError:\n        print 'site inaccessible !'", "response": "get un siren un siren un siren un siren un siren un siren un siren un siren un siren un siren un siren un siren un siren un siren un siren un siren un siren un siren un siren un siren un siren un siren un siren un siren un"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef parse_ok(l1, l3):\n    '''\n        parse html when siren is ok\n    '''\n    return {\n        'annee': l1.text.split(' : ')[1].split()[2],\n        'siren valide': ''.join(\n            l1.text.split(' : ')[1].split(u'\\xab')[0].split()[-4:-1]),\n        'categorie': ' '.join(\n            l1.text.split(' : ')[1].split(u'\\xab')[1].split()[:-1]),\n        'raison sociale': l3.text.split(' : ')[1][:-1],\n        'statut': 'ok'}", "response": "parse html when siren is ok\n    parse html when siren is ok\n    parse html when siren is ok\n   "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef parse_obsolete(l1, l3):\n    '''\n        parse html when siren is obsolete\n    '''\n    return {\n        'annee': l1.text.split('.')[2].split()[2],\n        'siren valide': ''.join(\n            l1.text.split('.')[2].split(u'\\xab')[0].split()[-4:-1]),\n        'categorie': ' '.join(\n            l1.text.split('.')[2].split(u'\\xab')[1].split()[:-1]),\n        'raison sociale': l3.text.split(' : ')[1][:-1],\n        'statut': 'obsolete'}", "response": "parse html when siren is obsolete\n   "}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef parse_new(l1, l2, l3):\n    '''\n        parse html when siren is obsolete\n    '''\n    return {\n        'annee': l1.text.split(' : ')[1].split()[2],\n        'siren valide': ''.join(l2.text.split(' : ')[1].split()),\n        'categorie': u'nouvellement cr\\xe9\\xe9e',\n        'raison sociale': l3.text.split(' : ')[1][:-1],\n        'statut': u'nouvellement cr\\xe9\\xe9e'}", "response": "parse html when siren is obsolete\n    parse html when siren is obsolete\n   "}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreads and outputs siren list from input xlsx and batches get", "response": "def batch(in_xlsx, out_xlsx):\n    '''\n        retrieves siren list from input xlsx and batches get() to output xlsx\n    '''\n    import pandas as pd\n    import time\n    import openpyxl\n    pd.core.format.header_style = None\n\n    # load file\n    sirens_df = pd.read_excel(in_xlsx)\n\n    # extract and batch sirens\n    sirens_sr = sirens_df[sirens_df.columns[0]]\n    sirens = [get(siren) for siren in sirens_sr]\n    sirens = [str(siren).zfill(9) for siren in sirens] # <-- repair leading zeros\n\n    # convert to dataframe and merge with initial sirens\n    res = pd.DataFrame(sirens)\n    final = pd.concat([sirens_df, res], axis=1)\n\n    # save to xlsx\n    tmstmp = time.strftime('%Y%m%d')\n    final.to_excel(out_xlsx, sheet_name='{} results'.format(tmstmp))\n    \n    return 'export ok'"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreact to given message.", "response": "def reactToAMQPMessage(message, send_back):\n    \"\"\"\n    React to given (AMQP) message. `message` is usually expected to be\n    :py:func:`collections.namedtuple` structure filled with all necessary data.\n\n    Args:\n        message (\\*Request class): only :class:`.ConversionRequest` class is\n                                   supported right now\n\n        send_back (fn reference): Reference to function for responding. This is\n                  useful for progress monitoring for example. Function takes\n                  one parameter, which may be response structure/namedtuple, or\n                  string or whatever would be normally returned.\n\n    Returns:\n        ConversionResponse: response filled with data about conversion and\\\n                            converted file.\n\n    Raises:\n        ValueError: if bad type of `message` structure is given.\n    \"\"\"\n    if _instanceof(message, ConversionRequest):\n        return convert(\n            message.input_format,\n            message.output_format,\n            message.b64_data\n        )\n\n    raise ValueError(\n        \"Unknown type of request: '\" + str(type(message)) + \"'!\"\n    )"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef sort_states(states, sort_list):\n    sorted_states= states.copy()\n    for sort_pair in reversed( _convert_list_of_dict_to_tuple(sort_list) ):\n        if sort_pair[0].lstrip('-') in ['data','measure','meta']:\n            sorted_states= _state_value_sort(sorted_states, sort_pair, _state_key_function)\n        elif sort_pair[0] == 'groupings':\n            for grouping in reversed(sort_pair[1]):\n                sorted_states= _groupings_values_sort(sorted_states, grouping)\n    return sorted_states", "response": "Returns a list of sorted states in order of the state field."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nregister a class to be used in the data streaming.", "response": "def register_class(klass, alias=None):\n    \"\"\"\n    Registers a class to be used in the data streaming. This is the equivalent\n    to the C{[RemoteClass(alias=\"foobar\")]} AS3 metatag.\n\n    @return: The registered L{ClassAlias} instance.\n    @see: L{unregister_class}\n    \"\"\"\n    meta = util.get_class_meta(klass)\n\n    if alias is not None:\n        meta['alias'] = alias\n\n    alias_klass = util.get_class_alias(klass) or ClassAlias\n\n    x = alias_klass(klass, defer=True, **meta)\n\n    if not x.anonymous:\n        CLASS_CACHE[x.alias] = x\n\n    CLASS_CACHE[klass] = x\n\n    return x"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef unregister_class(alias):\n    try:\n        x = CLASS_CACHE[alias]\n    except KeyError:\n        raise UnknownClassAlias('Unknown alias %r' % (alias,))\n\n    if not x.anonymous:\n        del CLASS_CACHE[x.alias]\n\n    del CLASS_CACHE[x.klass]\n\n    return x", "response": "Unregisters a class from the internal cache."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn the class that is registered to the given alias.", "response": "def get_class_alias(klass_or_alias):\n    \"\"\"\n    Finds the L{ClassAlias} that is registered to C{klass_or_alias}.\n\n    If a string is supplied and no related L{ClassAlias} is found, the alias is\n    loaded via L{load_class}.\n\n    @raise UnknownClassAlias: Unknown alias\n    \"\"\"\n    if isinstance(klass_or_alias, python.str_types):\n        try:\n            return CLASS_CACHE[klass_or_alias]\n        except KeyError:\n            return load_class(klass_or_alias)\n\n    try:\n        return CLASS_CACHE[klass_or_alias]\n    except KeyError:\n        raise UnknownClassAlias('Unknown alias for %r' % (klass_or_alias,))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nloading the class with the given alias.", "response": "def load_class(alias):\n    \"\"\"\n    Finds the class registered to the alias.\n\n    The search is done in order:\n      1. Checks if the class name has been registered via L{register_class}\n         or L{register_package}.\n      2. Checks all functions registered via L{register_class_loader}.\n      3. Attempts to load the class via standard module loading techniques.\n\n    @param alias: The class name.\n    @type alias: C{string}\n    @raise UnknownClassAlias: The C{alias} was not found.\n    @raise TypeError: Expecting class type or L{ClassAlias} from loader.\n    @return: Class registered to the alias.\n    @rtype: C{classobj}\n    \"\"\"\n    # Try the CLASS_CACHE first\n    try:\n        return CLASS_CACHE[alias]\n    except KeyError:\n        pass\n\n    for loader in CLASS_LOADERS:\n        klass = loader(alias)\n\n        if klass is None:\n            continue\n\n        if isinstance(klass, python.class_types):\n            return register_class(klass, alias)\n        elif isinstance(klass, ClassAlias):\n            CLASS_CACHE[klass.alias] = klass\n            CLASS_CACHE[klass.klass] = klass\n\n            return klass\n\n        raise TypeError(\"Expecting class object or ClassAlias from loader\")\n\n    mod_class = alias.split('.')\n\n    if mod_class:\n        module = '.'.join(mod_class[:-1])\n        klass = mod_class[-1]\n\n        try:\n            module = util.get_module(module)\n        except (ImportError, AttributeError):\n            pass\n        else:\n            klass = getattr(module, klass)\n\n            if isinstance(klass, python.class_types):\n                return register_class(klass, alias)\n            elif isinstance(klass, ClassAlias):\n                CLASS_CACHE[klass.alias] = klass\n                CLASS_CACHE[klass.klass] = klass\n\n                return klass.klass\n            else:\n                raise TypeError(\"Expecting class type or ClassAlias from loader\")\n\n    # All available methods for finding the class have been exhausted\n    raise UnknownClassAlias(\"Unknown alias for %r\" % (alias,))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_decoder(encoding, *args, **kwargs):\n    def _get_decoder_class():\n        if encoding == AMF0:\n            try:\n                from cpyamf import amf0\n            except ImportError:\n                from pyamf import amf0\n\n            return amf0.Decoder\n        elif encoding == AMF3:\n            try:\n                from cpyamf import amf3\n            except ImportError:\n                from pyamf import amf3\n\n            return amf3.Decoder\n\n        raise ValueError(\"Unknown encoding %r\" % (encoding,))\n\n    return _get_decoder_class()(*args, **kwargs)", "response": "Returns a L { codec. Decoder capable of decoding AMF [ C { encoding } ] streams."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a L { codec. Encoder capable of encoding AMF [ C { encoding } ] streams.", "response": "def get_encoder(encoding, *args, **kwargs):\n    \"\"\"\n    Returns a L{codec.Encoder} capable of encoding AMF[C{encoding}] streams.\n\n    @raise ValueError: Unknown C{encoding}.\n    \"\"\"\n    def _get_encoder_class():\n        if encoding == AMF0:\n            try:\n                from cpyamf import amf0\n            except ImportError:\n                from pyamf import amf0\n\n            return amf0.Encoder\n        elif encoding == AMF3:\n            try:\n                from cpyamf import amf3\n            except ImportError:\n                from pyamf import amf3\n\n            return amf3.Encoder\n\n        raise ValueError(\"Unknown encoding %r\" % (encoding,))\n\n    return _get_encoder_class()(*args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nadds a custom type to the internal list of types.", "response": "def add_type(type_, func=None):\n    \"\"\"\n    Adds a custom type to L{TYPE_MAP}. A custom type allows fine grain control\n    of what to encode to an AMF data stream.\n\n    @raise TypeError: Unable to add as a custom type (expected a class or callable).\n    @raise KeyError: Type already exists.\n    @see: L{get_type} and L{remove_type}\n    \"\"\"\n    def _check_type(type_):\n        if not (isinstance(type_, python.class_types) or\n                hasattr(type_, '__call__')):\n            raise TypeError(r'Unable to add '%r' as a custom type (expected a '\n                'class or callable)' % (type_,))\n\n    if isinstance(type_, list):\n        type_ = tuple(type_)\n\n    if type_ in TYPE_MAP:\n        raise KeyError('Type %r already exists' % (type_,))\n\n    if isinstance(type_, types.TupleType):\n        for x in type_:\n            _check_type(x)\n    else:\n        _check_type(type_)\n\n    TYPE_MAP[type_] = func"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget the declaration for the corresponding custom type.", "response": "def get_type(type_):\n    \"\"\"\n    Gets the declaration for the corresponding custom type.\n\n    @raise KeyError: Unknown type.\n    @see: L{add_type} and L{remove_type}\n    \"\"\"\n    if isinstance(type_, list):\n        type_ = tuple(type_)\n\n    for k, v in TYPE_MAP.iteritems():\n        if k == type_:\n            return v\n\n    raise KeyError(\"Unknown type %r\" % (type_,))"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add_error_class(klass, code):\n    if not isinstance(code, python.str_types):\n        code = code.decode('utf-8')\n\n    if not isinstance(klass, python.class_types):\n        raise TypeError(\"klass must be a class type\")\n\n    mro = inspect.getmro(klass)\n\n    if not Exception in mro:\n        raise TypeError(\n            'Error classes must subclass the __builtin__.Exception class')\n\n    if code in ERROR_CLASS_MAP:\n        raise ValueError('Code %s is already registered' % (code,))\n\n    ERROR_CLASS_MAP[code] = klass", "response": "Adds an exception class to the internal error list."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef remove_error_class(klass):\n    if isinstance(klass, python.str_types):\n        if klass not in ERROR_CLASS_MAP:\n            raise ValueError('Code %s is not registered' % (klass,))\n    elif isinstance(klass, python.class_types):\n        classes = ERROR_CLASS_MAP.values()\n        if klass not in classes:\n            raise ValueError('Class %s is not registered' % (klass,))\n\n        klass = ERROR_CLASS_MAP.keys()[classes.index(klass)]\n    else:\n        raise TypeError(\"Invalid type, expected class or string\")\n\n    del ERROR_CLASS_MAP[klass]", "response": "Removes a class from the error_classes list."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef register_alias_type(klass, *args):\n    def check_type_registered(arg):\n        for k, v in ALIAS_TYPES.iteritems():\n            for kl in v:\n                if arg is kl:\n                    raise RuntimeError('%r is already registered under %r' % (\n                        arg, k))\n\n    if not isinstance(klass, python.class_types):\n        raise TypeError('klass must be class')\n\n    if not issubclass(klass, ClassAlias):\n        raise ValueError('New aliases must subclass pyamf.ClassAlias')\n\n    if len(args) == 0:\n        raise ValueError('At least one type must be supplied')\n\n    if len(args) == 1 and hasattr(args[0], '__call__'):\n        c = args[0]\n\n        check_type_registered(c)\n    else:\n        for arg in args:\n            if not isinstance(arg, python.class_types):\n                raise TypeError('%r must be class' % (arg,))\n\n            check_type_registered(arg)\n\n    ALIAS_TYPES[klass] = args\n\n    for k, v in CLASS_CACHE.copy().iteritems():\n        new_alias = util.get_class_alias(v.klass)\n\n        if new_alias is klass:\n            meta = util.get_class_meta(v.klass)\n            meta['alias'] = v.alias\n\n            alias_klass = klass(v.klass, **meta)\n\n            CLASS_CACHE[k] = alias_klass\n            CLASS_CACHE[v.klass] = alias_klass", "response": "This function registers a new type of alias with the AMF stream."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef register_package(module=None, package=None, separator='.', ignore=[],\n                     strict=True):\n    \"\"\"\n    This is a helper function that takes the concept of Actionscript packages\n    and registers all the classes in the supplied Python module under that\n    package. It auto-aliased all classes in C{module} based on the parent\n    C{package}.\n\n    @param module: The Python module that will contain all the classes to\n        auto alias.\n    @type module: C{module} or C{dict}\n    @param package: The base package name. e.g. 'com.example.app'. If this\n        is C{None} then the value is inferred from C{module.__name__}.\n    @type package: C{string} or C{None}\n    @param separator: The separator used to append to C{package} to form the\n        complete alias.\n    @param ignore: To give fine grain control over what gets aliased and what\n        doesn't, supply a list of classes that you B{do not} want to be aliased.\n    @type ignore: C{iterable}\n    @param strict: Whether only classes that originate from C{module} will be\n        registered.\n\n    @return: A dict of all the classes that were registered and their respective\n        L{ClassAlias} counterparts.\n    @since: 0.5\n    @raise TypeError: Cannot get a list of classes from C{module}\n    \"\"\"\n    if isinstance(module, python.str_types):\n        if module == '':\n            raise TypeError('Cannot get list of classes from %r' % (module,))\n\n        package = module\n        module = None\n\n    if module is None:\n        import inspect\n\n        prev_frame = inspect.stack()[1][0]\n        module = prev_frame.f_locals\n\n    if type(module) is dict:\n        has = lambda x: x in module\n        get = module.__getitem__\n    elif type(module) is list:\n        has = lambda x: x in module\n        get = module.__getitem__\n        strict = False\n    else:\n        has = lambda x: hasattr(module, x)\n        get = lambda x: getattr(module, x)\n\n    if package is None:\n        if has('__name__'):\n            package = get('__name__')\n        else:\n            raise TypeError('Cannot get list of classes from %r' % (module,))\n\n    if has('__all__'):\n        keys = get('__all__')\n    elif hasattr(module, '__dict__'):\n        keys = module.__dict__.keys()\n    elif hasattr(module, 'keys'):\n        keys = module.keys()\n    elif isinstance(module, list):\n        keys = range(len(module))\n    else:\n        raise TypeError('Cannot get list of classes from %r' % (module,))\n\n    def check_attr(attr):\n        if not isinstance(attr, python.class_types):\n            return False\n\n        if attr.__name__ in ignore:\n            return False\n\n        try:\n            if strict and attr.__module__ != get('__name__'):\n                return False\n        except AttributeError:\n            return False\n\n        return True\n\n    # gotta love python\n    classes = filter(check_attr, [get(x) for x in keys])\n\n    registered = {}\n\n    for klass in classes:\n        alias = '%s%s%s' % (package, separator, klass.__name__)\n\n        registered[klass] = register_class(klass, alias)\n\n    return registered", "response": "This function is used to register all the classes in the supplied Python module under the specified package."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef create_signature(self, base_url, payload=None):\n        url = urlparse(base_url)\n\n        url_to_sign = \"{path}?{query}\".format(path=url.path, query=url.query)\n\n        converted_payload = self._convert(payload)\n\n        decoded_key = base64.urlsafe_b64decode(self.private_key.encode('utf-8'))\n        signature = hmac.new(decoded_key, str.encode(url_to_sign + converted_payload), hashlib.sha256)\n        return bytes.decode(base64.urlsafe_b64encode(signature.digest()))", "response": "Creates a unique signature for the request."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _convert(self, payload):\n        if not isinstance(payload, six.string_types):\n            payload = json.dumps(payload, cls=DefaultJSONEncoder, sort_keys=True)\n        return str(payload)", "response": "Converts the given payload to a string. Complex objects are dumped to json\n           "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef create_object(self, filename, read_only=False):\n        # Get the file name, i.e., last component of the given absolute path\n        prop_name = os.path.basename(os.path.normpath(filename))\n        # Ensure that the uploaded file has a valid suffix. Currently no tests\n        # are performed to ensure that the file actually conatains any data.\n        if prop_name.endswith('.nii.gz') or prop_name.endswith('.mgz') or prop_name.endswith('.mgh.gz'):\n            prop_mime = 'application/x-gzip'\n        elif prop_name.endswith('.nii'):\n            prop_mime = 'application/NIfTI-1'\n        elif prop_name.endswith('.mgh'):\n            prop_mime = 'application/MGH'\n        else:\n            raise ValueError('unsupported file type: ' + prop_name)\n        # Create a new object identifier.\n        identifier = str(uuid.uuid4()).replace('-','')\n        # The object directory is given by the object identifier.\n        object_dir = os.path.join(self.directory, identifier)\n        # Create (sub-)directories for the uploaded and extracted data files.\n        if not os.access(object_dir, os.F_OK):\n            os.makedirs(object_dir)\n        data_dir = os.path.join(object_dir, DATA_DIRECTORY)\n        os.mkdir(data_dir)\n        func_data_file = prop_name\n        uploaded_file = os.path.join(data_dir, prop_name)\n        shutil.copyfile(filename, uploaded_file)\n        # Create the initial set of properties for the new image object.\n        properties = {\n            datastore.PROPERTY_NAME: prop_name,\n            datastore.PROPERTY_FILENAME : prop_name,\n            datastore.PROPERTY_FILESIZE : os.path.getsize(uploaded_file),\n            datastore.PROPERTY_MIMETYPE : prop_mime,\n            datastore.PROPERTY_FUNCDATAFILE : func_data_file\n        }\n        if read_only:\n            properties[datastore.PROPERTY_READONLY] = True\n        # Create object handle and store it in database before returning it\n        obj = FunctionalDataHandle(\n            identifier,\n            properties,\n            object_dir\n        )\n        self.insert_object(obj)\n        return obj", "response": "Create a new functional data object for the given file."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef from_dict(self, document):\n        identifier = str(document['_id'])\n        active = document['active']\n        # The directory is not materilaized in database to allow moving the\n        # base directory without having to update the database.\n        directory = os.path.join(self.directory, identifier)\n        timestamp = datetime.datetime.strptime(document['timestamp'], '%Y-%m-%dT%H:%M:%S.%f')\n        properties = document['properties']\n        return FunctionalDataHandle(identifier, properties, directory, timestamp=timestamp, is_active=active)", "response": "Create a functional data object from a JSON document retrieved from the database."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nforecasting how long a backlog will take to complete given the historical values provided.", "response": "def forecast(self, throughputs, backlog_size, num_simulations=10000, max_periods=10000, seed=None):\n        \"\"\"Forecasts how long a backlog will take to complete given the historical values provided.\n        Arguments:\n            throughputs(List[int]): Number of units completed per unit of time (stories per week, story points per month, etc.)\n            backlog_size(int): Units in the backlog (stories, points, etc.)\n        Returns:\n            results\n        Exceptions:\n            ValueError: If there aren't any positive throughputs, or the simulation takes too long.\n        \"\"\"\n        self._check_throughputs(throughputs)\n        results = []\n\n        if seed is not None:\n            random.seed(seed)\n\n        for i in range(0, num_simulations):\n            simulated_backlog = backlog_size\n            time_unit_count = 0\n            while simulated_backlog > 0:\n                simulated_backlog -= random.choice(throughputs)\n                time_unit_count += 1\n                if time_unit_count > max_periods:\n                    raise ValueError(\"More than {} periods calculated\".format(max_periods))\n            results.append(time_unit_count)\n\n        return Results(results)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef extract_url_query_parameter(url, parameter):\n    query_string = urlparse(url).query\n    return parse_qs(query_string).get(parameter, [])", "response": "Given a URL and a parameter extract the value for the given query parameter"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _get_page_content(self, response):\n        document = html5lib.parse(\n            response.content,\n            encoding=response.encoding,\n            treebuilder='etree',\n            namespaceHTMLElements=False\n        )\n        # etree doesn't fully support XPath, so we can't just search\n        # the attribute values for \"content\"\n        divs = document.findall(\n            \".//body//div[@class]\")\n        content_div = None\n        for div in divs:\n            if \"content\" in div.attrib['class'].split(' '):\n                content_div = div\n                break\n\n        # The `Element` object is False-y when there are no subelements,\n        # so compare to `None`\n        if content_div is None:\n            return None\n        return content_div", "response": "Given a : class : requests. Response return the first content div or None."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nretrieves and parses the torrent page for a given torrent_id.", "response": "def view_torrent(self, torrent_id):\n        \"\"\"Retrieves and parses the torrent page for a given `torrent_id`.\n\n        :param torrent_id: the ID of the torrent to view\n        :raises TorrentNotFoundError: if the torrent does not exist\n        :returns: a :class:`TorrentPage` with a snapshot view of the torrent\n            detail page\n        \"\"\"\n        params = {\n            'page': 'view',\n            'tid': torrent_id,\n        }\n        r = requests.get(self.base_url, params=params)\n        content = self._get_page_content(r)\n\n        # Check if the content div has any child elements\n        if not len(content):\n            # The \"torrent not found\" text in the page has some unicode junk\n            # that we can safely ignore.\n            text = str(content.text.encode('ascii', 'ignore'))\n            if TORRENT_NOT_FOUND_TEXT in text:\n                raise TorrentNotFoundError(TORRENT_NOT_FOUND_TEXT)\n\n        cell_td_elems = content.findall('.//td')\n        name = cell_td_elems[3].text\n\n        category_href = content\\\n            .findall(\".//td[@class='viewcategory']/a[2]\")[0]\\\n            .attrib['href']\n        category_value = category_href.split('cats=')[1]\n        category = Category.lookup_category(category_value)\n\n        # parse the submitter details\n        submitter_a_elem = cell_td_elems[7].findall('a')[0]\n        submitter_id = submitter_a_elem.attrib['href'].split('=')[1]\n        submitter_name = submitter_a_elem.findall('span')[0].text\n        submitter = User(submitter_id, submitter_name)\n\n        tracker = cell_td_elems[11].text\n        date_created = datetime.datetime.strptime(\n            cell_td_elems[5].text, '%Y-%m-%d, %H:%M %Z')\n\n        seeders = int(content.findall(\".//span[@class='viewsn']\")[0].text)\n        leechers = int(content.findall(\".//span[@class='viewln']\")[0].text)\n        downloads = int(content.findall(\".//span[@class='viewdn']\")[0].text)\n\n        file_size = cell_td_elems[21].text\n\n        # note that the tree returned by html5lib might not exactly match the\n        # original contents of the description div\n        description = ElementTree.tostring(\n            content.findall(\".//div[@class='viewdescription']\")[0],\n            encoding='utf8', method='html')\n        return TorrentPage(\n            torrent_id, name, submitter, category, tracker, date_created,\n            seeders, leechers, downloads, file_size, description)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ngetting the. torrent data for the given torrent_id.", "response": "def get_torrent(self, torrent_id):\n        \"\"\"Gets the `.torrent` data for the given `torrent_id`.\n\n        :param torrent_id: the ID of the torrent to download\n        :raises TorrentNotFoundError: if the torrent does not exist\n        :returns: :class:`Torrent` of the associated torrent\n        \"\"\"\n        params = {\n            'page': 'download',\n            'tid': torrent_id,\n        }\n        r = requests.get(self.base_url, params=params)\n        if r.headers.get('content-type') != 'application/x-bittorrent':\n            raise TorrentNotFoundError(TORRENT_NOT_FOUND_TEXT)\n        torrent_data = r.content\n        return Torrent(torrent_id, torrent_data)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef search(self, terms, category=Category.all_categories, page=1,\n               sort_key=SearchSortKey.date,\n               order_key=SearchOrderKey.descending):\n        \"\"\"Get a list of torrents that match the given search term\n\n        :param terms: the `str` needle\n        :param category: the desired :class:`Category` of the results\n        :param page: the 1-based page to return the result\n        :param sort_key: the :class:`SearchSortKey` of the results list\n        :param order_key: the :class:`SearchOrderkey` of the results list\n        :return: a :class:`SearchPage` of results\n        \"\"\"\n        params = {\n            'page': 'search',\n            'term': terms,\n            'cats': category.value,\n            'sort': sort_key.value,\n            'order': order_key.value,\n        }\n        r = requests.get(self.base_url, params=params)\n        content = self._get_page_content(r)\n\n        # first, get the total number of pages returned. this findall returns\n        # two results (one from the top half of the page, one from the bottom),\n        # so only take the first element.\n        a_to_last_page = content.findall('.//div[@class=\"rightpages\"]/a[2]')\n        if not a_to_last_page:\n            total_pages = 1\n        else:\n            last_page_url = a_to_last_page[0].attrib['href']\n            offset = extract_url_query_parameter(last_page_url, \"offset\")[0]\n            total_pages = int(offset)\n\n        torrent_stubs = []\n        rows = (x for x in content.findall('.//table//tr')\n                if 'tlistrow' in x.attrib.get('class', ''))\n        for row in rows:\n            cell_td_elems = row.findall('td')\n\n            category_value = extract_url_query_parameter(\n                cell_td_elems[0].find('a').attrib['href'],\n                'cats')[0]\n            category = Category.lookup_category(category_value)\n            torrent_id = extract_url_query_parameter(\n                cell_td_elems[1].find('a').attrib['href'],\n                \"tid\")[0]\n            name = cell_td_elems[1].find('a').text\n            file_size = cell_td_elems[3].text\n            if cell_td_elems[4].text.isdigit():\n                seeders = int(cell_td_elems[4].text)\n            else:\n                seeders = None\n            if cell_td_elems[5].text.isdigit():\n                leechers = int(cell_td_elems[5].text)\n            else:\n                leechers = None\n            downloads = int(cell_td_elems[6].text)\n\n            stub = TorrentStub(torrent_id, name, category, seeders, leechers,\n                               file_size, downloads)\n            torrent_stubs.append(stub)\n        return SearchResultPage(\n            terms, category, sort_key, order_key, page, total_pages,\n            torrent_stubs)", "response": "Search the torrents in the page with the given search terms."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _parse_alt_title(html_chunk):\n    title = html_chunk.find(\n        \"input\",\n        {\"src\": \"../images_buttons/objednat_off.gif\"}\n    )\n\n    assert title, \"Can't find alternative title!\"\n\n    title = title[0]\n\n    assert \"title\" in title.params, \"Can't find alternative title source!\"\n\n    # title is stored as Bleh bleh: Title\n    title = title.params[\"title\"].split(\":\", 1)[-1]\n\n    return title.strip()", "response": "Parse alternative title from HTML chunk."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef _parse_title_url(html_chunk):\n    title = html_chunk.find(\"div\", {\"class\": \"comment\"})\n\n    if not title:\n        return _parse_alt_title(html_chunk), None\n\n    title = title[0].find(\"h2\")\n    if not title:\n        return _parse_alt_title(html_chunk), None\n\n    # look for the url of the book if present\n    url = None\n    url_tag = title[0].find(\"a\")\n    if url_tag:\n        url = url_tag[0].params.get(\"href\", None)\n        title = url_tag\n\n    return title[0].getContent(), normalize_url(BASE_URL, url)", "response": "Parse title and url of the book."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _parse_authors(html_chunk):\n    authors = html_chunk.match(\n        [\"div\", {\"class\": \"comment\"}],\n        \"h3\",\n        \"a\",\n    )\n\n    if not authors:\n        return []\n\n    authors = map(\n        lambda x: Author(                            # create Author objects\n            x.getContent().strip(),\n            normalize_url(BASE_URL, x.params.get(\"href\", None))\n        ),\n        authors\n    )\n\n    return filter(lambda x: x.name.strip(), authors)", "response": "Parse authors of the book."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _parse_format_pages_isbn(html_chunk):\n    ppi = get_first_content(\n        html_chunk.find(\"div\", {\"class\": \"price-overflow\"})\n    )\n\n    if not ppi:\n        return None, None, None\n\n    # all information this function should parse are at one line\n    ppi = filter(lambda x: x.strip(), ppi.split(\"<br />\"))[0]\n\n    # parse isbn\n    isbn = dhtmlparser.parseString(ppi)\n    isbn = isbn.find(\"b\")\n    isbn = isbn[0].getContent() if isbn else None\n\n    # parse pages and format\n    pages = None\n    book_format = None\n    details = ppi.split(\"|\")\n\n    if len(details) >= 2:\n        book_format = details[0].strip()\n        pages = details[1].strip()\n\n    return book_format, pages, isbn", "response": "Parse format number of pages and ISBN."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nparses price of the book.", "response": "def _parse_price(html_chunk):\n    \"\"\"\n    Parse price of the book.\n\n    Args:\n        html_chunk (obj): HTMLElement containing slice of the page with details.\n\n    Returns:\n        str/None: Price as string with currency or None if not found.\n    \"\"\"\n    price = get_first_content(\n        html_chunk.find(\"div\", {\"class\": \"prices\"})\n    )\n\n    if not price:\n        return None\n\n    # it is always in format Cena:\\n150k\u010d\n    price = dhtmlparser.removeTags(price)\n    price = price.split(\"\\n\")[-1]\n\n    return price"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nparse the contents of a page with the book details page.", "response": "def _process_book(html_chunk):\n    \"\"\"\n    Parse available informations about book from the book details page.\n\n    Args:\n        html_chunk (obj): HTMLElement containing slice of the page with\n                          details.\n\n    Returns:\n        obj: :class:`structures.Publication` instance with book details.\n    \"\"\"\n    title, url = _parse_title_url(html_chunk)\n    book_format, pages, isbn = _parse_format_pages_isbn(html_chunk)\n\n    # required informations\n    pub = Publication(\n        title=title,\n        authors=_parse_authors(html_chunk),\n        price=_parse_price(html_chunk),\n        publisher=\"Grada\"\n    )\n\n    # optional informations\n    pub.optionals.URL = url\n    pub.optionals.ISBN = isbn\n    pub.optionals.pages = pages\n    pub.optionals.format = book_format\n    pub.optionals.sub_title = _parse_subtitle(html_chunk)\n    pub.optionals.description = _parse_description(html_chunk)\n\n    return pub"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef workspaces(self, index=None):\r\n        c = self.centralWidget()\r\n        if index is None:\r\n            return (c.widget(n) for n in range(c.count()))\r\n        else:\r\n            return c.widget(index)", "response": "return generator for all workspace instances"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nchecking if annotated function arguments validate according to spec", "response": "def validate(func):\n    \"\"\"\n    Check if annotated function arguments validate according to spec\n    \"\"\"\n    call = PythonCall(func)\n\n    @wraps(func)\n    def decorator(*args, **kwargs):\n        parameters = call.bind(args, kwargs)\n        for arg_name, validator in func.__annotations__.items():\n            if not validator(parameters[arg_name]):\n                raise TypeError(\n                    \"Argument {!r} failed to validate\".format(arg_name))\n        return call.apply(args, kwargs)\n    return decorator"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef sub(self):\n        '''\n        :param fields:\n            Set fields to substitute\n        :returns:\n            Substituted Template with given fields.\n            If no fields were set up beforehand, :func:`raw` is used.\n        '''\n\n        if self.__fields:\n            return _Template(self.raw).substitute(self.__fields)\n        return self.raw", "response": "Substitute the fields of the current object with the given fields."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nwrites the current object into a file.", "response": "def write(self, filename, append=True, backup=True):\n        '''\n        :param filename:\n            File to write into\n        :param append:\n            Either append to existing content (if not already included)\n            or completely replace `filename`\n        :param backup:\n            Create a backup of `filename` before writing.\n            Only applies when `append` is set\n        '''\n\n        res = self.sub\n        if append:\n            org = read_file(filename)\n            if org:\n                if res in org:\n                    res = org\n                else:\n                    if backup:\n                        backup_location(filename)\n                    res = org + res\n\n        write_file(filename, res)\n        return self.m(\n            'template %s' % ('appended' if append else 'written'),\n            more=dict(fields=self.__fields, file=filename)\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ntakes a BaseX descendant from sqparse2 return a type class from above", "response": "def expression_type(con, topx, ex):\n  \"take a BaseX descendant from sqparse2, return a type class from above\"\n  if isinstance(ex,sqparse2.Literal):\n    if isinstance(ex.val,basestring): return STRING\n    else: raise NotImplementedError('literal', type(ex.val))\n  elif isinstance(ex,sqparse2.AttrX):\n    if ex.parent.name in con.db: # warning: what if it's not a table? what if it's aliased?\n      return expression_type(con, topx, con.db[ex.parent.name].get_column(ex.attr.name).coltp)\n    else:\n      raise NotImplementedError(ex.parent)\n  elif isinstance(ex,sqparse2.TypeX):\n    return dict(\n      integer=NUMBER,\n      text=STRING,\n    )[ex.type.lower()]\n  else:\n    raise NotImplementedError('unk type', type(ex))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef call_cur(f):\n  \"decorator for opening a connection and passing a cursor to the function\"\n  @functools.wraps(f)\n  def f2(self, *args, **kwargs):\n    with self.withcur() as cur:\n      return f(self, cur, *args, **kwargs)\n  return f2", "response": "decorator for opening a connection and passing a cursor to the function"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef partition(self, mapped_values):\n        partitioned_data = collections.defaultdict(list)\n        for key, value in mapped_values:\n            partitioned_data[key].append(value)\n        return partitioned_data.items()", "response": "Organize the mapped values by their key."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nprepare some context before install", "response": "def pre(self, command, output_dir, kw):\n        \"\"\"\n        Prepare some context before install\n        \n        Added kwargs in ``kw`` will be accessible into paste template files\n        \"\"\"\n        # Build a random secret_key\n        chars = u'abcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*(-_=+)'\n        kw['secret_key'] = ''.join([ choice(chars) for i in range(50) ])\n\n        # Paste version\n        kw['epaster_template_name'] = u'emencia-paste-djangocms-3'\n        kw['epaster_template_version'] = template_version"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nbuild the list of mod names that are available for the user.", "response": "def get_mods(self, project_path, vars):\n        \"\"\"\n        Build the mod list to enable\n        \"\"\"\n        # Start with answers from interactive command\n        mods = [var.name for var in self.vars if vars[var.name].lower() == 'yes']\n        mods = set(mods)\n\n        # Base mods\n        for name in self.mods_list:\n            mods.add(name)\n        \n        # Conditionnal mods dependancies\n        if 'accounts' in mods or 'contact_form' in mods:\n            mods.add('crispy_forms')\n            mods.add('recaptcha')\n        \n        return mods"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nbuild the symlink list to create", "response": "def get_symlinks(self, project_path, vars, mods):\n        \"\"\"\n        Build the symlink list to create (to enable mods and other stuff)\n        \"\"\"\n        # Some additional symlinks\n        if 'cms' in mods:\n            # Mirroring Ckeditor JS overrides for the CKEditor cmsplugin that \n            # use a different namespace than 'django-ckeditor'\n            self.symlink_list.append(('ckeditor', join(project_path, 'mods_available/ckeditor/static/djangocms_text_ckeditor')))\n\n        # Enable all selected mods (it resumes to make a list of symlinks to \n        # do in mods_enabled)\n        for name in mods:\n            self.symlink_list.append((\n                join('..', 'mods_available', name),\n                join(project_path, 'mods_enabled', name)\n            ))\n        \n        return self.symlink_list"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef post(self, command, output_dir, vars):\n        if command.simulate:\n            return\n        \n        # Find the 'project/' dir in the created paste project\n        project_path = join(getcwd(), vars['project'], 'project')\n        \n        # 1. Mods\n        mods = self.get_mods(project_path, vars)\n        \n        # 2. Create symlinks\n        for target, linkfile in self.get_symlinks(project_path, vars, mods):\n            print \"* Symlink TO:\", target, 'INTO:', linkfile\n            symlink(target, linkfile)\n\n        # 3. Git first initialization\n        call = Caller(vars['project'])\n        call('git', 'init', '.')\n        call('git', 'add', '.')\n        call('git', 'commit', '-m', 'First commit')", "response": "Create symlinks and copies the mods and the project into the output_dir"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nredirects users who don t have access to a page to the home page.", "response": "def red_home(request, message=None):\n    '''\n    Convenience function for redirecting users who don't have access to a page to the home page.\n    Parameters:\n        request - the request in the calling function\n        message - a message from the caller function\n    '''\n    if message:\n        messages.add_message(request, messages.ERROR, message)\n    return HttpResponseRedirect(reverse('homepage'))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\niterate over all paths that are in a directory and its subdirectory returning fully - specified paths.", "response": "def _iter_full_paths(path_list):\n    \"\"\"\n    Iterates over all paths that are in a directory and its subdirectory, returning \n    fully-specified paths.\n    \"\"\"\n    for path in path_list:\n        if not os.path.isdir(path):\n            full_path = os.path.realpath(path)\n            yield path\n        else:\n            for root, dirs, filenames in os.walk(path):\n                for filename in filenames:\n                    full_path = os.path.realpath(os.path.join(root, filename))\n                    yield full_path"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nverify that the object is a valid config container.", "response": "def verify_config_container(object_):\n    \"\"\"Verify object is a valid config container\n    \n    Valid config containers provide zope.interface.common.mapping.IEnumerableMapping\n    or an iterable of zope.interface.common.mapping.IEnumerableMapping.\n    \n    verification is performed by checking required interfaces attributes \n    against those provided by object_\n    \n    Raises: zope.interface.exceptions.BrokenImplementation if object_ does not\n            fully implement zope.interface.common.mapping.IEnumerableMapping\n    \"\"\"\n    try:\n        #check for a map\n        _verify_map(object_)\n    except BrokenImplementation as e:\n        #check for a iterable of maps\n        try:\n            for m in object_:\n                _verify_map(m)\n        except BrokenImplementation:\n            raise e"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef __spawn(self):\n        dat = {\n            'log.enabled': False,\n            'log.file_pth': '{}/{}.log'.format(self._pth, self._cfg_name),\n            'log.file_backups': 3,\n            'log.file_size': 5,\n            'log.level': 10,\n            'log.symbol': '\u2630\u2637\u2633\u2634\u2635\u2632\u2636\u2631',\n        }\n        self.__do_init(dat)", "response": "\u901a\u8fc7\u624b\u52a8\u65b9\u5f0f, \u6307\u5b9a\u5b57\u6bb5\u7c7b\u578b\u4e0e\u9ed8\u8ba4\u503c,\n            - \u5982\u679c\u914d\u7f6e\u6587\u4ef6\u6709\u53d8\u52a8, \u9700\u8981\u624b\u52a8\u5728\u8fd9\u91cc\u6dfb\u52a0\n            - \u5982\u679c\u914d\u7f6e\u5b57\u6bb5\u672a\u5728\u8fd9\u91cc\u6307\u51fa, \u5219\u9ed8\u8ba4\u4e3a string, \u4f7f\u7528\u65f6\u9700\u8981\u624b\u52a8\u8f6c\u6362"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ninitializes the cfg object.", "response": "def __do_init(self, dat_dict):\n        \"\"\"\n            \u4f7f\u7528\u5b57\u5178\u65b9\u5f0f\u6765\u66f4\u65b0\u5230\u5b58\u50a8\u6587\u4ef6\u4e2d\n        :param dat_dict:\n        :type dat_dict:\n        :return:\n        :rtype:\n        \"\"\"\n        for k, v in dat_dict.items():\n            if isinstance(v, dict):\n                self.cfg.init(k, v['val'], v['proto'])\n            else:\n                self.cfg.init(k, v)\n        self.cfg.sync()"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a client for not repeapting checks", "response": "def c(self):\n        \"\"\"Caching client for not repeapting checks\"\"\"\n        if self._client is None:\n            self._parse_settings()\n            self._client = Rumetr(**self.settings)\n        return self._client"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nparses the scrapy settings and returns a dictionary with the options that are required for the upload.", "response": "def _parse_settings(self):\n        \"\"\"Gets upload options from the scrapy settings\"\"\"\n        if hasattr(self, 'settings'):  # parse setting only one time\n            return\n\n        self.settings = {\n            'auth_key': self._check_required_setting('RUMETR_TOKEN'),\n            'developer': self._check_required_setting('RUMETR_DEVELOPER'),\n        }\n        self.settings.update(self._non_required_settings('RUMETR_API_HOST'))"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _parse_deadline(deadline):\n        if '-' in deadline and len(deadline) == 10:\n            return deadline\n\n        if '.' in deadline and len(deadline) == 10:  # russian format dd.mm.yyyy to yyyy-mm-dd\n            dmy = deadline.split('.')\n            if len(dmy) == 3 and all(v is not None for v in dmy):\n                return '-'.join(reversed(dmy))\n\n        raise exceptions.RumetrUnparsableDeadline()", "response": "Translate deadline date from human - acceptable format to the machine - acceptable format"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nensure a given path *p* exists.", "response": "def ensure_exists(p, assume_dirs=False):\n    \"\"\"\n    Ensures a given path *p* exists.\n\n    If a path to a file is passed in, then the path to the file will be checked. This can be overridden by passing a\n    value of ``True`` to ``assume_dirs``, in which case the paths will be assumed to be to directories, not files.\n    \"\"\"\n    if Path(p).ext and not assume_dirs:\n        Path(p).dirname().makedirs_p()\n    else:\n        Path(p).makedirs_p()\n    return p"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef expand_path(path_list, root_path=None):\n    to_return = set()\n    path_list = wrap_list(path_list)\n\n    # expand ignore list to include all directories as individual entries\n    for p in path_list:\n        p = Path(p)\n        if p.isdir():\n            to_return.add(p)\n        head, tail = p.splitpath()\n        while head and tail:\n            if root_path is not None and head == root_path:\n                break\n            to_return.add(head)\n            head, tail = head.splitpath()\n    return list(to_return)", "response": "Given a list of paths returns a list of all parent paths including the original paths."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef has_files(the_path):\n    the_path = Path(the_path)\n    try:\n        for _ in the_path.walkfiles():\n            return True\n        return False\n    except OSError as ex:\n        if ex.errno == errno.ENOENT:\n            # ignore\n            return False\n        else:\n            raise", "response": "Returns whether the path has any files in it or any subfolders. Works recursively."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nmirrors a folder source into a folder target.", "response": "def mirror_folder(source, target, delete_orphans=True, recurse=True, ignore_list=None, _level=0, logger=None):\n    \"\"\"Mirrors a folder *source* into a target folder *target*.\"\"\"\n\n    logger = logger or logging.getLogger(__name__)\n\n    def expand_tree(p):\n        tree = []\n        for node in Path(p).walk():\n            tree.append(node)\n        return tree\n\n    report = {\n        'deleted': set([]),\n        'overwritten': set([]),\n        'new': set([])\n    }\n    d1 = source\n    d2 = target\n    logger.debug(\"Mirroring %s ==> %s\" % (d1, d2))\n    if not d2.exists():\n        d2.makedirs()\n    compare = filecmp.dircmp(d1, d2)\n\n    # Expand the ignore list to be full paths\n    if ignore_list is None:\n        ignore_list = []\n    else:\n        ignore_list = [Path(d2 / i).normpath() for i in ignore_list]\n        ignore_files = [f for f in ignore_list if f.isfile()]\n        ignore_list.extend(expand_path(ignore_files, root_path=d2))\n\n    # Delete orphan files/folders in the target folder\n    if delete_orphans:\n        for item in compare.right_only:\n            fullpath = Path(d2 / item).normpath()\n            if fullpath in ignore_list:\n                logger.debug(\n                    \"%s ==> Ignored - path is in ignore list\" % fullpath)\n                continue\n\n            if fullpath.isdir() and recurse:\n                logger.debug(\n                    \"%s ==> Deleted - doesn't exist in source\" % fullpath)\n                report['deleted'].add(fullpath)\n                if len(fullpath.listdir()) > 0:\n                    report['deleted'].update(expand_tree(fullpath))\n\n                # noinspection PyArgumentList\n                fullpath.rmtree()\n            elif fullpath.isfile():\n                logger.debug(\n                    \"%s ==> Deleted - doesn't exist in source\" % fullpath)\n                report['deleted'].add(fullpath)\n                fullpath.remove()\n\n    # Copy new files and folders from the source to the target\n    for item in compare.left_only:\n        fullpath = d1 / item\n        if fullpath.isdir() and recurse:\n            logger.debug(\n                \"Copying new directory %s ==> %s\" % (fullpath, (d2 / item)))\n            fullpath.copytree(d2 / item)\n            report['new'].add(d2 / item)\n            report['new'].update(expand_tree(d2 / item))\n        elif fullpath.isfile():\n            logger.debug(\"Copying new file %s ==> %s\" % (fullpath, (d2 / item)))\n            fullpath.copy2(d2)\n            report['new'].add(d2 / item)\n\n    # Copy modified files in the source to the target, overwriting the target file\n    for item in compare.diff_files:\n        logger.debug(\n            \"Overwriting existing file %s ==> %s\" % ((d1 / item), (d2 / item)))\n        (d1 / item).copy2(d2)\n        report['overwritten'].add(d2 / item)\n\n    # Recurse into subfolders that exist in both the source and target\n    if recurse:\n        for item in compare.common_dirs:\n            rpt = mirror_folder(d1 / item, d2 / item, delete_orphans, _level=_level + 1)\n            report['new'].update(rpt['new'])\n            report['overwritten'].update(rpt['overwritten'])\n            report['deleted'].update(rpt['deleted'])\n    return report"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef tokenize(cls, obj):\n    tokens = {}\n\n    try:\n      token_iterator = cls.make_iterable(obj)\n      _lang = cls.language_definition()\n      tokens = {k: [] for k in _lang.argument_types}\n\n      prev, current = None, next(token_iterator)\n\n      while True:\n        token = [None, None]\n        arg_type = None\n\n        for arg_type in _lang.argument_types:\n          arg_start_seq = _lang.argument_types[arg_type]\n          arg_delimiters = _lang.value_delimiters[arg_type]\n\n          if prev is None and arg_start_seq is None:  # just start to scan and got \"default\" token\n            token[1] = current\n            break\n          elif arg_start_seq is None and prev[0] is None:  # next default token\n            token[1] = current\n            break\n          elif arg_start_seq is None and prev[0] is not None:  # default token used after non-default tokens\n            token[1] = current\n            break\n          elif arg_start_seq is None:  # value of non-default token\n            prev[1] = current\n            token = None\n            break\n          elif current[:len(arg_start_seq)] == arg_start_seq:\n            token[0] = current[len(arg_start_seq):]\n\n            for delimiter in arg_delimiters:\n              if delimiter == \" \":\n                continue\n\n              if delimiter in token[0]:\n                _delim = str(token[0]).partition(delimiter)\n                token = [_delim[0], _delim[2]]\n                break\n            break\n\n        if token:\n          tokens[arg_type].append(token)\n\n        prev, current = token, next(token_iterator)\n    except StopIteration:\n      return tokens", "response": "Convert input data to tokens\n   "}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nparse command line to out tree", "response": "def parse(self, argv, tokenizer=DefaultTokenizer):\n    \"\"\"\n    Parse command line to out tree\n\n    :type argv object\n    :type tokenizer AbstractTokenizer\n    \"\"\"\n    args = tokenizer.tokenize(argv)\n    _lang = tokenizer.language_definition()\n\n    #\n    # for param in self.__args:\n    #   if self._is_default_arg(param):\n    #     self.__out_tree[self.__default_arg_tag].append(param.strip())\n    #   else:\n    #     param = param.lstrip(\"-\").partition('=')\n    #     if len(param) == 3:\n    #       self.__parse_one_param(param)\n    pass"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncopying this model element and contained elements if they exist.", "response": "def copy(self, *args, **kwargs):\n        \"\"\"Copy this model element and contained elements if they exist.\"\"\"\n\n        for slot in self.__slots__:\n            attr = getattr(self, slot)\n            if slot[0] == '_':  # convert protected attribute name to public\n                slot = slot[1:]\n            if slot not in kwargs:\n                kwargs[slot] = attr\n\n        result = type(self)(*args, **kwargs)\n\n        return result"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nupdating this element related to other element.", "response": "def update(self, other, copy=True, *args, **kwargs):\n        \"\"\"Update this element related to other element.\n\n        :param other: same type than this.\n        :param bool copy: copy other before update attributes.\n        :param tuple args: copy args.\n        :param dict kwargs: copy kwargs.\n        :return: this\"\"\"\n\n        if other:  # dirty hack for python2.6\n\n            if isinstance(other, self.__class__):\n\n                if copy:\n                    other = other.copy(*args, **kwargs)\n\n                for slot in other.__slots__:\n                    attr = getattr(other, slot)\n                    if attr is not None:\n                        setattr(self, slot, attr)\n\n            else:\n                raise TypeError(\n                    'Wrong element to update with {0}: {1}'.format(self, other)\n                )\n\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef __i(self, other, func):\n\n        if isinstance(other, type(self)):\n            other = tuple(other)\n\n        elif isinstance(other, self.__contenttype__):\n            other = (other, )\n\n        for melt in list(other):\n            if not isinstance(melt, self.__contenttype__):\n                raise TypeError('Wrong element {0}'.format(melt))\n\n            else:\n                func(melt)\n\n        return self", "response": "Process input other with input func."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef update(self, other, copy=True, *args, **kwargs):\n\n        super(CompositeModelElement, self).update(\n            other, copy=copy, *args, **kwargs\n        )\n\n        if other:  # dirty hack for python2.6\n            contents = []\n\n            if isinstance(other, self.__class__):\n                contents = list(other.values())\n\n            elif isinstance(other, self.__contenttype__):\n                contents = [other]\n\n            else:\n                raise TypeError(\n                    'Wrong element to update with {0}: {1}'.format(self, other)\n                )\n\n            for content in contents:\n\n                selfcontent = self.get(content.name)\n\n                if selfcontent is None:\n\n                    if copy:\n                        content = content.copy(local=False)\n                    self[content.name] = content\n\n                else:\n                    selfcontent.update(content, copy=copy, *args, **kwargs)\n\n        return self", "response": "Update this composite model element with other element content."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef params(self):\n\n        result = {}\n\n        for content in list(self.values()):\n\n            if isinstance(content, CompositeModelElement):\n                cparams = content.params\n\n                for cpname in cparams:\n                    cparam = cparams[cpname]\n\n                    if cpname in result:\n                        result[cpname].update(cparam)\n\n                    else:\n                        result[cpname] = cparam.copy()\n\n            elif content.name in result:\n                result[content.name].update(content)\n\n            else:\n                result[content.name] = content.copy()\n\n        return result", "response": "Get set of parameters by names."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nprepare animation for the base class", "response": "def prepare(self, led_count, target_fps):\n        \"\"\"setup animation\"\"\"\n        self.led_count = led_count\n        self.target_fps = target_fps"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nprocesses the anchor start of a list of regions.", "response": "def process_anchor_start(regions_fn, to_count_fn,\n                         anchor_to=ANCHOR_START, normalize=False,\n                         verbose=False):\n  \"\"\"\n  :return: list where each element is the number of hits at that location\n           relative to the start of the regions.\n  \"\"\"\n  res = []\n  possible = []\n  trees = intervalTrees(to_count_fn, verbose=verbose)\n  for region in BEDIterator(regions_fn, verbose=verbose):\n    if normalize:\n      for i in range(0, len(region)):\n        while len(possible) <= i:\n          possible.append(0)\n        possible[i] += 1\n\n    if region.chrom not in trees:\n      continue\n    hits = trees[region.chrom].intersectingInterval(region.start, region.end)\n    for h in hits:\n      abs_pos = h.start\n      if abs_pos < region.start or abs_pos >= region.end:\n        continue\n      rel_pos = __to_relative(abs_pos, region, anchor_to)\n      assert(rel_pos < len(region))\n\n      while(len(res) <= rel_pos):\n        res.append(0)\n      res[rel_pos] += 1\n\n  if normalize:\n    __norm_counts(res, possible)\n  return res"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nprocessing the command line arguments of this script and dispatch.", "response": "def _main(args, prog_name):\n  \"\"\"Process the command line arguments of this script and dispatch.\"\"\"\n  # get options and arguments\n  ui = getUI(prog_name, args)\n\n  if ui.optionIsSet(\"test\"):\n    # just run unit tests\n    unittest.main(argv=[sys.argv[0]])\n  elif ui.optionIsSet(\"help\"):\n    # just show help\n    ui.usage()\n  else:\n    verbose = ui.optionIsSet(\"verbose\")\n\n    # know there are exactly two arguments, because we specified this in the\n    # UI description.\n    regions_fn = ui.getArgument(0)\n    to_count_fn = ui.getArgument(1)\n\n    # get output handle\n    out_fh = sys.stdout\n    if ui.optionIsSet(\"output\"):\n      out_fh = open(ui.getValue(\"output\"), \"w\")\n\n    # norm?\n    norm = ui.optionIsSet(\"normalize\")\n\n    # get anchor point\n    anch = ANCHOR_START\n    if ui.optionIsSet(\"anchor\"):\n      if ui.getValue(\"anchor\") == \"5-prime\":\n        anch = ANCHOR_5PRIME\n\n    res = process_anchor_start(regions_fn, to_count_fn, anchor_to=anch,\n                               normalize=norm, verbose=verbose)\n    write_output(res, out_fh, verbose=verbose)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nwriting fixture to disk.", "response": "def write_fixture_file(context, path):\n    \"\"\"Write fixture to disk.\"\"\"\n\n    print('CWD:', os.getcwd())\n    print('FIXTURE:', path)\n    with open(path, 'w') as stream:\n        stream.write(context.text)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn a link to verba for the given schedule.", "response": "def get_url_for_schedule(self, schedule):\n        \"\"\"\n        Returns a link to verba.  The link varies by campus and schedule.\n        Multiple calls to this with the same schedule may result in\n        different urls.\n        \"\"\"\n        url = self._get_url(schedule)\n        if url is None:\n            return None\n        response = DAO.getURL(url, {\"Accept\": \"application/json\"})\n        if response.status != 200:\n            raise DataFailureException(url, response.status, response.data)\n\n        data = json.loads(response.data)\n\n        if \"ubsLink\" in data:\n            return data[\"ubsLink\"][0][\"search\"]"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef query_yes_no(question, default=\"yes\"):\n    res = _query_yes_no(question, default)\n    if res == \"yes\":\n        return True\n    else:\n        return False", "response": "Ask the user for a yes or no question"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef _query_yes_no(question, default=\"yes\"):\n    valid = {\"yes\": \"yes\", \"y\": \"yes\", \"ye\": \"yes\",\n             \"no\": \"no\", \"n\": \"no\"}\n    if default is None:\n        prompt = \" [y/n] \"\n    elif default == \"yes\":\n        prompt = \" [Y/n] \"\n    elif default == \"no\":\n        prompt = \" [y/N] \"\n    else:\n        raise ValueError(\"invalid default answer: '%s'\" % default)\n\n    while 1:\n        sys.stdout.write(question + prompt)\n        try:\n            choice = raw_input().lower()\n        except KeyboardInterrupt:\n            print\n            return \"no\"\n        if default is not None and choice == '':\n            return default\n        elif choice in valid.keys():\n            return valid[choice]\n        else:\n            sys.stdout.write(\"Please respond with 'yes' or 'no' \"\n                             \"(or 'y' or 'n').\\n\")", "response": "Ask a yes or no question via raw_input and return their answer."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add_section(self, section):\n        if not issubclass(section.__class__, _AbstractSection):\n            raise TypeError(\"argument should be a subclass of Section\")\n        self.sections[section.get_key_name()] = section\n        return section", "response": "Add a new Section object to the config. Should be a subclass of\n       ."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef _load(self, exit_on_failure):\n        # pylint: disable-msg=W0621\n        log = logging.getLogger('argtoolbox')\n        discoveredFileList = []\n        if self.config_file:\n            if isinstance(self.config_file, types.UnicodeType):\n                discoveredFileList = self.file_parser.read(self.config_file)\n            else:\n                discoveredFileList = self.file_parser.readfp(\n                    self.config_file,\n                    \"file descriptor\")\n        else:\n            defaultFileList = []\n            defaultFileList.append(self.prog_name + \".cfg\")\n            defaultFileList.append(\n                os.path.expanduser('~/.' + self.prog_name + '.cfg'))\n            defaultFileList.append('/etc/' + self.prog_name + '.cfg')\n            log.debug(\"defaultFileList: \" + str(defaultFileList))\n            discoveredFileList = self.file_parser.read(defaultFileList)\n\n        log.debug(\"discoveredFileList: \" + str(discoveredFileList))\n\n        if self.mandatory and len(discoveredFileList) < 1:\n            msg = \"The required config file was missing.\"\n            msg += \" Default config files : \" + str(defaultFileList)\n            log.error(msg)\n            raise EnvironmentError(msg)\n\n        log.debug(\"loading configuration ...\")\n        if exit_on_failure:\n            for s in self.sections.values():\n                log.debug(\"loading section : \" + s.get_section_name())\n                try:\n                    s.load(self.file_parser)\n                except ValueError:\n                    sys.exit(1)\n        else:\n            for s in self.sections.values():\n                log.debug(\"loading section : \" + s.get_section_name())\n                s.load(self.file_parser)\n\n        log.debug(\"configuration loaded.\")", "response": "Load all the configuration data from the config file."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_representation(self, prefix=\"\", suffix=\"\\n\"):\n        res = prefix + \"Section \" + self.get_section_name().upper() + suffix\n        return res", "response": "return the string representation of the current object."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef add_element(self, elt):\n        if not isinstance(elt, Element):\n            raise TypeError(\"argument should be a subclass of Element\")\n        self.elements[elt.get_name()] = elt\n        return elt", "response": "Helper to add an element to the current section. The Element name\n        will be used as an identifier."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add_element_list(self, elt_list, **kwargs):\n        for e in elt_list:\n            self.add_element(Element(e, **kwargs))", "response": "Helper to add a list of similar elements to the current section."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef write_config_file(self, f, comments):\n        if len(self.elements) < 1:\n            return\n        super(_Section, self).write_config_file(f, comments)\n\n        for e in self.elements.values():\n            e.write_config_file(f, comments)\n        f.write(\"\\n\")", "response": "This method writes a sample file with attributes descriptions sample values required flags using the configuration object\n        properties."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nloading the current element from the configuration file.", "response": "def load(self, file_parser, section_name):\n        \"\"\"The current element is loaded from the configuration file,\n        all constraints and requirements are checked.\n        Then element hooks are applied.\n        \"\"\"\n        self._load(file_parser, section_name)\n        self.post_load()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _load(self, file_parser, section_name):\n        # pylint: disable-msg=W0621\n        log = logging.getLogger('argtoolbox')\n        try:\n            log.debug(\"looking for field (section=\" + section_name\n                      + \") : \" + self._name)\n            data = None\n            try:\n                if self.e_type == int:\n                    data = file_parser.getint(section_name, self._name)\n                elif self.e_type == float:\n                    data = file_parser.getfloat(section_name, self._name)\n                elif self.e_type == bool:\n                    data = file_parser.getboolean(section_name, self._name)\n                elif self.e_type == list:\n                    data = file_parser.get(section_name, self._name)\n                    data = data.strip()\n                    data = data.decode(locale.getpreferredencoding())\n                    data = data.split()\n                    if not data:\n                        msg = \"The optional field '%(name)s' was present, \\\ntype is list, but the current value is an empty \\\nlist.\" % {\"name\": self._name}\n                        log.error(msg)\n                        raise ValueError(msg)\n                elif self.e_type == str:\n                    data = file_parser.get(section_name, self._name)\n                    # happens only when the current field is present,\n                    # type is string, but value is ''\n                    if not data:\n                        msg = \"The optional field '%(name)s' was present, \\\n                        type is string, but the current value is an empty \\\n                        string.\" % {\"name\": self._name}\n                        log.error(msg)\n                        raise ValueError(msg)\n                    data = data.decode(locale.getpreferredencoding())\n                else:\n                    msg = \"Data type not supported : %(type)s \" % {\n                        \"type\": self.e_type}\n                    log.error(msg)\n                    raise TypeError(msg)\n\n            except ValueError as ex:\n                msg = \"The current field '%(name)s' was present, but the \\\nrequired type is : %(e_type)s.\" %  {\n                \"name\": self._name,\n                \"e_type\": self.e_type\n                }\n                log.error(msg)\n                log.error(str(ex))\n                raise ValueError(str(ex))\n\n            log_data = {\"name\": self._name, \"data\": data,\n                        \"e_type\": self.e_type}\n            if self.hidden:\n                log_data['data'] = \"xxxxxxxx\"\n            log.debug(\"field found : '%(name)s', value : '%(data)s', \\\ntype : '%(e_type)s'\", log_data)\n            self.value = data\n\n        except ConfigParser.NoOptionError:\n            if self.conf_required:\n                msg = \"The required field '%(name)s' was missing from the \\\nconfig file.\" % {\"name\": self._name}\n                log.error(msg)\n                raise ValueError(msg)\n\n            if self.default is not None:\n                self.value = self.default\n                log_data = {\"name\": self._name, \"data\": self.default,\n                            \"e_type\": self.e_type}\n                if self.hidden:\n                    log_data['data'] = \"xxxxxxxx\"\n                log.debug(\"Field not found : '%(name)s', default value : \\\n'%(data)s', type : '%(e_type)s'\", log_data)\n            else:\n                log.debug(\"Field not found : '\" + self._name + \"'\")", "response": "Loads the current element from the configuration file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_arg_parse_arguments(self):\n\n        ret = dict()\n        if self._required:\n            if self.value is not None:\n                ret[\"default\"] = self.value\n            else:\n                ret[\"required\"] = True\n        ret[\"dest\"] = self._name\n        if not self.e_type_exclude:\n            if self.e_type == int or self.e_type == float:\n                # Just override argparse.add_argument 'type' parameter for int or float.\n                ret[\"type\"] = self.e_type\n        if self.value is not None:\n            ret[\"default\"] = self.value\n        if self._desc:\n            ret[\"help\"] = self._desc\n        return ret", "response": "This method returns a dict containing all the argparse options that can be passed to the argument parser."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nadding a section to the tree.", "response": "def add_section(self, section):\n        \"\"\"You can add section inside a Element, the section must be a\n        subclass of SubSection. You can use this class to represent a tree.\n        \"\"\"\n\n        if not issubclass(section.__class__, SubSection):\n            raise TypeError(\"Argument should be a subclass of SubSection, \\\n                             not :\" + str(section.__class__))\n        self.sections[section.name] = section\n        return section"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nadd options to the configuration object.", "response": "def add_config_options(self):\n        \"\"\" You can override this method in order to add your options to the\n        config object.\"\"\"\n        # default section\n        default = self.config.get_default_section()\n        default.add_element(\n            Element('debug',\n                    e_type=int,\n                    e_type_exclude=True,\n                    default=0,\n                    desc=\"\"\"debug level : default : 0.\"\"\"))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef add_commands(self):\n        self.parser.add_argument(\n            '-d',\n            action=\"count\",\n            **self.config.default.debug.get_arg_parse_arguments())", "response": "Add the command line arguments to the argparse parser."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nsplitting a path into a tuple of all directories and then the final directory / file.", "response": "def split(path):\n    'Split a path into a tuple of all directories and then the final directory/file.'\n    if path == '':\n        raise ValueError('Path may not be empty.')\n\n    dn, fn = os.path.split(path)\n    if fn == '':\n        return (dn,)\n    elif dn == '':\n        return (fn,)\n    else:\n        return split(dn) + (fn,)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn the method or name of x in the given namespace.", "response": "def method_or_name(namespace, x):\n    '''\n    If x is a ``str``, get ``namespace.x``.\n\n    Otherwise, simply return ``x``.\n    '''\n    if not isinstance(x, str):\n        return x\n\n    if hasattr(namespace, x):\n        return getattr(namespace, x)\n\n    attrs = [y for y in dir(namespace) if not y.startswith('_')]\n    msg = '''\"%s\" is not available in %s.\nThese attributes are available: %s.''' % (x, namespace.__name__, attrs)\n    raise AttributeError(msg)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef strip_html(self, doc):\n        if not isinstance(doc, six.string_types):\n            return ''\n\n        doc = doc.strip()\n        doc = self.tag_re.sub('', doc)\n        return doc", "response": "This method removes all HTML from a docstring."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nparsing a botocore. parameters. Parameter object and returns a dict of the relevant information about that parameter.", "response": "def parse_param(self, core_param):\n        \"\"\"\n        Returns data about a specific parameter.\n\n        :param core_param: The ``Parameter`` to introspect\n        :type core_param: A ``<botocore.parameters.Parameter>`` subclass\n\n        :returns: A dict of the relevant information\n        \"\"\"\n        return {\n            'var_name': core_param.py_name,\n            'api_name': core_param.name,\n            'required': core_param.required,\n            'docs': self.strip_html(core_param.documentation),\n            'type': core_param.type,\n        }"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ngo through a set of parameters extracting information about each.", "response": "def parse_params(self, core_params):\n        \"\"\"\n        Goes through a set of parameters, extracting information about each.\n\n        :param core_params: The collection of parameters\n        :type core_params: A collection of ``<botocore.parameters.Parameter>``\n            subclasses\n\n        :returns: A list of dictionaries\n        \"\"\"\n        params = []\n\n        for core_param in core_params:\n            params.append(self.parse_param(core_param))\n\n        return params"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef introspect_operation(self, operation):\n        return {\n            'method_name': operation.py_name,\n            'api_name': operation.name,\n            'docs': self.convert_docs(operation.documentation),\n            'params': self.parse_params(operation.params),\n            'output': operation.output,\n        }", "response": "Introspects an entire operation returning a dict of information about the operation."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef introspect_service(self, service_name):\n        data = {}\n        service = self.get_service(service_name)\n\n        for operation in service.operations:\n            # These are ``Operation`` objects, not operation strings.\n            op_data = self.introspect_operation(operation)\n            data[op_data['method_name']] = op_data\n\n        return data", "response": "Introspect all the operations and related information about a service."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_closest_index(myList, myNumber):\n    closest_values_index = _np.where(self.time == take_closest(myList, myNumber))[0][0]\n    return closest_values_index", "response": "Returns the index of the closest value to myNumber in myList."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get(self,path):\n        path = path.upper()\n        if path in self._configCache:\n            return self._configCache[path]\n        else :\n            return self._findConfig(path)", "response": "Get a single config from the cache."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef render_document(template_name, data_name, output_name):\n\n    # Set up environment and load templates from pip package\n    env = Environment(loader=PackageLoader('aide_document')) #TODO: add custom path to templates\n\n    # Create output file, open template and data files, then combine\n    with open(output_name, 'w') as output_file:\n        output = env.get_template(template_name).render(yaml.load(open(data_name)))\n        output_file.write(output)", "response": "Renders a single document into a single MarkDown output file."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef stop(self):\n        LOGGER.debug(\"InjectorService.stop\")\n        self.driver.stop()\n        InjectorUITreeService.requester = None\n        InjectorCachedRegistryFactoryService.requester = None\n        InjectorCachedComponentService.requester = None\n        InjectorCachedGearService.requester = None", "response": "Stop the injector service."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nfinds the Ariane UI tree menu entity depending on its id (priority), value or context address :param entity_id: the Ariane UI tree menu ID to search :param entity_value: the Ariane UI tree menu Value to search :param entity_ca: the Ariane UI tree menu context address to search :return:", "response": "def find_ui_tree_entity(entity_id=None, entity_value=None, entity_ca=None):\n        \"\"\"\n        find the Ariane UI tree menu entity depending on its id (priority), value or context address\n        :param entity_id: the Ariane UI tree menu ID to search\n        :param entity_value: the Ariane UI tree menu Value to search\n        :param entity_ca: the Ariane UI tree menu context address to search\n        :return:\n        \"\"\"\n        LOGGER.debug(\"InjectorUITreeService.find_ui_tree_entity\")\n        operation = None\n        search_criteria = None\n        criteria_value = None\n        if entity_id is not None:\n            operation = 'GET_TREE_MENU_ENTITY_I'\n            search_criteria = 'id'\n            criteria_value = entity_id\n        if operation is None and entity_value is not None:\n            operation = 'GET_TREE_MENU_ENTITY_V'\n            search_criteria = 'value'\n            criteria_value = entity_value\n        if operation is None and entity_ca is not None:\n            operation = 'GET_TREE_MENU_ENTITY_C'\n            search_criteria = 'context address'\n            criteria_value = entity_ca\n\n        ret = None\n        if operation is not None:\n            args = {'properties': {'OPERATION': operation, 'TREE_MENU_ENTITY_ID': criteria_value}}\n            result = InjectorUITreeService.requester.call(args).get()\n\n            if result.rc == 0:\n                ret = InjectorUITreeEntity.json_2_injector_ui_tree_menu_entity(result.response_content)\n            elif result.rc != 404:\n                err_msg = 'InjectorUITreeService.find_ui_tree_entity - Problem while finding ' \\\n                          'injector UI Tree Menu Entity ('+search_criteria+':' + \\\n                          str(criteria_value) + '). ' + \\\n                          'Reason: ' + str(result.response_content) + '-' + str(result.error_message) + \\\n                          \" (\" + str(result.rc) + \")\"\n                LOGGER.warning(err_msg)\n\n        return ret"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef json_2_injector_ui_tree_menu_entity(json_obj):\n        LOGGER.debug(\"InjectorUITreeEntity.json_2_injector_ui_tree_menu_entity\")\n        return InjectorUITreeEntity(\n            uitid=json_obj['id'],\n            value=json_obj['value'],\n            uitype=json_obj['type'],\n            context_address=json_obj['contextAddress'],\n            icon=json_obj['icon'],\n            parent_id=json_obj['parentTreeMenuEntityID'],\n            child_ids=json_obj['childsID'],\n            display_permissions=json_obj['displayPermissions'],\n            display_roles=json_obj['displayRoles'],\n            other_actions_roles=json_obj['otherActionsRoles'] if 'otherActionsRoles' in json_obj else None,\n            other_actions_perms=json_obj['otherActionsPerms'] if 'otherActionsPerms' in json_obj else None,\n            remote_injector_tree_entity_components_cache_id=\n            json_obj['remoteInjectorTreeEntityComponentsCacheId'] if 'remoteInjectorTreeEntityComponentsCacheId' in\n                                                                     json_obj else None,\n\n            remote_injector_tree_entity_gears_cache_id=\n            json_obj['remoteInjectorTreeEntityGearsCacheId'] if 'remoteInjectorTreeEntityGearsCacheId' in\n                                                                json_obj else None\n        )", "response": "Transform remote JSON UI entity to local object"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef injector_ui_tree_menu_entity_2_json(self, ignore_genealogy=False):\n        LOGGER.debug(\"InjectorUITreeEntity.injector_ui_tree_menu_entity_2_json\")\n        if ignore_genealogy:\n            json_obj = {\n                'id': self.id,\n                'value': self.value,\n                'type': self.type,\n                'description': self.description if self.description is not None else \"\",\n                'contextAddress': self.context_address if self.context_address is not None else \"\",\n                'icon': self.icon if self.icon is not None else \"\"\n            }\n            if self.display_permissions is not None:\n                json_obj['displayPermissions'] = self.display_permissions\n            if self.display_roles is not None:\n                json_obj['displayRoles'] = self.display_roles\n            if self.other_actions_perms is not None:\n                json_obj['otherActionsPerms'] = self.other_actions_perms\n            if self.other_actions_roles is not None:\n                json_obj['otherActionsRoles'] = self.other_actions_roles\n            if self.remote_injector_tree_entity_gears_cache_id is not None and \\\n                    self.remote_injector_tree_entity_gears_cache_id:\n                json_obj['remoteInjectorTreeEntityGearsCacheId'] = self.remote_injector_tree_entity_gears_cache_id\n            if self.remote_injector_tree_entity_components_cache_id is not None and \\\n                    self.remote_injector_tree_entity_components_cache_id:\n                json_obj['remoteInjectorTreeEntityComponentsCacheId'] = \\\n                    self.remote_injector_tree_entity_components_cache_id\n        else:\n            json_obj = {\n                'id': self.id,\n                'value': self.value,\n                'type': self.type,\n                'description': self.description if self.description is not None else \"\",\n                'contextAddress': self.context_address if self.context_address is not None else \"\",\n                'icon': self.icon if self.icon is not None else \"\",\n                'parentTreeMenuEntityID': self.parent_id\n            }\n            if self.child_ids is not None:\n                json_obj['childsID'] = self.child_ids\n            if self.display_permissions is not None:\n                json_obj['displayPermissions'] = self.display_permissions\n            if self.display_roles is not None:\n                json_obj['displayRoles'] = self.display_roles\n            if self.other_actions_perms is not None:\n                json_obj['otherActionsPerms'] = self.other_actions_perms\n            if self.other_actions_roles is not None:\n                json_obj['otherActionsRoles'] = self.other_actions_roles\n            if self.remote_injector_tree_entity_gears_cache_id is not None and \\\n                    self.remote_injector_tree_entity_gears_cache_id:\n                json_obj['remoteInjectorTreeEntityGearsCacheId'] = self.remote_injector_tree_entity_gears_cache_id\n            if self.remote_injector_tree_entity_components_cache_id is not None and \\\n                    self.remote_injector_tree_entity_components_cache_id:\n                json_obj['remoteInjectorTreeEntityComponentsCacheId'] = \\\n                    self.remote_injector_tree_entity_components_cache_id\n\n        return json_obj", "response": "transform this local object to JSON"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nsave or update this UI Tree Menu Entity on Ariane server.", "response": "def save(self):\n        \"\"\"\n        save or update this entity on Ariane server\n        :return:\n        \"\"\"\n        LOGGER.debug(\"InjectorUITreeEntity.save\")\n        if self.id and self.value and self.type:\n            ok = True\n\n            if InjectorUITreeService.find_ui_tree_entity(self.id) is None:  # SAVE\n                self_string = str(self.injector_ui_tree_menu_entity_2_json(ignore_genealogy=True)).replace(\"'\", '\"')\n                args = {'properties': {'OPERATION': 'REGISTER', 'TREE_MENU_ENTITY': self_string}}\n                result = InjectorUITreeService.requester.call(args).get()\n                if result.rc != 0:\n                    err_msg = 'InjectorUITreeEntity.save - Problem while saving injector UI Tree Menu Entity (id:' + \\\n                              self.id + '). ' + \\\n                              'Reason: ' + str(result.response_content) + '-' + str(result.error_message) + \\\n                              \" (\" + str(result.rc) + \")\"\n                    LOGGER.warning(err_msg)\n                    ok = False\n\n            else:  # UPDATE\n                self_string = str(self.injector_ui_tree_menu_entity_2_json(ignore_genealogy=True)).replace(\"'\", '\"')\n                args = {'properties': {'OPERATION': 'UPDATE', 'TREE_MENU_ENTITY': self_string}}\n                result = InjectorUITreeService.requester.call(args).get()\n                if result.rc != 0:\n                    err_msg = 'InjectorUITreeEntity.save - Problem while saving injector UI Tree Menu Entity (id:' + \\\n                              self.id + '). ' + \\\n                              'Reason: ' + str(result.response_content) + '-' + str(result.error_message) + \\\n                              \" (\" + str(result.rc) + \")\"\n                    LOGGER.warning(err_msg)\n                    ok = False\n\n            if ok and self.parent_id is not None:\n                args = {'properties': {'OPERATION': 'SET_PARENT', 'TREE_MENU_ENTITY_ID': self.id,\n                                       'TREE_MENU_ENTITY_PARENT_ID': self.parent_id}}\n                result = InjectorUITreeService.requester.call(args).get()\n                if result.rc != 0:\n                    err_msg = 'InjectorUITreeEntity.save - Problem while updating injector UI Tree Menu Entity (id:' + \\\n                              self.id + '). ' + \\\n                              'Reason: ' + str(result.response_content) + '-' + str(result.error_message) + \\\n                              \" (\" + str(result.rc) + \")\"\n                    LOGGER.warning(err_msg)\n        else:\n            err_msg = 'InjectorUITreeEntity.save - Problem while saving or updating ' \\\n                      'injector UI Tree Menu Entity (id:' + self.id + '). ' + \\\n                      'Reason: id and/or value and/or type is/are not defined !'\n            LOGGER.debug(err_msg)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef remove(self):\n        LOGGER.debug(\"InjectorUITreeEntity.remove\")\n        if self.id and InjectorUITreeService.find_ui_tree_entity(self.id) is not None:\n            args = {'properties': {'OPERATION': 'UNREGISTER', 'TREE_MENU_ENTITY_ID': self.id}}\n            result = InjectorUITreeService.requester.call(args).get()\n            if result.rc != 0:\n                err_msg = 'InjectorUITreeEntity.remove - Problem while saving injector UI Tree Menu Entity (id:' + \\\n                          self.id + '). ' + \\\n                          'Reason: ' + str(result.response_content) + '-' + str(result.error_message) + \\\n                          \" (\" + str(result.rc) + \")\"\n                LOGGER.warning(err_msg)\n        else:\n            err_msg = 'InjectorUITreeEntity.remove - Problem while removing injector UI Tree Menu Entity (id:' + \\\n                      self.id + '). ' + \\\n                      'Reason: id is null or injector UI Tree Menu Entity not found'\n            LOGGER.warning(err_msg)", "response": "Removes the entity from the Ariane server."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncreate a new gears registry cache on Ariane Server", "response": "def make_gears_cache_registry(args):\n        \"\"\"\n        create a new gears registry cache on Ariane Server\n        :param args: the cache parameters - look to the tests to know more\n        :return: remote procedure call return - look to the tests to know more\n        \"\"\"\n        LOGGER.debug(\"InjectorCachedRegistryFactoryService.make_gears_cache_registry\")\n        if args is None:\n            err_msg = 'InjectorCachedRegistryFactoryService.make_gears_cache_registry - not args defined !'\n            LOGGER.debug(err_msg)\n            return None\n\n        if 'registry.name' not in args or args['registry.name'] is None or not args['registry.name']:\n            err_msg = 'InjectorCachedRegistryFactoryService.make_gears_cache_registry - registry.name is not defined !'\n            LOGGER.debug(err_msg)\n            return None\n        else:\n            args['ariane.community.injector.gears.registry.name'] = args['registry.name']\n            args.pop('registry.name', None)\n\n        if 'registry.cache.id' not in args or args['registry.cache.id'] is None or not args['registry.cache.id']:\n            err_msg = 'InjectorCachedRegistryFactoryService.make_gears_cache_registry - ' \\\n                      'registry.cache.id is not defined !'\n            LOGGER.debug(err_msg)\n            return None\n        else:\n            args['ariane.community.injector.gears.registry.cache.id'] = args['registry.cache.id']\n            args.pop('registry.cache.id', None)\n\n        if 'registry.cache.name' not in args or args['registry.cache.name'] is None or not args['registry.cache.name']:\n            err_msg = 'InjectorCachedRegistryFactoryService.make_gears_cache_registry - ' \\\n                      'registry.cache.name is not defined !'\n            LOGGER.debug(err_msg)\n            return None\n        else:\n            args['ariane.community.injector.gears.registry.cache.name'] = args['registry.cache.name']\n            args.pop('registry.cache.name', None)\n\n        if 'cache.mgr.name' not in args or args['cache.mgr.name'] is None or not args['cache.mgr.name']:\n            err_msg = 'InjectorCachedRegistryFactoryService.make_gears_cache_registry - cache.mgr.name is not defined !'\n            LOGGER.debug(err_msg)\n            return None\n        else:\n            args['ariane.community.injector.cache.mgr.name'] = args['cache.mgr.name']\n            args.pop('cache.mgr.name', None)\n\n        args['OPERATION'] = 'MAKE_GEARS_REGISTRY'\n        args = {'properties': args}\n        return InjectorCachedRegistryFactoryService.requester.call(args).get()"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nfinds a component from the Ariane server cache depending on its id", "response": "def find_component(co_id):\n        \"\"\"\n        find a component from the Ariane server cache depending on its id\n        :param co_id: the component id to find\n        :return: the component if found and None if not\n        \"\"\"\n        LOGGER.debug(\"InjectorCachedComponentService.find_component\")\n        ret = None\n        if co_id is not None:\n            args = {'properties': {'OPERATION': 'PULL_COMPONENT_FROM_CACHE',\n                                   'REMOTE_COMPONENT': str({'componentId': co_id}).replace(\"'\", '\"'),\n                                   'CACHE_ID': InjectorCachedComponentService.cache_id}}\n\n            result = InjectorCachedComponentService.requester.call(args).get()\n            if result.rc == 0:\n                ret = InjectorCachedComponent.json_2_injector_component(result.response_properties)\n                ret.blob = result.response_content\n            elif result.rc != 404:\n                err_msg = 'InjectorCachedComponentService.find_component - Problem while finding component ( id : ' + \\\n                          co_id + \\\n                          'Reason: ' + str(result.response_content) + '-' + str(result.error_message) + \\\n                          \" (\" + str(result.rc) + \")\"\n                LOGGER.warning(err_msg)\n        return ret"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ncreates a refresh on demand service.", "response": "def make_refresh_on_demand_service(injector_component):\n        \"\"\"\n        create a refresh on demand service listening to refresh order on the component admin queue\n        :param injector_component: the injector_component to bind with the new refresh on demande service\n        :return: the created service\n        \"\"\"\n        LOGGER.debug(\"InjectorCachedComponentService.make_refresh_on_demand_service\")\n        args = {\n            'service_q': injector_component.id,\n            'treatment_callback': injector_component.refresh,\n            'service_name': injector_component.id + \" - On Demand Refreshing Service\"\n        }\n        return InjectorCachedComponentService.driver.make_service(args)"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef json_2_injector_component(json_obj):\n        LOGGER.debug(\"InjectorCachedComponent.json_2_injector_component\")\n        return InjectorCachedComponent(\n            component_id=json_obj['componentId'],\n            component_name=json_obj['componentName'],\n            component_type=json_obj['componentType'],\n            component_admin_queue=json_obj['componentAdminQueue'],\n            refreshing=json_obj['refreshing'],\n            next_action=json_obj['nextAction'],\n            json_last_refresh=json_obj['jsonLastRefresh'],\n            attached_gear_id=json_obj['attachedGearId']\n        )", "response": "Transform the JSON return by Ariane server to local object"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ntransforming this local object to JSON. If properties only ignore the component blob.", "response": "def injector_component_2_json(self, properties_only=False):\n        \"\"\"\n        transform this local object to JSON. If properties only ignore the component blob (awaited by Ariane Server)\n        :param properties_only: true or false\n        :return: the JSON from this local object\n        \"\"\"\n        LOGGER.debug(\"InjectorCachedComponent.injector_component_2_json\")\n        if properties_only:\n            json_obj = {\n                'componentId': self.id,\n                'componentName': self.name,\n                'componentType': self.type if self.type is not None else \"not defined\",\n                'componentAdminQueue': self.admin_queue,\n                'refreshing': 'true' if self.refreshing else 'false',\n                'nextAction': self.next_action,\n                'jsonLastRefresh': self.json_last_refresh,\n                'attachedGearId': self.attached_gear_id\n            }\n        else:\n            json_obj = {\n                'componentId': self.id,\n                'componentName': self.name,\n                'componentType': self.type if self.type is not None else \"not defined\",\n                'componentAdminQueue': self.admin_queue,\n                'refreshing': 'true' if self.refreshing else 'false',\n                'nextAction': self.next_action,\n                'jsonLastRefresh': self.json_last_refresh,\n                'attachedGearId': self.attached_gear_id,\n                'componentBlob': self.blob\n            }\n        return json_obj"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef save(self, refreshing=None, next_action=None, json_last_refresh=None, data_blob=None):\n        LOGGER.debug(\"InjectorCachedComponent.save\")\n        ret = True\n\n        if refreshing is not None:\n            self.refreshing = refreshing\n        if next_action is not None:\n            self.next_action = next_action\n        if json_last_refresh is not None:\n            try:\n                self.json_last_refresh = json_last_refresh.strftime(\"%Y-%m-%d %H:%M:%S.%f\")\n            except AttributeError:\n                self.json_last_refresh = json_last_refresh\n        if data_blob is not None:\n            self.blob = data_blob\n\n        if self.service is None:\n            self.service = InjectorCachedComponentService.make_refresh_on_demand_service(self)\n        if self.service is not None and not self.service.is_started:\n            self.service.start()\n\n        args = {'properties': {'OPERATION': 'PUSH_COMPONENT_IN_CACHE',\n                               'REMOTE_COMPONENT':\n                                   str(self.injector_component_2_json(properties_only=True)).replace(\"'\", '\"'),\n                               'CACHE_ID': InjectorCachedComponentService.cache_id},\n                'body': self.blob}\n\n        result = InjectorCachedComponentService.requester.call(args).get()\n        if result.rc != 0:\n            err_msg = 'InjectorCachedComponent.save - Problem while saving component ( id : ' + self.id + \\\n                      'Reason: ' + str(result.response_content) + '-' + str(result.error_message) + \\\n                      \" (\" + str(result.rc) + \")\"\n            LOGGER.warning(err_msg)\n            ret = False\n\n        return ret", "response": "Save or update the component on the Ariane server cache."}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nremove this component from Ariane server cache stop the on demand refresh and actor linked to this component", "response": "def remove(self):\n        \"\"\"\n        remove this component from Ariane server cache, stop the on demand refresh and actor linked to this component\n        :return:\n        \"\"\"\n        LOGGER.debug(\"InjectorCachedComponent.remove\")\n        ret = True\n        args = {'properties': {'OPERATION': 'DEL_COMPONENT_FROM_CACHE',\n                               'REMOTE_COMPONENT':\n                                   str(self.injector_component_2_json(properties_only=True)).replace(\"'\", '\"'),\n                               'CACHE_ID': InjectorCachedComponentService.cache_id}}\n\n        result = InjectorCachedComponentService.requester.call(args).get()\n        if result.rc != 0:\n            err_msg = 'InjectorCachedComponent.remove - Problem while saving component ( id : ' + self.id + \\\n                      'Reason: ' + str(result.response_content) + '-' + str(result.error_message) + \\\n                      \" (\" + str(result.rc) + \")\"\n            LOGGER.warning(err_msg)\n            ret = False\n\n        if self.service is not None and self.service.is_started:\n            self.service.stop()\n\n        if self.actor_ref is not None:\n            self.stop()\n\n        return ret"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef refresh(self, props, body):\n        LOGGER.debug(\"InjectorCachedComponent.refresh\")\n        operation = props['OPERATION']\n        if operation == \"REFRESH\":\n            if self.parent_actor_ref is not None:\n                parent_actor = self.parent_actor_ref.proxy()\n                parent_actor.sniff().get()\n        else:\n            LOGGER.error(\"InjectorCachedComponent.refresh - Unsupported operation \" + str(operation))", "response": "This method is called when on demand refresh service receive a message."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\npushing this component into the cache :param refreshing: the new refreshing value :param next_action: the new next action value :param data_blob: the new data blob value :param json_last_refresh: the new json last refresh value - if None the date of this call :param rollback_point: define the rollback point with provided values (refreshing, next_action, data_blob and json_last_refresh) :return:", "response": "def cache(self, refreshing=None, next_action=None, data_blob=None, json_last_refresh=None, rollback_point=False):\n        \"\"\"\n        push this component into the cache\n\n        :param refreshing: the new refreshing value\n        :param next_action: the new next action value\n        :param data_blob: the new data blob value\n        :param json_last_refresh: the new json last refresh value - if None the date of this call\n        :param rollback_point: define the rollback point with provided values (refreshing, next_action, data_blob and\n        json_last_refresh)\n        :return:\n        \"\"\"\n        LOGGER.debug(\"InjectorComponentSkeleton.cache\")\n        if json_last_refresh is None:\n            json_last_refresh = datetime.datetime.now()\n        if rollback_point:\n            self.rollback_point_refreshing = refreshing\n            self.rollback_point_next_action = next_action\n            self.rollback_point_data_blob = data_blob\n            self.rollback_point_refreshing = refreshing\n        return self.component_cache_actor.save(refreshing=refreshing, next_action=next_action,\n                                               json_last_refresh=json_last_refresh, data_blob=data_blob).get()"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\npush back last rollbackpoint into the cache", "response": "def rollback(self):\n        \"\"\"\n        push back last rollbackpoint into the cache\n\n        :return:\n        \"\"\"\n        return self.component_cache_actor.save(refreshing=self.rollback_point_refreshing,\n                                               next_action=self.rollback_point_next_action,\n                                               json_last_refresh=self.rollback_point_last_refresh,\n                                               data_blob=self.rollback_point_data_blob).get()"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_gears_cache_size():\n        LOGGER.debug(\"InjectorCachedGearService.get_gears_cache_size\")\n        ret = None\n        args = {'properties': {'OPERATION': 'COUNT_GEARS_CACHE',\n                               'CACHE_ID': InjectorCachedGearService.cache_id}}\n\n        result = InjectorCachedGearService.requester.call(args).get()\n        if result.rc == 0:\n            ret = int(result.response_content)\n        else:\n            err_msg = 'InjectorCachedGearService.get_gears_cache_size - Problem while getting gears cache size' + \\\n                      'Reason: ' + str(result.response_content) + '-' + str(result.error_message) + \\\n                      \" (\" + str(result.rc) + \")\"\n            LOGGER.warning(err_msg)\n        return ret", "response": "Get the Ariane gears cache size"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef make_admin_on_demand_service(injector_gear):\n        LOGGER.debug(\"InjectorCachedGearService.make_admin_on_demand_service\")\n        args = {\n            'service_q': injector_gear.id,\n            'treatment_callback': injector_gear.admin,\n            'service_name': injector_gear.id + \" - On Demand Start/Stop Service\"\n        }\n        return InjectorCachedGearService.driver.make_service(args)", "response": "Create an admin service to start or stop the linked gear\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ntransforms the JSON return by Ariane server to local object", "response": "def json_2_injector_gear(json_obj):\n        \"\"\"\n        transform the JSON return by Ariane server to local object\n        :param json_obj: the JSON returned by Ariane server\n        :return: a new InjectorCachedGear\n        \"\"\"\n        LOGGER.debug(\"InjectorCachedGear.json_2_injector_gear\")\n        return InjectorCachedGear(\n            gear_id=json_obj['gearId'],\n            gear_name=json_obj['gearName'],\n            gear_description=json_obj['gearDescription'],\n            gear_admin_queue=json_obj['gearAdminQueue'],\n            running=json_obj['running']\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ntransforms this local object to JSON.", "response": "def injector_gear_2_json(self):\n        \"\"\"\n        transform this local object to JSON.\n        :return: the JSON from this local object\n        \"\"\"\n        LOGGER.debug(\"InjectorCachedGear.injector_gear_2_json\")\n        json_obj = {\n            'gearId': self.id,\n            'gearName': self.name,\n            'gearAdminQueue': self.admin_queue,\n            'gearDescription': self.description,\n            'running': 'true' if self.running else 'false'\n        }\n        return json_obj"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nsaves or update this cached gear into the Ariane server cache.", "response": "def save(self, running=None):\n        \"\"\"\n        save or update this cached gear into the Ariane server cache\n        :param running: the new running value. if None ignored\n        :return:\n        \"\"\"\n        LOGGER.debug(\"InjectorCachedGear.save\")\n        ret = True\n\n        if running is not None:\n            self.running = running\n\n        if self.service is None:\n            self.service = InjectorCachedGearService.make_admin_on_demand_service(self)\n\n        if self.service is not None and not self.service.is_started:\n            self.service.start()\n\n        args = {'properties': {'OPERATION': 'PUSH_GEAR_IN_CACHE',\n                               'REMOTE_GEAR': str(self.injector_gear_2_json()).replace(\"'\", '\"'),\n                               'CACHE_ID': InjectorCachedGearService.cache_id}}\n\n        result = InjectorCachedGearService.requester.call(args).get()\n        if result.rc != 0:\n            err_msg = 'InjectorCachedGear.save - Problem while saving gear ( id : ' + self.id + \\\n                      'Reason: ' + str(result.response_content) + '-' + str(result.error_message) + \\\n                      \" (\" + str(result.rc) + \")\"\n            LOGGER.warning(err_msg)\n            ret = False\n\n        return ret"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef cache(self, running):\n        LOGGER.debug(\"InjectorGearSkeleton.cache\")\n        self.running = running if running is not None else False\n        return self.cached_gear_actor.save(running).get()", "response": "Save the gear into Ariane server cache\n       "}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nremoving the gear from the cache and stop this actor", "response": "def remove(self):\n        \"\"\"\n        remove the gear from the cache and stop this actor\n        :return:\n        \"\"\"\n        LOGGER.debug(\"InjectorGearSkeleton.remove\")\n        ret = self.cached_gear_actor.remove().get()\n        if self.actor_ref:\n            self.stop()\n        return ret"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef outputscreate():\n    # Create table with a nested index\n    r.db(\"Brain\").table_create(\"Outputs\").run()\n    r.db(\"Brain\").table(\"Outputs\").index_create(\"Output_job_id\", r.row[\"OutputJob\"][\"id\"]).run()\n    r.db(\"Brain\").table(\"Outputs\").index_wait(\"Output_job_id\").run()", "response": "Create the Brain. Outputs table creation\n   "}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nchecking if a config value is set and valid.", "response": "def check_config(self, section, name, has_default=False, value=None, allowEmpty=False):\n    \n    \"\"\"\n    Check if a config value is set\n\n    Returns\n\n    True - config value is set and valid\n    False - config value is not set or invalid\n    \"\"\"\n\n    cfg = self.config\n    if not cfg.has_key(section) or not cfg.get(section).has_key(name):\n      if not has_default:\n        self.config_errors.append(\"%s: %s -> missing\" % (section, name))\n        return False\n      else:\n        return True\n\n    v = cfg.get(section).get(name)\n\n    if v == \"\" and not allowEmpty:\n      self.config_errors.append(\"%s: %s -> empty\" % (section, name))\n      return False\n    return True"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nconvert the results of a query to RdfDatatype instances", "response": "def convert_results(data, **kwargs):\n    \"\"\" converts the results of a query to RdfDatatype instances\n\n        args:\n            data: a list of triples\n    \"\"\"\n    if kwargs.get(\"multiprocessing\", False):\n        manager = SharedManager()\n        manager.register(\"BaseRdfDataType\", BaseRdfDataType)\n        manager.register(\"Uri\", Uri)\n\n        data_l = len(data)\n        group_size = data_l // pool_size\n        if data_l % pool_size:\n            group_size += 1\n        split_data = [data[i:i + group_size]\n                      for i in range(0, data_l, group_size)]\n        output = manager.Queue()\n        # output = manager.list()\n        # output_data = POOL.map(convert_row, split_data)\n        workers = [mp.Process(target=convert_batch, args=(item, output,))\n                   for item in split_data]\n        for worker in workers:\n            # worker.Daemon = True\n            worker.start()\n        results = []\n        while True:\n            running = any(p.is_alive() for p in workers)\n            while not output.empty():\n               results += output.get()\n            if not running:\n                break\n        print(\"Finished - workers not stoped\")\n        for worker in workers:\n            worker.join()\n        # pdb.set_trace()\n        # return output\n        for i in range(output.qsize()):\n            results += output.get()\n        return results\n    else:\n        return [{key:pyrdf(value) for key, value in row.items()}\n                for row in data]"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreplaces characters in string text based in regex sub", "response": "def transform(self, text):\n        \"\"\"Replaces characters in string ``text`` based in regex sub\"\"\"\n        return re.sub(self.regex, self.repl, text)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ndump a ValueTree instance returning its dict representation.", "response": "def dump(values):\n    \"\"\"\n    Dump a ValueTree instance, returning its dict representation.\n\n    :param values:\n    :type values: ValueTree\n    :return:\n    :rtype: dict\n    \"\"\"\n    root = {}\n    def _dump(_values, container):\n        for name,value in _values._values.items():\n            if isinstance(value, ValueTree):\n                container[name] = _dump(value, {})\n            elif isinstance(value, list):\n                items = []\n                for item in value:\n                    if not isinstance(item, str):\n                        raise ValueError()\n                    items.append(item)\n                container[name] = items\n            elif isinstance(value, str):\n                container[name] = value\n            else:\n                raise ValueError()\n        return container\n    return _dump(values, root)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nloads a ValueTree instance from its dict representation.", "response": "def load(obj):\n    \"\"\"\n    Load a ValueTree instance from its dict representation.\n\n    :param obj:\n    :type obj: dict\n    :return:\n    :rtype: ValueTree\n    \"\"\"\n    values = ValueTree()\n    def _load(_obj, container):\n        for name,value in _obj.items():\n            if isinstance(value, dict):\n                path = make_path(name)\n                container.put_container(path)\n                _load(value, container.get_container(path))\n            elif isinstance(value, list):\n                for item in value:\n                    container.append_field(ROOT_PATH, name, item)\n            elif isinstance(value, str):\n                container.put_field(ROOT_PATH, name, value)\n            else:\n                raise ValueError()\n    _load(obj, values)\n    return values"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ncreating a container at the specified path creating any necessary intermediate containers.", "response": "def put_container(self, path):\n        \"\"\"\n        Creates a container at the specified path, creating any necessary\n        intermediate containers.\n\n        :param path: str or Path instance\n        :raises ValueError: A component of path is a field name.\n        \"\"\"\n        path = make_path(path)\n        container = self\n        for segment in path:\n            try:\n                container = container._values[segment]\n                if not isinstance(container, ValueTree):\n                    raise ValueError()\n            except KeyError:\n                valuetree = ValueTree()\n                container._values[segment] = valuetree\n                container = valuetree"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nremoving the container at the specified path.", "response": "def remove_container(self, path):\n        \"\"\"\n        Removes the container at the specified path.\n\n        :param path: str or Path instance\n        :raises ValueError: A component of path is a field name.\n        :raises KeyError: A component of path doesn't exist.\n        \"\"\"\n        path = make_path(path)\n        container = self\n        parent = None\n        for segment in path:\n            parent = container\n            try:\n                container = container._values[segment]\n                if not isinstance(container, ValueTree):\n                    raise ValueError()\n            except KeyError:\n                raise KeyError()\n        del parent._values[path.segments[-1]]"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nreturning the container at the specified path.", "response": "def get_container(self, path):\n        \"\"\"\n        Retrieves the container at the specified path.\n\n        :param path: str or Path instance\n        :return:\n        :rtype: ValueTree\n        :raises ValueError: A component of path is a field name.\n        :raises KeyError: A component of path doesn't exist.\n        \"\"\"\n        path = make_path(path)\n        container = self\n        for segment in path:\n            try:\n                container = container._values[segment]\n                if not isinstance(container, ValueTree):\n                    raise ValueError()\n            except KeyError:\n                raise KeyError()\n        return container"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_container_containers(self, path):\n        container = self.get_container(path)\n        containers = {}\n        for name,value in container._values.items():\n            if isinstance(value, ValueTree):\n                containers[name] = value\n        return containers", "response": "Returns a dict of all containers that are set for the given path."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef contains_container(self, path):\n        path = make_path(path)\n        try:\n            self.get_container(path)\n            return True\n        except KeyError:\n            return False", "response": "Returns True if a container exists at the specified path otherwise False."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\ncreate a new field with the specified name and value at the specified path.", "response": "def put_field(self, path, name, value):\n        \"\"\"\n        Creates a field with the specified name an value at path.  If the\n        field already exists, it will be overwritten with the new value.\n\n        :param path: str or Path instance\n        :param name:\n        :type name: str\n        :param value:\n        :type value: str\n        \"\"\"\n        if not isinstance(value, str):\n            raise ValueError()\n        path = make_path(path)\n        container = self.get_container(path)\n        current = self._values.get(name)\n        if current is not None and isinstance(current, ValueTree):\n            raise TypeError()\n        container._values[name] = value"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nappend the field to the container at the specified path.", "response": "def append_field(self, path, name, value):\n        \"\"\"\n        Appends the field to the container at the specified path.\n\n        :param path: str or Path instance\n        :param name:\n        :type name: str\n        :param value:\n        :type value: str\n        \"\"\"\n        path = make_path(path)\n        container = self.get_container(path)\n        current = container._values.get(name, None)\n        if current is None:\n            container._values[name] = value\n        elif isinstance(current, ValueTree):\n            raise TypeError()\n        elif isinstance(current, list):\n            container._values[name] = current + [value]\n        else:\n            container._values[name] = [current, value]"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nremoving a field from the value tree at the specified path.", "response": "def remove_field(self, path, name):\n        \"\"\"\n        :param path: str or Path instance\n        :param name:\n        :type name: str\n        \"\"\"\n        path = make_path(path)\n        container = self.get_container(path)\n        try:\n            value = container._values[name]\n            if isinstance(value, ValueTree):\n                raise TypeError()\n            del container._values[name]\n        except KeyError:\n            pass"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget a key from the cache.", "response": "def get(self, path, name):\n        \"\"\"\n        :param path: str or Path instance\n        :param name:\n        :type name: str\n        :return:\n        \"\"\"\n        container = self.get_container(path)\n        try:\n            return container._values[name]\n        except KeyError:\n            raise KeyError()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_field(self, path, name):\n        try:\n            value = self.get(path, name)\n            if not isinstance(value, str):\n                raise TypeError()\n            return value\n        except KeyError:\n            raise KeyError()", "response": "Retrieves the value of the field at the specified path."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn True if a field exists at the specified path otherwise False.", "response": "def contains_field(self, path, name):\n        \"\"\"\n        Returns True if a field exists at the specified path, otherwise False.\n\n        :param path: str or Path instance\n        :param name:\n        :type name: str\n        :return:\n        :raises ValueError: A component of path is a field name.\n        :raises TypeError: The field name is a component of a path.\n        \"\"\"\n        try:\n            self.get_field(path, name)\n            return True\n        except KeyError:\n            return False"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nreturn True if a multi - valued field exists at the specified path otherwise False.", "response": "def contains_field_list(self, path, name):\n        \"\"\"\n        Returns True if a multi-valued field exists at the specified path, otherwise False.\n\n        :param path: str or Path instance\n        :param name:\n        :type name: str\n        :return:\n        :raises ValueError: A component of path is a field name.\n        :raises TypeError: The field name is a component of a path.\n        \"\"\"\n        try:\n            self.get_field_list(path, name)\n            return True\n        except KeyError:\n            return False"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef iter_fields(self):\n        def generator(path, values):\n            for name,value in sorted(values.items()):\n                if isinstance(value, ValueTree):\n                    for inner in generator(path + name, value._values):\n                        yield inner\n                else:\n                    yield (path, name, value)\n        return generator(Path([]), self._values)", "response": "Iterate all the fields of the current object as a sequence of tuples."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get():\n    result = runCommand('facter --json', raise_error_on_fail=True)\n    json_facts = result[1]\n    facts = json.loads(json_facts)\n    return facts", "response": "Get local facts about this machine"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\ngets all facts about all nodes", "response": "def get_all():\n    \"\"\" Get all facts about all nodes \"\"\"\n    result = {}\n    for k,v in nago.extensions.info.node_data.items():\n        result[k] = v.get('facts', {})\n    return result"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef send(remote_host=None):\n    my_facts = get()\n    if not remote_host:\n        remote_host = nago.extensions.settings.get('server')\n    remote_node = nago.core.get_node(remote_host)\n    if not remote_node:\n        raise Exception(\"Remote host with token='%s' not found\" % remote_host)\n    response = remote_node.send_command('facts', 'post', host_token=remote_node.token, **my_facts)\n    result = {}\n    result['server_response'] = response\n    result['message'] = \"sent %s facts to remote node '%s'\" % (len(my_facts), remote_node.get('host_name'))\n    return result", "response": "Send my facts to a remote host"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nincrease the resolution of an array by duplicating its values to fill a larger array.", "response": "def extend_array(a, n):\n    \"\"\"Increase the resolution of an array by duplicating its values to fill\n    a larger array.\n\n    Parameters\n    ----------\n    a: array, shape (a1, a2, a3, ...)\n    n: integer\n        Factor by which to expand the array.\n\n    Returns\n    -------\n    ae: array, shape (n * a1, n * a2, n * a3, ...)\n    \"\"\"\n    a_new = a.copy()\n    for d in range(a.ndim):\n        a_new = np.repeat(a_new, n, axis=d)\n    return a_new"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nreturn the value of a field at a subset of points.", "response": "def field_subset(f, inds, rank=0):\n    \"\"\"Return the value of a field at a subset of points.\n\n    Parameters\n    ----------\n    f: array, shape (a1, a2, ..., ad, r1, r2, ..., rrank)\n        Rank-r field in d dimensions\n    inds: integer array, shape (n, d)\n        Index vectors\n    rank: integer\n        The rank of the field (0: scalar field, 1: vector field and so on).\n\n    Returns\n    -------\n    f_sub: array, shape (n, rank)\n        The subset of field values.\n    \"\"\"\n    f_dim_space = f.ndim - rank\n    if inds.ndim > 2:\n        raise Exception('Too many dimensions in indices array')\n    if inds.ndim == 1:\n        if f_dim_space == 1:\n            return f[inds]\n        else:\n            raise Exception('Indices array is 1d but field is not')\n    if inds.shape[1] != f_dim_space:\n        raise Exception('Indices and field dimensions do not match')\n    # It's magic, don't touch it!\n    return f[tuple([inds[:, i] for i in range(inds.shape[1])])]"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns 1 - dimensional cartesian vectors converted into a 3 - dimensional representation with additional dimensional coordinates assumed to be zero.", "response": "def pad_to_3d(a):\n    \"\"\"Return 1- or 2-dimensional cartesian vectors, converted into a\n    3-dimensional representation, with additional dimensional coordinates\n    assumed to be zero.\n\n    Parameters\n    ----------\n    a: array, shape (n, d), d < 3\n\n    Returns\n    -------\n    ap: array, shape (n, 3)\n    \"\"\"\n    a_pad = np.zeros([len(a), 3], dtype=a.dtype)\n    a_pad[:, :a.shape[-1]] = a\n    return a_pad"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nreturns a vector appropriate to a dimensional space with a specified length.", "response": "def pad_length(x, d):\n    \"\"\"Return a vector appropriate to a dimensional space, using an input vector\n    as a prompt depending on its type:\n\n        - If the input is a vector, return that vector.\n        - If the input is a scalar, return a vector filled with that value.\n\n    Useful when a function expects an array specifying values along each axis,\n    but wants to also accept a scalar value in case the length is the same in\n    all directions.\n\n    Parameters\n    ----------\n    x: float or array-like\n        The input parameter that may need padding.\n    d: int\n        The dimensional space to make `x` appropriate for.\n\n    Returns\n    -------\n    x_pad: array-like, shape (d,)\n        The padded parameter.\n    \"\"\"\n    try:\n        x[0]\n    except TypeError:\n        x = d * [x]\n    return np.array(x)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nusing os. rename to move the node.", "response": "def rename(self, dest_path: str):\n        '''\n        use `os.rename()` to move the node.\n        '''\n        if not isinstance(dest_path, str):\n            raise TypeError\n        os.rename(self._path, dest_path)\n        self._path = Path(dest_path).get_abspath()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_parent(self, level=1):\n        '''\n        get parent dir as a `DirectoryInfo`.\n\n        return `None` if self is top.\n        '''\n        try:\n            parent_path = self.path.get_parent(level)\n        except ValueError: # abspath cannot get parent\n            return None\n        assert parent_path\n        return DirectoryInfo(parent_path)", "response": "get parent dir as a DirectoryInfo."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\ncreate from path. return None if path is not exists. return None if path is not a file.", "response": "def from_path(path):\n        '''\n        create from path.\n\n        return `None` if path is not exists.\n        '''\n        if os.path.isdir(path):\n            return DirectoryInfo(path)\n\n        if os.path.isfile(path):\n            return FileInfo(path)\n\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef write(self, data, *, mode=None, buffering=-1, encoding=None, newline=None):\n        ''' write data into the file. '''\n        if mode is None:\n            mode = 'w' if isinstance(data, str) else 'wb'\n        with self.open(mode=mode, buffering=buffering, encoding=encoding, newline=newline) as fp:\n            return fp.write(data)", "response": "write data into the file."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef read(self, mode='r', *, buffering=-1, encoding=None, newline=None):\n        ''' read data from the file. '''\n        with self.open(mode=mode, buffering=buffering, encoding=encoding, newline=newline) as fp:\n            return fp.read()", "response": "read data from the file."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef write_text(self, text: str, *, encoding='utf-8', append=True):\n        ''' write text into the file. '''\n        mode = 'a' if append else 'w'\n        return self.write(text, mode=mode, encoding=encoding)", "response": "write text into the file."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nwrites bytes into the file.", "response": "def write_bytes(self, data: bytes, *, append=True):\n        ''' write bytes into the file. '''\n        mode = 'ab' if append else 'wb'\n        return self.write(data, mode=mode)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncopy the file to dest path.", "response": "def copy_to(self, dest, buffering: int = -1):\n        '''\n        copy the file to dest path.\n\n        `dest` canbe `str`, `FileInfo` or `DirectoryInfo`.\n\n        if `dest` is `DirectoryInfo`, that mean copy into the dir with same name.\n        '''\n        if isinstance(dest, str):\n            dest_path = dest\n        elif isinstance(dest, FileInfo):\n            dest_path = dest.path\n        elif isinstance(dest, DirectoryInfo):\n            dest_path = dest.path / self.path.name\n        else:\n            raise TypeError('dest is not one of `str`, `FileInfo`, `DirectoryInfo`')\n\n        with open(self._path, 'rb', buffering=buffering) as source:\n            # use x mode to ensure dest does not exists.\n            with open(dest_path, 'xb') as dest_file:\n                for buffer in source:\n                    dest_file.write(buffer)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef read_text(self, encoding='utf-8') -> str:\n        ''' read all text into memory. '''\n        with self.open('r', encoding=encoding) as fp:\n            return fp.read()", "response": "read all text into memory."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef dump(self, obj, format=None, *, kwargs={}):\n        '''\n        serialize the `obj` into file.\n\n        * raise `FormatNotFoundError` on unknown format.\n        * raise `SerializeError` on any serialize exceptions.\n        '''\n        return dump(self, obj, format=format, kwargs=kwargs)", "response": "Serialize the object into a file."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_file_hash(self, *algorithms: str):\n        '''\n        get lower case hash of file.\n\n        return value is a tuple, you may need to unpack it.\n\n        for example: `get_file_hash('md5', 'sha1')` return `('XXXX1', 'XXXX2')`\n        '''\n        from .hashs import hashfile_hexdigest\n        return hashfile_hexdigest(self._path, algorithms)", "response": "get lower case hash of file"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nget items from directory.", "response": "def iter_items(self, depth: int = 1):\n        '''\n        get items from directory.\n        '''\n        if depth is not None and not isinstance(depth, int):\n            raise TypeError\n        def itor(root, d):\n            if d is not None:\n                d -= 1\n                if d < 0:\n                    return\n            for name in os.listdir(root):\n                path = os.path.join(root, name)\n                node = NodeInfo.from_path(path)\n                yield node\n                if isinstance(node, DirectoryInfo):\n                    yield from itor(path, d)\n        yield from itor(self._path, depth)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef has_file(self, name: str):\n        '''\n        check whether this directory contains the file.\n        '''\n        return os.path.isfile(self._path / name)", "response": "check whether this directory contains the file name"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef has_directory(self, name: str):\n        '''\n        check whether this directory contains the directory.\n        '''\n        return os.path.isdir(self._path / name)", "response": "check whether this directory contains the directory name."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_fileinfo(self, name: str):\n        '''\n        get a `FileInfo` for a file (without create actual file).\n        '''\n        return FileInfo(os.path.join(self._path, name))", "response": "get a FileInfo object for a file."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_dirinfo(self, name: str):\n        '''\n        get a `DirectoryInfo` for a directory (without create actual directory).\n        '''\n        return DirectoryInfo(os.path.join(self._path, name))", "response": "get a DirectoryInfo for a directory."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef create_file(self, name: str, generate_unique_name: bool = False):\n        '''\n        create a `FileInfo` for a new file.\n\n        if the file was exists, and `generate_unique_name` if `False`, raise `FileExistsError`.\n\n        the op does mean the file is created on disk.\n        '''\n        def enumerate_name():\n            yield name\n            index = 0\n            while True:\n                index += 1\n                yield f'{name} ({index})'\n        for n in enumerate_name():\n            path = os.path.join(self._path, n)\n            if os.path.exists(path):\n                if not generate_unique_name:\n                    raise FileExistsError\n            return FileInfo(path)", "response": "create a FileInfo for a new file."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ncreates hardlink for the directory", "response": "def create_hardlink(self, dest_path: str):\n        ''' create hardlink for the directory (includes childs). '''\n\n        # self\n        dirinfo = DirectoryInfo(dest_path)\n        dirinfo.ensure_created()\n\n        # child\n        for item in self.list_items():\n            item.create_hardlink(os.path.join(dest_path, item.path.name))"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ntransforms two unrelated random variables into correlated bivariate data", "response": "def rand_bivar(X, rho):\n    \"\"\"Transform two unrelated random variables into correlated bivariate data\n\n    X : ndarray\n        two univariate random variables\n        with N observations as <N x 2> matrix\n\n    rho : float\n        The Pearson correlations coefficient\n        as number between [-1, +1]\n    \"\"\"\n    import numpy as np\n    Y = np.empty(X.shape)\n    Y[:, 0] = X[:, 0]\n    Y[:, 1] = rho * X[:, 0] + np.sqrt(1.0 - rho**2) * X[:, 1]\n    return Y"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef link_to(self, source, transformation=None):\n        if isinstance(source, KerviValue):\n            if source.is_input and not self.is_input:\n                self.add_observer(source, transformation)\n            elif not source.is_input and self.is_input:\n                source.add_observer(self, transformation)\n            else:\n                raise Exception(\"input/output mismatch in kervi value link:{0} - {1}\".format(source.name, self.name))\n        elif isinstance(source, str):\n            if len(self._spine_observers) == 0:\n                self.spine.register_event_handler(\"valueChanged\", self._link_changed_event)\n\n            self._spine_observers[source] = transformation", "response": "Link this value to another kervi value."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add_value_event(self, event_value, func, event_type=None, parameters=None, **kwargs):\n        self._value_event_handlers += [(event_value, func, event_type, parameters, kwargs)]", "response": "Adds a function to be called when the value reach or pass the event_value."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef get_day():\n    day = datetime.datetime.today().weekday()\n    if len(sys.argv) == 3:\n        if sys.argv[2] == \"mon\":\n            day = 0\n        elif sys.argv[2] == \"tue\":\n            day = 1\n        elif sys.argv[2] == \"wed\":\n            day = 2\n        elif sys.argv[2] == \"thur\":\n            day = 3\n        elif sys.argv[2] == \"fri\":\n            day = 4\n        else:\n            day = 5\n    if day > 4:\n        print(\"There is no information about the menu today.\")\n        exit(5)\n    return day", "response": "Function for retrieving the wanted day"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef print_menu(place, static=False):\n    day = get_day()\n    if static:\n        plan = get(FILES[1])\n        for meal in plan[\"weeks\"][0][\"days\"][day][place][\"meals\"]:\n            if place == \"Diner\":\n                print(meal[\"category\"] + \" \" + meal[\"meal\"])\n            else:\n                print(meal[\"category\"] + \": \" + meal[\"meal\"])\n    else:\n        plan = get(FILES[0])\n        for meal in plan[\"weeks\"][0][\"days\"][day][place][\"meals\"]:\n            print(meal[\"category\"] + \": \" + meal[\"meal\"])", "response": "Function for printing the menu"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef setup(\n\twork_dir=\".resort\",\n\tprofiles=None\n):\n\n\t\"\"\"\n\tConfigures a project to be managed by *resort*.\n\t\n\t:param str work_dir:\n\t   Path of directory were profiles will be created.\n\t:param dict profiles:\n\t   Dictionary containing profile type and instance entries.\n\t\"\"\"\n\t\n\t# Initialize colorama\n\tcolorama.init()\n\t\n\t# Program name\n\tprog_name = sys.argv[0]\n\t\n\t# Profile manager\n\tprof_mgr = engine.ProfileManager(os.getcwd(), work_dir, profiles)\n\t\n\t# Retrieve arguments\n\tparser = argparse.ArgumentParser(\n\t\tprog=prog_name\n\t)\n\tparser.add_argument(\n\t\t\"profile\",\n\t\tmetavar=\"profile\",\n\t\ttype=str,\n\t\tnargs=1,\n\t\thelp=\"Profile name\"\n\t)\n\tparser.add_argument(\n\t\t\"command\",\n\t\tmetavar=\"command\",\n\t\ttype=argparse_command,\n\t\tnargs=1,\n\t\thelp=\"Command name\"\n\t)\n\tparser.add_argument(\n\t\t\"arguments\",\n\t\tmetavar=\"args\",\n\t\tnargs=argparse.REMAINDER,\n\t\thelp=\"Command arguments\"\n\t)\n\targs = parser.parse_args(sys.argv[1:])\n\t\n\t# Execute command\n\tcmd_name, cmd_fn = args.command[0]\n\tcmd_prog_name = \"{} profile {}\".format(prog_name, cmd_name)\n\tprof_name = args.profile[0]\n\tprog_args = args.arguments\n\tcmd_fn(cmd_prog_name, prof_mgr, prof_name, prog_args)", "response": "This function is called by the command line program that is used to configure a project."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nprint the list of components.", "response": "def command_list(prog_name, prof_mgr, prof_name, prog_args):\n\n\t\"\"\"\n\tPrint the list of components.\n\t\"\"\"\n\t\n\t# Retrieve arguments\n\tparser = argparse.ArgumentParser(\n\t\tprog=prog_name\n\t)\n\targs = parser.parse_args(prog_args)\n\t\n\t# Profile load\n\tprof_stub = prof_mgr.load(prof_name)\n\t\n\t# Print component list\n\tout = io.StringIO()\n\tfor comp_stub in prof_stub.component_list():\n\t\tif comp_stub.name() is not None:\n\t\t\tout.write(comp_stub.name())\n\t\t\tout.write(\"\\n\")\n\tout.seek(0)\n\tsys.stdout.write(out.read())"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\nprint status of component tree.", "response": "def command_status(prog_name, prof_mgr, prof_name, prog_args):\n\n\t\"\"\"\n\tShow status of component tree.\n\t\"\"\"\n\t\n\t# Retrieve arguments\n\tparser = argparse.ArgumentParser(\n\t\tprog=prog_name\n\t)\n\tparser.add_argument(\n\t\t\"-t\",\n\t\t\"--type\",\n\t\trequired=False,\n\t\taction=\"store_true\",\n\t\tdefault=False,\n\t\tdest=\"show_type\",\n\t\thelp=\"show component qualified class name\"\n\t)\n\tparser.add_argument(\n\t\t\"-d\",\n\t\t\"--depth\",\n\t\tmetavar=\"tree_depth\",\n\t\trequired=False,\n\t\ttype=argparse_status_depth,\n\t\tdefault=None,\n\t\tdest=\"tree_depth\",\n\t\thelp=\"integer value of dependency tree depth\"\n\t)\n\tparser.add_argument(\n\t\t\"components\",\n\t\tmetavar=\"comps\",\n\t\tnargs=argparse.REMAINDER,\n\t\thelp=\"system components\"\n\t)\n\targs = parser.parse_args(prog_args)\n\t\n\t# Profile load\n\tprof_stub = prof_mgr.load(prof_name)\n\t\n\t# Collect component stubs\n\tcomp_stubs = []\n\tif len(args.components) == 0:\n\t\traise Exception(\"Empty component list\")\n\tfor comp_name in args.components:\n\t\tcomp_stub = prof_stub.component(comp_name)\n\t\tcomponent_exists(prof_stub, comp_stub)\n\t\tcomp_stubs.append(comp_stub)\n\t\t\n\t# Print status\n\tshow_type = args.show_type\n\ttree_depth = args.tree_depth\n\tcontext = prof_stub.context()\n\tout = io.StringIO()\n\tfor i, comp_stub in enumerate(comp_stubs):\n\t\tlast = i == len(comp_stubs) - 1\n\t\tprint_component_status(out, context, comp_stub, last, 1, [], show_type,\n\t\t\t\ttree_depth)\n\tout.seek(0)\n\tsys.stdout.write(out.read())"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nfetching the entry point for a plugin and calls it with the given aux_info", "response": "def load_plugin(category, name, aux_info=None):\n    '''fetches the entry point for a plugin and calls it with the given\n    aux_info'''\n    func = load_simple_endpoint(category, name)\n    if aux_info is None:\n        return func()\n    else:\n        return func(aux_info)\n    raise KeyError(name)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nloads an entry point for a plugin and calls it with the given aux_info", "response": "def load_simple_endpoint(category, name):\n    '''fetches the entry point for a plugin and calls it with the given\n    aux_info'''\n    for ep in pkg_resources.iter_entry_points(category):\n        if ep.name == name:\n            return ep.load()\n    raise KeyError(name)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef gp_sims(version):\n  inDir, outDir = getWorkDirs()\n  inDir = os.path.join(inDir, version, 'cocktail_contribs')\n  xmax = {\n      'pion': 0.125, 'eta': 0.52, 'etap': 0.92, 'omega': 1.22,\n      'phi': 1.22, 'jpsi': 3.52\n  }\n  for particles in [\n      'pion', 'eta', 'etap', ['omega', 'rho'], 'phi', 'jpsi'\n  ]:\n      if isinstance(particles, str):\n          particles = [particles]\n      contribs = OrderedDict()\n      for particle in particles:\n          for energy in energies:\n              fstem = particle+str(energy)\n              fname = os.path.join(inDir, fstem+'.dat')\n              contribs[fstem] = np.loadtxt(open(fname, 'rb'))\n              contribs[fstem][:,2:] = 0\n      print contribs.keys()\n      titles = [\n          ' '.join([getEnergy4Key(str(energy)), 'GeV'])\n          for energy in energies\n      ] + [ '' for k in range(len(contribs)-len(energies)) ]\n      make_plot(\n          data = contribs.values(),\n          properties = [\n              'with lines lc %s lw 4 lt %d' % (\n                  default_colors[i%len(energies)], i/len(energies)+1\n              ) for i in xrange(len(contribs))\n          ],\n          titles = titles,\n          xlabel = xlabel, # if particles[0] == 'phi' else '',\n          ylabel = ylabel, # if particles[0] == 'pion' or particles[0] == 'omega' else '',\n          name = os.path.join(outDir, '_'.join(['sims']+particles)),\n          ylog = True, lmargin = 0.15, bmargin = 0.17, tmargin = 0.96, rmargin = 0.98,\n          gpcalls = [ 'nokey' ] if particles[0] != 'pion' else [],\n          xr = [1. if particles[0] == 'jpsi' else 0,xmax[particles[0]]],\n          size = '10in,6.5in',\n          labels = {\n              particleLabel4Key(particles[0]): [0.15,0.9,False],\n              particleLabel4Key(particles[1]) if len(particles) > 1 else '': [0.15,0.1,False],\n          }\n      )", "response": "example for a batch generating simple plots"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef gp_sims_panel(version):\n  inDir, outDir = getWorkDirs()\n  inDir = os.path.join(inDir, version)\n  mesons = ['pion', 'eta', 'etap', 'rho', 'omega', 'phi', 'jpsi']\n  fstems = ['cocktail_contribs/'+m for m in mesons] + ['cocktail', 'cocktail_contribs/ccbar']\n  data = OrderedDict((energy, [\n      np.loadtxt(open(os.path.join(inDir, fstem+str(energy)+'.dat'), 'rb'))\n      for fstem in fstems\n  ]) for energy in energies)\n  for v in data.values():\n      # keep syserrs for total cocktail\n      v[-2][:,(2,3)] = 0\n      # all errors zero for cocktail contribs\n      v[-1][:,2:] = 0\n      for d in v[:-2]: d[:,2:] = 0\n  make_panel(\n      dpt_dict = OrderedDict((\n          ' '.join([getEnergy4Key(str(energy)), 'GeV']),\n          [ data[energy], [\n              'with %s lc %s lw 5 lt %d' % (\n                  'lines' if i!=len(fstems)-2 else 'filledcurves pt 0',\n                  default_colors[(-2*i-2) if i!=len(fstems)-2 else 0] \\\n                  if i!=len(fstems)-1 else default_colors[1], int(i==3)+1\n              ) for i in xrange(len(fstems))\n          ], [particleLabel4Key(m) for m in mesons] + [\n              'Cocktail (w/o {/Symbol \\162})', particleLabel4Key('ccbar')\n          ]]\n      ) for energy in energies),\n      name = os.path.join(outDir, 'sims_panel'),\n      ylog = True, xr = [0.,3.2], yr = [1e-6,9],\n      xlabel = xlabel, ylabel = ylabel,\n      layout = '2x2', size = '7in,9in',\n      key = ['width -4', 'spacing 1.5', 'nobox', 'at graph 0.9,0.95']\n  )", "response": "make a panel plot of cocktail simulations at all energies includ. total\n     "}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef gp_sims_total_overlay(version):\n  inDir, outDir = getWorkDirs()\n  inDir = os.path.join(inDir, version)\n  data = OrderedDict()\n  for energy in energies:\n      fname = os.path.join(inDir, 'cocktail'+str(energy)+'.dat')\n      data[energy] = np.loadtxt(open(fname, 'rb'))\n      data[energy][:,2:] = 0\n  make_plot(\n      data = data.values(),\n      properties = [\n          'with lines lc %s lw 4 lt 1' % (default_colors[i])\n          for i in xrange(len(energies))\n      ],\n      titles = [\n          ' '.join([getEnergy4Key(str(energy)), 'GeV'])\n          for energy in energies\n      ],\n      xlabel = xlabel, ylabel = ylabel,\n      name = os.path.join(outDir, 'sims_total_overlay'),\n      ylog = True, xr = [0.,3.2], yr = [1e-6,9],\n      tmargin = 0.98, rmargin = 0.99, bmargin = 0.14,\n      size = '8.5in,8in',\n  )", "response": "single plot comparing total cocktails at all energies\n     "}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nensuring OS image at url has been downloaded and unpacked.", "response": "def ensure_image(name, url, images_root, md5, untar_to=None):\n    \"\"\"Ensure OS image at url has been downloaded and (optionally) unpacked.\"\"\"\n    image_dir_path = os.path.join(images_root, name)\n    mkdir(image_dir_path)\n    image_file_path = os.path.join(image_dir_path, os.path.basename(url))\n    ensure_file(url, image_file_path, md5)\n    if untar_to:\n        prepare_image(image_file_path, untar_to)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nunpack the OS image stored at tarpath to outfolder.", "response": "def prepare_image(tarpath, outfolder, **kwargs):\n    \"\"\"Unpack the OS image stored at tarpath to outfolder.\n\n    Prepare the unpacked image for use as a VR base image.\n\n    \"\"\"\n    outfolder = path.Path(outfolder)\n    untar(tarpath, outfolder, **kwargs)\n\n    # Some OSes have started making /etc/resolv.conf into a symlink to\n    # /run/resolv.conf.  That prevents us from bind-mounting to that\n    # location.  So delete that symlink, if it exists.\n    resolv_path = outfolder / 'etc' / 'resolv.conf'\n    if resolv_path.islink():\n        resolv_path.remove().write_text('', encoding='ascii')"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nensures that the image is downloaded and unpacked.", "response": "def ensure_image(self):\n        \"\"\"\n        Ensure that config.image_url has been downloaded and unpacked.\n        \"\"\"\n        image_folder = self.get_image_folder()\n        if os.path.exists(image_folder):\n            print(\n                'OS image directory {} exists...not overwriting' .format(\n                    image_folder))\n            return\n\n        ensure_image(\n            self.config.image_name,\n            self.config.image_url,\n            IMAGES_ROOT,\n            getattr(self.config, 'image_md5', None),\n            self.get_image_folder()\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nsend a notification to all registered listeners.", "response": "def notify(self, msg):\n        \"\"\"Send a notification to all registered listeners.\n\n        msg : str\n            Message to send to each listener\n        \"\"\"\n        for listener in self.listeners:\n            self._send(listener, msg)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef monitor(self, msg, transformer=lambda _: _, unpack=False):\n        def decorator(fn):\n            @wraps(fn)\n            def wrapper(*args, **kw):\n                results = fn(*args, **kw)\n                transformed = transformer(results)\n                if unpack:\n                    if isinstance(results, dict):\n                        self.notify(msg.format(**transformed))\n                    else:\n                        self.notify(msg.format(*transformed))\n                else:\n                    self.notify(msg.format(transformed))\n                return results\n            return wrapper\n        return decorator", "response": "Decorator that sends a notification to all listeners when the wrapped function returns optionally reporting said function s return value ( s )."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns an instance of the dependancies manager with given args and kwargs", "response": "def get_deps_manager(self, *args, **kwargs):\n        \"\"\"\n        Return instance of the dependancies manager using given args and kwargs\n\n        Add 'silent_key_error' option in kwargs if not given.\n        \"\"\"\n        if 'silent_key_error' not in kwargs:\n            kwargs['silent_key_error'] = self.silent_key_error\n        return self.deps_manager(*args, **kwargs)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nbuild source from global and item templates", "response": "def build_template(self, mapfile, names, renderer):\n        \"\"\"\n        Build source from global and item templates\n        \"\"\"\n        AVAILABLE_DUMPS = json.load(open(mapfile, \"r\"))\n\n        manager = self.get_deps_manager(AVAILABLE_DUMPS)\n\n        fp = StringIO.StringIO()\n\n        for i, item in enumerate(manager.get_dump_order(names), start=1):\n            fp = renderer(fp, i, item, manager[item])\n\n        if self.dump_other_apps:\n            exclude_models = ['-e {0}'.format(app) for app in\n                    self.exclude_apps]\n            for i, item in enumerate(manager.get_dump_order(names), start=1):\n                for model in manager[item]['models']:\n                    if '-e ' not in model:\n                        model = \"-e {0}\".format(model)\n                    if model not in exclude_models:\n                        exclude_models.append(model)\n            fp = renderer(fp, i+1, 'other_apps', {'models': exclude_models,\n                                                  'use_natural_key': True})\n\n        content = fp.getvalue()\n        fp.close()\n\n        context = self.get_global_context().copy()\n        context.update({'items': content})\n\n        return self.base_template.format(**context)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nreturning a formated dict context for dump item", "response": "def _get_dump_item_context(self, index, name, opts):\n        \"\"\"\n        Return a formated dict context\n        \"\"\"\n        c = {\n            'item_no': index,\n            'label': name,\n            'name': name,\n            'models': ' '.join(opts['models']),\n            'natural_key': '',\n        }\n        if opts.get('use_natural_key', False):\n            c['natural_key'] = ' -n'\n        c.update(self.get_global_context())\n        return c"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nbuilding a StringIO template to build a command line for dumpdata", "response": "def _dumpdata_template(self, stringbuffer, index, name, opts):\n        \"\"\"\n        StringIO \"templates\" to build a command line for 'dumpdata'\n        \"\"\"\n        context = self._get_dump_item_context(index, name, opts)\n\n        stringbuffer.write(self.dumper_item_template.format(**context))\n\n        return stringbuffer"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\nbuilds a StringIO template to build a command line for loaddata", "response": "def _loaddata_template(self, stringbuffer, index, name, opts):\n        \"\"\"\n        StringIO \"templates\" to build a command line for 'loaddata'\n        \"\"\"\n        context = self._get_dump_item_context(index, name, opts)\n\n        stringbuffer.write(self.loadder_item_template.format(**context))\n\n        return stringbuffer"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef generate_dumper(self, mapfile, names):\n        return self.build_template(mapfile, names, self._dumpdata_template)", "response": "Generate dumpdata for a set of names"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngenerates a loaddata template for the given names.", "response": "def generate_loader(self, mapfile, names):\n        \"\"\"\n        Build loaddata commands\n        \"\"\"\n        return self.build_template(mapfile, names, self._loaddata_template)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef tbframes(tb):\n  'unwind traceback tb_next structure to array'\n  frames=[tb.tb_frame]\n  while tb.tb_next: tb=tb.tb_next; frames.append(tb.tb_frame)\n  return frames", "response": "unwind traceback tb_next structure to array"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef tbfuncs(frames):\n  'this takes the frames array returned by tbframes'\n  return ['%s:%s:%s'%(os.path.split(f.f_code.co_filename)[-1],f.f_code.co_name,f.f_lineno) for f in frames]", "response": "this takes the frames array returned by tbframes"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef meth_once(f):\n  \"call once for member function (i.e. takes self as first arg)\"\n  attr = '__meth_once_'+f.__name__\n  @functools.wraps(f)\n  def f2(self,*args,**kwargs):\n    if hasattr(self,attr): raise CallOnceError(f.__name__)\n    setattr(self,attr,True)\n    return f(self,*args,**kwargs)\n  return f2", "response": "call once for member function ( i. e. takes self as first arg"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef add_result(self, _type, test, exc_info=None):\n        if exc_info is not None:\n            exc_info = FrozenExcInfo(exc_info)\n        test.time_taken = time.time() - self.start_time\n        test._outcome = None\n        self.result_queue.put((_type, test, exc_info))", "response": "Adds the given result to the list of results for the given type of test."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef addSuccess(self, test: unittest.case.TestCase) -> None:\n        # noinspection PyTypeChecker\n        self.add_result(TestState.success, test)", "response": "Adds a test as a success event to the result queue."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nadds a test result to the set of failures that occurred in the given test.", "response": "def addFailure(self, test: unittest.case.TestCase, exc_info: tuple) -> None:\n        \"\"\"\n        Transforms the test in a serializable version of it and sends it to a queue for further analysis\n\n        :param test: the test to save\n        :param exc_info: tuple of the form (Exception class, Exception instance, traceback)\n        \"\"\"\n        # noinspection PyTypeChecker\n        self.add_result(TestState.failure, test, exc_info)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef addError(self, test: unittest.case.TestCase, exc_info: tuple) -> None:\n        # noinspection PyTypeChecker\n        self.add_result(TestState.error, test, exc_info)", "response": "Adds an error result to the test queue."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef addExpectedFailure(self, test: unittest.case.TestCase, err: tuple) -> None:\n        # noinspection PyTypeChecker\n        self.add_result(TestState.expected_failure, test, err)", "response": "Adds an expected failure result to the test set."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nadding an unexpected success test to the test set.", "response": "def addUnexpectedSuccess(self, test: unittest.case.TestCase) -> None:\n        \"\"\"\n        Transforms the test in a serializable version of it and sends it to a queue for further analysis\n\n        :param test: the test to save\n        \"\"\"\n        # noinspection PyTypeChecker\n        self.add_result(TestState.unexpected_success, test)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef addSkip(self, test: unittest.case.TestCase, reason: str):\n        test.time_taken = time.time() - self.start_time\n        test._outcome = None\n        self.result_queue.put((TestState.skipped, test, reason))", "response": "Adds a test to the result queue for further analysis"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nregister a test as error", "response": "def addError(self, test, err):\n        \"\"\"\n        registers a test as error\n\n        :param test: test to register\n        :param err: error the test gave\n        \"\"\"\n        super().addError(test, err)\n        self.test_info(test)\n        self._call_test_results('addError', test, err)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nregisters as test as expected failure", "response": "def addExpectedFailure(self, test, err):\n        \"\"\"\n        registers as test as expected failure\n\n        :param test: test to register\n        :param err: error the test gave\n        \"\"\"\n        super().addExpectedFailure(test, err)\n        self.test_info(test)\n        self._call_test_results('addExpectedFailure', test, err)"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef addFailure(self, test, err):\n        super().addFailure(test, err)\n        self.test_info(test)\n        self._call_test_results('addFailure', test, err)", "response": "registers a test as failure\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nregisters a test as skipped", "response": "def addSkip(self, test, reason):\n        \"\"\"\n        registers a test as skipped\n\n        :param test: test to register\n        :param reason: reason why the test was skipped\n        \"\"\"\n        super().addSkip(test, reason)\n        self.test_info(test)\n        self._call_test_results('addSkip', test, reason)"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef addSuccess(self, test):\n        super().addSuccess(test)\n        self.test_info(test)\n        self._call_test_results('addSuccess', test)", "response": "registers a test as successful\n       "}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef addUnexpectedSuccess(self, test):\n        super().addUnexpectedSuccess(test)\n        self.test_info(test)\n        self._call_test_results('addUnexpectedSuccess', test)", "response": "registers a test as an unexpected success"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nprocesses the queue until the cleanup flag is set.", "response": "def run(self) -> None:\n        \"\"\"\n        processes entries in the queue until told to stop\n        \"\"\"\n        while not self.cleanup:\n            try:\n                result, test, additional_info = self.result_queue.get(timeout=1)\n            except queue.Empty:\n                continue\n\n            self.result_queue.task_done()\n\n            if result == TestState.serialization_failure:\n                test = self.tests[test]\n                warnings.warn(\"Serialization error: {} on test {}\".format(\n                    additional_info, test), SerializationWarning)\n                test(self)\n\n            else:\n                self.testsRun += 1\n\n                if result == TestState.success:\n                    self.addSuccess(test)\n                elif result == TestState.failure:\n                    self.addFailure(test, additional_info)\n                elif result == TestState.error:\n                    self.addError(test, additional_info)\n                elif result == TestState.skipped:\n                    self.addSkip(test, additional_info)\n                elif result == TestState.expected_failure:\n                    self.addExpectedFailure(test, additional_info)\n                elif result == TestState.unexpected_success:\n                    self.addUnexpectedSuccess(test)\n                else:\n                    raise Exception(\"This is not a valid test type :\", result)"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nperform argument glob expansion on an argument string.", "response": "def _expand_argument(self, arg):\n        \"\"\"Performs argument glob expansion on an argument string.\n        Returns a list of strings.\n        \"\"\"\n        if isinstance(arg, R): return [arg.str]\n        scope = self._scope or self._exports\n        arg = arg % scope\n        arg = os.path.expanduser(arg)\n        res = glob.glob(self._expand_path(arg))\n        if not res: return [arg]\n        if self._cwd != \"/\":\n            for idx in xrange(0, len(res)):\n                if res[idx].startswith(self._cwd + \"/\"):\n                    res[idx] = \"./\" + res[idx][len(self._cwd + \"/\"):]\n        return res"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef cached_accessor(func_or_att):\n    if callable(func_or_att): #allows decorator to be called without arguments\n        att = func_or_att.__name__\n        return cached_accessor(func_or_att.__name__)(func_or_att)\n    att = func_or_att\n    def make_cached_function(func):\n        @wraps(func)\n        def cached_check_version(self):\n            private_att = '_'+att\n            if getattr(self, private_att):\n                return getattr(self, private_att)\n            setattr(self, private_att, self.load_key(att))\n            if getattr(self, private_att):\n                return getattr(self, private_att)\n            value = func(self)\n            setattr(self, private_att, value)\n            self.save_key(att, value)\n            return value\n        return cached_check_version\n    return make_cached_function", "response": "Decorator that returns a function that checks in - memory cache and disc cache for att first"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef ask_for_board_id(self):\n        board_id = raw_input(\"paste in board id or url: \").strip()\n        m = re.search(r\"(?:https?://)?(?:trello.com)?/?b?/?([a-zA-Z]{8})/(?:.*)\", board_id)\n        if m:\n            board_id = m.group(1)\n        return board_id", "response": "Factored out in case interface isn t keyboard"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a list of names and IDs of cards from current board", "response": "def card_names_and_ids(self):\n        \"\"\"Returns [(name, id), ...] pairs of cards from current board\"\"\"\n        b = Board(self.client, self.board_id)\n        cards = b.getCards()\n        card_names_and_ids = [(unidecode(c.name), c.id) for c in cards]\n        return card_names_and_ids"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_shares(self, **kwargs):\n\n        response = self._get_shares(**kwargs)\n\n        rv = dict()\n\n        if response.http_status == 200:\n            for share in response.response:\n                rv[share['sharename']] = GettShare(self.user, **share)\n\n            return rv", "response": "Gets all shares for the current user"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef get_shares_list(self, **kwargs):\n\n        response = self._get_shares(**kwargs)\n\n        rv = list()\n\n        if response.http_status == 200:\n            for share in response.response:\n                rv.append(GettShare(self.user, **share))\n\n            return rv", "response": "Gets a list of all shares for the current user."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef get_share(self, sharename):\n\n        response = GettRequest().get(\"/shares/%s\" % sharename)\n\n        if response.http_status == 200:\n            return GettShare(self.user, **response.response)", "response": "Get a specific share. Does not require authentication."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_file(self, sharename, fileid):\n\n        if not isinstance(fileid, int):\n            raise TypeError(\"'fileid' must be an integer\")\n\n        response = GettRequest().get(\"/files/%s/%d\" % (sharename, fileid))\n\n        if response.http_status == 200:\n            return GettFile(self.user, **response.response)", "response": "Get a specific file. Does not require authentication."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef create_share(self, **kwargs):\n\n        params = None\n        if 'title' in kwargs:\n            params = {\"title\": kwargs['title']}\n\n        response = GettRequest().post((\"/shares/create?accesstoken=%s\" % self.user.access_token()), params)\n\n        if response.http_status == 200:\n            return GettShare(self.user, **response.response)", "response": "Creates a new share. Takes a keyword argument. Returns a new object."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nuploading a file to the Gett service.", "response": "def upload_file(self, **kwargs):\n        \"\"\"\n        Upload a file to the Gett service. Takes keyword arguments.\n\n        Input:\n            * ``filename`` the filename to use in the Gett service (required)\n            * ``data`` the file contents to store in the Gett service (required) - must be a string\n            * ``sharename`` the name of the share in which to store the data (optional); if not given, a new share will be created.\n            * ``title`` the share title to use if a new share is created (optional)\n\n        Output:\n            * A :py:mod:`pygett.files.GettFile` object\n\n        Example::\n\n            file = client.upload_file(filaname=\"foo\", data=open(\"foo.txt\").read())\n        \"\"\"\n        params = None\n        if 'filename' not in kwargs:\n            raise AttributeError(\"Parameter 'filename' must be given\")\n        else:\n            params = {\n                \"filename\": kwargs['filename']\n            }\n\n        if 'data' not in kwargs:\n            raise AttributeError(\"Parameter 'data' must be given\")\n\n        sharename = None\n        if 'sharename' not in kwargs:\n            share = None\n            if 'title' in kwargs:\n                share = self.create_share(title=kwargs['title'])\n            else:\n                share = self.create_share()\n            sharename = share.sharename\n        else:\n            sharename = kwargs['sharename']\n\n        response = GettRequest().post(\"/files/%s/create?accesstoken=%s\" % (sharename, self.user.access_token()), params)\n\n        f = None\n        if response.http_status == 200:\n            if 'sharename' not in response.response:\n                response.response['sharename'] = sharename\n            f = GettFile(self.user, **response.response)\n            if f.send_data(data=kwargs['data']):\n                return f"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef samdb_connect():\n    with root():\n        lp = samba.param.LoadParm()\n    lp.load(\"/etc/samba/smb.conf\")\n    creds = Credentials()\n    creds.guess(lp)\n    session = system_session()\n    samdb = SamDB(\"/var/lib/samba/private/sam.ldb\",\n                  session_info=session,\n                  credentials=creds,\n                  lp=lp)\n    return samdb", "response": "Open and return a SamDB connection with root"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nloading a schema from the given file into the SamDB", "response": "def load_schema(ldif_file):\n    \"\"\"\n    Load a schema from the given file into the SamDB\n    \"\"\"\n    samdb = samdb_connect()\n    dn = samdb.domain_dn()\n\n    samdb.transaction_start()\n    try:\n        setup_add_ldif(samdb, ldif_file, {\n            \"DOMAINDN\": dn,\n        })\n    except:\n        samdb.transaction_cancel()\n        raise\n\n    samdb.transaction_commit()"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef call(self, my_args=None):\n        LOGGER.debug(\"rest.Requester.call\")\n        if my_args is None:\n            raise exceptions.ArianeConfError('requester call arguments')\n        if 'http_operation' not in my_args or my_args['http_operation'] is None or not my_args['http_operation']:\n            raise exceptions.ArianeConfError('requester call http_operation')\n        if 'operation_path' not in my_args or my_args['operation_path'] is None:  # can be empty\n            raise exceptions.ArianeConfError('requester call operation_path')\n        if 'parameters' not in my_args:\n            my_args['parameters'] = None\n\n        if my_args['http_operation'] is \"GET\":\n            if my_args['parameters'] is None:\n                response = self.session.get(self.base_url + self.repository_path + my_args['operation_path'])\n            else:\n                response = self.session.get(self.base_url + self.repository_path + my_args['operation_path'],\n                                            params=my_args['parameters'])\n        elif my_args['http_operation'] is \"POST\":\n            if my_args['parameters'] is not None:\n                response = self.session.post(self.base_url + self.repository_path + my_args['operation_path'],\n                                             params=my_args['parameters'])\n            else:\n                raise exceptions.ArianeConfError('parameters argument is mandatory for http POST request')\n        else:\n            raise exceptions.ArianeNotImplemented(my_args['http_operation'])\n\n        if response.status_code is 200:\n            try:\n                return DriverResponse(\n                    rc=0,\n                    error_message=response.reason,\n                    response_content=response.json()\n                )\n            except ValueError as e:\n                return DriverResponse(\n                    rc=0,\n                    error_message=response.reason,\n                    response_content=response.text\n                )\n        else:\n            return DriverResponse(\n                rc=response.status_code,\n                error_message=response.reason,\n                response_content=response.text\n            )", "response": "This method is used to call the remote service."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef make_requester(self, my_args=None):\n        LOGGER.debug(\"rest.Driver.make_requester\")\n        if my_args is None:\n            raise exceptions.ArianeConfError('requester factory arguments')\n        my_args['session'] = self.session\n        my_args['base_url'] = self.base_url\n\n        return Requester(my_args)", "response": "make a new requester object"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nadd a child node to the tree.", "response": "def add_child(self, child):\n        \"\"\" Add a child node \"\"\"\n        if not isinstance(child, DependencyNode):\n            raise TypeError('\"child\" must be a DependencyNode')\n        self._children.append(child)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef add_children(self, children):\n        if not isinstance(children, list):\n            raise TypeError('\"children\" must be a list')\n        for child in children:\n            self.add_child(child)", "response": "Add multiple children to the current entry."}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef head_values(self):\n        values = set()\n        for head in self._heads:\n            values.add(head.value)\n        return values", "response": "Return the set of the head values"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef run(self, conn, tmp, module_name, module_args, inject):\n        ''' handler for file transfer operations '''\n\n        tokens  = shlex.split(module_args)\n        source  = tokens[0]\n        # FIXME: error handling\n        args    = \" \".join(tokens[1:])\n        source  = utils.template(self.runner.basedir, source, inject)\n        source  = utils.path_dwim(self.runner.basedir, source)\n\n        # transfer the file to a remote tmp location\n        source  = source.replace('\\x00','') # why does this happen here?\n        args    = args.replace('\\x00','') # why does this happen here?\n        tmp_src = os.path.join(tmp, os.path.basename(source))\n        tmp_src = tmp_src.replace('\\x00', '') \n\n        conn.put_file(source, tmp_src)\n\n        # fix file permissions when the copy is done as a different user\n        if self.runner.sudo and self.runner.sudo_user != 'root':\n            prepcmd = 'chmod a+rx %s' % tmp_src\n        else:\n            prepcmd = 'chmod +x %s' % tmp_src\n\n        # add preparation steps to one ssh roundtrip executing the script\n        module_args = prepcmd + '; ' + tmp_src + ' ' + args\n\n        handler = utils.plugins.action_loader.get('raw', self.runner)\n        result = handler.run(conn, tmp, 'raw', module_args, inject)\n\n        # clean up after\n        if tmp.find(\"tmp\") != -1 and C.DEFAULT_KEEP_REMOTE_FILES != '1':\n            self.runner._low_level_exec_command(conn, 'rm -rf %s >/dev/null 2>&1' % tmp, tmp)\n\n        return result", "response": "handler for file transfer operations"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef update_parser(parser):\n    def __stdin(s):\n        if s is None:\n            return None\n        if s == '-':\n            return sys.stdin\n        return open(s, 'r', encoding = 'utf8')\n    parser.add_argument('--root-prompt',\n            metavar = 'STR',\n            default = 'PlayBoy',\n            help = 'the root prompt string')\n    parser.add_argument('--temp-dir',\n            metavar = 'DIR',\n            default = '/tmp/easyshell_demo',\n            help = 'the directory to save history files')\n    parser.add_argument('--debug',\n            action = 'store_true',\n            help = 'turn debug infomation on')\n    parser.add_argument('file',\n            metavar = 'FILE',\n            nargs = '?',\n            type = __stdin,\n            help = \"execute script in non-interactive mode. '-' = stdin\")", "response": "Update the parser object for the shell."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ncall when an import is made.", "response": "def find_module(self, name, path=None):\n        \"\"\"\n        Called when an import is made. If there are hooks waiting for this\n        module to be imported then we stop the normal import process and\n        manually load the module.\n\n        @param name: The name of the module being imported.\n        @param path The root path of the module (if a package). We ignore this.\n        @return: If we want to hook this module, we return a C{loader}\n            interface (which is this instance again). If not we return C{None}\n            to allow the standard import process to continue.\n        \"\"\"\n        if name in self.loaded_modules:\n            return None\n\n        hooks = self.post_load_hooks.get(name, None)\n\n        if hooks:\n            return self"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef load_module(self, name):\n        self.loaded_modules.append(name)\n\n        try:\n            __import__(name, {}, {}, [])\n\n            mod = sys.modules[name]\n            self._run_hooks(name, mod)\n        except:\n            self.loaded_modules.pop()\n\n            raise\n\n        return mod", "response": "Load a module and run the hooks."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nrunning all hooks for a module.", "response": "def _run_hooks(self, name, module):\n        \"\"\"\n        Run all hooks for a module.\n        \"\"\"\n        hooks = self.post_load_hooks.pop(name, [])\n\n        for hook in hooks:\n            hook(module)"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef index_repeatmasker_alignment_by_id(fh, out_fh, vebrose=False):\n  def extract_UID(rm_alignment):\n    return rm_alignment.meta[multipleAlignment.RM_ID_KEY]\n\n  index = IndexedFile(fh, repeat_masker_alignment_iterator, extract_UID)\n  index.write_index(out_fh)", "response": "Build an index for a repeat - masker alignment file by repeat - masker ID."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nbuilding an index for a genome alig using coords in ref genome as keys.", "response": "def index_genome_alignment_by_locus(fh, out_fh, verbose=False):\n  \"\"\"Build an index for a genome alig. using coords in ref genome as keys.\"\"\"\n  bound_iter = functools.partial(genome_alignment_iterator,\n                                 reference_species=\"hg19\", index_friendly=True)\n  hash_func = JustInTimeGenomeAlignmentBlock.build_hash\n  idx = IndexedFile(fh, bound_iter, hash_func)\n  idx.write_index(out_fh, verbose=verbose)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nloads a GA index and its indexed file and extract one or more blocks.", "response": "def lookup_genome_alignment_index(index_fh, indexed_fh, out_fh=sys.stdout,\n                                  key=None, verbose=False):\n  \"\"\"Load a GA index and its indexed file and extract one or more blocks.\n\n  :param index_fh:   the index file to load. Can be a filename or a\n                     stream-like object.\n  :param indexed_fh: the file that the index was built for,\n  :param key:        A single key, iterable of keys, or None. This key will be\n                     used for lookup. If None, user is prompted to enter keys\n                     interactively.\n  \"\"\"\n  # load the genome alignment as a JIT object\n  bound_iter = functools.partial(genome_alignment_iterator,\n                                 reference_species=\"hg19\", index_friendly=True)\n  hash_func = JustInTimeGenomeAlignmentBlock.build_hash\n  idx = IndexedFile(record_iterator=bound_iter, record_hash_function=hash_func)\n  idx.read_index(index_fh, indexed_fh)\n\n  if key is None:\n    while key is None or key.strip() != \"\":\n      sys.stderr.write(\"[WAITING FOR KEY ENTRY ON STDIN; \" +\n                       \"END WITH EMPTY LINE]\\n\")\n      key = raw_input()\n      # we know keys for genome alignments have tabs as delims, so..\n      key = '\\t'.join(key.split()).strip()\n      if key != \"\":\n        out_fh.write(str(idx[key]) + \"\\n\")\n      sys.stderr.write(\"\\n\")\n  else:\n    # we know keys for genome alignments have tabs as delims, so..\n    key = '\\t'.join(key.split())\n    out_fh.write(str(idx[key]) + \"\\n\")"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef getUI_build_index(prog_name, args):\n  programName = prog_name\n  long_description = \"Build an index for one or more files.\"\n  short_description = long_description\n\n  ui = CLI(programName, short_description, long_description)\n  ui.minArgs = 0\n  ui.maxArgs = -1\n  ui.addOption(Option(short=\"o\", long=\"output\", argName=\"filename\",\n                      description=\"output to given file, else stdout\",\n                      required=False, type=str))\n  ui.addOption(Option(short=\"t\", long=\"type\", argName=\"filename\",\n                      description=\"the type of the file. If missing, \" +\n                      \"the script will try to guess the file type. \" +\n                      \"Supported file types are: \" +\n                      \", \".join([f.name for f in FileType]),\n                      required=False, type=str))\n  ui.addOption(Option(short=\"v\", long=\"verbose\",\n                      description=\"output additional messages to stderr \" +\n                                  \"about run (default: \" +\n                                  str(DEFAULT_VERBOSITY) + \")\",\n                      default=DEFAULT_VERBOSITY, required=False))\n  ui.addOption(Option(short=\"h\", long=\"help\",\n                      description=\"show this help message \", special=True))\n  ui.addOption(Option(short=\"u\", long=\"test\",\n                      description=\"run unit tests \", special=True))\n\n  ui.parseCommandLine(args)\n  return ui", "response": "Build an index for one or more files."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndetermining which indexer to use based on input files and type option.", "response": "def __get_indexer(in_fns, selected_type=None):\n  \"\"\"Determine which indexer to use based on input files and type option.\"\"\"\n  indexer = None\n  if selected_type is not None:\n    indexer = get_indexer_by_filetype(selected_type)\n  else:\n    if len(in_fns) == 0:\n      raise IndexError(\"reading from stdin, unable to guess input file \" +\n                       \"type, use -t option to set manually.\\n\")\n    else:\n      extension = set([os.path.splitext(f)[1] for f in in_fns])\n      assert(len(extension) >= 1)\n      if len(extension) > 1:\n        raise IndexError(\"more than one file extension present, unable \" +\n                         \"to get input type, use -t option to set manually.\\n\")\n      else:\n        indexer = get_indexer_by_file_extension(list(extension)[0])\n  assert(indexer is not None)\n  return indexer"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ndetermining which lookup function to use based on inpt files and type option.", "response": "def __get_lookup(in_fn, selected_type=None):\n  \"\"\"Determine which lookup func to use based on inpt files and type option.\"\"\"\n  lookup_func = None\n  if selected_type is not None:\n    lookup_func = get_lookup_by_filetype(selected_type)\n  else:\n    extension = os.path.splitext(in_fn)[1]\n    lookup_func = get_lookup_by_file_extension(extension)\n  assert(lookup_func is not None)\n  return lookup_func"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nfigure out which of the two options was used (build, get) and dispatch. :param args: the arguments for this script, as a list of string. Should already have had the script name stripped, so we expect the first item in this list to specify the mode ('build' an index or 'get' elements from an indexed file). :param prog_name: the name of the script; taken from command line args by default, but you can change it if you want.", "response": "def main(args=[], prog_name=sys.argv[0]):\n  \"\"\"Figure out which of the two options was used (build, get) and dispatch.\n\n  :param args:      the arguments for this script, as a list of string. Should\n                    already have had the script name stripped, so we expect the\n                    first item in this list to specify the mode ('build' an\n                    index or 'get' elements from an indexed file).\n  :param prog_name: the name of the script; taken from command line args by\n                    default, but you can change it if you want.\n  \"\"\"\n  helpStr = \"Build indexes and use them to extract elements from         \\n\" +\\\n            \"indexed files on-demand.                                    \\n\" +\\\n            \"                                                            \\n\" +\\\n            \"------------------------------------------------------------\\n\" +\\\n            \"                      BUILDING AN INDEX                     \\n\" +\\\n            \"------------------------------------------------------------\\n\" +\\\n            \"                                                            \\n\" +\\\n            \"To build an index for a file called foo.maf, where $ is     \\n\" +\\\n            \"your prompt:                                                \\n\" +\\\n            \"                                                            \\n\" +\\\n            \"$ pyokit index build -o foo.idx foo.maf                     \\n\" +\\\n            \"                                                            \\n\" +\\\n            \"for more information about the build command, where $ is    \\n\" +\\\n            \"your prompt, run:                                           \\n\" +\\\n            \"                                                            \\n\" +\\\n            \"$ pyokit index build --help                                 \\n\" +\\\n            \"                                                            \\n\" +\\\n            \"------------------------------------------------------------\\n\" +\\\n            \"                           LOOKUP                           \\n\" +\\\n            \"------------------------------------------------------------\\n\" +\\\n            \"To run interactive lookup of values using an index , where $\\n\" +\\\n            \"is your prompt:                                             \\n\" +\\\n            \"                                                            \\n\" +\\\n            \"$ pyokit index lookup foo.maf foo.idx                       \\n\" +\\\n            \"                                                            \\n\" +\\\n            \"for more information about the lookup command, where $ is   \\n\" +\\\n            \"your prompt, run:                                           \\n\" +\\\n            \"                                                            \\n\" +\\\n            \"$ pyokit index lookup --help                                \\n\" +\\\n            \"                                                              \"\n\n  if len(args) == 0 or (len(args) == 1 and isHelpString(args[0])):\n    sys.stderr.write(helpStr + \"\\n\\n\")\n  else:\n    arg_one = args[0].strip().lower()\n    if arg_one == \"build\":\n      main_build_index(args[1:])\n    elif arg_one == \"lookup\":\n      main_lookup_index(args[1:])\n    else:\n      raise PyokitUIError(\"Unknown option \" + arg_one)"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef main_lookup_index(args=[], prog_name=sys.argv[0]):\n  # get options and arguments\n  ui = getUI_lookup_index(prog_name, args)\n\n  # just run unit tests\n  if ui.optionIsSet(\"test\"):\n    unittest.main(argv=[sys.argv[0]])\n    sys.exit()\n\n  # just show help\n  if ui.optionIsSet(\"help\"):\n    ui.usage()\n    sys.exit()\n  verbose = (ui.optionIsSet(\"verbose\") is True) or DEFAULT_VERBOSITY\n\n  # required exactly two args, so this should be fine.\n  in_indexed, in_index = open(ui.getArgument(0)), open(ui.getArgument(1))\n\n  # Get output handle(s). If only one input file, and no output file, output\n  # to standard out.\n  out_fh = sys.stdout\n  if ui.optionIsSet(\"output\"):\n    out_fh = open(ui.getValue(\"output\"), \"w\")\n\n  # get the lookup key\n  key = None\n  if ui.optionIsSet(\"key\"):\n    key = ui.getValue(\"key\")\n\n  # figure out which indexer to use and then index each file\n  op_val = ui.getValue(\"type\") if ui.optionIsSet(\"type\") else None\n  lookup_func = __get_lookup(ui.getArgument(0), op_val)\n\n  lookup_func(in_index, in_indexed, out_fh, key, verbose)", "response": "This function is the main entry point for the index script. It will run unit tests and index each file in the file system."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef main_build_index(args=[], prog_name=sys.argv[0]):\n  # get options and arguments\n  ui = getUI_build_index(prog_name, args)\n\n  # just run unit tests\n  if ui.optionIsSet(\"test\"):\n    unittest.main(argv=[sys.argv[0]])\n    sys.exit()\n\n  # just show help\n  if ui.optionIsSet(\"help\"):\n    ui.usage()\n    sys.exit()\n  verbose = (ui.optionIsSet(\"verbose\") is True) or DEFAULT_VERBOSITY\n\n  # get input file-handle(s); fall back to stdin if none found.\n  in_fhs = [open(x) for x in ui.getAllArguments()]\n  if in_fhs == []:\n    if sys.stdin.isatty():\n      sys.stderr.write(\"[NO INPUT FILE FOUND; WAITING FOR INPUT FROM STDIN]\\n\")\n    in_fhs = [sys.stdin]\n\n  # Get output handle(s). If only one input file, and no output file, output\n  # to standard out.\n  out_fhs = [sys.stdout]\n  if ui.optionIsSet(\"output\"):\n    out_fhs = [open(x, \"w\") for x in ui.getValue(\"output\").split()]\n  if len(in_fhs) != len(out_fhs):\n    sys.stderr.write(\"mismatch between number of input files and output files\")\n    sys.exit(0)\n\n  # figure out which indexer to use and then index each file\n  op_val = ui.getValue(\"type\") if ui.optionIsSet(\"type\") else None\n  indexer = __get_indexer(ui.getAllArguments(), op_val)\n\n  for in_fh, out_fh in zip(in_fhs, out_fhs):\n    indexer(in_fh, out_fh, verbose)", "response": "This function is the entry point for the index script. It will build the index for the current command line arguments."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nlist the surveys available", "response": "def list_surveys():  # noqa: E501\n    \"\"\"list the surveys available\n\n    List the surveys available # noqa: E501\n\n\n    :rtype: List[Survey]\n    \"\"\"\n    pm = PrecisionMapper(login=_LOGIN, password=_PASSWORD)\n    pm.sign_in()\n    surveys = pm.get_surveys()\n    shared_surveys = pm.get_shared_surveys()\n\n    survey_list = []\n    for survey in surveys+shared_surveys:\n        survey_obj = Survey(\n            date=survey.date, image_nb=survey.image_nb,\n            location=survey.location, name=survey.name,\n            sensors=survey.sensor, size=survey.size, survey_id=survey.id)\n        survey_list.append(survey_obj)\n    return survey_list"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef call(self, my_args=None):\n        LOGGER.debug(\"zeromq.Publisher.call\")\n        if my_args is None:\n            raise exceptions.ArianeConfError(\"publisher call arguments\")\n        if 'topic' not in my_args or my_args['topic'] is None or not my_args['topic']:\n            raise exceptions.ArianeConfError(\"publisher topic\")\n        if 'msg' not in my_args or my_args['msg'] is None or not my_args['msg']:\n            raise exceptions.ArianeConfError(\"publisher call msg\")\n        self.zmqsocket.send_string(\"%s %s\" % (my_args['topic'], my_args['msg']))", "response": "publish the message in the topic"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nconsuming message from channel on the consuming thread.", "response": "def run(self):\n        \"\"\"\n        consume message from channel on the consuming thread.\n        \"\"\"\n        LOGGER.debug(\"zeromq.Subscriber.run\")\n        self.running = True\n        self.is_started = True\n        while self.running:\n            msg = None\n            try:\n                msg = self.zmqsocket.recv_string(zmq.NOBLOCK)\n            except zmq.ZMQError:\n                time.sleep(0.1)\n            except Exception as e:\n                LOGGER.warn(\"zeromq.Subscriber.run - Exception raised while consuming on topic \" + str(self.zmqtopic))\n            if msg is not None:\n                try:\n                    self.cb(msg)\n                except Exception as e:\n                    LOGGER.warn(\"zeromq.Subscriber.run - Exception raised while treating msg {\" + str(msg) + \"}\")\n        self.is_started = False"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nstop all ZMQ tools.", "response": "def stop(self):\n        \"\"\"\n        Stop ZMQ tools.\n        :return: self\n        \"\"\"\n        LOGGER.debug(\"zeromq.Driver.stop\")\n        for publisher in self.publishers_registry:\n            publisher.stop()\n        self.publishers_registry.clear()\n        for subscriber in self.subscribers_registry:\n            if subscriber.is_started:\n                subscriber.stop()\n        self.subscribers_registry.clear()\n        # pykka.ActorRegistry.stop_all()\n        return self"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef make_publisher(self):\n        LOGGER.debug(\"zeromq.Driver.make_publisher\")\n        if not self.configuration_OK or self.connection_args is None:\n            raise exceptions.ArianeConfError('zeromq connection arguments')\n        publisher = Publisher.start(self.connection_args).proxy()\n        self.publishers_registry.append(publisher)\n        return publisher", "response": "Creates a publisher instance and returns it"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef make_subscriber(self, my_args=None):\n        LOGGER.debug(\"zeromq.Driver.make_subscriber\")\n        if my_args is None:\n            raise exceptions.ArianeConfError('subscriber arguments')\n        if not self.configuration_OK or self.connection_args is None:\n            raise exceptions.ArianeConfError('zeromq connection arguments')\n        subscriber = Subscriber.start(my_args, self.connection_args).proxy()\n        self.subscribers_registry.append(subscriber)\n        return subscriber", "response": "Creates a subscriber instance and adds it to the list of subscribers."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ntakes a getlog requests result returns a table as df", "response": "def pg2df(res):\n    '''\n        takes a getlog requests result\n        returns a table as df\n    '''\n    # parse res\n    soup = BeautifulSoup(res.text)\n    \n    if u'Pas de r\\xe9ponse pour cette recherche.' in soup.text:\n        pass # <-- don't pass !\n    \n    else:\n        params = urlparse.parse_qs(urlparse.urlsplit(res.url)[-2])\n        tb = soup.find_all('table')[0]\n        data = [\n            [col.text for col in row.find_all('td')] + [params['dep'][0], params['mod'][0]]\n            for row in tb.find_all('tr')[1:]] # <-- escape header row\n        data = [dict(zip(\n            [u'depcom', u'date', u'obs', u'dep', u'mod'], lst)) for lst in data]\n            \n        return pd.DataFrame(data)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nget log for a given date range", "response": "def getlog(start, end, deplist=['00'], modlist=['M0'], xlsx=None):\n    '''\n        batch gets changelogs for cogs\n    '''\n    # entry point url\n    api = 'http://www.insee.fr/fr/methodes/nomenclatures/cog/recherche_historique.asp'\n    # build payloads\n    if modlist == ['M0']:\n        modlist = ['MA', 'MB', 'MC', 'MD', 'ME', 'MF', 'MG']\n    payloads = [{'debut':start, 'fin':end, 'dep':dep, 'mod':mod} for dep in deplist for mod in modlist]\n    # send requests\n    results = [pg2df(requests.get(api, params=payload)) for payload in payloads]\n    # make a df and fine tune it (force dtypes)\n    data = pd.concat(results)\n    data.reset_index()\n    data['date'] = pd.to_datetime(data['date'], format='%d/%m/%Y')\n    data[['dep', 'depcom', 'mod', 'obs']] = data[['dep', 'depcom', 'mod', 'obs']].astype(object)\n    # write xlsx\n    if xlsx:\n        pd.core.format.header_style = None\n        data.to_excel(xlsx, index=False)\n    \n    return pd.concat(results)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef currency_format(cents):\n    try:\n        cents = int(cents)\n    except ValueError:\n        return cents\n\n    negative = (cents < 0)\n    if negative:\n        cents = -1 * cents\n\n    if cents < 100:\n        dollars = 0\n    else:\n        dollars = cents / 100\n        cents = cents % 100\n\n    centstr = str(cents)\n    if len(centstr) < 2:\n        centstr = '0' + centstr\n\n    if negative:\n        return \"- $%s.%s\" % (intcomma(dollars), centstr)\n    return \"$%s.%s\" % (intcomma(dollars), centstr)", "response": "Format currency with symbol and decimal points."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef is_website_affected(self, website):\n        if self.domain is None:\n            return True\n        if not self.include_subdomains:\n            return self.domain in website['subdomains']\n        else:\n            dotted_domain = \".\" + self.domain\n            for subdomain in website['subdomains']:\n                if subdomain == self.domain or subdomain.endswith(dotted_domain):\n                    return True\n            return False", "response": "Tell if the website is affected by the domain change"}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef get_affected_domains(self):\n        results = set()\n        dotted_domain = (\".\" + self.domain) if self.domain else None\n        for website in self.websites:\n            for subdomain in website['subdomains']:\n                if self.domain is None or subdomain == self.domain or \\\n                        (self.include_subdomains and subdomain.endswith(dotted_domain)):\n                    results.add(subdomain)\n\n        # sort them by lenght so the shortest domain is the first\n        results = sorted(list(results), key=lambda item: len(item))\n        return results", "response": "Return a list of all affected domain and subdomains"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nreturn true if the website exists as secure", "response": "def website_exists_as_secure(self, website):\n        \"\"\"\" Return true if the website has an equivalent that is secure\n            we will have 2 websites with the same name, one insecure (that will contain just\n            the redirect and the identity-verification) and one secured\n        \"\"\"\n        if website['https']:\n            logger.info(\"website %s is already secured, skip\" % website['name'])\n            return website\n        # changes in these fields are ignored\n        for other in self._websites:\n            if other['id'] == website['id']:\n                continue\n            if other['name'] == website['name'] and other['https']:\n                return other\n        return None"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\ngive the http app list of a website return what should be in the secure version", "response": "def secured_apps_copy(self, apps):\n        \"\"\" Given the http app list of a website, return what should be in the secure version \"\"\"\n        return [[app_name, path] for app_name, path in apps if\n                app_name not in (self.LETSENCRYPT_VERIFY_APP_NAME,)]"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef create_le_verification_app(self):\n        if self.LETSENCRYPT_VERIFY_APP_NAME in self._apps:\n            logger.debug(\n                \"The LE verification APP already exists as %s\" % self.LETSENCRYPT_VERIFY_APP_NAME\n            )\n            verification_app = self._apps[self.LETSENCRYPT_VERIFY_APP_NAME]\n        else:\n            logger.info(\"Creating the identity-verification app for let's encrypt\")\n            verification_app = self.api.create_app(\n                self.LETSENCRYPT_VERIFY_APP_NAME,\n                'static_php70',\n            )\n            self._apps[self.LETSENCRYPT_VERIFY_APP_NAME] = verification_app\n\n        # LE use the .well-known subfolder of the domain to do its verifications.\n        # we will mount the app in the .well-known path, so we apply an hack to serve\n        # the app-folder/.well-known on root\n        app_root = os.path.join('~/webapps', self.LETSENCRYPT_VERIFY_APP_NAME)\n        well_known_folder = os.path.join(app_root, '.well-known')\n\n        if not is_link(well_known_folder):\n            logger.info(\"Preparing static app for the verification\")\n            run('ln -s {app_root} {well_known_folder}'.format(**locals()))\n        return verification_app", "response": "Create the let s encrypt app to verify ownership of the domain"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef website_verificable(self, website):\n        required_app = [self.LETSENCRYPT_VERIFY_APP_NAME, '/.well-known']\n        for app in website['website_apps']:\n            if app == required_app:\n                return True\n        return False", "response": "True if the website is Verificable"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef sync_certificates(self, subdomains=None):\n        result = run(\".acme.sh/acme.sh --list\", quiet=True)\n        logger.info(\"Syncing Webfaction certificates\")\n        for acme_certificate_description in result.split('\\n')[1:]:\n            main_domain = acme_certificate_description.split()[0]\n            if subdomains and main_domain not in subdomains:\n                continue\n            if exists(os.path.join(\"~/.acme.sh/\", main_domain)):\n                certificate_cer = self.get_remote_content(\n                    os.path.join(\"~/.acme.sh/\", main_domain, main_domain + \".cer\")\n                )\n                certificate_key = self.get_remote_content(\n                    os.path.join(\"~/.acme.sh/\", main_domain, main_domain + \".key\")\n                )\n                certificate_ca = self.get_remote_content(\n                    os.path.join(\"~/.acme.sh/\", main_domain, \"ca.cer\")\n                )\n                certificate_name = self.slugify(main_domain)\n\n                certificate = self._certificates.get(certificate_name)\n                if (certificate is None\n                    or certificate['certificate'] != certificate_cer\n                    or certificate['private_key'] != certificate_key\n                    or certificate['intermediates'] != certificate_ca):\n                    new_certificate = dict(\n                        name=certificate_name,\n                        certificate=certificate_cer,\n                        private_key=certificate_key,\n                        intermediates=certificate_ca,\n                    )\n                    if certificate is None:\n                        logger.info(\"Creating new certificate for %s\" % main_domain)\n                        self.api.create_certificate(new_certificate)\n                    else:\n                        logger.info(\"Updating certificate for %s\" % main_domain)\n                        self.api.update_certificate(new_certificate)\n                    self._certificates[certificate_name] = new_certificate", "response": "Check all certificates available in the host and sync them with the webfaction certificates"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\ngiving a list of subdomains return the main domain of them", "response": "def get_main_domain(self, website):\n        \"\"\" Given a list of subdomains, return the main domain of them\n            If the subdomain are across multiple domain, then we cannot have a single website\n            it should be splitted\n        \"\"\"\n        subdomains = website['subdomains']\n        main_domains = set()\n        for sub in subdomains:\n            for d in self._domains:\n                if sub == d or sub.endswith(\".\" + d):\n                    main_domains.add(d)\n        if len(main_domains) > 1:\n            logger.error(\n                \"The secure site %s cover multiple domains, it should be splitted\" % website['name']\n            )\n            exit(1)\n        elif not main_domains:\n            logger.error(\"We cannot find the main domain for %s\" % website['name'])\n        return list(main_domains)[0]"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_stroke_freq(Ax, Az, fs_a, nperseg, peak_thresh, stroke_ratio=None):\n    '''Determine stroke frequency to use as a cutoff for filtering\n\n    Args\n    ----\n    Ax: numpy.ndarray, shape (n,)\n        x-axis accelermeter data (longitudinal)\n    Ay: numpy.ndarray, shape (n,)\n        x-axis accelermeter data (lateral)\n    Az: numpy.ndarray, shape (n,)\n        z-axis accelermeter data (dorso-ventral)\n    fs_a: float\n        sampling frequency (i.e. number of samples per second)\n    nperseg: int\n        length of each segment (i.e. number of samples per frq. band in PSD\n        calculation. Default to 512 (scipy.signal.welch() default is 256)\n    peak_thresh: float\n        PSD power level threshold. Only peaks over this threshold are returned.\n\n    Returns\n    -------\n    cutoff_frq: float\n        cutoff frequency of signal (Hz) to be used for low/high-pass filtering\n    stroke_frq: float\n        frequency of dominant wavelength in signal\n    stroke_ratio: float\n\n    Notes\n    -----\n    During all descents and ascents phases where mainly steady swimming occurs.\n    When calculated for the whole dive it may be difficult to differentiate the\n    peak at which stroking rate occurs as there are movements than\n    only steady swimming\n\n    Here the power spectra is calculated of the longitudinal and dorso-ventral\n    accelerometer signals during descents and ascents to determine the dominant\n    stroke frequency for each animal in each phase\n\n    This numpy samples per f segment 512 and a sampling rate of fs_a.\n\n    Output: S is the amount of power in each particular frequency (f)\n    '''\n\n    import numpy\n\n    from . import dsp\n    from . import utils\n    from .plots import plotdsp\n\n    # Axes to be used for determining `stroke_frq`\n    stroke_axes = [(0,'x','dorsa-ventral', Ax),\n                   (2,'z','lateral', Az)]\n\n    # Lists for appending values from each axis\n    cutoff_frqs   = list()\n    stroke_frqs   = list()\n    stroke_ratios = list()\n\n    # Iterate over axes in `stroke_axes` list appending output to above lists\n    for i, i_alph, name, data in stroke_axes:\n\n        frqs, S, _, _ = dsp.calc_PSD_welch(data, fs_a, nperseg)\n\n        # Find index positions of local maxima and minima in PSD\n        delta = S.max()/1000\n        max_ind, min_ind = dsp.simple_peakfinder(range(len(S)), S, delta)\n\n        max0 = max_ind[0]\n\n        # TODO hack fix, improve later\n        try:\n            min0 = min_ind[0]\n        except:\n            min0 = None\n            stroke_ratio = 0.4\n\n        stroke_frq = frqs[max0]\n\n        # Prompt user for `cutoff_frq` value after inspecting PSD plot\n        title = 'PSD - {} axis (n={}), {}'.format(i_alph, i, name)\n        # Plot power spectrum against frequency distribution\n        plotdsp.plot_welch_peaks(frqs, S, max_ind, title=title)\n\n        # Get user input of cutoff frequency identified off plots\n        cutoff_frq = utils.recursive_input('cutoff frequency', float)\n\n        # Append values for axis to list\n        cutoff_frqs.append(cutoff_frq)\n        stroke_frqs.append(stroke_frq)\n        stroke_ratios.append(stroke_ratio)\n\n    # Average values for all axes\n    cutoff_frq = float(numpy.mean(cutoff_frqs))\n    stroke_frq = float(numpy.mean(stroke_frqs))\n\n    # Handle exception of manual selection when `stroke_ratio == None`\n    # TODO with fix\n    try:\n        stroke_ratio = float(numpy.mean(stroke_ratios))\n    except:\n        stroke_ratio = None\n\n    return cutoff_frq, stroke_frq, stroke_ratio", "response": "This function calculates the stroke frequency for a single segment based on the frequency of the signal."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef get_stroke_glide_indices(A_g_hf, fs_a, J, t_max):\n    '''Get stroke and glide indices from high-pass accelerometer data\n\n    Args\n    ----\n    A_g_hf: 1-D ndarray\n        Animal frame triaxial accelerometer matrix at sampling rate fs_a.\n\n    fs_a: int\n        Number of accelerometer samples per second\n\n    J: float\n        Frequency threshold for detecting a fluke stroke in m/s^2.  If J is not\n        given, fluke strokes will not be located but the rotations signal (pry)\n        will be computed.\n\n    t_max: int\n        Maximum duration allowable for a fluke stroke in seconds.  A fluke\n        stroke is counted whenever there is a cyclic variation in the pitch\n        deviation with peak-to-peak magnitude greater than +/-J and consistent\n        with a fluke stroke duration of less than t_max seconds, e.g., for\n        Mesoplodon choose t_max=4.\n\n    Returns\n    -------\n    GL: 1-D ndarray\n        Matrix containing the start time (first column) and end time (2nd\n        column) of any glides (i.e., no zero crossings in t_max or more\n        seconds). Times are in seconds.\n\n    Note\n    ----\n    If no J or t_max is given, J=[], or t_max=[], GL returned as None\n    '''\n    import numpy\n\n    from . import dsp\n\n    # Check if input array is 1-D\n    if A_g_hf.ndim > 1:\n        raise IndexError('A_g_hf multidimensional: Glide index determination '\n                         'requires 1-D acceleration array as input')\n\n    # Convert t_max to number of samples\n    n_max = t_max * fs_a\n\n    # Find zero-crossing start/stops in pry(:,n), rotations around n axis.\n    zc = dsp.findzc(A_g_hf, J, n_max/2)\n\n    # find glides - any interval between zeros crossings greater than `t_max`\n    ind = numpy.where(zc[1:, 0] - zc[0:-1, 1] > n_max)[0]\n    gl_ind = numpy.vstack([zc[ind, 0] - 1, zc[ind + 1, 1] + 1]).T\n\n    # Compute mean index position of glide, Only include sections with jerk < J\n    gl_mean_idx = numpy.round(numpy.mean(gl_ind, 1)).astype(int)\n    gl_ind = numpy.round(gl_ind).astype(int)\n\n    for i in range(len(gl_mean_idx)):\n        col = range(gl_mean_idx[i], gl_ind[i, 0], - 1)\n        test = numpy.where(numpy.isnan(A_g_hf[col]))[0]\n        if test.size != 0:\n            gl_mean_idx[i]   = numpy.nan\n            gl_ind[i,0] = numpy.nan\n            gl_ind[i,1] = numpy.nan\n        else:\n            over_J1 = numpy.where(abs(A_g_hf[col]) >= J)[0][0]\n\n            gl_ind[i,0] = gl_mean_idx[i] - over_J1 + 1\n\n            col = range(gl_mean_idx[i], gl_ind[i, 1])\n\n            over_J2 = numpy.where(abs(A_g_hf[col]) >= J)[0][0]\n\n            gl_ind[i,1] = gl_mean_idx[i] + over_J2 - 1\n\n    GL = gl_ind\n    GL = GL[numpy.where(GL[:, 1] - GL[:, 0] > n_max / 2)[0], :]\n\n    return GL", "response": "Get stroke and glide indices from high - pass accelerometer data."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef split_glides(n_samples, dur, fs_a, GL, min_dur=None):\n    '''Get start/stop indices of each `dur` length sub-glide for glides in GL\n\n    Args\n    ----\n    dur: int\n        Desired duration of glides\n    GL: ndarray, (n, 2)\n        Matrix containing the start time (first column) and end time\n        (2nd column) of any glides.Times are in seconds.\n    min_dur: int, default (bool False)\n        Minimum number of seconds for sub-glide. Default value is `False`, which\n        makes `min_dur` equal to `dur`, ignoring sub-glides smaller than `dur`.\n\n    Attributes\n    ----------\n    gl_ind_diff: ndarray, (n,3)\n        GL, with additional column of difference between the first two columns\n\n    Returns\n    -------\n    SGL: ndarray, (n, 2)\n        Matrix containing the start time (first column) and end time (2nd\n        column) of the generated sub-glides. All glides must have duration equal\n        to the given dur value.Times are in seconds.\n    '''\n    import numpy\n\n    # Convert `dur` in seconds to duration in number of samples `ndur`\n    ndur = dur * fs_a\n\n    # If minimum duration not passed, set to `min_dur` to skip slices < `dur`\n    if not min_dur:\n        min_ndur = dur * fs_a\n    else:\n        min_ndur = min_dur * fs_a\n\n    # `GL` plus column for total duration of glide, seconds\n    gl_ind_diff = numpy.vstack((GL.T, GL[:, 1] - GL[:, 0])).T\n\n    # Split all glides in `GL`\n    SGL_started = False\n    for i in range(len(GL)):\n        gl_ndur = gl_ind_diff[i, 2]\n\n        # Split into sub glides if longer than duration\n        if abs(gl_ndur) > ndur:\n\n            # Make list of index lengths to start of each sub-glide\n            n_sgl     = int(gl_ndur//ndur)\n            sgl_ndur  = numpy.ones(n_sgl)*ndur\n            sgl_start = numpy.arange(n_sgl)*(ndur+1)\n\n            # Add remainder as a sub-glide, skips if `min_ndur` not passed\n            if (gl_ndur%ndur > min_ndur):\n                last_ndur = numpy.floor(gl_ndur%ndur)\n                sgl_ndur  = numpy.hstack([sgl_ndur, last_ndur])\n\n                last_start = (len(sgl_start)*ndur) + ndur\n                sgl_start  = numpy.hstack([sgl_start, last_start])\n\n            # Get start and end index positions for each sub-glide\n            for k in range(len(sgl_start)):\n\n                # starting at original glide start...\n                # sgl_start_ind: add index increments of ndur+1 for next start idx\n                next_start_ind = (gl_ind_diff[i, 0] + sgl_start[k]).astype(int)\n\n                # end_glide: add `ndur` to that to get ending idx\n                next_end_ind = (next_start_ind + sgl_ndur[k]).astype(int)\n\n                # If first iteration, set equal to first set of indices\n                if SGL_started == False:\n                    sgl_start_ind = next_start_ind\n                    sgl_end_ind   = next_end_ind\n                    SGL_started = True\n                else:\n                    # Concatenate 1D arrays together, shape (n,)\n                    sgl_start_ind = numpy.hstack((sgl_start_ind, next_start_ind))\n                    sgl_end_ind   = numpy.hstack((sgl_end_ind, next_end_ind))\n\n    # Stack and transpose indices into shape (n, 2)\n    SGL = numpy.vstack((sgl_start_ind, sgl_end_ind)).T\n\n    # Filter out sub-glides that fall outside of sensor data indices\n    SGL =  SGL[(SGL[:, 0] >= 0) & (SGL[:, 1] < n_samples)]\n\n    # check that all sub-glides have a duration of `ndur` seconds\n    sgl_ndur = SGL[:, 1] - SGL[:, 0]\n\n    # If sub-glide `min_ndur` set, make sure all above `min_ndur`, below `ndur`\n    if min_dur:\n        assert numpy.all((sgl_ndur <= ndur) & (sgl_ndur >= min_ndur))\n    # Else make sure all sample number durations equal to `ndur`\n    else:\n        assert numpy.all(sgl_ndur == ndur)\n\n    # Create `data_sgl_mask`\n    data_sgl_mask = numpy.zeros(n_samples, dtype=bool)\n    for start, stop in SGL.astype(int):\n        data_sgl_mask[start:stop] = True\n\n    return SGL, data_sgl_mask", "response": "Split the glides into sub - gides of the given duration."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\ncalculating glide ascent and descent summary data for a given sub - glide.", "response": "def calc_glide_des_asc(depths, pitch_lf, roll_lf, heading_lf, swim_speed,\n        dives, SGL, pitch_lf_deg, temperature, Dsw):\n    '''Calculate glide ascent and descent summary data\n\n    Args\n    ----\n    SGL: numpy.ndarray, shape (n,2)\n        start and end index positions for sub-glides\n\n    Returns\n    -------\n    sgls: pandas.DataFrame\n        Sub-glide summary information defined by `SGL` start/stop indices\n\n        *Columns*:\n\n        * dive_phase\n        * dive_id\n        * dive_min_depth\n        * dive_max_depth\n        * dive_duration\n        * start_idx\n        * stop_idx\n        * duration\n        * mean_depth\n        * total_depth_change\n        * abs_depth_change\n        * mean_speed\n        * total_speed_change\n        * mean_pitch\n        * mean_sin_pitch\n        * SD_pitch\n        * mean_temp\n        * mean_swdensity\n        * mean_a\n        * R2_speed_vs_time\n        * SE_speed_vs_time\n        * mean_pitch_circ\n        * pitch_concentration\n        * mean_roll_circ\n        * roll_concentration\n        * mean_heading_circ\n        * heading_concentration\n\n    '''\n    import scipy.stats\n    import numpy\n    import pandas\n\n    keys = [\n            'dive_phase',\n            'dive_id',\n            'dive_min_depth',\n            'dive_max_depth',\n            'dive_duration',\n            'start_idx',\n            'stop_idx',\n            'duration',\n            'mean_depth',\n            'total_depth_change',\n            'abs_depth_change',\n            'mean_speed',\n            'total_speed_change',\n            'mean_pitch',\n            'mean_sin_pitch',\n            'SD_pitch',\n            'mean_temp',\n            'mean_swdensity',\n            'mean_a',\n            'R2_speed_vs_time',\n            'SE_speed_vs_time',\n            'mean_pitch_circ',\n            'pitch_concentration',\n            'mean_roll_circ',\n            'roll_concentration',\n            'mean_heading_circ',\n            'heading_concentration',\n            ]\n\n    # Create empty pandas dataframe for summary values\n    sgls = pandas.DataFrame(index=range(len(SGL)), columns=keys)\n\n    for i in range(len(SGL)):\n        start_idx = SGL[i,0]\n        stop_idx = SGL[i,1]\n\n        # sub-glide start point in seconds\n        sgls['start_idx'][i] = start_idx\n\n        # sub-glide end point in seconds\n        sgls['stop_idx'][i] = stop_idx\n\n        # sub-glide duration\n        sgls['duration'][i] = SGL[i,1] - SGL[i,0]\n\n        # mean depth(m)during sub-glide\n        sgls['mean_depth'][i] = numpy.mean(depths[start_idx:stop_idx])\n\n        # total depth(m)change during sub-glide\n        sgl_depth_diffs = numpy.diff(depths[start_idx:stop_idx])\n        sgls['total_depth_change'][i] = numpy.sum(abs(sgl_depth_diffs))\n\n        # depth(m)change from start to end of sub-glide\n        sgls['abs_depth_change'][i] = abs(depths[start_idx] - depths[stop_idx])\n\n        # mean swim speed during the sub-glide, only given if pitch>30 degrees\n        sgls['mean_speed'][i] = numpy.nanmean(swim_speed[start_idx:stop_idx])\n\n        # total speed change during sub-glide\n        sgl_speed_diffs = numpy.diff(swim_speed[start_idx:stop_idx])\n        sgls['total_speed_change'][i] = numpy.nansum(abs(sgl_speed_diffs))\n\n        # mean pitch during the sub-glide\n        sgls['mean_pitch'][i] = numpy.mean(pitch_lf_deg[start_idx:stop_idx])\n\n        # mean sin pitch during the sub-glide\n        sin_pitch = numpy.sin(numpy.mean(pitch_lf_deg[start_idx:stop_idx]))\n        sgls['mean_sin_pitch'][i] = sin_pitch\n\n        # SD of pitch during the sub-glide\n        # TODO just use original radian array, not deg\n        #      make sure \"original\" is radians ;)\n        sd_pitch = numpy.std(pitch_lf_deg[start_idx:stop_idx]) * 180 / numpy.pi\n        sgls['SD_pitch'][i] = sd_pitch\n\n        # mean temperature during the sub-glide\n        sgls['mean_temp'][i] = numpy.mean(temperature[start_idx:stop_idx])\n\n        # mean seawater density (kg/m^3) during the sub-glide\n        sgls['mean_swdensity'][i] = numpy.mean(Dsw[start_idx:stop_idx])\n\n        try:\n            # Perform linear regression on sub-glide data subset\n            xpoly = numpy.arange(start_idx, stop_idx).astype(int)\n            ypoly = swim_speed[start_idx:stop_idx]\n\n            # slope, intercept, r-value, p-value, standard error\n            m, c, r, p, std_err = scipy.stats.linregress(xpoly, ypoly)\n\n            # mean acceleration during the sub-glide\n            sgls['mean_a'][i] = m\n\n            # R2-value for the regression swim speed vs. time during the\n            # sub-glide\n            sgls['R2_speed_vs_time'][i] = r**2\n\n            # SE of the gradient for the regression swim speed vs. time during\n            # the sub-glide\n            sgls['SE_speed_vs_time'][i] = std_err\n\n        except:\n            # mean acceleration during the sub-glide\n            sgls['mean_a'][i] = numpy.nan\n\n            # R2-value for the regression swim speed vs. time during the\n            # sub-glide\n            sgls['R2_speed_vs_time'][i] = numpy.nan\n\n            # SE of the gradient for the regression swim speed vs. time during\n            # the sub-glide\n            sgls['SE_speed_vs_time'][i] = numpy.nan\n\n\n        # TODO this does not take into account the positive depths, flipping\n        # descents to ascents\n        sgl_signs = numpy.sign(sgl_depth_diffs)\n        if all(sgl_signs == -1):\n            sgls['dive_phase'][i] = 'descent'\n        elif all(sgl_signs == 1):\n            sgls['dive_phase'][i] = 'ascent'\n        elif any(sgl_signs == -1) & any(sgl_signs == 1):\n            sgls['dive_phase'][i] = 'mixed'\n\n        # Get indices of dive in which glide occurred\n        dive_ind = numpy.where((dives['start_idx'] < start_idx) & \\\n                               (dives['stop_idx'] > stop_idx))[0]\n\n        # TODO Hack way of pulling the information from first column of dives\n        if dive_ind.size == 0:\n            dive_inf = pandas.DataFrame.copy(dives.iloc[0])\n            dive_inf[:] = numpy.nan\n        else:\n            dive_inf = dives.iloc[dive_ind].iloc[0]\n\n        # Dive number in which the sub-glide recorded\n        sgls['dive_id'][i] = dive_inf['dive_id']\n\n        # Minimum dive depth (m) of the dive\n        sgls['dive_min_depth'][i] = dive_inf['depth_min']\n\n        # Maximum dive depth (m) of the dive\n        sgls['dive_max_depth'][i] = dive_inf['depth_max']\n\n        # Dive duration (s) of the dive\n        sgls['dive_duration'][i] = dive_inf['dive_dur']\n\n        # Mean pitch(deg) calculated using circular statistics\n        pitch_circmean = scipy.stats.circmean(pitch_lf[start_idx:stop_idx])\n        sgls['mean_pitch_circ'][i] = pitch_circmean\n\n        # Measure of concentration (r) of pitch during the sub-glide (i.e. 0\n        # for random direction, 1 for unidirectional)\n        pitch_circvar = scipy.stats.circvar(pitch_lf[start_idx:stop_idx])\n        sgls['pitch_concentration'][i] = 1 - pitch_circvar\n\n        # Mean roll (deg) calculated using circular statistics\n        roll_circmean = scipy.stats.circmean(roll_lf[start_idx:stop_idx])\n        sgls['mean_roll_circ'][i] = roll_circmean\n\n        # Measure of concentration (r) of roll during the sub-glide\n        roll_circvar = scipy.stats.circvar(roll_lf[start_idx:stop_idx])\n        sgls['roll_concentration'][i] = 1 - roll_circvar\n\n        # Mean heading (deg) calculated using circular statistics\n        heading_circmean = scipy.stats.circmean(heading_lf[start_idx:stop_idx])\n        sgls['mean_heading_circ'][i] = heading_circmean\n\n        # Measure of concentration (r) of heading during the sub-glide\n        heading_circvar = scipy.stats.circvar(heading_lf[start_idx:stop_idx])\n        sgls['heading_concentration'][i] = 1 - heading_circvar\n\n    return sgls"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncalculate summary information on glides during dives in sensor data.", "response": "def calc_glide_ratios(dives, des, asc, glide_mask, depths, pitch_lf):\n    '''Calculate summary information on glides during dive ascent/descents\n\n    Args\n    ----\n    dives: (n,10)\n        Numpy record array with summary information of dives in sensor data\n    des: ndarray\n        Boolean mask of descents over sensor data\n    asc: ndarray\n        Boolean mask of descents over sensor data\n    glid_mask: ndarray\n        Boolean mask of glides over sensor data\n    depths: ndarray\n        Depth values at each sensor sampling\n    pitch_lf: ndarray\n        Pitch in radians over the low frequency signals of acceleration\n\n    Returns\n    -------\n    gl_ratio: pandas.DataFrame\n        Dataframe of summary information of glides during dive descent/ascents\n\n        *Columns*:\n\n        * des_duration\n        * des_gl_duration\n        * des_gl_ratio\n        * des_mean_pitch\n        * des_rate\n        * asc_duration\n        * asc_gl_duration\n        * asc_gl_ratio\n        * asc_mean_pitch\n        * asc_rate\n    '''\n    import numpy\n    import pandas\n\n    # Create empty `pandas.DataFrame` for storing data, init with `nan`s\n    cols = ['des_duration',\n            'des_gl_duration',\n            'des_gl_ratio',\n            'des_mean_pitch',\n            'des_rate',\n            'asc_duration',\n            'asc_gl_duration',\n            'asc_gl_ratio',\n            'asc_mean_pitch',\n            'asc_rate',]\n\n    gl_ratio = pandas.DataFrame(index=range(len(dives)), columns=cols)\n\n    # For each dive with start/stop indices in `dives`\n    for i in range(len(dives)):\n        # Get indices for descent and ascent phase of dive `i`\n        start_idx = dives['start_idx'][i]\n        stop_idx  = dives['stop_idx'][i]\n        des_ind = numpy.where(des[start_idx:stop_idx])[0]\n        asc_ind = numpy.where(asc[start_idx:stop_idx])[0]\n\n        # DESCENT\n        # total duration of the descent phase (s)\n        gl_ratio['des_duration'][i] = len(des_ind)\n\n        # total glide duration during the descent phase (s)\n        des_glides = numpy.where(glide_mask[des_ind])[0]\n        gl_ratio['des_gl_duration'][i] = len(des_glides)\n\n        if len(des_ind) == 0:\n            gl_ratio['des_gl_ratio'][i] = 0\n            gl_ratio['des_rate'][i] = 0\n        else:\n            # glide ratio during the descent phase\n            des_gl_ratio = gl_ratio['des_gl_duration'][i] / len(des_ind)\n            gl_ratio['des_gl_ratio'][i] = des_gl_ratio\n\n            # descent rate (m/sample)\n            max_depth_des = depths[des_ind].max()\n            gl_ratio['des_rate'][i] = max_depth_des / len(des_ind)\n\n        # mean pitch during the descent phase(degrees)\n        des_mean_pitch = numpy.mean(numpy.rad2deg(pitch_lf[des_ind]))\n        gl_ratio['des_mean_pitch'][i] = des_mean_pitch\n\n        # ASCENT\n        # total duration of the ascent phase (s)\n        gl_ratio['asc_duration'][i] = len(asc_ind)\n\n        # total glide duration during the ascent phase (s)\n        asc_glides = numpy.where(glide_mask[asc_ind])[0]\n        gl_ratio['asc_gl_duration'][i] = len(asc_glides)\n\n        if len(asc_ind) == 0:\n            gl_ratio['asc_gl_ratio'][i] = 0\n            gl_ratio['asc_rate'][i] = 0\n        else:\n            # glide ratio during the ascent phase\n            asc_gl_ratio = gl_ratio['asc_gl_duration'][i] / len(asc_ind)\n            gl_ratio['asc_gl_ratio'][i] = asc_gl_ratio\n\n            # ascent rate (m/sample)\n            max_depth_asc = depths[asc_ind].max()\n            gl_ratio['asc_rate'][i] = max_depth_asc / len(asc_ind)\n\n        # mean pitch during the ascent phase(degrees)\n        asc_mean_pitch = numpy.mean(numpy.rad2deg(pitch_lf[asc_ind]))\n        gl_ratio['asc_mean_pitch'][i] = asc_mean_pitch\n\n    return gl_ratio"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\ngets the environment updates and write updates to a CSV file and a new configuration file.", "response": "def get_updates(\n        self,\n        display_all_distributions=False,\n        verbose=False\n    ):  # pragma: no cover\n        \"\"\"\n        When called, get the environment updates and write updates to a CSV\n        file and if a new config has been provided, write a new configuration\n        file.\n\n        Args:\n            display_all_distributions (bool): Return distribution even if it is\n                up-to-date.\n            verbose (bool): If ``True``, log to terminal to terminal.\n        \"\"\"\n        if verbose:\n            logging.basicConfig(\n                stream=sys.stdout,\n                level=logging.INFO,\n                format='%(message)s',\n            )\n            logging.info('Checking installed packages for updates...')\n\n        updates = self._get_environment_updates(\n            display_all_distributions=display_all_distributions\n        )\n\n        if updates:\n            for update in updates:\n                logging.info(update)\n\n        if updates and self._csv_file_name:\n            self.write_updates_to_csv(updates)\n\n        if updates and self._new_config:\n            self.write_new_config(updates)\n\n        return updates"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nget a CSV writer for the version of python that is being run.", "response": "def csv_writer(csvfile):\n        \"\"\" Get a CSV writer for the version of python that is being run. \"\"\"\n        if sys.version_info >= (3,):\n            writer = csv.writer(csvfile, delimiter=',', lineterminator='\\n')\n        else:\n            writer = csv.writer(csvfile, delimiter=b',', lineterminator='\\n')\n\n        return writer"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef write_updates_to_csv(self, updates):\n        with open(self._csv_file_name, 'w') as csvfile:\n            csvwriter = self.csv_writer(csvfile)\n            csvwriter.writerow(CSV_COLUMN_HEADERS)\n\n            for update in updates:\n                row = [\n                    update.name,\n                    update.current_version,\n                    update.new_version,\n                    update.prelease,\n                ]\n                csvwriter.writerow(row)", "response": "Writes the list of updates to a CSV file."}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef write_new_config(self, updates):\n        with open(self._new_config, 'w') as config_file:\n            for update in updates:\n                line = '{0}=={1}  # The installed version is: {2}\\n'.format(\n                    update.name,\n                    update.new_version,\n                    update.current_version\n                )\n\n                config_file.write(line)", "response": "Write out the updates out to the provided configuartion file."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nreturns a list of Update objects for all available updates in the environment.", "response": "def _get_environment_updates(self, display_all_distributions=False):\n        \"\"\"\n        Check all pacakges installed in the environment to see if there are\n        any updates availalble.\n\n        Args:\n            display_all_distributions (bool): Return distribution even if it is\n                up-to-date. Defaults to ``False``.\n\n        Returns:\n            list: A list of Update objects ordered based on ``instance.name``.\n        \"\"\"\n        updates = []\n        for distribution in self.pip.get_installed_distributions():\n\n            versions = self.get_available_versions(distribution.project_name)\n            max_version = max(versions.keys()) if versions else UNKNOW_NUM\n\n            update = None\n            distribution_version = self._parse_version(distribution.version)\n            if versions and max_version > distribution_version:\n                update = Update(\n                    distribution.project_name,\n                    distribution.version,\n                    versions[max_version],\n                    prelease=max_version[-1]\n                )\n\n            elif (\n                display_all_distributions and\n                max_version == distribution_version\n            ):\n                update = Update(\n                    distribution.project_name,\n                    distribution.version,\n                    versions[max_version],\n                )\n\n            elif display_all_distributions:\n                update = Update(\n                    distribution.project_name,\n                    distribution.version,\n                    UNKNOWN\n                )\n\n            if update:\n                updates.append(update)\n\n        return sorted(updates, key=lambda x: x.name)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function for\nquerying PyPI to see if the package has any available versions.", "response": "def get_available_versions(self, project_name):\n        \"\"\" Query PyPI to see if package has any available versions.\n\n        Args:\n            project_name (str): The name the project on PyPI.\n\n        Returns:\n            dict: Where keys are tuples of parsed versions and values are the\n                versions returned by PyPI.\n        \"\"\"\n        available_versions = self.pypi_client.package_releases(project_name)\n\n        if not available_versions:\n            available_versions = self.pypi_client.package_releases(\n                project_name.capitalize()\n            )\n\n        # ``dict()`` for Python 2.6 syntax.\n        return dict(\n            (self._parse_version(version), version)\n            for version in available_versions\n        )"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _parse_version(version):\n        parsed_version = parse_version(version)\n        return tuple(\n            int(dot_version)\n            for dot_version in parsed_version.base_version.split('.')\n        ) + (parsed_version.is_prerelease,)", "response": "Parse a version string."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nreturning True if the current python version matches the passed version.", "response": "def support(self, version):\n        \"\"\"\n        return `True` if current python version match version passed.\n       \n        raise a deprecation warning if only PY2 or PY3 is supported as you probably\n        have a conditional that should be removed. \n\n        \"\"\"\n\n        if not self._known_version(version):\n            warn(\"unknown feature: %s\"%version)\n            return True\n        else:\n            if not self._get_featureset_support(version):\n                warn(\"You are not supporting %s anymore \"%str(version), UserWarning, self.level)\n            if self._alone_version(version):\n                warn(\"%s is the last supported feature of this group, you can simplifiy this logic. \"%str(version), UserWarning,self.level)\n                \n            return self.predicates.get(version, True)\n\n\n\n\n        if (not self.PY3_supported) or (not self.PY2_supported):\n            warn(\"You are only supporting 1 version of Python\", UserWarning, self.level)\n\n        if version == PY3:\n            return sys.version_info.major == 3\n        elif version == PY2:\n            return sys.version_info.major == 2"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef _default_warner(self, message, stacklevel=1):\n        return warnings.warn(message,\n                PendingDeprecationWarning,\n                stacklevel=stacklevel+4)", "response": "default warner function use a pending deprecation warning,\n        and correct for the correct stacklevel"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef _check_if_complete(self, url, json_response):\n        if '__done' in json_response and isinstance(json_response, list):\n            mr_parts = list(urlparse(url))\n            mr_query = parse_qs(mr_parts[4])\n            mr_query['mr'] = '\"' + str(json_response[0]) + '\"'\n            mr_parts[4] = urlencode(mr_query, True)\n            mr_link = urlunparse(mr_parts)\n            mr_j, mr_r = self._ajax(mr_link)\n            self.log.debug('MultipleRedirect link: %s', mr_link)\n            return super(Installer, self)._check_if_complete(url, mr_j)\n\n        return False", "response": "Check if a request has been completed and return the redirect URL if it has been completed"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef setblocking(fd, blocking):\n    if not fcntl:\n        warnings.warn('setblocking() not supported on Windows')\n    flags = fcntl.fcntl(fd, fcntl.F_GETFL)\n    if blocking:\n        flags |= os.O_NONBLOCK\n    else:\n        flags &= ~os.O_NONBLOCK\n    fcntl.fcntl(fd, fcntl.F_SETFL, flags)", "response": "Set the O_NONBLOCK flag for a file descriptor. Availability : Unix."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef send_one(self, source_address: str, destination_address: str, message: str,\n                 validity_minutes: int = 0) -> SendSmsResult:\n        \"\"\"\n        http://www.devinotele.com/resheniya/dokumentaciya-po-api/http_rest_protocol/Otpravka_SMS-soobshcheny/\n        \"\"\"\n        session_id = self._get_session_id()\n        params = {\n            'sessionId': session_id,\n            'sourceAddress': source_address,\n            'destinationAddress': destination_address,\n            'data': message,\n            'validity': validity_minutes,\n        }\n        sms_ids = self._request(SEND_ONE_URL, params, method=METHOD_POST)\n        return SendSmsResult(destination_address, sms_ids)", "response": "Send one message to another address."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef send_bulk(self, source_address: str, destination_addresses: List[str], message: str,\n                 validity_minutes: int = 0) -> List[SendSmsResult]:\n        \"\"\"\n        http://www.devinotele.com/resheniya/dokumentaciya-po-api/http_rest_protocol/Otpravka_SMS-soobshcheny/\n        \"\"\"\n        session_id = self._get_session_id()\n        params = {\n            'sessionId': session_id,\n            'sourceAddress': source_address,\n            'DestinationAddresses': destination_addresses,\n            'data': message,\n            'validity': validity_minutes,\n        }\n        all_sms_ids = self._request(SEND_BULK_URL, params, method=METHOD_POST)\n\n        ids_per_sms = len(all_sms_ids) / len(destination_addresses)\n        results = []\n        message_ids = []\n        for sms_id in all_sms_ids:\n            message_ids.append(sms_id)\n\n            if len(message_ids) == ids_per_sms:\n                address = destination_addresses[len(results)]\n                send_result = SendSmsResult(address, message_ids)\n                message_ids = []\n                results.append(send_result)\n\n        return results", "response": "Send a message to a list of destination addresses."}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nreturns a reponse of a fixed number of entries ; all of them by default.", "response": "def entry_index(request, limit=0, template='djournal/entry_index.html'):\n    '''Returns a reponse of a fixed number of entries; all of them, by default. '''\n\n    entries = Entry.public.all()\n\n    if limit > 0:\n        entries = entries[:limit]\n\n    context = {\n        'entries': entries,\n    }\n\n    return render_to_response(\n        template,\n        context,\n        context_instance=RequestContext(request),\n    )"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef entry_detail(request, slug, template='djournal/entry_detail.html'):\n    '''Returns a response of an individual entry, for the given slug.'''\n\n    entry = get_object_or_404(Entry.public, slug=slug)\n\n    context = {\n        'entry': entry,\n    }\n\n    return render_to_response(\n        template,\n        context,\n        context_instance=RequestContext(request),\n    )", "response": "Returns a response of an individual entry for the given slug."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef tagged_entry_index(request, slug, template='djournal/tagged_entry_index.html'):\n    '''Returns a response of all entries tagged with a given tag.'''\n\n    tag = get_object_or_404(Tag, slug=slug)\n\n    entries = Entry.public.filter(tags__in=[tag])\n\n    context = {\n        'entries': entries,\n        'tag': tag,\n    }\n\n    return render_to_response(\n        template,\n        context,\n        context_instance=RequestContext(request),\n    )", "response": "Returns a response of all entries tagged with a given tag."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget input and output dirs", "response": "def getWorkDirs():\n  \"\"\"get input/output dirs (same input/output layout as for package)\"\"\"\n  # get caller module\n  caller_fullurl = inspect.stack()[1][1]\n  caller_relurl = os.path.relpath(caller_fullurl)\n  caller_modurl = os.path.splitext(caller_relurl)[0]\n  # split caller_url & append 'Dir' to package name\n  dirs = caller_modurl.split('/')\n  dirs[0] = 'data' # TODO de-hardcode\n  # get, check and create outdir\n  outDir = os.path.join(*(['output'] + dirs[1:]))\n  if not os.path.exists(outDir): os.makedirs(outDir)\n  # get and check indir\n  dirs.append('input')\n  inDir = os.path.join(*dirs)\n  if not os.path.exists(inDir):\n    logging.critical('create input dir %s to continue!' % inDir)\n    sys.exit(1)\n  return inDir, outDir"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef getUArray(npArr):\n  ufloats = []\n  for dp in npArr:\n      u = ufloat(dp[1], abs(dp[3]), 'stat')\n      v = ufloat(dp[1], abs(dp[4]), 'syst')\n      r = (u+v)/2.*dp[2]*2.\n      ufloats.append(r)\n      # NOTE: center value ok, but both error contribs half!\n      # see getErrorComponent()\n  return np.array(ufloats)", "response": "Returns an uncertainty array multiplied by binwidth"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\ngetting total error contribution for component with specific tag", "response": "def getErrorComponent(result, tag):\n    \"\"\"get total error contribution for component with specific tag\"\"\"\n    return math.sqrt(sum(\n        (error*2)**2\n        for (var, error) in result.error_components().items()\n        if var.tag == tag\n    ))"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef getEdges(npArr):\n  edges = np.concatenate(([0], npArr[:,0] + npArr[:,2]))\n  return np.array([Decimal(str(i)) for i in edges])", "response": "get np array of bin edges"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef getMaskIndices(mask):\n  return [\n    list(mask).index(True), len(mask) - 1 - list(mask)[::-1].index(True)\n  ]", "response": "get lower and upper indices of mask"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nget the cocktail sum for a given data bin range e0 e1 uCocktail", "response": "def getCocktailSum(e0, e1, eCocktail, uCocktail):\n  \"\"\"get the cocktail sum for a given data bin range\"\"\"\n  # get mask and according indices\n  mask = (eCocktail >= e0) & (eCocktail <= e1)\n  # data bin range wider than single cocktail bin\n  if np.any(mask):\n    idx = getMaskIndices(mask)\n    # determine coinciding flags\n    eCl, eCu = eCocktail[idx[0]], eCocktail[idx[1]]\n    not_coinc_low, not_coinc_upp = (eCl != e0), (eCu != e1)\n    # get cocktail sum in data bin (always w/o last bin)\n    uCocktailSum = fsum(uCocktail[mask[:-1]][:-1])\n    logging.debug('    sum: {}'.format(uCocktailSum))\n    # get correction for non-coinciding edges\n    if not_coinc_low:\n      eCl_bw = eCl - eCocktail[idx[0]-1]\n      corr_low = (eCl - e0) / eCl_bw\n      abs_corr_low = float(corr_low) * uCocktail[idx[0]-1]\n      uCocktailSum += abs_corr_low\n      logging.debug(('    low: %g == %g -> %g (%g) -> %g -> {} -> {}' % (\n        e0, eCl, eCl - e0, eCl_bw, corr_low\n      )).format(abs_corr_low, uCocktailSum))\n    if not_coinc_upp:\n      if idx[1]+1 < len(eCocktail):\n        eCu_bw = eCocktail[idx[1]+1] - eCu\n        corr_upp = (e1 - eCu) / eCu_bw\n        abs_corr_upp = float(corr_upp) * uCocktail[idx[1]]\n      else:# catch last index (quick fix!)\n        abs_corr_upp = eCu_bw = corr_upp = 0\n      uCocktailSum += abs_corr_upp\n      logging.debug(('    upp: %g == %g -> %g (%g) -> %g -> {} -> {}' % (\n        e1, eCu, e1 - eCu, eCu_bw, corr_upp\n      )).format(abs_corr_upp, uCocktailSum))\n  else:\n    mask = (eCocktail >= e0)\n    idx = getMaskIndices(mask) # only use first index\n    # catch if already at last index\n    if idx[0] == idx[1] and idx[0] == len(eCocktail)-1:\n      corr = (e1 - e0) / (eCocktail[idx[0]] - eCocktail[idx[0]-1])\n      uCocktailSum = float(corr) * uCocktail[idx[0]-1]\n    else: # default case\n      corr = (e1 - e0) / (eCocktail[idx[0]+1] - eCocktail[idx[0]])\n      uCocktailSum = float(corr) * uCocktail[idx[0]]\n    logging.debug('    sum: {}'.format(uCocktailSum))\n  return uCocktailSum"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\npatches sandbox to add match - all regex to whitelist", "response": "def break_sandbox():\n    \"\"\"Patches sandbox to add match-all regex to sandbox whitelist\n    \"\"\"\n    class EvilCM(object):\n        def __enter__(self):\n            return self\n\n        def __exit__(self, exc_type, exc, tb):\n            import re\n            tb.tb_next.tb_next.tb_next.tb_frame.f_locals[\n                'self']._enabled_regexes.append(re.compile('.*'))\n            return True\n    try:\n        import sqlite3  # noqa\n    except ImportError:\n        with EvilCM():\n            __import__('sqlite3')"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef execute(self, *args, **kwargs):\n        timeout = kwargs.pop(\"timeout\", -1)\n        execute_async = kwargs.pop(\"run_async\", False)\n        result = None\n        if self._action_lock.acquire(False):\n            try:\n                self.spine.trigger_event(\"actionStarted\", self.action_id)\n                if timeout == -1 and not execute_async:\n                    result = self._execute(*args, **kwargs)\n                else:\n                    thread = _ActionThread(self, args, kwargs)\n                    thread.start()\n                    if not execute_async:\n                        thread.join(timeout)\n                        if thread.is_alive():\n                            result = None\n                            #self._send_message(\"failed\", \"Timedout in call to action\")                \n                            raise TimeoutError(\"Timeout in call to action: \" + self.action_id)\n                        else:\n                            result = thread.result\n                    else:\n                        result = thread\n                return result\n            except Exception as ex:\n                print(ex)\n                self._action_lock.release()\n            finally:\n                pass\n            #    self._action_lock.release()\n        else:\n            if not self._action_lock.acquire(True, timeout):\n                return None\n            self._action_lock.release()\n            return self._last_result", "response": "Executes the action and returns the result."}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nfind the. tagcube config file in the current directory or in the user s home and parse it.", "response": "def parse_config_file():\n    \"\"\"\n    Find the .tagcube config file in the current directory, or in the\n    user's home and parse it. The one in the current directory has precedence.\n    \n    :return: A tuple with:\n                - email\n                - api_token\n    \"\"\"\n    for filename in ('.tagcube', os.path.expanduser('~/.tagcube')):\n\n        filename = os.path.abspath(filename)\n\n        if not os.path.exists(filename):\n            msg = 'TagCube configuration file \"%s\" does not exist'\n            cli_logger.debug(msg % filename)\n            continue\n\n        msg = 'Parsing tagcube configuration file \"%s\"'\n        cli_logger.debug(msg % filename)\n\n        email, api_key = _parse_config_file_impl(filename)\n        if email is not None and api_key is not None:\n            msg = ('Found authentication credentials:\\n'\n                   '    email: %s\\n'\n                   '    api_key: %s')\n            tokenized_api_key = '%s...%s' % (api_key[:3], api_key[-3:])\n            args = (email, tokenized_api_key)\n            cli_logger.debug(msg % args)\n\n            return email, api_key\n        else:\n            msg = 'Configuration file does not contain credentials'\n            cli_logger.debug(msg)\n    else:\n        return None, None"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _parse_config_file_impl(filename):\n    api_key = None\n    email = None\n\n    try:\n        doc = yaml.load(file(filename).read())\n        \n        email = doc['credentials']['email']\n        api_key = doc['credentials']['api_key']\n    except (KeyError, TypeError):\n        print(INVALID_FILE)\n        return None, None\n\n    except yaml.scanner.ScannerError, e:\n        print(SYNTAX_ERROR_FILE % (e.problem, e.problem_mark.line))\n        return None, None\n\n    # Just in case, we don't want the auth to fail because of a space\n    email = email.strip()\n    api_key = api_key.strip()\n\n    if not is_valid_api_key(api_key):\n        cli_logger.debug(INVALID_UUID)\n        api_key = None\n\n    if not is_valid_email(email):\n        cli_logger.debug('Invalid email address: %s' % email)\n        email = None\n\n    return email, api_key", "response": "Parse the config file into email and api_token."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef is_valid_path(path):\n    if not path.startswith('/'):\n        msg = 'Invalid path \"%s\". Paths need to start with \"/\".'\n        raise ValueError(msg % path[:40])\n\n    for c in ' \\t':\n        if c in path:\n            msg = ('Invalid character \"%s\" found in path. Paths need to be'\n                   ' URL-encoded.')\n            raise ValueError(msg % c)\n\n    return True", "response": "Checks if the path is valid."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef path_file_to_list(path_file):\n    paths = []\n    path_file_fd = file(path_file)\n\n    for line_no, line in enumerate(path_file_fd.readlines(), start=1):\n        line = line.strip()\n\n        if not line:\n            # Blank line support\n            continue\n\n        if line.startswith('#'):\n            # Comment support\n            continue\n\n        try:\n            is_valid_path(line)\n            paths.append(line)\n        except ValueError, ve:\n            args = (ve, path_file, line_no)\n            raise ValueError('%s error found in %s:%s.' % args)\n\n    return paths", "response": "Converts a path file to a list of paths."}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ntranslates a string that may be a freezer name into the internal freezer constant", "response": "def _freezer_lookup(freezer_string):\n    \"\"\"\n    Translate a string that may be a freezer name into the internal freezer constant\n\n    :param freezer_string\n    :return:\n    \"\"\"\n    sanitized = freezer_string.lower().strip()\n    for freezer in FREEZER.ALL:\n        freezer_instance = freezer()\n        freezer_name = six.text_type(freezer_instance)\n        if freezer_name == six.text_type(sanitized):\n            return freezer\n    else:\n        if sanitized != freezer_string:\n            raise ValueError(u\"Unsupported freezer type \\\"{0}\\\". (Sanitized to \\\"{1}\\\")\".format(freezer_string,\n                                                                                              sanitized))\n        else:\n            raise ValueError(u\"Unsupported freezer type \\\"{0}\\\".\".format(freezer_string))"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nlocate the appropriate freezer given a FREEZER constant or string input from the programmer.", "response": "def resolve_freezer(freezer):\n    \"\"\"\n    Locate the appropriate freezer given FREEZER or string input from the programmer.\n\n    :param freezer: FREEZER constant or string for the freezer that is requested.  (None = FREEZER.DEFAULT)\n    :return:\n    \"\"\"\n    # Set default freezer if there was none\n    if not freezer:\n        return _Default()\n\n    # Allow character based lookups as well\n    if isinstance(freezer, six.string_types):\n        cls = _freezer_lookup(freezer)\n        return cls()\n\n    # Allow plain class definition lookups (we instantiate the class)\n    if freezer.__class__ == type.__class__:\n        return freezer()\n\n    # Warn when a custom freezer implementation is used.\n    if freezer not in FREEZER.ALL:\n        warn(u\"Using custom freezer implelmentation: {0}\".format(freezer))\n\n    return freezer"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script for\nsplitting an iterable of packages into a list of pass - through includes and a list of the package_root_paths that are used to resolve the modules.", "response": "def _split_packages(cls, include_packages):\n        \"\"\"\n        Split an iterable of packages into packages that need to be passed through, and those that need to have their\n        disk location resolved.\n\n        Some modules don't have a '__file__' attribute.  AFAIK these aren't packages, so they can just be passed\n        through to the includes as-is\n        :return: 2-tuple of a list of the pass-through includes and the package_root_paths\n        \"\"\"\n        passthrough_includes = set([\n            six.text_type(package.__name__)\n            for package in include_packages\n            if not hasattr(package, '__file__')\n        ])\n        package_file_paths = dict([\n            (six.text_type(os.path.abspath(package.__file__)), six.text_type(package.__name__))\n            for package in include_packages\n            if hasattr(package, '__file__')\n        ])\n        return passthrough_includes, package_file_paths"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nbuilding the list of include files for the current version of the modules and the packages.", "response": "def build_includes(cls, include_packages):\n        \"\"\"\n        The default include strategy is to add a star (*) wild card after all sub-packages (but not the main package).\n        This strategy is compatible with py2app and bbfreeze.\n\n        Example (From SaltStack 2014.7):\n\n            salt\n            salt.fileserver.*\n            salt.modules.*\n            etc...\n\n        :param include_packages: List of package references to recurse for subpackages\n        \"\"\"\n        includes, package_root_paths = cls._split_packages(include_packages)\n        for package_path, package_name in six.iteritems(package_root_paths):\n            if re.search(r'__init__.py.*$', package_path):\n                # Looks like a package.  Walk the directory and see if there are more.\n                package_files = set([os.path.dirname(package_path)])\n                for root, dirs, files in os.walk(os.path.dirname(package_path)):\n                    if '__init__.py' in files:\n                        package_files.add(root)\n\n                if len(package_files) > 1:\n                    common_prefix = os.path.commonprefix(package_files)\n                    common_dir = os.path.dirname(common_prefix)\n                    package_tails = set([f[len(common_dir) + len(os.sep):] for f in package_files])\n                    package_names = set([tail.replace(os.sep, '.') for tail in package_tails])\n                    package_names_with_star = set([pkg + '.*' if pkg != package_name else pkg for pkg in package_names])\n                    includes |= package_names_with_star\n\n                else:\n                    # No sub-packages.  Just add the package name by itself.\n                    includes.add(package_name)\n            else:\n                # Not a package.  Just add the module.\n                includes.add(package_name)\n\n        return includes"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef build_includes(cls, include_packages):\n        includes, package_root_paths = cls._split_packages(include_packages)\n        for package_path, package_name in six.iteritems(package_root_paths):\n            includes.add(package_name)\n            if re.search(r'__init__.py.*$', package_path):\n                # Looks like a package.  Walk the directory and see if there are more.\n                package_modules = set()\n                for root, dirs, files in os.walk(os.path.dirname(package_path)):\n                    if '__init__.py' in files:\n                        package_modules.add(root)\n                        for module in [f for f in files if f != u\"__init__.py\" and f.endswith('.py')]:\n                            package_modules.add(os.path.join(root, module))\n\n                common_prefix = os.path.commonprefix(package_modules)\n                common_dir = os.path.dirname(common_prefix)\n                package_tails = set([f[len(common_dir) + len(os.sep):] for f in package_modules])\n                package_names = set([os.path.splitext(tail)[0].replace(os.sep, '.') for tail in package_tails])\n                includes |= package_names\n        return includes", "response": "Build a list of include paths for all the sub - modules of this class."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef parse_json_qry(qry_str):\n\n    def param_analyzer(param_list):\n        rtn_list = []\n        for param in param_list:\n            parts = param.strip().split(\"=\")\n            try:\n                rtn_list.append(\\\n                        JsonQryProcessor[parts[0].strip().lower()](parts[1]))\n            except IndexError:\n                rtn_list.append(\\\n                        JsonQryProcessor[parts[0].strip().lower()]())\n        return rtn_list\n\n    def part_analyzer(part, idx):\n        nonlocal dallor, asterick, question_mark\n        if part == \"$\":\n            dallor = idx\n            return part\n        elif part == \"*\":\n            asterick = idx\n            return part\n        elif part == \"?\":\n            question_mark = idx\n            return part\n        elif part.startswith(\"=\"):\n            return part\n        return cssparse(part)[0]\n    # pdb.set_trace()\n    main_parts = qry_str.split(\"|\")\n    or_parts = main_parts.pop(0).strip()\n    params = param_analyzer(main_parts)\n    rtn_list = []\n    for or_part in [item.strip()\n                    for item in or_parts.split(\",\")\n                    if item.strip()]:\n        dallor, asterick, question_mark = None, None, None\n        dot_parts = or_part.split(\".\")\n        rtn_list.append(([part_analyzer(part, i) \\\n                            for i, part in enumerate(dot_parts)],\n                          dallor,\n                          asterick,\n                          question_mark))\n    return {\"qry_parts\": rtn_list, \"params\": params}", "response": "Parses a json query string into its parts\n   "}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef get_json_qry_item(dataset, param, no_key=False):\n\n    def get_dataset_vals(ds, key, filter_tup=tuple()):\n        def reduce_list(value):\n            if isinstance(value, list):\n                if len(value) == 1:\n                    return value[0]\n            return value\n\n        def merge_list(value):\n            if isinstance(value, list):\n                rtn_list = []\n                for item in value:\n                    if isinstance(item, list):\n                        rtn_list += item\n                    else:\n                        rtn_list.append(item)\n                try:\n                    return list(set(rtn_list))\n                except TypeError:\n                    return rtn_list\n            return value\n\n        def test_elem(elem, filter_tup):\n            search_lst = elem\n            if isinstance(elem, dict):\n                search_lst = elem.get(filter_tup[0], [])\n            if filter_tup[2] == '=':\n                try:\n                    if elem.subject == filter_tup[1]:\n                        return True\n                except AttributeError:\n                    pass\n                test_lst = [item for item in search_lst \\\n                            if (isinstance(item, dict) \\\n                                and item.subject == filter_tup[1]) \\\n                            or item == filter_tup[1]]\n                if test_lst:\n                    return True\n                return False\n\n        def filter_list(ds, key, filter_tup):\n            rtn_list = ds\n            if key:\n                rtn_list = merge_list([reduce_list(reduce_list(elem)[key]) \\\n                                   for elem in ds\n                                   if isinstance(reduce_list(elem), dict)\n                                   and reduce_list(elem).get(key)])\n            if filter_tup:\n                return [elem for elem in rtn_list \\\n                        if test_elem(elem, filter_tup)]\n            return rtn_list\n\n        if isinstance(ds, list):\n            return filter_list(ds, key, filter_tup)\n        elif isinstance(ds, dict):\n            search_dict = ds\n            if key:\n                search_dict = ds.get(key,[])\n            if filter_tup:\n                datalist = []\n                for elem in search_dict:\n                    if filter_tup[2] == \"=\":\n                        # pdb.set_trace()\n                        if filter_tup[1] in elem.get(filter_tup[0], []):\n                            if isinstance(elem, list):\n                                datalist += elem\n                            else:\n                                datalist.append(elem)\n                    elif filter_tup[2] == \"!=\":\n                        if filter_tup[1] not in elem.get(filter_tup[0], []):\n                            datalist.append(elem)\n                return datalist\n                # return [elem for elem in ds[key] \\\n                #         if filter_tup[1] in elem.get(filter_tup[0], []) \\\n                #         and elem]\n            return merge_list(search_dict)\n    if param == \"*\":\n        return dataset\n    try:\n        if param.startswith(\"=\"):\n            # if the dataset length is '0' consider it a false match\n            if dataset:\n                return [pyrdf(param[1:])]\n            return []\n    except AttributeError:\n        pass\n    if hasattr(param, 'parsed_tree'):\n        param = param.parsed_tree\n\n    if hasattr(param, 'selector'):\n        if no_key:\n            key = None\n        else:\n            key = get_element(param.selector)\n        rtn_obj = None\n        if hasattr(param, 'ident'):\n            if key:\n                rtn_obj = get_dataset_vals(dataset,\n                                           key,\n                                           ('rdf_type',\n                                            param.ident, \"=\"))\n            elif param.ident in dataset.get('rdf_type', []):\n                rtn_obj = dataset\n            else:\n                rtn_obj = [value for value in dataset.values()\n                           if param.ident in value.get('rdf_type', [])]\n            # pdb.set_trace()\n        elif hasattr(param, 'attrib'):\n            # if param.parsed_tree.attrib == 'bf_role':\n            #     pdb.set_trace()\n            rtn_obj = get_dataset_vals(dataset,\n                                       key,\n                                       (param.attrib,\n                                        param.value,\n                                        param.operator))\n        if rtn_obj is not None:\n            if hasattr(param, 'selector') \\\n                    and hasattr(param.selector, 'selector') \\\n                    and rtn_obj:\n                rtn_obj = get_json_qry_item(rtn_obj, param.selector, True)\n            return rtn_obj\n        if key:\n            return dataset[key]\n        else:\n            return dataset\n    elif hasattr(param, 'element'):\n        key = param.element\n        return get_dataset_vals(dataset, key)", "response": "reads the paramater and returns the selected element"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_reverse_json_qry_item(dataset, param, no_key=False, initial_val=None):\n\n    def get_dataset_vals(ds, key, filter_tup=tuple(), initial_val=None):\n        def reduce_list(value):\n            if isinstance(value, list):\n                if len(value) == 1:\n                    return value[0]\n            return value\n\n        def merge_list(value):\n            if isinstance(value, list):\n                rtn_list = []\n                for item in value:\n                    if isinstance(item, list):\n                        rtn_list += item\n                    else:\n                        rtn_list.append(item)\n                return list(set(rtn_list))\n            return value\n\n        def test_elem(elem, filter_tup):\n            search_lst = elem\n            if isinstance(elem, dict):\n                search_lst = elem.get(filter_tup[0], [])\n            if filter_tup[2] == '=':\n                try:\n                    if elem.subject == filter_tup[1]:\n                        return True\n                except AttributeError:\n                    pass\n                test_lst = [item for item in search_lst \\\n                            if (isinstance(item, dict) \\\n                                and item.subject == filter_tup[1]) \\\n                            or item == filter_tup[1]]\n                if test_lst:\n                    return True\n                return False\n\n        def filter_list(ds, key, filter_tup, initial_val=None):\n            rtn_list = ds\n            if key:\n                rtn_list = merge_list([reduce_list(reduce_list(elem)[key]) \\\n                                   for elem in ds if reduce_list(elem).get(key)])\n            if filter_tup:\n                return [elem for elem in rtn_list \\\n                        if test_elem(elem, filter_tup)]\n            return rtn_list\n\n        def reverse_filter_list(ds, key, filter_tup, initial_val=None):\n\n            def get_reverse_ds_dict(ds, key, filter_tup, initial_val=None):\n                if hasattr(ds, 'rmap') and initial_val:\n                    # pdb.set_trace()\n                    if key:\n                        try:\n                            return ds.rmap[initial_val][key]\n                        except KeyError:\n                            return []\n                    else:\n                        return ds.rmap[initial_val]\n                data_list = UniqueList()\n                if not key and not initial_val:\n                    return data_list\n                for sub, ds_rdf_class in ds.items():\n                    for pred, obj in ds_rdf_class.items():\n                        if key and pred == key:\n                            if initial_val:\n                                if initial_val in obj:\n                                    data_list.append(ds_rdf_class)\n                            else:\n                                data_list.append(ds_rdf_class)\n                        if not key and initial_val:\n                            if initial_val in obj:\n                                data_list.append(ds_rdf_class)\n                # pdb.set_trace()\n                return data_list\n\n            if isinstance(ds, dict):\n                return get_reverse_ds_dict(ds, key, filter_tup, initial_val)\n            elif isinstance(ds, list):\n                rtn_list = UniqueList()\n                for item in ds:\n                    rtn_list += get_reverse_ds_dict(ds,\n                                                    key,\n                                                    filter_tup,\n                                                    initial_val)\n                return rtn_list\n\n\n        if isinstance(ds, list):\n            return reverse_filter_list(ds, key, filter_tup, initial_val)\n        elif isinstance(ds, dict):\n            search_dict = ds\n            if key:\n                search_dict = reverse_filter_list(ds,\n                                                  key,\n                                                  filter_tup,\n                                                  initial_val)\n            # pdb.set_trace()\n            if filter_tup:\n                datalist = []\n                for elem in search_dict:\n                    if filter_tup[2] == \"=\":\n                        # pdb.set_trace()\n                        if filter_tup[1] in elem.get(filter_tup[0], []):\n                            if isinstance(elem, list):\n                                datalist += elem\n                            else:\n                                datalist.append(elem)\n                    elif filter_tup[2] == \"!=\":\n                        if filter_tup[1] not in elem.get(filter_tup[0], []):\n                            datalist.append(elem)\n                return datalist\n            return merge_list(search_dict)\n\n\n\n    if param == \"*\":\n        pass\n    # pdb.set_trace()\n    if hasattr(param, 'parsed_tree'):\n        param = param.parsed_tree\n\n    if hasattr(param, 'selector'):\n\n        if no_key:\n            key = None\n        else:\n            key = get_element(param.selector)\n        rtn_obj = None\n        if hasattr(param, 'ident'):\n            rtn_obj = get_dataset_vals(dataset,\n                                       key,\n                                       ('rdf_type',\n                                        param.ident, \"=\"))\n        elif hasattr(param, 'attrib'):\n            # if param.parsed_tree.attrib == 'bf_role':\n            #     pdb.set_trace()\n            rtn_obj = get_dataset_vals(dataset,\n                                       key,\n                                       (param.attrib,\n                                        param.value,\n                                        param.operator))\n        if rtn_obj is not None:\n            if hasattr(param, 'selector') \\\n                    and hasattr(param.selector, 'selector') \\\n                    and rtn_obj:\n                rtn_obj = get_json_qry_item(rtn_obj, param.selector, True)\n            return rtn_obj\n        return dataset.get(key, [])\n    elif hasattr(param, 'element'):\n        key = param.element\n        return get_dataset_vals(dataset, key, initial_val=initial_val)", "response": "reads the paramater and returns the element in the dataset that matches the key"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\ntakes a json query string and returns the results", "response": "def json_qry(dataset, qry_str, params={}):\n    \"\"\" Takes a json query string and returns the results\n\n    args:\n        dataset: RdfDataset to query against\n        qry_str: query string\n        params: dictionary of params\n    \"\"\"\n    # if qry_str.startswith(\"$.bf_itemOf[rdf_type=bf_Print].='print',\\n\"):\n    #     pdb.set_trace()\n    if not '$' in qry_str:\n        qry_str = \".\".join(['$', qry_str.strip()])\n    dallor_val = params.get(\"$\", dataset)\n    if isinstance(dallor_val, rdflib.URIRef):\n        dallor_val = Uri(dallor_val)\n    if qry_str.strip() == '$':\n        return [dallor_val]\n    parsed_qry = parse_json_qry(qry_str)\n    qry_parts = parsed_qry['qry_parts']\n    post_actions = parsed_qry['params']\n    # print(qry_parts)\n    rtn_list = UniqueList()\n    if params.get('dataset'):\n        dataset = params['dataset']\n    for or_part in qry_parts:\n        if or_part[1] == 0:\n            if isinstance(dallor_val, dict):\n                result = dallor_val\n            else:\n                try:\n                    result = dataset[dallor_val]\n                except KeyError:\n                    try:\n                        result = dataset[Uri(dallor_val)]\n                    except KeyError:\n                        try:\n                            result = dataset[BlankNode(dallor_val)]\n                        except KeyError:\n                            continue\n\n            forward = True\n            for part in or_part[0][1:]:\n                if part == \"*\":\n                    forward = not forward\n                else:\n                    if forward:\n                        result = get_json_qry_item(result, part)\n                    else:\n                        result = get_reverse_json_qry_item(result,\n                                                           part,\n                                                           False)\n        else:\n            result = dataset\n            parts = or_part[0].copy()\n            parts.reverse()\n            forward = False\n            for part in parts[1:]:\n                if part == \"*\":\n                    forward = not forward\n                else:\n                    if forward:\n                        result = get_json_qry_item(result, part)\n                    else:\n                        result = get_reverse_json_qry_item(result,\n                                                           part,\n                                                           False,\n                                                           dallor_val)\n        rtn_list += result\n    for action in post_actions:\n        rtn_list = action(rtn_list)\n    return rtn_list"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef migrate1():\n    \"Migrate from version 0 to 1\"\n\n    initial = [\n    \"create table Chill (version integer);\",\n    \"insert into Chill (version) values (1);\",\n    \"alter table SelectSQL rename to Query;\",\n    \"alter table Node add column template integer references Template (id) on delete set null;\",\n    \"alter table Node add column query integer references Query (id) on delete set null;\"\n    ]\n\n\n    cleanup = [\n    \"drop table SelectSQL_Node;\",\n    \"drop table Template_Node;\"\n    ]\n\n    c = db.cursor()\n    try:\n        c.execute(\"select version from Chill limit 1;\")\n    except sqlite3.DatabaseError as err:\n        pass\n    result = c.fetchone()\n    if result:\n        version = result[0]\n        if version == 1:\n            current_app.logger.warn(\"Migration from version 0 to 1 is not needed.\")\n        else:\n            current_app.logger.warn(\"Migration from version 0 to {0} is not supported.\".format(version))\n        return\n\n    try:\n        for query in initial:\n            c.execute(query)\n    except sqlite3.DatabaseError as err:\n        current_app.logger.error(\"DatabaseError: %s\", err)\n\n    try:\n        c.execute(fetch_query_string('select_all_nodes.sql'))\n    except sqlite3.DatabaseError as err:\n        current_app.logger.error(\"DatabaseError: %s\", err)\n    result = c.fetchall()\n    if result:\n        (result, col_names) = rowify(result, c.description)\n        for kw in result:\n\n            try:\n                c.execute(\"\"\"\n                update Node set template = (\n                select t.id from Template as t\n                join Template_Node as tn on ( tn.template_id = t.id )\n                join Node as n on ( n.id = tn.node_id )\n                where n.id is :node_id\n                group by t.id)\n                where id is :node_id;\n                \"\"\", {'node_id':kw['id']})\n            except sqlite3.DatabaseError as err:\n                current_app.logger.error(\"DatabaseError: %s\", err)\n\n            try:\n                c.execute(\"\"\"\n                update Node set query = (\n                select s.id from Query as s\n                join SelectSQL_Node as sn on ( sn.selectsql_id = s.id )\n                join Node as n on ( n.id = sn.node_id )\n                where n.id is :node_id\n                group by s.id)\n                where id is :node_id;\n                \"\"\", {'node_id':kw['id']})\n            except sqlite3.DatabaseError as err:\n                current_app.logger.error(\"DatabaseError: %s\", err)\n    try:\n        for query in cleanup:\n            c.execute(query)\n    except sqlite3.DatabaseError as err:\n        current_app.logger.error(\"DatabaseError: %s\", err)\n\n    db.commit()", "response": "Migrate from version 0 to 1"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\ncheck if a C { float or an anonymized integer is in the AMF0.", "response": "def _check_for_int(x):\n    \"\"\"\n    This is a compatibility function that takes a C{float} and converts it to an\n    C{int} if the values are equal.\n    \"\"\"\n    try:\n        y = int(x)\n    except (OverflowError, ValueError):\n        pass\n    else:\n        # There is no way in AMF0 to distinguish between integers and floats\n        if x == x and y == x:\n            return y\n\n    return x"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef readString(self, bytes=False):\n        l = self.stream.read_ushort()\n        b = self.stream.read(l)\n\n        if bytes:\n            return b\n\n        return self.context.getStringForBytes(b)", "response": "Reads a C { string from the stream."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nread mixed array. @rtype: L{pyamf.MixedArray}", "response": "def readMixedArray(self):\n        \"\"\"\n        Read mixed array.\n\n        @rtype: L{pyamf.MixedArray}\n        \"\"\"\n        # TODO: something with the length/strict\n        self.stream.read_ulong() # length\n\n        obj = pyamf.MixedArray()\n        self.context.addObject(obj)\n\n        attrs = self.readObjectAttributes(obj)\n\n        for key in attrs.keys():\n            try:\n                key = int(key)\n            except ValueError:\n                pass\n\n            obj[key] = attrs[key]\n\n        return obj"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function to\nread a C { list from the data stream.", "response": "def readList(self):\n        \"\"\"\n        Read a C{list} from the data stream.\n        \"\"\"\n        obj = []\n        self.context.addObject(obj)\n        l = self.stream.read_ulong()\n\n        for i in xrange(l):\n            obj.append(self.readElement())\n\n        return obj"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nread an aliased ActionScript object from the stream and attempts to read it into a python class.", "response": "def readTypedObject(self):\n        \"\"\"\n        Reads an aliased ActionScript object from the stream and attempts to\n        'cast' it into a python class.\n\n        @see: L{pyamf.register_class}\n        \"\"\"\n        class_alias = self.readString()\n\n        try:\n            alias = self.context.getClassAlias(class_alias)\n        except pyamf.UnknownClassAlias:\n            if self.strict:\n                raise\n\n            alias = pyamf.TypedObjectClassAlias(class_alias)\n\n        obj = alias.createInstance(codec=self)\n        self.context.addObject(obj)\n\n        attrs = self.readObjectAttributes(obj)\n        alias.applyAttributes(obj, attrs, codec=self)\n\n        return obj"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef readObject(self):\n        obj = pyamf.ASObject()\n        self.context.addObject(obj)\n\n        obj.update(self.readObjectAttributes(obj))\n\n        return obj", "response": "Reads an anonymous object from the data stream."}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nreads a reference from the data stream.", "response": "def readReference(self):\n        \"\"\"\n        Reads a reference from the data stream.\n\n        @raise pyamf.ReferenceError: Unknown reference.\n        \"\"\"\n        idx = self.stream.read_ushort()\n        o = self.context.getObject(idx)\n\n        if o is None:\n            raise pyamf.ReferenceError('Unknown reference %d' % (idx,))\n\n        return o"}
{"SOURCE": "codesearchnet", "instruction": "Explain what the following Python 3 code does\ndef readDate(self):\n        ms = self.stream.read_double() / 1000.0\n        self.stream.read_short() # tz\n\n        # Timezones are ignored\n        d = util.get_datetime(ms)\n\n        if self.timezone_offset:\n            d = d + self.timezone_offset\n\n        self.context.addObject(d)\n\n        return d", "response": "Reads a UTC date from the data stream."}
{"SOURCE": "codesearchnet", "instruction": "Here you have a function in Python 3, explain what it does\ndef readLongString(self):\n        l = self.stream.read_ulong()\n\n        bytes = self.stream.read(l)\n\n        return self.context.getStringForBytes(bytes)", "response": "Reads a UTF8 string."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef readXML(self):\n        data = self.readLongString()\n        root = xml.fromstring(data)\n\n        self.context.addObject(root)\n\n        return root", "response": "Reads the next XML element and returns it."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nwriting the array to the data stream.", "response": "def writeList(self, a):\n        \"\"\"\n        Write array to the stream.\n\n        @param a: The array data to be encoded to the AMF0 data stream.\n        \"\"\"\n        if self.writeReference(a) != -1:\n            return\n\n        self.context.addObject(a)\n\n        self.writeType(TYPE_ARRAY)\n        self.stream.write_ulong(len(a))\n\n        for data in a:\n            self.writeElement(data)"}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nwrites a number to the data stream.", "response": "def writeNumber(self, n):\n        \"\"\"\n        Write number to the data stream .\n\n        @param  n: The number data to be encoded to the AMF0 data stream.\n        \"\"\"\n        self.writeType(TYPE_NUMBER)\n        self.stream.write_double(float(n))"}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef writeBoolean(self, b):\n        self.writeType(TYPE_BOOL)\n\n        if b:\n            self.stream.write_uchar(1)\n        else:\n            self.stream.write_uchar(0)", "response": "Writes a boolean to the data stream."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef serialiseString(self, s):\n        if type(s) is unicode:\n            s = self.context.getBytesForString(s)\n\n        l = len(s)\n\n        if l > 0xffff:\n            self.stream.write_ulong(l)\n        else:\n            self.stream.write_ushort(l)\n\n        self.stream.write(s)", "response": "Serialises a string to the stream."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef writeBytes(self, s):\n        l = len(s)\n\n        if l > 0xffff:\n            self.writeType(TYPE_LONGSTRING)\n        else:\n            self.writeType(TYPE_STRING)\n\n        if l > 0xffff:\n            self.stream.write_ulong(l)\n        else:\n            self.stream.write_ushort(l)\n\n        self.stream.write(s)", "response": "Write a string of bytes to the data stream."}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef writeString(self, u):\n        s = self.context.getBytesForString(u)\n\n        self.writeBytes(s)", "response": "Writes a unicode string to the data stream."}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\nwriting a reference to the data stream.", "response": "def writeReference(self, o):\n        \"\"\"\n        Write reference to the data stream.\n\n        @param o: The reference data to be encoded to the AMF0 datastream.\n        \"\"\"\n        idx = self.context.getObjectReference(o)\n\n        if idx == -1 or idx > 65535:\n            return -1\n\n        self.writeType(TYPE_REFERENCE)\n        self.stream.write_ushort(idx)\n\n        return idx"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef _writeDict(self, o):\n        for key, val in o.iteritems():\n            if type(key) in python.int_types:\n                key = str(key)\n\n            self.serialiseString(key)\n            self.writeElement(val)", "response": "Writes the contents of a dictionary to the data stream."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate the documentation for the following Python 3 function\ndef writeMixedArray(self, o):\n        if self.writeReference(o) != -1:\n            return\n\n        self.context.addObject(o)\n        self.writeType(TYPE_MIXEDARRAY)\n\n        # TODO: optimise this\n        # work out the highest integer index\n        try:\n            # list comprehensions to save the day\n            max_index = max([y[0] for y in o.items()\n                if isinstance(y[0], (int, long))])\n\n            if max_index < 0:\n                max_index = 0\n        except ValueError:\n            max_index = 0\n\n        self.stream.write_ulong(max_index)\n\n        self._writeDict(o)\n        self._writeEndObject()", "response": "Writes a mixed array to the data stream."}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nwriting a Python object to the data stream.", "response": "def writeObject(self, o):\n        \"\"\"\n        Write a Python object to the stream.\n\n        @param o: The object data to be encoded to the AMF0 data stream.\n        \"\"\"\n        if self.writeReference(o) != -1:\n            return\n\n        self.context.addObject(o)\n        alias = self.context.getClassAlias(o.__class__)\n\n        alias.compile()\n\n        if alias.amf3:\n            self.writeAMF3(o)\n\n            return\n\n        if alias.anonymous:\n            self.writeType(TYPE_OBJECT)\n        else:\n            self.writeType(TYPE_TYPEDOBJECT)\n            self.serialiseString(alias.alias)\n\n        attrs = alias.getEncodableAttributes(o, codec=self)\n\n        if alias.static_attrs and attrs:\n            for key in alias.static_attrs:\n                value = attrs.pop(key)\n\n                self.serialiseString(key)\n                self.writeElement(value)\n\n        if attrs:\n            self._writeDict(attrs)\n\n        self._writeEndObject()"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef writeDate(self, d):\n        if isinstance(d, datetime.time):\n            raise pyamf.EncodeError('A datetime.time instance was found but '\n                'AMF0 has no way to encode time objects. Please use '\n                'datetime.datetime instead (got:%r)' % (d,))\n\n        # According to the Red5 implementation of AMF0, dates references are\n        # created, but not used.\n        if self.timezone_offset is not None:\n            d -= self.timezone_offset\n\n        secs = util.get_timestamp(d)\n        tz = 0\n\n        self.writeType(TYPE_DATE)\n        self.stream.write_double(secs * 1000.0)\n        self.stream.write_short(tz)", "response": "Writes a date to the data stream."}
{"SOURCE": "codesearchnet", "instruction": "How would you implement a function in Python 3 that\nwrites an XML instance to the internal stream.", "response": "def writeXML(self, e):\n        \"\"\"\n        Writes an XML instance.\n        \"\"\"\n        self.writeType(TYPE_XML)\n\n        data = xml.tostring(e)\n\n        if isinstance(data, unicode):\n            data = data.encode('utf-8')\n\n        self.stream.write_ulong(len(data))\n        self.stream.write(data)"}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 script to\nwrite an AMF3 element in L{AMF3<pyamf. amf3 format.", "response": "def writeAMF3(self, data):\n        \"\"\"\n        Writes an element in L{AMF3<pyamf.amf3>} format.\n        \"\"\"\n        self.writeType(TYPE_AMF3)\n\n        self.context.getAMF3Encoder(self).writeElement(data)"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef make_val(clas,*vals):\r\n    \"this doesn't need to be a classmethod -- it can be a normal instance method\"\r\n    if clas.VALUE is None: raise TypeError('null meta-information in class for VALUE')\r\n    clas.type_check(zip(*clas.VALUE)[1],vals,'VALUE')\r\n    return msgpack.dumps(vals)", "response": "this doesn t need to be a classmethod -- it can be a normal instance method"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef saveget(self,con):\r\n    \"save, return old value. todo: make the expire() atomic with a redis script\"\r\n    k,v=self.kv()\r\n    oldv=con.getset(k,v)\r\n    if self.TTL is not None: con.expire(k,self.TTL)\r\n    return None if oldv is None else msgpack.loads(oldv)", "response": "save return old value. todo : make the expire() atomic with a redis script"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef pub(self,con):\r\n    \"careful -- save and pub aren't the same\"\r\n    k,v=self.kv()\r\n    con.publish(k,v)", "response": "careful -- save and pub aren t the same"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef wait(self):\r\n    \"wait for a message, respecting timeout\"\r\n    data=self.getcon().recv(256) # this can raise socket.timeout\r\n    if not data: raise PubsubDisco\r\n    if self.reset:\r\n      self.reset=False # i.e. ack it. reset is used to tell the wait-thread there was a reconnect (though it's plausible that this never happens)\r\n      raise PubsubDisco\r\n    self.buf+=data\r\n    msg,self.buf=complete_message(self.buf)\r\n    return msg", "response": "wait for a message respecting timeout"}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef get_access_token(username=None,\n                     password=None,\n                     client_id=None,\n                     client_secret=None,\n                     app_url=defaults.APP_URL):\n    \"\"\"\n    get the access token (http://docs.jut.io/api-guide/#unique_171637733),\n    by either using the direct username, password combination or better yet by\n    using the authorization grant you generated on jut with the client_id,\n    client_secret combination\n\n    auth_url: auth url for the jut application (defaults to production)\n\n    Use either two of the following to authenticate:\n\n    username: username used to login to Jut\n    password: password used to login to Jut\n    client_id: client_id generated through the Jut application or using the\n               authorizations API\n    client_secret: client_secret generated through the Jut appliation or using\n                   the authorizations API\n    \"\"\"\n    sess = requests.Session()\n    auth_url = environment.get_auth_url(app_url=app_url)\n\n    if client_id != None:\n        headers = {\n            'content-type': 'application/json'\n        }\n        response = sess.post(auth_url + \"/token\",\n                             headers=headers,\n                             data=json.dumps({\n                                 'grant_type': 'client_credentials',\n                                 'client_id': client_id,\n                                 'client_secret': client_secret\n                             }))\n    else:\n        form = {\n            'username': username,\n            'password': password\n        }\n\n        response = sess.post('%s/local' % auth_url, data=form)\n\n        if response.status_code != 200:\n            raise JutException('Failed /local check %s: %s' %\n                               (response.status_code, response.text))\n\n        response = sess.get(auth_url + '/status')\n        if response.status_code != 200:\n            raise JutException('Failed /status check %s: %s' %\n                               (response.status_code, response.text))\n\n        if not response.json()['authorized']:\n            raise JutException('Failed authentication with (%s,%s), got %s' %\n                               (username, password, response.text))\n\n        response = sess.post(auth_url + '/token',\n                             data={'grant_type': 'client_credentials'})\n\n    if response.status_code != 200:\n        raise JutException('Unable to get auth token %s: %s' %\n                           (response.status_code, response.text))\n\n    return response.json()", "response": "get the access token for a Jut user"}
{"SOURCE": "codesearchnet", "instruction": "Implement a Python 3 function for\ngetting a valid access token", "response": "def get_access_token(self):\n        \"\"\"\n        get a valid access token\n\n        \"\"\"\n        if self.is_access_token_expired():\n\n            if is_debug_enabled():\n                debug('requesting new access_token')\n\n            token = get_access_token(username=self.username,\n                                     password=self.password,\n                                     client_id=self.client_id,\n                                     client_secret=self.client_secret,\n                                     app_url=self.app_url)\n\n            # lets make sure to refresh before we're halfway to expiring\n            self.expires_at = time.time() + token['expires_in']/2\n            self.access_token = token['access_token']\n\n        return self.access_token"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreturn a dictionary of HTML attributes that should be added to the Widget based on this Field.", "response": "def widget_attrs(self, widget):\n        \"\"\"\n        Given a Widget instance (*not* a Widget class), returns a dictionary of\n        any HTML attributes that should be added to the Widget, based on this\n        Field.\n        \"\"\"\n        attrs = {}\n        if getattr(self, \"min_value\", None) is not None:\n            attrs['min'] = self.min_value\n        if getattr(self, \"max_value\", None) is not None:\n            attrs['max'] = self.max_value\n        return attrs"}
{"SOURCE": "codesearchnet", "instruction": "Given the following Python 3 function, write the documentation\ndef find_lines(self, line):\n        for other_line in self.lines:\n            if other_line.match(line):\n                yield other_line", "response": "Find all lines matching a given line."}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef update(self, old_line, new_line, once=False):\n        nb = 0\n        for i, line in enumerate(self.lines):\n            if line.match(old_line):\n                self.lines[i] = new_line\n                nb += 1\n                if once:\n                    return nb\n        return nb", "response": "Replace all lines matching old_line with new_line."}
{"SOURCE": "codesearchnet", "instruction": "Can you tell what is the following Python 3 function doing\ndef update(self, old_line, new_line, once=False):\n        nb = 0\n        for block in self.blocks:\n            nb += block.update(old_line, new_line, once=once)\n            if nb and once:\n                return nb\n        return nb", "response": "Update all lines matching old_line with new_line."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\ndelete all lines matching the given line.", "response": "def remove(self, line):\n        \"\"\"Delete all lines matching the given line.\"\"\"\n        nb = 0\n        for block in self.blocks:\n            nb += block.remove(line)\n\n        return nb"}
{"SOURCE": "codesearchnet", "instruction": "Create a Python 3 function for\nadding a new value for a key.", "response": "def add(self, key, value):\n        \"\"\"Add a new value for a key.\n\n        This differs from __setitem__ in adding a new value instead of updating\n        the list of values, thus avoiding the need to fetch the previous list of\n        values.\n        \"\"\"\n        self.configfile.add(self.name, key, value)"}
{"SOURCE": "codesearchnet", "instruction": "Can you create a Python 3 function that\nretrieves a section by name. Create it on first access.", "response": "def _get_section(self, name, create=True):\n        \"\"\"Retrieve a section by name. Create it on first access.\"\"\"\n        try:\n            return self.sections[name]\n        except KeyError:\n            if not create:\n                raise\n\n            section = Section(name)\n            self.sections[name] = section\n            return section"}
{"SOURCE": "codesearchnet", "instruction": "How would you explain what the following Python 3 function does\ndef get_line(self, section, line):\n        try:\n            section = self._get_section(section, create=False)\n        except KeyError:\n            return []\n        return section.find_lines(line)", "response": "Retrieve all lines compatible with a given line."}
{"SOURCE": "codesearchnet", "instruction": "Write a Python 3 function that can\niterate over all lines in a section. This will skip header lines.", "response": "def iter_lines(self, section):\n        \"\"\"Iterate over all lines in a section.\n\n        This will skip 'header' lines.\n        \"\"\"\n        try:\n            section = self._get_section(section, create=False)\n        except KeyError:\n            return\n\n        for block in section:\n            for line in block:\n                yield line"}
{"SOURCE": "codesearchnet", "instruction": "Can you implement a function in Python 3 that\nmarks entering a block.", "response": "def enter_block(self, name):\n        \"\"\"Mark 'entering a block'.\"\"\"\n        section = self._get_section(name)\n        block = self.current_block = section.new_block()\n        self.blocks.append(block)\n        return block"}
{"SOURCE": "codesearchnet", "instruction": "Can you write a function in Python 3 where it\ninserts a new line into the current block or header.", "response": "def insert_line(self, line):\n        \"\"\"Insert a new line\"\"\"\n        if self.current_block is not None:\n            self.current_block.append(line)\n        else:\n            self.header.append(line)"}
{"SOURCE": "codesearchnet", "instruction": "Implement a function in Python 3 to\nfill from a file - like object.", "response": "def parse(self, fileobj, name_hint='', parser=None):\n        \"\"\"Fill from a file-like object.\"\"\"\n        self.current_block = None  # Reset current block\n        parser = parser or Parser()\n        for line in parser.parse(fileobj, name_hint=name_hint):\n            self.handle_line(line)"}
{"SOURCE": "codesearchnet", "instruction": "How would you code a function in Python 3 to\nreplace all lines matching old_line with new_line.", "response": "def update_line(self, section, old_line, new_line, once=False):\n        \"\"\"Replace all lines matching `old_line` with `new_line`.\n\n        If ``once`` is set to True, remove only the first instance.\n\n        Returns:\n            int: the number of updates performed\n        \"\"\"\n        try:\n            s = self._get_section(section, create=False)\n        except KeyError:\n            return 0\n        return s.update(old_line, new_line, once=once)"}
{"SOURCE": "codesearchnet", "instruction": "Make a summary of the following Python 3 code\ndef remove_line(self, section, line):\n        try:\n            s = self._get_section(section, create=False)\n        except KeyError:\n            # No such section, skip.\n            return 0\n\n        return s.remove(line)", "response": "Remove all instances of a line."}
{"SOURCE": "codesearchnet", "instruction": "Can you generate a brief explanation for the following Python 3 code\ndef items(self, section):\n        for line in self.iter_lines(section):\n            if line.kind == ConfigLine.KIND_DATA:\n                yield line.key, line.value", "response": "Retrieve all key value pairs for a given section."}
